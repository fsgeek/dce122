/********************************************************************/
/*** IBM Corporation                                               ***/
/*** OS/2 LAN Systems Performance                                  ***/
/*** Department 59LS                                               ***/
/*** 11400 Burnet Road                                             ***/
/*** Austin Texas 78759                                            ***/
/*** Bob Russell, ZIP 9151                                         ***/
/*** (512) 838-0454,0844 TL 678-0454,0844                          ***/
/*********************************************************************
 *  Client program for sample DCE distributed application.
 *
 *  Functions:
 *
 *     - Binds to primary application server using DCE binding handle
 *       imported from DCE Cell Directory Services
 *
 *     - Message database function: (surrogate application server #1)
 *           - Store a new message to a HOSTNAME
 *           - Query if there are messages waiting
 *             - Optionally polls ever n seconds
 *           - Retrieve a message
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************/

  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
#ifdef AIX_PROD
  #include <cur00.h>
#else
  #include <curses.h>
#endif



  #include <signal.h>
  #include <ctype.h>
  #include <sys/types.h>
  #include <sys/timeb.h>

#include "rpc.h"
#include "dce_error.h"           /* defs for translation of DCE error codes */
#include "exc_handling.h"                    /* RPC exception handler stuff */
#include "pos_idl.h"                       /* generated by the IDL compiler */

FILE  *fp;                                        /* Generic file pointer */

/* Prototypes */
void  SetCursorPosition(int RR, int CC);           /* Position the cursor */
void  clear_screen(void);                           /* Clears the display */
void  clear_work_area(void);                    /* Clear bottom of screen */
void  show_the_menu(void);
char  FillChar[2]={0x20,0x0F};     /*  Mask for the clear_screen routine. */
double howlong(time_t a,time_t b, unsigned short c,unsigned short d);

void DCE_1(rpc_binding_handle_t *bind_h );  /* Import binding and connect */
void DCE_2(rpc_binding_handle_t *bind_h );                /* Free binding */
void perhaps_an_error( error_status_t st1);          /* DCE Error Checker */

/* These routines contain the RPC calls */
void MessgSend( rpc_binding_handle_t bind_h );
void MessgGet( rpc_binding_handle_t bind_h );
void MessgInq( rpc_binding_handle_t bind_h );


/********************** global variables *********************************/

char                  my_hostname[12];
char                  blank_line[82]=
"                                                                                ";
short                 rebind_flag = 0;
struct timeb          t1, t2;

/********************** defines and constants for application ************/

#define CAT_NAME_LEN 40

int die();
/**************************************************************
 *** MAIN
 **************************************************************/

void main(int argc, char *argv[]);
void main(int argc, char *argv[])
{

   char                  *env_ptr;
   short                 tranID;
   rpc_binding_handle_t  bind_h;
   char                  key_hit;
   double                resp_time;

/*************************************************************************
 * End of Local VAriables
 *************************************************************************
 * Begin doing real stuff
 *************************************************************************/

   /* clear and initialize screen */
   startscr();
   signal(SIGINT,die);

   printf("*******************************************\n");
   printf("*     OS/2 LAN Systems Performance        *\n");
   printf("*           Department 59LS               *\n");
   printf("*             Austin, TX                  *\n");
   printf("*******************************************\n");

   /************************************************
    * Init variables returned by the control program via rpc_CNTRL
    ************************************************/

   /************************************************
    * open & truncate the error file
    ************************************************/
   fp=fopen("client.err","w");

   if (fp==NULL)
   {
     printf("Couldn't open <client.err> error file.\n");
     exit(0);
   }
   else fclose(fp);

   /************************************************
    * Get the TCP/IP hostname from the environment
    ************************************************/
   if (!(env_ptr = getenv("HOSTNAME")))
   {
     printf("Environment variable 'HOSTNAME' is not set.\n");
     fp=fopen("client.err","a");
     fprintf(fp,"Environment variable 'HOSTNAME' is not set.\n");
     fclose(fp);
     exit(0);
   }
   else strcat(my_hostname, env_ptr);   /* HOSTNAME */

   /*****************************************
    * Make the DCE RPC Connection
    * - import binding from CDS
    * - resolve endpoint
    * - see if the server is listening
    * - set the authentication level
    *****************************************/

   DCE_1(&bind_h );

   printf("DCE/RPC Connection is completed.\n");

   /* clear and initialize screen */
   clear_screen();
   SetCursorPosition(2,0);


   /**********************************************************************
    * otherwise...
    */
   clear_screen();
   SetCursorPosition(0,0);
   printf("Terminal connected to DCE Application Server.\n");

   /*********************************************************************/
   do
   {
       /*
        * Display the menu choices
        */
       show_the_menu();
       refresh();

      SetCursorPosition(12,22);
      /*
       * Wait for the next key to be hit
       */
initinput();
      key_hit = getch();
resetit();

      if (key_hit >= '1' && key_hit <= '3')
      {
        ftime(&t1);                     /* Start time for RPC response time */
          /*
           * The next 2 calls will break and remake the binding with a primary
           * server. This is especially useful if more than one primary server
           * is available.
           */
          DCE_2(&bind_h);                      /* Disconnect from Server */
          DCE_1(&bind_h);                    /* Reconnect to Server Stub */
        ftime(&t2);                    /* Stop time for RPC response time */

        resp_time = howlong(t2.time,t1.time,t2.millitm,t1.millitm);
        SetCursorPosition(23,39);
        printw("ReBinding Time %8.2f>\n", resp_time);
	refresh();
      }

      switch(key_hit)
      {
        case '1':
          TRY
          MessgSend(bind_h);
          CATCH_ALL
          printf("The server failed to answer!\n");
          ENDTRY
          break;
        case '2':
          TRY
          MessgGet(bind_h);
          CATCH_ALL
          printf("The server failed to answer!\n");
          ENDTRY
          break;
        case '3':
          TRY
          MessgInq(bind_h);
          CATCH_ALL
          printf("The server failed to answer!\n");
          ENDTRY
          break;
        case 0:
          /* This may be a F3, need to read the extended ASCII code */
          key_hit = getch();
          if (key_hit != 61)
          {
            SetCursorPosition(15,4);
            printw("INVALID RESPONSE <ASCII=0-%d> str<%s> ch<%c>\n", key_hit,key_hit,key_hit);
	    refresh();
          }
          /* otherwise break and do loop will handle the ascii code */
          break;
        case '8':
          SetCursorPosition(14,4);
          printw("Oops! I've murdered the Server\n");
	    refresh();
          TRY
          rpc_KILL(bind_h);      /* Motivates the server to commit suicide */
          CATCH_ALL
          printw("The server failed to answer!\n");
	    refresh();
          ENDTRY
          key_hit = '9';             /* fake out the exit check in do loop */
          /* then fall-thru to exit routine. NO break; */
        case 27:
        case '9':
                /* 9 = Exit
                 * Just BREAK, the do loop will take care of the EXIT
                 */
          break;
        default:
          SetCursorPosition(15,4);
            printw("INVALID RESPONSE <ASCII=0-%d> str<%s> ch<%c>\n", key_hit,key_hit,key_hit);
	    refresh();
      }

      if (key_hit >= '1' && key_hit <= '3')
      {
        resp_time = howlong(t2.time,t1.time,t2.millitm,t1.millitm);
        SetCursorPosition(23,0);
        printw("RPC Response Time %8.2f>\n", resp_time);
	    refresh();
      }
    } while (key_hit != '9' && key_hit != 61);

/**********************************************************************/
/* Bailout: */
/**********************************************************************/

   /* Shutdown the RPC connection */
   SetCursorPosition(14,0);
   printw("I'm shutting down the RPC connection...\n");
	    refresh();
   DCE_2(&bind_h);
   die();
   exit(0);

} /* End of MAIN */
/**************************************************************************/

/***********************************************
 * DCE Error Checking Routine
 ***********************************************/
 void perhaps_an_error( error_status_t st1)
 {
     int           st2=0;
     unsigned char msgstring[160];

     if (st1 != error_status_ok)
     {
         printf("Error: %ld\n", st1);
         fp=fopen("client.err","a");
         fprintf(fp,"Error: %ld\n", st1);
         fclose(fp);

         dce_error_inq_text(st1, (unsigned char *)msgstring, &st2);

         if (st2 == error_status_ok)
         {
             printf("<%s>\n", msgstring);
             fp=fopen("client.err","a");
             fprintf(fp,"<%s>\n", msgstring);
             fclose(fp);
         }
     	 die();
         exit(0);
     }

     return;
 }

/*************************************************************
 * RPC Connect - Lookup application via CDS
 *
 *     DCE APIs      rpc_ns_binding_import_begin
 *                rpc_ns_mgmt_handle_set_exp_age
 *                    rpc_ns_binding_import_next
 *                    rpc_ns_binding_import_done
 *                        rpc_ep_resolve_binding
 *                 rpc_binding_to_string_binding
 *                  rpc_mgmt_is_server_listening
 *                     rpc_binding_set_auth_info
 *************************************************************/
void
DCE_1( rpc_binding_handle_t *bind_h )
{
  /* RPC variables */
   char                         * pszStringBinding;
   unsigned32                     longAuthnProtocol;
   unsigned32                     longAuthzProtocol;
   unsigned char                * pszAuthPrincipal    = "cell_admin";
   long                           longAuthLevel;
   error_status_t                 st;
   rpc_ns_handle_t                import_h;

   char                         * env_ptr;

   /*** Open an import context ***/
   rpc_ns_binding_import_begin (rpc_c_ns_syntax_default,
                                "/.:/Howdy",
                                Howdy_v0_0_c_ifspec,
                                NULL,
                                &import_h,
                                &st);

   perhaps_an_error(st);

   /*** Force the Client to refresh his local cache ***/

   rpc_ns_mgmt_handle_set_exp_age(import_h,
                                  0L,
                                  &st);
   perhaps_an_error(st);

   /*** Import a vector (of up to 5) binding handles.
    *** (If more than 1, one will is randomly selected from the list.
    ***  The entire vector is stored in the local CDS cache. Multiple
    ***  calls can be made to return more than 5 available handles.
    ***  A NO MORE BINDINGS return code (st=382312629) will tell you when
    ***  there are no more available.)
    ***/

   rpc_ns_binding_import_next (import_h,
                               bind_h,
                               &st);
   perhaps_an_error(st);


   /*** Close the import context ***/

   rpc_ns_binding_import_done (&import_h, &st);
   perhaps_an_error(st);


   /*** Resolve the server's endpoint with the RPC endpoint mapper ***/

   rpc_ep_resolve_binding (*bind_h, Howdy_v0_0_c_ifspec, &st);
   perhaps_an_error(st);

   /*** Bind using the handle returned by CDS ***/

   rpc_binding_to_string_binding (*bind_h, &pszStringBinding, &st);
   perhaps_an_error(st);

   SetCursorPosition(22,0);
   printw("RPC Binding=<%s>\n", pszStringBinding);
   refresh();

   /*** Free the binding string, not needed any longer. ***/

   rpc_string_free(&pszStringBinding, &st);
   perhaps_an_error(st);


   /**********************************************************************
    * Make sure the server is listening. If the server was ended by
    * a CNTRL-C, the handle will remain in CDS until it is deleted. So,
    * a bad (st=382312470) return from this call might prompt you to go back
    * up and IMPORT a new handle. "cdscp delete object /.:/Howdy" will
    * clean up the CDS namespace. When the server is killed using
    * the "rpc_KILL" routine (below), he removes himself from CDS.
    **********************************************************************/
   if (! rebind_flag)
   {
     rpc_mgmt_is_server_listening (*bind_h, &st);
     perhaps_an_error(st);
   }
   /**********************************************
    * Authentication Stuff
    **********************************************/

   /*********************************************************************
    * Next we want to set the DCE Authentication level of the binding.
    * I've defaulted him to CALL level, to use another level set
    * the AUTHL in the environment.
    *
    * 0=rpc_c_protect_level_default (0)
    * 1=rpc_c_protect_level_none (1)
    * 2=rpc_c_protect_level_connect (2)
    * 3=rpc_c_protect_level_call (3)            (default)
    * 4=rpc_c_protect_level_pkt (4)
    * 5=rpc_c_protect_level_pkt_integ (5)
    * 6=rpc_c_protect_level_pkt_privacy (6)
    *********************************************************************/

   if ((env_ptr = getenv("AUTHL")))
     longAuthLevel = atol(env_ptr);
   else
     longAuthLevel = 3;           /* call */

   /* Constants:
      rpc_c_authn_none (0)
      rpc_c_authn_dce_secret (1)
      rpc_c_authn_dce_public (2)
      rpc_c_authn_dce_dummy (3)
      rpc_c_authn_dssa_public (4)
      rpc_c_authn_default (-1)
    */
   longAuthnProtocol = 1;           /* secret */

   /* Constants:
      rpc_c_authz_none (0)
      rpc_c_authz_name (1)
      rpc_c_authz_dce (2)
    */
   longAuthzProtocol = 2;            /* DCE */


   /*****************/
   if (longAuthLevel != 0)
   {
     /* Set the RPC authentication parameters for the RPC connection ***/

     rpc_binding_set_auth_info(*bind_h,
                               pszAuthPrincipal,
                               longAuthLevel,    /* rpc_c_protect_level_call */
                               longAuthnProtocol,  /* rpc_c_authn_dce_secret */
                               NULL,
                               longAuthzProtocol,         /* rpc_c_authz_dce */
                               &st );
     perhaps_an_error(st);

   }

   return;

} /* End of Connect with Import Binding */
/****************************************************
 *     End the Connection to the Application Server *
 ****************************************************/
void DCE_2(rpc_binding_handle_t *bind_h )
{
     error_status_t  st;

     rpc_binding_free(bind_h, &st);
     perhaps_an_error(st);

     return;
}
/****************************************************
 *  Message Inquiry
 ****************************************************
 *
 *
 *
 *
 *
 ****************************************************/
void MessgInq( rpc_binding_handle_t bind_h )
{
  MESSG_QUERY_IDL           qmsg_data;
  MESSG_QUERY_IDL          *qmsg_buffer;
  unsigned short            qmessg_buffer_len;
  int                       i;
  /********* end of vars ***************/

  clear_work_area();
  SetCursorPosition(14,0);
  printw("Query number of messages for '%s'  ", my_hostname);
	    refresh();


  qmessg_buffer_len = sizeof(MESSG_QUERY_IDL);/* length of data structure */

  qmsg_data.message_count = 0;                 /* init the message count=0 */
  strcpy(qmsg_data.sender_host,my_hostname);       /* plug in may hostname */


  qmsg_buffer = &qmsg_data;                 /* redundant pointer to struct */

  ftime(&t1);                    /* Start time for RPC response time */

  rpc_QUERY_MSG( bind_h,                              /* Make the RPC call */
                &qmessg_buffer_len,
                 qmsg_buffer );

  ftime(&t2);                    /* Start time for RPC response time */

  SetCursorPosition(16,0);
  printw("You have %ld messages waiting.  ", qmsg_data.message_count);
	    refresh();

  return;

}
/* End MessgInq */
/****************************************************
 *  Message Send
 ****************************************************
 *
 *
 *
 *
 *
 ****************************************************/
void MessgSend( rpc_binding_handle_t bind_h )
{
  MESSG_DATA_IDL            msg_data;
  MESSG_DATA_IDL           *msg_buffer;
  unsigned short            messg_buffer_len;
  double                    resp_time;
  int len,c,i=0;
  char		buf[82];
  /********* end of vars ***************/

  clear_work_area();
  SetCursorPosition(14,0);
  printw("Message Send Routine.  ");
  SetCursorPosition(16,0);
  printw("Type addressee hostname and press Enter :");
	    refresh();

   initinput();

  for ( i=0; i<=81;i++)
  	buf[i] = '\0';

  i=0;
  while((buf[i] = c = getch()) != '\r') i++;
  buf[i] = '\0';
  strcpy(msg_data.addressee_host,buf);
   resetit();


  SetCursorPosition(18,0);
  len=strlen("Type message and press Enter (Maximum 80 characters) :");
  printw("Type message and press Enter (Maximum 80 characters) :");
	    refresh();

   initinput();
  for ( i=0; i<=81;i++)
  	buf[i] = '\0';

  i=0;
  while((buf[i] = c = getch()) != '\r'){
  	if(isspace(c)){
		SetCursorPosition(18, (len+i+1));
  		addch(" ");
		refresh();
	}
   i++;
  }
  buf[i] = '\0';
  strcpy(msg_data.message_text,buf);
   resetit();
	    refresh();

  messg_buffer_len = sizeof(MESSG_DATA_IDL);   /* length of data structure */

  msg_data.message_count = 0;                  /* init the message count=0 */
  msg_data.transaction_type = 1L;                         /* 1=send 2=recv */
  strcpy(msg_data.sender_host,my_hostname);        /* plug in may hostname */


  clear_work_area();
  SetCursorPosition(16,0);
  printw("Sending Message To:%s   From:%s\n\n%s  ",
                         msg_data.addressee_host,
                         msg_data.sender_host,
                         msg_data.message_text);

	    refresh();

  msg_buffer = &msg_data;                   /* redundant pointer to struct */

  ftime(&t1);                    /* Start time for RPC response time */

  rpc_MESSAGE( bind_h,                                /* Make the RPC call */
              &messg_buffer_len,
               msg_buffer );

  ftime(&t2);                    /* Stop time for RPC response time */
  return;
}
/****************************************************
 *  Message Retrieve
 ****************************************************
 *
 *
 *
 *
 *
 ****************************************************/
void MessgGet( rpc_binding_handle_t bind_h )
{
  MESSG_DATA_IDL           msg_data;
  MESSG_DATA_IDL          *msg_buffer;
  unsigned short            messg_buffer_len;
  double                    resp_time;
  /********* end of vars ***************/

  clear_work_area();
  SetCursorPosition(14,0);
  printw("In Message Receive Routine.  ");
	    refresh();

  messg_buffer_len = sizeof(MESSG_DATA_IDL);   /* length of data structure */

  msg_data.message_count = 0;                  /* init the message count=0 */
  msg_data.transaction_type = 2L;                         /* 1=send 2=recv */
  strcpy(msg_data.addressee_host,my_hostname);        /* plug in may hostname */


  msg_buffer = &msg_data;                   /* redundant pointer to struct */

  ftime(&t1);                    /* Start time for RPC response time */

  rpc_MESSAGE( bind_h,                              /* Make the RPC call */
              &messg_buffer_len,
               msg_buffer );

  ftime(&t2);                    /* Stop time for RPC response time */

  SetCursorPosition(16,0);
  printw("You have %ld messages waiting.  ", msg_data.message_count);

  SetCursorPosition(18,0);
  printw("TO: %s   FROM: %s  ",msg_data.addressee_host, msg_data.sender_host);
  SetCursorPosition(20,0);
  printw("%s  ",  msg_data.message_text  );
	    refresh();

  return;
}

/*************************************************************
 * Show the menu
 *************************************************************/
void show_the_menu(void)
{
    SetCursorPosition(1,4);
    printw("My HOSTNAME is %s  ", my_hostname);
    SetCursorPosition(3,4);
    printw("DCE Message - Distributed Demonstration Program  ");
    SetCursorPosition(4,4);
    printw("===============================================  ");
    SetCursorPosition(5,4);
    printw("1  Send a message to the message database  ");
    SetCursorPosition(6,4);
    printw("2  Receive a message from the message database  ");
    SetCursorPosition(7,4);
    printw("3  Query the message database    ");
    SetCursorPosition(9,4);
    printw("8  Kill the Server  ");
    SetCursorPosition(10,4);
    printw("9  Exit  ");
    SetCursorPosition(12,4);
    printw("   Pick a number...  ");

  return;
}
/*************************************************************
 * Clear bottom of screen
 *************************************************************/
void clear_work_area(void)
{
  int i;

  for (i=12;i<22;i++)
  {
    SetCursorPosition(i,0);
    printw("%s", blank_line);
  }
	    refresh();
  return;
}
/*************************************************************
 * Calculate elapsed time
 *************************************************************/
static double howlong(time_t a,time_t b,
                      unsigned short c,unsigned short d)
{
  double e;

  e=(double)(a-b);
  e=e*1000+(c-d);
  e=e/1000;

  return(e);
}
/*************************************************************
 * End of Program
 *************************************************************/


/*************************************************************************/
/*
 * OS/2 Specific call to set cursor position in text mode (RR=0-24, CC=0-79)
    mvcur(LINES/2, COLS/2,RR, CC);
 */
void SetCursorPosition(int RR, int CC)
{
    move(RR, CC); 
    return;
}
/*************************************************************************/
initinput(void)
{
   raw(); 
   echo(); 
   nonl(); 
/*
   raw(); 
   echo(); 
   nonl(); 
*/
   return;
}
resetit(void)
{
   nl(); 
   noecho(); 
   noraw(); 
/*
   noraw(); 
   noecho(); 
   nl(); 
*/
   return;
}
startscr(void)
{
   initscr();
   noecho(); 
   leaveok(stdscr,TRUE);	
   scrollok(stdscr,FALSE);	
   return;
}
die(void)
{
   signal( SIGINT, SIG_IGN);
   endwin();
   exit (0);
}
void clear_screen(void)
{
   wclear(curscr);	
   wrefresh(curscr);	
   return;
}
