/* Generated by IDL compiler version OSF DCE T1.1.0-03 */
#ifdef VMS
#pragma nostandard
#endif
#include <pos_idl.h>
#include <dce/idlddefs.h>

static rpc_syntax_id_t IDL_transfer_syntaxes[1] = {
{
{0x8a885d04, 0x1ceb, 0x11c9, 0x9f, 0xe8, {0x8, 0x0, 0x2b, 0x10, 0x48, 0x60}},
2}};

static rpc_if_rep_t IDL_ifspec = {
  1, /* ifspec rep version */
  3, /* op count */
  0, /* if version */
  {0x334a2e24, 0x0000, 0x0000, 0x0d, 0x00, {0x55, 0x51, 0x21, 0x20, 0x0, 0x0}},
  2, /* stub/rt if version */
  {0, NULL}, /* endpoint vector */
  {1, IDL_transfer_syntaxes} /* syntax vector */
};
/* global */ rpc_if_handle_t Howdy_v0_0_c_ifspec = (rpc_if_handle_t)&IDL_ifspec;
static idl_ulong_int IDL_offset_vec[] = {
0,
sizeof(MESSG_DATA_IDL ),
offsetof(MESSG_DATA_IDL , sender_host),
offsetof(MESSG_DATA_IDL , addressee_host),
offsetof(MESSG_DATA_IDL , message_text),
offsetof(MESSG_DATA_IDL , message_count),
offsetof(MESSG_DATA_IDL , transaction_type),
sizeof(MESSG_QUERY_IDL ),
offsetof(MESSG_QUERY_IDL , sender_host),
offsetof(MESSG_QUERY_IDL , message_count),
0
};

static void (*IDL_rtn_vec[])() = {
(void (*)())NULL,
(void (*)())NULL
};

static idl_byte IDL_type_vec[] = {
0xff,0xff,0xff,0xff,
1,
0,
0xff,0xff,
0x03,0x00,
0x01,0x00,
0x00,0x00,
0x00,0x00,
0x24,0x2e,0x4a,0x33,
0x00,0x00,
0x00,0x00,
0x0d,
0x00,
0x55,0x51,0x21,0x20,0x00,0x00,
0x00,0x00,0x00,0x00,
0x04,0x00,0x00,0x00,
0x68,0x01,0x00,0x00,
0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,
0x03,0x00,0x00,0x00,
0x02,0x00,0x00,0x00,
0x04,0x00,0x00,0x00,
0x02,0x00,0x00,0x00,
0x88,0x00,0x00,0x00,
0x02,0x00,0x00,0x00,
0x88,0x00,0x00,0x00,
0x02,0x00,0x00,0x00,
0x04,0x00,0x00,0x00,
0x02,0x00,0x00,0x00,
0xa0,0x00,0x00,0x00,
0x02,0x00,0x00,0x00,
0xa0,0x00,0x00,0x00,
0x02,0x00,0x00,0x00,
0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,
0x02,0x00,0x00,0x00,
IDL_DT_PASSED_BY_REF,
IDL_DT_USHORT,
IDL_DT_EOL,
0xff,
0x03,0x00,0x00,0x00,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_CHAR|IDL_PROP_DEP_INT,
0xff,
0xb8,0x00,0x00,0x00,
IDL_DT_EOL,
0xff,0xff,0xff,
0x02,0x00,0x00,0x00,
IDL_DT_PASSED_BY_REF,
IDL_DT_USHORT,
IDL_DT_EOL,
0xff,
0x03,0x00,0x00,0x00,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_CHAR|IDL_PROP_DEP_INT,
0xff,
0xcc,0x00,0x00,0x00,
IDL_DT_EOL,
0xff,0xff,0xff,
0x07,0x00,0x00,0x00,
IDL_DT_NDR_ALIGN_4,
IDL_DT_STRING,
IDL_DT_VARYING_ARRAY,
0|IDL_PROP_DEP_CHAR,
0x4b,0x01,0x00,0x00,
0x4b,0x01,0x00,0x00,
IDL_DT_LONG,
IDL_DT_EOL,
0xff,0xff,
0x01,0x00,0x00,0x00,
IDL_DT_NDR_ALIGN_4,
IDL_DT_STRING,
IDL_DT_VARYING_ARRAY,
0|IDL_PROP_DEP_CHAR,
0x2f,0x01,0x00,0x00,
0x2f,0x01,0x00,0x00,
IDL_DT_STRING,
IDL_DT_VARYING_ARRAY,
0|IDL_PROP_DEP_CHAR,
0xff,
0x13,0x01,0x00,0x00,
0x13,0x01,0x00,0x00,
IDL_DT_STRING,
IDL_DT_VARYING_ARRAY,
0|IDL_PROP_DEP_CHAR,
0xff,
0xf7,0x00,0x00,0x00,
0xf7,0x00,0x00,0x00,
IDL_DT_LONG,
IDL_DT_LONG,
IDL_DT_EOL,
1,
0x00,0x00,0x00,0x00,
0x4f,0x00,0x00,0x00,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_STRING,
1,
0xff,0xff,
0xff,0xff,0xff,0xff,
IDL_DT_CHAR,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x0b,0x00,0x00,0x00,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_STRING,
1,
0xff,0xff,
0xff,0xff,0xff,0xff,
IDL_DT_CHAR,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x0b,0x00,0x00,0x00,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_STRING,
1,
0xff,0xff,
0xff,0xff,0xff,0xff,
IDL_DT_CHAR,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x0b,0x00,0x00,0x00,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_STRING,
1,
0xff,0xff,
0xff,0xff,0xff,0xff,
IDL_DT_CHAR,
0xff,0xff,0xff,
0x00,0x00,0x00,0x10,
0
};


void rpc_QUERY_MSG
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t hBinding,
    /* [in, out] */ idl_ushort_int *qmsg_buf_len,
    /* [in, out] */ MESSG_QUERY_IDL *qmsg_buf
)
#else
(hBinding, qmsg_buf_len, qmsg_buf)
#endif

#ifndef IDL_PROTOTYPES
    handle_t hBinding;
    idl_ushort_int *qmsg_buf_len;
    MESSG_QUERY_IDL *qmsg_buf;
#endif
{
rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[4];

RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[1] = (rpc_void_p_t)&hBinding;
IDL_param_vec[2] = (rpc_void_p_t)qmsg_buf_len;
IDL_param_vec[3] = (rpc_void_p_t)qmsg_buf;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) hBinding, 0|rpc_c_call_idempotent,
 (rpc_if_handle_t)&IDL_ifspec,0,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    2,
    136,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    2,
    136,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2((rpc_call_handle_t *)&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,IDL_user_fault_id,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, NULL, NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
}

void rpc_MESSAGE
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t hBinding,
    /* [in, out] */ idl_ushort_int *msg_buf_len,
    /* [in, out] */ MESSG_DATA_IDL *msg_buf
)
#else
(hBinding, msg_buf_len, msg_buf)
#endif

#ifndef IDL_PROTOTYPES
    handle_t hBinding;
    idl_ushort_int *msg_buf_len;
    MESSG_DATA_IDL *msg_buf;
#endif
{
rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[4];

RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[1] = (rpc_void_p_t)&hBinding;
IDL_param_vec[2] = (rpc_void_p_t)msg_buf_len;
IDL_param_vec[3] = (rpc_void_p_t)msg_buf;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) hBinding, 0|rpc_c_call_idempotent,
 (rpc_if_handle_t)&IDL_ifspec,1,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    2,
    160,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    2,
    160,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2((rpc_call_handle_t *)&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,IDL_user_fault_id,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, NULL, NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
}

void rpc_KILL
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t hBinding
)
#else
(hBinding)
#endif

#ifndef IDL_PROTOTYPES
    handle_t hBinding;
#endif
{
rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[2];

RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[1] = (rpc_void_p_t)&hBinding;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) hBinding, 0|rpc_c_call_idempotent,
 (rpc_if_handle_t)&IDL_ifspec,2,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    0,
    0,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    0,
    0,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2((rpc_call_handle_t *)&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,IDL_user_fault_id,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, NULL, NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
}
#ifdef VMS
#pragma standard
#endif
