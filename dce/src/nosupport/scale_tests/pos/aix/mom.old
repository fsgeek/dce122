/** MOM.C ************************************************************/
/*** IBM Corporation                                               ***/
/*** OS/2 LAN Systems Performance                                  ***/
/*** Department 59LS                                               ***/
/*** 11400 Burnet Road                                             ***/
/*** Austin Texas 78759                                            ***/
/*** Bob Russell, ZIP 9151                                         ***/
/*** (512) 838-0454,0844 TL 678-0454,0844                          ***/
/*********************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <cur00.h>
#include <signal.h>


#include <sys/timeb.h>
#include <sys/ioctl.h>
#include <sys/types.h>

#include <fcntl.h>
#include <time.h>

#include "rpc.h"
#include "dce_error.h"
#include "mom.h"
#ifdef PROCNUM
#include "proc_idl.h"
#else
#include "pos_idl.h"
#endif

   int die();
   time_t	    CURTIME;	
/* seeds for the random number generator, unique prime numbers */
short prime_nums[]={3 ,79 ,181 ,293 ,73 ,
                    13 ,101 ,199 ,317 ,29 ,
                    113 ,229 ,349 ,43 ,139 ,
                    251 ,373 ,61 ,163 ,271 ,
                    397 ,277 ,5 ,401 ,83 ,
                    191 ,17 ,307 ,103 ,211 ,
                    31 ,331 ,127 ,233 ,47 ,
                    353 ,149 ,257 ,67 ,379 ,
                    167 ,383 ,173 ,7 ,193 ,
                    409 ,89 ,19 ,223 ,107 ,
                    311 ,37 ,239 ,337 ,131 ,
                    53 ,263 ,359 ,151 ,71 ,
                    281 ,157 ,283 ,419 ,11 ,
                    179 ,197 ,313 ,23 ,97 ,
                    227 ,347 ,41 ,109 ,241 ,
                    367 ,59 ,137 ,269 ,389 };

/*
 * Calculation of elapsed time between 2 ftime() values
 */
double howlong(time_t a,time_t b,
               unsigned short c,unsigned short d,
               int * elapsed_sec);

char back_s[2] = "/"; /* This is really a slash on AIX */

/* RPC File Transfer Buffers */
ndr_byte namebuf[NAMEMAX];            /* Name of perf data file     */
ndr_byte buffer[SENDMAX];             /* Contents of perf data file */

/*
 * Error handling routine:
 * - Check for non-zero return
 * - If error: Print to display
 *             Print to error file
 *             Close error file
 *             Exit program
 */
void perhaps_an_error( error_status_t st1,
                       FILE *fptr,
                       double resp_time,
                       unsigned char err_msg[40]);

#include <rpcexc.h>

EXCEPTION input_status;
/*

unsigned char comment[80];

//error_status_t error_stat, input_status;

//#define RESUME 0
//#define ABORT 1
//#define CHECK_STATUS(input_status, comment, action) \
//{ \
//  dce_error_inq_text(input_status, error_string, &error_stat); \
//  fprintf(stderr, "%s %s\n", comment, error_string); \
//  if (action == ABORT) exit(1); \
//};
*/



#define THE_USER "cell_admin"
#define THE_PASSWORD "-dce-"

/*
 * Structure for API performance data
 */
typedef
struct _perf_info
{
  double api_resp_time;
  char   api_call[40];
} PERF_INFO;

PERF_INFO        perf_array[20];              /* Name and Time of APIs   */
int              perf_array_ptr=0;            /* index to perf_array[]   */
/* unsigned short reqnum; */
int Numbytes;

/**************************************************************
 *** MAIN
void main(int argc, char *argv[]);
 **************************************************************/
   struct timeb     t2;
   struct timeb     t5;

void main(int argc, char *argv[])
{
   int              i, j;

   FILE             *fp2, *fp;                   /* Error and Data file hdl */
   int              NoPrint;
   char             error_file_name[NAMEMAX];
   unsigned char    data_file_name[NAMEMAX];
   unsigned char    out_name[80];

   int f_len;                                    /* Used in file transfer   */
   int in_file;                                  /* Used in file transfer   */
   int numread;                                  /* Used in file transfer   */

   short            histogram[208];              /* Response time histogram */
   long             avg_think=0;                 /* Sum of Think Times      */
   double           avg_serv_time=0.0;           /* Sum of Appl times retd  */
   long             appl_time=0L;                /* Format retd from RPC    */
   double           avg_req_time=0.0;            /* Sum of RPC times        */
   double           max_req_time=0.0;            /* Worst RPC time          */
   double           req_time=0.0, srv_time, api_time=0.0;
   int              tenths=0;

   double           curr_time;
   short            start_flag;                  /* Used to time the run    */
   double           start_at,stop_at;            /* Begin/End data window   */
   double           in_between=0.0;              /* Iterations in window    */
   long             tx_cnt=0L;                   /* Iterations in whole run */
   double           elapse;                      /* temp variable           */
   unsigned long    interval = 0;                /* Think Time Parmater     */
   long             think_time;                  /* Adjusted think time     */
   double           duration = 0.0,pace_time=0.0;  /* Used for run duration */
   long             resp_time=0L;                /* RPC out parm            */

   struct timeb     t1;
   /* struct timeb     t2; */
   struct timeb     t3;
   struct timeb     t4;
   /* struct timeb     t5; */
   struct timeb     d1, d2;

   unsigned char    *pospath;

   short num_send;
   short num_sent;
   short num_recv = 1;
   unsigned int     seed;                        /* Local Random Gen seed   */
   int              tranID, TID;                 /* transaction type to run
                                                  * 1=CMR Customer Master Rec
                                                  * 2=SAVe transaction
                                                  * 3=SHQ Sale Hist Query
                                                  * 4=PTQ Price Tbl Query
                                                  * 5=CATalog
                                                  * 9=Kill the Server
                                                  *10=Mixed Workload
                                                  */

   char          * env_ptr;

   rpc_binding_handle_t  bind_h;

   SAVE_DATA    save_data;

   EXCEPTION_INIT (input_status);


/*************************************************************************
 * End of Local VAriables
 *************************************************************************/

   if (argc < 5)
   {
      printf("Number of parms incorrect %d \n\n", argc);
      printf("USAGE:MOM  ReqID  TPH  duration  type [port# [ip_addr]]\n");
      printf("               ReqID  1,2,3,...,n inclusively         \n");
      printf("            duration  in whole minutes                \n");
      printf("                type  1 = CMR Phone Number Lookup     \n");
      printf("                      2 = SAV Sales Slip Processing   \n");
      printf("                      3 = RPC Data Transfer/Exchange  \n");
      printf("                      4 = PTQ Price Inquiry           \n");
      printf("                      5 = CAT Bit Image Transfer      \n");
      printf("                      9 = KILL The Server             \n");
      printf("                     10 = Mixed                       \n");
      printf("                port# Bypass IMPORT and use port#     \n");
      printf("                addr  IP Address of Server            \n");
      exit(0);
   }

   /* clear and initialize screen */
   startscr();
   signal( SIGINT, die );
   time(&CURTIME);
   strftime(save_data.trans_no.trans_date,9, "%D",localtime(&CURTIME));
   strftime(save_data.trans_no.trans_time,9, "%T",localtime(&CURTIME));

   /**** Read RunTime Parms *****************************/
   /* reqnum = atol(argv[1]);       */
   save_data.trans_no.reg_no = atol(argv[1]);       /* register number */
   interval        = 3600000L / (atol(argv[2]));    /* transactions per hour */
   duration        = atof(argv[3]) * 60.0;          /* run duration in seconds */
   tranID          = atoi(argv[4]);                 /* transaction type */
   TID             = tranID;

#ifdef DEBUGIT
fprintf(stderr,"interval=<%ld>\n",interval);
fprintf(stderr,"duration=<%ld>\n",duration);
fprintf(stderr,"tranID=<%d>\n",tranID);
fprintf(stderr,"TID=<%d>\n",TID);
#endif

   seed = prime_nums[(short)save_data.trans_no.reg_no-1];  /* randum seed */
   sprintf(save_data.trans_no.dept_no,"%.3d\0",seed);      /* Department Number ! */

   start_at = (duration / 6.0);    /* beginning of collection window */
   stop_at  = (duration / 1.1);    /* end of collection window */

   (void)sprintf(error_file_name,"OUT%ld.ERR\0",save_data.trans_no.reg_no);
   sprintf(data_file_name,"OUT%ld.DAT\0",save_data.trans_no.reg_no);

   /* copy root path  name */
   if (!(pospath = getenv("POSDIR")))
   {
      strcpy(out_name, pospath);
      strcat(out_name, back_s);
      strcat(out_name, data_file_name);
   }
   else
     strcpy(out_name, data_file_name);


   for (i=0;i<20;i++)
   {
     perf_array[i].api_resp_time = 0.0;
     strcpy(perf_array[i].api_call,data_file_name);
   }

  /* open the error file */
   fp=fopen(error_file_name,"w");
   if (fp==NULL)
   {
    printf("Couldn't open <%s> error file.\n", error_file_name);
    exit(1);
   }

   /********************************************************
    * Set flag to either (1) Full display of application activity, OR
    * (2) Supress printing to force maximum throughput.
    ********************************************************/

   if ((env_ptr = getenv("NOPRINT")))
     NoPrint = atoi(env_ptr);
   else
     NoPrint = 0;           /* print the results */

   printf("*******************************************\n");
   printf("*          IBM Confidential               *\n");
   printf("*     OS/2 LAN Systems Performance        *\n");
   printf("*           Department 59LS               *\n");
   printf("*             Austin, TX                  *\n");
   printf("*******************************************\n");
   sleep(1);

/* setvbuf(stdout, NULL, _IONBF, 0);     work around an OS/2 bug */

clear_screen();


  /************************************************************************
   * DCE LOGIN
   ************************************************************************/

   Login( fp );

  /************************************************************************
   * Make RPC Connection
   ************************************************************************/
   /* alternate connection method - known port/address */
   if (argc > 5)
   {
     DCE_1(argv[5],                 /* end point */
           argv[6],                 /* network address */
           fp,
           &bind_h
           );
   }
   else
   {
     DCE_2(fp,
           &bind_h
           );
   }
   /***********************************************************************/
   printf("DCE/RPC Connection is completed.\n");
   sleep(2);
   /**********************************************************************/
   if (tranID == 9)
   {
       /*
        * Now that we know where the server is, perhaps our mission
        * is to murder the sucker?
        */

       SetCursorPosition(23,0);
       printw("Shooting the Server                                      \n");
       refresh();

       /*
        * suicide is in the RPC IDL
        */
       suicide(bind_h);
       goto NoReport;
   }
   /**********************************************************************/

   clear_screen();
   paint_screen(save_data.trans_no.reg_no);

   SetCursorPosition(22,0);
   printw("Cash Register <%ld> on line.   ", save_data.trans_no.reg_no);
       refresh();

   /**** Initialize some stuff **********************/

   InitRan1(0, seed);                                 /* Seed the Random Gen */

   for (i=0;i<204;i++)
   {
     histogram[i] = 0;                                   /* init array       */
     tx_cnt = get_random(1000000L);                      /* warm it up,
                                                          * takes a couple
                                                          * reps to generate
                                                          * the full range
                                                          * when seeded with
                                                          * teeny seeds.
                                                          */
   }

   if ((env_ptr = getenv("POSPACKET")))
   {
     num_send = atoi(env_ptr);
   }
   else
     num_send = 1;

   if (num_send == 100)
     num_recv = 100;
   else
     num_recv = 1;

   SetCursorPosition(14,20);
   printw("Send bytes ......... %d (9999=Random 4K +/- 4K)",num_send);
   SetCursorPosition(15,20);
   printw("Receive bytes ...... %d",num_recv);
   refresh();
   /*********************************************************************
    * Notify the server RPC I'm ready and wait for signal
    * This is an RPC IDL call:
    *    1. Decrements the server's expected count file (P_COUNT)
    *       set by the POSSTART program.
    *    2. Then waits on a semaphore until all clients are
    *       are connected,
    *    3. When all clients are connected, the semaphore is
    *       cleared, thus releasing all to start simultaneously.
    *********************************************************************/
 TRY


   /*svrsyn(bind_h, reqnum);*/
   svrsyn(bind_h );

/*   CHECK_STATUS(input_status, "SvrSyn:",ABORT); */


CATCH (input_status)
/* CATCH(rpc_x_ss_pipe_comm_error) */
 {
   printf("SvrSyn: Communication Error:\n");
   exit(1);


 }
/* FINALLY
// {
//   printf("SvrSyn: Communication Error Finally:\n");
//   exit(1);


// } */
 ENDTRY

   SetCursorPosition(23,0);
   printw("Processing has begun ....                                       \n");
   refresh();
   /*********************************************************************/


   tx_cnt = 0L;
   in_between = 0.0;
   start_flag=0;
   save_data.trans_header.line_item_cnt = 0L;
   num_sent = num_send;

   /* Start doing real work *********************************/
   ftime(&t5);            /* t5 get a timestamp so i know when to quit */
   curr_time = 0.0;

   while(curr_time < duration)
   {
#ifdef DEBUGIT
fprintf(stderr,"TOP OF WHILE: curr_time=<%f> duration=<%f>\n",curr_time,duration);
#endif
       if (start_flag == 0 && curr_time >= start_at)
       {
                                   /** time to open the collection window **/
         start_flag = 1;
         SetCursorPosition(23,0);
         printw("Beginning Data Collection.                                \n");
      	 refresh();
         ftime(&t3);
       }

       /*
        * If we are running the mixed case, we need to change the
        * tranID in order to achieve the desired mix.
        */
       if (TID == 10)
       {
         switch(tranID)
         {
           case 10:
           {
             tranID = 1;               /* first iteration, do CAT first  */
             save_data.trans_header.line_item_cnt = get_random(4L); /* avg 2.5 item per invoice */
             save_data.trans_header.item_cnt = 0;
             break;
           }
           case 1:
           {
             tranID = 5;   /* next do a CMR */
             break;
           }
           case 5:
           {
             tranID = 4;   /* next do a Line Item PTQ */
             save_data.trans_header.line_item_cnt = get_random(4L); /* avg 2.5 item per invoice */
             save_data.trans_header.item_cnt = 0;
             break;
           }
           case 4:
           {
             if (++save_data.trans_header.item_cnt
                                     == save_data.trans_header.line_item_cnt)
             {
               tranID = 2;                     /* do SAV next  */
             }
             break;
           }
           case 2:
           {
             tranID = 1;   /* start over - do CAT next */
             for (i=0;i<=save_data.trans_header.line_item_cnt;i++)
             {
               SetCursorPosition(12+i,3);
               printw (
 "                                                                            \n"
                      );
             }
             break;
           }
         }
       }

       /* EXECUTE THE RPC PROCEDURE */
       switch(tranID)
       {
         case 1:             /* Phone Lookup */
           CustInq(&appl_time, 
		NoPrint, 
		&d1, 
		&d2, 
		&save_data, 
#ifdef PROCNUM
			procnum,
#endif
		bind_h);
           break;
         case 2:             /* Sales Check Processing */
           History(&appl_time, 
#ifdef PROCNUM
			procnum,
#endif
			NoPrint, 
			&d1, 
			&d2, 
			&save_data, 
			bind_h);
           break;
         case 3:             /* Data Transfer Only */
           if (num_send == 9999)
           {
              num_sent = (short)get_random(8192L);
              SetCursorPosition(14,41);
              printw("%4d",num_sent);
		refresh();
           }
           DataXfer(num_sent,
                    num_recv,
                    &d1,
                    &d2,
#ifdef PROCNUM
		     procnum,
#endif
                    bind_h);
           break;
         case 4:             /* Price Table Query */
           PriceInq(&appl_time, 
		NoPrint, 
		&d1, 
		&d2, 
		&save_data, 
#ifdef PROCNUM
			procnum,
#endif
		bind_h);
           break;
         case 5:             /* Catalog Page Transfer */
           Catalog (&appl_time, 
		NoPrint, 
		&d1, 
		&d2 ,
#ifdef PROCNUM
			procnum,
#endif
		 bind_h);
           break;
         default:
           SetCursorPosition(23,0);
           printw("Invalid transaction type <%d> !         ",tranID);
	   refresh();
           goto Bailout;

       }


       /*
        * What time is it now ?
        */
       ftime(&t2); /* t2 */
       /*curr_time =((t2.time * 1000L + t2.millitm) -
                  (t5.time * 1000L + t5.millitm)) * 0.001; */
       curr_time =howlong(t2.time,t5.time,t2.millitm,t5.millitm,&tenths); 
#ifdef DEBUGIT
fprintf(stderr,"After howlong curr_time=<%f> t2.time=<%g> t5.time=<%g> \n",curr_time, t2.time,t5.time);
#endif

       /*
        * Now, introduce the think time
        */
       if (interval > 0)
       {
                                               /* think time was specified */
         think_time = exp_ran(interval);       /* Get an exponentially
                                                * distributed random value
                                                */
         pace_time+=(float)think_time * 0.001; /* pace_time is a running
                                                * sum of unadjusted think
                                                * times. This is where
                                                * I should be in order to
                                                * make the next request.
                                                */
         if (curr_time < pace_time)
         {
           /*
            * Now, am I ahead or behind the specified arrival rate?
            * I'll adjust the actual think time as needed.
            * If curr_time >= pace time, then don't wait because
            * I'm running behind.
            */
           think_time = (long)((pace_time - curr_time) * 1000.0);
           sleep(think_time);
         }
         else
           think_time = 0L;
       }

       /*
        * This is the RPC response time measured at the client.
        */
       req_time =howlong(d2.time,d1.time,d2.millitm,d1.millitm,&tenths);

       if (! NoPrint)
       {
         /*
          * Rather than calculate the TAX and Sales Amount, lets display
          * the Response times in those fields
          */
         SetCursorPosition(18,60);
         printw("%8ld  %8.3f", tx_cnt+1, req_time);

         /*
          * This is the Application resp time returned from the server stub
          */
         srv_time = (double)appl_time * 0.001;
         SetCursorPosition(20,70);
         printw("%8.3f", srv_time);
	   refresh();
       }

       /** post processing **/
       if (start_flag == 1)
       {
         /* We are in the data collection window? **/
         if (curr_time <= stop_at)
         {
           if (tenths < 200)
               ++histogram[tenths + 1];          /* times 0.1-19.9 seconds */
           else
               ++histogram[201];                 /* times >= 20.0 seconds  */

           avg_serv_time += srv_time;            /** sum appl times **/
           avg_req_time += req_time;             /** sum RPC times **/

           if (req_time > max_req_time) max_req_time = req_time; /* worst  */

           avg_think += think_time;             /** sum actual think mSec **/

           in_between++;                 /** count transactions in window **/

          /*
           * Rather than calculate the TAX and Sales Amount, lets display
           * the Response times in those fields
           */

           if (! NoPrint)
           {
             SetCursorPosition(19,70);
             printw("%8.3f", avg_req_time/(float)in_between);
             SetCursorPosition(21,70);
             printw("%8.3f", avg_serv_time/(float)in_between);
	 	refresh();
           }
         }

         /* And, perhaps we are done **/
         if (curr_time >= stop_at)
         {
           ftime(&t4);                                     /* end of window */
           SetCursorPosition(23,0);
           printw("Finished Data Collection.                               ");
	 	refresh();
           start_flag=2;
         }
       }

       /** count all transactions **/
       tx_cnt++;

       /*
        * Bail Out of program sorta gracefully.
       if (kbhit()) break;
        */
       ioctl(0,FIONREAD,&Numbytes);  
       if(Numbytes >= 1) break;

#ifdef DEBUGIT
fprintf(stderr,"BOTTOM OF WHILE: in_between=<%f>\n",in_between);
fprintf(stderr,"bottom	   curr_time=<%f>  stop_at=<%f>\n",curr_time,stop_at);
#endif
   } /* end for duration loop */

Bailout:

if (in_between == 0.0) goto NoReport;         /* We pulled out prematurely */

/******************************************/
/*** Write the DATA file ***/
fp2=fopen(out_name,"w");

if (fp2==NULL)
{
 printf("Can't open <%s> data file.\n",data_file_name);
 goto NoReport;
}
fprintf(fp2,"<%8s> <%8s>         0\n",save_data.trans_no.trans_date,
                                      save_data.trans_no.trans_time);

/***************************************
 * Warning, the data reduction program (CALCPOS.C)
 * is line and column sensitive, don't twiddle with
 * rows count or column format of the following
 * fprintf's.
 ***************************************/

/* window size */
elapse   = howlong(t4.time,t3.time,t4.millitm,t3.millitm,&tenths);

fprintf(fp2,"MOMnPOP Transaction ID %8d\n", TID);
fprintf(fp2,"Cash Register Number   %8ld\n", save_data.trans_no.reg_no);
fprintf(fp2,"Transactions in Window %8ld\n", (long)in_between);
fprintf(fp2,"Avg Elapsed Time       %8.3f\n", elapse/(float)in_between);
fprintf(fp2,"Avg Remote Proc Time   %8.3f\n",
         avg_req_time/(float)in_between);
fprintf(fp2,"Avg Response Time      %8.3f\n",
         avg_serv_time/(float)in_between);
fprintf(fp2,"Maximum Response Time  %8.3f\n", max_req_time);
fprintf(fp2,"Think time parm        %8ld\n", interval);
fprintf(fp2,"Average Think Time     %8.3f\n",
         ((float)avg_think*0.001)/(float)in_between);
if (elapse > 0.0)
  fprintf(fp2,"TPS Rate (Local)       %8.3f\n", in_between/elapse);
else /* don't divide by zero */
  fprintf(fp2,"TPS Rate               %8.3f\n",0.0);
fprintf(fp2,"Total Iterations     = %8ld\n", tx_cnt);
if (num_send == 9999)
  fprintf(fp2,"Data Packet          = %8d\n",4192);
else
  fprintf(fp2,"Data Packet          = %8d\n",num_send);

/*
 * Write out the histogram table
 */
for (j=1;j<201;j++)
{
  fprintf(fp2,"Under %4.1f seconds.    %8d\n",
                (float)j / 10.0, histogram[j]);
}
fprintf(fp2,"Times over 20 sec      %8d\n",
                histogram[201]);

/*
 * Write the API data collected
 */
for (i=0;i<20 && i<perf_array_ptr;i++)
{
  fprintf(fp2,"%40s %8.3f\n",
         perf_array[i].api_call,
         perf_array[i].api_resp_time);
}

fprintf(fp2,"End of file.                            \n");
fprintf(fp,"<%8s> <%8s>         0\n", save_data.trans_no.trans_date,
                                      save_data.trans_no.trans_time);

/*
fprintf(fp2,"*******************************************\n");
fprintf(fp2,"*      OS/2 LAN Systems  Performance      *\n");
fprintf(fp2,"*           Department 59LS               *\n");
fprintf(fp2,"*             Austin, TX                  *\n");
fprintf(fp2,"*******************************************\n");
*/

fclose(fp2);

/****** Transfer DATA FILE to the SERVER ******/

   if ((in_file = open(out_name, O_RDONLY)) == -1)
   {
       SetCursorPosition(18, 0);
       printf("Couldn't open data file <%s>\n", data_file_name);
   }
   else
   {


       if ((numread = read(in_file, buffer, SENDMAX)) > 0)
       {
           buffer[numread] = '\0';

           f_len = strlen(data_file_name);
           data_file_name[f_len] = '\0';


           ftime(&t1);
           /*
            * This is an RPC IDL guy
            */
           file_tran(bind_h,
                     f_len,
                     NAMEMAX,
                     data_file_name,
                     numread,
                     SENDMAX,
#ifdef PROCNUM
		     procnum,
#endif
                     buffer);
           ftime(&t2);
           api_time =howlong(t2.time,t1.time,t2.millitm,t1.millitm,&tenths);

           SetCursorPosition(17, 0);
           printw("Bytes transfered <%d> Time <%8.2f>\n", numread, api_time);
  	   refresh();
           fprintf(fp,
           "RPC data_file_transfer <%8d> bytes       %8.2f\n",
                       numread, api_time);
           fprintf(fp,
           "RPC data_file_transfer millisec/byte            %8.4f\n",
                       (api_time/(float)numread)*1000.0);

       }

       close(in_file);
   }


NoReport:

/* Shutdown the RPC connection */
DCE_3(&bind_h);

SetCursorPosition(23,0);
fprintf(stderr,"End of MAIN\n");


fclose(fp);
die();

} /* End of MAIN */

/**************************************************************************/

/***********************************************
 * Error Routine
 ***********************************************/
 void perhaps_an_error( error_status_t st1,
                        FILE *fptr,
                        double resp_time,
                        unsigned char err_msg[40])
 {
     int           st2=0;
     unsigned char msgstring[160];

     if (st1 != error_status_ok)
     {
         printf("Error: %s Status = %ld\n", err_msg, st1);
         fprintf(fptr,"Error: %s Status = %ld\n", err_msg, st1);

         dce_error_inq_text(st1, (unsigned char *)msgstring, &st2);

         if (st2 == error_status_ok)
         {
             printf("<%s> (rc=%d)\n", msgstring, st2);
             fprintf(fptr,"<%s>\n (rc=%d)\n", msgstring, st2);
         }

         fclose(fptr);
         exit(1);
     }

     fprintf(fptr,"API %40s  %8.2f\n",err_msg, resp_time);
     printf("API %40s  %8.2f\n", err_msg, resp_time);


     return;
 }

/******** HOW LONG **********/
static double howlong(time_t a,time_t b,
                      unsigned short c,unsigned short d,
                      int * elapsed_sec)
{
  double e;

  e =((a * 1000L + c) - (b * 1000L + d)) * 0.001;
/*
  e=(double)(a-b);
  e=e*1000+(c-d);
  e=e/1000;
*/

  *elapsed_sec = (short)((e + 0.029) * 10.0); /* rounded up */
  return(e);
}
/**************************************************************************/
void paint_screen(long reg_no)
{
 char     Date[9], Time[9];

 time(&CURTIME);
   strftime(Date,9, "%D",localtime(&CURTIME));
   strftime(Time,9, "%T",localtime(&CURTIME));
 SetCursorPosition(0,0);
 printw("%s",Date);
 SetCursorPosition(0,70);
 printw("%s",Time);
 SetCursorPosition(0,22);
 printw("DCE Application Benchmark");

 SetCursorPosition(1,20);
 printw("Russell's Nickel & Dime Store");
/*0....:....1....:....2....:....3....:....4....:....5....:....6....:....7....:....8 */
 SetCursorPosition(2,0);
 printw(
 "Acct:___________ CrCard ________________________ TransType ____ Aproval ________");
 SetCursorPosition(3,0);
 printw(
 "Name:________________________________________________ ________________________ _");
 SetCursorPosition(4,0);
 printw(
 "Ship Adr:_______________________________________________________________________");
 SetCursorPosition(5,0);
 printw(
 "Mail Adr:_______________________________________________________________________");
 SetCursorPosition(6,0);
 printw(
 "City:________________________________________________ State __  ZIP _____ - ____");
 SetCursorPosition(7,0);
 printw(
 "Area (___) Ph _______ Extn _______  Drv Lic:________________________ DrvState __");
 SetCursorPosition(8,0);
 printw(
 "Cus Ref:________________________________________________________________________");
 SetCursorPosition(9,0);
 printw("Bytes written to history log: ");
 SetCursorPosition(10,3);
 printw(
 "Qty  Item No     Description                              Unit Prc   Amount");
 SetCursorPosition(11,3);
 printw(
 "---- ----------- ---------------------------------------- -------- --------");
 SetCursorPosition(12,3);
 printw (
 "  __ ___________                                              0.00     0.00");

 SetCursorPosition(18,3);
 printw(
 "Department 59LS                  [Sub Total ] Remote Time          _____.__");
 SetCursorPosition(19,3);
 printw(
 "Employee   379834                [Disc Pcnt ] Remote Avg   ___.__  _____.__");
 SetCursorPosition(20,3);
 printw(
 "Register   %3ld                   [Tax Pcnt  ] Appl Time    ___.__  _____.__",
   reg_no);
 SetCursorPosition(21,3);
 printw(
 "Last Purch MMDDYYYY              [Total     ] Appl Avg             _____.__");

/*wrefresh( curscr);*/
 return;
}
/*************************************************************************/
/*
 * OS/2 Specific call to set cursor position in text mode (RR=0-24, CC=0-79)
    mvcur(LINES/2, COLS/2,RR, CC);
 */
void SetCursorPosition(int RR, int CC)
{
    move(RR, CC); 
    return;
}
/*************************************************************************/
startscr(void)
{
   initscr();
   noecho();
   leaveok(stdscr,TRUE);	
   scrollok(stdscr,FALSE);	
   return;
}
die(void)
{
   signal( SIGINT, SIG_IGN);
/*
   mvcur(LINES/2, COLS/2,0, 0);
   wclear(curscr);	
   wrefresh(curscr);	
*/
   endwin();
   exit (0);
}
void clear_screen(void)
{
   wclear(curscr);	
   wrefresh(curscr);	
   return;
}
/************************************************************************/
/*
CATCH (input_status)
 {
   error_status_t st;
unsigned char error_string[80];

   dce_error_inq_text(input_status, error_string, &st);
   fprintf(stderr, "SvrSyn:\n%s\n",error_string);
   exit(1);
 }
 */
/**********************************
 * DCELOGIN cell_admin -dce-
 **********************************/
void Login(FILE          * fp)
{
   char		    execbuf[50];

   static char      template[20]="dce_login_noexec  ";
   static char      process_arg[32];
   static char      space[2]=" ";
   unsigned         execflags=2;
   int      rc1, rc2;
   struct timeb     t1;
   struct timeb     t2;
   double           api_time=0.0;
   int              tenths=0;



    strcat(process_arg, THE_USER);
    strcat(process_arg, space);
    strcat(process_arg, THE_PASSWORD);

    process_arg[17]= '\0';

    sprintf(execbuf,"%s %s", template, process_arg); 
    ftime(&t1);
    system(execbuf);

    ftime(&t2);

    api_time =howlong(t2.time,t1.time,t2.millitm,t1.millitm,&tenths);

 /*
  * Glitch work_around. On the first RPC API call, the local time
  * zone may get adjusted. Bug or Feature?
  */

    if (t1.timezone != t2.timezone)
    {
      api_time -= (float)(t2.timezone-t1.timezone)*60.0;
    }

    strcpy(perf_array[perf_array_ptr].api_call,"Client system(dce_login_noexec)");
    perf_array[perf_array_ptr].api_resp_time = api_time;
    perhaps_an_error(0,fp,api_time,perf_array[perf_array_ptr++].api_call );

   /*
    * end DCELOGIN
    */

}
/*************************************************************
 * RPC Connect with known address/port
 *************************************************************/
void
DCE_1(unsigned char * pszEndPoint,
      unsigned char * pszNetworkAddress,
      FILE          * fp,
      rpc_binding_handle_t *bind_h )
{
  /* RPC variables */
   unsigned char * pszUuid             = "334A2E24-0000-0000-0D00-379834040000";
   unsigned char * pszProtocolSequence = "ncadg_ip_udp";
   unsigned char * pszOptions          = NULL;
            char * pszStringBinding;
   error_status_t   st;
   struct timeb     t1;
   struct timeb     t2;
   double           api_time=0.0;
   int              tenths=0;
   char             * env_ptr;

  /*
   * Method 1: Connect to a known destination. Requires
   * Port Number and IP Address
   */

   printf("Override 'rpc_ns_binding_import' using <%s><%s>\n",
                                          pszEndPoint, pszNetworkAddress);

   if (!(env_ptr = getenv("POSPROTOCOL")))
     printf("Environment variable 'POSPROTOCOL' not found.\n");
   else
     strcpy(pszProtocolSequence, env_ptr);

   printf("PROTSEQ  = <%s>\n",pszProtocolSequence);

  /*
   * Compose String Binding
   */

   ftime(&t1);

   rpc_string_binding_compose(pszUuid,
                              pszProtocolSequence,
                              pszNetworkAddress,
                              pszEndPoint,
                              pszOptions,
                              &pszStringBinding,
                              &st);

   ftime(&t2);

   api_time =howlong(t2.time,t1.time,t2.millitm,t1.millitm,&tenths);

  /*
   * Glitch work_around. On the first RPC API call, the local time
   * zone may get adjusted. Bug or Feature?
   */
  if (t1.timezone != t2.timezone)
  {
    api_time -= (float)(t2.timezone-t1.timezone)*60.0;
  }

  strcpy(perf_array[perf_array_ptr].api_call,"rpc_string_binding_compose");
  perf_array[perf_array_ptr].api_resp_time = api_time;
  perhaps_an_error(st,fp,api_time,perf_array[perf_array_ptr++].api_call );

  /*
   ***** Bind it
   */

  ftime(&t1);

  rpc_binding_from_string_binding(pszStringBinding, bind_h ,&st);

  ftime(&t2);
  api_time =howlong(t2.time,t1.time,t2.millitm,t1.millitm,&tenths);

  strcpy(perf_array[perf_array_ptr].api_call,"rpc_binding_from_string_binding");
  perf_array[perf_array_ptr].api_resp_time = api_time;
  perhaps_an_error(st,fp,api_time,perf_array[perf_array_ptr++].api_call );

  printf("Bound to %s[%s]\n",pszNetworkAddress,
                                pszEndPoint);

  rpc_string_free(&pszStringBinding, &st);
  printf("RpcStringFree returned %ld\n", st);

} /* End of Connect with Known Address */

/*************************************************************
 * RPC Connect - Lookup application via CDS
 *************************************************************/
void
DCE_2(  FILE          * fp,
        rpc_binding_handle_t *bind_h )
{
  /* RPC variables */
   unsigned char * pszUuid             = "334A2E24-0000-0000-0D00-379834040000";
   unsigned char * pszProtocolSequence = "ncadg_ip_udp";
   unsigned char * pszOptions          = NULL;
            char * pszStringBinding;
   error_status_t  st;
   struct timeb    t1;
   struct timeb    t2;
   double          api_time=0.0;
   int              tenths=0;
   rpc_ns_handle_t import_h;

   char          * env_ptr;
   unsigned char * pszAuthPrincipal    = "cell_admin";
   unsigned char * pszAuthPrincipalL   = "";
   unsigned32      longAuthLevel       = 3;
   unsigned32      longAuthLevelL      = 0;
   /*
      rpc_c_protect_level_default (0)
      rpc_c_protect_level_none (1)
      rpc_c_protect_level_connect (2)
      rpc_c_protect_level_call (3)
      rpc_c_protect_level_pkt (4)
      rpc_c_protect_level_pkt_integ (5)
      rpc_c_protect_level_pkt_privacy (6)
    */
   unsigned32      longAuthnProtocol    = 1;
   unsigned32      longAuthnProtocolL   = 0;
   /*
      rpc_c_authn_none (0)
      rpc_c_authn_dce_secret (1)
      rpc_c_authn_dce_public (2)
      rpc_c_authn_dce_dummy (3)
      rpc_c_authn_dssa_public (4)
      rpc_c_authn_default (-1)
    */
   unsigned32      longAuthzProtocol    = 2;
   unsigned32      longAuthzProtocolL   = 0;
   /*
      rpc_c_authz_none (0)
      rpc_c_authz_name (1)
      rpc_c_authz_dce (2)
    */


   /*
    * User did not specify an endpoint, so we gotta
    * IMPORT it from CDS
    */

   ftime(&t1);

   rpc_ns_binding_import_begin (rpc_c_ns_syntax_default,
                                "/.:/PointOfSale",
                                PointOfSale_v0_0_c_ifspec,
                                NULL,
                                &import_h,
                                &st);

   ftime(&t2);
   api_time =howlong(t2.time,t1.time,t2.millitm,t1.millitm,&tenths);
   if (t1.timezone != t2.timezone)
   {
     api_time -= (float)(t2.timezone-t1.timezone)*60.0;
   }

   strcpy(perf_array[perf_array_ptr].api_call,"rpc_ns_binding_import_begin");
   perf_array[perf_array_ptr].api_resp_time = api_time;
   perhaps_an_error(st,fp,api_time,perf_array[perf_array_ptr++].api_call );

   /**********************************************************************/
   /*
    * Force the Client to refresh his local cache
    */

   printf("Force the Client to refresh his local cache!\n");

   ftime(&t1);


   rpc_ns_mgmt_handle_set_exp_age(import_h,
                                  0L,
                                  &st);
   ftime(&t2);
   api_time =howlong(t2.time,t1.time,t2.millitm,t1.millitm,&tenths);


   strcpy(perf_array[perf_array_ptr].api_call,"rpc_ns_mgmt_handle_set_exp_age");
   perf_array[perf_array_ptr].api_resp_time = api_time;
   perhaps_an_error(st,fp,api_time,perf_array[perf_array_ptr++].api_call );

   /**********************************************************************/

   ftime(&t1);

   rpc_ns_binding_import_next (import_h,
                               bind_h,
                               &st);

   ftime(&t2);
   api_time =howlong(t2.time,t1.time,t2.millitm,t1.millitm,&tenths);

   strcpy(perf_array[perf_array_ptr].api_call,"rpc_ns_binding_import_next");
   perf_array[perf_array_ptr].api_resp_time = api_time;
   perhaps_an_error(st,fp,api_time,perf_array[perf_array_ptr++].api_call );

   /**********************************************************************/
   ftime(&t1);

   rpc_ns_binding_import_done (&import_h, &st);

   ftime(&t2);
   api_time =howlong(t2.time,t1.time,t2.millitm,t1.millitm,&tenths);

   strcpy(perf_array[perf_array_ptr].api_call,"rpc_ns_binding_import_done");
   perf_array[perf_array_ptr].api_resp_time = api_time;
   perhaps_an_error(st,fp,api_time,perf_array[perf_array_ptr++].api_call );

   /**********************************************************************/
   ftime(&t1);

   rpc_ep_resolve_binding (*bind_h, PointOfSale_v0_0_c_ifspec, &st);

   ftime(&t2);
   api_time =howlong(t2.time,t1.time,t2.millitm,t1.millitm,&tenths);

   strcpy(perf_array[perf_array_ptr].api_call,"rpc_ep_resolve_binding");
   perf_array[perf_array_ptr].api_resp_time = api_time;
   perhaps_an_error(st,fp,api_time,perf_array[perf_array_ptr++].api_call );

   /**********************************************************************/
   ftime(&t1);

   rpc_binding_to_string_binding (*bind_h, &pszStringBinding, &st);

   ftime(&t2);
   api_time =howlong(t2.time,t1.time,t2.millitm,t1.millitm,&tenths);

   printf("Binding=<%s>\n", pszStringBinding);
   fprintf(fp,"Binding=<%s>\n", pszStringBinding);

   strcpy(perf_array[perf_array_ptr].api_call,"rpc_binding_to_string_binding");
   perf_array[perf_array_ptr].api_resp_time = api_time;
   perhaps_an_error(st,fp,api_time,perf_array[perf_array_ptr++].api_call );

   rpc_string_free(&pszStringBinding, &st);
   printf("RpcStringFree returned %ld\n", st);

   /**********************************************************************/

   ftime(&t1);

   rpc_mgmt_is_server_listening (*bind_h, &st);

   ftime(&t2);
   api_time =howlong(t2.time,t1.time,t2.millitm,t1.millitm,&tenths);

   strcpy(perf_array[perf_array_ptr].api_call,"rpc_mgmt_is_server_listening");
   perf_array[perf_array_ptr].api_resp_time = api_time;
   perhaps_an_error(st,fp,api_time,perf_array[perf_array_ptr++].api_call );

   /**********************************************
    * Authentication Stuff
    **********************************************/
   if ((env_ptr = getenv("AUTHP")))
   {
     strcpy(pszAuthPrincipal, env_ptr);
   }
   else
     strcpy(pszAuthPrincipal, "cell_admin");

   /*****************/
   if ((env_ptr = getenv("AUTHL")))
     longAuthLevel = atol(env_ptr);
   else
     longAuthLevel = 3;           /* call */

   /*****************/
   if ((env_ptr = getenv("AUTHN")))
     longAuthnProtocol = atol(env_ptr);
   else
     longAuthnProtocol = 1;           /* secret */

   /*****************/
   if ((env_ptr = getenv("AUTHZ")))
     longAuthzProtocol = atol(env_ptr);
   else
     longAuthzProtocol = 2;            /* DCE */


   strcpy(perf_array[perf_array_ptr].api_call,"Auth_Level Set To");
   perf_array[perf_array_ptr++].api_resp_time = (float)longAuthLevel;
   strcpy(perf_array[perf_array_ptr].api_call,"Auth_N Set To");
   perf_array[perf_array_ptr++].api_resp_time = (float)longAuthnProtocol;
   strcpy(perf_array[perf_array_ptr].api_call,"Auth_Z Set To");
   perf_array[perf_array_ptr++].api_resp_time = (float)longAuthzProtocol;

   /*****************/
   if (longAuthLevel != 0)
   {
     ftime(&t1);

     rpc_binding_set_auth_info(*bind_h,
                               pszAuthPrincipal,
                               longAuthLevel,
                               longAuthnProtocol,
                               NULL,
                               longAuthzProtocol,
                               &st );

     ftime(&t2);
     api_time =howlong(t2.time,t1.time,t2.millitm,t1.millitm,&tenths);

     strcpy(perf_array[perf_array_ptr].api_call,"rpc_binding_set_auth_info");
     perf_array[perf_array_ptr].api_resp_time = api_time;
     perhaps_an_error(st,fp,api_time,perf_array[perf_array_ptr++].api_call );

     /****************************************************/
     /*
     ftime(&t1);

     rpc_ss_register_auth_info(*bind_h,
                               pszAuthPrincipal,
                               longAuthLevel,
                               longAuthnProtocol,
                               NULL,
                               longAuthzProtocol,
                               &st );

     ftime(&t2);
     api_time =howlong(t2.time,t1.time,t2.millitm,t1.millitm,&tenths);

     strcpy(perf_array[perf_array_ptr].api_call,"rpc_ss_register_auth_info");
     perf_array[perf_array_ptr].api_resp_time = api_time;
     perhaps_an_error(st,fp,api_time,perf_array[perf_array_ptr++].api_call );
     */
     /****************************************************/
     ftime(&t1);

     rpc_binding_inq_auth_info(*bind_h,
                               &pszAuthPrincipalL,
                               &longAuthLevelL,
                               &longAuthnProtocolL,
                               NULL,
                               &longAuthzProtocolL,
                               &st );

     ftime(&t2);
     api_time =howlong(t2.time,t1.time,t2.millitm,t1.millitm,&tenths);


     strcpy(perf_array[perf_array_ptr].api_call,"rpc_binding_inq_auth_info");
     perf_array[perf_array_ptr].api_resp_time = api_time;
     perhaps_an_error(st,fp,api_time,perf_array[perf_array_ptr++].api_call );

     printf("Auth Info: Principal        =%s\n", pszAuthPrincipalL);
     printf("Auth Info: Level            =%ld\n", longAuthLevelL);
     printf("Auth Info: AuthNProtocol    =%ld\n", longAuthnProtocolL);
     printf("Auth Info: AuthZProtocol    =%ld\n", longAuthzProtocolL);
   }
} /* End of Connect with Import Binding */
/****************************************************
 *     End the Connection to the Application Server *
 ****************************************************/
void DCE_3(rpc_binding_handle_t *bind_h )
{
     error_status_t  st;

     rpc_binding_free(bind_h, &st);
     SetCursorPosition(20, 0);
     printf("RpcBindingFree returned %ld\n", st);

     SetCursorPosition(22,0);
     printf("Register Signed Off.                                             \n");

}

