CR Number                     : 13327
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : command_ref
Short Description             : rpc_intro(8rpc) references nonexistent rpcd(8rpc)
Reported Date                 : 2/16/96
Found in Baseline             : 1.1
Found Date                    : 2/16/96
Severity                      : B
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : src/dce_books/command_ref/man8rpc/rpc_intro.8rpc
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : open

[2/16/96 public]
The rpc_intro(8rpc) ref page includes the now-nonexistent rpcd(8rpc)
ref page in the Related Documents section.  The reference to rpcd
should be removed.
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `open'

[7/29/96 public]
This chapter begins with:

  "The DCE remote procedure call (RPC) component provides 
  two administrative facilities: the RPC daemon
  and the DCE RPC control program, \*Lrpccp\*O. 

  These facilities are superceded by the DCE host daemon (\*Ldced\*O)
  and the DCE control program (\*Ldcecp\*O) in OSF DCE Version 1.1." 

The references and the superceded 
commands have been left in the DCE documents, but 
annotated with notes such as the one above.  
Until a decision is made to delete the outdated 
commands from the documents, I believe the manpage is 
correct as stands.  I am canceling this bug.



CR Number                     : 13172
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : cs_remote.c
Short Description             : The VTS remote process hangs occasionally
Reported Date                 : 10/28/95
Found in Baseline             : 1.0.2
Found Date                    : 10/28/95
Severity                      : B
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/28/95 public]

Component (Module):     cs_remote.c 

One Line Description:
  	The VTS remote process hangs occasionally.


Related-file:::: Problem
 DESCRIPTION:
 
 The remote process isn't behaving properly sometimes when the connection 
 with local process is no longer alive.  The process gets hung.  The remote 
 process needs to continue to accept new connections and remove the old 
 file descriptor from the select() i/o descriptor set.  The remote also
 isn't cleaning up after the remote child process goes away.
 
 REPRODUCIBLE:
 
 Yes.
 
 
 TEST SOFTWARE DESCRIPTION:
 
 VTS 
 
 DESCRIPTION OF HARDWARE WHERE BUG OCCURRED:
 
 VM
 
 DESCRIPTION OF WHERE TEST SUCCESSFULLY RAN:
 
Related-file::Added 950919 by warnick:: /build/hiosfm/RCS/dce1.1/src/test/dvs/rpc/protocol/remote/cs/./cs_remote.c,v 8.4
 /build/hiosfm/RCS/dce1.1/src/test/dvs/rpc/protocol/remote/cs/./cs_remote.c,v 8.4
 warnick 1995/09/19 18:33:03 +10 -18
 Reason:  OSDqa12426 The VTS remote process hangs occasionally.
 Fix for OSDqa12426.
 
     *** /tmp/ci.27828..cs_remote.c.27869.1	Tue Sep 19 14:33:06 1995
     --- /tmp/cs_remote.c.27869.2	Tue Sep 19 14:33:06 1995
     ***************
     *** 247,256 ****
     --- 247,257 ----
       
       	    if (num < 0)
       	    {
       		ERROR_MSG("select returned < 0");
       		perror("CSR: ");
     + 		connection_alive = 0;
       		continue;
       	    }
       	    else
       	    {
       #ifdef DEBUG
     ***************
     *** 281,305 ****
       #ifdef DEBUG
       		    printf("local packet fd is set\n");
       #endif
       		    if ((process_local_packet(g_in_conn_sock)) != SUCCESS)
       		    {
     - #ifdef hitm
       			ERROR_MSG("process_local_packet failed\n");
       		    	FD_CLR(g_in_conn_sock, &all_rfds);
       		    	FD_CLR(g_in_conn_sock, &all_wfds);
       		    	FD_CLR(g_in_conn_sock, &all_xfds);
       			close(g_in_conn_sock);
     ! #else
     ! #ifdef XDEBUG
     ! 			ERROR_MSG("process_local_packet failed\n");
     ! 		    	/* FD_CLR(g_in_conn_sock, &all_rfds);
     ! 		    	FD_CLR(g_in_conn_sock, &all_wfds);
     ! 		    	FD_CLR(g_in_conn_sock, &all_xfds);
     ! 			close(g_in_conn_sock); */
     ! #endif
     ! #endif
       		    }
       		}
       
       		/*
       		 * The process_local_packet could call routine "stop"
     --- 282,297 ----
       #ifdef DEBUG
       		    printf("local packet fd is set\n");
       #endif
       		    if ((process_local_packet(g_in_conn_sock)) != SUCCESS)
       		    {
       			ERROR_MSG("process_local_packet failed\n");
       		    	FD_CLR(g_in_conn_sock, &all_rfds);
       		    	FD_CLR(g_in_conn_sock, &all_wfds);
       		    	FD_CLR(g_in_conn_sock, &all_xfds);
       			close(g_in_conn_sock);
     ! 			connection_alive = 0;
       		    }
       		}
       
       		/*
       		 * The process_local_packet could call routine "stop"
     ***************
     *** 322,335 ****
       		    if ((process_vta_ctl(g_from_child_ctl_sock)) != SUCCESS)
       		    {
       #ifdef DEBUG
       			ERROR_MSG("process_vta_ctl can not read\n");
       #endif
     ! 		        /* FD_CLR(g_from_child_ctl_sock, &all_rfds);
       		        FD_CLR(g_from_child_ctl_sock, &all_wfds);
       		        FD_CLR(g_from_child_ctl_sock, &all_xfds);
     ! 			close(g_from_child_ctl_sock); */
       		    }
       		}
       
       		if ( g_conn_oriented && remote_server == TRUE &&
       		    FD_ISSET(g_child_data_sock, &rfds) )
     --- 314,327 ----
       		    if ((process_vta_ctl(g_from_child_ctl_sock)) != SUCCESS)
       		    {
       #ifdef DEBUG
       			ERROR_MSG("process_vta_ctl can not read\n");
       #endif
     ! 		        FD_CLR(g_from_child_ctl_sock, &all_rfds);
       		        FD_CLR(g_from_child_ctl_sock, &all_wfds);
       		        FD_CLR(g_from_child_ctl_sock, &all_xfds);
     ! 			close(g_from_child_ctl_sock);
       		    }
       		}
       
       		if ( g_conn_oriented && remote_server == TRUE &&
       		    FD_ISSET(g_child_data_sock, &rfds) )
     ***************
     *** 358,371 ****
       			 * Forward the data (packet) to the local side.
       			 */
       			if ((rc = forward_data(vta_assoc[cnt].sock, cnt)) == (-1))
       			{
       			    fprintf(stderr, "forward_data FAILED for cnt %d\n", cnt);
     ! 			    /* FD_CLR(vta_assoc[cnt].sock, &all_rfds);
       			    FD_CLR(vta_assoc[cnt].sock, &all_wfds);
       			    FD_CLR(vta_assoc[cnt].sock, &all_xfds);
     ! 			    close(vta_assoc[cnt].sock); */
       			}
       		    }
       		}
       
       		if (FD_ISSET(g_child_stdout_sock, &rfds))
     --- 350,363 ----
       			 * Forward the data (packet) to the local side.
       			 */
       			if ((rc = forward_data(vta_assoc[cnt].sock, cnt)) == (-1))
       			{
       			    fprintf(stderr, "forward_data FAILED for cnt %d\n", cnt);
     ! 			    FD_CLR(vta_assoc[cnt].sock, &all_rfds);
       			    FD_CLR(vta_assoc[cnt].sock, &all_wfds);
       			    FD_CLR(vta_assoc[cnt].sock, &all_xfds);
     ! 			    close(vta_assoc[cnt].sock);
       			}
       		    }
       		}
       
       		if (FD_ISSET(g_child_stdout_sock, &rfds))
     ***************
     *** 376,389 ****
       		    if ((forward_stdout(g_child_stdout_sock)) != SUCCESS)
                           {
       #ifdef DEBUG
                               ERROR_MSG("forward_stdout: can not read (socket may be closed)\n");
       #endif
     !                         /* FD_CLR(g_child_stdout_sock, &all_rfds);
                               FD_CLR(g_child_stdout_sock, &all_wfds);
                               FD_CLR(g_child_stdout_sock, &all_xfds);
     ! 			close(g_child_stdout_sock); */
                           }
       
       		}
       	    }
       	}
     --- 368,381 ----
       		    if ((forward_stdout(g_child_stdout_sock)) != SUCCESS)
                           {
       #ifdef DEBUG
                               ERROR_MSG("forward_stdout: can not read (socket may be closed)\n");
       #endif
     !                         FD_CLR(g_child_stdout_sock, &all_rfds);
                               FD_CLR(g_child_stdout_sock, &all_wfds);
                               FD_CLR(g_child_stdout_sock, &all_xfds);
     ! 			close(g_child_stdout_sock);
                           }
       
       		}
       	    }
       	}
 
Related-file:::: Resolution 
 DESCRIPTION OF BUG FIX:
 
 Added back in code that OSF commented out for removing the file
 descriptor from the select() i/o descriptor set and closing the
 socket.  Also set the connection to nolonger alive so we will start 
 accepting new connections from the local process.

[11/01/95 public]

Removed extraneous header info in previous notes.
Cancelling this CR, opening new CR in dce_vts project.



CR Number                     : 13171
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : vts
Short Description             : Remote process dies from SIGPIPE
Reported Date                 : 10/28/95
Found in Baseline             : 1.1
Found Date                    : 10/28/95
Severity                      : C
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/28/95 public]

Component (Module):     cs_remote.c, .. 

Description:
  	Remote process dies prematurely from SIGPIPE.

Full Description:

Related-file:::: Problem
 DESCRIPTION:
 
 The child process of the remote sometimes exits before the remote
 has a chance to shut it down.  The remote tries to write to
 the pipe and dies from a SIGPIPE.
 
 
Related-file::Added 950920 by warnick:: /build/hiosfm/RCS/dce1.1/src/test/dvs/rpc/protocol/remote/cs/./cs_remote.c,v 8.5
 /build/hiosfm/RCS/dce1.1/src/test/dvs/rpc/protocol/remote/cs/./cs_remote.c,v 8.5
 warnick 1995/09/20 14:57:24 +14 -2
 Reason:  OSDqa12428 Remote process dies prematurely from SIGPIPE.
 Fix for OSDqa12428.
 
     *** /tmp/ci.28725..cs_remote.c.28765.1	Wed Sep 20 10:57:26 1995
     --- /tmp/cs_remote.c.28765.2	Wed Sep 20 10:57:26 1995
     ***************
     *** 145,154 ****
     --- 145,157 ----
           int s, af, type, protocol;
           struct sockaddr_in	addr, 
       			bind_addr;
           int addrlen;
           struct timeval timv = { 2, 0 };	/* initialize to 2.000000 seconds */
     + #ifdef hitm
     +     struct sigaction sigactn;
     + #endif
       
           if (argc == 2)
           {
       	g_portnr = atoi(argv[1]);
       	if (g_portnr == 0)
     ***************
     *** 156,165 ****
     --- 159,177 ----
       	    fprintf(stderr, 
       		"Usage: %s\n -OR- %s portnumber\n", argv[0], argv[0]);
       	    exit(-1);
       	}
           }
     + #ifdef hitm
     +     /*
     +      * Make sure broken pipes don't cause us to crash
     +      */
     +     sigactn.sa_handler = SIG_IGN;
     +     sigemptyset(&sigactn.sa_mask);
     +     sigactn.sa_flags   = 0;
     +     sigaction(SIGPIPE, &sigactn, NULL);
     + #endif
       
           memset((void *) vta_addrs, 0, sizeof(vta_addrs));
           memset((void *) vta_assoc, 0, sizeof(vta_assoc));
           top_assoc = 0;
       
 
Related-file::Added 950920 by warnick:: /build/hiosfm/RCS/dce1.1/src/test/dvs/rpc/protocol/remote/vta-cl/csar/./rtc2.c,v 8.3
 /build/hiosfm/RCS/dce1.1/src/test/dvs/rpc/protocol/remote/vta-cl/csar/./rtc2.c,v 8.3
 warnick 1995/09/20 14:59:20 +4 -4
 Reason:  OSDqa12428 Remote process dies prematurely from SIGPIPE.
 Fix for OSDqa12428.
 
     *** /tmp/ci.28801..rtc2.c.28843.1	Wed Sep 20 10:59:22 1995
     --- /tmp/rtc2.c.28843.2	Wed Sep 20 10:59:22 1995
     ***************
     *** 509,521 ****
       
       #ifdef DEBUG
           er_msg( "CL RPC SAR client completing.\n" );
       #endif
       
     ! #ifdef SNI_SVR4
           /* wait for CSR to terminate this process */
     !     sleep (120);
       #endif
       
           return ( 0 );
       }
       
     --- 509,521 ----
       
       #ifdef DEBUG
           er_msg( "CL RPC SAR client completing.\n" );
       #endif
       
     ! #if defined(SNI_SVR4) || defined(hitm)
           /* wait for CSR to terminate this process */
     !     sleep (180);
       #endif
       
           return ( 0 );
       }
       
 
Related-file::Added 950920 by warnick:: /build/hiosfm/RCS/dce1.1/src/test/dvs/rpc/protocol/remote/vta-cl/server/./rtc1.c,v 8.2
 /build/hiosfm/RCS/dce1.1/src/test/dvs/rpc/protocol/remote/vta-cl/server/./rtc1.c,v 8.2
 warnick 1995/09/20 15:01:52 +4 -4
 Reason:  OSDqa12428 Remote process dies prematurely from SIGPIPE.
 Fix for OSDqa12428.
 
     *** /tmp/ci.28894..rtc1.c.28934.1	Wed Sep 20 11:01:54 1995
     --- /tmp/rtc1.c.28934.2	Wed Sep 20 11:01:54 1995
     ***************
     *** 405,417 ****
       
       #ifdef DEBUG
         er_msg( "CL RPC server completing.\n" );
       #endif
       
     ! #ifdef SNI_SVR4
           /* wait for CSR to terminate this process */
     !     sleep (120);
       #endif
       
         /* Free up all resources */
         
         return 0;
     --- 405,417 ----
       
       #ifdef DEBUG
         er_msg( "CL RPC server completing.\n" );
       #endif
       
     ! #if defined(SNI_SVR4) || defined(hitm)
           /* wait for CSR to terminate this process */
     !     sleep (180);
       #endif
       
         /* Free up all resources */
         
         return 0;
 
Related-file::Added 950920 by warnick:: /build/hiosfm/RCS/dce1.1/src/test/dvs/rpc/protocol/remote/vta-co/client/./rtc4.c,v 8.3
 /build/hiosfm/RCS/dce1.1/src/test/dvs/rpc/protocol/remote/vta-co/client/./rtc4.c,v 8.3
 warnick 1995/09/20 15:04:00 +4 -4
 Reason:  OSDqa12428 Remote process dies prematurely from SIGPIPE.
 Fix for OSDqa12428.
 
     *** /tmp/ci.28967..rtc4.c.29007.1	Wed Sep 20 11:04:02 1995
     --- /tmp/rtc4.c.29007.2	Wed Sep 20 11:04:02 1995
     ***************
     *** 308,320 ****
       
       #ifdef DEBUG
           er_msg( "CO RPC client completing.\n" );
       #endif
       
     ! #ifdef SNI_SVR4
           /* wait for CSR to terminate this process */
     !     sleep (120);
       #endif
       
           return ( 0 );
       }
       
     --- 308,320 ----
       
       #ifdef DEBUG
           er_msg( "CO RPC client completing.\n" );
       #endif
       
     ! #if defined(SNI_SVR4) || defined(hitm)
           /* wait for CSR to terminate this process */
     !     sleep (180);
       #endif
       
           return ( 0 );
       }
       
 
Related-file::Added 950920 by warnick:: /build/hiosfm/RCS/dce1.1/src/test/dvs/rpc/protocol/remote/vta-co/server/./rtc3.c,v 8.2
 /build/hiosfm/RCS/dce1.1/src/test/dvs/rpc/protocol/remote/vta-co/server/./rtc3.c,v 8.2
 warnick 1995/09/20 15:06:11 +4 -4
 Reason:  OSDqa12428 Remote process dies prematurely from SIGPIPE.
 Fix for OSDqa12428.
 
     *** /tmp/ci.29057..rtc3.c.29098.1	Wed Sep 20 11:06:12 1995
     --- /tmp/rtc3.c.29098.2	Wed Sep 20 11:06:12 1995
     ***************
     *** 413,425 ****
       
       #ifdef DEBUG
         er_msg( "CO RPC server completing.\n" );
       #endif
       
     ! #ifdef SNI_SVR4
           /* wait for CSR to terminate this process */
     !     sleep (120);
       #endif
       
         /* Free up all resources */
         
         return 0;
     --- 413,425 ----
       
       #ifdef DEBUG
         er_msg( "CO RPC server completing.\n" );
       #endif
       
     ! #if defined(SNI_SVR4) || defined(hitm)
           /* wait for CSR to terminate this process */
     !     sleep (180);
       #endif
       
         /* Free up all resources */
         
         return 0;
 
Related-file::Added 950920 by warnick:: /build/hiosfm/RCS/dce1.1/src/test/dvs/rpc/protocol/remote/vta-ts/ndr_client/./ndr_r.c,v 8.2
 /build/hiosfm/RCS/dce1.1/src/test/dvs/rpc/protocol/remote/vta-ts/ndr_client/./ndr_r.c,v 8.2
 warnick 1995/09/20 15:11:09 +4 -4
 Reason:  OSDqa12428 Remote process dies prematurely from SIGPIPE.
 Fix for OSDqa12428.
 
     *** /tmp/ci.29154..ndr_r.c.29195.1	Wed Sep 20 11:11:11 1995
     --- /tmp/ndr_r.c.29195.2	Wed Sep 20 11:11:11 1995
     ***************
     *** 283,295 ****
       
       #ifdef DEBUG
           er_msg( "CL RPC client completing.\n" );
       #endif
       
     ! #ifdef SNI_SVR4
           /* wait for CSR to terminate this process */
     !     sleep (120);
       #endif
       
           return ( SUCCESS );
       }
       
     --- 283,295 ----
       
       #ifdef DEBUG
           er_msg( "CL RPC client completing.\n" );
       #endif
       
     ! #if defined(SNI_SVR4) || defined(hitm)
           /* wait for CSR to terminate this process */
     !     sleep (180);
       #endif
       
           return ( SUCCESS );
       }
       
 
Related-file::Added 950920 by warnick:: /build/hiosfm/RCS/dce1.1/src/test/dvs/rpc/protocol/remote/vta-ts/ndr_server/./rndr_server.c,v 8.2
 /build/hiosfm/RCS/dce1.1/src/test/dvs/rpc/protocol/remote/vta-ts/ndr_server/./rndr_server.c,v 8.2
 warnick 1995/09/20 15:15:27 +4 -4
 Reason:  OSDqa12428 Remote process dies prematurely from SIGPIPE.
 Fix for OSDqa12428.
 
     *** /tmp/ci.29298..rndr_server.c.29338.1	Wed Sep 20 11:15:28 1995
     --- /tmp/rndr_server.c.29338.2	Wed Sep 20 11:15:28 1995
     ***************
     *** 622,634 ****
       
       #ifdef DEBUG
           er_msg( "TS/NDR server completing.\n" );
       #endif
       
     ! #ifdef SNI_SVR4
           /* wait for CSR to terminate this process */
     !     sleep (120);
       #endif
       
           /* 
            * Free up all resources
            */
     --- 622,634 ----
       
       #ifdef DEBUG
           er_msg( "TS/NDR server completing.\n" );
       #endif
       
     ! #if defined(SNI_SVR4) || defined(hitm)
           /* wait for CSR to terminate this process */
     !     sleep (180);
       #endif
       
           /* 
            * Free up all resources
            */
 
Related-file:::: Resolution 
 DESCRIPTION OF BUG FIX:
 
 SNI added a sleep() to the remote child processes to try to compensate
 for the child process exiting to early.  This solution is timing dependent.  
 So besides adding the sleep() for synchronization also ignore the SIGPIPE 
 signal in the remote so the broken pipe doesn't cause the remote process
 to crash.
  
  
 REGRESSION TEST SCENARIO:
 
 Run the protocol portion of the VTS.
  
  
 RCSDIFFS (either inserted manually or via Fci):

[11/01/95]

Removed extraneous header info from previous notes.
Cancelling this CR, opening new CR under dce_vts project.



CR Number                     : 12933
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpcd
Short Description             : cleanup in dsm.c:grow_file()  may leave dangling ptrs
Reported Date                 : 6/25/95
Found in Baseline             : 1.0.3
Found Date                    : 6/25/95
Severity                      : B
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/25/95 public]
 Several issues are raised in the customer report.

   - Cleanup in dsm.c:grow_file() leaves dangling pointers. 
	I believe, from looking at dsm.c in 1.0.3, this is a bug 
	that could potentially cause other symptoms described here.

  - rpcd deadlock
	If a SEGV or SIGILL is raised while the db lock is held
	it is implementation dependent whether only the thread
	is terminated or the entire process is aborted with 
	a core dump. On rs6k reference this should be latter, as
	_CMA_SYNC_KILL_ flag is enabled.

  - rpcd spinning on mutex locks
	This is perhaps  property of the underlying threads
	implementation and perhaps a multi-processor issue.
	Unless _CMA_SPIN_LOOP_ is enabled at compile time
	the lock operations should block and not consume
	significant cpu.

 The cleanup should  be fixed in 1.1 as well as 1.0.3. I believe it
 would also be helpful to retry write(2) in grow_file() on EINTR
 and if write(2) returned fewer than the number of bytes presented.

 I am not sure if this is an issue for  dce 1.1.

-------------  Customer report -----

                          DCE Problem Report
                  =================================


Submitter Information 
- ----------------------

Submitter Name:           wright
Organization:             Hitachi Computer Products (America), Inc. 
Email Address:            osd.dce@hi.com wright@hi.com 
Phone:                    617-890-0444 
DCE License Number:       1616-MDCE-92
Licensee's Defect Number: OSDqa11561


Hardware/Software Configuration
- --------------------------------

Offering and Version:   DCEunknown 
Component (Module):     dsm.c et al 
Client Hardware:        see below 
Client Software:        see below 
Server Hardware:        see below 
Server Software:        see below 
Compiler:               n/a

Problem Description
- --------------------

Severity Level: Critical

Date of First Occurrence: 05/16/95

One Line Description:
   OSDqa11561 rpcd caught in a deadlock

Full Description:

Related-file:::: Problem
 DESCRIPTION:
 
 It appears that 1 rpcd thread exited while holding a mutex lock
 and caused a deadlock because the remaining threads were waiting for
 that particular lock. 
 
 [Cpu0] (Dot is "0")  cda: 6>  $PS
   N SW   PID     USER   %CPU    WCHAN(WMESG)    COMD/ARGS
   0 U=     0   <root>   0.00         (clock)    kernel idle 
 * 1 U=     0   <root>   0.00         (malloc)   kmem 
 * 2 U=     0   <root>   0.00         (netisr)   netisr 
 * 3 U=     0   <root>   0.00         (netisr)   netisr 
 * 4 U=     0   <root>   0.00         (netisr)   netisr 
 * 5 U=     0   <root>   0.00         (netisr)   netisr 
 * 6 U=     0   <root>   0.00         (netisr)   netisr 
 * 7 U=     0   <root>   0.00         (netisr)   netisr 
 * 8 U=     0   <root>   0.00         (netisr)   netisr 
 * 9 U=     0   <root>   0.00         (netisr)   netisr 
 * a U=     0   <root>   0.00         (netisr)   netisr 
 * b U=     0   <root>   0.00         (netisr)   netisr 
 * c R      0   <root>   0.00         (idlework) idle0 
 * d R      0   <root>   0.00         (idlework) idle1 
 * e U=     0   <root>   0.00   60bd78(callwork) callthrd 
 * f U=     0   <root>   0.00   621f18(pagework) pageout 
 *10 U=     0   <root>   0.00   621dc8(objuncac) objcache 
 *11 U=     0   <root>   0.00   625970(reaper)   reaper 
 *12 U=     0   <root>   0.00   625c38(thswpin)  thrdswapin 
 *13 U=     0   <root>   0.00   4977d8(thswpout) thrdswapout 
 *14 U=     0   <root>   0.00   623490(swapwork) tskswapper 
 *15 U=     0   <root>   0.00   623498(swapout)  tskswapthrd 
 *16 U      0   <root>   0.00   623660(actqueue) doaction 
 *17 U=     0   <root>   0.00         (sched)    scheduler 
 *18 U=     0   <root>   0.00   5afdd8(dequeue)  psignal 
 *19 U=     0   <root>   0.00    32fd8(acctwtch) acct 
 *1a U      0   <root>   0.00   60bec0(async_q)  async 
 *1b U      0   <root>   0.00   60bec0(async_q)  async 
 *1c U      0   <root>   0.00   60bec0(async_q)  async 
 *1d U      0   <root>   0.00   60bec0(async_q)  async 
 *1e U      0   <root>   0.00   60bec0(async_q)  async 
 *1f U      0   <root>   0.00   60bec0(async_q)  async 
 *20 U      0   <root>   0.00   60bec0(async_q)  async 
 *21 U      0   <root>   0.00   60bec0(async_q)  async 
 *22 U      0   <root>   0.00   60bec0(async_q)  async 
 *23 U      0   <root>   0.00   60bec0(async_q)  async 
 *24 S      0   <root>   0.00         (tapScann) tapScanner 
   1 s      1   <root>   0.00   5a6b98(pause)    init               <args N/A>
   2 S=     2   <root>   0.00         (msgdeque) vnode_pager 
 * 1 S=     2   <root>   0.00         (msgdeque) vnpager 
 * 2 S=     2   <root>   0.00         (msgdeque) vnpager 
 * 3 S=     2   <root>   0.00         (msgdeque) vnpager 
 * 4 S=     2   <root>   0.00         (msgdeque) vnpager 
 * 5 U=     2   <root>   0.00   60b800(vpasync)  vnpager 
   3 S=     3   <root>   0.00         (msgdeque) device pager 
   4 s      4   <root>   0.00         (msgdeque) exception hdlr 
   c S     12   <root>   0.00   5a6ba8(pause)    /sbin/update 
  14 s  12020     root   0.00  2385b30(wait)     ksh                <args N/A>
  17 s   3023   <root>   0.00  2373770(event)    rlogind            <args N/A>
  19 s   3025   <root>   0.00  22e6618(event)    rlogind            <args N/A>
  1a s   3026     root   0.00  22f96a8(wait)     ksh                <args N/A>
  1b s   3027   <root>   0.00  22e6be0(event)    rlogind            <args N/A>
  1c s   3028     root   0.00  2323b30(wait)     ksh                <args N/A>
  1e s   3030     root   0.00   4b433c(ttyin)    ksh                <args N/A>
  3b s   9059     root   0.00         (msgdeque) r_server.exe       <args N/A>
 * 1 S   9059     root   0.00         (msgdeque) 
 * 2 s   9059     root   0.00  2330178(event)    
 * 3 s   9059     root   0.00         (msgdeque) 
 * 4 s   9059     root   0.00         (msgdeque) 
 * 5 s   9059     root   0.00         (msgdeque) 
 * 6 s   9059     root   0.00         (msgdeque) 
 * 7 s   9059     root   0.00         (msgdeque) 
 * 8 s   9059     root   0.00         (msgdeque) 
 * 9 s   9059     root   0.00         (msgdeque) 
 * a s   9059     root   0.00         (msgdeque) 
 * b s   9059     root   0.00         (msgdeque) 
 * c s   9059     root   0.00         (msgdeque) 
 * d s   9059     root   0.00         (msgdeque) 
 * e s   9059     root   0.00         (msgdeque) 
 * f s   9059     root   0.00         (msgdeque) 
 *10 s   9059     root   0.00         (msgdeque) 
  65 U=   101   <root>   0.00   5fd7b0(lockwrit) nfsfsd             <args N/A>
  66 U=   102   <root>   0.00   5fd7b0(lockwrit) nfsfsd             <args N/A>
  67 U=   103   <root>   0.00   5fd7b0(lockwrit) nfsfsd             <args N/A>
  68 U=   104   <root>   0.00   5fd7b0(lockwrit) nfsfsd             <args N/A>
  69 U=   105   <root>   0.00   5fd7b0(lockwrit) nfsfsd             <args N/A>
  6a U=   106   <root>   0.00   5fd7b0(lockwrit) nfsfsd             <args N/A>
  6b U=   107   <root>   0.00   5fd7b0(lockwrit) nfsfsd             <args N/A>
  6c U=   108   <root>   0.00   5fd7b0(lockwrit) nfsfsd             <args N/A>
  6d U=   109   <root>   0.00   5fd7b0(lockwrit) nfsfsd             <args N/A>
  6e U=   110   <root>   0.00   5fd7b0(lockwrit) nfsfsd             <args N/A>
  6f U=   111   <root>   0.00   5fd7b0(lockwrit) nfsfsd             <args N/A>
  71 U=   113   <root>   0.00   5fd7b0(lockwrit) nfsfsd             <args N/A>
  72 U=   114   <root>   0.00   5fd7b0(lockwrit) nfsfsd             <args N/A>
  73 S=   115   <root>   0.00  6181740(socket)   nfsfsd             <args N/A>
  74 U=   116   <root>   0.00   5fd7b0(lockwrit) nfsfsd             <args N/A>
  75 U=   117   <root>   0.00   5fd7b0(lockwrit) nfsfsd             <args N/A>
  76 U=   118   <root>   0.00   5fd7b0(lockwrit) nfsfsd             <args N/A>
  77 U=   119   <root>   0.00   5fd7b0(lockwrit) nfsfsd             <args N/A>
  78 U=   120   <root>   0.00   5fd7b0(lockwrit) nfsfsd             <args N/A>
  79 U=   121   <root>   0.00   5fd7b0(lockwrit) nfsfsd             <args N/A>
  7e S    126   <root>   0.00  21b8d70(event)    /usr/sbin/routed 
  87 S    135   <root>   0.00  21b8b20(event)    /usr/sbin/portmap 
  91 S    145   <root>   0.00  21b88d0(event)    /sbin/syslogd 
  93 S    147            0.00   5e65a4(klg_get)  errord             <args N/A>
  9d S    157   <root>   0.00  21b87a8(event)    /usr/sbin/mountd -n 
  9f S=   159   <root>   0.00  626ed40(socket)   nfsd               <args N/A>
  a0 S=   160   <root>   0.00  626ed40(socket)   nfsd               <args N/A>
  a1 S=   161   <root>   0.00  626ed40(socket)   nfsd               <args N/A>
  a2 S=   162   <root>   0.00  626ed40(socket)   nfsd               <args N/A>
  a4 S=   164   <root>   0.00   5f8e98(nfs biod) nfsiod             <args N/A>
  a5 S=   165   <root>   0.00   5f8e98(nfs biod) nfsiod             <args N/A>
  a6 S=   166   <root>   0.00   5f8e98(nfs biod) nfsiod             <args N/A>
  a7 S=   167   <root>   0.00   5f8e98(nfs biod) nfsiod             <args N/A>
  b7 S    183   <root>   0.00  6289640(fifo)     /usr/sbin/cron 
  cf S    207   <root>   0.00  6288130(socket)   -accepting connections          
  d2 s    210   <root>   0.00  222dd38(event)    inetd              <args N/A>
  db S    219   <root>   0.00   5a6ba8(pause)    /usr/sbin/chpidd 
  e5 s    229   <root>   0.00  222d520(event)    lpd                <args N/A>
  e7 s    231     root   0.00  618847c(tty)      ksh                <args N/A>
  f0 s    240   <root>   0.00  222d898(event)    rpc.statd          <args N/A>
  f2 s    242   <root>   0.00  222d3f8(event)    rpc.lockd          <args N/A>
 12e s    302   <root>   0.00         (msgdeque) sec_clientd        <args N/A>
 * 1 S    302   <root>   0.00         (msgdeque) 
 * 2 s    302   <root>   0.00  222aa58(event)    
 * 3 s    302   <root>   0.00         (msgdeque) 
 * 4 s    302   <root>   0.00         (msgdeque) 
 * 5 s    302   <root>   0.00         (msgdeque) 
 * 6 s    302   <root>   0.00         (msgdeque) 
 * 7 s    302   <root>   0.00         (msgdeque) 
 * 8 s    302   <root>   0.00         (msgdeque) 
 * 9 s    302   <root>   0.00         (msgdeque) 
 * a s    302   <root>   0.00         (msgdeque) 
 * b s    302   <root>   0.00         (msgdeque) 
 * c s    302   <root>   0.00         (msgdeque) 
 * d s    302   <root>   0.00         (msgdeque) 
 * e s    302   <root>   0.00         (msgdeque) 
 * f s    302   <root>   0.00         (msgdeque) 
 *10 s    302   <root>   0.00         (msgdeque) 
 *11 s    302   <root>   0.00         (msgdeque) 
 *12 s    302   <root>   0.00         (msgdeque) 
 132 S    306   <root>   0.00  2229a28(event)    /opt/dcelocal/bin/cdsadv 
 * 1 S    306   <root>   0.00         (msgdeque) 
 * 2 s    306   <root>   0.00         (msgdeque) 
 * 3 s    306   <root>   0.00         (msgdeque) 
 * 4 s    306   <root>   0.00  2229210(event)    
 * 5 S    306   <root>   0.00         (msgdeque) 
 * 6 S    306   <root>   0.00         (msgdeque) 
 * 7 s    306   <root>   0.00         (msgdeque) 
 * 8 s    306   <root>   0.00         (msgdeque) 
 * 9 s    306   <root>   0.00         (msgdeque) 
 * a s    306   <root>   0.00         (msgdeque) 
 * b s    306   <root>   0.00         (msgdeque) 
 * c s    306   <root>   0.00         (msgdeque) 
 * d s    306   <root>   0.00         (msgdeque) 
 * e s    306   <root>   0.00         (msgdeque) 
 * f s    306   <root>   0.00         (msgdeque) 
 *10 s    306   <root>   0.00         (msgdeque) 
 *11 s    306   <root>   0.00         (msgdeque) 
 *12 s    306   <root>   0.00         (msgdeque) 
 *13 s    306   <root>   0.00         (msgdeque) 
 *14 s    306   <root>   0.00         (msgdeque) 
 136 s    310   <root>   0.00         (msgdeque) cdsd               <args N/A>
 * 1 S    310   <root>   0.00         (msgdeque) 
 * 2 s    310   <root>   0.00         (msgdeque) 
 * 3 s    310   <root>   0.00         (msgdeque) 
 * 4 S    310   <root>   0.00  226d9c0(event)    
 * 5 s    310   <root>   0.00         (msgdeque) 
 * 6 s    310   <root>   0.00         (msgdeque) 
 * 7 s    310   <root>   0.00         (msgdeque) 
 * 8 s    310   <root>   0.00         (msgdeque) 
 * 9 s    310   <root>   0.00         (msgdeque) 
 * a s    310   <root>   0.00         (msgdeque) 
 * b s    310   <root>   0.00         (msgdeque) 
 * c s    310   <root>   0.00         (msgdeque) 
 * d s    310   <root>   0.00         (msgdeque) 
 * e s    310   <root>   0.00         (msgdeque) 
 * f s    310   <root>   0.00         (msgdeque) 
 *10 S    310   <root>   0.00         (msgdeque) 
 *11 s    310   <root>   0.00         (msgdeque) 
 *12 s    310   <root>   0.00         (msgdeque) 
 *13 s    310   <root>   0.00         (msgdeque) 
 *14 S    310   <root>   0.00         (msgdeque) 
 *15 s    310   <root>   0.00         (msgdeque) 
 *16 s    310   <root>   0.00         (msgdeque) 
 *17 s    310   <root>   0.00         (msgdeque) 
 *18 s    310   <root>   0.00  62d2130(socket)   
 *19 s    310   <root>   0.00         (msgdeque) 
 *1a s    310   <root>   0.00         (msgdeque) 
 *1b s    310   <root>   0.00         (msgdeque) 
 *1c s    310   <root>   0.00         (msgdeque) 
 *1d s    310   <root>   0.00         (msgdeque) 
 *1e s    310   <root>   0.00         (msgdeque) 
 *1f s    310   <root>   0.00         (msgdeque) 
 *20 S    310   <root>   0.00         (msgdeque) 
 *21 s    310   <root>   0.00         (msgdeque) 
 *22 s    310   <root>   0.00         (msgdeque) 
 *23 s    310   <root>   0.00         (msgdeque) 
 *24 s    310   <root>   0.00         (msgdeque) 
 *25 s    310   <root>   0.00         (msgdeque) 
 *26 s    310   <root>   0.00         (msgdeque) 
 *27 s    310   <root>   0.00         (msgdeque) 
 *28 s    310   <root>   0.00  62d3740(socket)   
 13d s    317   <root>   0.00         (msgdeque) dts_null_provide   <args N/A>
 * 1 S    317   <root>   0.00         (msgdeque) 
 * 2 s    317   <root>   0.00  22b2178(event)    
 * 3 s    317   <root>   0.00         (msgdeque) 
 * 4 s    317   <root>   0.00         (msgdeque) 
 * 5 s    317   <root>   0.00         (msgdeque) 
 * 6 s    317   <root>   0.00         (msgdeque) 
 191 s   9401    atlas   0.00         (msgdeque) rpcd               <args N/A>
 * 1 S   9401    atlas   0.00         (msgdeque) 
 * 2 R   9401    atlas  42.89                    
 * 3 R   9401    atlas  35.03                    
 * 4 R   9401    atlas  43.11                    
 * 5 R   9401    atlas  33.79                    
 * 6 R   9401    atlas  37.32                    
 * 7 R   9401    atlas  38.02                    
 * 8 R   9401    atlas  43.41                    
 * 9 s   9401    atlas   0.00         (msgdeque) 
 * a s   9401    atlas   0.00         (msgdeque) 
 * b s   9401    atlas   0.00         (msgdeque) 
 * c s   9401    atlas   0.00         (msgdeque) 
 * d s   9401    atlas   0.00         (msgdeque) 
 * e s   9401    atlas   0.00         (msgdeque) 
 * f s   9401    atlas   0.00         (msgdeque) 
 *10 s   9401    atlas   0.00         (msgdeque) 
 *11 s   9401    atlas   0.00         (msgdeque) 
 *12 s   9401    atlas   0.00         (msgdeque) 
 *13 s   9401    atlas   0.00         (msgdeque) 
 *14 s   9401    atlas   0.00         (msgdeque) 
 *15 s   9401    atlas   0.00         (msgdeque) 
 *16 s   9401    atlas   0.00         (msgdeque) 
 *17 s   9401    atlas   0.00         (msgdeque) 
 *18 s   9401    atlas   0.00         (msgdeque) 
 *19 s   9401    atlas   0.00         (msgdeque) 
 *1a s   9401    atlas   0.00         (msgdeque) 
 *1b s   9401    atlas   0.00         (msgdeque) 
 *1c s   9401    atlas   0.00         (msgdeque) 
 *1d s   9401    atlas   0.00         (msgdeque) 
 *1e s   9401    atlas   0.00         (msgdeque) 
 *1f s   9401    atlas   0.00         (msgdeque) 
 *20 s   9401    atlas   0.00         (msgdeque) 
 *21 s   9401    atlas   0.00         (msgdeque) 
 *22 s   9401    atlas   0.00         (msgdeque) 
 *23 s   9401    atlas   0.00         (msgdeque) 
 *24 s   9401    atlas   0.00         (msgdeque) 
 *25 s   9401    atlas   0.00         (msgdeque) 
 *26 s   9401    atlas   0.00         (msgdeque) 
 *27 s   9401    atlas   0.00         (msgdeque) 
 *28 s   9401    atlas   0.00         (msgdeque) 
 *29 s   9401    atlas   0.00         (msgdeque) 
 *2a s   9401    atlas   0.00         (msgdeque) 
 *2b s   9401    atlas   0.00         (msgdeque) 
 *2c s   9401    atlas   0.00         (msgdeque) 
 *2d s   9401    atlas   0.00         (msgdeque) 
 *2e s   9401    atlas   0.00         (msgdeque) 
 *2f s   9401    atlas   0.00         (msgdeque) 
 *30 s   9401    atlas   0.00         (msgdeque) 
 *31 s   9401    atlas   0.00         (msgdeque) 
 *32 s   9401    atlas   0.00         (msgdeque) 
 19c S    412   <root>   0.00  22971a8(event)    rlogind            <args N/A>
 19d s    413    atlas   0.00  21d98ec(wait)     ksh                <args N/A>
 30a S    778   <root>   0.00         (msgdeque) /opt/dcelocal/bin/cdsclerk -U ro
 * 1 s    778   <root>   0.00         (msgdeque) 
 * 2 s    778   <root>   0.00         (msgdeque) 
 * 3 s    778   <root>   0.00  6784f30(socket)   
 * 4 s    778   <root>   0.00         (msgdeque) 
 * 5 s    778   <root>   0.00         (msgdeque) 
 * 6 S    778   <root>   0.00         (msgdeque) 
 * 7 s    778   <root>   0.00         (msgdeque) 
 * 8 s    778   <root>   0.00  617de40(socket)   
 * 9 s    778   <root>   0.00  675ea40(socket)   
 * a s    778   <root>   0.00  676bc40(socket)   
 * b s    778   <root>   0.00         (msgdeque) 
 * c s    778   <root>   0.00  222c618(event)    
 * d s    778   <root>   0.00         (msgdeque) 
 * e s    778   <root>   0.00         (msgdeque) 
 * f s    778   <root>   0.00         (msgdeque) 
 *10 s    778   <root>   0.00         (msgdeque) 
 *11 s    778   <root>   0.00         (msgdeque) 
 *12 s    778   <root>   0.00         (msgdeque) 
 *13 s    778   <root>   0.00         (msgdeque) 
 *14 s    778   <root>   0.00         (msgdeque) 
 *15 s    778   <root>   0.00         (msgdeque) 
 365 s  12869     root   0.00  23dd3f8(event)    telnet             <args N/A>
 36f s   9879     root   0.00         (msgdeque) secd               <args N/A>
 * 1 S   9879     root   0.00         (msgdeque) 
 * 2 s   9879     root   0.00         (msgdeque) 
 * 3 S   9879     root   0.00         (msgdeque) 
 * 4 S   9879     root   0.00         (msgdeque) 
 * 5 S   9879     root   0.00  2373f88(event)    
 * 6 s   9879     root   0.00         (msgdeque) 
 * 7 s   9879     root   0.00         (msgdeque) 
 * 8 S   9879     root   0.00         (msgdeque) 
 * 9 s   9879     root   0.00         (msgdeque) 
 * a s   9879     root   0.00         (msgdeque) 
 * b s   9879     root   0.00         (msgdeque) 
 * c s   9879     root   0.00  676a940(socket)   
 * d s   9879     root   0.00         (msgdeque) 
 * e s   9879     root   0.00         (msgdeque) 
 * f s   9879     root   0.00         (msgdeque) 
 *10 s   9879     root   0.00         (msgdeque) 
 *11 s   9879     root   0.00         (msgdeque) 
 *12 s   9879     root   0.00         (msgdeque) 
 *13 s   9879     root   0.00         (msgdeque) 
 *14 s   9879     root   0.00         (msgdeque) 
 *15 s   9879     root   0.00         (msgdeque) 
 *16 s   9879     root   0.00         (msgdeque) 
 44f s  13103     root   0.00         (msgdeque) t_server.exe       <args N/A>
 * 1 S  13103     root   0.00         (msgdeque) 
 * 2 s  13103     root   0.00  2399648(event)    
 * 3 s  13103     root   0.00         (msgdeque) 
 * 4 s  13103     root   0.00         (msgdeque) 
 * 5 s  13103     root   0.00         (msgdeque) 
 * 6 s  13103     root   0.00         (msgdeque) 
 * 7 s  13103     root   0.00         (msgdeque) 
 * 8 s  13103     root   0.00         (msgdeque) 
 * 9 s  13103     root   0.00         (msgdeque) 
 * a s  13103     root   0.00         (msgdeque) 
 * b s  13103     root   0.00         (msgdeque) 
 * c s  13103     root   0.00         (msgdeque) 
 * d s  13103     root   0.00         (msgdeque) 
 * e s  13103     root   0.00         (msgdeque) 
 * f s  13103     root   0.00         (msgdeque) 
 *10 s  13103     root   0.00         (msgdeque) 
 45b s  22115     root   0.00  222c990(event)    telnet             <args N/A>
 4f4 s  13268     root   0.00  23dd520(event)    telnet             <args N/A>
 521 s  13313     root   0.00  21d86cc(wait)     ksh                <args N/A>
 540 S   1344   <root>   0.00  22e72d0(event)    rlogind            <args N/A>
 541 s   1345     root   0.00  22f8fdc(wait)     ksh                <args N/A>
 544 s  13348   <root>   0.00  22e6990(event)    rlogind            <args N/A>
 7b4 S   4972    atlas   0.00   5a6b98(pause)    swap_stats 
 7f4 S   5036    atlas   0.00  2384910(wait)     su 
 871 s   8161     root   0.00         (msgdeque) t_server.exe       <args N/A>
 * 1 S   8161     root   0.00         (msgdeque) 
 * 2 s   8161     root   0.00  2330868(event)    
 * 3 s   8161     root   0.00         (msgdeque) 
 * 4 s   8161     root   0.00         (msgdeque) 
 * 5 s   8161     root   0.00         (msgdeque) 
 * 6 s   8161     root   0.00         (msgdeque) 
 * 7 s   8161     root   0.00         (msgdeque) 
 * 8 s   8161     root   0.00         (msgdeque) 
 * 9 s   8161     root   0.00         (msgdeque) 
 * a s   8161     root   0.00         (msgdeque) 
 * b s   8161     root   0.00         (msgdeque) 
 * c s   8161     root   0.00         (msgdeque) 
 * d s   8161     root   0.00         (msgdeque) 
 8be s   5238   <root>   0.00  23dc4f0(event)    rlogind            <args N/A>
 8d2 S   5258   <root>   0.00         (msgdeque) /opt/dcelocal/bin/cdsclerk -U DN
 * 1 s   5258   <root>   0.00         (msgdeque) 
 * 2 s   5258   <root>   0.00  6545530(socket)   
 * 3 s   5258   <root>   0.00         (msgdeque) 
 * 4 s   5258   <root>   0.00  6352140(socket)   
 * 5 s   5258   <root>   0.00         (msgdeque) 
 * 6 S   5258   <root>   0.00         (msgdeque) 
 * 7 s   5258   <root>   0.00  6785a40(socket)   
 922 R   5338    atlas  93.22                    cda 
 963 S   5403     root   0.00  23f6618(event)    telnet doolie 
 96a s   5410   jsivak   0.00   5a6ba8(pause)    csh                <args N/A>
 97a s   5426   jsivak   0.00   4b3bdc(ttyin)    tset               <args N/A>
 9c9 s  11505     root   0.00  2373898(event)    telnet             <args N/A>
 a37 S   2615    atlas   0.00  21d8000(wait)     su 
 a50 S   2640   <root>   0.00  22b2868(event)    rlogind            <args N/A>
 a51 s   2641    atlas   0.00  23236a8(wait)     ksh                <args N/A>
 af5 s  11805   <root>   0.00  22e79c0(event)    rlogind            <args N/A>
 
 [Cpu0] (Dot is "0")  cda: 9>  $<swap
 Num         Swapfile  -  Free   Max
 [ 0]     /dev/ckd0-2  -   71M  128M
 
 [Cpu0] (Dot is "1")  cda:10>  $<vmstat
 Virtual Memory Statistics: (pagesize = 8192)
        1107   active pages
        2283   inactive pages
         227   free pages
        4575   wired pages
    42566029   virtual memory page faults
     9766315   copy-on-write page faults
     7670108   zero fill page faults
     3035702   reattaches from reclaim list
      989804   pages paged in
      339548   pages paged out
      989804   # of faults resulting in pageins
      339548   # of pageout operations (cluster)
      591616   number of object cache lookups
      586634   number of object cache hits
   172530753   thread context switches
    45204261   task context switches
    18921386   device interrupts
 [Cpu0] (Dot is "1000000")  cda: 1>  $<runq
 [  6220d0] Priority level:  0
 [  6220d8] Priority level:  1
 [  6220e0] Priority level:  2
 [  6220e8] Priority level:  3
 [  6220f0] Priority level:  4
 [  6220f8] Priority level:  5
 [  622100] Priority level:  6
 [  622108] Priority level:  7
 [  622110] Priority level:  8
 [  622118] Priority level:  9
 [  622120] Priority level: 10
 [  622128] Priority level: 11
 [  622130] Priority level: 12
 [  622138] Priority level: 13
 [  622140] Priority level: 14
 [  622148] Priority level: 15
 [  622150] Priority level: 16
 [  622158] Priority level: 17
 [  622160] Priority level: 18
 [  622168] Priority level: 19
 [  622170] Priority level: 20
 [  622178] Priority level: 21
 [  622180] Priority level: 22
 [  622188] Priority level: 23
 [  622190] Priority level: 24
 [  622198] Priority level: 25
 [  6221a0] Priority level: 26
 [  6221a8] Priority level: 27
 [  6221b0] Priority level: 28
 [  6221b8] Priority level: 29
 [  6221c0] Priority level: 30
 [  6221c8] Priority level: 31
 
 REPRODUCIBLE:
 unknown
 
 TEST SOFTWARE DESCRIPTION:
 The deadlock occurred while executing the baseunit named rpcd_epoint.
 It creates 20 pthreads and each one attempts to add 1000 endpoint map
 entries to the end point map database. The database had grown to
 ~12 meg at the time of the failure.
 
 DESCRIPTION OF HARDWARE WHERE BUG OCCURRED:
 sybil 2 processors
 
 DESCRIPTION OF WHERE TEST SUCCESSFULLY RAN:
 
Related-file::Retitled 950516 by wright:: some problem analysis
 The rpcd was spinning, with multiple threads in db_lock() attempting to
 lock the same mutex.  These were all cthread_call_executor threads.
 
 The owner of the mutex was yet another cthread_call_executor thread,
 but it was idle.
 
 My guess is that one of the executor threads got into an epdb_xxx
 routine and took a SIGSEGV due to some sort of corruption, while
 holding the db_lock.  Since the executor threads always set a
 TRY/CATCH_ALL before invoking the service routine (in opX_ssr), the
 exception would not cause the rpcd to die, but the lock would not be
 unlocked.  Even if the lock were unlocked, it may not be much of a
 solution, if memory corruption has already occurred.
 
 If this problem can be reproduced, I'd very much like to try it with
 rpcd running under sdb.
 
Related-file::Added 950606 by wright:: /build/hiosfm/RCS/dce/src/rpc/rpcd/./rpcddb.h,v 7.2
 /build/hiosfm/RCS/dce/src/rpc/rpcd/./rpcddb.h,v 7.2
 wright 1995/06/06 16:41:20 +8 -2
 Reason:  OSDqa11561 rpcd caught in a deadlock
 Replace single lock with a set of locks to avoid spinning during
 blocking system calls.
 
     *** /tmp/ci.19448..rpcddb.h.19485.1	Tue Jun  6 12:41:22 1995
     --- /tmp/rpcddb.h.19485.2	Tue Jun  6 12:41:22 1995
     ***************
     *** 111,121 ****
     --- 111,127 ----
        */
       struct db {
           dsm_handle_t        dsh;
           uuid_t              object;
           db_lists_mgmt_t     lists_mgmt;         /* entry, object, interface lists mgmt */
     + #ifdef hitm
     +     pthread_mutex_t     lock_m;             /* Database mutex lock */
     +     pthread_mutex_t     lock_a;             /* Database acquisition lock */
     +     pthread_cond_t      sleep;              /* sleep if lock busy */
     + #else
           pthread_mutex_t     lock;               /* Database mutex lock */
     + #endif
           pthread_t           sliv_task1_h;       /* Server liveness task 1 handle */
           pthread_t           sliv_task2_h;       /* Server liveness task 2 handle */
           pthread_cond_t      sliv_task2_cv;      /* Server liveness condition variable used by
                                                      sliv_task1 to send an event to sliv_task2 */
       };
 
Related-file::Added 950606 by wright:: /build/hiosfm/RCS/dce/src/rpc/rpcd/./rpcddb.c,v 7.2
 /build/hiosfm/RCS/dce/src/rpc/rpcd/./rpcddb.c,v 7.2
 wright 1995/06/06 16:45:31 +49 -2
 Reason:  OSDqa11561 rpcd caught in a deadlock
 Enhance db_lock/unlock to avoid having multiple threads spinning for
 long periods (these threads do stuff like fsync while holding the
 lock, and a mutex isn't a good choice for that).
 
     *** /tmp/ci.19523..rpcddb.c.19557.1	Tue Jun  6 12:45:33 1995
     --- /tmp/rpcddb.c.19557.2	Tue Jun  6 12:45:33 1995
     ***************
     *** 667,691 ****
     --- 667,738 ----
        */
       
       PRIVATE void db_lock(h)
       struct db *h;
       {
     + #ifdef hitm
     +     pthread_mutex_lock(&h->lock_a);
     +     while (pthread_mutex_trylock(&h->lock_m) == 0) {
     +         int prev;
     + 
     +         /* callers don't expect that they can be cancelled in here! */
     + 
     +         prev = pthread_setcancel (CANCEL_OFF);
     +         pthread_cond_wait(&h->sleep, &h->lock_a);
     +         (void) pthread_setcancel (prev);
     +     }
     +     pthread_mutex_unlock(&h->lock_a);
     + #else
           pthread_mutex_lock(&h->lock);
     + #endif
       }
       
       PRIVATE void db_unlock(h)
       struct db *h;
       {
     + #ifdef hitm
     +     pthread_mutex_lock(&h->lock_a);
     +     (void)pthread_mutex_unlock(&h->lock_m);
     +     (void)pthread_cond_signal(&h->sleep);
     +     pthread_mutex_unlock(&h->lock_a);
     + #else
           pthread_mutex_unlock(&h->lock);
     + #endif
       }
       
       PRIVATE void db_init_lock(h)
       struct db *h;
       {
     + #ifdef hitm
     +     pthread_mutex_init(&h->lock_a, pthread_mutexattr_default);
     +     pthread_mutex_init(&h->lock_m, pthread_mutexattr_default);
     +     pthread_cond_init(&h->sleep, pthread_condattr_default);
     + #else
           pthread_mutex_init(&h->lock, pthread_mutexattr_default);
     + #endif
     + }
     + #ifdef hitm
     + void
     + db_timedwait(pthread_cond_t *c, struct db *h, struct timespec *waketime)
     + {
     +     pthread_mutex_lock(&h->lock_a);
     +     pthread_mutex_unlock(&h->lock_m);
     +     pthread_cond_signal(&h->sleep);
     +     pthread_cond_timedwait(c, &h->lock_a, waketime);
     + 
     +     pthread_mutex_unlock(&h->lock_a);
     +     db_lock(h);
       }
       
     + void
     + db_cond_signal(pthread_cond_t *c, struct db *h)
     + {
     +     pthread_mutex_lock(&h->lock_a);
     +     pthread_cond_signal(c);
     +     pthread_mutex_unlock(&h->lock_a);
     + }
     + #endif
       
       /*  Map dsm error codes to ept error codes
        */
       PRIVATE void db_to_ept_ecode(status)
       error_status_t  *status;
 
Related-file::Added 950606 by wright:: /build/hiosfm/RCS/dce/src/rpc/rpcd/./rpcdsliv.c,v 7.3
 /build/hiosfm/RCS/dce/src/rpc/rpcd/./rpcdsliv.c,v 7.3
 wright 1995/06/06 16:46:45 +10 -3
 Reason:  OSDqa11561 rpcd caught in a deadlock
 Use new db_cond_signal and db_timedwait procedures, to integrate
 with revised db_lock functionality.
 
     *** /tmp/ci.19578..rpcdsliv.c.19613.1	Tue Jun  6 12:46:46 1995
     --- /tmp/rpcdsliv.c.19613.2	Tue Jun  6 12:46:46 1995
     ***************
     *** 259,269 ****
     --- 259,273 ----
       #endif
       
                       if (!server_listening)
                       {
                           entp->ncomm_fails++;
     + #ifdef hitm
     +                     db_cond_signal(&h->sliv_task2_cv, h);
     + #else
                           pthread_cond_signal(&h->sliv_task2_cv);
     + #endif
                       }
                   }
       
               }   /* end entry list loop */
       
     ***************
     *** 307,318 ****
                   waketime.tv_sec = now.tv_sec + waitsecs + 1;
                   waketime.tv_nsec = 0;
           
                   /*  release lock and wait for task2 event or timeout or cancel
                    */
                   pthread_cond_timedwait(&h->sliv_task2_cv, &h->lock, &waketime);
     !     
                   /*  have lock now
                    */
           
       #ifdef SNI_SVR4
                   gettimeofday(&now);
     --- 311,325 ----
                   waketime.tv_sec = now.tv_sec + waitsecs + 1;
                   waketime.tv_nsec = 0;
           
                   /*  release lock and wait for task2 event or timeout or cancel
                    */
     + #ifdef hitm
     +             db_timedwait(&h->sliv_task2_cv, h, &waketime);
     + #else
                   pthread_cond_timedwait(&h->sliv_task2_cv, &h->lock, &waketime);
     ! #endif    
                   /*  have lock now
                    */
           
       #ifdef SNI_SVR4
                   gettimeofday(&now);
 
Related-file::Added 950606 by wright:: /build/hiosfm/RCS/dce/src/rpc/rpcd/./dsm.c,v 7.2
 /build/hiosfm/RCS/dce/src/rpc/rpcd/./dsm.c,v 7.2
 wright 1995/06/06 16:48:27 +13 -5
 Reason:  OSDqa11561 rpcd caught in a deadlock
 In grow_file, if write fails, be sure to clean up dangling pointer
 at end of map chain.
 
     *** /tmp/ci.19634..dsm.c.19669.1	Tue Jun  6 12:48:29 1995
     --- /tmp/dsm.c.19669.2	Tue Jun  6 12:48:29 1995
     ***************
     *** 1098,1112 ****
       {
           unsigned long       grow_pages,grow_bytes;  /* number of pages, bytes to grow */
           block_t            *p = NULL;               /* new header */
           file_map_t         *map = NULL;             /* file map entry */
           long                flen;[tatsu_s 2/5/96 public]

I'm cancelling this because rpcd is not supported any more. Also, dce1.2.1
dced can be started as "rpcd".



CR Number                     : 12905
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : memory leak from not freeing data buffer
Reported Date                 : 6/6/95
Found in Baseline             : 1.1
Found Date                    : 6/6/95
Severity                      : B
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[01/01/93 public]
[David Stephenson 6/7/95 public]

[2/5/96 public]

I'm cancelling this because it's empty. Please resubmit it if necessary.



CR Number                     : 12898
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : dcedoc
Short Description             : Undocumented functions
Reported Date                 : 6/1/95
Found in Baseline             : 1.1
Found Date                    : 6/1/95
Severity                      : B
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/1/95 public]
I have not found documentation for the following functions although DFS
uses them:
.
  rpc_mgmg_set_call_timeout
  rpc_mgmt_set_server_com_timeout
  rpc_ns_set_authn
  rpc_server_create_thread_pool
  rpc_server_set_thread_pool_fn
  rpc_server_set_thread_pool_qlen
  rpc_server_free_thread_pool
  rpc__binding_inq_sockaddr
  rpc__dbg_set_switches
.
  utc_adjtime
.
  pthread_getunique_np
.
Likewise for the following macros:
.
  dce_exc_setjmp
  dce_exc_longjmp

[06/01/95 public]

Many of those functions are deliberately not part of the public API.
For example rpc__XXX, the thread pool stuff (see OT CR 10218), and
perhaps the exception-related stuff.

[1/15/96 public]

Updated subcomponent field.

[1/15/95 public]

If none of these APIs are public this CR should be cancelled.

[01/15/96 public]
I think these three are the only ones that should be documented, but I
would ask HP their opinion.
  rpc_mgmg_set_call_timeout
  rpc_mgmt_set_server_com_timeout
  rpc_ns_set_authn

[3/7/96 public]
Reassigned to Pam Millette.

[8/9/96 public]
Status changed to cancel.  This are routines are not part 
of the public API and should not be documented according to 
HP developers.



CR Number                     : 12818
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc/runtime/dds.c
Short Description             : rpc_s_no_memory is returned for getsockname() failure
Reported Date                 : 3/16/95
Found in Baseline             : 1.1
Found Date                    : 3/16/95
Severity                      : B
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/16/95 public]

In rpc/runtime/dds.c, rpc_s_no_memory is returned when getsockname() fails 
in function desc_inq_addr():

    if (getsockname((int) desc, &dds_addr->sa, &len) < 0)
    {
        RPC_MEM_FREE(dds_addr, rpc_c_mem_rpc_addr);
        RPC_MEM_FREE(vector, rpc_c_mem_rpc_addr_vec);
        *st = rpc_s_no_memory;
        return;
    }

Looks like a cut-and-paste was done and the author forgot to change the error
code.

[2/7/96 public]

Cancelled. dds.c has never be supported.



CR Number                     : 12807
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc runtime
Short Description             : src/test/rpc/runtime/perf testcase
fails using "udp" protocol sequence. Specfically Static Cancel Test 2,&3.
Reported Date                 : 2/27/95
Found in Baseline             : 1.0,1.1
Found Date                    : 2/27/95
Severity                      : C
Priority                      : 0
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/27/95 public]

A rpc testcase fails using "udp" protocol sequence.  This testcase is located
in the src/test/rpc/runtime/perf directory tree.  The actual tests are 
designated by "15a,15b,15c and 15d" in the shell script "perf_udp.sh". 
The names given to these tests in the client.c source are "Static 
Test Cancel1", "Static Test Cancel2" and "Static Test Cancel3". These tests
execute different cancel scenarios by sending a canceto the thread
executing the remote procedure. These testcases fail due to the cancel still
pending after the call to the remote procedure. These testcases run 
successfully using "tcp" protocol sequence.

For the testcase to succeed,  
the client should detect the cancel and forward a cancel packet to the server.
For "udp" the client checks for cancel in the rpc__dg_call_transmit_int
function.  Once the client reaches this function, the flow of execution
will never reach the CHECK_CANCEL macro.  Even if the macro is introduced
into the flow, "cancel_check" will not be executed since the fragment number
is zero. 

One solution is to introduce a call to the "cancel_check" function in 
rpc__dg_call_transmit_int.  The location of this cancel_check, will be before
returning, but after checking the value of "end_of_data" (approx. line 453-
454).  The modification is provided below:

  +453          if (end_of_data) {
		    cancel_check(call);
  +454              return;
		   }

A question arises whether the testcase is incorrect in assuming a cancel will be
detected and forward to the server, when the amount of data sent to 
the server is small (less than 64 frags) ?? Another question is whether
the results of the testcases should be consitent independent of which
protocol sequence used???  (Remember this same testcase succeeds using "tcp")

[3/1/95 public]

The above code may do what you want, but you are actually introducing an
addidional cancellation point to fix the broken test.

First of all, the perf static cancel test is broken. It has a couple of
potential cancellation points in both sides of RPCs which may jeopardize
the test. (Timing sensitive.) Even after fixing these, it's hard to make it
do the right thing.

Secondly, what you have seen is caused by the CMA's recvmsg() wrapper.
dce1.1 introduced the private client socket, which makes the client call
thread to call cma_recvmsg() instead of pthread_cond_wait(). Unfortunately,
cma_recvmsg() does not deliver the exception unless recvmsg() returns
EWOULDBLOCK. Thus, the runtime doesn't detect the cancel if there is
something to read. (By increasing the sleep second, you can pass the static
cancel test 2 and 3.)  If you turn off the private client socket, the
runtime will detects the cancel because pthread_cond_wait() is a real
cancellation point (that is CMA always deliver a pending exception). I
think that we can't blame the CMA's behavior until the pthread standard
gets finalized.

There is no need to introduce an additinal cancellation point. Even if you
do, there is no guarantee that the cencel gets raised in the server
manager. The network delay, etc., could easily cause the miss of the
cancellation points in the server manager, though the rpc runtime is trying
hard to preserve the local cancel semantics. (In the above case, by the
time when the client call thread called cma_recvmsg(), the server finished
the call. And this can happen with the shared socket if the listener thread
receives a response before the client call thread calls
rpc__dg_call_receive_int().)

The CN client call thread calls pthread_cond_wait() if a response is not
received by the receiver thread yet.

[2/7/96 public]

Cancelled. Nothing is broken (extra cancellation points are removed from
the perf test in dce1.2.1). You just need to sleep long enough to
accommodate delays.



CR Number                     : 12705
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : dce1.1-Unintegrated rpc.mk - Malformed conditional (${TARGET_OS} == "HPUX")
Reported Date                 : 10/22/94
Found in Baseline             : 1.1
Found Date                    : 10/22/94
Severity                      : A
Priority                      : 0
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/22/94 public]


Platform - HPUX - dce1.1 unintegrated
Nightly build failed with following error:

Extracted from

[ /rpc/kdes at 20:05 (PM) Friday ]
makepath kdes/. && cd kdes &&  exec make MAKEFILE_PASS=THIRD     build_all
kdes: created directory
"/project/dce/build/unintegrated-snap/src/rpc/rpc.mk", line 352: Malformed condi
tional (${TARGET_OS} == "OSF1")
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.std.mk", line 660: Malforme
d conditional (${TARGET_OS} == "HPUX")
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.std.mk", line 1246: if-less
 endif
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.std.mk", line 1246: ".endif
" unrecognized input
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.lib.mk", line 91: Malformed
 conditional (${TARGET_OS} != "HPUX")
sh: HPUX: not found
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.lib.mk", line 91: ""HPUX""
returned non-zero
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.lib.mk", line 92: Unassocia
ted shell command "${_RANLIB_} ${.TARGE"
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.obj.mk", line 136: Malforme
d conditional (${TARGET_OS} == "HPUX")
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.rules.mk", line 57: if-less
 endif
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.rules.mk", line 57: ".endif
" unrecognized input
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.rules.mk", line 70: if-less
 endif
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.rules.mk", line 70: ".endif
" unrecognized input
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.rules.mk", line 72: if-less
 endif
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.rules.mk", line 72: ".endif
" unrecognized input
Fatal errors encountered -- cannot continue
*** Error code 1
`build_all' not remade because of errors.
*** Error code 1
[ /dce/utils/svc at 20:05 (PM) Friday ]
makepath dce/utils/svc/. && cd dce/utils/svc &&  exec make MAKEFILE_PASS=THIRD
   build_all
make: don't know how to make build_all (continuing)
[ /dce/utils/dcecf at 20:05 (PM) Friday ]
makepath dce/utils/dcecf/. && cd dce/utils/dcecf &&  exec make MAKEFILE_PASS=THI
RD     build_all
make: don't know how to make build_all (continuing)
[ /config at 20:05 (PM) Friday ]
makepath config/. && cd config &&  exec make MAKEFILE_PASS=THIRD     build_all
make: don't know how to make build_all (continuing)
[ /time at 20:05 (PM) Friday ]
makepath time/. && cd time &&  exec make MAKEFILE_PASS=THIRD     build_all
"/project/dce/build/unintegrated-snap/src/time/time.mk", line 198: Malformed con
ditional (${TARGET_OS}=="OSF1")
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.dce.mk", line 348: Malforme
d conditional (${TARGET_OS} != "HPUX")
sh: HPUX: not found
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.dce.mk", line 348: ""HPUX""
 returned non-zero
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.std.mk", line 660: Malforme
d conditional (${TARGET_OS} == "HPUX")
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.std.mk", line 662: if-less
else
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.std.mk", line 662: ".else"
unrecognized input
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.std.mk", line 666: if-less
endif
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.std.mk", line 666: ".endif"
 unrecognized input
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.std.mk", line 666: if-less
endif
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.std.mk", line 666: ".endif"
 unrecognized input
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.std.mk", line 1246: if-less
 endif
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.std.mk", line 1246: ".endif
" unrecognized input
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.rules.mk", line 72: if-less
 endif
"/project/dce/build/unintegrated-snap/src/lbe/mk/osf.rules.mk", line 72: ".endif
" unrecognized input
Fatal errors encountered -- cannot continue
*** Error code 1

[10/22/94 public]
Yesterday the problem had shown even though no new files were submitted.
The build is clean today.  I am cancelling the OT.



CR Number                     : 12692
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : under very heavy load DG leaks memory.
Reported Date                 : 10/20/94
Found in Baseline             : 1.1b16
Found Date                    : 10/20/94
Severity                      : C
Priority                      : 3
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/20/94 public]

I ran a server supporting a very simple interface (a single operation with
the manager code returning immediately). I then simultaneously started four
tight loops from the shell each executing a client program calling the
server over ncadg_ip_udp at each iteration.  The four loops ran for 1000
iterations each. I noticed at the end of the run that the memory use of the
server had increased by a little over a meg. I also collected pkt
information from the server and at the end of the run pkts (as reported by
pkt_alloc()) is 99738. With a start value of 100000 minus the 32 pkts
allocated initially it seems that during the run the server allocated
another 230 pkts at 4472 bytes a piece for roughly my missing meg. It also
seems that pkts are never deallocated. If this is indeed the case why is
it? This does not seem to be a problem under "normal" conditions but the
leak is relatively severe under heavy load (as described here).

By the way this is as much a "bug" report as it is a question so I would
very much appreciate an (even brief) explanation as soon as any of the
RPC/DG people finds a second (or two ;)).

(By the way I ran this with 1.1b1? on both an hp and a rios).

Thanks!

[10/20/94 public]

Without knowing how the memory (VM or in-core?) use is measured, it's hard
to answer. However, DG runtime never free() packet buffers, instead they
are kept in rpc_g_dg_pkt_pool.free_list . At the startup, 48 (32 for
pre-dce1.1) pkt buffers are allocated and linked to
rpc_g_dg_pkt_pool.free_list . rpc_g_dg_pkt_pool.free_count and
rpc_g_dg_pkt_pool.pkt_count are set to 48 and 1000000-48 respectively.
rpc_g_dg_pkt_pool.free_count+rpc_g_dg_pkt_pool.pkt_count never exceeds
100000. If you saw "(pkt_alloc) pkts 99738", that means 100000-99738 pkts
were in use. Those 262 pkts would probably been returned to free_list, if
you had waited long enough to see "(pkt_free) pkts 1000000".

[10/20/94 public]

(Thanks)

I meant in-core memory. My question, may be a little unclear, was exactly
for an explanation of why the DG runtime never free() packet buffers. Is
there, for example, a high probability that the pool never gets too large?
For example, I noticed that in one of my test the number of packets in use
seem to stabilize even under heavy load. On the other hand, I am running
another test right now where I've loaded the server even more and the
packet buffer usage has yet to stabilize.

[10/21/94 public]

I'm closing the ticket. Even under sustained very heavy load the buffer
usage eventually stabilizes (e.g. ~300 receive buffers for a sustained
average rate of 8 rpc/sec (I guess roughly corresponding to the peak
receive rate)). Thanks for the help.



CR Number                     : 12514
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : dg
Short Description             : problems with who_are_you2()
Reported Date                 : 10/5/94
Found in Baseline             : 1.1b20
Found Date                    : 10/5/94
Severity                      : B
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/5/94 public]

VTS has couple of tests which are getting into problem
with who_are_you2().

Summary:
	Always remote comm failure Fault PDU is received.


scenario 1:
	VTS acts as a CL client and RPC acts as CL server.

	VTS sends an idemp request to runtime. [seqnum=0;boottime=0];

	VTS receives a call back2 request from callback thread.
	VTS sends the callback response to callback thread with 
	status=0; seqnum=0; client actid.

	VTS receives a fault PDU immediately from the main thread.

scenario 2:
	VTS acts as a CL client and RPC acts as CL server.

	VTS sends an non-idemp request to runtime. [seqnum=0;boottime=0];

	VTS receives a call back request from callback thread.
	VTS sends the callback response to callback thread with 
	status=0; seqnum=0;

	VTS receives a call back2 request from callback thread.
	VTS sends the callback2 response to callback thread with 
	status=0; seqnum=0; client actid.

	VTS receives a fault PDU immediately from the main thread.

These tests used to work fine with 1.0.3; but now these tests fail.
Anybody know of any undocumented protocol features added to conv_mgr
protocol?

[10/5/94 public]
We need to look at this ASAP.  
We have been seeing mysterious comm failures and this may be the cause.
See OT 12315 for details on them.

Raising to an A0 and assigning to HP.
Please respond with an ACK that someone is working on this.

[10/6/94 public]

I don't understand the justification for making this an A0 bug, since it's
never been seen by anything other than the VTS tests.  (In particular, all
of the context handle tests run fine when run on a real client and server.)

Also, WAY2 calls are only made in support of context handles, and there are
no context handles being used in the failed calls described in OT 12315, so
I don't see any connection.

Either there's a bug in the VTS client, or there's a bug in the runtime that
doesn't manifest itself during calls between clients and servers built on top
of the reference implementation.  Either way, it's not an A0.

Is it possible to build the DCE client side of the test that's failing?  If
so, it would be interesting to see if it can talk to the DCE server.  If it
can't, then there's a bug in the runtime.  If it can, then compare what's
being sent from the VTS and DCE clients, and see where they differ.

We'll be happy to help out with this problem, but for the moment we're 
assuming that Tom is driving.

[10/6/94 public]
Lowering this to a B1, we can invetigate if we have time, but it
does not appear that this is causing 12315 (see Marks comments).

It is still a VTS failure, however, and should not be ignored.
Assigning to Prassad to investigate further next week as he
is the VTS expert.

[10/6/94 public]
I'm not familiar with the code - is it possible that this error is
affecting DFS to cause:

AFS_SetContext(sarpa.osf.org) fails: Communications failure (dce / rpc)

[10/6/94 public]

No. rpc_s_comm_failure is different from rpc_s_fault_remote_comm_failure.

This OT should be re-assigned to VTS because it is caused by the
programming error in VTS. VTS as a DG client is trying to use a
non-existing context. Also, probably the server manager routine is
returning the NULL context. If this was working at 1.0.3, then libidl was
broken.

[10/6/94 public]
I think I found the problem:

previously in the tests, the context handle was created using
an input/output parameter with NULL value. [See the Application
Development Guide 17.14.9.3 'Creating New Context'].

I changed the tests to use an extra operation with an output parameter
to get the context and then use the context obtained from the operation
in the later operations. In this way I could get rid of the original problem. 

So now should I cancel this OT? Is the Application Dev Guide wrong?

[10/18/94 public]

When using [in,out,context_handle], does the server manager routine returns
the non-NULL context? To create the context using [in,out,context_handle],
the client must make an RPC with a NULL context and the server manager
routine must return the non-NULL context for the subsequent use of it. To
destroy the context, the client must make an RPC with the existing
(non-NULL) context and the server manager routine must return the NULL
context. The non-NULL in/out means updating the existing context. Lastly
the NULL in/out is valid only when the client created the NULL context
(nil-UUID) before with [out,context_handle] which is not the case with VTS.

[2/5/96 public]

I'm cancelling this because it's a VTS bug which might be fixed already
given the above comment. Please resubmit it against VTS if necessary.



CR Number                     : 11957
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : EXPDIR not defined in rpc/kdes/Makefile for export pass.
Reported Date                 : 8/30/94
Found in Baseline             : 1.1
Found Date                    : 8/30/94
Severity                      : D
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/30/94 public]

Tom,
   Please check the file /rpc/kdes/Makefile.  It is trying to export some 
files while not definine EXPDIR in the Makefile.  The result is that they are 
put in a place that is inaccessable to your builds.


[ /rpc/kdes/Makefile ]
*** makefile error: :Can't export libkdes.a because EXPDIR is not defined in the Makefile.

[8/31/94 public]
Double checked Makefile, libkdes.a_EXPDIR is defined.
Canceled.



CR Number                     : 11914
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : backwards compat broken by show mapping format chg
Reported Date                 : 8/26/94
Found in Baseline             : 1.1
Found Date                    : 8/26/94
Severity                      : A
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/26/94 public]
I'm unable to configure a 1.0.3a security client to a 1.1 
security server.  The problem appears to lie in a format 
change in the output from rpccp show mapping.  103a 
dce_config awks through this output to populate the pe_site 
file with the address of the security server.  Since the 
format has changed, 103a dce_config can't find the interface 
id for the security server.  Here's the old and new output:

NEW:
  <object>         371f8d5e-c02e-11cd-8d58-080009247863
  <interface id>   4c878280-5000-0000-0d00-028714000000,1.0
  <string binding> ncacn_ip_tcp:130.105.4.201[1046]
  <annotation>     DCE user registry

OLD:
  <object>         0080852c-ef9e-1c7c-9169-08005a0d4582
  <interface id>   4c8782805000.0d.00.02.87.14.00.00.00,1.0
  <string binding> ncacn_ip_tcp:130.105.4.200[1039]
  <annotation>     DCE user registry

Notice the new display uses dashes while the old uses dots
in the interface id.  Looks like the new display has extra
zeroes in the interface id display as well.  Someone changed 
1.1 dce_config to look for dashes now which is why it works 
using the 1.1 dce_config.

[08/26/94 public]
I believe Tom chainged uuid_to_string.

[8/26/94 public]
Why, yes I did. From a defect (10052) filed by one of our chief
architects, Walt Tuvell, who should now defend my action
as being the right way because he said so...

[08/26/94 public]
I just thought of something -- are you using new rpccp and old dce_config?
If so, cancel this.

[8/26/94 public]

You must be using the 1.0.3 rpccp with the 1.1 shared libdce or the 1.1
rpccp with the 1.1 shared libdce since the uuid_to_string change is in the
library. Here is the example diff from "rpccp show mapping ip:dce_rpc":
(dce_rpc is at 1.1, the line "-" on 1.0.3 client and the "+" on 1.1)

   <object>         1340c542-c047-11cd-92a8-08000912c4f1
-  <interface id>   4c8782805000.0d.00.02.87.14.00.00.00,1.0
+  <interface id>   4c878280-5000-0000-0d00-028714000000,1.0
   <string binding> ncacn_ip_tcp:15.22.50.65[1061]
   <annotation>     DCE user registry

[8/26/94 public]
It's not what I intended, but I had old dce_config and new rpccp.
Looks like my /opt/dce symlink was never updated during dce_config
install.  It continues to point to /opt/dce1.1 which points to a 
1.1 install tree.  So my 1.0.3a dce_config session setup 
/opt/dce1.0 which points to a 1.0.3a install tree, but then 
proceeded to reference binaries through /opt/dce.  The result was 
I got 1.1 binaries while using a 1.0.3a dce_config and specifying 
a 1.0.3a install tree.  Looks like there's code in 1.0.3a 
dce_config to handle updating the /opt/dce symlink, but it didn't 
work for me.. Do we care?

[8/26/94 public]
OK, I tracked it down to the exact line with the problem
in dce_config.  Tom already fixed it in 1.1 dce_config.  
Since we don't expect customers to be installing 1.0.x over 
1.1 (at least we hope), this is not really important enough 
to care about.  Cancelled.  What a colossal waste of time...



CR Number                     : 11858
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rpc_string_binding_parse core dumps
Reported Date                 : 8/24/94
Found in Baseline             : 1.1
Found Date                    : 8/24/94
Severity                      : B
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/24/94 public]

Starting today I am periodicly getting a core dump from 
rpc_string_binding_parse. I am on a 486 running last nights build.
I am calling this with a pathname not a string binding. In this
particular instance I am passing in the fullpath to the security 
registry site. (/.../mpt/subsys/dce/sec/master)

Here is the gdb backtrace. 
#0  0xa40037c8 in malloc (1)
#1  0xa417ea94 in cma_lib_malloc (1)
#2  0xa41cca29 in rpc__mem_alloc (1, 52, 0)
#3  0xa41d3356 in rpc_string_binding_parse
    (5289540, -1073757944, -1073757948, -1073757952, -1073757956, -1073757960, -1073757912)
#4  0x493a09 in dcp_binding_string_to_tcl (
    str=0x50b644 "/.../mpt/subsys/dce/sec/master", rpc_status=0xbfffc128)
    at /project/dce/build/dce1.1-snap/src/admin/dcecp/util_binding.c:67
#5  0x422c7c in open_rgy_site (interp=0x57e0b0, name=0x432b54 "/.:", 
    access=site_update)
    at /project/dce/build/dce1.1-snap/src/admin/dcecp/rgy_utils.c:706
#6  0x43309b in dcp_rgy_sa_connect (clientData=0x0, interp=0x57e0b0, argc=2, 
    argv=0x57df28)
    at /project/dce/build/dce1.1-snap/src/admin/dcecp/rgy_sa_tclif.c:384
#7  0x4030d5 in dcp_registry (clientData=0x0, interp=0x57e0b0, argc=16, 
    argv=0x57df28)
    at /project/dce/build/dce1.1-snap/src/admin/dcecp/commands.c:1397
#8  0x4b264d in Tcl_Eval (5759152, -1073743584)
#9  0x4c4c2f in Tcl_RecordAndEval (5759152, -1073743584, 0)
#10 0x40079f in main (argc=1, argv=0xbffffa1c)
    at /project/dce/build/dce1.1-snap/src/admin/dcecp/main.c:421

[8/24/94 public]

This has actually started to move around. Something somewhere else
is apparently stompping on memory...



CR Number                     : 11697
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : rpc/runtime/i18n_api/ts/cs_eval/cs_byte/method_fixed.c
Short Description             : loc_string' undeclared
Reported Date                 : 8/15/94
Found in Baseline             : 1.1
Found Date                    : 8/15/94
Severity                      : A
Priority                      : 0
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/15/94 public]

/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/method_fixed.c:190: `net_string' undeclared (first use this function)
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/method_fixed.c:191: `loc_string' undeclared (first use this function)
*** Error code 1

[8/15/94 public]
Unable to reproduce, probably a result of disk space problems.



CR Number                     : 11696
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : /test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c
Short Description             : `in_size' undeclared
Reported Date                 : 8/15/94
Found in Baseline             : 1.1
Found Date                    : 8/15/94
Severity                      : A
Priority                      : 0
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/15/94 public]

dce1.1-snap/export/at386/usr/lib    -ldce -lc -ltettcm -ltetapi   /project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c:32: parse error before `net_byte'
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c: In function `cs_fixed_trans':
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c:37: `SIZE' undeclared (first use this function)
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c:37: (Each undeclared identifier is reported only once
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c:37: for each function it appears in.)
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c:41: `in_string' undeclared (first use this function)
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c:52: `out_string' undeclared (first use this function)
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c: At top level:
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c:65: parse error before `net_byte'
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c: In function `cs_conf_trans':
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c:73: `in_size' undeclared (first use this function)
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c:79: `in_string' undeclared (first use this function)
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c:90: `out_string' undeclared (first use this function)
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c: At top level:
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c:107: parse error before `net_byte'
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c: In function `cs_conf_vary_trans':
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c:115: `in_size' undeclared (first use this function)
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c:121: `in_string' undeclared (first use this function)
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c:132: `out_string' undeclared (first use this function)
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c: At top level:
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c:148: parse error before `net_byte'
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c: In function `cs_vary_trans':
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c:153: `SIZE' undeclared (first use this function)
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c:162: `in_length' undeclared (first use this function)
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c:165: `in_string' undeclared (first use this function)
/project/dce/build/dce1.1-snap/src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/cs_byte/manager.c:175: `out_string' undeclared (first use this function)
*** Error code 1

[8/15/94 public]
Unable to reproduce, probably a result of disk space problems.
Canceled.



CR Number                     : 11683
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : port_gd
Short Description             : Need detailed explanation for RPC_DEBUG env var.
Reported Date                 : 8/12/94
Found in Baseline             : 1.1
Found Date                    : 8/12/94
Severity                      : C
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/12/94 public]

Customer reported:

     "In order to gather DEBUG information from the RPC component, one must
     set the RPC_DEBUG environment variable from 1-25, with various levels
     between 0 and 255 for each flag.  However, some of these flags have
     undocumented minimum (and probably maximum) values.  One in particular
     that I ran into is flag number 18, rpc_e_dbg_pkt_quota_size.  If I set
     this flag to a value of less than 100, I could not get the TCP perf
     test to run.

     If we could be given a range of valid flag ranges, as well as whatever
     interdependencies there are between flags, it would be most appreciated.
"

[8/15/94 public]
A few points:

 - the RPC_DEBUG variable is for internal (and possibly external)
   debugging only.  Thus, if you need to know what its limits are
   and how to use a specific function, you look at the code.

 - The RPC_DEBUG facility for 1.1 has been converted to use serviceability
   thus, it ranges (1-9) and facilities (use dcecp log command) are
   now 'well known', and again, if you want specifics, you are
   certain to have access to the code base.

I don't believe that with the limited resources we have left, 
that spending much time documenting this (unsupported) debug 
interface is worthwhile.

[08/23/94 public]
Canceled this CR.  The Serviceability debugging facility is
now explained for each component in the Porting Guide, including
RPC.  Enabling RPC debugging output is also included in the explanation.



CR Number                     : 11198
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc/cn
Short Description             : cache a binding to ep map
Reported Date                 : 7/7/94
Found in Baseline             : 1.1
Found Date                    : 7/7/94
Severity                      : D
Priority                      : 4
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/7/94 public]

Under some circumstances it might make sense for the client runtime
to keep a binding handle open to the EP map on a remote host.  Not sure
WHEN it would make sense to do this, other then for faster benchmarking,
but it might make sense.

[7/7/94 public]

You mean "keep an association open to the EP mapper". It's really a server
(EP mapper) runtime who decides when the association gets shutdown.
Currently, it takes at most 30 seconds (10~30) for the open association to
get closed. (So, if the client keeps calling ep_resolve() (or others) every
10 seconds, the association stays open.) Also, keeing an association open
means keeping its receiver thread around. How many receiver threads would
you like to have in the EP mapper? :-) (Of course, if CN had a listener
thread instead of receiver threads...)

[8/30/94 public]
Sounds like this would hurt more than help.
Canceled.



CR Number                     : 11147
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl encoding services
Short Description             : wrong handle type
Reported Date                 : 6/30/94
Found in Baseline             : 1.1
Found Date                    : 6/30/94
Severity                      : B
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/30/94 public]

When using IDL encoding services the generated functions (as spelt into
the cstub and header file) expect a handle_t as their first parameter.
They should be expecting an idl_es_handle_t.  Right now you get compiler
warnings.

[7/7/94 public]
It would be helpful to have an example of what should
be changed (the genereated source).  I don't have the faintest idea
of where to start looking for this code in idl.

Any help from Rico would be appreciated.

[07/08/94 public]

It looks like it was user-error.  I had checked out the IDL file but
not the ACF file.  Danger, Will Robinson -- DONT DO THAT.
Cancel.



CR Number                     : 11131
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpcd
Short Description             : portability change to dsm_p.h
Reported Date                 : 6/29/94
Found in Baseline             : 1.1
Found Date                    : 6/29/94
Severity                      : B
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : dsm_p.h
Sensitivity                   : public

[6/29/94 public]

Currently PREHEADER is defined as:

  #define PREHEADER   16                  /* length of preheader */

A more portable definition would be:

  #define PREHEADER   (sizeof(block_t)-sizeof(double)) /* length of preheader */

The above change is needed to make rpcd work on systems that have longs
greater than 32 bits.

[06/29/94 public]
dsm_p.h is part of rpcd which will be moving to nosupport for 1.1.
dced does not have this problem, it doesn't use DSM.
I think this can be cancelled.

[6/29/94 public]
Rich is correct, rpcd is no longer supported in 1.1.
But thanks for pointing this out!
Canceled.



CR Number                     : 11051
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 10852
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : Auth rpc (privacy)
Short Description             : rpc runtime fails in WAY AUTH when using protection level of privacy
Reported Date                 : 6/22/94
Found in Baseline             : 1.0.3
Found Date                    : 6/22/94
Severity                      : A
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/22/94 public]

I'm creating a new CR because DCE 1.0.3 licensees with support contract
are entitled to bug fixes for bugs that exists in DCE 1.0.3 but being
fixed in DCE 1.1.

More information related to this bug can be found in OT #10852. A summary
of problem I am seeing is as follows derived from OT 10852:

> [parul 6/21/94 public]
> 
> I think I can tell why this problem has never showed up before despite
> being present. There are two tests that can produce a problem that I
> feel is related to this one.
> 
> 1) Functional test: run  the rpc perf test with packet privacy option
>    enabled when using DG protocol. This test fails for cases# 7
>    (Unregistered interface test) and #8 (Forwarding test). With my
>    analysis so far, I can see that when the client tries to respond
>    to a WAY AUTH it gets 'unknown reject' error:
> 
> (rpc__dg_call_start) rcvbuf 32768, ws 16
> (conv_stub_who_are_you_auth) Thinking about responding to WAYAUTH callback
> (rpc__dg_call_transceive) unblocking serialized waiters...
> (rpc__dg_do_reject) Got a live one [3947a3e0-8d0d-1d1d-bc42-0000c0ea4f78, 1.0]
> (rpc__dg_call_signal_failure) CCALL st = 0x16c9a060 (orig st = 0x0) [3947a3e0-8d0d-1d1d-bc42-0000c0ea4f78, 1.0]
> *** Unknown exception raised
> Exception: unknown reject (dce / rpc)
> 
> 2) System tests: run the rpc.cds.3 test with the protection level set to
>    privacy. It always fails trying do its fourth call.
> 
> Does OSF or anybody else run these tests with specified options? If this is
> pointing to a different problem then we should reopen this OT or create a
> new one.
> 
> Where can I find the fix that I can apply to SNI DCE 1.0.3 code?

As per HP this problem is fixed in 1.1 and we would like to have the
1.0.3 version of fix made available to us.

[6/22/94 public]

I finally got a list of bugs that I need to get fix for:

OT# 9551, 8643, 9614, 10444, and if possible 8053 & 7465.

[6/27/94 public]
OSF development does not provide back patch fixes for defects
that are fixed in the next release.  You must go through 
OSF System Engineering (assuming you have a support license) to request
these kind of fixes.  They might be able to assist you.



CR Number                     : 10904
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : nidl_to_idl
Short Description             : couldn't install nidl_to_idl
Reported Date                 : 6/8/94
Found in Baseline             : 1.1b9
Found Date                    : 6/8/94
Severity                      : C
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/8/94 public]

I took the AT386 install tree from AFS (/afs/dce/project/dce/build/dce_temp)
(last night's build) and started dce_config. All worked fine except :

Optional Utilities:

2. nidl_to_idl

I got: cp: /opt/dce/bin/nidl_to_idl: No such file or directory
Can't create file /opt/dcelocal/bin/nidl_to_idl
Ensure no DCE daemons are running
        Press <RETURN> to continue, CTRL-C to exit: 

I think nidl_to_idl was not in the install tree as it should be.

[6/8/94 public]
nidl_to_idl is only built when the Makefile variable
NO_COMPAT_NCS15 is not defined.

For DCE1.1, we define this variable.

from src/rpc/idl/Makefile:
# 
# NO_COMPAT_NCS15 is set in rpc.mk which is included in RULES_MK above.
# Therefore this test must be AFTER the above include.
# NO_KRPC is meant as an environment variable so it can be above the .include
#

.ifndef NO_COMPAT_NCS15
COMPAT_SUBDIRS  = nidl_to_idl
.endif

Bug canceled.



CR Number                     : 10689
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : nsi
Short Description             : rpc_ns_binding_export should test for the object if the rpc__nsentry_create fails
Reported Date                 : 5/18/94
Found in Baseline             : 1.0.3
Found Date                    : 5/18/94
Severity                      : B
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/18/94 public]

Configuration:

        system 1: sec master, cds master, dts server
        system 2: sec replica, cds replica, dts server
        system 3: dce client

        Replicated directories:

                /.:/
                /.:/hosts
                all dir under the above
                /.:/subsys/dce/sec

Shutdown DCE on system 1 and restart the DCE daemons on system 3.
When dtsd is trying to configure (dtscp set type clerk), it tries
to export its ACL Mgr  binding to the namespace.  It fails because
the master CDS server is not available.  The entry is available from
the CDS replica server.

The rpc_ns_binding_export function will not fail if the entry it is trying
to create already exists in the namespace and the data is available
in some CDS replica server.  If the call to rpc__nsentry_create fails,
rpc_ns_binding_export should try to do a read on the entry to see if
it already exists.  If it does, then the function should return success;
otherwise it should return the failure status from rpc__nsentry_create.

[5/18/94 public]
Interesting situation. I am assuming that by 'return success' you mean
rpc_ns_binding_export should continue on with its job.  Can we export
things to an entry if we have only replica servers available?  We can't
assume that just because the entry exists, it contains the correct
exported bindings.  In fact, the 1.1 dtsd is very careful to unexport
its bindings on shutdown.

Assuming we *can* export bindings to a replica cds server,
a possible fix for this would be in nsbndexp.c:

old:
    /*
     * Create entry -- it's ok if it already exists.
     */
    rpc__nsentry_create (nsentry, status);
    if ((*status != rpc_s_ok) &&
        (*status != rpc_s_entry_already_exists))
    {
        rpc__nsentry_free (&nsentry, &temp_status);
        return;
    }


new:
    /*
     * Create entry -- it's ok if it already exists.
     */
    rpc__nsentry_create (nsentry, status);
    if ((*status != rpc_s_ok) &&
        (*status != rpc_s_entry_already_exists))
    {
        /*
         * Create won't return already_exists if master server is down
         * Check replica's. (probably slow)
         */
	if (!rpc__nsentry_exists(nsentry, status)
        {
            rpc__nsentry_free (&nsentry, &temp_status);
            return;
        }
    }

[5/18/94 public]
Any feedback on this would be good.

[5/18/94 public]

What you are proposing sounds ok.  I do not know if you can export 
bindings to a replica cds server (I will defer this to Janet).

[5/23/94 public]

No, you can't write on replicas.

Could it be that they are asking for the following behavior:

    try to create the directory
    it fails because the master server is down
    look for a replica of the directory
    look for the entry that you were about to write
    if the entry already contains the information you wanted to write,
          report success.

In most cases, this would do just what you want.

[5/23/94 public]

The above algorithm is what I had originally thought should be done, but
I was not sure on the exporting bindings to the CDS replica.  I should
have made the original description more clear.

[8/29/94 public]
I am going to re-classify this as an enhancement, which I feel it really is.
This, however, is only a nit since this will not make it in to DCE 1.1,
but perhaps we can get it on the list early for 1.2

[2/7/96 public]

Cancelled. Even if you follow the above algorithm, there is no guarantee
that the entry in replica is up-to-date.



CR Number                     : 10511
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : dcerpcrun
Short Description             : dcerpcrun failes when running using the UPD protocol.
Reported Date                 : 5/3/94
Found in Baseline             : 1.1
Found Date                    : 5/3/94
Severity                      : A
Priority                      : 0
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/3/94 public]


Using BL8

The test dcerpcrun fails on all the three reference platforms
using UPD.

Command run:

./run.rpc -l 1 -m "west dce3 soldier" -P ncadg_ip_udp dcerpcrun

++++
Error On AIX:

Getting test results from database.
cat: 0652-050 Cannot open /tmp/dcerpcrun/endpoint.
dumpDatabase[13]:  Unknown status 2ff7f270^J***FAILURE***: unexpected CMA exception rpc_x_invalid_binding: 0403-009 The specified number is not valid for this command.


++++
Error On OSF/1

Waiting for clientwrapper pid(s) to exit...


Getting test results from database.
cat: Cannot open /tmp/dcerpcrun/endpoint.
dumpDatabase[13]:  Unknown status bffff35c^J***FAILURE***: unexpected CMA exception rpc_x_invalid_binding: Syntax error

++++
Error On HP-UX

Waiting for clientwrapper pid(s) to exit...


Getting test results from database.
cat: Cannot open /tmp/dcerpcrun/endpoint.
dumpDatabase[13]:  Unknown status bffff35c^J***FAILURE***: unexpected CMA except
ion rpc_x_invalid_binding: Syntax error



CR Number                     : 10342
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 10342
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : uuidgen
Short Description             : Enhancements in the handling of command line options.
Reported Date                 : 4/13/94
Found in Baseline             : 1.0.2
Found Date                    : 4/13/94
Severity                      : E
Priority                      : 4
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rpc/idl/uuidgen/uuidgen.c
Sensitivity                   : public

[4/13/94 public]
Hitachi submitted an enhancement request which would make uuidgen
deal with options more strictly ("-h" would give help but "-help"
would be illegal as would be anything else that starts with "-h").

I think the appropriate enhancement would be to a) use a standard
getopt() or b) use a modified getopt() that accepts long option
names but checks that the option is an unambiguous substring of
a standard long form. In both cases, portability would be enhanced.
Both cases however would be more appropriately dealt with as general
cleanup items and would be out of the scope of 1.1.

[05/04/94 public]
Fixed in a mad fit of hacking one night:
 *      Use SAMS and getopt; general cleanup (OT CR 10342).
Using standard getopt in the standard way.
Cancelling.



CR Number                     : 10313
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : auditd returns unknown reject after multiple calls
Reported Date                 : 4/7/94
Found in Baseline             : 1.1
Found Date                    : 4/7/94
Severity                      : B
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/7/94 public]
The audit daemon returns 'unknown reject' after 5 or so RPC's from 
the control interface. I haven't had a chance to try and track this down yet.
Repeating the same command will cause it to fail as well as different commands. 

dcecp> audf s {principal salamone}
{all all dce_audit_filter_query}
{denial all dce_dts_mgt_modify}
dcecp> audf s {principal salamone}
{all all dce_audit_filter_query}
{denial all dce_dts_mgt_modify}
dcecp> audf s {principal salamone}
{all all dce_audit_filter_query}
{denial all dce_dts_mgt_modify}
dcecp> audf s {principal salamone}
{all all dce_audit_filter_query}
{denial all dce_dts_mgt_modify}
dcecp> audf s {principal salamone}
Error: unknown reject
dcecp> audf s {principal salamone}
Error: unknown reject

Let me know what I can do to help narrow this down.

[4/14/94 public]
By caching the binding to the server I was able to work around this
problem. Previously I was binding to the server and then
rpc_binding_free()'ing the binding when I was done (after each command). I
think that this should work too. Any ideas?

[7/18/94 public]
I don't think this is an audit problem.  From the description it seems 
something to do with rpc runtime.  I think I could bypass the problem
also if I would declare the audfilter show operation as idempotent.

[7/18/94 public]

Which protocol (DG or CN) dcecp was using? Was it authenticated or not? If
it was, which level? If it was DG with pkt_privacy, it might be fixed by
CR9614.

[7/19/94 public]
Since John seems to have no way to reproduce this,
and given the high possibility that has been fixed (OT9614).
Canceled.  Please re=open if able to reproduce.



CR Number                     : 10028
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : binding obj (auth)
Short Description             : rpc_binding_set_auth_info returns 
sec_rgy_object_not_found instead of rpc_s_no_princ_name
Reported Date                 : 2/28/94
Found in Baseline             : 1.0.3
Found Date                    : 2/28/94
Severity                      : C
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/28/94 public]

From the DCE Valdiation Test Suite CR #11 (use -pdce_vts):

> [rhw 12/8/93 public]
> 
> The c_auth_info assertion #23 fails with rpc_binding_set_auth_info()
> returning sec_rgy_object_not_found instead of the expected 
> KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN or the AES-specified 
> rpc_s_no_princ_name. The latter, rpc_s_no_princ_name, is not 
> provided by the implementation.
> 
> 

The code sec_rgy_object_not_found "bubbles up" from the underlying 
security service.

Also, the code rpc_s_no_princ_name is not implemented.

[9/1/94 public]

This is happenning because of a problem in VTS code [See VTS ot#36].
So cancel this bug.



CR Number                     : 10015
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Exceptions and statuses inconsistent?
Reported Date                 : 2/24/94
Found in Baseline             : 1.0.3a
Found Date                    : 2/24/94
Severity                      : D
Priority                      : 3
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/24/94 public]
It seems as though there are two status codes defined in dce/rpcsts.h
that are supposed to be associated with exceptions, but the corresponding
exceptions aren't declared in dce/rpcexc.h.  They are:
 
	rpc_x_cannot_set_nodelay
	rpc_x_no_ns_privilege
 
Is this an oversight, or is there something else going on here?

[05/04/94 public]
Will, could you please take a look at this while you are doing the
serviceability work on rpc.  I know you have been working with
the rpcsts* files.

[08/22/94 public]
These exceptions are declared and initialized in
src/rpc/idl/lib/sscmaset.c. (The second one is
actually #define'd to rpc_x_no_ns_permission in
rpcpvt.h, and is declared/initted using that name.)

Not a bug.



CR Number                     : 9936
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : non POSIX constants in lseek call
Reported Date                 : 2/10/94
Found in Baseline             : 1.0.3
Found Date                    : 2/10/94
Severity                      : E
Priority                      : 4
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : src/rpc/runtime/uuid_15.c
Sensitivity                   : public

[2/10/94 public]

 The file .../src/rpc/runtime/uuid_15.c contains an lseek() call which
uses the symbolic value L_SET as its third parameter. L_SET is non-POSIX
compliant and should be replaced with SEEK_SET to facilitate porting. 
 Similar problems exist in other files; in fact, a quick examination seems
to show that the majority of lseek() calls use a numeric constant as the
third argument.

[02/10/94 public]
Note that uuid_15 (indeed, all the NCS1.5 code) is due to move to the
nosupport tree for dce1.1.  If you have places in other parts of the
rpc runtime that should be fixed, please list them, otherwise this CR
should be cancelled.

[05/04/94 public]
There is no support for the NCS 1.5 code in 1.1
Canceled.



CR Number                     : 9861
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : 
Short Description             : IDL generated stubs assume 32 bit alignment of data structure.
Reported Date                 : 1/31/94
Found in Baseline             : 1.0.3
Found Date                    : 1/31/94
Severity                      : C
Priority                      : 3
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/31/94 public]

----- begin licensee report -----
Full Description:

        The v1.0.3 IDL compiler generates stubs containing a data
        structure called 'IDL_type_vec'. This data structure is
        accessed using macros provided in the idlddefs.h file.
        These macros:
            IDL_GET_LONG_FROM_VECTOR
            IDL_DISCARD_LONG_FROM_VECTOR
            IDL_ALIGN_POINTER_TO_LONG
        perform bit arithmetic on the address they are given. The
        arithmetic is supposed to align the address on a 32 bit
        boundary within the data structure (to skip filler bytes
        within the structure). However, the arithmetic is done on
        the absolute address and so is dependent on the beginning
        of the data structure being aligned to a 32 bit boundary.
        Many vendors machines (and their C compilers) cannot
        guarantee this alignment which means that they cannot use
        the v1.0.3 IDL compiler.

Proposed Solution:

        The macros in idlddefs.h should perform their arithmetic on
        the offset of the address from the start of the IDL_type_vec
        data structure (and NOT on the absolute address).

        A temporary workaround is to revert to using the v1.0.2
        IDL compiler. However, there have been many defect fixes
        which have only been made in the v1.0.3 compiler (and
        its associated IDL library changes).

        It may be that this problem can be fixed just by changing
        the IDL library. However, it may require changes to
        the IDL generated stubs and the IDL library interfaces
        they invoke. This could cause serious maintenance and
        compatibility problems between v1.0.3 DCE products and
        future releases, unless this problem is fixed quickly
        and an update delivered to all v1.0.3 licensees.
----- end licensee report -----

Note, for example, the following code fragment from idl/lib/interpsh.c:

        case IDL_DT_VARYING_ARRAY:
            defn_vec_ptr += 2;      /* After properties byte */
            IDL_DISCARD_LONG_FROM_VECTOR(defn_vec_ptr);
            /* Ignore the full array definition and look at the flattened
one */
            IDL_GET_LONG_FROM_VECTOR(array_defn_index, defn_vec_ptr);
            array_defn_ptr = IDL_msp->IDL_type_vec + array_defn_index;
            dimensionality = (idl_ulong_int)*array_defn_ptr;
            array_defn_ptr++;
            array_element_count = 1;
            for (i=0; i<dimensionality; i++)
            {
                IDL_GET_LONG_FROM_VECTOR(lower_bound, array_defn_ptr);
                IDL_GET_LONG_FROM_VECTOR(upper_bound, array_defn_ptr);
                array_element_count *= (upper_bound - lower_bound + 1);
            }

The macro calls:

                IDL_GET_LONG_FROM_VECTOR(lower_bound, array_defn_ptr);
                IDL_GET_LONG_FROM_VECTOR(upper_bound, array_defn_ptr);

are aligning the "global address" (i.e. not an offset in IDL_vec_type) on a
32 bit boundary which, if IDL_vec_type is NOT aligned on a 32 bit boundary,
may not correspond to the right address within IDL_type_vec because it
is then not on a 32 bit offset boundary within IDL_vec_type.

As stated in the licensee report, this problem is critical on those
platforms which do not happen to align IDL_vec_type on a 32 bit boundary.

[2/3/94 public]

Here is the licensee response to Rico's initial suggestions (along
with the text of those suggestions):

----- begin licensee report -----
   Unfortunately, neither of the two suggested solutions work for our
architecture. Ideally, the solution should only rely on the presence of
an ANSI C compiler which would ensure its portability across all platforms.
     Cheers,
        Alan

------------   ORIGINAL ATTACHMENT   --------
SENT 02-02-94 FROM SMTPGATE (levy@osf.org)


------- Forwarded Message

Here is the developer response to the change request I filed:

- -----
We've discussed several possible fixes to this problem - I'll describe the
two simplest ones and hopefully one of those suffice.

 1) The simplest fix would be if the C compiler(s) on the failing platform
    support a pragma or language extension to specify alignment of a data
    structure.  For example, VAX C on OpenVMS has this.  Then the IDL
    compiler could emit conditional preprocessor logic into the stub.

 2) The next simplest fix would be to change the base type of IDL_type_vec
    to be a union of an array of bytes and a single long.  You could test
    the feasibility of this by munging an emitted stub slightly as follows:

     a) Add a new type declaration:

        typedef union {
            idl_byte type_vec[ <size-of-current-type-vector> ];
            idl_ulong_int align;
        } IDL_type_vec_t;

     b) Change the first line of the type vector definition from:

        static idl_byte IDL_type_vec[] = {

        to

        static IDL_type_vec_t IDL_type_vec = {

     c) If the stub references IDL_type_vec, change to
IDL_type_vec.type_vec

     d) Compile-link-run to validate correctness.

    If this works, let us know and we'll make the fixes in the IDL compiler
    and submit them.  I've tried this on DEC AXP OSF/1 and it works there.
----- end licensee report -----

[2/4/94 public]

Are you sure that your C compiler contains no way to specify alignment?
I just want to double check on that one, because that would be an
obvious and easy fix.  The platform that I'm guessing is most similar to
yours is VAX VMS - the VAX does not require natural alignment, and in
general anything can be allocated on any boundary.  But the VAX C
compiler provides both an '__align(size)' language extension and a
'#pragma member_alignment' pragma to control alignment.  I would expect
any C compiler on a "packed" platform to provide something like this.

I would like to pursue the possibility of a simple fix some more before
we go changing the macros (or pursuing a couple other possibilities we've
thought of).

 1) If your C compiler does not support any alignment, can you think of
    any trick which could be used to force alignment?  I haven't come up
    with anything yet, but suspect there might be some sort of hack.

 2) I hacked a simple stub by removing all the code, leavining in the
    declarations, and sticking in this little main program:

int main()
{
    printf("&IDL_transfer_syntaxes = %p\n", IDL_transfer_syntaxes);
    printf("sizeof(IDL_transfer_syntaxes) = %p\n",
sizeof(IDL_transfer_syntaxes)
);
    printf("&IDL_ifspec = %p\n", &IDL_ifspec);
    printf("sizeof(IDL_ifspec) = %p\n", sizeof(IDL_ifspec));
    printf("&test_v0_0_c_ifspec = %p\n", &test_v0_0_c_ifspec);
    printf("sizeof(test_v0_0_c_ifspec) = %p\n",
sizeof(test_v0_0_c_ifspec));
    printf("&IDL_offset_vec = %p\n", IDL_offset_vec);
    printf("sizeof(IDL_offset_vec) = %p\n", sizeof(IDL_offset_vec));
    printf("&IDL_rtn_vec = %p\n", IDL_rtn_vec);
    printf("sizeof(IDL_rtn_vec) = %p\n", sizeof(IDL_rtn_vec));
    printf("&IDL_type_vec = %p\n", IDL_type_vec);
    printf("sizeof(IDL_type_vec) = %p\n", sizeof(IDL_type_vec));
}

    The output I got from this, on VAX VMS, was this:

&IDL_transfer_syntaxes = 1094
sizeof(IDL_transfer_syntaxes) = 14
&IDL_ifspec = 10a8
sizeof(IDL_ifspec) = 32
&test_v0_0_c_ifspec = 1ed8
sizeof(test_v0_0_c_ifspec) = 4
&IDL_offset_vec = 10dc
sizeof(IDL_offset_vec) = 8
&IDL_rtn_vec = 10e4
sizeof(IDL_rtn_vec) = 8
&IDL_type_vec = 10ec
sizeof(IDL_type_vec) = 79

    Note that the collective size of the data leading up to IDL_type_vec
    is (2 mod 4), not (0 mod 4).  If we could assume (I have no idea if
    we can, but it's worth a check) that a particular module's contribution
    to an executable starts on a (0 mod 4) boundary, then we could
    possibly just stick in the correct number of filler bytes (2 in the
    above case) to make IDL_type_vec start on a (0 mod 4) boundary.

Rico

[2/8/94 public]

Unfortunately here is what the licensee reports:

----- begin licensee report -----
   Our C compiler does not support any way to specify alignment. It
does guarantee that the IDL_type_vec structure will be aligned on a 16
bit boundary. Our binder/linker can also only guarantee 16 bit
alignment of a particular modules global data.
----- end licensee report -----

[2/10/94 public]

As you know, we are only obligated to fix bugs/do enhancements on the
reference platforms.  This really is a porting issue.  I suggest we
proceed as follows: I'll make a couple of high-level suggestions as to
how this problem could be fixed.  You pick the one you prefer.  I give
you further technical detail on how to implement it.  You implement it.

Here are my suggestions:

 1) Modify the IDL_GET_LONG_FROM_VECTOR and related macros to take the
    original type vector alignment modulo 4 into account.  There may be
    a couple of other code sites that need to be modified as well.
    The original type vector alignment needs to be stored somewhere,
    probably in the marshalling state block.  There is a way to make this
    change compatibly, but we'll have to be careful.

 2) Under the existing Threads "once" logic (logic that gets executed
    exactly once per stub module), malloc space for the type vector,
    plus some extra to guarantee alignment, and copy the statically
    initialized type vector to the new storage.  This requires mods to
    the IDL compiler to emit an extra pointer cell and to specify it
    in place of the normal type vector address.

Incidentally, are your platforms big-endian or little-endian?

[2/18/94 public]

----- begin licensee report -----
It would appear that the first suggested solution would be the best because
it does not require any changes to the idl compiler ie. our implementation
of DCE could continue to use C stubs generated by any idl compiler.

Having investigated where the macros are called I have discovered
the following routines which do NOT have access to the marshalling
state block:
     rpc_ss_arm_switch_value ()       in interpsh.c prototyped in
idlddefs.h
     rpc_ss_find_union_arm_defn ()    in interpsh.c prototyped in
idlddefs.h
     rpc_ss_discard_allocate_ref ()   in ndrmi.c    prototyped in ndrmi.h
However all these routines are called from places where the IDL_msp is
available so it should be possible just to add this as an extra argument
to these functions.

So given that this solution may be possible I have the following questions:

1) Are these macros ALWAYS called with an absolute address, or are they
   sometimes called with an address which is a relative offset from a
   previously calculated 4 byte aligned boundary within the data structure?

2) You mentioned that "there may be a couple of other code sites that
   need to be modified as well". Can you indicate where?

3) Is there any possibility that the fix (we implement) will be integrated
   into the OSF source code?

4) Are you only unwilling to fix this problem in 1.0.3? Will you fix it
   in the 1.1 source code, which may have a wider audience than 1.0.3?

FYI, our platform is big-endian.

Thanks for your help,
----- end licensee report -----

[3/4/94 public]

Sorry about the delay in responding but things have been quite hectic.
The following set of source changes have been tested on VAX VMS which is a
little endian platform which by default "packs" data structures.  To
adequately test it I also munged the IDL compiler (not included in changes)
to emit filler byte(s) before the IDL_type_vec declaration, which forced
IDL_type_vec to be unaligned.  I realize that your platforms are big-endian
but I made the same changes in both little- and big-endian codepaths where
applicable.

I ran a complete test suite against the changes, with no observed problems,
so I have a fairly high degree of confidence that the changes really work.
Below are diff's for all the files that changed.

As to your questions:

 1) The macros are always called with an absolute address.

 2) I think I was incorrect when I said there may be additional code sites
    needing change.  I was anticipating that some 'ifdef little-endian'
    code that points directly into the data structure would no longer be
    able to do so.  Running the test suite on VAX VMS seems to have
disproved
    that, and as I think of it, as long as the platform provides unaligned
    accesses there should be no problem.

 3) OSF will have to answer as to whether the fix can be integrated into
the
    OSF source code.  At one level, the fix can be viewed as a porting
issue.
    To my knowledge, Tandem is the only licensee that has observed this
    problem.

 4) Depends on the decision for 3).

Regards,
Rico Annicchiarico
DEC/Nashua NH - IDL Project Leader


**** idlddefs.h ****


+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +

Element IDLDDEFS.H(92) Line 307  
      1)    idl_byte *_s = (idl_byte*)(((address-(idl_byte *)0)+3) & (~3));
\

File RPC$:[RICO.RPC.BLD.MAIN.SYSIDL.SRC]IDLDDEFS.H;6 Line 307  
      2)    idl_byte *_s = (idl_byte*)((((address-(idl_byte
*)0)+3-((IDL_msp->ID
L_type_vec-(idl_byte *)0)%4)) & (~3)) + ((IDL_msp->IDL_type_vec-(idl_byte
*)0)%4
)); \
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -



+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +

Element IDLDDEFS.H(92) Line 312  
      1){   address = (idl_byte *)(((address-(idl_byte *)0)+3) & (~3)); \

File RPC$:[RICO.RPC.BLD.MAIN.SYSIDL.SRC]IDLDDEFS.H;6 Line 312  
      2){   address = (idl_byte *)((((address-(idl_byte
*)0)+3-((IDL_msp->IDL_ty
pe_vec-(idl_byte *)0)%4)) & (~3)) + ((IDL_msp->IDL_type_vec-(idl_byte
*)0)%4)); 
\
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -



+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +

Element IDLDDEFS.H(92) Line 319  
      1){   address = (idl_byte *)(((address-(idl_byte *)0)+3) & (~3)); \

File RPC$:[RICO.RPC.BLD.MAIN.SYSIDL.SRC]IDLDDEFS.H;6 Line 319  
      2){   address = (idl_byte *)((((address-(idl_byte
*)0)+3-((IDL_msp->IDL_ty
pe_vec-(idl_byte *)0)%4)) & (~3)) + ((IDL_msp->IDL_type_vec-(idl_byte
*)0)%4)); 
\
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -



+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +

Element IDLDDEFS.H(92) Line 380  
      1)    address = (idl_byte *)(((address-(idl_byte *)0)+3) & (~3));

File RPC$:[RICO.RPC.BLD.MAIN.SYSIDL.SRC]IDLDDEFS.H;6 Line 380  
      2)    address = (idl_byte *)((((address-(idl_byte
*)0)+3-((IDL_msp->IDL_ty
pe_vec-(idl_byte *)0)%4)) & (~3)) + ((IDL_msp->IDL_type_vec-(idl_byte
*)0)%4));
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -



+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +

Element IDLDDEFS.H(92) Line 428  
      1)    idl_long_int index

File RPC$:[RICO.RPC.BLD.MAIN.SYSIDL.SRC]IDLDDEFS.H;6 Line 428  
      2)    idl_long_int index,
      2)    IDL_msp_t IDL_msp
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -



+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +

Element IDLDDEFS.H(92) Line 431  
      1)    rpc_ss_arm_switch_value(defn_vec_ptr, index)

File RPC$:[RICO.RPC.BLD.MAIN.SYSIDL.SRC]IDLDDEFS.H;6 Line 432  
      2)    rpc_ss_arm_switch_value(defn_vec_ptr, index, IDL_msp)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -



+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +

Element IDLDDEFS.H(92) Line 670  
      1)    idl_byte **p_arm_type_ptr

File RPC$:[RICO.RPC.BLD.MAIN.SYSIDL.SRC]IDLDDEFS.H;6 Line 671  
      2)    idl_byte **p_arm_type_ptr,
      2)    IDL_msp_t IDL_msp
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -



+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +

Element IDLDDEFS.H(92) Line 770  
      1)    idl_long_int index

File RPC$:[RICO.RPC.BLD.MAIN.SYSIDL.SRC]IDLDDEFS.H;6 Line 772  
      2)    idl_long_int index,
      2)    IDL_msp_t IDL_msp
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -



**** interpsh.c ****

+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +

Element INTERPSH.C(57) Line 1069 
      1)    /* [out] */ idl_byte **p_arm_type_ptr

File RPC$:[RICO.RPC.BLD.MAIN.LIBIDL.SRC]INTERPSH.C;2 Line 1069 
      2)    /* [out] */ idl_byte **p_arm_type_ptr,
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -



+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +

File RPC$:[RICO.RPC.BLD.MAIN.LIBIDL.SRC]INTERPSH.C;2 Line 1071 
      2)    IDL_msp_t IDL_msp
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -



+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +

Element INTERPSH.C(57) Line 1073 
      1)( defn_vec_ptr, arm_count, switch_value, p_arm_type_ptr )

File RPC$:[RICO.RPC.BLD.MAIN.LIBIDL.SRC]INTERPSH.C;2 Line 1074 
      2)( defn_vec_ptr, arm_count, switch_value, p_arm_type_ptr, IDL_msp )
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -



+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +

F-DL.SRC]INTERPSH.C;2 Line 1535 
      2)    /* [in] */ idl_long_int index,          /* Index of union arm
desc *
/
      2)    IDL_msp_t IDL_msp
- - - - - - - - - - - - - - - - - - - + + + + + + + + + + + + + + + + + + +
+ + + + *p_type_vec_ptr,
- - - _tN.LN.LIBID


+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
                  rpc_ssent NDRMI.H(26) Line 205 -(37) Line 229  
     &arm_typ
e_ptr) )

Fi+ + ype_ptr, IDL_msp) )
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -



+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +

Element NDRUI3.C(44) Line 367  
      1)                                                                &a
   &arm_type_ptr, ID - - - - - - - - - - - - - - - - - - - - - - - - - - -
- - - - - - - - 


**** ndrmi5.c ****


+ + + + + + + + + + +e_ref(&type_vec_ptr);

File RPC$:[RICO.RPC.BLD.MAIN.LIBIDL.SRC]NDRMI5.C;2 Line 822  
      2)                    rpc_ss_discard_allocate_ref(&type_vec_ptr,
IDL_msp);
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -



**** ndrui5.c ****


+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +

Element NDRUI5.C(4) Line 603  
      1)                    rpc_ss_discard_allocate_ref(&type_vec_ptr);

File RPC$:[RICO.RPC.BLD.MAIN.LIBIDL.SRC]NDRUI5.C;2 Line 603  
      2)                    rpc_ss_discard_allocate_ref(&type_vec_ptr,
IDL_msp);
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

[03/29/94 public]
Lowering this to a C3, since we feel this is a porting issue and
may not be appropriate for the OSF source base.

[8/17/94 public]
If the vendor is satisfied with the porting changes Rico has given
them, I would like to cancel this defect.

We can look in to adding these changes to the OSF source base if
anyone feels there is sufficient benifit.

[8/23/94 public]
No interest was expressed, so we will chalk this up to a porting
specific problem and cancel this defect.
I assume system engineering will keep this on file in the unlikely
event someone else encounters this problem.



CR Number                     : 9808
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : sinix
Component Name                : rpc
Subcomponent Name             : idl/idl_compiler/ddspell.c
Short Description             : Stubs differ on big & little endian
Reported Date                 : 1/24/94
Found in Baseline             : 1.0.3
Found Date                    : 1/24/94
Severity                      : A
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/24/94 public]

The IDL generated stubs differ when generated on a big endian machine instead of
a little endian machine.

The difference is in the way bug flags in the IDL_type_vec[] are stored. The
idl/idl_compiler/ddspell.c's DDBE_spell_type_vec_addenda() function generates
this field. The following test program mimics this functions behavior and can
be used to test on little and big endian machine:

-------------test_idl.c-----------------
#include <stdio.h>

main()
{
  unsigned long x=0;
  unsigned char *p4 = (unsigned char *)&x;

  x |= (1<<4);

  printf("0x%02x,0x%02x,0x%02x,0x%02x.\n",p4[0], p4[1], p4[2], p4[3]);

}
------------- end -----------------

Following #ifdef SNI_SVR4 code shows how to fix it (+ prefix shows lines added):

FIX: file idl/idl_compiler/ddspell.c
FUNCTION: DDBE_spell_type_vec_addenda()

------------- begin fix -----------------
    boolean         spell_stg_info; /* TRUE => spell storage information list */
+#ifdef SNI_SVR4
+    boolean             big_e;
+#endif /* SNI_SVR4 */

    p4 = (byte *)&longint;

+#ifdef SNI_SVR4
+    longint = 0x01020304;
+    big_e = ((byte) (longint & 0x0ff) == p4[3]);
+#endif /* SNI_SVR4 */

    /*
     * Process bugs flags.  Bug numbers start at 1, bug 0 value is a don't-care.
     */
    do_bug = (boolean *)cmd_val[opt_do_bug];
    index  = vip->type_vec_size;
    bugnum = 0;
    for (i = 0; i <= NUM_BUGS/32; i++)
    {
        longint = 0;
        for (j = 0; j < 32 && bugnum <= NUM_BUGS; j++)
        {
            if (do_bug[bugnum])
                longint |= (1 << j);
            bugnum++;
        }
        DDBE_SPELL_INDEX(fid, index);
+#ifdef SNI_SVR4
+        if (big_e) /* ndr_c_int_big_endian */
+            fprintf(fid, "0x%02x,0x%02x,0x%02x,0x%02x,",
+                         p4[3], p4[2], p4[1], p4[0]);
+        else       /* ndr_c_int_little_endian */
+            fprintf(fid, "0x%02x,0x%02x,0x%02x,0x%02x,",
+                         p4[0], p4[1], p4[2], p4[3]);
+#else
        fprintf(fid, "0x%02x,0x%02x,0x%02x,0x%02x,",p4[0], p4[1], p4[2], p4[3]);
+#endif /* SNI_SVR4 */
------------- end fix -----------------

[05/04/94 public]
Hp is going to give us a fix for the little/big endian problems
of the 'new' idl compiler.

I'm unclear if this defect is related to this overall problem:
Certain idl structure are kept in little-endian format, as opposed
to the native machine format, penalizing performance on big-endian machines.

Rico, could you take a quick glace at this?

[05/04/94 public]

This problem is not related to the overall endian partiality Tom mentioed above.
Its just a plain bug/ coding error.

[05/10/94 public]

These endian problems are always a little more mind bending to me than
they really ought to be!

Anyway, I think parul is correct.  I just emitted a stub on AIX with
some -bug options, and the emitted bug flags had bits set in the high-
order byte of the bugs flag, rather than the low-order byte.  As Tom
points out, since the current IDL spells the type vector in little-
endian format, emitted bug flags for '-bug 1 -bug 2 -bug 3' ought to
look something like 0x0e,0x00,0x00,0x00, not 0x00,0x00,0x00,0x0e.

[08/04/94 public]

I believe this should no longer be an issue, since the
fix for OT 10103 specifies that the type vector is now
spelled in the local integer representation of the 
machine.  Thus stubs on big and little endian architecture
machines are expected to differ.

[8/16/94 public]
Luis, can you verify that this field of the type vector
is indeed read back in the local endian representation
and does not need to be spelled out differently?

I guess I don't want to close/cancel this until we are sure.

[8/16/94 public]
Got clever and figured it out on my own that indeed, with the new
HP mods this array is spelled out correctly in the native format.
This bug is canceled.



CR Number                     : 9698
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 9601
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_gd
Short Description             : timop needs out_of_line removed
Reported Date                 : 1/6/94
Found in Baseline             : 1.0.3
Found Date                    : 1/6/94
Severity                      : C
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/6/94 public]

DCE 1.0.3 IDL ignores the IDL ACF attributes in_line and
out_of_line and no longer generates "aux" files. As part
of its DCE 1.1 work, Digital is in the process of removing
documentation of the attributes from the chapters in
Part 3, Remote Procedure Calls (see CR 9601). Documentation
about this functionality also needs to be removed from the
OSF-owned portions of the App Dev Guide. The places I've
found are:

- Section 1.5.4, "StepA4/Client and Server: Write the .acf File"
file is /app_gd/overview/chap1.gpsml)

- Chapter 3, "A Sample DCE Application" and the timop program itself
file is /app_gd/overview/chap3.gpsml)

- Section 11.1.1 "Generating an Interface UUID" (bulleted
items for _caux.c and _saux.c need to be removed...this is
actually in the RPC part, but Digital has not currently
removed it. File is /app_gd/rpc/3_build_app.gpsml.)

If timop is to be replaced with another example at DCE 1.1,
much of this work can be changed to removing references
to timop's functionality.

Documentation about using the environment variable
IDL_GEN_AUX_FILES for pre-1.0.3 IDL makefile compatibility
probably needs to be added (but this book might not be the
right place for it).

[3/24/94 public]

Reassigned this CR to John Shirley from Steve Lewontin.

[6/28/94 public]

Cancelled because we will not be using the timop example in DCE 1.1 Docs



CR Number                     : 9566
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : DG runtime
Short Description             : DG client runtime drops WAY request
Reported Date                 : 12/1/93
Found in Baseline             : 1.0.3
Found Date                    : 12/1/93
Severity                      : D
Priority                      : 3
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[12/1/93 public]

There is an intermittant failure that has been observed when running the DCE 
VTS DG Client tests. This happens only for non-idempotent RPCs. The PDU 
exchange is depicted below:

	VTS (server)			DG Client Runtime
	-----------			-----------------

			<------	request
			<------	ping
		WAY request --->
			<------ ping
			... comm failure

A real server would time out and send another WAY request (the server is 
acting as a client when doing the callback). In many cases, that might happen 
to work. Modifying the VTS to do that however, demonstrated that something 
akin to a race conditon can occur here, where the client keeps pinging and the
server keeps resending the WAY request. The RPC ends (comm failure) when 
the DG client runtime reaches the max number of pings and starts sending quits.

Apparently, the DG Client runtime either loses the WAY request or is not
checking for it properly. This happens on the OSF/1 486 reference platform
with greater frequency than it does on the HP (but it does happen on the 
HP from time to time).

At the application level, it means that any non-idempotent RPC which uses the 
DG protocol can inexplicably fail, returning comm failure, even though there 
is nothing wrong with the server.

Related CR is dce_vts CR 10.

[12/1/93 public]

I don't know what race condition you're seeing.  The client timed out
because the server failed to respond to its pings.  The fact that the
server is in the middle of a WAY has no bearing on the requirement that
it respond to pings.

And yes, VTS should be modified to retransmit WAY requests if no response
is seen.

[12/1393 public]

As it turns out, my original analysis was a little off the mark. After
consulting the AES/DC and modifying the VTS some, we have a better idea
of what we think is going on and what should be happening.

First of all, that business about resending the WAY request I mentioned 
above is plain wrong. The AES specifies that the correct response to a
ping PDU is a NOCALL PDU, with the optional body (see pg. 12-16 of the
AES/DC). But even when we do so, it can still fail.

A second point is that the CL Server CALLBACK state (see pg. 10-40) is a 
parallel state machine, executing independently of the DATA state. The 
server executes this state as if it were a DG client, and the client 
acts as a server. This means that the client (acting as server) is obliged 
to respond to the WAY request, even though it is waiting for a response 
to its original request.

Except as indicted, the PDU exchange is depicted in the order the CL 
client runtime sees the PDUs, in most of the analyses below.

When running the VTS to validate non-idempotent calls, we normally see 
something like the following (single frag request/response):

VTS (as server)			CL Client Runtime

			<-----	send request 
send WAY request	----->	
			<-----	send WAY response
send response		----->

So far, so good. Now, sometimes we get the following (running the same
test) which is still okay:

VTS (as server)			CL Client Runtime

			<-----	send request 
			<-----	ping for response
send WAY request	----->	
			<-----	send WAY response
send response		----->

One type of intermittant problem was that we were getting this:

VTS (as server)			CL Client Runtime

			<-----	send request 
			<------ ping
send WAY request	----->	
			<------ ping
			<------ ping
			<------ ping
			<------ ping
			... comm failure

As Mark pointed out, the client timed out waiting for a
response. The correct response to a ping is not for the VTS 
to re-send the WAY request, however, it is to return a NOCALL 
with the optional body in response to the PING (as stated in 
my second point, above), and, after timeout, to ping the WAY 
request.
The WAY request only gets re-sent in the event that the server
(which issued the request) receives a NOCALL in response a 
PING (which is not shown in the above example).

In this example, the CL Client runtime is acting incorrectly
in that it does not process the WAY request in parallel with 
waiting for the response to the call it issued, as evidenced 
by the comm failure behavior documented above (more about this
later).

The CL Client runtime is also incorrect in another sense, 
which requires a little more illustration.
In an atempt to fix the above problem, the VTS was modified, 
which allowed the following to take place (remember, this is 
an intermittant problem - it doesn't happen every time and it
doesn't happen in exactly the same way every time). RPC_DEBUG
produced some of the text shown on the right side, below:

VTS (as server)			CL Client Runtime

			<-----	send request, serial_lo = 0 

				(rpc__dg_xmitq_elt_xmit) request 49.0.0 len=16 frq
				(recv_state_timer) Starting to ping (rq->next_fragnum=0) [006975f8-2d23-1616-9c3b-0000c036d04c, 49.0]
			<-----	ping for response, serial_lo = 2
send WAY request	----->	
				(recv_state_timer) Re-pinging (rq->next_fragnum=0) [
send NOCALL with	----->
  optional body (ping 2)
				(rpc__dg_do_nocall) Has fack body [006975f8-2d23-1616-9c3b-0000c036d04c, 49.0]
				(do_fack-slow-q) frag 0, cws 0, bs 0, fo 0
				(stop_pinging) Next ping at: now = 4822, interval = 50 [006975f8-2d23-1616-9c3b-0000c036d04c, 49.0]

			<-----	ping for response, serial_lo = 3
send NOCALL with	----->
  optional body (ping 3)
				(recv_state_timer) Starting to ping (rq->next_fragnum=0) [006975f8-2d23-1616-9c3b-0000c036d04c, 49.0]
			<-----	ping for response, serial_lo = 4
				(recv_state_timer) Re-pinging (rq->next_fragnum=0) [006975f8-2d23-1616-9c3b-0000c036d04c, 49.0]

ping for WAY response	----->
			<-----	ping for response, serial_lo = 5
			<-----	NOCALL in response to WAY ping
send NOCALL with	----->
  optional body (ping 4)
				(rpc__dg_do_nocall) Transmit queue is empty [006975f8-2d23-1616-9c3b-0000c036d04c, 49.0]

send NOCALL with	----->
  optional body (ping 5)
				(rpc__dg_do_nocall) Transmit queue is empty [006975f8-2d23-1616-9c3b-0000c036d04c, 49.0]

resend WAY request	----->	
				(recv_state_timer) Re-pinging (rq->next_fragnum=0) [006975f8-2d23-1616-9c3b-0000c036d04c, 49.0]

			<-----	ping for response, serial_lo = 6
send NOCALL with	----->
  optional body (ping 6)
				(rpc__dg_do_nocall) Transmit queue is empty [006975f8-2d23-1616-9c3b-0000c036d04c, 49.0]

			<-----	ping for response, serial_lo = 7
send NOCALL with	----->
  optional body (ping 7)
				(rpc__dg_do_nocall) Transmit queue is empty [006975f8-2d23-1616-9c3b-0000c036d04c, 49.0]

			...
			<------ quit
			<------ quit
			<------ quit
			... comm failure

The odd thing is that sometimes sending the NOCALL from the VTS to
the CL Client runtime seems to work, and sometimes, like in this
example, it doesn't. 
When ping-ing the WAY request results in a NOCALL, resending the 
request doesn't work. 

The message "(rpc__dg_do_nocall) Transmit queue is empty" is generated 
at line 664 in dgclsn.c. At that place the function returns - before
it can stop pinging, as indicated in the comments. That means that 
the nocall PDU is not being interpreted correctly and that the correct
action - to stop pinging - is not happening. This may be ok but there
is still a WAY request outstanding that is not getting serviced.

Also, what happened to the PDU with serial_lo = 1?

I can provide packet dumps with lots more information, if required.

[12/21/93 public]

  >>  First of all, that business about resending the WAY request I mentioned 
  >>  above is plain wrong. The AES specifies that the correct response to a
  >>  ping PDU is a NOCALL PDU, with the optional body (see pg. 12-16 of the
  >>  AES/DC). But even when we do so, it can still fail.

No.  A 'nocall' is sent by a server when it has not received all of the
IN arguments to a call.  If the server has received *some* of the arguments,
it will send a 'nocall' with "optional body", indicating which packets it  
currently holds.  After all the arguments have been received, the correct 
response to a 'ping' is a 'working' packet.

The trace above show that the VTS server is confusing the client by saying
1) I got all the arguments to the call (via the optional body), and 2) I didn't
get all of the arguments to the call (by the fact that it's sending a 'nocall'.

[12/21/93 public]

We will try substituting a "working" for a "nocall" but I can't see how it
will correct the real problem we're seeing here: on an intermittant basis,
the CL client runtime is getting into a state where it can not respond to a 
WAY request. The first example shows that - there is no good reason why the
CL client should time out waiting for the response before it can send the 
WAY response.

[5/5/94 public]

Can we cancel this one?


[5/594 public]

The gray areas here were never clarified. Also, the VTS hasn't been run against
RPC recently (of particular interest would be any possible impact of the DG
performance enhancements). I recommend keeping this open as a place marker, at least 
until the VTS can be run against a 1.1 build.

[2/7/96 public]

Cancelled. This is a VTS bug. There is no gray area. VTS server is not
retransmitting a WAY request (often enough) when the packets get dropped.
If it happens again after fixing VTS, submit a new defect.



CR Number                     : 9558
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpcd
Short Description             : rpcd should return the non-zero exit status when it failed to start listening.
Reported Date                 : 11/29/93
Found in Baseline             : 1.0.3
Found Date                    : 11/29/93
Severity                      : E
Priority                      : 4
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rpc/rpcd/rpcd.c
Sensitivity                   : public

[11/29/93 public]

rpcd always returns the zero exit status unless -f or debug options are
specified. This behavior is unfriendly. It should return the non-zero exit
status if the child process failed to start listening so that dce_config
and rc.dce can easily determine the successful start of rpcd. (Even if this
gets fixed, rc.dce and dce_config should verify it by using rpccp.)

Also, rpcd should have an asynchronous signal handler to exit gracefully,
instead of just being killed.

Since rpcd will go away at DCE 1.1, dced should have these fixed in 1.1.

If anyone is interested, I have these fixes for rpcd.

[05/04/94 public]
The fixes Seiichi made to rpcd were passed along to the dced team.
these changes will not be made to rpcd for 1.1.
Canceled.



CR Number                     : 9532
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : cn
Short Description             : The pointer used after the deallocation
Reported Date                 : 11/22/93
Found in Baseline             : 1.0.3
Found Date                    : 11/22/93
Severity                      : A
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rpc/runtime/cnassoc.c
Sensitivity                   : public

[11/22/93 public]

In rpc__cn_assoc_sec_free()::cnassoc.c, the security context element (*sec)
is dereferenced after it's free'ed. The calling sequence should be
reversed, i.e., call RPC_CN_AUTH_RELEASE_REFERENCE() before
rpc__list_element_free().

[11/22/93 public]

Again, I've already reported this in CR9328. Should check the existing
entries before opening a new one...



CR Number                     : 9530
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : common
Short Description             : Potential misuse of the pointer
Reported Date                 : 11/22/93
Found in Baseline             : 1.0.3
Found Date                    : 11/22/93
Severity                      : D
Priority                      : 3
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rpc/runtime/comif.c
Sensitivity                   : public

[11/22/93 public]

In unregister_if_entry()::comif.c, at line# ~908, the removed element's
next pointer is used to follow the link:

            /*
             * remove this entry from the list for this interface
             */
            RPC_LIST_REMOVE (if_entry->type_info_list, type_info);

            /*
             * save this entry and get the next one on the list
             */
            current_type_info = type_info;
            
            RPC_LIST_NEXT (type_info, type_info, rpc_if_type_info_p_t);

This works because RPC_LIST_REMOVE() macro does not destroy type_info->next
pointer. But it's not a safe way. It should use RPC_LIST_FIRST() macro
instead:

            RPC_LIST_FIRST
                (if_entry->type_info_list, type_info, rpc_if_type_info_p_t);

[11/22/93 public]

Oops, I've already reported this in CR9330.



CR Number                     : 9416
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : admin_gd
Short Description             : the DCE RPC Admin Guide needs
to be brought up to date.
Reported Date                 : 11/9/93
Found in Baseline             : 1.0.3
Found Date                    : 11/9/93
Severity                      : D
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/9/93 public]

Chapter 1. DCE RPC Administrative Facilities, in the DCE Admin Guide needs
to be updated. Here is a list of things where to start:

1. There are several references to the file rpcdllb.dat which is not
   longer used. 

2. There is not reference to the file <dcelocal>/var/rpc/rpcd.log

3. References to /etc/dce.rc should be changed to /etc/rc.dce. Also, it
   is /etc/dce.clean that clears the endpoint database and it is not
   done as part of a system reboot necessarily.

4. Throughout this chapter the use of RPCD and RPCCP are always 
   capitalized and sometimes these words are bolded. To be in harmony  
   with the rest of the admin guide, all references to DCE programs
   should be in lower case (as they are) and bolded.

[11/12/93 public]

Temporarily assigning this bug to Bob Mathews (DCE 1.1
doc project leader). Will reassign when writer assignment
for rpc admin documentation is made (Larry Kaplan was the
former owner).

[4/18/94 public]

Assigning this CR to John Shirley, OSF's RPC and dced writer.

[9/7/94 public]
If you procrastinate long enough, some CRs will get fixed on their own :-)
Due to rewriting of the Administration guide, these issues are gone.

[9/7/94 public]
cancel.



CR Number                     : 9401
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : rpc/sys_idl/nbase.idl
Short Description             : error_status_t defined as unsigned long
Reported Date                 : 11/8/93
Found in Baseline             : 1.0.3
Found Date                    : 11/8/93
Severity                      : B
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/8/93 public]
When ported to a 64-bit platform (such as Alpha), this produces
copious warnings when compiled under code cleanup guidelines.
It is unacceptable for switch() statements, which are restricted to int.
It should instead be defined as unsigned32.

[11/8/93 public]
My face is red... The issue is not 64 bits. Let's go back to basics.
Our cleanup effort led to try to build on the 486 with all those
required gcc switches. Lo and behold, the following:

int
cds_convert_rpc_status ( commStatus )
    error_status_t      commStatus;
{
    int status;

    switch ( commStatus )	/* line 343 */
.
.
.
}

produces an error:

/project/dce/build/dce1.0.3/src/directory/cds/child/clerk_miscel.c:343: warning:
 `long' switch expression not converted to `int' in ANSI C

Is everyone going to have to cast these things to int?

[11/8/93 public]
This seems to be a benign warning from gcc.  In ANSI any integral type can
be used as an expression in a switch statement.  GCC is just telling you
about this.  I expect that it is the -Wtraditional switch that is causing
this.  If you remove this switch do the errors go away?  

There have been other problems with the use of this switch, so far I know
of no legitimate bug that it has found.  DEC is the furthest along in the
code cleanup, have you found any good reason to keep using this switch?  If
you say no, I'm tempted to stop using it.

[11/9/93 public]
I looked through the gcc sources, and I find the following messages which
could come from -Wtraditional:

c-decl.c        c declarations
  function `%s' was previously declared within a block
        * A function declared external in one block and then used after
          the end of the block.

c-lex.c         c lexical scanner
  the meaning of `\\x' varies with -traditional
  the meaning of `\\a' varies with -traditional
        * The character escape sequences `\x' and `\a' evaluate as the
          literal characters `x' and `a' respectively.  Without
          `-traditional', `\x' is a prefix for the hexadecimal
          representation of a character, and `\a' produces a bell.
  width of integer constant changes with -traditional
        * Integer types `unsigned short' and `unsigned char' promote to
          `unsigned int'. (-traditional)
  integer constant is unsigned in ANSI C, signed with -traditional
   * `-2147483648' is positive.
     This is because 2147483648 cannot fit in the type `int', so
     (following the ANSI C rules) its data type is `unsigned long int'.
     Negating this value yields 2147483648 again.
  width of integer constant may change on other systems with -traditional

c-typeck.c      type checking
  `long' switch expression not converted to `int' in ANSI C
        * A `switch' statement has an operand of type `long'.

[05/04/94 public]
Looking a nbase.idl, we have:
typedef unsigned long   unsigned32;         /* positive 32 bit integer */
typedef unsigned long   error_status_t;

So changing error_status_t to be defined as unsigned32 would not help
this warning.  I don't think we are going to declare it to be
an int, so I think the answer is: Yes, anyone who uses an error_status_t
in a switch will have to cast it.

Defect canceled.



CR Number                     : 9389
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 5915
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpcd
Short Description             : rpc_ep_unregister() fails
Reported Date                 : 11/5/93
Found in Baseline             : 1.0.3
Found Date                    : 11/5/93
Severity                      : E
Priority                      : 3
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/5/93 public]
The first part of relocating a clearinghouse is performing a
"cdscp clear clearinghouse" command. during execution of this command,
the clearinghouse endpoint is supposed to be removed from the mapper.
Our calls to rpc_ep_unregister() fail with 382312662:
"not registered in endpoint map (dce / rpc)". The endpoint remains
intact, and when the local clerk tries to access the relocated
clearinghouse, the outdated referral to the local server produces an
unexpected error code which terminates the search, thus not reaching
the new home for the clearinghouse.

I have verified that the information passed to the unregister is
the same as that provided to the previous register request.

[11/8/93 public]

You are seeing the result of OT7174 fix. Are you sure that you are passing
the exactly same interface specification, binding handle vectors and object
UUID vectors? Both rpc_ep_register() and rpc_ep_unregister() create a cross
product from these vectors and add/remove each element in the cross
product. If you are doing:

  rpc_server_use_*protoseqs*();
  rpc_server_inq_bindings(&binding_vector,);
  rpc_ep_register();

  rpc_server_use_*protoseqs*();
  rpc_server_inq_bindings(&binding_vector,);
  rpc_ep_unregister(,binding_vector,,);

the vector of binding handles returned from the fisrt
rpc_server_inq_bindings() call and the one from the second call are likely
different.

[11/8/93 public]
We just did the test over, checking the results with rpccp, and the entry
points go away! So the bug becomes that we get the phony status code.
We are dropping the priority to a minor nuisance.
 As to the comment above, I am using exactly the same binding vector for
both the register and unregister commands.

[11/8/93 public]

I don't think that rpcd returned the phony status code. What happened was
that between the call to rpc_ep_register() and rpc_ep_unregister() someone
else did remove the endpoint(s) registered by the clearinghouse. See my
comment in OT7174. If this defect is going to be kept open, it should be
addressed by 1.1 dced's endpoint mapper.

As for the original cdsclerk problem, is cdsclerk doing
rpc_binding_reset()? Otherwise, it may have a stale endpoint.

[8/15/94 public]
CDS should ignore an 'endpoint not registered' error status.
Note that in 1.1, cdsd complains on shutdown that something it
is trying to unregister is no longer in the endpoint map.

Could cdsadv be removing any endpoints?

The CDS people should re-open this if they can prove the ep_unregister
is returning a bad status code on an existing endpoint.



CR Number                     : 9286
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rpc__socket_inq_endpoint gets incomplete info from getsockname
Reported Date                 : 10/28/93
Found in Baseline             : 1.0.3
Found Date                    : 10/28/93
Severity                      : C
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rpc/runtime/*/comsoc_sys.c
Sensitivity                   : public

[10/28/93 public]

There is evidence (at least in the FTX environment) that getsockname of
a UNIX domain socket which has not been bound to an address will return 0
 (==> ok) without returning the associated naf id.

The consequence in terms of the rpc implementation, is that a call to
rpc__naf_is_connect_closed  (in runtime/comnaf.c) which calls
rpc__socket_inq_endpoint (in runtime/SVR4/comsoc_sys.c) which calls
getsockname such that the naf is not assigned, will lead to a misvectoring
by rpc__naf_is_connect_closed and probably a core dump. 

Although we have not been able to find documentation which specifically
states what the behavior of getsockname should be under these
circumstances, it seems that although an address may not have been bound,
the address family was clearly specified at the time the socket was
created, and should be made available by getsockname.

In any event, if the getsockname does not return the naf, additional
checking should be inserted in the rpc__socket_inq_endpoint to make sure
that a ligitimate address family is returned, or an error should be
returned.

The priority has been set low because this problem has not been reported on
any of our reference platforms. FTX is an SVR4 system, so we should at least
test the behavior of getsockname on our SVR4 reference platform.

I have asked Abbey what the expected behavior of getsockname is on sinix,
and depending on the outcome this report may be targeted more specifically.

I made it an enhnacement request instead of a defect report, because even
if the getsockname does the right thing on most systems. knowledge that it
misbehaves in some environments might inspire us to add a little
checking to our implementations of rpc__socket_inq_endpoint.

[10/29/93 public]

The current implementation of DCE RPC supports IP NAF (AF_INET) only. It
does not support the Unix domain (AF_UNIX) socket. It never open the Unix
domain socket. If Stratus is implementing Unix NAF (it's even not a network
address family, but local.), they are on their own. This is not an only
problem with AF_UNIX, but there are other problems.

[10/29/93 public]

My mistake, the problem was not reported with any specific family, I
incorrectly attributed the problem to UNIX domain sockets. I wasn't sure
what types of sockets RPC employed, but I went ahead and conducted an
experiment to see what getsockname returns for an unbound socket, and the
results indicate that there probably is a problem in our code.

It appears that in in many cases (and in many environments) getsockname does
not modify the family component of sockaddr. What you get is what you
gave getsockname.

The following program demonstrates this point.

#include <sys/types.h>
#include <sys/socket.h>
#include <errno.h>

#define rpc_c_naf_id_ip                 AF_INET
#define rpc_c_network_if_id_stream      SOCK_STREAM
#define rpc_c_network_if_id_dgram       SOCK_DGRAM
#define rpc_c_network_protocol_id_tcp   6
#define rpc_c_socket_ok 0

void main()
{
     int                 sock;
     int                 status;
     struct sockaddr     addr;
     unsigned            length;

     addr.sa_family = -1;

     if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
       printf("socket(AF_INET, SOCK_DGRAM, 0); failed\n");
     else if (getsockname(sock, &addr, &length) == -1)
       printf("getsockname failed, errno:%d\n",errno);
     else printf("address family: %d\n",addr.sa_family);

     addr.sa_family = -1;

     if ((sock = socket(AF_UNIX, SOCK_DGRAM, PF_UNSPEC)) == -1)
       printf("socket(AF_UNIX, SOCK_DGRAM, PF_UNSPEC); failed\n");
     else if (getsockname(sock, &addr, &length) == -1)
       printf("getsockname failed, errno:%d\n",errno);
     else printf("address family: %d\n",addr.sa_family);

     addr.sa_family = -1;

     if ((sock = socket(rpc_c_naf_id_ip, rpc_c_network_if_id_stream,
         rpc_c_network_protocol_id_tcp)) == -1)
       printf("socket(rpc_c_naf_id_ip, rpc_c_network_if_id_stream, \
         rpc_c_network_protocol_id_tc); failed\n");
     else if (getsockname(sock, &addr, &length) == -1)
       printf("getsockname failed, errno:%d\n",errno);
     else printf("address family: %d\n",addr.sa_family);
}

Outputs: Note that 65535 and 255 are different representations of the
         -1 that was assigned before the call to getsockname (the family
         id is unsigned and of differing sizes).      

HPUX:

	address family: 65535
	address family: 65535
	address family: 65535
	$

RIOS:
	address family: 255
	address family: 255
	address family: 255
	$

PMAX/OSF1:

	address family: 2
	address family: 65535
	address family: 65535
	$

SINIX:
	Segmentation Fault - core dumped

	(I'm waiting for SNI to give us a better result).

Proposed Enhancement:

	in rpc__socket_inq_endpoint, initialize addr.sa_family to
	AF_UNSPEC /* unspecified */ before calling getsockname,
        and test that addr.sa_family < AF_MAX after returning from
        getsockname.

[10/29/93 public]

Sorry, your test program doesn't initialize length=sizeof(addr). Also,
depending on the protocol family, you must use the different structure for
addr, i.e., struct sockaddr_in for AF_INET, to have enough space for
address. (Though you can get the address family by using struct sockaddr.)

[10/29/93 public]

thaks for attending to this so quickly, I have made the corrections
you pointed out, and the program demonstrates that getsockname
does set family to an appropriate value. These changes also corrected
core dump on sinix, and sinix returned

        address family: 2
        address family: 0
        address family: 2

I will ask submitter to run the test program on their machine.
It is probably safe to close this defect.

[11/10/93 public]

The following additional information was provided by the submitter:

AF_INET, SOCK_STREAM

the problem we have seen at Stratus (on their svr4 based port of DCE)
is actually that getsockname
returns 0 with an invalid address family when the connection is closed by
the other end.  When this happens, a T_DISCON_IND is received by sockmod,
and sockmod in turn send an M_ERROR streams message upstream to set the
write error on the socket to EPIPE.  Since getsockname must write to the
stream in order to obtain the infomation from sockmod, it fails with EPIPE
internally and the error code is not passed back to the application.

In any case, using the returned naf id as an index to an epv table without
checking wether it's valid or not does not appear to be a good idea to me.
Although we have got the problem fixed in our getsockname, performing the
ckeck should only provide a degree of robustness to the DCE applications.

[11/10/93 public]

How do you check if the returned naf id is valid or not? The returned
addr->sa (garbage) from getsockname() may have a valid id. The callers of
rpc__naf_desc_inq_naf_id() always check the returned status. If we can't
trust the status back from the syscalls, how can we code?

Clearly Stratus's socket implementation is broken because getsockname()
returns zero when it shouldn't. (errno should be set to EINVAL, I believe.)
I think that they should fix it or implement their own
rpc__socket_inq_endpoint(), which is the system dependent function. (Is OSF
going to ensure the portability of DCE onto broken systems? :-)

[05/04/94 public]
Going to have to go with Seiichi on this one.  Stratus has a broken
socket interface and it isn't DCE's fault.  Also, these routines
are machine dependant, and all the reference platforms work, so
its the vendors responsibility to rewrite this code as necessary
for their platforms.

Canceled.



CR Number                     : 9250
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : cn
Short Description             : Timer thread uses the assoc after freeing it
Reported Date                 : 10/25/93
Found in Baseline             : 1.0.3
Found Date                    : 10/25/93
Severity                      : A
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rpc/runtime/cnassoc.h
                                             rpc/runtime/cnassoc.c
Sensitivity                   : public

[10/25/93 public]

rpc__cn_assoc_reclaim() function MAY use the assoc after deallocating it.
Here is the code fragment from rpc__cn_assoc_reclaim():

                        /*
                         * Done with the shutdown attempt, so decrement the
                         * reference count. This is done via the acb dealloc
                         * routine.
                         */
                        rpc__cn_assoc_acb_dealloc (assoc);
                    }
		    if (loop == false && shutdown_or_abort == true)
			return;
                    RPC_LIST_NEXT (assoc, assoc, rpc_cn_assoc_p_t);
                } /* end while (assoc != NULL) */

If the call to rpc__cn_assoc_acb_dealloc() actually deallocates the assoc
(frees it or returns it to the lookasisde list), RPC_LIST_NEXT() will use
the already deallocated assoc. OT7504 fix eliminates this possibility when
the assoc was shutdown or aborted. However, there is still a chance that
acb_ref_count goes down to zero when rpc__cn_assoc_acb_dealloc() is called
in other cases. (It's a rare case, which happens only when there are thread
context switches before calling rpc__cn_assoc_acb_dealloc() and the
receiver thread releases the reference to the assoc. And even if this
happens assoc->next is still likely pointing to the right place.)

The proposed fix is to make rpc__cn_assoc_acb_dealloc() return a boolean
indicating if it called rpc__list_element_free().

In cnassoc.h line# ~384, change the signature:

PRIVATE boolean32 rpc__cn_assoc_acb_dealloc PROTOTYPE ((
    rpc_cn_assoc_p_t            assoc));

In rpc__cn_assoc_acb_dealloc()::cnassoc.c at line# ~4176, change the the
signature:

PRIVATE boolean32 rpc__cn_assoc_acb_dealloc (assoc)

at line# ~4184, after "rpc_cn_call_rep_t *call_r;", add:

    boolean32                   dflag = false;

and at line# ~4311, after the call to rpc__list_element_free(), add:

        dflag = true;

In rpc__cn_assoc_reclaim()::cnassoc.c at line# ~4036, change:

                        /*
                         * If the assoc has been deallocated, don't continue.
                         * There is a chance that the thread context switch
                         * happened.
                         */
                        if (rpc__cn_assoc_acb_dealloc (assoc) == true)
                            return;

I've found this by the code review and have no test for this. Thus the
priority is 2 (not a stopper for 1.0.3 :-).

[10/25/93 public]
Would this be a better fix for 9090 than passing a cancel up from
the list_free routine?

[10/25/93 public]

Definitely not. Whether rpc__list_element_free() is called or not is
irreverent for OT9090. It is whether rpc__cn_assoc_acb_free() is called or
not.

Well, after opening this CR, I've found the error in my logic. It is
impossible for the receiver thread to decrease the acb_ref_count because
the timer thread is holding the global mutex. So, this can happen only if
acb_ref_count was already zero when the timer thread incremented it, which
means that there was an unused assoc on the grp_assoc_list. The
grp_assoc_list corruption has occurred before the timer thread's execution.
Looks like this CR is going to be cancelled...

[8/16/94 public]
Since Seiichi says it should be canceled....



CR Number                     : 9060
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpccp
Short Description             : can't enter strings with spaces
Reported Date                 : 10/6/93
Found in Baseline             : 1.0.2
Found Date                    : 10/6/93
Severity                      : D
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : Not applicable
Sensitivity                   : public

[10/6/93 public]
There is no way from within rpccp to enter a string (such as the name of an
entry) with a space in it.

  rpccp>  show entry foo bar

does not work.  Placing foo bar in double or single quotes does not work,
nor does putting a \ before the space.  There should be a way to do this.

There is at least one work around.  Enter the command from the shell prompt
as follows:
 
  $ rpccp show entry "foo bar"

I also suspect that you could make use of rpccp's environment variable
processing to handle this as follows:

  $ export NAME="foo bar"
  $ rpccp
  $ show entry NAME

but I have not actually tried this.

There should probably be a mention in the documentation of this problem if
it is punted because dcecp will handle thi.

[05/04/94 public]
This is being punted since dcecp will replace rpccp.
Changed to a doc bug for someone to make a note of this in
rpccp man pages and point admin to dcecp.

[5/13/94 public]

Assigned this CR to John Shirley (OSF RPC writer).

[8/26/94 public]
This CR is moot because dcecp can do it and it supercedes

[9/6/94 public]
Entered correct status of cancel, not closed



CR Number                     : 8907
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8274
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : thread hang in 
rpc__cn_assoc_receive_frag
Reported Date                 : 10/4/93
Found in Baseline             : 1.0.2
Found Date                    : 10/4/93
Severity                      : A
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/4/93 public]

Thread trace for 7 =========>>

The following stack was found in cdsclerk which was in a deadlock:

cma__dispatch(0x200c2d68, 0x200c0db8, 0x200c2a88) at 0xd065d678
cma__block(0x200c2d68, 0x200c0db8) at 0xd065d3c0
ptdexc_cond_wait(0x200c2d68, 0x200c0db8) at 0xd06717c4
rpc__cn_assoc_request(0x200c2d68, 0x200c0db8, 0x200c2a88, 0x200c0ad8, 0x0,
0x0,
0x0) at 0xd0484c0c
allocate_assoc_action_rtn(0x200c2d68, 0x200c0db8) at 0xd04840a4
rpc__cn_sm_eval_event(0x200c2d68, 0x200c0db8, 0x200c2a88, 0x200c0ad8) at
0xd0488
a5c
rpc__cn_call_start(0x200c2d68, 0x200c0db8, 0x200c2a88, 0x200c0ad8, 0x0,
0x0) at
0xd0462b20
rpc_call_start(0x200c2d68, 0x200c0db8, 0x200c2a88, 0x200c0ad8, 0x0, 0x0,
0x0) at
 0xd0461638
cds_ReadAttribute(0x200c2d68, 0x200c0db8, 0x200c2a88, 0x200c0ad8, 0x0, 0x0,
0x0,
 0x20132b38) at 0x1001e6ac
ReadAttributeRPC(0x200c2d68, 0x200c0db8, 0x200c2a88) at 0x10030dec
processAddr(0x200c2d68, 0x200c0db8, 0x200c2a88) at 0x1002d440
processCH(0x200c2d68, 0x200c0db8) at 0x1002cfb4
clerk_WalkTree(0x200c2d68, 0x200c0db8) at 0x1002ccac
sendToWalkTree(0x200c2d68, 0x200c0db8) at 0x1002da84
clerkReadAttribute(0x200c2d68) at 0x10031e58
clerk_request(0x200c2d68) at 0x10010eb4
th_start(0x200c2d68) at 0xd055e2b0
cma__thread_base(0x200c2d68) at 0xd0666650

Thread trace for 24 =========>>
cma__dispatch(0x200d2e90, 0x202435e8, 0x200d2bb0) at 0xd065d678
cma__block(0x200d2e90, 0x202435e8) at 0xd065d3c0
ptdexc_cond_wait(0x200d2e90, 0x202435e8) at 0xd06717c4
rpc__cn_assoc_receive_frag(0x200d2e90, 0x202435e8, 0x200d2bb0) at
0xd0485924
rpc__cn_assoc_open(0x200d2e90, 0x202435e8, 0x200d2bb0, 0x20243308, 0x0,
0x0, 0x0
, 0xc00) at 0xd0486c94
rpc__cn_assoc_request(0x200d2e90, 0x202435e8, 0x200d2bb0, 0x20243308, 0x0,
0x0,
0x0) at 0xd0484d60
allocate_assoc_action_rtn(0x200d2e90, 0x202435e8) at 0xd04840a4
rpc__cn_sm_eval_event(0x200d2e90, 0x202435e8, 0x200d2bb0, 0x20243308) at
0xd0488
a5c
rpc__cn_call_start(0x200d2e90, 0x202435e8, 0x200d2bb0, 0x20243308, 0x0,
0x0) at
0xd0462b20
rpc_call_start(0x200d2e90, 0x202435e8, 0x200d2bb0, 0x20243308, 0x0, 0x0,
0x0) at
 0xd0461638
cds_ReadAttribute(0x200d2e90, 0x202435e8, 0x200d2bb0, 0x20243308, 0x0, 0x0,
0x0,
 0xc00) at 0x1001e6ac
ReadAttributeRPC(0x200d2e90, 0x202435e8, 0x200d2bb0) at 0x10030dec
processAddr(0x200d2e90, 0x202435e8, 0x200d2bb0) at 0x1002d440
processCH(0x200d2e90, 0x202435e8) at 0x1002cfb4
clerk_WalkTree(0x200d2e90, 0x202435e8) at 0x1002ccac
sendToWalkTree(0x200d2e90, 0x202435e8) at 0x1002da84
clerkReadAttribute(0x200d2e90) at 0x10031e58
clerk_request(0x200d2e90) at 0x10010eb4
th_start(0x200d2e90) at 0xd055e2b0
cma__thread_base(0x200d2e90) at 0xd0666650

Thread trace for 43 =========>>
cma__dispatch(0x20386bb8, 0x20250f50, 0x203868d8) at 0xd065d678
cma__block(0x20386bb8, 0x20250f50) at 0xd065d3c0
ptdexc_cond_wait(0x20386bb8, 0x20250f50) at 0xd06717c4
rpc__cn_assoc_request(0x20386bb8, 0x20250f50, 0x203868d8, 0x20250c70, 0x0,
0x0,
0x0) at 0xd0484c0c
allocate_assoc_action_rtn(0x20386bb8, 0x20250f50) at 0xd04840a4
rpc__cn_sm_eval_event(0x20386bb8, 0x20250f50, 0x203868d8, 0x20250c70) at
0xd0488
a5c
rpc__cn_call_start(0x20386bb8, 0x20250f50, 0x203868d8, 0x20250c70, 0x0,
0x0) at
0xd0462b20
rpc_call_start(0x20386bb8, 0x20250f50, 0x203868d8, 0x20250c70, 0x0, 0x0,
0x0) at
 0xd0461638
op3_csr(0x20386bb8, 0x20250f50, 0x203868d8, 0x20250c70, 0x0, 0x0, 0x0,
0x2007cb1
0) at 0xd046a860
ep_get_endpoint(0x20386bb8, 0x20250f50, 0x203868d8) at 0xd04672a8
rpc_ep_resolve_binding(0x20386bb8, 0x20250f50, 0x203868d8) at 0xd0466efc
rpc__cn_call_start(0x20386bb8, 0x20250f50, 0x203868d8, 0x20250c70, 0x0,
0x0) at
0xd046287c
rpc_call_start(0x20386bb8, 0x20250f50, 0x203868d8, 0x20250c70, 0x0, 0x0,
0x0) at
 0xd0461638
op4_csr(0x20386bb8, 0x20250f50, 0x203868d8, 0x20250c70, 0x0) at 0xd04839ec
rpc_mgmt_inq_server_princ_name(0x20386bb8, 0x20250f50, 0x203868d8,
0x20250c70) a
t 0xd04816bc
get_secure_handle(0x20386bb8, 0x20250f50, 0x203868d8) at 0x10013a90
get_rpc_handle(0x20386bb8, 0x20250f50, 0x203868d8, 0x20250c70) at
0x10013748
ReadAttributeRPC(0x20386bb8, 0x20250f50, 0x203868d8) at 0x10030e6c
processAddr(0x20386bb8, 0x20250f50, 0x203868d8) at 0x1002d440
processCH(0x20386bb8, 0x20250f50) at 0x1002cfb4
clerk_WalkTree(0x20386bb8, 0x20250f50) at 0x1002ccac
sendToWalkTree(0x20386bb8, 0x20250f50) at 0x1002da84
clerkReadAttribute(0x20386bb8) at 0x10031e58
clerk_request(0x20386bb8) at 0x10010eb4
th_start(0x20386bb8) at 0xd055e2b0
cma__thread_base(0x20386bb8) at 0xd0666650

Thread trace for 45 =========>>
cma__dispatch(0x2038b1a0, 0x20388f30, 0x2038aec0) at 0xd065d678
cma__block(0x2038b1a0, 0x20388f30) at 0xd065d3c0
ptdexc_cond_wait(0x2038b1a0, 0x20388f30) at 0xd06717c4
rpc__cn_assoc_request(0x2038b1a0, 0x20388f30, 0x2038aec0, 0x20388c50, 0x0,
0x0,
0x0) at 0xd0484c0c
allocate_assoc_action_rtn(0x2038b1a0, 0x20388f30) at 0xd04840a4
rpc__cn_sm_eval_event(0x2038b1a0, 0x20388f30, 0x2038aec0, 0x20388c50) at
0xd0488
a5c
rpc__cn_call_start(0x2038b1a0, 0x20388f30, 0x2038aec0, 0x20388c50, 0x0,
0x0) at
0xd0462b20
rpc_call_start(0x2038b1a0, 0x20388f30, 0x2038aec0, 0x20388c50, 0x0, 0x0,
0x0) at
 0xd0461638
op3_csr(0x2038b1a0, 0x20388f30, 0x2038aec0, 0x20388c50, 0x0, 0x0, 0x0,
0x201cb6c
8) at 0xd046a860
ep_get_endpoint(0x2038b1a0, 0x20388f30, 0x2038aec0) at 0xd04672a8
rpc_ep_resolve_binding(0x2038b1a0, 0x20388f30, 0x2038aec0) at 0xd0466efc
rpc__cn_call_start(0x2038b1a0, 0x20388f30, 0x2038aec0, 0x20388c50, 0x0,
0x0) at
0xd046287c
rpc_call_start(0x2038b1a0, 0x20388f30, 0x2038aec0, 0x20388c50, 0x0, 0x0,
0x0) at
 0xd0461638
op4_csr(0x2038b1a0, 0x20388f30, 0x2038aec0, 0x20388c50, 0x0) at 0xd04839ec
rpc_mgmt_inq_server_princ_name(0x2038b1a0, 0x20388f30, 0x2038aec0,
0x20388c50) a
t 0xd04816bc
get_secure_handle(0x2038b1a0, 0x20388f30, 0x2038aec0) at 0x10013a90
get_rpc_handle(0x2038b1a0, 0x20388f30, 0x2038aec0, 0x20388c50) at
0x10013748
ReadAttributeRPC(0x2038b1a0, 0x20388f30, 0x2038aec0) at 0x10030e6c
processAddr(0x2038b1a0, 0x20388f30, 0x2038aec0) at 0x1002d440
processCH(0x2038b1a0, 0x20388f30) at 0x1002cfb4
clerk_WalkTree(0x2038b1a0, 0x20388f30) at 0x1002ccac
sendToWalkTree(0x2038b1a0, 0x20388f30) at 0x1002da84
clerkReadAttribute(0x2038b1a0) at 0x10031e58
clerk_request(0x2038b1a0) at 0x10010eb4
th_start(0x2038b1a0) at 0xd055e2b0
cma__thread_base(0x2038b1a0) at 0xd0666650

Thread trace for 47 =========>>
cma__dispatch(0x2038f8e8, 0x2038d678, 0x2038f608) at 0xd065d678
cma__block(0x2038f8e8, 0x2038d678) at 0xd065d3c0
ptdexc_cond_wait(0x2038f8e8, 0x2038d678) at 0xd06717c4
rpc__cn_assoc_request(0x2038f8e8, 0x2038d678, 0x2038f608, 0x2038d398, 0x0,
0x0,
0x0) at 0xd0484c0c
allocate_assoc_action_rtn(0x2038f8e8, 0x2038d678) at 0xd04840a4
rpc__cn_sm_eval_event(0x2038f8e8, 0x2038d678, 0x2038f608, 0x2038d398) at
0xd0488
a5c
rpc__cn_call_start(0x2038f8e8, 0x2038d678, 0x2038f608, 0x2038d398, 0x0,
0x0) at
0xd0462b20
rpc_call_start(0x2038f8e8, 0x2038d678, 0x2038f608, 0x2038d398, 0x0, 0x0,
0x0) at
 0xd0461638
op3_csr(0x2038f8e8, 0x2038d678, 0x2038f608, 0x2038d398, 0x0, 0x0, 0x0,
0x2034dd4
8) at 0xd046a860
ep_get_endpoint(0x2038f8e8, 0x2038d678, 0x2038f608) at 0xd04672a8
rpc_ep_resolve_binding(0x2038f8e8, 0x2038d678, 0x2038f608) at 0xd0466efc
rpc__cn_call_start(0x2038f8e8, 0x2038d678, 0x2038f608, 0x2038d398, 0x0,
0x0) at
0xd046287c
rpc_call_start(0x2038f8e8, 0x2038d678, 0x2038f608, 0x2038d398, 0x0, 0x0,
0x0) at
 0xd0461638
op4_csr(0x2038f8e8, 0x2038d678, 0x2038f608, 0x2038d398, 0x0) at 0xd04839ec
rpc_mgmt_inq_server_princ_name(0x2038f8e8, 0x2038d678, 0x2038f608,
0x2038d398) a
t 0xd04816bc
get_secure_handle(0x2038f8e8, 0x2038d678, 0x2038f608) at 0x10013a90
get_rpc_handle(0x2038f8e8, 0x2038d678, 0x2038f608, 0x2038d398) at
0x10013748
ReadAttributeRPC(0x2038f8e8, 0x2038d678, 0x2038f608) at 0x10030e6c
processAddr(0x2038f8e8, 0x2038d678, 0x2038f608) at 0x1002d440
processCH(0x2038f8e8, 0x2038d678) at 0x1002cfb4
clerk_WalkTree(0x2038f8e8, 0x2038d678) at 0x1002ccac
sendToWalkTree(0x2038f8e8, 0x2038d678) at 0x1002da84
clerkReadAttribute(0x2038f8e8) at 0x10031e58
clerk_request(0x2038f8e8) at 0x10010eb4
th_start(0x2038f8e8) at 0xd055e2b0
cma__thread_base(0x2038f8e8) at 0xd0666650

Thread trace for 49 =========>>
cma__dispatch(0x20393fd8, 0x20391d68, 0x20393cf8) at 0xd065d678
cma__block(0x20393fd8, 0x20391d68) at 0xd065d3c0
ptdexc_cond_wait(0x20393fd8, 0x20391d68) at 0xd06717c4
rpc__cn_assoc_request(0x20393fd8, 0x20391d68, 0x20393cf8, 0x20391a88, 0x0,
0x0,
0x0) at 0xd0484c0c
allocate_assoc_action_rtn(0x20393fd8, 0x20391d68) at 0xd04840a4
rpc__cn_sm_eval_event(0x20393fd8, 0x20391d68, 0x20393cf8, 0x20391a88) at
0xd0488
a5c
rpc__cn_call_start(0x20393fd8, 0x20391d68, 0x20393cf8, 0x20391a88, 0x0,
0x0) at
0xd0462b20
rpc_call_start(0x20393fd8, 0x20391d68, 0x20393cf8, 0x20391a88, 0x0, 0x0,
0x0) at
 0xd0461638
op3_csr(0x20393fd8, 0x20391d68, 0x20393cf8, 0x20391a88, 0x0, 0x0, 0x0,
0x2034fd8
8) at 0xd046a860
ep_get_endpoint(0x20393fd8, 0x20391d68, 0x20393cf8) at 0xd04672a8
rpc_ep_resolve_binding(0x20393fd8, 0x20391d68, 0x20393cf8) at 0xd0466efc
rpc__cn_call_start(0x20393fd8, 0x20391d68, 0x20393cf8, 0x20391a88, 0x0,
0x0) at
0xd046287c
rpc_call_start(0x20393fd8, 0x20391d68, 0x20393cf8, 0x20391a88, 0x0, 0x0,
0x0) at
 0xd0461638
op4_csr(0x20393fd8, 0x20391d68, 0x20393cf8, 0x20391a88, 0x0) at 0xd04839ec
rpc_mgmt_inq_server_princ_name(0x20393fd8, 0x20391d68, 0x20393cf8,
0x20391a88) a
t 0xd04816bc
get_secure_handle(0x20393fd8, 0x20391d68, 0x20393cf8) at 0x10013a90
get_rpc_handle(0x20393fd8, 0x20391d68, 0x20393cf8, 0x20391a88) at
0x10013748
EnumerateObjectsRPC(0x20393fd8, 0x20391d68, 0x20393cf8) at 0x1003a518
processAddr(0x20393fd8, 0x20391d68, 0x20393cf8) at 0x1002d440
processCH(0x20393fd8, 0x20391d68) at 0x1002cfb4
clerk_WalkTree(0x20393fd8, 0x20391d68) at 0x1002ccac
sendToWalkTree(0x20393fd8, 0x20391d68) at 0x1002da84
clerkEnumerateObjects(0x20393fd8) at 0x1003aa5c
clerk_request(0x20393fd8) at 0x10010eb4
th_start(0x20393fd8) at 0xd055e2b0
cma__thread_base(0x20393fd8) at 0xd0666650

[10/5/93 public]

Is this really an RPC problem? The above stack dump doesn't show the
receiver thread and rpc__cn_assoc_receive_frag() was not hanging. It was
just conditional-waiting.

[10/05/93 public]

Added myself to the cc list, I seem to be having a similar problem on an
HP machine running DCE 1.0.3 from 09/30.  I can not restart my security
server machine, dtsd hangs during startup.  If I comment out dtsd from
/etc/rc.dce, rpcd, secd and the cdsadv start but as soon as I try one
DCE command my cell hangs.  I did not see this problem using a DCE 1.0.3
build from 09/24.

[10/05/93 public]

cdsclerk is chewing CPU cycles after the hang.

[10/6/93 public]
I don't think this is a deadlock scenario.
All the threads are trying to open an association.
Only Thread 24 is ahead of the other threads - looks like, its waiting 
for a response for a Bind PDU.

Two questions:
1. Client will wait indefinitely for a response for a Bind PDU
- is this behavior correct?
(See the OT 8224).

2. Why did not this thread receive a response bind PDU from the server?
Anything funny going on the server side or the heavy load factor of the cell
is contributing to the above scenario?

[10/6/93 public]

Since the thread 24 is in rpc__cn_assoc_open(), it's holding the grp_new
mutex and other threads are cond_wait'ing. (Assuming that all threads are
talking to the same server.) The BIND_ACK is sent by the server's receiver
thread. A problem in the server's receiver thread or the client's receiver
thread? Is a receiver thread started in the client?

[Kapoor 10/7/93 public]
I would appreciate if I could find out for sure that modifying
rpc_c_assoc_grp_alloc_size from 100 to 10 has been tested out in a high stress
environment.

[10/7/93 public]

We have succesfully run our scalability testing, ~50 client nodes for 8
hours, with rpc_c_assoc_grp_alloc_size=10.
Can anyone get the stack dumps of all known threads? On HP-UX, you can use
xdb macros in /afs/dce/project/dce/hp/debug-macros or
/afs/dce/project/dce/hp/debug-macros/xdb . You may need to "kill -ABRT" to
get a coredump.
Or if you can tolerate a lot of output (use the script command to capture
it :-), try
RPC_DEBUG=0.20,1-3.7,11.10,12,13.3,14.20,16.8,23,24,26.2,27,28,30
with cdsadv -f -v. (As long as RPC runtime is alive, you'll see the heart
beat from the timer thread, rpc__cn_assoc_timer_reclaim.)

[10/15/93 public]
The problem was traced to the presence of a secondary CDS server that was not
responding at all, but all the requests were being directed to that server.



CR Number                     : 8893
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rpc_server_inq_bindings returns "no bindings (dce / rpc)" when invoked after rpc_server_use_all_protseqs_if
Reported Date                 : 10/4/93
Found in Baseline             : 1.0.2a
Found Date                    : 10/4/93
Severity                      : C
Priority                      : 3
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/4/93 public]

An OSF DME engineer found this when writinng an application which 
calls rpc_server_use_all_protseqs_if() [instead of 
rpc_server_use_all_protseqs()] and then calls 
rpc_server_inq_bindings(). Adding a call to rpc_server_register_if()
before calling rpc_server_inq_bindings() makes no difference.

The DCE documentation uses general terms to lead one to believe this 
approach is correct.

The same behavior exists in dce1.0.3. A short test program to exhibit 
the problem follows.

The program takes a command line argument (just the letter 'a') and use
plain old  use_all_protseqs() instead of the _if() : It _does_work_ (!!)
when the 'a' is given:

golem 108 > ./test
ERROR rpc_server_inq_bindings: no bindings (dce / rpc)
golem 109 > ./test a
Success! Got bindings.
golem 110 >

The new test program is below; also there is "test.idl" -- it is required
to produce the  rdaclif_v0_0_s_ifspec 

  The pieces below are standalone -- you can try them yourself.

========================  Makefile  ====================


USEDCE=1

WARNS   = -Wall -Wstrict-prototypes
CFLAGS  = $(DEFS) $(WARNS)

IDLFILES = test.idl

PROGRAMS=test

test_OFILES = test.o test_sstub.o

test_sstub.o_CFLAGS = -Di386

test.o: test.c

test.idl:

# use common makefiles
.include <${RULES_MK}>

==========================================================================

============================  test.c  ====================================

#include <stdio.h>

#include <dce/dce_error.h>

#include <dce/aclbase.h>
#include <dce/rpcexc.h>
#include <dce/rdaclif.h>
#include <dce/rpc.h> 
#include <dce/sec_login.h>
#include <dce/rgybase.h>

void CHECK_RPC_STATUS(unsigned long dce_status, char *msg)
{
    if ( dce_status != error_status_ok )
    { 
	unsigned char   buff[dce_c_error_string_len];
	int		j;
	dce_error_inq_text(dce_status, buff, &j);
	fprintf(stderr,"ERROR %s: %s\n",msg,buff); 
	exit(-1); 
    }
}


int main(int argc, char **argv)
{
    unsigned long rpc_status;
    
    rpc_binding_vector_t *acl_binding_vector;
    
    rpc_server_register_if(rdaclif_v0_0_s_ifspec,
			   (uuid_t *)NULL, 
			   (rpc_mgr_epv_t)NULL,
			   &rpc_status);
    CHECK_RPC_STATUS(rpc_status, "rpc_server_register_if");
    
    /*
     * Use all protocol sequences for the rdacl interface.
     */

    /* with command line argument 'a', use plain old 'all_protseq' */
    if ( argc > 1 && argv[1][0] == 'a' )   
	rpc_server_use_all_protseqs(rpc_c_protseq_max_calls_default,
				   &rpc_status); 
    else
	rpc_server_use_all_protseqs_if(rpc_c_protseq_max_calls_default,
				       rdaclif_v0_0_s_ifspec,
				       &rpc_status); 
    
    CHECK_RPC_STATUS(rpc_status, "rpc_server_use_all_protseqs_if");
    
    /*
     * Obtain a vector of server binding handles from the DCE RPC runtime.
     */
    rpc_server_inq_bindings(&acl_binding_vector, &rpc_status);
    CHECK_RPC_STATUS(rpc_status, "rpc_server_inq_bindings");
    
    fprintf(stderr,"Success! Got bindings.\n");
   
}


void foo(char *bar)    /* "stub" function for the IDL file */
{                      /* the IDL compiler does NOT like empty files :-) */
}

===========================================================================

================================  test.idl ================================
/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1990, 1991, 1992, 1993 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE in the
 * src directory for the full copyright text.
 */
/*
 * historry  
 *
 * Revision 1.1.4.2  1992/12/29  13:30:15  zeliff
 * 	Embedding copyright notice
 * 	[1992/12/28  20:48:29  zeliff]
 *
 * Revision 1.1.2.2  1992/05/08  14:49:31  burati
 * 	Cleaned up comments.
 * 	[1992/05/07  15:15:48  burati]
 * 
 * 	Add rdacl_get_mgr_types_semantics(...)
 * 	[1992/04/29  03:05:27  burati]
 * 
 * Revision 1.1  1992/01/19  14:55:25  devrcs
 * 	Initial revision
 * 
 * 
 */

/*  rdaclif.idl V=11 10/28/91 //littl/prgy/src/idl
**
** Copyright (c) Hewlett-Packard Company 1991
** Unpublished work. All Rights Reserved.
**
*/

[10/4/93 public]
Workaround for OT bug (doesn't like the string H I S T O R Y - without the spaces) 
in the note text.
The rest of that IDL definition is:

[10/4/93 public]
OT doesn't like square brackets in column 0 either.
	 [
	     uuid(47B33331-8000-0000-0D00-01DC6C000000)
	 ]
	 
	 interface rdaclif {
	 
	 	typedef [ref] char *foobar;
	 
	 
	     void foo([in,out] char *bar);
	 
	 }

[10/5/93 public]

This is a user error. You must define the well-known endpoint in your IDL
file to use rpc_server_use_all_protseqs_if(). The documentation is clear.
From rpc_server_use_all_protseqs_if(3) man page:

      rpc_server_use_all_protseqs_if - Tells the RPC runtime to use all the
      protocol sequences and endpoints specified in the interface
      specification for receiving remote procedure calls

	:
	:

      if_handle
          Specifies an interface specification containing the protocol
          sequences and their corresponding endpoint information to use in
          creating binding handles.  Each created binding handle contains a
          well-known (nondynamic) endpoint contained in the interface
          specification.

[10/05/93 public]
Seiichi is is correct, you are not specifying an endpoint when you
use rpc_server_use_all_protseqs_if().

Canceled.



CR Number                     : 8868
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : rpc/runtime ?
Short Description             : invalid endpoint entry in rpc
Reported Date                 : 9/29/93
Found in Baseline             : 1.0.3
Found Date                    : 9/29/93
Severity                      : A
Priority                      : 0
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : cdscp
Sensitivity                   : public

[9/29/93 public]

During DCE cell setup for the RIOS smoketest dce_config failed when
it tried to start cdsadv and cdsd with the complaints:

S:****** Starting cdsadv...
invalid endpoint entry (dce / rpc)
S:****** Starting cdsd...
invalid endpoint entry (dce / rpc)
ERROR:   cdscp show dir /.: failing -- CDS not usable

[09/29/93 public]
This was caused by a corrupt rpcdep.dat (the endpoint database) file.
A removal of this file allow the cell to come up.

Bug canceled.



CR Number                     : 8656
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : mx300
S/W Ref Platform              : sinix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : closing fd 0 before server exports bindings causes CN/RPC hang
Reported Date                 : 9/22/93
Found in Baseline             : 1.0.2a
Found Date                    : 9/22/93
Severity                      : B
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/22/93 public]

A problem was detected when file descriptor 0 is closed by a server
prior to the point at which the server exports it's bindings. A test
program was provided which was shown at OSF to be capable of reproducing
the reported problem on the OSF SVR4 reference platform (Frenzy release
from SNI, installed at OSF on machine sni1). It was also demonstated that
the problem copuld not be reproduced on the other DCE refernce platforms.

	rios/aix
	pmax/osf1 (486/osf1 was not tried)
	hp/ux

The test program was pakaged along with instructions, and sent to SNI
for resolution.

More detail on what the program does, and what the problem looks like:

	This example illustrates a bug in the DCE RPC Runtime when the CN
        protocol is used. If file descriptor zero is closed prior to the
        server exporting its bindings, the server will sometimes forget to
        post the file descriptor for the TCP port when it does a
        select/poll call. 

        As a result of this problem, a client of the server will hang
        when it performs the corresponding rpc_mgmt_is_server_listening().

	The problem does not occur if the client uses a DG binding
        in the rpc_mgmt_is_server_listening() call, or id the server
        doesn not close file descriptor 0 before exporting it's bindings.

uuencoded tar archive of the test program including directions on how to
build and execute it is include below.
-------------
begin 644 sni.tar
M+@                                                          
M                                                            
M             # P,# W-34 ,# R,S8Q,@ P,# P,# Q # P,# P,# P,# P
M # U-#0V,S,U-C,P # P,3(R,#  -0                              
M                                                            
M                                          !U<W1A<@ P,&UO;GII
M;&QO                                ;W1H97(                 
M                   P,# P,# P # P,# P,#$                     
M                                                            
M                                                            
M                                                            
M                       N+U)%041-10                          
M                                                            
M                                    ,# P,#8T-  P,#(S-C$R # P
M,# P,#$ ,# P,# P,#4P-#$ ,#4T-#4Q,C(S,S  ,# Q,S$R-0 P        
M                                                            
M                                                            
M     '5S=&%R # P;6]N>FEL;&\                               !O
M=&AE<@                                   # P,# P,#  ,# P,# P
M,0                                                          
M                                                            
M                                                            
M                                             $%B8F5Y+ H*"51H
M:7,@8G5G('=A<R!R97!O<G1E9"!B>2!0>7)A;6ED+"!W:&\@9&5M;VYS=')A
M=&5D('1H870@=&AE('!R;V)L96T*9&ED(&YO="!E>&ES="!O;B Q+C N,B!0
M34%8+B!)(&AA=F4@<VEN8V4@9&5M;VYS=')A=&5D('1H870@,2XP+C(@56QT
M<FEX+"!A;F0*,2XP+C,@:'!U>"!T;R!B92!F<F5E(&]F('1H92!R97!O<G1E
M9"!P<F]B;&5M+@H*"4D@:&%V92!S96YT('EO=2!T:&5I<B!S86UP;&4@<')O
M9W)A;2X@0V]U;&0@>6]U('!L96%S92!T<GD@=&\@<F5P<F]D=6-E"G1H92!P
M<F]B;&5M(&]N(&%N(&%P<')O<')I871E("AK;F]W:6YG('=H870@4'ER86UI
M9"!I<R!W;W)K:6YG('=I=&@L(&%N9"!W:&%T"FES(&%V86EL86)L92!T;R!Y
M;W4I(')E;&5A<V4@;V8@=&AE(%-64C0@=F5R<VEO;B!O9B!$0T4N"@H)22!M
M861E('-O;64@<VUA;&P@8VAA;F=E<R!T;R!T:&4@=&]P(&QE=F5L(&UA:V5F
M:6QE('!R;W9I9&5D(&)Y('1H96TN"D]T:&5R=VES92P@22!W87,@86)L92!T
M;R!R=6X@=&AE('1E<W0@<')E='1Y(&UU8V@@8GD@9F]L;&]W:6YG('1H92!D
M:7)E8W1I;VYS"BAB96QO=RD@9VEV96X@8GD@4'ER86UI9"X@3VYE('=A>2!T
M;R!Q=6EC:VQY(&)U:6QD('1H92!T97-T('!R;V=R86TL('=O=6QD(&)E"G1O
M(&UA:V4@<W9R-"!S<&5C:69I8R!-86ME9FEL97,@*$UA:V5F:6QE+G-V<C0I
M(&)E;F5A=&@@=&AE(&-L:65N="!A;F0@<V5R=F5R"F1I<F5C=&]R:65S+"!A
M;F0@8VAA;F=E('1H92!V86QU92!O9B!-04-(24Y%(&EN('1H92!T;W @;&5V
M96P@;6%K969I;&4@=&\@(G-V<C0B"DD@;6%D92!T:&5S92!C:&%N9V5S(&9O
M<B!Y;W4L('EO=2!W:6QL(&IU<W0@:&%V92!T;R!M86ME('1H92!-86ME9FEL
M92YS=G(T(&9I;&5S"G-U:71A8FQE(&9O<B!U<V4@;VX@>6]U<B!0;&%T9F]R
M;2X*"E1H86YK<R!F;W(@>6]U<B!H96QP+@D*"E)O;B!-;VYZ:6QL;PI$0T4@
M<W5P<&]R= H*4%,Z($D@<F5V:65W960@=&AE($]4(&1A=&%B87-E+"!A;F0@
M:&%D(&$@8V]N=F5R<V%T:6]N('=I=&@@2F]H;B!$=6=A<PH@(" @;VX@:VYO
M=VX@<')O8FQE;7,@:6X@8VUA+"!W:&EC:"!M87D@:&%V92!B965N(')E;&%T
M960@=&\@=&AE('!R;V)L96T*(" @(%!Y<F%M:60@:7,@<V5E:6YG+B!/=7(@
M8V]N8VQU<VEO;B!W87,@=&AA="!T:&ES(&UA>2!R96%L;'D@8F4@86X@4U92
M- H@(" @<W!E8VEF:6,@<')O8FQE;2X*"E1H92!F;VQL;W=I;F<@8V%M92!F
M<F]M(%!Y<F%M:60*+2TM+2TM+2TM+2TM+2TM+2T*5&AI<R!E>&%M<&QE(&EL
M;'5S=')A=&5S(&$@8G5G(&EN('1H92!$0T4@4E!#(%)U;G1I;64@=VAE;B!T
M:&4@0TX@<')O=&]C;VP*:7,@=7-E9"X@268@9FEL92!D97-C<FEP=&]R('IE
M<F\@:7,@8VQO<V5D('!R:6]R('1O('1H92!S97)V97(@97AP;W)T:6YG(&ET
M<PIB:6YD:6YG<RP@=&AE('-E<G9E<B!W:6QL('-O;65T:6UE<R!F;W)G970@
M=&\@<&]S="!T:&4@9FEL92!D97-C<FEP=&]R(&9O<B!T:&4@5$-0"G!O<G0@
M=VAE;B!I="!D;V5S(&$@<V5L96-T+W!O;&P@8V%L;"X@5&\@:6QL=7-T<F%T
M92!T:&ES+"!W92!H879E(&$@*G9E<GDJ"G-I;7!L92!24$,@<')O9W)A;2!H
M97)E('1H870@97AP;W)T<R!A(&)I;F1I;F<@=&\@+RXZ+W9E;F1O<B]P>7)A
M;6ED+VYO=&AI;F<N"@I4:&4@<V5R=F5R(&UU<W0@8F4@<G5N('=I=&@@1$-%
M(&-R961E;G1I86QS('1H870@=VEL;"!A;&QO=R!I="!T;R!P;&%C90IA(&)I
M;F1I;F<@:6X@=&AE(&YA;65S<&%C92!A="!T:&%T(&QO8V%T:6]N+@H*+2!-
M;W9E(&-L:65N="]-86ME9FEL92X\=VAA=&5V97(^('1O($UA:V5F:6QE("AI
M;G-T96%D(&]F(&1O:6YG('1H:7,L(&UA:V4@>6]U<@H@(&]W;B!-86ME9FEL
M92YS=G(T('5S:6YG(&]N92!O9B!T:&4@97AI<W1I;F<@9FEL97,@87,@82!T
M96UP;&%T92X@=&AE;B!#:&%N9V4@=&AE"B @=F%L=64@;V8@34%#2$E.12!I
M;B!T:&4@=&]P(&QE=F5L($UA:V5F:6QE*2X@( HM($UO=F4@<V5R=F5R+TUA
M:V5F:6QE+CQW:&%T979E<CX@=&\@36%K969I;&4@*'-A;64@87,@<')E=FEO
M=7,I"BT@36]D:69Y($UA:V5F:6QE('1O('-E=" G4%))3D-)4$%,)PHM($QO
M9VEN(&%S(&-E;&Q?861M:6X*+2!M86ME(&YA;65S<&%C90HM($QO9VEN(&EN
M(&%S("=04DE.0TE004PG("A)('5S960@8V5L;%]A9&UI;BD*+2!-;V1I9GD@
M:6YC;'5D92]D;VYO=&AI;F<N:"!T;R!S970@>6]U<B!P<F5F97)R960@8FEN
M9&EN9R!L;V-A=&EO;BX@("AN;W0@;F5C97-S87)Y*0HM(&UA:V4@86QL"BT@
M4G5N('1H92!S97)V97(@=VET:"!T:&4@+7@@*&1E8G5G*2!A;F0@=&AE("UC
M("AC;&]S92!&1" P*2!O<'1I;VXN"BT@4G5N('1H92!C;&EE;G0O1$])5"!S
M8W)I<'0*"E1H92!C;&EE;G0@=VEL;"!H86YG('=H96X@:70@8VAE8VMS(')P
M8U]M9VUT7VES7W-E<G9E<E]L:7-T96YI;F<H*2X@268@=&AE"G-E<G9E<B!I
M<R!R=6X@=VET:&]U="!T:&4@+6,@;W!T:6]N("TM(&]R(&EF('1H92!C;&EE
M;G0@=7-E<R!T:&4@1$<@<')O=&]C;VPL"FYO(&AA;F<@;V-C=7)S+@H*3D]4
M13H*5&AI<R!B=6<@9&]E<R!N;W0@87!P96%R(&]N('1H92 Q+C N,B!034%8
M(')E9F5R96YC92!P;W)T+@IG:6X@87,@8V5L;%]A9&UI;@HM(&UA:V4@;F%M
M97-P86-E"BT@3&]G:6X@:6X@87,@)U!224Y#25!!3"<@*$D@=7-E9"!C96QL
M7V%D;6EN*0HM($UO9&EF>2!I;F-L=61E+V1O;F]T:&EN9RYH('1O('-E="!Y
M;W5R('!R969E<G)E9"!B:6YD:6YG(&QO8V%T:6]N+B @*&YO="!N96-E<W-A
M<GDI"BT@;6%K92!A;&P*+2!2=6X@=&AE('-E<G9E<B!W:71H('1H92 M>" H
M9&5B=6<I(&%N9"!T:&4@+6,@*&-L;W-E($9$(# I(&]P=&EO;BX*+2!2=6X@
M=&AE(&-L:65N="]$3TE4('-C<FEP= H*5&AE(&-L:65N="!W:6QL(&AA;F<@
M=VAE;B!I="!C:&5C:W,@<G!C7VUG;71?:7-?<V5R=F5R7VQI<W1E;FEN9R@I
M+B!)9B!T:&4*<V5R=F5R(&ES(')U;B!W:71H;W5T('1H92 M8R!O<'1I;VX@
M+2T@;W(@:68@=&AE(&-L:65N="!U<V5S('1H92!$1R!P<F]T;V-O;"P*;F\@
M:&%N9R!O8V-U<G,N"@I.3U1%.@I4:&ES(&)U9R!D;V5S(&YO="!A<'!E87(@
M;RXO36%K969I;&4                                             
M                                                            
M               P,# P-C0T # P,C,V,3( ,# P,# P,0 P,# P,# P,3(W
M,P P-30T-3$R,C$R-P P,#$S-S$T #                              
M                                                            
M                                            =7-T87( ,#!M;VYZ
M:6QL;P                               &]T:&5R                
M                    ,# P,# P,  P,# P,# Q                    
M                                                            
M                                                            
M                                                            
M                        4%))3D-)4$%,/6-E;&Q?861M:6X*4%))3D-)
M4$%,7U5)1#TQ,# *34%#2$E.13US=G(T"@IA;&PZ('-E<G9E<E]D:7(@8VQI
M96YT7V1I<@H*<V5R=F5R7V1I<CH*"6-D('-E<G9E<CL@;6%K92 M9B!-86ME
M9FEL92XD*$U!0TA)3D4I(&YO=&AI;F=?<V5R=F5R"@IC;&EE;G1?9&ER.@H)
M8V0@8VQI96YT.R!M86ME("UF($UA:V5F:6QE+B0H34%#2$E.12D*"F-L96%N
M.@H)8V0@<V5R=F5R.R!M86ME("UF($UA:V5F:6QE+B0H34%#2$E.12D@8VQE
M86X*"6-D(&-L:65N=#L@;6%K92 M9B!-86ME9FEL92XD*$U!0TA)3D4I(&-L
M96%N"@IC;&]B8F5R.@H)8V0@<V5R=F5R.R!M86ME("UF($UA:V5F:6QE+B0H
M34%#2$E.12D@8VQO8F)E<@H)8V0@8VQI96YT.R!M86ME("UF($UA:V5F:6QE
M+B0H34%#2$E.12D@8VQO8F)E<@H*=&%R9FEL93H*"71A<B!C=F8@+BXO;F]T
M:&EN9RY@9&%T92 G*R5M)60G8" N"@IN86UE<W!A8V4Z"@EC9'-C<"!C<F5A
M=&4@9&ER96-T;W)Y("\N.B]V96YD;W(*"6-D<V-P(&-R96%T92!D:7)E8W1O
M<GD@+RXZ+W9E;F1O<B]P>7)A;6ED"@EA8VQ?961I=" O+CHO=F5N9&]R+W!Y
M<F%M:60@+6T@=7-E<CHD*%!224Y#25!!3"DZ<G=D=&EC80H*8VQE86Y?;F%M
M97-P86-E.@H)8V1S8W @9&5L971E(&1I<F5C=&]R>2 O+CHO=F5N9&]R+W!Y
M<F%M:60*"6-D<V-P(&1E;&5T92!D:7)E8W1O<GD@+RXZ+W9E;F1O<@H*;&4N
M)"A-04-(24Y%*0H*8VQE86XZ"@EC9"!S97)V97([(&UA:V4@+68@36%K969I
M;&4N)"A-04-(24Y%*2!C;&5A;@H)8V0@8VQI96YT.R!M86ME("UF($UA:V5F
M:6QE+B0H34%#2$E.12D@8VQE86X*"F-L;V)B97(Z"@EC9"!S97)V97([(&UA
M:V4@+68@36%K969I;&4N)"A-04-(24Y%*2!C;&]B8F5R"@EC9"!C;&EE;G0[
M(&UA:V4@+68@36%K969I;&4N)"A-04-(24Y%*2!C;&]B8F5R"@IT87)F:6QE
M.@H)=&%R(&-V9B N+B]N;W1H:6YG+F!D871E("<K)6TE9"=@("X*"FYA;65S
M<&%C93H*"6-D<V-P(&-R96%T92!D:7)E8W1O<GD@+RXZ+W9E;F1O<@H)8V1S
M8W @8W)E82XO8VQI96YT                                        
M                                                            
M                       P,# P-S4U # P,C,V,3( ,# P,# P,0 P,# P
M,# P,# P,  P-30T-C,S-C$R-@ P,#$S-#4W #4                     
M                                                            
M                                                    =7-T87( 
M,#!M;VYZ:6QL;P                               &]T:&5R        
M                            ,# P,# P,  P,# P,# Q            
M                                                            
M                                                            
M                                                            
M                                +B]C;&EE;G0O8VQI96YT7V%R9W,N
M8P                                                          
M                                             # P,# V-#0 ,# R
M,S8Q,@ P,# P,# Q # P,# P,# P-38W # U-#,P-3(P,#0T # P,38Q-C< 
M,                                                           
M                                                            
M              !U<W1A<@ P,&UO;GII;&QO                        
M        ;W1H97(                                    P,# P,# P
M # P,# P,#$                                                 
M                                                            
M                                                            
M                                                       C:6YC
M;'5D92 B9&]N;W1H:6YG+F@B"@II;G0@<')O8V5S<U]C;&EE;G1?87)G<RAI
M;G0@87)G8RP@8VAA<B J87)G=EM=*0I["@ES:6=N960@:6YT(&,["@H)=VAI
M;&4@*"AC(#T@9V5T;W!T*&%R9V,L(&%R9W8L(")B.GAV(BDI("$]($5/1BD@
M>PH)"7-W:71C:"AC*2!["@D)8V%S92 G8B<Z"@D)"6)F;&%G(#T@5%)513L*
M"0D)8FEN9&EN9R ](&]P=&%R9SL*"0D)8G)E86L["@H)"6-A<V4@)W@G.@H)
M"0EX9FQA9R ](%12544["@D)"6)R96%K.PH*"0EC87-E("=V)SH*"0D)=F9L
M86<@/2!44E5%.PH)"0EB<F5A:SL*"@D)8V%S92 G/R<Z"@D)8V%S92 G:"<Z
M"@D)"65R<F9L9R ](%12544["@D)"6)R96%K.PH)"7T*"7T*"@ER971U<FXH
M97)R9FQG*3L*?0H()R,%"!@$        "0    $                    K
M*   [4$   (   "*)P   0                     "        5KR9+.@[
MG!Q6O)DLZ*,E)E:\F2SHHR4F  0   (   !U9G,                 R"4%
M" @    45 8(& 0  "XO8VQI96YT+V-L:65N=%]M86EN+F,             
M                                                            
M                               P,# P-C0T # P,C,V,3( ,# P,# P
M,0 P,# P,# P,30P,P P-30S,3$P,#0W-  P,#$V,30W #              
M                                                            
M                                                            
M=7-T87( ,#!M;VYZ:6QL;P                               &]T:&5R
M                                    ,# P,# P,  P,# P,# Q    
M                                                            
M                                                            
M                                                            
M                                        (VEN8VQU9&4@(F1O;F]T
M:&EN9RYH(@HC:6YC;'5D92 \<'1H<F5A9"YH/@H*:6YT"71C;W5N=" ](#$[
M"0D)"0II;G0)<F-O=6YT(#T@,3L)"0D*:6YT"6)F;&%G(#T@1D%,4T4["0D*
M:6YT"79F;&%G(#T@1D%,4T4["0II;G0)>&9L86<@/2!&04Q313L*:6YT"65R
M<F9L9R ]($9!3%-%.PD)"0D*8VAA<@DJ8FEN9&EN9R ]($))3D1)3D<["0D)
M"@IM86EN*&EN="!A<F=C+"!C:&%R("IA<F=V6UTI"GL*"79O:60)"55S86=E
M*"D["@H):68@*'!R;V-E<W-?8VQI96YT7V%R9W,H87)G8RP@87)G=BDI('L*
M"0E5<V%G92@I.PH)"65X:70H,2D["@E]"@H)9&]?:6UP;W)T7V)I;F1I;F<H
M8FEN9&EN9RP@)F=L;V)A;%]B:6YD:6YG7V@I.PH*"7!R:6YT9B@B4E!#(')E
M='5R;G,@)61<;B(L(&1O;F]T:&EN9R@Q,"DI.PH*?0H*=F]I9"!5<V%G92@I
M"GL*"69P<FEN=&8H<W1D97)R+" B57-A9V4Z(&QO;VMU<"!;+6A=(%LM>%T@
M6RUV72!;+6(@8FEN9&EN9UU<;B(I.PH)9G!R:6YT9BAS=&1E<G(L(")<="UH
M("T@:&5L<%QN(BD["@EF<')I;G1F*'-T9&5R<BP@(EQT+60@+2!D96)U9UQN
M(BD["@EF<')I;G1F*'-T9&5R<BP@(EQT+78@+2!V97)B;W-E7&XB*3L*"69P
M<FEN=&8H<W1D97)R+" B7'0M8B M('5S92!A(&1I9F9E<F5N="!B:6YD:6YG
M(&QO8V%T:6]N7&XB"@D)"2)<=" @(" @*&1E9F%U;'1S('1O("5S9W)O=7 @
M86YD("5S:&]S="E<;B(*"0D)(EQT(" @(" H8V%N(&YO="!B92!U<V5D('=I
M=&@@+6PI7&XB+" *"0D)0DE.1$E.1RP@0DE.1$E.1RD["GT*;&EE;G1?87)G
M<RAA<F=C+"!A<F=V*2D@>PH)"55S86=E*"D["@D)97AI="@Q*3L*"7T*"@ED
M;U]I;7!O<G1?8FEN9&EN9RAB:6YD:6YG+" F9VQO8F%L7V)I;F1I;F=?:"D[
M"@H)<')I;G1F*")24$,@<F5T=7)N<R E9%QN(BP@9&]N;W1H:6YG*#$P*2D[
M"@I]"@IV;VED(%5S86=E*"D*>PH)9G!R:6YT9BAS=&1E<G(L(")5<V%G93H@
M;&]O:W5P(%LM:%T@6RUX72!;+79=(%LM8B!B:6YD:6YG75QN(BD["@EF<')I
M;G1F*'-T9&5R<BP@(EQT+6@@+2XO8VQI96YT+V-L:65N=%]S=6)R+F,     
M                                                            
M                                       P,# P-C0T # P,C,V,3( 
M,# P,# P,0 P,# P,# P-#$W,@ P-30S,3$P,#4U-P P,#$V,C V #      
M                                                            
M                                                            
M        =7-T87( ,#!M;VYZ:6QL;P                              
M &]T:&5R                                    ,# P,# P,  P,# P
M,# Q                                                        
M                                                            
M                                                            
M                                                (VEN8VQU9&4@
M(F1O;F]T:&EN9RYH(@HC:6YC;'5D92 \9&-E+W)P8RYH/@H*=F]I9"!D;U]I
M;7!O<G1?8FEN9&EN9RAC:&%R(&5N=')Y7VYA;65;72P@<G!C7V)I;F1I;F=?
M:&%N9&QE7W0@*F)I;F1I;F=?:"D*>PH)=6YS:6=N960S,B @(" @('-T871U
M<SL@(" @(" @(" @(" @(" @+RH@97)R;W(@<W1A='5S("AN8F%S92YH*2 @
M(" @(" @("HO"@ER<&-?;G-?:&%N9&QE7W0@:6UP;W)T7V-O;G1E>'0[(" @
M(" @(" O*B!R97%U:7)E9"!T;R!I;7!O<G0@*')P8V)A<V4N:"D@*B\*"6-H
M87()"2IS=')I;F=?8FEN9&EN9SL*"@ED<')I;G1F*'-T9&5R<BP@(FEM<&]R
M=&EN9R!B:6YD:6YG(&9R;VT@)7-<;B(L(&5N=')Y7VYA;64I.PH*"7)P8U]N
M<U]B:6YD:6YG7VEM<&]R=%]B96=I;B@@("\J('-E="!C;VYT97AT('1O(&EM
M<&]R="!B:6YD:6YG(&AA;F1L97,@*B\*"0ER<&-?8U]N<U]S>6YT87A?9&5F
M875L="P@(" @(" @+RH@=7-E(&1E9F%U;'0@<WEN=&%X(" @(" @(" @(" @
M(" @(" @*B\*"0DH=6YS:6=N961?8VAA<E]T("HI96YT<GE?;F%M92P@+RH@
M8F5G:6X@<V5A<F-H('=I=&@@=&AI<R!N86UE(" @(" @(" @*B\*"0EN;W1H
M:6YG7W8Q7S!?8U]I9G-P96,L(" @(" O*B!I;G1E<F9A8V4@<W!E8VEF:6-A
M=&EO;B H;F]T:&EN9RYH*2 J+PH)"4Y53$PL(" @(" @(" @(" @(" @(" @
M(" @(" @(" O*B!N;R!O<'1I;VYA;"!O8FIE8W0@555)1"!R97%U:7)E9" @
M(" J+PH)"29I;7!O<G1?8V]N=&5X="P@(" @(" @(" @(" @(" O*B!I;7!O
M<G0@8V]N=&5X="!O8G1A:6YE9" @(" @(" @(" @(" J+PH)"29S=&%T=7,*
M"2D["@E#2$5#2U]35$%455,H<W1A='5S+" B0V%N)W0@8F5G:6X@:6UP;W)T
M.B(L($%"3U)4*3L*"@EW:&EL92@Q*2!["@D)<G!C7VYS7V)I;F1I;F=?:6UP
M;W)T7VYE>'0H(" @(" @(" @(" @(" O*B!I;7!O<G0@82!B:6YD:6YG(&AA
M;F1L92 J+PH)"0EI;7!O<G1?8V]N=&5X="P@(" @(" @("\J(&-O;G1E>'0@
M9G)O;2!R<&-?;G-?8FEN9&EN9U]I;7!O<G1?8F5G:6X@*B\*"0D)8FEN9&EN
M9U]H+" @(" @(" @(" @(" O*B!A(&)I;F1I;F<@:&%N9&QE(&ES(&]B=&%I
M;F5D(" @(" @(" @(" @("HO"@D)"29S=&%T=7,*"0DI.PH)"4-(14-+7U-4
M05154RAS=&%T=7,L(")#86XG="!I;7!O<G0@82!B:6YD:6YG(&AA;F1L93HB
M+"!!0D]25"D["@D)9'!R:6YT9BAS=&1E<G(L(")I;7!O<G0@;F5X="!R971U
M<FYE9"!O:UQN(BD["@H)"7)P8U]E<%]R97-O;'9E7V)I;F1I;F<H*F)I;F1I
M;F=?:"P@;F]T:&EN9U]V,5\P7V-?:69S<&5C+" F<W1A='5S*3L*"0E#2$5#
M2U]35$%455,H<W1A='5S+" B0V%N)W0@<F5S;VQV92!B:6YD:6YG.B B+"!2
M15-5344I.PH)"61P<FEN=&8H<W1D97)R+" B<F5S;VQV95]B:6YD:6YG(')E
M='5R;F5D("5D7&XB+"!S=&%T=7,I.PH)"6EF("AS=&%T=7,@(3T@<G!C7W-?
M;VLI"@D)"6-O;G1I;G5E.PH*"0ES=')I;F=?8FEN9&EN9R ]($Y53$P["@D)
M<G!C7V)I;F1I;F=?=&]?<W1R:6YG7V)I;F1I;F<H*F)I;F1I;F=?:"P@"@D)
M"2AU;G-I9VYE9%]C:&%R7W!?=" J*29S=')I;F=?8FEN9&EN9RP@)G-T871U
M<RD["@D)0TA%0TM?4U1!5%53*'-T871U<RP@(D-A;B=T(&-O;G9E<G0@8FEN
M9&EN9R!T;R!S=')I;F<Z("(L(%)%4U5-12D["@D):68@*'-T<FEN9U]B:6YD
M:6YG*0H)"0ED<')I;G1F*'-T9&5R<BP@(F-H96-K:6YG(&9O<B!D865M;VX@
M870@)7-<;B(L('-T<FEN9U]B:6YD:6YG*3L*"@D):68@*')P8U]M9VUT7VES
M7W-E<G9E<E]L:7-T96YI;F<H*F)I;F1I;F=?:"P@)G-T871U<RDI('L*"0D)
M9'!R:6YT9BAS=&1E<G(L(")S97)V97(@:7,@;&ES=&5N:6YG7&XB*3L*"0D)
M8G)E86L["@D)?0H)"61P<FEN=&8H<W1D97)R+" B<V5R=F5R(&ES(&YO="!L
M:7-T96YI;F=<;B(I.PH)"4-(14-+7U-405154RAS=&%T=7,L(")397)V97(@
M=V%S(&YO="!L:7-T96YI;F<Z("(L(%)%4U5-12D["@E]("\J96YD('=H:6QE
M("HO"@H*"7)P8U]N<U]B:6YD:6YG7VEM<&]R=%]D;VYE*" @(" @(" @(" @
M(" @(" O*B!D;VYE('=I=&@@:6UP;W)T(&-O;G1E>'0@*B\*"0DF:6UP;W)T
M7V-O;G1E>'0L(" @(" @(" @+RH@;V)T86EN960@9G)O;2!R<&-?;G-?8FEN
M9&EN9U]I;7!O<G1?8F5G:6X@*B\*"0DF<W1A='5S"@DI.PH)<F5T=7)N.PI]
M"@EI9B H<W1R:6YG7V)I;F1I;F<I"@D)"61P<FEN=&8H<W1D97)R+" B8VAE
M8VMI;F<@9F]R(&1A96UO;B!A=" E<UQN(BP@<W1R:6YG7V)I;F1I;F<I.PH*
M"0EI9B H<G!C7VUG;71?:7-?<V5R=F5R7VQI<W1E;FEN9R@J8FEN9&EN9U]H
M+" F<W1A='5S*2D@>PH)"0ED<')I;G1F*'-T9&5R<BP@(G-E<G9E<B!I<R!L
M:7-T96YI;F=<;B(I.PH)"0EB<F5A:SL*"0E]"@D)9'!R:6YT9BAS=&1E<G(L
M(")S97)V97(@:7,@;F]T(&QI<W1E;FEN9UQN(BD["@D)0TA%0TM?4U1!5%53
M*'-T871U<RP@(E-E<G9E<B!W87,@;F]T(&QI<W1E;FEN9SH@(BP@4D5354U%
M*3L*"7T@+RIE;F0@=VAI;&4@*B\*"@H)<G!C7VYS7V)I;F1I;F=?:6UP;W)T
M7V1O;F4H(" @(" @(" @(" @(" @("\J(&1O;F4@=RXO8VQI96YT+VYO=&AI
M;F<N86-F                                                    
M                                                       P,# P
M-C0T # P,C,V,3( ,# P,# P,0 P,# P,# P,#$P-@ P-30S,#4Q-# Q,0 P
M,#$U-C,T #                                                  
M                                                            
M                        =7-T87( ,#!M;VYZ:6QL;P              
M                 &]T:&5R                                    
M,# P,# P,  P,# P,# Q                                        
M                                                            
M                                                            
M                                                            
M    6PII;7!L:6-I=%]H86YD;&4H:&%N9&QE7W0@9VQO8F%L7V)I;F1I;F=?
M:"D*70II;G1E<F9A8V4@;F]T:&EN9PI["GT*"FYS7V)I;F1I;F=?:6UP;W)T
M7V)E9VEN("HO"@D))G-T871U<PH)*3L*"7)E='5R;CL*?0H):68@*'-T<FEN
M9U]B:6YD:6YG*0H)"0ED<')I;G1F*'-T9&5R<BP@(F-H96-K:6YG(&9O<B!D
M865M;VX@870@)7-<;B(L('-T<FEN9U]B:6YD:6YG*3L*"@D):68@*')P8U]M
M9VUT7VES7W-E<G9E<E]L:7-T96YI;F<H*F)I;F1I;F=?:"P@)G-T871U<RDI
M('L*"0D)9'!R:6YT9BAS=&1E<G(L(")S97)V97(@:7,@;&ES=&5N:6[P    
M      C[!0AE86L[R T  !!4!@@L6 8(     ,D-   L6 0(0!@%"#!8!@BX
M:@0("    "0O!@@     R%@$""<C!0@8!         D    !            
M        *R@  .U!   "    BB<   $                      @      
M &.\F2R(>XD)5KR9+.BC)296O)DLZ*,E)@ $   "    =69S            
M     ,@E!0@(    %%0&"!@$   N+V-L:65N="]$3TE4                
M                                                            
M                                        ,# P,#<U-0 P,#(S-C$R
M # P,# P,#$ ,# P,# P,# T-#( ,#4T,S U,34W,#$ ,# Q-#(Q,@ P    
M                                                            
M                                                            
M         '5S=&%R # P;6]N>FEL;&\                             
M  !O=&AE<@                                   # P,# P,#  ,# P
M,# P,0                                                      
M                                                            
M                                                            
M                                                 ",A+V)I;B]S
M: IS970@+7@*;6%K92!N;W1H:6YG"@H*"F5C:&\@5&AI<R!O;F4@=VEL;"!W
M;W)K"E)00U]355!03U)4141?4%)/5%-%45,];F-A9&=?:7!?=61P.R!E>'!O
M<G0@4E!#7U-54%!/4E1%1%]04D]44T514PHN+VYO=&AI;F<@+7@*"@H*96-H
M;R!4:&ES(&]N92!W:6QL(&AA;F<@249&('1H92!S97)V97(@=V%S('-T87)T
M960@=VET:"!T:&4@+6,@;W!T:6]N"E)00U]355!03U)4141?4%)/5%-%45,]
M;F-A8VY?:7!?=&-P.R!E>'!O<G0@4E!#7U-54%!/4E1%1%]04D]44T514PHN
M+VYO=&AI;F<@+7@*<V5R=F5R(&ES(&QI<W1E;FEN\          (^P4(96%K
M.\@-   05 8(+%@&"     #)#0  +%@$"$ 8!0@P6 8(N&H$" @    D+P8(
M     ,A8! @G(P4(& 0        )     0                   "LH  #M
M00   @   (HG   !                      (       !CO)DLV,WF#E:\
MF2SHHR4F5KR9+.BC)28 !    @   '5F<P                #()04("   
M !14!@@8!   +B]C;&EE;G0O36%K969I;&4N<&UA>                   
M                                                            
M                         # P,# V-#0 ,# R,S8Q,@ P,# P,# Q # P
M,# P,# Q-#4S # U-#0T,C$R,C,U # P,38Q,S4 ,                   
M                                                            
M                                                      !U<W1A
M<@ P,&UO;GII;&QO                                ;W1H97(     
M                               P,# P,# P # P,# P,#$         
M                                                            
M                                                            
M                                                            
M                                  !)1$Q#340)/0DO;W!T+V1C92]B
M:6XO:61L("UV"D-#"3T)9V-C"DE.0TP)/0DM22X@+4DN+B]I;F-L=61E("U)
M+W5S<B]I;F-L=61E"D1)3D-,"3T)+4D@+V]P="]D8V4O<VAA<F4O:6YC;'5D
M92 M22]O<'0O9&-E+W-H87)E+VEN8VQU9&4O9&-E"DQ)3E0)/0EL:6YT("U)
M)"A$24Y#3"D*3$E"4PD]"2UL9&-E("UL:0I#1$5&4PD]"0I#3U-&,0D]"0I#
M1DQ!1U,)/0DD*$E.0TPI("0H1$E.0TPI(" M1$-,245.5" M1$1#12 D*$-$
M1493*2 D*$-/4T8Q*0H*(PHC($-/35!,151%($)524Q$(&]F('1H92!A<'!L
M:6-A=&EO;BX*(PIA;&PZ(" @(&YO=&AI;F<*"@HC"B,@1$-%($E.5$521D%#
M12!"54E,1" *(PII;G1E<F9A8V4Z"6YO=&AI;F<N: IN;W1H:6YG+F@@;F]T
M:&EN9U]C<W1U8BYC.@DN+B]I;F-L=61E+VYO=&AI;F<N:61L(&YO=&AI;F<N
M86-F"@D@(" D*$E$3$--1"D@+4DN+B]I;F-L=61E("UK965P(&-?<V]U<F-E
M("US97)V97(@;F]N92 N+B]I;F-L=61E+VYO=&AI;F<N:61L"@HC"B,@1$-%
M($-,245.5"!"54E,1" *(PI#3$E%3E1?3T)*4R ]8VQI96YT7W-U8G(N;R!N
M;W1H:6YG7V-S='5B+F\@8VQI96YT7V%R9W,N;R!C;&EE;G1?;6%I;BYO"FYO
M=&AI;F<Z"6YO=&AI;F<N:" D*$-,245.5%]/0DI3*0H)(" @"20H0T,I("0H
M0T9,04=3*2 M;R!N;W1H:6YG("0H0TQ)14Y47T]"2E,I("0H3$E"4RD*"@HC
M"B,@36ES8V5L;&%N96]U<PHC"F-L96%N.@H)<FT@+68@8V]R92 J+F\@*E]C
M<W1U8BH@*E]S<W1U8BH@;F]T:&EN9RYH("I?<V%U>"H@<W1U8BYC"@IC;&]B
M8F5R.B!C;&5A;@H)<FT@+68@;F]T:&EN9PH*"F%L;#H@(" @;F]T:&EN9PH*
M"B,*(R!$0T4@24Y415)&04-%($)524Q$( HC"FEN=&5R9F%C93H);F]T:&EN
M9RYH"FYO=&AI;F<N:"!N;W1H:6YG7V-S='5B+F,Z"2XN+VEN8VQU9&4O;F]T
M:&EN9RYI9&P@;F]T:&EN9RYA8V8*"2 @("0H241,0TU$*2 M22XN+VEN8VQU
M9&4@+6ME97 @8U]S;W5R8V4@+7-E<G9E<B!N;VYE("XN+VEN8VQU9&4O;F]T
M:&EN9RYI9&P*"B,*(R!$+B]C;&EE;G0O36%K969I;&4N9&-O<W@         
M                                                            
M                                 # P,# V-#0 ,# R,S8Q,@ P,# P
M,# Q # P,# P,# R,C0V # U-#,Q,3 S-3$S # P,38S,#, ,           
M                                                            
M                                                            
M  !U<W1A<@ P,&UO;GII;&QO                                ;W1H
M97(                                    P,# P,# P # P,# P,#$ 
M                                                            
M                                                            
M                                                            
M                                          !)1$Q#340)/0DO;W!T
M+V1C92]B:6XO:61L("UV"D-&3$%'4PD]"2U/("U)+B M22XN+VEN8VQU9&4@
M+41$0T4@+41#3$E%3E0*0T,)/0DO;W!T+V1C92]B:6XO8V,*24Y#3 D]"2]U
M<W(O:6YC;'5D90I$24Y#3 D]"2]O<'0O9&-E+W-H87)E+VEN8VQU9&4*3$E.
M5 D]"6QI;G0@+4DD*$1)3D-,*0I,24)3"3T)+6QG96Y?<@I83$E"4PD]"2UL
M6&UP("UL6&T@+6Q78R M;&1L("UL6&UU("UL6'0@+6Q897AT("UL6#$Q"@HC
M"B,@0T]-4$Q%5$4@0E5)3$0@;V8@=&AE(&%P<&QI8V%T:6]N+@HC"F%L;#H@
M(" @;F]T:&EN9PH*"B,*(R!$0T4@24Y415)&04-%($)524Q$( HC"FEN=&5R
M9F%C93H);F]T:&EN9RYH"FYO=&AI;F<N:"!N;W1H:6YG7V-S='5B+F,Z"2XN
M+VEN8VQU9&4O;F]T:&EN9RYI9&P@;F]T:&EN9RYA8V8*"2 @("0H241,0TU$
M*2 M22XN+VEN8VQU9&4@+6ME97 @8U]S;W5R8V4@+7-E<G9E<B!N;VYE("XN
M+VEN8VQU9&4O;F]T:&EN9RYI9&P*"B,*(R!$0T4@0TQ)14Y4($)524Q$( HC
M"D-,245.5%]/0DI3(#UC;&EE;G1?<W5B<BYO(&YO=&AI;F=?8W-T=6(N;R!C
M;&EE;G1?87)G<RYO(&-L:65N=%]M86EN+F\*;F]T:&EN9SH);F]T:&EN9RYH
M("0H0TQ)14Y47T]"2E,I"@D@(" ))"A#0RD@)"A#1DQ!1U,I("UO(&YO=&AI
M;F<@)"A#3$E%3E1?3T)*4RD*"@HC"B,@36ES8V5L;&%N96]U<PHC"F-L96%N
M.@H)<FT@+68@8V]R92 J+F\@*E]C<W1U8BH@*E]S<W1U8BH@;F]T:&EN9RYH
M("I?<V%U>"H@<W1U8BYC"@IC;&]B8F5R.B!C;&5A;@H)<FT@+68@;F]T:&EN
M9PH*(PHC($1E<&5N9&5N8VEE<PHC"D-(14-+7U-405154U])3D-,541%4PD]
M"20H24Y#3"DO<W1D:6\N:" D*$1)3D-,*2]D8V4O9&-E7V5R<F]R+F@@)"A$
M24Y#3"DO9&-E+W!T:')E860N:"!<"@D)"0DD*$1)3D-,*2]D8V4O<G!C97AC
M+F@*;F]T:&EN9U](7TE.0TQ51$53"3T)( DD*$E.0TPI+W-T9&QI8BYH("0H
M24Y#3"DO<W1D:6\N:" D*$E.0TPI+W-T<FEN9RYH(%P*"0D)"20H24Y#3"DO
M<WES+W1Y<&5S+F@@)"A)3D-,*2]C='EP92YH("0H24Y#3"DO<WES+VUM86XN
M:"!<"@D)"0DD*$E.0TPI+W-Y<R]S=&%T+F@@)"A)3D-,*2]F8VYT;"YH("0H
M24Y#3"DO87-S97)T+F@@7 H)"0D))"A)3D-,*2]8,3$O26YT<FEN<VEC+F@@
M)"A)3D-,*2]8;2]4;V=G;&5"+F@@7 H)"0D))"A#2$5#2U]35$%455-?24Y#
M3%5$15,I"G5S"B,*8VQE86XZ"@ER;2 M9B!C;W)E("HN;R J7V-S='5B*B J
M7W-S='5B*B!N;W1H:6YG+F@@*E]S875X*B!S='5B+F,*"F-L;V)B97(Z(&-L
M96%N"@ER;2 M9B!N;W1H:6YG"@HC"B,@1&5P96YD96YC:65S"B,*0TA%0TM?
M4U1!5%537TE.0TQ51$53"3T))"A)3D-,*2]S=&1I;RYH("0H1$E.0TPI+V1C
M92]D8V5?97)R;W(N:" D*$1)3D-,*2]D8V4O<'1H<F5A9"YH(%P*"0D)"20H
M1$E.0TPI+V1C92]R<&-E>&,N: IN;W1H:6YG7TA?24Y#3%5$15,)/0D@"20H
M24Y#3"DO<W1D;&EB+F@@)"A)3D-,*2]S=&1I;RYH("0H24Y#3"DO<W1R:6YG
M+F@@7 H)"0D))"A)3D-,*2]S>7,O='EP97,N:" D*$E.0TPI+V,N+V-L:65N
M="]-86ME9FEL92YS=G(T                                        
M                                                            
M    ,# P,#8T-  P,#(S-C$R # P,#$W-3  ,# P,# P,#$T-C, ,#4T-#8S
M,S,T,30 ,# Q-34U-@ P                                        
M                                                            
M                                 '5S=&%R # P;6]N>FEL;&\     
M                          !O<V8                             
M         # P,# P,#  ,# P,# P,0                              
M                                                            
M                                                            
M                                                            
M             $E$3$--1 D]"2]O<'0O9&-E+V)I;B]I9&P@+78*0T,)/0DO
M;W!T+V1C96QO8V%L+V)I;B]C8PI)3D-,"3T)+4DN("U)+BXO:6YC;'5D92 M
M22]U<W(O:6YC;'5D90I$24Y#3 D]"2U)("]O<'0O9&-E+W-H87)E+VEN8VQU
M9&4@+4DO;W!T+V1C92]S:&%R92]I;F-L=61E+V1C90I,24Y4"3T);&EN=" M
M220H1$E.0TPI"DQ)0E,)/0D*0T1%1E,)/0D*0T]31C$)/0D*0T9,04=3"3T)
M)"A)3D-,*2 D*$1)3D-,*2 @+41#3$E%3E0@+41$0T4@)"A#1$5&4RD@)"A#
M3U-&,2D*"B,*(R!#3TU03$5412!"54E,1"!O9B!T:&4@87!P;&EC871I;VXN
M"B,*86QL.B @("!N;W1H:6YG"@H*(PHC($1#12!)3E1%4D9!0T4@0E5)3$0@
M"B,*:6YT97)F86-E.@EN;W1H:6YG+F@*;F]T:&EN9RYH(&YO=&AI;F=?8W-T
M=6(N8SH)+BXO:6YC;'5D92]N;W1H:6YG+FED;"!N;W1H:6YG+F%C9@H)(" @
M)"A)1$Q#340I("U)+BXO:6YC;'5D92 M:V5E<"!C7W-O=7)C92 M<V5R=F5R
M(&YO;F4@+BXO:6YC;'5D92]N;W1H:6YG+FED; H*(PHC($1#12!#3$E%3E0@
M0E5)3$0@"B,*0TQ)14Y47T]"2E,@/6-L:65N=%]S=6)R+F\@;F]T:&EN9U]C
M<W1U8BYO(&-L:65N=%]A<F=S+F\@8VQI96YT7VUA:6XN;PIN;W1H:6YG.@EN
M;W1H:6YG+F@@)"A#3$E%3E1?3T)*4RD*"2 @( DD*$-#*2 D*$-&3$%'4RD@
M+6\@;F]T:&EN9R D*$-,245.5%]/0DI3*2 D*$Q)0E,I"@H*(PHC($UI<V-E
M;&QA;F5O=7,*(PIC;&5A;CH*"7)M("UF(&-O<F4@*BYO("I?8W-T=6(J("I?
M<W-T=6(J(&YO=&AI;F<N:" J7W-A=7@J('-T=6(N8PH*8VQO8F)E<CH@8VQE
M86X*"7)M("UF(&YO=&AI;F<*"@IA;&PZ(" @(&YO=&AI;F<*"@HC"B,@1$-%
M($E.5$521D%#12!"54E,1" *(PII;G1E<F9A8V4Z"6YO=&AI;F<N: IN;W1H
M:6YG+F@@;F]T:&EN9U]C<W1U8BYC.@DN+B]I;F-L=61E+VYO=&AI;F<N:61L
M(&YO=&AI;F<N86-F"@D@(" D*$E$3$--1"D@+4DN+B]I;F-L=61E("UK965P
M(&-?<V]U<F-E("US97)V97(@;F]N92 N+B]I;F-L=61E+VYO=&AI;F<N:60N
M+W-E<G9E<@                                                  
M                                                            
M            ,# P,#<U-0 P,#(S-C$R # P,# P,#$ ,# P,# P,# P,#  
M,#4T-#8S,S8Q,C8 ,# Q,S4P-P U                                
M                                                            
M                                         '5S=&%R # P;6]N>FEL
M;&\                               !O=&AE<@                  
M                 # P,# P,#  ,# P,# P,0                      
M                                                            
M                                                            
M                                                            
M                     "XO<V5R=F5R+W-E<G9E<E]A<F=S+F,         
M                                                            
M                                   P,# P-C0T # P,C,V,3( ,# P
M,# P,0 P,# P,# P,#8R-@ P-30S,#4R,#$P,0 P,#$V,C,U #          
M                                                            
M                                                            
M    =7-T87( ,#!M;VYZ:6QL;P                               &]T
M:&5R                                    ,# P,# P,  P,# P,# Q
M                                                            
M                                                            
M                                                            
M                                            (VEN8VQU9&4@(F1O
M;F]T:&EN9RYH(@H*:6YT('!R;V-E<W-?<V5R=F5R7V%R9W,H:6YT(&%R9V,L
M(&-H87(@*F%R9W9;72D*>PH):6YT(&,["@H)=VAI;&4@*"AC(#T@9V5T;W!T
M*&%R9V,L(&%R9W8L(")C>'9H8CHB*2D@(3T@14]&*0H)"7-W:71C:"AC*2![
M"@D)8V%S92 G8B<Z"@D)"6)I;F1I;F<@/2!O<'1A<F<["@D)"6)F;&%G(#T@
M5%)513L*"0D)8G)E86L["@H)"6-A<V4@)V,G.@H)"0EC9FQA9R ](%12544[
M"@D)"6)R96%K.PH*"0EC87-E("=X)SH*"0D)>&9L86<@/2!44E5%.PH)"0EB
M<F5A:SL*"@D)8V%S92 G=B<Z"@D)"79F;&%G(#T@5%)513L*"0D)8G)E86L[
M"@H)"6-A<V4@)S\G.@H)"6-A<V4@)V@G.@H)"0EE<G)F;&<@/2!44E5%.PH)
M"0EB<F5A:SL*"0E]"@D*"7)E='5R;BAE<G)F;&<I.PI]"@  SS@  .U!   "
M    BB<   $                      @       %6\F2S0\*0U5KR9+&BV
MY@Y6O)DL:+;F#@ $   "    =69S                 ,@E!0@(    %%0&
M"!@$   N+W-E<G9E<B]S97)V97)?;6%I;BYC                        
M                                                            
M                    ,# P,#8T-  P,#(S-C$R # P,# P,#$ ,# P,# P
M,#0R,30 ,#4T-#0R,#<U-S4 ,# Q-C(U,  P                        
M                                                            
M                                                 '5S=&%R # P
M;6]N>FEL;&\                               !O=&AE<@          
M                         # P,# P,#  ,# P,# P,0              
M                                                            
M                                                            
M                                                            
M                             "-I;F-L=61E(")D;VYO=&AI;F<N:"(*
M"FEN= EB9FQA9R ]($9!3%-%.PD)"0H*:6YT"6-F;&%G(#T@1D%,4T4["0D)
M"0II;G0)=F9L86<@/2!&04Q313L)"0D)"FEN= EX9FQA9R ]($9!3%-%.PD)
M"0D*:6YT"65R<F9L9R ]($9!3%-%.PD)"0D*8VAA<@DJ8FEN9&EN9R ]($))
M3D1)3D<["0D)"G-T871I8R!V;VED(%5S86=E*"D["@IM86EN*&EN="!A<F=C
M+"!C:&%R("IA<F=V6UTI"GL*(" @"75N<VEG;F5D,S(@(" @(" @(" @('-T
M871U<SL@(" @(" @(" @+RH@97)R;W(@<W1A='5S("AN8F%S92YH*2 @(" @
M(" @*B\*(" @"7)P8U]B:6YD:6YG7W9E8W1O<E]T("IB:6YD:6YG7W9E8W1O
M<CL@+RH@8FEN9&EN9R!H86YD;&4@;&ES=" H<G!C8F%S92YH*2 J+PH*"6EF
M("AP<F]C97-S7W-E<G9E<E]A<F=S*&%R9V,L(&%R9W8I*2!["@D)57-A9V4H
M*3L*"0EE>&ET*#$I.PH)?0H*"@EI9B H8V9L86<I"@D)8VQO<V4@*# I.PH*
M"6EF("AS971U<%]S97)V97)?8FEN9&EN9W,H8FEN9&EN9RDI('L*"0EF<')I
M;G1F*'-T9&5R<BP@(F-O=6QD(&YO="!E>'!O<G0@8FEN9&EN9W,@=&\@;F%M
M92!S<&%C95QN(BD["@D)97AI="@Q*3L*"7T*"@EF<')I;G1F*'-T9&5R<BP@
M(FYO=&AI;F<@<V5R=F5R(&ES(')E861Y7&XB*3L*"@H)+RHJ*BHJ*BHJ*BHJ
M*BHJ*BHJ*BH@3$E35$5.($9/4B!214U/5$4@4%)/0T5$55)%($-!3$Q3("HJ
M*BHJ*BHJ*BHJ*BHJ*BHJ*BHO"@E44ED@(" @(" @(" @(" @(" @(" @(" @
M(" @(" @(" @(" O*B!T:')E860@97AC97!T:6]N(&AA;F1L:6YG(&UA8W)O
M("HO"@H)"7)P8U]S97)V97)?;&ES=&5N* H)"0ER<&-?8U]L:7-T96Y?;6%X
M7V-A;&QS7V1E9F%U;'0L"@D)"29S=&%T=7,*"0DI.PH)"4-(14-+7U-40515
M4RAS=&%T=7,L(")R<&,@;&ES=&5N(&9A:6QE9#HB+"!215-5344I.PH)"@E&
M24Y!3$Q9(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @+RH@
M97)R;W(@<F5C;W9E<GD@86YD(&-L96%N=7 @*B\*"0ER<&-?<V5R=F5R7VEN
M<5]B:6YD:6YG<R@@(" @(" @(" @(" @(" @("\J(&=E="!B:6YD:6YG(&EN
M9F]R;6%T:6]N("HO"@D)"29B:6YD:6YG7W9E8W1O<BP*"0D))G-T871U<PH)
M"2D["@D)0TA%0TM?4U1!5%53*'-T871U<RP@(D-A;B=T(&=E="!B:6YD:6YG
M(&EN9F]R;6%T:6]N.B(L(%)%4U5-12D["@D*"0ER<&-?97!?=6YR96=I<W1E
M<B@@(" @(" O*B!R96UO=F4@96YD<&]I;G1S(&9R;VT@;&]C86P@96YD<&]I
M;G0@;6%P("HO"@D)"6YO=&AI;F=?=C%?,%]S7VEF<W!E8RP@("\J(&EN=&5R
M9F%C92!S<&5C:69I8V%T:6]N("AN;W1H:6YG+F@I("HO"@D)"6)I;F1I;F=?
M=F5C=&]R+" @(" @(" @(" @(" @(" O*B!V96-T;W(@;V8@<V5R=F5R(&)I
M;F1I;F<@:&%N9&QE<R J+PH)"0E.54Q,+" @(" @(" @(" @(" @(" @(" @
M(" @(" @(" @(" @(" @(" @(" @(" O*B!N;R!O8FIE8W0@555)1',@*B\*
M"0D))G-T871U<R *"0DI.PH)"4-(14-+7U-405154RAS=&%T=7,L(")#86XG
M="!R96UO=F4@96YD<&]I;G1S(&9R;VT@96YD<&]I;G0@;6%P.B(L(%)%4U5-
M12D["@D*"0ER<&-?8FEN9&EN9U]V96-T;W)?9G)E92@@(" @(" @(" @(" @
M+RH@9G)E92!S97)V97(@8FEN9&EN9R!H86YD;&5S("HO"@D)"29B:6YD:6YG
M7W9E8W1O<BP*"0D))G-T871U<PH)"2D[(" *"0E#2$5#2U]35$%455,H<W1A
M='5S+" B0V%N)W0@9G)E92!S97)V97(@8FEN9&EN9R!H8[tom 10/19/93 public]
Since This is not a problem on any other reference platform,
I am lowering this to a B2.

[04/01/94 public]
Canceling this defect since it doesn't appear OSF is going to get
the SVR4 fix for it, and it doesn't happen on any other platform.



CR Number                     : 8636
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rpc_ep_resolve_binding() core dumps
Reported Date                 : 9/20/93
Found in Baseline             : 1.0.2a
Found Date                    : 9/20/93
Severity                      : A
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : comif.c
Sensitivity                   : public

[9/20/93 public]
A application does the following and gets a core dump:

do_import_binding(entry_name, binding_h)
unsigned_char_t         *entry_name;
rpc_binding_handle_t    binding_h;
{
  rpc_ns_handle_t import_context;
  error_status_t  status;

  rpc_ns_binding_import_begin(rpc_c_ns_syntax_default,
                              (unsigned_char_t *)entry_name,
                              message_v1_0_c_ifspec,
                              NULL,
                              &import_context,
                              &status);
  CHECK_STATUS(status, "Error (rpc_ns_binding_import_begin):", ABORT);

  rpc_ns_binding_import_next(import_context,
                             (rpc_binding_handle_t *)binding_h,
                             &status);
  CHECK_STATUS(status, "Error (rpc_ns_binding_import_next):", ABORT);

  rpc_ns_binding_import_done(&import_context,
                             &status);
  CHECK_STATUS(status, "Error (rpc_ns_binding_import_done):", ABORT);

  rpc_ep_resolve_binding((rpc_binding_handle_t )binding_h,
                         message_v1_0_c_ifspec,
                         &status);
  CHECK_STATUS(status, "Error (rpc_ep_resolve_binding):", ABORT);
}



(gdb) where
#0  0xa41d6f49 in rpc__if_set_wk_endpoint (4198648, 4202756, -1073743680)
#1  0xa41dcc66 in ep_get_endpoint (4198648, 4202724, -1073743680)
#2  0xa41dcb15 in rpc_ep_resolve_binding (4202724, 4198648, -1073743680)
#3  0x400748 in do_import_binding (
    entry_name=0x47b330 "/.:/users/rousseau/alarm_server", binding_h=0x4020e4)
    at send_alarm.c:138
#4  0x400354 in main (argc=4, argv=0xbffff92c) at send_alarm.c:78


The track of the routines:

rpc_ep_resolve_binding (binding_h, if_spec_h, status)
{
    rpc_binding_rep_p_t     binding_rep = (rpc_binding_rep_p_t) binding_h;
...
    RPC_BINDING_VALIDATE_CLIENT (binding_rep, status);

    if (!binding_rep->addr_has_endpoint)
    {
        /*
         * The binding is partially bound. Prevent other threads
         * from using this handle while we are trying to resolve
         * it.
         */
        ep_get_endpoint ((rpc_if_rep_p_t) if_spec_h, binding_rep, status);
    }

...
}

ep_get_endpoint (if_r, binding_r, st)
{

    rpc_addr = &binding_r->rpc_addr;

    /*
     * Get the endpoint from the i/f spec, if present.
     */
    rpc__if_set_wk_endpoint (if_r, rpc_addr, st);

...
}

rpc__if_set_wk_endpoint (ifspec, rpc_addr, status)
{
    /*
     * get the endpoint from the if spec
     */
    rpc__if_inq_endpoint (
        ifspec,
        (*rpc_addr)->rpc_protseq_id,
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  probable core dump
        &endpoint,
        status);

...
}

Looking at the RPC internals guide, I find this description for the
rpc_addr field of a binding handle:

rpc_addr        An rpc_addr_p_t representing the address of the client (or
                server) half of this binding.  It is initialized to NULL
                if the binding refers to the local host.  Otherwise, it is
                initialized to a protocol-specific value via a call to the
                protocol server specified in "protocol_id"


In this case, the server is on the local host, and the rpc_addr field 
is NULL.

I am testing out a fix in comif.c, rpc__if_set_wk_endpoint():

    /*
     * get the endpoint from the if spec
     */
+    if (*rpc_addr == NULL)
+    {
+        *status = rpc_s_endpoint_not_found;
+        return;
+    }
    rpc__if_inq_endpoint (

[09/20/93 public]
The fix did not work:
(gdb) where
#0  0xa41d8f62 in rpc__naf_addr_set_endpoint (endpoint=0xa41dd7ae "", 
    rpc_addr=0x402104, status=0xbffffad4)
    at /project/dce/build/dce1.0.3/src/rpc/runtime/comnaf.c:437
#1  0xa41dde0e in ep_get_endpoint (if_r=0x4010f8, binding_r=0x4020e4, 
    st=0xbffffb0c) at /project/dce/build/dce1.0.3/src/rpc/runtime/comep.c:2055
#2  0xa41dd6b5 in rpc_ep_resolve_binding (binding_h=0x4020e4, 
    if_spec_h=0x4010f8, status=0xbffffb0c)
    at /project/dce/build/dce1.0.3/src/rpc/runtime/comep.c:1596
#3  0x400748 in do_import_binding (
    entry_name=0x47b330 "/.:/users/rousseau/alarm_server", binding_h=0x4020e4)
    at send_alarm.c:138
#4  0x400354 in main (argc=4, argv=0xbffffb78) at send_alarm.c:78

I am now investigating taking some code from rpc_binding_to_string_binding()
which gets an rpc_addr if the binding doesn't have one.

This might work, but I am uncertain as to when the rpc_addr in a binding
needs to be non-NULL, or if it might be required for it to be NULL in certain
cases.  The code in rpc_binding_to_string_binding() certainly expects
it to be NULL on certain occasions.

[09/21/93 public]

Since this happens in the CLEANUP path, earlier failed call may be free'ing
rpc_addr (== &binding_r->rpc_addr)? If that's the case, you may want to
keep **rpc_addr to somewhere else for the CLEANUP path.

[09/21/93 public]
Well, the problem is that binding_r->rpc_addr is NULL to start with,
so the restoration shouldn't be done.

I am guessing that you could never resolve a 'local' binding with
this routine, because it had this NULL address field.  This code
is *not* set up to handle this case.

This is looking to be a larger can of worms than I though....
Anyone at HP have thoughts on this?

[09/22/93 public]
Turns out this was a problem in the source code, the binding_h was
being cast to a pointer when it wasn't a pointer.

Not a bug in RPC
Canceled.



CR Number                     : 8606
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 8574
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : app_ref
Short Description             : error cases not described well
Reported Date                 : 9/14/93
Found in Baseline             : 1.0.2
Found Date                    : 9/14/93
Severity                      : C
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : Not applicable
Sensitivity                   : public

[9/14/93 public]
The man page for rpc_ns_profile_elt_inq_begin(3rc) does not describe the
error cases well at all.  The Output section of the PARAMETERS section is
useless.  The descriptions are nothing more than the names of the error
cases.  The DESCRIPTION section doesn't describe anything of what needs to
be done on error.  For example, do I need to call
rpc_ns_profile_elt_inq_done(3rpc) if an error occurred with the begin call?

One the rpc_s_incomplete_name error, which name is incomplete?  The
profile_name, the member_name?

What error do I get if the profile name doesn't exist?  I assume the
rpc_s_incomplete_name error.  Here's the harder question, what happens if
the profile exists, but no members match the inquiry (e.g., I gave a query
to match a specific interface_id and there are none in the profile), does
the begin call return an error?  Do I get an error on the first call to
rpc_ns_profile_elt_inq_next?  What error?

[9/24/93 public]

This CR is essentially the same as CR8574, which
(rightly) faults the error message documentation
in other rpc_ns* man pages. However, since it
makes recommendations for adding explanatory
information that's specific to rpc_ns_profile_elt_inq_begin,
I am leaving it as its own CR so as not to lose
the specific questions that it addresses.

The existing man page rpc_status_codes(7rpc) gives
somewhat better explanations of the output error
messages for rpc_ns_profile_elt_inq_begin. All
DCE error message documentation must be revisited
at DCE 1.1 due to the DCE 1.1 serviceability
project. Therefore, I am changing the "fix by" date
to "1.1" and assigning this bug to Steve
Lewontin, who presently owns the rpc ref pages.

[3/24/94 public]

Reassigned this CR to John Shirley (OSF RPC writer)
from Steve Lewontin.

[8/25/94 public]
Closed this CR because the new Problem Determination Guide does this.

[9/6/94 public]
Entered correct status of cancel, not closed



CR Number                     : 8580
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : 
Short Description             : - /u1/devobj/sb/nb_486/export/at386/usr/include/dce/stubbase.h:332: dce/ker/exc_handling_ids_krpc.h: No such file or directory
Reported Date                 : 9/10/93
Found in Baseline             : 1.0.3
Found Date                    : 9/10/93
Severity                      : A
Priority                      : 0
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/10/93 public]

- /u1/devobj/sb/nb_486/export/at386/usr/include/dce/stubbase.h:332: dce/ker/exc_
handling_ids_krpc.h: No such file or directory

- /u1/devobj/sb/nb_486/export/at386/usr/include/dce/stubbase.h:338: dce/ker/idl_
ss_krpc.h: No such file or directory

- /project/dce/build/dce1.0.3-snap/tools/at386/macho/gcc -B/project/dce/build/dc
e1
.0.3-snap/tools/at386/macho/  -c       -D_BSD -DCOMPAT_43 -DMACH -D__OSF__ -DNID
L_PROTOTYPES -DIDL_PROTOTYPES  -DAT386 -Wtrigraphs -Wcomment  -pic-none -nostdin
c -pedantic -Wpointer-arith -D_KERNEL -DKERNEL -DIDL_LIB_FLAG -DMIA    -I. -I/u1
/devobj/sb/nb_486/src/rpc/idl/klib -I/project/dce/build/dce1.0.3-snap/src/rpc/id
l/klib  -I../lib -I/u1/devobj/sb/nb_486/src/rpc/idl/lib -I/project/dce/build/dce
1.0.3-snap/src/rpc/idl/lib -I/u1/devobj/sb/nb_486/export/at386/usr/include/kerne
l -I/project/osc/build/osc_sbox1.2/export/at386/usr/include/kernel -I/project/os
c/build/osc_sbox1.2/export/at386/usr/include/kernel -I/u1/devobj/sb/nb_486/expor
t/at386/usr/include -I/project/osc/build/osc_sbox1.2/export/at386/usr/include -I
/project/dce/build/dce1.0.3-snap/export/at386/usr/include -I/project/osc/build/o
sc_sbox1.2/export/at386/usr/include   /project/dce/build/dce1.0.3-snap/src/rpc/i
dl/lib/alfrsupp.c
In file included from /project/dce/build/dce1.0.3-snap/src/rpc/idl/lib/alfrsupp.
c:61:
/u1/devobj/sb/nb_486/export/at386/usr/include/dce/stubbase.h:302: dce/ker/pthrea
d_exc.h: No such file or directory
In file included from /u1/devobj/sb/nb_486/export/at386/usr/include/dce/stubbase
.h:326, from /project/dce/build/dce1.0.3-snap/src/rpc/idl/lib/alfrsupp.c:61:
/u1/devobj/sb/nb_486/export/at386/usr/include/dce/rpcexc.h:108: dce/ker/exc_hand
ling.h: No such file or directory
In file included from /project/dce/build/dce1.0.3-snap/src/rpc/idl/lib/alfrsupp.
c:61:
/u1/devobj/sb/nb_486/export/at386/usr/include/dce/stubbase.h:332: dce/ker/exc_ha
ndling_ids_krpc.h: No such file or directory
/u1/devobj/sb/nb_486/export/at386/usr/include/dce/stubbase.h:338: dce/ker/idl_ss
_krpc.h: No such file or directory
*** Error code 1 (continuing)

[09/10/93 public]
Since this is 486 DFS stuff, reassigning to Diane.

[09/27/93 public]
Diane,

Is this still a bug?  Please close/cancel if not...

[09/30/93 public]
Doesn't look like this is still a bug, and we don't build DFS 
on the 486 for 1.0.3.  Canceled.



CR Number                     : 8525
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : cn runtime
Short Description             : bad choice of socket error to
exception mapping
Reported Date                 : 8/29/93
Found in Baseline             : 1.0.2
Found Date                    : 8/29/93
Severity                      : C
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/29/93 public]
On cma_connect error EISCONN, rpc runtime raises rpc_x_connection_closed.
This precludes partitioning cn communication errors into those 
raised during a connect and those occuring during a sendmsg or recvmsg.

Mapping to something other than rpc_x_connection_closed(aborted), for
example, rpc_x_is_already_connected, would simplify application error 
handling.

Someone might take a moment to examine the semantics of runtime when
this socket error is encountered - superficially it would seem like
a very bad situation.  An application writer might just (re)try another
binding upon receiving rpc_x_connection_closed.


See OT 7239 for more info on the socket error to exception mapping.

[09/03/93 public]
Humm...  I'm not sure what code you are talking about here.
In cnnet.c, the routine rpc__socket_connect() is called.  This
routine does a connect() (I assume it gets mapped to cma_connect)
and returns any error back up to rpc__socket_connect() (variable 'serr').

Serr, is examined for rpc_c_socket_eisconn, and set to ok if this is
the case.  Otherwise, is is mapped to a status code by 
rpc__cn_network_serr_to_status().  This routine seems harmless
enough and doesn't map the errors to anything untoward.

This is the only code I can find in RPC that refers to EISCONN.
OT 7239 isn't relevant info to this problem.  I believe you meant 7293.

[09/28/93 public]
If I don't get any more information on this bug, I will cancel it
as unable to reproduce.

[09/29/93 public]
I discovered this "bug" by munging cma_connect to to return EISCONN and then
making an rpc. The result returned was rpc_x_connection closed, but it
may have come from the subsequent cma_sendmsg on a non-existent 
connection. I had assumed runtime would be unhappy with EISCONN and the
rpc would fail during the connect.

If this is the case then no special status is required for EISCONN in
the current runtime implementation. 

I am curious, however, if runtime's coming across an already connected
socket is "normal"? Or, should it be considered an error condition?

[09/29/93 public]
It is normal for isconnected to be true in CN rpc.  If you are
trying to connect, why worry if it's already done!

I would also believe that places in RPC are not too carefull when
opening an association, that the connect hasn't already been done.

There is not a bug here.  Canceled.



CR Number                     : 8385
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : idl compiler
Short Description             : the DCE Validation Test Suite (VTS) required modifications for varying multidimensional array test with the new IDL compiler.
Reported Date                 : 7/29/93
Found in Baseline             : 1.0.3
Found Date                    : 7/29/93
Severity                      : B
Priority                      : 0
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : VTS file dvs/rpc/protocol/remote/vta-ts/ndr_server/ndr_server_mgr.c
Sensitivity                   : public

[7/29/93 public]

The VTS test number 7_21 (and 8_21), "server unmarshalling of
multidimensional varying arrays", failed when using the new IDL
compiler on the 486 port (presumably it would fail on other platforms 
as well).

This is because the previous IDL compiler generated a server stub
which produced the wrong result and the test had been incorrectly
written to interpret this result as correct.

The IDL definition is:

/* 20 - Multidimensional varying array unmarshalling test */

 [idempotent]
void ndr_mulvrary_unmarsh( [in] handle_t h,
	[in] long	first,
	[in] long	last,
	[in] long	length,
	[in, first_is(first,), last_is(last,)] signed8	small_test[0..3][0..VTA_NDR_SMALL_MARSHALL_MAX - 1],
	[in, first_is(first,), last_is(last,)] unsigned16	u_short_test[0..3][0..VTA_NDR_SHORT_MARSHALL_MAX - 1],
	[in, first_is(first,), last_is(last,)] unsigned hyper	u_hyper_test[0..3][0..VTA_NDR_HYPER_MARSHALL_MAX - 1]);
	);

The resultant C prototype is:

extern void ndr_mulvrary_unmarsh(
#ifdef IDL_PROTOTYPES
    /* [in] */ handle_t h,
    /* [in] */ idl_long_int first,
    /* [in] */ idl_long_int last,
    /* [in] */ idl_long_int length,
    /* [in] */ signed8 small_test[4][5],
    /* [in] */ unsigned16 u_short_test[4][7],
    /* [in] */ idl_uhyper_int u_hyper_test[4][7]
#endif
);

According to the AES/DC (page F-5 of the 2/20/93 draft), this mapping
to the C language is correct.

In this test, first = 0 and last = 2. 

Using the old IDL compiler, the stub code caused the data to appear in
the server manager operation AS IF the parameter declaration above
were:

    /* [in] */ idl_ulong_int [3][3],

... that is, the values are in the wrong place for a 4x7 array.
 
The new IDL is correct: the values end up in the correct
positions. The VTS has been modified to reflect this change.

Affected file:

dvs/rpc/protocol/remote/vta-ts/ndr_server/ndr_server_mgr.c

[10/12/93 public]

This VTS bug will have a new life in the dce_val OT database as CR000001.



CR Number                     : 8312
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : rpccp
Short Description             : inclusion of  <fcntl.h> not portable
Reported Date                 : 7/19/93
Found in Baseline             : 1.0.2
Found Date                    : 7/19/93
Severity                      : D
Priority                      : 3
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : rpccp.c
Sensitivity                   : public

[7/19/93 public]


The addition of  " #include <fcntl> " is operating system specific.
fcntl is a operation system specific header file.

The inclusion of file.h, a C header file, includes the necessary
information, on u*x systems it includes fcntl.h, and is portable.

The following depicts the change:

+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
Element RPCCP.C(12) Line 96
      1)#include <sys/file.h>
      1)

+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
Element RPCCP.C(11) Line 96
      2)#include <fcntl.h>
      2)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


This change was compiled, built, and executed on three of our platforms,
two of them being ultrix and osf/1.

[7/19/93 public]

Not so fast; I just checked my copy of the POSIX standard.

POSIX.1 specifies <fcntl.h>.

It does *not* specify <sys/file.h>

This change decreases portability, not increases it, and should probably
not go in.

[7/20/93 public]

Good point.  I was not aware of this.  But, our definitions of portability are
different.  My definition extends beyond u*ix operating systems to other o.s.
where fcntl.h does not exist.  Your definition of portability addresses only
the u*ix world.  So, your point about this change decreases portability is not
true when talking about my definition of portability.  The rpccp.c component 
has been building on all the platforms until this change.

[07/20/93 public]
Perhaps you have a system where "file.h" is found and "fcntl.h" is not
found.  This doesn't mean that using file.h is the "more portable" thing
to do.  DCE conforms to Posix, and posix says "use fcntl.h".  For 1.1
this defect should probably be cancelled; I guess for 1.0.3 it can
live a little longer. :-)

[7/20/93 public]

"DCE conforms to Posix" - no need to say more.  POSIX chose System V's not BSD's
header file.  My loss.  No sense it letting this live longer then it needs to.
I'll cancel this defect.

[07/20/93 public]
Canceled.



CR Number                     : 8290
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 8288
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_gd
Short Description             : The description of ACL manager 
registering information to the EPM is not correct
Reported Date                 : 7/16/93
Found in Baseline             : 1.0.2
Found Date                    : 7/16/93
Severity                      : B
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/16/93 public]

This is to do with OT 8288, on how rpcd finds the endpoint for a partial
binding. This results in the following.

Does acl server need to register to the EPM?

The doc (section 2.4.5 and 2.5.1.2 of Application Dev Guide) certains says so. 
It even tells you to register all object UUIDs for object with ACL interface.
Obviously, this comes from the conclusion that in order to resolve the end
point, rpcd would search for the pair of object UUID and interface UUID.

Now we know this is not the case. Unless the application (acl_edit in this
case) calls rpc_ep_resolve_binding() explicitly, making a call with partial
binding will result in a mgmt call being made, which will resolve the end point
using object UUID ONLY.

So if an ACL manager is writen to run with a server from the same name space
entry, we know the server itself is definitely going to export its object
UUID(s) and interface UUID and binding to the name space, and is going to
register that/those obejct UUID(s) with the interface UUID to the EPM.

When acl_edit calls sec_acl_bind(), sec_acl_bind() imports A server object UUID
(again, the acl server does not have to export to the name sapce. See section
2.4.5 of app dev guide if you are not sure of this), then it uses NULL
interface to import A binding (partial). Th next thing it does is to set
authentication stuff for the binding. In order to do so, it calls
rpc_mgmt_inq_server_princ_name() to get the server principal name with the
partial binding. What do we know already? The mgmt call will resolve the
partial binding with the object uuid in the partial binding. The call not only
returns the server's principal name, it returns the fully bound handle too. All
the subsequet rpc calls to acl interface uses this fully bound handle.

What does it mean here? It means the ACL manager does not need to register
anything to the EPM as long as the server has done so already.

Why does it work? Becasue the acl manager and the server runs in the same
server runtime process. Once the calls get to the server runtime, the ACL
interface UUID can be further used to get to the right manager, the ACL manager.

Of course, doing the extra registration is harmless, but this is not the point.

If you implement a stand alone acl server, or the acl server is exported to a
different name space entry, then you sure need to 1. export to the name space,
2. register in the epm.

[07/22/93 public]
Assigned to writer Steve Lewontin.

[10/12/93 public]

It is true that the only way for the ACL editor to reach the right server
is to look for the correct object in the endpoint map.  After all, lots of
servers export the ACL interface.  However, this kind of overloading of the
ep map entries doesn't work in every case, as the OT points out.  Given
that the current documentation tells you to do something that always works,
I'd favor leaving this for now and revisiting this question when we do the
policy guide at 1.1.



CR Number                     : 8288
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_gd
Short Description             : The description of how rpcd finds the endpoint for a partial binding is incorrect
Reported Date                 : 7/16/93
Found in Baseline             : 1.0.2
Found Date                    : 7/16/93
Severity                      : B
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/16/93 public]

According to the DCE App Dev Guide Section 14.4.1, the algorithm for obtaining 
an endpoint of a compatible server with a partial binding is as follows:

1. if the client requests a non-nil object UUID, the epm wil use the
{obj-uuid, if-uuid} pair to search the mapper. If success, return the endpoint.
Otherwise, go to 2.

2. If the client requests the nil object UUID (or if the requested non-nil
object UUID is not registered), the epm will use the pair {nil-obj-uuid,
if-uuid}. If success, return the endpoint. Otherwise, failure.

The above description is not right. When a RPC call is
passed with a partial binding, the above algorithm is NOT applied. The above
algorithm is used when an application explicitly calls
rpc_ep_resolve_binding().

The man page of rpc_ep_resolve_binding() gives a better and correct explanation
of what happens when a partial binding is used:

"Partially Bound Handles with a Non-nil Object UUID

If the application has a partially bound handle with a non-nil object UUID, the
application can decide not to call the rpc_ep_resolve_binding() routine before
calling a procedure in the management interface. In this case the remote
management call is sent to a server instance, registered on the remote host,
that offers that object UUID.

After completing the remote management call, the application has a fully bound
handle to the server instance. The server instance that the handle specifies
probably offers the non-management interface of interest to the calling
application. However, if you want to be certain of obtaining a fully bound
handle to a server intance that offers the interface needed for later remote
procedure calls, call the rpc_ep_resolve_binding() routine."

The above description matches with my programming experiment. This explains why,
if after the server comes up and I change the ep registration with a different 
interface uuid, the application still runs.

The above description further reveals that whenever a call to the mgmt routine
is made with a partial binding, upon the return, the binding is fully bound ---
to the server with the matching object uuid only.

[07/22/93 public]
Assigned to writer Steve Lewontin.

[10/12/92 public]

I believe OT 8288 reflects some misunderstanding of the role of
interface IDs in the binding process.  To begin with, the binding
information referenced by a binding handle does not contain an
interface UUID.  A partial binding consists of the tuple
object-UUID/protocol-sequence/host-address. A full binding adds an
endpoint to this. The interface UUID sent with a call is supplied by
the stub from the interface handle for the call.

When I make a call with a partial binding, the ep mapper uses both the
the object UUID and the (stub supplied) if UUID to find a compatible
endpoint, as described in the documentation.  Subsequent calls made
with the same binding handle--which is now fully bound--will no longer
make use of the endpoint mapper.  Hence, I can change the endpoint
mapping information in any way I want without affecting the success of
such calls.  Note that I can also make a call on another interface
using the same binding handle, as in the case of the management call
followed by an application RPC using the same binding.  In such a
case, the same binding information will be used for both calls, but
the stub will supply different if UUIDs.  As long as the supplied
interface UUID is registered by the server for the endpoint (along
with a compatible object UUID) the call will succeed, just as you
found.

In case you have any doubts about this, look at the cncall.c code for
connection oriented calls.  If you make a call on a binding without an
endpoint, the code actually calls rpc_ep_resolve_binding(). This call
itself makes a call to the endpoint mapper's map() routine, which is
also used for connectionless style call forwarding.

Now, the question comes up, what happens in the case of a management
call without an endpoint?  Here you can supply either an object UUID
or make an ep_resolve_binding call().  It would seem that in the
former case, the ep mapper can find you a binding for a non-matching
interface (since the mgmt interface ID is not exported to the endpoint
mapper) with a matching object UUID.  How is this done?  From
examining the rpcd code (specifically rpcdepdb.c) you can see that the
rpcd special cases the management interface UUID.  If the call is made
on this UUID, then the ep search algorithm is different and can match
on the object UUID alone.  In other words the documented endpoint
search algorithm does not apply in this special case.

My conclusion is that the endpoint algorithm described in the App.
Dev. Guide is essentially right for application specified RPCs.



CR Number                     : 8273
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : rpcd (endpoint mapper)
Short Description             : is_listening not initialized
Reported Date                 : 7/14/93
Found in Baseline             : 1.0.2
Found Date                    : 7/14/93
Severity                      : D
Priority                      : 3
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : rpcdsliv.c
Sensitivity                   : public

[7/14/93 public]

In the ping_server routine, the boolean variable is_listening is not
initialized to false.  ping_server could potentially return a true when the
server is not at all listening thus leaving stale data in the ep database.
D
D
D
D
D
D
D
D
D
D
D
server is not at all listening and thus leav

[08/23/93 public]
Looking at the code, the variable in question, is_listening, is always set:

	is_listening = rpc_mgmt_is_server_listening(binding_h, status);

The call to rpc_mgmt_is_server_listening() will always return true or false.

Not a bug, canceled.



CR Number                     : 8268
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Turn on prototype for other platforms/languages supported by DCE.
Reported Date                 : 7/13/93
Found in Baseline             : 1.0.2
Found Date                    : 7/13/93
Severity                      : E
Priority                      : 3
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : dce_error.h
Sensitivity                   : public

[7/13/93 public]
 
Turn on prototypes for dce_error_inq_text() for languages and platforms
supported by DCE.

[10/14/93 public]
As far as I can see the file *does* provide prototypes:
extern void dce_error_inq_text (
#ifdef __STDC__
    unsigned long           status_to_convert,
    unsigned char           *error_text,
    int                     *status
#endif    
);

Until code cleanup time, using STDC seems good enough for me.
Canceled.



CR Number                     : 8200
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : building rpcd
Short Description             : rpcd should not have llbd support
Reported Date                 : 6/25/93
Found in Baseline             : 1.0.2
Found Date                    : 6/25/93
Severity                      : C
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/25/93 public]
By default, rpcd should be built without NCS1.5 llbd support.  This means
adding -DNO_LLB to the CFLAGS, or perhaps adding NO_LLB as a make
variable.  I can't figure it out -- somebody who understands rpc.mk and
rpcd/Makefile should make this change.

[6/25/93 public]
It should probably be combined with the other variables that do the NCS
support such as NO_COMPAT_NCS15 in src/rpc/runtime/Makefile.

[6/25/93 public]

1) I don't think that this is a defect.

2) even if it is, you don't want to combine NO_LLB and NO_COMPAT_NCS15
(they were originally combined and were separated for a reason).

If NO_LLB is off and NO_COMPAT_NCS15 is on, you generate an rpcd which can
deal with llb requests from legacy NCS applications (such as the HP-UX
audio server, questions about which from Rich Salz spawned this defect
report), without all the COMPAT_NCS15 rpc_$foobar calls.

Since llbd and rpcd use the same well known port, you can't run both of
them at once.

I don't think the 1.5 llbd support hurts you any; you aren't testing it,
and it doesn't add that much code space.

[10/14/93 public]
I am going to have agree with Bill on this one.  Since HP is now a reference
port, its usefull to us (OSF) to have this functionality, and its more
work to take it out.

Besides, you can turn it off with the ifdefs.
Canceled.



CR Number                     : 8180
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc/runtime/cn
Short Description             : Potential memory leak in CN call control block.
Reported Date                 : 6/18/93
Found in Baseline             : 1.0.2
Found Date                    : 6/18/93
Severity                      : B
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/18/93 public]

rpc__cn_call_ccb_create() allocates a large fragbuf for the protocol
header. However, rpc__cn_call_ccb_free() returns it to a small fragbuf
list. In cncall.c/rpc__cn_call_ccb_create():
    fragbuf_p = rpc__cn_fragbuf_alloc (false);
In cncall.c/rpc__cn_call_ccb_free():
        rpc__cn_smfragbuf_free (ccb->prot_header);

This means that a process is wasting some memory, i.e., a large fragbuf in
a small fragbuf list.

[7/2/93 public]

Fixing the above memory leak caused secd and cdsd crashes in our
scalability testing (>50 client nodes doing dce_login and change passwd
simultaneously for 8 hours). The crash happened in free() because of memory
corruption in malloc'ed space. Our guess is that somewhere in CN code, the
small fragbuf, which is used only for the call_rep->prot_tlr, is
overwritten beyond 256 bytes. Without the fix, the small fragbuf free list
is populated with large fragbufs and it gives enough space to be
overwritten.

Also, I believe that sometime in the past, call_rep->prot_header
(ccb->prot_header) size was increased from the small fragbuf to the large
one (in rpc__cn_call_ccb_create()). However, other parts of CN code weren't
adjusted. For instance, RPC_CN_FREE_ALL_EXCEPT_PROT_HDR macro defined in
cnxfer.h is still using rpc_c_cn_small_frag_size to calculate the free
bytes in the prot_header.

[9/24/93 public]
rpc__cn_fragbuf_alloc with the input value 'false' is going
to allocate only a small fragbuf. (see cnfbuf.c) -
So rpc__cn_call_ccb_free() is doing the correct thing 
of calling rpc__cn_smfragbuf_free();

[9/24/93 public]

Right. I'm cancelling this CR.



CR Number                     : 8122
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpccp
Short Description             : rpcpc_entry.sh test is incomplete
Reported Date                 : 6/9/93
Found in Baseline             : 1.0.2
Found Date                    : 6/9/93
Severity                      : E
Priority                      : 4
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : test/rpc/rpccp/rpccp_entry.sh
Sensitivity                   : public

[6/9/93 public]

rcpcp_entry.sh is incomplete and therefore, does not execute properly.

specifically the syntax of the UUID's in the setup file
rpccp_setup.sh and the syntax of the commands in rpccp_entry.sh
contain errors.

We either should remove the test from our source tree or complete it.

[8/29/94 public]
Since dcecp replaces rpccp, this test is no longer supported.
We will not be moving rpccp to nosupport for 1.1, so when we do
we can move this test.  I will note that the test needs to be moved
in the defect for moving rpccp (if/when there is one).



CR Number                     : 8078
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : dg
Short Description             : flserver dumps core with fixed unaligned read access
Reported Date                 : 6/1/93
Found in Baseline             : 1.0.2a
Found Date                    : 6/1/93
Severity                      : A
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[6/1/93 public]
This happened during cho.  This is a 3 flserver cell. The flserver
on the pmax dumped core :
There is absolutely no warranty for GDB; type "show warranty" for details.
GDB 4.5, Copyright 1992 Free Software Foundation, Inc.
OSF version 1.0 created Thu Dec  3 12:48:59 1992
..(no debugging symbols found)...
Core was generated by `flserver'.
Program terminated with signal 6, IOT/Abort trap.
#0  0x73055b48 in ubik_dbVersion ()
(gdb) b main
Breakpoint 1 at 0x40fd10
(gdb) run
Starting program: /opt/dcelocal/bin/flserver 
(no debugging symbols found)...(no debugging symbols found)...
Breakpoint 1, 0x40fd10 in main ()
(gdb) kill
Kill the inferior process? (y or n) y
In Local core dump file,
#0  0x73055b48 in kill ()
(gdb) bt
#0  0x73055b48 in kill ()
#1  0x73008610 in raise ()
#2  0x7300d030 in abort ()
We had rpc tracing turned on at the time on this flserver, and this
is what it was doing at the time of the core dump:
(recv_state_timer) Ping timeout [002943a2-cae3-1515-ba9f-08002b14b387, 10.0]
(rpc__dg_call_signal_failure) CCALL st = 0x16c9a016 (orig st = 0x0) [002943a2-cae3-1515-ba9f-08002b14b387, 10.0]
(rpc__dg_call_end) Sending orphan quit
rpc__dg_ccall_timer) Orphan timeout
(rpc__dg_call_signal_failure) CCALL st = 0x16c9a016 (orig st = 0x16c9a016) [002943a2-cae3-1515-ba9f-08002b14b387, 10.0]
(rpc__dg_do_quit) Orphaning call [00295824-6a28-1818-9f6c-08002b14b387, 3.0]
(rpc__dg_scall_orphan) Orphaning scall [00295824-6a28-1818-9f6c-08002b14b387, 3.0]
(rpc__dg_call_signal_failure) SCALL st = 0x16c9a05e (orig st = 0x0) [00295824-6a28-1818-9f6c-08002b14b387, 3.0]
(rpc__krb_get_tkt) refresh failed (status 16c9a0e7)
(rpc__krb_dg_pre_call) rpc__krb_get_tkt failed: st 16c9a0e7
(rpc__dg_call_signal_failure) CCALL st = 0x16c9a0e7 (orig st = 0x0) [0012b22c-6aaa-1818-ba9f-08002b14b387, 0.0]
(rpc__dg_call_end) Sending orphan quit
rpc__dg_ccall_timer) Orphan timeout
(rpc__dg_call_signal_failure) CCALL st = 0x16c9a016 (orig st = 0x16c9a0e7) [0012b22c-6aaa-1818-ba9f-08002b14b387, 0.0]
Fixed unaligned read access. PID 447 (flserver) at pc 0x734cb9ac, addr 0x23
AbortDumpHandler called

[6/1/93 public]
Filled in Interest List CC with `cfe@transarc.com' 
Changed Responsible Engr. from `pakhtar@transarc.com' to `khale@transarc.com' 
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'

[06/02/93]

Dave is going to have a look at this.

[06/17/93 public]

Don't see it very often - lowering priority.

[06/22/93 public]

It's still with us.  Here's the stack trace from the core file:

GDB is free software and you are welcome to distribute copies of it
 under certain conditions; type "show copying" to see the conditions.
There is absolutely no warranty for GDB; type "show warranty" for details.
GDB 4.5, Copyright 1992 Free Software Foundation, Inc.

OSF version 1.0 created Thu Dec  3 12:48:59 1992

..(no debugging symbols found)...
Core was generated by `flserver'.
Program terminated with signal 6, IOT/Abort trap.
#0  0x73055b48 in ubik_dbVersion ()
(gdb) b main
Breakpoint 1 at 0x40fd10
(gdb) run
Starting program: /opt/dcelocal/bin/flserver 
(no debugging symbols found)...(no debugging symbols found)...
Breakpoint 1, 0x40fd10 in main ()
(gdb) kill
Kill the inferior process? (y or n) y
In Local core dump file,
#0  0x73055b48 in kill ()
(gdb) bt
#0  0x73055b48 in kill ()
#1  0x73008610 in raise ()
#2  0x7300d030 in abort ()
#3  0x40e12c in AbortDumpHandler ()
Cannot access memory at address 0x101be32c.
(gdb)

[6/23/93 public]

From the evidence above, I wouldn't assume that this is an RPC bug.  There are several
RPCs which fail (and appear to be handled correctly by the runtime), and there's some
kind of trap occuring.  The two may or may not be related.

Anyway, the flserver is setting up a handler (AbortDumpHandler) for SIGBUS, SIGSEGV, 
and SIGILL.  If you can reproduce the problem without using this handler, you'll be
able to tell where the fault is happening.

[7/15/93 public]
Moving out to 1.0.3 since problem is not currently blocking and we
can't make progress with the current problem staging/debugging
environment.

[9/4/93 public]

Anymore info on this? As Mark stated, the above evidence doesn't tell
whether this is an RPC bug or not. Also, the use of RPC_DEBUG, as stated in
the first report, was dangerous without the OT8255 fix. I'm lowering the
priority.

[8/22/94 public]
Since we are reaching the end of 1.1, we need to know if this really
is an RPC defect.  Has this been seen by any DFS folks in the past
6 months?  If not, I am considering canceling this defect.

[8/25/94 public]
We haven't seen this (the original failure was on the PMAX!) recently.
No usefull information will be lost, so I am canceling this defect.



CR Number                     : 8049
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : krpc
Short Description             : DG call timer should probably not time out calls in "init" state..
Reported Date                 : 5/24/93
Found in Baseline             : 1.0.2a
Found Date                    : 5/24/93
Severity                      : B
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.2a
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[5/24/93 public]
Transarc has seen some spurious comm failures when the system was under
heavy load, and these, among others, are blocking their CHO runs (exit
criteria for 1.0.2a).  I can't find an open defect report relating to this,
but I've seen mail go by on the issue in the past month, so I'm opening
this one.
When an authenticated DG call is just starting, it calls the authentication
"pre_call" operation as the last thing in rpc__dg_call_start().  At this
point, it appears that the call timer is running; if the pre_call operation
takes more than 30 seconds (and it may if the system is under very heavy
load), the call timer will blow out the call before it gets a chance to
actually transmit anything.
One possible fix may be to comment out the code in the switch in
rpc__dg_ccall_timer() which calls ccall_cancel_timer() and
ccall_timeout_timer() if the call is in the "init" state.  [The theory here
is that there isn't anything for the client to be hung up waiting for in
*this* call until after it transmits something.]

[5/25/93 public]
It's not possible to see a comm failure while in the init state.
The reason we call the two timer routines while the call is in the init
state is that it *is* possible for a call to get hung up before it has 
transmitted anything.  The runtime guarantees that calls made over a single
binding handle will be serviced by a single server.  In the event that 
concurrent calls are made over a single partially bound handle, only the first
proceeds, all others are blocked until the handle becomes fully bound.
The ccall_timeout_timer() routine is used to detect *call* timeouts (set up
through rpc_mgmt_set_call_timeout), not *comm* timeouts.  That is, it guarantees
that the total amount of time taken to run a call does not exceed a pre-determined
value.

[6/1/93 public]
Cancelled as per Mark K.

[6/2/93 public]
While the specific code in question may be correct, there is still a significant
problem being seen in dfs with respect to communication failures.  See 
OT 7932 and 7785 for more descriptions.  Can someone involved with RPC look
at these problems and give us a clue on what to do next?
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'



CR Number                     : 7958
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : dce rpc
Short Description             : Bug in binding_cache_remove function
Reported Date                 : 5/7/93
Found in Baseline             : 1.0.2
Found Date                    : 5/7/93
Severity                      : B
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[5/7/93 public]
The test cell is configureed by dfs-102-2.10 backed by osf b23 with
two machines. Running our distributed tests leads to the death of
"dfsbind" (core dump). 
Here is the stack trace for the core dump.
As you can see it is panic at refcnt == 0;
(dbx) where
raise(0x0) at 0xd00d693c
abort(0x0) at 0xd00d684c
_assert(0x0, 0xdeadbeef, 0xdeadbeef) at 0xd012c904
rpc_binding_free(binding_h = 0x202c3fbc, status = 0x201cd11c), line 214 in "com
bind.c"
rpc_binding_vector_free(binding_vec = 0x20212a6c, status = 0x201cd11c), line 28
5 in "combind.c"
rpc_ns_binding_import_done(import_context = 0x202393bc, status = 0x201cd11c), l
ine 225 in "nsbndimp.c"
sec_rgy_site_close(0x202393a8, 0x201cd11c, 0x1, 0x0, 0xdeadbeef, 0xdeadbeef, 0x
deadbeef, 0xdeadbeef) at 0xd0427d60
binding_cache_remove(0x202393a8) at 0xd0423b04
rca_binding_cache_purge(0x0) at 0xd0423d64
binding_cache_enter(0x202c1e48) at 0xd0423860
rca_site_bind(0x201cd660, 0x201cdd24, 0x3, 0x0, 0x20053f00, 0x0, 0x201cdd1c, 0x
201cdd18) at 0xd04279ac
sec_rgy_site_bind(0x201cdd38, 0x201cdd24, 0x201cdd1c, 0x201cdd18) at 0xd0422fac
sec_rgy_site_bind_query(0x201cdd38, 0x201cdd24, 0x201cdd1c, 0x201cdd18) at 0xd0
4230c8
sec_krb_sec_parse_name(0x202d8328, 0x5, 0x20171dec, 0x201ce984) at 0xd0448b90
cred_from_cred_rep(credrep = 0x201cea40, cred = 0x201ce9f8), line 446 in "auth_
helper.c"
handle_sec_krb_get_cred(inptr = "^C^B^A^A\241^Z0^X^[^Ehosts^[^Cmoe^[\ndfs-serve
r\243\2000\200\240^C^B^A^A\241^C^B^A^B\242\200^D\202^A\350^HE\347\276\324\177\3
62\315z\277\334\276\243\221\264\256^^3^H^V\274Qu[N^C\355\215\361^M\337L\274\377
3\367\353\332\207-\276Z3>&\234q\355K\306J\204\3135y; \240%[Dp^]KP^X\344\342^$|\
200\356\241\366?\373\337\316\210c2[3", inlen = 58, outbuf = ""), line 519 in "a
uth_helper.c"
do_auth_request(inptr = "A", inlen = 58, outbuf = "", outsize = 0x20171dcc), li
ne 786 in "auth_helper.c"
ProcessRequest(req = 0x20171dc4), line 371 in "main_helper.c"
service_thread(addr = 0x20090b18), line 277 in "main_helper.c"
cma__thread_base(0x200a8838) at 0xd04149a4
cma__restore_thread_ctx() at 0xd03fdfe8
raise(0x0) at 0xd00d693c
(dbx)
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[5/7/93 public]
A couple of things that I might add:  First, this condition occurs
under heavy load (and seems to take a while O(hours) to create).  It
seems to be reproducible but with effort.
I looked at the stack trace a bit.  It is running with a libdce where
the rpc code is compiled -g, so I got lost when I got into the sec
code.  Anyway, the binding vector passed to rpc_binding_vector_free is
bogus.  For example, it thinks there are ~7000 binding handles.  The
context passed to rpc_ns_binding_import_done() looks pretty bogus, as
well.  I don't know if binding_cache_remove is passing the right
thing.

[6/10/93 public]
Change fixby to 1.0.3 as agreed at 6/9 tech call with Transarc.

[6/10/93 public]
I think this problem may be fixed by Carl's auth_helper fixes.  
We should try to reproduce it when we get the new dfsbind.

[8/29/94 public]
I think this defect was fixed by the auth_helper fixes submitted over
a year ago.  In any case, the above comments seem to indicate that
bogus data was passed to rpc from security.

Canceled.



CR Number                     : 7833
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : rtandidl rattrc test
Short Description             : race cond. in rattrc
Reported Date                 : 4/29/93
Found in Baseline             : 1.0.2
Found Date                    : 4/29/93
Severity                      : D
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/29/93 public]
There is a race condition in the RPC rtandidl test rattrc (maybe attribute 
test). When verifying the maybe call to the server the client call back can
preceed completion of the server maybe call data processing. This would result
in a test failure. This characteristic was noticed during 486 platform testing.
The correction for this could be a sleep (1 sec is successful) between op1 
and op2 calls in the client.

[4/29/93 public]

The specific problem is in rattrc.c:

       rattrtest_op1 (h, 22);	/* do a maybe call */

       j = rattrtest_op2(h);	/* do a non-maybe call to check the result
 				 * of rattrtest_op1 */


When rattrtest_op2 is called, the <maybe> call might not have yet completed
on the server.  The test interprets this as a failure.

We could do something like:

	BOOL Passed = FALSE;

	rattrtest_op1 (h, 22);
	for (i = 0; (i < 10) &! Passed; i++)
	{
		j = rattrtest_op2(h);	
		if OK 
			Passed = TRUE;
		else
			sleep (2);
	}

	if !Passed
		ERROR

[4/29/93 public]

It's worse than that, if you're trying to run this over the DG protocol.  If the first 
call is still running when the second one arrives, the DG protocol assumes that  it 
missed a quit packet sent to the first call, and that the client wants to continue on to
this new call.  It tries to make things right by posting a cancel to the first call 
thread. (see OT CR 1236)

[4/29/93 public]

Hmmm... Ed was doing this test under DG.  OT 1236 is slightly different in
that it is referring to two <maybe> calls, but I assume Mark's comment
above is generic.  For the purpose of this test, it might be acceptable to
introduce a delay before trying to check the result and not trying to loop
(and thereby avoiding the cancel.)

        rattrtest_op1 (h, 22);	/* do a maybe call */
	sleep (n);
        j = rattrtest_op2(h);	/* do a non-maybe call to check the result
 				 * of rattrtest_op1 */

[10/01/93 public]
I ran in to this recently.  Mark is almost ready to submit
a fix for 1236 which may fix this.

Prasad, could you look in to this to see if we need to introduce
a delay between the calls?

[10/6/93 public]
1. From the OT1236 fix - 
A newly received maybe-call will still cancel a currently running 
non-maybe call (with a lower sequence number), but not vice versa.

2. Server has only one call thread  in the tests - so the second
idemp request will execute only after the completion of the first
Maybe request.

For these reasons there is no need for any delay between the two calls.



CR Number                     : 7790
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : RPC API rpc_binding_set_auth_info()
Short Description             : incorrect status code.
Reported Date                 : 4/23/93
Found in Baseline             : 1.0.2
Found Date                    : 4/23/93
Severity                      : B
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/23/93 public]
        We found this problem on RIOS with RPC Validation software, while
        testing RPC API with a recent DCE build.

        When rpc_binding_set_auth_info() is supplied with an unregistered
        server principal name and a valid server binding handle, it returns
        with the status "sec_rgy_object_not_found" in stead of
        KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN. This test returns the correct status
	code KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN on Pmax with the latest build.
	This test used to work on RIOS until Feb 93 with the correct status code
	KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN.

[9/27/93 public]

Is this still happening? I got the KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN status
on HP-UX using both 1.0.2 and 1.0.3 based builds (running the perf test).
Since I can't test it on RIOS, could you try it again on 1.0.3 based build.

[9/30/93 public]

If there is no new info, I'll cancel this CR.


I ran the RPC VTS API tests on 9/29/93 and did not see this 
error.

[10/1/93 public]

Not happening anymore.



CR Number                     : 7777
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : rpc_server_register_if() API
Short Description             : input parameter is being modified
upon a successful return.
Reported Date                 : 4/21/93
Found in Baseline             : 1.0.2
Found Date                    : 4/21/93
Severity                      : B
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/21/93 public]
        We found this problem on RIOS with RPC Validation software, while
        testing RPC API with latest weekly DCE build.

        rpc_server_register_if() modifies the value of the input parameter
        mgr_type_uuid when invoked, upon successful return. This happens
	with a nil or a generated uuid is supplied for this parameter.

[4/30/93 public]
	Cancelling this bug. Intermediate failures are gone with the latest
	dce build.

[8/13/93 public]
not reproducible.



CR Number                     : 7728
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : style_gd
Short Description             : explain maximum concurrency calls
Reported Date                 : 4/15/93
Found in Baseline             : 1.0.2
Found Date                    : 4/15/93
Severity                      : D
Priority                      : 3
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/15/93 public]

This note from the FAQ might be a good candidate for inclusion
in the Application Style Guide.

From: mhickey@osf.org
Subject: RPC: RPC Max Requests 
Date: Wed, 24 Feb 93 13:26:38 -0500


> From: Chris Liou <ccliou@sabre.bellcore.com>
> To: dce-talk@osf.org
> Subject: RPC max requests
> Reply-To: ccliou@cc.bellcore.com
> Date: Tue, 23 Feb 93 10:33:35 -0500
> 
> Does anybody know why rpc_c_protseq_max_reqs_default (the
> default maximum number of concurrent RPC requests that
> a server can accept) is defined as "0" in rpcbase.h,

Yes.  This is a sort-of-flag that says "at the present time, one
or more of the protocols cannot support more than one listener
socket at a time, so just allocate one socket for the protocol." 
I say sort-of-flag because in the future, if
the protocols were rev'ed to the point where they could handle 
more that one listener socket, then this value would become a 
parameter value, and code internal to the rpc runtime that currently
uses this as a flag would have to be modified to use this value
correctly as a parameter.

  Currently, as noted in the rpc_server_use*protseq*(3rpc) man pages,
any value passed in the max_call_requests arguement is reset to the
value of rpc_c_protseq_max_reqs_default internally to the rpc runtime.
The rpc runtime routines that allocate network resources (sockets, etc.)
are then called.  Currently, seeing that the max_calls parameter has the
value rpc_c_protseq_max_reqs_default, these routines set up only one 
socket for each protocol.  In the future, the latter routines would probably
not check for this equality.

> while rpc_c_listen_max_calls_default is "10"?
> The 0 value doesn't make sense to me - is this value 
> ignored, or does it have some significance?

You are mixing apples and oranges in a way that became common due to the 
way that the DCE 1.0.1 docs were written (a problem that we believe we have
dealt with in the DCE 1.0.2 docs).  The rpc_c_protseq_max_reqs_default value
has to do with the number of calls the server can ACCEPT.  The 
rpc_c_listen_max_calls_default value has to do with the number of client
requests the server can EXECUTE in parallel.  The 
rpc_c_listen_max_calls_default value (if used in the call to 
rpc_server_listen(3rpc) specifies the number of threads that the rpc runtime
creates to concurrently EXECUTE server manager code in response to RPC's 
from clients.  It also affects the number of slots in the call request buffer
that the rpc runtime allocates to queue incoming RPC's when all of the 
server execution threads are busy, since the call request buffer is sized
on an "X slots per execution thread" basis.

[6/9/93 public]

Reassigned to new owner of the document

[6/22/93 public]
Changed "Fix By Baseline" from 1.0.3 to 1.1.

[3/29/94 public]

Reassigned this CR temporarily to John Shirley (OSF rpc writer)
from Steve Lewontin until new owner of Style Guide is determined.

[4/21/94 public]

Peter Neilson and Doug Weir are joint book owners for the Style
Guide. Reassigning the CR to Peter.

[10/07/94 public]
I asked Doug Weir what to do about this CR, and he said the following:

> The short answer to your question is that nothing seems to need to
> be done. Following is an explanation why.
> 
> The CR is essentially about a parameter for rpc_server_use_protseq()
> and another parameter for rpc_server_listen() which seem to specify
> the same thing but in fact do not, but which can be (and were) con-
> fused by users-- hence the explanation.
> 
> The explanation Mark gives in the comments of your CR is sufficient
> by itself, if you wanted to insert it somewhere in the Application
> Guide. However, it looks as though the situation has silently gone
> away (almost), because of the introduction in DCE 1.1 of dced and the
> dce_server_ routines.
> 
> If a server uses the dce_server_ routines for its setup, it will
> never call rpc_server_use_protseq() (although it will call
> rpc_server_listen()), and the possible confusion your CR is all
> about can never arise. I just talked to John Shirley about the
> situation with the dce_server_ routines and he confirms what I
> guessed: the value the caller of rpc_server_use_protseq() supplies
> via the max_call_requests parameter is simply defaulted by the
> dce_server_ routines.
> 
> Of course, the old lower-level routines still exist and can still
> be used, so the question could still arise. Mark's text used to
> exist in the old version of Chapter 1 of the Application Guide (the
> one we dismembered); it's not there anymore. However, there are
> abbreviated versions of it in the RPC section of the book, and that
> is probably sufficient.

I am therefore cancelling this CR.



CR Number                     : 7689
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : Protocol version mismatch
during cdscp create clearinghouse
Reported Date                 : 4/12/93
Found in Baseline             : 1.0.2
Found Date                    : 4/12/93
Severity                      : C
Priority                      : 3
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/12/93 public]
A create clearinghouse generated the following:

cdscp> create clear /.:/os2dce06
(receive_packet) assoc->20134ad8 Protocol version mismatch - major->1
minor->5
Failure in routine: cp_create_clh; code = 382312502
Connection closed (dce / rpc)

receive_packet is in rpc/runtime/cnrcvr.c

[4/14/93 public]

We are intermittently seeing a very similar problem on the pmax while
bringing up a cell:

        /opt/dcelocal/bin/sec_clientd
        /opt/dcelocal/bin/cdsadv
        /opt/dcelocal/bin/dtsd
root@dce9> (receive_packet) assoc->100f5880 Protocol version mismatch -
major->1 minor->5
(receive_packet) assoc->100f5480 Protocol version mismatch - major->1
minor->5
(receive_packet) assoc->100f5a80 Protocol version mismatch - major->1
minor->5
(receive_packet) assoc->10183af8 Protocol version mismatch - major->1
minor->5
(receive_packet) assoc->100f5a80 Protocol version mismatch - major->1
minor->5
(receive_packet) assoc->100f5080 Protocol version mismatch - major->1
minor->5
(receive_packet) assoc->100f5080 Protocol version mismatch - major->1
minor->5
(receive_packet) assoc->100f5a80 Protocol version mismatch - major->1
minor->5
/opt/dcelocal/bin/sec_clientd 04/13/93 23:13:11 - Warning - unable to
refresh identity ... will idle and retry

[4/15/93 public]

The following is excerpted from OT 7700 and happened on the same test run:

ON CDS SERVER, DCE STARTUP WINDOW MESSAGES:

(receive_packet) assoc->20128c18 Protocol version mismatch - major->1 minor->5
(receive_packet) assoc->20128c18 frag_length 4097 in header > fragbuf data size 4096
(receive_packet) assoc->20158148 Protocol version mismatch - major->1 minor->5
/opt/dcelocal/bin/sec_clientd 04/13/93 23:13:04 - Warning - unable to refresh identity ... will idle and retry
... Cannot contact any KDC for requested realm (dce / krb)

[9/8/93 public]
Weidong Wang previously could reprodce this problem on RIOS
with an earlier DCE build (1.0.2a) with a test program.
With this same test program, this problem is not reproducible
on RIOS as well as on HP using the lastest nightly builds.
So lowering the priority - if anybody sees the problem again 
we can increase the priority.

[9/8/93 public]

did not see this problem in a while; And also could not reproduce
this problem with the test program which had sucess in reproducing in 
the earlier builds. If this problem reappears, reopen this bug.



CR Number                     : 7535
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : kruntime
Short Description             : -UNCK doesn't always undefine NCK 
					     in 1.2 Gcc compiler
Reported Date                 : 3/18/93
Found in Baseline             : 1.0.2
Found Date                    : 3/18/93
Severity                      : C
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : kruntime/Makefile
Sensitivity                   : public

[3/18/93 public]
 This problem only appears with latest 1.2 Gcc compiler:
     gcc version 2.3.1-osf.8 (pmax) 

    Some files in kruntime do want the NCK being defined, but
    some files do not. The kruntime/Makefile uses a global CFLAGS which
    has "-DNCK".  For those file who do not want it, the makefile uses
    the technique "-UNCK" to undefine it for them. But unfortunately, 
    our gcc will regroup all symbols defined and symbols undefined into 
    two groups, the order of these two groups appear is not certainly 
    the way you hope in which the group of defined symbols appears before 
    the group of undefined symbols. This means that the technique we 
    currently use does not always work. 

    So the Makefile need to be changed to have secondary CFALGS which doesn't
    have NCK defined for those files who do not want NCK.

[07/27/93 public]
Diane Delgado encountered this, and has a fixed Makefile.
Since the OSF/1 platform is not a suported reference platform
for DFS (and kruntime), I am going to cancel this bug, however
if and when these changes are needed, they are already made
so this info isn't being lost.



CR Number                     : 7485
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : idl/idl_compiler
Short Description             : Enum max boundary check is wrong.
Reported Date                 : 3/11/93
Found in Baseline             : 1.0.2b18
Found Date                    : 3/11/93
Severity                      : C
Priority                      : 3
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
The AES says that enumeration identifiers map onto consecutive integers
beginning with 0 (Section 4.3.13.1) and that up to 32767 are allowed. This
means that the mapped values of enumeration literals are in the range
0-32766. We therefore believe the existing code is correct. If you actually
have an IDL with 32767 identifiers in an enumeration and it is failing,
please e-mail me a copy and I will look into it further.
	hinxman@clt.enet.dec.com

[3/11/93 public]


IDL compiler does not allow enumerated types with 32767 elements (the max
number allowed, according to the documentation).  This is because the check
it does for determining the boundary condition is incorrect.

File affected:     src/rpc/idl/idl_compiler/astp_sim.c
Routine affected:  AST_enumerator_node().

There should be a ">" in a comparison instead of ">=" when checking for
the max number of allowed elements.

The line:
        if ((unsigned int)N >= ASTP_C_SHORT_MAX) overflow = TRUE;

Should be:
        if ((unsigned int)N > ASTP_C_SHORT_MAX) overflow = TRUE;

[3/11/93 public]

This defect should NOT have been cancelled.  I can show the problem in the
code, and I have a testcase to prove that it does not work correctly as is.

Here is the relevent code piece, from astp_sim.c:

AST_type_n_t *AST_enumerator_node
#ifdef PROTO
(
    AST_constant_n_t *constant_list,
    AST_type_k_t size
)
#else
(constant_list, size)
    AST_constant_n_t *constant_list;
    AST_type_k_t size;
#endif
{
    AST_enumeration_n_t *enum_node_ptr;
    AST_type_n_t *type_node_ptr;
    unsigned int N = 0;
    AST_constant_n_t *cp;
    int overflow = FALSE;


    /*
     * Loop through the constant nodes and assign them integer values from
     * 0 through N.
     */
    for (cp = constant_list; cp; cp = cp->next)
    {
        /*
        ** Set the value of the enum element, if we overflow set a flag
        */
        cp->value.int_val = N++;
        if ((unsigned int)N >= ASTP_C_SHORT_MAX) overflow = TRUE;
    }

    ....
    ....

If you look at the above for loop, you see that although N is initialized
to 0, it is incremented before the overflow check is done.  This causes the
overflow check to fail when the enum has the maximum number of elements,
because it considers N = max to be a failure.  Since N was set to 1 before
the first comparison was done, N should have a range of 1 to max, and not
0 to max-1.  Simply changing the >= to a > fixes the problem, and we have
the testcase to show that this fix works.  I am not going to send the
testcase thru the mail though, since it is about 500k big.  I can ftp it
somewhere, or put it somewhere where it can be picked up.



CR Number                     : 7379
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc_ns
Short Description             : clean up classversion optimization
Reported Date                 : 3/1/93
Found in Baseline             : 1.0.2
Found Date                    : 3/1/93
Severity                      : C
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/1/93 public]

David Magid of DEC reviewed the change I made for 7351 and found it to be
ok; however (as might be expected) he wanted to make a minor change to it.
He wrote:

   I don't see anything wrong with the code changes made for this.

   However, I probably would have done it a bit differently. I would have:

   - added the boolean field classversion_checked to the rpc_nsentry_t
     structure

   - initialized the field to false in rpc__nsentry_from_entry()

   - tested the field in rpc__ns_check_rpc_class_version(), called
     dnsReadAttrValue() as necessary, and change the field to true

   Both the lookup node (rpc_lkup_node_t) and inquiry context 
   (rpc_ns_inq_rep_t) contain an nsentry, so there'd be no need to
   modify those structures. 
   
   I'd prefer this alternative - it better localizes the change (to
   rpc_nsentry_t and rpc__ns_check_rpc_class_version()) and doesn't
   need to involve any of the lookup code.

Rather than delaying the submit of this known, working, performance
improvement, we're going to submit it as-is, and defer cleaning it up until
after 1.0.2..

[07/20/93 public]
Unless you wich to make the changes Bill, this isn't going get done.

Canceled.  Please re-open if you have the cleanup ready (tested of course!).



CR Number                     : 7350
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : rpc debugging
Short Description             : Hangs dce_login.
Reported Date                 : 2/24/93
Found in Baseline             : 1.0.1
Found Date                    : 2/24/93
Severity                      : C
Priority                      : 3
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[2/24/93 public]
With the environment variable RPC_DEBUG set to the value,
  2-5.255,10.255,15.255,18.255,22.255,26.255
I tried doing a dce_login.  After issuing the following message, it just
hung.
(pkt_make_reservation) blocking call, pkts 0 [007d8a02-e231-1b1b-be6c-08005a4d2084, 0.0]
This was on OSF build b15.
(OT required me to put a responsible engineer, sorry Bill.)
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[2/24/93 public]

The particular DEBUG values you've come up with tell the DG protocol to

    1) create a packet pool of size 0
    2) drop 40% of all transmitted packets

(of course #2 is hardly a problem, given #1)

[8/27/93 public]

This will go away at 1.1, as part of the serviceability mods.

[08/27/93 public]
Lower the priority on this one since it wont be fixed till 1.1.

Also, the user caused the error by setting incorrect debug flags,
an argument can be made that being able to shoot yourself in the foot
with debug isn't really a bug....  Should we close this one?

[8/27/93 public]

Yes, I think so.  The functionality which was (incorrectly) used
above will not be removed at 1.1, it will just be accessible through some
other mechanism.  If a user finds the new back door, they can cause the
same failure;  I think the important thing is that this not be something
a user can do unknowingly.

[8/27/93 public]
Complete documentation of the DEBUG values would help.  The Porting and
Testing Guide is very weak on this subject and should be updated.  Perhaps
this should be changed to a doc bug.

[08/31/93 public]
I am canceling this defect and will open a doc bug for 1.1 to get
the description of RPC_DEBUG enhanced.

[08/31/93 public]
Actually, the 1.0.2 Porting and Testing Guide has a nice section on
RPC_DEBUG (3.5.1).  I think all the info needed is there, so I'm
not going to open a doc bug.



CR Number                     : 7293
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 8574,8606
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_ref
Short Description             : rpc_mgmt_is_server_listening
man page does not list rpc_s_connect_rejected status
Reported Date                 : 2/19/93
Found in Baseline             : 1.0.2
Found Date                    : 2/19/93
Severity                      : C
Priority                      : 3
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : Problem Determination Guide Doc.
Sensitivity                   : public

[2/19/93 public]

Running the rpc Validation test suite with the dce weekly build (2/5/93)
found the following problem:

Supplying a non-NULL server binding handle to the
rpc_mgmt_is_server_listening api routine when the server is not listening,
the CN run-time returns status code "rpc_s_connect_rejected" instead of
"rpc_s_comm_failure". However, the DG run-time returns the correct status
code: "rpc_s_comm_failure".

This api test passed with prior dce builds. Also, the  status code 
"rpc_s_connect_rejected" is not listed in the Application Development
Reference.

[2/23/93 public]

I believe that the code is working correctly.  DG just returns a
generic error (comm failure) for any of a large number of failure
cases.  CN is more specific and makes an attempt to map back the
specific socket error to an RPC status code.

This means that this is a doc defect.  I leave it to Art to decide
how much specificity to incorporate.  You should also update the
VTS.

[3/18/93 public]

This appears to conflict with the goal of making choice of RPC protocol
transparent.  If the server is not listening, then there should be a common
status value used by both RPC protocols to indicate this condition.  I
don't think this should be classified as a doc bug.

[3/24/94 public]

Reassigned this CR to John Shirley (OSF RPC writer) from Steve Lewontin.

[06/08/93 public]
Changed "Fixed By Baseline" field from 1.0.2 to 1.0.3.

[ page 07/01/93 public ]

Here's the results of hacking cma to read an env var and just return
the error code from cma_connect, cma_sendmsg, cma_recvmsg.

I agree that this should be reconsidered as more than a doc bug - it
makes for a rather long list of catches if you don't use a [comm_status]
attribute.

 - Communication failures in ncacn_ip_tcp:

   When using connection-oriented rpc (ncacn_ip_tcp), note that several
   exceptions are possible where rpc_x_comm_failure was the only
possibility
   for connection-less rpc (ncadg_ip_udp).  The following lists the rpc
   exception and the socket error condition(s) under which it is raised.
   Obviously, some of the error conditions are unrealistic for the tcp
   function requested (e.g., EHOSTUNREACH for sendmsg).

     connect error (client attempts to make tcp connection to server)

       rpc exception                    socket errno

       rpc_x_cannot_connect             ENOBUFS, ESHUTDOWN, ENOTCONN
       rpc_x_connect_closed_by_rem      ECONNRESET
       rpc_x_connect_rejected           ECONNREFUSED
       rpc_x_connect_timed_out          ETIMEDOUT
       rpc_x_connection_closed          EISCONN
       rpc_x_host_unreachable           EHOSTUNREACH
       rpc_x_loc_connect_aborted        ECONNABORTED
       rpc_x_network_unreachable        ENETUNREACH
       rpc_x_rem_host_down              EHOSTDOWN
       rpc_x_rem_network_shutdown       ENETDOWN

       rpc_x_connect_no_resources
       rpc_x_too_many_rem_connects
       rpc_x_server_too_busy   

     sendmsg error (connection established, error sending packet to server)

       rpc_x_connection_aborted         ECONNRESET
       rpc_x_connection_closed          All other (errno 69-72, 73-81).

     recvmsg error (connection established, packet sent, error on recvmsg)

       rpc_x_connection_closed          All errno 69-81.

[07/02/93 public ]

Given the tenor of the last two comments, I've changed this to a code bug.

[08/24/93 public]

Note the above issue pertains to all cn rpcs, not just the mgmt calls, and
occurs on at least aix+rs6000 along with the listed platform.

Wei's point is important, also. What might be more useful than the 
current socket error to exception mapping (where rpc_x_connect_closed
appears in too many cases) is a partitioning of the errors (using runtime
state) into something like rpc_x_bind_unsuccessful and
rpc_x_connect_closed.  In the former class the application would know the 
server never received the call args and might retry the call to another
server.  For the second case, the application might be more interested
in trying to reconnect to the original server.  Not exactly transactional
rpc, but might be useful (my guess is the vast number of call failures
would fall into the first class, but that's pure speculation).

[8/25/93 public]

This one seems to be growing...

The original complaint was that the documentation did not list all of
the possible status codes returned by the rpc_mgmt_is_server_listening()
call.  I believe this is a doc bug.  Even if we did what Scott suggests,
it will never be the case that [comm_status] variables are restricted to
returning only "rpc_s_comm_failure."  Given this, the documentation should
provide a (single) listing of all the possible values that might be seen
when using a [comm_status] parameter. (Or does it already?  I know the AES
does.)  This list will also be useful to developers who want to use

[comm_status] parameters in their applications.  The description of API 
calls that use a [comm_status] parameter to do their work could then just 
refer to this list.  

The other part of this problem is the claim that there are currently too
many possible [comm_status] return values.  I agree with the intent of 
Scott's proposal, but I don't think making the runtime filter the error 
cases is the right way to achieve it; we'd be losing too much information
just for the sake of making things "cleaner."

As an example, I just finished working with a developer who was having 
trouble reaching a particular server; the client returned the status - 
ENETUNREACH.  It turned out that the server was on a multi-homed node, 
with no routing done between the two local nets.  The client happened 
to be pulling the "wrong" binding handle out of the namespace.  The point 
is, ENETUNREACH was a *much* more useful status to see than something 
like "rpc_x_bind_unsuccessful".

Obviously, a developer can hide some of this complexity by writing a
macro:

    #define CATCH_ALL_COMM_FAILURES \
            } \
            else if (exc_matches(...) || \
                     exc_matches(...) || \
                          ...
                     {
                          ...user's code


Or we could add such a macro to exc_handling.h (as an enhancement).

[08/29/93 public]
Okay. I agree the connect errors are useful info and shouldn't be 
buried.  

Let's move this back to a doc defect. I'll open code defects on 
those distinct features of the two protseqs that seem hazardous
to app development.

----
Some cn & dg (based on runtime greps) errors:

rpc_x_unknown_reject

rpc_s_unknown_if   (e.g. wrong if uuid)

----
Some cn specific (based on runtime greps) errors:

rpc_x_server_too_busy  (from common rpc_s_cthread_not_found, dg pretends it
                        never got the call).

rpc_x_rpc_prot_version_mismatch

rpc_x_tsyntaxes_unsupported


These are interesting?????

rpc_x_too_many_rem_connects  ETOOMANYREFS 
  (from errno.h)
  /* BSD 4.3 RENO */
  #define ETOOMANYREFS    115     /* Too many references: can't splice */

rpc_x_connect_no_resources   ENOSPC       
  (from errno.h)
  #define       ENOSPC  28      /* No space left on device              */

[08/30/93 public]
Moving this back to a doc bug.  Perhaps the writer and those people
involved in this discussion (page, markar) could get together and
decide what needs to be changed in the docs.

[9/23/93 public]

Reassigned this CR to myself.

[10/6/93 public]

I consulted with Steve Lowentin (RPC AES, RPC guide and ref page
writer) on this bug. Here are the results:

1. The issue: the individual man pages for the RPC routines that return
the rpc_comm_failure status code do not list all of the
possible protocol-specific communications-related status
codes that might also be returned, e.g., rpc_s_connect_rejected.

2. A possible solution would be to add a list of all the
possible protocol-specific communications-related status
codes that can be returned to the rpc status codes man page
(rpc_status_codes(7rpc). Then, for each affected API man page, 
remove the specific listing of "rpc_comm_failure" from the list of
returned status codes, and instead say that the routine
can return the protocol-specific communications-oriented
status codes described in rpc_status_codes(7rpc).

3. This change is too intensive to be completed in the 1.0.3
timeframe given its schedule and the resources available.

4. The documentation strategy for the RPC status codes
(and the rest of the DCE APIs) will need to be revisited at DCE 1.1
in light of the DCE 1.1 serviceability project and the
planned DCE Error Messages manual (see related CRs).
A better solution than the one proposed in (2) could
be found as a result of this work.

Therefore, I am changing the "fixby" date from 1.0.3 to 1.1
and I am reassigning this bug to Steve Lowentin (current
RPC writer). The writer(s) who implement the solution
to this bug will make sure they consult with the developers
who contributed to this CR (desai, markar, page) to ensure
that the solution is appropriate.

And, since new bugs were planned to be opened against
the code part of this CR, I made this CR more doc-specific
(changed the "subcomponent" and "description" fields
to refer to the Application Development Reference and
the rpc_mgmt_is_server_listening man page instead of
code-related info).

[10/15/93 public]
Changed status to defer for purposes of the 1.0.3 release.  Will be
reopened after 1.0.3 finishes.

[8/26/94 public]
This DOC BUG is being closed because the new Problem Determination Guide (PDG)
should handle explanations of all errors, regardless of which routine
returned the message.  All possible errors may not be listed for a routine,
but the PDG will (is supposed to) give you the help needed.

[9/6/94 public]
Entered correct status of cancel, not closed



CR Number                     : 7199
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : 
Short Description             : exception creating
client the second time on different machines
Reported Date                 : 2/10/93
Found in Baseline             : 1.0.1
Found Date                    : 2/10/93
Severity                      : D
Priority                      : 3
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/10/93 public]
Creating an rpc client on a different machine than the server works the
first time but the client gets an exception the second time. 
DCE has to be reloaded to fix it.

[2/10/93 public]

Could you give more information on reproducing this?  Was this using a
test program, which RPC protocols, other DCE activity, etc?

[2/10/93 public]
Bug is reproduced in mainstream. 
No other dce activity. Code follows.

server OSF1 dce6 1.1.1 osc1.1.1 b? mips
client OSF1 dce4 1.1.1 osc1.1.1 b? mips

on Client...

ot@dce4> cd /project/dme/qa/dtet/mckeen/pmax
root@dce4> ulimit -n 256
root@dce4> ./ping_client mckeen
Password must be changed!
root@dce4> ./ping_client mckeen
Password must be changed!
./ping_client: caught exception
Exception: Address exception raised (dce / thd)

on Server...

root@dce6> ./ping_server mckeen
Password must be changed!
NOTE  6192 2.11 14:43:19: SERVER mckeen: listening...
NOTE  6192 2.11 14:43:56: SERVER mckeen: ping RPC called
NOTE  6192 2.11 14:43:56: SERVER mckeen: done listening...
NOTE  6192 2.11 14:43:56: SERVER mckeen: unexporting from namespace
NOTE  6192 2.11 14:43:58: SERVER mckeen: unregistering from endpoint mapper
NOTE  6192 2.11 14:43:59: SERVER mckeen: unregistering interface
root@dce6> ./ping_server mckeen
Password must be changed!
NOTE  5902 2.11 14:44:25: SERVER mckeen: listening...

This also reproduces on 486 machines under 1.1.1b5 and 1.1.2 .

/build/bbelch@sif % more client.log
Script started on Wed Feb 03 11:16:40 1993

 clam:/project/dme/qa/dtet/mckeen# ./ping_client feb4

 clam:/project/dme/qa/dtet/mckeen# ./ping_client feb4
./ping_client: caught exception (-1539973516)
%Exception report; exception address is 0xA435DE74.
Abort process (core dumped)

/build/bbelch@sif % more server.log
mckeen@craftsman (dme10 mckeen_dme10 1) $ ./ping server feb4
NOTE  2625 2.3 11:16:29: SERVER feb4: listening...
NOTE  2625 2.3 11:16:58: SERVER feb4: ping RPC called
NOTE  2625 2.3 11:16:58: SERVER feb4: done listening...
NOTE  2625 2.3 11:16:58: SERVER feb4: unexporting from namespace
NOTE  2625 2.3 11:16:59: SERVER feb4: unregistering from endpoint mapper
NOTE  2625 2.3 11:16:59: SERVER feb4: unregistering interface
mckeen@craftsman (dme10 mckeen_dme10 1) $ ./ping server feb4
NOTE  2626 2.3 11:17:13: SERVER feb4: listening...
NOTE  2626 2.3 11:18:38: SERVER feb4: ping RPC called
NOTE  2626 2.3 11:18:38: SERVER feb4: done listening...
NOTE  2626 2.3 11:18:38: SERVER feb4: unexporting from namespace
NOTE  2626 2.3 11:18:39: SERVER feb4: unregistering from endpoint mapper
NOTE  2626 2.3 11:18:39: SERVER feb4: unregistering interface


The code is a pair of test programs. The idl file appears first.

[3/26/93 public]

Our test bed is no longer availabe to do the stack trace as Dave
requested. If someone can find machines you can contact Andy
McKeen about the problem.

[6/14/93 public]

Cancelled.



CR Number                     : 6989
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : idl backend test binop_alloc
Short Description             : not checking for exceptions properly
Reported Date                 : 1/23/93
Found in Baseline             : 1.0.2b12
Found Date                    : 1/23/93
Severity                      : C
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/23/93 public]

idl backend test binop_alloc not checking for exceptions properly

from test/rpc/idl/binop_alloc/client_aux.c:

            TRY
                binop_alloc_fail(h, i, i, &n);
                failures++;
                printf("***FAIL***: binop_alloc_fail did not raise an
exception\
n");
L3            CATCH(exc_e_illaddr)
L4            CATCH(rpc_x_unknown_remote_fault)
L1                /* Expected result */
            CATCH_ALL
                printf("***FAILURE***: binop_alloc_fail wrong exception
(expecte
d exc_e_illaddr)\n");
L2                print_exception(THIS_CATCH);
            ENDTRY;


Comments:

L1  This comment seems out of place.  The expected result should be the 
    particular CATCH clause of the expected exception.

L2  "failures++;" should be part of the CATCH_ALL (i.e., the unexpected
    results).

L3,L4 If SIGSEGV is not caught by the server, the expected exception
    is rpc_x_comm_failure.

[08/23/93 public]
Since this is in a test, OSF is responsible to fix it.

[08/31/93 public]
This code/test has been removed from the test (in 1.0.2).
Bug canceled.



CR Number                     : 6171
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : nidl_to_idl
Short Description             : calls itself to2 rather than nidl_to_idl
Reported Date                 : 11/20/92
Found in Baseline             : 1.0.2b4
Found Date                    : 11/20/92
Severity                      : D
Priority                      : 3
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/20/92 public]

The usage message in rpc/idl/nidl_to_idl refers to the program as "to2"
rather than "nidl_to_idl".

The version number of 0.001 seems rather low.

This is a purely cosmetic problem, of course.

[1/7/93 public]
Promoted to enhancement.

[5/13/94 public]
For DCE 1.1, this program is no longer supported and will be defuncted.
Enhancement canceled.



CR Number                     : 5815
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : idl makes bloated stubs
Reported Date                 : 10/26/92
Found in Baseline             : 1.0.1
Found Date                    : 10/26/92
Severity                      : B
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : oolrtns.c
Sensitivity                   : public

[10/26/92 public]

 The current IDL compiler has a serious, but very simple defect
that causes excessive stub code to be generated.  This OT report
describes a small change to IDL that will result in dramatic
savings in DFS and other DCE components.
.
BACKGROUND
  When the IDL author tries to conserve code space by applying
the [out_of_line] attribute to complex data types, the subroutines
for marshalling and unmarshalling complex data types are generated
in the xxx_caux.c and xxx_saux.c files.  The idea is that the
client stub code in the xxx_cstub.c file calls the marshall/unmarshall
routines in the xxx_caux.c file, and the server stub code in the
xxx_sstub.c file calls the marshall/unmarshall routines in the
xxx_saux.c file. 
.
  Each out_of_line data type generates four subroutines:
.
	<type>Ome [marshall, callee]   appears in xxx_saux.c file
	<type>Oue [unmarshall, callee] appears in xxx_caux.c file
.
	<type>Omr [marshall, caller]   appears in xxx_caux.c file
	<type>Our [unmarshall, caller] appears in xxx_caux.c file
.
PROBLEM STATEMENT
.
  But in fact, the marshalling code in the 'Ome' routines is identical 
to that in the 'Omr' routines.  The unmarshalling code in the 'Oue' and
'Our' routines is also identical.
.
  Therefore, binaries like a DFS kernel or kernel extension, or a shared
libdce, that must link in both client and server stubs, are likely to be
linking in two copies of the marshalling/unmarshalling code.  For 
aggressive users of the [out_of_line] facility, this can add up to a
big penalty.
.
SUGGESTION
.
  The suggestion is to add a new switch to IDL, "-client stub_saux",
directing the IDL compiler to generate a client stub which calls the
marshalling and unmarshalling routines in the server aux file, and 
leave out the generation of a client aux file.  This change is backward
compatible with existing uses of the IDL compiler - clients who
do not supply the new switch will not observe any change.  Clients
who wish to take advantage can add the switch in their IDLFLAGS.
.
  I have prototyped this enhancement using a 1.0.1-based IDL compiler
with reasonable success.  The idl changes involve expanding the
command line parser to recognize a new switch, and a one line change
to change the name of the out_of_line [un]marshalling routines to
be the name found in the server aux file. 
.
  In the case of DFS, use of the '-client stub_saux' switch, combined
with tagging most of the non-trivial data-types with [out_of_line],
resulted in a 100KB savings in kernel code size, and smaller savings
for user space utilities.  I believe similar or better results could
be obtained in libdce.

[6/9/93 public]

The new idl code generator makes this OT moot.



CR Number                     : 5721
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : port_gd
Short Description             : Better test descriptions needed for perf client program
Reported Date                 : 10/20/92
Found in Baseline             : 1.0.1
Found Date                    : 10/20/92
Severity                      : E
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/20/92 public]

section 3.4.2.2.3 of the dce porting and testing guide describes the perf
client test program. The various tests which can be run using this program
are enumerated and the syntax of their invocation is descibed under
"test_params". The format and content of this section should be improved to
include decriptions of what functionality is excercised by each of the
tests (e.g test 15 excercises thread cancellation functionality), as well
as more complete command line descriptions detailing the semantic 
relationships between the various test parameters in the context of each
of the numbered tests. In addition, some information should be provided
to aid the user in interpretting the output produced by these tests.

I am making this enhancement request, after recieving a service call
regarding a particular client test, I resolved by inspecting the test code
to learn what functionality was being tested, under what conditions, and
fromthis information I eventually drew the conclusion that the parameters
passed to the test caused explainable behavior to be presented in a
misleading fashion. The problem was simply that the user, in the absence of
information explaining how to assign values to related test parameters,
chose values which caused the test to produce output which, in the absence
of instructions on how to interpret test output, was perceived
(incorrectly) to indicate that the test had failed.

[11/5/92 public]
Assigned this to me

[8/13/96 public]
Cancelled--Porting Guide no longer exists.



CR Number                     : 5659
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : uuidgen
Short Description             : Add an interface name command
line option to uuidgen.
Reported Date                 : 10/15/92
Found in Baseline             : 1.0.1
Found Date                    : 10/15/92
Severity                      : E
Priority                      : 4
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/15/92 public]
Why not include the capability in the uuidgen command code to accept an
optional command line argument to plug into "INTERFACENAME" in the
resulting .idl file?

[07/20/93 public]
After consideration, OSF does not have the resources to make this enhancement. 

Canceled.



CR Number                     : 5340
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : pkt_alloc asserts due to
rpc_g_dg_pkt_pool.free_count=0
Reported Date                 : 9/4/92
Found in Baseline             : 1.0.1b25
Found Date                    : 9/4/92
Severity                      : B
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/4/92 public]

Using the dramatic tests with a three system configuration.  We found
that pkt_alloc asserts due to rpc_g_dg_pkt_pool.free_count=0.

This problem cannot currently be reproduced but should be investigated
using the stack trace and looking at the runtime time code.

is_sort() is simply an intermediate server routine that sorts data by calling
ussort().

The idl definition for ussort:
extern void ussort(
#ifdef IDL_PROTOTYPES
    /* [in] */ handle_t h,
    /* [in] */ uuid_t *cuuid,
    /* [in, out] */ idl_long_int data[][80],
    /* [in] */ idl_ulong_int size,
    /* [out] */ error_status_t *status
#endif

The acf entry for ussort:

interface isus1
{
	[enable_allocate] ussort([comm_status, fault_status] status);
}

The call to ussort from is_sort() in dtis1_manager.c:
void    is_sort(
        handle_t bh,
        uuid_t *cuuid,
        idl_ulong_int nth,
        idl_char *unres_name,
        IS_SortType stype,
        idl_long_int data[][IS_LINE_LENGTH],
        idl_ulong_int size,
        error_status_t *stp
)
{
        rpc_binding_handle_t    us_bh;
        uuid_t  objuuid;
        int     allowed;
        int     check_stack;
        NestedRpcThreadData     *nrtd;
        error_status_t  st;

        SS_ALLOC_TEST;

        nrtd = callcallback(bh, cuuid, nth);

        allowed = chkacl(
                logfp,
                bh,
                cuuid,
                princ_full_name,
                si->protect_level,
                si->authn_svc,
                si->authz_svc,
                op_name[3],
                stp
        );
        if (*stp != rpc_s_ok) {
                if (trace_rpc)
                        LOGhead(logfp, cuuid, "exiting is_sort(1)");
                waitcallback(cuuid, nrtd);
                return;
        }
        if (!allowed) {
                LOGshot(logfp, cuuid, "Error",
                        "Not allowed to execute is_sort");
                *stp = sec_acl_not_authorized;
                if (trace_rpc)
                        LOGhead(logfp, cuuid, "exiting is_sort(2)");
                waitcallback(cuuid, nrtd);
                return;
        }

        check_stack = chkmgrcount(logfp, cuuid);

        getobjuuid(cuuid, stype, &objuuid);

        setupbinding(bh, cuuid, nth, unres_name, &objuuid, &us_bh, stp);
        if (*stp != rpc_s_ok) {
                if (trace_rpc)
                        LOGhead(logfp, cuuid, "exiting is_sort(3)");
                waitcallback(cuuid, nrtd);
                return;
        }

        if (trace_rpc)
                LOGhead(logfp, cuuid, "calling ussort");
        else
                showentryname(us_bh, cuuid, "is_sort");
        ussort(us_bh, cuuid, data, size, stp);
        if (trace_rpc)
                LOGhead(logfp, cuuid, "returning from ussort");
        if (*stp != rpc_s_ok)
                LOGstat(logfp, cuuid, "ussort", *stp);

        rpc_binding_free(&us_bh, &st);
        if (st != rpc_s_ok)
                LOGstat(logfp, cuuid, "rpc_binding_free", st);

        waitcallback(cuuid, nrtd);
        have_a_rest(logfp, cuuid, si->pacing);
        if (trace_rpc)
                LOGhead(logfp, cuuid, "exiting is_sort(0)");
}

[10/16/92 public]
Changed code enginer to Mishkin.

[1/7/92 public]

This bug does not seem to be reproducible.  Can we get it cancelled?

[1/7/93 public]

For William Sullivan in our PVT group:

 We can probably reproduce this defect by using the dramatic test in
 a high stress environment ( ie 10 clients, 10 threads/client ) with
 short ( i.e. 5 minute ) call timeouts.  This problem was reproducible
 in the testing but it got marked defer because we could avoid it
 easily and otherwise it was not reproducible.  I am fairly certain 
 it is related to rpc call cancellation.

I do not think this should be cancelled.  We (IBM) will get back to it
as soon as we are able.

[8/29/94 public]
This defect is so stale I do not believe any information will be lost
by canceling it.  IBM has (apparently) never gotten back it (1 1/2 years)
and no one outside of them has seen it (*ever* as far as I can tell).

Canceled.



CR Number                     : 5181
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : Connection-Oriented RPC Protocol
Short Description             : Server hangs and sends dummy
packets forever.
Reported Date                 : 8/24/92
Found in Baseline             : 1.0.1b23
Found Date                    : 8/21/92
Severity                      : B
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/24/92 public]

As part of the DCE validation test suite we are testing the Connection-based
RPC protocol and we need explanation on the following test scenario.

We are testing the CN RPC Server run-time in the following manner.
The validation software acting as a DCE Client sends a BIND PDU to the 
CN RPC Server runtime with:
		max_xmit_frag = 0;
		max_recv_frag = 0;

The value '0' implies (according to the NCA Run-time Extensions Spec) the
default value; i.e.MustRecvFragSize = 1432.

The DCE Server run-time in turn sends a BIND_ACK PDU with:
		max_xmit_frag = 1432;
		max_recv_frag = 0;

A Request PDU is then sent to the Server run-time to perform a remote 
procedure call. The Server run-time in turn sends a correct Response to the
validation software. But, after the last fragment of the Response is sent
by the Server, it starts behaving differently. The Server starts sending
unknown packets to the validation client software forever; i.e with the
value '0' in every field except call_id and p_cntx_id which are same
as were for the original request.

It appears that the DCE Server run-time is hung in the loop sending the
unknown packets forever assuming that it is still continuing with the
response fragments for the request. Another BIND request is also ignored by
the Server run-time when it is hung in this state.

[9/9/92 public]

We are having difficulty reproducing this.  We are able to reproduce
the bind/bind_ack behavior, but we don't see the looping that comes
after.

Can you please rerun the experiment with the following values:

1) Have the client send
   max_xmit_frag = 4096
   max_recv_frag = 0

2) Have the client send
   max_xmit_frag = 0
   max_recv_frag = 4096

And see if either of these cases exhibit the same behavior.

Also, can you send me the IDL file that you used and, if it's variable,
the datasize you specified?

[9/23/92 public]

As per our conversation, we have tested the two scenerios described
below and have found the following results.

1) Client sends:
   max_xmit_frag = 4096
   max_recv_frag = 0

The same behavior by the dce server run-time has been exhibited as before; 
i.e. server appears to be hung.

2) Client sends:
   max_xmit_frag = 0
   max_recv_frag = 4096

This scenerio works ok.

Also, the datasize in the IDL file is not variable.

[10/16/92 public]
Changed A1 -> B2

[10/16/92 public]
Changed code engineer to Wei Hu @ DEC.

[1/7/93 public]
Promoted to enhancement.

[07/20/93 public]
Bill Sommerfeld makes a convincing argument that this should be a defect
because you can write a denial of service attack if you can get
servers to hang.

[9/16/93 public]
We found this problem through RPC validation software, when we filed
this bug.

I tried to reproduce the problem using the RPC validation software, 
with the recent nightly builds, both on HP and 486, with no luck.



CR Number                     : 4970
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : rpccp
Short Description             : unauthenticated rpccp behavior
differs from cdscp.
Reported Date                 : 8/9/92
Found in Baseline             : 1.0.1b25
Found Date                    : 8/9/92
Severity                      : D
Priority                      : 3
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/9/92 public]

unauthenticated (no/expired creds) rpccp behavior differs from cdscp:

$ klist
No DCE identity available: No currently established network identity for
which c
ontext exists (dce / sec)

Kerberos Ticket Information:
klist: No credentials cache file found (dce / krb) while setting cache
flags (ti
cket cache /tmp/krb5cc_1252)
$ rpccp show entry /.:/cell-profile

>>> rpc runtime error: No currently established network identity for which
conte
xt exists (dce / sec)

$ cdscp show obj /.:/cell-profile
Warning: you have no network credentials. All requests will be
unauthenticated.

                        SHOW
                      OBJECT   /.../raiford.austin.ibm.com/cell-profile
                          AT   1992-08-09-19:22:35
            RPC_ClassVersion = 0100
                 RPC_Profile =
501e7c0d3a11ca11b71f08001e01dc6c01000000000973656
369646d61700020002f2e2e2e2f726169666f72642e61757374696e2e69626d2e636f6d2f7365630
0
                 RPC_Profile =
50de738f8c76ca11bffc08001e0394310100000000086b726
2357270630020002f2e2e2e2f726169666f72642e61757374696e2e69626d2e636f6d2f73656300
                 RPC_Profile =
f838e3b13395c911a34a08001e019c1e01000000000672707
269760020002f2e2e2e2f726169666f72642e61757374696e2e69626d2e636f6d2f73656300
                 RPC_Profile =
4242266ff8b9c911ad3108002b0dc0350100000000044c414
e0028002f2e2e2e2f726169666f72642e61757374696e2e69626d2e636f6d2f6c616e2d70726f666
96c6500
                 RPC_Profile =
ddf2374d43ed000002c037cf2e00000104000000000366730
01f002f2e2e2e2f726169666f72642e61757374696e2e69626d2e636f6d2f667300
                 RPC_Profile =
2a4e81eb9900ca11867802608c2ea96e04000000000462616
b002f002f2e2e2e2f726169666f72642e61757374696e2e69626d2e636f6d2f7375627379732f646
3652f6466732f62616b00
                     CDS_CTS =
1992-08-07-01:24:57.343905100/10-00-5a-4f-53-3a
                     CDS_UTS =
1992-08-07-01:25:38.338633100/10-00-5a-4f-53-3a
                   CDS_Class = RPC_Profile
            CDS_ClassVersion = 1.0

[10/16/92 public]
Changed to enhancement.

[05/04/94 public]
This enhancement wont be made to rpccp, since it it being replaced by dcecp.
However the dcecp and dced people should take a look at this and 
make sure dcecp has consistant behavior. 
Adding them to the CC list so they can see it.
Canceling this enhancement



CR Number                     : 4330
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : src/rpc/runtime/ns*.c
Short Description             : Output context parameter not
checked for all ns..begin APIs
Reported Date                 : 6/18/92
Found in Baseline             : 1.0.1b17
Found Date                    : 6/18/92
Severity                      : E
Priority                      : 4
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/18/92 public]

I have entered this as an enhancenment. 

Full Description:

        In rpc_ns_binding_import_begin, the value of import_context
        was not checked before being used to store the import context.

        In rpc_ns_binding_lookup_begin, the value of lookup_context
        was not checked before being used to store the lookup context.

        In rpc_ns_group_mbr_inq_begin, the value of inquiry_context
        was not checked before being used to store the inquiry context.

        In rpc_ns_profile_elt_inq_begin, the value of inquiry_context
        was not checked before being used to store the inquiry context.

        In rpc_ns_entry_object_inq_begin, the value of inquiry_context
        was not checked before being used to store the inquiry context.

        This would cause a write to an invalid address.

Repeat By:

        passing a NULL as the context for any of the above APIs

Proposed Solution:

        At least check for NULL import_context, lookup_context,
        or inquiry_context before storing to it.

[07/20/93 public]
OSF DCE does not have input argument checking as a philosophy.

Canceled.



CR Number                     : 3896
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : rpc_ns_binding_export api.
Short Description             : This api returns a status code
which is incorrect.
Reported Date                 : 5/28/92
Found in Baseline             : 1.0.1b16
Found Date                    : 5/28/92
Severity                      : C
Priority                      : 3
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/28/92 public]

The rpc_ns_binding_export routine is supplied with the entry 
/.:/DVS_dir/dvs_entry. But the directory DVS_dir does not exist under cell
root (/.:). This routine returns a status: entry not found; which is
incorrect. It should return as status something like directory does not
exist. Also, the Application Development Reference does not list the
status code entry not found under rpc_ns_binding_export reference page.

[6/15/92 public]

The nsentry create routine does a cds create object call.  When the
directory does not exist, cds returns DNS_UNKNOWNENTRY and we convert
that to a status message of rpc_s_entry_not_found.
I don't think we can return anything else unless we change the
behavior of the CDS clerk.

I've marked this an enhancement instead of a defect and downgraded
its severity from B1 to C2.



CR Number                     : 3690
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : idl invokes '/lib/cpp' by default.
Reported Date                 : 5/20/92
Found in Baseline             : 1.0.1
Found Date                    : 5/20/92
Severity                      : C
Priority                      : 3
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rpc/idl/idl_compiler/sysdep.h
Sensitivity                   : public

[5/20/92 public]
On Unix systems, the idl compiler invokes the C preprocesser via
'/lib/cpp'.  This is a bad assumption for the PMAX.  A better answer is to
invoke 'cc -E' instead so that the preprocessor is picked off the command
line and (the big benefit for the PMAX) the GCC_EXEC_PREFIX prefix will be
used.  The code in question is included below.

/*
** Default command to invoke C preprocessor.
*/
#ifdef UNIX
# ifdef apollo
#  define CPP "/usr/lib/cpp "
# else
#  define CPP "/lib/cpp "
# endif
#endif

[1/ 5/93 public]
Changed to a 1.1 code cleanup.

[08/23/93 public]
This doesn't seem to be a high priority problem if we aren't going to
fix it till 1.1.

Lowered to a C3.

[05/13/94 public]
The #define in question are in the system dependant header file for idl.
Since our current use of -cpp_cmd gives us (and anyone else) the 
functionality we need, I don't see any point in changing this code.

Any vendors who wants to invoke a different cpp can do so when porting.

Enhacement canceled.



CR Number                     : 3207
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 3207
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rpc_ss_register_auth_info routine is not supported in DCE1.0, will it be supported in DCE1.0.1?
Reported Date                 : 5/2/92
Found in Baseline             : 1.0
Found Date                    : 5/2/92
Severity                      : C
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/2/92 public]


Full Description:

        No security on automatic binding;
        The rpc_ss_register_auth_info routine is not supported.
        It is therefore not possible to set authentication and
        authorization information for auto_handles and implicit
        binding handles in general.


	[The Application Development Guide, page 13-16, notes that 
	rpc_ss_register_auth_info is not supported in DCE RPC Version 1.0,
	if this won't be supported in DCE1.0.1 this note needs to be
	updated -  Martha DasSarma]

[5/7/92 public]

Full Description:
	rpc_ss_register_auth_info(3rpc) man page not found in includes or
	libdce.a. 

	Could not find rpc_ss_register_auth_info(3dfs) in the include
	files or in libdce.a.

	Which is correct, the man page or the code?

[10/16/92 public]
Changed code enginer to Mishkin.

[1/7/93 public]
Promoted to enhancement.

[07/20/93 public]
The answer to the question is NO.

Canceled.



CR Number                     : 2186
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : rdacl interface
Short Description             : acl clients forced to use server's language
Reported Date                 : 3/5/92
Found in Baseline             : 1.0
Found Date                    : 3/5/92
Severity                      : D
Priority                      : 3
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/5/92 public]

the rdacl interface doesn't allow the acl client to specify the language
to use for converting internal acls into a printable format (ex. for cds
directories, "rwdtcia").  since the rdacl server is the process that deals
with message catalogues, all acl clients in a cell (for a given rdacl server)
are forced to use the same language that the rdacl server is using.

[3/5/92 public]

You're absolutely right.  It's something that should have been thought
of before, but since some components (secd) don't even use msg catalogs
for permissions yet, it'll be a little more complicated.  The OSF has
decided that Internationalization issues shall be deferred to DCE1.1,
and since this issue needs the time to be thought out (and proposed)
correctly, we'd like to defer this defect to DCE1.1.  None of the auth6
changes planned for DCE1.0.1 will preclude us from fixing the problem
in 1.1. Please lower the severity/priority from B2 as that does not
reflect the severity (and definitely not the priority) of the problem
for 1.0.1 and please change the status to 'defer' from 'open'.

[3/5/92 public]

oops.  changed sev/pri from B2 to D3.

[3/16/92 public]

Mike wasn't quite right - we did consider this before.  It was decided
at a DCE technical meeting at the OSF that there was no standard for
passing locale information over an RPC call.  Given this (and given
issues with threading) we decided to not worry about internationalization
of messages provided in RPCs.  I've reassigned this problem to DCE
instead of security since it is a general problem with the DCE that
has to be solved before action can be taken in the security component.

[03/28/94 public]

This is very old, is it still a valid problem?

Mike, please cancel this enhancement if it no longer is an issue.

[03/29/94 public]
I am cancelling this for two related reasons:
While in DCE 1.1 we do now have a way to send I18N characters around,(1)
for interoperability (reachability, really) there are certain fields in
certain parameters that by design we limit to the portable character set.(2)



