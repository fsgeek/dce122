CR Number                     : 12737
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : dce1.1 Unintegrated - pointer_t and byte redefined
Reported Date                 : 10/27/94
Found in Baseline             : 1.1
Found Date                    : 10/27/94
Severity                      : A
Priority                      : 0
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/27/94 public]

platform AT486

extract from  file tests.log.10-26-94 in directory
/u1/RAT_tools/1_1unintegratedlogs/nb_unintegrated_486 
on vertigo


/project/dce/build/unintegrated-snap/tools/at386/macho/gcc -B/project/dce/build/
unintegrated-snap/tools/at386/macho/  -c    -D_SHARED_LIBRARIES   -D_BSD     -I.
 -I/u2/devobj/sb/nb_unintegrated_486/src/test/rpc/rtandidl/moretests -I/project/
dce/build/unintegrated-snap/src/test/rpc/rtandidl/moretests   -I/u2/devobj/sb/nb
_unintegrated_486/export/at386/usr/include -I/project/dce/build/unintegrated-sna
p/export/at386/usr/include   -pic-lib   -L/u2/devobj/sb/nb_unintegrated_486/expo
rt/at386/usr/shlib -L/project/dce/build/unintegrated-snap/export/at386/usr/shlib
 -L/usr/shlib -L/u2/devobj/sb/nb_unintegrated_486/export/at386/usr/lib     -L/pr
oject/dce/build/unintegrated-snap/export/at386/usr/lib    -ldce -lm -lbsd   /pro
ject/dce/build/unintegrated-snap/src/test/rpc/rtandidl/moretests/binding_copy.c

/project/dce/build/unintegrated-snap/src/test/rpc/rtandidl/moretests/bindtest.h:
55: redefinition of `pointer_t'
/u2/devobj/sb/nb_unintegrated_486/export/at386/usr/include/dce/dce.h:105: `point
er_t' previously declared here
*** Error code 1

......
......

/project/dce/build/unintegrated-snap/tools/at386/macho/gcc -B/project/dce/build/
unintegrated-snap/tools/at386/macho/  -c    -D_SHARED_LIBRARIES   -D_BSD    -I.
-I/u2/devobj/sb/nb_unintegrated_486/src/test/rpc/idl/cover1 -I/project/dce/build
/unintegrated-snap/src/test/rpc/idl/cover1  -I.. -I/u2/devobj/sb/nb_unintegrated
_486/src/test/rpc/idl -I/project/dce/build/unintegrated-snap/src/test/rpc/idl -I
/u2/devobj/sb/nb_unintegrated_486/export/at386/usr/include -I/project/dce/build/
unintegrated-snap/export/at386/usr/include   -pic-lib  -L.. -L/u2/devobj/sb/nb_u
nintegrated_486/src/test/rpc/idl -L/project/dce/build/unintegrated-snap/src/test
/rpc/idl -L/u2/devobj/sb/nb_unintegrated_486/export/at386/usr/shlib -L/project/d
ce/build/unintegrated-snap/export/at386/usr/shlib -L/usr/shlib -L/u2/devobj/sb/n
b_unintegrated_486/export/at386/usr/lib     -L/project/dce/build/unintegrated-sn
ap/export/at386/usr/lib    -lidltest -ldce -lm -lbsd   /project/dce/build/uninte
grated-snap/src/test/rpc/idl/cover1/manager.c

/project/dce/build/unintegrated-snap/src/test/rpc/idl/cover1/manager.c:41: redef
inition of `byte'
/u2/devobj/sb/nb_unintegrated_486/export/at386/usr/include/dce/dce.h:151: `byte'
 previously declared here

[10/27/94 public]
I assume this is a result of the threads code submitted.
Reassigning to John and Threads.



CR Number                     : 12728
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : libdce_1.o
Short Description             : UHYPE:undefined symbols
Reported Date                 : 10/26/94
Found in Baseline             : 1.1
Found Date                    : 10/26/94
Severity                      : A
Priority                      : 0
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : threads/Makefile
Sensitivity                   : public

[10/26/94 public]

/project/dce/build/unintegrated-snap/tools/at386/macho/ld -R -export_default libdce:          -L/u2/devobj/sb/nb_unintegrated_486/export/at386/usr/shlib -L/project/dce/build/unintegrated-snap/export/at386/usr/shlib -L/usr/shlib -L/u2/devobj/sb/nb_unintegrated_486/export/at386/usr/lib     -L/project/dce/build/unintegrated-snap/export/at386/usr/lib   -o libdce.so.X libdce_1.o libdce_2.o libdce_3.o libdce_4.o  -lc -lbsd -liconv /project/dce/build/unintegrated-snap/tools/at386/macho/gnulib  
libdce_1.o: Undefined symbol "_cma_send_error" referenced
libdce_1.o: Undefined symbol "_cma_send_errno" referenced
libdce_1.o: Undefined symbol "_cma_send_exception" referenced
libdce_1.o: Undefined symbol "_cma_send_fatal" referenced
libdce_1.o: Undefined symbol "_cma__init_dce_errors" referenced

[10/26/94 public]
Maryanne approved UHYPE status. About to do the submit.

[10/26/94 public]
Submitted the Makefile.

[10/26/94 pubic]
This should have been against threads. It was fixed yesterday.



CR Number                     : 11665
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : pthread_yield causes multi-delegate infinite loop
Reported Date                 : 8/12/94
Found in Baseline             : 1.1b13
Found Date                    : 8/12/94
Severity                      : A
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/12/94 public]

The multi delegate test for delegation fails on a 486 machine
when I start any of the servers.  It goes into an infinite
loop on the call:

   /* Give the sigcatch thread a chance to do its work before we
   ** continue.  Force a context switch to the signal catching thread.
   ** The signal catching thread will yield back to us when it calls
   ** sigwait().
   */
   pthread_yield();

I get zillions of "caught unexpected signal (signum -1)"

caught unexpected signal (signum -1)
caught unexpected signal (signum -1)
caught unexpected signal (signum -1)

This code works on HP/UX machine but it is failing on a 486.
The code is in my sandbox ~bhaim/sb/dce/src/test/systest/multi/sigcatch.c
The code is also in the AFS cell in /afs/dce.osf.org/project/dce/hp/dlg.tar
I have assigned this CR to myself for further investigation.
However, if anyone has a clue as to what is going 
on that is greatly appreciated.

[8/12/94 public]

This is probably a porting problem with the test.

[8/15/94 public]
Nothing brilliant to say, but I would recommend putting a -1 case in the
switch following sigwait() and printing the errno.  EINVAL is the only 
documented one but who knows what you might get.  Why is signal SIGLOST
in there?

[9/17/94 public]

      By commenting out the following lines in sigcatch.c
      the servers were able to start.

        #if 0
                sigaddset(&mask, SIGUSR1);
                sigaddset(&mask, SIGUSR2);
                sigaddset(&mask, SIGLOST);
        #endif

     Apparently the mask was getting corrupted
     from the sigaddset calls.  This only happens on OSF/1.

     Since I was able to workaround this problem,
     I am cancelling this bug.



CR Number                     : 9101
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : thr
Subcomponent Name             : 
Short Description             : thread assertion fails in cdscp
Reported Date                 : 10/13/93
Found in Baseline             : 1.0.3
Found Date                    : 10/13/93
Severity                      : B
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/13/93 public]
cdscp fails with a thread assertion failure:

cdscp> show obj /.:/subsys/dce/*
cdscp> 
**** Assertion failure. cma__queue_empty: queue corruption -- head->blink->flink != head
     at line 436 in /project/dce/build/dce1.0.3/src/threads/cma_timer.c 
%Internal DCE Threads problem (version CMA BL10+), terminating execution.

[7/12/94 public]
This was almost certainly caused by a pointer in cdscp stomping on the
threads run queue. It hasn't been seen that I know, at least in cdscp 
since this report. cancelled.



CR Number                     : 8906
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : thr
Subcomponent Name             : 
Short Description             : bogus errno's returned by cma_read
Reported Date                 : 10/4/93
Found in Baseline             : 1.0.2a
Found Date                    : 10/4/93
Severity                      : C
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.2a
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : closed

[10/4/93 public]
This is related to OT 8693.  cma_read on HPUX can be persuaded to return some
very bogus-looking errno's, including ENOSPC and ENXIO.  The errno returned
is dependent on external circumstances, such as whether stdout is piped into
"more" or goes directly to the terminal.  Here are some specifics.
(1) Simple read program
    I compiled the following program using c89 on an HP9000/710 at Transarc:
--------------
#include <pthread.h>
#include <fcntl.h>
#define DEVICE  "/dev/rdsk/c201d6s0"
#define SIZE    (814162 * 1024)
main()
{
        int fd;
        int offset = SIZE - 10 * 1024;
        extern int errno;
        int bytes;
        char buf[1024];
        errno = 0;
        fd = open(DEVICE, O_RDONLY);
        printf("fd=%d\n", fd);
        while (1) {
                lseek(fd, offset);
                bytes = read(fd, buf, 1024);
		if (bytes == -1)
                printf("bytes = %d, offset=%ld, errno=%d\n", bytes, offset, errno);
		else
		printf("bytes = %d, offset=%ld\n", bytes, offset);
                offset += 1024;
        }
}
--------------
Results:
  - When I piped the output through more, reads beyond some point return
    ENOSPC.  I haven't determined what point that is (i.e. whether it
    corresponds to the size of the partition).  I only know that when I
    ran the program as is, I got ENOSPC, but when I set the initial value
    of SIZE to 10 * 1024, cma_read returned 1024.
  - When I didn't pipe the output through more, cma_read returned 1024
    (i.e. successful read) on EVERY call no matter where we had lseek'ed to.
I ran the following program also:
--------------
/*
 * This is edsk_GuessDeviceCapacity ported as a trivial
 * standalone utility.  It doesn't work on HPUX with or
 * without my proposed patch.
 *
 * The errno is still ENXIO, which I don't know how to get
 * with a simpler program.
 */
#include <pthread.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#define DEVICE  "/dev/rdsk/c201d6s0"
long edsk_GuessDeviceCapacity(int, char*, long);
main()
{
    long capacity;
    int fd;
    if ((fd = open(DEVICE, O_RDONLY)) == -1) {
       perror("couldn't open device");
       exit (1);
    }
    capacity = edsk_GuessDeviceCapacity(fd, DEVICE, 8096);
    printf("capacity=%ld\n", capacity);
}
#define AFS_HPUX_ENV
#define EPISODE_DISKBUFFER_MINSIZE 8096
#define osi_Alloc malloc
#define osi_Free(d, s) free((void *)s)
/*
 * The following function is identical to the one in episode/anode/edbasic.c
 */
long 
edsk_GuessDeviceCapacity(
    int rfd,
    char *RawDev,
    long blksiz
    )
{
    char ErrMsg[500];
    unsigned long L, H, M;
    int High, Res, Size;
    char *Data;
    Size = blksiz;
    if (Size < EPISODE_DISKBUFFER_MINSIZE) Size = EPISODE_DISKBUFFER_MINSIZE;
    Data = (char *) osi_Alloc(Size);
    if (Data == NULL) return -1;
    L = 1;	/* needs to be > 0 so that the loop can terminate if H hits 0 */
    H = (0xffffffff) / ((unsigned long) blksiz) - 1;
    while (L <= H) {
	M = (L + H) / 2;
	High = 0;
	errno = 0;
	if (lseek(rfd, M*blksiz, SEEK_SET) == -1) {
	    if (errno == EINVAL) High = 1;
	    else {
		sprintf(ErrMsg, "lseek(%lu) of %s", (M*blksiz), RawDev);
		perror(ErrMsg);
		osi_Free(Data, Size);
		return -1;
	    }
	} else {
	    errno = 0;
	    Res = read(rfd, Data, blksiz);
	    if (Res == blksiz) {
		High = -1;
	    } else if (Res >= 0 && Res < blksiz) {
		High = 1;
	    } else if ((Res > blksiz) || Res < 0) {
#ifdef AFS_HPUX_ENV
		if (errno == ENOSPC)
#else /* AFS_HPUX_ENV */
		if (errno == ENXIO || errno == EINVAL || errno == EIO)
#endif /* AFS_HPUX_ENV */
		{
		    High = 1;
		} else {
		    sprintf(ErrMsg, "read() of %s, %lu for %d", RawDev, (M*blksiz), blksiz);
		    perror(ErrMsg);
		    osi_Free(Data, Size);
		    return -1;
		}
	    }
	}
	if (High > 0) {
	    H = M - 1;
	} else {
	    L = M + 1;
	}
    }
    osi_Free(Data, Size);
    return H;
}
--------------
Results:
  The first call to read ALWAYS returns ENXIO.
Both programs were provided by Michael Schmitz @ OSF.  They were constructed
in the process of debugging OT 8693.
It is not clear to me what cma_read is "supposed" to do when reading beyond
the end of a partition.  For a single-threaded program, I suggest that it
should return the same errno (if any) or results (if any) as are returned
by the read system call.
In any case, the fact that the results depend upon the use of "more" suggests
that the current behavior is unintentional, i.e. a bug.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[10/5/93 public]
Since this is not a DFS problem, I have changed the responsible engineer to
our threads guy.

[10/5/93 public]
Sigh.  Was that really me who wrote the above programs?  First of all, I
defined osi_Free incorrectly, and of course lseek has three arguments.
The following fixed program produces correct results multithreaded or
not.  
As not documented in the HPUX read(2) system call, read() can return
ENXIO for a raw disk device special file if you do the following:
	lseek to an offset not a multiple of the block size (512)
	attempt a read
Also, ENOSPC is returned on reads past EOF.  All that is
needed is to check for ENXIO in edsk_GuessDeviceCapacity.  
edsk_GuessDeviceCapacity is unusual in that it is meant to fail
for small block sizes.  The caller is expected to call back with
blksiz set to progressively higher powers of two until the function
succeeds.  During newaggr, this function is called first with
blksiz=128, then with blksiz=256, then with blksiz=512.  The
first two fail with ENXIO, and the third succeeds.  The only
problem in the original code was that ENXIO was not treated as
an expected error.
/*
 * Compile with:
 *
 * c89 -o g -g -D_HPUX_SOURCE  
 *	-I/project/dce/build/nb_ux/export/hp800/usr/include
 *      -L/project/dce/build/nb_ux/export/hp800/usr/lib g.c -ldce
 */
#include <pthread.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#define DEVICE  "/dev/rdsk/c201d4s0"
long edsk_GuessDeviceCapacity(int, char*, long);
main(
    int argc,
    char *argv[]
    )
{
    long capacity;
    int fd;
    long blksiz;
    if (argc <2) {
        printf("g: must specify blksize\n");
        exit(1);
    }
    blksiz = atol(argv[1]);
    if ((fd = open(DEVICE, O_RDONLY)) == -1) {
       perror("couldn't open device");
       exit (1);
    }
    capacity = edsk_GuessDeviceCapacity(fd, DEVICE, blksiz);
    if (capacity > 0)
        printf("Device has %ld blocks of size %ld\n", capacity, blksiz);
    else
        printf("blksiz not usable (%ld)\n", capacity);
}
#define AFS_HPUX_ENV
#define EPISODE_DISKBUFFER_MINSIZE 8192
#define osi_Alloc malloc
#define osi_Free(d, s) free((void *)d)
#define EXPORT
#define IN
/*
 * The following function is identical to the one in episode/anode/edbasic.c
 */
EXPORT long edsk_GuessDeviceCapacity (rfd, RawDev, blksiz)
  IN int rfd;
  IN char *RawDev;
  IN long blksiz;
{
    char ErrMsg[500];
    unsigned long L, H, M;
    int High, Res, Size;
    char *Data;
    Size = blksiz;
    if (Size < EPISODE_DISKBUFFER_MINSIZE) Size = EPISODE_DISKBUFFER_MINSIZE;
    Data = (char *) osi_Alloc(Size);
    if (Data == NULL) return -1;
    L = 1;      /* needs to be > 0 so that the loop can terminate if H hits 0 */
    H = (0xffffffff) / ((unsigned long) blksiz) - 1;
    while (L <= H) {
        M = (L + H) / 2;
        High = 0;
        errno = 0;
        if (lseek(rfd, M*blksiz, SEEK_SET) == -1) {
            if (errno == EINVAL) High = 1;
            else {
                sprintf(ErrMsg, "lseek(%lu) of %s", (M*blksiz), RawDev);
                perror(ErrMsg);
                osi_Free(Data, Size);
                return -1;
            }
        } else {
            errno = 0;
            Res = read(rfd, Data, blksiz);
            if (Res == blksiz) {
                High = -1;
            } else if (Res >= 0 && Res < blksiz) {
                High = 1;
            } else if ((Res > blksiz) || Res < 0) {
#ifdef AFS_HPUX_ENV
                /*
                 * HPUX returns ENOSPC when reading past the end of
                 * the device and ENXIO when reading at offsets not
                 * a multiple of the device block size.  There's no
                 * need to continue the search when errno is ENXIO.
                 */
                if (errno == ENXIO) {
                    osi_Free(Data, Size);
                    return -1;
                }
                else if (errno == ENOSPC)
#else /* AFS_HPUX_ENV */
                if (errno == ENXIO || errno == EINVAL || errno == EIO)
#endif /* AFS_HPUX_ENV */
                {
                    High = 1;
                } else {
                    sprintf(ErrMsg, "read() of %s, %lu for %d", RawDev, (M*blksiz
), blksiz);
                    perror(ErrMsg);
                    osi_Free(Data, Size);
                    return -1;
                }
            }
        }
        if (High > 0) {
            H = M - 1;
        } else {
            L = M + 1;
        }
    }
    osi_Free(Data, Size);
    return H;
}

[10/5/93 public]
The above explanation looks adequate to me.  Cancelling.
Changed Status from `open' to `cancel' 
Changed Transarc Status from `open' to `closed'



CR Number                     : 8454
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : cma_timer.c
Short Description             : In cma__init_timer, there is
no check for error return from setitimer.
Reported Date                 : 8/16/93
Found in Baseline             : 1.0.2
Found Date                    : 8/16/93
Severity                      : C
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/16/93 public]

Full Description:

        If an error occurs on the call to setitimer, there is no
        indication of failure and the timer will not be running thereby
        disabling most of the thread scheduling.

[10/18/93 public]
There isn;t any meaningfull way to handle this condition. The call is
internal to threads and it must just work. If an error were detected 
there is no way to get notification to the application. The call to
cma_init is transparent and is made as a result of a call to an api 
interface. No api interface allows for notification to the user of setimer
errors.



CR Number                     : 8398
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : cma_init.c, cma_util.c
Short Description             : Trace file management in
startup won't work with locks that are added by osf/1 reentrant libc
Reported Date                 : 8/2/93
Found in Baseline             : 1.0.2
Found Date                    : 8/2/93
Severity                      : C
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/2/93 public]

Licensee reported the following problem with osf/1's reentrant C library. 
Basically the lock that libc_r.a added for file operation does not 
coexist with DCE trace mechanism.

The suggested fix also involves some fix to libc_r.a on osf/1 system.

Full Description:

 On our OSF/1 base, stdio locking and the use of the trace file are
 incompatible.  The trace file is opened before locks have been set;
 however, once the locks have been specified, the next use of the trace
 file fails because its lock is not known to DCE.
 
 The only way I know of to solve this is to close the trace file while
 the locks are being specified, then reopen it (for append).  This also
 requires modifying libc to not attempt to retain lock info on FILE
 structures that are currently unused.
 
 Reason:  OSDqa05606 Trace file management in startup won't work with locks
 Add cma__suspend_trace function, fix trace file opening to re-open
 after a suspension of tracing.
 
     *** /tmp/ci.21083..cma_util.c.21110.1	Thu Jul 15 12:53:37 1993
     --- /tmp/cma_util.c.21110.2	Thu Jul 15 12:53:38 1993
     ***************
     *** 601,616 ****
            */
           if (optcnt == 0)
       	cma___g_trace_bits = ~0;
       
           trace_env[trclen] = '\0';
     !     cma___g_trace_file = cma__int_fopen (trace_env, "w");
     !     cma__trace_print (
       	    cma__c_trc_init,
       	    "(init_trace) opening trace file %s",
       	    trace_env);
           }
       /*
        *  FUNCTIONAL DESCRIPTION:
        *
        *	cma__trace_print - Print trace statements to a log file.
        *
     --- 601,670 ----
            */
           if (optcnt == 0)
       	cma___g_trace_bits = ~0;
       
           trace_env[trclen] = '\0';
     ! #if _CMA_OSIMPL_ == _CMA__OS_OSF
     !     /* if cma___g_trace_file is non-null, we're re-opening, so append */
     ! 
     !     if (cma___g_trace_file) {
     !         cma___g_trace_file = cma__int_fopen (trace_env, "a+");
     ! 	cma__trace_print (
     ! 	    cma__c_trc_init,
     ! 	    "(init_trace) re-opening trace file %s",
     ! 	    trace_env);
     !     } else {
     ! #endif
     !         cma___g_trace_file = cma__int_fopen (trace_env, "w");
     ! 	cma__trace_print (
       	    cma__c_trc_init,
       	    "(init_trace) opening trace file %s",
       	    trace_env);
     + #if _CMA_OSIMPL_ == _CMA__OS_OSF
     +     }
     + #endif
     +     }
     + #if _CMA_OSIMPL_ == _CMA__OS_OSF
     + /*
     +  *  FUNCTIONAL DESCRIPTION:
     +  *
     +  *	Close the trace file (if one is open); this is normally done
     +  *	only when locks are being set (to prevent the FILE struct
     +  *	for the trace file from having an improper lock in it).
     +  *
     +  *  FORMAL PARAMETERS:
     +  *
     +  *	none
     +  *
     +  *  IMPLICIT INPUTS:
     +  *
     +  *	cma___g_trace_file
     +  *
     +  *  IMPLICIT OUTPUTS:
     +  *
     +  *	none
     +  *
     +  *  FUNCTION VALUE:
     +  *
     +  *	none
     +  *
     +  *  SIDE EFFECTS:
     +  *
     +  *	none
     +  */
     + void
     + cma__suspend_trace
     + #ifdef _CMA_PROTO_
     + 	(void)
     + #else	/* no prototypes */
     + 	()
     + #endif	/* prototype */
     +     {
     + 	    if (cma___g_trace_file)
     + 		    fclose(cma___g_trace_file);
           }
     + #endif
       /*
        *  FUNCTIONAL DESCRIPTION:
        *
        *	cma__trace_print - Print trace statements to a log file.
        *
     ***************
     *** 1647,1656 ****
     --- 1701,1711 ----
       	cma__bugcheck ("gettimeval: gettimeofday");
       
           time_struc->tv_sec = tmptime.tv_sec;
           time_struc->tv_nsec = tmptime.tv_usec * 1000;
       #endif
     +     return(0);
           }
       /*  DEC/CMS REPLACEMENT HISTORY, Element CMA_UTIL.C */
       /*  *23   24-MAR-1992 13:46:39 BUTENHOF "Put bugcheck output in file" */
       /*  *22   13-MAR-1992 14:10:35 BUTENHOF "Add tracing" */
       /*  *21   10-MAR-1992 16:27:58 BUTENHOF "Change ftime to gettimeofday" */
 
Related-file::Added 930716 by wright:: 3.add_enc
 /build/hiosfm/RCS/src/dce/src/threads/./cma_init.c,v 7.2
 wright 1993/07/15 16:55:22 +47 -3
 Reason:  OSDqa05606 Trace file management in startup won't work with locks
 Correct setting of locks, add errno function specification, and
 revise trace file usage to avoid lock mismanagement.
 
     *** /tmp/ci.21129..cma_init.c.21158.1	Thu Jul 15 12:55:24 1993
     --- /tmp/cma_init.c.21158.2	Thu Jul 15 12:55:24 1993
     ***************
     *** 250,259 ****
     --- 250,262 ----
       #include <cma.h>
       #undef _EXC_NO_EXCEPTIONS_
       #if defined(SNI_DCOSX)
       #include <sys/resource.h>
       #endif	/* SNI_DCOSX */
     + #if _CMA_OSIMPL_ == _CMA__OS_OSF
     + #include <lib_data.h>
     + #endif
       #include <cma_defs.h>
       
       #if _CMA_UNIX_TYPE ==  _CMA__SVR4
       #define CMA_INIT_NEEDED 1
       #endif
     ***************
     *** 452,461 ****
     --- 455,467 ----
       	lib_spinlock_func_t	spinlock_trylock;
       	lib_threadid_func_t	thread_id;
       } lib_lock_functions_t;
       
       static lib_lock_functions_t	cma___g_lib_funcs;
     + #if _CMA_OSIMPL_ == _CMA__OS_OSF
     + static lib_data_functions_t	cma___g_data_funcs;
     + #endif
       
       # ifndef NDEBUG
       static cma__t_int_mutex		*cma___g_dbg_libcr_m;
       static lib_mutex_t		cma___g_dbg_libcr_v[1024];
       static int			cma___g_dbg_libcr_c;
     ***************
     *** 551,560 ****
     --- 557,576 ----
           {
           /*
            * Initialize the environment first, specifically to get the value of the
            * trace file (if any). This assume that cma___init_env isn't dependent
            * on ANY other DECthreads features!
     +      *
     + #if _CMA_OSIMPL_ == _CMA__OS_OSF
     +      * Which, on OSF/1, is a bogus assumption, unless you close the
     +      * trace file in cma___init_lib_hooks; otherwise, you get conflicting
     +      * locks in place for the trace file, and the DCE locking package
     +      * barfs ("never heard of this lock").  Close-and-reopen didn't work
     +      * either, since the close logic tried to be cute and recycle the
     +      * FILE struct, rather than deleting the lock.  I have since modified
     +      * our libc to avoid this.
     + #endif     
            */
           cma___init_env ();
       
           /*
            * WARNING:
     ***************
     *** 669,679 ****
     --- 685,706 ----
           cma__init_signal ();
           cma__trace ((cma__c_trc_init, "(init_static) debug code"));
           cma__init_debug ();			/* Must be after mutexes */
       #if (_CMA_OSIMPL_ == _CMA__OS_OSF) && _CMA_REENTRANT_CLIB_
           cma__trace ((cma__c_trc_init, "(init_static) library reentrancy hooks"));
     + # if _CMA_OSIMPL_ == _CMA__OS_OSF
     +     cma__suspend_trace ();
     + # endif
           cma___init_lib_hooks ();
     + # if _CMA_OSIMPL_ == _CMA__OS_OSF
     +     /*
     +      * Reinitialize the environment, specifically to reopen the trace file
     +      * (if any).  We can't continue to use the same stream, because its locks
     +      * will be wrong now that they've been explicitly specified.
     +      */
     +     cma___init_env ();
     + # endif
       #endif
           cma__trace ((cma__c_trc_init, "(init_static) timers"));
           cma__init_timer ();
           cma__trace ((cma__c_trc_init, "(init_static) initialization complete"));
           }
     ***************
     *** 998,1010 ****
           cma___g_lib_funcs.spinlock_delete = (lib_spinlock_func_t)cma___spin_delete;
           cma___g_lib_funcs.spinlock_lock = (lib_spinlock_func_t)cma___spin_lock;
           cma___g_lib_funcs.spinlock_unlock = (lib_spinlock_func_t)cma___spin_unlock;
           cma___g_lib_funcs.spinlock_trylock = (lib_spinlock_func_t)cma___spin_trylock;
           cma___g_lib_funcs.thread_id = (lib_threadid_func_t)cma___get_self_tcb;
     ! 
           libc_declare_lock_functions (&cma___g_lib_funcs);
           ldr_declare_lock_functions (&cma___g_lib_funcs);
           }
       #endif					/* _CMA__OS_OSF */
       /*  DEC/CMS REPLACEMENT HISTORY, Element CMA_INIT.C */
       /*  *30   24-APR-1992 17:04:11 SCALES "Unconditionalize signal module init" */
       /*  *29   17-APR-1992 11:11:19 BUTENHOF "Add version number string" */
     --- 1025,1054 ----
           cma___g_lib_funcs.spinlock_delete = (lib_spinlock_func_t)cma___spin_delete;
           cma___g_lib_funcs.spinlock_lock = (lib_spinlock_func_t)cma___spin_lock;
           cma___g_lib_funcs.spinlock_unlock = (lib_spinlock_func_t)cma___spin_unlock;
           cma___g_lib_funcs.spinlock_trylock = (lib_spinlock_func_t)cma___spin_trylock;
           cma___g_lib_funcs.thread_id = (lib_threadid_func_t)cma___get_self_tcb;
     ! #if _CMA_OSIMPL_ == _CMA__OS_OSF
     !     /* OSF/1 libc name starts with an underscore */
     !     _libc_declare_lock_functions (&cma___g_lib_funcs);
     ! #else
           libc_declare_lock_functions (&cma___g_lib_funcs);
     + #endif
     + #if _CMA_OSIMPL_ != _CMA__OS_OSF
     +     /* function does nothing on OSF/1 system */
           ldr_declare_lock_functions (&cma___g_lib_funcs);
     + #endif
     + 
     + #if _CMA_OSIMPL_ == _CMA__OS_OSF
     + {
     +     extern int *cma_errno _CMA_PROTOTYPE_ ((void));
     + 
     +     cma___g_data_funcs.data_hdl = NULL;
     +     cma___g_data_funcs.data_ref = (void *(*)(void *))cma_errno;
     +     _libc_declare_data_functions(&cma___g_data_funcs);
     + }
     + #endif
           }
       #endif					/* _CMA__OS_OSF */
       /*  DEC/CMS REPLACEMENT HISTORY, Element CMA_INIT.C */
       /*  *30   24-APR-1992 17:04:11 SCALES "Unconditionalize signal module init" */
       /*  *29   17-APR-1992 11:11:19 BUTENHOF "Add version number string" */

[10/18/93 public]
libc_r.a isn't used in our reference osf/1 configuration. Even as an 
enjancement request we wouldn;t want to modify osf.1'a libc_r.a to make
it work. Canceled

[10/18/93 public]
Marked as enhancement last time, meant to cancel. Canceled now.



CR Number                     : 8396
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : cma_ux.c cma_vp.c
Short Description             : cma_fork code does not manage
child properly when using Mach threads and reentrant libc
Reported Date                 : 8/2/93
Found in Baseline             : 1.0.2
Found Date                    : 8/2/93
Severity                      : C
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/2/93 public]

Licensee reported the following problem when using Mach threads and
reentrant libc:

Full Description:

 In a threads implementation using Mach threads, the cma_fork() call
 does not maintain state properly in the child.  The mach state must be
 reinitialized, and the vp state must be reinitialized in a specific
 order. 
 
 Do reinits in correct order, invoke mach_reinit, avoid reinit_malloc
 (which does not exist on OSF/1). cma__reinit_malloc is used but not 
 defined in OSF/1 reentrant code part.

 mach_init() is part of libmach.a on osf/1 system.
 
     *** /tmp/ci.22319..cma_ux.c.22346.1	Thu Jul 15 17:03:55 1993
     --- /tmp/cma_ux.c.22346.2	Thu Jul 15 17:03:55 1993
     ***************
     *** 249,258 ****
     --- 249,266 ----
           } cma___t_fork_rtns;
       
       /*
        * LOCAL MACROS
        */
     + #if (_CMA_OSIMPL_ == _CMA__OS_OSF) && _CMA_REENTRANT_CLIB_
     +     /*
     +      * If we're on OSF/1 system and using libc_r.a instead of wrappers, then
     +      * there are cma__reinit_malloc calls, but there is no such routine, so
     +      * we're just defining it out of existence for now.  Error??
     +      */
     + # define cma__reinit_malloc(cma__c_reinit_prefork_lock)
     + #endif
       
       /*
        * LOCAL FUNCTIONS
        */
       
     ***************
     *** 426,436 ****
           else {					/* child process */
       	/*
       	 * Reinitialize required data structures, and remove all other
       	 * threads from the known threads list in forked process.
       	 */
     ! 
       	/*
       	 * FIX-ME:
       	 *
       	 * This is inefficient. In each case, we need to clear state and
       	 * unlock the mutexes. The two are separated because the parent
     --- 434,446 ----
           else {					/* child process */
       	/*
       	 * Reinitialize required data structures, and remove all other
       	 * threads from the known threads list in forked process.
       	 */
     ! #if (_CMA_OSIMPL_ == _CMA__OS_OSF) && _CMA_REENTRANT_CLIB_
     !     mach_init();
     ! #endif
       	/*
       	 * FIX-ME:
       	 *
       	 * This is inefficient. In each case, we need to clear state and
       	 * unlock the mutexes. The two are separated because the parent
     ***************
     *** 439,448 ****
     --- 449,459 ----
       	 * functions should be implemented as a switch() with the clear case
       	 * preceeding and falling through into the unlock case.
       	 */
       	cma__unset_kernel ();	
       	cma__int_unlock (cma__g_global_lock);
     + 
       #if (_CMA_OSIMPL_ == _CMA__OS_OSF) && _CMA_REENTRANT_CLIB_
       	/*
       	 * If we're on OSF/1 system and using libc_r.a instead of wrappers,
       	 * then we're also using cma_malloc.c, and need to call its prefork
       	 * reinit.
     ***************
     *** 475,488 ****
       	cma__reinit_signal (cma__c_reinit_postfork_unlock);
       	cma__reinit_mutex (cma__c_reinit_postfork_clear);
       	cma__reinit_mutex (cma__c_reinit_postfork_unlock);
       	cma__reinit_attr (cma__c_reinit_postfork_clear);
       	cma__reinit_attr (cma__c_reinit_postfork_unlock);
     ! 	cma__reinit_vp (cma__c_reinit_postfork_clear);
       	cma__reinit_vp (cma__c_reinit_postfork_unlock);
       	cma__reinit_debug (cma__c_reinit_postfork_clear);
       	cma__reinit_debug (cma__c_reinit_postfork_unlock);
       
       	/*
       	 * Call do fork specifying that we're in child just after fork. This
       	 * for atfork() functionality.
       	 */
     --- 486,503 ----
       	cma__reinit_signal (cma__c_reinit_postfork_unlock);
       	cma__reinit_mutex (cma__c_reinit_postfork_clear);
       	cma__reinit_mutex (cma__c_reinit_postfork_unlock);
       	cma__reinit_attr (cma__c_reinit_postfork_clear);
       	cma__reinit_attr (cma__c_reinit_postfork_unlock);
     ! 
     ! 	/* don't rearrange the following unless you really know what
     ! 	 * you are doing */
     ! 
       	cma__reinit_vp (cma__c_reinit_postfork_unlock);
       	cma__reinit_debug (cma__c_reinit_postfork_clear);
       	cma__reinit_debug (cma__c_reinit_postfork_unlock);
     + 	cma__reinit_vp (cma__c_reinit_postfork_clear);
       
       	/*
       	 * Call do fork specifying that we're in child just after fork. This
       	 * for atfork() functionality.
       	 */
     ***************
     *** 684,693 ****
     --- 699,710 ----
           {
           cma___g_fork_queue_mutex = cma__get_mutex (&cma__g_def_attr);
           cma__obj_set_name (cma___g_fork_queue_mutex, "atfork queue");
           cma__queue_init (&cma___g_fork_handler_queue);
           }
     + 
     + 
       /*  DEC/CMS REPLACEMENT HISTORY, Element CMA_UX.C */
       /*   14A1 17-APR-1992 08:34:06 KEANE "Apply undeferral fix to improved BL9" */
       /*  *17   13-MAR-1992 14:10:46 BUTENHOF "Add tracing" */
       /*  *16   19-FEB-1992 13:50:37 SCALES "Perform undeferal on enter-kernel" */
       /*  *15   18-FEB-1992 15:31:27 BUTENHOF "Adapt to new alloc_mem protocol" */
 
Related-file::Added 930716 by wright:: 3.add_enc
 /build/hiosfm/RCS/src/dce/src/threads/./cma_vp.c,v 7.4
 wright 1993/07/15 21:07:07 +75 -16
 Reason:  OSDqa05609 cma_fork code does not manage child properly
 Clean up vpid's properly, note which one belongs to the only thread
 running in the child.
 
     *** /tmp/ci.22365..cma_vp.c.22425.1	Thu Jul 15 17:07:09 1993
     --- /tmp/cma_vp.c.22425.2	Thu Jul 15 17:07:09 1993
     ***************
     *** 262,275 ****
           }
       
       /*
        *  FUNCTIONAL DESCRIPTION:
        *
     !  *	cma__reinit_vp:  Do pre/post re-Initialize 
        *
        *  FORMAL PARAMETERS:
        *
        *	flag
        *
        *  IMPLICIT INPUTS:
        *
        *	None
     --- 262,338 ----
           }
       
       /*
        *  FUNCTIONAL DESCRIPTION:
        *
     !  *	cma___del_vpid:  delete a specific vpid structure
        *
        *  FORMAL PARAMETERS:
        *
     +  *	qptr		 queue containing vpid structure
     +  *
     +  *  IMPLICIT INPUTS:
     +  *
     +  *	none
     +  *
     +  *  IMPLICIT OUTPUTS:
     +  *
     +  *	None
     +  *
     +  *  FUNCTION VALUE:
     +  *
     +  *	None
     +  *
     +  *  SIDE EFFECTS:
     +  *
     +  *	None
     +  *
     +  *      this code was removed from the reinit_vp routine since it's
     +  *	needed twice
     +  *
     +  */
     + #if _CMA_KTHREADS_ == _CMA__MACH
     + static void
     + cma___del_vpid
     + #ifdef _CMA_PROTO_
     + 	(
     + 	cma__t_queue	*qptr)
     + #else	/* no prototypes */
     + 	(qptr)
     + 	cma__t_queue	*qptr;
     + #endif	/* prototype */
     +     {
     + 	cma__t_vpid	vptr = (cma__t_vpid)qptr;
     + 
     + 	cma__queue_remove (qptr);
     + 
     + 	/*
     + 	 * FIX-ME
     + 	 *
     + 	 * Need to determine whether ports are copied to a forked
     + 	 * task... if so, we need to port_deallocate() here, and
     + 	 * we don't need to allocate a new port for the current
     + 	 * VP (else clause).
     + 	 */
     + 	cma__trace ((
     + 		cma__c_trc_init | cma__c_trc_vp,
     + 		"(del_vpid) deleting cached vp_id %08x, vp %d, synch %d",
     + 		vptr,
     + 		vptr->vp,
     + 		vptr->synch));
     + 
     + 	cma__free_mem ((cma_t_address)vptr);
     +     }
     + #endif
     + 
     + /*
     +  *  FUNCTIONAL DESCRIPTION:
     +  *
     +  *	cma__reinit_vp:  Do pre/post fork re-Initialize 
     +  *
     +  *  FORMAL PARAMETERS:
     +  *
        *	flag
        *
        *  IMPLICIT INPUTS:
        *
        *	None
     ***************
     *** 308,319 ****
       	    break;
       	    }
       	case cma__c_reinit_postfork_clear : {
       	    thread_t		self;
       	    cma__t_queue	*qptr;
       
     - 
       	    /*
       	     * Remove all active VP structures, except for the VP that's
       	     * currently running.
       	     */
       	    self = thread_self ();
     --- 371,383 ----
       	    break;
       	    }
       	case cma__c_reinit_postfork_clear : {
       	    thread_t		self;
       	    cma__t_queue	*qptr;
     + 	    cma__t_int_tcb	*cur_tcb = cma__get_self_tcb();
     + 	    cma__t_vpid		myvp = cur_tcb->sched.processor->vp_id;
       
       	    /*
       	     * Remove all active VP structures, except for the VP that's
       	     * currently running.
       	     */
       	    self = thread_self ();
     ***************
     *** 322,342 ****
       	    while (qptr != &cma___g_vp_queue) {
       		cma__t_vpid	vptr = (cma__t_vpid)qptr;
       		cma__t_queue	*qnext = cma__queue_next (qptr);
       
       
     ! 		if (vptr->vp != self) {
     ! 		    cma__queue_remove (qptr);
       		    /*
       		     * FIX-ME
       		     *
       		     * Need to determine whether ports are copied to a forked
       		     * task... if so, we need to port_deallocate() here, and
       		     * we don't need to allocate a new port for the current
       		     * VP (else clause).
       		     */
     - 		    cma__free_mem ((cma_t_address)vptr);
       		    }
       		else {
       		    kern_return_t	status;
       		    port_t		synch_port;
       		    task_t		task;
     --- 386,405 ----
       	    while (qptr != &cma___g_vp_queue) {
       		cma__t_vpid	vptr = (cma__t_vpid)qptr;
       		cma__t_queue	*qnext = cma__queue_next (qptr);
       
       
     ! 		if (vptr != myvp) {
     ! 		    cma___del_vpid (qptr);
       		    /*
       		     * FIX-ME
       		     *
       		     * Need to determine whether ports are copied to a forked
       		     * task... if so, we need to port_deallocate() here, and
       		     * we don't need to allocate a new port for the current
       		     * VP (else clause).
       		     */
       		    }
       		else {
       		    kern_return_t	status;
       		    port_t		synch_port;
       		    task_t		task;
     ***************
     *** 347,357 ****
       		    self = thread_self ();
       		    status = port_allocate (task, &synch_port);
       
       		    cma__trace ((
       			    cma__c_trc_init | cma__c_trc_vp,
     ! 			    "(reinit_vp) running in vp %d, synch port is %d",
       			    self,
       			    synch_port));
       
       		    if (status != KERN_SUCCESS) {
       			cma__trace ((
     --- 410,422 ----
       		    self = thread_self ();
       		    status = port_allocate (task, &synch_port);
       
       		    cma__trace ((
       			    cma__c_trc_init | cma__c_trc_vp,
     ! 			    "(reinit_vp) running in thread %x, vpid %x, vp %d, synch is %d",
     ! 			    cur_tcb,
     ! 			    myvp,
       			    self,
       			    synch_port));
       
       		    if (status != KERN_SUCCESS) {
       			cma__trace ((
     ***************
     *** 399,416 ****
       	    while (qptr != &cma___g_vp_cache) {
       		cma__t_vpid	vptr = (cma__t_vpid)qptr;
       		cma__t_queue	*qnext = cma__queue_next (qptr);
       
       
     ! 		cma__queue_remove (qptr);
     ! 		/*
     ! 		 * FIX-ME
     ! 		 *
     ! 		 * Need to determine whether ports are copied to a forked
     ! 		 * task... if so, we need to port_deallocate() here.
     ! 		 */
     ! 		cma__free_mem ((cma_t_address)vptr);
       		qptr = qnext;
       		}
       
       	    cma__spinunlock (&cma___g_vp_lock);
       	    break;
     --- 464,475 ----
       	    while (qptr != &cma___g_vp_cache) {
       		cma__t_vpid	vptr = (cma__t_vpid)qptr;
       		cma__t_queue	*qnext = cma__queue_next (qptr);
       
       
     ! 		cma___del_vpid (qptr);
     ! 
       		qptr = qnext;
       		}
       
       	    cma__spinunlock (&cma___g_vp_lock);
       	    break;

[10/18/93 public]
The reference platform doesn;t support libc_r.a. Canceled.



CR Number                     : 8060
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : 
Short Description             : pthread_cond_timedwait
returns wrong errno when timer expires.
Reported Date                 : 5/25/93
Found in Baseline             : 1.0.2
Found Date                    : 5/25/93
Severity                      : B
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/25/93 public]
pthread_cond_timed_wait returns EWOULDBLOCK when the timer expires rather
that EAGAIN as documented.

[8/17/93 public]
corrected short description; correct function name is 
pthread_cond_timedwait.

After searching all the files in src/threads and comparing all revisions
of cma_pthread.c (where pthread_cond_timedwait lives), I could not find 
the string EWOULDBLOCK. The pertinent code section is:


    TRY {

        if (cma_cond_timed_wait (cond, mutex, &time) == cma_s_timed_out) {
            cma__set_errno (EAGAIN);
            status = -1;
            }

        }
    CATCH (cma_e_alerted) {
        /*
         * This exception is used to implement pthread_cancel; as such, the
         * exception must be allowed to propagate out of the wait call so
         * that the cleanup handlers can catch it, and eventually the thread
         * will terminate.
         */
        RERAISE;
        }
    CATCH_ALL {
        cma__set_errno (EINVAL);
        status = -1;
        }
    ENDTRY

    return status;
    }

... and ...

lobster 537 %  bdiff -r1.1.4.6 -r1.1 cma_pthread.c | grep EWOULD

 [ ./threads/cma_pthread.c ]
===================================================================
RCS file: ./threads/cma_pthread.c,v
retrieving revision 1.1.4.6
retrieving revision 1.1
diff -r1.1.4.6 -r1.1
lobster 538 %



CR Number                     : 7926
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : stubbase.h can't include <dce/pthread_exc.h>
Reported Date                 : 5/3/93
Found in Baseline             : 1.0.2
Found Date                    : 5/3/93
Severity                      : B
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : src/rpc/sys_idl/stubbase.h src/rc_files/shared
Sensitivity                   : public

[5/3/93 public]

At 1.0.2, the installed location of pthread_exc.h was changed from
/share/include/dce to /share/include. However, stubbase.h has not been
changed to reflect this change and still includes <dce/pthread_exc.h>.
Thus, without the compatibility links created by dce_config the compilation
of the IDL generated stubs will fail. Since the compatibility link
($DCELOCAL/share/include/dce/pthread_exc.h ->
$DCELOCAL/share/include/pthread_exc.h) is for the existing codes, not for a
new code, stubbase.h should be changed to include <pthread_exc.h>.

Also, when this change will take effect, the INCDIRS env. in
rc_files/shared must be changed to

  replace setenv INCDIRS "-I${export_base}/usr/include -I${export_base}/usr/include/dce"

so that stubbase.h can find pthread_exc.h under ODE where pthread_exc.h is
exported to ${export_base}/usr/include/dce instead of
${export_base}/usr/include. Note: You don't want to export it to
${export_base}/usr/include because A LOT of DCE internal codes are
expecting it in the dce directory.

[06/16/93 public]
As soon as we decide where pthread_exc.h should reside I'll take care of 
this bug or reassign it to dave weisman. I believe there are other includes
of dce/pthread_exc.h in addition to the one in stubbase.h that are
affected.

[9/7/93]
pthread_exc.h will stay in the dce subdirectory so the #include in stubbase.h
is correct.



CR Number                     : 7708
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : style_gd
Short Description             : thread-safe RPC clients
Reported Date                 : 4/13/93
Found in Baseline             : 1.0.2
Found Date                    : 4/13/93
Severity                      : C
Priority                      : 2
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/13/93 public]

This note is from the FAQ.  I think it would be appropriate for
the Application Style Guide.  If not, then the App Dev Gd.


From: weisman
To: melman
Subject: THR: Thread-safety in RPC clients 
Date: Mon, 21 Dec 92 17:51:14 -0500


"Thread-safe" is a somewhat catchall term.  The important
concepts are:

- Blocking I/O should block just the thread, not the entire
  process.

- Routines which operate on shared objects should have
  appropriate reentrancy and locking in place.  Example: malloc.

In your application, you have a logically single-threaded client
application.  DCE will not surreptitiously invoke multiple
instances of your application; therefore your *application*code*
does not have to be particularly reentrant.

But DCE will spawn multiple internal threads for its own
purposes.  So the *process* is multithreaded, and therefore your
application must be built with DCE threads wrappers.  These
wrappers manage both blocking I/O and reentrancy of libc
routines.

Blocking I/O problem example:

- You execute an *unwrapped* blocking I/O call such as a read()
  from the keyboard.

- The read sleeps indefinitely.  All threads in the process are
  incorrectly blocked.

- A timer thread inside RPC which normally manages the RPC
  protocol is blocked, and eventually the remote side times the
  connection out.  If context handles were in use the application
  would lose its context.

Reentrancy problem example:

- An application is compiled *without* threads wrappers.

- The application invokes malloc.

- DCE threads interrupts the malloc with a virtual timer.  The
  interrupt handler executes a *properly-wrapped* malloc.  That
  wrapped malloc examines a lock and incorrectly infers that
  nobody else is currently doing a malloc.

- Que lastima.

Important disclaimer:

The DCE threads wrappers support only a subset of libc.  Before
using any potentially blocking or nonreentrant library routines,
you should first check to ensure that there are wrappers
available.

Everything described above is somewhat the worst-case scenario.
DCE vendors may make this a much better implementation by: 1)
shipping reentrant libraries (like libc_r), 2) using native
kernel threads packages to avoid any blocking problems.

Hope this helps clear up a DCE frequently-asked-question.

Dave

>
>Hi,
>
>	The question is:
>
>	If a client application is single-threaded but is using the 
>RPC mechanism (which relies on threads) to make (but not receive) 
>remote calls, does the application code need to be thread-safe?
>
>	The answer is YES, it does, and here is why:
>
>1. The application must use the thread-safe versions of any other
>   runtime libraries, such as libc, because those library functions
>   may be called by the multithreaded RPS runtime code.
>
>2. If the application makes any blocking call, then it will block
>   the RPC library, which is not expecting to be blocked.  This can
>   cause timeouts and break the RPC protocol.
>

[04/13/93 public]
There is another class of things to worry about:  those common C routines
that cannot be 'thread-safe' because of their API.  For example,
things like gethostbyname() which return pointer to private static data.

[04/13/93 public]

I may be wrong about this, but it does not seem like functions which
return pointers to "static data" "cannot" be made reentrant.  It is 
possible to make these functions thread-safe by implementing them
using per-thread context memory.

It is not required by the definition of these functions to return
"static data".  All that is required is that they return a pointer
to data which the function has obtained in some way.

[4/13/93 public]

All of this discussion is also very applicable to people porting DCE.

Since our customers will need to think about these issues when productizing
DCE, we may want to have a cross reference to this topic in the Porting
Guide.

[4/13/93 public]
In my discussions with various people it has become apparent that there
seems to be a lot of confusion about what thread-safe means and how to 
get there. This is true even of people who have read our documentation. I've
recently talked to Doug Weir about addressing the problem and we both agree
that a fairly in depth discussion of the concepts is called for in the
app dev guide. I don't know if he opened an ot to this affect. If not
this one will do, if he has this is a dup of it. I'll check with him. The
above FAQ is a good starting point but probably needs to be expanded.
I've already agreed to work with Doug on but if  he isn't the doc person
doing the work I'll work with whoever is.

[6/9/93 public]

Assigned to new owner of Appl Style Guide

[6/22/93 public]
Changed "Fix By Baseline" from 1.0.3 to 1.1.

[3/29/94 public]

Temporarily reassigned this CR to Doug Weir (OSF threads
and porting guide writer) until new owner of Style Guide
is determined.

[10/26/94 public]
Cancelled, because the new discussion of Thread safety in Chapter
2 of the Application Style Guide incorporates and supersedes the
material here.



CR Number                     : 7565
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : app_ref
Short Description             : RELATED INFO refs missing 3thr
Reported Date                 : 3/23/93
Found in Baseline             : 1.0.2
Found Date                    : 3/23/93
Severity                      : D
Priority                      : 3
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/23/93 public]
Several of the 3thr man pages (pthread_cont_init, pthread_condattr_create,
pthread_condattr_delete, pthread_exit, pthread_join, pthread_keycreate,
etc.  This list is not exhaustive!) have RELATED INFORMATION sections that
refer to other man pages, but the names of the other man pages don't
include the "(3thr)".  I assume that they should since most other man pages
do.

[5/27/93 public]
Assigned to myself.

[5/27/93 public]
All of the 3thr reference pages (including those specifically mentioned 
in this CR) appear to currently have the correct (3thr) indicators in
their RELATED INFORMATION sections.  Magically fixed!  Or possibly,
this bug was filed against an older version of the doc?  In any case,
I'm going to cancel this CR.



CR Number                     : 7316
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : mx300
S/W Ref Platform              : sinix
Component Name                : thr
Subcomponent Name             : 
Short Description             : probable parse error in cma_px.h
Reported Date                 : 2/22/93
Found in Baseline             : 1.0.2
Found Date                    : 2/22/93
Severity                      : A
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : src/threads/cma_px.h
Sensitivity                   : public

[2/22/93 public]
Looking through cma_px.h I found the following:

/*
 * CONSTANTS AND MACROS
 */

#if (!_CMA_REENTRANT_CLIB_) || (_CMA_UNIX_TYPE ==  _CMA__SVR4)
   #if (_CMA_UNIX_TYPE ==  _CMA__SVR4)
     #if !defined(_REENTRANT_LIBC_) && !defined(_REENTRANT_RTLD_) && \
         !defined(_REENTRANT_MALLOC_)!defined(__REENTRANT_EXIT_) && \
         !defined(_REENTRANT_STDIO_) && !defined(_REENTRANT_LIBGEN_) && \
         !defined(_REENTRANT_LIBM_) && !defined(_REENTRANT_NSL_) && \
         !defined(_REENTRANT_LIBNSL_) && !defined(_REENTRANT_LIBSOCKET_) &&\
          !defined(_REENTRANT_LIBRESOLV_) && !defined(_REENTRANT_TCPIP_)
            #define sigaction cma_sigaction
      #endif
   #else
# ifndef _CMA_NOWRAPPERS_
#  if !_CMA_THREAD_IS_VP_
#   define sigaction cma_sigaction   
#  endif
# endif
   #endif  /*_CMA__SVR4 */
#endif

In addition to the indentation style chosen bein unreadable, the line with
_REENTRANT_MALLOC seems to be in error.  There needs to be an && between
the two conditions tested for on that line.  Also I would bet that the
second conditional on that line has one too many leading underscores (i.e.,
it should be _REENTRANT_EXIT_ and not __REENTRANT_EXIT_).  Also couldn't the
conditionals have been broken up a little better so that OS == SVR4 isn't
tested for on both the first and second lines.

[Fri Jul 16 12:48:35 EDT 1993 public]

This file has been changed.  Hopefully the indentation style is
more readable and all typos have been fixed.

Since this is not assigned to me anymore, I am not going to change the
state.  If it is not agreed that this has been fixed, please post more
information about what other problems should be fixed.

[8/9/93 public]
Inspection of the code shows this was fixed as part of the merge by hinman@sni
(file cma_px.h, rev. 1.1.7.2).



CR Number                     : 7214
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : idl marshalling code
Short Description             : a client may be able to crash a server
in its marshalling code by passing bogus parameters
Reported Date                 : 2/12/93
Found in Baseline             : 1.0.2
Found Date                    : 2/12/93
Severity                      : C
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/12/93 public]
This problem was found during early testing of security replication.
The master security server propagated an account replace (rs_prop_acct_replace)
that contained a pointer to a null rs_acct_key_transmit_t (instead
of the correct null pointer) which crashed the slave in marshalling code.
This example can be reproduced by using:
    security/server/rs/rs_log_acct.c, revision 1.1.4.6
Rebuild this file, librs.a, and secd.  Configure a master and slave.
Use rgy_edit to change some fields of an account without changing
the password.

[3/1/93 public]
This problem is sufficiently complex that it cannot be fixed in 
the 1.0.2 timeframe.   Changed to "fix in 1.0.3."

[3/1/93 public]
Because this problem can be resolved by not passing bogus parameters, 
the severity is being changed and we will address this in the next release.

[3/4/93 public]
When assigning severity, please don't miss the fact that this problem
may make any server vulnerable to a denial of service attack.

[08/03/93 public]
For 1.0.3 there has been a redesign of the idl backend.  This
may not be a problem anymore, but this should be verified.
Tony Hinxman is probably the person who would know...

[08/18/93 public]
This is really the old raise an exception or core dump on syncronous 
terminating signal argument. For 1.0.1 and earlier the default behavior
for such a signal was to raise an exception. For 1.0.2 this was changed to
force a core dump. I emphasize the word default. If a server writer,
for any reason, believes the correct behavior for the server is to raise
an exception the server may be written to do so. Establish the signal
handler with sigaction, it can be on a per thread basis, and supply a 
handler similar to....

sigsegv_handler(int sig,int  siginfo, struct sigcontext *scp)
{
   RAISE(exc_e_illaddr);
}

For 1.1 there is a proposal to have the behavior depend on a setting in 
the acf file. An enhancement request is being filed to implement this
in the 1.1 timeframe. The above description is a work around for the 
problem, as  stated in this ot, during the 1.0.3 timeframe.



CR Number                     : 4853
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 4444
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : cuvb_wrp_002
Short Description             : fflush((FILE *)0) does not work on all systems
Reported Date                 : 7/27/92
Found in Baseline             : 1.0.1
Found Date                    : 7/27/92
Severity                      : C
Priority                      : 1
Status                        : cancel
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/27/92 public]

        OT 4444 was fixed by adding a check for __STDC__. But __STDC__ does
        not guarantee the working of fflush((FILE *)0). I am using gcc on
        a Sun Sparc, which does not support fflush(0), even though __STDC__
        is defined with gcc.

Proposed Solution:

        I guess we have to find out which system C libs support this fflush
        feature, and which don't.

[10/5/93 public]
This is a functional test porting issue for a platform which is not 
supported. fflush() is a POSIX - defined function.

[10/6/93 public]
The rationale given above was incorrect. The problem is that flushing 
all streams with fflush does not work on the Sun platform. Removing the 
#ifdef __STDC__ and forcing the call fflush((FILE *)0) in the test 
cuvb_wrp_002 works on the OSF/1 and HP/UX reference platforms. This 
behavior is documented in the man pages for the respective systems. If 
this were considered a defect, it would be a code defect, not a test 
defect.



