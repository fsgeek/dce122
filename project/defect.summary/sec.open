CR Number                     : 13696
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : Can't create global group when using DNS
Reported Date                 : 1/10/97
Found in Baseline             : 1.2.2
Found Date                    : 1/10/97
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : provider
Diff release                  : 1.2.2
Sensitivity                   : public

[1/10/97 public]

It was discovered that if cells were connected via DNS (ie. the "right"
way), attempting to add a foreign member to a local group returns "Registry
server unavailable".

On startup secd disables the security binding code's ability to use the NSI
for binding (it relies on the pe_site file only). In general, this is
desired behavior, but in the case of Global Groups, secd needs to
sec_id_parse_name() the FQ foreign principal. Without the NSI, secd cannot
contact the remote security server.

The change was to enable secd's use of the NSI during the
sec_id_parse_name() call in rs_pgo_add_member().

This change required locking and a global refcount to prevent multiple
threads doing rs_pgo_add_member()'s from stepping on each other or leaving
the NSI enabled when they were done.

Note that the mutex locking for the NSI state changes do not prevent
other executor threads from using the NSI to do binding. The mutex
locking is to prevent leaving the NSI enabled after all the threads
that need it are done. Doing otherwise would incur a significant
performance hit.

Another issue arose in that a malicious user could tie up all of secd's
call threads by repeatedly adding a foreign principal from a
known-unavailable cell to a local group. The solution to this problem was
to create a seperate thread pool to service only the rs_pgo_add_member
operations. 

Diffs follow:

Files changed:
src/security/h/rs_lock.h
src/security/h/rs_ns.h
src/security/idl/sec.sams
src/security/server/rs/rs_lock.c
src/security/server/rs/rs_main.c
src/security/server/rs/rs_misc.c
src/security/server/rs/rs_ns.c
src/security/server/rs/rs_pgo.c

*** rs_lock.h@@/main/jrr_122_8/0        Mon Dec  2 13:25:38 1996
--- rs_lock.h   Tue Dec  3 12:32:10 1996
***************
*** 82,88 ****
  
  typedef enum lock_type_t {
          lock_db, lock_replist, lock_log, lock_kdc, lock_master_info,
!       lock_login_info
  } lock_type_t;
  
  typedef enum lock_mode_t {
--- 82,88 ----
  
  typedef enum lock_type_t {
          lock_db, lock_replist, lock_log, lock_kdc, lock_master_info,
!       lock_login_info, lock_nsi_access
  } lock_type_t;
  
  typedef enum lock_mode_t {





*** rs_ns.h@@/main/jrr_122_8/0  Mon Dec  2 13:06:00 1996
--- rs_ns.h     Mon Jan  6 16:48:52 1997
***************
*** 60,66 ****
--- 60,107 ----
  
  #include <dce/nbase.h>
  #include <dce/rgynbase.h>
+ #include <rs_lock.h>
  
+ /*
+  * Global reference count for NSI state IN SECD. This is for the security
+  * server's use only. By default the state is on (>0), but this will be
+  * changed on secd startup in rs_login.c:rs_login_pvt_setup_context()
+  */
+ extern signed32 rs_ns_use_nsi_refcount;
+ 
+ /*
+  * Turn on the ability use the NSI for security server binding in a 
+  * thread safe way.
+  */
+ #define RS_NS_ENABLE_NSI \
+     { \
+         lock_type_t  rs_ns_nsi_lock = lock_nsi_access; \
+         lock(rs_ns_nsi_lock, lock_mode_write); \
+         rs_ns_use_nsi_refcount++; \
+         if (rs_ns_use_nsi_refcount == 1) \
+             sec_rgy_enable_nsi(true); \
+         unlock(rs_ns_nsi_lock, lock_mode_write); \
+         TRY {
+ 
+ #define RS_NS_NSI_DONE \
+         } CATCH(pthread_cancel_e) { \
+             lock(rs_ns_nsi_lock, lock_mode_write); \
+             rs_ns_use_nsi_refcount--; \
+             if (rs_ns_use_nsi_refcount > 0) rs_ns_use_nsi_refcount--; \
+                 sec_rgy_enable_nsi(false); \
+             unlock(rs_ns_nsi_lock, lock_mode_write); \
+             RERAISE; \
+         } CATCH_ALL { \
+             dce_svc_printf(SEC_RS_LOCK_FATAL_EXC_MSG, \
+                            mode_string(lock_mode_write), \
+                            type_string(rs_ns_nsi_lock)); \
+         } ENDTRY; \
+         lock(rs_ns_nsi_lock, lock_mode_write); \
+         if (rs_ns_use_nsi_refcount > 0) rs_ns_use_nsi_refcount--; \
+         if (rs_ns_use_nsi_refcount == 0) \
+             sec_rgy_enable_nsi(false); \
+         unlock(rs_ns_nsi_lock, lock_mode_write); \
+     }
  
  PUBLIC void rs_ns_bootstrap_enable (
  #ifdef __STDC__





*** sec.sams@@/main/DCE_1.2.2/jrr_122_8/0       Mon Jan  6 13:30:35 1997
--- sec.sams    Mon Jan  6 13:38:35 1997
***************
*** 5038,5043 ****
--- 5038,5067 ----
  engineer      "Sekhar Vajjhala"
  end
  
+ # Files : rs_main.c
+ start
+ code          sec_rs_thr_pool_create_fail
+ text          "Unable to create thread pool: %d"
+ notes         "%d is a status code."
+ explanation   "The call to rs_misc_init_thread_pool failed."
+ action                "None required."
+ sub-component sec_s_rs_thr
+ attributes    svc_c_sev_fatal
+ engineer      "John Rousseau"
+ end
+ 
+ # Files : rs_misc.c
+ start
+ code          sec_rs_thr_pool_set_fn_fail
+ text          "Unable to set thread pool function: %d"
+ notes         "%d is a status code."
+ explanation   "The call to rpc_server_set_thread_pool_fn failed."
+ action                "None required."
+ sub-component sec_s_rs_thr
+ attributes    svc_c_sev_fatal
+ engineer      "John Rousseau"
+ end
+ 
  #  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  #  %                                                          %
  #  %      Messages logged by sec_create_db                    %





*** rs_lock.c@@/main/jrr_122_8/0	Tue Dec  3 13:17:05 1996
--- rs_lock.c	Tue Dec  3 13:20:47 1996
***************
*** 98,110 ****
  /* master info lock */
  static  lock_pvt_t  login;
  
! #define NUM_LOCKS 6
  static  lock_pvt_t  *known_locks[NUM_LOCKS] = { &db,
                                                  &replist,
                                                  &log,
                                                  &kdc,
                                                  &master_info,
!                                                 &login
                                                };
  
  static  char   *lock_debug_info[NUM_LOCKS] = { "database lock",
--- 98,114 ----
  /* master info lock */
  static  lock_pvt_t  login;
  
! /* NSI access lock */
! static  lock_pvt_t  nsi_access;
! 
! #define NUM_LOCKS 7
  static  lock_pvt_t  *known_locks[NUM_LOCKS] = { &db,
                                                  &replist,
                                                  &log,
                                                  &kdc,
                                                  &master_info,
!                                                 &login,
!                                                 &nsi_access
                                                };
  
  static  char   *lock_debug_info[NUM_LOCKS] = { "database lock",
***************
*** 112,118 ****
                                                 "log lock",
                                                 "KDC lock",
                                                 "master info lock",
!                                                "login info lock"
                                               };
  
  PRIVATE print_lock_info
--- 116,123 ----
                                                 "log lock",
                                                 "KDC lock",
                                                 "master info lock",
!                                                "login info lock",
!                                                "NSI access lock"
                                               };
  
  PRIVATE print_lock_info
***************
*** 135,146 ****
          sprintf(buf, "%s: db\n", type);
      } else if (lock_p == &log) {
          sprintf(buf, "%s: log\n", type);
!      } else if (lock_p == &kdc) {
          sprintf(buf, "%s: kdc\n", type);
!      } else if (lock_p == &master_info) {
          sprintf(buf, "%s: master_info\n", type);
!      } else if (lock_p == &login) {
          sprintf(buf, "%s: login_info\n", type);
      } else {
          sprintf(buf, "%s: <unknown lock>\n", type);
      }
--- 140,153 ----
          sprintf(buf, "%s: db\n", type);
      } else if (lock_p == &log) {
          sprintf(buf, "%s: log\n", type);
!     } else if (lock_p == &kdc) {
          sprintf(buf, "%s: kdc\n", type);
!     } else if (lock_p == &master_info) {
          sprintf(buf, "%s: master_info\n", type);
!     } else if (lock_p == &login) {
          sprintf(buf, "%s: login_info\n", type);
+     } else if (lock_p == &nsi_access) {
+         sprintf(buf, "%s: nsi_access\n", type);
      } else {
          sprintf(buf, "%s: <unknown lock>\n", type);
      }
***************
*** 212,217 ****
--- 219,228 ----
          case lock_login_info:
              lock_p = &login;
              break;
+ 
+         case lock_nsi_access:
+             lock_p = &nsi_access;
+             break;
      }
  
      return lock_p;
***************
*** 376,382 ****
  					  "log",
                                            "KDC",
  					  "master info",
! 					  "login info"
  					 };
  
  PUBLIC char *type_string
--- 387,394 ----
  					  "log",
                                            "KDC",
  					  "master info",
! 					  "login info",
!                                           "NSI access"
  					 };
  
  PUBLIC char *type_string





*** rs_main.c@@/main/DCE_1.2.2/jrr_122_8/0      Mon Dec 30 14:18:27 1996
--- rs_main.c   Mon Jan  6 13:37:11 1997
***************
*** 300,305 ****
--- 300,306 ----
  #include <rs_task.h>
  #include <rs_log.h>
  #include <rs_util.h>
+ #include <rs_misc.h>
  #include <rs_audit_trail.h>
  #include <rs_rep_mgmt.h>
  #include <rs_rep_auth.h>
***************
*** 335,340 ****
--- 336,344 ----
  #define _SEC_AUDIT_FILTER_ENV "DCEAUDITFILTERON=1"
  #endif        /* defined(DCE_AUD_POINTS) */
  
+ /* Number of threads to create in the alternate thread pool. */
+ #define RS_NUM_POOL_THREADS 2
+ 
  /*
   * Prototypes for local routines
   */
***************
*** 377,382 ****
--- 381,389 ----
  
  extern boolean32  priv_debug;
  
+ /* Handle to the 'dangerous' thread pool. Defined in rs_misc.c */
+ extern rpc_thread_pool_handle_t rs_thread_pool_h;
+ 
  PUBLIC boolean32             rs_verbose     = false;
  PUBLIC boolean32             rs_prop_debug  = false;
  
***************
*** 642,647 ****
--- 649,667 ----
          }
  
  
+         /*
+          * Initialize an additional thread pool for servicing operations
+          * that may potentially block for an extended period of time.
+          */
+         rs_thread_pool_h = rs_misc_init_thread_pool(RS_NUM_POOL_THREADS,
+                                                     &status);
+         if (BAD_STATUS(&status)) {
+             dce_svc_printf(DCE_SVC(sec_svc_handle, ""),
+                            sec_s_rs_main,
+                            svc_c_sev_fatal | svc_c_action_exit_bad,
+                            sec_rs_thr_pool_create_fail, status);
+         }
+             
          /*
           * Start the listener tasks
           * rs_login_become_rgy will make call to secd





*** rs_misc.c@@/main/jrr_122_8/0	Thu Dec 19 13:11:18 1996
--- rs_misc.c	Mon Jan  6 16:23:49 1997
***************
*** 119,124 ****
--- 119,125 ----
  #include <rs_util.h>
  #include <rs_auth.h>
  #include <rs_secidmap.h>
+ #include <rs_pgo.h>
  #include <rsdb_acct.h>
  #include <rsdb_pgo.h>
  #include <rsdb_acl.h>
***************
*** 425,428 ****
--- 426,583 ----
  	rsdb_checkpt_reset_interval(do_checkpt_now, new_checkpt_interval, 
  		at_time_str, status);
      }
+ }
+ 
+ 
+ /* 
+  * The following functions and data structures are to manage an additional 
+  * threads pool for 'dangerous' operations. Stolen from the DFS thread pool
+  * work.
+  */ 
+ 
+ /* 
+  * Some constants
+  */
+ #define RS_THREAD_POOL_ENTRIES 1
+ 
+ /* The global list of operations to select for the pool */
+ typedef struct {
+     rpc_if_handle_t  *ifspec;              /* the exported interface */
+     rpc_if_id_t      *ifspec_id;           /* the exported interface ID */
+     unsigned32       op_num;               /* the operation number */
+ } pool_table_entry;
+ 
+ /* The operations to put into the pool. One entry per interface-operation pair. */
+ PRIVATE pool_table_entry pool_table[RS_THREAD_POOL_ENTRIES] = {
+     {&rs_pgo_v1_0_s_ifspec, NULL, 6}  /* rs_pgo_add_member */
+ };
+ 
+ /* Handle to the thread pool. Set during startup in rgy_main(). */
+ rpc_thread_pool_handle_t rs_thread_pool_h = NULL;
+ static pthread_mutex_t rs_thread_pool_mutex;   /* mutex lock for pool table */
+ static unsigned32 rs_g_thread_pool_inited = 0; /* init flag */
+ 
+ 
+ /*
+  * The callback to locate a reserved thread-pool if the rpc call is 
+  * considered 'dangerous'. 
+  */
+ static void
+ rs_misc_lookup_pool(uuid_t *object_uuid,
+                     rpc_if_id_t *interface_id, 
+                     unsigned32 op_num,
+                     rpc_thread_pool_handle_t *pool_h,
+                     unsigned32 *st)
+ {
+     rpc_if_id_t         ifspec_id;
+     unsigned32          i;
+ 
+     CLEAR_STATUS(st);
+ 
+     *pool_h = NULL;
+ 
+     if (op_num == 0)
+         return;
+ 
+    /* 
+     * Check whether the call is from an appropriate ifspec,
+     * Check whether the call is with the appropriate operation number. 
+     * (ie., from the set of interfaces we consider 'dangerous'.)
+     */
+     pthread_mutex_lock(&rs_thread_pool_mutex);
+     for (i = 0; (i < RS_THREAD_POOL_ENTRIES); i++)  {
+         if (op_num == pool_table[i].op_num) {
+             if (uuid_equal(&interface_id->uuid, 
+                            &(*(pool_table[i].ifspec_id)).uuid, st)) {
+ 		*pool_h = rs_thread_pool_h;
+                 DCE_SVC_DEBUG((sec_svc_handle, sec_s_rs_thr, svc_c_debug1,
+                                "Got interface/opnum match, pooling RPC.\n"));
+                 break;
+             }
+ 	}
+     } 
+     pthread_mutex_unlock(&rs_thread_pool_mutex);
+     return;
+ }
+ 
+ 
+ /* 
+  * Create an additional pool of threads for 'dangerous' operations.
+  * These are operations that could block for an extended period of time.
+  * Currently this is just for the rs_pgo_add_member operation because
+  * it can go remote to a security server in a foreign cell.
+  * Update pool_table above (and RS_THREAD_POOL_ENTRIES) to select more 
+  * interface-operation pairs for the pool.
+  * 
+  * This function should only be called at server startup time.
+  */
+ rpc_thread_pool_handle_t
+ rs_misc_init_thread_pool(unsigned32 num_threads,
+                          error_status_t *st)
+ {
+     rpc_thread_pool_handle_t    pool_p;
+     unsigned32                  i;
+     rpc_if_id_t                 *ifspec_id;
+     boolean32                   wait_flag = 1;
+     static unsigned32           lookup_fn_set = 0;
+ 
+     CLEAR_STATUS(st);
+ 
+     if (rs_g_thread_pool_inited)
+         return;
+ 
+     pthread_mutex_init(&rs_thread_pool_mutex, pthread_mutexattr_default);
+ 
+     rpc_server_create_thread_pool(num_threads, &pool_p, st);
+     if (BAD_STATUS(st)) {
+         return NULL;
+     }
+ 
+     /* Populate the the table with the interface uuids */
+     for (i = 0; i < RS_THREAD_POOL_ENTRIES; i++) {
+         ifspec_id = (rpc_if_id_t *)malloc(sizeof(rpc_if_id_t));
+         if (ifspec_id == NULL) 
+             dce_svc_printf(DCE_SVC(sec_svc_handle, ""),
+                            sec_s_rs_main,
+                            svc_c_sev_fatal | svc_c_action_exit_bad,
+                            sec_rgy_cant_allocate_memory);
+             
+         rpc_if_inq_id(*(pool_table[i].ifspec), ifspec_id, st);
+ 
+         if (BAD_STATUS(st)) {
+             free(ifspec_id);
+             goto fail;
+         }
+ 
+         pool_table[i].ifspec_id = ifspec_id;
+ 
+         {
+             unsigned_char_t *_tmp = NULL;
+ 
+             uuid_to_string(&ifspec_id->uuid, &_tmp, st);
+             DCE_SVC_DEBUG((sec_svc_handle, sec_s_rs_thr, svc_c_debug1,
+                            "Initializing pool_table[%d] with op_num = %d, if uuid = %s\n", i, pool_table[i].op_num, _tmp));
+         }
+     }
+ 
+ 
+     if (!lookup_fn_set) {
+         rpc_server_set_thread_pool_fn((rpc_thread_pool_fn_t )rs_misc_lookup_pool, 
+                                       st);
+         if (BAD_STATUS(st)) {
+             dce_svc_printf(DCE_SVC(sec_svc_handle, ""),
+                            sec_s_rs_main,
+                            svc_c_sev_fatal | svc_c_action_exit_bad,
+                            sec_rs_thr_pool_set_fn_fail, *st);
+             goto fail;
+         }
+         lookup_fn_set = 1;
+     }
+ 
+     rs_g_thread_pool_inited = 1;
+     return pool_p;
+ 
+ fail:
+     rpc_server_free_thread_pool(&pool_p, wait_flag, st);
+     return NULL;
  }





*** rs_ns.c@@/main/jrr_122_8/0  Fri Jan  3 16:42:46 1997
--- rs_ns.c     Mon Jan  6 16:07:41 1997
***************
*** 247,252 ****
--- 247,258 ----
  static unsigned_char_p_t   rs_ns_server_name = NULL;
  
  /*
+  * Global reference count for NSI state IN SECD. This is for the security
+  * server's use only.
+  */
+ signed32 rs_ns_use_nsi_refcount = 0;
+ 
+ /*
   * Attribute name (ie. Object ID) in ns of rep_id attribute 
   */
  #define rs_ns_c_attrib_rep_id   ((unsigned_char_p_t) "1.3.22.1.5.1")





*** rs_pgo.c@@/main/DCE_1.2.2/jrr_122_8/0       Mon Nov 25 11:30:55 1996
--- rs_pgo.c    Fri Jan  3 16:51:07 1997
***************
*** 183,188 ****
--- 183,189 ----
  #include <rs_ch_lock.h>
  #include <rs_ver.h>
  #include <rs_ver_pvt.h>
+ #include <rs_ns.h>
  #include <rsdb_pgo.h>
  #include <rsdb_name_util.h>
  #include <rsdb_util.h>
***************
*** 1571,1578 ****
            }
  
            if ( STATUS_OK(status) ) {
!               sec_id_parse_name(NULL, person_name,
!                    cell_name, &cell_uuid, princ_name, &princ_uuid, status);
                member_cell_uuid_p = &cell_uuid;
                member_princ_uuid_p = &princ_uuid;
            }
--- 1572,1594 ----
            }
  
            if ( STATUS_OK(status) ) {
!                 /* 
!                  * Flip the big switch in the security binding code so
!                  * that the NSI is used for binding. Otherwise, we can 
!                  * not find the remote cell when using a global name
!                  * service, and the sec_id_parse_name() will return
!                  * "Registry server unavailable". Restore the state
!                  * when we are done.
!                  */
!                 RS_NS_ENABLE_NSI {
!                     sec_id_parse_name(NULL, 
!                                       person_name,
!                                       cell_name, 
!                                       &cell_uuid, princ_name,
!                                       &princ_uuid,
!                                       status);
!                 } RS_NS_NSI_DONE;
! 
                member_cell_uuid_p = &cell_uuid;
                member_princ_uuid_p = &princ_uuid;
            }


[domian   1/17/97  public]

NOTE: The diff offered above ("jrr 1/10/97 public"] has been tested and
proven to solve a portion of the associated problem.  However, a recent
review of the diff uncovered a flaw.
The following is a recommended total solution to this OT.  Note that due
to the GA-schedule, it was not implemented and tested.  It is offered here
as an unsupported solution.
---------------------------

"John" == John Rousseau <jrr@apollo.hp.com> writes:

    On Monday, 6 Jan 1997 16:59:32 -0500 John Rousseau from HP wrote
regarding the latest Global Groups design change:

John> Here are the latest set of changes to help secd use the NSI in a
John> thread-safe, denial-of-service-attack resistant and environmentally
John> friendly way.

    HP's latest GG design change is NOT "denial-of-service-attack
resistant".  When one or more threads in the secd process executes the
rs_pgo_add_member(), it will turn on the global variable to allow NSI
lookups to be done ... the other threads in the secd process will now be
forced to use the NSI lookup (incurring additional performance
penalties) AND allowing a "denial-of-service-attack" (which the
original design intentionally avoided) until ALL of the threads which
are executing the rs_pgo_add_member() are finished and turn off the
global variable.

    On Wednesday, 15 Jan 1997 14:46:20 -0500 John Rousseau from HP wrote:

John>                            Having secd use the NSI for binding is
John> not a bad thing. I agree that having unpredictable binding semantics
John> is not ideal, but there is no other choice at this point. 

    John Rousseau agrees that the latest GG design does have this
"window", but HP will NOT be addressing this design flaw.

    This "window" of "denial-of-service-attack" can easily be
eliminated.  I would like to propose these changes to the GG design,
which would allow a thread specific value for each thread to determine
if the NSI lookups should be done:

    1) Another global variable should be created in
       src/security/client/rca/internal_binding.c preferrably
       near the rca_use_nsi (since it expands it's meaning) 
            boolean32 rca_check_pthread_specific = false;

       Secd would enable the global variable
            rca_check_pthread_specific = true;

    2) A thread specific key should be created in secd initialization
            pthread_keycreate(&rca_use_nsi_key, NULL);

    3) In the RS_NS_ENABLE_NSI Macro, set the thread specific to true at the
       beginning and when completed turn to false
            pthread_setspecific(rca_use_nsi_key, true);
            .
            .
            .   
            pthread_setspecific(rca_use_nsi_key, false);
        
    4) In the rca_nsi_binding_import() function, wherever rca_use_nsi
       is used change it to
            rca_use_nsi && ((rca_check_pthread_specific &&
                             (0 == pthread_getspecific(rca_use_nsi_key, &rca_use_nsi_in_thread)) &&
                             rca_use_nsi_in_thread)  ||
                            !rca_check_pthread_specific)

    With these changes ONLY the threads that are executing the rs_pgo_add_member
will be doing the NSI lookups, all the other threads will not be effected.


--
William E. Hannon Jr.                         internet:whannon@austin.ibm.com
AIX/DCE Technical Lead                                         whannon@austin
Austin, Texas 78758     Department ATKS/9132     Phone:(512)838-3238 T/L(678)
'Confidence is what you had, before you understood the situation.' Dr. Dobson



CR Number                     : 13695
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : security tests
Short Description             : Must have authz tests for secd and DCE ACL lib
Reported Date                 : 1/8/97
Found in Baseline             : 1.1
Found Date                    : 1/8/97
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/8/97 public]

There's not enough ACL/authorization testing going on.  An error case
in secd's sec_acl_mgr_get_access() and a couple similar cases in
the DCE ACL library have gone unnoticed (by tests and multiple reviewers
from multiple companies) for a couple of years.  This is not an area
where DCE can afford to have bugs (theoretically, no part should have bugs,
but this ranks up there in the worst places for a bug).

There must be tests written to test the authorization checks (normal
and delegate) of secd and the DCE ACL lib, in the next release of DCE!



CR Number                     : 13694
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd, libdce ACL eval
Short Description             : acl evaluation wrong for delegated privs
Reported Date                 : 1/7/97
Found in Baseline             : 1.2.1
Found Date                    : 1/7/97
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/server/rsdb/rsdb_daclmgr.c, utils/acldb/acleval.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/7/97 public]

A support customer reported the following problem.

Code inspection revealed:
DCE 1.1 maint  - dce_acl_inq_permset_for_creds has fixed the *st pointer
	         problem.
DCE 1.2.1maint - dce_acl_inq_permset_for_creds still has one place where
		 'st != error_status_ok' instead of *st.
DCE 1.2.2      - dce_acl_inq_permset_for_creds still has one place where
		 'st != error_status_ok' instead of *st.

Otherwise the remaining diffs supplied below can be applied and tested.
=======================================================================

Full Description: 
 The acl evaluation algorithms do not correctly adjust for access rights
 when a delegate ( not the initiator ) specified in an epac chain (creds)
 has no privileges specified in the acl being checked against.

 This is true for the dce api call
   dce_acl_inq_permset_for_creds (src/dce/utils/acldb/acleval.c)
 and the security server acl manager
   sec_acl_mgr_get_access (src/security/server/rsdb/rsdb_daclmgr.c)

 While the first call incorrectly returns because of a failure of
 a check that compares st ( a pointer to status ) versus *st to 
 error_status_ok. Further it does not adjust the permissions
 granted by 'AND'ing the initiator permissions with those of delegates.

 The second (rsdb acl manager) breaks out of the loop if it fails to
 get access for a delegate without adjusting the permissions returned.
 
Repeat By: 
 Create user (initiator) acl entry on an object under /.:/sec
 junction without permission for user delegate. Access this object with
 a delegated login identity.

 Inspect code in dce_acl_inq_permset_for_creds and
 sec_acl_mgr_get_access.

Proposed Solution:
 A context diff for a potential fix included below. 

 
Archive file: \\buckwheat\dce32\dce32_rcs\src/dce/utils/acldb\acleval.c,v
retrieving revision 1.21.1.1
retrieving revision 1.21.1.2
diff -r1.21.1.1 -r1.21.1.2
*** C:/wk/sb/src/dce/utils/acldb/rdif00FC.aaa Fri Dec 13 15:06:38 1996
--- C:/wk/sb/src/dce/utils/acldb/rdif00FC.aab Fri Dec 13 15:06:38 1996
***************
*** 7,13 ****
   * 
   * HISTORY
   * $Log:	c013694,v $
# Revision 1.2  97/01/08  10:36:05  root
# changed fields: Subcomponent Name  Affected File(s)   new/changed/deleted note(s) [burati 1/8/97 public]
# 
# Revision 1.1  97/01/07  21:53:53  root
# new CR
# 
!  * Revision 1.21.1.1  96/07/29 22:00:02  kevin
   * Merge 1.1 changes into 1.2.1 code base
--- 7,15 ----
   * 
   * HISTORY
   * $Log:	c013694,v $
# Revision 1.2  97/01/08  10:36:05  root
# changed fields: Subcomponent Name  Affected File(s)   new/changed/deleted note(s) [burati 1/8/97 public]
# 
# Revision 1.1  97/01/07  21:53:53  root
# new CR
# 
!  * Revision 1.21.1.2  96/12/12 22:23:26  bhandaru
!  * name to cred secd extension plus acl eval bugfixes
!  * Revision 1.21.1.1  1996/07/29 22:00:02  kevin
   * Merge 1.1 changes into 1.2.1 code base
***************
*** 747,752 ****
--- 749,755 ----
      sec_cred_pa_handle_t	cred_pa;
      sec_cred_cursor_t		del_cursor;
      error_status_t		xst;
+     sec_acl_permset_t 		net_rights; /* Gradient Fix */
  
      *st = error_status_ok;
      *perms = dce_acl_c_no_permissions;
***************
*** 769,778 ****
  
      dce_acl__permset_alg(FALSE, pa_p, ap, own_id, grp_id,
  		&unauth_mask, posix_semantics, perms, st);
!     if (st != error_status_ok) {
! 	return;
!     }
  
      /* Now, loop through the delegates, doing the same check. */
      sec_cred_initialize_cursor(&del_cursor, st);
      STAT_CHECK_RET(*st);
--- 772,782 ----
  
      dce_acl__permset_alg(FALSE, pa_p, ap, own_id, grp_id,
  		&unauth_mask, posix_semantics, perms, st);
!     STAT_CHECK_RET(*st); /*Gradient Fix */
!     /* WAS if (st != error_status_ok) { return; } */
  
+     net_rights = *perms;  /*Gradient Fix */
+ 
      /* Now, loop through the delegates, doing the same check. */
      sec_cred_initialize_cursor(&del_cursor, st);
      STAT_CHECK_RET(*st);
***************
*** 781,786 ****
--- 785,791 ----
  	    sec_cred_free_cursor(&del_cursor, &xst);
  	    return;
  	}
+ 
  	cred_pa = sec_cred_get_delegate(cred_h, &del_cursor, st);
  	if (*st == sec_cred_s_no_more_entries) {
  	    *st = error_status_ok;
***************
*** 801,808 ****
--- 806,816 ----
  	    *perms = dce_acl_c_no_permissions;
  	    return;
  	}
+         net_rights = (net_rights & (*perms));  /*Gradient Fix */
      }
      sec_cred_free_cursor(&del_cursor, &xst);
+ 
+     *perms = net_rights;  /*Gradient Fix */
  
      /* If creds were not authenticated then apply the unauth mask perms */
      if (!auth) {




Archive file: \\buckwheat\dce32\dce32_rcs\src/security/server/rsdb\rsdb_daclmgr.c,v
retrieving revision 1.21.1.1
retrieving revision 1.21.1.2
diff -r1.21.1.1 -r1.21.1.2
*** C:/wk/sb/src/security/server/rsdb/rdif0091.aaa Fri Dec 13 15:09:04 1996
--- C:/wk/sb/src/security/server/rsdb/rdif0091.aab Fri Dec 13 15:09:04 1996
***************
*** 1253,1259 ****
  		    &granted, auth, stp);
                  if (GOOD_STATUS(stp) && got_access) {
                      *net_rights = (*net_rights & granted);
!                 }
              }
          }
      } while (GOOD_STATUS(stp) && got_access);
--- 1253,1264 ----
  		    &granted, auth, stp);
                  if (GOOD_STATUS(stp) && got_access) {
                      *net_rights = (*net_rights & granted);
!                 } else {
! 		   /* GRADIENT FIX. If we failed to get access for a delegate
! 	 	    * in the chain, we do not want to grant access at all !
! 		    * - nb */
! 		   if (!got_access) *net_rights = (sec_acl_permset_t)0;
! 		}
              }
          }
      } while (GOOD_STATUS(stp) && got_access);

--=====================_850525987==_
Content-Type: text/plain; charset="us-ascii"



-----------------------------------------------------------
--=====================_850525987==_--

[1/8/97 public]
Good catch (shows how little the tests are really testing :-( ).
I've reviewed the above rsdb_daclmgr.c fix and it looks correct.
I'm not as familiar with the acleval.c code, so I'll have to take a
look at it later today.  

I took a quick look at my original delegate ACL eval code (used by fnc tests)
in src/test/security/svr_example/dacl_manager.c and it doesn't appear to
have this problem.  I'll open a test defect, stating that the authz
checks in the DCE ACL lib and secd need tests written for them,
given that multiple reviewers over 2 years didn't catch the above
problem.



CR Number                     : 13693
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : pkss
Short Description             : pkss database bug with page re-use
Reported Date                 : 1/7/97
Found in Baseline             : 1.2.2
Found Date                    : 1/7/97
Severity                      : A
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : bt_close.c,bt_open.c,bt_trans.c,bt_page.c,btree.h,gdb_db44.c,mpool.h,mpool.c
Diff supplied by              : provider
Diff release                  : 1.2.2
Sensitivity                   : public

[1/7/97 public]
The database code that was submitted as part of PKSS has 
incomplete logic in the area of page re-use that will cause
unpredictable results including database corruption.

There is also an bug in the routine gdb_entry_delete()-- a 
missing call to lock a mutex.  

We are still testing the fixed modules.  Anyone who uses PKSS
will need to pull the fixed sources when they are available.
No component other than PKSS will be affected.

[1/16/1997 public]

The following files are affected:
bt_close.c (diff to follow)
bt_open.c (diff to follow)
bt_page.c (diff to follow)
bt_trans.c (diff to follow)
btree.h (diff to follow)
gdb_db44.c (diff to follow)
mpool.h (diff to follow)
mpool.c (replacement source file to follow)

Keep in mind that all the .o's need to be rebuilt after the
changes are made because of changes in btree.h.

diff dce1.2.2/bt_close.c new/bt_close.c
81c81
< #include "btree.h"
---
> #include <btree.h>
214d213
<          m.free = t->bt_free;

diff dce1.2.2/bt_open.c new/bt_open.c
369d368
<               t->bt_free = m.free;
391d389
<               t->bt_free = P_INVALID;

diff dce1.2.2/bt_page.c new/bt_page.c
96,98c96
<       /* Insert the page at the head of the free list. */
<       h->prevpg = P_INVALID;
<       h->nextpg = t->bt_free;
---
>       status = mpool_put(t->bt_mp, h, (MPOOL_DIRTY|MPOOL_EMPTY));
100,105d97
<       TREE_LOCK(t) {
<          t->bt_free = h->pgno;
<       } TREE_UNLOCK(t);
< 
<       status = mpool_put(t->bt_mp, h, MPOOL_DIRTY);
< 
126,136d117
< 
< 
<       TREE_LOCK(t) {
<          if (t->bt_free != P_INVALID &&
<              (h = mpool_get(t->bt_mp, t->bt_free, 0)) != NULL) {
<             *npg = t->bt_free;
<             t->bt_free = h->nextpg;
<             TREE_UNLOCK(t);
<             return (h);
<          }
<       } TREE_UNLOCK(t);

diff dce1.2.2/bt_trans.c new/bt_trans.c
159d158
<    tree->bt_free = P_INVALID;

diff dce1.2.2/btree.h new/btree.h
360c360
<       pthread_mutex_t bt_mutex;       /* Protects bt_free, bt_last, bt_order,
---
>       pthread_mutex_t bt_mutex;       /* Protects bt_last, bt_order,
368a369
> /*    pgno_t    bt_free;              /* next free page */
370,371d370
< 
<       pgno_t    bt_free;              /* next free page */

diff dce1.2.2/gdb_db44.c new/gdb_db44.c
887a888,889
>        else GDB_WRITE_LOCK(s);
> 

diff dce1.2.2/mpool.h new/mpool.h
94a95
> #define MPOOL_EMPTY     0x04            /* page is empty and may be reused */
117c118
<       pgno_t  npages;                 /* number of pages in the file */
---
>       pgno_t  npages;                 /* number of pages in use */
118a120
>         pgno_t  max_pages;              /* number of page slots in page table*/
138a141
> #define FREE_PAGE_ID ((pgno_t)0)


Complete replacement file for mpool.c:


/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1996 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE in the
 * src directory for the full copyright text.
 */
/*
 * @DEC_COPYRIGHT@
 * G-L-O-R-I-A modifications:
 * Copyright (c) 1996
 * Digital Equipment Corporation, Maynard, Massachusetts, USA
 * All Rights Reserved
 */
/*
 * HISTORY
 * $Log:	c013693,v $
# Revision 1.2  97/01/16  15:38:16  root
# changed fields: Affected File(s)  Diff supplied by  Diff release   new/changed/deleted note(s) [farrell 1/16/1997 public]
# 
 * Revision 1.1.2.1  1996/10/03  20:24:54  arvind
 * 	OSF DCE 1.2.2 Drop 4
 * 	[1996/10/03  19:19:48  arvind]
 *
 * Revision /main/DCE_1.2.2/1  1996/09/09  21:22 UTC  arvind
 * 	PKSS drop from DEC (DCE1.2.2)
 * 	[1996/08/30  15:36 UTC  arvind  /main/arvind_pkss/1]
 * 
 * 	GLORIA (R1.2.2) revision.
 * 	[1996/06/24  20:47:40  zee]
 * 
 * $EndLog$
 */
/*-
 * Copyright (c) 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#if defined(LIBC_SCCS) && !defined(lint)
static char sccsid[] = "@(#)mpool.c	8.5 (Berkeley) 7/26/94";
#endif /* LIBC_SCCS and not lint */

/* just for debugging... */
#include <dce/dce.h>
#include <dcecdssvc.h>


#include <sys/param.h>
#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <db.h>

#define	__MPOOLINTERFACE_PRIVATE
#include <mpool.h>

static BKT *mpool_bkt __P((MPOOL *));
static BKT *mpool_look __P((MPOOL *, pgno_t));
static int  mpool_write __P((MPOOL *, BKT *));
static void mpool_trash_page_table(MPOOL *); 
static void mpool_trash_cache(MPOOL *);

static int extend_page_table(MPOOL *);
static int mpool_load_page_table (MPOOL *);

#define P_META 0


/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
/*
 * mpool_load_page_table
 *
 * Create a buffer with room for the page table plus 
 * several new pages to save time when adding to the 
 * database.  Read the file containing the current page 
 * table into a buffer.  Create the free frame list
 * and set appropriate info in MPOOL structure.
 * 
 * Parameters:
 *   MPOOL *mp
 *
 * Returns:
 *   RET_ERROR or RET_SUCCESS
 */
static int
mpool_load_page_table (mp)
     MPOOL *mp; 
{
   struct stat buffer;
   int table_size;
   FRAME *tmp_frame;
   int f,p;
   size_t nr;
   int in_use;

   if (fstat (mp->page_table_fd[mp->current], &buffer) == 0 ) {

      mp->npages = buffer.st_size / sizeof(pgno_t);
      
      table_size = MAX(PAGE_TABLE_SIZE(buffer.st_size),PAGE_TABLE_EXTEND*PAGE_TABLE_INIT_FACTOR);
      if ((mp->page_table = malloc (table_size)) == NULL)
	return (RET_ERROR);
      memset (mp->page_table, FREE_PAGE_ID, table_size);
      
      if (buffer.st_size != 0) {
	 if (lseek(mp->page_table_fd[mp->current], 0, SEEK_SET) != 0){
           free (mp->page_table);
	   return (RET_ERROR);
         }
	 if ((nr = read (mp->page_table_fd[mp->current], 
			 mp->page_table, buffer.st_size)) != buffer.st_size) {
            free (mp->page_table);
	    return (RET_ERROR);
	 }
      }

      /*
       * How many pages we have to work with 
       */
      mp->max_pages = table_size / sizeof (pgno_t); 

      /*
       * Build the free list 
       */
#ifdef STATISTICS
      mp->nfree_frames = 0;
#endif

      /*
       * Build the free frames list, based on pagetable data
       * Start with frame 1 because frame 0 is reserved for P_META
       */
      for (f=mp->total_frames-1; f >= 1; f--) {
	 in_use = FALSE;
	 for (p=1; p < mp->npages; p++) {
	    if ( mp->page_table[p] == f ) {
	       in_use = TRUE;
	       break;
	    }
	 }
	 if (!in_use) {
	    tmp_frame = mp->free_frames;
	    mp->free_frames = malloc (sizeof(FRAME));
	    mp->free_frames->frame = f;
	    mp->free_frames->next = tmp_frame;
#ifdef STATISTICS
	    mp->nfree_frames++;
#endif
	 }
      }
   } else {
      return (RET_ERROR);
   }
   
   return (RET_SUCCESS);
}
/* *** G-L-O-R-I-A TXN CHANGES *** END */

/*
 * mpool_open --
 *	Initialize a memory pool.
 */
/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
MPOOL *
mpool_open(key, fd, pt_0_fd, pt_1_fd, current_pt, pagesize, maxcache)
/* *** G-L-O-R-I-A TXN CHANGES *** END */
	void *key;
	int fd;
/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
	int pt_0_fd;
	int pt_1_fd;
	u_long current_pt;
/* *** G-L-O-R-I-A TXN CHANGES *** END */
        pgno_t pagesize, maxcache;
{
	struct stat sb;
	MPOOL *mp;
	int entry;
/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
	int status;
/* *** G-L-O-R-I-A TXN CHANGES *** END */	

	/*
	 * Get information about the file.
	 *
	 * XXX
	 * We don't currently handle pipes, although we should.
	 */
	if (fstat(fd, &sb)) {
/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
	   perror("fstat in mpool_open()");
/* *** G-L-O-R-I-A TXN CHANGES *** END */
	   return (NULL);
	}
	if (!S_ISREG(sb.st_mode)) {
		errno = ESPIPE;
		return (NULL);
	}

	/* Allocate and initialize the MPOOL cookie. */
	if ((mp = (MPOOL *)calloc(1, sizeof(MPOOL))) == NULL)
		return (NULL);
	CIRCLEQ_INIT(&mp->lqh);
	for (entry = 0; entry < HASHSIZE; ++entry)
		CIRCLEQ_INIT(&mp->hqh[entry]);
	mp->maxcache = maxcache;
/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
        mp->total_frames = sb.st_size / pagesize;
/* *** G-L-O-R-I-A TXN CHANGES *** END */
	mp->pagesize = pagesize;
	mp->fd = fd;

/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
	if ( pt_1_fd >= 0 && pt_0_fd >= 0 ) {
	   mp->page_table_fd[0] = pt_0_fd;
	   mp->page_table_fd[1] = pt_1_fd;
	   mp->in_memory = FALSE;

	   /*
	    * Save the indication of which page table is current
	    * (__bt_open passes us from the metadata page)
	    *
	    * Then load the page table and set appropriate info
	    */
	   mp->current = current_pt;
	   if ( mpool_load_page_table(mp) != RET_SUCCESS) {
	      return (NULL);
	   }
	   mp->shadow_frames = NULL; /* No shadow frames until we're in a 
					transaction */
#ifdef STATISTICS
	   mp->nshadow_frames = mp->max_free_frames = 
	     mp->max_shadow_frames = 0;
	   mp->rollback = mp->commit = 0;
#endif
	} else if (pt_1_fd == NO_FD) {
	   mp->in_memory = TRUE;
	}

#ifdef THREADS
	/*
	 * Create mutex to guard the queue and statistical data
	 */
	if ( pthread_mutex_init (&mp->mutex, pthread_mutexattr_default) != 0) {
	   return (NULL);
	}
#endif

/* *** G-L-O-R-I-A TXN CHANGES *** END */

	return (mp);
}

/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */

/*
 * extend_page_table -- make room for more pages in table
 *
 * Parameters:
 *      mp - MPOOL cookie
 *
 * Returns:
 *      1 for success
 *      NULL for failure
 */
static
int extend_page_table(mp) 
     MPOOL *mp;
{
   int table_size;
   void *tmp_ptr;
   int f;
   FRAME *tmp_frame;
   pgno_t p;

   table_size = (mp->npages * PAGE_TABLE_ENTRY_SIZE) + PAGE_TABLE_EXTEND;
   tmp_ptr = (void *)mp->page_table;
   if ((mp->page_table = (pgno_t *)realloc(tmp_ptr, table_size)) == NULL) {
      mp->page_table = tmp_ptr;
      return ((int)NULL);
   }
   for (p = mp->npages; p < mp->npages + PAGE_TABLE_EXTEND_FACTOR; p++)
	mp->page_table[p] = FREE_PAGE_ID;

   mp->max_pages = table_size / PAGE_TABLE_ENTRY_SIZE;

   return (1);
}

/* *** G-L-O-R-I-A TXN CHANGES *** END */

/*
 * mpool_filter --
 *	Initialize input/output filters.
 */
void
mpool_filter(mp, pgin, pgout, pgcookie)
	MPOOL *mp;
	void (*pgin) __P((void *, pgno_t, void *));
	void (*pgout) __P((void *, pgno_t, void *));
	void *pgcookie;
{
	mp->pgin = pgin;
	mp->pgout = pgout;
	mp->pgcookie = pgcookie;
}

/*
 * mpool_new --
 *	Get a new page of memory.
 */
void *
mpool_new(mp, pgnoaddr)
	MPOOL *mp;
	pgno_t *pgnoaddr;
{
	struct _hqh *head;
	BKT *bp;
/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
	FRAME *tmp_frame;
	pgno_t p, new_page = FREE_PAGE_ID;
	
   MP_LOCK(mp){

        if (!(mp->in_memory)) {
	  /*
	   * First look for a free page among the ones that have already
	   * been used. (**Optimization opportunity**)
	   */
	  for (p = 1; p < mp->npages && new_page==FREE_PAGE_ID; p++) {
	    if (mp->page_table[p] == FREE_PAGE_ID) 
	      new_page = p;
	  }
	}
	/*
	 * If none, make sure there is room to add one more 
	 */
	if (new_page == FREE_PAGE_ID ) {
	  if (mp->npages == MAX_PAGE_NUMBER) {
	    (void)fprintf(stderr, "mpool_new: page allocation overflow.\n");
	    MP_UNLOCK(mp);
	    abort();
	  }
	}
	/*
	 * Get a BKT from the cache.  Assign a new page number, attach
	 * it to the head of the hash chain, the tail of the lru chain,
	 * and return.
	 */
	if ((bp = mpool_bkt(mp)) == NULL) {
	  MP_UNLOCK(mp);
	  return (NULL);
	}
	/*
	 * If none, use the next available page 
	 */
	if (new_page == FREE_PAGE_ID)
	  new_page = mp->npages++;

	if (mp->npages >= mp->max_pages) 
	  extend_page_table(mp);

	*pgnoaddr = bp->pgno = new_page;

#ifdef STATISTICS
	++mp->pagenew;
#endif

/* *** G-L-O-R-I-A TXN CHANGES *** END */
	bp->flags = MPOOL_PINNED;
#ifdef THREADS
	bp->users = 1; /* we just pinned it.  This thread is a user */
#ifdef TDEBUG
	(void)fprintf(stderr,
		      "Set page %d user count to %d (mpool_new)\n",
		      bp->pgno,bp->users);
#endif	     
#endif
	head = &mp->hqh[HASHKEY(bp->pgno)];
	CIRCLEQ_INSERT_HEAD(head, bp, hq);
	CIRCLEQ_INSERT_TAIL(&mp->lqh, bp, q);

/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
	if (!(mp->in_memory)) {
	   /*
	    * Find a free or new frame to associate with the new page
	    */
	  if (mp->free_frames) {
	     mp->page_table[bp->pgno] = mp->free_frames->frame;
	     tmp_frame = mp->free_frames->next;
	     free (mp->free_frames);
	     mp->free_frames = tmp_frame;
#ifdef STATISTICS
	     mp->nfree_frames--;
#endif
	   }
	   else {
	     mp->page_table[bp->pgno] = mp->total_frames++;
	   }
	 }
/* *** G-L-O-R-I-A TXN CHANGES *** END */

   } MP_UNLOCK(mp);

   return (bp->page);
}

/*
 * mpool_get
 *	Get a page.
 */
void *
mpool_get(mp, pgno, flags)
	MPOOL *mp;
	pgno_t pgno;
	u_int flags;				/* XXX not used? */
{
	struct _hqh *head;
	BKT *bp;
	off_t off;
	int nr;



   MP_LOCK(mp) {

	/* Check for attempt to retrieve a non-existent page. */
	if (pgno >= mp->npages) {
		errno = EINVAL;
		MP_UNLOCK(mp);
		return (NULL);
	}

	/* Make sure this page is being used before we try to read it */
	if (!mp->in_memory && pgno != P_META && mp->page_table[pgno] == FREE_PAGE_ID) {
		errno = EINVAL;
		MP_UNLOCK(mp);
	        return (NULL);
	}

#ifdef STATISTICS
	++mp->pageget;
#endif

	/* Check for a page that is cached. */
	if ((bp = mpool_look(mp, pgno)) != NULL) {
#ifdef THREADS
	   /* 
	    * Assume that if it's already pinned, then
	    * another thread did it, and we're still in
	    * good shape 
	    */
#else
#ifdef DEBUG
		if (bp->flags & MPOOL_PINNED) {
			(void)fprintf(stderr,
			    "mpool_get: page %d already pinned\n", bp->pgno);
			MP_UNLOCK(mp);
			abort();
		}
#endif
#endif
		/*
		 * Move the page to the head of the hash chain and the tail
		 * of the lru chain.
		 */
		head = &mp->hqh[HASHKEY(bp->pgno)];
		CIRCLEQ_REMOVE(head, bp, hq);
		CIRCLEQ_INSERT_HEAD(head, bp, hq);
		CIRCLEQ_REMOVE(&mp->lqh, bp, q);
		CIRCLEQ_INSERT_TAIL(&mp->lqh, bp, q);

		/* Return a pinned page. */
#ifdef THREADS
		bp->users++; /* do this while we have the mutex locked */

#ifdef TDEBUG
	(void)fprintf(stderr,
		      "Incremented page %d user count to %d\n",
		      bp->pgno,bp->users);
#endif	     
#endif		
		bp->flags |= MPOOL_PINNED;
		MP_UNLOCK(mp);
		return (bp->page);
        }

	/* Get a page from the cache. */
	if ((bp = mpool_bkt(mp)) == NULL) {
           errno = EFAULT;
	   MP_UNLOCK(mp);
	   return (NULL);
	}

	/* Set the page number, pin the page. */
	bp->pgno = pgno;
	bp->flags = MPOOL_PINNED;
#ifdef THREADS
	bp->users=1; /* We are the first user thread */
#ifdef TDEBUG
	(void)fprintf(stderr,
		      "Set page %d user count to %d(mpool_get)\n",
		      bp->pgno,bp->users);
#endif	     
#endif		

	/* Read in the contents. */
#ifdef STATISTICS
	++mp->pageread;
#endif

/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
	if (mp->in_memory) {
	   off = mp->pagesize * pgno;
	}
	else {
	   off = mp->pagesize * mp->page_table[bp->pgno];
	}
/* *** G-L-O-R-I-A TXN CHANGES *** END */

	if (lseek(mp->fd, off, SEEK_SET) != off) {
	   /*
	    * ??? G-L-O-R-I-A:
	    * Here's a bug.  THis page should be put back
	    * on the lru and hash lists.  We'll lose
	    * this page forever this way.
	    */
           errno = ESPIPE;
	   MP_UNLOCK(mp);
	   return (NULL);
	}
	if ((nr = read(mp->fd, bp->page, mp->pagesize)) != mp->pagesize) {
		if (nr >= 0) {
		   errno = EFTYPE;
		}
		/*
		 * ??? G-L-O-R-I-A:
		 * Here's a bug.  THis page should be put back
		 * on the lru and hash lists.  We'll lose
		 * this page forever this way.
		 */
		MP_UNLOCK(mp);
		return (NULL);
	}

	/*
	 * Add the page to the head of the hash chain and the tail
	 * of the lru chain.  If threads, take the mutex while we do
	 * this
	 */
	head = &mp->hqh[HASHKEY(bp->pgno)];
	CIRCLEQ_INSERT_HEAD(head, bp, hq);
	CIRCLEQ_INSERT_TAIL(&mp->lqh, bp, q);

	/* Run through the user's filter. */
	if (mp->pgin != NULL)
		(mp->pgin)(mp->pgcookie, bp->pgno, bp->page);

   } MP_UNLOCK(mp);

   return (bp->page);
}

/*
 * mpool_put
 *	Return a page.
 */
int
mpool_put(mp, page, flags)
	MPOOL *mp;
	void *page;
	u_int flags;
{
	BKT *bp;
	FRAME *tmp_frame;	   

   MP_LOCK(mp) {

#ifdef STATISTICS
	++mp->pageput;
#endif
	bp = (BKT *)((char *)page - sizeof(BKT));

#ifdef DEBUG
#ifndef THREADS
	if (!(bp->flags & MPOOL_PINNED)) {
		(void)fprintf(stderr,
		    "mpool_put: page %d not pinned\n", bp->pgno);
		MP_UNLOCK(mp);
		abort();
	}
#endif
#endif

#ifdef THREADS
	/*
	 * We shouldn't have any other threads with this 
	 * page pinned if we are writing it.  If we aren't writing it, then 
	 * other threads are welcome.
	 * 
	 * If this is the last thread using the page, then unpin it.
	 */
	if ( --bp->users != 0 ) {
	    if ( flags & MPOOL_DIRTY ) {
#ifdef TDEBUG
		(void)fprintf(stderr,
			      "Trying to write to page with non-0 user count (%d)\n",bp->users);
#endif	     
		MP_UNLOCK(mp);
		abort();
	    }
/* G-L-O-R-I-A _- fixing this to clear pinned flags. */
	}
	else {
	    bp->flags &= ~MPOOL_PINNED;
	}

#ifdef TDEBUG
	(void)fprintf(stderr,
		      "Decremented page %d user count to %d\n",
		      bp->pgno,bp->users);
#endif	     
#else
	bp->flags &= ~MPOOL_PINNED;
#endif

	/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
	if (mp->in_memory) {
	   bp->flags |= (flags & MPOOL_DIRTY);
	   MP_UNLOCK(mp);
	   return (RET_SUCCESS);
	}

	/*
	 * Check to see if this page is just becoming dirty
	 */
	if ( flags & MPOOL_DIRTY && !(bp->flags & MPOOL_DIRTY)) {

	   /*
	    * Mark it dirty 
	    */
	   bp->flags |= (flags & MPOOL_DIRTY);	   
	   
	   if (bp->pgno != P_META) {
	      /*
	       * If it isn't a brand new page, 
	       * put original frame on the shadow frame list, so
	       * we don't overwrite it before the transaction is committed
	       */
	      if ( mp->page_table[bp->pgno] != FREE_PAGE_ID) {
		 if ((tmp_frame = malloc (sizeof(FRAME))) == NULL) {
		    MP_UNLOCK(mp);
		    return (RET_ERROR);
		 }
		 tmp_frame->frame = mp->page_table[bp->pgno];
		 tmp_frame->next = mp->shadow_frames;
		 mp->shadow_frames = tmp_frame;
#ifdef STATISTICS
		 mp->nshadow_frames++;
		 if (mp->max_shadow_frames < mp->nshadow_frames)
		   mp->max_shadow_frames = mp->nshadow_frames;
#endif
	      }
	      /*
	       * Now, assign a new frame to the page, so that we 
	       * can write the new changes without squashing the shadow
	       * copies of these pages.  
	       */
	      if (flags & MPOOL_EMPTY) {
		mp->page_table[bp->pgno] = FREE_PAGE_ID;
		bp->flags &= ~MPOOL_DIRTY;
		bp->flags |= MPOOL_EMPTY;
	      }
	      else if (mp->free_frames) {
		mp->page_table[bp->pgno] = mp->free_frames->frame;
		tmp_frame = mp->free_frames->next;
		free (mp->free_frames);
		mp->free_frames = tmp_frame;
#ifdef STATISTICS
		mp->nfree_frames--;
#endif
	      }
	      else {
		mp->page_table[bp->pgno] = mp->total_frames++;
	      }
	   }
	   else { 
	      /*
	       * For page 0 or P_META, we always use frame 0
	       * This is okay because transactions don't change it.
	       * Except for the first word which is written automicly (we hope),
	       * it is frozen after the database is created.
	       */
	      mp->page_table[bp->pgno] = 0;
	   }
	}
	else if (flags & MPOOL_EMPTY) {
	  /*
	   * Page was already dirty and now it's empty.
	   *
	   * Don't need the frame we're currently using, put
	   * it back on the free frame list
	   */
	  tmp_frame = mp->free_frames;
	  mp->free_frames = malloc (sizeof(FRAME));
	  mp->free_frames->frame = mp->page_table[bp->pgno];
	  mp->free_frames->next = tmp_frame;
#ifdef STATISTICS
	  mp->nfree_frames++;
#endif
	  /*
	   * Mark the page empty 
	   */
	  if (flags & MPOOL_EMPTY) {
	    mp->page_table[bp->pgno] = FREE_PAGE_ID;
	    bp->flags &= ~MPOOL_DIRTY;
	    bp->flags |= MPOOL_EMPTY;
	    mp->nfree_frames++;
	  }
	}
	/* *** G-L-O-R-I-A TXN CHANGES *** END */

   } MP_UNLOCK(mp);

   return (RET_SUCCESS);
}

/*
 * mpool_close
 *	Close the buffer pool.
 */
int
mpool_close(mp)
	MPOOL *mp;
{
	BKT *bp;

   MP_LOCK(mp) {

	/* 
	 * Free up any space allocated to the cache
	 */
	while ((bp = mp->lqh.cqh_first) != (void *)&mp->lqh) {
		CIRCLEQ_REMOVE(&mp->lqh, mp->lqh.cqh_first, q);
		free(bp);
	}
/*** G-L-O-R-I-A TXN CHANGES - BEGIN ***/
	/*
	 * Free page table memory, and lru and free frame queues
	 */
	mpool_trash_page_table(mp);

   } MP_UNLOCK(mp);

#ifdef THREADS
	/*
	 * Destroy the mutex which guards the queues and statistical data
	 */
	if ( pthread_mutex_destroy (&mp->mutex) != 0) {
	    free (mp);
	    return ((int)NULL);
	}
#endif

	/* Free the MPOOL cookie. */
	free(mp);

/*** G-L-O-R-I-A TXN CHANGES - BEGIN ***/

   return (RET_SUCCESS);
}


/*
 * mpool_sync
 *	Sync the pool to disk.
 */
int
mpool_sync(mp)
	MPOOL *mp;
{
	BKT *bp;

  MP_LOCK(mp) {

	/* Walk the lru chain, flushing any dirty pages to disk. */
	for (bp = mp->lqh.cqh_first; bp != (void *)&mp->lqh; bp = bp->q.cqe_next) {

	    if (bp->flags & MPOOL_DIRTY && mpool_write(mp, bp) == RET_ERROR) {
		MP_UNLOCK(mp);
		return (RET_ERROR);
	    }
	}

  } MP_UNLOCK(mp);

  /* Sync the file descriptor. */
  return (fsync(mp->fd) ? RET_ERROR : RET_SUCCESS);
}

/*
 * mpool_bkt
 *	Get a page from the cache (or create one).
 *
 * Assumptions:
 *      MP_LOCK must be held when this is called
 */
static BKT *
mpool_bkt(mp)
	MPOOL *mp;
{
	struct _hqh *head;
	BKT *bp;


	/* If under the max cached, always create a new page. */
	if (mp->curcache < mp->maxcache)
		goto new;

	/*
	 * If the cache is max'd out, walk the lru list for a buffer we
	 * can flush.  If we find one, write it (if necessary) and take it
	 * off any lists.  If we don't find anything we grow the cache anyway.
	 * The cache never shrinks.
	 */
	for (bp = mp->lqh.cqh_first;
	    bp != (void *)&mp->lqh; bp = bp->q.cqe_next)

/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
	  if (!(bp->flags & MPOOL_PINNED)) {
	     if (!mp->in_memory) {
	       if (!(bp->flags & MPOOL_EMPTY) &&
		   ((bp->flags & MPOOL_DIRTY) && (mpool_write(mp,bp) == RET_ERROR))) {
		    return (NULL);
		}
	     }
	     else if (bp->flags & MPOOL_DIRTY)
	       continue; /* leave the dirty one alone until txn completes */

/* *** G-L-O-R-I-A TXN CHANGES *** END */
	     
#ifdef STATISTICS
			++mp->pageflush;
#endif
			/* Remove from the hash and lru queues. */

			head = &mp->hqh[HASHKEY(bp->pgno)];
			CIRCLEQ_REMOVE(head, bp, hq);
			CIRCLEQ_REMOVE(&mp->lqh, bp, q);
#ifdef DEBUG
			{ void *spage;
				spage = bp->page;
				memset(bp, 0xff, sizeof(BKT) + mp->pagesize);
				bp->page = spage;
			}
#endif
			return (bp);
	         }

new:	if ((bp = (BKT *)malloc(sizeof(BKT) + mp->pagesize)) == NULL) {
           return (NULL);
	}

#ifdef STATISTICS
	++mp->pagealloc;
#endif

	++mp->curcache;

#if defined(DEBUG) || defined(PURIFY)
	memset(bp, 0xff, sizeof(BKT) + mp->pagesize);
#endif
	bp->page = (char *)bp + sizeof(BKT);

  return (bp);
}

/*
 * mpool_write
 *	Write a page to disk.
 *
 * Assumptions:
 *      MP_LOCK must be held when this is called
 */
static int
mpool_write(mp, bp)
	MPOOL *mp;
	BKT *bp;
{
	off_t off;


#ifdef STATISTICS
	++mp->pagewrite;
#endif

	/* Run through the user's filter. */
	if (mp->pgout)
		(mp->pgout)(mp->pgcookie, bp->pgno, bp->page);

/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
	if (mp->in_memory)
	  off = mp->pagesize * bp->pgno; 
	else 
	  off = mp->pagesize * (mp->page_table[bp->pgno]);
/* *** G-L-O-R-I-A TXN CHANGES *** END */

	if (lseek(mp->fd, off, SEEK_SET) != off) {
	   return (RET_ERROR);
	}
	if (write(mp->fd, bp->page, mp->pagesize) != mp->pagesize) {
	   return (RET_ERROR);
	}

	bp->flags &= ~MPOOL_DIRTY;

  return (RET_SUCCESS);
}

/*
 * mpool_look
 *	Lookup a page in the cache.
 *
 * Assumptions:
 *      MP_LOCK must be held when this is called
 */
static BKT *
mpool_look(mp, pgno)
	MPOOL *mp;
	pgno_t pgno;
{
	struct _hqh *head;
	BKT *bp;

	head = &mp->hqh[HASHKEY(pgno)];
	for (bp = head->cqh_first; bp != (void *)head; bp = bp->hq.cqe_next)
		if (bp->pgno == pgno && !(bp->flags & MPOOL_EMPTY)) {
#ifdef STATISTICS
			++mp->cachehit;
#endif
			return (bp);
		}
#ifdef STATISTICS
	++mp->cachemiss;
#endif

  return (NULL);
}

#ifdef STATISTICS
/*
 * mpool_stat
 *	Print out cache statistics.
 */
void
mpool_stat(mp)
	MPOOL *mp;
{
	BKT *bp;
	int cnt;
	char *sep;


  MP_LOCK(mp) {

	(void)fprintf(stderr, "%lu pages in the file\n", mp->npages);
	(void)fprintf(stderr,
	    "page size %lu, cacheing %lu pages of %lu page max cache\n",
	    mp->pagesize, mp->curcache, mp->maxcache);
	(void)fprintf(stderr, "%lu page puts, %lu page gets, %lu page new\n",
	    mp->pageput, mp->pageget, mp->pagenew);
	(void)fprintf(stderr, "%lu page allocs, %lu page flushes\n",
	    mp->pagealloc, mp->pageflush);
	if (mp->cachehit + mp->cachemiss)
		(void)fprintf(stderr,
		    "%.0f%% cache hit rate (%lu hits, %lu misses)\n", 
		    ((double)mp->cachehit / (mp->cachehit + mp->cachemiss))
		    * 100, mp->cachehit, mp->cachemiss);
	(void)fprintf(stderr, "%lu page reads, %lu page writes\n",
	    mp->pageread, mp->pagewrite);
	/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
	if (!mp->in_memory) {
	   (void)fprintf(stderr, "free frames: %lu, max: %lu.\n",
			 mp->nfree_frames, mp->max_free_frames);
	   (void)fprintf(stderr, "shadow frames: %lu, max: %lu.\n",
			 mp->nshadow_frames, mp->max_shadow_frames);
	   (void)fprintf(stderr, "commits: %lu, rollbacks: %lu.\n",
			 mp->commit, mp->rollback);	
	}
	/* *** G-L-O-R-I-A TXN CHANGES *** END */

	sep = "";
	cnt = 0;
	for (bp = mp->lqh.cqh_first;
	    bp != (void *)&mp->lqh; bp = bp->q.cqe_next) {
		(void)fprintf(stderr, "%s%d", sep, bp->pgno);
		if (bp->flags & MPOOL_DIRTY)
			(void)fprintf(stderr, "d");
		if (bp->flags & MPOOL_PINNED)
			(void)fprintf(stderr, "P");
		if (++cnt == 10) {
			sep = "\n";
			cnt = 0;
		} else
			sep = ", ";
			
	}
	(void)fprintf(stderr, "\n");

  } MP_UNLOCK(mp);
}
#endif

/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
/*
 * mpool_trash_cache -- throw dirty pages in cache away, forcing
 *                      new read of on-disk copy
 * 
 *
 */
static void
mpool_trash_cache(mp) 
    MPOOL *mp;
{
   BKT *bp, *next_bp;

#ifdef DEBUG_TXN
      fprintf(stderr, "Dumping pages from cache: ");
#endif

   for (bp = mp->lqh.cqh_first; bp != (void *)&mp->lqh; 
	bp = next_bp) {

      next_bp = bp->q.cqe_next;

      if (bp->flags & MPOOL_DIRTY) {
#ifdef DEBUG_TXN
	 fprintf(stderr, "%d ", bp->pgno);
#endif 
	 
	 CIRCLEQ_REMOVE(&mp->hqh[HASHKEY(bp->pgno)], bp, hq);
	 CIRCLEQ_REMOVE(&mp->lqh, bp, q);

	 free (bp);
	 --(mp->curcache);
#ifdef STATISTICS
	 --(mp->pagealloc);
#endif
      }
   }
#ifdef DEBUG_TXN
	 fprintf(stderr, ".\n");
#endif 
}

/*
 * mpool_trash_page_table -- trash structures associated with 
 *                           current page table: free_list,
 *                           shadow_list and page_table.
 * Parameters:
 *   MPOOL *mp
 *
 * Returns:
 *   none
 */
static void
mpool_trash_page_table(mp) 
   MPOOL *mp;
{
   FRAME *f,*nextframe;

   /*
    * We don't really need to change much, just 
    * free all the allocated memory, and set some
    * pointers to NULL, and it's as though the 
    * table and lists never existed.
    */
   for (f = mp->free_frames; f != NULL; f = nextframe) {
      nextframe = f->next;
      free (f);
   }
   mp->free_frames = NULL;

   for (f = mp->shadow_frames; f != NULL; f = nextframe) {
      nextframe = f->next;
      free (f);
   }
   mp->shadow_frames = NULL;

   if (mp->page_table) {
       free (mp->page_table);
   }

   mp->max_pages = 0;

#ifdef STATISTICS
   mp->nfree_frames = mp->nshadow_frames = 0;
#endif
}

/*
 * mpool_txn_begin
 *
 * Parameters:
 *   MPOOL *mp
 *
 * Returns:
 *   RET_ERROR, RET_SUCCESS
 */
/*
 * Changed to MACRO per code review.  Stored in MPOOL.H
 *
 * int mpool_txn_begin (mp)
 *     MPOOL *mp;
 * {
 *   mp->rollback_npages = mp->npages;
 * }
 */



/*
 * mpool_txn_commit - commit this txn to the non-volatile database
 *
 * Parameters:
 *   MPOOL *mp
 *
 * Returns:
 *   RET_ERROR, RET_SUCCESS
 */
int mpool_txn_commit (mp)
     MPOOL *mp;
{
   int new_current;
   int table_size;
   FRAME *f,*nextframe;

   /*
    * Check to see if there's no changes to commit
    */
   if (mp->shadow_frames == NULL) {
      return(RET_SUCCESS);
   }

   /*
    * Sync dirty blocks to disk 
    */
   if (mpool_sync (mp) != RET_SUCCESS) {
      return (RET_ERROR);
   }

   /*
    * Write page table to disk file that does not
    * have the current page table
    */
   new_current = mp->current == 0 ? 1 : 0;
   table_size = mp->npages * PAGE_TABLE_ENTRY_SIZE;
   if (lseek (mp->page_table_fd[new_current], 0, SEEK_SET) != 0)
     return (RET_ERROR);
   if (write (mp->page_table_fd[new_current], mp->page_table, table_size) !=
       table_size)
     return (RET_ERROR);
   if (fsync(mp->page_table_fd[new_current]) != RET_SUCCESS)
     return (RET_ERROR);

   /*
    * Tell disk to use the new page table
    */
   if (lseek (mp->fd, 0, SEEK_SET) != 0)
     return (RET_ERROR);
   if (write (mp->fd, &new_current, sizeof(new_current)) != sizeof(new_current))
     return (RET_ERROR);
   if (fsync(mp->fd) != RET_SUCCESS)
     return (RET_ERROR);

   /*
    * Remind ourselves which on disk page table is good too
    */
   mp->current = new_current;

   /*
    * Move shadow frames onto the free frame list 
    */
#ifdef DEBUG_TXN
      fprintf(stderr, "Freeing shadow frames: ");
#endif

   for (f = mp->shadow_frames; f != NULL; f = nextframe) {
      nextframe = f->next;
      f->next = mp->free_frames;
      mp->free_frames = f;
#ifdef STATISTICS
      mp->nfree_frames++;
      mp->nshadow_frames--;
#endif 
#ifdef DEBUG_TXN
      fprintf(stderr, "%d ",f->frame);
#endif
   }
   mp->shadow_frames = NULL;

#ifdef DEBUG_TXN
      fprintf(stderr, ".\n ");
#endif
   
#ifdef STATISTICS
   mp->commit++;
   if (mp->nfree_frames > mp->max_free_frames) 
     mp->max_free_frames = mp->nfree_frames;
#endif 

   return (RET_SUCCESS);
}

/*
 * mpool_txn_rollback (mp) 
 *
 * Parameters:
 *   MPOOL *mp
 * 
 * Returns:
 *   RET_ERROR, RET_SUCCESS
 */
int mpool_txn_rollback (mp)
     MPOOL *mp;
{
   int status;

   /*
    * Dump dirty pages from cache
    */
   mpool_trash_cache (mp); /* always success */
   mp->npages = mp->rollback_npages;

   /*
    * Read in on-disk current page table, this remains current
    *
    * Start over reading the page table in.  This isn't
    * the fastest way to accomplish the task, but it 
    * won't happen often.  We hope.
    */
   mpool_trash_page_table (mp); /* always success */
   status = mpool_load_page_table (mp);

#ifdef STATISTICS
   mp->rollback++;
#endif
   
   return (status);
}
/* *** G-L-O-R-I-A TXN CHANGES *** END */



CR Number                     : 13692
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : rgynbase.idl
Short Description             : sec_rgy_domain_principal does not exist
Reported Date                 : 1/6/97
Found in Baseline             : 1.1
Found Date                    : 1/6/97
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/idl/rgynbase.idl
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[1/6/97 public]
The constant "sec_rgy_domain_principal" referred to in the documentation
does not exist, but sec_rgy_domain_person is what it means.

The following diff to security/idl/rgynbase.idl adds
sec_rgy_domain_principal with the same value as sec_rgy_domain_person (0)
and causes /usr/include/dce/rgybase.h to change to reflect it as well.
Since both constants will now exist it won't break existing code but will
allow end-users (and vendors/providers) to use the
sec_rgy_domain_principal name.

*** security/idl/rgynbase.idl
--- 13.2        1997/01/03 21:28:21
***************
*** 177,182 ****
--- 188,194 ----
      typedef signed32    sec_rgy_domain_t;

      const signed32      sec_rgy_domain_person = 0;
+     const signed32      sec_rgy_domain_principal = 0;
      const signed32      sec_rgy_domain_group = 1;
      const signed32      sec_rgy_domain_org = 2;
      const signed32      sec_rgy_domain_last = 3;



CR Number                     : 13688
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : pkss
Short Description             : potential security problem in pkss
Reported Date                 : 12/18/96
Found in Baseline             : 1.2.2b5
Found Date                    : 12/18/96
Severity                      : A
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/pkc/pkss/pipe/<platform>/pkss_helper.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/18/96 public]

Summary
-------
The PKSS code in R1.2.2BL5 has a security vulnerability that can allow an
attacker to gain root access to the machine.  While the released version of
DCE R1.2.2 does not exhibit this problem on the reference platform, the fix
is specific to AIX, and vendors porting DCE to other platforms should be
aware of this problem so that an appropriate platform-specific solution can
be designed.


Description
-----------
The protocol used to communicate between the PKSS server and DCE's client-side
login code requires that the client authenticate the identity of the PKSS.
This requires the client-side to have access to a DCE login-context before
login has completed.  The PKSS client-side makes use of the machine's
credential to perform this authentication.  This requires that some portion
of the client-side code run with root privileges.  The PKSS client-side is
divided into two parts - a small API layer that is linked with libdce and an
ancillary process which is installed as a setuid-root program.

On platforms supporting shared libraries with user-controllable library
path resolution, this may introduce a security hole into the system.  It is
possible for an attacker to run the ancillary program having configured
the environment such that the libraries that the ancillary program invokes
(which include libdce and the C++ runtime) are replaced with the attacker's 
own libraries, which will then be invoked with root privileges.

Solution
--------
The final release version of DCE includes a fix for this problem.  This fix
is specific to the reference platform, but can be used as a template for
other platforms for which this problem exists.

The ancillary process has been split into two files: pkss_helper and
pkss_helper2.  pkss_helper2 contains all the code of the original ancilliary
process, but is not installed as a setuid file.  pkss_helper is a setuid-root
program whose sole purpose is to establish a secure environment in which
to exec pkss_helper2.  pkss_helper is linked against only static libraries
so that it does not suffer from this problem itself.

On AIX, establishing a secure environment in accomplished by setting the
LIBPATH environment variable to an empty string, telling the AIX loader
to search only the default directories when attempting to resolve references
to shared libraries.  While a similar approach is expected to work on other
Unix platforms, the details are likely to vary between platforms.

The source code for the pkss_helper program has therefore been placed in an
AIX-specific subdirectory (src/security/pkc/pkss/pipe/RIOS/pkss_helper.c).
This file may be used as an example for porting.  For platforms where this
attack is possible, it is important that pkss_helper is built using only
static libraries.



CR Number                     : 13686
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : libdce u2u
Short Description             : Overzealous mem leak fix broke use of u2u by RPC runtime
Reported Date                 : 12/18/96
Found in Baseline             : 1.2.2
Found Date                    : 12/18/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/utils/sec_authn.c
Diff supplied by              : provider
Diff release                  : 1.2.2
Sensitivity                   : public

[12/18/96 public]
A recent overzealous memory leak fix to sec_authn.c freed too much data.
This was not picked up by the automatic kerberos user to user test because
it did not rely on the routine changed.  The manual test picked it up a
couple days ago and I proved that it was broken yesterday afternoon.  The
fix must be applied to 1.2.2 GA by licensees in order for full use of the
user to user protocol in DCE products (eg, use via auth-RPC instead of just
by Kerberos).  The fix listed below has been tested and has fixed the problem,
and has been reviewed and verified that it does not re-open the memory leak
that the previous fix intended to plug, or any new memory leaks.  The fix
really is a simple as the diff looks (remove the if block that free()s the
second ticket data, which is necessary for correct operation of the
following call krb5_get_credentials_dce())

I'll take responsibility for this going unnoticed, as I'm the one that's
been complaining for years about manual tests, and I didn't put this work
item on the plate for 1.2.2 (mistaken assumption that the existing automatic
u2u test was testing more of the code path, and that we would have run this
manual test enough to notice the regression).  I'm opening up a related
OT (RPC enhancement OT for the RPC runtime "perf" test which has always been
a manual test) for this test to become automated (TETified) in the next
release.

*** sec_authn.c@@/main/DCE_1.2.2/mb_u2u3/0      Wed Dec 18 11:20:14 1996
--- sec_authn.c Wed Dec 18 11:22:19 1996
***************
*** 1065,1083 ****
                           * Kerberos does not expect a fully populated kcred
                           * structure, so free what we don't need.
                           */
                          if (kcred->ticket.data) {
                              xfree(kcred->ticket.data);
                              kcred->ticket.data = NULL;
                          }
-                         if (kcred->second_ticket.data) {
-                             xfree(kcred->second_ticket.data);
-                             kcred->second_ticket.data = NULL;
-                         }
- 
  
                          st = krb5_get_credentials_dce(options,
                                          krb_ccache, kcred, tgt_authdata);
                          /* CHFts16434: if we get an error here, it means the
                           * PTGT just expired.  Release any epac data, then loop
                           * again, which will get a fresh PTGT this time
                           */



CR Number                     : 13685
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : gssapi
Short Description             : interoperate with krb5 mechanism
Reported Date                 : 12/17/96
Found in Baseline             : 1.1
Found Date                    : 12/17/96
Severity                      : B
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/17/96 public]

This is from some email by the GSSAPI engineer:

The DCE GSSAPI implements two mechanisms - DCE and "name-based" security.  The
protocol used for the latter mechanism was the basis for the original IETF
Kerberos GSSAPI Internet Draft.  Since then there have been a couple revisions
to the ID, and now it's made its way to RFC status.

We never fully tested interoperability with any MIT Kerberos implementation of
the protocol, since at the time DCE R1.1 froze, the MIT implementation didn't
fully meet the ID spec (because of an endian-ness bug).  We haven't tested
subsequent releases of the MIT implementation, although now that the spec has
become an RFC it's probably time to do this and officially support
interoperation (once the underlying DCE Kerberos implementation is fully
interoperable, as of R1.2.2).

One "happy accident" of the ID-RFC process is that the OID used to indicate
"GSSAPI over Kerberos" changed during the standardization process.  The DCE
implementation treats either the original OID or the new OID as equivalent on
receipt (and tries to interpret the packet accdording to the original
protocol), but always generates the original OID value in emitted packets.  It
would be simple to add support for a third mechanism (MIT Kerberos), and retain
the current behavior for packets using the original OID, thus retaining
backwards compatibility across DCE versions as well as achieving interoperation
with MIT.



CR Number                     : 13684
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : krb5 interop
Short Description             : Reservation of sec_login flags, new error code for krb5 ticket requests
Reported Date                 : 12/16/96
Found in Baseline             : 1.2.1
Found Date                    : 12/16/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : sec_login.h, sec.sams
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/16/96 public]

We would like to reserve the following sec_login_flag_t values
and error code for future KRB5/DCE interoperability support.
This change is being logged in advance to prevent interoperability/API 
compatibility problems between DCE releases.

sec_login.h:

      /*
       * login context with forwardable flag on
       */
      const unsigned32    sec_login_forwardable_tkt   = 0x40;
 
      /*
       * login context with renewable flag on - not implemented yet
       */
      const unsigned32    sec_login_renewable_tkt     = 0x80;
 
      /*
       * login context with proxiable flag on - not implemented yet
       */
      const unsigned32    sec_login_proxiable_tkt     = 0x100;

sec.sams:

>< start   undocumented
>< code    sec_login_s_PADe
>< text    "sec_login_s_PADe"
>< explanation    "?"
>---
>> start   
>> code    sec_login_s_flag_not_support
>> text    "Specified flag is not yet implemented in this version of DCE."
>> explanation    "Do not use this flag."



CR Number                     : 13676
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : pkc
Short Description             : Some certs not found
Reported Date                 : 12/3/96
Found in Baseline             : 1.2.2b5
Found Date                    : 12/3/96
Severity                      : C
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/security/pkc/capi/plcy/pkc_plcy_hierarchy.cxx
Diff supplied by              : provider
Diff release                  : 1.2.2b5
Sensitivity                   : public

[12/3/96 public]

The Certification API's hierarchical policy module may not find all 
certificates needed for a certification path.  The hierarchical policy
is supposed to find CA certificates stored under either their subject 
or their issuer.  Currently, when traversing the up portion of a
certification path, the policy module will only find certificates stored
under the issuer; on the down path, only certificates stored under the
subject will be found.

Until a code fix can be provided, a work-around is to store up-certificates 
in the directory entry of the certificate issuer, and down-certificates in 
the directory entry of the certificate subject.

[12/23/96 public]

Here is the fix for this problem.  This fix will allow the hierarchical
policy module to find CA certificates stored in either the CACert or
CrossCertPair attributes of the directory entries of either the
certificate subject or the issuer.

To address the bug in this OT, you need to make changes to module
src/security/pkc/capi/plcy/pkc_plcy_hierarchy.cxx (since the drop in
R1.2.2_bl5). The changes to pkc_plcy_hierarchy.cxx are as follows:


1. Two #defines have been added.
2. Prototypes for 2 functions (process_ca_user_certs, & process_cross_certs)
   have been changed to include an extra integer parameter.
3. The code for three functions  (process_ca_user_certs,process_cross_certs & 
   add_certs_in_entry) has been changed. The prototype for add_certs_in_entry
   has not been changed.


Instead of providing traditional diff's, it is simpler to provide the
entire code for the three functions & their prototypes. 

Perform the following steps:

STEP I:

Add the following lines (anywhere) before the start of the function prototypes. 

#define FIRST_TIME 0
#define SECOND_TIME 1


STEP 2:

Replace the function prototypes for process_ca_user_certs & process_cross_certs
with the ones below:

unsigned32 process_ca_user_certs(pkc_trust_list_t *partial, 
			 x500name  & ca, 
                         int is_ca,
			 x500name &ca_cert_dir,
			 direction flag,
			 int depth,
                         struct ca_db_entry **cainfo_p,
                         int step_number);

unsigned32 process_cross_certs(pkc_trust_list_t *partial, 
			 x500name  & ca, 
                         int is_ca,
			 x500name &ca_cert_dir,
			 direction flag,
			 int depth,
                         struct ca_db_entry **cainfo_p,
                         int step_number);


STEP 3:

Replace the entire code for functions add_certs_in_entry,
process_ca_user_certs, and process_cross_certs, with the code 
fragments shown below.  Functions are separated by a comment line
of the form /* ************************************************** */


static void add_certs_in_entry (pkc_trust_list_t *partial, 
			 x500name  & ca, 
                         int is_ca,   /* 1 if ca, 0 if user */
			 x500name  & ca_cert_dir, 
			 direction flag,
			 int depth,
                         struct ca_db_entry **cainfo_p,
			 unsigned32 *status)
{


  unsigned32 status1;



  DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug9,
        ">add_certs_in_entry"));

  DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
        ">add_certs_in_entry: ca = %s",convert_x500name_to_printable_form(ca)));
  DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
        ">add_certs_in_entry: ca_cert_dir = %s",convert_x500name_to_printable_form(ca_cert_dir)));
  DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
        ">add_certs_in_entry: is_ca = %ld, direction = %ld, & depth = %ld",
         is_ca, flag, depth));



  switch (flag) {

   // ************************************************
   // **************  UP ****************************
   // ************************************************
  case up:
    // first, read the ca_revoke list, and for each of the certificates listed,
    // call the appropriate pkc_certs api to remove any certificates that have
    // been revoked.

    *status = revoke_certs_if_any (ca_cert_dir, is_ca, partial);
    if (*status != 0) {

      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
            "add_certs_in_entry: revoke_certs_if_any failed %ld",*status));

      return;
    }

    // mbg: for now, we process both user revocation as well as 
    // ca revocation list regardless of whether we were called
    // for the target or an intermediate ca.
    *status = revoke_certs_if_any (ca_cert_dir, !is_ca, partial);
    if (*status != 0) {

      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
            "add_certs_in_entry: revoke_certs_if_any failed %ld",*status));

      return;
    }

    // process the certs in CA_CERT_OID. While establishing
    // trustbase, we only process certs in CA_CERT_OID &
    // don't process certs in USER_CERT_OID

    // mbg: 12/13/96: we found a bug in the current implementation
    // in R1.2.2bl6. The problem was that while going up, we were
    // honoring only "up" certs in an entry 
    // for which the issuer was the entry itself. This 
    // is not right.. We need to honor "up" certs where the subject is 
    // the entry being looked up as well. 
    // IN order to do this correctly, we need to process "up" certs
    // stored in entry for which the entry is a subject
    //  before processing "up" certs stored in entry for which it is a issuer.
    // We thus call process_ca_user_certs twice: First time to 
    // to process up certs in which entry is subject, and second time
    // to process up certs where entry is issuer.
    // The order is important (i.e. process "up" certs for which entry is
    // subject before processing "up" certs for which entry is issuer)
    // since it may otherwise result in missing on some valid public
    // keys. 
    // To distinguish these two steps, we add yet another paramter
    // to process_ca_user_certs and process_cross_certs. The constants
    // FIRST_TIME and SECOND_TIME are used to distinguish the two steps
    // in the code. 

    *status = process_ca_user_certs(partial, 
			 ca, 
                         is_ca,   /* 1 if ca, 0 if user */
			  ca_cert_dir, 
			 flag,
			 depth,
                         cainfo_p, FIRST_TIME);
    if (*status != 0) {
      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
            "add_certs_in_entry: process_ca_user_certs failed %ld",*status));
      return;
    }


  // second, read the certificates in the cross_cert_oid attr.
    *status = process_cross_certs(partial, 
			 ca, 
                         is_ca,   /* 1 if ca, 0 if user */
			  ca_cert_dir, 
			 flag,
			 depth,
                         cainfo_p, FIRST_TIME);

    if (*status != 0) {
      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
            "add_certs_in_entry: process_cross_certs failed %ld",*status));
      return;
    }



    *status = process_ca_user_certs(partial, 
			 ca, 
                         is_ca,   /* 1 if ca, 0 if user */
			  ca_cert_dir, 
			 flag,
			 depth,
                         cainfo_p, SECOND_TIME);
    if (*status != 0) {
      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
            "add_certs_in_entry: process_ca_user_certs failed %ld",*status));
      return;
    }


  // second, read the certificates in the cross_cert_oid attr.
    *status = process_cross_certs(partial, 
			 ca, 
                         is_ca,   /* 1 if ca, 0 if user */
			  ca_cert_dir, 
			 flag,
			 depth,
                         cainfo_p, SECOND_TIME);

    if (*status != 0) {
      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
            "add_certs_in_entry: process_cross_certs failed %ld",*status));
      return;
    }

   break;

   // ************************************************
   // **************  DOWN ****************************
   // ************************************************
   case down: 

   // we need to do the downward processing in two steps
   // as well. In the first step, we process down ca-certs & user certs
   // whose subject is the current entry; in the second step
   // we process down ca-certs & user-certs whose issuer is the
   // current entry.


    // while going down, we need to process both ca_cert_oid
   // and user_cert_oid if is_ca == user.
    *status = process_ca_user_certs(partial, 
			 ca, 
                         is_ca,   /* 1 if ca, 0 if user */
			  ca_cert_dir, 
			 flag,
			 depth,
                         cainfo_p, FIRST_TIME);
    if (*status != 0) {
      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
            "add_certs_in_entry: process_ca_user_certs failed %ld",*status));
      return;
    }

    if (!is_ca) {  /* if ca was a user, process ca_cert_oid as well */
                   /* since for users, we need to do both */
     *status = process_ca_user_certs(partial, 
			 ca, 
                         !is_ca,
			  ca_cert_dir, 
			 flag,
			 depth,
                         cainfo_p, FIRST_TIME);
      if (*status != 0) {
        DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
              "add_certs_in_entry: process_ca_user_certs failed %ld",*status));
        return;
      }
    }

  // second, read the certificates in the cross_cert_oid attr.
    *status = process_cross_certs(partial, 
			 ca, 
                         is_ca,   /* 1 if ca, 0 if user */
			  ca_cert_dir, 
			 flag,
			 depth,
                         cainfo_p, FIRST_TIME);

    if (*status != 0) {
        DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
              "add_certs_in_entry: process_cross_certs failed %ld",*status));
      return;
    }

    // certs in db are definitely those s.t. entry is a subject in certs
    // thus we need to do it only once.
    *status = process_cross_certs_in_db(partial, 
			 ca, 
                         is_ca,   /* 1 if ca, 0 if user */
			 flag,
			 depth,
                         cainfo_p);

    if (*status != 0) {
      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
              "add_certs_in_entry: process_cross_certs_in_db failed %ld",*status));
      return;
    }



    // while going down, we need to process both ca_cert_oid
   // and user_cert_oid if is_ca == user.
    *status = process_ca_user_certs(partial, 
			 ca, 
                         is_ca,   /* 1 if ca, 0 if user */
			  ca_cert_dir, 
			 flag,
			 depth,
                         cainfo_p, SECOND_TIME);
    if (*status != 0) {
      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
            "add_certs_in_entry: process_ca_user_certs failed %ld",*status));
      return;
    }

    if (!is_ca) {  /* if ca was a user, process ca_cert_oid as well */
                   /* since for users, we need to do both */
     *status = process_ca_user_certs(partial, 
			 ca, 
                         !is_ca,
			  ca_cert_dir, 
			 flag,
			 depth,
                         cainfo_p, SECOND_TIME);
      if (*status != 0) {
        DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
              "add_certs_in_entry: process_ca_user_certs failed %ld",*status));
        return;
      }
    }

  // second, read the certificates in the cross_cert_oid attr.
    *status = process_cross_certs(partial, 
			 ca, 
                         is_ca,   /* 1 if ca, 0 if user */
			  ca_cert_dir, 
			 flag,
			 depth,
                         cainfo_p, SECOND_TIME);

    if (*status != 0) {
        DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
              "add_certs_in_entry: process_cross_certs failed %ld",*status));
      return;
    }



    *status = revoke_certs_if_any (ca_cert_dir, is_ca, partial);
    if (*status != 0) {
      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
              "add_certs_in_entry: revoke_certs_if_any failed %ld",*status));
      return;
    }



    // mbg: for now, we process both user revocation as well as 
    // ca revocation list regardless of whether we were called
    // for the target or an intermediate ca.
    *status = revoke_certs_if_any (ca_cert_dir, !is_ca, partial);
    if (*status != 0) {
      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
            "add_certs_in_entry: revoke_certs_if_any failed %ld",*status));
      return;
    }





    break;


    default:
     DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
           "add_certs_in_entry: direction is neither up or down, serious error"));
     return;
    }       /* end of switch */

  
 *status = 0;
 DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug9,
       ">add_certs_in_entry"));
  return ;


}  /* add_certs_in_entry */

/* ************************************************** */

unsigned32 process_ca_user_certs(pkc_trust_list_t *partial, 
			 x500name  & ca, 
                         int is_ca,
			 x500name &ca_cert_dir,
			 direction flag,
			 int depth,
                         struct ca_db_entry **cainfo_p,
                         int step_count)
{
  unsigned32 status, status1;
  x500name cert_issuer, cert_subject;
  int  is_ancestor,  is_descendant, is_equal, 
     is_sibling, depth_difference;
  Certificate cert;
  const xds_attribute_t *attr_result = 0;
  xds_read_result_t *result = 0;
  unsigned char *asn1_cert_p = 0; size_t length = 0;
  const xds_value_t *value_result = 0;

  DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug9,
    ">process_ca_user_certs"));

  // first, read the x500 certificate attribute values 
  // there should only be one attribute, with possibly multiple values returned
  // where the attribute identifies this to be a certificate attribute, and the
  // individual values correspond to the one or more certificates.
  result = read_xds_certificate_attribute(ca_cert_dir, is_ca, &status);
  if (status != 0) {
    return 0; 
  }

  status = result->get_first_attribute(attr_result); // we only have one attribute.
  if (status != 0 || attr_result == 0) {
    delete result;
    return 0;
  }

  status = attr_result->get_first_value(value_result); //get the first value
  if (status != 0 || value_result == 0) {
    delete result;
    return 0; 
  }


  status = value_result->get_value(asn1_cert_p, length);  // get the asn1 encoding in value
  if (status != 0 || length == 0 || asn1_cert_p == 0) {
    DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
      "process_ca_user_certs get value failed %ld", status));
    delete result;
    return 0;  // actually a problem, in that, there is value, but zero bytes in value.
  }
  

  while (1) {

    status = construct_certificate(asn1_cert_p,length, cert);
    if (status != 0)  { // problem creating certificate
      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
        "process_ca_user_certs construct_certificate failed %ld", status));
      status = 0;
      goto next_cert;
    }
    cert_issuer = cert.certificateInfo.issuer;
    cert_subject = cert.certificateInfo.subject;

    status = determine_relation(cert_issuer, cert_subject, is_ancestor,
                          is_descendant, is_equal,
                          is_sibling, depth_difference);
    if (status != 0) {
      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
        "process_ca_user_certs determine_relation failed %ld", status));
     if (asn1_cert_p)  
       pkc_free (asn1_cert_p);
     delete result;
     return status;
    }

    // check if ca is present in the required depth in the list of ca's so far..
    // if not, skip adding this certificate.

    // this is slightly more complicated.. If direction is up, then
    // we are willing to tolerate certs that are issued by cert_issuer who
    // is a child of ca, and within depth.
    //
    // if direction is down, we are willing to tolerate certs issued by
    // cert_issuer who is an ancestor of ca, and within depth. however,
    // in this case, we are also willing to tolerate certs that are
    // issued by cert_issuer who is a cross-link of ca. This is because,
    // to complete trust chain while coming down, we are allowed to take
    // one cross link.

    switch (flag) {

    // ******************************************************
    // ******************** UP *****************************
    // *****************************************************
    case up:

     if ((ca == cert_subject) && (step_count == FIRST_TIME)) {
       // process this certificate
       // we only process  UP certificates and cross certificates. 
      // first check for up certificate, and whether ca == cert_subject
      // these are processed during first step while traveling up..
      if (is_descendant && (depth_difference <= depth)) {

	status1  = pkc_check_cert_against_trustlist (partial, 
                  &cert, 1);

        DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
          "process_ca_user_certs pkc_check_cert_against_trustlist returned %ld", status1));


      }

 
    }  /* if ca == cert_subject && step_count == FIRST_TIME  */

     if ((ca == cert_issuer) && (step_count == SECOND_TIME)) {
       // process this certificate
       // we only process  UP certificates and cross certificates. 
      // first check for up certificate and make sure the entry
      // being looked up is the issuer itself.
      if (is_descendant && (depth_difference <= depth)) {

	status1  = pkc_check_cert_against_trustlist (partial, 
                  &cert, 1);

        DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
          "process_ca_user_certs pkc_check_cert_against_trustlist returned %ld", status1));


      }

      // even though this is not exactly good, we still
      // allow for a cross-cert to be in a ca-cert oid..
      if (is_sibling)  {  /* cross certificate */
	unsigned char *princ = 0;        
	status = convert_x500name_to_string(cert_subject, princ);
        if (status != 0) {
          if (asn1_cert_p)  
            pkc_free (asn1_cert_p);
          delete result;
          return status;
       }
       status = add_ca_and_cert_to_crdb((char *)princ, asn1_cert_p, length, cainfo_p);
       if (status != 0) {
          if (asn1_cert_p)  
            pkc_free (asn1_cert_p);
          delete result;
          return status;
       }
       pkc_free (princ);
    }


   }  /* if ca == cert_issuer && step_count == SECOND_TIME */

   break;

    // ******************************************************
    // ******************** DOWN *****************************
    // *****************************************************

    case down:


     if ((ca == cert_subject) && (step_count == FIRST_TIME)) {
       // process this certificate
       // we only process  DOWN certificates and cross certificates. 
      // in both cases, we try to add the certificate
      if ((is_ancestor && (depth_difference <= depth)) ||
           (is_sibling)) {

	status1  = pkc_check_cert_against_trustlist (partial,
                       &cert, 1);

        DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
          "process_ca_user_certs pkc_check_cert_against_trustlist returned %ld", status1));

      }

     }  /* if ca == cert_subject && step_count == FIRST_TIME */

     if ((ca == cert_issuer) && (step_count == SECOND_TIME)) {
      if (is_ancestor && (depth_difference <= depth)) {
	status1  = pkc_check_cert_against_trustlist (partial,
                       &cert, 1);

        DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
          "process_ca_user_certs pkc_check_cert_against_trustlist returned %ld", status1));

      }
     } /* if ca == cert_issuer && step_count == SECOND_TIME */
     


   break;

   default:  /* should never come here */
      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
        "process_ca_user_certs pkc_check_cert_against_trustlist ** ERROR **"));
   delete result;
   return (-1);
  } /* end of switch statement */




next_cert:
    if (asn1_cert_p)  
       pkc_free (asn1_cert_p);


    asn1_cert_p = 0;
    length = 0;

    status = attr_result->get_next_value(value_result); //get the next value value
    if (status != 0 || value_result == 0) {   // end of certificates..
      // should check for value and make sure it indicates last value.. but for now, this is ok.
      // this is really a normal return from this procedure.

      delete result;
      return 0;
    }

    status = value_result->get_value(asn1_cert_p, length);  // get the asn1 encoding in value
    if (status != 0 || length == 0 || asn1_cert_p == 0) {
      delete result;
      return 0;
    }

  } /* while (1) */

  /* should never come here */
   DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
     "process_ca_user_certs pkc_check_cert_against_trustlist ** ERROR **"));
  return (-1);
}  /* end of process_ca_user_certs */

/* ************************************************** */

unsigned32 process_cross_certs(pkc_trust_list_t *partial, 
			 x500name  & ca, 
                         int is_ca,
			 x500name &ca_cert_dir,
			 direction flag,
			 int depth,
                         struct ca_db_entry **cainfo_p,
                         int step_count)
{
  unsigned32 status, status1, status2;
  Certificate cert1, cert2;
  const xds_attribute_t *attr_result = 0;
  xds_read_result_t *result = 0;
  const xds_value_t *value_result = 0;

  unsigned char *asn1_cert1_p = 0, *asn1_cert2_p = 0;
  unsigned char  *asn1_cross_cert_p = 0;
  size_t length = 0, asn1_length = 0, asn2_length = 0;
  int cert1_present, cert2_present;
  x500name cert1_issuer, cert1_subject, cert2_issuer, cert2_subject;
  int cert1_is_ancestor,  cert1_is_descendant, cert1_is_equal,
      cert1_is_sibling, cert1_depth_difference,
     cert2_is_ancestor,  cert2_is_descendant, cert2_is_equal,
      cert2_is_sibling, cert2_depth_difference;

  DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug9,
    ">process_cross_certs"));

  DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
    ">process_cross_certs ca = %s", convert_x500name_to_printable_form(ca)));
  DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
    ">process_cross_certs ca_cert_dir = %s", convert_x500name_to_printable_form(ca_cert_dir)));

  // first, read the x500 certificate attribute values 
  // there should only be one attribute, with possibly multiple values returned
  // where the attribute identifies this to be a certificate attribute, and the
  // individual values correspond to the one or more cross-certificates.

  // even though, strictly speaking, both for ca and user, cross cert oid
  // is same, we have made provision for read_xds_cross_cert.. to 
  // to take in is_ca, just in case we find that the standard specifes
  // otherwise.
  result = read_xds_cross_certificate_attribute(ca_cert_dir, is_ca, &status);
  if (status != 0 || result == 0) {
    return 0; 
  }

  status = result->get_first_attribute(attr_result); // we only have one attribute.
  if (status != 0 || attr_result == 0) {
    delete result;
    return 0;
  }

  status = attr_result->get_first_value(value_result); //get the first value
  if (status != 0 || value_result == 0) {
    delete result;
    return 0; 
  }


  status = value_result->get_value(asn1_cross_cert_p, length);  // get the asn1 encoding in value
  if (status != 0 || length == 0 || asn1_cross_cert_p == 0) {
    DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
      "process_cross_certs get_value failed %ld", status));
    delete result;
    return 0;  // actually a problem, in that, there is value, but zero bytes in value.
  }
  

  while (1) {



    status = construct_cross_certificate(asn1_cross_cert_p,length,
				  cert1_present, 
                                 &asn1_cert1_p, asn1_length, 
                                cert1, 
                                cert2_present,
                                 &asn1_cert2_p, asn2_length,
                               cert2);

    if (status != 0)  { // problem creating certificate

      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
        "process_cross_certs construct_cross_certificate failed %ld", status));

      goto next_cross_cert;
    }

    if (cert1_present) {    
        cert1_subject = cert1.certificateInfo.subject;
        cert1_issuer = cert1.certificateInfo.issuer;
        status = determine_relation(cert1_issuer, cert1_subject, cert1_is_ancestor,
                                cert1_is_descendant, cert1_is_equal,
                               cert1_is_sibling, cert1_depth_difference);
        if (status != 0) {
          if (asn1_cross_cert_p)  
             pkc_free (asn1_cross_cert_p);
          if (asn1_cert1_p)  
             pkc_free (asn1_cert1_p);
          if (asn1_cert2_p)  
             pkc_free (asn1_cert2_p);
         delete result;
         return status;
        }
    }

    if (cert2_present) {    
        cert2_subject = cert2.certificateInfo.subject;
        cert2_issuer = cert2.certificateInfo.issuer;

        status = determine_relation(cert2_issuer, cert2_subject, cert2_is_ancestor,
                                cert2_is_descendant, cert2_is_equal,
                               cert2_is_sibling, cert2_depth_difference);
        if (status != 0) {
          if (asn1_cross_cert_p)  
             pkc_free (asn1_cross_cert_p);
          if (asn1_cert1_p)  
             pkc_free (asn1_cert1_p);
          if (asn1_cert2_p)  
             pkc_free (asn1_cert2_p);
          delete result;
          return status;
        }
    }



    switch (flag) {

    // ***************************************************
    // ********************* UP **************************
    // ***************************************************

    case up:


      // first check if the certificate can be added to the cross
      // cert database of the subject. 
      // for this to work, we tolerate a cross certificate only if
      // issuer == ca, & issuer is a sibling of subject && 
      // step_count == FIRST_TIME.
      // any other type of cross cert is ignored. If the check 
      // passes, we add this cross cert in the subject's cross-cert
      // database entry.

     if ((cert1_present) &&
         (ca == cert1_issuer) &&
         (cert1_is_sibling) && (step_count == FIRST_TIME)) {
        	unsigned char *princ = 0;        
	        status = convert_x500name_to_string(cert1_subject, princ);
               if (status != 0) {
                 if (asn1_cross_cert_p)  
                    pkc_free (asn1_cross_cert_p);
                 if (asn1_cert1_p)  
                    pkc_free (asn1_cert1_p);
                 if (asn1_cert2_p)  
                    pkc_free (asn1_cert2_p);
                  delete result;
                  return status;
               }
               status = add_ca_and_cert_to_crdb((char *)princ, asn1_cert1_p, asn1_length, cainfo_p);
              if (status != 0) {
                if (asn1_cross_cert_p)  
                  pkc_free (asn1_cross_cert_p);
                if (asn1_cert1_p)  
                  pkc_free (asn1_cert1_p);
                if (asn1_cert2_p)  
                  pkc_free (asn1_cert2_p);
                delete result;
                return status;
              }
              pkc_free (princ);
     }  /* cross cert whose subject is a sibling and issuer==ca */

     if ((cert2_present) &&
         (ca == cert2_issuer) &&
         (cert2_is_sibling) && (step_count == FIRST_TIME)) {

        	unsigned char *princ = 0;        
	        status = convert_x500name_to_string(cert2_subject, princ);
               if (status != 0) {
                  if (asn1_cross_cert_p)  
                    pkc_free (asn1_cross_cert_p);
                  if (asn1_cert1_p)  
                    pkc_free (asn1_cert1_p);
                  if (asn1_cert2_p)  
                    pkc_free (asn1_cert2_p);
                  delete result;
                  return status;
               }
               status = add_ca_and_cert_to_crdb((char *)princ, asn1_cert2_p, asn2_length, cainfo_p);
              if (status != 0) {
                if (asn1_cross_cert_p)  
                  pkc_free (asn1_cross_cert_p);
                if (asn1_cert1_p)  
                  pkc_free (asn1_cert1_p);
                if (asn1_cert2_p)  
                  pkc_free (asn1_cert2_p);
                delete result;
                return status;
              }
              pkc_free (princ);
     }  /* cross cert whose subject is a sibling and issuer==ca */

      // the same way we tolerate cross-certs in ca-cert-oid's,
      // we also tolerate ca-cert's in cross-cert-oids.
      // so now, we check whether either of the cross certs are
      // up certs. If so, we need to process them in two steps
      // similar to the up certs.. Note that we don't store
      // these in cross-cert database, as that is just a database
      // for certs whose  subjects  may be looked up during downward
      // traversal.
    
     if ((cert1_present) &&
         (ca == cert1_subject) && (cert1_is_descendant) && 
         (cert1_depth_difference <=  depth) &&  (step_count == FIRST_TIME)) {
           status1 = pkc_check_cert_against_trustlist(partial, &cert1, 1);
             DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
               "process_cross_certs pkc_check_cert_against_trustlist failed %ld", status1));
     }

     if ((cert2_present) &&
         (ca == cert2_subject) && (cert2_is_descendant) && 
         (cert2_depth_difference <=  depth) && (step_count == FIRST_TIME)) {
           status1 = pkc_check_cert_against_trustlist(partial, &cert2, 1);
             DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
               "process_cross_certs pkc_check_cert_against_trustlist failed %ld", status1));
     }

     if ((cert1_present) &&
         (ca == cert1_issuer) && (cert1_is_descendant) && 
         (cert1_depth_difference <=  depth) && (step_count == SECOND_TIME)) {
           status1 = pkc_check_cert_against_trustlist(partial, &cert1, 1);
             DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
               "process_cross_certs pkc_check_cert_against_trustlist failed %ld", status1));
     }

     if ((cert2_present) &&
         (ca == cert2_issuer) && (cert2_is_descendant) && 
         (cert2_depth_difference <=  depth) && (step_count == SECOND_TIME)) {
           status1 = pkc_check_cert_against_trustlist(partial, &cert2, 1);
             DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
               "process_cross_certs pkc_check_cert_against_trustlist failed %ld", status1));
     }

   break;

    // *****************************************************
    // ******************  DOWN  ********************************
    // *****************************************************
    case down:

      // check validity of cross cert and location before
     // trying to add the certificate
   
      // the same way we tolerate cross-certs in ca-cert-oid's,
      // we also tolerate ca-cert's in cross-cert-oids.
      // so now, we check whether either of the cross certs are
      // down certs. If so, we need to process them in two steps
      // similar to the up certs.. 

    if (cert1_present && 
         (cert1_is_sibling || (cert1_is_ancestor &&
                               (cert1_depth_difference <= depth))) &&
        (cert1_subject == ca) && (step_count == FIRST_TIME)) {


	status1  = pkc_check_cert_against_trustlist (partial, &cert1, 1);

        DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
          "process_cross_certs pkc_check_cert_against_trustlist failed %ld", status1));

      }

    if (cert2_present && 
        (cert2_is_sibling || (cert2_is_ancestor &&
                (cert2_depth_difference <=  depth))) &&
        (cert2_subject == ca) && (step_count == FIRST_TIME)) {


	status2  = pkc_check_cert_against_trustlist (partial,  &cert2, 1);

        DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
          "process_cross_certs pkc_check_cert_against_trustlist failed %ld", status2));


      }

    // now, steps for second time... Since we now proecss certs
    // fow which the entry is the issuer, we don't need to check
    // for sibling relationshiops.. We just check if this is a misplaced
    // down certificate and honor it if all other checks pass..
    if (cert1_present && 
         cert1_is_ancestor && (cert1_depth_difference <= depth) &&
        (cert1_issuer == ca) && (step_count == SECOND_TIME)) {


	status1  = pkc_check_cert_against_trustlist (partial, &cert1, 1);

        DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
          "process_cross_certs pkc_check_cert_against_trustlist failed %ld", status1));

      }

    if (cert2_present && 
        cert2_is_ancestor && (cert2_depth_difference <=  depth) &&
        (cert2_issuer == ca) && (step_count == SECOND_TIME)) {


	status2  = pkc_check_cert_against_trustlist (partial,  &cert2, 1);

        DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
          "process_cross_certs pkc_check_cert_against_trustlist failed %ld", status2));


      }
    
    

   break;

   default:  /* should never come here */
     DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
       "process_cross_certs  ** ERROR **"));
   return (-1);
  } /* end of switch statement */





next_cross_cert:
    if (asn1_cross_cert_p)  
       pkc_free (asn1_cross_cert_p);
    if (asn1_cert1_p)  
       pkc_free (asn1_cert1_p);
    if (as

CR Number                     : 13675
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : pkc
Short Description             : pkc_api.h has C++ comments
Reported Date                 : 12/3/96
Found in Baseline             : 1.2.2b5
Found Date                    : 12/3/96
Severity                      : B
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : pkc_api.h
Diff supplied by              : provider
Diff release                  : 1.2.2b5
Sensitivity                   : public

[12/3/96 public]

File pkc_api.h, the Certification API header file, contains some comments
using the C++ comment syntax (i.e. introduced by "//").  This header is
intended for use with either C or C++, so these comments must be changed
to use C syntax.

Diffs as below ("<" denotes current file, ">" denotes fixes)

188,190c188,190
<    UNTRUSTED,     // No trust (e.g. unauthenticated)
<    DIRECT_TRUST,  // Direct trust via third party (e.g. authenticated registry
)
<    CERTIFIED_TRUST    // Trust certified by caller's trustbase.
---
>    UNTRUSTED,     /* No trust (e.g. unauthenticated) */
>    DIRECT_TRUST,  /* Direct trust via third party (e.g. authenticated registry
) */
>  CERTIFIED_TRUST    /* Trust certified by caller's trustbase. */
198,201c198,202
<   trust_type_t trust_type;  // The style of trust
<   char missing_crls;      // True if one or more CRLs were missing
<   char revoked;             // True if any certificate has been revoked (even
<                             // if it were still valid at the retrieval time).
---
>   trust_type_t trust_type;  /* The style of trust */
>   char missing_crls;      /* True if one or more CRLs were missing */
>   char revoked;             /* True if any certificate has been revoked (even
>                              * if it were still valid at the retrieval time).
>                              */



CR Number                     : 13674
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : klist
Short Description             : klist misprints years >= 2000
Reported Date                 : 12/2/96
Found in Baseline             : 1.1
Found Date                    : 12/2/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/krb5/clients/klist/klist.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[12/2/96 public]

Dates are printed by klist using the format %02d for a struct tm tm_year
field, which causes 2001 to print as 101, and so on.  Dates are also in the
format YY/MM/DD:HH:MM:SS, which is not A Good Thing.

The diff included here changes the format to YYYY-MM-DD-HH:MM:SS, which
conforms to the DTS format as described in Appendix D of the Admin Guide -
Core Components.

*** security/krb5/clients/klist/klist.c
--- 13.2	1996/12/02 16:27:20
***************
*** 277,284 ****
      struct tm *stime;
      stime = localtime((time_t *)&tv);
  
!     printf("%02d/%02d/%02d:%02d:%02d:%02d",
!            stime->tm_year,
             stime->tm_mon + 1,
             stime->tm_mday,
             stime->tm_hour,
--- 298,305 ----
      struct tm *stime;
      stime = localtime((time_t *)&tv);
  
!     printf("%04d-%02d-%02d-%02d:%02d:%02d",
!            stime->tm_year + 1900,
             stime->tm_mon + 1,
             stime->tm_mday,
             stime->tm_hour,



CR Number                     : 13673
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : psm
Short Description             : DCE client requires C++ runtime
Reported Date                 : 11/26/96
Found in Baseline             : 1.2.2b5
Found Date                    : 11/26/96
Severity                      : D
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/psm/Makefile, security/psm/domestic/sec_pvtkey_registered_keystores.c
Diff supplied by              : provider
Diff release                  : 1.2.2b5
Sensitivity                   : public

[11/26/96 public]

Currently, the DCE 1.2.2 runtime requires the presence of a C++ runtime.  
This is because the PKSS client-side is written in C++, and the PSM contains
an array of entrypoint vectors (one for each keystore), one of which points
to PKSS entrypoints.  While C++ runtimes aren't uncommon, this OT documents
a way of lifting this restriction (at the cost of eliminating PKSS support).


security/psm/domestic/sec_pvtkey_registered_keystores.c:
--------------------------------------------------------

On line ~74, the code:
> #ifdef HPUX
should be changed to:
> #if defined(HPUX) || defined(NO_PKSS)

security/psm/Makefile:
----------------------

On line ~315, after the line:
> CFLAGS  = -DOSF_DCE ${DCEPATHS} -D_BSD -DBSD ${${TARGET_MACHINE}_CFLAGS}
insert the line:
> CFLAGS += -DNO_PKSS



CR Number                     : 13672
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : Adopting orphans should be
protected separately from creating principals.
Reported Date                 : 11/20/96
Found in Baseline             : 1.1
Found Date                    : 11/20/96
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/20/96 public]

This is from Tyson Richmond(GTE): he is worried about the ability of an
admin to adopt orphans. He thinks that "relatively weakly empowered" admins
would have too much power since they would be able to adopt orphaned UUIDs
with "large" permission sets since it is difficult to find all the ACL
instances and expunge them. I suggested the usual precaution of (only)
using groups in ACLs, but in addition to that, he would like to see the
ability of an admin to adopt orphaned UUIDS, to be controlled by an
additional ACL permission, e.g on the principal, group and org directories.



CR Number                     : 13671
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : CertAPI
Short Description             : pkc_get_registered_policies API call not tested
Reported Date                 : 11/18/96
Found in Baseline             : 1.2b5
Found Date                    : 11/18/96
Severity                      : D
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/test/security/api/capi/Makefile, src/test/security/api/capi/grp_test.cxx (new file)
Diff supplied by              : provider
Diff release                  : 1.2b5
Sensitivity                   : public

[11/18/96 public]
When compiling our API coverage results for the Certification API,
we found that the convenience routine pkc_get_registered_policies 
is not being tested.  This OT supplies a stand-alone test for
this routine.

----------------------------------------------------------------
src/test/security/api/capi/Makefile must be modified as follows:
----------------------------------------------------------------
At the end of the file, change the lines:

>test_registry_OFILES = test_registry.o trycase_helper.o
>trycase_a_OFILES = trycase_a.o cds_help_a.o trycase_helper.o
>PROGRAMS = trycase_a test_registry
>
>.include <${RULES_MK}>

to the following:

>test_registry_OFILES = test_registry.o trycase_helper.o
>trycase_a_OFILES = trycase_a.o cds_help_a.o trycase_helper.o
>grp_test_OFILES = grp_test.o
>PROGRAMS = trycase_a test_registry grp_test
>
>.include <${RULES_MK}>

----------------------------------------------------------------
Add new file src/test/security/api/capi/grp_test.cxx as follows:
----------------------------------------------------------------
extern "C" {
#include <stdio.h>
#include <stdlib.h>
}
#include <dce/pkc_api.h>

int main(int argc, char * argv[]) {


   unsigned32 status;
   gss_OID_set oid_set;
   gss_OID plcy;
   int i;
   int reg_plcy_found = 0;
   int hier_plcy_found = 0;

   status = pkc_get_registered_policies(&oid_set);

   if (status) {
      fprintf(stderr,
              "pkc_get_registered_policies returned 0x%x\n",
              status);
      fprintf(stderr, "!!!!!!!!!!Test failed!!!!!!!!!!\n");
      return EXIT_FAILURE;
   };

   fprintf(stdout,
           "pkc_get_registered_policies returned %d policies\n",
           oid_set->count);

   if (oid_set->count != 2) {
      fprintf(stderr, "Expecting 2\n");
      fprintf(stderr, "!!!!!!!!!!!Test failed!!!!!!!!\n");
      return EXIT_FAILURE;
   };

   for (i=0;i<2;i++) {

      plcy = &((oid_set->elements)[i]);

      if (plcy->length != 4) {
          fprintf(stderr,
                  "Length of policy OID %d is %d, expecting 4\n",
                  i, plcy->length);
          fprintf(stderr, "!!!!!!Test failed!!!!!!\n");
          return EXIT_FAILURE;
      };

      if (((unsigned char *)(plcy->elements))[0] != 0x2b) {
          fprintf(stderr,
             "First octet of policy %d is 0x%2.2x, expecting 0x2b\n",
             i, ((unsigned char *)(plcy->elements))[0]);
          fprintf(stderr, "!!!!!!!!!Test failed!!!!!!!!!\n");
          return EXIT_FAILURE;
      };
      if (((unsigned char *)(plcy->elements))[1] != 0x18) {
          fprintf(stderr,
             "Second octet of policy %d is 0x%2.2x, expecting 0x2b\n",
             i, ((unsigned char *)(plcy->elements))[1]);
          fprintf(stderr, "!!!!!!!!!Test failed!!!!!!!!!\n");
          return EXIT_FAILURE;
      };
      if (((unsigned char *)(plcy->elements))[2] != 0x09) {
          fprintf(stderr,
             "Third octet of policy %d is 0x%2.2x, expecting 0x2b\n",
             i, ((unsigned char *)(plcy->elements))[2]);
          fprintf(stderr, "!!!!!!!!!Test failed!!!!!!!!!\n");
          return EXIT_FAILURE;
      };
      if (((unsigned char *)(plcy->elements))[3] == 0x0c) {
          fprintf(stdout,
                  "Policy %d is DCE-HIERARCHY\n", i);
          hier_plcy_found++;
      } else if (((unsigned char *)(plcy->elements))[3] == 0x0d) {
         fprintf(stdout,
                 "Policy %d is DCE-REGISTRY\n", i);
         reg_plcy_found++;
      } else {

         fprintf(stderr, "Final octet of policy %d is %2.2x\n",
                 i,((unsigned char *)(plcy->elements))[3]);
         fprintf(stderr, "Expecting 0x0c or 0x0d\n");
         fprintf(stderr, "!!!!!!!!Test failed!!!!!!\n");
         return EXIT_FAILURE;
      };
   };

   if ((reg_plcy_found != 1) || (hier_plcy_found != 1)) {
      fprintf(stderr, "Error - incorrect policy registrations:\n");
      fprintf(stderr,
              "Registry policy found %d times (should be 1)\n",
              reg_plcy_found);
      fprintf(stderr,
              "Hierarchy policy found %d times (should be 1)\n",
              hier_plcy_found);
      fprintf(stderr, "!!!!!!!!Test failed!!!!!!!!\n");
      return EXIT_FAILURE;
   };
   fprintf(stdout, "pkc_get_registered_policies test succeeded\n");
   return EXIT_SUCCESS;

}

--------------------------------------------------------------------------
Running the test
--------------------------------------------------------------------------

This new test does not run under tet.  To run the test, set your working
directory to obj/<platform>/test/security/api/capi and execute "grp_test".
A successful run will result in the following output to stdout:

>pkc_get_registered_policies returned 2 policies
>Policy 0 is DCE-REGISTRY
>Policy 1 is DCE-HIERARCHY
>pkc_get_registered_policies test succeeded

Any test failures will print diagnostic messages on stderr, finishing with
a line of the form:

>!!!!!!!!Test Failed!!!!!!!!

Successful test run will also return 0 to the shell; a test failure will
return EXIT_FAILURE.



CR Number                     : 13664
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : certapi
Short Description             : crypto switch broken
Reported Date                 : 11/8/96
Found in Baseline             : 1.2.2b5
Found Date                    : 11/8/96
Severity                      : B
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : pkc_crypto_reg.cxx,
                                             pkc_crypto_alg_rsamd2.cxx
                                             pkc_crypto_alg_rsamd5.cxx
                                             pkc_crypto_alg_rsamd5.h
                                             pkc_crypto_preload.cxx
Diff supplied by              : provider
Diff release                  : 1.2.2b5
Sensitivity                   : public

[11/8/96 public]
The two certificate signature algorithms supported by the certification API
(RSA-with-MD2 and RSA-with-MD5) are registered with incorrect OIDs.  This
should have the effect of breaking interoperability with certificates created
by other (non-DCE-based) certification authorities.  However, there is also
a bug in the switch code itself that always directs signature verification
operations to the MD2 module, regardless of the signature algorithm specified
in the certificate.

[11/12/96 public]
The fixes are as follows:

--------------------------------------------------------
File security/pkc/capi/crypto/pkc_crypto_alg_rsamd2.cxx:
--------------------------------------------------------
Line ~56:
The array rsa_md2_oid should be declared as follows:

>  unsigned char rsa_md2_oid[9] = {
>     0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x02
>  };

--------------------------------------------------------
File security/pkc/capi/crypto/pkc_crypto_alg_rsamd5.cxx:
--------------------------------------------------------
Line ~56:
The array rsa_md5_oid should be declared as follows:

>  unsigned char rsa_md5_oid[9] = {
>     0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x04
>  };

--------------------------------------------
File security/pkc/h/pkc_crypto_alg_rsamd5.h:
--------------------------------------------
Line ~18:

The two lines:

>#ifndef PKC_CRYPTO_ALG_RSAMD2_
>#define PKC_CRYPTO_ALG_RSAMD2_
 
should be changed to:

>#ifndef PKC_CRYPTO_ALG_RSAMD5_
>#define PKC_CRYPTO_ALG_RSAMD5_
 

-------------------------------------------------
File security/pkc/capi/crypto/pkc_crypto_reg.cxx:
-------------------------------------------------
Line ~245, constructor for pkc_signature_algorithm_int_t:

Replace the lines:

>        state = ALG_CLOSED;
>        next = NULL;
>        prev = NULL;
>        implementation = *imp;
 
with:

>        state = ALG_CLOSED;
>        implementation = *imp;


 
Line ~266, routine find_alg:
The following code:

>    done = ((algorithm = algorithm_list) != NULL);
>
>    while (!done) {
>        if (algorithm->check(oid)) done = 1;

should be replaced with:

>    done = ((algorithm = algorithm_list) == NULL);
>
>    while ((algorithm != NULL) && !done) {
>        if (algorithm->check(oid)) done = 1;


-----------------------------------------------------
File security/pkc/capi/crypto/pkc_crypto_preload.cxx:
-----------------------------------------------------

The initialiser for the array pkc_preloaded_algorithms 
at line ~56 should be changed from:

>pkc_signature_algorithm_t * pkc_preloaded_algorithms[] = {
>    &pkc_crypto_alg_rsamd2,
>    &pkc_crypto_alg_rsamd2,
>    NULL
>};

to:

>pkc_signature_algorithm_t * pkc_preloaded_algorithms[] = {
>    &pkc_crypto_alg_rsamd2,
>    &pkc_crypto_alg_rsamd5,
>    NULL
>};



CR Number                     : 13663
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : gssapi
Short Description             : Makefile invokes SAMS wrong
Reported Date                 : 11/7/96
Found in Baseline             : 1.2.2
Found Date                    : 11/7/96
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/7/96 public]

The Makefile in security/gssapi is wrong.  It has
	${DEFTOOLBASE}sams ...
When it should be
	${SAMS} ...

[11/8/96 public]

Actually, no, it shouldn't invole SAMS directly, it should set SAMSFILES
and put the files it wants to build in OTHERS...

[11/08/96 public]
Oops, yeah.   That would also solve the overkill that it currently has
of generating *all* the sams output files... :)



CR Number                     : 13648
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_login API
Short Description             : Need means of changing expired passwd
Reported Date                 : 10/03/96
Found in Baseline             : 1.1
Found Date                    : 10/03/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/4/96 public]
"What we really need here is an API call to change an expired password, passing
in the old password and new one, and that could return an error if the old
password was incorrect.  This API should not require you to have credentials
to do the password change, because you can't get credentials with an expired
password.  This type of call is really necessary to make integrated login
programs work in the face of password expiration policy (now enforced as of
DCE1.1)."

[10/4/96 public]
BTW, I forgot to mention that this should not be implemented without an
accompanying policy switch that lets the administrator disable the changing
of expired passwords without an identity (since some administrators are
too paranoid to allow that to happen without their intervention).

BTW, the Fixby 1.2 above is only because OT is being extremely annoying and
not accepting anything else for the Fixby field.  For an enhancement
(especially after 1.2 is frozen), this is ridiculous.



CR Number                     : 13646
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : DCE ACL library
Short Description             : DCE ACL library can't support owning USER/GROUP
Reported Date                 : 10/2/96
Found in Baseline             : 1.1
Found Date                    : 10/2/96
Severity                      : A
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : dce/utils/acldb/aclimpl.c,dce/utils/misc/lib.sams, admin/dced/libdcedpvt/acls.c
Diff supplied by              : provider
Diff release                  : 1.2
Sensitivity                   : public

[10/2/96 public]

There's a bug open here that you can use dce_rdacl_replace() to set a
user_obj or group_obj entry on an ACL, but after that point, can never
update the ACL again (because evaluating an ACL with a user_obj or group_obj
entry requires the ACL manager providing the owner and group owner UUIDs,
and it looks like provisions for doing so were never accounted for when
the DCE ACL library was implemented (can't get them through the resolver
and none of the ACL DB code knows anything about them).

The short term fix is not to allow Apps to specify that owners or owning
groups (dce_acl_c_has_owner and/or dce_acl_c_has_groups, the latter of which
is really ambiguous and should probably be changed at some point).  We're
fixing it here by adding a new acl_s_ error: acl_s_owners_not_implemented
and having dce_acl_register_object_type() return this new error if either
of those flags is specified.  This will prevent apps from running into the
other problems encountered because the library can't support owners yet.
We'll supply the diffs here as soon as we have a fix tested.

I'll open another OT (enhancement) with Rich Salz's and my suggestions for
how to fix this (by providing new support) in a post 1.2.2 release.

[10/10/96 public]
Here are the diffs for the fix based on the HP DCE product release,
so they may not match line number for line number with the 1.2 release.

********************************
<<< file 1:
/vob/dce/src/dce/utils/acldb/aclimpl.c@@/main/HPDCE02/elley_CHFts19
775/0
>>> file 2: aclimpl.c
********************************
-----[after 108 inserted 109-119]-----
>
>     /* The DCE ACL library does not yet support user/group ownership of
>      * objects. If an ACL manager that supports user/group ownership
>      * attempts to register, an error is returned. This check can be
>      * removed after support for ownership is implemented.
>      */
>     if ((flags & dce_acl_c_has_owner) || (flags & dce_acl_c_has_groups)){
>       *st = acl_s_owners_not_implemented;
>       return;
>     }
>
-----[after 423 inserted 435]-----
>
********************************
<<< file 1:
/vob/dce/src/dce/utils/misc/lib.sams@@/main/HPDCE02/elley_CHFts1977
5/0
>>> file 2: lib.sams
********************************
-----[after 463 inserted 464-476]-----
>
> start
> code          acl_s_owners_not_implemented
> text          "User_obj and group_obj ACL entries are not supported yet"
> explanation   "In a dce_acl_register_object_type operation an attempt was
>                made to register an ACL manager that supports user/group
>                ownership while the DCE ACL library does not support this
>                ownership yet."
> action                "Modify code in the ACL manager until support for
owners
hip
>                is implemented."
> end
>
>
********************************
<<< file 1:
/vob/dce/src/admin/dced/libdcedpvt/acls.c@@/main/HPDCE02/elley_CHFt
s19775/0
>>> file 2: acls.c
********************************
-----[716 changed to 716]-----
<       dced_resolve_object, NULL, dce_acl_c_has_owner, st);
---
>       dced_resolve_object, NULL, 0, st);
-----[722 changed to 722]-----
<       dced_resolve_object, NULL, dce_acl_c_has_owner, st);
---
>       dced_resolve_object, NULL, 0, st);
-----[728 changed to 728]-----
<       dced_resolve_object, NULL, dce_acl_c_has_owner, st);
---
>       dced_resolve_object, NULL, 0, st);
-----[734 changed to 734]-----
<       dced_resolve_object, NULL, dce_acl_c_has_owner, st);
---
>       dced_resolve_object, NULL, 0, st);
-----[740 changed to 740]-----
<       dced_resolve_object, NULL, dce_acl_c_has_owner, st);
---
>       dced_resolve_object, NULL, 0, st);



CR Number                     : 13645
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : sec
Subcomponent Name             : sec_login
Short Description             : sec_rgy_unix_getpw*() return incorrect results
Reported Date                 : 10/02/96
Found in Baseline             : 1.2.2
Found Date                    : 10/02/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : private

[10/3/96 private]
    The code for testing override flags while creating a unix password
    entry was incorrect. The user visible effect of this error is:

        If more than one field in a passwd entry was overridden
        sec_rgy_unix_getpwnam() and sec_rgy_unix_getpwuid()
        would return incorrect results.


diffs for file security/client/rca/unix.c
- -----------------------------------------

10a11,13
>  * Revision /main/hinxman_override_flags/1  1996/10/02  14:11 UTC  hinxman
>  *    Handling of flags in rgy_override_entry
>  * 
493c496
<         if (*overridden == sec_override_pw_passwd) {
- ---
>         if (FLAG_SET(*overridden, sec_override_pw_passwd)) {
497c500
<         if (*overridden == sec_override_pw_gecos) {
- ---
>         if (FLAG_SET(*overridden, sec_override_pw_gecos)) {
507c510
<         if (*overridden == sec_override_pw_dir) {
- ---
>         if (FLAG_SET(*overridden, sec_override_pw_dir)) {
517c520
<         if (*overridden == sec_override_pw_shell) {
- ---
>         if (FLAG_SET(*overridden, sec_override_pw_shell)) {



CR Number                     : 13642
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : PK ERAs
Short Description             : Allow ERA aaclmgr permset be updated after creation.
Reported Date                 : 10/02/96
Found in Baseline             : 1.2.2
Found Date                    : 10/27/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : private

[10/3/96 private]
[cuti]
By design, ERA aclmgr permset cannot be changed after creation.  However,
in public key world, there is a need to loosen up this restriction to allowcell admin to be able to change the permset of ERA on site



CR Number                     : 13641
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : PK pvtkey & dcecp
Short Description             : passphrase of bothkey usages' key pair should be the same
Reported Date                 : 09/27/96
Found in Baseline             : 1.2.2
Found Date                    : 09/27/96
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : private

[10/3/96 private]
[cuti 960927]
If two passphrases entered by the cell admin are different during account 
creation or update, then no matter which passphrase the user eneters for 
dce_login, the login will fail.  The reason is dce_login only takes one 
password and we use both key usage's key pair for authentication, if these two

passphrase are different, one of key pairs' private key won't be able to be 
decrypted and public key operation won't succeed, therefore the login will fai
.

There are two fix involved:
1. Check the passphrases of the tow key usages key pair if they are entered in
the samle line in dcecp.
2. In private_key_store/update, if there is already private key existent, use
the new passphrase to test on the old private key, only if the private key can
be decrypted, the passphrase can be used to store the key, otherwise the 
passphrase (pwd in code) will be rejected



CR Number                     : 13640
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : PK login
Short Description             : International build doesn't work
Reported Date                 : 09/26/96
Found in Baseline             : 1.2.2
Found Date                    : 10/01/96
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : private

[10/3/96 private]
Whereever there is a pkc referenced, set ".if defined(USE_DES)" and ".end" around.  Also define NOENCRYPTION for international build in rsdb_acct.o to avoid
undefined symbol, sec_pvtkey__register_pvtkey

I also fix one of dcecp assumption about default value of PK key modulus size.
Dcecp shouldn't assume the value, should just pass in 0 to psm call which will
turn 0 modulus size to default value.

LIST THE SOURCE FILES AFFECTED BY THE CHANGE:

./admin/dcecp/rgy.h
./libdce/Makefile
./libdce/RIOS/machdep.mk
./security/Makefile
./security/psm/international/sec_psm.c
./security/server/rsdb/Makefile
./security/server/rsdb/rsdb_acct.c



CR Number                     : 13639
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : PK preauth
Short Description             : dce_login of PK princ does not work
Reported Date                 : 10/01/96
Found in Baseline             : 1.2.2
Found Date                    : 10/01/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : private

[10/3/96 private]

[10/01/96]
the following test scenario does not work properly:

    dcecp> account create pk_user1 -group none -organization none -mypwd $CELL
PW -password
 pk_passwd -pkmechanism file -pksignature { {gen 512} {newpassphrase pk_passwd

} -pkkeycipher { {gen 512} {newpassphrase pk_passwd} }

    mtet_echo "dce_login_tp1: add  pre_auth_req ERA 3 PADATA-ENC_PUBLIC_KEY to
p
rinc."
    dcecp> principal modify pk_user1 -add {pre_auth_req 3}

    dce_login pk_user1 $PWD -e kdestroy

produces:

Warning: Generating pksignature public key; this may take a few minutes.
Warning: Generating pkkeycipher public key; this may take a few minutes.

Sorry.
Password Validation Failure. - Preauthentication failed (dce / krb)



CR Number                     : 13638
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : secd crashes reading replay log
Reported Date                 : 09/25/96
Found in Baseline             : 1.2.2
Found Date                    : 09/25/96
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : private

[10/3/96 private]
We have reproduced the secd replay log crash that occured a few
months ago. It is now reproducible because we backed up the
security directory. secd is crashing with "registry object
not found" when replaying the log.



CR Number                     : 13635
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : DCE ACL lib
Short Description             : DCE ACL lib dce_rdacl_get_access Broken
Reported Date                 : 9/27/96
Found in Baseline             : 1.1
Found Date                    : 9/27/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/dce/utils/acldb/aclimpl.c
Diff supplied by              : provider
Diff release                  : 1.2
Sensitivity                   : public

[9/27/96 public]

dce_rdacl_get_access() passes in the PAC's user and group as the owner and
group_obj-owner to dce_acl_inq_permset_for_creds(), along with the cred_h.
This is *wrong*, because dce_acl__permset_alg() below these calls is expecting
those args to be the owning user_obj and group_obj uuids of the object that
the ACL is protecting, and will be comparing them against the user and group
it gets from the cred_h passed in (in other words, it's now comparing them
against themselves, which will always return true).

For now, since the DCE ACL library can't possibly support user_obj and group_obj
(see the next OT, I'll be opening in a few minutes), dce_rdacl_get_access()
should just pass NULL for these two arguments, so that if a user_obj or
group_obj entry exists (via the other bug), it'll just get an error from this
call rather than an incorrect result.

[10/14/96 public]
Here are the diffs for the fix based on the HP DCE product release,
so they may not match line number for line number with the 1.2 release.
Again, note that these diffs will yield an error from this call rather
than an incorrect result. The underlying problem (that the DCE ACL library
doesn't support user_obj and group_obj ACL entries) is not fixed by
these diffs.

*** aclimpl.c#1 Thu Oct 10 16:58:55 1996
--- aclimpl.c   Thu Oct 10 17:30:18 1996
***************
*** 492,500 ****
      rpc_authz_cred_handle_t   cred_h;
      acl_mgt_t                 *am_info;
      sec_acl_result_t          result;
!     sec_cred_pa_handle_t      *cred_pa;
!     sec_id_pa_t                       *pa_p;
!
      *st = error_status_ok;
      *net_rights = dce_acl_c_no_permissions;   /* default perms - none */

--- 495,501 ----
      rpc_authz_cred_handle_t   cred_h;
      acl_mgt_t                 *am_info;
      sec_acl_result_t          result;
!
      *st = error_status_ok;
      *net_rights = dce_acl_c_no_permissions;   /* default perms - none */

***************
*** 515,532 ****
        UNLOCK;
        return;
      }
!
!     /* Find who the caller is - we need the prin/group in case there are
!      * user_obj and group_obj ACLEs */
!     cred_pa = sec_cred_get_initiator(cred_h, st);
!     STAT_CHECK_RET_UNLOCK(*st);
!     pa_p = sec_cred_get_pa_data(cred_pa, st);
!     STAT_CHECK_RET_UNLOCK(*st);
!
      /* Compare ACL with PAC, determining permissions. */
      dce_acl_inq_permset_for_creds(cred_h,
!           result.tagged_union.sec_acl_list->sec_acls[0],
!           &pa_p->principal.uuid, &pa_p->group.uuid,
            sec_acl_posix_no_semantics, net_rights, st);
      STAT_CHECK_RET_UNLOCK(*st);

--- 516,525 ----
        UNLOCK;
        return;
      }
!
      /* Compare ACL with PAC, determining permissions. */
      dce_acl_inq_permset_for_creds(cred_h,
!           result.tagged_union.sec_acl_list->sec_acls[0],NULL,NULL,
            sec_acl_posix_no_semantics, net_rights, st);
      STAT_CHECK_RET_UNLOCK(*st);



CR Number                     : 13633
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : error msg catalog
Short Description             : Wrong explanation for two acl err msgs
Reported Date                 : 9/27/96
Found in Baseline             : 1.1
Found Date                    : 9/27/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/security/idl/sec.sams
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/27/96 public]

The following explanations and actions are wrong (backwards).  The error
occurs when an ACL manager finds a user_obj or group_obj entry, but cannot
determine who the owner is (was not passed the correct information), and thus
cannot determine whether the acl entry applies to this caller or not.  I
can't come up with a great explanation at this time, but something more like:
ACL contains a user_obj entry, but owner cannot be determined
would be closer to reality.  The only action that makes sense in this case is
to log a bug against the ACL manager that caused this problem and get it fixed.
ACL managers that allow user_obj or group_obj entries to be set on ACLs that
they control, must also provide owner information for each ACL evaluation call.
If they cannot, then they should reject user_obj and group_obj entries on
rdacl_replace calls with the error: sec_acl_invalid_entry_type
(unfortunately, this can't tell the caller which entry type was bad;  With
almost 20-20 hindsight, I can say we should have provided feedback in one of
the pre-calls (sec_acl_get_manager_types()?) that specified what ACL entry types
the manager supported).

start
code    sec_acl_expected_user_obj
text    "acl operation expected user_obj"
explanation    "Object has an owner but no user_obj entry contained in its ACL."
action         "Add a user_obj entry to the ACL, then retry the operation."
end

start
code    sec_acl_expected_group_obj
text    "acl operation expected group_obj"
explanation    "Object has an owning group but no group_obj entry in its ACL."
action         "Add a group_obj entry to the ACL, then retry the operation."
end



CR Number                     : 13613
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : login
Short Description             : Allow AFS principals to migrate to DCE via Krb5 Beta6 AFS string_to_key()
Reported Date                 : 8/21/96
Found in Baseline             : 1.2.1
Found Date                    : 8/21/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/21/96 public]

Doug Engert has suggested the following enhancement to allow AFS principals
to migrate to DCE without changing their passwords. Doug writes:

I see that the K5b6 has a afsstring2key.c routine which is only called
from the string2key.c. In string2key.c the comments refer to "cheating"
by calling the afstring2key.c if the salt length is -1.  The use of a
-1 for a salt length may have many other consequences, and
ramifications to the code in different places. 

I would like to suggest an additional method of "cheating" be added, so if
the salt starts with the string "AFS:" that the rest of the string is
interpreted as the AFS salt, and the afsstring2key.c be called. 

This method is transparent to the rest of the code which deals with
salts, such as preauthentication.

I am using a DCE security server as the KDC, and have successfully
copied keys from our AFS cell "anl.gov" to the DCE security registry
in our DCE cell, "dce.anl.gov". Unlike the K5 database, the DCE
security registry allows the salt to be stored in the entry, and can
be anything, including "AFS:anl.gov".

This presents a nice migration path from AFS to DCE, even when
the realm/cell names differ. The keys can be copied, and users do not
have to change their passwords during the conversion.   

*** ,string2key.c       Tue Apr  9 17:47:24 1996
--- string2key.c        Tue Aug 20 10:28:49 1996
***************
*** 78,83 ****
--- 78,104 ----
      key = keyblock->contents;
  
      if (salt) {
+         /* ANL Change */
+         /* we can store AFS keys in DCE, and set the salt such that 
+          * it is preceeded by AFS:
+          * If so, pass the rest of the salt to the afs_string_to_key
+          * But it is cheating, and expecting the salt.data to be a
+          * null terminated string. This may not be the case from DCE.
+          */
+         if ((salt->length >= 4) && !memcmp(salt->data,"AFS:",4)) {
+               krb5_data afssalt;
+               krb5_error_code ret;
+               afssalt.length = salt->length - 4;
+               afssalt.data = (char*)malloc(afssalt.length+1);
+               if (!afssalt.data)
+                       return(ENOMEM);
+               memcpy(afssalt.data,salt->data + 4,afssalt.length);
+               afssalt.data[afssalt.length] = '\0'; /* make it a string */
+               ret = mit_afs_string_to_key (eblock, keyblock, data, &afssalt);
+               free(afssalt.data);
+               return(ret);
+         } else
+               /* end of ANL change */
        if (salt->length == -1) {
        /* cheat and do AFS string2key instead */
        return mit_afs_string_to_key (eblock, keyblock, data, salt);


Another method is to use the new padata type in K5 beta 6, KRB5_PADATA_AFS3_SALT,
which says to use the afsstring2key. This would be another approach to 
doing the same thing. But this requires changes to the server as well. 
This should probable be added at some future time when many of the other 
K5b* code is integrated in.



CR Number                     : 13596
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : login
Short Description             : Cannot dce_login with keys with a zero length salt (pepper)
Reported Date                 : 8/16/96
Found in Baseline             : 1.1
Found Date                    : 8/16/96
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/client/login/sec_login_pvt.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/16/96 public]

Principals with keys that have a zero length pepper cannot validate
their DCE identity. This is a defect. The bug is in the preauthentication
retry code in sec_login_pvt.c. The initial preauth request uses the
default pepper and if that fails, the security server returns the
correct pepper for that account. The preauth code then retries the
request with the correct pepper. However, the following code in
sec_login_pvt.c is in error:

if (memcmp(key->pepper, dce_err_data->contents,
      dce_err_data->length) != 0) {

Since the length will be zero, the memcmp will always return 0, and
the code to try another salt will never be executed.

Principals from a Kerberos 4 database can migrate to DCE without
changing their passwords if you specify a zero length pepper. This
bug currently prevents that.



CR Number                     : 13590
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : command_ref
Short Description             : xattrschema stringarray encoding not handled correctly
Reported Date                 : 8/12/96
Found in Baseline             : 1.1
Found Date                    : 8/12/96
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/16/96 public]
Changing responsible engineer.  This is a guide bug, not 
a manpage bug.  Note also that the typo noticed by rps 
in his quoted excerpt from the app dev guide should also 
be fixed when this CR is fixed.

[8/12/96 public]

One of our support engineers writes:
>SYNOPSIS: cannot use a stringarray in encoding while setting up xattrschema and attaching to a principal.
> 
>To create the xattrschema I am using the following:
> 
>dcecp> xattrschema create /.:/sec/xattrschema/DCRT/MVS/accounts
>-aclmgr {principal r m r D} -encoding stringarray  -trigbind {{dce
>/.:/myers default default dce} {/.:/subsys/dce/sec/master}} -trigtype
>query -uuid dbf933bc-e5a1-11cf-a117-89b
> 
>To attach it to the principal:
> 
>dcecp> principal modify myers -add {DCRT/MVS/accounts present}  
>Error: invalid encoding type specified
>dcecp> principal modify myers -add {DCRT/MVS/accounts {present}}
>Error: invalid encoding type specified
>dcecp> principal modify myers -add {DCRT/MVS/accounts {"present"}}
>Error: invalid encoding type specified
> 
>As you can see, I get an error message.
>myers-Wed, 07 Aug 1996 19:36:25

It's extremely unclear in the documentation how such things should be
added, especially for attributes with query triggers.  The evidence that it
is a code bug rather than a doc bug, however, is as follows.  :)

>From: Rich Salz <rsalz@osf.org>
>Date: Wed, 7 Aug 1996 23:52:36 -0400
>To: Mike_Myers@transarc.com, kgorlen@alw.nih.gov
>Subject: Re: TR25188
>Cc: rsalz@osf.org
>
>This sounds like a bug in the OSF source base -- Mike, please forward
>info along thru your folks (Craig?) so it gets into our bug database.

[8/13/96 public]
App Dev Gd, 28.4.1.1, Query Triggers:

If you execute a sec_rgy_attr() update call with an attribute type that
is associated with a query trigger, not an update trigger, the input
attribute values is [sic] ignored and a "stub" attribute instance is
created on the named object simply to mark the existence of this
attribute on the object.  Modifications to the real attribute value must
occur at the attribute trigger.

At 1.2.1 you should get a better error --

dcecp> princ mod foo -add {accounts present}
Error: updates of query trigger attributes must have encoding type void

Perhaps this deserves mention in the Admin Gd or Command Ref.

[8/16/96 public]
Assigned to HP.



CR Number                     : 13587
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : need rdacl v0.0 for unauth client
Reported Date                 : 8/5/96
Found in Baseline             : 1.1
Found Date                    : 8/5/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/5/96 public]

If a 1.1 server that exports rdacl v1.0 to the endpoint mapper only,
that is, rdacl 1.0 and not rdacl 0.0, then an unauthenticated client
(in this case, dcecp but this also applies to acl_edit) gets the
"Unknown interface" error when you try to view the server's acls,
even though the acls on the namespace entry grant access to the client.
Adding support for the rdacl 0.0 interface in the server makes this
problem go away.  Although the 1.1 endpoint mapper protects its 
entries more carefully than the previous endpoint mapper, it doesn't
seem to make sense that access from an unauthenticated client should
vary so much between the two rdacl interfaces, unless there's an endpoint
mapper acl for the rdacl 1.0 i/f that I'm forgetting to set somewhere.

[8/8/96 public]

On the advise of Mike Burati, changing the component
from 'dcecp' to 'sec'.



CR Number                     : 13565
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : src/test/security/api/moretests
Short Description             : Test cases never run the
intended test
Reported Date                 : 7/9/96
Found in Baseline             : 1.1
Found Date                    : 7/9/96
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/9/96 public]

A support customer reported the following:
==========================================

Area:                   test
Component Name:         sec

Severity Level:         Minor

Date of First Occurrence: 6/13/96

Affected File(s):
    src/test/security/api/moretests/acct_add_del.c
    src/test/security/api/moretests/acct_admin_repl.c
    src/test/security/api/moretests/acct_lookup.c
    src/test/security/api/moretests/acct_passwd.c
    src/test/security/api/moretests/acct_rename.c
    src/test/security/api/moretests/acct_repl_all.c
    src/test/security/api/moretests/acct_user_repl.c

One Line Description: Testcases never run the intended test

Full Description:

    The testcases have a check to validate the setup before running the
    actual test (in most cases).  The validation code is incorrect and
    subsequent error reporting is incorrect.  The net result is that the
    test is never run, but the testcase indicates a successful completion.

----------------------------------------------------------------------------
/* CUT [ SECTION ONE ] */

/* Setup the parameters to the sec_rgy_acct_add function. */

   bzero ((char *)&user_part, sizeof (user_part));

   user_part.passwd_version_number = 1;
   user_part.passwd_dtm = time(NULL);
   user_part.flags = 0;

   memcpy ((char *)user_part.gecos,
       (char *)"marco's test user account\0",
       sizeof (user_part.gecos));

   memcpy ((char *)user_part.homedir,
       (char *)"//node_feb5/marco\0",
       sizeof (user_part.homedir));

   memcpy ((char *)user_part.shell,
       (char *)"/bin/seashell\0",
       sizeof (user_part.shell));

/* CUT */

/* Add the test account. */

   sec_rgy_acct_add (context,

/* CUT */

/* Even if tstatus came back with the normal return on the acct_add
   above, check to see if the account really exists by attempting to
   look it up in the registry.  */

   sec_rgy_acct_lookup (context,

/* CUT  [ SECTION TWO ] */

/* If the lookup fails or if the data supplied as input to acct_add does
   not match the data returned as output from the acct_lookup, then treat
   the acct_add as if it had failed. */

   if ((tstatus != rpc_s_ok)
       || (key_parts != lkp_key_parts)
       || (memcmp ((char *)&admin_part,
                   (char *)&lkp_admin_part,
                   sizeof (sec_rgy_acct_admin_t)))
       || (memcmp ((char *)&user_part,
                   (char *)&lkp_user_part,
                   sizeof (sec_rgy_acct_user_t))))
     {
       TSHMessage (ctx, SETUP, "sec_rgy_acct_lookup failed\n");
       goto EXIT_DEL_ACCT;
     }
----------------------------------------------------------------------------

    The code in SECTION ONE above zeros the user_part structure then uses
    memcpy to copy strings (plus any trailing garbage in memory) into the
    user_part structure.

    The user_part structure is used as input to sec_rgy_acct_add(), then
    sec_rgy_acct_lookup() is called to verify successful completion of the
    acct_add call.  The verification in SECTION TWO does a memcmp of the
    entire user_part and admin_part structures.  These will never compare
    correctly since only the valid string portions of the user_part.gecos,
    user_part.homedir, and user_part.shell are transferred by the RPC.
    The extra garbage copied into user_part via the memcpy never compares
    correctly with the garbage in the lkp_user_part returned from the
    sec_rgy_acct_lookup() call.

    The call to TSHMessage() then silently covers up the problem since it is
    passing a flag of SETUP (0x00000000).  The TSHMessage routine never prints
    anything, the cleanup routine is jumped to, and the output of the testcase
    indicates success.
	
Repeat By:

    <A description of how to reproduce the problem (optional)>

Proposed Solution:

    The memcpy's to initialize the user_part structure should be changed to
    strncpy to avoid the chance of attempting to access unallocated memory.

    The memcmp of the entire structure in the validation should be changed to
    compare each important field of the structure using strcmp where
    appropriate.
	
    The calls to TSHMessage() should be changed to use the flag MOFAILURE so
    that an error message is printed and the failure is correctly indicated.



CR Number                     : 13560
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : app_gd
Short Description             : sec_attr_util_inst_free_ptrs() not for servers
Reported Date                 : 7/3/96
Found in Baseline             : 1.1
Found Date                    : 7/3/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/3/96 public]
The function sec_attr_util_inst_free_ptrs() is the usual method
for freeing memory allocated for Extended Registry Attributes
(e.g. by sec_rgy_attr_lookup_by_id()).

RPC servers should not use sec_attr_util_inst_free_ptrs(), however,
since the function always uses "free()" as its deallocator.

RPC servers should instead call sec_attr_util_free(), which takes
a "deallocate" function parameter, but otherwise has the same
semantics as sec_attr_util_inst_free_ptrs().

Both the DCE Application Development Guide and the DCE Application
Development Reference should describe both of these functions.

[7/16/96 public]
Assigned to Digital. As with 13559, this may be wrong, so correct
me Evelyn if so,



CR Number                     : 13531
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : always check return from malloc()
Reported Date                 : 6/20/96
Found in Baseline             : 1.1
Found Date                    : 6/20/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/20/96 public]

Several files in src/security/krb5/lib/mvr never check the pointer
returned from malloc for failure:
decode.c encode.c krb5-glue.c krb5-manual-glue.c



CR Number                     : 13495
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : sec_rgy_unix_getgr* routines
ignore group_override
Reported Date                 : 6/6/96
Found in Baseline             : 1.1
Found Date                    : 6/6/96
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : client/rca/unix.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[6/6/96 public]

The sec_rgy_unix_getgr* routines do not extract information from
the group_override file.  Since the sec_rgy_unix_getpw* routines get
override information from the passwd_override file, the sec_rgy_unix_getgr*
routines should get override information as well.

The following diff has new code to do this.  Note that the override lookup
does not handle the member list correctly when the number of members 
exceeds max_num_members.  But the existing  sec_rgy_unix_getgr* API doesn't
get this right either.


DIFFS unix.c_new unix.c_1.1

134,141d133
< PRIVATE void rgy_grp_override_entry (
<     sec_rgy_unix_group_t    *grp,
<     signed32                 max_num_members,
<     signed32                 *num_supplied,
<     sec_rgy_member_t         members[],
<     error_status_t          *st
< );
< 
355d346
<     sec_override_fields_t  overridden;
368,371d358
<     if (*status == error_status_ok) {
<         rgy_grp_override_entry(group_entry, max_num_members,
&ret_members, members, status);
<       }
< 
374d360
< 
420,423d405
<     if (*status == error_status_ok) {
<         rgy_grp_override_entry(group_entry, max_num_members,
&ret_members, members, status);
<       }
< 
479,482d460
<     if (*status == error_status_ok) {
<         rgy_grp_override_entry(group_entry, max_num_members,
&ret_members, members, status);
<       }
< 
549,572d526
< }
< 
< PRIVATE void rgy_grp_override_entry (
<     sec_rgy_unix_group_t    *grp,
<     signed32                 max_num_members,
<     signed32                 *num_supplied,
<     sec_rgy_member_t         members[],
<     error_status_t          *st
< )
< 
< {
<   sec_rgy_cursor_t               mem_cursor;
<   sec_rgy_unix_passwd_buf_t      gr_passwd;
<   sec_group_override_fields_t    overridden = false;
<   signed32                       num_members;
<    
<   sec_rgy_cursor_reset(&mem_cursor);
<   gr_passwd[0] = '\0';
<  
<   override_get_group_info(grp->name, max_num_members, &(grp->gid),
&mem_cursor, gr_passwd, 
<                                               members, num_supplied,
&num_members, &overridden, st);
< 
<   if (*st == sec_login_s_no_override_info || *st ==
sec_login_s_ovrd_ent_not_found)
<          *st = error_status_ok;



CR Number                     : 13486
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : doc
Short Description             : sec_rgy_unix_getgr* routines
won't take multiple calls for member list
Reported Date                 : 5/30/96
Found in Baseline             : 1.0.3,1.1
Found Date                    : 5/30/96
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : rca/unix.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/30/96 public]

The documentation for the sec_rgy_unix_getgr*() routines states that if the
number of members in the group exceeds max_num_members, that multiple
calls can be made to the routine to get the remaining entries in the
member list.  However, the API does not contain a member_list
cursor, and in rca/unix.c, the "member_marker" for these routines 
is always initialized to be invalid.  So multiple calls can't work.

This is not just a bug with the code, it's a bug with the API: Unless
there's a member_cursor argument, there's no way for the routines to know
where in the member list to continue returning entries on a subsequent
call.  Presently, you can only get at most max_num_members member entries,
and there is no indication that the number returned in number_members
is less than the total.



CR Number                     : 13475
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : preauth and keytab files don't work together
Reported Date                 : 5/21/96
Found in Baseline             : 1.1
Found Date                    : 5/21/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : security/client/login/sec_login_pvt.c
Diff supplied by              : osf
Diff release                  : 1.1
Sensitivity                   : public

[5/21/96 public]
If a principal is given a pre_auth_req attribute with value 2, then
the following program fails at the sec_login_validate_identity call
with "Invalid password". With a value of 0, the validate succeeds.
dce_login succeeds in either case. The program is as follows:

int main(int argc, char *argv[])
{
    char                *user   = NULL;
    boolean32           reset_passwd, valid;
    sec_login_auth_src_t auth_src;
    sec_login_handle_t  lcontext;
    error_status_t      st;
    void		*prec;

    user=argv[1];
    if (sec_login_setup_identity((unsigned_char_p_t) user,
				 sec_login_no_flags,
				 &lcontext, 
				 &st)) {

      sec_key_mgmt_get_key(rpc_c_authn_dce_secret, (unsigned char *)
"FILE:/tmp/keytab.file",
			   user,
			   0,	/* return most recent version */
			   &prec, 
			   &st);

      valid = sec_login_validate_identity(lcontext,
					  prec,
					  &reset_passwd,
					  &auth_src,
					  &st);
    }
}

The difference between dce_login and this program is that the key type
of the key retrieved from the keytab file is sec_passwd_des, whereas in
dce_login, it is sec_passwd_plain.

Tracing the  code uncovers the following in 
sec_login_pvt_get_and_process_krb_tgt() which is called from
sec_login_validate_identity():

    while (retries_left-- && lcp->auth_src == sec_login_auth_src_network) {

        /* get TGT */
        *stp = krb5_do_as_request(KRB_REQUEST_INFO(lcp)->options,
                                  KRB_REQUEST_INFO(lcp)->addrs,
                                  patype,
                                  ETYPE_DES_CBC_CRC,
                                  KEYTYPE_DES,
                                  skey_keyproc,
                                  &ukey,
                                  &KRB_REQUEST_INFO(lcp)->nonce,
                                  &KRB_REQUEST_INFO(lcp)->creds,
                                  &KRB_REQUEST_INFO(lcp)->reply,
                                  &etext,
                                  &reply_random_key);
        if (GOOD_STATUS(stp) || 
            !STATUS_EQUAL(stp, KRB5KDC_PREAUTH_FAILED) || 
            !retries_left ||
	    etext == NULL ||
            (PASSWD_TYPE(key) != sec_passwd_plain)) {

            break;
        }

	...

where it is not clear why we break if the passwd_type is not plain.

[6/05/96]

Given a plain text password, sec_login_validate_identity transforms the password 
into a DES type password before proceeding with the validation. As noted above,
passwords are stored in key tables as DES type passwords and accordingly no 
transformation is necessary. 

sec_login_validate_identity makes a call to sec_login_pvt_get_preauth. One argument
to this call is the user password. In the original code, the form of the user
password (transformed or untransformed) was contigent on whether or not the 
preathentication subtype was OSF_DCE_THIRD_PARTY. sec_login_pvt_get_preauth requires
a password of DES type, since the preauth subtype has no bearing on whether or not
the user key needed to be transformed, an incorrect type of password could be passed.
The proposed solution makes the user password argument of the call to sec_login_pvt_get_preauth
contigent on whether the original key type required transformation to DES.

The proposed fix was tested at OSF on an HP system running OSF maint release
of DCE 1.1. It resolved the reported problem.

Comment: this fix should also take care of the path through sec_login_valid_and_cert_ident
         since it also leads to sec_login_pvt_get_and_process_krb_tgt.

***************
*** 6332,6338 ****
              cleanup_key(reply_random_key);
              *stp = sec_login_pvt_get_preauth(pa_subtype,
                           KRB_REQUEST_INFO(lcp)->creds.client,
!                          (pa_subtype == OSF_DCE_THIRD_PARTY) ? &user_key : key,
                           &reply_random_key, &padata);
              if (*stp == KRB5_PREAUTH_FAILED) {
                  /* fallback to KRB5_PADATA_ENC_UNIX_TIME */
--- 6329,6335 ----
              cleanup_key(reply_random_key);
              *stp = sec_login_pvt_get_preauth(pa_subtype,
                           KRB_REQUEST_INFO(lcp)->creds.client,
!                          (PASSWD_TYPE(key) == sec_passwd_plain) ? &user_key : key,
                           &reply_random_key, &padata);
              if (*stp == KRB5_PREAUTH_FAILED) {
                  /* fallback to KRB5_PADATA_ENC_UNIX_TIME */

[06/05/96 public]

This fix will break the OSF_DCE_THIRD_PARTY_PLAINTEXT preauth type. THis
is a preauthentication protocol which preserves the plaintext portion of
the user's password.  It can be very useful for the security server to
check against other password databases, etc. Only the client side was implemented
for DCE 1.1 so it is currently undocumented. However, I would rather not break
this in case we decide to add this server functionality in th future.

Anyway the fix is basically:

If PASSWD_TYPE(key) == sec_passwd_plain AND pa_subtype != 
	OSF_DCE_THIRD_PARTY_PLAINTEXT, always pass key to sec_login_pvt_get_preath().
Else, pass user_key.

Or:

--- 6329,6335 ----
              cleanup_key(reply_random_key);
              *stp = sec_login_pvt_get_preauth(pa_subtype,
                           KRB_REQUEST_INFO(lcp)->creds.client,
!                          (PASSWD_TYPE(key) == sec_passwd_plain &&
!			    pa_subtype != OSF_DCE_THIRD_PARTY_PLAINTEXT) ? &user_key : key,
                           &reply_random_key, &padata);
              if (*stp == KRB5_PREAUTH_FAILED) {
                  /* fallback to KRB5_PADATA_ENC_UNIX_TIME */

[06/05/96 public]

Oops, typo above. That should be:

If PASSWD_TYPE(key) == sec_passwd_plain AND pa_subtype !=
        OSF_DCE_THIRD_PARTY_PLAINTEXT, always pass user_key to sec_login_pvt_get_preath().
Else, pass key.



CR Number                     : 13466
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : admin_gd
Short Description             : masks only apply to ACL mgrs that implement them
Reported Date                 : 4/30/96
Found in Baseline             : 1.2.1
Found Date                    : 4/30/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : admin_gd/security/security/1.5_acls.gpsml
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : open

[4/30/96 public]
In the section called ACL Entry Types for Masks and in subsequent
sections that discuss masks (The mask_obj Mask and ACL Checking
section and The Unauthenticated Mask and ACL Checking section), it
should be noted that not all components implement masks.  A note could
be added to the ACL Entry Types for Masks section that says something
like the following:
	A particular mask only applies to components whose ACL
	Managers implement it.  For example, the mask_obj mask is
	implemented in DFS but the unauthenticated mask is not.
and subsequent references to particular masks could be qualified to
note that they are used as filters only if they are implemented by the
ACL Manager.
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `open'

[5/16/96 public]

Assigned to HP.



CR Number                     : 13459
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : admin_gd
Short Description             : foreign princ. discussion should reflect LFS behavior
Reported Date                 : 4/30/96
Found in Baseline             : 1.2.1
Found Date                    : 4/30/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : admin_gd/security/security/5_multicell.gpsml
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : open

[4/30/96 public]
In the section called Establishing Trust Relationships the discussion
about foreign principals and UNIX numbers could be made to reflect
more accurately the LFS behavior.  For example, the current sentence:
	Thus, a foreign principal that is accessing files in the local
	cell could have the same UNIX number as the local principal
	and be seen by the local system as the owner of the local
	user's files on the local machine.
could be made into a new paragraph that describes this behavior in
terms of file systems, as follows:
	Thus, in file systems, such as LFS, that use extended
	credentials (which are communicated using secure RPC),
	foreign principals can be uniquely identified using their
	UUID.  But UFS is limited in what it is able to record about
	users; it holds just the UNIX number.  Therefore, an LFS file
	that is created by a foreign user is correctly reported as
	owned by that foreign user when examined with DCE tools.
	However the UNIX tools are only able to report the foreign
	principal's UNIX number, which may correspond to a different
	user in the local cell.
The next paragraph (which begins with, "Creating a UNIX number...")
could likewise be expanded, for example, it might be replaced with
something like the following:
	Since native UNIX file systems store only the UNIX number,
	they do not have the ability to uniquely identify foreign
	users, as LFS does.  For exported UFS partitions, DFS maps
	every foreign principal to the predefined principal, "nobody."
	The "nobody" principal is also used for unauthenticated
	access.  So the very feature that prevents foreign principals
	from accessing the local user's files also allows them to
	access each other's files.  With UNIX file systems, each user
	from a foreign cell is seen as the same user, every file on
	the local machine that is owned by a foreign user can be
	accessed by every other foreign user as well as by
	unauthenticated users.
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `open'

[5/16/96 public]

Assigned to HP.



CR Number                     : 13458
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : rgy
Short Description             : default acls make names public
Reported Date                 : 4/30/96
Found in Baseline             : 1.1
Found Date                    : 4/30/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/30/96 public]
A note on cypherpunks got me thinking...

> I'm still reasonably serious about that "Hack Stanford Privacy" thing. If
> there is an easy way for outsiders to glean our whole kerberos namespace
> (outside of other major universities interconnected via AFS, and we'll
> get that fixed Real Soon Now), I want to know about it.

So, what are the default ACLs on the registry?  Can anyone do a
dcecp "principal catalog" command or it's C code equivalent?

	dcecp> acl show -ic /.:/sec/principal 
	{unauthenticated r-----}
	{user cell_admin rcidDn}
	{group acct-admin rcidDn}
	{other_obj r-----}
	{any_other r-----}

Hmmm, it looks like anyone can.  The required permission to see any 
particular pgo is r on that pgo item.  Would anything break if principals
weren't readable?  I know that acl editing could display uuids instead
of names.

I'm not sure what the right thing is.  Many companies guard their org 
charts and their /etc/passwd files.  How much info is leaking by allowing
principal info out?  Would companies care?  Should we change the default
configuration?



CR Number                     : 13457
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : admin_gd
Short Description             : can't use cm to change cell membership
Reported Date                 : 4/30/96
Found in Baseline             : 1.2.1
Found Date                    : 4/30/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : admin_gd/overview/overview/9_tasks.gpsml
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : open

[4/30/96 public]
The section called Reconfiguring the Cache Manager includes a bulleted
list that begins, 
	You can use the cm commands to perform the following tasks:
It would be more accurate to say,
	You can use the cm commands or switches to dfsd to perform the
	following tasks:
In addition, one of the items in the list,
	- Changing the cell membership is incorrect.
You can not use the cm command to change the cell membership.
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `open'

[5/16/96 public]

Well, I'm not sure whom to assign this one to. But since the topic
has to do with the Cache Manager, I'm giving it to Transarc. Bill
(or Anne Jane), if this is wrong, let me know and I'll correct my
action.



CR Number                     : 13456
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : admin_gd
Short Description             : references to /opt/dce1.0 should be updated
Reported Date                 : 4/30/96
Found in Baseline             : 1.2.1
Found Date                    : 4/30/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : admin_gd/overview/overview/5_file.gpsml
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : open

[4/30/96 public]
The section called The dcceshared Subtree includes the paragraph that
follows.  Shouldn't the references to /opt/dce1.0 be updated to the
current version number?
The default pathname prefix for \*Vdceshared\*O is \*L/opt/dce\*O,
which is a symbolic link to \*L/opt/dce1.0\*O, or for DFS, to
\*L/:/opt/dce1.0\*O (the short form of \*L/.:/fs/opt/dce1.0\*O).  This
entry is always physically located at the local machine.  Therefore,
the local system administrator (or the respective software
administrator) must have write permission to modify this link.  You
can redirect this link from the fileset on the local machine to the
cell-wide accessible fileset as soon as the local machine is
configured and the cell is available; for example, redirect
\*L/opt/dce\*O to \*L/:/opt/dce1.0\*O.
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `open'

[5/16/96 public]

Assigned this to myself, as it seems straightforward enough,
and I don't know who else to assign it to.



CR Number                     : 13454
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : admin_gd
Short Description             : permission to delete wrong in figure
Reported Date                 : 4/25/96
Found in Baseline             : 1.2.1
Found Date                    : 4/25/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : admin_gd/security/security/13_access.gpsml
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : open

[4/25/96 public]
In the section called Permissions Required to Delete Principals,
Group, or Organizations, the text states the you must have rD
permission on the principal, group, or organization to be deleted, but
the figure indicates only D permission.  The figure should be modified
to say rD like the text.
Also, shouldn't this section be called Permissions Required to Delete
Principals, Groups, or Organizations?
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `open'

[5/16/96 public]

Assigned to HP.



CR Number                     : 13448
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : admin_gd
Short Description             : typos appear in Admin Gd Intro and Core docs
Reported Date                 : 4/24/96
Found in Baseline             : 1.2.1
Found Date                    : 4/24/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : open

[4/24/96 public]
Typos in Admin Guide-Core, organized by source file name:
admin_gd/dcecp/language.gpsml
0390	"indispensible"		should be	"indispensable"
0391	"colletion"		should be	"collection"
0392	"parseagrs"		should be	"parseargs"
admin_gd/dcecp/script.gpsml
0393	"cannnot"		should be	"cannot"
admin_gd/tasks/task_cell.gpsml
0394	"pringstring"		should be	"printstring"
admin_gd/rpc/rpc/host_admin.gpsml
0395	"adminitrators"		should be	"administrators"
admin_gd/rpc/rpc/appl_admin.gpsml
0396	"commmunicate"		should be	"communicate"
0397	"assessible"		should be	"accessible"
admin_gd/directory/overview/1_dir_overview.gpsml
0398	"adminstration"		should be	"administration"
admin_gd/directory/cds/6_cds_access.gpsml
0399	"hierarchial"		should be	"hierarchical"
admin_gd/directory/cds/8_cds_directory.gpsml
0400	"CSA_DirectoryVersion"	should be	"CDS_DirectoryVersion
admin_gd/directory/cds/9_cds_view.gpsml
0401	"preceeded"		should be	"preceded"
admin_gd/directory/cds/10_cds_restruct.gpsml
0402	"dabase"		should be 	"database"
0403	"Hierchical"		should be	"Hierarchical"
admin_gd/dts/dts/1_intro_dts.gpsml
0404	"Sample time-providers"	should be	"(Sample time-providers"
admin_gd/dts/dts/3_managing_dts.gpsml
0405	"visa versa"		should be	"vice versa"
admin_gd/security/security/3_pgo.gpsml
0406	"to the the master"	should be	"to the master"
0407	"mutiple"		should be	"multiple"
admin_gd/security/security/4_accts.gpsml
0408	"dececp"		should be	"dcecp"
0409	"mon#Repos}}"		should be	"mon#Repos}}}"
0410	"entires"		should be	"entries"
admin_gd/security/security/4.5_era.gpsml
0411	"updateaset"		should be	"updateset"
0412	"ncarn_tp_tcp"		should be	"ncacn_tp_tcp
0413	"mutli-valued"		should be	"multi-valued"
admin_gd/security/security/5_multicell.gpsml
0414	"from one cell be authenticated"
				should be	"from one cell to be
						authenticated"
0415	"princpals"		should be	"principals"
admin_gd/security/security/7_pols.gpsml
0416	"pwdminlin"		should be	"pwdminlen"
admin_gd/security/security/8_maint.gpsml
0417	"followng"		should be	"following"
admin_gd/security/security/10_setup.gpsml
0418	"kmen"			should be	"kmem"
admin_gd/security/security/11_import.gpsml
0419	"acount"		should be	"account"
admin_gd/security/security/14_audit.gpsml
0420	"satsified"		should be	"satisfied"
0421	"programer"		should be	"programmer"
admin_gd/security/security/15_audit_tasks.gpsml
0422	"permssions"		should be	"permissions"
0423	"registery"		should be	"registry"
0424	"evet_osf_dce_rs..."	should be	"evt_osf_dce_rs..."
0425	"auditrail show"	should be	"audtrail show"
admin_gd/directory/cds/b_cds_files_app.gpsml
0426	"distinquish"		should be	"distinguish"
-------------------------------------------------------------------
Typos in Admin Guide-Intro, organized by source file name:
admin_gd/overview/overview/3_cell.gpsml
0427	"to to communicate"	should be	"to communicate"
0428	"deamon"		should be	"daemon"
admin_gd/overview/overview/4_serv.gpsml
0429	"\(*Re"			should be	"\*(Re"
0430	"Cient"			should be	"Client"
0431	"Figure 3-3"		should be	"Figure 3-1"
	There is no Figure 3-3; this problem appears twice.
admin_gd/overview/overview/9_tasks.gpsml
0432	"Audit Service data""	should be	"Audit Service data"
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `open'

[04/29/96 public]
The following:
 admin_gd/dts/dts/1_intro_dts.gpsml
 0404	"Sample time-providers"	should be	"(Sample time-providers"
is not correct.  The opening paren is at the start of the preceding
sentence.
In regard to:
 admin_gd/security/security/5_multicell.gpsml
 0414    "from one cell be authenticated"
                                 should be       "from one cell to be
                                                 authenticated"
I find this phrase rendered correctly in my 1.1PH version; it
should thus be correct in 1.2 and I wonder why it isn't.
The following:
 admin_gd/overview/overview/4_serv.gpsml
 0429    "\(*Re"                 should be       "\*(Re"
	 ...
 0431    "Figure 3-3"            should be       "Figure 3-1"
         There is no Figure 3-3; this problem appears twice.
 admin_gd/overview/overview/9_tasks.gpsml
 0432    "Audit Service data""   should be       "Audit Service data"
were fixed in the 1.1PH version of this document; the fixes
were presumably carried to 1.2 when the 1.1 PH files were
incorporated into that tree.

[4/29/96 public]
My mistake on the first two (labeled 0404 and 0414), they are actually
correct in my 1.2.1 tree.
The other three (labeled 0429, 0431, and 0432), however, are not
correct in my 1.2.1 tree (last sup'd on April 16).

[5/16/96 public]

Assigned to myself, since this all appears to be mechanical and
straightforward, and there is a mixture of actual responsibility
among providers for the material mentioned in the above.



CR Number                     : 13447
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : gssapi
Short Description             : Support X/Open API
Reported Date                 : 4/24/96
Found in Baseline             : 1.2.1
Found Date                    : 4/24/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1maint
Affected File(s)              : src/security/gssapi/gssapi.[ch]
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/24/96 public]

The X/Open version of GSSAPI renames some functions.  We should support
those names.  That was never a requirement, so this is an enhnacement.
But V2 of the IETF GSSAPI will follow the X/Open names, so once that
becomes an official IETF standards document, this should be changed
to a defect. :)

[04/30/96 public]
Here is a set of untested changes.  To gssapi.h add the following:
	OM_uint32 gss_get_mic
			 (OM_uint32*,       /* minor_status */
			  gss_ctx_id_t,     /* context_handle */
			  int,              /* qop_req */
			  gss_buffer_t,     /* message_buffer */
			  gss_buffer_t      /* message_token */
			 );

	OM_uint32 gss_verify_mic
			 (OM_uint32*,       /* minor_status */
			  gss_ctx_id_t,     /* context_handle */
			  gss_buffer_t,     /* message_buffer */
			  gss_buffer_t,     /* token_buffer */
			  int*              /* qop_state */
			 );

	OM_uint32 gss_wrap
			 (OM_uint32*,       /* minor_status */
			  gss_ctx_id_t,     /* context_handle */
			  int,              /* conf_req_flag */
			  int,              /* qop_req */
			  gss_buffer_t,     /* input_message_buffer */
			  int*,             /* conf_state */
			  gss_buffer_t      /* output_message_buffer */
			 );

	OM_uint32 gss_unwrap
			 (OM_uint32*,       /* minor_status */
			  gss_ctx_id_t,     /* context_handle */
			  gss_buffer_t,     /* input_message_buffer */
			  gss_buffer_t,     /* output_message_buffer */
			  int*,             /* conf_state */
			  int*              /* qop_state */
			 );
To gssapi.c add the following:
	OM_uint32 gss_verify_mic
			 (OM_uint32* minor_status,
			  gss_ctx_id_t context_handle,
			  gss_buffer_t message_buffer,
			  gss_buffer_t token_buffer,
			  int* qop_state) {
		return gss_verify(minor_status, context_handle, message_buffer,
			token_buffer, qop_state);
	}

	OM_uint32 gss_wrap
			 (OM_uint32* minor_status,
			  gss_ctx_id_t context_handle,
			  int conf_req_flag,
			  int qop_req,
			  gss_buffer_t message_buffer,
			  int* conf_state,
			  gss_buffer_t token_buffer) {
		return gss_seal(minor_status, context_handle, conf_req_flag,
			qop_req, message_buffer, conf_state, token_buffer);
	}

	OM_uint32 gss_unwrap
			 (OM_uint32* minor_status,
			  gss_ctx_id_t context_handle,
			  gss_buffer_t token_buffer,
			  gss_buffer_t message_buffer,
			  int* conf_state,
			  int* qop_state) {
		return gss_unwrap(minor_status, context_handle, token_buffer,
			message_buffer, conf_state, qop_state);
	}

[04/30/96 public]

A couple of small corrections (eye-balled but still untested).

The changes in gssapi.c need a definition for gss_get_mic (which, from the
looks of it is the new name of gss_sign):

	OM_uint32 gss_get_mic
			 (OM_uint32* minor_status,
			  gss_ctx_id_t context_handle,
			  int qop_req,
			  gss_buffer_t message_buffer,
			  gss_buffer_t message_token
			 ) {
		return gss_sign(minor_status, context_handle, qop_req,
			message_buffer, message_token);
	}

Also the definition of gss_unwrap should call gss_unseal not gss_unwrap.



CR Number                     : 13444
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : admin_gd
Short Description             : time-related attrs should be in relative_time
Reported Date                 : 4/23/96
Found in Baseline             : 1.2.1
Found Date                    : 4/23/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : admin_gd/security/security/4_accts.gpsml
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 17655
Transarc Status               : open

[4/23/96 public]
The Admin Gd should be updated to use relative_time rather than hours
when referring to time-related attributes.  Specifically, in the Admin
Gd-Core, on page 31-9, the Attribute Options table uses hours with the
maxtktlife and maxtktrenew attributes instead of relative_time.
Added field Transarc Deltas with value `17655' 
Added field Transarc Status with value `open'

[5/16/96 public]

Assigned to HP.



CR Number                     : 13438
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : admin_gd
Short Description             : disable_time_interval specified in secs not mins
Reported Date                 : 4/18/96
Found in Baseline             : 1.2.1
Found Date                    : 4/18/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : admin_gd/security/security/3_pgo.gpsml
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : open

[4/18/96 public]
In the Admin Guide--Core, page 30-12 (section 30.6.2, Managing Invalid
Login Handling), it says that the ERA "disable_time_interval" is an
integer indicating the number of minutes the principal's account
should be disabled from login attempts.  This is incorrect; it is the
number of seconds, not minutes.
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `open'

[5/16/96 public]

Assigned to HP.



CR Number                     : 13434
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : admin_gd
Short Description             : definition of min tkt life varies
Reported Date                 : 4/18/96
Found in Baseline             : 1.2.1
Found Date                    : 4/18/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : open

[4/18/96 public]
The definition of Minimum Ticket Lifetime seems to vary in the Admin
Guide-Core:
page 31-10 (section 31.5.1, Setting Ticket Lifetimes)
        Minimum Ticket Lifetime--The shortest possible lifetime that
        can be assigned to a ticket.
page 35-9 (section 25.2.7, Minimum Ticket Lifetime Property)
        The minimum ticket lifetime is the minimum amount of time in
	minutes before the principal's ticket must be renewed.
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `open'

[5/16/96 public]

Assigned to HP.



CR Number                     : 13433
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : keymgmt
Short Description             : sec_key_mgmt_change_key can leave keytab file out of sync
Reported Date                 : 4/18/96
Found in Baseline             : 1.1
Found Date                    : 4/18/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/key_mgmt/keymgmt.c
Sensitivity                   : public
Transarc Deltas               : cox-17734-rollback-keytab-if-rgy-change-fails
Transarc Status               : open

[4/18/96 public]
If sec_key_mgmt_change_key is called with a specific kvno while the
rgy is in maintenance mode, the sec_rgy_acct_passwd call would fail.
However, the new key would be entered into the keytab file, causing
the keytab file to be out of sync with the rgy.  The next time
sec_key_mgmt_change_key was called (with the same kvno, since the
previous update failed) it would fail saying that the requested kvno
already existed in the keytab.
(This problem doesn't manifest when you call with
sec_passwd_c_version_none, because in that case it will remove the
appropriate kvno before it starts.)
With this change, if the rgy update fails, roll back the addition of
the new key into the keytab file, to keep them in sync.
*** security/client/key_mgmt/keymgmt.c
--- 12.7	1996/04/16 20:07:49
***************
*** 361,370 ****
--- 373,399 ----
  
                      /* Set the key in the registry */
                      if (GOOD_STATUS(err)) {
+ 			/* In case sec_rgy_acct_passwd mucks with next_vno,
+ 			 * which it is entitled to do.
+ 			 */
+ 			unsigned32 n_kvno = next_vno;
+ 
                          sec_rgy_acct_passwd(rgy_h, &login_name, oldkey,
                                              (sec_passwd_rec_t *) keydata,
                                              sec_passwd_des, &next_vno, err);
                          sec_key_mgmt_free_key(oldkey, &lst);
+ 			if (BAD_STATUS(err)) {
+ 			    /* If setting the key in the rgy failed, remove
+ 			     * the key from the keytab also.  This is
+ 			     * guaranteed not to wipe out a key that was valid
+ 			     * before we were called, because if next_vno were
+ 			     * valid then, the sec_key_mgmt_set_key call above
+ 			     * would have failed.
+ 			     */
+ 			    sec_key_mgmt_delete_key(authn_service, arg,
+ 						    principal_name, n_kvno,
+ 						    &lst);
+ 			}
                      }
                  }
              } /* set_key succeeded */
Added field Transarc Deltas with value 
 `cox-17734-rollback-keytab-if-rgy-change-fails' 
Added field Transarc Status with value `open'



CR Number                     : 13425
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : admin_gd
Short Description             : information on local registry is misleading
Reported Date                 : 4/2/96
Found in Baseline             : 1.1
Found Date                    : 4/2/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : admin_gd/security/security/1_over.gpsml, 4_accts.gpsml
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 17268
Transarc Status               : open

[4/2/96 public]
The documentation on the local registry found on pages 27-9 and 31-19
in the Adinistrative Guide - Core Components is misleading in that it
never explicitly states that this is only by the unified login when a
user is trying to log into a machine and the security registry is
down.
Also, the explanation on using the rgy_edit -l command never specifies
that you need to be root for the commands to work.
Added field Transarc Deltas with value `17268' 
Added field Transarc Status with value `open'

[5/16/96 public]

Assigned to HP.



CR Number                     : 13394
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : Audit events for authentication not being generated
Reported Date                 : 3/17/96
Found in Baseline             : 1.1
Found Date                    : 3/17/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/17/96 public]

Security authentication audit events are not being generated.
Affected events are AS_Request, TGS_TicketReq, TGS_RenewReq, 
and TGS_ValidateReq.



CR Number                     : 13392
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : REPADMIN_SetSwRev audit event incorrect
Reported Date                 : 3/17/96
Found in Baseline             : 1.1
Found Date                    : 3/17/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : sec_aud_evts.h
Sensitivity                   : public

[3/17/96 public]

The REPADMIN_SetSwRev is incorrectly specified, not documented and 
may cause memory faults on certain platforms.  This event was added
for the 1.1 WP release but currently can not be generated.  However,
depending on the memory allocation characteristics of a particular 
platform, a fault will occur due to the audit subsystem incorrectly
allocating insufficient storage for Security's audit events.  (Security
audit event count is one too small.)

The interim fix is as follows:

Within ./security/h/sec_aud_evts.h, change  
#define REPADMIN_SetSwRev               0x0140  /* 314 */
to
#define REPADMIN_SetSwRev               0x013A  /* 314 */

and change
#define SEC_AUD_NUM_OF_EVTS		58     /* 314 - 256 */
to
#define SEC_AUD_NUM_OF_EVTS		59     /* 314 - 256 + 1 */

(A separate doc OT will be also opened for this.)

[3/18/96 public]

In addition to the above fix, the dce_sec_control and dce_sec_server
audit ec filter files should include an entry for this event (0x013A)
to permit proper handling when audit filtering is enabled.



CR Number                     : 13388
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : key mgmt
Short Description             : Using sec_key_mgmt_manage_key() call with login context refreshing thread can cause invalid password due to race condition
Reported Date                 : 3/14/96
Found in Baseline             : 1.2
Found Date                    : 3/14/96
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/14/96 public]

For long running servers, we recommend people to start two threads after
the initial dce login: one to periodically refresh the login context before
it expires, one to call sec_key_mgmt_manage_key to change the server key
according to the password lifespan policy. In particular, 
sec_key_mgmt_manage_key() is normally a never-return function, which calls
sec_key_mgmt_change_key() to change the key locally first, then change the
key in the registry.

When there is a finite password lifespan, there is small time window when
race condition can happen: when the sec_key_mgmt_change_key() finishes 
changing the key locally to the keyfile and before it sets the new password
to the registry, now refreshing thread wakes up and tries to validate the
login context with the new key from the keyfile. You get "invalid password"
error.

When the password lifespan is set to forever (default), you will never see
this race condition since sec_key_mgmt_manage_key() will never really change
any key. If you set the password lifespan to 1 day, then with the default
ticket lifetime to be 10 hours, the earliest time you can possibily (not
necessarily) see the problem is 5 days later. Anything else could have happened
to cause the server restart. So again most likely, you will not see it.

I actually saw the error when working on a sample dce login code. I think
the reason I could see it happening within several hours is becasue I set
the ticket life to be 2 minutes and password life to be 4 minutes.

To guard against the race condition, mutex is an obvious choice. But I cannot
use mutex with sec_key_mgmt_manage_key() becasue it is a never return function.
This pretty much makes the sec_key_mgmt_manage_key() a useless function for
a strict environment where password and ticket life time are both short.

This problem can be worked around: instead of using sec_key_mgmt_manage_key(),
I inquire the registry to get the password liefspan, sleep, get a random key,
lock the mutex, change the key, unlock the mutex, loop. In the refreshing
thread, I sleep, wake up before the context expires, lock the mutex, call
sec_login_refresh_identity() and sec_key_mgmt_get_key(), unlock mutex, validate
and certify the context, loop.



CR Number                     : 13379
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : dce_login allows success login with pwdvalid set to no
Reported Date                 : 3/2/96
Found in Baseline             : 1.1
Found Date                    : 3/2/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/2/96 public]

A support customer noted the following:
---------------------------------------

  With the acctvalid and pwdvalid flags set to no for a user's 
  account in the dce registry, kinit successfully returns a TGT.  
  This presents a security problem since the TGT can be used to 
  obtain service tickets. dce_login, however, fails with acctvalid 
  set to no.  It appears that the dce_login code does a kinit and 
  then makes sec API calls to retrieve and examine these flags.  
  The dce_login code then determines the login validity.  Placing 
  the responsibility of account validation in a client program (dce_login) 
  also seems to be a security problem in that I could write my own
  login program which doesn't do this check and get access to my 
  invalidated account.  

  Also, dce_login allows successful login with the pwdvalid flag set to no.  
  Our administrative policy requires users to change their passwords 
  regularly which it appears we cannot enforce with DCE.

  Repeat By:

  Use dcecp to set the acctvalid and pwdvalid flags for an account to no.  
  Do a kinit to that account and use klist to verify that a TGT has been
  obtained.  

  Proposed Solution:

  The DCE security server should fail to authenticate a client whose
  acctvalid flag is set to no, the same as it fails if a wrong password is 
  entered.  The policy for failure or warning in the case of the pwdvalid 
  flag set to no should be controllable by the dce administrator, perhaps 
  as an attribute of the registry or organization policy; and the failure 
  or warning response should be determined by the DCE security server NOT 
  the dce_login client.

[3/4/96 public]
Fixed the 'description' field to correctly summarize the problem.  We'll
be looking into it here, but could you please verify that your security
servers were all based on OSFDCE1.1 and that the version was set to 1.1?
(verify the version setting with "dcecp registry show -attributes").
Pre-1.1 servers will expect the client to do the checking, while 1.1 servers
should enforce acct and pwd expiration at the server.

[3/5/96 public]
Sorry about that, I was going by what your comments described above (where it
only says that kinit has the problem) when I changed the short description.
It turns out that dce_login does have the described problem with pwdvalid
(although not with acctvalid and passwd expiration), so I've changed the
short description back to what it was orginally...

[3/14/96 public]
Ok, I finally got prodded back into looking into this.  Here's the story:
Account not valid and Password expiration were client enforced only up through
1.0.3.  Password expiration became server enforced as of OSFDCE1.1.
Account not valid became server (secd) enforced by at least 1.2.1 (was
supposed to be in 1.1, but I believe it didn't make it, but is definitely in
1.2.1).

Password not valid is still just advice to the client side for a reason:
All dce_config tools up through and including 1.2.1 set the cell_admin's
password to not valid (if default is specified) to make sure the user is
warned to change it to something better.  If we started enforcing the pwd
not valid policy in the server, then no existing config tools based on
dce_config would be able to configure against this server.  

Since the remaining problem in this OT is not easily solvable and amounts
to improving functionality at the expense of affecting backwards compatibility,
this OT will be listed as an enhancement request.



CR Number                     : 13378
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : principal_catalog
Short Description             : rgy cursors can get trashed
Reported Date                 : 2/28/96
Found in Baseline             : 1.1
Found Date                    : 2/28/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : admin/dcecp/rgy.c
Sensitivity                   : public

[2/28/96 public]
We have encountered a problem with registry cursors, specifically in
sec_rgy_pgo_get_next(), but I believe the problem is not specific to
that function but general to all of the functions which use a
sec_rgy_cursor_t for looking up registry entries.
 
The problem is that it is possible to delete the registry entry that a
cursor points at, thus trashing the cursor out from under its owner.

When this occurs, (a) the function in question returns with status
sec_rgy_pgo_not_found (which, at least in the case of
sec_rgy_pgo_get_next, is not documented as one of the possible
results), and (b) the cursor is no longer usable.

Clearly, this is more important for some functions than it is for
others; it means that it is difficult to use a cursor to get an
accurate picture of what is actually in the registry database.
Certainly, it is to be expected that it is hard to get an accurate
snapshot of a database that is changing while it is being examined,
but part (b) means that functions taking that snapshot may actually be
interrupted.  (IMHO, it would be preferable to return an out-of-date
snapshot rather than interrupt the cursor sweep.)

It seems that the fix for this is rather complicated; a "bulletproof"
fix would probably involve using context handles to maintain some
state in the server about where cursors point (they could lock the
pointed-to objects, or advance cursors when pointed-to objects are
deleted, for example).  This, of course, would involve a new cursor
type and new cursor-related functions.

A workaround for the meantime is probably to document
sec_rgy_object_not_found as a possible return status from
sec_rgy_pgo_get_next() and to change dcecp's principal_catalog()
function to expect and deal with this error code.
 
Here is a diff for dcecp:

*** admin/dcecp/rgy.c
--- 12.9        1996/02/22 19:31:41
***************
*** 878,883 ****
--- 887,893 ----
      int                  pargc = 0;
      char                 **pargv;
      int                  i = 0;
+     int                  saved_length;
      boolean32            simplename = FALSE;
 
      dcp_ArgvInfo arg_table[] = {
***************
*** 932,943 ****
--- 942,965 ----
 
          if(strlen(interp->result))
              Tcl_AppendResult(interp,"\n",NULL);
+       saved_length = strlen(interp->result);
 
          for( result = error_status_ok; result == error_status_ok ;){
              sec_rgy_pgo_get_next(rgy_context,sec_rgy_domain_person,name,
                                   &item_cursor,&pgo_item,name1,&result);
              if(result == sec_rgy_no_more_entries)
                  continue;
+           if(result == sec_rgy_object_not_found) {
+               /* If we get this result code, the cursor has been trashed */
+               /* because someone deleted the element out from under it.  */
+               /* In that situation, all we can do is start over.  Fooey. */
+               sec_rgy_cursor_reset(&item_cursor);
+               strcpy((char *)name,"");
+               strcpy((char *)name1,"");
+               interp->result[saved_length] = '\0';
+               result = error_status_ok;
+               continue;
+           }
              if (result != sec_rgy_status_ok)
                  free(pargv);
              DCP_CHECK_SEC_ERROR(result);



CR Number                     : 13368
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : clock skew error after 2 invalid bindings
Reported Date                 : 2/24/96
Found in Baseline             : 1.1
Found Date                    : 2/24/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/24/96 public]

A support customer reported the following problem:
-------------------------------------------------

On Line Description : 
	dce_login produces "Clock skew too great" error if it access 
	more than two bad bindings.

Full Description : 
	dce_login produces "Clock skew too great" error after trying
	two invalid bindings even though successfully contacting
	an secd with a third binding. It appears that the start time
	of the communication is not reset after a binding fails 
	to work.
	How to recreate the problem : 
	1. Edit the pe_site file to have as its first two entry
   	   unreachable ip address. Have as the third entry a valid
   	   ip address,
	2. Set the environment variable BIND_PE_SITE to 1
	3. Execute dce_login cell_admin <password>
	4. The following error message appears after a delay:

	Sorry.
	Password Validation Failure. - status 0x14129025 (dce / krb)

[3/5/96 public]

I am unable to reproduce this problem on 1.2.1. Does this customer have
access to 1.2.1 code? If so, please have them retry with the new code. 

I created a pe_site file with six invalid entries in it. After a several
minute delay, my login succeeded. I will wait for further information
before continuing on this problem.



CR Number                     : 13365
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : security/utils
Short Description             : cred handle prematurely
declared via magic cookie
Reported Date                 : 2/24/96
Found in Baseline             : 1.1
Found Date                    : 2/24/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/24/96 public]

A support customer reported the following problem:
-------------------------------------------------

in security/utils/sec_cred_internal.c, the  sec__cred_create_authz_handle()
routine has two cases of returning without filling in  
authz_cred_handle->data .

Near the top of the routine, the clauses starting with :

if (auth_info->authz_svc == rpc_c_authz_none) {
and
if (auth_info->handle_type == sec__cred_handle_type_client) {

might lead to a return of 0 for status (it was cleared above), and 
would seem to be missing a statement:
	authz_cred_handle->data = (idl_void_p_t) cred_handle;
in each case.

I haven't yet figured out how to make this happen at-will, and any 
suggestions in that regard would be warmly received.


< mail from support customer - Tue, 21 Mar 1995 >
Subject: Re: Ticket#20949 possible problem with sec__cred_create_authz_handle

I may not have understood things completely with my original mail, 
but I eventually made the following changes in 
sec__cred_create_authz_handle():

The first change actually has to do with a different bug reported 
concerning a possibly nasty startup race with secd and login sessions 
using a cred handle prematurely declared legal via the magic cookie. 
It requires adding the initialization of magic fields in subsequent 
changes.

The returning of a valid data ptr in the next two changes  is, I think 
required.I can't say that I've knowingly been able to exercise this code, 
however.

*** 8.1	1995/03/16 02:53:42
- --- sec_cred_internal.c	1995/03/16 14:12:53
***************
*** 1,9 ****
  #if !defined(lint) && !defined(_NOIDENT) && !defined(rcsid_IV5_gE83r)
! static char rcsid_IV5_gE83r[]="@(#)$RCSfile: c013365,v $ $Revision: 1.1 $";
  #define rcsid_IV5_gE83r 1
  #endif
  /*
! $Id: c013365,v 1.1 96/02/24 13:16:34 root Exp $
  
  ----------------------------------------------------------------
   Copyright 1994 Hitachi, Ltd.
- --- 1,9 ----
  #if !defined(lint) && !defined(_NOIDENT) && !defined(rcsid_IV5_gE83r)
! static char rcsid_IV5_gE83r[]="@(#)$RCSfile: c013365,v $ $Revision: 1.1 $";
  #define rcsid_IV5_gE83r 1
  #endif
  /*
! $Id: c013365,v 1.1 96/02/24 13:16:34 root Exp $
  
  ----------------------------------------------------------------
   Copyright 1994 Hitachi, Ltd.
***************
*** 422,429 ****
      sec__cred_handle_t      *cred_handle = NULL;
      int                     i;
      error_status_t          rst;
! 
      authz_cred_handle->magic = AUTHZ_CRED_HANDLE_MAGIC;
      cred_handle = (sec__cred_handle_t *) MALLOC(sizeof(sec__cred_handle_t));
      if (cred_handle == NULL) {
  	return sec_s_no_memory;
- --- 422,430 ----
      sec__cred_handle_t      *cred_handle = NULL;
      int                     i;
      error_status_t          rst;
! #ifndef hitm
      authz_cred_handle->magic = AUTHZ_CRED_HANDLE_MAGIC;
+ #endif
      cred_handle = (sec__cred_handle_t *) MALLOC(sizeof(sec__cred_handle_t));
      if (cred_handle == NULL) {
  	return sec_s_no_memory;
***************
*** 450,455 ****
- --- 451,460 ----
  	 * result in sec_cred_s_authz_svc_cannot_comply errors
  	 */
  	cred_handle->auth_info.authz_svc = auth_info->authn_svc;
+ #ifdef hitm
+ 	authz_cred_handle->data = (idl_void_p_t) cred_handle;
+ 	authz_cred_handle->magic = AUTHZ_CRED_HANDLE_MAGIC;
+ #endif
  	return rst;
  
      }
***************
*** 470,475 ****
- --- 475,484 ----
  	 */
  	if (auth_info->authz_svc != rpc_c_authz_dce) {
  	    cred_handle->auth_info.authz_svc = rpc_c_authz_none;
+ #ifdef hitm
+ 	    authz_cred_handle->data = (idl_void_p_t) cred_handle;
+ 	    authz_cred_handle->magic = AUTHZ_CRED_HANDLE_MAGIC;
+ #endif
  	    return rst;
  	}
  

From wwang@osf.org  Wed Mar 22 09:13:12 1995
Cc: scnotes@osf.org
From: Weidong Wang from OSF <wwang@osf.org>

	I noticed sth else when reading the code (sec_cred_internal.c,
sec__cred_create_authz_handle() ):

    if (auth_info->authz_svc == rpc_c_authz_none) {
        /*
         * if no authorization service info, then just return.  Any attempt
         * to extract any authz info of any kind from the cred handle will
         * result in sec_cred_s_authz_svc_cannot_comply errors
         */
        cred_handle->auth_info.authz_svc = auth_info->authn_svc;
        return rst;

    }


I noticed that it assigns auth_info->authn_svc (the authentication info) to
the authorization info field. Shouldn't it be:

        cred_handle->auth_info.authz_svc = auth_info->authz_svc;

What do you think? Considering the next case when (auth_info->authz_svc !=
rpc_c_authz_dce), it assigns 

            cred_handle->auth_info.authz_svc = rpc_c_authz_none;


< mail from support customer Wed, 14 Feb 1996 >
< The code excerpt below from the customer contains their latest changes >
< to the security/utils/sec__cred_create_authz_handle routine.           >

I think the best I can do is to send you our source file, indicating how we
were running w/o known problems.  The modified code is conditional to "hitm".
As indicated in the mail history, the first change is a distinct issue from
the other two. 
    
PUBLIC  error_status_t  sec__cred_create_authz_handle (
    sec__cred_auth_info_t    *auth_info,
    sec_bytes_t              *delegation_chain,
    sec_dlg_token_set_t      *dlg_token_set,
    sec_id_seal_set_t        *seal_set,
    rpc_authz_cred_handle_t  *authz_cred_handle
)
{
    sec__cred_handle_t      *cred_handle = NULL;
    int                     i;
    error_status_t          rst;
#ifndef hitm
    authz_cred_handle->magic = AUTHZ_CRED_HANDLE_MAGIC;
#endif
    cred_handle = (sec__cred_handle_t *) MALLOC(sizeof(sec__cred_handle_t));
    if (cred_handle == NULL) {
	return sec_s_no_memory;
    }

    CLEAR_STATUS(&rst);
    memset(cred_handle, 0, sizeof(*cred_handle));

    cred_handle->auth_info.handle_type = auth_info->handle_type;

    /* Initialize sec_cred_get_authz_session_info() specific variables */
    uuid_create_nil(&cred_handle->session_id, &rst);
    cred_handle->session_expiration = 0;

    /* 
     * if no authorization service info, then just return.  Any attempt
     * to extract any authz info of any kind from the cred handle will
     * result in sec_cred_s_authz_svc_cannot_comply errors
     */
    if (auth_info->authz_svc == rpc_c_authz_none) {
	/* 
	 * if no authorization service info, then just return.  Any attempt
	 * to extract any authz info of any kind from the cred handle will
	 * result in sec_cred_s_authz_svc_cannot_comply errors
	 */
	cred_handle->auth_info.authz_svc = auth_info->authn_svc;
#ifdef hitm
	authz_cred_handle->data = (idl_void_p_t) cred_handle;
	authz_cred_handle->magic = AUTHZ_CRED_HANDLE_MAGIC;
#endif
	return rst;

    }

    /* 
     * if this is a client side handle, then all we use is the delegation
     * chain, and we decode it right away.
     */
    if (auth_info->handle_type == sec__cred_handle_type_client) {
	/* 
	 * The only legitimate authz_svc value for a client cred handle is
	 * rpc_c_authz_dce.  We rely on the caller to call us correctly, 
         * so if we spot anything funny, we behave as though the 
	 * authz_svc were "none".  Any attempt to use the resulting
         * cred handle will result in sec_cred_s_authz_svc_cannot_comply
         * errors, but that's okay because this is an internal error
         * condition which should never arise in the first place.
	 */
	if (auth_info->authz_svc != rpc_c_authz_dce) {
	    cred_handle->auth_info.authz_svc = rpc_c_authz_none;
#ifdef hitm
	    authz_cred_handle->data = (idl_void_p_t) cred_handle;
	    authz_cred_handle->magic = AUTHZ_CRED_HANDLE_MAGIC;
#endif
	    return rst;
	}

	cred_handle->auth_info.authz_svc = rpc_c_authz_dce;

	/* 
	 * alias the delegation chain storage in the auth_info parameter
	 * so we can decode it
	 */
	DLG_CHAIN(cred_handle) = *delegation_chain;
	sec___cred_decode_epac_set(cred_handle, &rst);
	/*
         * now undo the alasing so we won't free up storage that isn't ours
         * somewhere down the line.
         */
 	DLG_CHAIN(cred_handle).num_bytes = 0;
	DLG_CHAIN(cred_handle).bytes = NULL;
    }

    cred_handle->auth_info.authenticated = auth_info->authenticated;

    /*
     * Server-side cred handles use everything in the auth_info block
     */
    if (auth_info->handle_type == sec__cred_handle_type_server) {
#ifndef KERNEL
        if (auth_info->server_princ_name != NULL) {
            cred_handle->auth_info.server_princ_name = (unsigned_char_p_t)
	        strdup((char *)auth_info->server_princ_name);
        } else {
            cred_handle->auth_info.server_princ_name = (unsigned_char_p_t)NULL;
        }
#else
        cred_handle->auth_info.server_princ_name = (unsigned_char_p_t)NULL;
#endif /*KERNEL*/
	cred_handle->auth_info.protect_level = auth_info->protect_level;
	cred_handle->auth_info.authn_svc = auth_info->authn_svc;
	cred_handle->auth_info.authz_svc = auth_info->authz_svc;

	if (auth_info->authz_svc == rpc_c_authz_name) {
#ifndef KERNEL
	    /*
	     * need to make a copy of the client principal name
	     */
            if (auth_info->authz_info.client_princ_name != NULL) {
                CLIENT_PRINC(cred_handle) = (unsigned_char_p_t)
		    strdup((char *)auth_info->authz_info.client_princ_name);
            } else {
                CLIENT_PRINC(cred_handle) = (unsigned_char_p_t) NULL;
            }
#else
            CLIENT_PRINC(cred_handle) = (unsigned_char_p_t) NULL;
#endif /*KERNEL*/
	} else if (auth_info->authz_svc == rpc_c_authz_dce) {
	/*
	 * Need to stash away a copy of the delegation token for future use in
	 * priv server delegation calls.
	 */
	if (dlg_token_set != NULL) {
	    if ((DLG_TOKEN(cred_handle).num_tokens =
                dlg_token_set->num_tokens) == 0) {
                DLG_TOKEN(cred_handle).tokens = NULL;
            } else {
                /* Make room for the array of tokens */
                DLG_TOKEN(cred_handle).tokens = (sec_dlg_token_t *)
                  MALLOC(dlg_token_set->num_tokens * sizeof(sec_dlg_token_t));
                if (DLG_TOKEN(cred_handle).tokens == NULL) {
                    FREE(cred_handle);
		    return(sec_s_no_memory);
                }
                memset(DLG_TOKEN(cred_handle).tokens, 0,
                    (dlg_token_set->num_tokens * sizeof(sec_dlg_token_t)));


                /* Copy each individual token entry */
                for (i = 0; i < dlg_token_set->num_tokens; i++) {
                   DLG_TOKEN(cred_handle).tokens[i].expiration =
                        dlg_token_set->tokens[i].expiration;
                    if ((DLG_TOKEN(cred_handle).tokens[i].token_bytes.num_bytes = dlg_token_set->tokens[i].token_bytes.num_bytes) == 0) {
                       DLG_TOKEN(cred_handle).tokens[i].token_bytes.bytes = NULL;
                    } else {
                        DLG_TOKEN(cred_handle).tokens[i].token_bytes.bytes = (idl_byte *) MALLOC(dlg_token_set->tokens[i].token_bytes.num_bytes);
                        memcpy(DLG_TOKEN(cred_handle).tokens[i].token_bytes.bytes,
                            dlg_token_set->tokens[i].token_bytes.bytes,
                            dlg_token_set->tokens[i].token_bytes.num_bytes);
                    }
                }
	    }
	}


	    /* FAKE-EPAC
	     * Need to do something about "backdoor" authentication
	     * info here (krb5 session key and ticket expiration times,
	     * etc.  This info will be stored only if the server principal
	     * in the request is one of the architectural service names
	     * for the security service.
	     */

	    /* 
	     * If we're creating the handle on behalf of a server
	     * we have to stash away a copy of the delegation chain because
	     * it might be needed later by an intermediary for use in priv
	     * server delegation calls.  All decoding will  be done
	     * on demand as accessor functions are called.
	     */
	    if (GOOD_STATUS(&rst) && delegation_chain->num_bytes > 0) {
		DLG_CHAIN(cred_handle).num_bytes = delegation_chain->num_bytes;
		DLG_CHAIN(cred_handle).bytes = (idl_byte *) MALLOC(delegation_chain->num_bytes);
		if (DLG_CHAIN(cred_handle).bytes != NULL) {
		    memcpy(DLG_CHAIN(cred_handle).bytes, 
			   delegation_chain->bytes,
			   delegation_chain->num_bytes);
		    DLG_CHAIN(cred_handle).num_bytes = delegation_chain->num_bytes;
		} else { 
                    SET_STATUS(&rst, sec_s_no_memory);
                }
	    }
	    
	}
    }   

    if (BAD_STATUS(&rst)) {
	if (auth_info->handle_type == sec__cred_handle_type_client) {
	    sec___cred_free_handle(cred_handle);

	} else { /* handle_type == sec__cred_handle_type_server */
	    if (DLG_CHAIN(cred_handle).bytes != NULL) {
		FREE(DLG_CHAIN(cred_handle).bytes);
	    }
	    if (DLG_TOKEN(cred_handle).tokens != NULL) {
                for (i = 0; i < dlg_token_set->num_tokens; i++) {
                    if (DLG_TOKEN(cred_handle).tokens[i].token_bytes.bytes != NULL)
                        FREE(DLG_TOKEN(cred_handle).tokens[i].token_bytes.bytes);
                }
                FREE(DLG_TOKEN(cred_handle).tokens);
	    }
	}
	return rst;
    }

    /*
     * store a copy of our authz_cred_handle reference locally
     * for use in future handle integrity checks.
     */
    cred_handle->magic = cred_handle;

    /*
     * fill in the authz_cred_handle
     * !!! Probably need some logic here to either reject
     *      reallocation of an already valid cred handle
     *      or call the destructor function to get rid of
     *      the existing resources.
     */
    LOCK_CRED_KERNEL {
	authz_cred_handle->data = (idl_void_p_t) cred_handle;
	authz_cred_handle->magic = AUTHZ_CRED_HANDLE_MAGIC;
    } UNLOCK_CRED_KERNEL;

    return error_status_ok;

	
}

-------



CR Number                     : 13349
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : kdc
Short Description             : better RNG seeding
Reported Date                 : 2/21/96
Found in Baseline             : 1.0.3
Found Date                    : 2/21/96
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1maint
Affected File(s)              : security/h/rs_mkey.h, security/krb5/kdc/main.c security/server/rs/rs_mkey.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/21/96 public]

secd uses an all-zero keyblock to seed its random number genrator.  It
should be strengthened to use something more random.  The following diffs
are extensive, because they include some unrelated code-cleanup (ANSIfication)
work.  Search for rs_mkey_random_keyblock to see the important changes.


*** rs_mkey.h	Tue Dec 29 13:08:28 1992
--- rs_mkey.h.orig	Wed Feb 14 12:44:20 1996
***************
*** 8,13 ****
--- 8,18 ----
  /*
   * HISTORY
   * $Log:	c013349,v $
# Revision 1.2  96/09/24  14:39:21  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [rsalz 2/21/96 public] [rsalz 2/21/96 public]
# 
# Revision 1.1  96/02/21  13:11:24  root
# new CR
# 
+  * Revision /main/HPDCE02/1  1996/02/14  17:44 UTC  jrr
+  * 	Code cleanup.
+  * 	Fix weakness in random key generation.
+  * 	[1996/02/10  01:22 UTC  sommerfeld  /main/sommerfeld_krb5rng/1]
+  * 
   * Revision 1.1.3.5  1992/12/29  13:08:28  zeliff
   * 	Embedding copyright notice
   * 	[1992/12/28  20:44:48  zeliff]
***************
*** 47,125 ****
  
  
  void rs_mkey_create (
- #ifdef __STDC__
      sec_id_t            *rgy_local_cell,
      char                *keyseed
- #endif
  );
  
  void rs_mkey_init (
- #ifdef __STDC__
      unsigned32          rep_state,
      error_status_t      *st_p
- #endif
  );
  
  void rs_mkey_store_in_db (
- #ifdef __STDC__
      error_status_t      *st_p
- #endif
  );
  
  void rs_mkey_verify (
- #ifdef __STDC__
      krb5_keyblock           *mkey,
      krb5_kvno               mkey_version,
      krb5_encrypt_block      *eblock,
      error_status_t          *st_p
- #endif
  );
  
  void rs_mkey_encrypt_with_master (
- #ifdef __STDC__
      krb5_keyblock               *in,
      krb5_encrypted_keyblock     *out,
      error_status_t              *st_p
- #endif
  );
  
  void rs_mkey_decrypt_with_master (
- #ifdef __STDC__
      krb5_kvno                   mkey_version,
      krb5_encrypted_keyblock     *in,
      krb5_keyblock               *out,
      error_status_t              *st_p
- #endif
  );
        
  void rs_mkey_random (
- #ifdef __STDC__
      sec_passwd_rec_t    *passwd,
      error_status_t      *st_p
- #endif
  );
  
  void rs_mkey_string_to_key (
- #ifdef __STDC__
      krb5_keytype        keytype,
      krb5_data           *pwd_data,
      krb5_data           *pepper,
      krb5_keyblock       *key,
      error_status_t      *st_p
- #endif
  );
  
  void rs_mkey_change (
- #ifdef __STDC__
      error_status_t      *st_p
- #endif
  );
  
  
  void rs_mkey_purge (
- #ifdef __STDC__
      void
- #endif
  );
  
  
--- 52,115 ----
  
  
  void rs_mkey_create (
      sec_id_t            *rgy_local_cell,
      char                *keyseed
  );
  
  void rs_mkey_init (
      unsigned32          rep_state,
      error_status_t      *st_p
  );
  
  void rs_mkey_store_in_db (
      error_status_t      *st_p
  );
  
  void rs_mkey_verify (
      krb5_keyblock           *mkey,
      krb5_kvno               mkey_version,
      krb5_encrypt_block      *eblock,
      error_status_t          *st_p
  );
  
  void rs_mkey_encrypt_with_master (
      krb5_keyblock               *in,
      krb5_encrypted_keyblock     *out,
      error_status_t              *st_p
  );
  
  void rs_mkey_decrypt_with_master (
      krb5_kvno                   mkey_version,
      krb5_encrypted_keyblock     *in,
      krb5_keyblock               *out,
      error_status_t              *st_p
  );
        
  void rs_mkey_random (
      sec_passwd_rec_t    *passwd,
      error_status_t      *st_p
  );
  
+ error_status_t rs_mkey_random_keyblock
+ (
+     krb5_keyblock **random_key
+ );
+ 
  void rs_mkey_string_to_key (
      krb5_keytype        keytype,
      krb5_data           *pwd_data,
      krb5_data           *pepper,
      krb5_keyblock       *key,
      error_status_t      *st_p
  );
  
  void rs_mkey_change (
      error_status_t      *st_p
  );
  
  
  void rs_mkey_purge (
      void
  );
  
  



*** main.c	Thu Oct 14 13:45:20 1993
--- main.c.orig	Wed Feb 14 12:49:24 1996
***************
*** 8,13 ****
--- 8,19 ----
  /*
   * HISTORY
   * $Log:	c013349,v $
# Revision 1.2  96/09/24  14:39:21  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [rsalz 2/21/96 public] [rsalz 2/21/96 public]
# 
# Revision 1.1  96/02/21  13:11:24  root
# new CR
# 
+  * Revision /main/HPDCE02/1  1996/02/14  17:49 UTC  jrr
+  * 	Code cleanup.
+  * 	Fix weakness in random key generation.
+  * 	Silence compiler warnings.
+  * 	[1996/02/10  01:22 UTC  sommerfeld  /main/sommerfeld_krb5rng/1]
+  * 
   * Revision 1.1.7.1  1993/10/14  17:45:20  mccann
   * 	CR8651 64bit port
   * 	[1993/10/14  17:42:53  mccann]
***************
*** 48,55 ****
   * All Rights Reserved
   */
  /*
!  * $Source: /project/ot/dce/d01/d33/RCS/c013349,v $
!  * $Author: root $
   *
   * Copyright 1990 by the Massachusetts Institute of Technology.
   *
--- 54,61 ----
   * All Rights Reserved
   */
  /*
!  * $Source: /project/ot/dce/d01/d33/RCS/c013349,v $
!  * $Author: root $
   *
   * Copyright 1990 by the Massachusetts Institute of Technology.
   *
***************
*** 75,81 ****
  
  #if !defined(lint) && !defined(SABER)
  static char rcsid_main_c[] =
! "$Id: c013349,v 1.2 96/09/24 14:39:21 root Exp $";
  #endif	/* !lint & !SABER */
  
  #include <krb5/krb5.h>
--- 81,87 ----
  
  #if !defined(lint) && !defined(SABER)
  static char rcsid_main_c[] =
! "$Id: c013349,v 1.2 96/09/24 14:39:21 root Exp $";
  #endif	/* !lint & !SABER */
  
  #include <krb5/krb5.h>
***************
*** 87,95 ****
  
  #include <com_err.h>
  /* for STDC, com_err gets varargs/stdarg */
- #ifndef __STDC__
- #include <varargs.h>
- #endif
  
  #include <krb5/osconf.h>
  #include <krb5/kdb.h>
--- 93,98 ----
***************
*** 109,126 ****
  #ifdef OSF_DCE
  #   include <rgymacro.h>
  #   include <rs_task.h>
  #endif
  
  
  static void
  kdc_com_err_proc
- #ifndef __STDC__
-     (whoami, code, format, pvar)
- 	const char *whoami;
- 	long code;
- 	const char *format;
- 	va_list pvar;
- #else
    (
  	const char *whoami,
  	long code,
--- 112,123 ----
  #ifdef OSF_DCE
  #   include <rgymacro.h>
  #   include <rs_task.h>
+ #   include <rs_mkey.h>
  #endif
  
  
  static void
  kdc_com_err_proc
    (
  	const char *whoami,
  	long code,
***************
*** 127,139 ****
  	const char *format,
  	va_list pvar
    )
- #endif
  {
      /* XXX need some way to do this better... */
  
- #ifndef __STDC__
-     extern int vfprintf();
- #endif
  
  #if defined(OSF_DCE) && (defined(ultrix) || defined(__osf__))
      /* Ultrix integration must rely on bsd4.2 syslog instead
--- 124,132 ----
***************
*** 180,188 ****
  
  void
  setup_com_err(
- #ifdef __STDC__
      void
- #endif
  )
  {
  #ifndef OSF_DCE
--- 173,179 ----
***************
*** 196,206 ****
      return;
  }
  
  krb5_sigtype
  request_exit(
- #ifdef __STDC__
      void
- #endif
  )
  {
      signal_requests_exit = 1;
--- 187,197 ----
      return;
  }
  
+ 
+ #ifndef OSF_DCE
  krb5_sigtype
  request_exit(
      void
  )
  {
      signal_requests_exit = 1;
***************
*** 208,214 ****
      return;
  }
  
- #ifndef OSF_DCE
  /* Don't setup signal handlers in pthread environment when the server is
   * a thread in the DCE security daemon.
   */
--- 199,204 ----
***************
*** 225,238 ****
  
  void
  usage
- #ifndef __STDC__
-     (name)
-     char *name;
- #else
    (
      char *name
    )
- #endif
  {
      fprintf(stderr, "usage: %s [-d dbpathname] [-r dbrealmname] [-R replaycachename ]\n\t[-m] [-k masterkeytype] [-M masterkeyname]\n", name);
      return;
--- 215,223 ----
***************
*** 240,255 ****
  
  void
  process_args
- #ifndef __STDC__
-     (argc, argv)
-     int argc;
-     char **argv;
- #else
    (
      int argc,
      char **argv
    )
- #endif
  {
      int c;
      krb5_boolean manual = FALSE;
--- 225,234 ----
***************
*** 261,267 ****
      krb5_error_code retval, retval2;
      krb5_enctype etype;
      extern krb5_deltat krb5_clockskew;
! 
      extern char *optarg;
  
      while ((c = getopt(argc, argv, "r:d:mM:k:R:")) != EOF) {
--- 240,247 ----
      krb5_error_code retval, retval2;
      krb5_enctype etype;
      extern krb5_deltat krb5_clockskew;
!     krb5_keyblock *random_keyblock;
!     
      extern char *optarg;
  
      while ((c = getopt(argc, argv, "r:d:mM:k:R:")) != EOF) {
***************
*** 352,362 ****
  	(void) krb5_rc_close(kdc_rcache);
  	exit(1);
      }
  #else
!     master_keyblock.keytype = KEYTYPE_DES;
!     master_keyblock.length = 8;
!     master_keyblock.contents = (krb5_octet *) malloc(master_keyblock.length);
!     bzero(master_keyblock.contents, master_keyblock.length);
  #endif
  
      /* initialize random key generators */
--- 332,346 ----
  	(void) krb5_rc_close(kdc_rcache);
  	exit(1);
      }
+     random_keyblock = &master_keyblock;
  #else
!     retval = rs_mkey_random_keyblock(&random_keyblock);
!     if (retval != NULL) 
!     {
! 	com_err(argv[0], retval, "while generating random key seed");
! 	(void) krb5_rc_close(kdc_rcache);
! 	exit(1);
!     }
  #endif
  
      /* initialize random key generators */
***************
*** 363,369 ****
      for (etype = 0; (int) etype <= krb5_max_cryptosystem; etype++) {
  	if (krb5_csarray[etype]) {
  	    if (retval = (*krb5_csarray[etype]->system->
! 			  init_random_key)(&master_keyblock,
  					   &krb5_csarray[etype]->random_sequence)) {
  		com_err(argv[0], retval, "while setting up random key generator for etype %d--etype disabled", etype);
  		krb5_csarray[etype] = 0;
--- 347,353 ----
      for (etype = 0; (int) etype <= krb5_max_cryptosystem; etype++) {
  	if (krb5_csarray[etype]) {
  	    if (retval = (*krb5_csarray[etype]->system->
! 			  init_random_key)(random_keyblock,
  					   &krb5_csarray[etype]->random_sequence)) {
  		com_err(argv[0], retval, "while setting up random key generator for etype %d--etype disabled", etype);
  		krb5_csarray[etype] = 0;
***************
*** 376,389 ****
  
  void
  finish_args
- #ifndef __STDC__
-     (prog)
-     char *prog;
- #else
    (
      char *prog
    )
- #endif
  {
      krb5_error_code retval;
      if (retval = krb5_rc_close(kdc_rcache)) {
--- 360,368 ----
***************
*** 397,414 ****
  
  krb5_error_code
  init_db
- #ifndef __STDC__
-     (dbname, masterkeyname, masterkeyblock)
-     char *dbname;
-     krb5_principal masterkeyname;
-     krb5_keyblock *masterkeyblock;
- #else
    (
      char *dbname,
      krb5_principal masterkeyname,
      krb5_keyblock *masterkeyblock
    )
- #endif
  {
      krb5_error_code retval;
      int nprincs;
--- 376,386 ----
***************
*** 504,512 ****
  
  krb5_error_code
  closedown_db(
- #ifdef __STDC__
      void
- #endif
  )
  {
      krb5_error_code retval;
--- 476,482 ----
***************
*** 609,615 ****
      krb5_error_code retval;
      int errout = 0;
  #ifdef OSF_DCE
!     krb5_ui_4 sleep_time = 120;       /*  decaying sleep time */
  #endif
  
  #ifdef OSF_DCE
--- 579,585 ----
      krb5_error_code retval;
      int errout = 0;
  #ifdef OSF_DCE
!     unsigned32 sleep_time = 120;       /*  decaying sleep time */
  #endif
  
  #ifdef OSF_DCE






*** rs_mkey.c	Thu Aug 25 17:21:09 1994
--- rs_mkey.c.orig	Wed Feb 14 12:52:11 1996
***************
*** 8,13 ****
--- 8,19 ----
  /*
   * HISTORY
   * $Log:	c013349,v $
# Revision 1.2  96/09/24  14:39:21  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [rsalz 2/21/96 public] [rsalz 2/21/96 public]
# 
# Revision 1.1  96/02/21  13:11:24  root
# new CR
# 
+  * Revision /main/HPDCE02/1  1996/02/14  17:52 UTC  jrr
+  * 	Code cleanup.
+  * 	Fix weakness in random key generation.
+  * 	Silence compiler warnings.
+  * 	[1996/02/10  01:22 UTC  sommerfeld  /main/sommerfeld_krb5rng/1]
+  * 
   * Revision 1.1.7.2  1994/08/25  20:14:23  sekhar
   * 	Put back SVC messages for fatal_st() and error_st() calls.
   * 	[1994/08/25  20:12:49  sekhar]
***************
*** 54,60 ****
  
  #ifdef MODULE_VERSION_ID
  static char *VersionID = 
!     "$Id: c013349,v 1.2 96/09/24 14:39:21 root Exp $";
  #endif
  
  #include <stdio.h>
--- 60,66 ----
  
  #ifdef MODULE_VERSION_ID
  static char *VersionID = 
!     "$Id: c013349,v 1.2 96/09/24 14:39:21 root Exp $";
  #endif
  
  #include <stdio.h>
***************
*** 123,136 ****
   *  No lock required.
   */
  PRIVATE void rs_mkey_gen_init_keyseed
- #ifndef __STDC__
-     ( mname, eblock, keyseed, mkey, st_p )
-     krb5_principal      mname;              /* [in] */
-     krb5_encrypt_block  *eblock;            /* [in] */
-     char                *keyseed;           /* [in] */
-     krb5_keyblock       *mkey;              /* [in, out] */
-     error_status_t      *st_p;              /* [out] */
- #else
      (
      krb5_principal      mname,
      krb5_encrypt_block  *eblock,
--- 129,134 ----
***************
*** 138,144 ****
      krb5_keyblock       *mkey,
      error_status_t      *st_p
      )
- #endif
  {
      krb5_data           scratch;
      krb5_data           pwd;
--- 136,141 ----
***************
*** 211,224 ****
   *  No lock required.
   */
  PRIVATE void rs_mkey_gen_new
- #ifndef __STDC__
-     ( old_rblock, new_mkeyblock, new_master_eblock, new_rblock, st_p )
-     rsdb_realm_info         *old_rblock;        /* [in] */
-     krb5_keyblock           **new_mkeyblock;    /* [out] */
-     krb5_encrypt_block      *new_master_eblock; /* [out] */
-     rsdb_realm_info         *new_rblock;        /* [out] */
-     error_status_t          *st_p;              /* [out] */
- #else
      (
      rsdb_realm_info         *old_rblock,
      krb5_keyblock           **new_mkeyblock,
--- 208,213 ----
***************
*** 226,232 ****
      rsdb_realm_info         *new_rblock,
      error_status_t          *st_p
      )
- #endif
  {
      CLEAR_STATUS(st_p);
  
--- 215,220 ----
***************
*** 274,286 ****
   *  No lock required.
   */
  PRIVATE void rs_mkey_encrypt_key
- #ifndef __STDC__
-     ( eblock, in, out, st_p )
-     krb5_encrypt_block          *eblock;
-     krb5_keyblock               *in;
-     krb5_encrypted_keyblock     *out;
-     error_status_t              *st_p;
- #else
      (
      krb5_encrypt_block          *eblock,
      krb5_keyblock               *in,
--- 262,267 ----
***************
*** 287,293 ****
      krb5_encrypted_keyblock     *out,
      error_status_t              *st_p
      )
- #endif
  {
      /* encrypted rep has the real (unencrypted) key length stored
         along with the encrypted key */
--- 268,273 ----
***************
*** 351,363 ****
   *  No lock required.
   */
  PRIVATE void rs_mkey_decrypt_key
- #ifndef __STDC__
-     ( eblock, in, out, st_p )
-     krb5_encrypt_block          *eblock;
-     krb5_encrypted_keyblock     *in;
-     krb5_keyblock               *out;
-     error_status_t              *st_p;
- #else
      (
      krb5_encrypt_block          *eblock,
      krb5_encrypted_keyblock     *in,
--- 331,336 ----
***************
*** 364,370 ****
      krb5_keyblock               *out,
      error_status_t              *st_p
      )
! #endif
  {
      CLEAR_STATUS(st_p);
      /* the encrypted version is stored as the unencrypted key length
--- 337,343 ----
      krb5_keyblock               *out,
      error_status_t              *st_p
      )
! 
  {
      CLEAR_STATUS(st_p);
      /* the encrypted version is stored as the unencrypted key length
***************
*** 419,431 ****
   *  so that the master_key doesn't change during the operation.
   */
  PRIVATE void rs_mkey_fetch
- #ifndef __STDC__
-     ( keyfile, key, key_version, st_p )
-     char                        *keyfile;       /* [in] */
-     krb5_keyblock               *key;           /* [out] */
-     krb5_kvno                   *key_version;   /* [out] */
-     error_status_t              *st_p;          /* [out] */
- #else
      (
      char                        *keyfile,
      krb5_keyblock               *key,
--- 392,397 ----
***************
*** 432,438 ****
      krb5_kvno                   *key_version,
      error_status_t              *st_p
      )
- #endif
  {
      rsdb_auth_key_t     rsdb_key;
  
--- 398,403 ----
***************
*** 471,490 ****
   *  This operation must be invoked with the global write lock.
   */
  PRIVATE void rs_mkey_store_on_disk
- #ifndef __STDC__
-     ( keyfile, key, key_version, st_p )
-     char                        *keyfile;       /* [in] */
-     krb5_keyblock               *key;           /* [in] */
-     krb5_kvno                   key_version;    /* [in] */
-     error_status_t              *st_p;          /* [out] */
- #else
      (
!     char                        *keyfile,
!     krb5_keyblock               *key,
!     krb5_kvno                   key_version,
!     error_status_t              *st_p
      )
- #endif
  {
      rsdb_auth_key_t     rsdb_key;
  
--- 436,447 ----
   *  This operation must be invoked with the global write lock.
   */
  PRIVATE void rs_mkey_store_on_disk
      (
!     char                        *keyfile,	/* [in] */
!     krb5_keyblock               *key,		/* [in] */
!     krb5_kvno                   key_version,    /* [in] */
!     error_status_t              *st_p		/* [out] */
      )
  {
      rsdb_auth_key_t     rsdb_key;
  
***************
*** 521,540 ****
   *  This operation must be invoked with the global write lock.
   */
  PRIVATE void rs_mkey_encrypt_store_in_db
- #ifndef __STDC__
-     ( mkey,  mkey_version, encblock, st_p )
-     krb5_keyblock       *mkey;
-     krb5_kvno           mkey_version;
-     krb5_encrypt_block  *encblock;
-     error_status_t      *st_p;
- #else
    (
!     krb5_keyblock       *mkey,
!     krb5_kvno           mkey_version,
!     krb5_encrypt_block  *encblock,
!     error_status_t      *st_p
    )
- #endif
  {
      krb5_encrypted_keyblock ekey;
      rsdb_encrypt_key_t      encrypted_mkey;
--- 478,489 ----
   *  This operation must be invoked with the global write lock.
   */
  PRIVATE void rs_mkey_encrypt_store_in_db
    (
!     krb5_keyblock       *mkey,			/* [in] */
!     krb5_kvno           mkey_version,		/* [in] */
!     krb5_encrypt_block  *encblock,		/* [in] */
!     error_status_t      *st_p			/* [out] */
    )
  {
      krb5_encrypted_keyblock ekey;
      rsdb_encrypt_key_t      encrypted_mkey;
***************
*** 581,600 ****
   *  rs_mkey_save should be invoked with the global write lock.
   */
  PRIVATE void rs_mkey_save
- #ifndef __STDC__
-     ( new_mkeyblock, new_master_eblock, new_mkey_version, st_p )
-     krb5_keyblock           *new_mkeyblock;     /* [in] */
-     krb5_encrypt_block      *new_master_eblock; /* [in] */
-     krb5_kvno               *new_mkey_version;  /* [in] */
-     error_status_t          *st_p;              /* [out] */
- #else
      (
!     krb5_keyblock           *new_mkeyblock,
!     krb5_encrypt_block      *new_master_eblock,
!     krb5_kvno               *new_mkey_version,
!     error_status_t          *st_p
      )
- #endif
  {
      sec_rgy_name_t          old_master_key_file;
  
--- 530,541 ----
   *  rs_mkey_save should be invoked with the global write lock.
   */
  PRIVATE void rs_mkey_save
      (
!     krb5_keyblock           *new_mkeyblock,	/* [in] */
!     krb5_encrypt_block      *new_master_eblock,	/* [in] */
!     krb5_kvno               *new_mkey_version,	/* [in] */
!     error_status_t          *st_p		/* [out] */
      )
  {
      sec_rgy_name_t          old_master_key_file;
  
***************
*** 654,677 ****
   * consistency among all replicas)
    */
  PRIVATE void rs_mkey_reencrypt_acct_key
- #ifndef __STDC__
-     ( cursor, old_eblock, old_version, new_eblock, new_version, st_p )
-     sec_rgy_cursor_t            *(cursor);      /* [in, out] */
-     krb5_encrypt_block          *old_eblock;    /* [in] */
-     krb5_kvno                   old_version;    /* [in] */
-     krb5_encrypt_block          *new_eblock;    /* [in] */
-     krb5_kvno                   new_version;    /* [in] */
-     error_status_t              *st_p;          /* [out] */
- #else
      (
      sec_rgy_cursor_t            *(cursor),      /* [in, out] */
!     krb5_encrypt_block          *old_eblock,
!     krb5_kvno                   old_version,
!     krb5_encrypt_block          *new_eblock,
!     krb5_kvno                   new_version,
!     error_status_t              *st_p
      )
- #endif
  {
      sec_rgy_login_name_t        login_name;
      sec_rgy_acct_key_t          name_parts;
--- 595,608 ----
   * consistency among all replicas)
    */
  PRIVATE void rs_mkey_reencrypt_acct_key
      (
      sec_rgy_cursor_t            *(cursor),      /* [in, out] */
!     krb5_encrypt_block          *old_eblock,	/* [in] */
!     krb5_kvno                   old_version,	/* [in] */
!     krb5_encrypt_block          *new_eblock,	/* [in] */
!     krb5_kvno                   new_version,	/* [in] */
!     error_status_t              *st_p		/* [out] */
      )
  {
      sec_rgy_login_name_t        login_name;
      sec_rgy_acct_key_t          name_parts;
***************
*** 799,820 ****
   *  This lock will be promoted and demoted during operation execution.
   */
  PRIVATE void rs_mkey_reencrypt_db_keys
- #ifndef __STDC__
-     ( old_eblock, old_version, new_eblock, new_version, st )
-     krb5_encrypt_block          *old_eblock;    /* [in] */
-     krb5_kvno                   old_version;    /* [in] */
-     krb5_encrypt_block          *new_eblock;    /* [in] */
-     krb5_kvno                   new_version;    /* [in] */
-     error_status_t              *(st);
- #else
      (
!     krb5_encrypt_block          *old_eblock,
!     krb5_kvno                   old_version,
!     krb5_encrypt_block          *new_eblock,
!     krb5_kvno                   new_version,
!     error_status_t              *(st)
      )
- #endif
  {
      unsigned32              i;
      sec_rgy_cursor_t        cursor;
--- 730,742 ----
   *  This lock will be promoted and demoted during operation execution.
   */
  PRIVATE void rs_mkey_reencrypt_db_keys
      (
!     krb5_encrypt_block          *old_eblock,	/* [in] */
!     krb5_kvno                   old_version,	/* [in] */
!     krb5_encrypt_block          *new_eblock,	/* [in] */
!     krb5_kvno                   new_version,	/* [in] */
!     error_status_t              *(st)		/* [out] */
      )
  {
      unsigned32              i;
      sec_rgy_cursor_t        cursor;
***************
*** 865,880 ****
   *  (with, in essence, a global write lock).
   */
  PUBLIC void rs_mkey_create
- #ifndef __STDC__
-     ( rgy_local_cell, keyseed )
-     sec_id_t            *rgy_local_cell;     /* [in] */
-     char                *keyseed;            /* [in] */
- #else
    (
!     sec_id_t            *rgy_local_cell,
!     char                *keyseed
    )
- #endif
  {
      char                    *mkey_name = n_master_key;
      char                    *realm;
--- 787,796 ----
   *  (with, in essence, a global write lock).
   */
  PUBLIC void rs_mkey_create
    (
!     sec_id_t            *rgy_local_cell,	/* [in] */
!     char                *keyseed		/* [in] */
    )
  {
      char                    *mkey_name = n_master_key;
      char                    *realm;
***************
*** 1009,1024 ****
   *  
   */
  PUBLIC void rs_mkey_init
- #ifndef __STDC__
-     ( rep_state, st_p )
-     unsigned32          rep_state;      /* [in] */
-     error_status_t      *st_p;          /* [out] */
- #else
    (
!     unsigned32          rep_state,
!     error_status_t      *st_p
    )
- #endif
  {
      sec_rgy_name_t          old_master_key_file;
      boolean32               old_mkey_file_exists = false;
--- 925,934 ----
   *  
   */
  PUBLIC void rs_mkey_init
    (
!     unsigned32          rep_state,		/* [in] */
!     error_status_t      *st_p			/* [out] */
    )
  {
      sec_rgy_name_t          old_master_key_file;
      boolean32               old_mkey_file_exists = false;
***************
*** 1094,1107 ****
   *  This operation must be invoked with the global write lock.
   */
  PUBLIC void rs_mkey_store_in_db
- #ifndef __STDC__
-     ( st_p )
-     error_status_t      *st_p;
- #else
    (
      error_status_t      *st_p
    )
- #endif
  {
      /* Encrypt master_key and store in database for
       * master_key verification routine.
--- 1004,1012 ----
***************
*** 1125,1137 ****
   *  so that the master_key doesn't change during the operation.
   */
  PUBLIC void rs_mkey_verify
- #ifndef __STDC__
-     ( mkey, mkey_version, eblock, st_p )
-     krb5_keyblock           *mkey;          /* [in] */
-     krb5_kvno               mkey_version;   /* [in] */
-     krb5_encrypt_block      *eblock;        /* [in] */
-     error_status_t          *st_p;          /* [out] */
- #else
      (
      krb5_keyblock           *mkey,
      krb5_kvno               mkey_version,
--- 1030,1035 ----
***************
*** 1138,1144 ****
      krb5_encrypt_block      *eblock,
      error_status_t          *st_p
      )
- #endif
  {
      rsdb_encrypt_key_t          encrypted_mkey;
      krb5_encrypted_keyblock     ekey;
--- 1036,1041 ----
***************
*** 1197,1214 ****
   *  so that the master_key doesn't change during the operation.
   */
  PUBLIC void rs_mkey_encrypt_with_master
- #ifndef __STDC__
-     ( in, out, st_p )
-     krb5_keyblock               *in;        /* [in] */
-     krb5_encrypted_keyblock     *out;       /* [in, out] */
-     error_status_t              *st_p;      /* [out] */
- #else
      (
      krb5_keyblock               *in,
      krb5_encrypted_keyblock     *out,
      error_status_t              *st_p
      )
- #endif
  {
      CLEAR_STATUS(st_p);
   
--- 1094,1104 ----
***************
*** 1233,1245 ****
   *  so that the master_key doesn't change during the operation.
   */
  PUBLIC void rs_mkey_decrypt_with_master
- #ifndef __STDC__
-     ( mkey_version, in, out, st_p )
-     krb5_kvno                   mkey_version;
-     krb5_encrypted_keyblock     *in;
-     krb5_keyblock               *out;
-     error_status_t              *st_p;
- #else
      (
      krb5_kvno                   mkey_version,
      krb5_encrypted_keyblock     *in,
--- 1123,1128 ----
***************
*** 1246,1252 ****
      krb5_keyblock               *out,
      error_status_t              *st_p
      )
- #endif
  {
      if(mkey_version == master_key_version)
          rs_mkey_decrypt_key(&master_encblock, in, out, st_p);
--- 1129,1134 ----
***************
*** 1257,1268 ****
          dce_svc_printf(SEC_RS_MKEY_UNKNOWN_MSG);
  }
  
  
  
  /*
   *  r s _ m k e y _ r a n d o m
   *
!  *  Generate a random DES key.
   *
   *  Lock Notes:
   *  A database (lock_db) read lock is required for this operation
--- 1139,1164 ----
          dce_svc_printf(SEC_RS_MKEY_UNKNOWN_MSG);
  }
  
+ /*
+  *  r s _ m k e y _ r a n d o m
+  *
+  *  Generate a random DES key in a krb5 keyblock.
+  *
+  */
  
+ PUBLIC error_status_t rs_mkey_random_keyblock (
+     krb5_keyblock **random_key
+ )
+ {
+     error_status_t st;
  
+     return krb5_random_key(rblock.eblock, rblock.rseed, random_key);
+ }
+ 
  /*
   *  r s _ m k e y _ r a n d o m
   *
!  *  Generate a random DES key in a sec_passwd_rec_t
   *
   *  Lock Notes:
   *  A database (lock_db) read lock is required for this operation
***************
*** 1269,1289 ****
   *  so that the master_key doesn't change during the operation.
   */
  PUBLIC void rs_mkey_random
- #ifndef __STDC__
-     ( passwd, st_p )
-     sec_passwd_rec_t    *passwd;             /* [in, out] */
-     error_status_t      *st_p;
- #else
    (
      sec_passwd_rec_t    *passwd,
      error_status_t      *st_p
    )
- #endif
  {
      krb5_keyblock       *random_key_p;
  
!     if (*st_p = krb5_random_key(rblock.eblock, rblock.rseed,
!                               &random_key_p))
          return;
      PASSWD_TYPE(passwd) = sec_passwd_des;
      bcopy(random_key_p->contents, DES_PASSWD(passwd),
--- 1165,1178 ----
   *  so that the master_key doesn't change during the operation.
   */
  PUBLIC void rs_mkey_random
    (
      sec_passwd_rec_t    *passwd,
      error_status_t      *st_p
    )
  {
      krb5_keyblock       *random_key_p;
  
!     if (*st_p = rs_mkey_random_keyblock (&random_key_p))
          return;
      PASSWD_TYPE(passwd) = sec_passwd_des;
      bcopy(random_key_p->contents, DES_PASSWD(passwd),
***************
*** 1291,1298 ****
      krb5_free_keyblock(random_key_p);
  }
  
- 
- 
  /*
   *  r s _ m k e y _ s t r i n g _ t o _ k e y
   *
--- 1180,1185 ----
***************
*** 1308,1321 ****
   *  so that the master_key doesn't change during the operation.
   */
  PUBLIC void rs_mkey_string_to_key
- #ifndef __STDC__
-     ( keytype, pwd_data, pepper, key, st_p )
-     krb5_keytype        keytype;        /* [in] */
-     krb5_data           *pwd_data;      /* [in] */
-     krb5_data           *pepper;        /* [in] */
-     krb5_keyblock       *key;           /* [out] */
-     error_status_t      *st_p;          /* [out] */
- #else
    (
      krb5_keytype        keytype,
      krb5_data           *pwd_data,
--- 1195,1200 ----
***************
*** 1323,1329 ****
      krb5_keyblock       *key,
      error_status_t      *st_p
    )
- #endif
  {
      CLEAR_STATUS(st_p);
  
--- 1202,1207 ----
***************
*** 1343,1356 ****
   *  This operation should be called with the GLOBAL_RIW lock.
   */
  PUBLIC void rs_mkey_change
- #ifndef __STDC__
-     ( st_p )
-     error_status_t          *st_p;
- #else
      (
      error_status_t          *st_p
      )
- #endif
  {
      sec_rgy_name_t          old_master_key_file;
      error_status_t          tmp_status;
--- 1221,1229 ----
***************
*** 1462,1470 ****
   *  This operation should be called with the GLOBAL_RIW lock.
   */
  PUBLIC void rs_mkey_purge (
- #ifdef __STDC__
      void
- #endif
  )
  {
      krb5_free_keyblock(master_keyblock_p);
--- 1335,1341 ----


[public 09/24/96]

This was fixed in 1.1 maintenance tree in February.



CR Number                     : 13305
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : dce_login,kinit
Short Description             : Pre-auth fails for kinit,
succeeds for dce_login
Reported Date                 : 2/6/96
Found in Baseline             : 1.1
Found Date                    : 2/6/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/6/96 public]

A support customer reported the following:

    Also, my real problem which I reported is that the ERROR_REP to the AS_REQ
does not include the e_data field with the correct salt.  It returns the error
31 which is a BAD INTEGRITY error, instead of a PREAUTHENTICATION error.  
This happens when I attempt preauthentication with the wrong salt, and also
when I do not do authentication at all.   RFC 1510 states that the ERROR_REP
should contain both an authentication error and return the salt in the e_data
field.  This seems to work okay with dce_login but does not work with kinit.


Repeat By:

	Use the DCE security API to create an account with a password which
uses a non-standard pepper.  Set the pre_auth_req extended attribute for the
principal.  dce_login will succeed.  kinit will fail with invalid password.

[2/7/96 public]

I think this may be a defect, but I would like to make sure of
one thing.

What value is the pre_auth_req ERA set to? If it is set to 2 (DCE Third
Party), then the user will not be able to get a TGT with kinit even if the
salt is a default. This is because kinit uses Krb5 timestamps preauthentication,
which is less secure.

Make sure the pre_auth_req ERA is set to 0 or 1. Please let me know if
kinit still fails.

[2/9/96 public]

The customer reports kinit is failing when :

>   The pre_auth_req is set to 1.



CR Number                     : 13304
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : erarel001 sometimes errors and FAILS
Reported Date                 : 2/6/96
Found in Baseline             : 1.2.1
Found Date                    : 2/6/96
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/6/96 public]

During system testing, erarel001 sometimes fails with the following 
message:
	|Attempting to remove seaclcliblu20prin members from group without permission
	|ERROR: Able to remove member seaclcliblu20prin from group unexpectedly in remove_neg_from_group_or_org
	|ERROR: Some members have been removed unexepectedly from group in remove_neg_from_group_or_org

This does not stop all tests or cause major problems, but it is an intermittent
failure during testing.



CR Number                     : 13297
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : grp_override
Short Description             : override_check_group_passwd fail
Reported Date                 : 2/2/96
Found in Baseline             : 1.2.1
Found Date                    : 2/2/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/2/96 public]

grp_override functional test failing.  24 tests pass, 1 failure:  

FAILED feature override_check_group_passwd seq 8 result: 0   expected: 1



CR Number                     : 13296
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 13220
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : gssapi test
Short Description             : should fail with gssapi crypto capability in export build
Reported Date                 : 2/1/96
Found in Baseline             : 1.2
Found Date                    : 12/17/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/1/96 public]
The gssapi functional test currently prints a notice that data privacy is
available via gssapi; it should actually fail in the export build case.



CR Number                     : 13292
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : login
Short Description             : Remove resetpag() stub from security when available in DFS
Reported Date                 : 1/26/96
Found in Baseline             : 1.2.1
Found Date                    : 1/26/96
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/client/login/sec_login_pvt.c
Sensitivity                   : public

[1/26/96 public]

The function resetpag() is defined as stub. Remove that once its
included in new DFS code.

Meanwhile, workaround is to define a dummy function doing nothing.



CR Number                     : 13277
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : pgo idl file
Short Description             : pgo.idl sec_rgy_pgo_get_members desc wrong.
Reported Date                 : 1/9/96
Found in Baseline             : 1.1
Found Date                    : 1/9/96
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : src/security/idl/pgo.idl
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/9/96 public]

The description in the comments for sec_rgy_pgo_get_members() in pgo.idl
is wrong (implies that it only works for Group and Org domains, but it
also works for Princ domain) (and the title in the comment is wrong; it
calls it rs_pgo_get_members() ).  This is minor, but has confused one
developer already, so it's worth fixing soon.



CR Number                     : 13276
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : hpux
Component Name                : sec
Subcomponent Name             : 
Short Description             : TKT rqst for local alias treated as foreign
Reported Date                 : 1/8/96
Found in Baseline             : 1.1
Found Date                    : 5/26/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/10/96 public]
Ticket requests to alias names for the local privilege server are treated as
foreign cell requests.  At DCE 1.1 the privilege server removes ERAs from
credentials requested by foreign cells.  Therefore the credentials returned by
ticket requests to alias names will not include ERAs.

[1/9/96 public]
Moved the description to the description section and created a reasonable
size short description for the subject header.



CR Number                     : 13228
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : functional/security migration-tc
Short Description             : sec_rgy_attr() doesn't init cursor
Reported Date                 : 12/19/95
Found in Baseline             : 1.1
Found Date                    : 12/19/95
Severity                      : A
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/test/functional/security/ts/client/migration/migration-tc.c
Sensitivity                   : public

[12/19/95 public]

In migration-tc.c, sec_rgy_att() is calling sec_rgy_attr_sch_update_entry()
with a NULL sch_entry_p.  This is not allowed, and in some cases, causes
the test to hang.

Also, sec_rgy_attr() is calling sec_rgy_attr_lookup_by_id()
with an uninitialized cursor, leading to a crash.  The man page for
sec_rgy_attr_lookup_by_id() allows this, but the man page is wrong
(this will be a seperate OT).  migration-tc.c must initialize the
cursor.

Diffs:
*** migration-tc.c.old  Tue Dec 19 12:19:03 EST 1995
--- migration-tc.c      Tue Dec 19 12:20:58 EST 1995
***************
*** 122,129 ****
  static void sec_rgy_attr_sch(void)
  {
      error_status_t            st;
!     sec_attr_schema_entry_t   *sch_entry_p = NULL,
!                               sch_entry,
                                schema_entries[1];
      uuid_t                    attr_id;
      unsigned32                        cur_num_entries,
--- 122,129 ----
  static void sec_rgy_attr_sch(void)
  {
      error_status_t            st;
!     sec_attr_schema_entry_t   sch_entry,
!                               *sch_entry_p = &sch_entry,
                                schema_entries[1];
      uuid_t                    attr_id;
      unsigned32                        cur_num_entries,
***************
*** 219,224 ****
--- 219,230 ----
       * sec_attr_trig_update
       */

+     sec_rgy_attr_cursor_init( context, sec_rgy_domain_person, (unsigned_char_p
_t) "root",
+                             &num_attrs, &cursor, &st);
+     CHECK_RESULT(true, "Migration(sec_rgy_attr): sec_rgy_attr_cursor_init",
+         &st, error_status_ok);
+
+     num_attrs = 1;
      sec_rgy_attr_lookup_by_id(context, sec_rgy_domain_person, (unsigned_char_p
_t)"root",
                              &cursor, num_attrs, num_attrs, attrs, &num_ret, ou
t_attrs,
                              &num_left, &st);



CR Number                     : 13227
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : migration-tc
Short Description             : various bugs
Reported Date                 : 12/19/95
Found in Baseline             : 1.1
Found Date                    : 12/19/95
Severity                      : A
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/test/functional/security/ts/client/migration/migration-tc.c
Sensitivity                   : public

[12/19/95 public]

A few more bugs in migration-tc.c;



CR Number                     : 13221
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_login
Short Description             : Local rgy stale info may be used inappropriately
Reported Date                 : 12/7/95
Found in Baseline             : 1.1
Found Date                    : 12/7/95
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : sec_login_pvt.c
Sensitivity                   : public
Transarc Deltas               : cox-OT13221-lrgy-ignore-deleted-users
Transarc Status               : open

[12/7/95 public]
In sec_login_pvt_allocate_login_context:
This function attempts to contact the DCE registry for
sec_id_parse_name, and if it fails, tries to find the named principal
in the local registry.  It seems to me that the reason for this is
that if the network registry is unavailable, we want the function to
succeed anyway (which is entirely reasonable).
However, if a principal has been _deleted_ from the DCE registry, the
function may still succeed because the principal may still be in the
local registry.  It seems to me that if the error returned from
sec_id_parse_name is sec_rgy_object_not_found, the function should not
try the local registry but instead return with that status set.
(I.e., only try the local registry if the network registry is
unavailable.)
The following change should probably take care of it:
*** sec_login_pvt.c~	Mon Dec  4 11:44:02 1995
--- sec_login_pvt.c	Tue Dec  5 16:04:54 1995
***************
*** 2705,2710 ****
--- 2705,2718 ----
                  }
              }
          }
+ 
+ 	/* If the failure was because the principal is not present
+ 	 * in the registry, then don't try the local registry -- he
+ 	 * may have been deleted.  We _do_ want to try it if the
+ 	 * network registry is unavailable, however.
+ 	 */
+ 	if ( stp && *stp == sec_rgy_object_not_found )
+ 	    goto errout;
  
          if (BAD_STATUS(stp)) {
  
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `open'

[1/9/96 public]
Filled in Transarc Deltas with `cox-OT13221-lrgy-ignore-deleted-users'



CR Number                     : 13216
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : eraobj001 test rgy_edit and acl_edit errors
Reported Date                 : 12/5/95
Found in Baseline             : 1.2
Found Date                    : 11/29/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[12/5/95 public]
 
These problems were seen at the end of the long (36 hour) CHO run 
in 3 out 22 runs of the eraobj001 test.    

It is suspected that these problems occurred because of failing DCE. 

Some "rgy_edit -update" and acl_edit commands fail.  

The portion of the journal of concern is as follows: 

520|0 1 16150 1 327|Attempting to authenticate the cell by seacladblu2p
520|0 1 16150 1 328|The cell is now authenticated by seacladblu2p
520|0 1 16150 1 329|Attempting to assign "M" permission in sec/org/seaclcliblu20
org for seaclcliblu21
520|0 1 16150 1 330|ERROR: Unable to assign permission for seaclcliblu21
520|0 1 16150 1 331|Attempting to authenticate the cell by seaclcliblu21
520|0 1 16150 1 332|The cell is now authenticated by seaclcliblu21
520|0 1 16150 1 333|Attempting to add seaclcliblu20prin member to org in add_to_
group_or_org
520|0 1 16150 1 334|Members seaclcliblu20prin have been ADDED properly to org se
aclcliblu20org
520|0 1 16150 1 335|ERROR: in adding member of organization
520|0 1 16150 1 336|Testing permission to delete member of organization
520|0 1 16150 1 337|Attempting to authenticate the cell by seacladblu2p
520|0 1 16150 1 338|The cell is now authenticated by seacladblu2p
520|0 1 16150 1 339|Attempting to remove "M" permission in sec/org/seaclcliblu20
org for seaclcliblu21
520|0 1 16150 1 340|ERROR: Unable to remove permission for seaclcliblu21

520|0 1 16150 1 347|Attempting to authenticate the cell by seacladblu2p
520|0 1 16150 1 348|The cell is now authenticated by seacladblu2p
520|0 1 16150 1 349|Attempting to assign "M" permission in sec/org/seaclcliblu20
org for seaclcliblu21
520|0 1 16150 1 350|Able to assign permission for seaclcliblu21
520|0 1 16150 1 351|Attempting to authenticate the cell by seaclcliblu21
520|0 1 16150 1 352|The cell is now authenticated by seaclcliblu21
520|0 1 16150 1 353|Attempting to remove seaclcliblu20prin members from org
520|0 1 16150 1 354|Members seaclcliblu20prin have been removed properly from se
aclcliblu20org
520|0 1 16150 1 355|ERROR: in deleting member of organization
520|0 1 16150 1 356|ERROR: in add_del_org()



CR Number                     : 13205
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : error message invalid password
Reported Date                 : 11/16/95
Found in Baseline             : 1.1
Found Date                    : 11/16/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/16/95 public]

If a program gets 2 keys entered into the keytab file in the same 
second when the code that trys to refresh the key looks through 
the list it compares the version numbers and timestamps.  If a 
larger numbered key is found with the same timestamp it does not
think it is the latest key.

This was originally reported by the CICS development team.

Here is an explaination of the solution.

Somehow, your region managed to get two keys in the keytab with different version
numbers but the same timestamp - version 1 and version 2 were apparently written
in the same second.  The code as written walks through the keytab looking for
the entry that matchs and has the highest timestamp.  It will hit version 1 first
and then when it hits version 2 it compares the timestamps and since the timestamp
for version 2 is not greater than version 1, it doesn't think it is later.

What it needs to do is check for the case where the timestamps match, and then
choose the greater version number.  It probably should also allow for the possibility
that the version number could wrap in the 8 bit field.

Here is the solution that we implemented.

Here's how I changed the compare.  Instead of just checking ktentry.timestamp > ts
I also check the case that ktentry.timestamp == ts and the version number
is greater.  Since I want to handle the case of wrapping, I say if the difference
between the ktentry vno and the already found version is less than 128 (modulo 255)
we've got a more recent entry.  The idea is that the version numbers won't ever
get more than a few numbers apart in one second, and if we didn't wrap the difference
will be small, while if we did wrap the difference will be between -255 and -245, e.g.
0xffffff01 and 0xffffff0b, which when ANDed with 0xff gives 0x01 and 0x0b.

#if defined(AIX_PROD) || defined(IBMOS2)  /* CMVC 14949 */
                && (!found_one || (found_one && ((ktentry.timestamp > ts) ||
                ((ktentry.timestamp == ts) && (((ktentry.vno - keydata->version_number) & 0xff) < 0x
80))
))) ) {
#else
                && (!found_one || (found_one && ktentry.timestamp > ts)) ) {
#endif  /* CMVC 14949 */



CR Number                     : 13198
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : prob_gd/sec.sams
Short Description             : missing "undocumented" from pad entries
Reported Date                 : 11/13/95
Found in Baseline             : 1.1
Found Date                    : 11/13/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : security/idl/sec.sams,h/sad.sams
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/13/95 public]
Ward Rosenberry reports the following:

 Two appendixes at the back of the Problem Determination Guide offer
 ways to look up error message information. Appendix A organizes by
 message numbers pointing to symbolic name. Appendix B organizes by
 message text string pointing to symbolic name.  In both cases you then
 look up the actual message using the symbolic name.

 Both appendixes include many entries (mostly in the sec component)
 that point to symbolic names which don't exist in the message part of
 the book.  For instance, Appendix B has a text string
 "sec_cred_s_PAD9" pointing to symbolic name "sec_cred_s_PAD9". However
 there is no message in the main body of the book with that symbolic
 name.  There are lots of these.

Rich, please correct anything misleading I may have entered in the
above.

[11/18/95 public]
I took a look at the src/security/idl/sec.sams file and found entries
like this:
    start
    code    sec_cred_s_PADd
    text    "sec_cred_s_PADd"
    explanation    "?"
    action         "None required"
    end
The bug is that it doesn't say "start undocumented".  Which it should.
So I marked this as a doc bug; you folks will have to figure out which
components have this problem and then get the engineers to fix them.

[3/20/96 public]
This is fixed in the 1.2.1 Problem Determination Guide; that is, I
inserted the necessary "undocumented" tags in the copied (from the
tree) sams file before using it to build the book code. There is only
one such offending file, namely "sad.sams". I don't know who
the actual owner of the component is, so I'm assigning the bug to
HP and changing the fixby-date to 1.2.2.

[6/18/96 public]
It appears that sec.sams has been fixed for a while now (in 1.2.1 too).
sad.sams (the admin tool msg file) still needs to be fixed.



CR Number                     : 13174
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : rs_replist2_read fails to init replist[]
Reported Date                 : 10/29/95
Found in Baseline             : 1.1wp
Found Date                    : 10/29/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/server/rs/rs_replist2.c
Sensitivity                   : public

[10/29/95 public]

Affected file: /security/server/rs/rs_replist2.c
 
Problem: 

        rs_replist2_read may fail to init output structure replist[].

Full Description:

rs_replist2_read and rs_replist2_read rely on a call to read_replica()
to initialize the output array of structures replist[].  If read_replica()
fails, the output array will contain residue which is later processed by
the rpc runtime.


Proposed Solution:  preset the output structure to zero prior to
                    calling read_replia().

[11/01/95 public]

Removed extraneous info/header from previous note.



CR Number                     : 13147
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : secd
Short Description             : rs_replist_read may fail to set output parameter *n_ents
Reported Date                 : 10/7/95
Found in Baseline             : 1.1wp
Found Date                    : 10/7/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : security/server/rs/rs_replist.c
Sensitivity                   : public

[10/7/95 public]

Customer reported:


rs_replist_read does not set the output parameter *n_ents when the
"BEGIN_READ" check fails. The rpc runtime proceeds to marshal the
response using the fault *n_ents value.  Compare the following
code with rs_replist_read_full().
- - - - -

void  rs_replist_read
  (
    handle_t            h,          /* [in] */
    uuid_t              *marker,    /* [in, out] */
    unsigned32          max_ents,   /* [in] */
    unsigned32          *n_ents,    /* [out] */
    rs_replica_item_t   replist[],  /* [out, length_is(*n_ents), size_is(max_ent
s)] */
    error_status_t      *st
  )
{

    BEGIN_READ(lock_replist, st) {

        rs_replist2_read(marker, max_ents, n_ents, replist, st);

    } END_READ

}

- - - -

Repeat By:


Proposed Solution:

Preset *n_ents to zero.
- - - - -

    *n_ents = 0;
    BEGIN_READ(lock_replist, st) {

        rs_replist2_read(marker, max_ents, n_ents, replist, st);

    } END_READ

[11/16/95 public]
Fix submitted to 1.1maint tree.



CR Number                     : 13143
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 13142
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : fix malloc/free wrappers
Reported Date                 : 10/4/95
Found in Baseline             : 1.2
Found Date                    : 10/4/95
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/4/95 public]

As part of the XIDL integration it was realized/decided that idl_size_t
must be a typedef for the local size_t datatype.  To aid portability
and reduce confusion we want to replace all idl_size_t's with size_t
wherever possible.  This will make it unnecessary to have "wrappers"
around malloc and free.  There are some in the sec code, that can
be removed.  (Some wrappers that is.)



CR Number                     : 13118
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : app_gd
Short Description             : App Gd description of sec_login_setup_identity is wrong.
Reported Date                 : 9/11/95
Found in Baseline             : 1.1
Found Date                    : 9/11/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/11/95 public]

In section 29.2.1 of the Application Dev Gd, it says:

"An application invokes sec_login_setup_identity() so that it can then make
other authenticated RPC calls.  However, sec_login_setup_identity() is itself
a local interface to an authenticated remote procedure call, and authenticated
RPC needs a validated login context in order to execute."

This is incorrect and should just be removed from the document.

[5/17/96 public]

Corrected sub-component field, assigned to HP.



CR Number                     : 13117
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : app_ref
Short Description             : Incorrect note on sec_login_setup_identity manpage
Reported Date                 : 9/11/95
Found in Baseline             : 1.1
Found Date                    : 9/11/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/11/95 public]

App Ref description of sec_login_setup_identity() includes a note saying that
neither it nor sec_login_validate_identity() fail when an account has expired.
As of DCE1.1 that is no longer true (it never failed with either before, now
it fails correctly with sec_login_validate_identity() on the server side).  The
note should be removed (here and in the manpage and anyplace else it appears).

[11/2/95 public]

Assigned to HP.



CR Number                     : 13113
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : admin_gd
Short Description             : principal create alias doc error
Reported Date                 : 9/11/95
Found in Baseline             : 1.1
Found Date                    : 9/11/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/11/95 public]

Admin Guide Core Components, section 30.9.1 "Creating Aliases" has
a bad error.  The "-alias" option is incorrectly explained and does
not show the required yes/no value.  The two examples are also
wrong.  The whole section, therefore, is misleading and unhelpful.

[5/17/96 public]

Assigned to HP.



CR Number                     : 13102
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : erarel001 fails-unable to delete schema
Reported Date                 : 9/6/95
Found in Baseline             : 1.2
Found Date                    : 8/31/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/6/95 public]

System test erarel001 fails with the following errors: 

ERROR: Unable to remove all objects in del_obj() for ibm_l3
ERROR: Schema /.:/sec/xattrschema/sestribm_l4aibm_l3 was not
 deleted from registry as expected in delete_schema
ERROR: Unable to remove all objects in del_obj() for ibm_l4



CR Number                     : 13095
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : admin_gd
Short Description             : pwd_strengthd doc deficiencies
Reported Date                 : 9/5/95
Found in Baseline             : 1.1
Found Date                    : 9/5/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/5/95 public]

There are a couple of documentation problems that make password
strength management hard to use.

First, the example in section 30.6.3 (Adm Gd Core) on how to create 
a principal with a binding attribute for pwd_strengthd is probably wrong.
This example command fails when I try to execute it.  Because there 
is no documentation for the "binding" ERA type, I don't know for 
certain what a correct value for pwd_mgmt_binding might look like.

Second, there should be more discussion about the practical
problem of running a password strength server in a cell that includes
clients that may not support RPC privacy packet encryption.  This
problem is obvious when you look at the sample pwd_strengthd code and
think about what the auth_info field of pwd_mgmt_binding means.

Since export controls have resulted in a profusion of DCE products
without encryption support, documentation might do well to explain
a pwd_strengthd deployment strategy regarding this issue.  Initially, 
pwd_strengthd looks like it might just work out of the box.  For 
many users it won't.

[9/6/95 public]

Just noticed the section on password management in the release notes.
The caveat about using pwd_strengthd with a  "non-domestic" version
of DCE 1.1 because of the lack of password encryption is noted.
The note could be embellished to point out that most "domestic"
versions of DCE 1.1 lack password encryption as well.

[5/17/96 public]

Assigned to HP.



CR Number                     : 13094
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : admin_gd
Short Description             : "binding" ERA encoding type
not documented
Reported Date                 : 9/5/95
Found in Baseline             : 1.1
Found Date                    : 9/5/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/5/95 public]

The Admin Guide - Core Components, section 32.2.7 has a table (32-2)
that describes the predefined ERA encoding types.  The description
for the "binding" type refers the reader to the section called
"Defining Attribute Binding".  This section does not exist, and
I cannot locate any additional documentation that sufficiently
describes this type.

[5/17/96 public]

Assigned to HP.



CR Number                     : 13087
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : acl binding
Short Description             : one-way auth is insecure
Reported Date                 : 8/31/95
Found in Baseline             : 1.0
Found Date                    : 8/31/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/31/95 public]

There are some mis-features in the way sec_acl_bind & friends (bind_to_addr,
etc) work.  It's not clear if they are bugs, representative of bigger
overall issues, or if there are reasonable work-arounds.  I am sure that
some of this could/should be split into separate OT's, but as there is
at least one real security bug I'm going to open this OT and fill it with
all I know.

On the one hand we constantly say that CDS isn't part of the TCB, 
yet sec_acl_bind uses CDS.  Perhaps we need to document (and reinforce)
better how to use sec_acl_bind_to_addr.

More importantly, the authentication is only one-way.  The client is
authenticated to the server.  The client has no way of knowing that it is
talking to the right server, because the acl binding code calls rpc...inq_name
itself, rather then providing an API that lets the client name who it expects
to have on the other side.

There might be other places in DCE where one-way auth is used, arguably broken.

[02/02/96 public]
Looking back, "arguably broken" seems a little harsh.  This is really
asking for new functionality.  Made an enhancement.



CR Number                     : 13033
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : client
Short Description             : some files don't check malloc()
					     for failures.
Reported Date                 : 8/9/95
Found in Baseline             : 1.1
Found Date                    : 8/9/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/9/95 public]

Three files in src/security/client/rca don't deal with malloc() failures
well; priv.c, sec_lrgy.c, and sec_rgy_attr.c.

	priv.c, at lines 879, 886, 1489, 1496, 2077, 2084, 2683, and
2690, appears to detect malloc failures, but does not set the status
code to indicate a failure.
	sec_lrgy.c, at lines 721, 726, 731, 736, 741, 746, 751, 756,
763, 770, 909, 913, and 918, does not check for a NULL return from
malloc().
	sec_rgy_attr.c, at lines 461 and 625, does not check for a NULL
return from malloc().

	These line numbers are from the HP Warranty Patch code.

	I gave this a "B2" because there is no work-around, and these
bugs can cause an application to crash, but to my knowledge no one has
run into them yet.



CR Number                     : 13019
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : Coding error in krb5_ktfileint_internal_read_entry()
Reported Date                 : 8/4/95
Found in Baseline             : 1.1
Found Date                    : 3/24/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : security/krb5/lib/keytab/file/ktf_util.c
Sensitivity                   : public

[8/4/95 public]

1) In krb5_ktfileint_internal_read_entry(),
ret_entry->principal is allocated twice, when KRB5_BETA1 is defined.
The first allocation should be removed.

2) There are many missing free()s, when it returns with error, too.
All of the return after the allocation of ret_entry->principal, should be
changed to "goto fail".

=============================================================
src/security/krb5/lib/keytab/file/ktf_util.c
=============================================================
***************
*** 308,313 ****
--- 308,316 ----
      if (!(ret_entry = (krb5_keytab_entry *)calloc(1, sizeof(*ret_entry))))
        return ENOMEM;

+     /* This is to free the pointer in case of error */
+     *entrypp = ret_entry;
+
      /* fseek to synchronise buffered I/O on the key table. */

      if (fseek(KTFILEP(id), 0L, SEEK_CUR) < 0)
***************
*** 348,356 ****
--- 351,363 ----
      }
      if (!count || (count < 0))
        return KRB5_KT_END;
+ #if !defined (AIX_PROD) && !defined (IBMOS2)
+ #ifndef KRB5_BETA1
      ret_entry->principal = (krb5_principal)malloc(sizeof(krb5_principal_data))
;
      if (!ret_entry->principal)
          return ENOMEM;
+ #endif
+ #endif

  #ifdef KRB5_BETA1
      count++;
***************
*** 357,378 ****
      if (!(ret_entry->principal = (krb5_data **)calloc(count+1, sizeof(krb5_dat
a *))))
        return ENOMEM;
      for (i = 0; i < count; i++) {
!       if (!xfread(&princ_size, sizeof(princ_size), 1, KTFILEP(id)))
!           return KRB5_KT_END;
        if (KTVERSION(id) != KRB5_KT_VNO_1)
            princ_size = ntohs(princ_size);
!       if (!princ_size || (princ_size < 0))
!           return KRB5_KT_END;

!       if (!(ret_entry->principal[i] = (krb5_data *)malloc(sizeof(krb5_data))))
!           return ENOMEM;
        ret_entry->principal[i]->length = princ_size;
        ret_entry->principal[i]->data = malloc(princ_size);
!       if (!ret_entry->principal[i]->data)
!           return ENOMEM;
!       if (!xfread(ret_entry->principal[i]->data, sizeof(char), princ_size,
!                   KTFILEP(id)))
!           return KRB5_KT_END;
      }
     /* read in the principal type and throw it away, if we can get it */
      if (KTVERSION(id) != KRB5_KT_VNO_1) {
--- 364,396 ----
      if (!(ret_entry->principal = (krb5_data **)calloc(count+1, sizeof(krb5_dat
a *))))
        return ENOMEM;
      for (i = 0; i < count; i++) {
!         if (!xfread(&princ_size, sizeof(princ_size), 1, KTFILEP(id))) {
!             error = KRB5_KT_END;
!             goto fail;
!         }
        if (KTVERSION(id) != KRB5_KT_VNO_1)
            princ_size = ntohs(princ_size);
!         if (!princ_size || (princ_size < 0)) {
!             error = KRB5_KT_END;
!             goto fail;
!         }

!         if (!(ret_entry->principal[i] = (krb5_data *)malloc(sizeof(krb5_data))
))
!         {
!             error = ENOMEM;
!             goto fail;
!         }
        ret_entry->principal[i]->length = princ_size;
        ret_entry->principal[i]->data = malloc(princ_size);
!         if (!ret_entry->principal[i]->data) {
!             error = ENOMEM;
!             goto fail;
!         }
!         if (!xfread(ret_entry->principal[i]->data, sizeof(char), princ_size,
!                     KTFILEP(id))) {
!             error = KRB5_KT_END;
!             goto fail;
!         }
      }
      /* read in the principal type and throw it away, if we can get it */
      if (KTVERSION(id) != KRB5_KT_VNO_1) {

[10/6/95 public]

Submitted to 1.1 maint code base.

[12/29/95 public]
NOTE: (1) above has already been fixed in 1.2.1.
(2) from above should not be done unless you also make sure that it zeroes
out the length first, right after allocating it (because the fail: section
uses that in the loop condition).



CR Number                     : 13018
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : gssapi
Short Description             : Acceptor credentials time-out
Reported Date                 : 8/4/95
Found in Baseline             : 1.1
Found Date                    : 8/4/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/4/95 public]
There is a bug in gss_accept_sec_context's handling of login-contexts.  When 
a server application calls gss_accept_sec_context and requests the client's
name, GSSAPI has to translate the client's UUID (obtained from the PAC) by
making an RPC to the registry, which requires a login-context.  If the
credential being used to accept the context is not capable of initiating
security contexts (i.e it's a GSS_C_ACCEPT credential), it doesn't contain
a login-context, so gss_accept_sec_context has to create one from the
credential's keytable entry.  This login-context is cached in the credential
for subsequent use.

Once the cached login-context expires, gss_accept_sec_context is supposed to
refresh it if it needs to translate another name.  The code is there to do
this refresh, but it never gets executed.

There are several workarounds, until I can get a fix for this:

i)  Don't ask for the client's name.  If the server is using DCE ACLs it
    doesn't need the client's name to do access control.  If the client's
    name is subsequently needed (e.g. for auditing), the application can
    do the translation itself, using its own login-context management.

ii) Use a fresh credential for each gss_accept_sec_context.  A fresh credential
    won't have a cached login-context, so gss_accept_sec_context will always
    create a new one.

iii) Use the Kerberos mechanism.  This mechanism transfers the client's name
     within the authentication token, so no registry translation is needed.
     Of course, the server doesn't get the client's PAC this way.

[8/4/95 public]

(i) is the solution we chose for the DCE sec_cred API.  Calls
to sec_cred_get_client_princ_name() return a sec_s_authz_cannot_comply
sttaus when the authorization service in use is authz_dce.



CR Number                     : 13015
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : more mem leaks in security APIs
Reported Date                 : 8/3/95
Found in Baseline             : 1.1wp
Found Date                    : 8/3/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : 
src/security/client/acl/daclbind.c
src/rpc/runtime/nsentry.c
src/admin/dced/server/init.c
Sensitivity                   : public

[8/3/95 public]
There are memory leaks in the DCED Database init routines and also in the
acl client binding code.

The point of this defect is to change rpc_ns_entry_inq_resolution to allocate
them as RPC_C_MEM_STRING so they can be freed with rpc_string_free().

=============================================================
src/security/client/acl/daclbind.c
=============================================================
***************
*** 450,456 ****
                    (char *)unresolved_name));
                strcpy((char *)tmp_unresolved_name, (char *)(unresolved_name +
                    1));
!               free(unresolved_name);
                  unresolved_name = tmp_unresolved_name;
            }
          /* component_name = unresolved_name + optional residual */
--- 450,456 ----
                    (char *)unresolved_name));
                strcpy((char *)tmp_unresolved_name, (char *)(unresolved_name +
                    1));
!               rpc_string_free(&unresolved_name, &st);
                  unresolved_name = tmp_unresolved_name;
            }
          /* component_name = unresolved_name + optional residual */
***************
*** 492,498 ****
        free((char *)residual);
      /* If we had an unresolved name and it's not the component name, free it *
/
      if ((unresolved_name != NULL) && (unresolved_name != component_name))
!       free((char *)unresolved_name);

      SEC_DBG_PRINTF(1,("sec_acl_bind: resolved name is '%s'\n",resolved_name));
      /* Get the uuid for the object
--- 492,501 ----
        free((char *)residual);
      /* If we had an unresolved name and it's not the component name, free it *
/
      if ((unresolved_name != NULL) && (unresolved_name != component_name))
!     {
!       rpc_string_free(&unresolved_name, &st);
!       unresolved_name = NULL;
!     }

      SEC_DBG_PRINTF(1,("sec_acl_bind: resolved name is '%s'\n",resolved_name));
      /* Get the uuid for the object
***************
*** 863,869 ****
                          IMPORT_HANDLE_VALID(context) = false;
                      }
                      if (HANDLE_STR(context) != (unsigned_char_p_t)NULL) {
!                         free((char *) HANDLE_STR(context));
                          HANDLE_STR(context) = (unsigned_char_p_t)NULL;
                      }
                      rebound = true;
--- 866,872 ----
                          IMPORT_HANDLE_VALID(context) = false;
                      }
                      if (HANDLE_STR(context) != (unsigned_char_p_t)NULL) {
!                         rpc_string_free(&(HANDLE_STR(context)), stp);
                          HANDLE_STR(context) = (unsigned_char_p_t)NULL;
                      }
                      rebound = true;
***************
*** 1034,1040 ****
                                      SET_STATUS(&lst, sec_acl_object_not_found)
;
                                      SEC_DBG_PRINTF(1,
                                      ("sec__acl_check_binding: skip over identi
cal binding\n"));
!                                     free((char *)hstr);
                                }
                            }
                          }
--- 1037,1043 ----
                                      SET_STATUS(&lst, sec_acl_object_not_found)
;
                                      SEC_DBG_PRINTF(1,
                                      ("sec__acl_check_binding: skip over identi
cal binding\n"));
!                                     rpc_string_free(&hstr, &lst);
                                }
                            }
                          }
***************
*** 1055,1061 ****
                      HANDLE_VALID(context) = true;   /* Rebound successfully */
                      HANDLE(context) = handle;
                      if (HANDLE_STR(context) != (unsigned_char_p_t)NULL)
!                         free((char *) HANDLE_STR(context));
                      HANDLE_STR(context) = hstr;
                      return true;
                  } else {
--- 1058,1064 ----
                      HANDLE_VALID(context) = true;   /* Rebound successfully */
                      HANDLE(context) = handle;
                      if (HANDLE_STR(context) != (unsigned_char_p_t)NULL)
!                         rpc_string_free(&(HANDLE_STR(context)), st_p);
                      HANDLE_STR(context) = hstr;
                      return true;
                  } else {



=============================================================
src/rpc/runtime/nsentry.c
=============================================================
***************
*** 718,724 ****
                  *resolved_name,
                  unsigned_char_p_t,
                  partial_results_length+1,
!                 RPC_C_MEM_NSRESOLUTION,
                  RPC_C_MEM_WAITOK);

              strcpy ((char *) *resolved_name, (char *)partial_results);
--- 718,724 ----
                  *resolved_name,
                  unsigned_char_p_t,
                  partial_results_length+1,
!                 RPC_C_MEM_STRING,
                  RPC_C_MEM_WAITOK);

              strcpy ((char *) *resolved_name, (char *)partial_results);
***************
*** 751,757 ****
                  *unresolved_name,
                  unsigned_char_p_t,
                  residual_length+1,
!                 RPC_C_MEM_NSRESIDUAL,
                  RPC_C_MEM_WAITOK);

              strcpy ((char *) *unresolved_name,
--- 751,757 ----
                  *unresolved_name,
                  unsigned_char_p_t,
                  residual_length+1,
!                 RPC_C_MEM_STRING,
                  RPC_C_MEM_WAITOK);

              strcpy ((char *) *unresolved_name,


=============================================================
src/admin/dced/server/init.c
=============================================================
***************
*** 229,235 ****
        unsigned_char_t *ucp;
        uuid_to_string(cf_pp_list[i], &ucp, st);
        sprintf(buf, "%s %s/bin/%s", ucp, dcelocal_path, DCECF_POSTPROC);
!       free(ucp);
        sa->strings[sa->num_strings] = (idl_char *)dce_strdup(buf);
        sa->num_strings++;
      }
--- 229,235 ----
        unsigned_char_t *ucp;
        uuid_to_string(cf_pp_list[i], &ucp, st);
        sprintf(buf, "%s %s/bin/%s", ucp, dcelocal_path, DCECF_POSTPROC);
!       rpc_string_free(&ucp, st);
        sa->strings[sa->num_strings] = (idl_char *)dce_strdup(buf);
        sa->num_strings++;
      }

[10/2/95 public]
Fixed in 1.1maint code



CR Number                     : 13011
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : RCA
Short Description             : assert in sec_rgy_site_close()
Reported Date                 : 8/3/95
Found in Baseline             : 1.1wp
Found Date                    : 6/15/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
security/client/rca/internal_binding.c
Sensitivity                   : public

[8/3/95 public]

Note: this may be the same problem reported by 12952.

There is a problem in the locking scheme in internal_binding.c
sec_rgy_site_close() only locks the context handle that it is passed,
NOT the cache_mutex (which protects against concurrent list ops.
There are several places in the code where a particular context is
chosen and the refcount incremented under only the cache_mutex lock, not
its individual handle lock.  

        binding_cache_enter(): When a new context is being created, 
           rca_handle_init() sets the refcount to 1.  This is OK since
           the new context is not in the cache list yet (so it is in-
           visible to other operations).  rca_site_bind() calls 
           binding_cache_enter() to actually enter the new context into
           the list.  Under the protection of cache_mutex only, 
           binding_cache_enter() inc's refcount.  If an app has called
           sec_rgy_site_close(), there is a race condition since 
           sec_rgy_site_close() takes only the context handle mutex.

           I was able to move the refcount++ up in the routine so 
           that it gets done before the new context is inserted into
           the cache (and is thus visible to other routines like
           sec_rgy_site_close).  This change was just more efficient
           since I got away with not taking a lock!

        binding_cache_lookup(): Exactly the same problem here.  At the
           end of the routine, under the protection of only cache_mutex,
           refcount is inc'd.  This indicates a cache hit.  But the same
           race condition exists as mentioned above for binding_cache_enter().

           I added a call to rca_lock_handle() to lock the context just
           inside the loop where cur traverses the cache.  Then at the
           bottom of the loop (in the case of a cache hit) AND just outside
           of the loop (in the case of a cache miss) I added the necessary
           rca_unlock_handle().

A concrete example of the race condition.  thread1 has already opened
a context in ismember() by calling sec_rgy_site_open().  At the end
of ismember() it calls sec_rgy_site_close() to release the handle.
Suppose that thread1 has gotten into sec_rgy_site_close(), taken the
handle mutex and has started to decrement refcount.  That is, it
has loaded the 'current' value, in this case 2, into a register.  Now
thread1 gets pre-empted and thread2 resumes.  Suppose thread2 is
attempting to open the same context.  It gets into binding_cache_lookup(),
takes cache_mutex (not the context handle mutex) and then, at the
end of the routine, it increments refcount from 2 to 3.  Now thread2 
gets pre-empted and thread1 resumes.  It continues decrementing refcount
by decrementing the register that it loaded, and then stores the new
value of refcount (1) back into the context.  Now the next time that
thread2 resumes and tries to call sec_rgy_site_close(), it will
barf since the link fields (cache_next and cache_prev) are still valid
but the refcount is 1.

Long and short of it is that any internal routine that reads/writes
anything inside of a context HAS to take the context mutex.

Another problem - the global variable binding_clock is not protected
by any mutex.  This means that the ordering assumed by the routines that
set/use the last_used field of a context handle is not garunteed.  This
should not be a *FUNCTIONAL* problem, since this ordering is used only
for gc'ing in purge/purge_int.  But the value does bounce around in 
'random' fashion.  Since this is the case, I suggest we use a system
clock fetch routine.  Otherwise we would have to protect access to
binding_clock via a mutex.  The only other alternative is not to use an
LRU purging algorithm in purge/purge_int (i.e. we don't care which
of the currently unused context gets gc'ed.  This has the advantage
of being efficient at purge time, but in a heavily used scenario,
it will cause unnecessary thrashing of the cache).

Changed the code to call time() (from libc) to timestamp the context
handles.  This doesn't use binding_clock at all, though it is a slight
performance hit.  But at least there will be an ordering that 
purge/purge_int can rely on to implement its LRU disposal mechanism.

=============================================================
src/security/client/rca/internal_binding.c
=============================================================
***************
*** 229,234 ****
--- 229,237 ----
  #include <dce/sec_login_util.h>
  #include <u_str.h>

+ #include <sys/time.h>
+ #include <sys/types.h>
+
  #include <sec_svc.h>
  #include <sec_bind_util.h>

***************
*** 373,378 ****
--- 376,383 ----
  {
      assert(new_context->cache_next == NULL);
      assert(new_context->cache_prev == NULL);
+     new_context->refcount++;
+
      if (!cache_mutex_inited) {
        pthread_once(&cache_mutex_once, rca_create_cache_mutex);
      }
***************
*** 393,399 ****
        cache_head->cache_prev = new_context;
        cache_head = new_context;
      }
-     new_context->refcount++;
      rca_cache_enters++;

      V(cache_mutex);
--- 398,403 ----
***************
*** 527,533 ****
      unsigned char *cell;
      rca_pvt_handle_blk_t **context;
  {
!     rca_pvt_handle_blk_t *cur;
      if (!cache_mutex_inited) {
        pthread_once(&cache_mutex_once, rca_create_cache_mutex);
      }
--- 531,539 ----
      unsigned char *cell;
      rca_pvt_handle_blk_t **context;
  {
!     rca_pvt_handle_blk_t *cur, *prev=NULL;
!     error_status_t        status;
!
      if (!cache_mutex_inited) {
        pthread_once(&cache_mutex_once, rca_create_cache_mutex);
      }
***************
*** 538,543 ****
--- 544,560 ----

      for (cur = cache_head; cur != NULL; cur = cur->cache_next)
      {
+         rca_lock_handle( &(cur->mutex) , &status);
+         if (STATUS_OK(&status)) {
+                 /**
+                  ** We have to let go of the mutex for the previous
+                  ** handle we looked at.
+                  **
+                  **/
+                 if (prev)
+                         rca_unlock_handle( &(prev->mutex) );
+                 prev=cur;
+
        SEC_DBG_PRINTF(3,("(binding_cache_lookup) Looking at %x: site `%s' cell
`%s' princ `%s' %d\n", cur,
                cur->site_name, cur->cell_name, cur->princ_name,
                cur->auth_info.info_type));
***************
*** 620,628 ****
--- 637,652 ----
        SEC_DBG_PRINTF(2,("(binding_cache_lookup) Cache hit: returning %x\n", cu
r));
        cur->refcount++;
        *context = cur;
+         rca_unlock_handle( &(cur->mutex) );
+
        V(cache_mutex);
        return true;
+       }
      }
+
+     if (prev)
+         rca_unlock_handle( &(prev->mutex) );
+
      V(cache_mutex);

      SEC_DBG_PRINTF(2,("(binding_cache_lookup) Cache miss\n"));
***************
*** 1638,1644 ****
          return false;
      }
      /* set last time used */
!     context->last_used = binding_clock++;

      SEC_DBG_PRINTF(6, ("(rca_check_binding) flags is %x\n", context->handle_fl
ags));

--- 1662,1668 ----
          return false;
      }
      /* set last time used */
!     context->last_used = (unsigned32)time(NULL);

      SEC_DBG_PRINTF(6, ("(rca_check_binding) flags is %x\n", context->handle_fl
ags));

***************
*** 2018,2024 ****
      new_context->cache_next = NULL;
      new_context->cache_prev = NULL;
      new_context->refcount = 1;
!     new_context->last_used = binding_clock++;
      new_context->handle_flags = RCA_HANDLE_FLAGS_NONE;
      new_context->import_flags = 0;
      new_context->rpc_handle = 0;
--- 2042,2048 ----
      new_context->cache_next = NULL;
      new_context->cache_prev = NULL;
      new_context->refcount = 1;
!     new_context->last_used = (unsigned32)time(NULL);
      new_context->handle_flags = RCA_HANDLE_FLAGS_NONE;
      new_context->import_flags = 0;
      new_context->rpc_handle = 0;

[8/15/95 public]

I'm interested in using this patch, but I have a question about the
arguments you pass to rca_lock_handle() and rca_unlock_handle().  In 
the code above, you have

rca_lock_handle ( &(cur->mutex) , &status)
-and-
rca_unlock_handle ( &(prev->mutex) )

How is it that you can pass in a mutex, when the declarations
for rca_lock_handle() and rca_unlock_handle() have the
first argument declared as a pointer to a sec_rgy_handle_t
and a sec_rgy_handle_t, respectively?

[8/31/95 public]

I tried a similar fix as noted in OT# 12952. But I have seen deadlock in the
following call chain:
 
        binding_cache_lookup()
        bca_site_bind()
        sec_krb5rpc_sendto_kdc()
        krb5_sendto_kdc()
        krb5_send_tgs()
        krb5_get_cred_via_tgt()
        krb5_get_cred_from_kdc()
        krb5_get_credentials_dce()
        sec_krb_get_cred()
        rpc__krb_get_tkt()
        rpc__krb_dg_pre_call()
        rpc__dg_call_start()
        rpc_call_start()
        op3_csr()
 
        sec__id_parse_name()
 
        sec_id_parse_name()
        sec_krb_sec_parse_name()
        rpc__krb_bnd_set_auth()
        rpc_binding_set_auth_info()
 
sec__id_parse_name() has already done rca_lock_handle().
If tickets have expired, then sec_krb5rpc_sendto_kdc() uses RCA to bind to KDC
and results in deadlock.



CR Number                     : 13010
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : secd traps
Reported Date                 : 8/3/95
Found in Baseline             : 1.1
Found Date                    : 6/12/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
security/krb5/lib/krb/princ_fcomp.c
security/krb5/kdc/do_tgs_req.c
security/krb5/lib/kdb/decrypt_key.c
security/server/rs/rpriv_util.c
Sensitivity                   : public

[8/3/95 public]

Problems found while debugging secd traps.

1) verify inputs to krb5_principal_equiv() (princ_fcomp.c)
2) initialize variable fromstring in process_tgs_req() (do_tgs_req.c)
3) invalid length with memcpy() in krb5_kdb_decrypt_key() (decrypt_key.c)
4) a. verify input argument princ in is_priv_server() (rpriv_util.c)
   b. verify input argument ptgt-req in rpriv_util_parse_request(),
	set status if NULL. 

================================================================================
src/security/krb5/lib/krb/princ_fcomp.c
================================================================================
***************
*** 116,121 ****
--- 116,124 ----
  {
      register krb5_data * const *p1, * const *p2;

+     if (princ1 == NULL || princ2 == NULL)
+        return FALSE;
+
      if (!krb5_realm_equiv (*princ1, *princ2))
        return FALSE;

================================================================================
src/security/krb5/kdc/do_tgs_req.c
================================================================================
***************
*** 196,202 ****
      krb5_keyblock *session_key = 0;
      krb5_timestamp until, rtime;
      krb5_keyblock encrypting_key;
!     char *cname = 0, *sname = 0, *tmp = 0, *fromstring = 0;
      krb5_last_req_entry *nolrarray[2], nolrentry;
  /*    krb5_address *noaddrarray[1]; */
      krb5_enctype useetype;
--- 196,202 ----
      krb5_keyblock *session_key = 0;
      krb5_timestamp until, rtime;
      krb5_keyblock encrypting_key;
!     char *cname = 0, *sname = 0, *tmp = 0, *fromstring = "<unknown>";
      krb5_last_req_entry *nolrarray[2], nolrentry;
  /*    krb5_address *noaddrarray[1]; */
      krb5_enctype useetype;

================================================================================
src/security/krb5/lib/kdb/decrypt_key.c
================================================================================
***************
*** 91,97 ****
        return ENOMEM;
      }
      /* copy out the real length count */
!     memcpy((char *)&out->length, (char *)in->contents, sizeof(out->length));

      /* remember the contents of the encrypted version has a sizeof(in->length)
         integer length of the real embedded key, followed by the
--- 91,97 ----
        return ENOMEM;
      }
      /* copy out the real length count */
!       memcpy((char *)&out->length, (char *)in->length, sizeof(out->length));

      /* remember the contents of the encrypted version has a sizeof(in->length)
         integer length of the real embedded key, followed by the

================================================================================
src/security/server/rs/rpriv_util.c
================================================================================
***************
*** 302,308 ****
      if (priv_princ == NULL) {
          (void) krb5_parse_name((char *)SEC_PRIV_SERVER_NAME, &priv_princ);
      }
!     if (priv_princ != NULL) {
        if (krb5_principal_equiv(princ, priv_princ)) {
              return 1;
          }
--- 302,308 ----
      if (priv_princ == NULL) {
          (void) krb5_parse_name((char *)SEC_PRIV_SERVER_NAME, &priv_princ);
      }
!     if (priv_princ != NULL && princ != NULL) {
        if (krb5_principal_equiv(princ, priv_princ)) {
              return 1;
          }
***************
*** 1028,1033 ****
--- 1028,1038 ----

      memset(authz_data, 0, sizeof(*authz_data));
      *req_info = NULL;
+
+     if (ptgt_req == NULL) {
+       SET_STATUS(stp,sec_priv_s_no_mem);
+       return;
+     }

      krb_req.length = ptgt_req->num_bytes;
      krb_req.data = (char *) ptgt_req->bytes;

[08/03/95 public]
Is it really legal to pass in NULL?
If not, then this defect should probably be cancelled.
DCE does not try to "validate" its input parameters because it's
impossible to do completely, and lets programmers be sloppy, not fixing
their own errors.  Something coredumps usually make you do. :)



CR Number                     : 13008
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : Mem leak in security API's
Reported Date                 : 8/2/95
Found in Baseline             : 1.1wp
Found Date                    : 5/23/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : 
security/client/login/sec_login_pvt.c
security/client/acl/daclbind.c
security/client/acl/dacl_ifr.c
security/krb5/kdc/do_tgs_req.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/2/95 public]
The culprit is find_alternate_tgs, where they temporarily replace the realm in
an element of this krb5_principal structure with the realm of the tgs server,
make a call to krb5_db_get_principal, then try to put the original realm back in
the structure.  However, they dereferenced the pointer where they shouldn't have
and end up replacing the original realm pointer with a pointer to the temporary
save spot on the stack.

On the client side, the cause of the bogus string name is the memory that
the cell name resides in being freed by someone else and then reallocated and
used to store a uuid.  The cause of the inappropriate free is a string pointer
not being set via rpc_stralloc (so it would have its own copy) and then later
being passed to rpc_string_free.

=============================================================
src/security/client/login/sec_login_pvt.c
=============================================================
***************
*** 3617,3622 ****
--- 3617,3623 ----
                                  (unsigned_char_t *) cell_pgo_name, &unix_sid,
                                  &user_part, &admin_part, &policy, NULL, stp);
          }
+       free(cell_pgo_name);

      } else {

=============================================================
src/security/client/acl/daclbind.c
=============================================================
***************
*** 446,455 ****
                 * unresolved_name pointer if we do component_name =
                 * unresolved_name later on.
                 */
!               tmp_unresolved_name = (unsigned_char_p_t)malloc(strlen(
!                   (char *)unresolved_name));
!               strcpy((char *)tmp_unresolved_name, (char *)(unresolved_name +
!                   1));
                free(unresolved_name);
                  unresolved_name = tmp_unresolved_name;
            }
--- 446,452 ----
                 * unresolved_name pointer if we do component_name =
                 * unresolved_name later on.
                 */
!               tmp_unresolved_name = rpc_stralloc(unresolved_name);
                free(unresolved_name);
                  unresolved_name = tmp_unresolved_name;
            }
***************
*** 461,466 ****
--- 458,464 ----
              strcpy((char *) component_name, (char *) unresolved_name);
              strcat((char *) component_name, "/");
              strcat((char *) component_name, (char *) residual);
+           rpc_string_free (&unresolved_name, &st);
          }
          else {
              component_name = unresolved_name;
***************
*** 617,622 ****
--- 615,623 ----
              new_context->resolved_name[0] = '\0';
          }
      }
+
+     if (unresolved_name != NULL)
+        rpc_string_free (&unresolved_name, &st);

      if (STATUS_EQUAL(st_p, sec_login_s_no_current_context)) {
          SET_STATUS(st_p, sec_acl_unable_to_authenticate);


=============================================================
src/security/client/acl/dacl_ifr.c
=============================================================
***************
*** 741,747 ****
          free(COMPONENT_NAME(*h));
      }
      if (RESOLVED_NAME(*h) != (unsigned_char_p_t)NULL) {
!         free(RESOLVED_NAME(*h));
      }
      if (IS_DFS_ACL(*h)) {
          free(*h);
--- 741,747 ----
          free(COMPONENT_NAME(*h));
      }
      if (RESOLVED_NAME(*h) != (unsigned_char_p_t)NULL) {
!       rpc_string_free(&(RESOLVED_NAME(*h)), st_p);
      }
      if (IS_DFS_ACL(*h)) {
          free(*h);
***************
*** 751,757 ****
          if (IMPORT_HANDLE_VALID(*h))
              rpc_ns_binding_import_done(&(IMPORT_HANDLE(*h)), st_p);
          if (HANDLE_STR(*h) != (unsigned_char_p_t) NULL)
!             free((char *) HANDLE_STR(*h));
          free(*h);
          *h = NULL;
      }
--- 751,757 ----
          if (IMPORT_HANDLE_VALID(*h))
              rpc_ns_binding_import_done(&(IMPORT_HANDLE(*h)), st_p);
          if (HANDLE_STR(*h) != (unsigned_char_p_t) NULL)
!           rpc_string_free(&(HANDLE_STR(*h)), st_p);
          free(*h);
          *h = NULL;
      }

=============================================================
src/security/krb5/kdc/do_tgs_req.c
=============================================================
***************
*** 1052,1058 ****
  {
      krb5_error_code retval;
      krb5_principal *plist, *pl2;
!     krb5_data tmp;

      *nprincs = 0;
      *more = FALSE;
--- 1052,1058 ----
  {
      krb5_error_code retval;
      krb5_principal *plist, *pl2;
!     krb5_data *tmp;

      *nprincs = 0;
      *more = FALSE;
***************
*** 1073,1082 ****
         ignore it */
      while (--pl2 > plist) {
        *nprincs = 1;
!       tmp = *krb5_princ_realm(*pl2);
        krb5_princ_set_realm(*pl2, krb5_princ_realm(tgs_server));
        retval = krb5_db_get_principal(*pl2, *keytype, 0, server, nprincs, more)
;
!       krb5_princ_set_realm(*pl2, &tmp);
        if (retval) {
            *nprincs = 0;
            *more = FALSE;
--- 1073,1082 ----
         ignore it */
      while (--pl2 > plist) {
        *nprincs = 1;
!       tmp = krb5_princ_realm(*pl2);
        krb5_princ_set_realm(*pl2, krb5_princ_realm(tgs_server));
        retval = krb5_db_get_principal(*pl2, *keytype, 0, server, nprincs, more)
;
!       krb5_princ_set_realm(*pl2, tmp);
        if (retval) {
            *nprincs = 0;
            *more = FALSE;
***************
*** 1091,1104 ****
            krb5_principal tmpprinc;
            char *sname;

!           tmp = *krb5_princ_realm(*pl2);
            krb5_princ_set_realm(*pl2, krb5_princ_realm(tgs_server));
            if (retval = krb5_copy_principal(*pl2, &tmpprinc)) {
                krb5_db_free_principal(server, *nprincs);
!               krb5_princ_set_realm(*pl2, &tmp);
                continue;
            }
!           krb5_princ_set_realm(*pl2, &tmp);

            krb5_free_principal(request->server);
            request->server = tmpprinc;
--- 1091,1104 ----
            krb5_principal tmpprinc;
            char *sname;

!           tmp = krb5_princ_realm(*pl2);
            krb5_princ_set_realm(*pl2, krb5_princ_realm(tgs_server));
            if (retval = krb5_copy_principal(*pl2, &tmpprinc)) {
                krb5_db_free_principal(server, *nprincs);
!               krb5_princ_set_realm(*pl2, tmp);
                continue;
            }
!           krb5_princ_set_realm(*pl2, tmp);

            krb5_free_principal(request->server);
            request->server = tmpprinc;

[8/17/95 public]

The last rpc_string_free(&unresolved_name) that you add to daclbind.c may 
unwittingly free up component_name, which you don't want to do because
component_name gets passed back to the caller in new_context.  
unresolved_name is freed up (in the original version at line 493), unless
it's identical to component_name.  So the additional rpc_string_free is
redundant and dangerous.

493:

/* If we had an unresolved name and it's not the component name, free it */
    if ((unresolved_name != NULL) && (unresolved_name != component_name))
        free((char *)unresolved_name);

There are other memory management problems with daclbind.c, that appear
in the cleanup of new_context in the error case.  It's hard to tell, but 
it doesn't appear that the various strings assigned to new_context fields 
are cleaned up.

[9/11/95 public]

From Tom at Gradient has to say the following:

This change to daclbind.c is wrong:
***************
*** 617,622 ****
--- 615,623 ----
              new_context->resolved_name[0] = '\0';
          }
      }
+
+     if (unresolved_name != NULL)
+        rpc_string_free (&unresolved_name, &st);

      if (STATUS_EQUAL(st_p, sec_login_s_no_current_context)) {
          SET_STATUS(st_p, sec_acl_unable_to_authenticate);

You can not free this, as "unresolved_name" is assigned to 
"new_context->component_name" above this code.  It isn't needed
anyway since we already checked unresolved name for NULL and
free'd it if it wasn't assigned to component_name.

If this change is made (at least on my SVR4), an acl_edit /.:/sec/group -l
or dcecp -c acl show /.:/sec/group will FAIL.

[10/7/96 public]

Fixed in 1.1maint.



CR Number                     : 13007
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : rpc_binding_free misplaced in rca_rebind()
Reported Date                 : 8/2/95
Found in Baseline             : 1.1unintegrated
Found Date                    : 10/10/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : security/client/rca/internal_binding.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/2/95 public]

Under certain situations, some code that frees binding handles before
they are replaced with new handles was prematurely freeing
a binding handle to the security server, which it was still using.  
The freeing code was moved to only hit the cases where the handle was
about to be replaced.

=============================================================
src/security/client/rca/internal_binding.c
=============================================================
***************
*** 1298,1303 ****
--- 1298,1307 ----
      sec_rgy_bind_auth_info_t    *auth_info = &context->auth_info;

      CLEAR_STATUS(status);
+
+     if (context->rpc_handle)
+         rpc_binding_free (&context->rpc_handle, &xst);
+
      context->rpc_handle = NULL;

      start = context->tower_vec_index;
***************
*** 1443,1448 ****
--- 1447,1456 ----
        if (h != NULL)
        {
            boolean32 bound;
+
+             if (context->rpc_handle)
+                 rpc_binding_free (&context->rpc_handle, &xst);
+
            SEC_DBG_GPRINTF(("(rca_rebind) Took alt_handle %d from context\n", i
));
            context->rpc_handle = h;
            SET(context->handle_flags, RCA_HANDLE_FLAGS_VALID);

[10/7/96 public]
Fixed in 1.1maint.



CR Number                     : 13005
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : mem leak rca_site_bind_nsi_cell_if()
Reported Date                 : 8/2/95
Found in Baseline             : 1.1unintegrated
Found Date                    : 6/16/95
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : security/client/rca/internal_binding.c
Sensitivity                   : public

[8/2/95 public]

The cell_name allocated by the rpc_stralloc() is overwriten in
rca_site_bind_nsi_cell_if().

=============================================================
security/client/rca/internal_binding.c
=============================================================
***************
*** 1728,1733 ****
--- 1728,1735 ----

        SEC_DBG_GPRINTF(("(rca_site_bind_nsi_cell) about to call rca_setup_handl
e; rpc_handle==%x\n", context->rpc_handle));
        if (rca_setup_handle(context, status)) {
+           if ( context->cell_name )  /* CMVC #14569 */
+               rpc_string_free( &context->cell_name , &st);
            context->cell_name = cell_name;
            return;
        }

[11/03/95 public]
Fix submitted to 1.1maint tree.



CR Number                     : 13000
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : Inconsistent malloc()/free(), memory leakage
Reported Date                 : 8/2/95
Found in Baseline             : 1.1wp
Found Date                    : 8/2/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : src/security/utils/sec_authn.c
src/security/helper/auth_helper.c, src/security/client/rca/binding.c
Sensitivity                   : public

[8/2/95 public]

Inconsistent malloc and free calls due to introduction of
RPC memory pool in AIX DCE will cause memory leakage.
The memory allocated using rpc_stralloc (currently using RPC
memory pool) is being freed somewhere else in security
using system free call.

=====================================================================
src/security/utils/sec_authn.c
=====================================================================
***************
*** 499,512 ****
       */
      free(cell);
      free(principal);
!     outname = rpc_stralloc ((unsigned char *)tempname);
!     if (outname != NULL)
!     {
!       *name = outname;
!     } else {
!         SET_STATUS(&st, sec_rgy_cant_allocate_memory);
!     }
!     free (tempname);
      return st;
  }

--- 499,506 ----
       */
      free(cell);
      free(principal);
!     *name = tempname;
!
      return st;
  }

***************
*** 695,701 ****

          if (strcmp((char *)server_global, (char *)id->server_global) == 0) {
              /* !!! this may not be right allocator here.. */
!             rpc_string_free (&server_global, &xst);

              if (id->get_key_func) {
                  rpc_auth_key_retrieval_fn_t tmp_get_key_func = id->get_key_fun
c;
--- 689,695 ----

          if (strcmp((char *)server_global, (char *)id->server_global) == 0) {
              /* !!! this may not be right allocator here.. */
!           free(server_global);   /* sec_krb_unparse_name() uses malloc() */

              if (id->get_key_func) {
                  rpc_auth_key_retrieval_fn_t tmp_get_key_func = id->get_key_fun
c;
***************
*** 728,734 ****
          }
      }
      UNLOCK_IDENTITY();
!     rpc_string_free (&server_global, &xst);
      return KRB5KRB_AP_WRONG_PRINC;
  }

--- 722,728 ----
          }
      }
      UNLOCK_IDENTITY();
!     free(server_global);        /* sec_krb_unparse_name() uses malloc() */
      return KRB5KRB_AP_WRONG_PRINC;
  }

***************
*** 909,915 ****
                  *global_name = NULL;
                  return st;
              }
!             *global_name = tname;
              return error_status_ok;
          }
          else
--- 903,912 ----
                  *global_name = NULL;
                  return st;
              }
!             *global_name = malloc(strlen(tname)+1);
!             strcpy(*global_name, tname);
!             rpc_string_free(&tname, &st);
!
              return error_status_ok;
          }
          else
***************
*** 1038,1044 ****
          sec__serv_id_table = nid;

          sec__serv_id_table[sec__n_idents].server_string =
!             rpc_stralloc(server_princ_name);
          sec__serv_id_table[sec__n_idents].server_global = server_global;
          sec__serv_id_table[sec__n_idents].get_key_func = get_key_func;
          sec__serv_id_table[sec__n_idents].arg = arg;
--- 1035,1043 ----
          sec__serv_id_table = nid;

          sec__serv_id_table[sec__n_idents].server_string =
!             malloc(strlen(server_princ_name) + 1);
!         strcpy(sec__serv_id_table[sec__n_idents].server_string, server_princ_n
ame);
!
          sec__serv_id_table[sec__n_idents].server_global = server_global;
          sec__serv_id_table[sec__n_idents].get_key_func = get_key_func;
          sec__serv_id_table[sec__n_idents].arg = arg;
***************
*** 1117,1123 ****
          }
        if (BAD_STATUS(&st)) {
            sec__n_idents--;
!           rpc_string_free(&sec__serv_id_table[sec__n_idents].server_string, &x
st);
            free(sec__serv_id_table[sec__n_idents].server_global);
        }
      }
--- 1116,1122 ----
          }
        if (BAD_STATUS(&st)) {
            sec__n_idents--;
!           free(sec__serv_id_table[sec__n_idents].server_string);
            free(sec__serv_id_table[sec__n_idents].server_global);
        }
      }
***************
*** 1808,1814 ****
          case rpc_c_authz_name:
              message->data[message->length-1] = '\0';

!             *client_name = rpc_stralloc (&message->data[1]);

              *authz_proto = rpc_c_authz_name;
            *authentP == NULL;
--- 1807,1814 ----
          case rpc_c_authz_name:
              message->data[message->length-1] = '\0';

!             *client_name = malloc (strlen(&message->data[1]) + 1);
!             strcpy(*client_name, &message->data[1]);

              *authz_proto = rpc_c_authz_name;
            *authentP == NULL;

***************
*** 2211,2223 ****
      sec_encode_v1_1_authz_data_free(free, &v1_1_ad);

      if (authP->server_princ_name) {
!       rpc_string_free(&authP->server_princ_name, &ignore_st);
      }

      if (BAD_STATUS(&st))
      {
        if (client_name && *client_name)
!           rpc_string_free(client_name, &ignore_st);

        if (server_name && *server_name)
            sec_krb_parsed_name_free(server_name);
--- 2211,2223 ----
      sec_encode_v1_1_authz_data_free(free, &v1_1_ad);

      if (authP->server_princ_name) {
!       free(authP->server_princ_name);
      }

      if (BAD_STATUS(&st))
      {
        if (client_name && *client_name)
!           free( *client_name );

        if (server_name && *server_name)
            sec_krb_parsed_name_free(server_name);

=====================================================================
src/security/utils/sec_authn.c
=====================================================================
***************
*** 564,570 ****
     if (n != NULL) { \
         status = sec_krb_unparse_name(n, &tempname); \
         PUT_STRING(ptr, tempname); \
!        rpc_string_free(&tempname, &xst); \
     } else { \
         PUT_STRING(ptr, NULL); \
     } \
--- 564,570 ----
     if (n != NULL) { \
         status = sec_krb_unparse_name(n, &tempname); \
         PUT_STRING(ptr, tempname); \
!        free(tempname); \
     } else { \
         PUT_STRING(ptr, NULL); \
     } \
***************
*** 1019,1025 ****
        PUT_SEC_BYTES(outptr, &raw_epac_set);
      }
      if (client_name)
!         rpc_string_free(&client_name, &xst);
      if (server_name)
          sec_krb_parsed_name_free(&server_name);
      if (tmpsvr)
--- 1019,1025 ----
        PUT_SEC_BYTES(outptr, &raw_epac_set);
      }
      if (client_name)
!         free(client_name);
      if (server_name)
          sec_krb_parsed_name_free(&server_name);
      if (tmpsvr)

=====================================================================
src/security/client/rca/binding.c
=====================================================================
***************
*** 305,325 ****
      rca_lock_handle(&context, status);

      if (cell_name && STATUS_OK(status) && CELL_NAME(context)) {
!       *cell_name = rpc_stralloc(CELL_NAME(context));
        if (*cell_name == NULL)
        {
            SET_STATUS(status, sec_rgy_cant_allocate_memory);
              goto free_none;
        }
      }

      if (server_name && STATUS_OK(status) && SITE_NAME(context)) {
!         *server_name = rpc_stralloc(SITE_NAME(context));
!
          if (*server_name == NULL) {
              SET_STATUS(status, sec_rgy_cant_allocate_memory);
              goto free_cell_name;
          }
      }

      if (string_binding && STATUS_OK(status)) {
--- 305,326 ----
      rca_lock_handle(&context, status);

      if (cell_name && STATUS_OK(status) && CELL_NAME(context)) {
!       *cell_name = malloc(strlen(CELL_NAME(context)) + 1);
        if (*cell_name == NULL)
        {
            SET_STATUS(status, sec_rgy_cant_allocate_memory);
              goto free_none;
        }
+       strcpy(*cell_name, CELL_NAME(context));
      }

      if (server_name && STATUS_OK(status) && SITE_NAME(context)) {
!       *server_name = malloc(strlen(SITE_NAME(context)) + 1);
          if (*server_name == NULL) {
              SET_STATUS(status, sec_rgy_cant_allocate_memory);
              goto free_cell_name;
          }
+       strcpy(*server_name, SITE_NAME(context));
      }

      if (string_binding && STATUS_OK(status)) {

[1/11/96 public]
Submitted the above fix (along with addition for checking NULL pointer
after malloc() ) to the 1.1 maint tree.



CR Number                     : 12981
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : migration test
Short Description             : Security migration test aborts 
with 'Fault invalid tag' exception.
Reported Date                 : 7/28/95
Found in Baseline             : 1.1wp
Found Date                    : 7/24/95
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : migration-tc.c
Sensitivity                   : public

[7/28/95 public]

(from Tom Jordahl at Gradient)

In the file:
	src/test/functional/security/ts/client/migration/migration-tc.c,
sec_rgy_attr_update() is called with num_attrs==1, but the attrs array
is assigned to NULL.  There needs to be at least one element in the array.
Otherwise, the call tries to marshall the non-existent element and 
generates an 'Invalid tag' (the sec_attr_value_t is a union) exception.

Repeat by:
	Run the migration tests as shipped with the warranty patch
	and the sec_rgy_attr() test will die.  If you stack garbage
	it is correct.  This fix also solves the coredump problem with
	sec_rgy_attr_lookup_by_id().

Proposed Solution:
	Put something in the attrs array.



Diff:

***************
*** 8,17 ****
  /*
   * HISTORY
   * $Log:	c012981,v $
# Revision 1.1  95/07/28  13:42:41  root
# new CR
# 
   * Revision 1.1.2.1  1995/06/26  20:41:00  tom
   *    OSF DCE Warranty Patch code
   *    [1995/06/26  19:06:36  tom]
!  *
   * $EndLog$
   */
  /*
--- 8,22 ----
  /*
   * HISTORY
   * $Log:	c012981,v $
# Revision 1.1  95/07/28  13:42:41  root
# new CR
# 
+  * Revision 1.1.3.2  1995/07/24  16:49:56  tom
+  *    In sec_rgy_attr test, put something in the attrs array
+  *    so we don't get a 'Fault invalid tag' exception when
+  *    we call sec_rgy_attr_update().
+  *
   * Revision 1.1.2.1  1995/06/26  20:41:00  tom
   *    OSF DCE Warranty Patch code
   *    [1995/06/26  19:06:36  tom]
!  *
   * $EndLog$
   */
  /*
***************
*** 187,194 ****
                        num_ret,
                          num_attrs = 1;
      sec_attr_t                out_attrs[20],
!                         *attrs = NULL;
      sec_attr_cursor_t cursor;

      sec_rgy_attr_update(context, sec_rgy_domain_person, (unsigned_char_p_t)"root",
                        num_attrs, num_attrs, attrs, &num_ret, out_attrs, &num_left,
--- 192,203 ----
                        num_ret,
                          num_attrs = 1;
      sec_attr_t                out_attrs[20],
!                         attrs[20];
      sec_attr_cursor_t cursor;
+     unsigned32                status;
+
+     uuid_create(&attrs[0].attr_id, &status);
+     attrs[0].attr_value.attr_encoding = sec_attr_enc_void;

      sec_rgy_attr_update(context, sec_rgy_domain_person, (unsigned_char_p_t)"root",

!                             &cursor, num_attrs, 20, attrs, &num_ret, out_attrs,
                              &num_left, &st);
      CHECK_MIGRATE_RESULT(Msec_rgy_attr_lookup_by_id, true,
                         "Migration(sec_rgy_attr): sec_rgy_attr_lookup_by_id", &st);
--- 223,229 ----
       */

      sec_rgy_attr_lookup_by_id(context, sec_rgy_domain_person, (unsigned_char_p_t)"root",
!                             &cursor, num_attrs, num_attrs, attrs, &num_ret, out_attrs,
                              &num_left, &st);
      CHECK_MIGRATE_RESULT(Msec_rgy_attr_lookup_by_id, true,
                         "Migration(sec_rgy_attr): sec_rgy_attr_lookup_by_id", &st);



CR Number                     : 12978
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : Renaming a polymorphic pgo/dir can corrupt registry
Reported Date                 : 7/27/95
Found in Baseline             : 1.1
Found Date                    : 7/27/95
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : sec
Sensitivity                   : public

[7/27/95 public]

Try the following in dcecp (see the warning that follows)

group create foo/bar
group create foo
group rename foo -to foo/xyz
group catalog

At this time, either secd will dump core and leaving a corrupted registry
which prevents a restart of secd, or the pgo/dir is gone.  Secd does not
detect the case of moving a pgo/dir aggregate as a descendent of itself.

[8/3/95 public]

If the intent of renaming a pgo/dir aggregate is to move the whole thing,
then here is a fix which solves the problem.

In rsdb_pgo_move(), make the following changes

RCS file: security/server/rsdb/RCS/rsdb_pgo.c,v
retrieving revision 12.3
retrieving revision 12.4
diff -c -r12.3 -r12.4

          rsdb_util_delete_dirs_if_empty(domain, new_parent_name, &tmp_st);
          SET_STATUS(status, sec_rgy_object_not_found);
          return;
+     }
+     /*
+      * Disallow moving a pgo/dir aggregate as a descendent of itself
+      */
+     if (RSDB_IS_DIR(&old_pgo) && RSDB_IS_PGO(&old_pgo)) {
+       if(rsdb_name_util_is_prefix(old_name, old_name_len, new_name,
+                                   new_name_len, &prefix_type)) {
+           if(prefix_type == rsdb_prefix) {
+               /* delete empty directories we may have created above. */
+               rsdb_util_delete_dirs_if_empty(domain,
+                                              new_parent_name, &tmp_st);
+               SET_STATUS(status, sec_rgy_dir_move_illegal);
+               return;
+           }
+       }
      }
      rsdb_util_change_name_key(domain, &old_pgo, new_parent_id,
                                name_key.name, name_key.name_len, status);

[12/19/95 public]
Fixed in DCE 1.2.1
Closed

[01/11/96 public]
The change merged from our local source was a simpler, more restrictive patch
made prior to the suggested diff.  Thus this gets reopened w/a lower priority.



CR Number                     : 12976
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : Memory leak in krb5_free_last_req()
Reported Date                 : 7/25/95
Found in Baseline             : 1.1wp
Found Date                    : 7/25/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/krb5/kdc/kdc_util.c,
security/krb5/lib/free/f_last_req.c, src/libdce/RIOS/syms.imp
Sensitivity                   : public

[7/25/95 public]

1) security/krb5/lib/free/f_last_req.c
* Revision 1.1.2.2  1992/12/29  14:27:54  zeliff

Check if the pointer is dinamically allocated or not. If yes, free it.

*** 61,66 ****
--- 61,68 ----
  #include <krb5/krb5.h>
  #include <krb5/ext-proto.h>
  
+ extern krb5_last_req_entry *nolrarray[];
+ 
  void
  krb5_free_last_req(val)
  krb5_last_req_entry **val;
***************
*** 67,74 ****
  {
      register krb5_last_req_entry **temp;
  
!     for (temp = val; *temp; temp++)
!       xfree(*temp);
!     xfree(val);
      return;
  }
--- 69,78 ----
  {
      register krb5_last_req_entry **temp;
  
!     if ( val != nolrarray ){
!       for (temp = val; *temp; temp++)
!               xfree(*temp);
!       xfree(val);
!     } 
      return;

  }
------------------------------------------------------------
2) security/krb5/kdc/kdc_util.c
* Revision /main/DCE1_1_WP/3  1995/04/25  20:19 UTC  jrr

In order to check the pointer, The constant pointer should be changed to public.

*** 689,695 ****
  /* This probably wants to be updated if you support last_req stuff */
  
  static krb5_last_req_entry nolrentry = { KRB5_LRQ_NONE, 0 };
! static krb5_last_req_entry *nolrarray[] = { &nolrentry, 0 };
  
  krb5_error_code
  fetch_last_req_info(dbentry, lrentry)
--- 689,695 ----
  /* This probably wants to be updated if you support last_req stuff */
  
  static krb5_last_req_entry nolrentry = { KRB5_LRQ_NONE, 0 };
! krb5_last_req_entry *nolrarray[] = { &nolrentry, 0 };
  
  krb5_error_code
  fetch_last_req_info(dbentry, lrentry)

------------------------------------------------------------
3) libdce/RIOS/syms.imp

*** 1,3 ****
--- 1,4 ----
  #!
  kutc_gettime
  kutc_adjtime
+ nolrarray

[07/28/95 public]
This OT CR was deleted by mistake.  Perhaps it was meant to be cancelled?



CR Number                     : 12975
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : rpc_mem_string memory leak( rca_setup_handle)
Reported Date                 : 7/25/95
Found in Baseline             : 1.1wp
Found Date                    : 7/25/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/client/rca/internal_binding.c
Sensitivity                   : public

[7/25/95 public]
In rca_setup_handle(), context->site_name is reset without checking if
it points to the area that was already allocated.
***************************************************************
*** security/client/rca/internal_binding.c		    ***
*** Revision /main/DCE1_1_WP/2  1995/05/04  17:59 UTC  greg ***
***************************************************************
*** 1215,1220 ****
--- 1215,1222 ----
      else if (context->requested_site_name != NULL) 
      {
        SEC_DBG_GPRINTF(("(rca_setup_handle) No entry name -- status %x.  Fallin
g back to site == %s\n", st, context->requested_site_name));
+       if (context->site_name)
+           rpc_string_free(&context->site_name,&st);
        context->site_name = rpc_stralloc(context->requested_site_name);
      }    
      else if (context->cell_name != NULL)
***************
*** 1224,1229 ****
--- 1226,1233 ----
         * as the server name.
         */
        SEC_DBG_GPRINTF(("(rca_setup_handle) No entry name -- status %x.  Fallin
g back to site == cell\n", st));
+       if (context->site_name)
+           rpc_string_free(&context->site_name,&st);
        context->site_name = rpc_stralloc(context->cell_name);
      }



CR Number                     : 12973
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : Memory leak inconsistent malloc() and free()
Reported Date                 : 7/25/95
Found in Baseline             : 1.1
Found Date                    : 7/25/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/client/acl/dacl_pvt.h
Sensitivity                   : public

[7/25/95 public]
With current macro definition, memory is being allocated using RPC_MEM_ALLOC
routine which defaults to using memory pool alloc routine for AIX and
it is being freed using system free().

*******************************************************
*** security/client/acl/dacl_pvt.h	    	    ***	
*** Revision 1.1.60.1  1994/01/28  23:09:57  burati ***
*******************************************************
*** 86,92 ****
      rpc_ns_binding_inq_entry_name(handle,rpc_c_ns_syntax_dce,&tnameP,&xst);\
      if (GOOD_STATUS(&xst)) { \
          printf("%s imported binding from %s\n", txt, tnameP); \
!         free((char *)tnameP); \
      } \
  }
  #define SEC_OBJ_PRINTF(obj_uuid, txt) \
--- 86,92 ----
      rpc_ns_binding_inq_entry_name(handle,rpc_c_ns_syntax_dce,&tnameP,&xst);\
      if (GOOD_STATUS(&xst)) { \
          printf("%s imported binding from %s\n", txt, tnameP); \
!         rpc_string_free(&tnameP,&xst); \
      } \
  }
  #define SEC_OBJ_PRINTF(obj_uuid, txt) \
***************
*** 96,102 ****
      uuid_to_string(&obj_uuid, &touidP, &xst); \
      if (GOOD_STATUS(&xst)) { \
          printf("%s object uuid is %s\n", txt, touidP); \
!         free((char *)touidP); \
      } \
  }
  
--- 96,102 ----
      uuid_to_string(&obj_uuid, &touidP, &xst); \
      if (GOOD_STATUS(&xst)) { \
          printf("%s object uuid is %s\n", txt, touidP); \
!         rpc_string_free(&touidP,&xst); \
      } \
  }



CR Number                     : 12972
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : memory Leak in rs_setup_creator()
Reported Date                 : 7/25/95
Found in Baseline             : 1.1wp
Found Date                    : 7/25/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/server/rs/rs_reserved.c
Sensitivity                   : public

[7/25/95 public]

In rs_setup_creator(), memory for tmp_uuid_str is allocated via 
uuid_to_string(), but is never freed.
*******************************************************************
*** security/server/rs/rs_reserved.c 				***
*** Revision /main/DCE1_1_WP/1  1995/04/26  19:48 UTC  jrr 	***
*******************************************************************
*** 1549,1554 ****
--- 1549,1556 ----
              strncpy(pp->uuid, (char *)tmp_uuid_str, UUID_STR_LEN);
              pp->uuid[UUID_STR_LEN] = '\0';
              new_creator = false;
+             if (tmp_uuid_str != NULL)
+               rpc_string_free(&tmp_uuid_str, st);     
              return;
          }
      }
***************
*** 1567,1572 ****
--- 1569,1576 ----
      }
      strncpy(creator_uuid, (char *)tmp_uuid_str, UUID_STR_LEN);
      creator_uuid[UUID_STR_LEN] = '\0';
+     if (tmp_uuid_str != NULL)
+       rpc_string_free(&tmp_uuid_str, st);
      return;
  }



CR Number                     : 12971
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : memory leak in rs_rep_mgmt_delete()
Reported Date                 : 7/25/95
Found in Baseline             : 1.1wp
Found Date                    : 7/25/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/server/rs/rs_rep_mgmt.c
Sensitivity                   : public

[7/25/95 public]
Memory allocated using dce_cf_get_cell_name() for cell_name is never freed.
**************************************************************
*** security/server/rs/rs_rep_mgmt.c
*** Revision /main/DCE1_1_WP/1  1995/04/26  19:48 UTC  jrr ***
**************************************************************
*** 1584,1589 ****
--- 1584,1590 ----
      dce_cf_get_cell_name((char **) &cell_name, st);
      if (BAD_STATUS(st)) return;
      rs_ns_name_compose(cell_name, my_name, &full_name, st);
+     free(cell_name);
      if (BAD_STATUS(st)) return;
      rs_ns_server_delete_name(full_name, st);
      if (BAD_STATUS(st)) {



CR Number                     : 12970
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : memory leak in sec_login_validate_cert_auth()
Reported Date                 : 7/25/95
Found in Baseline             : 1.1wp
Found Date                    : 7/25/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/client/rca/sec_certify.c
Sensitivity                   : public

[7/25/95 public]
There is memory leakage in function sec_login_validate_cert_auth().
Memory allocated using dce_cf_prin_name_from_host() for variable
hostname is never freed after call to rpc_binding_set_auth_info().

***********************************************************
*** security/client/rca/sec_certify.c			***
*** Revision 1.1.6.1  1994/05/11  19:04:12  ahop	***
***********************************************************
diff output: < current version, > modified version
102a103,104
> 
>           free(hostname);

-----------------------------------------------------------

[7/25/95 public]
A context diff is much easier to read!
*** 98,107 ****
--- 98,108 ----
              rpc_binding_set_auth_info(cert_h, hostname,
                                  rpc_c_authn_level_pkt_integrity,
                                  rpc_c_authn_dce_private,
                                  (rpc_auth_identity_handle_t)login_context,
                                  rpc_c_authz_dce, st);
+               free(hostname);
          }
      }
  
      /* Call sec_clientd to validate certification authority */
      if (GOOD_STATUS(st)) {



CR Number                     : 12969
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : memory leak in sec_login_pvt_get_local_login_info()
Reported Date                 : 7/25/95
Found in Baseline             : 1.1wp
Found Date                    : 7/25/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/client/login/sec_login_np.c,
						security/client/login/RIOS/sec_login_np.c
Sensitivity                   : public
The first time that sec_login_pvt_get_local_login_info calls dce_cf_get_cell_name
it doesn't free my_cell, like it does the second time.
***********************************************************
*** src/security/client/login/RIOS/sec_login_np.c	***
*** Revision 1.1.4.2  1993/07/26  20:38:42  burati	***
***********************************************************
diff output: < current version, > modified version
190a191,192
> 
>                       free(my_cell);
***********************************************************
*** src/security/client/login/sec_login_np.c		***
*** Revision 1.1.5.2  1992/12/29  12:43:49  zeliff 	***
***********************************************************
diff output: < current version, > modified version
191a192,193
> 
>                       free(my_cell);

[7/25/95 public]

[7/25/95 public]
A context diff is much easier to read!
*************************************
security/client/login/sec_login_np.c
*************************************
*** 187,196 ****
--- 187,197 ----
                          && len < strlen(name)
                          && name[len] != '\0') {
                              /*  add 1 to get past '/' separator */
                              qname = name + len + 1;
                          }
+                       free(my_cell);
                      }
                  }
  
                  if (qname != NULL) {
                      pwd_data = GETPWNAM(qname);

*************************************
security/client/login/RIOS/sec_login_np.c
*************************************
*** 186,195 ****
--- 186,196 ----
                          && len < strlen(name)
                          && name[len] != '\0') {
                              /*  add 1 to get past '/' separator */
                              qname = name + len + 1;
                          }
+                       free(hostname);
                      }
                  }
  
                  if (qname != NULL) {
                      pwd_data = GETPWNAM(qname);



CR Number                     : 12968
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : sec_rgy_site_close() leaks memory
Reported Date                 : 7/25/95
Found in Baseline             : 1.1wp
Found Date                    : 7/25/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/client/rca/internal_binding.c
Sensitivity                   : public

[7/25/95 public]

Function sec_rgy_site_close() in security/client/rca/internal_binding.c
is freeing memory incorrectly for several members of its rca_pvt_handle_blk_t
structure.  It should be using rpc_string_free() instead of free()
since the members where allocated using rpc_stralloc().  As a result
memory is being leaked and the rpc memory stats are incorrect.
The members which should be released using rpc_string_free() are:
site_name, cell_name, uncanon_princ_name, and requested_site_name.
***************************************************************
*** security/client/rca/internal_binding.c 		    ***
*** Revision /main/DCE1_1_WP/2  1995/05/04  17:59 UTC  greg ***
***************************************************************
diff output: < current version, > modified version
2496c2496
<                   free(context->site_name);
---
>                   rpc_string_free(context->site_name);
2499c2499
<                   free(context->cell_name);
---
>                   rpc_string_free(context->cell_name);
2502c2502
<                   free (context->uncanon_princ_name);
---
>                   rpc_string_free (context->uncanon_princ_name);
2508c2508
<                   free (context->requested_site_name);
---
>                   rpc_string_free(context->requested_site_name);

[7/25/95 public]
A context diff is much easier to read!
*************************************
security/client/rca/internal_binding.c
*************************************
*** 2493,2511 ****
                }
                    
                if (context->site_name != NULL)
!                   free(context->site_name);
  
                if (context->cell_name != NULL)
!                   free(context->cell_name);
  
                if (context->uncanon_princ_name != NULL)
!                   free (context->uncanon_princ_name);
                
                if (context->princ_name != NULL) 
                    free(context->princ_name);
                
                if (context->requested_site_name != NULL)
!                   free (context->requested_site_name);
                
                if (context->tower_vec != NULL)
                    TOWER_VEC_FREE(free, context->tower_vec);
--- 2493,2511 ----
                }
                    
                if (context->site_name != NULL)
!                   rpc_string_free(context->site_name);
  
                if (context->cell_name != NULL)
!                   rpc_string_free(context->cell_name);
  
                if (context->uncanon_princ_name != NULL)
!                   rpc_string_free(context->uncanon_princ_name);
                
                if (context->princ_name != NULL) 
                    free(context->princ_name);
                
                if (context->requested_site_name != NULL)
!                   rpc_string_free(context->requested_site_name);
                
                if (context->tower_vec != NULL)
                    TOWER_VEC_FREE(free, context->tower_vec);

[8/18/95 public]

You need to qualify the argument to rpc_string_free with the 
address operator, "&".  As in 

rpc_string_free(&context->cell_name)



CR Number                     : 12966
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : The sec_key_mgmt_set_key() and sec_key_mgmt_delete_key() call do not work with the FILE prefix appended to keytab name.
Reported Date                 : 7/23/95
Found in Baseline             : 1.1b24
Found Date                    : 7/23/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/23/95 public]

The routines sec_key_mgmt_delete_key() and sec_key_mgmt_set_key() do
not handle the argument for the keytab file if it is prepended with 
the FILE prefix.  This is the procedure specified in the documentation.
However, if the file is entered without the prefix the operations are
successful.  

The reason for this is that the operations table loaded with the FILE
prefix excludes the "add" and "delete" function pointers.  However, if
the file is left unprefixed the "WRFILE" prefix is automatically
preappended to the file name, resulting in the loading of the complete
set of keytab file operation pointers.

We are not sure of the reason for this mechanism.  It seems that for
readonly operations the FILE prefix is needed, whereas for the update
operations no prefix is necessary. 

If this is the way it should work then the documentation should be 
modified to reflect the proper behavior, otherwise the code needs
to be changed to maintain consistency in the naming of the keytab
files in the APIs.

[8/1/95 public]

does anyone care to comment on this defect at HP?  We
are wondering what you all think the proper way to fix this
is?



CR Number                     : 12956
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : sec_key_mgmt* KRB5_KT_NOWRITE
error if "FILE:" present
Reported Date                 : 7/18/95
Found in Baseline             : 1.1
Found Date                    : 7/18/95
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/18/95 public]

Documentation says the sec_key_mgmt* routines  will prepend 
the "FILE:" prefix to the key file parameter if it's not supplied, 
effectively making this prefix optional.  Routines such as 
sec_key_mgmt_manage_key() and sec_key_mgmt_get_next_kvno() work 
with or without the "FILE:" prefix.  

However, sec_key_mgmt_change_key() and sec_key_mgmt_set_key()
won't work with the "FILE:" prefix (on Digital UNIX/Alpha) and
report a KRB5_KT_NOWRITE error code.



CR Number                     : 12952
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : RCA
Short Description             : core dump in binding_cache_lookup().
Reported Date                 : 7/14/95
Found in Baseline             : 1.1
Found Date                    : 7/14/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/14/95 public]

we have seen DCE servers dump in binding_cache_lookup() (file security/client/rca/internal_binding.c).
binding_cache_lookup() assumes the context is not changing which is not correct.Some other thread which has the mutex for the context can be in the process
of rebinding (via rca_rebind) can cause the fileds (site_name in particular)
in the context to become null. binding_cache_lookup() does a strcmp() with this.This can be easily reproduced by running a test case which does sec. calls
from multiple threads and taking the secd down while it is running.
 
Turns out that locking the context mutex in binding_cache_lookup() 
will cause deadlocks as rca_site_bind() called from the client stub calls 
binding_cache_lookup() , but before the stub the same thread has locked 
the context. 
 
Any suggestions to fix this?.

[8/31/95 public]

Check out the fix in OT 13011 and tell us if that helps you.

[2/8/96 public]
The binding_cache_lookup() code has changed and the file 
security/client/rca/internal_binding.c has changed even more. I have lowered
the priority because binding code has been worked on in this release and this
may be fixed (from looking at the code). If not you can change the priority 
back up and provide more details like core dump stack trace etc... 
Mike, would you like to comment?


OK..Here are the details:

t@6 is the faulting thread
t@7 is rebinding.

[t@6 l@4]:w 
t@6
  [1] strcmp(), at 0xeefe27c8
=>[2] binding_cache_lookup(site_name = 0xee6f0f9f "/.../shasta.dce.transarc.com"
, auth_info = 0xee6f14d8, princ = 0xef6ef440 , cell = 0xee6f0b97 "/.../shasta.dc
e.transarc.com", context = 0xee6f0b8c), line 642 in "/afs/dfs.transarc.com/dept/
dce/dev/V1.1/12.043/src/security/client/rca/internal_binding.c"
  [4] rca_site_bind(site_name = 0xee6f0f9f "/.../shasta.dce.transarc.com", auth_
info = 0xee6f14d8, flags = 3, if_spec = (nil), princ = 0xef6ef440 , cell = (nil)
, context = 0xee6f1d18, status = 0xee6f1d14), line 2465 in "/afs/dfs.transarc.co
m/dept/dce/dev/V1.1/12.043/src/security/client/rca/internal_binding.c"
  [5] sec_rgy_site_bind(site_name = 0x21054 "", auth_info = 0xee6f14d8, context 
= 0xee6f1d18, status = 0xee6f1d14), line 187 in "/afs/dfs.transarc.com/dept/dce/
dev/V1.1/12.043/src/security/client/rca/binding.c"
  [6] sec_rgy_site_bind_query(site_name = 0x21054 "", auth_info = 0xee6f14d8, co
ntext = 0xee6f1d18, status = 0xee6f1d14), line 252 in "/afs/dfs.transarc.com/dep
t/dce/dev/V1.1/12.043/src/security/client/rca/binding.c"
  [7] do_func1(), line 52 in "c.c"
  [8] pthread_start(arg = 0x220f0), line 975 in "/afs/dfs.transarc.com/dept/dce/
dev/V1.1/12.043/src/sol_pth/pthread.c"
[t@6 l@4]: p cur->site_name 
cur->site_name = (nil)
[t@6 l@4]: list 638
638
639          if (site_name && site_name[0])
640          {
641              if ((u_strcmp (cur->site_name, site_name) != 0) &&
642                  (u_strcmp (cur->cell_name, site_name) != 0))
643              {
644                  SEC_DBG_PRINTF(3,("Site mismatch\n"));
645                  continue;
646              }
647          }
[t@6 l@4]:w t@7
t@7
  [1] _write(0x0, 0xb, 0x0, 0xee6f1e47, 0xff00, 0xff), at 0xeeff8650
  [2] write(0xee6cfa8c, 0x96790, 0xb5, 0x0, 0x0, 0x10d0a001), at 0xef1641a0
  [3] cds_send(Flags_p = 0xee6cfa8c, msg_p = 0x96790 ""), line 238 in "/afs/dfs.
transarc.com/dept/dce/dev/V1.1/12.043/src/directory/cds/library/dnssend.c"
  [4] cdsReadAttrValue(Name_p = 0xee6cf5dc, Handle_p = 0x97e08 "", AttrName_p = 
0xee6cf563, EntryType = cdsDirOrObj, Clearinghouse_p = 0xef7640fe, Value_pp = 0x
ee6cfa64, CTS_pp = (nil), AddrBuf_p = (nil), AddrBufLen_p = (nil), Flags_p = 0xe
e6cfa8c), line 138 in "/afs/dfs.transarc.com/dept/dce/dev/V1.1/12.043/src/direct
ory/cds/library/dnsreadattrvalue.c"
  [5] rpc__nsattr_read_resolution(nsentry = 0x21fa8, attr_type = 3, resolved_nam
e = 0xee6cff74 "", resolved_name_length = 0xee6cff6c, status = 0xee6cff64), line
 654 in "/afs/dfs.transarc.com/dept/dce/dev/V1.1/12.043/src/rpc/runtime/nsattr.c
"
  [6] rpc_ns_entry_inq_resolution(entry_name_syntax = 3, entry_name = 0x24308 "/
.../shasta.dce.transarc.com", resolved_name = 0x23fdc, unresolved_name = (nil), 
status = 0xee6d1d14), line 718 in "/afs/dfs.transarc.com/dept/dce/dev/V1.1/12.04
3/src/rpc/runtime/nsentry.c"
  [7] rca_site_bind_nsi(context = 0x23fc8, status = 0xee6d1d14), line 1835 in "/
afs/dfs.transarc.com/dept/dce/dev/V1.1/12.043/src/security/client/rca/internal_b
inding.c"
  [8] rca_nsi_binding_import(context = 0x23fc8, status = 0xee6d1d14), line 1205 
in "/afs/dfs.transarc.com/dept/dce/dev/V1.1/12.043/src/security/client/rca/inter
nal_binding.c"
  [9] rca_rebind(context = 0x23fc8, status = 0xee6d1d14), line 1596 in "/afs/dfs
.transarc.com/dept/dce/dev/V1.1/12.043/src/security/client/rca/internal_binding.
c"
  [10] rca_check_binding(context_p = 0xee6d07e4, which = 0, status = 0xee6d1d14)
, line 1743 in "/afs/dfs.transarc.com/dept/dce/dev/V1.1/12.043/src/security/clie
nt/rca/internal_binding.c"
  [11] rca_check_binding_resolved(context_p = 0xee6d07e4, which = 0, retry_count
 = 0xee6d07a8, status = 0xee6d1d14), line 1651 in "/afs/dfs.transarc.com/dept/dce/dev/V1.1/12.043/src/security/client/rca/internal_binding.c"
  [12] sec__id_parse_name(rcontext = 0x23fc8, domain = 0, global_name = 0x2105c 
"/.../shasta.dce.transarc.com/hosts/shasta/self", cell_namep = 0xee6d1913 "", ce
ll_idp = 0xee6d1900, princ_namep = 0xee6d14ff "", princ_idp = 0xee6d14ec, status
 = 0xee6d1d14), line 1361 in "/afs/dfs.transarc.com/dept/dce/dev/V1.1/12.043/src
/security/client/rca/secidmap.c"
  [13] sec_id_parse_name(rcontext = 0x23fc8, global_name = 0x2105c "/.../shasta.
dce.transarc.com/hosts/shasta/self", cell_namep = 0xee6d1913 "", cell_idp = 0xee
6d1900, princ_namep = 0xee6d14ff "", princ_idp = 0xee6d14ec, status = 0xee6d1d14
), line 1442 in "/afs/dfs.transarc.com/dept/dce/dev/V1.1/12.043/src/security/cli
ent/rca/secidmap.c"
  [14] do_func1(), line 57 in "c.c"
  [15] pthread_start(arg = 0x22138), line 975 in "/afs/dfs.transarc.com/dept/dce
/dev/V1.1/12.043/src/sol_pth/pthread.c"

[8/12/96 public]

  I was able to fix this problem by locking the cache_mutex in rca_check_binding
before calling rca_rebind().  This seems safe, and will stop 
binding_cache_lookup from examining contexts that are being updated by
rca_rebind.

  I have looked at the 1.2.1 code, and there still seem to be inconsistencies
between what mutexes need to be held during a particular operation.  It
would be nice if there were an explanation of the order these mutexes
should be obtained.  In particular, there are some functions that are exported
by this file that I think assume that the cache_mutex is locked when they
are called - the problem is that cache_mutex is static to the file and there
are no functions that are exported that would allow the mutex to be locked
by an external caller.

  internal_binding.c is a pretty confusing file.  For fun sit down and
draw a call graph of the functions in the file (it still makes me laugh
every time I look at it :).



CR Number                     : 12945
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : aud, sams
Short Description             : auditd usage message not in catalog
Reported Date                 : 7/6/95
Found in Baseline             : 1.1
Found Date                    : 7/6/95
Severity                      : D
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/6/95 public]

                          DCE Problem Report
                  =================================


Submitter Information (Include email address at miminum)
---------------------

Submitter Name:         Tom Jordahl
Organization:           Gradient Technologies
Email Address:          tomj@gradient.com
Phone:                  (508) 485-5235 x173
DCE License Number:     


Hardware/Software Configuration
- --------------------------------

Offering and Version:   DCE 1.1
Component (Module):     aud
Client Hardware:        x86
Client Software:        Unixware 2.0
Server Hardware:        SAME
Server Software:        SAME
Compiler:               Unixware cc

Problem Description
- --------------------

Severity Level: Minor

Date of First Occurrence: April 26, 1995

One Line Description:
auditd usage message not in message catalog

Full Description:

        The auditd usage message is specified 'undocumented' which
also means it doesn't get in the message table or catalog.

Repeat By:

        run auditd -x and see message not found error

Proposed Solution:

fix it in src/security/audit/libaudit/aud.sams:

***************
*** 135,141 ****
  action                "Give the trail file size limit (defined by the user) wi
th the \*L-s\*O option."
  end

! start           undocumented
  code          aud_s_dmn_usage
  sub-component         aud_s_general
  attributes    "svc_c_sev_fatal | svc_c_action_exit_bad"
--- 139,145 ----
  action                "Give the trail file size limit (defined by the user) wi
th the \*L-s\*O option."
  end

! start           intable incatalog undocumented
  code          aud_s_dmn_usage
  sub-component         aud_s_general
  attributes    "svc_c_sev_fatal | svc_c_action_exit_bad"



CR Number                     : 12944
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : krb5
Short Description             : portability issues in reading keytab files
Reported Date                 : 7/6/95
Found in Baseline             : 1.1
Found Date                    : 7/6/95
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/6/95 public]


                          DCE Problem Report
                  =================================


Submitter Information (Include Email address at miminum)
- ---------------------

Submitter Name:         Spike White
Organization:           HaL Software Systems
Email Address:          spike@hal.com
Phone:                  (512) 834-9964 x 5083
DCE License Number:     1352


Hardware/Software Configuration
- -------------------------------

Offering and Version:   DCE 1.1
Component (Module):     security
Client Hardware:        N/A 
Client Software:        N/A 
Server Hardware:        Sun 
Server Software:        Solaris 2.4 
Compiler:               SunSoft 2.0.1 

Problem Description
- -------------------

Severity Level: Severe 

Date of First Occurrence: 

One Line Description:

Our implementation found a portability problem in reading/writing keytab file. 
Full Description:

Fixed a "weakness" in  krb5_ktfileint_write_entry.  Namely, the "keytype"
field is written out as a krb5_ui_2, but read in (in krb5_ktfileint_read_entry)
as a krb5_keytype.  If the size of those types differ (as they did in our
implementation), you have problems.  The fix was to read and write the field
consistently as a krb5_keytype, whatever size that ends up being.


Repeat By:
   if sizeof(krb5_ui_2) != sizeof(krb5_keytype) for a given implementation,
   try to bring up secd and then CDS. The security server will not 
   authenticate cdsadv or cdsd with root credentials.  This is because cdsadv
   or cdsd reads the /krb5/v5srvtab key field incorrectly, so gives secd the
   wrong value for the key.  So the two keys don't match and the cds programs
   aren't authenticated.

Proposed Solution:
   Context diff is given below.

*** /net/wilma/ext/cvshome/apps/dce/sandbox/hal11_intl_sb/src/security/krb5/lib/keytab/file/ktf_util.c	Tue Dec  6 10:49:14 1994
--- ./ktf_util.c	Fri Sep 16 16:51:39 1994
***************
*** 8,23 ****
  /*
   * HISTORY
   * $Log:	c012944,v $
# Revision 1.1  95/07/06  22:45:27  root
# new CR
# 
-  * Revision 1.1  1994/12/06  16:49:14  spike
-  * @defects
-  *
-  * @comment
-  * Fixed a "weakness" in  krb5_ktfileint_write_entry.  Namely, the "keytype"
-  * field is written out as a krb5_ui_2, but read in (in krb5_ktfileint_read_entry)
-  * as a krb5_keytype.  If the size of those types differ (as they did in our
-  * implementation), you have problems.  The fix was to read and write the field
-  * consistently as a krb5_keytype, whatever size that ends up being.
-  *
   * Revision 1.1.9.2  1994/09/16  21:51:34  sommerfeld
   * 	[OT12036] Bug in ktfileint_delete_entry: doesn't byte swap length
   * 	enough places.
--- 8,13 ----
***************
*** 37,44 ****
  **
  */
  /*
!  * $Source: /project/ot/dce/d01/d29/RCS/c012944,v $
!  * $Author: root $
   *
   * Copyright (c) Hewlett-Packard Company 1991
   * Released to the Massachusetts Institute of Technology for inclusion
--- 27,34 ----
  **
  */
  /*
!  * $Source: /project/ot/dce/d01/d29/RCS/c012944,v $
!  * $Author: root $
   *
   * Copyright (c) Hewlett-Packard Company 1991
   * Released to the Massachusetts Institute of Technology for inclusion
***************
*** 109,115 ****
  
  #if !defined(lint) && !defined(SABER)
  static char rcsid_ktf_util_c[] =
! "$Id: c012944,v 1.1 95/07/06 22:45:27 root Exp $";
  #endif	/* !lint & !SABER */
  
  #include <krb5/krb5.h>
--- 99,105 ----
  
  #if !defined(lint) && !defined(SABER)
  static char rcsid_ktf_util_c[] =
! "$Id: c012944,v 1.1 95/07/06 22:45:27 root Exp $";
  #endif	/* !lint & !SABER */
  
  #include <krb5/krb5.h>
***************
*** 567,598 ****
  {
      krb5_data *princ;
      krb5_data **princp;
- #ifdef __haldce__ /* HaL@PORT-SOLARIS@19941212 SW */
-     /* 
-      * Name: Spike White (spike@hal.com)
-      * Reason:
-      *    In porting to Solaris, we had changed the size of
-      *    krb5_ui_2 from 2 bytes to 4 bytes.  This was to avoid
-      *    alignment errors (originally seen on SunOS w/ an earlier
-      *    version of the compiler).  But that exposed a weakness in
-      *    this code.  Namely, the krb5_ktfileint_write_entry writes the
-      *    "keytype" field out as a krb5_keytype (which is equivalent to a
-      *    krb5_ui_2 which is 32 bits in our implementation).  And
-      *    this routine reads it in as a krb5_int16, which is 16 bits.  That 
-      *    doesn't work.
-      * Approach:  Write the "keytype" field out as type krb5_keytype and read 
-      *    it in as the same type.  That way, whatever size this krb5_keytype 
-      *    type is in the future, the code still works.  And the comments at
-      *    the beginning of this file about the structure of a keytab file are 
-      *    still correct.
-      */
-     krb5_int16 count, size, size1; 
-     krb5_keytype keytype;
- #else
-     /* Original OSF code */
      krb5_int16 count, size, size1, keytype;
- #endif /* __haldce__ HaL@PORT-SOLARIS@19941212 SW */
- 
      krb5_error_code retval = 0;
      krb5_timestamp timestamp;
      krb5_int32	princ_type;
--- 557,563 ----
***************
*** 724,758 ****
      if (KTVERSION(id) == KRB5_KT_VNO_1)
  	    keytype = entry->key.keytype;
      else
- #ifdef __haldce__ /* HaL@PORT-SOLARIS@19941212 SW */
-     /* 
-      * Name: Spike White (spike@hal.com)
-      * Reason:
-      *    In porting to Solaris, we had changed the size of
-      *    krb5_ui_2 from 2 bytes to 4 bytes.  This was to avoid
-      *    alignment errors (originally seen on SunOS w/ an earlier
-      *    version of the compiler).  But that exposed a weakness in
-      *    this code.  Namely, the krb5_ktfileint_write_entry writes the
-      *    "keytype" field out as a krb5_keytype (which is equivalent to a
-      *    krb5_ui_2 which is 32 bits in our implementation).  And
-      *    this routine reads it in as a krb5_int16, which is 16 bits.  That 
-      *    doesn't work.
-      * Approach:  Write the "keytype" field out as type krb5_keytype and read 
-      *    it in as the same type.  That way, whatever size this krb5_keytype 
-      *    type is in the future, the code still works.  And the comments at
-      *    the beginning of this file about the structure of a keytab file are 
-      *    still correct.
-      */
- 	    switch (sizeof(keytype)) { 
- 	        case 2 : keytype = htons(entry->key.keytype);  break;
- 	        case 4 : keytype = htonl(entry->key.keytype);  break;
- 		default: goto abend;
-             }
- #else
- 	    /* Original OSF code */
  	    keytype = htons(entry->key.keytype);
- #endif /* __haldce__ HaL@PORT-SOLARIS@19941212 SW */
- 
      if (!xfwrite(&keytype, sizeof(keytype), 1, KTFILEP(id))) {
  	goto abend;
      }
--- 689,695 ----



CR Number                     : 12940
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : 
Short Description             : secd coredumps because authn_protocol == 255
Reported Date                 : 6/29/95
Found in Baseline             : 1.1
Found Date                    : 6/28/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/30/95 public]
We've had two occasions where secd has indexed through the
rpc_g_authn_protocol_idarray using a bad authn protocol (255 or 511).
I suspect the value is really -1 in disguise.  In both cases, the
bad authn protocol came from the auth_info.authn_protocol in an rpc
binding handle.  Both cases were making ncacn_ip_tcp RPCs.  At this
time the problem can not be reliably reproduced.

We're not certain of cause and effect, but the crashes seem to be
related to changing the security master in a cell.  Here's the chain
of events that caused the first crash (from one of our engineer's
notes):

    Some additional background information about how to reproduce this
    problem.
    I configured a secd on highline.
    I configured a security slave on testlab31.
    I designated the secd on testlab31 to be the master.
    I used dcesetup to configure a slave cds on testlab31.
    The script uses rgy_edit -update to create principals
    keytab files etc..
    >>>>>>This crashed the replica security server!!<<<<<<<<

The first occurrence was in rpc_auth_info_release, called from 
rpc__cn_assoc_sec_free, trying to access the free_info field of the
rpc_g_authn_protocol_id's epv vector.

From the first core:
 [1] 0x322e3220(0xedfd89dc, 0xef766fa4, 0xef75aea8, 0xb988, 0x1, 0x234d58), at \
0x322e321f
=>[2] rpc__auth_info_release(info = 0x276714), line 562 in "/afs/transarc.com/p\
roject/dce/V1.1/12.019/src/rpc/runtime/comauth.c"
 [3] rpc__cn_assoc_sec_free(sec = 0xedfd8aac), line 4096 in "/afs/transarc.com/\
project/dce/V1.1/12.019/src/rpc/runtime/cnassoc.c"
 [4] rpc__cn_assoc_acb_dealloc(assoc = 0x233928), line 4690 in "/afs/transarc.c\
om/project/dce/V1.1/12.019/src/rpc/runtime/cnassoc.c"
 [5] rpc__cn_network_receiver(assoc = 0x233928), line 515 in "/afs/transarc.com\
/project/dce/V1.1/12.019/src/rpc/runtime/cnrcvr.c"
 [6] pthread_start(arg = 0x235868), line 919 in "/afs/transarc.com/project/dce/\
V1.1/12.019/src/sol_pth/pthread.c"

The value of auth_info->authn_protocol:
auth_info->authn_protocol = 255

The second occurrence was in rpc__auth_rpc_prot_epv, called from
rpc__cn_call_start.  The configuration was the same as above (the
crashed security server had been restarted and had been running
overnight).  This crash occured while he was changing the epoch on
a CDS directory.

From the second core:

*binding_r->auth_info = {
    cache_link        = {
        next = 0x28caf8
        last = 0xef79eeec
    }
    refcount          = 2
    server_princ_name = 0x283c80 "dce-ptgt@highline.dce.transarc.com"
    authn_level       = 5
    authn_protocol    = 511      <----- This is the offending value
    authz_protocol    = 1
    is_server         = 0
    u                 = {
        auth_identity = 0x1
        s             = {
            privs = 0x1
            creds = (nil)
        }
    }
}

=>[1] rpc__auth_rpc_prot_epv(authn_prot_id = 511, rpc_prot_id = 0), line 375 in "/afs/transarc.com/project/dce/dev/sb/nydick/nydick2/sb4/src/rpc/runtime/comauth.c"
  [2] rpc__cn_call_start(binding_r = 0x2a2340, call_options = 0, ifspec_r = 0xef73ef1c, opnum = 3, transfer_syntax = 0xedfa1ce4, st = 0xedfa1c84), line 337 in "/afs/transarc.com/project/dce/dev/sb/nydick/nydick2/sb4/src/rpc/runtime/cncall.c"
  [3] rpc_call_start(binding_h = 0x2a2340, flags = 0, ifspec_h = 0xef73ef1c, opnum = 3, call_handle = 0xedfa1c78, xfer_syntax = 0xedfa1ce4, status = 0xedfa1c84), line 175 in "/afs/transarc.com/project/dce/dev/sb/nydick/nydick2/sb4/src/rpc/runtime/comcall.c"
  [4] op3_csr(handle = 0x2a2340, authn_svc = 1, authz_svc = 2, requested_privs = 0x26c70c, ptgt_req = 0x299848, ptgt_rep = 0xedfa1f68, granted_privs = 0xedfa1ec0, aux_attr_request = 0xedfa1d94, aux_attr_result = 0xedfa1d88, app_tkt_request = (nil), app_tkt_result = 0xedfa1d7c, status = 0xedfa28d8), line 1917 in "/afs/transarc.com/project/dce/dev/sb/nydick/nydick2/sb4/obj/sparc_sol24/security/utils/rpriv_cstub.c"
  [5] sec_priv_get_eptgt_internal(login_context = 0x26bea8, target_cell = 0xedfa212b "/.../highline.dce.transarc.com", authn_svc = 1, authz_svc = 2, recurse = 1, privs = (nil), stp = 0xedfa28d8), line 991 in "/afs/tr/proj/dce/V1.1/12.017/src/security/client/rca/priv.c"
  [6] sec_priv_get_eptgt_internal(login_context = 0x26bea8, target_cell = 0xedfa212b "/.../highline.dce.transarc.com", authn_svc = 1, authz_svc = 2, recurse = 0, privs = 0xedfa28d8, stp = 0x45586732), line 1205 in "/afs/tr/proj/dce/V1.1/12.017/src/security/client/rca/priv.c"
  [7] _dce_JpVAJVgvCx(security_context = 0x26bea8, target_cell = 0xedfa212b "/.../highline.dce.transarc.com", authn_svc = 1, authz_svc = 2, stp = 0xedfa28d8), line 307 in "/afs/tr/proj/dce/V1.1/12.017/src/security/client/login/sec_login_util.c"
  [8] get_auth_info_creds(creds = 0xedfa2594, status = 0xedfa28d8), line 236 in "/afs/transarc.com/project/dce/V1.1/12.019/src/security/server/rs/rs_rep_auth.c"
  [9] rs_rep_auth_get_auth_info(auth_info = 0xedfa275c, status = 0xedfa28d8), line 375 in "/afs/transarc.com/project/dce/V1.1/12.019/src/security/server/rs/rs_rep_auth.c"
  [10] rs_rep_mgr_get_info_and_creds(h = 0x2798c0, rep_info = 0xedfa28e0, rep_auth_info = 0xedfa28dc, st = 0xedfa28d8), line 225 in "/afs/transarc.com/project/dce/V1.1/12.019/src/security/server/rs/rs_repmgr.c"
  [11] op0_ssr(h = 0x2798c0, IDL_call_h = 0x2af978, IDL_elt_p = 0xedfa2cc0, IDL_drep_p = 0x2339a4, IDL_transfer_syntax_p = 0x2afb6c, IDL_mgr_epv = 0x19ebb0, IDL_status_p = 0xedfa2c9c), line 893 in "/afs/transarc.com/project/dce/V1.1/12.019/obj/sparc_sol24/security/server/rs/rs_repmgr_sstub.c"
  [12] rpc__cn_call_executor(arg = 0x2af978, call_was_queued = 0), line 225 in "/afs/transarc.com/project/dce/dev/sb/nydick/nydick2/sb4/src/rpc/runtime/cncthd.c"
  [13] cthread_call_executor(cthread = 0x26cb58), line 604 in "/afs/transarc.com/project/dce/dev/sb/nydick/nydick2/sb4/src/rpc/runtime/comcthd.c"
  [14] pthread_start(arg = 0x26cc28), line 915 in "/afs/transarc.com/project/dce/dev/sb/nydick/nydick2/sb4/src/sol_pth/pthread.c"

I still have the cores if someone would like more information.

[8/10/95 public]

Why do you think that the value is really -1? (rpc_authn_protocol_id_t is
unsigned32.)

In a client binding, auth_info.authn_protocol is set to
rpc_c_authn_dce_private (1) by rpc__krb_bnd_set_auth() (through
rpc_binding_set_auth_info()). It is a read-only field. At the same time,
auth_info.u.auth_identity is set by sec_krb_get_cc(), which really is a
login context. In the above second trace, it was 0x1. Shouldn't it be
0x26bea8? Also, in the second trace, sec_priv_get_eptgt_internal() was
called by sec_priv_get_eptgt_internal(), which shouldn't happen. I think
that the level 6 is really sec_priv_get_eptgt() because privs and stp got
shifted. (The debugger seems to be lying. Can we trust the authn_protocol
value reported by the debugger?) Looks like some sort of memory corruption
because two read-only fields had weird values. (Hard to tell who
corrupted.) Do you still have a core file? If so, can you check the
auth_info_cache list?

[12/21/95 public]

We do not consider this problem critical any
longer, since a workaround has been discovered.

Below are additional notes on how to reproduce the problem, using
which, I hope you will be able to verify whether or not this
has been fixed in DCE 1.2.1:
 
After designating the slave registry as the new master, it takes
about 5 minutes for the registrys to synchronize.  I deliberately
proceeded with the test before the synchronize completed and
reproduced the crash.  If I wait for the registrys to synchronize
then the crash does not occur.  The case of waiting for the
synchronize was tested three times.  We also found that
restarting the crashed secd seemed to work and allow things
to proceed as normal.  For this reason
we should downgrade this defect to sev 3 and make
an appropriate release note to document the workaround.
 
The release note should be something like:
 
"When designating a new master security registry, wait about 5 minutes
to allow the registrys to fully synchronize before doing any
registry write operations (i.e. creating principals etc.).
Check that the registrys are synchronized with "dcecp registry verify"
before performing write operations.  Failure to do so may cause
one of the secd to crash. In that event, simply restart the secd."



CR Number                     : 12937
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : acct_rename
Short Description             : acct_rename test script doesn't pass
Reported Date                 : 6/26/95
Found in Baseline             : 1.1wp
Found Date                    : 6/26/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/26/95 public]

acct_rename test script doesn't pass. The file 
src/test/security/api/control/acct_rename.tsh has the following in it:

test $TEST \
"2 account does not exist" \
$ACCT_RENAME_NOT_FOUND $sec_rgy_object_not_found

test $TEST \
"3 target account already exists" \
$ACCT_RENAME_NOT_FOUND $sec_rgy_name_exists

Test 3 should never pass, since it is doing exactly the
same test as test 2.

Repeat By:

        Run the security api acct_rename tests.

Proposed Solution:


Change the test file:

*** /dce/build/dce1.1/src/test/security/api/control//acct_rename.tsh    Mon Dec
12 23:08:27 1994
--- acct_rename.tsh     Mon Jun 19 16:40:19 1995
***************
*** 6,11 ****
--- 6,13 ----
  # src directory for the full copyright text.
  #
  # HISTORY
+ # Fix third test to actually test already exists and
+ # look for object exists error code.
  # $Log:	c012937,v $
# Revision 1.1  95/06/26  15:16:28  root
# new CR
# 
  # Revision 2.1  1994/12/13  04:06:23  devrcs
  # OSF DCE 1.1 Source
***************
*** 68,74 ****
 
  test $TEST \
  "3 target account already exists" \
! $ACCT_RENAME_NOT_FOUND $sec_rgy_name_exists
 
  # In dce 1.0 the only valid key_parts value is sec_rgy_acct_key_person.
  # No test of non-unique key parts will be conducted until this
--- 70,76 ----
 
  test $TEST \
  "3 target account already exists" \
! $ACCT_RENAME_ALREADY_EXISTS $sec_rgy_object_exists

  # In dce 1.0 the only valid key_parts value is sec_rgy_acct_key_person.
  # No test of non-unique key parts will be conducted until this



CR Number                     : 12936
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : grp_override
Short Description             : grp_override tests fails
Reported Date                 : 6/26/95
Found in Baseline             : 1.1wp
Found Date                    : 6/26/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/26/95 public]

Customer reported:

I am getting failures that are timing related on SVR4.

If I add a sleep(1) in between each test, I can duplicate the
OSF results, otherwise I get sparadic failures.

I believe the problem is sec_clientd(aka dced) checks the modification
time of the override file, and since this is in seconds, doesn't
refresh its cache if things happen too quickly (as they do in the test).

Note that sequence #23 fails both for me and in the OSF 1.1 test results.
I have not analyzed why this test fails.  I'll leave this to HP/OSF

Repeat By:

        Run grp_override test on a sufficiently fast machine.
        Sequence 19 (and possbily later tests) will fail.
        Sequence 23 will always fail.

Proposed Solution:

        Add a sleep or at least a second between each replacement
of the group override file.  This way the modification times are
certain to be different.

        This will not fix the failure for #23.



CR Number                     : 12935
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : grp_override
Short Description             : grp_override functional tests install in the wrong place
Reported Date                 : 6/26/95
Found in Baseline             : 1.1wp
Found Date                    : 6/26/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/26/95 public]

grp_override functional tests install in the wrong place.

Proposed Solution:

Fix the IDIRS:

*** /dce/build/dce1.1/src/test/functional/security/grp_override/Makefile
Tue Dec 13 00:03:25 1994
--- Makefile    Tue Jun 20 11:50:42 1995
***************
*** 25,31 ****
 
  ILIST         = ${DATAFILES}

! IDIR            = ${TET_ROOT}/security/
 
  SUBDIRS               = ts

--- 25,31 ----
 
  ILIST         = ${DATAFILES}

! IDIR            = ${TET_ROOT}/grp_override/
 
  SUBDIRS               = ts

*** /dce/build/dce1.1/src/test/functional/security/grp_override/ts/Makefile
Tue Dec 13 00:03:31 1994
--- Makefile    Tue Jun 20 11:52:07 1995
***************
*** 45,51 ****
 

  # Directory in which to install the files
! IDIR = /test/tet/functional/grp_override/
 
  grp_override_OFILES = \
                         grp_override.o
--- 45,51 ----
 

  # Directory in which to install the files
! IDIR = ${TET_ROOT}/grp_override/ts/
 
  grp_override_OFILES = \
                         grp_override.o



CR Number                     : 12927
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : 
Short Description             : kerberos error codes ret'd where DCE sec msgs expected
Reported Date                 : 6/21/95
Found in Baseline             : 1.0.3
Found Date                    : 6/21/95
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/21/95 public]

Kerberos error messages occassionaly percolate up through the
DCE security services.  For these codes no translation to text is
available. In general, kerberos failure messsages are intercepted
inside of DCE and mapped to a DCE message, but this doesn't 
happen all the time.

I have had users give me error status codes that I have then had to
look up in krb5/lib/error_tables files.  This is not right.  Digital
doesn't ship these error table header files.  Do other vendors do this?

Can the kerberos->DCE messaging be cleaned up so that sense can be
made of these error codes?

[12/8/95 public]
Yes, other vendors do ship those msg catalogs, and they translate fine.
I've downgraded this for now, since there's no obvious bug here, just
a friendliness issue over what types of errors appear where.  This is really
be an enhancement request to translate KRB errors to DCE SEC errors,
and I've marked it as such.



CR Number                     : 12919
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : creds/auth
Short Description             : creds shareable by all clients from foreign cell
Reported Date                 : 6/15/95
Found in Baseline             : 1.1
Found Date                    : 6/15/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/15/95 public]

Mike Burati sent out this detailed explanation of a weakness in the way
creds for foreign cell principals are stored in the local filesystem:

>There's another limitation which I don't believe is documented well enough,
>that I believe all vendors should be made aware of, so that they can deal
>with it as they see fit.
>
>Allowing intercell login poses yet another security limitation, unless you
>trust all members of your cell when you perform an intercell login.  (I can
>hear the "huh?" responses now :-)
>
>When you perform an intercell login (user Mike from Cell A logs into a
>machine in Cell B as /.../cella/mike), it is not possible for the processes
>created for you on that machine (assume Unix for this scenario) to run as
>the Unix ID assigned to user mike in Cell A (because that same Unix ID may
>be assigned to another user in Cell B).  Thus, ALL users from Cell A that
>log into a machine in Cell B, using intercell login, will be assigned the
>Unix ID of the account created in CellB for CellA's intercell trust
>(krbtgt/cella).
>
>While '/.../cella/mike' is logged on to this machine in Cell B, *any* user
>from CellA can log onto that machine and have the same Unix credentials as
>Mike.  This allows any of those /.../cella/* users to log into that machine
>and access the DCE credentials stored for /.../cella/mike (since they're
>stored in a file protected by the Unix ID krbtgt/cella).  Any one of these
>users could remove the credentials, or improperly obtain them (as simple as
>setting KRB5CCNAME to Mike's credential files).
>
>What does this mean?
>It means Intercell Login is less useful than customers may be led to
>believe, if they don't understand what the limitations are.  Intercell
>trust for RPCs is what a customer may really want when they connect two
>cells, but by default intercell login is allowed after that point, so
>uninformed users and admins could be affected by this limitation.  We are
>in the process of opening an OT warning about this limitation and
>suggesting how a vendor might make abuse of this limitation more difficult
>and require administrator intervention (don't allow intercell logins by
>default just because intercell trust has been established).


The workaround we're recommending is to require an administrative decision
on a per-foreign cell basis to enable such intercell logins, by causing the
security server to check for the validity flag on any of the foreign cell's
accounts (typically there's exactly one, krbtgt/foreign-cell.none.none, but
this is not architecturally specified.)  This is a change in default behav-
ior that will have to be publicized in admin/config docs and release notes.


--- rpriv.c     Tue Jun 13 16:19:37 1995
***************
*** 335,336 ****
--- 335,345 ----
  
+       sec_rgy_login_name_t    fcell_aname;
+       sec_rgy_cursor_t        cursor;
+       sec_rgy_sid_t           sid;
+       sec_rgy_unix_sid_t      unix_sid;
+       sec_rgy_acct_key_t      key_part;
+       sec_rgy_acct_user_t     user_part;
+       sec_rgy_acct_admin_t    admin_part;
+       error_status_t          xst;
+ 
        /* 
***************
*** 366,367 ****
--- 375,401 ----
                SET_STATUS(stp, sec_priv_s_invalid_request);
+               goto get_ptgt_cleanup;
+           }
+ 
+           /*
+            * Verify that remote logins are allowed on any foreign cell
+            * account -- this affords some control over the "shared creds"
+            * problem, which occurs because all remote users' creds are
+            * stored in the local filesystem under the same uid owner.
+            */
+           u_strcpy(fcell_aname.pname, authz_data.client_tgt_princ);
+           fcell_aname.gname[0] = '\0';
+           fcell_aname.oname[0] = '\0';
+           rs_util_clear_cursor(&cursor);
+           SET_STATUS(stp, sec_priv_s_invalid_trust_path);
+ 
+           for (;;) {
+               rsdb_acct_lookup(&fcell_aname, &cursor,
+                                &sid, &unix_sid, &key_part,
+                                &user_part, &admin_part, &xst);
+               if (BAD_STATUS(&xst))
+                   break;
+               if (admin_part.flags & sec_rgy_acct_admin_valid) {
+                   CLEAR_STATUS(stp);
+                   break;
+               }
            }

--- rpriv_v1_1_mgrs.c   Tue Jun 13 16:19:56 1995
***************
*** 1482,1483 ****
--- 1482,1519 ----
            }
+ 
+           if (STATUS_OK(status)) {
+               /*
+                * Verify that remote logins are allowed on any foreign cell
+                * account -- this affords some control over the "shared creds"
+                * problem, which occurs because all remote users' creds are
+                * stored in the local filesystem under the same uid owner.
+                */
+ 
+               sec_rgy_login_name_t    fcell_aname;
+               sec_rgy_cursor_t        cursor;
+               sec_rgy_sid_t           sid;
+               sec_rgy_unix_sid_t      unix_sid;
+               sec_rgy_acct_key_t      key_part;
+               sec_rgy_acct_user_t     user_part;
+               sec_rgy_acct_admin_t    admin_part;
+               error_status_t          xst;
+ 
+               u_strcpy(fcell_aname.pname, authz_data.client_tgt_princ);
+               fcell_aname.gname[0] = '\0';
+               fcell_aname.oname[0] = '\0';
+               rs_util_clear_cursor(&cursor);
+               SET_STATUS(status, sec_priv_s_invalid_trust_path);
+ 
+               for (;;) {
+                   rsdb_acct_lookup(&fcell_aname, &cursor,
+                                       &sid, &unix_sid, &key_part,
+                                       &user_part, &admin_part, &xst);
+                   if (BAD_STATUS(&xst))
+                       break;
+                   if (admin_part.flags & sec_rgy_acct_admin_valid) {
+                       CLEAR_STATUS(status);
+                       break;
+                   }
+               }
+           }
        }

[02/02/96 public]
Yow, these diffs are out of date -- later removed & changes made to other
modules.  This spirit of the description remains, though:  in DCE 1.2.1
the cell account validity flag is checked, and dcecp "registry connect"
has two new switches (-acctvalid & -facctvalid) that allow the selection
of permitting such intercell logins.

No further plans to address this problem; left as enhancement.



CR Number                     : 12912
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : gssapi
Short Description             : unused arguments in gss_init_sec_context
Reported Date                 : 6/7/95
Found in Baseline             : 1.1
Found Date                    : 6/7/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/7/95 public]

In the gss_init_sec_context routine the 7th argument is passed in 
but never used.  I am opening this on behalf of the IBM AIX 
Security Team.

[7/16/95 public]

Does anyone have an opinion about this defect?

[7/17/95 public]

Yes - It's not a bug, it's a feature :-).

The GSSAPI spec says that this argument (time_req) is for the user to specify
a requested length of time that the created context will remain valid.  Since
the DCE imeplementation allows contexts to remain valid indefinitely (and
correctly reports this via the time_rec return parameter), the time_req
parameter serves no purpose in the DCE implementation, and is ignored.

I'd say this defect should be cancelled.  However, raising the priority to 
B2 implies that there is a critical need for a fix.  What problem would
reading (and presumably honoring) this argument solve?

[7/19/95 public]

I am appending this from an IBM internal defect.  Please bear 
with the IBM stuff in this.  Please tell us if the behavior on HPUX
or OSF/1 is different....

    <Note by jejones (Ed Jones), 95/07/18 10:55:06, action: note>
GSS does not return indefinite in the non-mutual authentication case, it 
returns zero (see the first two notes above, when mutual authentication is
not being used, the client does not issue the gss_init_sec_context a second
time). Without going any further, this is a defect.
If we are not going to tell the user how long a context is valid for, we 
should document this in the description of gss_init_sec_context. The fact that
we are not going to support context lifetimes, but support creds lifetimes,
as shown by the proper setting of the lifetime_req and lifetime_rec parameters
on the gssdce_login_context_to_cred call, is somewhat inconsistent. What it  
seems to me we are doing is telling the user that your credentials are valid fora given length of time, but we are not going to tell you how long t
he contexts
you create from the creds are good for, either at the context init time or
through the query context life remaing call (gss_context_time). The information
seems to be there, we should look at the effort needed to fully support the
API.
In addition, we should be making it as easy as possible to port existing GSS
applications to use the DCE Security mechanisms, without requiring too many
code changes. By supporting context lifetimes, we make it easier for an
application to know when it must re-authenticate to DCE. It seems to me that 
an application that is concerned about security would not desire to have
indefinite context lifetimes, but would want to be able to protect itself
by constantly creating new contexts, for all the reasons that DCE gives for 
reauthenticating frequently.

[7/20/95 public]

If gss_init_sec_Context is returning 0 as the context lifetime (when it returns
a status of GSS_S_COMPLETE), that's certainly a bug.  However, from the
description above, it sounds as though gss_init_sec_context hasn't finished - 
it needs to be called a second time.  Even if the application doesn't ask for
mutual authentication, sequence numbers have to be set up in each direction,
so that integrity protection can work in either direction, and the protocol
requires a reply message to do that.  The application should not be assuming
that, just because mutual authentication was not requested, a response message
is not required.  A valid GSSAPI-caller should always invoke the
gss_init_sec_context/gss_accept_sec_context calls inside a loop, checking
both the output-token length field to determine whether there is a token to
send, and the return status to see whether to exit the loop.  It sounds as
though, in this case, the application isn't waiting for the reply message. 
Can you verify that the application is checking the return status of
gss_init_sec_context, and that a status of GSS_S_CONTINUE_NEEDED isn't
being returned?  If a value of zero is being returned as the context lifetime
when gss_init_sec_context really has finished, could you open a fresh OT 
about that, please?


By returning the value GSS_C_INDEFINITE, GSSAPI is indicating that, as far as
it can tell, the context will never expire.  Once a context is established,
use of the per-message services allow the recipient to determine that the
originator of a message is the same entity that authenticated.  They don't
necessarily mean that that entity would be capable of re-authenticating.
The only reason to expire a context is to protect the session key against
over-use, and how much is over-use isn't obvious to GSSAPI (it really
depends on what you perceive as the threat, and how valuable is the aggregate
of all data that you have sent over the context).  Thus, GSSAPI doesn't have
any reason to impose a lifetime of its own.

Now, if the user asks for a finite lifetime, I guess GSSAPI could enforce
it (it currently doesn't).  The intended behavior is to return GSS_C_INDEFINITE
in all cases.  However, if an application has decided that it wants to renew
the context after a given time, then the application is capable of noticing
when that time arrives and doing the rollover then.  Note that a portable
application would have to do this anyway, since the GSSAPI spec doesn't require
that GSSAPI honor the application's request for a particular lifetime, even
if the GSSAPI implementation does support context expiration.  A GSSAPI may
ignore the application's request, may round it up or down (although rounding
down is unfriendly, and shouldn't be done if it can be avoided), or it may 
enforce it.  The lifetime_req parameter is intended as a hint to the GSSAPI
implementation about the length of time that the application is going to want
to use the context, so that if something special has to be done to create a 
context that will last that long, then GSSAPI should do the extra work.  It's
not supposed to be a way for applications to get a timer service from GSSAPI.



CR Number                     : 12895
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : security
Short Description             : Usage of old context when a new context is set
Reported Date                 : 5/31/95
Found in Baseline             : 1.1
Found Date                    : 5/31/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/31/95 public]

Dawn Stokes at IBM observed the /opt/dcelocal/var/security/creds dir
had many obsolete creds files for the various dfs servers and found
that to an error in the dfsauth package. 

While reading the security code for set_login_set_context to look at
Dawn's suggested fix, I observed that when set_login_set_context is
called when one already has a current context, the code creates a new
dcecred_XXXXXXXX, dcecred_XXXXXXXX.data files for the new context that
are hardlinks to the dcecred files (say dcecred_YYYYYYYY*) for the
current context.  Then the routine that writes out the new login
context writes it into a temporary file and then renames it atomically
over dcecred_XXXXXXXX file effectively orphaning the dcecred_YYYYYYYY
files which seems unintuitive. Clearly the hardlinks created suggest
that any old users of the current (old) context will somehow fallover
to using the new context but the rename operation clearly prevents
that. So its self-inconsistent. 

Is this the desired behaviour?

[5/31/95 public]

This defect looks interesting. I have heard somewhat related problem
from another customer:

> On command line:
> dce_login <princ> <princ_passwd>
>
> Sometime later:
> I want to run a utility within the context of the earlier shell that will
> extend my expiration time.
>
> For this I could use kinit, but cant because kinit does some funny things
> with the tty to read the passwd. Hence I am trying to use a very simple
> program. The program takes as an argument the passwd for the currently 
> logged in context.
>
> The steps are:
> - Get the login context
> - Refresh the context using
>      sec_login_refresh_identity (inherited context,  status)
>   If the status is okay, and now it is, then
>      sec_login_validate_identity(lc, ....) using the passwd string.
>
> I set the current login context after validating. But this step is noise
> because there is no difference whether I set the context or not.
>
> Now when I run this program, I have no problem at all. There are no errors.
> When I exit the program, and run klist I see no change in the expiration
> time for the  krbtgt, or the ticket granting ticket.
>
> But If I do this process using kinit, I can see the change in the krbtgt time.
>
> What am I doing wrong ?



CR Number                     : 12889
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : 
Short Description             : A 1.1 client restricted to the DG
protocol isn't able to config against a 1.0.x server
Reported Date                 : 4/04/95
Found in Baseline             : 1.1
Found Date                    : 4/06/95
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : client/rca/priv.c
Sensitivity                   : public

[5/26/95 public]

(from Tom Jordahl @ Gradient)

If a 1.1 client is restricted to the DG protocol, it is unable to config
against a 1.0.x server.  In the 1.1 security code (src/client/rca/priv.c) 
it is assumed that you will get back either an rpc_s_unknown_if, or
ept_s_not_registered status back from an attempt to bind to a 1.0.x
secd.  It seems that if DG is used, the rpcd will drop the packets with
an idl 1.1 interface version, and the status returned is comm_failure.

Repeat by:

Config a 1.1 client with RPC_SUPPORTED_PROTSEQS=ncadg_ip_udp against
a 1.0.x server

Proposed Solution:

Check for comm_failure and try the 1.0 interface?
Doesn't seem like a great idea...



CR Number                     : 12883
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : command_ref
Short Description             : describe initial object permission glitch
Reported Date                 : 5/23/95
Found in Baseline             : 1.0.3
Found Date                    : 5/23/95
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/23/95 public]

The following describes a quirk of ACLs on CDS directories.  I'm not sure
whether this
 really belongs in the acl_edit  man page, some CDS doc,  release notes, or
what.
 
 The problem:
 
 When specifying the permissions for ACL entries of the Initial Object ACL
on CDS directories,
 the user is allowed to turn on the "i" and "a" permissions.  The semantics
of these permissions
 are such that they simply do not apply to objects.  But being set in the
Initial Object ACL
 means that any object created in the directory will automatically inherit
them for its ACL.
 Attempts to modify the ACL on the object, other than to clear these bits,
will fail
 with no clear indication of exactly why.
 
 
 According to OSF, there are backward compatibility reasons for maintaining
this behavior
 on CDS Version 3 directories (e.g. OSF1.0.3 and below).
 
 REPRODUCIBLE:
 yes
Related-file::Added 950421 by lconrad:: R
 
 
 Added the following text to the 1.0 release notes:
      permissions associated with a CDS object and the command fails,
       check the Initial Object ACL associated with the CDS directory.
       Although i (insert) and a (administer) permissions do not apply
       to CDS objects, they can be inherited from the Inital Object ACL
       associated with the parent directory. If the i and a permissions
       are set, turn them off.
Related-file:::: Resolution 
 DESCRIPTION OF BUG FIX:
  Described problem and corrective action in both the 
  release notes and the acl_edit manpage.
  
 REGRESSION TEST SCENARIO:
  
  
 RCSDIFFS (either inserted manually or via Fci):
  Inserted by FCI (manpage diffs) 
  See enclosure for Release notes text.

Related-file::Added 950421 by ddts::
/build/hiosfm/RCS/dce/doc/admin.rf/man1sec/./acl_edit.1sec,v 7.7
 /build/hiosfm/RCS/dce/doc/admin.rf/man1sec/./acl_edit.1sec,v 7.7
 lconrad 1995/04/21 20:11:16 +20 -10
 Reason:  OSDqa10934 describe initial object permission glitch
 Added description of inherited i and a ACL
 problem for CDS objects
 Reformatted NOTES section to match template
 Also added caveat that we do not support the GUI

    *** /tmp/ci.6412..acl_edit.1sec.6447.1     Fri Apr 21 16:11:19 1995
     --- /tmp/acl_edit.1sec.6447.2      Fri Apr 21 16:11:19 1995
     ***************
     *** 264,281 ****
       To do so, use the \fBcommit\fR subcommand to save the changes
without exiting 
       \fBacl_edit\fR or the \fBexit\fR subcommand to save the changes and 
       exit \fBacl_edit\fR.  Use the 
       \fBabort\fR subcommand to exit \fBacl_edit\fR and save none of the
changes 
       you have made.
     ! .nS note
     ! When you invoke \fBacl_edit\fR for a specific object's ACL, that ACL
is 
     ! not locked.  This means that it is possible for multiple users to 
     ! edit the ACL simultaneously, with each change overwriting the
previous changes.  
     ! For this reason, the number of users assigned rights to change 
     ! a particular ACL should be 
     ! tightly controlled and limited to one user if possible.
     ! .nE  
       .SH "INTERACTIVE SUBCOMMANDS"
       The following subcommands are available when \fBacl_edit\fR is
       invoked in interactive mode. All of the commands act on the
       ACL associated with the object specified by \fIpathname\fR
       when \fBacl_edit\fR was invoked.
     --- 264,291 ----
       To do so, use the \fBcommit\fR subcommand to save the changes
without exiting 
       \fBacl_edit\fR or the \fBexit\fR subcommand to save the changes and 
       exit \fBacl_edit\fR.  Use the 
       \fBabort\fR subcommand to exit \fBacl_edit\fR and save none of the
changes 
       you have made.
     ! .SH "NOTES"
     ! When you invoke \fBacl_edit\fR for a specific object's ACL, that ACL
     ! is not locked.  This means that it is possible for multiple users to
     ! edit the ACL simultaneously, with each change overwriting the
previous
     ! changes.  For this reason, the number of users assigned rights to
     ! change a particular ACL should be tightly controlled and limited to
     ! one user if possible.
     ! .PP
     ! If you attempt to use the \fBacl_edit\fR command to change the
permissions
     ! associated with a CDS object and the command fails, check the
Initial
     ! Object ACL associated with the CDS directory. Although \fBi\fR
(insert) and
     ! \fBa\fR (administer) permissions do not apply to CDS objects, they
can be
     ! inherited from the Initial Object ACL associated with the parent
     ! directory. If the \fBi\fR and \fBa\fR permissions are set, turn them
off.
     ! .PP
     ! Hitachi DCE/Base-M does not currently support the \fBacl_edit\fR
command
     ! graphic user interface. You must use the command line interface to
     ! modify ACLs on CDS names.
       .SH "INTERACTIVE SUBCOMMANDS"
       The following subcommands are available when \fBacl_edit\fR is
       invoked in interactive mode. All of the commands act on the
       ACL associated with the object specified by \fIpathname\fR
       when \fBacl_edit\fR was invoked.

[5/17/96 public]

I have no idea whether this bug is still valid. The CR escaped
notice for some time because of some incorrect coding. Anyway,
I'm assigning it to HP now.

[7/23/96 public]
Peculiarities of ACLs for a particular component are documented in that 
component's documentation.  The security ACL sections (including acl_edit and 
and dcecp acl) describe generic use.  I think this CR should be assigned to 
CDS.



CR Number                     : 12882
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : krb
Short Description             : superfluous file in sources/build
Reported Date                 : 5/22/95
Found in Baseline             : 1.1
Found Date                    : 5/22/95
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1maint
Affected File(s)              : security/krb5/lib/krb5/Makefile
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/22/95 public]


 In security/krb5/lib/krb, the file in_tkt_sky.c is no longer needed
 in the build (not to mention containing bogus code!).
Related-file::Added 950403 by rusman::
/build/hiosfm/RCS/dce1.1/src/security/krb5/lib/krb5/./Makefile,v 8.3
 /build/hiosfm/RCS/dce1.1/src/security/krb5/lib/krb5/./Makefile,v 8.3
 rusman 1995/04/03 13:19:12 +3 -3
 Reason:  OSDqa11096 superfluous file in sources/build
 remove in_tkt_sky.o from build
 
     *** /tmp/ci.13168..Makefile.13202.1        Mon Apr  3 09:19:15 1995
     --- /tmp/Makefile.13202.2  Mon Apr  3 09:19:15 1995
     ***************
     *** 149,159 ****
        copy_princ.o copy_tick.o cp_key_cnt.o decode_kdc.o decrypt_tk.o \
        encode_kdc.o encrypt_tk.o free_rtree.o faddr_ordr.o \
        gc_2tgt.o gc_frm_kdc.o gc_via_tgt.o gen_rname.o \
               gen_subkey.o get_creds.o get_in_tkt.o
       libkrb5b_OFILES  = \
     !  in_tkt_pwd.o in_tkt_sky.o kdc_rep_dc.o krbconfig.o \
        mk_error.o mk_priv.o mk_rep.o mk_req.o mk_req_ext.o \
        mk_safe.o parse.o preauth.o pr_to_salt.o princ_comp.o \
        rd_error.o rd_priv.o \
        rd_rep.o rd_req.o rd_req_sim.o  rd_req_dec.o rd_safe.o  \
        send_tgs.o tgtname.o unparse.o walk_rtree.o \
     --- 149,159 ----
        copy_princ.o copy_tick.o cp_key_cnt.o decode_kdc.o decrypt_tk.o \
        encode_kdc.o encrypt_tk.o free_rtree.o faddr_ordr.o \
        gc_2tgt.o gc_frm_kdc.o gc_via_tgt.o gen_rname.o \
               gen_subkey.o get_creds.o get_in_tkt.o
       libkrb5b_OFILES  = \
   !  in_tkt_pwd.o kdc_rep_dc.o krbconfig.o \
        mk_error.o mk_priv.o mk_rep.o mk_req.o mk_req_ext.o \
        mk_safe.o parse.o preauth.o pr_to_salt.o princ_comp.o \
        rd_error.o rd_priv.o \
        rd_rep.o rd_req.o rd_req_sim.o  rd_req_dec.o rd_safe.o  \
        send_tgs.o tgtname.o unparse.o walk_rtree.o \

[3/11/96 public]
A redundant file that's useless but not causing any harm doesn't warrant
a C3 rating.  I've downgraded this to E4.



CR Number                     : 12866
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : replicas leave stale CDS info
after graceful shutdown
Reported Date                 : 5/12/95
Found in Baseline             : 1.1wp
Found Date                    : 5/12/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/12/95 public]

Replicas currently leave themselves registered in the cds
namespace after they're gracefully shut down; thus they can still be
offered for client binding, which entails long timeouts, and causes
seemingly random failures in sec_rgy_site_bind_update().

This is not a warranty patch problem per se, but when security
servers are migrated forward to full 1.1, any "true" 1.0.3
replicas get are told by the 1.1 master to shut down.  In so 
doing, those replicas leave stale bindings in the CDS namespace.
This causes, among other things, spurious failures in security
functional tests, many of which call sec_rgy_site_bind_update().

[5/12/95 public]

I neglected to mention that the workaround for this
problem is to (1) remove the server entry for the 
dead server from the namespace and (2) remove the
server link to that server entry from the /.:/sec
group in the namespace.  Or you could migrate the
server in question to 1.1 in the usual fashion
(see the warranty patch release notes for such a
fashion statement).



CR Number                     : 12864
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : cellalias
Short Description             : cell renames don't work reliably
Reported Date                 : 5/12/95
Found in Baseline             : 1.1wp
Found Date                    : 5/08/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/12/95 public]

*NOTE* "found in baseline" above should be "1.1 warrantee patch".

`cellalias set' correctly changes the primary name of the cell on all
systems within the cell, but after that change, some residues of the old
name linger on, and that lingering residue causes problems.

We have observed several failures after a cell rename which we haven't yet
had time to characterize; for instance, binding to a read-write replica
after contacting a read-only replica.

The most likely cause of this *within secd* is the use of the cell property
containing the "original" cell name as the "primary" cell name.  The
original is used in a half dozen places throughout secd, and perhaps half
of them should be using dce_cf_get_cell_name() instead.

There are also likely residues of the old cell name within CDS as well.

We tried to fix these, but they won't make the warrantee patch, so 
"cellalias set" will be disabled in the WP.

[6/8/95 public]

Could this be the cause of problems described in OT 12908?

[7/13/95 public]

Please add the comments at the end of the OT's "full description" with
appropriate tag "[your_name date public]" etc..... I have relocated the
following text as it was inserted at the wrong place:

-------BEGIN--------
This is a note from one of our developers []: 
  The 'cellalias set' function was to provide all function required to set an
  existing cell alias name to be the primary cell name, and in turn move the
  existing primary cell name to become an alias name.  This function is above
  that provided by 'cdsalias set' in that it 'notifies security'.  The 'cdsalias
  set' command specifically states that prior to its use, the CDS and Security
  servers, as well as each host in the cell, must know about the alias.  I am
  not 100% clear of how the required function is allocated between the
 'cellalias
  create', 'cdsalias set', and that which was to be available in 'cellalias
 set',
  but it does appear that in the current TCL script for 'cellalias set', there
 is
  some principal data modified, and then a 'registry verify' is performed which
  should updated all security replicas.  In viewing the existing OT defect on
  'cellalias set' it makes reference to some embedded security names not
 becoming
  updated properly.  Hence it is assumed that some problem with security is what
  has us lacking the function to be provided by 'cellalias set'.
  We require the means to take an existing cell and configure it into a hierar-
  chy.  We are not guaranteed that our customers will configure hierarchies
 based
  on strictly newly configured cells.  Hence we cannot assume that our configu-
  ration steps telling the customer to provide a cell name which is the ultimate
  primary name for the cell as it will exist in the hierarchy is satisfactory
  for an H-Cell product delivery.  Whatever is required to take an arbitrary
  existing cell and smoothly configure it into a hierarchy is the functionality
  we require.  In the readings on the H-Cells, it appears that the 'cellalias
  set' function was pivotal to this desired functionality.
-------END--------

[01/22/96 public]
This has been changed to an enhancement rather than a defect the
PM team has agreed to this change.



CR Number                     : 12860
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : client, server
Short Description             : Portability of threads macros
Reported Date                 : 5/9/95
Found in Baseline             : 1.1
Found Date                    : 5/9/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : client/login/sec_login_pag.c, client/login/sec_login_pvt.c, client/login/sec_login_np.c, client/login/[AT386|HP800|PMAX|RIOS|SVR4]/sec_login_np.c, server/rs/rwl.c
Sensitivity                   : public

[5/9/95 public]

A support customer raised the following point about several threads
macros used within security:

> We suggest making a simple change to  several places in the security code
> to enhance portability to Posix Threads based implementations, without impact
> on CMA Threads based ones.
> 
> As one example, in security/server/rs/rwl.c, the PSEM/VSEM macros
> are coded in a manner which exposes a nefarious behavioral difference
> between CMA Threads and Pthreads, coming from their definitions of the
> primitive type pthread_mutex_t. Similar remarks apply to pthread_cond_t.
> 
> In CMA threads these types are defined, essentially, as references
> to the objects in question. In our version of
> Pthreads, these types ARE the objects.  Thus an assignment statement
> as in the aforementioned PSEM macro creates of copy of the object, rather
> than merely another reference to it.  Using a copy of a mutex does not
> create the required serialization.  As we read the Posix Pthreads spec.
> there is room for just this kind of divergence between implementations
> supporting the API.
> 
> If the OSF sources are modified so that objects of these primitive types
> are never seen on the left hand side of assignment statements, these
> differences will never occur.  Since we believe that, over time, more
> ports of DCE will use Posix Threads, we suggest making such modifications
> to enhance portability now (and alert submitters of new code to
> the issue).
> 
> In all, three cases of macros requiring mods have been identified and
> are found in:
>        security/server/rs/rwl.c
>        security/client/login/sec_login_pag.c and sec_login_pvt.c
> In all cases, the change is merely to define a pthread_mutex_t* as the
> automatic variable, rather than a pthread_mutex_t.

On further examination, use of similar macros was found in the various
sec_login_np.c files listed above.  Also, the suggested change will be
a bit more complicated in server/rs/rwl.c, where the macro involves a
struct containing a mutex and not just a pthread_mutex_t.



CR Number                     : 12858
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_login
Short Description             : context expiration incorrect
Reported Date                 : 5/4/95
Found in Baseline             : 1.1
Found Date                    : 5/4/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/4/95 public]
sec_login_get_expiration extracts the expiration from the in-memory copy
of a login-context.  If it's called to inquire about the default
context, this means that it may not return the correct expiration time,
if the context has been refreshed by another process.

[5/12/95 public]

Following is customer reported problem that I believe is yet another symptom of
this problem:

on command line:
---------------
dce_login <princ> <princ_passwd>

sometime later:
--------------
I want to run a utility within the context of the earlier shell that will
extend my expiration time.

For this I could use kinit, but cant because kinit does some funny things
with the tty to read the passwd. Hence I am trying to use a very simple program

The program takes as an argument the passwd for the currently logged in context.

The steps are:
-------------
get the login context

refresh the context using 
sec_login_refresh_identity (inherited context,  status)

If the status is okay, and now it is, then

sec_login_validate_identity(lc, ....) using the passwd string.

I set the current login context after validating. But this step is noise
because there is no difference whether I set the context or not.

Now when I run this program, I have no problem at all. There are no errors.
When I exit the program, and run klist I see no change in the expiration time
for the  krbtgt, or the ticket granting ticket.

But If I do this process using kinit, I can see the change in the krbtgt time.



CR Number                     : 12840
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : Restrictions on default context
Reported Date                 : 4/12/95
Found in Baseline             : 1.1
Found Date                    : 4/12/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/12/95 public]
The following sec_login routines don't allow the use of the default
login-context.  While I can see arguments why a few of these routines might
not want to support the default context, for the rest it seems an arbitary
restriction.

sec_login_refresh_identity
sec_login_newgroups
sec_login_get_pwent

sec_login_validate_identity
sec_login_certify_identity
sec_login_valid_and_cert
sec_login_valid_from_keytable
sec_login_set_context
sec_login_purge_context
sec_login_release_context
sec_login_get_groups
sec_login_krb5_add_cred
sec_login_inq_pag
sec_login_become_initiator
sec_login_become_impersonator
sec_login_set_extended_attrs
sec_login_disable_delegation
sec_login_cred_get_initiator
sec_login_cred_get_delegate
sec_login_tkt_request_options

Routines in the first group above explicitly test for and reject an
attempt to use the default handle; routines in the second group call
sec_login_pvt_check_handle which doesn't like the default context.

Also, sec_login_purge_context rejects a null _pointer_ to a login-context
with the error sec_login_s_default_use, which isn't an appropriate error.



CR Number                     : 12785
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : security sams
Short Description             : missing arguments generate build warnings
Reported Date                 : 1/27/95
Found in Baseline             : 1.1
Found Date                    : 1/27/95
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/h/sad.sams
Sensitivity                   : public

[1/27/95 public]
During the build of security/h/sad.sams, two adjacent errors pop up:
 
Line 191: syntax error (ignored)
Line 192: syntax error (ignored)
 
Both are caused by the generation, in obj/*/security/dcesad.msg, of the
lines
 
184
185
 
... both of which lack text for their message.
 
Proposed solution: Change src/security/h/sad.sams to have the following
block replace the existing one -- the unused message contents are
*totally* up to you...
 
  start
  code            pwd_imp_err_DEL0
! text            "no message"
  explanation     "MESSAGE NOT REFERENCED, THEREFORE DELETED."
  action          "None required"
  end
 
  start
  code            pwd_imp_err_DEL1
! text            "no message"
  explanation     "MESSAGE NOT REFERENCED, THEREFORE DELETED."
  action          "None required"
  end

[12/21/95 public]
Build  "warnings", (especially useless ones like the above) don't warrant
a C2 rating.  Bumped it down to E4.

[2/8/96 public]
Actually, I just checked the build logs on rios and hp and I don't see
these messages...

Changed the platform and marked it enh.



CR Number                     : 12780
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : gssapi test
Short Description             : Extra free's in test-gssapi.c
Reported Date                 : 1/26/95
Found in Baseline             : 1.1
Found Date                    : 1/26/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : test/security/api/gssapi/test-gssapi.c
Sensitivity                   : public

[1/26/95 public]
Free's showed up as errors when using sentinel.

diff -c test-gssapi.c fixed-test-gssapi.c 
*** test-gssapi.c       Thu Jan 26 11:14:18 1995
--- fixed-test-gssapi.c Thu Jan 26 11:15:34 1995
***************
*** 994,1000 ****
                    error_status);
            fflush(stderr);
        };
-       if (temp_c_ptr) free(temp_c_ptr);
  
        temp_c_ptr = NULL;
        fprintf(stdout, 
--- 994,999 ----
***************
*** 1011,1017 ****
            fflush(stderr);
            if (interactive) pause();
        };
-       if (temp_c_ptr) free(temp_c_ptr);



CR Number                     : 12778
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : test_gd
Short Description             : acct_rename already_exists case is wrong?
Reported Date                 : 1/20/95
Found in Baseline             : 1.1
Found Date                    : 1/20/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : src/test/sec*/api/c*/acct_rename.tsh
Sensitivity                   : public

[1/20/95 public]
 
Aswini (here at T'arc) notes that case 3 in the acct_rename tests is
probably set up incorrectly. The comment and the C code for the suite
seems to expect the subcase to be ACCT_RENAME_ALREADY_EXISTS, but the
TSH for the subcase tries another ACCT_RENAME_NOT_FOUND .
 
At first glance, I can't immediately see how acct_rename subcases 2 and
3 ever both passed together. I'll keep looking..

[01/25/95 public]
When I was extending the security tests to test replication, I
uncovered a bunch of false passes and code which was not
exercised. I thought I fixed all of them but this was one that
I definitely missed.
Simply change the expected code in acct_rename.tsh for test 3 to
$ACCT_RENAME_ALREADY_EXISTS $sec_rgy_name_exists

[1/25/95 public]
sec_rgy_name_exists ? It looked (from the code) that it would be
sec_rgy_object_exists to me -- can you confirm which one?

[1/25/95 public]
Oh, now it's all coming back to me.
The man page for sec_rgy_acct_rename states that sec_rgy_name_exists
should be returned, so we changed the code in rsdb_acct_rename() to
return this error:
    /* To check if new account name exists, compare against full name (key_parts) */
    full_key_parts = sec_rgy_acct_key_org;
    if (account_exists(&person, &new_group, &new_org, full_key_parts, &last_account)) {
        SET_STATUS(status, sec_rgy_name_exists);
        return;
    }

[1/25/95 public]
  Not trying to be a pain -- bear with me. I've attached the code
fragment you refer to as seen in our current port of 1.1 . It still
reads the same as 1.0.3 did ... when you say the code has been changed,
do you mean in this "Warranty Release" I have been told to expect? And
if so, we have a concern here about this being a backwards-compatibility
bug now, as any coders outside that coded to the observed value instead
of the documented value are going to suffer. I'd dismiss them as having
coded against the spec, had not it been necessary to do so for 1.0.3
(and prior?) releases.
  Attachment:
-------------------------------------------------------
    /* To check if new account name exists, compare against full name (key_parts) */
    full_key_parts = sec_rgy_acct_key_org;
    if (account_exists(&person, &new_group, &new_org, full_key_parts, &last_account)) {
        SET_STATUS(status, sec_rgy_object_exists);
        return;
    }
-------------------------------------------------------

[1/25/95 public]
You're right, we can't change the error without breaking compatibility.
So, change acct_rename.tsh to:
$ACCT_RENAME_ALREADY_EXISTS $sec_rgy_object_exists
The man page for sec_rgy_acct_rename should be changed to expect
sec_rgy_object_exists instead of sec_rgy_name_exists.

[1/25/95 public]
Changed CR in Code, Doc, or Test? from `code' to `test'

[1/25/95 public]
Changed CR in Code, Doc, or Test? from `test' to `doc'

[5/17/96 public]

Assigned to myself, since I'm responsible for the Test Guide.



CR Number                     : 12752
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : bad grep test for server startup
Reported Date                 : 11/18/94
Found in Baseline             : 1.1
Found Date                    : 11/18/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : src/test/systest/security/sec.rgy.7/dcesergy
Sensitivity                   : public

[11/18/94 public]

Full Description:

in dcesecrgy, there is a loop to test for the existence of the server
process before continuing with the test. The logic of this test is flawed,
although in the general case, the server has already started, and there is
no neeed to delay and the test results are inconsequential. In the case
where server has not yet started, it is likely that the test will
erroneously conclude that the server is running, and proceed prematurely.
The basic problem is that the grep is likely to pick up the grep itself,
even though the server is not actually running

Proposed solution:

follow the grep bt a grep -v grep.

# These lines get secrgy_server's pid
  
!         until ( ps -ef |grep secrgy_server | grep -v grep> /dev/null )
          do

[11/18/94 public]
Alternative is to use ps -e, which will not pick up the grep command
itself.  This saves an extra grep.



CR Number                     : 12746
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec/sams
Short Description             : need vendor-specific category
Reported Date                 : 11/10/94
Found in Baseline             : 1.1
Found Date                    : 11/10/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : sec.sams
Sensitivity                   : public

[11/10/94 public]
  Vendors are going to need unused, reserved error codes for certain
porting operations, in our case those errors generated by our
vendor-specific license management code. I'm lucky right now, as the
only uses I have for these codes do not go across wires and are not
returned by any API; hence, they can take on any (free) value from
release to release.
  How best to handle this with adequate foresight is an open problem.
Vendors using vendor-specific codes must either share their codes'
SAMS descriptions, or agree not to pass such codes over the wires or
through any other API accesses...
  For the immediate future, a sub-component "sec_s_vendor" with
several tens (64?) of reserved values would be a start. Or, should we
make it "sec_s_<vendor>" (that is, instantiate the vendor name eg
sec_s_transarc, sec_s_yoyodyne, sec_s_acme, etc.)?
  It may simplify things to keep in mind that even if vendors cannot
share their specific codes -- but are gauranteed reserved values for
theirs -- the worst a customer using a heterogenous cell could ever
see would be an untranslated code which could be looked-up on the
machine (server node) that sent it. Field support wouldn't be hindered
by this.

[11/10/94 public]
  That was my first CR for 1.1, and so now I've updated my baseline
defaults, sorry for the '1.0.3' mentioned in the initial edit of this
CR.
Changed Found in Baseline from `1.0.3' to `1.1' 
Changed Fix By Baseline from `1.1' to `1.2'



CR Number                     : 12732
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : admin_gd
Short Description             : Appendix A needs to describe /.:/subsys/dce/pwd_mgmt/pwd_strength
Reported Date                 : 10/26/94
Found in Baseline             : 1.1doc
Found Date                    : 10/26/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : admin_gd/overview/overview/appa.gpsml
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/26/94 public]

Appendix A in the Administration Guide - Introduction needs
to include the entry /.:/subsys/dce/pwd_mgmt/pwd_strength,
which is the location in CDS at which the password validation/
generation server pwd_strengthd stores its binding information.
The figure that illustrates the CDS namespace needs to be
modified to show this entry, and new tables that describe
the pwd_mgmt and pwd_strength entries need to be created
in the section that describes CDS namespace entries.

[6/30/95 public]

Assigned to HP for DCE 1.2.



CR Number                     : 12683
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : sec gen_pwd errors
Reported Date                 : 10/20/94
Found in Baseline             : 1.1b22
Found Date                    : 10/20/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/20/94 public]

I found two major problems with this test:
1) It not built in the backing tree. Building it was not a problem, but
   no Makefile exists.
2) The file setup.ksh which is run by the test calls "attr_update".
   This program/script is not located in the build tree.

According to the TestSummary file this test has been run succesfully.
How is this possible?



CR Number                     : 12681
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : sec gssapi test hangs
Reported Date                 : 10/20/94
Found in Baseline             : 1.1b22
Found Date                    : 10/20/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/20/94 public]

When running the gssapi test the following output appears in tet_xres
and the test case hangs indefinitely:

15|0 1.10 1|TCM Start
400|0 1 1 17:24:10|IC Start
200|0 1 17:24:10|TP Start
520|0 1 20804 1 1|Retrieving test-driver argument-list
520|0 1 20804 1 2|Parsing argument-list
520|0 1 20804 1 3|Invoking main test program
520|0 1 20804 1 4|GSSAPI tester started

[10/20/94 public]
This is how I execute the gssapi and the results are as follows:

1. Execute gss-test-setup.sh from ./gssapi/ts

# ./gss-test-setup.sh^M
Adding accounts for GSSAPI test: gss-test-1 & gss-test-2^M
Please supply the cell_admin password:^M
^M
^M
Adding principals...^M
Current site is: registry server at
/.../final_hp_cell/subsys/dce/sec/master ^M
Domain changed to: principal^M
bye.^M
Adding accounts...^M
Current site is: registry server at
/.../final_hp_cell/subsys/dce/sec/master ^M
Domain changed to: account^M
bye.^M
Adding keytable...^M
Current site is: registry server at
/.../final_hp_cell/subsys/dce/sec/master ^M
bye.^M
Setup phase completed^M

2. Invoke the tests by issuing the following command.
   /test/security/api/gssapi/test-gssapi -i -l -p gss-pw-1 gss-prin-1 gss-prin-2 gss-keytab

Here is the results script:
--------------------------

GSSAPI tester^M
^M
^M
Logging in as "gss-prin-1"...^M
Succesfully logged in as client.^M
Tests available:^M
^M
 1:  Error codes^M
 2:  Name Conversions^M
 3:  Server keytable registration^M
 4:  Credential establishment^M
 5:  Kerberos authentication^M
 6:  DCE authentication^M
 7:  Sign service^M
 8:  Seal service (non-encrypting)^M
 9:  Seal service (encrypting)^M
10:  PAC extraction routines (obsolete)^M
11:  Context deletion^M
12:  DCE Credential extraction^M
13:  DCE login-context extraction^M
14:  Delegation test 1: Refusing impersonation^M
15:  Delegation test 2: Refusing traced delegation^M
16:  Delegation test 3: Accepting impersonation^M
17:  Delegation test 4: Accepting traced delegation^M
18:  Delegation test 5: Constructing impersonation^M
19:  Misc routines^M
20:  Credential management^M
^M
Selected tests: <none>^M
Select test, 'A' to select all, 0 or 'S' to start:A^M
Selected tests: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ^M
Select test, 'A' to select all, 0 or 'S' to start:s^M
^M
Performing following tests:^M
 1:  Error codes^M
 2:  Name Conversions^M
 3:  Server keytable registration^M
 4:  Credential establishment^M
 5:  Kerberos authentication^M
 6:  DCE authentication^M
 7:  Sign service^M
 8:  Seal service (non-encrypting)^M
 9:  Seal service (encrypting)^M
10:  PAC extraction routines (obsolete)^M
11:  Context deletion^M
12:  DCE Credential extraction^M
13:  DCE login-context extraction^M
14:  Delegation test 1: Refusing impersonation^M
15:  Delegation test 2: Refusing traced delegation^M
16:  Delegation test 3: Accepting impersonation^M
17:  Delegation test 4: Accepting traced delegation^M
18:  Delegation test 5: Constructing impersonation^M
19:  Misc routines^M
20:  Credential management^M
^M
===========================================================================^M
^M
1.  Error message routines^M
Checking default message availability via dce_msg_get_default_msg()^M
rpc_s_ok: ^M
Error 173CA011 retrieving RPC_S_OK error text^M
GSSDCE_S_MESSAGE_LATE: The token was valid, but a later token has already
been re
ceived.^M
Checking catalog message availability via dce_msg_get_cat_msg^M
rpc_s_ok: ^M
Error 173CA015 retrieving RPC_S_OK error text^M
GSSDCE_S_MESSAGE_LATE: ^M
Error 173CA015 retrieving GSSDCE_S_MESSAGE_LATE error text^M
Press return to continue...^M
Checking combined message availability via dce_msg_get_msg^M
rpc_s_ok: Unknown message number 0x00000000^M
Error 173CA011 retrieving RPC_S_OK error text^M
GSSDCE_S_MESSAGE_LATE: The token was valid, but a later token has already
been re
ceived.^M
Supplementary info bits...^M
Bit 00:^M
    Calling gss_display_status for bit code^M
    Returned from gss_display_status^M
   A response token is required from the peer application.^M
    Calling gss_release_buffer^M
    Returned from gss_release_buffer^M
Bit 01:^M
    Calling gss_display_status for bit code^M
    Returned from gss_display_status^M
   The token is a duplicate of one already received.^M
    Calling gss_release_buffer^M
    Returned from gss_release_buffer^M
Bit 02:^M
    Calling gss_display_status for bit code^M
    Returned from gss_display_status^M
   The token is old. A more recent token has already been received.^M
    Calling gss_release_buffer^M
    Returned from gss_release_buffer^M
Bit 03:^M
    Calling gss_display_status for bit code^M
    Returned from gss_display_status^M
   The token was received out of sequence.^M

    Calling gss_release_buffer^M
    Returned from gss_release_buffer^M
Bit 04:^M
Bit 11:^M
    Calling gss_display_status for bit code^M
    Returned from gss_display_status^M
   <No message>^M
Bit 12:^M
    Calling gss_display_status for bit code^M
    Returned from gss_display_status^M
   <No message>^M
Bit 13:^M
    Calling gss_display_status for bit code^M
    Returned from gss_display_status^M
   <No message>^M
Bit 14:^M
    Calling gss_display_status for bit code^M
    Returned from gss_display_status^M
   <No message>^M
Bit 15:^M
    Calling gss_display_status for bit code^M
    Returned from gss_display_status^M
   <No message>^M
Press return to continue...^M
^M
Named error codes:^M
GSS_S_BAD_MECH:^M
    Calling gss_display_status for code^M
   The specified authentication mechanism is unsupported.^M
GSS_S_BAD_NAME:^M
    Calling gss_display_status for code^M
   The name passed by the parameter was invalid.^M
GSS_S_BAD_NAMETYPE:^M
    Calling gss_display_status for code^M
   The name passed by the name parameter is unsupported.^M
GSS_S_BAD_BINDINGS:^M
    Calling gss_display_status for code^M
   The given channel bindings did not match those in the token.^M
GSS_S_BAD_STATUS:^M
    Calling gss_display_status for code^M
   The status value was invalid.^M
GSS_S_BAD_SIG:^M
    Calling gss_display_status for code^M
   The token's signature was incorrect.^M
GSS_S_NO_CRED:^M
    Calling gss_display_status for code^M
   No credentials were supplied.^M
GSS_S_NO_CONTEXT:^M
    Calling gss_display_status for code^M
   No security context has been established.^M
GSS_S_DEFECTIVE_TOKEN:^M
    Calling gss_display_status for code^M
   The token was invalid.^M
GSS_S_DEFECTIVE_CREDENTIAL:^M
    Calling gss_display_status for code^M
   The supplied credentials are invalid.^M
GSS_S_CREDENTIALS_EXPIRED:^M
    Calling gss_display_status for code^M
   The supplied credentials have expired.^M
GSS_S_CONTEXT_EXPIRED:^M
    Calling gss_display_status for code^M
   The security context has expired.^M
GSS_S_FAILURE:^M
    Calling gss_display_status for code^M
   The routine failed.^M
BAD_SIG+OLD_TOKEN:^M
    Calling gss_display_status for code^M
   The token's signature was incorrect.^M
    Calling gss_display_status for code^M
   The token is old. A more recent token has already been received.^M
^M
===========================================================================^M
^M
2.  Miscellaneous routine tests^M
2.2:  OID manipulation, set creation^M
    Calling GSSDCE_CREATE_EMPTY_OID_SET^M
    Returned from GSSDCE_CREATE_EMPTY_OID_SET^M
^M
    Calling GSSDCE_ADD_OID_SET_MEMBER^M
    Returned from GSSDCE_ADD_OID_SET_MEMBER^M
^M
    Calling GSSDCE_ADD_OID_SET_MEMBER^M
    Returned from GSSDCE_ADD_OID_SET_MEMBER^M
^M
Element 0: length=5, Addr=400cfec0^M
Element 1: length=4, Addr=400cfeb0^M
2.3:  OID manipulation, set interrogation 1^M
    Calling GSSDCE_TEST_OID_SET_MEMBER^M
    Returned from GSSDCE_TEST_OID_SET_MEMBER^M
^M
Element 0: length=5, Addr=400cfec0^M
Element 1: length=4, Addr=400cfeb0^M
2.4:  OID manipulation, set interrogation 2^M
    Calling GSSDCE_TEST_OID_SET_MEMBER^M
    Returned from GSSDCE_TEST_OID_SET_MEMBER^M
^M
Element 0: length=5, Addr=400cfec0^M
Element 1: length=4, Addr=400cfeb0^M
2.5:  OID manipulation, set interrogation 3^M
    Calling GSSDCE_TEST_OID_SET_MEMBER^M
    Returned from GSSDCE_TEST_OID_SET_MEMBER^M
^M
Element 0: length=5, Addr=400cfec0^M
Element 1: length=4, Addr=400cfeb0^M
2.6:  OID manipulation, set free^M
    Calling GSS_RELEASE_OID_SET^M
    Returned from GSS_RELEASE_OID_SET^M
2.7:  GSS_INDICATE_MECHS^M
    Calling GSS_INDICATE_MECHS^M
    Returned from GSS_INDICATE_MECHS^M
2.8:  GSS_INDICATE_MECHS, verifying results^M
    Calling GSSDCE_TEST_OID_SET_MEMBER^M
    Returned from GSSDCE_TEST_OID_SET_MEMBER^M
^M
    Calling GSSDCE_TEST_OID_SET_MEMBER^M
    Returned from GSSDCE_TEST_OID_SET_MEMBER^M
^M
    Calling GSSDCE_TEST_OID_SET_MEMBER^M
    Returned from GSSDCE_TEST_OID_SET_MEMBER^M
^M
2.9:  Releasing mech-set^M
    Calling GSS_RELEASE_OID_SET^M
    Returned from GSS_RELEASE_OID_SET^M
3.2:  GSS_Import_name for server name^M
   Converting server-name "gss-prin-2" to internal form^M
    Calling GSS_IMPORT_NAME^M
    Returned from GSS_IMPORT_NAME^M
^M
    Calling GSS_RELEASE_NAME^M
    Returned from GSS_RELEASE_NAME^M
^M
    Returned from GSS_RELEASE_NAME^M
^M
^M
===========================================================================^M
    Calling GSS_IMPORT_NAME^M
    Calling GSS_IMPORT_NAME^M
Registering server in table gss-keytab^M
    Calling GSSDCE_REGISTER_ACCEPTOR_IDENTITY^M
    Returned from GSSDCE_REGISTER_ACCEPTOR_IDENTITY^M
^M
^M
^M
4.  Kerberos tests^M
4.2:  GSS_Acquire_cred (as KRB server)^M
    Calling CREATE_EMPTY_OID_SET ^M
    Returned from CREATE_EMPTY_OID_SET^M
^M
    Calling ADD_OID_SET_MEMBER^M
    Returned from ADD_OID_SET_MEMBER^M
^M
    returned from GSS_ACQUIRE_CRED^M
Got cred handle 1^M
^M
    Calling GSS_RELEASE_OID_SET^M
    Returned from GSS_RELEASE_OID_SET^M
    Calling GSS_INQUIRE_CRED^M
    returned from GSS_INQUIRE_CRED^M
^M
    Calling GSS_DISPLAY_NAME^M
    Returned from GSS_DISPLAY_NAME^M
^M
   Server Name: "/.../final_hp_cell/gss-prin-2"^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
^M
^M
^M
    Calling GSS_RELEASE_NAME^M
    Returned from GSS_RELEASE_NAME^M
^M
   Expiration (secs): 86399^M
   Mechanism count: 1^M
   Credential-type: ACCEPT^M
4.3:  GSS_Acquire_cred (as KRB client)^M
    Calling GSS_ACQUIRE_CRED^M
    returned from GSS_ACQUIRE_CRED^M
Got cred handle 2^M
^M
    Calling GSS_RELEASE_OID_SET^M
    Returned from GSS_RELEASE_OID_SET^M
^M
    Calling GSS_INQUIRE_CRED^M
    returned from GSS_INQUIRE_CRED^M
^M
    Calling GSS_DISPLAY_NAME^M
    Returned from GSS_DISPLAY_NAME^M
^M
    Calling GSS_RELEASE_NAME^M
    Returned from GSS_RELEASE_NAME^M
^M
   Client Name: "/.../final_hp_cell/gss-prin-1"^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
^M
   Expiration (secs): 86399^M
   Mechanism count: 1^M
   Credential-type:BOTH^M
4.4:  Init_Sec_Context (KRB client)^M
    Calling GSS_INIT_SEC_CONTEXT^M
    returned from INIT_SEC_CONTEXT^M
^M
Got ctx handle 1^M
4.5:  Accept_Sec_Context (KRB server)^M
    Calling GSS_ACCEPT_SEC_CONTEXT^M
    returned from ACCEPT_SEC_CONTEXT^M
^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
^M
Got ctx handle 2^M
^M
^M
       WARNING! Non-exportable GSSAPI!^M
^M
    Calling GSS_DISPLAY_NAME^M
    Returned from GSS_DISPLAY_NAME^M
^M
    Calling GSS_RELEASE_NAME^M
    Returned from GSS_RELEASE_NAME^M
^M
   Client Name: "/.../final_hp_cell/gss-prin-1"^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
^M
Flags:^M
  Mutual^M
  Replay detection^M
  Out-of-sequence detection^M
  Confidentiality (NON-EXPORTABLE!)^M
  Integrity^M
4.6:  Init_Sec_Context (client, 2nd time)^M
    Calling GSS_INIT_SEC_CONTEXT^M
    returned from INIT_SEC_CONTEXT^M
Got ctx handle 1^M
^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
^M
Flags:^M
  Mutual^M
  Replay detection^M
  Out-of-sequence detection^M
  Confidentiality^M
  Integrity^M
^M
^M
       WARNING! Non-exportable GSSAPI!^M
^M
    Calling GSS_RELEASE_OID_SET^M
^M
    Calling GSS_RELEASE_CRED (KRB server)^M
^M
    Calling GSS_RELEASE_CRED (KRB client)^M
^M
^M
===========================================================================^M
^M
5.  Credential establishment tests^M
5.2:  Establishing Kerberos mechanism credentials^M
    Calling CREATE_EMPTY_OID_SET ^M
    Returned from CREATE_EMPTY_OID_SET^M
^M
    Calling ADD_OID_SET_MEMBER^M
    Returned from ADD_OID_SET_MEMBER^M
^M
    Calling GSS_ACQUIRE_CRED (KRB server)^M
    returned from GSS_ACQUIRE_CRED (KRB server)^M
    Calling GSS_ACQUIRE_CRED (KRB client)^M
    returned from GSS_ACQUIRE_CRED (KRB client)^M
5.3:  GSS_Acquire_cred (as DCE server)^M
    Calling GSS_IMPORT_NAME^M
    Returned from GSS_IMPORT_NAME^M
^M
    Calling GSS_ACQUIRE_CRED^M
    returned from GSS_ACQUIRE_CRED^M
Got cred handle 5^M
^M
    Calling GSS_RELEASE_OID_SET^M
    Returned from GSS_RELEASE_OID_SET^M
    Calling GSS_INQUIRE_CRED^M
    returned from GSS_INQUIRE_CRED^M
^M
    Calling GSS_DISPLAY_NAME^M
    Returned from GSS_DISPLAY_NAME^M
^M
   Server Name: "/.../final_hp_cell/gss-prin-2"^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
^M
    Calling GSS_RELEASE_NAME^M
    Returned from GSS_RELEASE_NAME^M
^M
   Expiration (secs): 86399^M
   Mechanism count: 2^M
   Credential-type: ACCEPT^M
^M
6.  DCE authentication tests^M
6.2:  GSS_Acquire_cred (as client)^M
    Calling GSS_ACQUIRE_CRED^M
    returned from GSS_ACQUIRE_CRED^M
Got cred handle 6^M
^M
    Calling GSS_RELEASE_OID_SET^M
    Returned from GSS_RELEASE_OID_SET^M
^M
    Calling GSS_INQUIRE_CRED^M
    returned from GSS_INQUIRE_CRED^M
^M
    Calling GSS_DISPLAY_NAME^M
    Returned from GSS_DISPLAY_NAME^M
^M
    Calling GSS_RELEASE_NAME^M
    Returned from GSS_RELEASE_NAME^M
^M
   Client Name: "/.../final_hp_cell/gss-prin-1"^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
^M
   Expiration (secs): 86399^M
   Mechanism count: 1^M
   Credential-type:BOTH^M
6.3:  Init_Sec_Context (DCE client)^M
    Calling GSS_INIT_SEC_CONTEXT^M
    returned from INIT_SEC_CONTEXT^M
Got ctx handle 3^M
^M
6.4:  Accept_Sec_Context (DCE server)^M
    Calling GSS_ACCEPT_SEC_CONTEXT^M
    returned from ACCEPT_SEC_CONTEXT^M
^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
^M
Got ctx handle 4^M
^M
^M
       WARNING! Non-exportable GSSAPI!^M
^M
    Calling GSS_DISPLAY_NAME^M
    Returned from GSS_DISPLAY_NAME^M
^M
    Calling GSS_RELEASE_NAME^M
    Returned from GSS_RELEASE_NAME^M
^M
   Client Name: "/.../final_hp_cell/gss-prin-1"^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
^M
Flags:^M
  Mutual^M
  Replay detection^M
  Out-of-sequence detection^M
  Confidentiality^M
  Integrity^M
6.5:  Init_Sec_Context (client, 2nd time)^M

    Calling GSS_INIT_SEC_CONTEXT^M
    returned from INIT_SEC_CONTEXT^M
^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
^M
Got ctx handle 3^M
Flags:^M
  Mutual^M
  Replay detection^M
  Out-of-sequence detection^M
  Confidentiality^M
  Integrity^M
^M
^M
       WARNING! Non-exportable GSSAPI!^M
^M
^M
===========================================================================^M
^M
7.  GSS_SIGN (integrity protection)^M
    Calling GSS_SIGN for client packet 1^M
    returned from GSS_SIGN^M
^M
    Calling GSS_SIGN for client packet 2^M
    returned from GSS_SIGN^M
    Calling GSS_SIGN for client packet 3^M
    returned from GSS_SIGN^M
^M
    Calling server GSS_VERIFY with client message 1^M
    returned from GSS_VERIFY^M
^M
    Calling server GSS_VERIFY with client message 1 again^M
    returned from GSS_VERIFY^M
^M
    Calling client GSS_VERIFY with client message 1 ^M
1994-10-19-11:41:26.532-04:00I----- PID#21983 ERROR gss protection gssapi.c
7588
0x7affb2e8^M
Sequence number invalid in decode_message_header^M
1994-10-19-11:41:26.757-04:00I----- PID#21983 ERROR gss protection gssapi.c
7601
0x7affb2e8^M
Detected reflected token in decode_message_header^M
1994-10-19-11:41:26.842-04:00I----- PID#21983 ERROR gss protection gssapi.c
8096
0x7affb2e8^M
Decode_message_header failed in gss_verify (1286203c)^M
    returned from GSS_VERIFY^M
^M
    Calling server GSS_VERIFY with client token 1, bad data^M
1994-10-19-11:41:27.007-04:00I----- PID#21983 ERROR gss protection gssapi.c
8231
0x7affb2e8^M
The token signature was incorrect^M
    returned from GSS_VERIFY^M
^M
    Calling server GSS_VERIFY with client token 3^M
    returned from GSS_VERIFY^M
^M
    Calling server GSS_VERIFY with client token 2^M
    returned from GSS_VERIFY^M
^M
    Calling server GSS_VERIFY with client token 3 again^M
    returned from GSS_VERIFY^M
^M
    Calling server GSS_VERIFY with client token 2 again^M
    returned from GSS_VERIFY^M
^M
    Calling GSS_RELEASE_BUFFER for message 1^M
    Returned from GSS_RELEASE_BUFFER^M
^M
    Calling GSS_RELEASE_BUFFER for message 2^M
    Returned from GSS_RELEASE_BUFFER^M
^M
    Calling GSS_RELEASE_BUFFER for message 3^M
    Returned from GSS_RELEASE_BUFFER^M
^M
^M
===========================================================================^M
^M
8.  GSS_SEAL (integrity protection)^M
    Calling GSS_SEAL for client packet 4^M
    returned from GSS_SEAL^M
^M
    Calling GSS_SEAL for client packet 5^M
    returned from GSS_SEAL^M
^M
    Calling GSS_SEAL for client packet 6^M
    returned from GSS_SEAL^M
^M
    Calling server GSS_UNSEAL with client packet 4^M
    returned from GSS_UNSEAL^M
^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
    Calling server GSS_UNSEAL with client message 1 again^M
    returned from GSS_UNSEAL^M
^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
    Calling server GSS_UNSEAL with client packet 6^M
    returned from GSS_UNSEAL^M
^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
    Calling server GSS_UNSEAL with client packet 5^M
    returned from GSS_UNSEAL^M
^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
    Calling server GSS_UNSEAL with client packet 6^M
    returned from GSS_UNSEAL^M
^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
    Calling server GSS_UNSEAL with client token 2 again^M
    returned from GSS_UNSEAL^M
^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
    Calling GSS_RELEASE_BUFFER for message 1^M
    Returned from GSS_RELEASE_BUFFER^M
^M
    Calling GSS_RELEASE_BUFFER for message 2^M
    Returned from GSS_RELEASE_BUFFER^M
^M
    Calling GSS_RELEASE_BUFFER for message 3^M
    Returned from GSS_RELEASE_BUFFER^M
^M
^M
===========================================================================^M
^M
9.  GSS_SEAL (confidentiality protection)^M
    Calling GSS_SEAL for client packet 4^M
    returned from GSS_SEAL^M
^M
    Calling GSS_SEAL for client packet 5^M
    returned from GSS_SEAL^M
^M
    Calling GSS_SEAL for client packet 6^M
    returned from GSS_SEAL^M
^M
    Calling server GSS_UNSEAL with client message 1^M
    returned from GSS_UNSEAL^M
^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
    Calling server GSS_UNSEAL with client message 1 again^M
    returned from GSS_UNSEAL^M
^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
    Calling server GSS_UNSEAL with client token 3^M
    returned from GSS_UNSEAL^M
^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
    Calling server GSS_UNSEAL with client token 2^M
    returned from GSS_UNSEAL^M
^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
    Calling server GSS_UNSEAL with client token 3 again^M
    returned from GSS_UNSEAL^M
^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
    Calling server GSS_UNSEAL with client token 2 again^M
    returned from GSS_UNSEAL^M
^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
    Calling GSS_RELEASE_BUFFER for message 1^M
    Returned from GSS_RELEASE_BUFFER^M
^M
    Calling GSS_RELEASE_BUFFER for message 2^M
    Returned from GSS_RELEASE_BUFFER^M
^M
    Calling GSS_RELEASE_BUFFER for message 3^M
    Returned from GSS_RELEASE_BUFFER^M
^M
^M
10.  PAC extraction^M
^M
^M
^M
11.  DCE credentials extraction^M
    Calling gssdce_extract_creds_from_sec_context^M
    Returned from gssdce_extract_creds_from_sec_context^M
^M
    Verifying returned creds by calling sec_cred_get_initiator^M
    Returned from sec_cred_get_initiator^M
    Calling sec_cred_iniatialize_attr_cursor^M
    Returned from sec_cred_iniatialize_attr_cursor^M
    Calling sec_cred_get_extended_attrs^M
    Returned from sec_cred_get_extended_attrs^M
sec_cred_get_extended_attrs failed on GSSAPI-derived authz_cred_handle^M
Return status: 1712212E^M
Message: no more entries available^M
This error is expected, and does not cause a test failure^M
^M
12.  Extraction of login-context from credential^M
    Calling gssdce_cred_to_login_context^M
    Returned from gssdce_cred_to_login_context^M
^M
^M
13.  Delegation functional test 1: Refusal of offered impersonation^M
    Calling gssdce_login_context_to_cred^M
    Returned from login_context_to_cred^M
^M
    Calling GSS_INIT_SEC_CONTEXT^M
    returned from INIT_SEC_CONTEXT^M
Got ctx handle 5^M
^M
    Calling GSS_ACCEPT_SEC_CONTEXT^M
    returned from ACCEPT_SEC_CONTEXT^M
^M
    Calling GSS_RELEASE_BUFFER for token.1^M
    Returned from GSS_RELEASE_BUFFER^M
^M
Got ctx handle 6^M
^M
^M
       WARNING! Non-exportable GSSAPI!^M
^M
    Calling GSS_DISPLAY_NAME^M

    Returned from GSS_DISPLAY_NAME^M
^M
    Calling GSS_RELEASE_NAME^M
    Returned from GSS_RELEASE_NAME^M
^M
   Client Name: "/.../final_hp_cell/gss-prin-1"^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
^M
Flags:^M
  Mutual^M
  Replay detection^M
  Out-of-sequence detection^M
  Confidentiality^M
  Integrity^M
    Calling GSS_INIT_SEC_CONTEXT again^M
    returned from INIT_SEC_CONTEXT^M
^M
    Calling GSS_RELEASE_BUFFER for token.2^M
    Returned from GSS_RELEASE_BUFFER^M
^M
Got ctx handle 5^M
Flags:^M
  Mutual^M
  Replay detection^M
  Out-of-sequence detection^M
  Confidentiality^M
  Integrity^M
^M
^M
       WARNING! Non-exportable GSSAPI!^M
^M
^M
^M
    Returned from GSS_RELEASE_BUFFER^M
^M
^M
14.  Delegation functional test 2: Refusal of offered traced delegation^M
    Calling gssdce_login_context_to_cred^M
    Returned from login_context_to_cred^M
^M
    Calling GSS_INIT_SEC_CONTEXT^M
    returned from INIT_SEC_CONTEXT^M
Got ctx handle 7^M
^M
    Calling GSS_ACCEPT_SEC_CONTEXT^M
    returned from ACCEPT_SEC_CONTEXT^M
^M
    Calling GSS_RELEASE_BUFFER for token.1^M
    Returned from GSS_RELEASE_BUFFER^M
^M
Got ctx handle 8^M
^M
^M
       WARNING! Non-exportable GSSAPI!^M
^M
    Calling GSS_DISPLAY_NAME^M
    Returned from GSS_DISPLAY_NAME^M
^M
    Calling GSS_RELEASE_NAME^M
    Returned from GSS_RELEASE_NAME^M
^M
   Client Name: "/.../final_hp_cell/gss-prin-1"^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
^M
Flags:^M
  Mutual^M
  Replay detection^M
  Out-of-sequence detection^M
  Confidentiality^M
  Integrity^M
    Calling GSS_INIT_SEC_CONTEXT again^M
    returned from INIT_SEC_CONTEXT^M
^M
    Calling GSS_RELEASE_BUFFER for token.2^M
    Returned from GSS_RELEASE_BUFFER^M
^M
Got ctx handle 7^M
Flags:^M
  Mutual^M
  Replay detection^M
  Out-of-sequence detection^M
  Confidentiality^M
  Integrity^M
^M
^M
      WARNING! Non-exportable GSSAPI!^M
^M
^M
^M
    Returned from GSS_RELEASE_BUFFER^M
^M
^M
15.  Delegation functional test 3: Acceptance of offered impersonation^M
    Calling gssdce_login_context_to_cred^M
    Returned from login_context_to_cred^M
^M
    Calling GSS_INIT_SEC_CONTEXT^M
    returned from INIT_SEC_CONTEXT^M
Got ctx handle 9^M
^M
    Calling GSS_ACCEPT_SEC_CONTEXT^M
    returned from ACCEPT_SEC_CONTEXT^M
^M
    Calling GSS_RELEASE_BUFFER for token.1^M
    Returned from GSS_RELEASE_BUFFER^M
^M
Got ctx handle 10^M
^M
^M
       WARNING! Non-exportable GSSAPI!^M
^M
Delegation occurred as requested^M
A delegated credential (10) was returned as expected^M
    Calling GSS_DISPLAY_NAME^M
    Returned from GSS_DISPLAY_NAME^M
^M
    Calling GSS_RELEASE_NAME^M
    Returned from GSS_RELEASE_NAME^M
^M
   Client Name: "/.../final_hp_cell/gss-prin-1"^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
^M
Flags:^M
  Delegation^M
  Mutual^M
  Replay detection^M
  Out-of-sequence detection^M
  Confidentiality^M
  Integrity^M
    Calling GSS_INIT_SEC_CONTEXT again^M
    returned from INIT_SEC_CONTEXT^M
^M
    Calling GSS_RELEASE_BUFFER for token.2^M
    Returned from GSS_RELEASE_BUFFER^M
^M
Got ctx handle 9^M
Flags:^M
  Delegation^M
  Mutual^M
  Replay detection^M

  Out-of-sequence detection^M
  Confidentiality^M
  Integrity^M
^M
^M
       WARNING! Non-exportable GSSAPI!^M
^M
^M
^M
    Returned from GSS_RELEASE_BUFFER^M
^M
    Calling GSS_RELEASE_CRED (delegated credential)^M
^M
^M
16.  Delegation functional test 4: Acceptance of offered traced
delegation^M
    Calling gssdce_login_context_to_cred^M
    Returned from login_context_to_cred^M
^M
    Calling GSS_INIT_SEC_CONTEXT^M
    returned from INIT_SEC_CONTEXT^M
Got ctx handle 11^M
^M
    Calling GSS_ACCEPT_SEC_CONTEXT^M
    returned from ACCEPT_SEC_CONTEXT^M
^M
    Calling GSS_RELEASE_BUFFER for token.1^M
    Returned from GSS_RELEASE_BUFFER^M
^M
Got ctx handle 12^M
^M
^M
       WARNING! Non-exportable GSSAPI!^M
^M
Delegation occurred as requested^M
A delegated credential (12) was returned as expected^M
    Calling GSS_DISPLAY_NAME^M
    Returned from GSS_DISPLAY_NAME^M
^M
    Calling GSS_RELEASE_NAME^M
    Returned from GSS_RELEASE_NAME^M
^M
   Client Name: "/.../final_hp_cell/gss-prin-1"^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
^M
Flags:^M
  Delegation^M
  Mutual^M
  Replay detection^M
  Out-of-sequence detection^M
  Confidentiality^M
  Integrity^M
    Calling GSS_INIT_SEC_CONTEXT again^M
    returned from INIT_SEC_CONTEXT^M
^M
    Calling GSS_RELEASE_BUFFER for token.2^M
    Returned from GSS_RELEASE_BUFFER^M
^M
Got ctx handle 11^M
Flags:^M
  Delegation^M
  Mutual^M
  Replay detection^M

  Out-of-sequence detection^M
  Confidentiality^M
  Integrity^M
^M
^M
       WARNING! Non-exportable GSSAPI!^M
^M
^M
^M
    Returned from GSS_RELEASE_BUFFER^M
^M
    Calling GSS_RELEASE_CRED (delegated credential)^M
^M
^M
17.  Delegation functional test 5: Initiation of impersonation^M
    Calling GSS_INIT_SEC_CONTEXT^M
    returned from INIT_SEC_CONTEXT^M
Got ctx handle 13^M
^M
    Calling GSS_ACCEPT_SEC_CONTEXT^M
    returned from ACCEPT_SEC_CONTEXT^M
^M
    Calling GSS_RELEASE_BUFFER for token.1^M
    Returned from GSS_RELEASE_BUFFER^M
^M
Got ctx handle 14^M
^M
^M
       WARNING! Non-exportable GSSAPI!^M
^M
Delegation occurred as requested^M
A delegated credential (13) was returned as expected^M
    Calling GSS_DISPLAY_NAME^M
    Returned from GSS_DISPLAY_NAME^M
^M
    Calling GSS_RELEASE_NAME^M
    Returned from GSS_RELEASE_NAME^M
^M
   Client Name: "/.../final_hp_cell/gss-prin-1"^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
^M
Flags:^M
  Delegation^M
  Mutual^M
  Replay detection^M
  Out-of-sequence detection^M
  Confidentiality^M
  Integrity^M
    Calling GSS_INIT_SEC_CONTEXT again^M
    returned from INIT_SEC_CONTEXT^M
^M
    Calling GSS_RELEASE_BUFFER for token.2^M
    Returned from GSS_RELEASE_BUFFER^M
^M
Got ctx handle 13^M
Flags:^M
  Delegation^M
  Mutual^M
  Replay detection^M
  Out-of-sequence detection^M
  Confidentiality^M
  Integrity^M
^M
^M
       WARNING! Non-exportable GSSAPI!^M
^M
^M
^M
    Returned from GSS_RELEASE_BUFFER^M
^M
    Calling GSS_RELEASE_CRED (delegated credential)^M
^M
^M
18.  Context deletion^M
^M
^M
    Returned from GSS_RELEASE_BUFFER^M
^M
^M
19.  Credential management^M
19.2:  Creating a BOTH-mode credential from the keytable^M
    Calling GSS_ACQUIRE_CRED^M
    returned from GSS_ACQUIRE_CRED^M
Got cred handle 14^M
^M
    Calling GSS_RELEASE_OID_SET^M
    Returned from GSS_RELEASE_OID_SET^M
    Calling GSS_INQUIRE_CRED^M
    returned from GSS_INQUIRE_CRED^M
^M
    Calling GSS_DISPLAY_NAME^M
    Returned from GSS_DISPLAY_NAME^M
^M
   Server Name: "/.../final_hp_cell/gss-prin-2"^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
^M
    Calling GSS_RELEASE_NAME^M
    Returned from GSS_RELEASE_NAME^M
^M
   Expiration (secs): 86399^M
   Mechanism count: 2^M
   Credential-type:BOTH^M
    Calling GSS_RELEASE_OID_SET^M
    Returned from GSS_RELEASE_OID_SET^M
19.3:  Extracting login-context from new credential^M
    Calling gssdce_cred_to_login_context^M
    Returned from gssdce_cred_to_login_context^M
^M
Got context 401d3c88^M
19.4:  Verifying newly-extracted login-context^M
>>>Checking login-context 401d3c88^M
    Calling sec_login_get_expiration^M
    Returned from sec_login_get_expiration^M
    Calling sec_login_get_groups^M
    Returned from sec_login_get_groups^M
>>>Exp: 782617329^M
>>>num_groups: 1^M
19.5:  Releasing credential...^M
    Calling gss_release_cred^M
    Returned from gss_release_cred^M
^M
19.6:  Verifying login-context again...^M
>>>Checking login-context 401d3c88^M
    Calling sec_login_get_expiration^M
    Returned from sec_login_get_expiration^M
    Calling sec_login_get_groups^M
    Returned from sec_login_get_groups^M
>>>Exp: 782617329^M
>>>num_groups: 1^M
19.7:  Deleting extracted context^M
Purging login context 401d3c88^M
    Calling sec_login_purge_context^M
    Returned from sec_login_purge_context^M
19.8:  Creating another BOTH-mode credential from the keytable^M
    Calling GSS_ACQUIRE_CRED^M
    returned from GSS_ACQUIRE_CRED^M
Got cred handle 15^M
^M
    Calling GSS_RELEASE_OID_SET^M
    Returned from GSS_RELEASE_OID_SET^M
    Calling GSS_INQUIRE_CRED^M
    returned from GSS_INQUIRE_CRED^M
^M
    Calling GSS_DISPLAY_NAME^M
    Returned from GSS_DISPLAY_NAME^M
^M
   Server Name: "/.../final_hp_cell/gss-prin-2"^M
    Calling GSS_RELEASE_BUFFER^M
    Returned from GSS_RELEASE_BUFFER^M
^M
    Calling GSS_RELEASE_NAME^M
    Returned from GSS_RELEASE_NAME^M
^M
   Expiration (secs): 86399^M
   Mechanism count: 2^M
   Credential-type:BOTH^M
    Calling GSS_RELEASE_OID_SET^M
    Returned from GSS_RELEASE_OID_SET^M
19.9:  Extracting login-context from new credential^M
    Calling gssdce_cred_to_login_context^M
    Returned from gssdce_cred_to_login_context^M
^M
19.10:  Verifying newly-extracted login-context^M
>>>Checking login-context 401d4558^M
    Calling sec_login_get_expiration^M
    Returned from sec_login_get_expiration^M
    Calling sec_login_get_groups^M
    Returned from sec_login_get_groups^M
>>>Exp: 782617332^M
>>>num_groups: 1^M
19.11:  Setting cred GSSAPI-managed^M
    Calling gssdce_set_cred_context_ownership^M
    Returned from gssdce_set_cred_context_ownership^M
^M
19.12:  Releasing credential...^M
    Calling gss_release_cred^M
    Returned from gss_release_cred^M
^M
^M
^M
All tests successfully completed^M

[10/20/94 public]

When running under TET, you should get output to stdout/stderr between the last
message you see ("GSSAPI tester started") and the next TET-logged message
(which will be a success or failure message).  Are you blocking output on either
of these streams?  All the output that Rajendra posted (except the menu, which
you don't get under TET) should be seen.

If you're not simply blocking, do you see any output to stdout or stderr?

Also, please try running the test-program stand-alone (following Rajendra's 
example) and post the output you get from that.

[10/24/94 public]
test-gssapi.c has an error on line 637, where the value from getopt is
0xff. This value is being compared to 0xffffffff (EOF = -1). I
changed this line to be:


    while ((c = getopt(argc, argv, "lit:p:")) != (char)EOF) {

[10/26/94 public]
Oops.  The real fix for this is to declare 'c' as an int rather than a char.
I think that the code as written will work on platforms that use a signed type
for char, and break on platforms on which char is unsigned.



CR Number                     : 12676
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : sec group override test fails
Reported Date                 : 10/19/94
Found in Baseline             : 1.1b22
Found Date                    : 10/19/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/19/94 public]

The following output was generated by the group override test:

testing override_get_by_unix_num
pass: feature override_get_by_unix_num seq 1
pass: feature override_get_by_unix_num seq 2
pass: feature override_get_by_unix_num seq 3
pass: feature override_get_by_unix_num seq 4

testing override_is_grp_pwd_overridden
pass: feature override_is_grp_pwd_overidden seq 5
pass: feature override_is_grp_pwd_overidden seq 6
pass: feature override_is_grp_pwd_overidden seq 7

testing override_check_group_passwd
fail: feature override_check_group_passwd seq 8 result: 0   expected: 1
pass: feature override_check_group_passwd seq 9

testing sec_rgy_pgo_get_by_eff_unix_num
pass: feature sec_rgy_pgo_get_by_eff_unix_num seq 10
pass: feature sec_rgy_pgo_get_by_eff_unix_num seq 11
pass: feature sec_rgy_pgo_get_by_eff_unix_num seq 12

testing override_get_group_info
pass: feature override_get_group_info seq 13
pass: feature override_get_group_info seq 14
pass: feature override_get_group_info seq 15
pass: feature override_get_group_info seq 16

testing modify of /opt/dcelocal/etc/group_override after sec_clientd boot
testing override_get_group_info
pass: feature override_get_group_info seq 17

testing modify of /opt/dcelocal/etc/group_override after sec_clientd boot
testing override_get_group_info
pass: feature override_get_group_info seq 18

testing errors when /opt/dcelocal/etc/group_override is removed
testing override_get_group_info
pass: feature override_get_group_info seq 19

now reinstate /opt/dcelocal/etc/group_override and do a sanity check
testing override_get_group_info
pass: feature override_get_group_info seq 20

testing override_get_group_info member cursor stuff
pass: feature override_get_group_info seq 21
pass: feature override_get_group_info seq 22
fail: feature override_get_group_info seq 23 result: 0   expected: 387063929
pass: feature override_get_group_info seq 24
pass: feature override_get_group_info seq 25

passwd_export:  Could not open temporary passwd file /etc/ptmp for writing ( Do 
not specify an existing file. ).
couldn't run 'passwd_export -d /tmp' command - exit status 256

[10/20/94 public]
I have a fix in my sandbox for test 23 failure (it is basically a return
status code check change). I don't see any other failures like you are
seeing. Please check your test setup.

Here is the results script:

# tcc -e /usr/users/desai/sectest/dce1.1/grp_override^M
journal file name is:
/usr/users/desai/sectest/dce1.1/grp_override/results/0006e/
journal^M
testing override_get_by_unix_num^M
pass: feature override_get_by_unix_num seq 1^M
pass: feature override_get_by_unix_num seq 2^M
pass: feature override_get_by_unix_num seq 3^M
pass: feature override_get_by_unix_num seq 4^M
^M
testing override_is_grp_pwd_overridden^M
pass: feature override_is_grp_pwd_overidden seq 5^M
pass: feature override_is_grp_pwd_overidden seq 6^M
pass: feature override_is_grp_pwd_overidden seq 7^M
^M

testing override_check_group_passwd^M
pass: feature override_check_group_passwd seq 8^M
pass: feature override_check_group_passwd seq 9^M
^M
testing sec_rgy_pgo_get_by_eff_unix_num^M
pass: feature sec_rgy_pgo_get_by_eff_unix_num seq 10^M
pass: feature sec_rgy_pgo_get_by_eff_unix_num seq 11^M
pass: feature sec_rgy_pgo_get_by_eff_unix_num seq 12^M
^M
testing override_get_group_info^M
pass: feature override_get_group_info seq 13^M
pass: feature override_get_group_info seq 14^M
pass: feature override_get_group_info seq 15^M
pass: feature override_get_group_info seq 16^M
^M
testing modify of /opt/dcelocal/etc/group_override after sec_clientd boot^M
testing override_get_group_info^M
pass: feature override_get_group_info seq 17^M
^M
testing modify of /opt/dcelocal/etc/group_override after sec_clientd boot^M
testing override_get_group_info^M
pass: feature override_get_group_info seq 18^M
^M
testing errors when /opt/dcelocal/etc/group_override is removed^M
testing override_get_group_info^M
pass: feature override_get_group_info seq 19^M
^M
now reinstate /opt/dcelocal/etc/group_override and do a sanity check^M
testing override_get_group_info^M
pass: feature override_get_group_info seq 20^M
^M
testing override_get_group_info member cursor stuff^M
pass: feature override_get_group_info seq 21^M
pass: feature override_get_group_info seq 22^M
pass: feature override_get_group_info seq 23^M
pass: feature override_get_group_info seq 24^M
pass: feature override_get_group_info seq 25^M
^M
pass- check: kmem::333 in line: kmem::333:root,sys in file: /tmp/group^M
pass- check:
nogroup::555:a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a0,a1,a2,a3,a4,a5,a6,a7,a
8,a9,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a0,a1,a2,a3,a4,a
5,a6,a7,a8,a9,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a0,a1,a
2,a3,a4,a5,a6,a7,a8,a9,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a0,a1,a2,a3,a4,a5,a6,a7,a8,a
9 in line:
nogroup::555:a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a0,a1,a2,a3,a4,a5,a6,a7,a8,
a9,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a0,a1,a2,a3,a4,a5,
a6,a7,a8,a9,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a0,a1,a2,
a3,a4,a5,a6,a7,a8,a9,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,
a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a0,a1,a2,a3,a4,a5,a6,
a7,a8,a9,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9 in
file: /tm
p/group^M
pass- check: bin::444: in line: bin::444: in file: /tmp/group^M
# exit^M

[10/21/94 public]
I may have interrupted the test the first time it was run and it left
the file /etc/ptmp. I moved this file and then reran the test and test 8
and test 23 failed. I did not get the same failure about opening /etc/ptmp.

However, I then decided to run the test again because /etc/ptmp had
been recreated. The test failed when it tried to open /etc/ptmp. This
file should be deleted by the test probably before and after the test
is run. I believe that leaving a temporary file in /etc is not a good
idea. Why can't this file be created in /tmp?

[10/21/94 public]
This test shouldn't be creating /etc/ptmp itself and I doubt that it is.
That file is created by passwd_export when it starts up and deleted when
it finishes.  It must be /etc/ptmp because that's what vipw uses to make
sure multiple processes aren't trying to update /etc/passwd at the same
time.  Are you running the test as root?  If not, then you're probably
creating the file, but don't have permissions to remove it?  If that's the
case, then this is just pilot error and the CR should be cancelled (or
changed to ask for documentation with the test that says that it needs to
be run as root).



CR Number                     : 12672
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : sec_rgy_attr_sch-tc test fails
Reported Date                 : 10/19/94
Found in Baseline             : 1.1b22
Found Date                    : 10/19/94
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/19/94 public]

The sec_rgy_attr_sch-tc test failed with the following:

520|0 5 20315 1 1|test case (tp5)
520|0 5 20315 1 2|FAILED sec_rgy_attr_sch_scan()        result:         Fault re
mote no memory (dce / rpc)      expected:       this operation not implemented (
dce / sec)
220|0 5 1 15:52:59|FAIL

It appears that test test needs to be updated.

[10/20/94 public]
HP wants to take a look at the back-end for this
call (rs_*_sch_scan) - even though the test isn't
implemented, the "Fault remote no memory" status
is *NOT* expected and we want to understand why
we're getting this.  If we find the code problem,
a separate OT will be opened for this and if time
allows, we'll put it in the unintegrated tree.

[10/20/94 public]

Don't bother, it's a bug in the test code. I fixed it
while working on the functional tests for security replication.
The fix will be submitted as part of that.

[10/20/94 public]
Ran the same test with the latest Integrated 1.1 bits and this test does
fail. This appears to be intermittent since this test passed before.

FAILED sec_rgy_attr_sch_scan()
result:         Fault remote no memory (dce / rpc)
expected:       this operation not implemented (dce / sec)

[10/20/94 public]

No, it was probably always failing. There was another test in this
same test case that was core dumping - this problem was eventually
fixed.

*However*, when a TET test purpose causes a core dump, the Test Case
Controller loses contact with the test case and reports the test
case as being incomplete (or the TET results for this test case
is missing).

To catch these problems, I strongly recommend the following :

1) Set the following in tetexec.cfg

TET_SAVE_FILES=./core

TCC will look for core files after the test case completes and copy
them to the results directory.

2) Run a script after the test suite is finished which looks for core files
in $TET_ROOT/{test_suite}/results directory.

3) Carefully parse the TET journal looking for missing test case results.

This should really be mandatory.



CR Number                     : 12655
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : h, krb5/kdc
Short Description             : kdc_util.h near-duplication
Reported Date                 : 10/18/94
Found in Baseline             : 1.1
Found Date                    : 10/18/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : kdc_util.h
Sensitivity                   : public

[10/18/94 public]

There are two versions of kdc_util.h in the build tree--one in security/h
and a newer one in krb5/kdc which includes a TGS workaround to handle an
incompatibility between DCE and MIT Kerberos.  The two files are nearly
identical and should probably be consolidated into a single file.  Here 
are the diffs:


*** h/kdc_util.h	Wed Dec 15 13:34:52 1993
--- krb5/kdc/kdc_util.h	Wed Dec 15 13:35:17 1993
***************
*** 8,18 ****
  /*
   * HISTORY
   * $Log:	c012655,v $
# Revision 1.1  94/10/18  15:14:44  root
# new CR
# 
!  * Revision 1.1.2.2  1992/12/29  13:06:39  zeliff
!  * 	Embedding copyright notice
!  * 	[1992/12/28  20:14:23  zeliff]
   *
!  * Revision 1.1  1992/01/19  14:43:38  devrcs
   * 	Initial revision
   * 
   * $EndLog$
--- 8,27 ----
  /*
   * HISTORY
   * $Log:	c012655,v $
# Revision 1.1  94/10/18  15:14:44  root
# new CR
# 
!  * Revision 1.1.6.1  1993/10/14  20:02:23  sommerfeld
!  * 	Workaround MIT-DCE incompatibility in tgs request
!  * 	[1993/10/14  15:52:56  sommerfeld]
   *
!  * Revision 1.1.4.2  1992/12/29  14:18:26  zeliff
!  * 	Embedding copyright notice
!  * 	[1992/12/28  20:54:51  zeliff]
!  * 
!  * Revision 1.1.2.2  1992/05/28  20:59:19  sommerfeld
!  * 	[CR3650] Add prototype for krb5_add32_nowrap.
!  * 	Add ADD macro to call it.
!  * 	[1992/05/27  22:28:53  sommerfeld]
!  * 
!  * Revision 1.1  1992/01/19  14:54:29  devrcs
   * 	Initial revision
   * 
   * $EndLog$
***************
*** 27,35 ****
  **
  */
  /*
!  * $Source: /project/ot/dce/d01/d26/RCS/c012655,v $
!  * $Author: root $
!  * $Id: c012655,v 1.1 94/10/18 15:14:44 root Exp $
   *
   * Copyright 1990 by the Massachusetts Institute of Technology.
   *
--- 36,44 ----
  **
  */
  /*
!  * $Source: /project/ot/dce/d01/d26/RCS/c012655,v $
!  * $Author: root $
!  * $Id: c012655,v 1.1 94/10/18 15:14:44 root Exp $
   *
   * Copyright 1990 by the Massachusetts Institute of Technology.
   *
***************
*** 80,90 ****
--- 89,104 ----
  					   int));
  krb5_error_code kdc_process_tgs_req PROTOTYPE((krb5_kdc_req *,
  					       const krb5_fulladdr *,
+ 					       krb5_data *,
  					       krb5_tkt_authent **));
  
  krb5_error_code kdc_get_server_key PROTOTYPE((krb5_ticket *,
  					      krb5_keyblock **,
  					      krb5_kvno *));
+     
+ krb5_int32 krb5_add32_nowrap PROTOTYPE ((krb5_int32, krb5_int32));
+ #define ADD(x,y) krb5_add32_nowrap(x,y)
+     
  /* do_as_req.c */
  krb5_error_code process_as_req PROTOTYPE((krb5_kdc_req *,
  					  const krb5_fulladdr *,
***************
*** 93,98 ****
--- 107,113 ----
  /* do_tgs_req.c */
  krb5_error_code process_tgs_req PROTOTYPE((krb5_kdc_req *,
  					   const krb5_fulladdr *,
+ 					   krb5_data *,
  					   krb5_data ** ));
  /* dispatch.c */
  krb5_error_code dispatch PROTOTYPE((krb5_data *,
***************
*** 132,136 ****
  #define	min(a, b)	((a) < (b) ? (a) : (b))
  #define	max(a, b)	((a) > (b) ? (a) : (b))
  #endif
! 
  #endif /* __KRB5_KDC_UTIL__ */
--- 147,151 ----
  #define	min(a, b)	((a) < (b) ? (a) : (b))
  #define	max(a, b)	((a) > (b) ? (a) : (b))
  #endif
!     
  #endif /* __KRB5_KDC_UTIL__ */



CR Number                     : 12638
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : app_gd
Short Description             : add sec_login_validate_identity and 
sec_login_certify identity
Reported Date                 : 10/17/94
Found in Baseline             : 1.1
Found Date                    : 10/17/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : app_gd/security/2_authn.gpsml
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/17/94 public]

The auth walkthough should describe the use of the sec_login_validate_identity and 
sec_login_certify identity calls not just sec_login_valid_and_cert identity.

[6/30/95 public]

Re-assigned for DCE 1.2.



CR Number                     : 12599
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : server
Short Description             : wait_until_consistent poor error behavior
Reported Date                 : 10/12/94
Found in Baseline             : 1.1b20
Found Date                    : 10/12/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rs/rs_master_replist.c
Sensitivity                   : public

[10/12/94 public]
When rs_m_replist_check_prop_seqno() is called in a replica it returns
sec_rgy_read_only status as expected, but with a boolean "true" return
value & it causes a serviceability error record to be written.
Simple fixes for unintegrated as time allows.



CR Number                     : 12586
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : small number of dlgcfg001 failures in 48 CHO run
Reported Date                 : 10/12/94
Found in Baseline             : 1.1b21
Found Date                    : 10/12/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/12/94 public]


There were a small number of failures in last weekends 48 CHO run
of dlgcfg001.  These happened after about 48 hours.
The client apparently wasn't able to talk to the delegate.

520|0 1 20460 1 12|ERROR: client side test FAILED
520|0 1 20460 1 13|non zero return code
520|0 1 20460 1 14|ERROR: local attribute test FAILED
520|0 1 20460 1 15|non zero return code
520|0 1 20460 1 16|ERROR: remote attribute test FAILED
520|0 1 20460 1 17|non zero return code

There was a hardware failure on the machine that had the
client about the same time these tests were running.
So this may be hardware related.  Once the machine is repaired by CF,
I will rerun the test.



CR Number                     : 12526
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : Extended Login audit points needed
Reported Date                 : 10/5/94
Found in Baseline             : 1.1
Found Date                    : 10/5/94
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/5/94 public]

Extended login audit points need to be added.  Opened as with a A1 
priority as this is currently tentatively planned to be fixed in
the unintegrated tree.

[1/22/95 public]

Changed categorization from defect to enhancement to reflect true
status for this OT.



CR Number                     : 12504
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : Need priv_attr_triq_query
functional test
Reported Date                 : 10/5/94
Found in Baseline             : 1.1
Found Date                    : 10/5/94
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/5/94 public]

There are no functional tests for the priv_attr_triq_query() trigger callouts
in the privilege server, hence we don't know whether the trigger callout
feature works as advertised.  

Hopefully, the tests can be developed in time to be included in the
unintegrated tree.



CR Number                     : 12476
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : rgy_edit
Short Description             : rgy_edit should print errors on stderr
Reported Date                 : 10/3/94
Found in Baseline             : 1.0.3a
Found Date                    : 10/3/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/admin/rgy_edit/tty_io.c
Sensitivity                   : public

[10/3/94 public]

rgy_edit prints error messages on stdout, instead of stderr. Note that
if this change goes through, some changes in tests will be necessary to
log all the output, because currently only stdout is redirected.
An example of this is in 

	src/test/security/api/moretests/rgy.sh



CR Number                     : 12450
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : admin_gd
Short Description             : Permission for adding an account may be inaccurate
Reported Date                 : 9/30/94
Found in Baseline             : 1.0.3
Found Date                    : 9/30/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[9/30/94 public]
The Security Service portion of the admin guide may be incorrect in the
permissions that it lists for creating a new account.  We think that the
permissions should be as follows:
 
rmaug  on the principal named in the account
tm     on the group named in the account
tm     on the organization named in the account
r      on the registry policy object
 
We looked through the code, and these permissions seem to be correct.  Can
someone verify this and, if necessary, update the admin guide.
 
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'

[10/3/94 public]
reassigned to Security component owner.

[11/1/94 public]

While doing this goes against my policy of not doing technical changes for
1.1 Prentice Hall, this seems to be a relatively high visibility change
that we can make.  If doing this is not easy, and confirming its technical
correctness is not easy, we should defer it to 1.2 again

[hal 11/18/94 public] 

The previously assigned documentor will not be able to do the work.  I'd
still like to see if this can be fixed for 1.1PH though.....

[6/30/95 public]

Assigned to HP for DCE 1.2.



CR Number                     : 12317
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : sec_login_purge_context doesn't kill contexts
Reported Date                 : 9/23/94
Found in Baseline             : 1.1b17
Found Date                    : 9/23/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/23/94 public]

A call to sec_login_purge_context is documented as deleting any external
credential cache and freeing up in-memory resources associated with a
login-context.  This doesn't seem to work for non-default login-contexts.

The program below demonstrates this.  It creates a login-context from a
key-table entry, copies the login-context handle, purges the context via one
copy of the handle, and then successfully access the context via the other
copy.

To run the program, create a test principal <prin>, use rgy_edit ktadd to
put <prin>'s key in a keytable <keyfile>, then run the program:

%test <prin> <keyfile>


Program test.c:

#include <stdio.h>
#include <dce/rgybase.h>
#include <dce/sec_login.h>
#include <dce/binding.h>
#include <dce/rpc.h>
#include <dce/dce_error.h>

sec_login_handle_t login_context;
sec_login_handle_t login_context_copy;
error_status_t error_status;

void display_dce_error(error_status_t st) {
    int stat;
    char error_text[1024];
    dce_error_inq_text(st, error_text, &stat);
    if (stat) fprintf(stderr, "Unknown message number\n");
    else fprintf(stderr, "DCE error: \"%s\"\n", error_text);
    fflush(stderr);
}
 
int verify_login_context(sec_login_handle_t lc,
                         unsigned32 * error_status) {
    signed32 exp;
    unsigned32 num_groups;
    signed32* group_set;

    fprintf(stdout, ">>>Checking login-context %ld\n", (long)lc);
    fflush(stdout);

    sec_login_get_expiration(lc,
                             &exp,
                             error_status);

    if ((*error_status != 0) && (*error_status != sec_login_s_not_certified)) {
        return 1;
    };


    sec_login_get_groups(lc,
                         &num_groups,
                         &group_set,
                         error_status);

    if ((*error_status != 0) && (*error_status != sec_login_s_not_certified)) {
        return 1;
    };


    fprintf(stdout, ">>>Exp: %ld\n", (long)exp);
    fprintf(stdout, ">>>num_groups: %ld\n", (long)num_groups);
    fflush(stdout);

/* Else return a success indication...                                      */
    return 0;

}


int main(int argc, char *argv[]) {

    unsigned_char_p_t prin_name = argv[1];
    unsigned32 used_kvno;
    boolean32 reset_passwd;
    sec_login_auth_src_t auth_src;
    void * keytab = argv[2];

    sec_login_setup_identity(prin_name,
                             sec_login_no_flags,
                             &login_context,
                             &error_status);

    if (error_status) {
        fprintf(stderr, "Error %X setting up identity\n", error_status);
        display_dce_error(error_status);
    } else fprintf(stderr, "sec_login_setup_identity OK.\n");
    fflush(stderr);


    sec_login_valid_from_keytable(login_context,
                                  rpc_c_authn_dce_secret,
                                  keytab,
                                  0,
                                  &used_kvno,
                                  &reset_passwd,
                                  &auth_src,
                                  &error_status);


    if (error_status) {
        fprintf(stderr, "Error %X validating context\n", error_status);
        display_dce_error(error_status);
    } else fprintf(stderr, "sec_login_valid_from_keytable OK.\n");
    fflush(stderr);

    login_context_copy = login_context;

    if (verify_login_context(login_context_copy, &error_status)) {
        fprintf(stderr, "Error %X checking context copy\n", error_status);
        display_dce_error(error_status);
    } else fprintf(stderr, "Context copy OK.\n");
    fflush(stderr);

    sec_login_purge_context(&login_context, &error_status);

    if (error_status)
        fprintf(stderr, "Error %X purging context\n", error_status);
    else fprintf(stderr, "Purged context...\n");
    fflush(stderr);


    if (verify_login_context(login_context_copy, &error_status)) {
        fprintf(stderr, "Error %X checking context copy\n", error_status);
        display_dce_error(error_status);
        fprintf(stderr, "This is expected\n");
    } else fprintf(stderr, "Error: Context copy still OK after purge!\n");
    fflush(stderr);

    return error_status;
}

[9/23/94 public]

Here's my guess.

The purge gets rid of the files on disk immediately.

The login handle is cached and reference-counted
and does not go away until the reference count drops
to zero.  E.G. if you call rpc_binding_set_auth_info()
with a login context and a binding handle, the login
handle isn't released until the binding handle is
freed. 

It's dangerous to alias login handles.  The
internal check for a valid context is not
particularly robust, so you could end up
extracting garbage from a minimally valid
login handle.

I'm curious as to why you consider this a 
P1 bug?  Does gssapi depend on the ability 
to "verify" an aliased login handle that
may have been purged elsewhere?

[9/23/94]

No, GSSAPI itself doesn't depend on it.  However, I ran into this during
the GSSAPI tests, and I want to make sure that GSSAPI's correctly freeing
any login-contexts it creates.  The only way I can see to do this is to
have the GSSAPI test program take a copy of the handle before it invokes
the GSSAPI routine that's expected to delete the context, and then check that
the copy fails afterwards.  Note that this does seem to work if the
login-context is created by dce_login (I assume the difference is that in this
case it's associated with a credential file), but not for a login-context
created via valid_from_keytable().

The test program in this OT doesn't use
the login-context to do any RPC ops, so I don't think it can be a refcount
issue - the only reference to this login-context should be the handle that
the program purges.

[9/23/94 public]

After further thought, I'm changing this to an
enhancement request.   Aliasing a login handle,
purging the original handle, and then attempting
to use the aliased handle, is equivalent to using
an uninitialized login handle variable.  The results
are indeterminate.

The implementation could be made more robust with
the addition of a magic number to the vm login handle
structure, but not by next Friday.

[12/20/95 public]
This was supposed to be an enhancement request, rather than a code
bug.  Therefore lowering priority to 2 from 1.



CR Number                     : 12173
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : client
Short Description             : printf %s being passed a struct
Reported Date                 : 9/13/94
Found in Baseline             : 1.1
Found Date                    : 9/13/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/13/94 public]

Customer reported that "login_test" sometimes dumps core because a print
formatting statement is being passed a sec_passwd_rec_t struct instead of 
a string:

> Full Description:
> 
>      The api security test for login drops core when run with the
>      highest debug output_level because it prints a binary structure
>      (passwd) as a string (%s).
> 
> 
> Proposed Solution:  
> 
>      Replace code like
> 
>           TSHMessage(ctx, MOTRACE, 
>                     "sec_login_valid_and_cert_ident (%s .. ), status; %s\n",
>                      passwd, error_buf);
> 
>      with code like
> 
>           TSHMessage(ctx, MOTRACE, 
>                     "sec_login_valid_and_cert_ident (%s .. ), status; %s\n",
>                     passwd.key.tagged_union.plain, error_buf);
> 
>      so the %s gets a char* argument not a binary structure or like
> 
>           TSHMessage(ctx, MOTRACE, 
>                     "sec_login_valid_and_cert_ident ( .. ), status; %s\n",
>                     error_buf);
> 
>      so the %s is removed. 
> 
>      I found this problem only in moretests/login_test.c.

Nothing further to add--either solution would fix the problem.



CR Number                     : 12164
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : client
Short Description             : glitches in passwd_import test
Reported Date                 : 9/13/94
Found in Baseline             : 1.1
Found Date                    : 9/13/94
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : passwd_import.sh
Sensitivity                   : public

[9/13/94 public]

Customer reports a couple of small glitches in the "passwd_import.sh" test
script:

> Full Description:
> 
>      The api security test for passwd_import has several minor bugs:
> 
>      1. if test is run for first time then rm -r  /tmp/tmp_dir
>         outputs error that file/dir does not exist.
> 
>      4. There are too many questions expected of passwd_import. The
>         answers are too numerous. The sequence y,a,y,a makes no sense 
>         and should be y,a,n.
       
And has suggested the following fixes:
  
> Proposed Solution:  
> 
>      Replace code in src/test/security/api/moretests/passwd_import.sh
> 
>         "1")
> !         rm -r  /tmp/tmp_dir
>         :        :        :        :        :        :        :
>           echo "unix_bin" >> /tmp/passwd_import.script
>           echo "y" >> /tmp/passwd_import.script
>           echo "a">> /tmp/passwd_import.script
> !         echo "y" >> /tmp/passwd_import.script
> !         echo "a" >> /tmp/passwd_import.script
>         :        :        :        :        :        :        :
> 
> 
>      with code like
> 
>         "1")
> !         rm -rf  /tmp/tmp_dir  # use -f to not complain if directory does not exist
>         :        :        :        :        :        :        :
>           echo "unix_bin" >> /tmp/passwd_import.script
>           echo "y" >> /tmp/passwd_import.script
>           echo "a">> /tmp/passwd_import.script
> !         echo "n" >> /tmp/passwd_import.script
>         :        :        :        :        :        :        :

I would only add that the first problem could alternatively be fixed by
file-specific existence tests a la:

	if [ -s /tmp/tmp_dir/foo ]
	then
		rm /tmp/tmp_dir/foo	
	fi

[9/13/94 public]
This is a test defect, not a code defect, so I modified the appropriate
field above to accurately represent that fact...



CR Number                     : 12163
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : client
Short Description             : group/user ID/name dependencies
Reported Date                 : 9/13/94
Found in Baseline             : 1.1
Found Date                    : 9/13/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : passwd_import.sh
Sensitivity                   : public

[9/13/94 public]

Customer reported several instances in the "passwd_import.sh" test script
where expected results may not occur because of embedded assumptions about
the mappings of "standard" group and user IDs and names:

> Full Description:
> 
>      passwd_import test #9 fails because it assumes that specific
>      Unix usernames and groups have the same user and group ids
>      on all platforms.  The ids on SVR4 platforms, however, are
>      not the same as on other platforms.
> 
>      The test does not get the expected set of conflicts.  There
>      are only 2 conflicts instead of the expected 7.  So the
>      resulting set of user/group ids is not what the test expects.
> 
> Full Description:
> 
>      The api security test for passwd_import has several minor bugs:
> 
>      2. the sed command must handle comment lines (start with #) in
>         passwd and group files.

(Note:  this is not a bug but a request for an enhancement to allow 
modification of the test "group" and "passwd" files to handle local 
variations in group and user IDs and names.)

>      3. bpc in moretests/passwd file has group 0 which is root on SVR4.
>         So, the rgy_edit command "c -p bpc -g system -o org..." fails.
>         It should be "c -p bpc -g root -o org..." fails.
> 
>      5. rgy_edit is told to del sys for testcase 6 when it does not
>         exist on SVR4.

An informal survey of a few of our own machines confirms the potential 
problem, which extends well beyond SVR4-based implementations:

GID	Test	HP-UX	AIX		SINIX	SCO	SunOS
---	----	-----	---		-----	---	-----

0	root	root	system		root	root	wheel
1	other	other	staff		other	other	daemon
2	bin	bin	bin		bin	bin	kmem
3	sys	sys	sys		sys	sys	bin
4	adm	adm	adm		adm	adm	tty
5	daemon	daemon	uucp		uucp	uucp	operator
6	mail	mail	mail		mail	----	news
7	lp	lp	security	tty	mail	----

The customer proposes a number of SVR4-specific solutions:

> Proposed Solution:  
> 
>      Change the security passwd_import.sh script to expect a
>      different set of user and group ids for SVR4 platforms.
> 
> Proposed Solution:  
> 
>      Replace code in src/test/security/api/moretests/passwd_import.sh
> 
>                 if [ "$1" = 6 ]
>                 then
>               echo "del unix_bin " >> /tmp/passwd_import.script
> -             echo "del sys" >> /tmp/passwd_import.script
>         :        :        :        :        :        :        :
>         "4")
> !               sed -e "/[\/ ]\*.*/d" ../moretests/passwd | sed -e "1d" > /tmp/tmp_dir/passwd
> !               sed -e "/[\/ ]\*.*/d" ../moretests/group  | sed -e "1d"  > /tmp/tmp_dir/group
>         :        :        :        :        :        :        :
>           # Change user's passwd and account status, so the user can login.
> 
>           echo "v" > /tmp/passwd_import.script
> !         echo "c -p bpc -g system -o org -pw -dce- -mp -dce- -av -pv"  >> /tmp/passwd_import.script
>         :        :        :        :        :        :        :
> 
> 
>      with code like
> 
>                 if [ "$1" = 6 ]
>                 then
>               echo "del unix_bin " >> /tmp/passwd_import.script
>         :        :        :        :        :        :        :
>         "4")
> !               sed -e "/[\/ ]\*.*/d" ../moretests/passwd | sed -e "/^#/d" | sed -e "1d" > /tmp/tmp_dir/passwd
> !               sed -e "/[\/ ]\*.*/d" ../moretests/group  | sed -e "/^#/d" | sed -e "1d"  > /tmp/tmp_dir/group
>         :        :        :        :        :        :        :
>           # Change user's passwd and account status, so the user can login.
> 
>           echo "v" > /tmp/passwd_import.script
> !         echo "c -p bpc -g root -o org -pw -dce- -mp -dce- -av -pv"  >> /tmp/passwd_import.script

Aside from the change in the sed line, which could be generally useful for
anyone modifying the test "group" and "passwd" files, these changes will only
work for systems with the same group and user IDs and names as those on the
customer's system.

As I see it, there are three basic options for dealing with this:

	(1) Add a lot of implementation-specific code (like the above) to 
	    "passwd_import.sh", with the likelihood that there will still 
	    be discrepancies.

	(2) Rewrite (or write a script which itself rewrites)
	    "passwd_import.sh" to modify the test "group" and "passwd" files
	    and some of the specific tests within "passwd_import.sh" based
	    on either the actual "group" and "passwd" files of the platform 
	    being tested or else on IDs and names defined in some sort of 
	    test-specific configuration file; either way, this could take a 
	    fair amount of work.

	(3) Add specific language to the release notes or the porting guide
	    which explicitly indicates that "passwd_import.sh" and the test 
	    "group" and "passwd" files may need to be modified to accommodate 
	    local variations in these "standard" IDs; this is clearly the 
	    simplest option.

[9/13/94 public]
This is a test defect, not a code defect, so I modified the appropriate
field above to accurately represent that fact...



CR Number                     : 12155
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : pwd_strengthd
Short Description             : dce_config does not support automated config of Password Management Server
Reported Date                 : 9/13/94
Found in Baseline             : 1.1b17
Found Date                    : 9/13/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/13/94 public]
The dce_config function config(), which interprets the optional input
file COMMAND_FILE (command line option -c) does not contain instructions
for configuring the Password Management Server.

Need to add case under <component> "sec" for "pwd-mgmt" as follows:

pwd-mgmt) #No log message here because pwd_config generates its own;
	  auth_login; verify_auth; config_pwd_mgmt;;

[9/13/94 public]
Don't forget to update the sample command file, src/config/config.cmd
with the new command.  And the environment file (config.env) with
any automatic variables that might need to be set.



CR Number                     : 12073
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : gssapi
Short Description             : gss_acquire_cred(GSS_C_NO_NAME) doesn't pickup login context set by sec_login_set_context.
Reported Date                 : 9/7/94
Found in Baseline             : 1.1
Found Date                    : 9/7/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/7/94 public]

 A call sequence of :
     sec_login_setup_identity ( .., &lc ,.. )
     sec_login_valid_fom_keytable ( .., lc,. )
     nlc = sec_login_set_extended_attrs (.., lc , ..)
     sec_login_set_context  ( .. , nlc, .. )
     gss_acquire_cred (GSS_C_NO_NAME,, GSS_C_BOTH,.)

 results in gss_acquire_cred creating a new login context, so that the
 security token issued by a subsequent gss_init_sec_context call
 does NOT contain the ERAs set by sec_login_set_extended_attrs.

[9/7/94 public]

There is no guarantee that the attributes requested in 
the sec_login_set_extended_attrs() call will be present
in the new credentials, and no error is returned if they are 
not.  In that sense, ERAs are like groupsets.  You can request
as many groups as you like, but only those that are legitimately
part of the requestor's groupset are actually included in
the granted credentials. 

To determine whether the attributes you need are really there
after a successful sec_login_set_extended_attrs() call,
use sec_login_cred_get_initiator() followed by 
sec_cred_get_extended_attrs() to iterate over the extended
attributes.

[9/7/94 public]

Correct, but this was not the reason for the token lacking the ERAs. The 
calling process was allowed to get the ERAs (type X500_DN) in the login
context. We checked with sec_cred_get_extended_attrs().

[9/23/94 public]

I have changed gssdce_login_context_to_cred to create a BOTH-mode credential
(assuming you have a keytable entry for the principal).  This is a work-around
for the problem, in that it allows you to create a BOTH-mode credential that
contains extended attributes.  A future drop will enhance gss_acquire_cred
so that it will also pick up any extended attributes from the default
login-context if you're creating a credential with GSS_C_NO_NAME.



CR Number                     : 12041
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : login
Short Description             : Memory leak in sec_login_pvt_get_trusted_preauth()
Reported Date                 : 9/2/94
Found in Baseline             : 1.1b17,1.2.2
Found Date                    : 9/2/94
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : security/client/login/sec_login_pvt.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/2/94 public]

I am logging this for Sean Mullan ( mullan_s@apollo.hp.com).

In the function sec_login_pvt_get_trusted_preauth() ( file - 
sec_login_pvt.c ) , the memory allocated for the temporary file 
name ( "tfilename" ) is never freed.

Assigned to myself since I am fixing the same function to fix OT 11687.

[ sekhar 9/7/94 public ]

Fixed.

There were also a couple of other fixes with this :
(a) another memory leak : rpc binding handle was not free on an 
    error path (thanks to Mike Burati for spotting this).

(b) use open() instead of creat()  ( which was not really doing 
    what it was intended to do ).

[11/14/96]

Improper fix to memory leak involving tfilename results in freelist corruption,
which can ultimately lead to SEGV. tfilename is an output parameter of an
rpc to dced. Memory allocated by an rpc server and returned to an rpc
client should be released with rpc_ss_client_free not free. This bug can
be expected to cause memory corruption in servers which have a login
context refresh thread which calls sec_login_pvt_get_trusted_preauth
in an attempt to validate via the DCE 1.1 preauthentication protocol (for 
example, cdsd).

If the original memory leak was found with a tool, I would suggest that
the code be reinstrumentd, as I would expect the fix to have essentially
traded a leak for an improper free, which should also be detectable.

Proposed solution follows:

./security/client/login/sec_login_pvt.c
Comparing the file in your sandbox with revision 1.1.54.1.
***************
*** 7154,7160 ****
          free(client_unparsed);
      if (BAD_STATUS(stp)) {
          if (tfilename)
! 	    free(tfilename);
          return;
      }
  
--- 7151,7157 ----
          free(client_unparsed);
      if (BAD_STATUS(stp)) {
          if (tfilename)
! 	    rpc_ss_client_free(tfilename);
          return;
      }
  
***************
*** 7163,7169 ****
       */
      tfp = fopen((char *) tfilename, "r");
      if (tfp == (FILE *) NULL) {
!         free(tfilename);
          rpc_ss_client_free((idl_void_p_t) machine_tkt);
          rpc_ss_client_free((idl_void_p_t) ebuf);
          *stp = errno;
--- 7160,7166 ----
       */
      tfp = fopen((char *) tfilename, "r");
      if (tfp == (FILE *) NULL) {
!         rpc_ss_client_free(tfilename);
          rpc_ss_client_free((idl_void_p_t) machine_tkt);
          rpc_ss_client_free((idl_void_p_t) ebuf);
          *stp = errno;
***************
*** 7176,7182 ****
          /* could be EOF */
          *stp = errno;
          (void) fclose(tfp);
!         free(tfilename);
          rpc_ss_client_free((idl_void_p_t) machine_tkt);
          rpc_ss_client_free((idl_void_p_t) ebuf);
          return;
--- 7173,7179 ----
          /* could be EOF */
          *stp = errno;
          (void) fclose(tfp);
!         rpc_ss_client_free(tfilename);
          rpc_ss_client_free((idl_void_p_t) machine_tkt);
          rpc_ss_client_free((idl_void_p_t) ebuf);
          return;
***************
*** 7185,7191 ****
             (krb5_octet *) malloc(random_key->length))) {
          SET_STATUS(stp, sec_login_s_no_memory);
          (void) fclose(tfp);
!         free(tfilename);
          rpc_ss_client_free((idl_void_p_t) machine_tkt);
          rpc_ss_client_free((idl_void_p_t) ebuf);
          return;
--- 7182,7188 ----
             (krb5_octet *) malloc(random_key->length))) {
          SET_STATUS(stp, sec_login_s_no_memory);
          (void) fclose(tfp);
!         rpc_ss_client_free(tfilename);
          rpc_ss_client_free((idl_void_p_t) machine_tkt);
          rpc_ss_client_free((idl_void_p_t) ebuf);
          return;
***************
*** 7196,7202 ****
          /* could be EOF */
          *stp = errno;
          (void) fclose(tfp);
!         free(tfilename);
          krb5_free_keyblock(random_key);
          rpc_ss_client_free((idl_void_p_t) machine_tkt);
          rpc_ss_client_free((idl_void_p_t) ebuf);
--- 7193,7199 ----
          /* could be EOF */
          *stp = errno;
          (void) fclose(tfp);
!         rpc_ss_client_free(tfilename);
          krb5_free_keyblock(random_key);
          rpc_ss_client_free((idl_void_p_t) machine_tkt);
          rpc_ss_client_free((idl_void_p_t) ebuf);
***************
*** 7204,7210 ****
      }
      (void) fclose(tfp);
  
!     free(tfilename);
  
      if (!(*machine_tgt = (krb5_data *) malloc(sizeof(krb5_data)))) {
          SET_STATUS(stp, sec_login_s_no_memory);
--- 7201,7207 ----
      }
      (void) fclose(tfp);
  
!     rpc_ss_client_free(tfilename);
  
      if (!(*machine_tgt = (krb5_data *) malloc(sizeof(krb5_data)))) {
          SET_STATUS(stp, sec_login_s_no_memory);



CR Number                     : 11969
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : era
Short Description             : sec_rgy_attr_delete should support attr-value removal
Reported Date                 : 8/31/94
Found in Baseline             : 1.1b16
Found Date                    : 8/31/94
Severity                      : D
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/31/94 public]

The security api call sec_rgy_attr_delete() should support
removal of attributes by type-value pairs.  Currently,
regardless of the value passed in for a given attribute,
all instances of that attribute are removed.

[10/4/94 public]
I checked with ahop and she agrees that this should be an enhancement request
because of the reasons specified in CR11951 (the docs and IDL file comments
were wrong).  She may or may not cancel it depending on the outcome of a
discussion she's having with Joe about whether it'll be too complex and
possibly inconsistent behavior with the multi-valued stuff...  Assigned to
ahop until they decide what to do about this one.  Note that the protocol
would support this enhancement if necessary, so there's no changes to be
made there...



CR Number                     : 11894
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : gss
Short Description             : Add gssapi tests for coverage
Reported Date                 : 8/25/94
Found in Baseline             : 1.1b15
Found Date                    : 8/25/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : test-gssapi.c
Sensitivity                   : public

[8/25/94 public]
This is a placeholder, to remind me that I have to enhance the gssapi
test-suite to improve the test-coverage numbers for GSSAPI.

[9/15/94 public]

Some additional test (mostly for support & convenience routines) were
added in today's drop.

Still need additional negative tests to get the coverage numbers up.

[9/23/94 public]

Submitted additional test exercising credential management routines.



CR Number                     : 11886
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : sec_rgy_rep_admin_become_master() API changes a master to a slave replica.
Reported Date                 : 8/25/94
Found in Baseline             : 1.1b16
Found Date                    : 8/25/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/25/94 public]

I have a master and 1 slave replica in my cell configuration. I invoke
the become -master command on a master replica. This produces an
error message but the sec_rgy_rep_admin_become_master() API performs
some work that makes the master a slave replica.


Try this:

>sec_admin
sec_admin> lrep -all

Default replica:  /.../dcecp_cell.osf.org/subsys/dce/sec/master
Default cell:     /.../dcecp_cell.osf.org


subsys/dce/sec/master (master)
Instance id: 4216c210-bfa5-11cd-96c2-0800092734a4
Addresses: ncacn_ip_tcp:130.105.5.121[]
           ncadg_ip_udp:130.105.5.121[]
State:                   in service - master
Last update received at: Thu Aug 25 11:15:39 1994
Last update's seqno: 0.529

subsys/dce/sec/ice
Instance id: e0ed07a7-c012-11cd-bb6f-0000c0239a70
Addresses: ncacn_ip_tcp:130.105.5.45[]
           ncadg_ip_udp:130.105.5.45[]
State:                   in service - slave
Last update received at: Thu Aug 25 11:15:39 1994
Last update's seqno: 0.529
Propagation state: ready for updates 
Last update delivered: Thu Aug 25 11:15:39 1994 
Last update's seqno: 0.529 
Number of outstanding updates: 0 
Last comm status:        Successful completion (dce / svc)

sec_admin> become -master
Do you wish to continue (y[es]) or abort this operation (n[o])? y
Become operation failed - Replica is the master (dce / sec)


This is a good error message, however....


sec_admin> site subsys/dce/sec/master
Default replica:  /.../dcecp_cell.osf.org/subsys/dce/sec/master
Default cell:     /.../dcecp_cell.osf.org

sec_admin> info -f

Default replica:  /.../dcecp_cell.osf.org/subsys/dce/sec/master
Default cell:     /.../dcecp_cell.osf.org
State:                   in service - slave
Last update received at: Thu Aug 25 11:15:39 1994
Last update's seqno:     0.529
Instance id: 4216c210-bfa5-11cd-96c2-0800092734a4
Addresses: ncacn_ip_tcp:130.105.5.121[] 
	   ncadg_ip_udp:130.105.5.121[]
Master id: 4216c210-bfa5-11cd-96c2-0800092734a4
Master address: ncacn_ip_tcp:130.105.5.121[]
		ncadg_ip_udp:130.105.5.121[]
Master seqno: 0.100 
Software version:        secd.dce.1.1


Note that the master replica is changed to a slave.

[10/12/94 public]

CR being removed from  unintegrated list until fix is known and
can be evaluated.

[10/14/94 public]
Returning this ot to it's natural state - priority had been raised as an
indication of wanting to get this into the unintegrated tree.



CR Number                     : 11817
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : Misleading KDC Measage when
"good-since" date postdates current time
Reported Date                 : 8/22/94
Found in Baseline             : 1.0.3,1.1
Found Date                    : 8/22/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : krb5/kdc/do_as_req.c
Sensitivity                   : public

[8/22/94 public]

When you try to log into an account when the "good since date" of the
account postdates the current time, you get the KDC_ERR_CLIENT_NOTYET
message.  The associated text is:

Client not yet valid - try again later

A better message would be "account not yet valid for login".  "Client" in
DCE can mean lots of things, and someone could interpret the above message 
to mean that a DCE client was improperly configured or started.

[8/22/94 public]

Would "Client account not yet valid" satify you?

[8/23/94 public]

Yes. That's fine.



CR Number                     : 11755
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : 64 bit porting changes
Reported Date                 : 8/18/94
Found in Baseline             : 1.1
Found Date                    : 8/18/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/18/94 public]

The following files needed to be modified to run on a 64 bit platform:

    evt_read.c
    sec_login_pvt.c
    rsdb_attr_schema.c
    rsdb_acct.h
    kinit.c
    rsdb_acl.c
    rsdb_attr.c

The following are the diffs of the changes:

==========================================================
diff evt_read.c /project/dce/build/dce1.1/src/security/audit/libaudit/evt_read.c
774,777d773
< #if LONG_BIT >= 64
<                  sprintf(strbuf+strlen(strbuf), "hyper int %ld\n",
<                         tail->info_item[i].tagged_union.hyper_int);
< #else
782d777
< #endif
797,800d791
< #if LONG_BIT >= 64
<                 sprintf(strbuf+index, "uhyper int %ld\n",
<                      tail->info_item[i].tagged_union.uhyper_int);
< #else
805d795
< #endif

==========================================================
diff sec_login_pvt.c /project/dce/build/dce1.1/src/security/client/login/sec_login_pvt.c
1786c1786
<     *unix_projlist = (signed32 *) malloc(num_groups * sizeof(signed32));
---
>     *unix_projlist = (long *) malloc(num_groups * sizeof(signed32));


==========================================================
diff rsdb_attr_schema.c /project/dce/build/dce1.1/src/security/server/rsdb/rsdb_attr_schema.c
262c261
<     signed32          sch_entry_len;
---
>     long              sch_entry_len;

==========================================================
diff rsdb_acct.h /project/dce/build/dce1.1/src/security/h/rsdb_acct.h
253,254c253,254
<     signed32              max_num,            /* [in] */
<     signed32              *(num_returned),    /* [out] */
---
>     long                  max_num,            /* [in] */
>     long                  *(num_returned),    /* [out] */
256,257c256,257
<     signed32              *unix_projlist,     /* [out] */
<     signed32              *(num_projects),    /* [out] */
---
>     long                  *unix_projlist,     /* [out] */
>     long                  *(num_projects),    /* [out] */

==========================================================
diff kinit.c /project/dce/build/dce1.1/src/security/krb5/clients/kinit/kinit.c
419c419
<         signed32 ticket_expiration;
---
>         long ticket_expiration;

==========================================================
diff rsdb_acl.c /project/dce/build/dce1.1/src/security/server/rsdb/rsdb_acl.c
1107,1108c1107
<     long                    name_key_len = sizeof(name_key);
---
>     signed32                    name_key_len = sizeof(name_key);
1110,1111c1109
<     long                    plen;
---
>     signed32                    plen;

==========================================================
diff rsdb_attr.c /project/dce/build/dce1.1/src/security/server/rsdb/rsdb_attr.c
679c678
<     signed32          attr_inst_len;
---
>     long              attr_inst_len;

[9/1/94 public]
In most of these files, you suggest changing a type "long" to type "signed32",
but in rsdb_acl.c, you suggest changing type "signed32" to type "long".  Is this
actually correct?  I am unable to verify the changes without a 64-bit architecture.

[9/7/94 public]
The priority of this defect has been dropped to indicate that this will
not be fixed in the mainline, instead it will be put in the unintegrated
tree.  We do still need input from DEC on this.

[9/7/94 public]
For rsdb_acl.c, the change should be from "signed32" to type "long".  The
reason for this is the function rsdb_util_get_key_of_id() expects a pointer
to type long as its 4th parameter.  Every other place this function is
called the type of parameter passed is a pointer to long.  On a 64 bit
machine "signed32" is not the same as "long".

Another possible fix would be to change the function rsdb_util_get_key_of_id
so it expects a pointer to signed32 and change all invocations that currently
pass a pointer to long.  This fix would be prefered.

[10/5/94 public]
We had bumped this from the mainline per Bob Hathaway's request (timing of
the submission) and the plan was for it to go into the unintegrated tree.
We still plan to do this.

[10/12/94 public]
Removed from unintegrated tree list.

[10/14/94 public]
Returning this ot to it's natural state - priority had been raised as an
indication of wanting to get this into the unintegrated tree.



CR Number                     : 11754
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : need to include stdio.h
Reported Date                 : 8/18/94
Found in Baseline             : 1.1
Found Date                    : 8/18/94
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/18/94 public]

The following file need to include stdio.h :

    sec_login_pag.c
    sec_login_util.c

[8/24/94 public]
Could you provide information on why these files needs to include
stdio.h?  They have been building successfully on the reference
machines.

[8/24/94 public]
sec_login_pag.c uses sprintf(), so it should have stdio.h for the prototypes
(will build on many platforms without it, but it still should be included)

sec_login_util.c uses strcmp et al, but I don't see any stdio type stuff, so
I would argue that it really wants <string.h>

[9/7/94 public]
The priority of this defect has been dropped to indicate that this will
not be fixed in the mainline, instead it will be put in the unintegrated
tree.  We do still need input from DEC on this

[9/07/94 public]

sec_login_pag.c needs the definition of stderr and sec_login_util.c 
needs the definition of FILE.  Both of these are defined in stdio.h.

When compiling with ANSI C not having these defined causes compilation
errors.

Why are you putting these in the unintegrated tree?  This is such
and easy change.

[10/5/94 public]
We had bumped this from the mainline per Bob Hathaway's request (timing of
the submission) and the plan was for it to go into the unintegrated tree.
We still plan to do this.

[10/05/94 public]
See my comments in OT CR 12503 for another take on this.

[10/12/94 public[]

Removed from unintegrated list.



CR Number                     : 11753
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : need to include stdlib.h
Reported Date                 : 8/18/94
Found in Baseline             : 1.1
Found Date                    : 8/18/94
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/18/94 public]

The following files need to include stdlib.h:

    rsdb_attr_schema.c
    rsdb_attr.c
    rs_reserved.c
    sec_rgy_attr.c
    rgy_create.c
    rpriv_attr.c

[8/24/94 public]
Why have these files been building successfully without stdlib.h to
date?  Could you provide more information on why stdlib.h needs to be
included?

[9/7/94 public]
The priority of this defect has been dropped to indicate that this will
not be fixed in the mainline, instead it will be put in the unintegrated
tree.  We do still need input from DEC on this

[9/07/94 public]

stdlib.h is needed to pick up the prototype for malloc which is
defined in stdlib.h.  When compiling with an ANSI C compiler, 
you get compiliation errors if this file is not included.

Why are you putting these changes in the unintegrated tree?
The fix is simple.

[10/5/94 public]
We had bumped this from the mainline per Bob Hathaway's request (timing of
the submission) and the plan was for it to go into the unintegrated tree.
We still plan to do this.

[10/12/94 public]

Removed from unintegrated list.



CR Number                     : 11718
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : security replica
Short Description             : account pepper on replica is not the same as on master
Reported Date                 : 8/16/94
Found in Baseline             : 1.1b15
Found Date                    : 8/16/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/16/94 public]

While working on OT11489 (dce_login from 1.03 client crashes
1.1 secd replica), I uncovered a potentially serious bug.

The pepper for an account is not the same on a replica as it
is on the master. This information should be identical. 

I was using cell_admin to log in. I did not change the pepper
so it was using the default. On the master secd, the pepper was
the default. However, on the replica, it was not the default.
This can be reproduced by killing the master and forcing a log
in thru the replica. Then set a breakpoint in process_as_req()
in security/krb5/kdc/do_as_req.c and analyze client.salt_type.

[9/8/94 public]

This OT was opened based on code inspection instead of a buggy
behavior.  We verified the described scenario will cause a retry
effort but does not create a problem.  So it is down-graded to
E4.



CR Number                     : 11699
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : server rsdb
Short Description             : alias between cell and non-cell namespaces provokes error
Reported Date                 : 8/15/94
Found in Baseline             : 1.1
Found Date                    : 8/15/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/15/94 public]

Using the weekend build of 8/14/94, configured a single machine cell on HP.
The cell alias functionality is not working while using rgy_edit -al
option. Here is the info:

rgy_edit=> v
nobody                                        -2
root                                           0
daemon                                         1
sys                                            2
bin                                            3
uucp                                           4
who                                            5
mail                                           6
tcb                                            9
dce-ptgt                                      20
dce-rgy                                       21
cell_admin                                   100
krbtgt/hp_cell                             12439
rgy_edit=> add real_alias -al
Enter UNIX number: 12439
Enter full name: () 
Enter object creation quota: (unlimited) 
?(rgy_edit) Unable to add principal  "real_alias" - Uuid version invalid
(dce / sec)
Do you wish to try again  [y/n]? (n)

[8/15/94 public]
Pilot error; lowered priority.
You meant to do "add krbtgt/real_alias -al 12439"
                     ^^^^^^

[8/15/94 public]
This still does not work:
rgy_edit=> add krbtgt/real_alias -al 12439
?(rgy_edit) "12439" - Unknown or redundant keyword (Registry Editor/TTY
Interface)
 (dce / sad)

[8/15/94 public]
Ok, mixed our syntaxes & goofed...
You meant to do "add krbtgt/real_alias 12439 -al"
                     ^^^^^^^

[10/5/94 public]
Mike B pointed out that this was still open, with a misleading title.
Lowered priority; this is just baffling behavior ("don't do that").



CR Number                     : 11639
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12864
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : cell alias account doesn't "float"
Reported Date                 : 8/10/94
Found in Baseline             : 1.1b14
Found Date                    : 8/10/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/10/94 public]
For tracking:  cell accounts are currently associated with the original
principal name of a cell, so if aliases are added, the primary name is
changed, and the original name is deleted, the account is deleted as well.

[9/6/94 public]
Dropped the priority to 2 to indicate that this does not need to be fixed
in the DCE 1.1 mainline.  This is planned for unintegrated, but could be
"fixed with documentation" according to Rob.

[3/11/96 public]
Moot wrt unsupported cell rename functionality.



CR Number                     : 11638
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : functional tests
Short Description             : Functional test for preauth needed
Reported Date                 : 8/10/94
Found in Baseline             : 1.1b14
Found Date                    : 8/10/94
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/10/94 public]

Although there are functional tests which test sec_login_validate_identity(),
a test is needed to ensure that DCE preauthentication is working
properly and it is not failing and falling back to a less secure
preauthentication.

Test would consist of attaching an pre_auth_req ERA of value 2 to a
test principal and then performing a login with valid and invalid
passwords.



CR Number                     : 11552
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : secd comm errors to pwd_strengthd retranslated
Reported Date                 : 8/3/94
Found in Baseline             : 1.1b13
Found Date                    : 8/3/94
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rs_pwd_mgmt.c
Sensitivity                   : public

[8/3/94 public]

If secd has problems communicating with the password strength server 
any rpc error will be pushed back over the wire and caught by the 
client binding code and treated as if it were a communications failure 
to secd. The client will then try to rebind to secd.

So far, some but not all of the rpc errors have been trapped and translated 
to a unique password strength server communication errors.

The rpc error should be logged via servicability before it is translated.

[08/19/94 public]

Bumped priority to P1. This is serious enough that it should be fixed
for DCE 1.1.

[08/31/94 public]

Lowered priority to 2. This is not as bad as I thought. Currently, all RPC
runtime errors which may conflict with the security client binding code are
translated to a more generic error (sec_pwd_mgmt_svr_unavail). However, the
real code should be logged via servicability so an admin can know how to
fix the problem.



CR Number                     : 11549
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_login
Short Description             : If user is root, bypass sec_clientd(dced) for preauth
Reported Date                 : 8/3/94
Found in Baseline             : 1.1b13
Found Date                    : 8/3/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/3/94 public]

If user/effective user is root, there is no need 
to communicate with sec_clientd (dced) for DCE preauthentication 
data; you already have the appropriate privileges to formulate the 
padata.

Should also improve performance a bit.



CR Number                     : 11480
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_create_db
Short Description             : sec_create_db coredumps if dup name
Reported Date                 : 7/28/94
Found in Baseline             : 1.1b13
Found Date                    : 7/28/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/28/94 public]
If you attempt to create a security replica with the same name as
one that exists in the cell, sec_create_db coredumps. This case
will occur infrequently, therefore only a priority 1. Sorry - don't
have coredump or info from it - easy to reproduce however:
	- configure sec replica
	- dce_config unconfigure mach w/ sec replica
	(requires some hand cdscp del obj/ cdscp del dir effort)
	- attempt to configure sec replica again

dce_config doesn't remove original sec replica as part of unconfig
(separate CR) - and sec_create_db less than graceful about handling
problem.

[7/29/94 public]
Downgraded to C3 because it is a 'recovery from operator error at config time'
type of bug.



CR Number                     : 11470
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 11466
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : login
Short Description             : sec_login_util_bind_to_sec_clientd use dce_binding_from_file
Reported Date                 : 7/28/94
Found in Baseline             : 1.1b12
Found Date                    : 7/28/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/login/sec_login_util.c
Sensitivity                   : public

[7/28/94 public]
The routine sec_login_util_bind_to_sec_clientd could be made simpler by
calling the new routine dced_binding_from_file.



CR Number                     : 11332
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : kerberos
Short Description             : case of DNS realm names is wrong.
Reported Date                 : 7/15/94
Found in Baseline             : 1.0
Found Date                    : 7/15/94
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/15/94 public]

Cliff Neuman has recently stated that the default case for kerberos realm
names derived from DNS names should be UPPER CASE.

DCE forces the cell name to lower case, and uses the cell name as the realm
name.

This causes two potential problems:

 - potential interrealm interoperability problems for "plain kerberos"
apps between a DCE-managed realm and a non-DCE-managed realm.

 - a "realm takeover" of an existing realm with an UPPER CASE name is
cannot be done as a bloodless coup; you have to visit all the kerberos acls
on all objects in the realm and rename them (which would not be trivial for
something like the ATHENA.MIT.EDU realm..).

We may not be able to fix this in time for 1.1.



CR Number                     : 11217
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : admin_gd
Short Description             : improve hosts/hostname/self desc
Reported Date                 : 7/8/94
Found in Baseline             : 1.0.3
Found Date                    : 7/8/94
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : admin_gd/overview/overview/appa.gpsml
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/8/94 public]
I sent mail to Lisa Z. about this, but there is a bug contest on.  :-)

Appendix A of the Admin Guide Intro Book (at least in 1.0.3) is a
description of the names in the DCE namespace.  The description of
/.:/sec/principal/hosts/hostname/self could be improved.  It is correct
that this is a well-known name, but it should be explained that only the
"self" part is well-known.  The first part the name of the host and what
is well-known is that given the name of a host there is a principal
beneath that name called "self".  There is nothing that says the
hostname couldn't be foo/bar resulting in the principal:

  /.:/sec/principal/foo/bar/self

What I'm trying to get across is that the "hosts/" part is not
well-known.

[7/25/94 public]

The descriptions of the well-known names in Appendix A of
the Admin Guide - Intro with "hosts" and/or "hosts/hostname"
in their paths need to note that these names are not well-known,
e.g., that

/.:/sec/principal/<hosts>/<hostname>/self

    could be

/.:/sec/principal/foo/bar/self

    because "hosts" and "hostname" are not well-known names,
    (but "/.:" and "principal" are, and I believe that "sec",
    although not well-known, is a recommended name.)
    
Clear (as mud?;-)

I'm assigning this CR to Susan Teto (OSF DCE config writer).

[8/1/94 public]
Close.  Please don't put "hosts" in <>'s, it's is a real name and it by far
"usually" is hosts.  We don't write other names are that are not well-known
in <>'s (italics?), only those names where we don't know the text.  E.g.:

  /.:/sec/principal/hosts/absolut/self 

That's a real name in my cell (my machine's name is "absolut"), the name
that should be in the appendix should be:

  /.:/sec/principal/hosts/<hostname>/self 

Since we don't know the name of the host at "press time".

You are correct on the treatment of "sec" and it is correct in the docs.
The only thing this CR addresses is that the description of the
hosts/<hostname>/self entry should be broadened to make it clear that the
host could be named anything (this includes the "hosts/" portion) and that
given a hostname the well-known part is that you can append "/self" to the
hostname to get the principal name:

I would normally name my host:  hosts/absolut

I *could* name it: machines/absolut or nodes/absolut

Given those names my "well-known" host principcal name would be:

machines/absolut/self or nodes/absolut/self  both under /.:/sec/principal/

[10/24/94 public]
Put fix forward to the Prentice Hall version of the Admin. Guide - Intro.

[10/24/94 public]
I am deferring this CR to DCE R1.2.  After re-examining the appendix (Appendix
A in the Admin. Guide-Intro.), I've concluded that the fix is not simple.
Moifying the description of the .:/sec/principal/self name, as zahn
indicates above, is not enough.  All the namespace entries need a similar
breakdown of the parts of their names.  These names can consist of
user-selected, recommended, and well-known parts.  We could add an
description of the names at the beginning of the appendix; we certainly
don't want to explain every name that appears in the tables contained
in the appendix.  But, an appendix is really not the place to present important
information like this, and we fail to address the real need: a description
of CDS names in the body of the Admin Guide.  Currently, there is none.
I looked through both the Intro. and Core volumes -- also, the Intro to DCE.
I don't think it is appropriate to put such information into the Intro to
DCE, but recommend that someone add it to Part II of the Admin. Guide-Intro,
perhaps in a new chapter with other overview info, for R1.2.  I recommend
this solution because the Core volume of the guide assumes right off
(in .../dcecp/language.gpsml) that the reader knows what the "self" name is.
There is also an allusion to the .:/sec/principal/self in the chapter of
the Intro volume on configuring DCE (8_config.gpsml), but this is in a
message that dce_config prints during initalization of the Security
server, and I think it can remain unexplained (see the "keyseed" input step).

[6/30/95 public]

Assigned to HP for DCE 1.2.



CR Number                     : 11164
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : site name not evaluated properly 
when performing site_bind_{query,update}
Reported Date                 : 7/1/94
Found in Baseline             : 1.1
Found Date                    : 7/1/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/1/94 public]

When performing a sec_rgy_site_bind_update or query the site name 
is not evaluated correctly in two specific situations. 

If the site name starts with /.:/subsys/dce/sec the bind will 
fail unless of course the site name is /.:/subsys/dce/sec/master. 

If the site name starts with /.:/hosts the bind will fail. 

The error that is displayed is: 

Error: Registry server unavailable

Other compound names work correctly. For instance /.:/foo/bar will 
correctly bind the appropriate server for query or update.


[31-Aug-94 public]
priority lowered to indicate that this will not be fixed in the 1.1 mainline



CR Number                     : 11100
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : acl
Short Description             : sec_acl_test_access on -ic
Reported Date                 : 6/27/94
Found in Baseline             : 1.1b10
Found Date                    : 6/27/94
Severity                      : B
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/27/94 public]
Ok, pie in the sky enhancement not for 1.1.  

I would like to be able to test access on an initial container ACL.
Here's a case for why: In writing the subtree commands for CDS if you
want to check if you can create a subtree underneath an existing object,
you need to check two things.  First can you create objects in the
directory ( ir on dir and w on the clearinghouse).  Second, if you are
creating grandchildren, you need to make sure that you can create
objects in the newly created child directories.  What are the ACL's on
a child directory?  Well since it will be created beneath the parent,
it will be the initial container ACL of the parent.  To check if you
have permissions to do this, you need to see if you have ir on the
parent's initial container ACL.  Having an API to do this would be much
easier (and certainly more correct) than getting the ACL and doing the
access check yourself.

There should be a new fucntion added to the ACL interface just like
sec_acl_test_access() that has a sec_acl_type_t parameter as most of the
other ACL routines do.

[8/1/94 public]
I'll accept a lower priority but it's still a severity B since there is no
work-around.  This is not a cosmetic enhancement request.



CR Number                     : 11073
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : registry
Short Description             : sec_rgy_site_bind_update() returns "Registry server unavailable" for unavailable slave replica passed in.
Reported Date                 : 6/24/94
Found in Baseline             : 1.1b10
Found Date                    : 6/24/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/24/94 public]

I have a 3-machine cell configuration with one slave replica.

I invoke sec_rgy_site_bind_update() with the slave replica name,
like /.../dcecp_cell.osf.org/subsys/dce/sec/ice and it would bind to
the update site in that cell.  Great, this is what is expected.

Now, say I kill the slave security server. I used to invoke
sec_rgy_site_bind_update() with the same slave replica name and 
it would function as above. 

However, now I get the error "Registry server unavailable". It seems
that sec_rgy_site_bind_update() is now less forgiving than 2 months
ago.

Although not documented anywhere, we were be able
to pass in an invalid replica name or one that was "unavailable"
 and we were be able to bind to the master registry server in that cell.

Whatever is decided here, it must be documented in the man pages about
how forgiving this security API really is.


[31-Aug-94 public]
priority lowered to indicate that this will not be fixed in the 1.1 mainline



CR Number                     : 11007
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : 
Short Description             : Calls to getpw*() are not thread safe
Reported Date                 : 6/20/94
Found in Baseline             : 1.0.3
Found Date                    : 6/20/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/20/94 public]

Library calls for accessing user attribute information: getpw*() are
not thread safe. They copy the returned information to a static area.
Subsequent calls will overwrite the area. So in a threaded application,
it is crutial to guard such a memory overwriting problem.

There are various places in the sec code where such function calls are made
without the guard (either using a mutex or a lock, or call the reentrant 
version getpw*_r()).

1. security/krb5/lib/os/kuserok.c, function krb5_kuserok(). But there is no
place that actually calls krb5_kuserok(). If this function is indeed not
used at all, please remove it.

2. in security/utils/sec_authn.c. Calls to getpwuid() is guarded by #ifdef
USE_GETPW_R, so if it is defined, the reentrant version of getpwuid_r() is
called, otherwise getpwuid() is called WITHOUT further guard. In the 1.0.3 
code, this happens in two fucntions: sec_krb_dg_build_message() and
sec_krb_cn_build_message. In the 1.1 code, it is in 
sec_krb_build_message_none(), which is called by sec_krb_[cn|dg]_build_message.

USE_GETPW_R is defined in security/mk for only the HP platform. That means for
AIX and OSF/1 (the reference platforms), we could get problem.

3. security/client/login/sec_login_np.c and 
security/client/login/$ARCH/sec_login_np.c

At the beginning (right after #ifdef USE_GETPW_R), it says "On OSF, we use 
the getpwnam_r routine, which is already thread safe, so we can ...". Too bad
the fact is, with OSF reference platforms, only HP-UX actually defines this
USE_GETPW_R and links with libc_r.a. AIX and OSF/1 do support the reentrant C
library, but they are not configured to use libc_r.a.

But, even USE_GETPW_R is not defined, the code seems to do the right thing by 
creating mutex to guard the use. The only thing we may want to add is for the
case when USE_GETPW_R is defined: we may define LOCK_PWD_DATA as setpwent_r and
define UNLOCK_PWD_DATA for endpwent_r.

4. Thare are other two places (client/unix_utils/su/su.c and 
client/unix_utils/login/login.c) where the getpw*() calls are made without
protection. But since these two are stand-alone code, it does not seem to be
in danger.



CR Number                     : 10983
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : registry
Short Description             : Issues with pre-created regsitry principals and groups.
Reported Date                 : 6/16/94
Found in Baseline             : 1.0.3
Found Date                    : 6/16/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/16/94 public]

SVR4 customer reported that in a split server configuration (Security server
on AIX, CDS on FTX, a SNI 1.0.3 early access), acl_edit, during name space
initialization, failed on the following entries: principal/adm, group/root,
group/other, group/adm, and group/sys. In another configuration (Security
server on FTX, SNI SVR4 DCE, CDS on AIX), acl_edit failed on the following
entries: principal/who, group/system, group/daemon, and group/kmem.

The reason of this failure is that SNI has its proprietary code in the secd
registry pre-created entries part that creates principal/group according to
SVR4 operating system accounts and groups. So it does not creates those
default principals and groups that OSF DCE creates.

SNI also modifies their dce_config script so that during the name space
initialization, acl_edit will set acls on those SNI specific principals and
groups, not OSF ones. 

This explains the reason of the above failures. Some entries simply do not
exist.

SNI believes that the pre-created DCE registry principals and groups SHOULD
reflect local OS's default accounts and groups. They view becasue of different
OS (UNIX)'s different (sometimes conflicting) uid/gid for accounts/groups, 
they need to do things specific to SVR4. Here is some comments from SNI 
(tikku@sni-usa.com (Sanjay Tikku)):

------start quoting
Well, since I put this portion of code in the SNI version of DCE let me try
and explain the situation.

There are uid/gid conflicts between system accounts of same names between
different Unix systems. Also, there are system accounts which only exist on
one or the other version of Unix out there.

I have always been of the opinion that there is no point in creating Unix
system accounts in the DCE registry but that is something that only folks
at OSF can change. 

If the system accounts are going to be there then potential for conflict is
always there between a client/server pair. What we have done by adding code
wrapped in SNI_PROPRIETARY flag is to ensure that there will be no
conflicts between SVR4 machines in a cell. If we did not do this then every
time we create a new cell there were id conflicts when the first
machine was added to the cell. 

There are two possible ways to handle this situation:

1. Get rid of Unix system accounts from the DCE registry when dce_config is
run. I have not as yet heard a convincing argument that those accounts are
needed. 

2. If those accounts cannot be removed from the registry, at this stage, for 
whatever reason then dce_config should be changed on all platforms so that
it tests the existence of a certain account (we are talking of Unix system
accounts only) before trying to set the ACLs.

------- end quoting

Personally I don't think this has anything to do with conflict uid/gid between
different OS. Those DCE pre-created principals and groups should be viewed as
DCE entries, not a map of local OS accounts and groups. In this sense, SNI
should change their code to do what other companies are doing by creating the
same set of principals and groups.

On the other hand, one can argue what is the use of these pre-created principalsand groups after all. One solution is not to create them at all, but leave to
DCE administrator to determine if he/she wants to do so.

Yet another possible solution is to create the union of all existing system
princiapals and groups.

I have concern over the number 2 suggestion from SNI, that dce_config should 
test the existence before doing acl_edit. The problem is, if dce_config does
not know the all possible entries, it may well leave some entries untested,
hence unset with acls. This may leave security holes.

If secd is changed for its creation of principals and groups at registry
startup, dce_config needs to be changed to reflect it.



CR Number                     : 10973
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : rgy_edit
Short Description             : rgy_edit could provide info on lifetime conflict
Reported Date                 : 6/15/94
Found in Baseline             : 1.0.3
Found Date                    : 6/15/94
Severity                      : C
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/15/94 public]
If you want to increase your login credential lifetime so you 
don't have to do kinit so frequently, the intuitive (but wrong) way 
to do this is to modify the principal account value Maximum Certificate
Lifetime.  An informational message from rgy_edit at this point saying
whether this value would effectively be superseded by either or both of
the cell-wide Default Certificate Lifetime or Max Certificate Lifetime
would be a helpful indication that a reading of documentation was called for.

[6/15/94 public]
There's no conflict in the case mentioned, that's how it's documented to work:
You get the default as long as the default is between the min and the max.
If you feel that it's not documented well enough, open a doc CR.  I've changed
this from a defect to an enhancement request, since your suggestion might help
those that haven't read or understood the documentation and ran into a conflict
(eg: making default larger than max or max smaller than default, not just
making the max larger and not knowing that the default will still be what's
used, as the above situation implies).

[6/16/94 public]
Since dcecp will probably be replacing rgy_edit after 1.1 this is low
priority.  Now, does dcecp do a better job?  Well the max certificate
lifetime is called maxtktlife and is a policy on the account object.
You can change the value and dcecp does not give an informational
message.  However, if you display the policies and the cell-wide default
value is stricter, you'll see that displayed:


 dcecp> account show foo -policies   # value not overridden
 {maxtktlife <value1>}

 dcecp> account show foo -policies   # value overridden by cell-wide default
 {maxtktlife <value1> effective <value2>}

I think this provides enough info for the user.  rgy_edit only displays
default info for organizations.



CR Number                     : 10941
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : Authentication.
Short Description             : Kerberos V5 and DCE compatibility.
Reported Date                 : 6/14/94
Found in Baseline             : 1.1
Found Date                    : 6/14/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/14/94 public]

This is a placeholder for compatibility work in dce 1.1 with Kerberos V5
specification.

[12/8/95 public]
KRB5 Interoperability not really supported fully until 1.2.2, so this is an
enhancement request.



CR Number                     : 10823
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : pwd strength checking
Short Description             : acct add fails if schema entry doesn't exist for pwd_val_type ERA
Reported Date                 : 6/1/94
Found in Baseline             : 1.1b9
Found Date                    : 6/1/94
Severity                      : D
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/1/94 public]
When adding an account, I get "invalid or unsupported attribute type" error.
Same result with dcecp:
    dcecp> account crea -pass yow -mypwd -dce- -group none -org none ross
    Error: invalid or unsupported attribute type
or rgy_edit:
    rgy_edit=> a ross -g none -o none -pw -ross- -mp -dce-
    ?(rgy_edit) Unable to add "ross" - invalid or unsupported attribute type\
    (dce / sec)

Setup: client on HP or 486.  Server: HP.  All BL-9.

(The rgy database was created with bl-8, I think, then I upgraded the
binaries/libs to bl-9.  Don't know if this should make a difference.)

[7/8/94 public]
The "pwd_val_type" schema entry was provided in the default database
with the bl-9 version of sec_create_db.  You must rerun sec_create_db
to avoid this problem.  I downgraded the bug because there's an available
workaround -- run the new sec_create_db.  The bug remains open because
the acct_add should not fail if the schema entry is missing.



CR Number                     : 10806
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : krb5
Short Description             : security/krb5/comerr/error_message.c:error_message() is not thread-safe.
Reported Date                 : 5/31/94
Found in Baseline             : 1.0.2
Found Date                    : 5/31/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/krb5/comerr/error_message.c
Sensitivity                   : public

[5/31/94 public]
security/krb5/comerr/error_message.c:error_message() is not thread-safe
as it uses a static buffer.  This can lead to memory corruption problems
in situations like ...
        str = error_message(code);
        cpy = malloc(strlen(str));
        strcpy(cpy, str);
... when `str' changes between the strlen() and the strcpy().  See, for
example, (Transarc's) defect AFS-5412.
Evidence of this problem was being seen in TGT_REQ and other messages
displayed by SECD -- they were getting garbled. DFS was also getting
cores dumps out of it.
Transarc's internal solution to this was to produce two additional
routines, the first of which allocates a buffer and returns it to be
freed by the caller at its leisure, and another that accepts a buffer
and buffer length from above for use in returning the text. However,
this approach does require editys to be made at all use sites of
error_message(), and unless these fixes become part of the accepted base
code, we'll have to periodically search for new instances of its use
(after each OSF code drop) and fix them; further, other vendors will be
equally inconvenienced.

[8/17/94 public]

How about changing the prototype of error_message from :

  const char * error_message (int code)

to:

  char * error_message (int code, char **msg)

The caller would be responsible for freeing the contents of msg.
Although I am wondering how important the "const" is.


[31-Aug-94 public]
priority lowered to indicate that this will not be fixed in the 1.1 mainline



CR Number                     : 10799
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : krb5
Short Description             : Symbols undefined when using ASN1_DEBUG
Reported Date                 : 5/27/94
Found in Baseline             : 1.0.3
Found Date                    : 5/27/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : krb5/lib/mvr/encode.c|decode.c
Sensitivity                   : public

[5/27/94 public]

     If you build security with the flag ASN1_DEBUG, the symbols MVR_UNLOCK,
     MVR_LOCK, and MVR_LEAKCHECK are not defined.
     In order to compile DCE with ASN1_DEBUG, I added the following lines
     to decode.c and encode.c.


 #ifdef ASN1_DEBUG
 #   define debug_printf(ARG_LIST) printf ARG_LIST
>#   define MVR_LOCK()
>#   define MVR_UNLOCK()
>#   define MVR_LEAKCHECK(x)
 #else
 #   define debug_printf(ARG_LIST)
 #   define MVR_LOCK()
 #   define MVR_UNLOCK()
 #   define MVR_LEAKCHECK(x)
 #endif

[05/27/94 public]
Isn't it better to move those three #defines outside of the #ifdef
altogether?

[5/27/94 public]
Yes, that would seem to be the obvious fix, rather than have the redundant
defines.  Somebody will get to this at some point, but I've downgraded it from
C2 to E4 since it only affects you if you're building with ASN1 debugging
turned on, which is not the normal mode of operation...

[9/6/94 public]
Currently not supporting the building of DCE with ASN1_DEBUG defined should
not be construed as a bug, but just a limitation...  I've changed this to an
enhancement request that we support building of DCE with ASN1_DEBUG defined.



CR Number                     : 10747
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : krb5/lib/os/localaddr.c
Short Description             : extraction of network
interfaces won't scale
Reported Date                 : 5/24/94
Found in Baseline             : 1.0.3
Found Date                    : 5/24/94
Severity                      : C
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/24/94 public]

Customer reported:
"In the krb5_os_localaddr() routine, (krb5/lib/os/localaddr.c),
 the logic which extracts available network interfaces is hard-coded
 to accommodate 32 such.  This is too small for our needs.  In addition,
 memory is allocated on the stack rather than malloc'd, and we suggest
 modifying this as well.

 This is identical to the problem seen in the rpc runtime
 enumerate_interfaces() routine. In fact, one wonders whether
 or not this duplication is really necessary...
"

Both 1.0.3 and 1.1 code use buf[1024] for extraction in both rpc and krb5
code.

Suggested fix (for krb5 part):

     *** /tmp/ci.24291..localaddr.c.24323.1     Wed May 18 15:12:08 1994
     --- /tmp/localaddr.c.24323.2       Wed May 18 15:12:08 1994
     ***************
     *** 18,27 ****
     --- 18,31 ----
        * src directory for the full copyright text.
        */
       /*
        * HISTORY
        * $Log:	c010747,v $
# Revision 1.6  96/06/25  10:42:44  root
# changed fields: Status  
# 
# Revision 1.5  94/08/24  13:56:43  root
# changed fields: Defect or Enhancement?  Priority  Status  Fix By Baseline  
# 
# Revision 1.4  94/08/24  13:37:59  root
# changed fields:  new/changed/deleted note(s) [max@osf.org 8/24/94 ]
# 
# Revision 1.3  94/08/11  15:49:12  root
# changed fields: Responsible Engr.  Resp. Engrs Company  
# 
# Revision 1.2  94/06/06  14:43:30  root
# changed fields: Responsible Engr.  Resp. Engrs Company  
# 
# Revision 1.1  94/05/24  11:39:09  root
# new CR
# 
     +  * Revision 7.3  1994/05/18  19:12:05  rusman
     +  * Reason:  OSDqa08190 extraction of network interfaces won't scale
     +  * make krb5_os_localaddr() scale up a bit more
     +  *
        * Revision 7.2  1993/11/16  19:34:13  rusman
        * rollup to 1.0.3-
        *
        * Revision 1.1.7.2  1993/06/24  20:19:57  hinman
        *       [hinman] - Save merged-in SNI version (these files have been freed of nasty code)
     ***************
     *** 152,177 ****
           krb5_address ***addr;
       {
           struct ifreq *ifr;
           struct ifconf ifc;
           int s, code, n, i;
           char buf[1024];
           krb5_address *addr_temp [ 1024/sizeof(struct ifreq) ];
           int n_found;
           int mem_err = 0;
     !
           ifc.ifc_len = sizeof(buf);
           ifc.ifc_buf = buf;

           s = socket (USE_AF, USE_TYPE, USE_PROTO);
     !     if (s < 0)
        return errno;

           code = ioctl (s, SIOCGIFCONF, (char *)&ifc);
           if (code < 0) {
        int retval = errno;
        close(s);
        return retval;
           }
           n = ifc.ifc_len / sizeof (struct ifreq);

           for (n_found=0, i=0; i<n && ! mem_err; i++) {
     --- 156,200 ----
           krb5_address ***addr;
       {
           struct ifreq *ifr;
           struct ifconf ifc;
           int s, code, n, i;
     + #if defined(hitm)
     + #define BUFSZ 4096
     +     uchar *buf;
     +     krb5_address *addr_temp [ BUFSZ/sizeof(struct ifreq) ];
     + #else
           char buf[1024];
           krb5_address *addr_temp [ 1024/sizeof(struct ifreq) ];
     + #endif
           int n_found;
           int mem_err = 0;
     ! #if defined(hitm)
     !     buf = (uchar *)malloc(BUFSZ*sizeof(uchar));
     !     if (!buf) return(errno);
     !     ifc.ifc_len = BUFSZ*sizeof(uchar);
     !     ifc.ifc_buf = (caddr_t) buf;
     ! #else
           ifc.ifc_len = sizeof(buf);
           ifc.ifc_buf = buf;
     + #endif

           s = socket (USE_AF, USE_TYPE, USE_PROTO);
     ! #if defined(hitm)
     !     if (s < 0) { free(buf); return errno; }
     ! #else
     !     if (s < 0)
        return errno;
     + #endif

           code = ioctl (s, SIOCGIFCONF, (char *)&ifc);
           if (code < 0) {
        int retval = errno;
        close(s);
     + #if defined(hitm)
     +  free(buf);
     + #endif
        return retval;
           }
           n = ifc.ifc_len / sizeof (struct ifreq);

           for (n_found=0, i=0; i<n && ! mem_err; i++) {
     ***************
     *** 268,283 ****
     --- 291,312 ----
           if (mem_err) {
        for (i=0; i<n_found; i++) {
            free((char *)addr_temp[i]);
            addr_temp[i] = 0;
        }
     + #if defined(hitm)
     +  free(buf);
     + #endif
        return ENOMEM;
           }

           for (i=0; i<n_found; i++) {
        (*addr)[i] = addr_temp[i];
           }
           (*addr)[n_found] = 0;
     + #if defined(hitm)
     +  free(buf);
     + #endif
           return 0;
       }

       #endif /* SNI_SVR4_TAINTED */

[8/24/94]

This should be deferred past 1.1 for two reasons.
Support for 32 network interfaces is not pressing enough,
right now.
The rpc component has exactly the same issue and it is
not dealt with in the 1.1 timeframe.

I'll make it an enhancement and defer it (to 1.2 ?) tomorrow
if nobody objects.



CR Number                     : 10719
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : security/utils/
Short Description             : Problems compiling with -D DEBUG
Reported Date                 : 5/20/94
Found in Baseline             : 1.0.3
Found Date                    : 5/20/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/20/94 public]

     There were several problems encounterd when attempting to compile the
     file with DEBUG.  Problem 1 involves a missing comma in the printf
     argument list, and also necessitated changing the Endian of the
     arguments (code enclosed for both).  Problem 2 involved a comparison
     between an int and an unisgned int.

Problem 1  (approximately line 1219)
====================================

[1.1 code, this is in seca_dg.c]

NOTE:  This fix only works if the machine in question is Big Endian.

#ifdef DEBUG
< #ifdef _FTX
< #define FTX_EXT32(p) ( (unsigned32)(*p)<<24 | (unsigned32)(*(p+1))<<16 | (unsigned32)(*(p+2))<<8 | (unsigned32)(*(p+3)) )
<       {
<       idl_byte *bp; unsigned32 i[2],j[2];
<
<       bp=challenge->bits;
<       i[0]= FTX_EXT32(bp); bp+=4;
<       i[1]= FTX_EXT32(bp);
<       bp=nonce2.bits;
<       j[0]= FTX_EXT32(bp); bp+=4;
<       j[1]= FTX_EXT32(bp);
<
<       printf("given nonce: %08x%08x; packet nonce: %08x%08x\n",
<              i[0], i[1], j[0], j[1]);
<       }
<#else
        printf("given nonce: %08x%08x; packet nonce: %08x%08x\n",
<           ((unsigned32 *)(challenge))[0], ((unsigned32 *)(challenge))[1]
---
>           ((unsigned32 *)(challenge))[0], ((unsigned32 *)(challenge))[1],

<#endif
#endif


Problem 2)  (approximately line 1645)
=====================================

	In sec_id_pac_print(), for statement:

    for (i=0; i<pac->num_groups; i++) {

Here i is of type int, but pac->num_groups is unsigned. To remove the 
compiler warning, declare i as unsigend too.

[10/3/94 public]
The above is "extra" unsupported debugging info that just isn't currently
usable.  Since we don't support building the DCE1.1 security comp with -DDEBUG
it's not a bug that this extra debugging info isn't quite right.  I've made
this an enhancement request.



CR Number                     : 10718
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : krb5/lib/crypto/common/string2key.c
Short Description             : The symbol mit_des_debug is undefined, when DEBUG enabled
Reported Date                 : 5/20/94
Found in Baseline             : 1.0.3
Found Date                    : 5/20/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/20/94 public]

     There is a misdeclared variable at the top of the file, des_debug,
     which should be mit_des_debug to compile the file with DEBUG.

     #ifdef DEBUG
     #include <stdio.h>

     80c80
     < extern int des_debug;
     ---
     > extern int mit_des_debug;

     #endif

1.1 code has the same problem.

[10/3/94 public]
We don't claim to support the building of Kerberos w/in security, with -DDEBUG
so this is not a defect in the product.  I've made this an enhancement request.



CR Number                     : 10620
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : intercell initrep and delrep fail
Reported Date                 : 5/12/94
Found in Baseline             : 1.0.3
Found Date                    : 5/12/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/12/94 public]

Intercell sec_admin initrep and delrep commands fail.
_____________________________________________________
Intercell is configured.  I've dce_logged into the foreign cell as
/.../foreign_cell/cell_admin.  I site to the slave server.

sec_admin> delrep fails to delete a slave in the foreign cell when the default
replica is the slave.

ALSO
sec_admin> initrep fails in the foreign cell when the default replica is the
slave.

When the default replica is the master, I am able to delete the replica
in the foreign cell or issue an initrep successfully. But when the
default replica is the slave replica then these commands do not work.
The following message is displayed on the master replica in the foreign cell :

sec_admin> (RPC_CN_AUTH_VFY_CLIENT_REQ) on server failed status = 14129090


It appears that something is corrupting the binding handle sec_admin
is supposed to bind to. Both initrep and delrep have the
set_default_to_master call in common although this call appears to
succeed. See OT#10588 which is also an intercell problem that may be
related to this problem.

Below is sample output from the sec_admin> delrep command:

sec_admin> site /.../texas.austin.ibm.com/subsys/dce/sec/repl1
Default replica:  /.../texas.austin.ibm.com/subsys/dce/sec/repl1
Default cell:     /.../texas.austin.ibm.com
sec_admin> delrep subsys/dce/sec/repl1

WARNING: Command requires default replica to be the master
/.../texas.austin.ibm.com/subsys/dce/sec/repl1 is not a master replica
Attempting to reset the default replica to the master now
Default replica:  /.../texas.austin.ibm.com/subsys/dce/sec/master
Default cell:     /.../texas.austin.ibm.com
Do you wish to continue (y[es]) or abort this operation (n[o])? y
Delete replica operation failed - connection closed (dce / rpc)
sec_admin>



Below is sample output from the sec_admin> initrep command:

sec_admin> site /.../texas.austin.ibm.com/subsys/dce/sec/repl1
Default replica:  /.../texas.austin.ibm.com/subsys/dce/sec/repl1
Default cell:     /.../texas.austin.ibm.com
sec_admin> initrep subsys/dce/sec/repl1

WARNING: Command requires default replica to be the master
/.../texas.austin.ibm.com/subsys/dce/sec/repl1 is not a master replica
Attempting to reset the default replica to the master now
Default replica:  /.../texas.austin.ibm.com/subsys/dce/sec/master
Default cell:     /.../texas.austin.ibm.com
Do you wish to continue (y[es]) or abort this operation (n[o])? y
Initialize replica operation failed - connection closed (dce / rpc)
sec_admin>

[8/18/94 public]
Can someone check to see if the equivalent commands work in dcecp?
If so, then this can become an E4 against "old" admin tools.

[8/18/94 public]

After a conversation with Howard, we believe that dcecp will not have the
same problem, so this is being downgraded.



CR Number                     : 10614
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_admin
Short Description             : sec_admin does not display
time in a DTS-style or locale dependent format.
Reported Date                 : 5/11/94
Found in Baseline             : 1.1
Found Date                    : 5/11/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/11/94 public]

The control program sec_admin displays the time as part of
the output of several commands. The time is not displayed 
in DTS format or locale format. According to RFC 23, all 
non-DTS style time should be converted to internationalized 
format.  

Example: Using the japanese.euc locale, here is the output
of sec_admin.

# echo $LANG
japanese.euc
#
#sec_admin> monitor
Default replica:  /.../b_cell.qadce.osf.org/subsys/dce/sec/master
Default cell:     /.../b_cell.qadce.osf.org

subsys/dce/sec/master (master)
          State:                   in service - master
          Last update received at: Tue May 10 10:18:17 1994
          Last update's seqno:     0.211
sec_admin> info 

Default replica:  /.../b_cell.qadce.osf.org/subsys/dce/sec/master
Default cell:     /.../b_cell.qadce.osf.org
          State:                   in service - master
          Last update received at: Tue May 10 10:18:17 1994
          Last update's seqno:     0.211
sec_admin>

[7/27/94 public]
This CR either does not affect dcecp or has a related CR open.
It really belongs to sec_admin and should not be assigned to dcecp.

[8/1/94 public]
All control program bugs are being changed to E4 due to the existance
of dcecp.

[12/21/95 public]
sec_admin was never designed to do this and we have no intention of doing
this at this time.  It remains in the build tree solely for backwards
compatibility with existing customer scripts...   Any new functionality
should be added to dcecp.  I've changed this to an enhancement request
in case anybody else wants to do this work themselves (only if done with
a new cmd line argument, so that the default behavior remains backwards
compatible).



CR Number                     : 10588
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : sec_admin inter-cell functionality
Reported Date                 : 5/9/94
Found in Baseline             : 1.0.3
Found Date                    : 5/9/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/9/94 public]

There are numerous problems when using sec_admin to do intercell
manipulations.

I first log into the foreign cell.  I invoke sec_admin and then
site to the foreign cell.

A sec_admin> lrep -all command does not return state information.  I
believe this is due to the code having "/.:" hard-coded as a parameter -
it returns a:

subsys/dce/sec/master (master)
          Instance id: 006f7c00-9533-1d4d-9a5a-10005aa8bb82
          Addresses:               ncacn_ip_tcp:129.35.68.58[]
                                   ncadg_ip_udp:129.35.68.58[]
                    State:         unavailable - connection closed (dce / rpc)

The state is unavailable, I believe, due to the rgyh being used with a
local cell cellname and a foreign cell site name.  Any attempt to pass as input
the foreign cell name (either hard-coded or received as output from
sec_rgy_site_binding_get_info call) causes sec_admin to core dump.


This type of behavior also occurs when doing a sec_admin> state -m
or sec_admin> state -s command.

On the foreign cell the following error message is displayed:

(RPC_CN_AUTH_VFY_CLIENT_REQ) on server failed status = 14129090

The rgy_edit cell command dumps core in 1.1.

[ mob 8/18/94 public ]
Can someone check to see if the equivalent commands in dcecp work?
If so, this can be changed to an E4 against the "old" admin commands.

[8/18/94 public]
After a conversation with Howard, we believe that dcecp will not have the
same problem, so this is being downgraded.

[3/11/96 public]
sec_admin was never meant to administer foreign cells, so this is really
an enhancement request.  Admins should really be using dcecp now, since
sec_admin is an obsolete tool.  Moved to the enhancement category.



CR Number                     : 10536
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : sec_id API
Short Description             : stale name cache -- missed hints?
Reported Date                 : 5/4/94
Found in Baseline             : 1.0.2
Found Date                    : 5/4/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/4/94 public]
  Taken directly from the external report we received:
.
> RPC code seems to check principal names rather than UUIDs when
> checking accuracy of connections cached in the credentials file.
> Resulting in communication errors when server's principal is deleted
> and recreated.
>
> I start a Encina logserver with a principal 'A', I then issues
> commands to it via 'logadmin' a client program of the logserver.  My
> local credentials files therefore caches the connection to the
> principal 'A'.  If however I stop the server, remove its principal and
> then create a new principal also named 'A' and then restart the server
> using this new principal 'A', I can not talk to the logserver unless I
> kdestroy and dce_login again, because my credentials file has the old
> A in its cache and does not detect the change.  This same problem
> shows up in a more serious place as well.
>
> The Encina monitor has a node manager which is a deamon process which
> starts and stops Encina applications that customers write.  The server
> too has a credentials file and if a user starts an application server
> with a pricipal name 'A', stops the server, destroys the principal,
> recreates the principal 'A' and tries to have the node manager start
> the server again it will not start up.  Unfortunatly the node manager
> does not display an error and just keeps trying to restart the
> application, over and over and over...  The only way around this is to
> stop the node manager which then shuts down all applications on that
> node.



CR Number                     : 10528
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : krb5_read_password()
Short Description             : kinit requires controlling terminal
Reported Date                 : 5/4/94
Found in Baseline             : 1.0.2
Found Date                    : 5/4/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/4/94 public]
  Like many other password readers, the library routine used by KRB
to collect passwords from the user go out of their way to ensure that
they are talking to a terminal. In KRB's case, it isn't that it goes out
the way, it's just plain that the way was built on the assumption that the
input device was a terminal.
  A testing script here tried to pipe the password into 'kinit' in order
to ensure a given amount of time remained within the lifetime of the
script's inherited context. The result:
.
        kinit: Invalid argument while getting initial credentials
.
  I understand all the motivations behind keeping passwords off of
command lines -- I agree with those motivations. But with more and more
tests being written in PERL and things like TCL, there's a growing
reliance on being able to write any test without invoking a compiler
(sigh). With no access to the Security API, such a test wants to use
'kinit' to rejuvenate its credentials before it starts a pass in a test.
It was pointed out that 'dce_login' accepts the '-e' option, but
dce_login spawns a new shell with a new PAG, and for DFS testing this is
a liability (I am told). So 'kinit' was flagged as having a bug, a bug
in which it will not read stdin for the password if there is no
controlling tty.
.
  My initial attempt to solve this is diff'd below. I passed a
stripped-down copy of the reader down through the chain of command if
kinit is run with a new option (-P for pipe, capitalized to reduce the
chance of conflict with any future flags). We didn't take this route,
and this diff is (for us) deadwood, unless the OSF likes it and accepts
it as common code.
.
  Other options we have considered would be to just simply jump around
all the terminal control after using isatty() or ioctl() to determine
whether or not there's a pipe on stdin... 
.
------------------------------------------------------------------
------------------------------------------------------------------
------------------------------------------------------------------
Checked-out CML/delta/travis-tr10732-kinit-gets-a-pipe-option, revision
1.1 Delta: travis-tr10732-kinit-gets-a-pipe-option Change:
security/krb5/clients/kinit/kinit.c from 9.2 to 9.3
=================================================================== RCS
file:
/afs/tr/project/dce/dev/rcs/security/krb5/clients/kinit/RCS/kinit.c,v
retrieving revision 9.2 retrieving revision 9.3 diff
-Lsecurity/krb5/clients/kinit/kinit.c -c -r9.2 -r9.3 ***
security/krb5/clients/kinit/kinit.c --- 9.3	1994/02/10 19:17:25
*************** *** 2,7 **** --- 2,23 ----
   * @TRANSARC_COPYRIGHT@
   *
   * $TALog: kinit.c,v $
+  * Revision 9.3  1994/02/10  19:17:25  travis
+  *   Add an ability for krb5_process_as_reply to read the incoming
+  *   (user-supplied) password on a non-terminal device (stdin as a pipe,
+  *   for example).
+  *
+  *   Add a -P flag (for -Pipe) to inform the logic to pass
+  *   a different "getkey" function into the KRB5 AS works.
+  *
+  *   Update the usage message to include the new flag.
+  *
+  *   Bring in the (unexported, by historical precedence) get-key
+  *   function's signature.
+  *
+  *   Pass the new get-key'er into KRB5 if the -P option was found.
+  * [from r9.2 by delta travis-tr10732-kinit-gets-a-pipe-option, r1.1]
+  *
   * Revision 9.2  1993/09/25  21:19:30  travis
   *   Watch time intervals more closely to reject illegal units.
   *
***************
*** 16,22 ****
   */
  
  #if !defined(_NOIDENT) && !defined(lint)
! static char *TARCSId = "$Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $";
  #endif
  
  /*
--- 32,38 ----
   */
  
  #if !defined(_NOIDENT) && !defined(lint)
! static char *TARCSId = "$Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $";
  #endif
  
  /*
***************
*** 91,97 ****
  
  #if !defined(lint) && !defined(SABER)
  static char rcsid_kinit_c [] =
! "$Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $";
  #endif  /* !lint & !SABER */
  
  #include <stdio.h>
--- 107,113 ----
  
  #if !defined(lint) && !defined(SABER)
  static char rcsid_kinit_c [] =
! "$Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $";
  #endif  /* !lint & !SABER */
  
  #include <stdio.h>
***************
*** 311,316 ****
--- 327,342 ----
  #endif
  );
  
+ /*  declaration of string password keyproc defined in in_tkt_pwd.c */
+ krb5_error_code  pwd_keyproc_pipe (
+ #ifdef __STDC__ 
+      krb5_keytype  type,
+      krb5_keyblock ** key,
+      krb5_const_pointer keyseed,
+      krb5_pa_data ** padata
+ #endif
+ );
+ 
  void
  main(argc, argv)
      int argc;
***************
*** 321,326 ****
--- 347,353 ----
      long lifetime = KRB5_DEFAULT_LIFE;  /* -l option */
      long rlife = 0;
      long verbose = 0;           /* -v option */
+     long piping = 0;		/* -P option */
      int options = KRB5_DEFAULT_OPTIONS;
      int option;
      int errflg = 0;
***************
*** 345,351 ****
      if (strrchr(argv[0], '/'))
          argv[0] = strrchr(argv[0], '/')+1;
  
!     while ((option = getopt(argc, argv, "vr:fpl:c:")) != EOF) {
          switch (option) {
          case 'r':
              options |= KDC_OPT_RENEWABLE;
--- 372,378 ----
      if (strrchr(argv[0], '/'))
          argv[0] = strrchr(argv[0], '/')+1;
  
!     while ((option = getopt(argc, argv, "vr:fpl:c:P")) != EOF) {
          switch (option) {
          case 'r':
              options |= KDC_OPT_RENEWABLE;
***************
*** 358,363 ****
--- 385,392 ----
          case 'v':
              verbose++;
              break;
+         case 'P':
+             piping++;
          case 'p':
              options |= KDC_OPT_PROXIABLE;
              break;
***************
*** 406,412 ****
      }
      
      if (errflg) {
!         fprintf(stderr, "Usage: %s [ -r time ] [ -vpf ] [ -l lifetime ] [ -c cachename ] principal\n", argv[0]);
          exit(2);
      }
      if (ccache == NULL) {
--- 435,441 ----
      }
      
      if (errflg) {
!         fprintf(stderr, "Usage: %s [ -r time ] [ -vpfP ] [ -l lifetime ] [ -c cachename ] principal\n", argv[0]);
          exit(2);
      }
      if (ccache == NULL) {
***************
*** 472,478 ****
                                       options, 
                                       my_addresses, 
                                       KEYTYPE_DES, 
!                                      pwd_keyproc, 
                                       &keyseed,
                                       krb5_kdc_rep_decrypt_proc, 0,
                                       &my_creds, 
--- 501,507 ----
                                       options, 
                                       my_addresses, 
                                       KEYTYPE_DES, 
!                                      piping ? pwd_keyproc_pipe : pwd_keyproc, 
                                       &keyseed,
                                       krb5_kdc_rep_decrypt_proc, 0,
                                       &my_creds, 
Delta: travis-tr10732-kinit-gets-a-pipe-option
Change: security/krb5/include/krb5/los-proto.h from 9.1 to 9.2
===================================================================
RCS file: /afs/tr/project/dce/dev/rcs/security/krb5/include/krb5/RCS/los-proto.h,v
retrieving revision 9.1
retrieving revision 9.2
diff -Lsecurity/krb5/include/krb5/los-proto.h -c -r9.1 -r9.2
*** security/krb5/include/krb5/los-proto.h
--- 9.2	1994/02/10 19:17:28
***************
*** 1,3 ****
--- 1,21 ----
+ /*-
+  * @TRANSARC_COPYRIGHT@
+  *
+  * $TALog: los-proto.h,v $
+  * Revision 9.2  1994/02/10  19:17:28  travis
+  *   Add an ability for krb5_process_as_reply to read the incoming
+  *   (user-supplied) password on a non-terminal device (stdin as a pipe,
+  *   for example).
+  *
+  *   Export the new routine "krb5_load_password", which mocks
+  *   the function of "krb5_read_password" with the exception
+  *   of not echoing anything to stdout/stderr and of not
+  *   doing any terminal control whatsoever.
+  * [from r9.1 by delta travis-tr10732-kinit-gets-a-pipe-option, r1.1]
+  *
+  * $EndTALog$
+  */
+ 
  /*
   * @OSF_COPYRIGHT@
   * COPYRIGHT NOTICE
***************
*** 28,35 ****
  */
  /*
   * $Source: /project/ot/dce/d01/d05/RCS/c010528,v $
!  * $Author: root $
!  * $Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $
   *
   * Copyright 1990,1991 by the Massachusetts Institute of Technology.
   * All Rights Reserved.
--- 46,53 ----
  */
  /*
   * $Source: /project/ot/dce/d01/d05/RCS/c010528,v $
!  * $Author: root $
!  * $Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $
   *
   * Copyright 1990,1991 by the Massachusetts Institute of Technology.
   * All Rights Reserved.
***************
*** 59,64 ****
--- 77,88 ----
  
  #include <stdio.h>
  
+ /* Transarc addition for passing passwords through non-ttys */
+ krb5_error_code krb5_load_password
+ 	PROTOTYPE((char *,
+ 		   char *,
+ 		   char *,
+ 		   int * ));
  /* libos.spec */
  krb5_error_code krb5_read_password
  	PROTOTYPE((char *,
Delta: travis-tr10732-kinit-gets-a-pipe-option
Change: security/krb5/lib/krb/in_tkt_pwd.c from 9.1 to 9.2
===================================================================
RCS file: /afs/tr/project/dce/dev/rcs/security/krb5/lib/krb/RCS/in_tkt_pwd.c,v
retrieving revision 9.1
retrieving revision 9.2
diff -Lsecurity/krb5/lib/krb/in_tkt_pwd.c -c -r9.1 -r9.2
*** security/krb5/lib/krb/in_tkt_pwd.c
--- 9.2	1994/02/10 19:17:31
***************
*** 1,3 ****
--- 1,28 ----
+ /*-
+  * @TRANSARC_COPYRIGHT@
+  *
+  * $TALog: in_tkt_pwd.c,v $
+  * Revision 9.2  1994/02/10  19:17:31  travis
+  *   Add an ability for krb5_process_as_reply to read the incoming
+  *   (user-supplied) password on a non-terminal device (stdin as a pipe,
+  *   for example).
+  *
+  *   Create a common routine which is the embodiment of the old
+  *   get_keyproc. Use this common routine to implement get_keyproc
+  *   as a simple jacket of this new routine. Also use the new common
+  *   routine as the underlying logic beneath a new get-key routine
+  *   which differs only in that it knows to call krb5_load_password()
+  *   instead of krb5_read_password(); this is useful when the calling
+  *   application is not using a "terminal" for stdin.
+  * [from r9.1 by delta travis-tr10732-kinit-gets-a-pipe-option, r1.1]
+  *
+  * $EndTALog$
+  */
+ 
+ #if !defined(_NOIDENT) && !defined(lint)
+ static char *TARCSId = "$Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $";
+ #endif
+ 
  /*
   * @OSF_COPYRIGHT@
   * COPYRIGHT NOTICE
***************
*** 28,34 ****
  */
  /*
   * $Source: /project/ot/dce/d01/d05/RCS/c010528,v $
!  * $Author: root $
   *
   * Copyright 1990,1991 by the Massachusetts Institute of Technology.
   * All Rights Reserved.
--- 53,59 ----
  */
  /*
   * $Source: /project/ot/dce/d01/d05/RCS/c010528,v $
!  * $Author: root $
   *
   * Copyright 1990,1991 by the Massachusetts Institute of Technology.
   * All Rights Reserved.
***************
*** 54,60 ****
  
  #if !defined(lint) && !defined(SABER)
  static char rcsid_in_tkt_pwd_c[] =
! "$Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $";
  #endif	/* !lint & !SABER */
  
  #include <krb5/krb5.h>
--- 79,85 ----
  
  #if !defined(lint) && !defined(SABER)
  static char rcsid_in_tkt_pwd_c[] =
! "$Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $";
  #endif	/* !lint & !SABER */
  
  #include <krb5/krb5.h>
***************
*** 76,90 ****
   *      libdce
   */
  
  krb5_error_code
! pwd_keyproc(DECLARG(const krb5_keytype, type),
! 	    DECLARG(krb5_keyblock **, key),
!             DECLARG(krb5_const_pointer, keyseed),
!             DECLARG(krb5_pa_data **,padata))
  OLDDECLARG(const krb5_keytype, type)
  OLDDECLARG(krb5_keyblock **, key)
  OLDDECLARG(krb5_const_pointer, keyseed)
  OLDDECLARG(krb5_pa_data **,padata)
  {
      krb5_data salt;
      krb5_error_code retval;
--- 101,126 ----
   *      libdce
   */
  
+ /* The additional argument specifying the function that will actually
+  * put the 'keystrokes' of the password together takes the following
+  * form (a duplicate of the signature for krb5_read_password).
+  */
+ typedef krb5_error_code (*assemble_password) PROTOTYPE((char *,
+ 							char *,
+ 							char *,
+ 							int *));
+ static
  krb5_error_code
! pwd_keyproc_common(DECLARG(const krb5_keytype, type),
!                    DECLARG(krb5_keyblock **, key),
!                    DECLARG(krb5_const_pointer, keyseed),
!                    DECLARG(krb5_pa_data **,padata),
! 		   DECLARG(assemble_password, keyreader))
  OLDDECLARG(const krb5_keytype, type)
  OLDDECLARG(krb5_keyblock **, key)
  OLDDECLARG(krb5_const_pointer, keyseed)
  OLDDECLARG(krb5_pa_data **,padata)
+ OLDDECLARG(assemble_password, keyreader)
  {
      krb5_data salt;
      krb5_error_code retval;
***************
*** 121,129 ****
      }
  
      if (!arg->password.length) {
! 	if (retval = krb5_read_password(krb5_default_pwd_prompt1,
! 					0,
! 					pwdbuf, &pwsize)) {
  	    if (f_salt) xfree(salt.data);
  	    return retval;
  	}
--- 157,165 ----
      }
  
      if (!arg->password.length) {
! 	if (retval = (keyreader)(krb5_default_pwd_prompt1,
! 				 0,
! 				 pwdbuf, &pwsize)) {
  	    if (f_salt) xfree(salt.data);
  	    return retval;
  	}
***************
*** 149,154 ****
--- 185,218 ----
      if (f_salt) xfree(salt.data);
      return 0;
  }
+ 
+ krb5_error_code
+ pwd_keyproc(DECLARG(const krb5_keytype, type),
+             DECLARG(krb5_keyblock **, key),
+             DECLARG(krb5_const_pointer, keyseed),
+             DECLARG(krb5_pa_data **,padata))
+ OLDDECLARG(const krb5_keytype, type)
+ OLDDECLARG(krb5_keyblock **, key)
+ OLDDECLARG(krb5_const_pointer, keyseed)
+ OLDDECLARG(krb5_pa_data **,padata)
+ {
+   return pwd_keyproc_common(type, key, keyseed, padata, krb5_read_password);
+ }
+ 
+ krb5_error_code
+ pipe_pwd_keyproc(DECLARG(const krb5_keytype, type),
+                  DECLARG(krb5_keyblock **, key),
+                  DECLARG(krb5_const_pointer, keyseed),
+                  DECLARG(krb5_pa_data **,padata))
+ OLDDECLARG(const krb5_keytype, type)
+ OLDDECLARG(krb5_keyblock **, key)
+ OLDDECLARG(krb5_const_pointer, keyseed)
+ OLDDECLARG(krb5_pa_data **,padata)
+ {
+   return pwd_keyproc_common(type, key, keyseed, padata, krb5_load_password);
+ }
+ 
+ 
  
  /*
   Attempts to get an initial ticket for creds->client to use server
Delta: travis-tr10732-kinit-gets-a-pipe-option
Change: security/krb5/lib/os/read_pwd.c from 9.2 to 9.3
===================================================================
RCS file: /afs/tr/project/dce/dev/rcs/security/krb5/lib/os/RCS/read_pwd.c,v
retrieving revision 9.2
retrieving revision 9.3
diff -Lsecurity/krb5/lib/os/read_pwd.c -c -r9.2 -r9.3
*** security/krb5/lib/os/read_pwd.c
--- 9.3	1994/02/10 19:17:34
***************
*** 2,7 ****
--- 2,18 ----
   * @TRANSARC_COPYRIGHT@
   *
   * $TALog: read_pwd.c,v $
+  * Revision 9.3  1994/02/10  19:17:34  travis
+  *   Add an ability for krb5_process_as_reply to read the incoming
+  *   (user-supplied) password on a non-terminal device (stdin as a pipe,
+  *   for example).
+  *
+  *   Implement the new routine "krb5_load_password", which mocks
+  *   the function of "krb5_read_password" with the exception
+  *   of not echoing anything to stdout/stderr and of not
+  *   doing any terminal control whatsoever.
+  * [from r9.2 by delta travis-tr10732-kinit-gets-a-pipe-option, r1.1]
+  *
   * Revision 9.2  1993/06/23  13:30:14  aswini
   * [merge of changes from 8.1 to 8.2 into 9.1]
   *
***************
*** 9,15 ****
   */
  
  #if !defined(_NOIDENT) && !defined(lint)
! static char *TARCSId = "$Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $";
  #endif
  
  /*
--- 20,26 ----
   */
  
  #if !defined(_NOIDENT) && !defined(lint)
! static char *TARCSId = "$Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $";
  #endif
  
  /*
***************
*** 50,56 ****
   */
  /*
   * $Source: /project/ot/dce/d01/d05/RCS/c010528,v $
!  * $Author: root $
   *
   * Copyright 1990,1991 by the Massachusetts Institute of Technology.
   * All Rights Reserved.
--- 61,67 ----
   */
  /*
   * $Source: /project/ot/dce/d01/d05/RCS/c010528,v $
!  * $Author: root $
   *
   * Copyright 1990,1991 by the Massachusetts Institute of Technology.
   * All Rights Reserved.
***************
*** 77,83 ****
  
  #if !defined(lint) && !defined(SABER)
  static char rcsid_read_pwd_c[] =
! "$Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $";
  #endif	/* lint */
  
  #include <krb5/krb5.h>
--- 88,94 ----
  
  #if !defined(lint) && !defined(SABER)
  static char rcsid_read_pwd_c[] =
! "$Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $";
  #endif	/* lint */
  
  #include <krb5/krb5.h>
***************
*** 326,328 ****
--- 337,509 ----
  
      return 0;
  }
+ 
+ 
+ /* This macro becomes straightforward when term. control is removed.
+  * It's only used where mutiple statements are expected; a do {} while ()
+  * would provoke "statement not reached" warnings.
+  */
+ 
+ #undef  cleanup
+ #define cleanup(errcode) (void) signal(SIGINT, ointrfunc); return errcode;
+ 
+ /* Reiterate the actions of read_password, without sending anything
+  * to stdout/err, and using the prompts more as booleans to direct whether
+  * or not to confirm the sent password. Expect the password on stdin.
+  */
+ krb5_error_code
+ krb5_load_password(prompt, prompt2, return_pwd, size_return)
+ char *prompt;
+ char *prompt2;
+ char *return_pwd;
+ int *size_return;
+ {
+     /* adapted from Kerberos v4 des/read_password.c */
+ #if defined(__STDC__) || defined(mips)
+     /* readin_string is used after a longjmp, so must be volatile */
+     volatile
+ #endif
+              char *readin_string = 0;
+     register char *ptr;
+     int scratchchar;
+     krb5_sigtype (*ointrfunc)();
+ #ifdef apollo
+     char ch, *ch_p;
+ #endif
+ 
+ #if defined(SNI_SVR4_POSIX) || defined(SUNOS5)
+     if (sigsetjmp(pwd_jump,1))
+ #else
+     if (setjmp(pwd_jump))
+ #endif
+     {
+ 	/* interrupted */
+ 	if (readin_string) {
+ 	    (void) memset((char *)readin_string, 0, *size_return);
+ 	    xfree(readin_string);
+ 	}
+ 	(void) memset(return_pwd, 0, *size_return);
+ 	cleanup(KRB5_LIBOS_PWDINTR);
+     }
+     /* save intrfunc */
+ #if defined(SNI_SVR4_POSIX) || defined(SUNOS5)
+     /*
+      *   FIX-ME:
+      *       It would be desirable to use sigaction(2) here but
+      *   the current implementation of DCE pthreads does not
+      *   allow sigaction to be used with asynchronous signals.
+      *
+      *   sigset(2) is used here because, unlike signal(2),
+      *   it blocks the signal within the interrupt handler
+      *   and does not set its disposition to SIG_DFL.
+      *   It also restores the signal mask that was in effect
+      *   after exiting the signal handler.
+      */
+     if ( (ointrfunc = sigset(SIGINT, intr_routine)) == SIG_ERR )
+ 		{
+ 		perror("sigset: intr_routine");
+ 		exit(1);
+ 		}
+ #else
+     ointrfunc = signal(SIGINT, intr_routine);
+ #endif
+ 
+     /* Since this isn't a terminal, no need to put out the prompt */
+ 
+     (void) memset(return_pwd, 0, *size_return);
+ 
+ #ifdef apollo
+     ch_p = return_pwd;
+     while ((ch = fgetc(stdin)) != '\n'  &&  ch != '\r'  &&  ch != EOF ) {
+         *ch_p++ = ch;
+     }
+ #else
+     if (fgets(return_pwd, *size_return, stdin) == NULL) {
+ 	/* error */
+ 	(void) memset(return_pwd, 0, *size_return);
+ 	cleanup(KRB5_LIBOS_CANTREADPWD);
+     }
+ #endif
+     /* fgets always null-terminates the returned string */
+ 
+     /* replace newline with null */
+     if (ptr = strchr(return_pwd, '\n'))
+ 	*ptr = '\0';
+ #ifndef apollo
+     else /* flush rest of input line */
+ 	do {
+ 	    scratchchar = getchar();
+ 	} while (scratchchar != EOF && scratchchar != '\n');
+ #endif /* apollo */
+ 
+     if (prompt2) {
+ 	/* Mock the read-password behavior, but don't put out the prompt */
+ 	readin_string = malloc(*size_return);
+ 	if (!readin_string) {
+ 	    (void) memset(return_pwd, 0, *size_return);
+ 	    cleanup(ENOMEM);
+ 	}
+ 	(void) memset((char *)readin_string, 0, *size_return);
+ #ifdef apollo
+         ch_p = readin_string;
+         while ((ch = fgetc(stdin)) != '\n'  &&  ch != '\r'  &&  ch != EOF ) {
+                 *ch_p++ = ch;
+         }
+ #else
+ 	if (fgets((char *)readin_string, *size_return, stdin) == NULL) {
+ 	    /* error */
+ 	    (void) memset((char *)readin_string, 0, *size_return);
+ 	    (void) memset(return_pwd, 0, *size_return);
+ 	    xfree(readin_string);
+ 	    cleanup(KRB5_LIBOS_CANTREADPWD);
+ 	}
+ #endif /* apollo */
+ 
+ 	if (ptr = strchr((char *)readin_string, '\n'))
+ 	    *ptr = '\0';
+ #ifndef apollo
+         else /* need to flush */
+ 	    do {
+ 		scratchchar = getchar();
+ 	    } while (scratchchar != EOF && scratchchar != '\n');
+ #endif /* apollo */
+ 	    
+ 	/* compare */
+ 	if (strncmp(return_pwd, (char *)readin_string, *size_return)) {
+ 	    (void) memset((char *)readin_string, 0, *size_return);
+ 	    (void) memset(return_pwd, 0, *size_return);
+ 	    xfree(readin_string);
+ 	    cleanup(KRB5_LIBOS_BADPWDMATCH);
+ 	}
+ 	(void) memset((char *)readin_string, 0, *size_return);
+ 	xfree(readin_string);
+     }
+     
+     /* reset intrfunc */
+ #if defined(SNI_SVR4_POSIX) || defined(SUNOS5)
+     /*
+      *   FIX-ME:
+      *       It would be desirable to use sigaction(2) here but
+      *   the current implementation of DCE pthreads does not
+      *   allow sigaction to be used with asynchronous signals.
+      *
+      *   sigset(2) is used here because, unlike signal(2),
+      *   it blocks the signal within the interrupt handler
+      *   and does not set its disposition to SIG_DFL.
+      *   It also restores the signal mask that was in effect
+      *   after exiting the signal handler.
+      */
+     if ( sigset(SIGINT, ointrfunc) == SIG_ERR )
+ 		{
+ 		perror("sigset: ointrfunc");
+ 		exit(1);
+ 		}
+ #else
+     (void) signal(SIGINT, ointrfunc);
+ #endif
+ 
+     *size_return = strlen(return_pwd);
+ 
+     return 0;
+ }
+

[8/11/94 public]
I definately don't understand all that happens here, but does the login
command in dcecp make this easier?  In a dcecp session you can DCE login as
another user using the dcecp login command.  Then for that dcecp session
you are that user.  There is a corresponding logout command and yes they
nest. We write dcecp scripts all the time that:

   login cell_admin -password -dce-

   stuff

   logout
   exit

Yes we know that these "setuid" scripts are bad, we run them as tests.  If
you don't like imbeding the password in the script you can use builtin Tcl
command to ask the user, read it from a file, get if from a command line
argument, etc.  Just a thought.

[8/23/94 public]

Is this still of interest ?  I think that if we are going to change kinit
at all we should keep the interface as consistent with dce_login as
possible, that is allow passing the passwd on the command line.  Different
usage will feel very idiosyncratic.

[3/11/96 public]
Downgraded to E4, since this functionality is now available with "dce_login -r"
which is what should be used to refresh DCE credentials anyway.  Made it an
enhancement request to improve kinit, in case anybody wants to do it.



CR Number                     : 10507
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : acl_edit
Short Description             : acl_edit entry length in 'assign' cmd could be unlimited
Reported Date                 : 5/2/94
Found in Baseline             : 1.0.3
Found Date                    : 5/2/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/admin/acl_edit/deif.c
Sensitivity                   : public

[5/2/94 public]
I should be shot for this one :-(  For some unknown reason, when acl_edit was
first written years ago (ok, so I was a rookie, shoot me) I made the (now bad)
assumption that an acl entry would never be more than 256 characters, so when
the acl_edit 'assign' command reads entries in from a file, it only uses a
buffer of max size 256.  If someone else had made a mistake like this I'd be
really upset, but as it is, all I can do is sulk and fix it...

This means that old (1.0.x) acl_edit's will not be able to 'assign' extended
entry types from a file, that correspond to the encoded entry types that DCE1.1
will be passing back to 1.0.x clients.  1.0.x acl_edit's will still be able
to lookup, change other entries and replace 1.1 ACLs, they just won't be able
to write them to a file, edit the file and assign the ACL from that file (not
a common thing to do, but it is broken...  (you get invalid extended entry type
when you try to do the assign because it's missing part of the entry).

For those that want to patch their 1.0.x products, change the buffer size of
sec_acl_entry_str in deif_sec_acl_from_file() to something more reasonable than
256 (the biggest entry I've seen is 276, but they could be much larger if you
had an extra long cellname/principal name in the DCE1.1 entry).  The simplest
fix is to change it to 1024 (bigger than anything we currently know of), but
it probably should be fixed so that it does the right thing in the future (so
we don't hit this again when another unforseen change causes entries larger
than 1024 chars).

[7/14/94 public]
Well, the code has been fixed for a while now to use a 1024 buffer instead of
256, so the problem no longer exists...  I've changed this to an enhancement
request that acl_edit not have this hard limit, in case future changes would
exceed 1024 chars.  I assume it might not be implemented in acl_edit, since
acl_edit will eventually go away completely once people stop using it in favor
of dcecp, but I wanted to leave this as an open enh CR so that vendors would 
know that they could make this change if they felt that acl_edit was going to
be in use for a long enough period of time to warrant working on this...

[7/14/94 public]
Moved to dcecp component for Howard to look at prior to setting status
to defer to 1.2  (dcecp now performs most functions of the control programs)

[7/15/94 public]
Moved back to sec/enhancement for reasons described by Mike above.

[7/15/94 public]
Just to confirm. This doesn't apply to dcecp acl support.

[8/1/94 public]
All control program bugs are being changed to E4 due to the existance
of dcecp.



CR Number                     : 10498
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : krb5
Short Description             : krb5_lock_file returns errno
Reported Date                 : 5/2/94
Found in Baseline             : 1.0.2
Found Date                    : 5/2/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : ktf_util.c,others?
Sensitivity                   : public

[5/2/94 public]
    In dce102, sec_key_mgmt_get_key() can and does return (undocumented)
system error codes when the supplied keyfile (arg) does not refer to an
extant file, or when a lock conflict is encountered.
    Comparing this against the 103 sources, this problem still exists.
While one obvious workaround is to add a call to ktf_convert() within
krb5_ktfileint_openr() and krb5_ktfileint_open(), this does not address
the situation where fcntl() (in krb5_lock_file()) has returned EAGAIN.
In this case, the OSF base code should either convert that error into a
KRB error code, or take some action to retry the lock. There are pros
and cons for both approaches, so I haven't gone and tried either; I hope
to learn what the OSF base product will do in this case.



CR Number                     : 10308
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 10263
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : app_ref
Short Description             : add sec_rgy_bind_from_towerv
Reported Date                 : 4/6/94
Found in Baseline             : 1.0.3
Found Date                    : 4/6/94
Severity                      : D
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/6/94 public]

notes:
    <Note by yarsa (Julianne Yarsa), 93/08/26 12:47:57, action: open>
Need security manpage for sec_rgy_bind_from_towerv (Appl Dev Ref)

[4/11/94 public]
sec_rgy_bind_from_towerv() is declared in binding.idl along with the 
other public binding management routines. Since this interface is
exposed to applications, it should be documented appropriately.

I've recently learned (from Rob Stanzel) that sec_rgy_bind_from_towerv() 
was (is?) intended to be a private interface.  If so, it should not be
declared in binding.idl, but rather in a non-exported/non-installed file.
In that case it need not be documented.

[4/18/94 public]

I'm assigning this CR to Pam Millett (HP security writer) so
that she can coordinate with Rob Stanzel on whether this is
a doc CR (document routine) or code CR (move routine from public
declaration).

[4/18/94]

Added a cross-reference to CR10263 (document tower APIs)
per Hal's suggestion.

[8/29/94 public]
Changed status to defer and priority to 4 after consultation with 
rps and pato.

[6/30/95 public]

Re-assigned for DCE 1.2.



CR Number                     : 10295
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : dce_login
Short Description             : dce_login -e should purge creds when done
Reported Date                 : 4/5/94
Found in Baseline             : 1.0.3
Found Date                    : 4/5/94
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/dce_login/dce_login.c
Sensitivity                   : public

[4/5/94 public]
dce_login -e may exec a shell script or binary, with the credentials that it
creates.  It should purge these when done (the script or binary shouldn't
have to know to do it; the -e option was added so that they wouldn't have to
know to log in...).   Not doing this means that a lot of tests using this
option will  not be able to clean up creds and thus fill your disk (preventing
any real scalability testing...).

[4/5/94 public]
Oops, as Greg pointed out, dce_login is doing an exec of the -e'd binary
so it's not going to be around to clean up the credentials when the binary
is done.  Cancelled this CR.

[4/5/94 public]
Yo yo time...  I was misinformed, dce_login can and does call fork in the
normal case, so it should be able to clean up when the child exits (both in
the normal case and in the -e case).  Cancelled the cancel (reopened it).



CR Number                     : 10267
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : rgy_edit
Short Description             : rgy_edit ask for passwd just once
Reported Date                 : 4/1/94
Found in Baseline             : 1.1b3
Found Date                    : 4/1/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/1/94 public]
Rgy_edit ktadd asks for the user's password twice (to guard against the
"unattended seat" attack).  It needs to ask for that password only once.

[6/6/94 public]

"unattended seat" attack?  Huh?

The double-entry is to guard the liklihood of "stupid typo" during entry.

ktadd puts a copy of the password you typed in key-crunched form into the
file.

It does not check the key against the registry; if you get the password
wrong at that point, it will just put garbage in the file.



CR Number                     : 10058
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : passwd_import
Short Description             : Password visible on command line.
Reported Date                 : 3/2/94
Found in Baseline             : 1.1b3
Found Date                    : 3/2/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/2/94 public]
The passwd_import command takes a password on the (shell) command line.
This is a security hole, since command lines can be displayed by the ps
command.

Note that the dce_login command has the same problem.  However, in that case,
we can finesse the problem by saying dce_login is "only an example program,
and is not an officially supported DCE deliverable".  Fair enough.  However,
I note that dce_login is explicitly cited in the manpages for cdsadv and
cdsclerk (in the Admin Ref), so they should be scrubbed from there.
I believe dcecp is going to make dce_login obsolete, and it doesn't have
the same exposure-of-password problem.

[3/3/94 public]
I've now learned that dce_login is indeed officially supported and documented
in the User's Gd and Ref.  The doc says dce_login is "supplied for use in DCE
configuration", however by virture of it's being documented it's not solely a
dce_config-internal implementation detail.  In any case, it has the
password-exposure problem mentioned above, so something needs to be done about
that.

One suggestion is that instead of supporting passwords on the command line,
dce_login and friends could search a file for the password, a la .netrc.



CR Number                     : 9947
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : sec
Subcomponent Name             : 
Short Description             : acl_edit accepts both -ic & -io swithes.
Reported Date                 : 2/11/94
Found in Baseline             : 1.1
Found Date                    : 2/11/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/11/94 public]

Try this:

> acl_edit /.:/hosts -io -ic
sec_acl_edit> l

# Initial SEC_ACL for directories created under: /.:/hosts:
# Default cell = /.../ice_cell.osf.org
unauthenticated:r--t---
group:subsys/dce/cds-admin:rwdtcia
group:subsys/dce/cds-server:rwdtcia
any_other:r--t---

The only way you know what ACL type you are working with is by
looking at the comment generated with the "list" sub-command.  Here, 
acl_edit gets the initial container ACL for the specified object 
using the last switch specified.

An error should be displayed that only one of these switches, -e, -ic, 
and -io, can be specified on an ACL object.

[7/14/94 public]
Moved to dcecp component for Howard to look at prior to setting status
to defer to 1.2  (dcecp now performs most functions of the control programs)

[7/18/94 public]
This CR either does not affect dcecp or has a related CR open.
It really belongs to acl_edit and should not be changed back to dcecp.

[8/1/94 public]
All control program bugs are being changed to E4 due to the existance
of dcecp.



CR Number                     : 9922
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : kinit
Short Description             : make kinit user friendly
Reported Date                 : 2/9/94
Found in Baseline             : 1.1
Found Date                    : 2/9/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/9/94 public]

The kinit command should warn the user when the requested 
lifetime exceeds the maximum permitted in the registry.
Currently, kinit will quietly set the lifetime to the
max permitted when the requested lifetime is larger than
the maximum permitted.

[2/9/94 public]
kinit isn't the one quietly setting the lifetime to the max permitted.
It just asks for a ticket with a specified lifetime.  It's the registry
that (as spec'd) clips the requested lifetime to a value within the min-max
range.  I'll leave this open as an enhancement request that kinit check the
expiration time and issue a warning if it was different than the
requested time.

[2/9/94 public]
It would also be nice if kinit allowed you to put the password on the
command line, like dce_login.

[2/10/94 public]

Extending kinit to take an ascii password is a no-no  since this could
encourage the use of hard-coded ascii passwords in scripts (a security
hole). I went through this issue during DCE 1.0.2 .

Of course, the same argument could be made against dce_login_noexec 
(widely used in dce_config) or dce_login . The only justification (my 
opinion only - since I have never seen it spelt out clearly anywhere) 
that I can think of is that in this case dce_login is considered a
'sample' program whereas kinit is not.

[ If I recall correctly, an option was added to kinit (from Athena) 
  which would read the (encrypted not ascii) password from a keytab file.
  DCE's version of kinit does not however have this option ]



CR Number                     : 9914
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : passwd_export
Short Description             : passwd_export does not allow choice of registry
Reported Date                 : 2/9/94
Found in Baseline             : 1.1
Found Date                    : 2/9/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/9/94 public]

The passwd_export command randomly binds to any master or slave registry
in your cell, it would be nice if I had the option to choose which site
I wanted to bind to.



CR Number                     : 9853
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : sec
Subcomponent Name             : 
Short Description             : acl_edit mask calculation inconsistent for substitute & assign cmds
Reported Date                 : 1/28/94
Found in Baseline             : 1.1
Found Date                    : 1/28/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/28/94 public]

For the acl_edit "substitute" cmd, the mask calculation will occur
and follow POSIX 1003.6 Steps 3, 4, 5, 7, and 8 whether the mask_obj 
entry was specified or not.

For the acl_edit "assign file" cmd, the mask calculation will occur
and follow POSIX 1003.6 Steps 3, 4, and 5. Therefore, the mask is 
NEVER re-calculated whether the mask_obj entry was specified or not.

Since both these commands are similiar, should they follow the SAME
mask calculation method? Refer to CR9842 for the correct mask
calculation method here if accepted.

[7/14/94 public]
Moved to dcecp component for Howard to look at prior to setting status
to defer to 1.2  (dcecp now performs most functions of the control programs)

[7/18/94 public]
This CR either does not affect dcecp or has a related CR open.
It really belongs to acl_edit and should not be changed back to dcecp.

[8/1/94 public]
All control program bugs are being changed to E4 due to the existance
of dcecp.



CR Number                     : 9849
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : sec
Subcomponent Name             : acl_edit
Short Description             : acl_edit should warn when c-bit only on foreign entries
Reported Date                 : 1/28/94
Found in Baseline             : 1.1
Found Date                    : 1/28/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/28/94 public]

I have an intercell configuration with /.../ice_cell.osf.org and
/.../ninja_cell.osf.org.
I created principal, salamone, in /.../ice_cell.osf.org and changed
the default cell information. An erroroneous message was displayed
that stated I was not authorized to perform the change default cell
operation but it did.

>acl_edit /.:/sec/principal/salamone
sec_acl_edit> l
# SEC_ACL for /.:/sec/principal/salamone:
# Default cell = /.../ice_cell.osf.org
unauthenticated:r-------g
user:cell_admin:rcDnfmaug
user:melman:r--------
group:acct-admin:rcDnfmaug
other_obj:r-------g
any_other:r--------

sec_acl_edit> ce /.../ninja_cell.osf.org
sec_acl_edit> l
# SEC_ACL for /.:/sec/principal/salamone:
# Default cell = /.../ninja_cell.osf.org
unauthenticated:r-------g
user:00000064-d05d-2ce7-a000-0000c0239a70:rcDnfmaug
user:00003a9c-3662-2d33-9600-0000c0239a70:r--------
group:00003e80-d087-2ce7-a901-0000c0239a70:rcDnfmaug
other_obj:r-------g
any_other:r--------
sec_acl_edit> co
sec_acl_edit> ex
ERROR: operation on acl not authorized (dce / sec)


>acl_edit /.:/sec/principal/salamone
sec_acl_edit> l

# SEC_ACL for /.:/sec/principal/salamone:
# Default cell = /.../ninja_cell.osf.org
unauthenticated:r-------g
user:00000064-d05d-2ce7-a000-0000c0239a70:rcDnfmaug
user:00003a9c-3662-2d33-9600-0000c0239a70:r--------
group:00003e80-d087-2ce7-a901-0000c0239a70:rcDnfmaug
other_obj:r-------g
any_other:r--------

[1/28/94 public]
Acl_edit did not print an erroneous message.  After the
"cell" command, a "commit" was performed which saved
the acl.  The commit was successful because the user
was presumably logged in as cell_admin (or was in
the group acct_admin, since those were the only 
entries with the 'c' bit).  Now that the acl's 
default cell is /.../ninja_cell.osf.org, the 
only entries with the 'c' bit are a user:UUID
and a group:UUID **in the cell /.../ninja_cell.osf.org**!
Since these uuids aren't registered in the ninja_cell,
these entries are meaningless.  (Note they do *not*
equate to cell_admin @ ninja_cell or acct_admin @ ninja_cell.)
The user has locked herself out of this acl.  Without
creating a principal or group in ninja_cell with the
same uuids of those entities in the ice_cell, there is
no way to modify this acl.

The bottom line is that acl_edit does not have a bug.
Since the "cell" command provides a way of shooting
yourself in the foot (locking you out of the acl),
I suggest the enhancement of printing a warning message
and/or prompt for confirmation during a commit after
a cell command.  Perhaps it would be more appropriate to
print this warning/prompt for *any* acl that contains
the 'c' bit ONLY on foreign entries.
Changing to an enhancement request.



CR Number                     : 9816
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : security db creation
Short Description             : Must the tgt and ptgt unix IDs be fixed?
Reported Date                 : 1/25/94
Found in Baseline             : 1.0.2
Found Date                    : 1/25/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rs_reserved.h
Sensitivity                   : public

[1/25/94 public]
  The dce-ptgt and dce-rgy principals are assigned fixed Unix IDs, and
so they cannot always conform to the specified "Low Unix ID" for the
principals.
  The "none" group has the same problem with the Low Unix ID for the
groups.
  I presume that there is a reason for reserving the Unix IDs for these
entries. I'd like to get some discussion on that -- we have a request
from outside that it be changed to allow easier administration
(configuration) of secd .. admins are using the Low Unix ID limits to
set the DCE-specific groups and identities to not collide with their
existing ID assignments. E.g. they set all Low Unix IDs (and that of
their 'cell_admin' equivalent) to values like 24000. then their
passwd importation goes smoothly.
  Could these princs and groups be given dynamic Unix IDs?



CR Number                     : 9516
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : various cases of
non-deterministic return values
Reported Date                 : 11/18/93
Found in Baseline             : 1.0.3
Found Date                    : 11/18/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/18/93 public]

Licensee reported:

"The following files have return statements coded without supplying
 explicit values for functions. These are cases in which the functions
 are typed non-void and whose return values ARE actually used in the code.

 client/rca/internal_binding.c  OSF rcsid 1.1.14.2
        rca_nsi_binding_import() as called from rca_site_bind()

 client/rca/secidmap.c          osf 1.0.2 release
        output_cache_line() as called from sec__id_check_cache()

 client/admin/passwd_import/passwd_import.c OSF rcsid 1.1.6.1
        add_pgo() as called from process_groups()

 server/sec_salvage_db/sec_svg_rec.c OSF rcsid 1.1.89.1
        construct_rep_rec() as called from construct_replicas()

"
I checked with our 1.0.3 code, these problems are still there.

[10/14/94 public]
Returning to it's natural state - had bumped the priority in an effort
to get it into the unintegrated tree.



CR Number                     : 9491
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : acl_edit
Short Description             : tokens not used by acl_edit yet.
Reported Date                 : 11/15/93
Found in Baseline             : 1.0.2
Found Date                    : 11/15/93
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/15/93 public]
  Mike Young has reported the following shortcomings in the ACL support
layer. This is his report:
   ------------------------------------------------------------------
The acl_edit program ignores the "tokenize" value returned
by an ACL manager's rdacl_get_printstring function.  This
value is supposed to indicate whether the set of permissions
contains overlaps or combinations.  The intention is for
tools to look for combinations and use them instead of the
individual bits.  The acl_edit program does not -- it prints
anything that matches at all.  In the case of overlaps (aliases),
this is merely annoying.  In the case of real combinations,
the code is just plain wrong -- it can overstate permissions.
It looks like fixing the deif_permset_output function in "deif.c"
would do it.  Something like this would work (after making tokenize a
global like sec_acl_printstrings):
    if (tokenize) {
        int i;
        for (i = num_printstrings; --i >= 0; )
            if ((sec_acl_printstrings[i].permissions & perms) ==
                sec_acl_printstrings[i].permissions) {
                printf("%s",sec_acl_printstrings[i].printstring);
                perms &= ~sec_acl_printstrings[i].permissions;
            }
    } else {
        /* old deif_permset_output implementation */
    }
[haven't tested this code... it is merely a rough example.]
According to the commentary in "rdaclif.idl", combinations should
appear at the end of the list, so a backwards traversal appears to be
in order.  My code would cause the bits to come out in reverse order
compared to how it does things now, but since it does it wrong now,
who cares?  Reversing the list or printing "-" for unambigiuous
missing bits would take just a little more code if it really mattered.
The code also assumes that there are only 32 permission strings
for a given ACL, which is not correct in the presence of combinations
or aliases.
It also ignores a number of other features described in the rdaclif
interface, like chaining, but those aren't useful.  Handling aliases
and combinations most definitely IS useful.
I noticed this misfeature while experimenting with an RQS server
that has two names for the same permission bit.  I wanted to have the
printed entries contain just one of the two aliases, so I set
the "tokenize" return parameter to TRUE.  Alas, it had no effect.
.... I realize that DCE 1.1
will have new ACL management tools, but it really should be easy to
fix acl_edit.  It wouldn't surprise me if the DCE 1.1 tools will
inherit the same problem, and that would be very bad.

[11/15/93 public]
This is one of several things available in the architecture that acl_edit
does not make use of yet (the others being polymorphic types via multiple
ACL managers and >32 permission bits via chained ACL managers).  This CR has
been changed from 'def' to 'enh'.



CR Number                     : 9375
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : sec
Subcomponent Name             : sec_login
Short Description             : certify shouldn't require root
Reported Date                 : 11/4/93
Found in Baseline             : 1.0.3
Found Date                    : 11/4/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/4/93 public]
sec_login_* API's that require privelidge (uid==0) should be changed to not
require priviledge.  It was a historical implmenation accident that never
got fixed.  Ask walt or Joe P for details. 

This will also involve a doc change when the code is changed

[11/8/93 public]
It was not an accident.  It was a design decision made at that time.  If it's
going to be changed, that will be new functionality, and will be done as an
enhancement.  Changed from 'def' to 'enh'.

[1/21/94 public]
The debate has been settled (sort of) on dce-tech.  valid_and_cert
*MUST* be a privileged operation.  Cancelling this enhancement request.

[1/25/94 public]
Howard channeling for walt:

Howard, I don't think this is quite correct.  I believe we have to:

	- Make sure it valid_and_cert() is spec'd to be the *only* API
	  that is privileged.  E.g.: sec_login_certify_identity()
	  manpage says, "On some systems, this may be a privileged
	  operation."

	- Make it clear that validated-but-not-certified login contexts
	  result only in warnings, not failures.  E.g.:
	  sec_login_get_expiration() manpage says, "This routine works
	  only on previously certified contexts."  [Curiously, the 1.0
	  doc says "validated" instead of "certified", which now
	  appears to be correct.]

The docs (and perhaps some code?) are currently deficient in these areas.

It would also be nice to fix the App Dev Gd to explain the "why" of
these things, but that's a major job.  At least the AES will (try to)
have the right info, and we've alerted Doc that it would be nice to do a
rehaul of the Sec documentation based on it.  But I don't know if that's
committed for 1.1.

The code portion is that we need to check some sec_* routines that require
certification (e.g. sec_login_inquire_net_info) and see if that is a
reasonable thing.  After this is done this should become a doc bug to
handle the above mentioned issues.

[1/25/94 public]
Thanks for including all the information on this topic, but adding comments
to a cancelled CR is not going to make sure that they're addressed, because
CR's in that state no longer show up on anybody's list...

Please open a doc CR for those docs that you feel are lacking in the description
of this problem.  As far as code goes, it's doing what it's spec'd to do and
will stay that way (per agreement from Walt, myself, Bill and Joe).  The
sec_login_inquire_net_info() call does not require certification, it gives you
a warning (doc calls it an error now, which is a bug that Joe sent email about
and should be in your description of the problem in the doc bug opened for the
above comments by Walt) if it's not certified.

[1/25/94 public]
Changed to open.  This is currently a code but and I'll leave it like that
so walt can comment on anything in code that needs to be reviewed.  When
done, change this to a doc bug.  Our code does a sec_login_certify_identity
and then a sec_login_inquire_net_info and works today.  That's what I care
about.  Walt...



CR Number                     : 9370
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : sec
Subcomponent Name             : sec_admin
Short Description             : no way to know hostname of master
Reported Date                 : 11/4/93
Found in Baseline             : 1.0.3
Found Date                    : 11/4/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/4/93 public]
The names of security replicas is (by convention? default?),

    subsys/dce/sec/<hostname> 

but the name of the master is always (again by convention?)

    subsys/dce/sec/master

There is no easy way to know what host the security master is.  You can do
an info -full which gives teh string binding to the master, and then parse
that and using some probably external to DCE means (gethostbyaddr) convert
it to a name, but that's not a good story.

What if subsys/dce/sec/master was a link to a hostname?

[2/17/94 public]

Note that the master name need not necessarily be subsys/dce/sec/master
because change_master and become -slave/become -master (when available) 
can be used to change the master.

So the only definitive way to know the current master is via sec_admin
commands such as lrep or info. But even such info will not yield a host
name. So for now there is no way to obtain the hostname of a master other
than  by an external means (as you have pointed).



CR Number                     : 9364
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec.msg
Short Description             : confusing error message (Cell UUID not a valid cellname)
Reported Date                 : 11/4/93
Found in Baseline             : 1.0.3
Found Date                    : 11/4/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/4/93 public]

"Cell UUID is not a valid cell name"

(of course it's not; cell UUID's are not cell names..)

(seen in OT 9362).

Try rewording to "Cell UUID is not valid" or "Cell UUID not known to this
cell's security server" depending on what it really means..

P.S. "The door is a jar".



CR Number                     : 9343
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : use of sys_nerr is not portable
Reported Date                 : 11/3/93
Found in Baseline             : 1.0.2a
Found Date                    : 11/3/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : krb5/comerr/error_message.c krb5/comerr/internal.h krb5/lib/perror.c
Sensitivity                   : public

[11/3/93 public]

sys_nerr is a global variable which is used on some UNIX systems to
determine the maximum errno value. It is not supported by POSIX or XOPEN
(in fact XOPEN withdrew its support for it). For portability, the use of
sys_nerr should be removed.

One use of sys_nerr is in error_message() in krb5/comerr/error_message.c.
A possible solution is to first do a dce_error_inq_text() and check the
status on that call to determine if the error is a dce error:

        dce_error_inq_text(...,&inqstatus);
        if (inqstatus == 0) /* it's a DCE error */
        {
                ...
        }
        else /* it's (probably) a system error */
        {
                ...
        }

That way, the else clause is the system error and the test (offset <
sys_nerr) is removed.  Also the statement sys_errlist[offset] (not ANSI C)
should be replaced by strerror(offset) (ANSI C). If one could assume XPG/3
support for strerror() then a better solution whould be to check errno upon
return from strerror() for EINVAL to determine whether the error number is
a system error.

The other use of sys_nerr occurs in krb5/lib/perror.c, essentially another
implementation of strerror(). Shouldn't this code be defuncted and
<string.h> strerror() be used instead?

[11/3/93 public]

This code predates general availability of ANSI C libraries.

It should use strerror instead if and only if the status is less than a
constant (defaulting to 0x10000000)..

this is a code cleanup issue; deferred to 1.1



CR Number                     : 9338
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : sec auth_helper
Short Description             : dfsbind cache discards far too often
Reported Date                 : 11/3/93
Found in Baseline             : 1.0.2
Found Date                    : 11/3/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/helper/auth_helper.c
Sensitivity                   : public

[11/3/93 public]
 The auth_helper cache is keyed by (pag, euid). Typical use of this
cache presents the cache with requests for several servers (the dfs
servers on the various servers in the cell) all from the same (pag,
euid) pair in bursts.
 Cache entries are 'discarded' -- their krb creds are removed and
replaced -- over and over in these bursts. The cache cosistently
discovers a slot used by a given (pag, euid) but which is caching the
ticket for the wrong (previously accessed) hosts/<varies>/dfs-server
principal. If I read it correctly, this results in disk traffic as the
old server's cred is dropped and the new one retrieved. Also the
registry (or self's name cache .nc file) is called/consulted to perform
a global name parse.. expensive.
 Why not convert the cache management to not tromp on a slot's krb? It
would seem more effective to to allow any number of slots to match a
given (pag, euid) pair just as long as each such slot holds the cred for
a different server.

[11/3/93 public]

this is, more or less, a reasonable suggestion..

[8/29/94 public]
Will do if there's time and if the OSF lets it in (if they don't, we'll at
least drop it in the unintegrated tree).



CR Number                     : 9335
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : sec
Subcomponent Name             : secd
Short Description             : secd should check all alias accounts on replace/add
Reported Date                 : 11/3/93
Found in Baseline             : 1.0.2
Found Date                    : 11/3/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/server/rs/rs_pwd.c
Sensitivity                   : public

[11/3/93 public]

Operations which involve changing or replacing accounts do not always
work with alias accounts. This is because secd looks up the account
based on the UUID. Since alias accounts of a primary account share the
same UUID, the lookup returns the primary account instead of the
alias account and subsequent checks (decryption, key versioning) fail.

The fix is to have rs_pwd_get_key_by_prnc() check all aliases of the
primary account and only return failure if all accounts fail. 

To reproduce, create an alias account and then do the following in
rgy_edit :

rgy_edit=> kta -p alias -r -a
?(rgy_edit) Unable to add key - key version number out of range (dce / sec)

This is because the primary account was looked up and the key versions
did not match with the alias account.

Fix is available. Will put in for 1.1.

[8/1/94 public]

Tried "kta -p alias -r -a" on alias account but it still fails (hp800).
On the other hand it fails for normal accounts too.

[8/9/94 public]
Max, please update this CR with the error messages that it failed with in
both cases.  The statement that it fails for normal accounts too is
particularly troubling, since if that fails then dce_config could not possibly
succeed.



CR Number                     : 9331
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : test/security/api/moretests/sec_acl_stubs.c
Short Description             : clash between function decl.
and def. for sec_acl_get_access
Reported Date                 : 11/3/93
Found in Baseline             : 1.0.3
Found Date                    : 11/3/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/3/93 public]

Licensee reported:

"In test/security/api/moretests/sec_acl_stubs.c, the inclusion of
 dce/daclif.h defines sec_acl_get_access() as extern, but the definition
 is provided in the .c file in question.  Our ANSI compiler chokes.
"

I think the real problem is that the signatures are different in two
definitions:

In sec_acl_stubs.c, it is defined as:

void sec_acl_get_access (acl_handle, manager_type, user_obj, group_obj,
                         net_rights, status)

  sec_acl_handle_t acl_handle;
  uuid_t *manager_type;
  sec_id_t *user_obj;
  sec_id_t *group_obj;
  sec_acl_permset_t *net_rights;
  unsigned32 *status;


But in daclif.h, it is defined as:

    void sec_acl_get_access (
        [in]        sec_acl_handle_t        h,
        [in, ref]   uuid_t                  *manager_type,
        [out, ref]  sec_acl_permset_t       *net_rights,
        [out]       error_status_t          *st
    );

[11/03/93 public]
You're right that is the signature-mismatch that is causing the error.
Making DCE source code ANSI-compliant is a DCE 1.1 cleanup task.  Changed
the "fix in" to 1.1



CR Number                     : 9329
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : security
Short Description             : redefinition of macros in
param.h cause compilation failures
Reported Date                 : 11/3/93
Found in Baseline             : 1.0.3
Found Date                    : 11/3/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/3/93 public]

Licensee reported:

"Redefintion of the macros MIN and MAX, provided in sys/param.h, cause
 compilation failures.  In the following cases, this is caused by the
 inclusion of macros.h before sys/param.h

        src/security


                server/rs/rs_rep_auth.c : macros.h via rgymacro.h via
                                                rs_base.h via rs_server.h

                        and sys/param.h via sec_login_file_loc.h via
                                sec_login_pvt.h

                client/login/sec_login_util.c: macros.h via rgymacro.h
                        param.h via sec_login_file_loc.h via sec_login_pvt.h

                client/login/sec_login_cache.c : same as last case
"

Verified with OSF/1 include files for 1.0.3.

Since the definition in sys/param.h does not have a #ifdef to wrap and the 
defintion in macros.h does have #ifdef wrap, the suggested fix is to
include <sec_login_pvt.h> in front of rgymacros.h.

[8/23/94]

I have seen the warnings.  In dce1.1 the above solution will not
suffice as MAX and MIN are defined in dce.h
Two solutions are possible.
1 Include sys/param.h in dce.h
2 Check all the files that cause the warning and explicitly include
  sys/param.h before any dce header file.  This will do as sys/param.h
  is multiple-inclusion safe.

[8/23/94 public]
Choice 1 isn't good since dce.h is included by virtually every DCE file and
many DCE application files.  Many that don't need param.h

Choice 2 isn't bad.

NOTE: the original CR said failures, and I would question how this could be
verified on OSF/1.  These files build on OSF/1.  Max's comment that they
generate warnings makes sense.  If this is the case, since it's warnings,
and it's not a trival one character fix (:-), and 1.1 is on a very tight
schedule, I would defer this.  

This is in violation of the coding style guide (we are supposed to compile
cleanly on the reference platforms), but the easy out is to "mention it in
the porting guide".  A simple note that says "we see these warnings in these
files on this platform" is enough to get you pass the code cleanup
requirements.



CR Number                     : 9257
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : sec/utils
Short Description             : return within TRY-block (coding style)
Reported Date                 : 10/26/93
Found in Baseline             : 1.0.2
Found Date                    : 10/26/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : commands.c
Sensitivity                   : public

[10/26/93 public]
  There's a return from within a TRY-block in commands.c . Here, it
triggers a sanity-check about the mismatching of TRY/ENDTRY executions.
DCE documentation advocates that return's not be placed within TRY-blocks.
......................................................................
diff -c -t -b -r9.2 security/utils/commands.c
*** 9.2 1993/06/23 14:02:10
--- security/utils/commands.c   1993/10/25 22:07:47
***************
*** 335,351 ****
  {
      command_buf       c;
!
!     while (TRUE) {
          TRY {
              if (must_prompt) {
                  fputs(prompt_string, stdout);
              }
              get_command(&c);
!
!             if (c.done) {
!                 return;
!             }
              (*c.op)(&c);
          } CATCH_ALL {
          } ENDTRY
      }
--- 335,351 ----
  {
      command_buf       c;
!
!     c.done = FALSE;
!     while (!c.done) {
          TRY {
              if (must_prompt) {
                  fputs(prompt_string, stdout);
              }
              get_command(&c);
!
!             if (!c.done) {
                  (*c.op)(&c);
+             }
          } CATCH_ALL {
          } ENDTRY
      }

[10/28/93 public]
  Found six? more? instances of this in client/rca/sec_lrgy.c ...
Filled in Responsible Engr. with `sec_bat' 
Filled in Resp. Engr's Company with `hp'



CR Number                     : 9210
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : acl example server.
Short Description             : dacl_sutil should be defuncted
Reported Date                 : 10/20/93
Found in Baseline             : 1.0.3
Found Date                    : 10/20/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : client/admin/acl_edit/svr_example/dacl_sutil.c
Sensitivity                   : public

[10/20/93 public]

security/client/admin/acl_edit/svr_example/dacl_sutil.c should go away and
the function it implements should be be replaced by dce_error_inq_text().

[10/20/93 public]
It isn't used for anything (isn't even built).  We'll defunct it when the
tree opens up again for 1.1 work.

[10/3/94 public]
A year later he says "wow, I remember this CR, kinda sad that there hasn't
been time in a year to defunct an unused file :-(".  Reassigned to test,
since the acl server has been moved from the core tree to the test tree.



CR Number                     : 9094
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 4616
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : test/security/api/testsh/tsh.l
Short Description             : api/testsh/tsh.l needs
prototype for malloc()
Reported Date                 : 10/13/93
Found in Baseline             : 1.0.3
Found Date                    : 10/13/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/13/93 public]

Licensee reported:

" Since test/security/api/testsh/tsh.l does not include a prototype for 
 malloc() our ANSI compiler complains of a type mismatch.

 add include of stdlib.h to provide prototype for malloc()
"

OT 4616 was also about unable to compile the c code from tsh.l. It was
fixed by including <malloc.h>, but malloc.h does not give the prototype for
malloc() (check /usr/include/malloc.h of AIX)



CR Number                     : 9093
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : macro redefinition causing
compilation to fail
Reported Date                 : 10/13/93
Found in Baseline             : 1.0.3
Found Date                    : 10/13/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/13/93 public]

Licensee reported: (code under test/security/api/moretests)

" In tests/security/api/moretests/key_mgmt.c, the macro PLAIN_PASSWD is
 already defined from rgymacro.h via key_mgmt.h.  This redefinition
 prevents the file from compiling with our ANSI compiler.


 In addition, tsh_misc.h includes tsh_common.h which defines
 SUCCESS and FAILURE, but later
 key_mgmt.h includes rgymacro.h which includes macros.h which redefines
 SUCCESS and FAILURE.  This also prevents compilation with our compiler.
"

rgymacro.h and macros.h are under src/security/h.

The suggested fix is for key_mgmt.c to undef PLAIN_PASSWD before defining
again. And adding #if defined(FAILURE) to macros.h.



CR Number                     : 9079
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : binding
Short Description             : consolidate some of the sec_rgy_site_ API.
Reported Date                 : 10/9/93
Found in Baseline             : 1.0.2
Found Date                    : 10/9/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/9/93 public]

Following are the list of APIs that do more or less the same thing.  They
should be combined into one API.

	sec_rgy_site_open - Opens a registry site with default sec. level.
        	            (It does not take auth_info arg. unlike bind ver.)
	sec_rgy_site_open_query - same as sec_rgy_site_open.
	sec_rgy_site_open_update - opens the master registry site
	sec_rgy_site_bind - Opens a registry site with requested sec. level.
        	            It takes auth_info arg.
	sec_rgy_site_bind_query - same sec_rgy_site_bind.
	sec_rgy_site_bind_update - opens the master registry site. Takes
	                           auth_info arg.

All these API's could be combined into one API, let's call it:

        sec_rgy_site_get_handle(
                unsigned_char_t *site_name,
                sec_rgy_bind_auth_info_t *auth_info,
                unsigned8 site_type,
                sec_rgy_handle_t *context,
                error_status_t *status)

This has one extra parameter 'unsigned8 site_type' than what 'bind' type of
calls have. site_type could be one of the following:

	sec_c_site_query - get handle for a query site
	sec_c_site_update - get handle for a update site
	sec_c_site_any - don't care what type of site is bound to
	sec_c_site_default - may be we do not need this.

To get same behavior as 'open' type of calls, application can just pass
NULL for the auth_info argument.

AES/DC Security can make this new API as full-use and others temp. use.

[10/11/93 public]
There's no way that a functional change like this can be considered for 1.0.3,
so I've changed the requested fixby field to 1.1.



CR Number                     : 9048
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : Sec_RepUUID converted to
string for stored as type byte in cds
Reported Date                 : 10/5/93
Found in Baseline             : 1.0.3
Found Date                    : 10/5/93
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/5/93 public]
The replica id is converted to a string then stored as a CDS
attribute of type byte.  An array of char and an array of byte are
not the same thing, although since the uuid is a numeric string
you probably don't have ascii/ebcidic problems.  But, cdscp
cannot display the attribute intellegently.

You could have stored it as a uuid (VT_UUID) and cds/rpc would
have taken care of endian issues.  IN addition cdscp would be
able to display it as such.

I don't know if this can be fixed gracefully, but if there is a time
when all security servers have to upgraded at once this would be
worth fixing.



CR Number                     : 8892
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : security/client/admin
Short Description             : passwd_import the passwords?
Reported Date                 : 10/1/93
Found in Baseline             : 1.0.2
Found Date                    : 10/1/93
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : many (rca, server/rs, idl)
Sensitivity                   : public

[10/1/93 public]
  It is not obvious why security cannot allow passwd_import to send the
Unix-crypted password for an account directly to the server for storage
as a pre-expired password. I imagine that an encrypted password could
be stored in the acct_user section of an account using mostly existing
code. This would greatly ease the importation of tens of thousands of
Unix accounts (at universities, for example).
  I presume that I am missing a serious problem in what it would take to
do this. Otherwise, could we register a new passwd type (plaintext, des,
unix?) for transmission of 13-byte encryptions (and salt)?

[10/1/93 public]

Changed to enhancement.

This would not be useful without adding a new, trusted, service which
registered the user. The UNIX crypt strings are not useable by DCE security
since they don't establish a shared secret between the user and the
security service.

In a workstation based environment, the users would have walk over to
specifically authorized workstations and type their passwords in there...
or else type them in the clear over the network.. to such a service.

If you want this to happen, tell the security SIG about it and have them
make it a requirement for 1.1.1...



CR Number                     : 8866
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : sec_key_mgmt_get_key() (&..key__type()) API should not return sec_rgy_bad_data status code
Reported Date                 : 9/28/93
Found in Baseline             : 1.0.3
Found Date                    : 9/28/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/key_mgmt/seckey_get.c
Sensitivity                   : public

[9/28/93 public]

Full Description:

	procedure sec_key_mgmt_get_key_type tests keydata, and if
it is NULL, sec_rgy_bad_data is assigned to the output parameter err.
Processing however, continues, through subsequent tests of authn_service
and key_vno, and if both authn_service and key_vno are acceptable, a
successfull call to SEC_KEY_CHECK_INIT will conceal the fact that
keydata was incorrect, allowing processing to continue. The probable result
is an addressing exception at *keydata = (void *) keys;

Proposed Solution:

	insert return; following detection of invalid keydata;

    if (keydata) {
        *keydata = NULL;
    } else {
        /*
         * Caller didn't pass a valid output parameter - 
         * return with an error status. (This should not be a 
         * sec_rgy error status!)
         */
        SET_STATUS(err, sec_rgy_bad_data);
        return;
    }

[09/29/93 public]
I suppose this should be written as
	if (keydata == NULL) {
	    SET_STATUS(err, sec_rgy_bad_data);
	    return;
	}
However, I would rather just see the whole if test removed.  We should
not be testing for NULL pointers; they just obscure application programming
errors.

[7/19/94 public]
The man pages I have do not list 'sec_rgy_bad_data' as a potential 
return from this API (as a matter of fact, they don't even list
..get_key_type() at all, only ..get_key() which simply calls ..key_type() 
with type 'sec_passwd_none').  Anyway, since there is no momentum from
the doc. side to keep this NULL input check, I agree with Rich that
it should be removed.  Anyone disagree?  I will change the short 
description to reflect this.



CR Number                     : 8665
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : security client binding
Short Description             : enhance security client binding
Reported Date                 : 9/22/93
Found in Baseline             : 1.0.3
Found Date                    : 9/22/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/22/93 public]
The security client binding model should be enhanced:
1. to allow administrators to specify the 'best,'
'closest,' or favored secd site(s) for a 
given DCE client machine,
2. to randomize the order in which secd bindings are
chosen OR to provide load sharing amongst all
available secd sites,
3. to reduce the likelihood that a given binding
will be tried if a previous attempt to bind with
it from this client machine failed.

Caching for #3 should be applied at the DCE client
machine level (not per application) so that
subsequent invocations of clients (like dce_login)
benefit from earlier invocations.

[9/22/93 public]

This functionality really belongs in CDS.

An administrator should be able to create a file containing
address/mask/weight tuples which the cds client code (either the clerk or
the NSI code; I'm not sure which) uses to sort addresses returned from the
name space.

the "addresses" should be in string binding form; exactly how to express a
"mask" in string binding form would be an interesting problem (and may
require minor extensions to string binding syntax).

Addresses with the same weight should be randomized (and I really mean
*randomized*, not "pick the first one").

[09/23/93 public]
Isn't a large portion of this "external file" stuff already handled by
RPC profiles?

[9/23/93 public]

Profiles require far too much manual intervention, and are too hard to get
right, both in the services and for administrators; you have to hack each
one on a service-by-service basis.  I should be able to give general rules
("prefer something on the local net, then something in the local swamp, and
don't ever go to a server over in europe unless there's no other choice")
which are *distinct* from the coding of the applications or the
installation of individual services, which are then used to select the
ordering in which applications see the binding info back from the name
service.

I guess what I'm looking for is something along the lines of the BIND
"sortlist" feature.



CR Number                     : 8650
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : helper
Short Description             : auth_helper confuses creds on cached contexts
Reported Date                 : 9/22/93
Found in Baseline             : 1.0.2
Found Date                    : 9/22/93
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : open

[9/22/93 public]
Here is the information from our bug database regarding this defect.
The problem is that if the first file access that generates the call
to auth helper (dfsbind) is under an su process then the euid saved in
the cache context does not reflect the real owner of the ticket.
The code change is included at the end.
abstract      auth_helper confuses creds on cached contexts
duplicate     
notes:
    <Note by dstokes (Dawn C. Stokes), 93/09/07 18:47:44, action: open>
I have seen this a couple of times now, and Ken Walker just hit it in
the dceprod cell.  There seems to be a problem when you su back and
forth between non-root and root users while holding credentials.
You eventually starting getting failures indicating that you are
unauthenticated, but your creds are still valid.  Looking at the
dfstrace log:
time 543.103925, pid 0: Current time: Tue Sep  7 18:15:43 1993
time 543.103925, pid 17676: ERR: dfs: set auth binding failed (code 382312714),
running unauthenticated.
time 256.193075, pid 17676: ERR: dfs: set auth binding failed (code 382312714),
running unauthenticated.
time 390.927316, pid 17676: ERR: dfs: set auth binding failed (code 382312714),
running unauthenticated.
# dce_err 382312714
dce_err: 382312714: attempting to use credentials belonging to otheruser (dce /rpc)
I have hit it when trying to operate as a non-root, non-cell_admin user,
but then having to become root for some reason.  Ken hit it by dce_logging
prior to starting X windows, and then opening several windows, on of which
does an su root.
I intend to try to come up with a more finite sequences of steps for
reproducing this, but I decided to go ahead and open the defect so I
don't forget.
    <Note by dstokes (Dawn C. Stokes), 93/09/15 16:55:46, action: note>
Method for reproducing this bug:
rlogin host -l <non-root-user>
dce_login cell_admin -dce-
su root
cp -r data into DFS (I did a build export tree)
exit
ls -l directory being copied into
START_SYMPTOM
After dce_login'ing to the cell as a user and su'ing to another user, dfsbind
returns a creds error which the DFS client will present as:
dfs: set auth binding failed (code 382312714), running unauthenticated.
The creds have not expired at this time and should still be valid.
This seems to occur after several hours when several su's have been
attempted or a lot of file system activity has happened.
STOP_SYMPTOM
START_SOLUTION
Change the auth_helper code in get_context_from_pag() so that it avoids
looking in the cache at the euid's and verifies the context by
calling check_ownership() everytime to see who owns the ticket file.
STOP_SOLUTION
auth_helper.c:
-------------------
static int check_ownership (euid, slot, st)
    unsigned32 euid;
    int slot;
    error_status_t *st;
{
    int ret;
    struct stat stbuf;
    char tkt_file_path[1024];
    if (context_cache[slot].pag == 0) {
        *st = -1 /* XXX */;
#ifdef OT /* ORB: 7237 */
        dprintf("check_ownership pag is 0\n");
#endif /* OT */
        return -1;
    }
    sprintf (tkt_file_path, 
	SEC_LOGIN_CCACHE_FILE_FROM_PAG_FMT, context_cache[slot].pag);
    ret = stat (tkt_file_path, &stbuf);
    if (ret < 0) {
        *st = -1 /* XXX */;
#ifdef OT /* ORB: 7237 */
        dprintf("check_ownership stat failed on %s \n",tkt_file_path);
#endif /* OT */
        return -1;
    }
    if (!S_ISREG(stbuf.st_mode)) {
#ifdef OT /* ORB: 7237 */
        dprintf("check_ownership failed on %s, !S_ISREG\n",tkt_file_path);
#endif /* OT */
        *st = rpc_s_helper_wrong_user; /* not quite right */
        return -1;
    }
    if ((euid != 0) &&
        (stbuf.st_uid != euid))  {
#ifdef OT /* ORB: 7237 */
        dprintf("check_ownership failed on %s, euid %d, st_uid %d\n",	
	    tkt_file_path, euid, stbuf.st_uid);
#endif /* OT */
        *st = rpc_s_helper_wrong_user;
        return -1;
    }
    *st = error_status_ok;
    return slot;
}
.
.
.
static int  get_context_from_pag (pag, euid, login_context, st)
    unsigned32 pag;
    unsigned32 euid;
    sec_login_handle_t *login_context;
    error_status_t *st;
{
    int slot;
    *st = error_status_ok;
    slot = find_context_cache(pag);
    if (slot >= 0) {
	*login_context = context_cache[slot].context;
#ifdef OT /* 7237 */
	(void)check_ownership(euid, slot, st);
#else /* OT */
	if ((context_cache[slot].euid == euid) || (euid == 0)) {
	    (void)check_ownership(euid, slot, st);
	} else {
	    *st = rpc_s_helper_wrong_user;
	}
#endif /* OT */
	if (*st != error_status_ok) {
	    release_context_cache(slot, login_context);
	    slot = -1;
	}
    } else { /* no entry found in context cache */
.
.
.
.
.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `open'

[9/22/93 public]
There is a revision to the above change.  The revised changes are included below
static int check_ownership (euid, slot, st)
    unsigned32 euid;
    int slot;
    error_status_t *st;
{
    int ret;
    struct stat stbuf;
    char tkt_file_path[1024];
    if (context_cache[slot].pag == 0) {
        *st = -1 /* XXX */;
#ifdef OT /* ORB: 7237 */
        dprintf("check_ownership pag is 0\n");
#endif /* OT */
        return -1;
    }
    sprintf (tkt_file_path, 
	SEC_LOGIN_CCACHE_FILE_FROM_PAG_FMT, context_cache[slot].pag);
    ret = stat (tkt_file_path, &stbuf);
    if (ret < 0) {
        *st = -1 /* XXX */;
#ifdef OT /* ORB: 7237 */
        dprintf("check_ownership stat failed on %s \n",tkt_file_path);
#endif /* OT */
        return -1;
    }
    if (!S_ISREG(stbuf.st_mode)) {
#ifdef OT /* ORB: 7237 */
        dprintf("check_ownership failed on %s, !S_ISREG\n",tkt_file_path);
#endif /* OT */
        *st = rpc_s_helper_wrong_user; /* not quite right */
        return -1;
    }
    if ((euid != 0) &&
        (stbuf.st_uid != euid))  {
#ifdef OT /* ORB: 7237 */
        dprintf("check_ownership failed on %s, euid %d, st_uid %d\n",	
	    tkt_file_path, euid, stbuf.st_uid);
#endif /* OT */
        *st = rpc_s_helper_wrong_user;
        return -1;
    }
    *st = error_status_ok;
    return slot;
}
.
.
.
static int  get_context_from_pag (pag, euid, login_context, st)
    unsigned32 pag;
    unsigned32 euid;
    sec_login_handle_t *login_context;
    error_status_t *st;
{
    int slot;
    *st = error_status_ok;
    slot = find_context_cache(pag);
    if (slot >= 0) {
	*login_context = context_cache[slot].context;
#ifdef OT /* ORB:7237 */
	(void)check_ownership(euid, slot, st);
#else /* OT */
	if ((context_cache[slot].euid == euid) || (euid == 0)) {
	    (void)check_ownership(euid, slot, st);
	} else {
	    *st = rpc_s_helper_wrong_user;
	}
#endif /* OT */
	if (*st != error_status_ok) {
	    release_context_cache(slot, login_context);
	    slot = -1;
	}
    } else { /* no entry found in context cache */
	unsigned char import_buf[1024];
	error_status_t xst;
	int exists;
	/* Fetch the context and add it to the context cache */
	sprintf ((char *)import_buf, SEC_LOGIN_CCACHE_FROM_PAG_FMT, pag);
	dprintf ("Importing pag %x, `%s'\n", pag, import_buf);
	sec_login_import_context (strlen(import_buf)+1, import_buf, 
                              login_context, st);
	if (*st == error_status_ok) {
	    slot = add_context_cache(pag, euid, login_context, &exists, st);
	    if (*st == error_status_ok) {
		if (exists) {
		    /* 
		     * Another thread must have beat us to it, release our
		     * context and use the one returned from the cache.
		     */
		    dprintf("discarding duplicate ctx %x\n", *login_context);
                    sec_login_release_context (login_context, &xst);
		    *login_context = context_cache[slot].context;
		}
#ifdef OT /* ORB:7237 */
		(void)check_ownership(euid, slot, st);
#else /* OT */
		if ((context_cache[slot].euid == euid) || (euid == 0)) {
		    (void)check_ownership(euid, slot, st);
		} else {
		    *st = rpc_s_helper_wrong_user;
		}
#endif /* OT */
		if (*st != error_status_ok) {
		    release_context_cache(slot, login_context);
		    slot = -1;
		}
	    }
	} else {
	    dprintf("unable to import pag %x in `%s': status %x\n",
		pag, import_buf, *st);
	}
    }
    return slot;
}

[10/6/93 public]

I've gotten Rajendra's permission to integrate the
proposed fix for this problem.



CR Number                     : 8632
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : allow input of a start UNIX id to the rgy tests rather than using fixed hardwired ones
Reported Date                 : 9/19/93
Found in Baseline             : 1.0.2
Found Date                    : 9/19/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : src/test/security/api/moretests/rgy_*
Sensitivity                   : public

[9/19/93 public]

In some ports of DCE the registry is configured with UNIX ids beginning at
a value (e.g. 1000) which causes failures when running some of the tests in
src/test/security/api/moretests (e.g. rgy_add.sh, rgy_change.sh) which use
fixed UNIX ids such as 1002 (these ids being already attributed).  Make
those tests more flexible so that they can start from a given UNIX id
rather than use fixed ones.



CR Number                     : 8588
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : caching problem in rca_site_bind
Reported Date                 : 9/13/93
Found in Baseline             : 1.0.3
Found Date                    : 9/13/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/rca/internal_binding.c
Sensitivity                   : public

[9/13/93 public]

Full Description:

	While evaluating a service call from Stratus, I noticed
some undesirable state dependent behavior in the routines sec_rgy_site_get
and sec_rgy_site_binding_get_info, which I traced to caching being done
by the routine rca_site_bind which is ultimately called as the result of a
call to sec_rgy_site_bind.

	The first argument to sec_rgy_site_bind identifies the registry
server to which you would like to bind. There are several alternate 
forms in which you can indicate/name the server you wish to bind to.

	0 length string passed as server name

	protocol tower identifying host on which server is located and how
        to contact server (e.g. ncadg_ip_udp:130.105.1.60,
        ip:130.105.1.60, or ip:hostname)

        /.: indicating any registry server in your cell

        /.../x indicating any server in cell x

        and maybe some additional ways I haven't yet discovered
			
In any case, I noticed that when you indicate your server by other than 
one of the protocol tower forms, a subsequent call to sec_rgy_site_get or
sec_rgy_site_binding_get_info will return the name of the bound registry
server as a CDS name (e.g. /.../tofino_cell/subsys/dce/sec/master). However,
after using one of the protocol tower site name formats, all subsequent
calls to either sec_rgy_site_get or sec_rgy_site_binding_get_info will
return the name of the bound site exactly as it was specified in the
call to sec_rgy_site_open. This format persists even if you use
sec_rgy_site_close and then reopen the site with one of the other formats.

after looking at the code in internal_binding.c it became clear that
the caching logic is the cause of the persistence of the protocol tower
server name form across a close and (re)open. The following segment of code
was apparently written under the assumption that when binding_cache_lookup
returns true, the site name stored in the cached_context will be the same
as the site name passed to binding_cache_lookup. In practice this turns out
not to be the case.

/*
     * check our cache.
     */
    
    if (binding_cache_lookup(site_name, auth_info,
	(unsigned_char_p_t)princ, cell_name, &new_context))
    {
	SEC_DBG_GPRINTF(("returning cached context %x\n", new_context));
	*context = (sec_rgy_handle_t) new_context;
	CLEAR_STATUS(status);
	return;
    }

Repeat by:

use the following program to open the registry with a protocol tower format
site name, and then with a cell name such as /.:. Then kill the program and
open the registry with a cel name (e.g. /.:).

#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <dce/rpc.h>
#include <dce/binding.h>
#include <dce/pgo.h>
#include <dce/dce_error.h>

char *GetDceError(ErrorCode,DefaultMessage,ErrorBuffer)
  error_status_t ErrorCode;
  char           *DefaultMessage;
  char           *ErrorBuffer;
{
  int            Status;
  char           *Rvalue;
  dce_error_inq_text(ErrorCode,(unsigned char *)ErrorBuffer,&Status);
  if (Status == 0) Rvalue = ErrorBuffer;
  else Rvalue = DefaultMessage;
  return Rvalue;
}

void ReportResult(FunctionName,ErrorCode,DefaultMessage)
  char           *FunctionName;
  error_status_t ErrorCode;
  char           *DefaultMessage;
{
  char ErrorBuffer[dce_c_error_string_len];

  fprintf(stdout,"%s(%d): %s\n",FunctionName,ErrorCode,
      GetDceError(ErrorCode,DefaultMessage,ErrorBuffer));
}

void main()
{
  unsigned_char_t    site_name[sec_rgy_pname_t_size];
  unsigned_char_p_t  bound_site_name;
  unsigned32         status;
  sec_rgy_handle_t   context;

  do
  {
    do 
    {
      printf("\nEnter the name of registry site you wish to bind to\n");

    } while (gets((char *)site_name) == NULL);

    printf("Binding to registry site:'%s'\n", (char *)site_name);

    sec_rgy_site_open(site_name, &context, &status);

    ReportResult("sec_rgy_site_open",status,"succeeded");

    if (status == error_status_ok)
    {
      sec_rgy_site_get(context, &bound_site_name, &status);
      ReportResult("sec_rgy_site_get",status,"succeeded");
      if (status == error_status_ok)
      {
        printf("bound to site '%s'\n", (char *)bound_site_name);
        free(bound_site_name);
      }
      sec_rgy_site_close(context, &status);
      ReportResult("sec_rgy_site_close",status,"succeeded");
    }

  } while (1);
}

Proposed Solution:
 
At the time of an initial bind (no matching entry in cache) using a server
name in protocol tower format, the name that is stored in the newly created
cache entry should be the CDS name of the corresponding registry server
(not the protocol tower). Doing so, would eliminate the reliance on the 
"names are the same" assumption mentioned above, since only the CDS name
for a registry server would ever be stored as the ccahed server name.

Alternatively, if it is not possible or efficient to transform a site name
in protocol tower format into the CDS name of the corresponding registry
server, then in the code fragment listed above, the site name should be
updated in the cache, each time the cache entry is reused. Furthermore, if
this turns out to be necessary, the documentation for sec_rgy_site_get and
sec_rgy_site_binding_get_info should be modified to indicate that there is
some variability in what these routines return.



CR Number                     : 8581
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : Need capability to allow specific principal(s) access to UNIX passwd
Reported Date                 : 9/10/93
Found in Baseline             : 1.0.2
Found Date                    : 9/10/93
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/10/93 public]

When the passwd_export command is executed, the UNIX password is NOT
obtained unless the registry policy for passwords is set such that
they are visible. This is a major handicap for administrators who
need to periodically synchronize their local database with the DCE registry. 

This can very easily be fixed by adding a new permission type to the policy
ACL manager, which when set will give the UNIX encrypted password to the
requesting client. 
For passw_export

[9/10/93 public]
Changed fixby to 1.1, since 1.0.3 is only a bugfix release, and this is
definitely new functionality that we couldn't even consider adding until 1.1
Changed short description so summary reports will be more accurate
(previous desc said passwd_export couldn't get Unix passwd, which it can
if the policy is set right, so there's nothing wrong with the utility itself)



CR Number                     : 8403
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_admin
Short Description             : sec_admin gives wrong err on "site <replist_name> -u"
Reported Date                 : 8/2/93
Found in Baseline             : 1.0.2
Found Date                    : 8/2/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : client/admin/sec_admin/sec_admin.c
Sensitivity                   : public

[8/2/93 public]
sec_admin won't bind to master when using slave replist name and -u flag:

-#> sec_admin -s /.:/subsys/dce/sec/repl1
Default replica:  /.../rep.cell.austin.ibm.com/subsys/dce/sec/repl1
Default cell:     /.../rep.cell.austin.ibm.com
sec_admin> site subsys/dce/sec/repl1 -u
Unable to bind to master registry - ERROR - Registry server unavailable (dce / sec)
sec_admin> lrep
Default replica:  /.../rep.cell.austin.ibm.com/subsys/dce/sec/repl1
Default cell:     /.../rep.cell.austin.ibm.com


subsys/dce/sec/master (master)

subsys/dce/sec/repl1
sec_admin> lrep -state
Default replica:  /.../rep.cell.austin.ibm.com/subsys/dce/sec/repl1
Default cell:     /.../rep.cell.austin.ibm.com


subsys/dce/sec/master (master)
          State:                   in service - master
          Last update received at: Tue Jul 13 13:44:45 1993
          Last update's seqno:     0.203

subsys/dce/sec/repl1
          State:                   in service - slave
          Last update received at: Tue Jul 13 13:44:45 1993
          Last update's seqno:     0.203
sec_admin> h site
Usage: site [name [-u[pdate]]]
sec_admin> site subsys/dce/sec/repl1 -u
Unable to bind to master registry - ERROR - Registry server unavailable (dce / sec)
sec_admin> site subsys/dce/sec/master
Default replica:  /.../rep.cell.austin.ibm.com/subsys/dce/sec/master
Default cell:     /.../rep.cell.austin.ibm.com
sec_admin> 

It works ok if global name or just cellname is used:

-#> sec_admin
Default replica:  /.../rep.cell.austin.ibm.com/subsys/dce/sec/repl1
Default cell:     /.../rep.cell.austin.ibm.com
sec_admin> site /.: -u
Default replica:  /.../rep.cell.austin.ibm.com/subsys/dce/sec/master
Default cell:     /.../rep.cell.austin.ibm.com
sec_admin> site subsys/dce/sec/repl1
Default replica:  /.../rep.cell.austin.ibm.com/subsys/dce/sec/repl1
Default cell:     /.../rep.cell.austin.ibm.com
sec_admin> site subsys/dce/sec/repl1 -u
Unable to bind to master registry - ERROR - Registry server unavailable (dce / sec)
sec_admin> site /.:/subsys/dce/sec/repl1 -u
Default replica:  /.../rep.cell.austin.ibm.com/subsys/dce/sec/master
Default cell:     /.../rep.cell.austin.ibm.com
sec_admin> site subsys/dce/sec/repl1
Default replica:  /.../rep.cell.austin.ibm.com/subsys/dce/sec/repl1
Default cell:     /.../rep.cell.austin.ibm.com
sec_admin> site subsys/dce/sec/repl1 -u
Unable to bind to master registry - ERROR - Registry server unavailable (dce / sec)
sec_admin> quit
bye.

[08/18/93 public]
This isn't supposed to work.  You cannot bind to the master with just the
replist name (the replist name functionality is only there to bind to a
specific replica) because you must use sec_rgy_site_bind_update() to get to
a master, and it requires a global name.  The site command should be fixed
so that it doesn't allow -u with a non global name (ie: give a better error
than just "Registry server unavailable").

[08/18/93 public]
Based on Mike's info, the sec_admin manpage needs to be changed too.  The
version I have (DCE 1.0.2) states that you can use a replist 
name to bind to the master:

site subcommand
site [ name [-u[pdate]] ]
                    Set or display the default cell and the default
                    replica.

                    The name argument identifies the replica to set as
                    the default replica and, as a consequence, the
                    default cell.  It can be:
                                .
                                .
                                .
                      o  The name of a replica as it appears on the
                         replica list to make the named replica (which
                         exists in the default cell) the default
                         replica.
                                .
                                .
                                .
                    The -u option specifies that sec_admin should find
                    the master replica. Normally you specify the name
                    of a cell for name in conjunction with the -u
                    option.  In this case sec_admin finds the master
                    replica in that cell. If you use a replica name
                    for name, sec_admin queries the named replica to
                    find the master replica in the named replica's
                    cell.

Perhaps this should be changed to a doc defect?

[7/27/94 public]
This CR either does not affect dcecp or has a related CR open.
It really belongs to sec_admin and should not be assigned to dcecp.

[8/1/94 public]
All control program bugs are being changed to E4 due to the existance
of dcecp.



CR Number                     : 8401
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : sec_admin
Short Description             : (DIFF) sec_admin monitor subcmd accepts
negative intervals
Reported Date                 : 8/2/93
Found in Baseline             : 1.0.2
Found Date                    : 8/2/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/admin/sec_admin/sec_admin.c
Sensitivity                   : public

[8/2/93 public]
The sec_admin monitor subcommand accepts negative values as time
intervals.  The simple fix is to the tty_do_monitor routine in
sec_admin.c:

-#> diff -c sec_admin.c sec_admin.new
*** sec_admin.c Mon Aug  2 13:59:42 1993
--- sec_admin.new       Mon Aug  2 14:00:09 1993
***************
*** 222,228 ****
      case 3:
          if (match_command("-r", c->args[1], 2)) {
              minutes = strtol(c->args[2], (char **)NULL, 10);
!             if ((minutes==0) || (minutes==LONG_MAX) || (minutes==LONG_MIN)) {
                  fprintf(stderr,
                    "%s is not a legal integer value or is out of range\n",
                      c->args[2]);
--- 222,228 ----
      case 3:
          if (match_command("-r", c->args[1], 2)) {
              minutes = strtol(c->args[2], (char **)NULL, 10);
!             if ((minutes<=0) || (minutes==LONG_MAX) || (minutes==LONG_MIN)) {
                  fprintf(stderr,
                    "%s is not a legal integer value or is out of range\n",
                      c->args[2]);

[7/27/94 public]
This CR either does not affect dcecp or has a related CR open.
It really belongs to sec_admin and should not be assigned to dcecp.

[8/1/94 public]
All control program bugs are being changed to E4 due to the existance
of dcecp.



CR Number                     : 8383
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : DES
Short Description             : DES key generation should avoid "pseudo-weak" keys.
Reported Date                 : 7/28/93
Found in Baseline             : 1.0
Found Date                    : 7/28/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/28/93 public]

In the interests of completeness and paranoia, our DES key generation
should avoid the "pseudo-weak keys" cited in _Cryptography: An Introduction
to Computer Security_, by Seberry and Pierprzyk (of the Univ. of New South
Wales).  Thanks to Walt Tuvell for noticing this one..

DES keys are converted into a 16-element "key schedule", each element of
which is logically a 48-bit quantity containing 48 of the 56 bits of the
key.

If all subkeys in the key schedule are the same, the cryptographic strength
of DES is significantly weakened; by analogy, if there are only a few
different subkeys, the algorithm is somewhat weakened.

There are four "weak" keys (with only one distinct subkey) and twelve
"semi-weak" keys (with two subkeys); there is also a set of 48 keys (which
I will call "pseudo-weak"; S&P only refers to them as "other keys") which
have only four distinct subkeys.

Currently we only reject the "weak" and "semi-weak" keys in key generation.
We should detect and reject the "pseudo-weak" keys, either in key schedule
generation (as we do for "weak" keys), or in key generation itself.  I
prefer doing this in key schedule generation for sanity checking, though it
might break communication between an old and new DCE if the old DCE picks a
pseudo-weak key.  Note that is slightly less than 1 chance in 1.5e15 of
this happening; I believe that this is in the same order of magnitude as an
undetected multiple bit error on most communications and storage media, so
I'm not going to worry about backwards compatibility in this case.



CR Number                     : 8360
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : Statement not reached and extraneous ";" cause compilation warnings.
Reported Date                 : 7/23/93
Found in Baseline             : 1.0.2
Found Date                    : 7/23/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : in security/client/admin/rgy_edit form.c tty_acct.c
Sensitivity                   : public

[7/23/93 public]

In form.c:

There is an extraneous ";" after the closing brace of the function
definition for form_num_fields().

In tty_acct.c (line 1673 in DCE1.0.2):

        } while (true);

>       SET_AND_EXIT_ON_ERROR(&st);
>       return st;

The marked statements are never reached.

[8/2/93 public]

Fixed as part of code cleanup for 1.1.  Assigned to sec_bat.



CR Number                     : 8327
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : 
Short Description             : argument/parameter incompatability
Reported Date                 : 7/20/93
Found in Baseline             : 1.0.2
Found Date                    : 7/20/93
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/server/sec_clientd/sec_clientd.c
Sensitivity                   : public

[7/20/93 public]

Full Description:

The following warning is produced during the compilation of
security/server/sec_clientd/sec_clientd.c because the 2nd parameter
of scd_thread_join is declared as a void **, and this piece of code is
trying to pass an argument of & (unsigned long *).

../../../../../src/security/server/sec_clientd/sec_clientd.c: In function
main:
../../../../../src/security/server/sec_clientd/sec_clientd.c:688: warning:
argument passing between incompatible pointer types

Proposed Solution:

	change the definition of result_p to be of type pointer to void:

	void *result_p = &result;



CR Number                     : 8325
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : simplification of krb5_add32_nowrap
Reported Date                 : 7/20/93
Found in Baseline             : 1.0.2
Found Date                    : 7/20/93
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/krb5/kdc/kdc_util.c
Sensitivity                   : public

[7/20/93 public]

    I just got a service call complaining of a compiler warning from the
the line 

    krb5_int32 sign_bit = ~((~(unsigned)0) & ((~(unsigned)0) >> 1));

of the function krb5_add32_nowrap in the file security/krb5/kdc/kdc_util.c.
The caller suggested the following change, 

    krb5_int32 sign_bit = (krb5_int32) ~((~(unsigned)0) & ((~(unsigned)0)
>> 1));

I took a closer look at the function, and it ocurred to me that a
simplification might be in order. The existing information uses the
expression (variable & sign_bit) to determine the sign of a variable.
It seems to me that equivalent functionality could be accomplished by
uniformly replacing these expressions with expressions of the form
(variable < 0) or (variable >=0). An example of substitution with
the (variable < 0) expression would look like the following).

Simplfying the function in this manner would eliminate the compiler
warning.

-------------
/*
 * add two signed integers, clipping the result to INT32_MAX or
 * INT32_MIN rather than wrapping around on overflow.
 */

krb5_int32 krb5_add32_nowrap(a, b)
    krb5_int32 a;
    krb5_int32 b;
{
    krb5_int32 sum;
    sum = a + b;

    /* 
     * The following assumes twos-complement binary arithmetic.
     * If you don't like it, fix your ALU.
     * 
     * We overflow if sign(a) == sign(b) && sign(sum) != sign(a) 
     */
    if (((a < 0) ^ (b < 0)) == 0)
    {
	if ((a < 0) ^ (sum < 0)) 
	{
	    /* we overflowed */
	    if (a < 0) 
	    {
		sum = KRB5_INT32_MIN;
	    } else 
	    {
		sum = KRB5_INT32_MAX;
	    }
	}
    }
    return sum;
}



CR Number                     : 8322
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : ANSI-C compiler warning at comparison between signed and unsigned arithmetic types.
Reported Date                 : 7/20/93
Found in Baseline             : 1.0.2
Found Date                    : 7/20/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/login/sec_login_np.c
Sensitivity                   : public

[7/20/93 public]
In security/client/login/sec_login_np.c the line "&& len < strlen(name)" in
the following code fragment:

PUBLIC  void  sec_login_pvt_get_local_login_info
...
                else {
                    dce_cf_get_cell_name(&my_cell, &lst);
                    if (GOOD_STATUS(&lst)) {
                        int len;

                        len = strlen(my_cell);
                        if (strncmp(name, my_cell, len) == 0
                        && len < strlen(name)
                        && name[len] != '\0') {
                            /*  add 1 to get past '/' separator */
...
	
causes some ANSI-C compilers to generate a warning. Why not replace the
declaration "int len" with "unsigned len" (or maybe size_t len)?

[8/2/93 public]

Fixed as part of code cleanup for 1.1.  Changed to enhancement
until 1.0.3 ships.



CR Number                     : 8318
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : redefinition of pthread_equal_np
Reported Date                 : 7/19/93
Found in Baseline             : 1.0.2
Found Date                    : 7/19/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/server/sec_clientd/scd_thread.c,security/server/rs/rwl.c
Sensitivity                   : public

[7/19/93 public]

scd_thread.c redefines macro pthread_eqaul_np. The original definition
occurs in pthread.h which is included in scd_thread.c.

Proposed solution:

	It doesn't appear necessary for scd_thread.c to define
pthread_eqaul_np. Alternatively, compiler warning could be extinguished
by bracketing the definition of pthread_equal_np in scd_thread.c
with

	#ifndef pthread_equal_np

	...

	#endif.

[10/28/93 public]

similar problem was discovered in security/server/rs/rwl.c which
includes un_maloc.h which includes krb5/osf_dce.h which includes
thread.h, which results in previous definition of pthread_equal_np.

Proposed solution:

	same as above, first determin if the definition
        should be removed form rwl.c, and if not then
        bracketing the definition of pthread_equal_np in rwl.c
        as follows

	#ifdef pthread_equal
+	#ifndef pthread_equal_np

        #define pthread_equal_np pthread_equal

+       #endif
	#endif

	Note that the following comment appears in rwl.c

/****  SNI_SEC_MERGE: Check to see if the following code is not required
                      because pthread_equal_np is already defined to be
                      the equivalent of pthread_equal
****/



CR Number                     : 8316
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : 
Short Description             : warning: argument passing of pointer from integer lacks a cast
Reported Date                 : 7/19/93
Found in Baseline             : 1.0.2
Found Date                    : 7/19/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/krb5/comerr/com_err.c
Sensitivity                   : public

[7/19/93 public]

Full Description:

	At approximately line 109 there is a call to fputs which uses as
it's first argument the returned value from a call to error_message.

	fputs(error_message(code), stderr);

error_message is defined in security/krb5/comerr/error_message.c as

	const char * error_message (code)

and by prototype  security/krb5/comerr/com_err.h as

	extern char const *error_message (long);

the include of com_err.h has been commented out of com_err.c,
causing the definition of error_message to default to

	int error_message();

The result being that at compile time we get the warning

../../../../../../src/security/krb5/comerr/com_err.c:108: warning: argument
passing of pointer from integer lacks a cast

Proposed Solution:

	reinstate definition of error_message() in com_err.c either
        by uncommented include of com)_err.h, or by an adding a new
        definition.



CR Number                     : 8315
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : krb5/lib/os/read_pwd.c
Short Description             : There is a missing type cast
in the file read_pwd.c which causes a warning when the file is compiled
Reported Date                 : 7/19/93
Found in Baseline             : 1.0.2
Found Date                    : 7/19/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/19/93 public]

     The line:

     if ( (ointrfunc = sigset(SIGINT, intr_routine)) == SIG_ERR )
               SHOULD BE REPLACED WITH
     if ( (ointrfunc = sigset(SIGINT, (void (*)())intr_routine)) == SIG_ERR )

     at line 194.

[07/20/93 public]
NO!  Fix intr_routine so that it is defined properly to be an ANSI/Posix
style signal handler, not a V7 Unix signal handler.

Don't cast, fix the code.

[07/20/93 public]
Added myself to interest list.

[8/2/93 public]

Fixed as part of code cleanup for 1.1.  Changed to enhancement until
1.0.3 ships.



CR Number                     : 8314
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : remove unreachable abort() statements
Reported Date                 : 7/19/93
Found in Baseline             : 1.0.2
Found Date                    : 7/19/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/utils/sec_authn.c
Sensitivity                   : public

[7/19/93 public]

in sec/utils/sec_auth.c there are two places where abort() is called at the
end of a function. With each of these calls, there is a comment which
indicates that it was the developer's intention to design the function
such that it would only return by one of the flows enumerated in the body
of the function, and that the abort statement was included to detect and
extinguish unanticipated flows which would result in a return from the
function at its closing brace.

An interesting characteristic of this strategy is that, given a
finicky enough compiler, you get a complaint when the function is written
as designed, and the complaint goes away when an erroneous change to the
function causes the abort message to become reachable. It seams to me that
it would be easy to refute this coding practice if there was a way (using
C) to turn the equation around, such that the compiler is silent as long as
the function is guaranteed to return by one of the implemented return
statements, and you get a warning or error when it is it is possible to
drop out at the bottom.

Proposed Solution:

    remove abort statements from end of functions:

        sec_krb_dg_build_message
        sec_krb_cn_build_message

[7/19/93]

The "abort()" calls can go.

If the functions are not void (and I think they aren't; I don't have
time at this moment to check), a good compiler will warn if you can
"fall off the end" and not return a value.

					- Bill



CR Number                     : 8311
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : krb5/lib/mvr/krb5-manual-glue.c
Short Description             : There are several missing type
casts which cause warnings when the file is compiled
Reported Date                 : 7/19/93
Found in Baseline             : 1.0.2
Found Date                    : 7/19/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/19/93 public]

Full Description: (NOTE: Line numbers are only approximate due to source
     control headers)

     The line:

     m->v = asn1_malloc (4);
          SHOULD BE REPLACED WITH
     m->v = (asn1)asn1_malloc (4);

     at line 120.

     The line:

     m->v = asn1_malloc (len?len:1);
          SHOULD BE REPLACED WITH
     m->v = (asn1)asn1_malloc (len?len:1);

     at lines 141 and 161.

     The line:

     m->v = asn1_malloc (20);
          SHOULD BE REPLACED WITH
     m->v = (asn1)asn1_malloc (20);

     at line 176.

[8/2/93 public]

Fixed as part of code cleanup for 1.1.  Changed to enhancement until
1.0.3 ships.



CR Number                     : 8308
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : compiler warnings
Reported Date                 : 7/19/93
Found in Baseline             : 1.0.2
Found Date                    : 7/19/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/utils/sec_id_pac_util.c
Sensitivity                   : public

[7/19/93 public]

In function sec_id_pac_util_free chnage the decalaration of i as follows:

	change: int i;

	to:	unsigned16 i;

This change will elimate compiler warnings resulting form the
compilation of the following lines:

line 80:	for (i = 0; i < p->num_groups; i++) {
line 92:	for (i = 0; i < p->num_foreign_groups; i++) {

[7/19/93 public]

If at all possible, use just "unsigned". instead of "unsigned16".  This
will make for less size-specific code (should we choose to widen the
num_groups/num_foreign_groups fields in the future).



CR Number                     : 8307
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : 
Short Description             : warning: return between incompatible pointer types
Reported Date                 : 7/19/93
Found in Baseline             : 1.0.2
Found Date                    : 7/19/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/utils/crypt.c
Sensitivity                   : public

[7/19/93 public]

function sec_crypt_create_context is defined to return type
sec_crypt_handle_t, but returned value is type sec_crypt_context_t.
This results in compiler warning 

../../../../src/security/utils/crypt.c:244: warning: return between
incompatible pointer types

Alternative Solutions:
	
	a. cast value before return to type sec_crypt_handle_t

	b. security/h/crypt.h defines sec_crypt_handle_t as

		typedef  Pointer  sec_crypt_handle_t;

	   security/h/Pointer.h	defines Pointer as

           #   if !defined(apollo) || defined(CHARPTR)
                   typedef char * Pointer;
           #   else
                   typedef void * Pointer;
           #   endif

	   which appears to define the Pointer type for the purpose
	   of holding an opaque pointer to any datatype.

	   Note that this capability has only been enabled for
           compilation environments which define apollo and don't
           define CHARPTR. I suggest that we expand the situations
           where Pointer is typedefed to be a void *, such that it
           includes other compilation environments most notably,
           OSF1/i486 (I suspect we must be careful not to include
           environments where pointesr are of different sizes).



CR Number                     : 8302
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : deletion of principals needs work
Reported Date                 : 7/16/93
Found in Baseline             : 1.0.2
Found Date                    : 7/16/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/16/93 public]

Our handling of the deletion of principals is suboptimal.

Because of the caching of tickets in login contexts, we shouldn't delete
and then recreate a principal name in a time interval less than the maximum
ticket lifetime.

We could implement this by leaving the old name around pointing at a
"zombie" principal until the lifetime has run out.  If you attempt to
re-create a principal inside that lifetime, either
	a) you get an error and it refuses to let you do this
or
	b) you start with a key version number other than the default
initial value.

This would give you a distinct error message indicating that you used the
wrong version if you re-use a stale ticket talking to a new server.

We could then handle that error by nuking that ticket out of the credential
cache, fetching a new one, and trying again.

there would need to be a limit on the number of iterations you try on that,
lest you wind up in an infinite loop fetching the same ticket over & over
again..

This is too much of a change for 1.0.3; marked "fix in 1.1".



CR Number                     : 8278
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : 
Short Description             : security/server/bin/Makefile redefines BSD
Reported Date                 : 7/15/93
Found in Baseline             : 1.0.2
Found Date                    : 7/15/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/server/bin/Makefile
Sensitivity                   : public

[7/15/93 public]

section 3.8.3 Macro Replacement of the ANSI C specification (X3.159-1989),
clause 10, states basically that an identifier defined using define can
only be redefined in a second define statement if the definitions are
identical. Otherwise, it is a compilation error.

The security/server/bin/Makefile redefines BSD using the -DBSD mechanism
this redefinition is incosistent with the definition of BSD present in
sys/param.h (#define BSD     198911)

Our builds at OSF only produce a warning, which is lucky for us, but we
should have expected to pay more dearly if our compiler followed the
spec. There is some question about whether or not this define should occur
in the sys/param.h file, or in other words, whether it is really OSF1
which should be fixed.

/u1/skel/dce/export/pmax/usr/include/sys/param.h:374: warning: BSD

Proposed Solution:

Add the -DBSD to the RIOS_CFLAGS and remove it from the the CFLAGS
definition. That is, if there is any reason the RIOS build depends
on BSD.



CR Number                     : 8256
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : des
Short Description             : des_ecb_buffer not used
Reported Date                 : 7/12/93
Found in Baseline             : 1.0.2a
Found Date                    : 7/12/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/krb5/lib/crypto/*/ecb_buffer.c
Sensitivity                   : public

[7/12/93 public]

As far as I can tell (via a "grep" over the 1.0.2a source tree),
des_ecb_buffer is not used anywhere in the DCE source tree.

In any event, encrypting byte streams in ECB mode is not recommended, as it
turns the cipher into a 64-bit simple substitution cypher.. patterns in the
underlying plaintext with 8-byte alignment show up as similar patterns in
the cyphertext.  It would really be bad for, encrypting RISC object code,
where the underlying symbols are typically 4-byte aligned anyway..

It should be flushed from the source tree.



CR Number                     : 8216
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : sec_admin
Short Description             : C shorthand foils printf on SunOS
Reported Date                 : 6/30/93
Found in Baseline             : 1.0.2
Found Date                    : 6/30/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : client/admin/sec_admin/sa_util.c,sa_replist.c
Sensitivity                   : public

[6/30/93 public]
I've been seeing the following in sec_admin info, monitor, and lrep
output for a few months on Suns and not realizing that it was in error:
sec_admin> info
Default replica:  /.../rainier.dce.transarc.com/subsys/dce/sec/master
Default cell:     /.../rainier.dce.transarc.com
          State:                    - master
          Last update received at: Wed Jun 30 10:33:11 1993
          Last update's seqno:     0.43520
Note the blank before the dash in the 'State:' line. The code lines
causing this are printf()'s that expect the following argument to fill a
%s format: 
		rgy_state[infoP->rep_state]
rgy_state is an array of structures, each having one field, a char
pointer. I haven't the time to figure out why, but the SunOS 4 and the
Solaris 2.* C compiler does not complain about this, yet does *not*
issue code that passes the contents of that singular field to printf() .
What results - every time - is a single space being printed for that %s .
Changing the references to the above structure to the following fixes
the problem and places this argument into strict(er) C syntax:
		rgy_state[infoP->rep_state].state
Changing this twice on about lines 566 and 569 - in routine
sa_print_site_info() - causes the above missing field to show up every
time.
Also found along the way for this was that, in sa_replist.c, there is an
unused, similar structure array called "rep_state" which is not
referenced (at least, as far as 'grep' reveals) anywhere; maybe this was
superceded by 'rgy_state'?

[7/9/93 public]
  There's also one other instance of this: a use of array
'prop_type_text' at about line 350 or so of sa_replist.c .
It too was found to need '.state' appended to the reference
in order to solve the same problem
Changed Affected File from `client/admin/sec_admin/sa_util.c' to 
 `client/admin/sec_admin/sa_util.c,sa_replist.c'

[8/2/93 public]

SunOS only problem.  Changed to enhancement.



CR Number                     : 8177
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : krb5_read_password
Short Description             : krb5_read_password not even close to thread-safe if interrupted.
Reported Date                 : 6/18/93
Found in Baseline             : 1.0
Found Date                    : 6/18/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
	security/krb5/lib/os/read_pwd.c
Sensitivity                   : public

[6/18/93 public]

krb5_read_password isn't even *close* to thread safe (it does a longjmp
from a signal handler to deal with an interrupted read.  Just plain bad
news...).

It's not at all clear what the correct fix is..



CR Number                     : 8170
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : definition of GOOD_STATUS STATUS_OK
Reported Date                 : 6/17/93
Found in Baseline             : 1.0.2
Found Date                    : 6/17/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/h/macros.h and others
Sensitivity                   : public

[6/17/93 public]

 The macros:

 #define STATUS_OK(stp)   ((stp)==NULL || (*stp) == error_status_ok)
 #define GOOD_STATUS(stp) ((stp)==NULL || (*stp) == error_status_ok)

 Looks wrong. If some function call sets the status (stp) to NULL then this
 GOOD_STATUS(stp) will return true incorrectly.  Shouldn't it be:

 #define GOOD_STATUS(stp) ((stp)!=NULL && (*stp) == error_status_ok)

 implying that NULL stp is also incorrect.

 This argument is backed by the definition and typical use of the following
 macro:

 #define SET_STATUS(stp, val)      (*stp) = val

 And you will see many places in DCE code the following logic:

 if (GOOD_STATUS(st)) {
 ...
   SET_STATUS(st, xxx_s_xxx);
 ...
 }

 What would you expect if 'st' is NULL? GOOD_STATUS will allow it and
 SET_STATUS would core dump it!!!

Repeat By:

        N/A

Proposed Solution:

        Change the definition of GOOD_STATUS(stp) and STATUS_OK(stp)
        (at many places in DCE code) to the following:

 #define GOOD_STATUS(stp) ((stp)!=NULL && (*stp) == error_status_ok)

        Or on the contrary you want to change SET_STATUS(stp, val) to:

#define SET_STATUS(stp, val)      (stp? (*stp) = val : ;)

        This won't solve all the problems because there are many instances of
        '*stp = val' that does not check for stp != NULL.

[06/17/93 public]
I believe that passing in a NULL pointer for a status parameter is generally
not supported and that it is therefore okay for SET_STATUS to not check
for a NULL pointer.  I would like to see either GOOD_STATUS or STATUS_OK
go away -- why have two ways of saying the same thing?  I am not sure
about the first comment here; perhaps the "stp == NULL" test should just
be removed altogether.

[6/17/93 public]

What he said.

The test against NULL is bogus and stands only as an invitation for certain
code-coverage tools to generate deflated test coverage metrics.

The MMU is in your systems for a reason; let *it* detect the store through
a null pointer.

[8/2/93 public]

Fixed as part of code cleanup in 1.1.  Changed to enhancement until
1.0.3 ships.



CR Number                     : 8131
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : acl_edit should be able to delete stranded acl entries
Reported Date                 : 6/9/93
Found in Baseline             : 1.0
Found Date                    : 6/9/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/9/93 public]

From comp.unix.osf.misc; this is an enhancement, not a bug, because there
is a workaround (adopt the principal).

Newsgroups: comp.unix.osf.misc
Path: apollo.hp.com!sdd.hp.com!col.hp.com!csn!cherokee!da_vinci!jld
From: Jeffrey L. DeMent <jld@advtech.uswest.com>
Subject: Deleting Obsolete ACL Entries
Message-ID: <C8B3wF.ErH@da_vinci.it.uswc.uswest.com>
Originator: jld@dropzone
Sender: news@da_vinci.it.uswc.uswest.com (IT Netnews)
Nntp-Posting-Host: dropzone
Reply-To: Jeffrey L. DeMent <jld@advtech.uswest.com>
Organization: U S WEST Advanced Technologies
Distribution: usa
Date: Tue, 8 Jun 1993 14:21:51 GMT
Lines: 41

Tell me this is not true .....

I have obsolete ACL entries I would like to remove but acl_edit does not
let me do it, for instance:

% acl_edit /.:/u/jld -l

# SEC_ACL for /.:/u/jld:
# Default cell = /.../ssed.advtech.uswest.com
unauthenticated:r--t---
user:cell_admin:rwdtcia
user:hosts/hacksaw/cds-server:rwdtcia
user:000015B6-7A86-2B3F-B200-820D1A420000:rwdtci-
group:subsys/dce/cds-admin:rwdtcia
group:subsys/dce/cds-server:rwdtcia
any_other:r--t---

This ACL entry belongs to a principal I've deleted.  When I try and remove
a single entry, acl_edit complains about the syntax:

% acl_edit /.:/u/jld -d user:000015B6-7A86-2B3F-B200-820D1A420000:rwdtci-

AND ACL_EDIT SAYS INVALID ENTRY OR WORDS TO THAT EFFECT.

I've been told the only way to remove the offending entry is to use "kill"
and blow away all ACL entries for /.:/u/jld and then re-entry the ones I
want to keep.  Isn't there a better way ?

Jeff
_____________________________________________________________________

 Jeffrey L. DeMent                                  _._._._._._._
 U S WEST Advanced Technologies                    (_|_|_|_|_|_|_)
 1475 Lawrence Street, Suite 400                    ` \` | | '/ '
 Denver, Colorado  80202                             ` \`| |'/ '
                                                      ` \| |/ '
 Phone: (303) 595-0519                                 ` \0/ '
 FAX:   (303) 592-6532                                  `~#~'



CR Number                     : 8092
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : security repl. authentication
Short Description             : unnecessary key schedule generation
Reported Date                 : 6/4/93
Found in Baseline             : 1.0.2
Found Date                    : 6/4/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : server/rs/rs_rep_auth.c
Sensitivity                   : public

[travis@transarc.com 6/4/93 public] Just a nit -- private routine
  decode_auth_info() in rs_rep_auth.c calls krb5_process_key() even
though the computed eblock is not used; instead, the immediately
following call to krb5_decrypt_tkt_part() repeats the krb5_process_key()
call within its own scope, on a local eblock. Just a minor performance
thing -- rarely happens -- but it does happen under a read lock on the
database.



CR Number                     : 8040
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : unix test
Short Description             : unxi test #4 failed.
Reported Date                 : 5/21/93
Found in Baseline             : 1.0.2
Found Date                    : 5/21/93
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
 ./test/security/api/moretests/unix_getgrnam.c
Sensitivity                   : public

[5/21/93 public]
Not initialized person_name before calling strcat.  So test failed
with "data mismatch"



CR Number                     : 8014
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : 
Short Description             : more problems with key garbage collection
Reported Date                 : 5/18/93
Found in Baseline             : 1.0.2
Found Date                    : 5/18/93
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/18/93 public]
Some (post - OT 7612) analysis by OS/2 DCE development:

    Assuming all fixes made under O.T. 7612 are in place, the garbage
 collection algorithm is still not "foolproof".  It is not foolproof
 since the tacit assumption made under 7612 was that the policy
 parameter "maximum ticket lifetime" remains a constant over time.

    It is not difficult to construct scenarios where the value of
 "max ticket lifetime" is reduced over a time period, and where
 some number of key updates have occurred.  In such situations, one
 can have a key garbage collected that still represents a valid,
 unexpired ticket.  For example:

    - at hour zero, max ticket lifetime = 16 hours.  User obtains
        ticket for application server ABC, good for 16 hours.  Let's
        call the key used to encrypt this ticket X

    - at hour one, administrators decide max ticket lifetime should
        be set to "standard" value of 8 hours.

    - at hour two, server ABC just so happens to do its periodic key
         update.  Let's call this new key X+1.

    - at hour eleven, an administrator decides, for some reason, to
         manually alter ABC's key via the rgy_edit "kta -p ABC -r -a".
         (The administrator may well have to alter the acl for ABC
         first, to grant 'u' permission to himself.)  This generates
         key X+2.  It turns out that key X+1 is the most recent key
         that was generated prior to time (NOW-maxticket life) which
         is (11-8) = third hour.  Hence, by 7612 algorithm, key X is
         housecleaned and removed from the keytable that server ABC
         is looking at.

    - from hour eleven until hour sixteen, use of the original ticket
         to server ABC will fail.  ABC will be unable to decrypt it.

    Thus, thought should be given as to whether there is a reasonable
 fix to this problem.  One possible solution that does not work in
 all situations is to store the max_ticket_life that existed at time
 of key generation with that key in the key table.  The problem here
 is that during the timeframe before the *next* key is generated, the
 max ticket lifetime could have changed.  To be foolproof, you need
 to know what the largest value of max_ticket_life was between the
 period timestamp(X) and timestampt(X+1).  (And, given the fact that
 several registry entities control what is effectively the maximum
 ticket lifetime makes the problem somewhat more complicated.)

    The only other general solution that pops into mind would be to
 make the registry maintain a "history of effective maximum ticket
 lifetime" values.  Thus, when clients do garbage collection, they
 could query the registry for the maximum ticket life between two
 requested times.  Typically, it would ask for the period between
 the granting of X and X+1.   Besides defining a new API, this solution
 has additional "headaches":  what criteria is used to clean up this
 "history"; more importantly, how does the history reflect changes
 to the effective max_ticket_life that is unique per principal due to
 altering max ticket life in the individual accounts?  This would
 seemingly complicate the processing of the "history" file to a much
 greater extent than if you assumed max_ticket_life applied equally
 to all principals.

    In any event, some thought needs to be given.  Perhaps the overhead
 of the above solutions is too much cost for too little benefit.  Perhaps
 simpler solutions, not necessarily foolproof, should be considered
 to at least solve scenarios like the one given.  Perhaps the registry
 could adapt some ad hoc policies, such as "ensure that the password
 lifetime be at least 3 times as great as max ticket lifetime".  In
 addition, restrictions might be placed on how often key updates could
 occur based on these policy parameters.  The affect of all of this
 might be to realistically reduce the problem of garbage collection,
 but not render it foolproof.

    Or, the affect of this O.T. could simply be to provide adequate
 warnings in documentation as to what might happen if administrators
 muck around with the max_ticket_lifetime, or if administrators take
 it upon themselves to change passwords for server principals, a job
 normally associated with a daemons special thread.

 SUMMARY:

    After 7612, there still exist odd circumstances where keys for
 still valid tickets will be garbage collected.  These scenarios are
 somewhat unlikely, and require both changes to max_ticket_life and
 administrator manual changes to server keys.  It appears that any
 foolproof solution involves significant work.  It may be acceptable
 to use ad hoc solutions which further limit the possibility of
 "bad" garbage collection.  It may be acceptable to provide warnings
 in documentation.  This is not truly a serious problem as of yet,
 it would not appear, so the luxury exists of thinking through all of
 this thoroughly before a decision is made.



CR Number                     : 7806
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : security tests
Short Description             : security tests have the password -dce- hardcoded in scripts and C code.
Reported Date                 : 4/27/93
Found in Baseline             : 1.0.2
Found Date                    : 4/27/93
Severity                      : C
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/27/93 public]

Many of the security tests only work if the cell_admin password is -dce-.
This basically means NONE of the tests can be run on a real cell. Worse,
knowledge of this password has been hardcoded into C sources, for example:

	src/test/security/api/moretests/unix_getpwname.c

and several others in that directory.

The cell_admin password (and really the account name too) should be
parameterized, so that the tests can be run in a real cell.

[10/14/93 public]

The test functionality works as required. This request is not a defect, but
an enhancement to support flexible cell admin password. Changing this
defect to an enhancement.

[9/1/94 public]

Lowered priority and deferred to 1.2 .
It does not seem that running the tests on a 'real' cell is a
high priority item.  First it will bring the cell to its knees
and make it unusable for some time.  Second the tests are liable
to leave the cell in unknown state as not much consideration has
been given to the case of them being run on a 'real' cell.
Finally it's too late for the 1.1 timeframe.



CR Number                     : 7788
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : rgy_edit
Short Description             : auth pol changes in rgy_edit are
confusing
Reported Date                 : 4/22/93
Found in Baseline             : 1.0.2
Found Date                    : 4/22/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/22/93 public]
rgy_edit has some serious usability problems.

Situations (1) and (2) below are just a couple of the inconsistent and puzzling
ways in which rgy_edit acts.  I've made suggestions (labeled A - C) that I think 
would clear up some confusion.


(1) Changing an account's "Max certificate lifetime" and "Max renewable
    lifetime" is inconsistent, depending on how the "change" subcommand
    is invoked.

rgy_edit=> c -p julie
Enter new misc info: 
Enter new home directory: 
        .
        .
        .
Create/Change auth policy for this acct [y/n]? (n) y
Enter maximum certificate lifetime in hours or 'forever': 
Enter maximum certificate-renewable lifetime in hours or 'forever': 

rgy_edit=> c -p julie -g none -o none
Enter new account id [pname]: (julie)
Enter account group [gname]: none
        .
        .
        .
Enter maximum certificate lifetime in hours or 'forever': (8) 
Enter maximum certificate-renewable lifetime in hours or 'forever': (168) 

Default change values are provided in the second case but not in the first.
The values provided in the second case do not match the default values
for the registry as seen with the "au" subcommand.

rgy_edit=> au
  Authorization Policy:
    Max certificate lifetime:                 1d
    Max renewable lifetime:                   4w
Do you wish to make changes [y/n]? (n)

Suggestions:
A) If default change values are provided, they should be provided via any
   change path.
B) The default change values should match the default auth policy values.
C) The "max certificate lifetime" and "max certificate renewable lifetime"
   should not specify hours for input -- they both take values of the
   form XwXdXhXm.

(2) When viewing an account, if the auth policy has not been changed, the
    values for "max certificate lifetime" and "max certificate renewable lifetime"
    are shown as "default-policy" upon a "view -f".  Once they've been
    changed to some numeric value, the values shown are the numeric values of what

    they've been changed to, even if that value is greater than the registry auth
    pol value. If they've been changed to "forever", the values shown go back to
    "default-policy".

Suggestion:
A) Upon a full view of an account, values for "max certificate lifetime" and
   "max certificate renewable lifetime" should show the numeric values of the
   account policy (if set) AND the numeric values of the policy in effect (which
   should be the shorter of the account policy and the registry policy).

[4/23/93 public]
This is really asking for enhancements to rgy_edit to make it easier to
understand, so I changed it from 'def' to 'enh'.  Here's answers to some
of the above comments:

> Default change values are provided in the second case but not in the first.
Default values for any account change prompt are those values that are already
stored in the database.  In the first case you are doing what rgy_edit
considers a wildcard change (specified only subset of princ,group,org) so 
there is no specific account.  Another enhancement CR is open to make sure
that we change it so that rgy_edit won't consider any operation a wildcard
if the principal is specified (in it's previous incantation, rgy_edit
operated in an environment where you could have more than 1 acct per princ),
which will fix that particular problem.  Then in the case where you specified
a wildcard (ie: just group and/or org), this part of this CR will address the
fact that it should use the RGY's auth policy for the default values.  We
will not change the defaults for the non-wildcard case, because they currently
match the way the rest of account changes work.

>C) The "max certificate lifetime" and "max certificate renewable lifetime"
>   should not specify hours for input -- they both take values of the
>   form XwXdXhXm.
Yes that prompt is confusing, but the current rgy_edit prompt mechanism had
limited us to 1 line prompts, and there wasn't enough room in 80 chars to
say: "Enter maximum certificate-renewable lifetime in hours if you don't
specify units, or in format XwXdXhXm or 'forever':"    :-)
The specify in hours was correct until we let you specify the kerberos type
lifetime units described above.  Now if you don't specify a unit it will
default to hours.  If you specify any units, you must do it in the form
above, and if you specify 'lifetime' it defaults to 0 (which is forever).
We need to figure out how to say that all in one prompt.

>(2) When viewing an account, if the auth policy has not been changed, the
>values for "max certificate lifetime" and "max certificate renewable lifetime"
>are shown as "default-policy" upon a "view -f".  Once they've been
>changed to some numeric value, the values shown are the numeric values of what
>they've been changed to, even if that value is greater than the registry auth
>pol value. If they've been changed to "forever", the values shown go back to
>"default-policy".

If the auth policy has never been modified via rgy_edit for a specific acct,
then it doesn't even exist in the registry (it's unique in this way).  That's
why all it can tell you is that it's 'default-policy'.  If they're set to
'forever' then it really isn't valid forever, it's valid for the lifetimes
in the RGY's auth policy (which is <= your auth policy if yours is forever).

>Suggestion:
>A) Upon a full view of an account, values for "max certificate lifetime" and
> "max certificate renewable lifetime" should show the numeric values of the
> account policy (if set) AND the numeric values of the policy in effect (which
> should be the shorter of the account policy and the registry policy).
We'll consider printing the "effective auth policy" too.

Note that a lot of the prompts may be improved when we redo them all for the
DCE1.1 i18n work... and hopefully the output labels can be improved a little
too.



CR Number                     : 7779
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : lack of concurrancy control on secd cred. refresh
Reported Date                 : 4/21/93
Found in Baseline             : 1.0.2
Found Date                    : 4/21/93
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/21/93 public]

This defect report is extracted from 7751 so that it can be closed.

There may be a problem with concurrancy control on ticket refresh in the
rs_login module.  There's no guarantee that there is the proper amount of
interlocking between clients using the security server's machine principal
and sec. principal contexts, and the thread(s) refreshing them.

It's also not clear why we need two threads to do this when one thread
could conceivably handle both.

[8/2/93 public]

Responsible engineer -> hanfei.

[10/13/93 public]

potential (but not seen yet) concurrancy problem on refresh.



CR Number                     : 7770
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : need well known anonymous cell uuid for security
Reported Date                 : 4/21/93
Found in Baseline             : 1.0.2
Found Date                    : 4/21/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[4/21/93 public]
When an unauthenticated user creates a file, acl_edit can't comprehend the
realm UUID in the file's ACL.  It is indeed a bogus UUID, consisting of
-2 in the first word, and zeroes in the other three words.  This UUID was
assigned to the unauthenticated user (i.e. put into his PAC) by the fshost
module of DFS, in order to avoid assigning any legitimate realm UUID to the
unauthenticated user.
Sample output, courtesy of Shepherd B. Shi, who added annotations:
# dce_login cell_admin -dce-
Password must be changed!
# exit
# klist | grep principal
Default principal: hosts/sos.austin.ibm.com/self@sos.cell.austin.ibm.com
# touch foo1
# acl_edit foo1 -l
/***********?????!!!!!! **********************************************/
Unknown default cell from ACL - ERROR: Cell UUID is not a valid cell name (
dce / sec)
INFO: Local cell will be used for operations requiring default cell info.
# SEC_ACL for foo1:
/***********Wrong default cell ****************************************/
# Default cell = fffffffe0000.00.00.00.00.00.00.00.00
user_obj:rw-c--
group_obj:rw----
other_obj:rw----
/***********Where is this from? **************************************/
foreign_other:/.../sos.cell.austin.ibm.com:rw----
The "foreign_other" entry is a separate problem, probably a bug in Episode,
and is not relevant to this bug.
The fshost module, when handling an unauthenticated user, should use a
realm UUID that acl_edit will be able to understand.  I suggest that there
should be a well-known realm UUID that does not represent any real realm,
but is understood as such by the fshost module and by acl_edit.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[5/23/93 public]
Why is this listed as a test defect instead of code?

[5/23/93 public]
Filled in Interest List CC with `lhughes@austin.ibm.com'

[5/24/93 public]
I have no idea why this was "test" rather than "code".  No wonder no one found
it.
Changed CR in Code, Doc, or Test? from `test' to `code'

[8/17/93 public]
                                                                              
For the record, I am posting our recent discussion (between Burati and Tu) 
on this issue at the end. 
Assign this to Elliot to coordinate the task among OSF, HP and Transarc.
                                                                              
From: burati@apollo.hp.com
Date: Tue, 17 Aug 93 13:29:25
Subject: Re: ot7770 and acl_edit
To: Shu-Tsui_Tu@transarc.com
Cc: pato@apollo.hp.com, frisco@apollo.hp.com, rsalz@osf.org, dmackey@osf.org
                                                                              
> It is nice to hear back... This is with regard to ot7770. Attached at the end
> is a copy of the ot report for that defect.
> Briefly speaking, when an anonymous user creates a file, the (uid, gid) is
>            42949672944294967294      0 Aug 17 10:34 anony
> however, acl_edit -l on this will get spurious message like :
> # acl_edit anony -l
> Unknown default cell from ACL - ERROR: Cell UUID is not a valid cell name (dce / sec)
> INFO: Local cell will be used for operations requiring default cell info.
> # SEC_ACL for anony:
> # Default cell = fffffffe0000.00.00.00.00.00.00.00.00
> user_obj:rw-c--
> group_obj:r-----
> other_obj:r-----
This is correct behavior because it is an unknown cell uuid (it can only know
about cell uuid's that succeed when passed to sec_id_gen_name() ).    
> If we can define a well-know cell uuid for the anonymous cell, then the
> problem would be resolved.
                                                                              
True, but that deserves some thought and planning, to make sure we come up
with a correct concept for an anonymous cell for all possible uses, not just
to change the acl_edit behavior.
> The DFS server currently assigns "-2" or (65534 for SUN) to frist 32
> bits of the cell uuid, group uuid and user uuid respectively upon detecting
> the caller is an unauthenticated.
> Unless, you have other suggestions, we would like to propose using "-2" (i.e.,
> fffffffe0000.00.00.00.00.00.00.00.00) or  "65534" (in the case of running on
> Solaris) as the well-known cell uuid representing the "unknown" cell.
                                                                              
I didn't like the idea of this, but couldn't think of a concrete reason off the
top of my head as to why it was a bad idea, so I left Joe some vmail (he's out
on business, then vacation for a while) and just got a reply.  Here's a summary
of his opinion:
                                                                              
This is bad, because it's not a legal uuid.  A cell uuid must be a legal
principal uuid, which means it must be tagged internally so that it can be
recognized as a valid principal uuid. It seems that we need to come up with
a well known anonymous cell id...
                                                                              
> If we agree on this, the remaining work is just to modify acl_edit.
We agree that something needs to be done.  This will take more effort than just
going ahead and doing it (to make sure the parse name and gen name calls can
handle it, and that it's recognized correctly by anything that might receive
it...), which will most likely not happen (or be allowed to happen by OSF) for
1.0.3.  Joe didn't seem certain has to how we should go about defining (and
creating a default principal for?) the well known anonymous id, and neither of
us will have much time to work on it in the next couple of weeks, but we should
keep it on the list of things that need to be worked out...  Maybe this should
be brought up on the tech conf call (Rich, Dick?)
                                                                              
..Mike
-------
Changed Interest List CC from `lhughes@austin.ibm.com' to 
 `lhughes@austin.ibm.com, tu@transarc.com' 
Changed Responsible Engr. from `bwl@transarc.com' to `jaffe@transarc.com'

[8/17/93 public]
I wanted to be aware of the verdict with respect to "nobody."
Changed Interest List CC from `lhughes@austin.ibm.com, tu@transarc.com' to 
 `lhughes@austin.ibm.com, tu@transarc.com, jeff@transarc.com'

[8/18/93 public]
I'm assigning this to security, since the main problem here seems to be the
definition of an anonymous cell id.  When this issue is decided, we will need
at least three defects, one for changes to acl_edit and security, one for DFS,
and one for doc changes.
Changed H/W Ref Platform from `pmax' to `all' 
Changed S/W Ref Platform from `osf1' to `all' 
Changed Short Description from `acl_edit chokes on file created by unauth user' 
 to `need well known anonymous cell uuid for security' 
Changed Responsible Engr. from `jaffe@transarc.com' to `burati@apollo.hp.com' 
Changed Resp. Engr's Company from `tarc' to `hp'

[08/18/93 public]
This is an enhancement request to add new functionality (an anonymous cell id)
and cannot be addressed in 1.0.3, changed to fixby 1.1.  Added Walt to the CC
list, because he would like to keep informed on what's happening with this.



CR Number                     : 7659
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : registry and sec_clientd
Short Description             : uid's and gid's are incompatible between DCE and OSF/1.
Reported Date                 : 4/6/93
Found in Baseline             : 1.0.2
Found Date                    : 4/6/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/6/93 public]

   The default accounts in the registry are incompatible with OSF/1 as
   shipped by OSF. There was a discussion of this topic on dce-tech.
   Having not heard any blinding disagreement. I'm submitting this OT
   defect as an enhancement. Basically, the text below (from the last
   message from the dce-tech exchange) outlines a fix.


        Well, Joe asked for a concrete proposal, so here it is. Assuming
        there's not massive disagreement with this (how could there be
        on dce-tech? :-)), I'll submit this as an OT enhancement.

	1) Modify the code in sec_login_setup_identity which handles login,
           so that accounts (and principals and groups) can be added using
           the password override file.

	   This would be done by adding the 'is password overriden?' check
           from sec_login_valid_and_cert to the code path in
           sec_login_setup_identity which has determined there's no registry
           info.
                                 
	   I see this as a necessary step in any fix to this issue.
           Specifically, note from my original message on this subject:

> 
>         uid             mail    6(dce)          -(osf1)
>                         auth    -(dce)          6(osf1)
>
>         "-" indicates "not defined"
>

	  Since DCE doesn't have an 'auth', NOTHING can currently be
          done at an integrated login client of a (reference implementation)
          DCE environment to make that account accessible. Yes a vendor
          shipping OSF/1 with integrated login could make his installation
          add this account to the registry so that he can subsequently
          override it on his system (Doesn't that make a lot of sense?), 
          but vendors will just have to keep adding more and more, as they
          discover differences with their UNIX implementations. The far
          simpler fix is to permit the password override file to add
          accounts (which will have no network credentials).


	2) Modify the registry database creation code to eliminate the
           pre-existing accounts.

	   This forces every vendor with integrated login to supply an
           override file, which removes any responsibility for this stuff
           from the user/administrator.



CR Number                     : 7598
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_admin / initrep
Short Description             : rep API returns ambiguous error msgs on auth errs.
Reported Date                 : 03/25/93
Found in Baseline             : 1.0.2
Found Date                    : 03/25/93
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[03/25/93 public]

If you try to do a sec_admin/initrep command and you are not logged in as
cell_admin you get the following error message:

  Initialize replica operation failed - Registry object not found (dce / sec)

This error message doesn't give you a clue (at least to me since I tried this
many times over several days and kept blaming replication) as to what the real
problem is.  It should say something like "not authorized to perform initrep"
or a facsimile there of.

root@dce9> sec_admin
Default replica:  /.../admin_cell/subsys/dce/sec/master
Default cell:     /.../admin_cell
sec_admin> lrep -all
Default replica:  /.../admin_cell/subsys/dce/sec/master
Default cell:     /.../admin_cell


subsys/dce/sec/loan201_rep
          Instance id: 005bf540-010c-1bb2-b87c-08002b14b1a0
          Addresses:               ncacn_ip_tcp:130.105.201.6[]
                                   ncadg_ip_udp:130.105.201.6[]
          State:                   in service - slave
          Last update received at: Thu Mar 25 16:50:53 1993
          Last update's seqno:     0.212
          Propagation state:       ready for updates
          Last update delivered:   Thu Mar 25 16:50:53 1993
          Last update's seqno:     0.212
          Number of outstanding updates: 0
          Last comm status:        successful completion

subsys/dce/sec/master (master)
          Instance id: 0069a794-fc77-1bb1-a21c-08002b1c9287
          Addresses:               ncacn_ip_tcp:130.105.202.29[]
                                   ncadg_ip_udp:130.105.202.29[]
          State:                   in service - master
          Last update received at: Thu Mar 25 16:50:53 1993
          Last update's seqno:     0.212
sec_admin> initrep subsys/dce/sec/loan201_rep
Do you wish to continue (y[es]) or abort this operation (n[o])? y
Initialize replica operation failed - Registry object not found (dce / sec)
sec_admin>

[4/1/93 public]
This is a cosmetic problem, so I moved it from severity 'B' to 'C'.
It is not a sec_admin problem.  secd itself returns these ambiguous errors
if you don't have the rights to perform the repl operation you attempted.
Changed fixby field to 1.0.3.

[8/2/93 public]

Responsible -> hanfei.

[10/14/93 public]

Converted to enhancement and deferred to 1.1 . "Registry object 
not found" message is going to be fixed as part of the 1.1 Servceability
work. (this message is issued from a lot of places) and this will be
fixed as part of that work.  A specific solution for this particular
instance of the error message is outlined below (thanks to Anne Hopkins).
However, I would like to evaluate all the places where this message
is issued before adopting the solution outlined below. Hence the
reason for deferral to 1.1.

One fix is to add the "r" permission bit to the replist ACL.
This bit is not currently supported. In addition 
an acl entry needs to be created giving read access to  an 
unauthenticated user.

Note that the 'obvious' fix of changing rs_authorized_by_pac() to 
return an unauthorized error message instead of "registry object
not found" when a user has  no access at all is NOT correct since
this creates a security hole since "not authorized" message would be
returned for *every* unauthorized access not just unauthorized access
to the replica list.  This in turn would enable the following 
determination to made :

   sec_rgy_not_authorized -> object exists
   sec_rgy_object_not_found -> object doesn't exist

and allow an unauthorized user to browse the namespace. 

It is pecisely to prevent the unauthorized browsing of the namespace
that the "registry object not found" is returned if the client
has absolutely has no rights and the "not authorized" message if the
client has some rights.

So, by adding the support for an "r" bit in the replist ACL and
creating an entry in the replist ACL allowing an uauthenticated user
read access the "not authorized message" would be issued.



CR Number                     : 7496
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : 
Short Description             : dce_login should have option to specify ticket lifetime other than default.
Reported Date                 : 3/15/93
Found in Baseline             : 1.0.2
Found Date                    : 3/15/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/15/93 public]

The default certificate lifetime set under properties serves as an
upper bound for TGT lifetime.  It limits the value on the account.
I don't really know if this is a bug in code or if it just isn't explained
well in the documentation.  It seems like the authentication policies
are meant to control upper bounds, so why does the default property
do the same.

So when you use dce_login, your TGT lifetime can be no greater then
the default property lifetime.  If you use kinit, you can by-pass this
by specify a lifetime.

janet

[3/15/93 public]

Not a bug; it's an enhancement request.

dce_login currently always uses the default lifetime; it doesn't provide a
way to specify a lifetime on the command line.

You can deal with this by using dce_login, and then refreshing your tickets
with kinit with the desired lifetime.



CR Number                     : 7450
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : test/security/api/moretests
Short Description             : provide a prefix for temporary
files where to redirect output.
Reported Date                 : 3/9/93
Found in Baseline             : 1.0.2b18
Found Date                    : 3/9/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/9/93 public]

Most of the *.sh scripts (e.g. sec_acl_setup.sh, passwd_import.sh,
passwd_override.sh) in the directory src/test/security/api/moretests
redirect the output to a file in the following manner, for example:

in the rgy_setup_init.sh,
 
echo "do acc" >>/tmp/rgy_edit.script

or

in the passwd_import.sh script,

../moretests/binlogin lp -dce-  >> /tmp/passwd_import_ie.out


It would be better to provide a prefix variable for the temp files the 
scripts create and allow users to customize them their own environment.

eg. 

PI_TMP="/YOURTEMPDIR"

and replace all the instances of /tmp to $PI_TMP in the scripts.

[03/09/93 public]
Actually this is probably best and follows standard shell practive:
	PI_TMP=${TMPDIR-/tmp}



CR Number                     : 7319
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : login context typedef of "void *" is error prone.
Reported Date                 : 2/22/93
Found in Baseline             : 1.0
Found Date                    : 2/22/93
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/22/93 public]

There is a lot of casting going on in security between "abstract void *"
types (specifically, sec_login_handle_t and sec_rgy_handle_t) and their
"implementation types".

Because C does (most) type equivalence by structure rather than name, this
is incredibly error prone; bug 7248 was mostly caused by the explicit
flaunting of the C type system -- a sec_rgy_handle_t was used instead of a
sec_login_handle_t, with disastrous results.

The ideal fix would be to just typedef them to a pointer to an otherwise
"unknown" structure (and only define it in the context of the modules which
see the internals of the structure.  Unfortunately, idl doesn't let you do
that -- it complains, even in a [local] interface, if you attempt to
typedef something to a pointer to an unknown type.

Alternatively, we can define a "dummy" structure in the .idl files, and
typedef to that, and get *most* of the benefits of the typechecking.

[02/23/93 public]
Defining a dummy structure is a bad idea; casting (struct foo *) to
(struct bar *) is not as safe and portable as casting (void *) to
(struct bar *).  So much so that I would rather see the current bug-prone
situation left as-is then to make this fix.  I totally agree that the
right thing to do is fix IDL, as requested in 7320.
	/r$



CR Number                     : 7287
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : name cache
Short Description             : Shouldn't be using export_context to get creds name for name_cache
Reported Date                 : 2/18/93
Found in Baseline             : 1.0.2
Found Date                    : 2/18/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/18/93 public]
Should be able to get name for name_cache with less overhead than the current
call to sec_login_export_context from sec_login_pvt_get_namecache



CR Number                     : 7155
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : key_mgmt
Short Description             : seckey_set always uses default salt.
Reported Date                 : 2/8/93
Found in Baseline             : 1.0.2
Found Date                    : 2/8/93
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/8/93 public]

security/client/key_mgmt/seckey_set.c always uses the default salt rather
than the one passed in to the routine.

This means that if you attempt to set the key in a keytable for a principal
which has been renamed since the last time its password was changed, the
wrong thing will happen.

This will probably require some changes to rgy_edit to set the salt
correctly in the incoming request.

[9/30/93 public]
Changing principal names isn't yet implemented, so this is moot for 1.0.3.

[10/1/93 public]
Oops, that's account rename; pgo rename is implemented, so undeferred.

[10/20/93 public]

This bug manifests itself when an administrator changes a
principal name and then attempts to use the ktadd command
to add the principal to a keytable.  The ktadd will
complete successfully, but the key in the keytable will
not match the renamed principal's current key in the 
security server (because the salt stored at the server is no 
longer the default).  Attempts to either perform a login, or
decrypt service tickets using the key in the keytable will fail.

The workaround for this is to change the principal's password
(thereby assuring that the salt for the principal's current
key is once again the default salt) before attempting the ktadd.  

The mechanism for fixing this using currently available internal
API's (namely the krb5 library) would break when 1.1 
preauthentication is implemented.  A proper fix requires a new 
API call that will be available in 1.1.

Given the shortness of time and the availabilty of a workaround,
I'm dropping the priority and deferring this bug to 1.1.



CR Number                     : 7146
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : 
Short Description             : krb5_cc_match() cleanup
Reported Date                 : 2/5/93
Found in Baseline             : 1.0.2
Found Date                    : 2/5/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/5/93 public]

krb5_cc_match was broken out of krb5_fcc_retrieve very late in 1.0.2 to
make it easier to write alternative credential cache managers.

krb5_cc_match should move out of krb5/lib/file/ccache/fcc_retrv.c and into a
file/ccache/*.c module.

There should be a prototype for it in krb5/include/krb5/ccache.h

This is a code cleanup issue.

[2/5/93 public]
excuse me, this should be an enhancement..



CR Number                     : 7145
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : sec_id_gen_name should use name cache.
Reported Date                 : 2/5/93
Found in Baseline             : 1.0.2
Found Date                    : 2/5/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/5/93 public]

sec_id_gen_name should use the name cache to do uuid->string mapping.

also, sec_id_parse_name should always ask for the cell uuid if it also asks
for the pgo uuid.



CR Number                     : 7101
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : security/client/acl/dfs_dce_acl.c
Short Description             : NGROUPS, getgroups() and errno problem
Reported Date                 : 2/3/93
Found in Baseline             : 1.0.1
Found Date                    : 2/3/93
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/3/93 public]

NGROUPS is not defined in the include files included by dfs_dce_acl.c.
And getgroups() is not called according to the POSIX.1 conventions.
POSIX (as does SunOS and System V) defines getgroups() to take an
integer listing the size of the group array, not a pointer to an
integer.

POSIX.1 does not define NGROUPS, rather it defines NGROUPS_MAX,
which may be found in <limits.h>. To get NGROUPS, one has to include
<sys/param.h>

Also, the code include <sys/errno.h> instead of <errno.h>. According to the
man page (of osf/1 and Sun), the right way is to include <errno.h>.

Diff follows:

*** dfs_dce_acl.c       Wed Feb  3 10:09:45 1993
--- dfs_dce_acl.c.orig  Fri Jul 31 15:24:07 1992
***************
*** 37,45 ****
  #include <sys/types.h>
  #include <sys/file.h>
  #include <sys/stat.h>
- #include <sys/param.h>
  
! #include <errno.h>
  #include <dce/dce_cf.h>
  #include <dce/id_base.h>
  #include <dce/binding.h>
--- 37,44 ----
  #include <sys/types.h>
  #include <sys/file.h>
  #include <sys/stat.h>
  
! #include <sys/errno.h>
  #include <dce/dce_cf.h>
  #include <dce/id_base.h>
  #include <dce/binding.h>
***************
*** 483,489 ****
  {
    uid_t                               localUid;
    gid_t                               localGid;
!   int                         gidsetlen=NGROUPS;
    gid_t                               gidset[NGROUPS];
    int                         i;
    uuid_t                      realmUuid;
--- 482,488 ----
  {
    uid_t                               localUid;
    gid_t                               localGid;
!   int                         gidsetlen;
    gid_t                               gidset[NGROUPS];
    int                         i;
    uuid_t                      realmUuid;
***************
*** 527,533 ****
        bcopy((char *)&localUid, (char *)&(pacP->principal.uuid), sizeof(localUid));
        bcopy((char *)&localGid, (char *)&(pacP->group.uuid), sizeof(localGid));        
!       pacP->num_groups = getgroups(gidsetlen, gidset);
        pacP->groups = (sec_id_t *)malloc(pacP->num_groups * sizeof(sec_id_t));
        bzero((char *)pacP->groups, pacP->num_groups * sizeof(sec_id_t));
        for (i = 0; i < pacP->num_groups; i++) {
--- 526,532 ----
        bcopy((char *)&localUid, (char *)&(pacP->principal.uuid), sizeof(localUid));
        bcopy((char *)&localGid, (char *)&(pacP->group.uuid), sizeof(localGid));        
!       pacP->num_groups = getgroups(&gidsetlen, gidset);
        pacP->groups = (sec_id_t *)malloc(pacP->num_groups * sizeof(sec_id_t));
        bzero((char *)pacP->groups, pacP->num_groups * sizeof(sec_id_t));
        for (i = 0; i < pacP->num_groups; i++) {

[2/26/93 public]
Since this is not affecting any of the reference platforms, I'm downgrading it
from severity 'B' (Critical - no workaround) to 'D' (Significant - an
acceptable workaround), since it's not going to get past the DRB for this
release anyway.  Assigned it to myself...

[8/2/93 public]

Fixed as part of code cleanup for 1.1.  Changed to enhancement.



CR Number                     : 6945
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : sec_login.c
Short Description             : set_context returns invalid ctx. ifsec_login_credentials_private flag set
Reported Date                 : 1/20/93
Found in Baseline             : 1.0.2b11
Found Date                    : 1/20/93
Severity                      : E
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/20/93 public]
The sec_login_set_context routine returns invalid context if the 
sec_login_credentials_private flag was set during the 
sec_login_setup_identity call. This should probably return 
sec_s_not_implemented.

[2/20/93 public]
Downgraded to E4.  Given the number of real problems we have CR's for, I'm
letting you know now that this won't be fixed in 1.0.2.  It's cosmetic anyway,
since it really is an invalid context for the set_context() call, if you
set the flags to sec_login_credentials_private.

[8/2/93 public]

Changed to enhancement to be fixed in 1.1.



CR Number                     : 6866
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : testsh
Short Description             : testsh in rpc and sec should be collapsed into one directory.
Reported Date                 : 1/16/93
Found in Baseline             : 1.0.2
Found Date                    : 1/16/93
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/16/93 public]

The test directories src/test/rtandidl/testsh and 
src/test/security/api/testsh are identical and should be collapsed into one
so that fixes do not have to be made into both sets of files.

[2/26/93 public]

This enh is even more desirable now.  The testsh in
test/rpc/rtandidl/testsh has been significantly cleaned up and the security
tests should use that version.

The tests should be moved to a common subtree and out of rpc and security.

[6/10/93 public]

Changed component to security.



CR Number                     : 6758
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec/krb5/comerr
Short Description             : extra carriage return in output
Reported Date                 : 1/7/93
Found in Baseline             : 1.0.2
Found Date                    : 1/7/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/krb5/comerr/com_err.c
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[1/7/93 public]
  com_err is not informed enough about the terminal state to make a
decision about raw/cooked mode and, hence, always appends a \r onto
its finished output lines for saftey. These ^M's appear in traces and
log files and produced a low-severity bug for us here at Transarc.
Forwarding JFYI.
  Code segment follows: 
		    ---- ---- ---- ---- ---- ----
    putc('\n', stderr);
    /* should do this only on a tty in raw mode */
    putc('\r', stderr);
    fflush(stderr);

		    ---- ---- ---- ---- ---- ----
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[1/7/93 public]

Changed to enhancement (this is purely cosmetic; you can flush the ^M's
trivially from the log file using "tr -d '\013'" from the shell.

emacs users might want to M-x load-library man and then run M-x
nuke-nroff-bs to flush the ^M's..

[1/8/93 public]
Changed Interest List CC from `travis@transarc.com, 
 bb+transarc.alpine@transarc.com' to `travis@transarc.com'



CR Number                     : 6648
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : krb
Short Description             : null file in krb5
Reported Date                 : 12/28/92
Found in Baseline             : 1.0.2
Found Date                    : 12/28/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
./security/krb5/lib/crc-32/crc-test
Sensitivity                   : public

[12/28/92 public]
./security/krb5/lib/crc-32/crc-test is a zero-length file and should be
defuncted.

[12/28/92 public]
Assuming that this file is in fact unnecessary, it's a cleanup issue, not a
Severity 'C' (Severe / Major) defect.  I've changed it from sev C defect to
sev E enhancement.



CR Number                     : 6316
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_key_mgmt
Short Description             : need some slack in the expiration interval
Reported Date                 : 12/3/92
Found in Baseline             : 1.0.2
Found Date                    : 12/3/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/key_mgmt/keymgmt.c
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[12/3/92 public]
  It appears that sec_key_mgmt_manage_key() waits to within a second
of key expiration to update the key with a new key. Shouldn't there be
a small window to allow for any rebindings, swap-ins, or transient
errors and the like?
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[12/3/92 public]
The password expiration period is not a "hard' value.  There is no
need to update a server's key prior to the expiration time since the server
will b e able to obtain initial authentication and change its key later.
The timeout period is there as guidance for local OS login programs that
want to impose the hard limit.  The DCE itself does nothing with the 
expiration time.  [still, in the future we may want to harden the policy
at the KDC, so it would probably be worth trying the password update sometime
before the actual expiration]



CR Number                     : 6274
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : overrides
Short Description             : Obtain overrides locally if call fails
Reported Date                 : 12/1/92
Found in Baseline             : 1.0.1
Found Date                    : 12/1/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/rca/override.c
Sensitivity                   : public

[12/1/92 public]
Because the parsing of the override file is time consuming (too much overhead
to do per login) we put the override parsing in sec_clientd, so it could keep
an in memory cache of the current override file (refreshing it if it changed),
and you make a call to sec_clientd to check for overrides for the specified
account.
Because it's a possible breach of security to not be able to determine if an
override exists for an account, the login code does not allow anyone to log in
if it can't get override information (the account trying to log in may be
denied access by the override file, but the login layer can't tell, because it
can't see the override info...).
This made perfect sense when implementing it, but it turns out that it's too
restrictive, because it is possible that you can't get to secd *and* your
sec_clientd had problems coming back up when the machine rebooted or...
We need to enhance the override client agent, to do things the hard way (read
and parse the file per login) when the override call to sec_clientd fails.
This will continue to give us the benefit of having it cached when sec_clientd
is working, but still allow people to log in off the local registry if both
secd and the local sec_clientd are down.



CR Number                     : 6174
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_login_ API
Short Description             : Need to reinstate and implement sec_login_check_passwd()
Reported Date                 : 11/20/92
Found in Baseline             : 1.0.1
Found Date                    : 11/20/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/login/sec_login*.c
Sensitivity                   : public

[11/20/92 public]
We have decided that there is a need for this routine, by vendors wishing to
be able to validate a password without the overhead of setting up a login
context (and app developers too), so we plan to UN-obsolete it in sec_login.idl
and implement it at some point (hopefully soon :-).



CR Number                     : 5918
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec
Short Description             : cred files should be owned by
uid, not euid
Reported Date                 : 11/4/92
Found in Baseline             : 1.0.2
Found Date                    : 11/4/92
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/4/92 public]

The cred files are owned by the effective uid of the process
logging in. But if a set-user-ID program does a dce login,
the resulting cred file will not be usable by the user who ran
the program, because the security runtime does not honor cred
files which are not owned by the current user.  There are various
possible workarounds for this in the set-user-ID program,
but they are not portable.  It would be better for the security
code to create the cred file owned by the real uid, not the effective
uid, of the program doing the dce login.



CR Number                     : 5875
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : build
Short Description             : build directory structure complex
Reported Date                 : 10/30/92
Found in Baseline             : 1.0.2b1
Found Date                    : 10/30/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/30/92 public]

    The DCE Security software is built in various stages inside a large
    number of subdirectories with long lists of directories to be searched
    when compiling modules.  To build the software on VMS requires that we
    emulate the UN*X build procedures, which are very complex. Furthermore,
    our source code management system (CMS) imposes limits on what we can
    and cannot do in setting up a source code library.

    (We have also noted that there have been a large number of edits to the
    build procedures.  This would seem to suggest that the build procedures
    are a source of maintenance problems.)

    SUGGESTION: Reduce the number of subdirectories.

    SUGGESTION: Avoid file name collisions (such as /client/admin/acl_edit/
                tty.c and /client/admin/rgy_edit/tty.c).

[11/17/92 public]
Ok, I'll agree the build structure is complex, but it is not causing build
problems on any of the reference platforms, so this shouldn't be a B2 defect.
Given the number of high priority defects we've been getting, this won't be
considered for 1.0.2, so it's now an enhancement request that we'll think
about post1.0.2.



CR Number                     : 5873
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : security/krb5/clients/kinit/kinit.c
Short Description             : typecasting problem in kinit
Reported Date                 : 10/30/92
Found in Baseline             : 1.0.1
Found Date                    : 10/30/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/30/92 public]

The following is still in 1./0.2.

File:    security/krb5/clients/kinit/kinit.c
Problem: typecasting

  Line - 445
        printf("%s: ticket expires at %s", client_string,
            ctime(&my_creds.times.endtime));
    should be:
        printf("%s: ticket expires at %s", client_string,
            ctime((const time_t *) &my_creds.times.endtime));

[07/12/93 public]
It is not clear to me that just adding the cast is the right thing
to do.  my_creds.times.endtime is a krb5_timestamp, which is
a krb5_int32.  Adding the cast is only right if sizeof(time_t) ==
sizeof(krb5_int32); is that guaranteed?  If not, you'll need to add
a time_t local variable and use that.



CR Number                     : 5872
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : security/client routines
Short Description             : security/client - miscellaneous typecast problems
Reported Date                 : 10/30/92
Found in Baseline             : 1.0.1
Found Date                    : 10/30/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : client/rca/sec{idmap,_lrgy}.c, client/admin/acl_edit/deif.c, client/login/sec_login{_pvt}.c
Sensitivity                   : public

[10/30/92 public]

The following problems still exist in 1.0.2.

  >  File:    security/client/admin/acl_edit/deif
  >  Problem: wrong definition
  >  
  >    Line - 1364
  >           #define NUM_TYPES 13
  >      should be:
  >           #define NUM_TYPES 12
  >  
  >  
  >  File:    security/client/rca/secidmap
  >  Problem: typecasting
  >  
  >    Line - 332
  >  #define NEXT_FIELD     \
  >      do { line = cp; cp = (unsigned char *)u_strchr (line, FS); if (!cp) return NULL; *cp++ = NULL; \
  >           if (*cp==' ') cp++;  \
  >      } while (0)
  >      should be:
  >  #define NEXT_FIELD     \
  >      do { line = cp; cp = (unsigned char *)u_strchr (line, FS); if (!cp) return NULL; *cp++ = '\0'; \
  >           if (*cp==' ') cp++;  \
  >      } while (0)
  >  
  >  
  >  File:    security/client/login/sec_login
  >  Problem: typecasting
  >  
  >    Line - 1290
  >      *identity_expiration = NULL;
  >      should be:
  >      *identity_expiration = 0;
  >  
  >
  >  File:    security/client/login/sec_login_pvt
  >  Problem: typecasting
  >  
  >    Line - 2685
  >          *stp = krb5_process_as_reply(&KRB_REQUEST_INFO(lcp)->reply,
  >                                      KRB_REQUEST_INFO(lcp)->nonce,
  >                                      KRB_REQUEST_INFO(lcp)->options,
  >                                      KRB_REQUEST_INFO(lcp)->addrs,
  >                                      KEYTYPE_DES, pwd_keyproc, &pwd_keyseed,
  >                                      krb5_kdc_rep_decrypt_proc, 0,
  >                                      &KRB_REQUEST_INFO(lcp)->creds,
  >                                      &as_reply);
  >      should be:
  >          *stp = krb5_process_as_reply(&KRB_REQUEST_INFO(lcp)->reply,
  >                                      KRB_REQUEST_INFO(lcp)->nonce,
  >                                      KRB_REQUEST_INFO(lcp)->options,
  >                                      KRB_REQUEST_INFO(lcp)->addrs,
  >                                      KEYTYPE_DES,
  >                                      (krb5_error_code (*)
  >                                            (const krb5_keytype,
  >                                             krb5_keyblock **,
  >                                             krb5_const_pointer,
  >                                             krb5_pa_data **))pwd_keyproc,
  >                                      &pwd_keyseed,
  >                                      krb5_kdc_rep_decrypt_proc, 0,
  >                                      &KRB_REQUEST_INFO(lcp)->creds,
  >                                      &as_reply);
  >  
  >  
  >  File:    security/client/rca/sec_lrgy
  >  Problem: typecasting
  >  
  >    Line - 417
  >      p = *var_ptr = malloc(fixed->var_len);
  >      should be:
  >      p = *var_ptr = (char *) malloc(fixed->var_len);
  >

[12/17/92 public]
Submitted fixed deif.c, secidmap.c, sec_lrgy.c, still working on sec_login.c,
need better fix than described above for sec_login_pvt.c

[12/17/92 public]
Submitted fix for sec_login.c as part of 6295, only one left now is the fix for
sec_login_pvt.c, which we need a cleaner fix for than the one described above.



CR Number                     : 5857
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : security/utils routines
Short Description             : security/utils - miscellaneous typecast problems
Reported Date                 : 10/29/92
Found in Baseline             : 1.0.1
Found Date                    : 10/29/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/29/92 public]

The following problems also exist in the current 1.0.2 code base.


File:    security/utils/sec_authn.c
Problem: typecasting

  Line - 340
    if (SEC_LOCAL_NAME(name) != NULL) {
    should be:
    if (SEC_LOCAL_NAME(name) != 0) {

         ***************************************************

File:    security/utils/crypt.c
Problem: typecasting

  Line - 230
     return cc;
    should be:
     return (void *)cc;

         ***************************************************

File:    security/utils/sec_krb_util.c
Problem: typecasting

  Line - 220
    *rp++ = NULL;
    should be:
    *rp++ = '\0';

  Line - 395
        *rp1++ = NULL;
    should be:
        *rp1++ = '\0';

  Line - 403
        *rp2++ = NULL;
    should be:
        *rp2++ = '\0';

  Line - 638
    krb5_cksumtype  krb_sum_type = NULL;
    should be:
    krb5_cksumtype  krb_sum_type = 0;

         ***************************************************

File:    security/utils/u_str.c
Problem: typecasting

  Line - 51, 75
    if ((source != NULL) && (*source != NULL)) {
    should be:
    if ((source != NULL) && (*source != '\0')) {

         ***************************************************

[10/29/92 public]
Changed to an enhancement since this is currently not an issue 
for building on the reference platforms.



CR Number                     : 5856
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : security/helper/auth_helper.c
Short Description             : security/helper - miscellaneous typecast problems
Reported Date                 : 10/29/92
Found in Baseline             : 1.0.1
Found Date                    : 10/29/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/29/92 public]

The following problems also exist in current 1.0.2 code base.

File:    security/helper/auth_helper.c
Problem: typecasting

  Line - 236
        context_cache[slot].pathname = rpc__stralloc (pathname_buf);
    should be:
        context_cache[slot].pathname =
              (char *) rpc__stralloc (pathname_buf);

  Line - 710
        time (&helper_now);
    should be:
        time ((long *) &helper_now);

[10/29/92 public]
Changed to an enhancement since this is not an issue for building
on the reference platforms.

[07/12/93 public]
I think there are a number of errors here.  In the first one, rpc__stralloc()
should be declared properly, not have its return value casted.
The (long*) cast needed in time() (line 710) is wrong.  time takes
a time_t* not a long*.



CR Number                     : 5854
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : sec server routines
Short Description             : security/server - miscellaneous typecast problems
Reported Date                 : 10/29/92
Found in Baseline             : 1.0.1
Found Date                    : 10/29/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/29/92 public]

The following problems also exist in the current 1.0.2 code base.



File:    security/server/rsdb/balanced_trees.c
Problem: syntax error

  Line - 86
    typedef enum { IMPLANT, NOT_FOUND, REPLACED, DUPLICATE, } result_t;
    should be:
    typedef enum { IMPLANT, NOT_FOUND,
                   REPLACED, DUPLICATE } result_t;

         ***************************************************

File:    security/server/sec_clientd/sec_clientd.c
Problem: parameter conflict

  Line - 97
    time_info = *localtime(&now.tv_sec);
    should be:
    time_info = *localtime((long *)&now.tv_sec);

  Line - 125
    time_info = *localtime(&now.tv_sec);
    should be:
    time_info = *localtime((long *)&now.tv_sec);

  Line - 639
            if (! scd_thread_join(listener_handle, &result_p) ) {
    should be:
            if (! scd_thread_join(listener_handle,
                   (void *)&result_p) ) {

         ***************************************************

File:    security/server/rsdb/rsdb_acct.c
Problem: typecasting

  Line - 975
    acct->flags      = NULL;
    should be:
    acct->flags      = 0;

         ***************************************************

File:    security/server/rsdb/rsdb_acl.c
Problem: typecasting

  Line - 148
    rsdb_fetch(rsdb_acl_db, (Pointer) &sequential_key, sizeof(sequential_key),
                        &data, &data_len, st);
    should be:
    rsdb_fetch(rsdb_acl_db, (Pointer) &sequential_key, sizeof(sequential_key),
                        &data, (int *)&data_len, st);

  Line - 194
    rsdb_fetch(rsdb_acl_db, (Pointer) &sequential_key, sizeof(sequential_key),
                        &data, &data_len, st);
    should be:
    rsdb_fetch(rsdb_acl_db, (Pointer) &sequential_key, sizeof(sequential_key),
                        &data, (int *)&data_len, st);

  Line - 899
    if(BAD_STATUS(st)) {
        return NULL;
    should be:
    if(BAD_STATUS(st)) {
        return ( (unsigned long)0 );

  Line - 1020
    rsdb_fetch(rsdb_acl_db, (Pointer) &sequential_key, sizeof(sequential_key),
                        &data, &data_len, st);
    should be:
    rsdb_fetch(rsdb_acl_db, (Pointer) &sequential_key, sizeof(sequential_key),
                        &data, (int *)&data_len, st);

  Line - 1204
    if(acl_ids->acl_id == NULL) {
    should be:
    if(acl_ids->acl_id == (unsigned long)0 ) {

         ***************************************************

File:    security/server/rsdb/rsdb_daclmgr.c
Problem: typecasting

  Line - 1194
    if(key_ids->acl_id == NULL) {
    should be:
    if(key_ids->acl_id == (unsigned long)0 ) {

File:    security/server/rsdb/rsdb_dir_util.c
Problem: typecasting

  Line - 122
    rsdb_fetch(domain_info[domain].db, (Pointer)&uid_key,
               sizeof(uid_key), &name_key, &name_key_len, &status);
    should be:
    rsdb_fetch(domain_info[domain].db, (Pointer)&uid_key,
               sizeof(uid_key), &name_key,
               (int *)&name_key_len, &status);

         ***************************************************

File:    security/server/rsdb/rsdb_pgo.c
Problem: typecasting

  Line - 516
    item->fullname[pgo->fullname_len] = NULL;
    should be:
    item->fullname[pgo->fullname_len] = '\0';

  Line - 868
        } while ((previous_pgo_p == NULL) &&
                 (previous_pgo.body.threads.alias != NULL));
    should be:
        } while ((previous_pgo_p == NULL) &&
                 (previous_pgo.body.threads.alias != 0 ));

  Line - 1237
    *name = NULL;
    should be:
    *name = '\0';

  Line - 1277
    *name = NULL;
    should be:
    *name = '\0';

  Line - 1475
        name[name_len] = NULL;
    should be:
        name[name_len] = '\0';

  Line - 1510
        name[name_len] = NULL;
    should be:
        name[name_len] = '\0';

  Line - 1807
            member_list[num][member_len] = NULL;
    should be:
            member_list[num][member_len] = '\0';

         ***************************************************

File:    security/server/rsdb/rsdb_replica.c
Problem: typecasting

  Line - 426
    rsdb_fetch_next(rsdb_replica_db, (Pointer) rs_id,
                    (rs_id == NULL ? 0 : sizeof(*rs_id)),
                    (Pointer *) &next_id_p, &next_id_len,
                    (Pointer *) &rsdb_rep_item_p, &item_len, st);
    should be:
    rsdb_fetch_next(rsdb_replica_db, (Pointer) rs_id,
                    (rs_id == NULL ? 0 : sizeof(*rs_id)),
                    (Pointer *) &next_id_p,
                    (int *)&next_id_len,
                    (Pointer *) &rsdb_rep_item_p,
                    (int *)&item_len, st);

         ***************************************************

File:    security/server/rsdb/rsdb_util.c
Problem: typecasting

  Line - 84
    rsdb_fetch(domain_info[domain].db, (Pointer) &sequential_key,
               sizeof(sequential_key),
                                &name_key, &name_key_len, &st);
    should be:
    rsdb_fetch(domain_info[domain].db, (Pointer) &sequential_key,
               sizeof(sequential_key),
               &name_key, (int *)&name_key_len, &st);

  Line - 595
    rsdb_util_path_resolve(domain, residual, &residual_len, resolved, &resolved_len,
                            &item, status);
    should be:
    rsdb_util_path_resolve(domain, residual,
          (long int*)&residual_len, resolved,
          (long int*)&resolved_len, &item, status);

  Line - 698
        rsdb_util_path_resolve(*domain, obj_name, &obj_name_len, resolved,
                               &resolved_len, object, st);
    should be:
        rsdb_util_path_resolve(*domain, obj_name,
                    (long int*)&obj_name_len, resolved,
                    (long int*)&resolved_len, object, st);

  Line - 1210
    rsdb_fetch(domain_info[domain].db, key, key_len, &data, &data_len, &st);
    should be:
    rsdb_fetch(domain_info[domain].db, key, key_len, &data,
               (int *)&data_len, &st);

  Line - 1338
    rsdb_fetch_next(domain_info[domain].db, (Pointer) & name_key, name_key_len,
                    &next_key, &next_key_len,
                    &data, &data_len, status);
    should be:
    rsdb_fetch_next(domain_info[domain].db, (Pointer) & name_key, name_key_len,
                    &next_key, (int *)&next_key_len,
                    &data, (int *)&data_len, status);

  Line - 1508
    rsdb_fetch(domain_info[domain].db, (Pointer) &mem_key,
               sizeof(mem_key), &data, &data_len, &st);
    should be:
    rsdb_fetch(domain_info[domain].db, (Pointer) &mem_key,
       sizeof(mem_key), &data, (int *)&data_len, &st);

         ***************************************************

File:    security/server/rs/rpriv.c
Problem: typecasting

  Line - 459
        sec_id_pac_t_unpickle(ppac, malloc, authz_data, stp);
    should be:
        sec_id_pac_t_unpickle(ppac,
         (void *(*) (unsigned32))malloc, authz_data, stp);

         ***************************************************

File:    security/server/rs/rs_audit_trail.c
Problem: typecasting

  Line - 181
        strcpy(time_buf, ctime(&tv.tv_sec));
    should be:
        strcpy(time_buf, ctime((long *)&tv.tv_sec));

         ***************************************************

File:    security/server/rsdb/rsdb.c
Problem: typecasting & bug in directory name

  Line - 288
#define RGY_XXX_TMP  "/tmp/rgy_data.bak"
    should be:
#define RGY_XXX_TMP  "/tmp/rgy_data.bak/"

  Line - 539
            printf("%s Checkpoint on %s", rs_prod_name, ctime(&tv.tv_sec));
    should be:
            printf("%s Checkpoint on %s", rs_prod_name, ctime((long *)&tv.tv_sec));

  Line - 584
            printf("End %s Checkpoint on %s", rs_prod_name, ctime(&tv.tv_sec));
    should be:
            printf("End %s Checkpoint on %s", rs_prod_name, ctime((long *)&tv.tv_sec));

         ***************************************************

File:    security/server/rs/rs_log_acct.c
Problem: typecasting

  Line - 376
    login_name->pname[item->person_name_len] = NULL;
    should be:
    login_name->pname[item->person_name_len] = '\0';

  Line - 380
    login_name->gname[item->group_name_len] = NULL;
    should be:
    login_name->gname[item->group_name_len] = '\0';

  Line - 384
    login_name->oname[item->org_name_len] = NULL;
    should be:
    login_name->oname[item->org_name_len] = '\0';

         ***************************************************

File:    security/server/rs/rs_log_pgo.c
Problem: typecasting

  Line - 231
    pgo_name[pgo_log_item->name_len] = NULL;
    should be:
    pgo_name[pgo_log_item->name_len] = 0;

  Line - 235
   pgo_item->fullname[pgo_log_item->fullname_len] = NULL;
    should be:
   pgo_item->fullname[pgo_log_item->fullname_len] = 0;

  Line - 418
    name[log_info->name_len] = NULL;
    should be:
    name[log_info->name_len] = 0;

  Line - 585
    old_name[log_info->old_name_len] = NULL;
    should be:
    old_name[log_info->old_name_len] = 0;

  Line - 588
    new_name[log_info->new_name_len] = NULL;
    should be:
    new_name[log_info->new_name_len] = 0;

  Line - 620
    old_name[log_info->old_name_len] = NULL;
    should be:
    old_name[log_info->old_name_len] = 0;

  Line - 623
    new_name[log_info->new_name_len] = NULL;
    should be:
    new_name[log_info->new_name_len] = 0;

  Line - 735
    go_name[log_info->go_name_len] = NULL;
    should be:
    go_name[log_info->go_name_len] = 0;

  Line - 739
    person_name[log_info->person_name_len] = NULL;
    should be:
    person_name[log_info->person_name_len] = 0;

  Line - 767
    go_name[log_info->go_name_len] = NULL;
    should be:
    go_name[log_info->go_name_len] = 0;

  Line - 771
    person_name[log_info->person_name_len] = NULL;
    should be:
    person_name[log_info->person_name_len] = 0;

         ***************************************************

File:    security/server/rs/rs_log_policy.c
Problem: typecasting

  Line - 398
    org_name[log_info->name_len] = NULL;
    should be:
    org_name[log_info->name_len] = 0;

  Line - 485
    name[log_info->name_len] = NULL;
    should be:
    name[log_info->name_len] = 0;

         ***************************************************

File:    security/server/rs/rs_main.c
Problem: typecasting

  Line - 550
    *st = krb5_read_password("Enter password for locksmith account:",
                             "Reenter password to verify:",
                              passwd_str,
                              &passwd_str_len);
    should be:
    *st = krb5_read_password(
                "Enter password for locksmith account:",
                            "Reenter password to verify:",
                             passwd_str,
                             (int *)&passwd_str_len);

  Line - 635
            rsdb_unix_uuid_gen_check(sec_rgy_domain_person, true,
                                     &(pgo.unix_num), &(pgo.id), st);
    should be:
            rsdb_unix_uuid_gen_check(sec_rgy_domain_person,
             true, (int*)&(pgo.unix_num), &(pgo.id), st);

  Line - 658
            rsdb_unix_uuid_gen_check(sec_rgy_domain_group, true,
                                     &(pgo.unix_num), &(pgo.id), st);
    should be:
            rsdb_unix_uuid_gen_check(sec_rgy_domain_group,
             true, (int*)&(pgo.unix_num), &(pgo.id), st);

  Line - 679
            rsdb_unix_uuid_gen_check(sec_rgy_domain_org, true,
                                     &(pgo.unix_num), &(pgo.id), st);
    should be:
            rsdb_unix_uuid_gen_check(sec_rgy_domain_org,
             true, (int*)&(pgo.unix_num), &(pgo.id), st);

  Line - 1089
        if ( ! rs_task_join(task_handle, &result_p) ) {
    should be:
        if ( ! rs_task_join(task_handle,
               (void *)&result_p) ) {

         ***************************************************

File:    security/server/rs/rs_misc.c
Problem: typecasting

  Line - 86
    sec_acl_permset_t       parent_perms = NULL;
    should be:
    sec_acl_permset_t       parent_perms = (long)0;

         ***************************************************

File:    security/server/rs/rs_pgo.c
Problem: typecasting

  Line - 243
            rsdb_unix_uuid_check(&(pgo_item->unix_num), &(pgo_item->id), status);
    should be:
            rsdb_unix_uuid_check(
                              (int *)&(pgo_item->unix_num),
                              &(pgo_item->id), status);

  Line - 271
                    if(rsdb_unix_uuid_gen_check(name_domain, !is_cell,
                       &(pgo_item->unix_num), &(pgo_item->id), status)) {
    should be:
                    if(rsdb_unix_uuid_gen_check(name_domain, !is_cell,
                       (int *)&(pgo_item->unix_num),
                       &(pgo_item->id), status)) {

  Line - 394  and all such occurrences within the file
    sec_acl_permset_t       parent_perms = NULL;
    should be:
    sec_acl_permset_t       parent_perms = 0;

  Line - 794
    requested_perms = NULL;
    should be:
    requested_perms = 0;

         ***************************************************

File:    security/server/rs/rs_pwd.c
Problem: typecasting

  Line - 184
            sec_crypt_decrypt(ch, rpc_ss_allocate, rpc_ss_free, NULL,
                              transmit_rep->checksum->enc_pickle_len,
                              transmit_rep->checksum->enc_pickle,
                              (Pointer *)&sum_pkl, stp);
    should be:
            sec_crypt_decrypt(ch, (Pointer (*)
                                      (unsigned32 size)) rpc_ss_allocate,
                                  (void (*)
                                      (Pointer ptr)) rpc_ss_free,
                              NULL, transmit_rep->checksum->enc_pickle_len,
                              transmit_rep->checksum->enc_pickle,
                              (Pointer *)&sum_pkl, stp);

  Line - 195
                sec_crypt_decrypt(ch,  rpc_ss_allocate, rpc_ss_free, NULL,
                                  transmit_rep->key->enc_pickle_len,
                                  transmit_rep->key->enc_pickle,
                                  (Pointer *)&key_pkl, stp);
    should be:
                sec_crypt_decrypt(ch, (Pointer (*)
                                          (unsigned32 size)) rpc_ss_allocate,
                                      (void (*)
                                          (Pointer ptr)) rpc_ss_free,
                                  NULL, transmit_rep->key->enc_pickle_len,
                                  transmit_rep->key->enc_pickle,
                                  (Pointer *)&key_pkl, stp);

         ***************************************************

File:    security/server/rs/rs_reserved.c
Problem: typecasting

  Line - 512
            rsdb_unix_uuid_gen_check(pp->domain, pp->embedded_unix_id,
                                     &(pp->num), &(pgo_rec.id), st);
    should be:
            rsdb_unix_uuid_gen_check(pp->domain,
                           pp->embedded_unix_id,
                (int *)&(pp->num), &(pgo_rec.id), st);

  Line - 520
            rsdb_unix_uuid_gen_check(pp->domain, pp->embedded_unix_id,
                                     &(pp->num), &(pgo_rec.id), st);
    should be:
            rsdb_unix_uuid_gen_check(pp->domain,
                           pp->embedded_unix_id,
                 (int *)&(pp->num), &(pgo_rec.id), st);

  Line - 796
        if (*st_p = krb5_read_password(mkeyseed_prompt,
                                   0, password, &plen))
    should be:
        if (*st_p = krb5_read_password(mkeyseed_prompt,
                             0, password, (int*)&plen))

         ***************************************************

File:    security/server/rs/rs_secidmap.c
Problem: typecasting

  Line - 316, 524
    sec_acl_permset_t       parent_perms = NULL;
    should be:
    sec_acl_permset_t       parent_perms = 0;

  Line - 354, 554
            requested_perms = NULL;
    should be:
            requested_perms = 0;

         ***************************************************

File:    security/server/rs/rs_task.c
Problem: typecasting

  Line - 147
    result = pthread_create(task_handle, rs_task_attr,
                (void * /* pthread_startroutine_t */) task_fn,
    should be:
    result = pthread_create(task_handle, rs_task_attr,
                /* pthread_startroutine_t */ task_fn,

         ***************************************************

File:    security/server/rs/rwl.c
Problem: typecasting

  Line - 928
    if (debug_info != NULL && *debug_info != NULL) {
    should be:
    if (debug_info != NULL && *debug_info != '\0') {

  Line - 1080
    if (info_p->debug_info != NULL && *info_p->debug_info != NULL) {
    should be:
    if (info_p->debug_info != NULL &&
        *info_p->debug_info != '\0') {

         ***************************************************

[10/29/92 public]
The complaint about the "typedef enum" is wrong.  ANSI C allows an extra
trailing comma.
The complaint about localtime in sec_clientd.c is wrong; the
parameter to localtime is a (time_t *), not a (long *).
The complaint about ctime() in rsdb.c is wrong; ctime takes a
(time_t *), not a (long *).
The complaints about (int *) on some parameters should probably be
better fixed by making sure that the parameter is an int!

[10/29/92 public]

With respect to "typedef enum", I just checked the ANSI C spec, and Rich is
wrong, and Weidong Wang is correct.

See section 3.5.2.2, "Enumeration specifiers".  The syntax is defined as
(more or less):

enum-specifier:
	ENUM identifier_opt '{' enumerator-list '}'

enumerator-list:
	enumerator
	| enumerator-list ',' enumerator

There's no room for a spare comma at the end.

I seem to recall someone on comp.lang.c or comp.std.c flaming the ANSI
committee for not allowing this; Doug Gwyn's excuse was that they didn't
think they had implementation experience on this one like they did for
initializers.

[10/29/92 public]
Changed to an enhancement since this is not an issue for building
on the reference platform.



CR Number                     : 5768
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : perf improvement for secd's construct_pac_from_local_name
Reported Date                 : 10/22/92
Found in Baseline             : 1.0.1
Found Date                    : 10/22/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/server/rs/rs_auth.c
Sensitivity                   : public

[10/22/92 public]

Iterative algorithm used by construct_pac_from_local_name to make sure
that enough buffer space is allocated to accept results returned by
rsdb_acct_get_projlist, could be replaced by at most two calls to
rsdb_acct_get_projlist since this routine return number of projects.



CR Number                     : 5745
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : Add checks to secd RPC_DEBUG flag
Reported Date                 : 10/21/92
Found in Baseline             : 1.0.1
Found Date                    : 10/21/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : src/security/server/rs/rs_main.c
Sensitivity                   : public

[10/21/92 public]

In the file rs_main.c there is a section of code:

        else if (match_command("-rpc_debug", argv[i], 3)) {
            if (++i == argc) {
                rpc__dbg_set_switches("0-4.3", st);
            } else {
                rpc__dbg_set_switches(argv[i], st);
            }
        }

There are two things wrong with the above code.  First, if the function
rpc__dbg_set_switches returns a failure status in st, there is no
check for it in the remainder of the code segment.

Second, there is no check to see if the next argument (argv[i]:) is
a valid rpc debug switch specification.

Repeat By:


Proposed Solution:

        Fix the parameter checking.

[10/21/92 public]
Assigned this to myself, downgraded it since there's nothing broken here,
it's just not doing robust argument checking...  This is an internal debugging
option that is only there for development and porting purposes.



CR Number                     : 5666
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : Name collisions between security
headers and system headers
Reported Date                 : 10/15/92
Found in Baseline             : 1.0.1
Found Date                    : 10/15/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/h/macros.h,crypt.h
Sensitivity                   : public

[10/15/92 public]
Some security header files (crypt.h, macros.h, others??) have the same name
as some AIX system headers.  This causes problems in certain build situations.
How about renaming the security headers sec_crypt.h and sec_macros.h?

[10/20/92 public]
How come nobody else has seen problems with name collisions, building on RIOS?
How can you not know what the others are if there are collisions?  I'll look
into changing these 2 for 1.0.2, but will assume these are the only 2
collisions unless you explicitly name others.

[11/2/92 public]
Well you know that there are multiple DCE projects going on within
all the companies -- it doesn't surprise me that build environments,
base platforms, etc may differ...

The "others?" comment was because I didn't do an exhaustive
comparison of the DCE header files with the AIX 3.2+ headers; I 
mentioned the ones that happended to cause problems at the time 
figuring (correctly) that there could be more.  Here are contenders
for current and possible future collisions:

DCE             AIX 3.2.3
macros.h        /usr/include/macros.h
crypt.h         /usr/include/crypt.h
rs.h            /usr/include/sys/rs.h
priv.h          /usr/include/sys/priv.h
acct.h          /usr/include/sys/acct.h

Generically named files always have this collision potential.

[11/17/92 public]
This is not causing build problems on any of the reference platforms, so we
will not be able to address it in 1.0.2.  This is an enhancement request, so
that it will be easier to build the source tree in ways other than the OSF
ships DCE.  We will consider it as part of the post1.0.2 code cleanup, but not
before then.



CR Number                     : 5611
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : dce-ptgt
Short Description             : dce-ptgt ticket renewal window causes dts synchronization to fail
Reported Date                 : 10/12/92
Found in Baseline             : 1.0.1
Found Date                    : 10/12/92
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/12/92 public]

DTS gets authentication errors or fails to synchronize if the dtscp
command or the synchronization is attempted as the machine principal
(root) during the renewal of the dce-ptgt ticket.  There appears to
be a window between the time the dce-ptgt ticket expires and the time
it is renewed.  The errors are:

        warning - DTS control program is not authenticated:
                Registry server unavailable (dce / sec)

or

        error executing command:
                must have write permission to the DTS entity (dce / dts)
        warning - DTS control program is not authenticated:
                Cannot find ticket for requested realm (dce / krb)

[10/15/92 public]

OT cleanup 1 : Severity : unchanged (B) ; Priority : (2)

N.B. Severity B implies that this MUST be fixed in the 1.0.2 time frame.

     This bug has been around even in 1.0.1. But this problem
     persists even after the fixes for all the known problems have been
     incorporated (this includes the most recent fix from Wei Hu).

[10/12/93 public]

This problem is caused by the lack of an inter-locking mechanism
between sec_clientd (who is doing the refresh) and the clients.
Since this would require new code to implement, it should be
deferred to 1.1. (per conversation with Bill Sommerfeld)

[10/13/93 public]

Marked as an enhancement because it requires new code to fix and
deferred to 1.1



CR Number                     : 5480
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_rgy_
Short Description             : Certain account ops don't need group/org to be specified
Reported Date                 : 9/28/92
Found in Baseline             : 1.0.1
Found Date                    : 9/28/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/28/92 public]
Operations that act on an existing account need only have the principal
name specified, since only one account per principal is allowed.  The
sec_rgy_acct_delete call already works this way, The following (and any
other call that operates on an existing account) should be enhanced to
work this way (should be allowed to pass in "" for group and org):
sec_rgy_acct_user_replace
sec_rgy_acct_admin_replace
sec_rgy_acct_replace_all
sec_rgy_acct_rename (old_login_name only)
sec_rgy_acct_passwd
sec_rgy_acct_get_projlist
(if we find others that could benefit from behaving this way, we'll add
them to this list).



CR Number                     : 5437
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : acl_edit
Short Description             : Unhelpful acl_edit error msg w/non-DCE objects
Reported Date                 : 9/22/92
Found in Baseline             : 1.0.2
Found Date                    : 9/22/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mcinerny@transarc.com
Transarc Status               : open

[9/22/92 public]
It would be nice if acl_edit could give a more useful error message,
like:
	``The file/directory `foo' resides in a filesystem which does
	not support access control lists.''  

instead of what it currently prints:

	acl_edit `pwd`/foo
	ERROR: no identity set yet (dce / sec)
	Unable to bind to object /.../dfs-102-1-51.transarc.com/fs/foo

which leads one to believe that one is not authenticated (which, in
this case, is not the fact).  The only problem here is that .../fs is
in JFS.

Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mcinerny@transarc.com' 
Added field Transarc Status with value `open'



CR Number                     : 5436
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : sec_login_file_loc.h should not be in export directory
Reported Date                 : 9/22/92
Found in Baseline             : 1.0.1
Found Date                    : 9/22/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : export/$MACH/usr/include/dce/sec_login_file_loc.h or src/security/h/initstring.h
Sensitivity                   : public

[9/22/92 public]
While compiling a program that had "#include <dce/sec_login_file_loc.h>",
I discovered that it included <initstring.h>. However, initstring.h is
not in the export directory, it is only src/security/h. Either initstring.h
should be in the export directory or sec_login_file_loc.h should not be
in the export directory.

[10/15/92 public]
OT cleanup 1 : Severity : unchanged (E) ; Priority : unchanged (4)

N.B. At this point I felt no change is required in either the priority
     or severity of this bug.

[11/27/92 public]
This is a cleanup item, that should be handled with the rest of the cleanup
CRs (header file names...) which are all enhancements. Made this an enhancement
request.  The file being exported causes *no* problems if you don't include it
and *no* documentation even suggests that you include it anywhere.



CR Number                     : 5233
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : kinit
Short Description             : kinit only refreshing TGT (not rest of DCE info...)
Reported Date                 : 8/27/92
Found in Baseline             : 1.0.1
Found Date                    : 8/27/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[8/27/92 public]

Using kinit after doing a dce_login on an account for which the primary
goup information has changed causes the group information in the credential
cache to show up as "group name unknown".

To recreate this, do the following:

Create an account in the registry for e.g.

rgy_edit=>add brad -g foo -o none -pw brad -mp -dce- -av

where "brad" and "foo" are principal and group entities that were 
earlier created.

Next do a dce_login as brad and do a klist. The output of klist is:

# klist
DCE Identity Information:
        Warning: Identity information is not certified
        Global Principal: /.../sydney.dce.transarc.com/brad
        Cell:      006C4C7E-ACF3-1A9B-AF56-08005A4D1B20 /.../sydney.dce.transa
rc.com
        Principal: 0000006C-01B3-2A9D-9A00-08005A4D1B20 brad
        Group:     0000006E-01A6-2A9C-9A01-08005A4D1B20 foo
        Local Groups:
                0000006E-01A6-2A9C-9A01-08005A4D1B20 foo

Identity Info Expires: 92/08/27:22:24:54
Account Expires:       never
Passwd Expires:        never

Kerberos Ticket Information:
Ticket cache: /opt/dcelocal/var/security/creds/dcecred_388bd800
Default principal: brad@sydney.dce.transarc.com
Server: krbtgt/sydney.dce.transarc.com@sydney.dce.transarc.com
        valid 92/08/27:12:24:54 to 92/08/27:22:24:54
Server: dce-rgy@sydney.dce.transarc.com
        valid 92/08/27:12:24:56 to 92/08/27:22:24:54
Server: dce-ptgt@sydney.dce.transarc.com
        valid 92/08/27:12:25:00 to 92/08/27:14:25:00
Client: dce-ptgt@sydney.dce.transarc.com        Server: krbtgt/sydney.dce.tran
sarc.com@sydney.dce.transarc.com
        valid 92/08/27:12:25:01 to 92/08/27:14:25:00
Client: dce-ptgt@sydney.dce.transarc.com        Server: dce-rgy@sydney.dce.tra
nsarc.com
        valid 92/08/27:12:25:03 to 92/08/27:14:25:00

Now change the account information of "brad" in the registry and change
his group to "none". Then do a kinit as "brad" again in the same window,
followed by a klist. The output this time is:

# kinit
Enter password:
# klist
DCE Identity Information:
        Warning: Identity information is not certified
        Global Principal: /.../sydney.dce.transarc.com/brad
        Cell:      006C4C7E-ACF3-1A9B-AF56-08005A4D1B20 /.../sydney.dce.transa
rc.com
        Principal: 0000006C-01B3-2A9D-9A00-08005A4D1B20 brad
        Group:     0000006E-01A6-2A9C-9A01-08005A4D1B20 <group name unknown>
        Local Groups:
                0000006E-01A6-2A9C-9A01-08005A4D1B20 <group name unknown>

Identity Info Expires: 92/08/27:22:29:06
Account Expires:       never
Passwd Expires:        never

Kerberos Ticket Information:
Ticket cache: /opt/dcelocal/var/security/creds/dcecred_388bd800
Default principal: brad@sydney.dce.transarc.com
Server: krbtgt/sydney.dce.transarc.com@sydney.dce.transarc.com
        valid 92/08/27:12:29:08 to 92/08/27:22:29:06
Server: dce-ptgt@sydney.dce.transarc.com
        valid 92/08/27:12:29:14 to 92/08/27:14:29:14
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[8/27/92 public]
This seems to be a problem with groups in security, not cds or nsi.

[10/12/92 public]
Assigned it to myself.  I have no idea why it was assigned to saxena@transarc,
but it's obviously security related, not DFS.

[10/15/92 public]

OT cleanup 1 : New Severity : C ;  Priority : unchanged (2)
               Old severity : B 

N.B. I have lowered the severity to C which means that it would be nice
     to fix this in 1.0.2 but will be done only if there is time. 
     Severity B implies that this MUST be fixed on 1.0.2 . I have done this
     because there seems to be a workaround i.e. after the group has been 
     changed log out and dce_login back in. 

     If this is not an acceptable workaround or my understanding of the 
     bug is incorrect, please update this report.

[11/20/92 public]
This is not a problem of kinit messing up the group name.  kinit is refreshing
the TGT, but not the rest of the DCE information.  When klist goes to get the
group name with sec_id_gen_group() it uses sec_rgy_default_handle for the
registry binding handle.  This tries to bind to /.: to set up the default
handle, thus it must call rpc_binding_set_auth_info with the client's pac.
The group in the client's pac is not the same as that stored for that account
in the server now, so the priv server (line 812 of server/rs/rpriv.c) returns
sec_priv_s_invalid_principal and the rpc_binding_set_auth_info fails, causing
the default handle setup to fail, causing the sec_id_gen_group to fail, which
is why it can only print out the uuid for the group.  The following is the
comment about the check in rpriv.c, and I was just going to close this as
"not a bug" based on it being correct as coded, but Bill wants to think about
whether kinit should be refreshing everything, since it's supposedly integrated
with DCE, so I'm leaving it open and reassigning it to him.
        /* 
         * check the principal and group uuid asserted by the client
         * in the request's autorization data against the prinicipal
         * and group uuids current for the named client.  If they differ,
         * either the client screwed up, or an administrator has changed
         * the principal's credentials after the client logged in. 
         * 
         *XXX we fail for now, but we might want to consider alternatives
         *    to failure when only the primary group has changed e.g., we
         *    might want to add the client asserted primary group to
         *    client-asserted groupinfo, causing the old primary group
         *    to appear in the client's groupset, if the client is a 
         *    member of the old primary group.
         */
        if (!(uuid_equal(&sid.person, &authz_data.principal.uuid, stp)
               && uuid_equal(&sid.group, &authz_data.group.uuid, stp))) {
            SET_STATUS(stp, sec_priv_s_invalid_principal);
        }

[12/8/92 public]
Bill and I agree that this is an enhancement request for kinit to refresh the
DCE information too (not just the TGT).  It currently operates as designed.



CR Number                     : 4851
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_login_ API
Short Description             : sec_login_export_context may "obtain" "unfinalized" login context
Reported Date                 : 7/27/92
Found in Baseline             : 1.0
Found Date                    : 7/27/92
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : h/sec_login_pvt.h client/login/sec_login{_pvt}.c
Sensitivity                   : public

[7/27/92 public]

Full Description:

When sec_login_import_context(3sec) is called with the name of the
exportable login context returned by a call to sec_login_export_context(3sec),
sec_login_import_context(3sec) will return sec_login_s_no_current_context,
unless the call to sec_login_export_context is preceded by a call to
sec_login_set_context(3sec), in which case the import returns error_status_ok.
In both cases, the call to sec_login_export_context returns error_status_ok.

 [pato ??/??/92 public]
Ron,
It looks to me like the export context call has a bug.  In the case you
cite, it should have failed.  Normally you need not call set_context - because
you are running in an environment that has a default context (i.e., you've run
login or dce_login).  It appears that in your example this was not true.
Since it wasn't true and the context passed to the export function had not been
"finalized" via a set_context call - state was not yet established to allow
the context to be exported.  We should either cause export to fail in this case
- or force it to finalize the context to a point that would allow the import
to succeed.  In either case, this appears to be a bug in export.

I didn't read the detail of the rest of your note, but from skimming, the
observations you've made look correct.
- joe

[10/19/92 public]

OT cleanup 1 : Severity = unchanged (C) ; Priority = unchanged (2)

N.B. In view of the workaround which seems to work, severity and priority
     have both been unchanged.

[10/19/92 public]
Put missing comment leader on Joe's comment, so you can tell that it's not just
part of the original defect comment.  There was no history info for when he
updated it, thus the ??/?? date.  Filled in the empty company field.

[12/15/92 public]
Submitted fix, marked 'fix'.  Verify by running the following test program
(should import with no errors if fixed):
#include <stdio.h>
#include <dce/sec_login.h>
#include <dce/passwd.h>
main()
{
    sec_passwd_rec_t		prec;
    sec_login_handle_t  	lc, lc2;
    error_status_t    		st;
    boolean32           	rp;
    sec_login_auth_src_t 	src;
    char                        buf[BUFSIZ];
    unsigned32		        len1, len2;
    if (! sec_login_setup_identity("cell_admin",sec_login_no_flags,&lc,&st)) {
	printf("Can't setup_identity: %x\n", st); exit(1);
    }
    prec.key.key_type = sec_passwd_plain;    prec.pepper = NULL;
    prec.key.tagged_union.plain = (unsigned char *) "-dce-";
    prec.version_number = sec_passwd_c_version_none;
    if (! sec_login_validate_identity(lc, &prec, &rp, &src, &st)) {
	printf("Can't validate_identity: %x\n", st); exit(2);
    }
    sec_login_export_context(lc, sizeof(buf), buf, &len1, &len2, &st);
    if (st) {
	printf("Unable to export context: %x\n", st); exit(3);
    }
    sec_login_import_context(sizeof(buf), buf, &lc2, &st);
    if (st) {
	printf("Unable to import context: %s %x\n", buf, st); exit(3);
    }
}

[1/3/93 public]

The above program generates a "Exception: Invalid memory address (dce / thd"
on PMAX running OSF/1.1.1 with a nightly build of approx 12/29 . 
I will come back to this after I have closed the other bugs in fixed state.

[1/26/93 public]
Removed fix for now, since it was causing 6917 and 6938.  Correct fix will
have to check new boolean value for whether context has been written out to
cred data file... instead of KRB_INFO(lcp).num_caches, which doesn't work
correctly for contexts obtained with sec_login_get_current_context().

[9/29/93 public]
After finally having time to look into this again (first time since Jan),
I've concluded that this is really a request for new functionality (a good
request that we do wish to implement, but it is new nevertheless...).  At
the moment, you have to do a sec_login_set_context() before you can do
sec_login_export_context().  This CR is asking that sec_login_export_context()
be able to do the whole set of operations if ...set_context() hasn't been done.
This new functionality is actually a good size change to the internal login
context handling and we'll look into doing it with the massive amounts of
other sec_login changes we have to make for 1.1 anyway.



CR Number                     : 4728
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 4714
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : Kerberos error codes returned from routines in sec_login_pvt.c
Reported Date                 : 7/15/92
Found in Baseline             : 1.0
Found Date                    : 7/15/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/15/92 public]

    Some of the security functions do not adequately mask off kerberos errors.
    (e.g allocate_krb_info in security/client/login/sec_login_pvt.c). In
    some cases, these error codes are passed directly up through the api
    to the application developer. In some more carefully handled cases,
    kerberos error values are "masked" into a single sec_ error code.

    The kerberos error codes are not documented in the DCE documentation which
    makes life very difficult for an application developer.

    Also, mapping the kerberos error to a generic sec_ error indicating
    that a kerberos error occured makes it difficult to determine what
    actually went wrong.

Repeat By:

Code inspection.

Proposed Solution:

     Only sec_ codes should be returned through the api, The kerberos
     errors should be mapped to an appropriate sec error which helps the
     application developer fix the problem. In general, the "a kerberos error
     occured" approach should be reserved for problems whose cause cannot
     be expected to be resolved by changing the way the function which
     returned the error was called.

[10/19/92 public]

OT cleanup 1 : New severity = C ;  New priority = 2
               Old severity = E ;  Old priority = 4

N.B. This is a significant problem and does impact users/programmers.
     Hence the severity of C and priority of 2. I have marked it as
     C2 merely because in general finding and fixing all the places 
     kerberos error codes and convertng of kerberos error codes may 
     take up so much time that it may prevent the meeting of other exit
     criteria (e.g. meeting the defect density ).

[10/20/92 public]

Converted the defect into an enhancement. This is consistent with other
similar enhancements logged against the propagation of error codes.
I will leave the priority at C2 because this is still an important
enhancement.



CR Number                     : 4714
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : Kerberos error codes / UNIX errnos returned by sec_key_mgmt API functions.
Reported Date                 : 7/14/92
Found in Baseline             : 1.0
Found Date                    : 7/14/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/key_mgmt/seckey_del.c
Sensitivity                   : public

[7/14/92 public]

Full Description:

The sec_key_mgmt functions can pass up UNIX errnos or kerberos error codes.

A very common case of UNIX errnos being passed up is ENOENT (errno = 2)
when a key table file does not exist. When EACCES is returned (errno = 13),
this is intercepted in the key_mgmt API functions which call the kerberos
key table access functions - in this case, the error is reset to
sec_key_mgmt_e_unauthorized.

In the ENOENT case, we should have a return code such as
sec_key_mgmt_e_no_such_key_table to show that the key table file does not
exist - this is a very serious omission.

Two specific cases of kerberos error codes being passed up and not
intercepted are the API functions sec_key_mgmt_delete_key and
sec_key_mgmt_delete_key_type.

Here the functions do not test for KRB5_KT_NOTFOUND which corresponds
to the error sec_key_mgmt_e_key_unavailable.  It should be straightforward
to map the kerberos error codes onto sec_key_mgmt_e codes - the problem
is in finding where the errors have been missed.

Repeat By:

Code inspection and running test cases.

Proposed Solution:

Context diff for fixes to DCE1 version of seckey_del.c follows :

Basically, the added lines check for KRB5_KT_NOTFOUND and reset
the error codes. These changes fix sec_key_mgmt_delete_key and
sec_key_mgmt_delete_key_type.

*** seckey_del.c        Fri Jul  3 19:10:59 1992
--- tmp.c               Fri Jul  3 19:10:23 1992
***************
*** 122,131 ****
              *err = sec_key_mgmt_e_unauthorized;
          }

-         else if (*err == KRB5_KT_NOTFOUND) {
-             *err = sec_key_mgmt_e_key_unavailable;
-         }
-
          /*
           * Release storage for parsed name.
           */
--- 122,127 ----
***************
*** 239,248 ****

          if (*err == EACCES) {
              *err = sec_key_mgmt_e_unauthorized;
-         }
-
-         else if (*err == KRB5_KT_NOTFOUND) {
-             *err = sec_key_mgmt_e_key_unavailable;
          }

          /*
--- 235,240 ----
--

[10/19/92 public]

OT cleanup 1 : Severity = unchanged (2) ; Priority = unchanged (2)

N.B. This is a significant problem and does impact users/programmers.
     Hence the severity and priority have been left unchanged.

[10/20/92 public]

Converted the defect into an enhancement. This is consistent with other
similar enhancements logged against the propagation of error codes.
I will leave the priority at C2 because this is still an important
enhancement.



CR Number                     : 4270
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : Princ name change on sec_rgy_acct_rename not implemented
Reported Date                 : 6/15/92
Found in Baseline             : 1.0.1
Found Date                    : 6/15/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/15/92 public]

The following does not work:

rgy_edit=> do p
rgy_edit=> a rk
rgy_edit=> do a
rgy_edit=> a rk -g none -o none -pw -dce- -mp -dce-
rgy_edit=> do p
rgy_edit=> a xyz
rgy_edit=> do a
rgy_edit=> c -p rk -g none -o none -mp -dce- -np xyz
?(rgy_edit) Unable to change "rk" - Illegal PGO or directory name (dce / sec)

We have tried the above without adding the principal xyz, which also does
not work. Burati says that if the principal is not created then it 
should not work, but if the principal is created then it should work.

[6/15/92 public]
Note: The '-mp -dce-' option in the change command above is useless, since
it's only used to encrypt a new key that was specified with a -pw or -rp
option.  I am able to reproduce the problem here on RIOS at b18 with both
the above syntax, and the interactive change command (using prompts instead
of the -np option).  It's lower priority than a couple CR's I'm working on
now, so I'll get to it after those.

[6/18/92 public]
It turns out that principal name changes on an account rename are not
supported by secd yet.  I need to talk this over with Joe when he gets
back next week.  It may be an enhancement to secd that gets deferred to
1.0.2, in which case we'll have to get something into the release notes
explaining why rgy_edit change -np always returns an error.

[6/22/92 public]
This enhancement to secd cannot be done in time for 1.0.1, so we've marked
it 'defer'.  We'll look into it for 1.0.2, and try to get a msg in the release
notes that the registry functionality corresponding to rgy_edit's change -np
is not implemented yet.



CR Number                     : 4062
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : acl_edit
Short Description             : Some suggestions for usability.
Reported Date                 : 6/4/92
Found in Baseline             : 1.0.1b17
Found Date                    : 6/4/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[6/4/92 public]

I would like to make the following suggestions for enhancing the usability
of the acl_edit command.

1)  Make it more UNIX like and put the options prior to the object that 
    acl_edit is to act upon.

2)  Remove the #'s from the output.

3)  My understanding is that to modify an ACL I need to go into the
    interactive mode.  This is very painful.

This command will have a usage pattern similar to the ls -l command.  Given
that, the current interface seems insufficient.  Users will be using this
command in admin scripts and such, so making the interface more usable,
as quickly as possible would be a benefit to such users.

Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[6/4/92 public]
> 1) Make it more UNIX like
Maybe.  It was designed around early POSIX drafts and there may be a way to
make it more unix like, but it's perfectly usable as it is.

> 2) Remove the #'s from the output.
No.  These denote non-data (except for the cellname, which is an unfortunate
exception).  The data portion of the output can be used as input to acl_edit
through the -f option (or the interactive 'assign' command).  So, you can run
acl_edit and redirect output to a file, run it again using the -f option with
that filename, and effectively copy an acl from one object to another.

> 3) Must use interactive mode
Who gave you this idea???  Interactive mode is a secondary feature which we
put there to make it easier on users to do certain things.  If you don't like
it don't use it.  All commands are available on the command line.  Transarc
must have a copy of the documentation there, and I know the docs on acl_edit
explain what each command line option does (although the 1.0.1 doc is much
better).  Take a look at dce_config, it modifies acls all over the place and
never goes into interactive mode.

I've marked this as 'defer', since no new functionality will be added to
any DCE component before 1.0.1 is out the door.

[6/5/92 public]

>> 2) Remove the #'s from the output.
>No.  These denote non-data (except for the cellname, which is an unfortunate
>exception).  The data portion of the output can be used as input to acl_edit
>through the -f option (or the interactive 'assign' command).  So, you can run
>acl_edit and redirect output to a file, run it again using the -f option with
>that filename, and effectively copy an acl from one object to another.

This sounds like a nice feature, but I don't think it should be the default
behavior.  I wold prefer if I could contorl this output via an option.

One other thing that I think would be useful is for acl_edit to indicate
if the ACL it prints is real, or contrived from the mode bits.  I know that
the two are to be kept in sync and changes to one affect the other, but
if I were an administrator I think I would want to know when I was looking at 
real ACL's versus an interpretation of the mode bits.

[6/5/92 public]

The use of '#' is in keeping with the draft posix specification.  Posix
stipulates that the effective access rights (after masking) are supposed
to be output after a '#' character.  In addition Posix mandates that the 
standard output format of an ACL (as emitted by editors or lsacl) contain
several lines that begin with '#' that identify the object protected by the
acl.

Given that we want to conform to POSIX, we cannot change the default behavior.
It is possible that we will add options in the future to provide an alternate
output format, but this will be low priority.

[6/5/92 public]
To reiterate my position on this CR:
> 1) More Unix like
I'll look into the command line syntax *after* 1.0.1 to see if I can't
make it more tolerant of UNIX behavior, without breaking any current possible
usage.  That's all I'll do in that area.

> 2) #'s
This is *not* going to change, unless POSIX changes their mind (see Joe's note)

> 3) Must use interactive mode
Just plain wrong.

> 4) Indicate if the ACL is real or contrived from mode bits.
HUH?  I don't think you understand what the DCE ACL architecture is.  Maybe
internal to DFS you can tell how an ACL came about but the DCE ACL architecture
the API, acl_edit, the wire interface ... are *not* designed around the DFS
acls.  There is a conversion layer that lets you manipulate DFS acls via the
DCE ACL API.  This indication of how the ACL was generated will not be a part
of the DCE ACL architecture anytime soon.  If you feel strongly enough about
it, and can convince OSF that it's necessary and that there's a way to do it
that isn't catering to DFS (ie: generic enough that any DCE ACL manager can
do something with it) then somebody may think about doing it for DCE2.0 or
beyond.



CR Number                     : 3819
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : need to avoid uninitialized output arguments
Reported Date                 : 5/26/92
Found in Baseline             : 1.0.1
Found Date                    : 5/26/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/26/92 public]

Someone (me?) needs to make a pass through all the remoted routines
exported by secd and ensure that all output arguments are initialized to
known, "safe" values in all paths through the manager routines; otherwise,
one might be able to pick up interesting and useful encryption keys out of
"stack garbage".

Exploiting this "feature" is inherantly machine-dependant, but is likely to
be possible on most systems.

I suspect the appropriate thing to do is add a bunch of "memset()" calls in
appropriate places.

The only one I'm sure of is secd's implementation of the rsecidmap
interface.

[6/24/92 public]

I've fixed the one case I'm sure of, but still need to through the rest of
them.

[10/19/92 public]

OT cleanup 1 : Severity = unchanged(C)  ;  Priority = unchanged (2)

[1/4/93 public]
Changed priority to 3 since this is a cleanup activity that no one
is waiting for and with no real known cases that need fixing.

[10/13/93 public]

changed to enhancement.



CR Number                     : 3637
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : Need better error msg on acct add w/ bad caller passwd.
Reported Date                 : 5/18/92
Found in Baseline             : 1.0.1b14
Found Date                    : 5/18/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/18/92 public]

I have recently installed a dce cell and have been experimenting with
rgy_edit.
After going thru the litany of questions to add a new principal I got
the following error message:

?(rgy_edit) Unable to add "jec" - Data integrity error (dce / sec)

After playing around a bit more I figured it out - I had entered the
same password 3 times instead of entering the new password tweice and
the third time to enter the password of the account that I was
dce_login'ed as (in this case cell_admin).

The error message did nothing to indicate where the problem was. Is
this a feature or a (potential) slip?

[5/27/92 public]
Changed subcomponent to secd, since that's where the error is coming
from (rgy_edit can't know that there wasn't really a data integrity
problem, so it can't just replace the error message).  We're looking
into enhancing the password change code to be able to detect the incorrect
password case, to give a more usable error (there may still be a possibility
of getting this error if data integrity was not preserved over the wire).
Changed short description, so readers of summary reports will know what this
defect is really about.

[6/22/92 public]
Not likely to be done for 1.0.1, because it may also involve documentation
changes...



CR Number                     : 3323
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : kerberos
Short Description             : remove export warning
Reported Date                 : 5/7/92
Found in Baseline             : 1.0.1
Found Date                    : 5/7/92
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/7/92 public]
Most kerberos files are not restricted from export.  Please remove
the export warning from the following comment in all files which
are not.

 * Export of this software from the United States of America is assumed
 *   to require a specific license from the United States Government.
 *   It is the responsibility of any person or organization contemplating
 *   export to obtain such a license before exporting.
 *
 * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
 * distribute this software and its documentation for any purpose and
 * without fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation, and that
 * the name of M.I.T. not be used in advertising or publicity pertaining
 * to distribution of the software without specific, written prior
 * permission.  M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is" without express
 * or implied warranty.

[5/7/92 public]

I assume that the only lines which should be removed are:

 * Export of this software from the United States of America is assumed
 *   to require a specific license from the United States Government.
 *   It is the responsibility of any person or organization contemplating
 *   export to obtain such a license before exporting.

I think it might be safer to change "is assumed to" to "may":

 * Export of this software from the United States of America may
 *   require a specific license from the United States Government.
 *   It is the responsibility of any person or organization contemplating
 *   export to obtain such a license before exporting.

Is there any problem with this?

[5/14/92 public]
Lowered the priority to 2.

[7/9/93 public]

Note that the phrase in question is a constraint of the license from MIT;
we cannot unilaterally change this without their approval.

I'll ping Ted Ts'o about this and see if he can make anything happen; if
not, we can't change this.

[9/8/93 public]

I just saw mail saying that MIT's licensing folks have approved just such a
change; with any luck it will be in Krb5B3 ...



