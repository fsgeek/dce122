CR Number                     : 13682
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : PK preauth memory corruption (aka. Hitachi can't config)
Reported Date                 : 12/13/96
Found in Baseline             : 1.2.2
Found Date                    : 12/13/96
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : src/security/krb5/kdc/kdc_pk_preauth.c
Diff supplied by              : provider
Diff release                  : 1.2.2
Sensitivity                   : public

[12/13/96 public]
Hitachi Japan was not able to configure DCE 1.2.2 international code on
AIX. The dce_login during dce_config was failing with:

1996-12-12-18:01:09.459-06:00I----  dce_login ERROR sec login preauth.c \
1276 0x2044ca00 krb5_obtain_dce_tp_preauth failed; errno text: Generic \
preauthentication failure (dce / krb)

The KDC (in secd) logged the following to syslog:

Dec 10 14:13:56 dfamrs6s secd[16123]: AS_REQ; ENCODE_KDC_REP: host \
20a7604e-524c-11d0-bc22-10005afa0c50@ncacn_ip_tcp:202.216.113.49[1038], \
cell_admin@6s.cell for krbtgt/6s.cell@6s.cell failed: Unknown code DCE:krb \
185 (336761017)

This was traced to memory corruption in the PK preauth code. The reply_keyP
contents in krb5_pkinit_sign_as_rep was being free()'ed by mistake. Random
chance decided if the memory pointed to by reply_keyP was to be corrupted
before using the key. The fix is to not free reply_key at the end of the
routine.

*** kdc_pk_preauth.c@@/main/DCE_1.2.2/jrr_122_8/0       Fri Dec 13 13:20:01
1996
--- kdc_pk_preauth.c@@/main/DCE_1.2.2/jrr_122_8/1       Fri Dec 13 13:40:14
1996
***************
*** 8,13 ****
--- 8,17 ----
  /*
   * HISTORY
   * Log: kdc_pk_preauth.c,v 
+  * Revision /main/DCE_1.2.2/jrr_122_8/1  1996/12/13  18:40 UTC  jrr
+  *    Do not free reply_key before returning it in reply_keyP
+  *    in krb5_pkinit_sign_as_rep().
+  * 
   * Revision /main/DCE_1.2.2/4  1996/11/05  19:59 UTC  aha
   *    CHFts20610: free reply_key contents only if bad status; modify
   *    reply_keyP only if good status.
***************
*** 314,320 ****
             krb5_free_keyblock(reply_key);
      } else {
         *reply_keyP = reply_key;
-        free(reply_key);
      }
      if (tmpkey)
         krb5_free_keyblock(tmpkey);
--- 318,323 ----

[12/13/96 public]

OT test.

[12/14/96 public]

More cleanup. Sigh.



CR Number                     : 13651
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : PK Login
Short Description             : PK Login policy is not implemented
Reported Date                 : 10/4/96
Found in Baseline             : 1.2.2
Found Date                    : 10/4/96
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : security/krb5/include/krb5/kdb.h
Diff supplied by              : provider
Diff release                  : 1.2.2
Sensitivity                   : public

[10/4/96 public]

Policy control to require users to log in using Public Key Login
has not yet been implemented.  Policy control will be included
in the BL05 drop.

[11/13/96 public]
Support for policy control is included in the BL05 drop.  This
uses the existing "pre_auth_req" ERA to specify which protocols
a user is allowed to use.



CR Number                     : 13644
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_login
Short Description             : validate ID errcodes have changed
Reported Date                 : 10/02/96
Found in Baseline             : 1.2.2
Found Date                    : 10/27/96
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 1.2.2
Affected File(s)              : sec_login_pvt.c,do_as_req.c,kdc_preauth.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : private

[10/3/96 private]
Error codes for certain validate ID cases have been changed.  This
affects interoperability and tests.  Basically raw Kerberos error
codes are being returned (dce / krb).

Sec API failures:
---------------------------------------------------------------
Routine Tested:   login_test
Tested For:       2 login_validate_identity test: invalid password

Trace Message:    sec_login_setup_identity (flintstone 0.. ), status; Successf

l completion (dce / svc)
Trace Message:    sec_login_validate_identity ( .. ), status; status 0x1412901

 (dce / krb)
Trace Message:    Reset Login flag is true, AuthSrc is Network
Failure Message:  sec_login_validate_identity
Failure Message:  failure set by the function under test
Trace Message:    sec_login_purge_context ( .. ), status; Successful completio

 (dce / svc)
Test Status:      Test FAILED
Status Returned:  30146561
Status Text:      test failed

sec_psm_open failed: 1712207a...
Registry object not found (dce / sec)

[11/13/96 public]
This defect has been fixed in the BL05 drop.  All tests now pass.



CR Number                     : 13643
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : Third-Party pre-authentication does not work
Reported Date                 : 10/02/96
Found in Baseline             : 1.2.2
Found Date                    : 10/27/96
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 1.2.2
Affected File(s)              : do_as_req.c,kdc_preauth.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : private

[10/3/96 private]
The Third-Party Pre-authentication protocol introduced in OSF DCE
1.1 does not work in the BL04 release of OSF DCE 1.2.2.  The code
has been #ifdef 0 until it can be merged into the new authentication
framework from KRB5 Beta6 used for public key login.

Sec TET failures:

520|4 1 11576 16 1|Login for testlogin passed after 300 seconds, account succes
sfully reset
520|4 1 11576 16 2|PASSED: Login activity 3: reset account, good login
220|4 1 1 12:03:55|FAIL
410|4 3 1 12:03:55|IC End
520|4 0 11576 1 1|DCE invalid login tests done, cleanup begun on client ibm_l4
80|4 0 12:04:01|TC End
10|5 /ts/client/login/preauth/preauth-tc 12:04:01|TC Start, scenario ref 76-1
15|5 1.9 1|TCM Start
510|5|warning: illegal entry 13 in TET_SIG_IGN ignored
400|5 1 1 12:04:09|IC Start
200|5 1 12:04:09|TP Start
520|5 1 14718 1 1|DCE Preauthentication test purpose 1: successful login
520|5 1 14718 1 2|\texpecting THIRD PARTY preauth
520|5 1 14718 1 3|FAILED: preauth_tp1: see tp1_errors file
220|5 1 1 12:04:14|FAIL
410|5 1 1 12:04:14|IC End
80|5 0 12:04:17|TC End

[10/3/96 public]
The BL05 drop includes full support for OSF DCE Third-Party
Pre-Authentication as well as Public Key Pre-Authentication.



CR Number                     : 13637
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_pvtkey_switch
Short Description             : Keystore entry 1 is corrupt
Reported Date                 : 10/1/96
Found in Baseline             : 1.2.2
Found Date                    : 10/1/96
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : sec_pvtkey_registered_keystores.c
Diff supplied by              : user
Diff release                  : 1.2.2
Sensitivity                   : public

[10/1/96 public]
I configured a fresh cell using the BL04 binaries from the Sept 27
release build on miney (HP-UX).

After completion of configuration, the following error was in 
/opt/dcelocal/var/svc/error.log:
1996-10-01-11:35:38.429-04:00I----- secd ERROR psm psm_psm \
 sec_pvtkey_switch.c 417 0x7aff35f8 Keystore entry 1 is corrupt

As this is not a debuggable libdce, I cannot provide more information.

[10/01/96 public]
Problem is that when HP conditionalized sec_pvtkey_registered_keystores.c
(since PKSS would not build on HPUX), we left the SEC_PVTKEY_SWITCH_FLAG_TERMINATE
flag off the last entry in installed_keystore[].

[10/04/96 public]
Fix submitted with international BL04.
Diffs:
*** /vob/dce/src/security/psm/domestic/sec_pvtkey_registered_keystores.c@@/main/DCE_1.2.2/2	Mon Sep 23 17:36:14 1996
--- /vob/dce/src/security/psm/domestic/sec_pvtkey_registered_keystores.c@@/main/DCE_1.2.2/aha_pk9_5/1	Tue Oct  1 13:53:08 1996
***************
*** 5,10 ****
--- 5,14 ----
   *
   * HISTORY
   * $Log:	c013637,v $
# Revision 1.3  96/10/04  16:51:11  root
# changed fields: Status  Fix By Baseline  Fixed In Baseline  Affected File(s)  Diff supplied by  Diff release   new/changed/deleted note(s) [aha 10/04/96 public]
# 
+  * Revision /main/DCE_1.2.2/aha_pk9_5/1  1996/10/01  17:53 UTC  aha
+  * 	Add TERMINATE flag to last HPUX installed_keystore entry.  Change
+  * 	is conditionalized for HPUX only.
+  * 
   * Revision /main/DCE_1.2.2/2  1996/09/23  21:36 UTC  arvind
   * 	Conditionalize  HP build not to use pkss/pkc
   * 	[1996/09/10  18:32 UTC  arvind  /main/arvind_pkss/3]
***************
*** 55,60 ****
--- 59,65 ----
  keystore_epv installed_keystore[MAX_KEYSTORES] = {
      {SEC_PVTKEY_KEYSTORE_MAGIC,
       SEC_PVTKEY_SWITCH_FLAG_ENABLED
+      | SEC_PVTKEY_SWITCH_FLAG_TERMINATE
       | SEC_PVTKEY_SWITCH_FLAG_MATCHALL,
       &sec_psm_file_mechanism,
       "Local file",



CR Number                     : 13574
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : acldb
Short Description             : dce_acl_copy_acl() handles foreign_id incorrectly
Reported Date                 : 7/23/96
Found in Baseline             : 1.2.2
Found Date                    : 7/23/96
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : dce/utils/acldb/aclconv.c
Diff supplied by              : provider
Diff release                  : 1.2.2
Sensitivity                   : public

[7/23/96 public]

The dce_acl_copy_acl() routine in aclconv.c does not copy over foreign_id
correctly that causes some junk to be left for id.name and realm.name
after operations like dce_acl_obj_add*().

The diffs of the fix will be posted soon.

[7/23/96 public]

This bug does not affect dce_acl_obj_add*() routines but rather *acl_lookup()
routines.

[7/24/96 public]

Further review of this routine indicates that it also handles extended_acl
and delegate entries incorrectly. Diff's is on its way.

[7/25/96 public]
Part of 1.2.2 and will be provided in next drop:

*** /vob/dce/src/dce/utils/acldb/aclconv.c@@/main/psn_bugfix/1  Tue Jul 23 10:33
:39 1996
--- /vob/dce/src/dce/utils/acldb/aclconv.c      Wed Jul 24 13:40:47 1996
***************
*** 8,13 ****
--- 8,23 ----
  /*
   * HISTORY
   * $Log:	c013574,v $
# Revision 1.5  96/07/25  17:52:39  root
# changed fields:  new/changed/deleted note(s) [psn 7/25/96 public]
# 
# Revision 1.4  96/07/25  13:47:16  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Diff supplied by  Diff release   new/changed/deleted note(s) [psn 7/25/96 public]
# 
+  * Revision /main/psn_bugfix/2  1996/07/23  15:39 UTC  psn
+  *    Fix OTs 13547: dce_acl_copy_acl() handles foreign_id incorrectly
+  *
   * Revision /main/psn_bugfix/1  1996/07/23  14:34 UTC  psn
   *    Fix OTs 13031: dce_acl_obj_add_obj lacks support to add user_obj,
   *    group_obj, mask_obj & other_obj.
***************
*** 69,74 ****
--- 79,85 ----

  #include <aclimpl.h>

+ #include <dce/uuid.h>
  #include <dce/pgo.h>
  #include <dce/secidmap.h>
  #include <dce/dce_cf.h>
***************
*** 145,150 ****
--- 156,173 ----
        /* free each entry */

        switch (ae->entry_info.entry_type) {
+       case sec_acl_e_type_mask_obj:
+       case sec_acl_e_type_user_obj:
+       case sec_acl_e_type_group_obj:
+       case sec_acl_e_type_other_obj:
+       case sec_acl_e_type_unauthenticated:
+       case sec_acl_e_type_any_other:
+       case sec_acl_e_type_user_obj_deleg:
+       case sec_acl_e_type_group_obj_deleg:
+       case sec_acl_e_type_other_obj_deleg:
+       case sec_acl_e_type_any_other_deleg:
+           break;                      /* no action */
+
        case sec_acl_e_type_user:
        case sec_acl_e_type_group:
        case sec_acl_e_type_foreign_other:

***************
--- 192,201 ----
            break;

+       case sec_acl_e_type_extended:
+             if (ae->entry_info.tagged_union.extended_info)
+                 rpc_sm_free(ae->entry_info.tagged_union.extended_info, st);
+           break;
+
        default:
            break;
        }
***************
*** 447,468 ****
      acl2->sec_acl_entries     = (sec_acl_entry_t *)rpc_sm_allocate(
                sizeof(sec_acl_entry_t)*acl1->num_entries, st);
      STAT_CHECK_RET(*st);

!     for (i=0; i<acl1->num_entries; i++) {
        ae1 = &acl1->sec_acl_entries[i];
        ae2 = &acl2->sec_acl_entries[i];
!       acl2->sec_acl_entries[i] = acl1->sec_acl_entries[i];

        switch (ae1->entry_info.entry_type) {
        case sec_acl_e_type_user:
        case sec_acl_e_type_group:
        case sec_acl_e_type_foreign_other:
!           ae2->entry_info.tagged_union.id.uuid =
!               ae1->entry_info.tagged_union.id.uuid;
            if (ae1->entry_info.tagged_union.id.name) {
                cp = ae1->entry_info.tagged_union.id.name;
                ae2->entry_info.tagged_union.id.name =
                        (idl_char *)rpc_sm_allocate(strlen((char *)cp) + 1, st);
                strcpy((char *)ae2->entry_info.tagged_union.id.name, (char *)cp)
;
            }
            else
--- 558,587 ----
      acl2->sec_acl_entries     = (sec_acl_entry_t *)rpc_sm_allocate(
                sizeof(sec_acl_entry_t)*acl1->num_entries, st);
      STAT_CHECK_RET(*st);
+     memset(acl2->sec_acl_entries, 0, sizeof(sec_acl_entry_t)*acl1->num_entries
);

!     for (i=0; *st == error_status_ok && i<acl1->num_entries; i++) {
        ae1 = &acl1->sec_acl_entries[i];
        ae2 = &acl2->sec_acl_entries[i];
!         /* Copy perms and entry type */
!       ae2->perms = ae1->perms;
!       ae2->entry_info.entry_type = ae1->entry_info.entry_type;

        switch (ae1->entry_info.entry_type) {
        case sec_acl_e_type_user:
        case sec_acl_e_type_group:
        case sec_acl_e_type_foreign_other:
!       case sec_acl_e_type_user_deleg:
!       case sec_acl_e_type_group_deleg:
!       case sec_acl_e_type_for_other_deleg:
!             ae2->entry_info.tagged_union.id.uuid =
!               ae1->entry_info.tagged_union.id.uuid;
            if (ae1->entry_info.tagged_union.id.name) {
                cp = ae1->entry_info.tagged_union.id.name;
                ae2->entry_info.tagged_union.id.name =
                        (idl_char *)rpc_sm_allocate(strlen((char *)cp) + 1, st);
+                 if (*st != error_status_ok)
+                     break;
                strcpy((char *)ae2->entry_info.tagged_union.id.name, (char *)cp)
;
            }
            else
***************
*** 475,509 ****
        case sec_acl_e_type_other_obj:
        case sec_acl_e_type_unauthenticated:
        case sec_acl_e_type_any_other:
            break;                      /* no action */

        case sec_acl_e_type_foreign_user:
        case sec_acl_e_type_foreign_group:
-           ae2->entry_info.tagged_union.foreign_id =
-               ae1->entry_info.tagged_union.foreign_id;
-           break;
-       case sec_acl_e_type_extended:
-           ae2->entry_info.tagged_union.extended_info =
-               ae1->entry_info.tagged_union.extended_info;
-           /* ae2->entry_info.tagged_union.extended_info.pickled_data
-            * is NOT a pointer, so we cannot allocate a copy.
-            */
-           break;
-       case sec_acl_e_type_user_obj_deleg:
-       case sec_acl_e_type_user_deleg:
        case sec_acl_e_type_for_user_deleg:
-       case sec_acl_e_type_group_obj_deleg:
-       case sec_acl_e_type_group_deleg:
        case sec_acl_e_type_for_group_deleg:
!       case sec_acl_e_type_other_obj_deleg:
!       case sec_acl_e_type_for_other_deleg:
!       case sec_acl_e_type_any_other_deleg:
            break;
        default:
            break;
        }
      }
!     acl2->num_entries = acl1->num_entries;
  }

  /* ______________________________________________________________________ */
--- 594,681 ----
        case sec_acl_e_type_other_obj:
        case sec_acl_e_type_unauthenticated:
        case sec_acl_e_type_any_other:
+       case sec_acl_e_type_user_obj_deleg:
+       case sec_acl_e_type_group_obj_deleg:
+       case sec_acl_e_type_other_obj_deleg:
+       case sec_acl_e_type_any_other_deleg:
            break;                      /* no action */

        case sec_acl_e_type_foreign_user:
        case sec_acl_e_type_foreign_group:
        case sec_acl_e_type_for_user_deleg:
        case sec_acl_e_type_for_group_deleg:
!             /* Copy foreign id */
!           ae2->entry_info.tagged_union.foreign_id.id.uuid =
!               ae1->entry_info.tagged_union.foreign_id.id.uuid;
!             /* Copy foreign id name if not NULL */
!           if (ae1->entry_info.tagged_union.foreign_id.id.name) {
!               cp = ae1->entry_info.tagged_union.foreign_id.id.name;
!               ae2->entry_info.tagged_union.foreign_id.id.name =
!                       (idl_char *)rpc_sm_allocate(strlen((char *)cp) + 1, st);
!                 if (*st != error_status_ok)
!                     break;
!               strcpy((char *)ae2->entry_info.tagged_union.foreign_id.id.name,
(char *)cp);
!
!           }
!           else
!               ae2->entry_info.tagged_union.foreign_id.id.name = NULL;
!
!             /* Copy foreign realm */
!           ae2->entry_info.tagged_union.foreign_id.realm.uuid =
!               ae1->entry_info.tagged_union.foreign_id.realm.uuid;
!             /* Copy foreign realm name if not NULL */
!           if (ae1->entry_info.tagged_union.foreign_id.realm.name) {
!               cp = ae1->entry_info.tagged_union.foreign_id.realm.name;
!               ae2->entry_info.tagged_union.foreign_id.realm.name =
!                       (idl_char *)rpc_sm_allocate(strlen((char *)cp) + 1, st);
!                 if (*st != error_status_ok)
!                     break;
!               strcpy((char *)ae2->entry_info.tagged_union.foreign_id.realm.nam
e, (char *)cp);
!           }
!           else
!               ae2->entry_info.tagged_union.foreign_id.realm.name = NULL;
            break;
+       case sec_acl_e_type_extended:
+             if (ae1->entry_info.tagged_union.extended_info) {
+                 idl_size_t ext_len;
+                 sec_acl_extend_info_t *ae2e, *ae1e;
+
+                 ae1e = ae1->entry_info.tagged_union.extended_info;
+                 /* The size should be calculated using:
+                  *      sizeof(sec_acl_extend_info_t) - 1 +
+                  *      ae1e->num_bytes * sizeof(idl_byte)
+                  * The following was chosen to keep consistency with other
+                  * modules of security code that deals with extended_info.
+                  * The approach below could break if strcture field alignment
+                  * or size changes.
+                  */
+                 ext_len = sizeof(uuid_t) + sizeof(ndr_format_t) +
+                           sizeof(unsigned32) +
+                           ae1e->num_bytes * sizeof(idl_byte);
+                 ae2e = ae2->entry_info.tagged_union.extended_info =
+                     (sec_acl_extend_info_t *)rpc_sm_allocate(ext_len, st);
+                 if (*st != error_status_ok)
+                     break;
+                 ae2e->extension_type = ae1e->extension_type;
+                 ae2e->format_label   = ae1e->format_label;
+                 ae2e->num_bytes      = ae1e->num_bytes;
+               memcpy(&(ae2e->pickled_data), &(ae1e->pickled_data),
+                        ae1e->num_bytes);
+             } else
+                 ae2->entry_info.tagged_union.extended_info = NULL;
+           break;
+
        default:
            break;
        }
      }
!
!     /* Free up allocated memory if we encounter failure during copy */
!     if (*st != error_status_ok) {
!         error_status_t dummy_st;
!         dce_acl_obj_free_entries(acl2, &dummy_st);
!     } else
!         acl2->num_entries = acl1->num_entries;
  }

  /* ______________________________________________________________________ */

[7/25/96 public]
Just noticed a minor problem that would have caused memory leak in case of
malloc failure. DIFF:

*** /vob/dce/src/dce/utils/acldb/aclconv.c@@/main/DCE_1.2.2/1   Thu Jul 25 17:27:09 1996
--- /vob/dce/src/dce/utils/acldb/aclconv.c@@/main/DCE_1.2.2/2   Thu Jul 25 17:50:25 1996
***************
*** 8,13 ****
--- 8,17 ----
  /*
   * HISTORY
   * $Log:	c013574,v $
# Revision 1.5  96/07/25  17:52:39  root
# changed fields:  new/changed/deleted note(s) [psn 7/25/96 public]
# 
+  * Revision /main/DCE_1.2.2/2  1996/07/25  21:50 UTC  psn
+  *    One minor fix to fix for OT13574.
+  *    [1996/07/25  21:46 UTC  psn  /main/psn_bugfix/7]
+  * 
   * Revision /main/DCE_1.2.2/1  1996/07/25  21:27 UTC  psn
   *    Rename dce_acl__check_dup_id to dce_acl__check_duplicate.
   *    [1996/07/25  17:34 UTC  psn  /main/psn_bugfix/6]
***************
*** 677,688 ****
        }
      }
  
      /* Free up allocated memory if we encounter failure during copy */
      if (*st != error_status_ok) {
          error_status_t dummy_st;
          dce_acl_obj_free_entries(acl2, &dummy_st);
!     } else 
!         acl2->num_entries = acl1->num_entries;
  }
  
  /* ______________________________________________________________________ */
--- 681,693 ----
        }
      }
  
+     acl2->num_entries = acl1->num_entries;
+ 
      /* Free up allocated memory if we encounter failure during copy */
      if (*st != error_status_ok) {
          error_status_t dummy_st;
          dce_acl_obj_free_entries(acl2, &dummy_st);
!     }
  }
  
  /* ______________________________________________________________________ */



CR Number                     : 13573
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : dce_config
Short Description             : dce_config doesn't install DCE headers
Reported Date                 : 7/19/96
Found in Baseline             : 1.2.2b3
Found Date                    : 7/19/96
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : dce_config
Diff supplied by              : provider
Diff release                  : 1.2.2
Sensitivity                   : public

[7/19/96 public]

Running dce_config from BL3 to install the DCE application develpment
environment doesn't create the /usr/include/dce directory.  The headers
in /usr/include (e.g. xds.h, xom.h) are installed, but none of the headers
that belong in /usr/include/dce.

This was found in an install on a clean machine - one on whicih the directory
/usr/include/dce didn't exist; perhaps the headers would have been installed
if the directory did exist.

No errors were reported by dce_config.

[7/19/96 public]
From my test machine:

(root@ibm_l4) -->ls -l /usr/include | grep dce | pg
lrwxrwxrwx   1 root     system        31 Apr 21 1995  dce -> /opt/dcelocal/share/include/dce

from dce_config:
        # Now create the link for /usr/include/dce/
        # Be nice and make sure they don't already have a directory
        issymlink /usr/include/dce
        temp=$?
        if [ $? -eq 2 ]         # does not exists
        then
                ln -s $DCELOCAL/share/include/dce /usr/include/dce
        elif [ $temp -eq 1 ]    # exists and not a symlink
        then
            echo "\t/usr/include/dce on your Operating System already exists"
            echo "\tIf desired, replace it with a symbolic link to $DCELOCAL/sha
re/include/dce"
        fi
        # else do nothing if its a symlink

Shouldn't this be cancelled?

did you do 'cd <dce_install_tree>/etc; ./dce_config -i?

[7/19/96 public]
Sorry I was too hasty, it is a bug and here is the fix:
*** /vob/dce/src/config/dce_config@@/main/DCE_1.2.2/psn_bugfix/0        Fri Jul 19 15:44:36 1996
--- /vob/dce/src/config/dce_config      Fri Jul 19 15:47:19 1996
***************
*** 3500,3506 ****
        # Be nice and make sure they don't already have a directory
        issymlink /usr/include/dce
        temp=$?
!       if [ $? -eq 2 ]         # does not exists
        then
                ln -s $DCELOCAL/share/include/dce /usr/include/dce
        elif [ $temp -eq 1 ]    # exists and not a symlink
--- 3500,3506 ----
        # Be nice and make sure they don't already have a directory
        issymlink /usr/include/dce
        temp=$?
!       if [ $temp -eq 2 ]              # does not exists
        then
                ln -s $DCELOCAL/share/include/dce /usr/include/dce
        elif [ $temp -eq 1 ]    # exists and not a symlink



CR Number                     : 13564
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_login_pvt_synch_refresh_context()
Short Description             : Memory leak in sec_login_pvt_synch_refresh_context()
Reported Date                 : 7/9/96
Found in Baseline             : 1.2.1
Found Date                    : 7/9/96
Severity                      : C
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : src/security/client/login/sec_login_pvt.c
Diff supplied by              : provider
Diff release                  : 1.2.1
Sensitivity                   : public

[7/9/96 public]

Will be dropped in next DCE 1.2.2 baselevel.

Memory leak when refreshing credentials. dced is leaking memory. Each 
context refresh in the key management thread leaks approx. 1000 bytes.

In sec_login_pvt_synch_refresh_context(), free the TGT data in the
caller's login context before filling in the refreshed data.

(line numbers may be off)

***************
*** 4787,4792 ****
--- 4790,4804 ----
                  1, &db_entry, stp);
      if (dfn)
          free(dfn);
      if (BAD_STATUS(stp)) {
          return;
      }
+ 
+     /* 
+      * Free the TGT data in the login context before we stomp it with 
+      * the contents of the refresh context.
+      */
+     free_krb_request_info(&KRB_REQUEST_INFO(lcp));



CR Number                     : 13563
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : secval pesite update thread
Short Description             : dced dumps core attempting to update the pesite file
Reported Date                 : 7/9/96
Found in Baseline             : 1.2.1
Found Date                    : 7/9/96
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : admin/dced/server/pe_update.c
Diff supplied by              : provider
Diff release                  : 1.2.1
Sensitivity                   : public

[7/9/96 public]

dced dumps core attempting to update the pesite file and the file open fails.
In addition, several minor changes to make function names static.
Will be dropped in next DCE 1.2.2 baselevel.

*** pe_update.c@@/main/3        Tue Apr  2 19:39:06 1996
- --- pe_update.c       Tue Jun 25 16:45:58 1996
***************
*** 104,110 ****
  /*
   * Retrieve a copy of the replica list
   */
! error_status_t scd_refresh_replist(ctx, context)
      struct pe_update_context *ctx;
      sec_rgy_handle_t  context;
  {
- --- 120,126 ----
  /*
   * Retrieve a copy of the replica list
   */
! static error_status_t scd_refresh_replist(ctx, context)
      struct pe_update_context *ctx;
      sec_rgy_handle_t  context;
  {
***************
*** 185,191 ****
      return pb->weight - pa->weight;
  }
  
! error_status_t scd_sort_pesite(struct pe_update_context *ctx) 
  {
      int npslines = ctx->npslines;
      int i, j;
- --- 201,207 ----
      return pb->weight - pa->weight;
  }
  
! static error_status_t scd_sort_pesite(struct pe_update_context *ctx) 
  {
      int npslines = ctx->npslines;
      int i, j;
***************
*** 223,242 ****
      return error_status_ok;
  }
  
! error_status_t scd_print_pesite(struct pe_update_context *ctx, char *file)
  {
      int i;
      int npslines = ctx->npslines;
!     FILE *outfile, *infile;
      char *outfilename = malloc (strlen(file)+5);
      char buf[1024];
      int ret;
!     
      int cellnamelen = strlen ((const char *)ctx->real_cellname);
      strcpy(outfilename, file);
      strcat(outfilename, ".new");
  
      outfile = fopen(outfilename, "w");
          
      for (i=0; i < npslines; i++) 
      {
- --- 239,265 ----
      return error_status_ok;
  }
  
! static error_status_t scd_print_pesite(struct pe_update_context *ctx, char 
*file)
  {
      int i;
      int npslines = ctx->npslines;
!     FILE *outfile = NULL, *infile;
      char *outfilename = malloc (strlen(file)+5);
      char buf[1024];
      int ret;
!     error_status_t st = -1;
! 
      int cellnamelen = strlen ((const char *)ctx->real_cellname);
+ 
+     if (outfilename == NULL)
+       goto bail;
+ 
      strcpy(outfilename, file);
      strcat(outfilename, ".new");
  
      outfile = fopen(outfilename, "w");
+     if (outfile == NULL)
+         goto bail;
          
      for (i=0; i < npslines; i++) 
      {
***************
*** 267,280 ****
        return errno;
      else 
        return error_status_ok;
!   bail:
!     (void)fclose(outfile);
!     (void)unlink(outfilename);
!     free(outfilename);
!     return -1;                        /* !!! need stcode */
  }
  
! char *ipstr_to_hostname(unsigned char *addr)
  {
  #if 0
      struct hostent h;
- --- 290,308 ----
        return errno;
      else 
        return error_status_ok;
! 
! bail:
!     if (outfile) {
!         (void)fclose(outfile);
!     }
!     if (outfilename) {
!         (void)unlink(outfilename);
!         free(outfilename);
!     }
!     return st;
  }
  
! static char *ipstr_to_hostname(unsigned char *addr)
  {
  #if 0
      struct hostent h;
***************
*** 302,312 ****
  
  /* Update krb.conf file in place */
  
! error_status_t scd_print_krb_conf(struct pe_update_context *ctx, char *file)
  {
      int i;
      int npslines = ctx->npslines;
!     FILE *outfile, *infile;
      char *outfilename = malloc (strlen(file)+5);
      char buf[1024];
      int ret;
- --- 330,340 ----
  
  /* Update krb.conf file in place */
  
! static error_status_t scd_print_krb_conf(struct pe_update_context *ctx, char 
*file)
  {
      int i;
      int npslines = ctx->npslines;
!     FILE *outfile = NULL, *infile;
      char *outfilename = malloc (strlen(file)+5);
      char buf[1024];
      int ret;
***************
*** 313,323 ****
      extern char *sec_krb_realm_from_dce_cell();
      char *realmname = sec_krb_realm_from_dce_cell(ctx->real_cellname);
      int realmnamelen = strlen(realmname);
!       
      strcpy(outfilename, file);
      strcat(outfilename, ".new");
  
      outfile = fopen(outfilename, "w");
          
      if (infile = fopen(file, "r")) 
      {
- --- 341,356 ----
      extern char *sec_krb_realm_from_dce_cell();
      char *realmname = sec_krb_realm_from_dce_cell(ctx->real_cellname);
      int realmnamelen = strlen(realmname);
! 
!     if (outfilename == NULL)
!       goto bail;
! 
      strcpy(outfilename, file);
      strcat(outfilename, ".new");
  
      outfile = fopen(outfilename, "w");
+     if (outfile == NULL)
+         goto bail;
          
      if (infile = fopen(file, "r")) 
      {
***************
*** 352,368 ****
        return errno;
      else 
        return error_status_ok;
!   bail:
!     (void)fclose(outfile);
!     (void)unlink(outfilename);
!     free(outfilename);
!     return -1;                        /* !!! need stcode */
  }
  
  /* bias against selecting master; perhaps should be comparable to
   * weight against selecting node on different subnet..
   */
! int master_badness = 0;
  
  static int compute_replica_weight (rs_replica_item_t *repitem) 
  {
- --- 385,406 ----
        return errno;
      else 
        return error_status_ok;
! 
! bail:
!     if (outfile) {
!         (void)fclose(outfile);
!     }
!     if (outfilename) {
!         (void)unlink(outfilename);
!         free(outfilename);
!     }
!     return -1;                  /* !!! need stcode */
  }
  
  /* bias against selecting master; perhaps should be comparable to
   * weight against selecting node on different subnet..
   */
! static int master_badness = 0;
  
  static int compute_replica_weight (rs_replica_item_t *repitem) 
  {
***************
*** 414,420 ****
      return weight;
  }
  
! error_status_t scd_convert_replist(struct pe_update_context *ctx) 
  {
      int i, psl;
      ctx->npslines = 0;
- --- 452,458 ----
      return weight;
  }
  
! static error_status_t scd_convert_replist(struct pe_update_context *ctx) 
  {
      int i, psl;
      ctx->npslines = 0;
***************
*** 508,514 ****
      return error_status_ok;
  }
  
! void free_ctx_contents(struct pe_update_context *ctx)
  {
      error_status_t st;
      int i, j;
- --- 546,552 ----
      return error_status_ok;
  }
  
! static void free_ctx_contents(struct pe_update_context *ctx)
  {
      error_status_t st;
      int i, j;
***************
*** 576,581 ****
- --- 614,620 ----
      sec_rgy_cell_bind (ctx->real_cellname, &auth_info, &context, &st);
      if (st != error_status_ok) 
      {
+       free_ctx_contents(ctx);
        return st;
      }
      st = scd_refresh_replist(ctx, context);



CR Number                     : 13533
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : 
Short Description             : dced memory leaks
Reported Date                 : 6/20/96
Found in Baseline             : 1.1
Found Date                    : 6/20/96
Severity                      : C
Priority                      : 3
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.2, 1.1maint
Affected File(s)              : acls.c oeops.c hdmisc.c
Diff supplied by              : provider
Diff release                  : 1.2.2
Sensitivity                   : public

[6/20/96 public]

dced leaks memory in the following two places:  acls.c - acl_patcher
calls rpc_ss_enable_allocate, but never calls rpc_ss_disable_allocate.

Change: admin/dced/server/acls.c from 12.3 to 12.5
*** admin/dced/server/acls.c
***************
*** 956,959 ****
--- 962,966 ----
      if (st2 != error_status_ok)
        dce_svc_printf(DCED_S_UNLOCK_FAIL_MSG, "acl_lock", "acl_patcher", (long)st2);
      free(patches);
+     rpc_ss_disable_allocate();
  }



And oeops.c leaks in epdb_database_read - the space allocated for the 
temporary variable ent should be free'd upon each iteration of the for
loop.

Change: admin/dced/server/oeops.c from 12.8 to 12.9
*** admin/dced/server/oeops.c
***************
*** 374,379 ****
--- 381,387 ----
      if (*st != error_status_ok)
        return;
      for ( ; ; ) {
+       error_status_t alloc_st;
          dce_db_iter_next_by_uuid(h->db, &u, st);
          if (*st == db_s_no_more)
            break;
***************
*** 383,392 ****
            dce_db_status_to_ept_status(st);
            return;
        }
!       if (ent.flags & db_entry_c_deleted)
            continue;
!       if (ent.flags & db_entry_c_local)
            continue;
  
        if ((new = malloc(sizeof *new)) == NULL) {
            *st = ept_s_cant_perform_op;
--- 391,404 ----
            dce_db_status_to_ept_status(st);
            return;
        }
!       if (ent.flags & db_entry_c_deleted) {
!           rpc_sm_free(&ent, &alloc_st);
            continue;
!       }
!       if (ent.flags & db_entry_c_local) {
!           rpc_sm_free(&ent, &alloc_st);
            continue;
+       }
  
        if ((new = malloc(sizeof *new)) == NULL) {
            *st = ept_s_cant_perform_op;
***************
*** 403,408 ****
--- 415,421 ----
        new->readers = 0;
        new->comm_failures = 0;
        dblist_add(&h->lists_mgmt, new);
+       rpc_sm_free(&ent, &alloc_st);
      }
      dce_db_iter_done(h->db, st);
      dce_db_status_to_ept_status(st);

[7/1/96 public]

The above fix for epdb_database_read is incorrect.  The fix should
use rpc_ss_enable/disable_allocate().  The delta for this approach is:

***************
*** 347,355 ****
      if (*st != error_status_ok)
        return;
  
      dce_db_iter_start(h->db, st);
!     if (*st != error_status_ok)
        return;
      for ( ; ; ) {
          dce_db_iter_next_by_uuid(h->db, &u, st);
          if (*st == db_s_no_more)
--- 412,423 ----
      if (*st != error_status_ok)
        return;
  
+     rpc_ss_enable_allocate();
      dce_db_iter_start(h->db, st);
!     if (*st != error_status_ok) {
!       rpc_ss_disable_allocate();
        return;
+     }
      for ( ; ; ) {
          dce_db_iter_next_by_uuid(h->db, &u, st);
          if (*st == db_s_no_more)
***************
*** 358,372 ****
        dce_db_fetch_by_uuid(h->db, u, &ent, st);
        if (*st != error_status_ok) {
            dce_db_status_to_ept_status(st);
            return;
        }
!       if (ent.flags & db_entry_c_deleted)
            continue;
!       if (ent.flags & db_entry_c_local)
            continue;
  
        if ((new = malloc(sizeof *new)) == NULL) {
            *st = ept_s_cant_perform_op;
            return;
        }
        *new = ent;
--- 426,444 ----
        dce_db_fetch_by_uuid(h->db, u, &ent, st);
        if (*st != error_status_ok) {
            dce_db_status_to_ept_status(st);
+           rpc_ss_disable_allocate();
            return;
        }
!       if (ent.flags & db_entry_c_deleted) {
            continue;
!       }
!       if (ent.flags & db_entry_c_local) {
            continue;
+       }
  
        if ((new = malloc(sizeof *new)) == NULL) {
            *st = ept_s_cant_perform_op;
+           rpc_ss_disable_allocate();
            return;
        }
        *new = ent;
***************
*** 375,380 ****
--- 447,453 ----
        tower_to_addr(new->tower, &new->addr, st);
        if (*st != error_status_ok) {
            *st = ept_s_invalid_entry;
+           rpc_ss_disable_allocate();
            return;
        }
        new->readers = 0;

***************
*** 383,598 ****
      }
      dce_db_iter_done(h->db, st);
      dce_db_status_to_ept_status(st);
  }
  
  void
  epdb_write_entry(
--- 456,631 ----
      }
      dce_db_iter_done(h->db, st);
      dce_db_status_to_ept_status(st);
+     rpc_ss_disable_allocate();
+     return;
  }
  
  void
  epdb_write_entry(

[7/9/96 public]
Merged into the 1.2.2 baseline. Note that a similar problem was fixed in
hdmisc.c. Diffs follow.

*** hdmisc.c@@/main/HPDCE02/jrr_patch_1/0       Tue Jul  2 10:33:12 1996
--- hdmisc.c    Tue Jul  2 10:34:38 1996
***************
*** 96,104 ****
--- 96,107 ----
        postprocs.count = postprocs.size = 0;
      }
  
+     rpc_ss_enable_allocate();
+ 
      dce_db_fetch_by_uuid(hd_db, &dced_g_uuid_hostdata_post_proc, &id_d,
st);
      if (*st == db_s_key_not_found) {
        *st = dced_s_no_postprocessors;
+         rpc_ss_disable_allocate();
        return;
      }
      CHECK_STAT_RET(*st);
***************
*** 106,113 ****
--- 109,119 ----
      if ((F = fopen((char *)id_d.data.storage_tag, "r")) == NULL) {
        if (errno != ENOENT)
            *st = dced_s_postprocessor_file_fail;
+         rpc_ss_disable_allocate();
        return;
      }
+ 
+     rpc_ss_disable_allocate();
  
      /* Allocate space for an initial array */
      postprocs.size = 20;



CR Number                     : 13479
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : keymgmt
Short Description             : races to create keytab before principal exists on read-only replica
Reported Date                 : 5/23/96
Found in Baseline             : 1.1
Found Date                    : 5/23/96
Severity                      : B
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : security/client/key_mgmt/keymgmt.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[5/23/96 public]

There is window in which account can not be seen on the readonly.
Adding keys to the local keytab file will fail in this window because
sec_key_mgmt_get_next_kvno() works with the default registry.

Fix:

File: security/client/key_mgmt/keymgmt.c
*** 12.2        1994/12/05 19:46:39
--- 12.3        1995/07/12 20:02:39
***************
*** 2,7 ****
--- 2,17 ----
   * @TRANSARC_COPYRIGHT@
   *
   * $TALog: keymgmt.c,v $
+  * Revision 12.3  1995/07/12  20:02:39  aswini
+  * Bug: There is window in which account can not be seen on the readonly.
+  * Adding keys to the local keytab file will fail in this window because
+  * sec_key_mgmt_get_next_kvno() works with the default registry.
+  * Fix: If the account lookup fails in the default registry retry the lookup
+  * in the master registry.
+  *
+  * See above.
+  * [from r12.2 by delta aswini-15858-sec-client-keymgmt-kta-local-try-master-if-default-fails, r1.1]
+  *
   * Revision 12.2  1994/12/05  19:46:39  aswini
   * [merge of changes from 11.1 to 11.2 into 12.1]
   *
***************
*** 11,17 ****
   */
  
  #if !defined(_NOIDENT) && !defined(lint)
! static char *TARCSId = "$Id: c013479,v 1.2 96/05/23 18:02:03 root Exp $
";
  #endif
  
  /*
--- 21,27 ----
   */
  
  #if !defined(_NOIDENT) && !defined(lint)
! static char *TARCSId = "$Id: c013479,v 1.2 96/05/23 18:02:03 root Exp $
";
  #endif
  
  /*
***************
*** 671,676 ****
--- 681,697 ----
      sec_rgy_cursor_reset(&cursor);
      sec_rgy_acct_lookup(rgy_h, &name_in, &cursor, &name_out, NULL, NULL,
                               NULL, &user_part, NULL, err);
+     if(BAD_STATUS(err) && (*err == sec_rgy_object_not_found)) {
+         sec_rgy_site_close(rgy_h, &lerr);
+         sec_key_mgmt__bind_rgy(principal_name, auth_type, lc,
+                                name_in.pname, NULL, true, &rgy_h, err);
+         if (BAD_STATUS(err)) {
+             return;
+         }
+         sec_rgy_cursor_reset(&cursor);
+         sec_rgy_acct_lookup(rgy_h, &name_in, &cursor, &name_out, NULL, NULL,
+                                  NULL, &user_part, NULL, err);
+     }
      sec_rgy_site_close(rgy_h, &lerr);
  
      if (GOOD_STATUS(err)) {

[5/23/96 public]
Was differently fixed in 1.2.1.



CR Number                     : 13472
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : sec_rgy_attr_update() causes
leak in secd
Reported Date                 : 5/13/96
Found in Baseline             : 1.1
Found Date                    : 5/13/96
Severity                      : C
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : security/server/rsdb/balanced_trees.c
Sensitivity                   : public

[5/13/96 public]

Running a testcase that repeatedly makes calls to sec_rgy_attr_update()
attempting to update the same attribute with the same value will cause the
security daemon to grow without bound.  The server end of
sec_rgy_attr_update(), (rsdb_attr_update()) in secd makes no attempt to update
pre-existing attributes, instead it deletes the previous attribute and creates
a new one ... which would cause secd memory to grow indefinitely.

It appears as thought OSF's design for rsdb_attr_update() was intended to be
used only as a very simplistic write-once/read-many semantic, not as a
write-many/read-many semantic as the customer requires.

Unfortunately the testcase supplied by the customer is non-trivial enough to
not include it in this OT but I will be glad to supply what I have with
whomever ends up working this problem.

PauL
phighley@austin.ibm.com

[5/15/96 public]
This is not an attribute specific problem.  All of secd (since the beginning
of time, or at least DCE1.0) has had the limitation that if something was
replaced or deleted, the memory was kept around (someone had intended on
finishing the reuse feature at some point).  As of DCE1.2.1, secd now correctly
malloc()s and free()s memory as it's needed, which should fix the above problem.
As such, I'm marking the above as 'fix'ed in 1.2.1.  Try it, I'm sure you'll
like it a *lot* better than the 1.1 secd.



CR Number                     : 13439
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_salvage_db
Short Description             : sec_salvage_dp -print failure
if 10+ attributes
Reported Date                 : 4/19/96
Found in Baseline             : 1.1
Found Date                    : 4/19/96
Severity                      : A
Priority                      : 3
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : sec_svg_prt.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/19/96 public]

Running sec_salvage_db with the -print option will fail if there
are more than 10 attribute instances attached to a principal.
To verify this, try doing a "sec_salvage_db -print" after you've
run the test/functional/security/ts/client/rca/sec_rgy_attr test.
This test creates 11 attribute instances for "root".

The reason for this failure is that the pgo extraction logic in
print_pgo does a single rsdb fetch into an arry of type
rsdb_max_attr_list_t, which only holds 10 attribute instances.  
Either there's an easy way to get print_pgo to fetch the remaining 
attribute instances, or the logic will have to be reworked somehow.  
I don't think you want to bump up RSDB_MAX_ATTR_LIST_SIZE to be 
arbitrarily large, but this would fix it.

You might want to check around and see if there are other places
rsdb_max_attr_list_t is used incorrectly and where the code needs to
be able to handle more than 10 entries.

[6/18/96 public]
Fixed in 1.2.2 for next drop to OSF.



CR Number                     : 13416
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : rs_attr_lookup_by_id fails to return list of accessible attributes
Reported Date                 : 3/29/96
Found in Baseline             : 1.1
Found Date                    : 3/29/96
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : src/security/server/rs/rs_attr.c
Diff supplied by              : provider
Diff release                  : 1.2.2
Sensitivity                   : public

[3/29/96 public]

In the documentation for sec_rgy_attr_lookup_by_id() there is a claim that
when especifying the argument for num_attrs=0 the api would return a list
of all the attributes to which the user has "access".  This is not the 
case.  The code actually gets a list of all the attributes on the object
and then proceeds to check the authorization of the caller against each.
If any of these checks fails, the api returns an error code of "not
authorized".  The expected behavior would be that the code would skip
the attribute that inhibits access and continue to check the next attribute.

This checks occur at the rs_attr_lookup_by_id() and rs_attr_lookup_no_expand().

[4/1/96 public]


Following is a possible solution to this problem. 
I have tested this successfully, and it fixes the problem described in this OT.
I have used the sch_list->entries[j].flags.deleted  as a marker for unauthorized
schemas.   The only concern I have is that this use of this flag would not
conflict with the designed use for it.

In rs_attr_lookup_by_id() and rs_attr_lookup_no_expand() (rs_attr.c) I did
the following:

                                   *
                                   *
                                   *
        /* Check if caller is authorized for queries of each attr type */
        for(i = 0; STATUS_OK(st_p) && i < sch_list->count; i++) {
            rs_attr_util_get_permset(&rgy_obj_info,
                &(sch_list->entries[i].sch_entry),
                rs_attr_op_query, &requested_perms, st_p);
            if(STATUS_OK(st_p)) {
                rs_attr_util_is_auth(h, &rgy_obj_info,
                    requested_perms, component_name, st_p);
            }
#if defined(IBMOS2) || defined(AIX_PROD)        /*  CMVC 21266  */       

           if ( *st_p == sec_attr_unauthorized )                         <
           {                                                       <
              sch_list->entries[i].flags.deleted = 1;               <
              CLEAR_STATUS(st_p);                                    <
           }                                                       <
#endif                                       /*  CMVC 21266  */
        }

        if(STATUS_OK(st_p)) {
            rsdb_attr_lookup_by_uuid(&rgy_obj_info, cursor,
                space_avail, sch_list,
                rpc_ss_allocate, num_returned, attrs,
                num_left, st_p);
        }

                                 *
                                 *

                                 *



In rsdb_attr_llokup_by_uuid() (rsdb_attr.c) I did the following:


                                 *
                                 *
                                 *
                                 *

    while (cursor->list != END_OF_LIST) {
        if(!(rsdb_attr_list_get_by_id(cursor->list, &list))) {
            dce_svc_printf(SEC_ATTR_CANT_GET_ATTRLIST_MSG);
        }
        for(i = cursor->entry; i < list.total_count; i++) {
            if(*num_returned < space_avail) {
                if(!list.attr[i].inst_id.deleted) {
                    for(j = 0; j < sch_list->count; j++) {
#if defined(IBMOS2) || defined(AIX_PROD)        /*  CMVC 21266  */
                       if((list.attr[i].type_id == sch_list->entries[j].sch_entry_id)  <
                           && (sch_list->entries[j].flags.deleted != 1)) {             <

#else
                       if(list.attr[i].type_id ==                          <   OLD CODE
                            sch_list->entries[j].sch_entry_id) {           <
#endif                                       /*  CMVC 21266  */

                            attr_inst_id = list.attr[i].inst_id.id;
                            rsdb_attr_get_by_id_and_export(attr_inst_id,
                                allocator, &attrs[*num_returned], st_p);
                            if(BAD_STATUS(st_p)) {
                                dce_svc_printf(DCE_SVC(sec_svc_handle, ""),
                                           sec_s_rs_rsdb,
                                           svc_c_sev_fatal | svc_c_action_abort,
                                           *st_p);
                            }
                                 *
                                 *

                                 *
                                 *
                                 *



Actually, I just looked at the code of other similar functions, and I 
discovered that rpriv_attr_get_effective() and rsdb_attr_get_effective()
work similarly to the code described above.  Therefore, I assume I have not
been doing a terrible hack.

[4/3/96 public]


While trying to fix this problem in our code,  I came into a problem
with the setting of the return status when processing a partially or
fully unauthorized attribute schema list.

The behavior that we would propose is that the error status be set to
"unauthorized" only if all of the schemas in the list denied access.  If
the returned attribute list is partial, a status OK would be returned.
It would be up to the caller to verify that he got the list that he
requested.

Please attach to this OT what would be HP's approach.  Thanks.

[4/24/96 public]
I spoke to Anne Hopkins regarding this issue. The lookup routines should
always return success in this case. Even if the number of entries that the
caller is authorized to lookup is zero.

[7/25/96 public]
Merged fix to DCE 1.2.2 code. Will be part of next drop. DIFFs:

*** /vob/dce/src/security/server/rs/rs_attr.c@@/main/DCE_1.2.2/1        Thu Jul
18 13:34:27 1996
--- /vob/dce/src/security/server/rs/rs_attr.c@@/main/DCE_1.2.2/2        Thu Jul
25 15:09:01 1996
***************
*** 8,13 ****
--- 8,20 ----
  /*
   * HISTORY
   * $Log:	c013416,v $
# Revision 1.5  96/07/25  15:16:34  root
# changed fields: Status  Fixed In Baseline  Diff supplied by  Diff release  Responsible Engr.  Resp. Engrs Company   new/changed/deleted note(s) [psn 7/25/96 public]
# 
+  * Revision /main/DCE_1.2.2/2  1996/07/25  19:09 UTC  psn
+  *    Modify rs_attr_lookup_by_id() and rs_attr_lookup_no_expand() to
+  *    return all entries that the caller is authorized to get. Do not
+  *    fail if entries are found that the caller is not auth'ed to get.
+  *    Return success even if 0 entries are returned.
+  *    [1996/05/17  17:36 UTC  jrr  /main/HPDCE02/jrr_davis_3/1]
+  *
   * Revision /main/DCE_1.2.2/1  1996/07/18  17:34 UTC  aha
   *    Merge Registry support for KDC private key storage
   *
***************
*** 255,261 ****
                rs_attr_util_is_auth(h, &rgy_obj_info,
                    requested_perms, component_name, st_p);
            }
!       }
        if(STATUS_OK(st_p)) {
            rsdb_attr_lookup_by_uuid(&rgy_obj_info, cursor,
                space_avail, sch_list,
--- 262,278 ----
                rs_attr_util_is_auth(h, &rgy_obj_info,
                    requested_perms, component_name, st_p);
            }
!
!             /*
!              * If the caller is not authorized to lookup this entry,
!              * just mark it as deleted and clear the status.
!              */
!             if (*st_p == sec_attr_unauthorized ) {
!                 sch_list->entries[i].flags.deleted = 1;
!                 CLEAR_STATUS(st_p);
!             }

!         }
!
        if(STATUS_OK(st_p)) {
            rsdb_attr_lookup_by_uuid(&rgy_obj_info, cursor,
                space_avail, sch_list,
***************
*** 385,391 ****
                rs_attr_util_is_auth(h, &rgy_obj_info,
                    requested_perms, component_name, st_p);
            }
!       }
        if(STATUS_OK(st_p)) {
            rsdb_attr_lookup_by_uuid(&rgy_obj_info, cursor,
                space_avail, sch_list,
--- 402,418 ----
                rs_attr_util_is_auth(h, &rgy_obj_info,
                    requested_perms, component_name, st_p);
            }
!
!             /*
!              * If the caller is not authorized to lookup this entry,
!              * just mark it as deleted and clear the status.
!              */
!             if (*st_p == sec_attr_unauthorized ) {
!                 sch_list->entries[i].flags.deleted = 1;
!                 CLEAR_STATUS(st_p);
!             }
!         }
!
        if(STATUS_OK(st_p)) {
            rsdb_attr_lookup_by_uuid(&rgy_obj_info, cursor,
                space_avail, sch_list,



CR Number                     : 13319
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : 
Short Description             : diffs: secd failure caused by
sec_rgy_attr_sch test
Reported Date                 : 2/15/96
Found in Baseline             : 1.1
Found Date                    : 2/15/96
Severity                      : A
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2, 1.1maint
Fixed In Baseline             : 1.2.2
Affected File(s)              : rs_log_attr_schema.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/15/96 public]

There are a couple fixes in rs_log_attr_schema.c that I would
like HP to place in 1.2.1.  The alloc_attr_sch_update fix keeps secd
from crashing during the sec_rgy_attr_sch test, so I'm filing this OT 
as an A1.

First, in alloc_attr_sch_update, sch_entry_len should be declared as
an unsigned32, because it gets passed to rsdb_attr_calc_size in
an unsigned32 argument.  The declaration of sch_entry_len in
alloc_attr_sch_create was recently modified to be an unsigned32.  
This change can be applied to the declaration in alloc_attr_sch_update 
as well.

Second, in  rs_log_attr_sch_prop_update(), the stack declaration of
"schema" should be initialized, as in:

    rs_prop_attr_sch_update_data_t  schema = {0};

[2/16/96 public]
Too late, 1.2.1 is already frozen and out of our hands.  It's in
the end game stage, so we can't drop this in.  Feel free to include
it in your product version of 1.2.1 after verifying that the fix is
correct (I can't do that today).  Changed the platform to 'other' from
all, since this can't have been seen on HPUX or AIX (secd crashing) or
1.2.1 wouldn't have frozen.

[2/19/96 public]
Okay, sorry I missed the deadline.  Just so we don't loose these
fixes, I'm appending a diff of my changes against the 1.2.1 
rs_log_attr_schema.c.  Also,  John Wray at Digital advised me to
modify the description field with the word "diffs:", because
later this will be used as a key word to facilitate automatic extraction
of patches.  Or something like that.

diff new old ---

192c192
<     unsigned32          sch_entry_len, total_size;
---
>     long                sch_entry_len, total_size;
569c569
<     rs_prop_attr_sch_update_data_t  schema = {0};
---
>     rs_prop_attr_sch_update_data_t  schema;

[6/18/96 public]
Fixed in 1.2.2 for next drop to OSF.

[10/1/96 public]
Fixed in 1.1 maintenance tree.



CR Number                     : 13314
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_login
Short Description             : need status code for uid/gid overflow
Reported Date                 : 2/8/96
Found in Baseline             : 1.1
Found Date                    : 2/8/96
Severity                      : C
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.2
Affected File(s)              : security/idl/sec.sams
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : open

[2/8/96 public]
Given that the uid_t and gid_t types in the system-dependent struct
passwd may be different sizes on different systems, it may be possible
for the OS-dependent functions
sec_login_pvt_get_local_login_info() and/or sec_login_np_lc_to_pwent()
to truncate a uid or gid when inserting it into the struct passwd.
This should be detected, and an error status code should be returned.
I was unable to find an appropriate status code for this situation
in the existing code; I would like to propose that a status code be
created for this purpose, so that sec_login_get_pwent() would return
with this status set if that call would result in a passwd structure
with a truncated uid/gid.
Without this code, it is possible for a client program to detect overflow
by using the sec_rgy_acct_lookup() function and comparing the uid/gid
returned there to the one returned by sec_login_get_pwent(), but if
the uid/gid in login context was affected by overrides (obtained via
sec_login_valid_and_cert_ident(), for example), they will differ even
in the absence of an overflow condition.
A kludgy workaround is possible, by having the client program use the
override interface to detect an overridden uid/gid, but it seems that
a better solution (reporting the overflow when it happens) would be
preferable.
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `open'

[6/7/96 public]
New error code (sec_login_s_unix_id_overflow) supplied in latest 1.2.2 drop
(2nd drop to OSF), so this is marked fix.  I don't believe overflow of UIDs
is a problem on AIX, so I won't open a separate bug for that, but could you
send me the context of where/when you're using this new error code, so that
we can apply it to platform(s) that do have this problem if/when we run into
them?



CR Number                     : 13295
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : gssapi
Short Description             : DIFF : Memory-leak in gssapi key-schedule calculation
Reported Date                 : 2/1/96
Found in Baseline             : 1.1, 1.2.1
Found Date                    : 2/1/96
Severity                      : C
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : gssapi-supp.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/1/96 public]

There is a small memory leak in GSSAPI, in the area where a DES key-schedule is
calculated for integrity protection.  Two distinct key-schedules are
used, one for privacy and one for integrity, and both are supposed to be 
created the first time they're needed.

In the current 1.1 & 1.2.1 codebases, however, the integrity key-schedule is
re-created every time it's needed, wasting time and leaking memory.

The fix is in file security/gssapi/gssapi-supp.c, routine
gss__fixup_safe_key_info.  The 10th line of this routine that reads:

      if (ctx_ptr->priv_key_schedule != NULL) return 0;

should read:

      if (ctx_ptr->safe_key_schedule != NULL) return 0;

The comment immediately preceeding this line should also be changed to
refer to the safe_session_key rather than the priv_session_key.

[6/18/96 public]
Fixed in 1.2.2 for next drop to OSF.



CR Number                     : 13291
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : dcecp
Short Description             : dcecp host unconfigure broken with CDS replicas
Reported Date                 : 1/26/96
Found in Baseline             : 1.1
Found Date                    : 1/26/96
Severity                      : C
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2
Affected File(s)              : unknown
Sensitivity                   : public

[1/26/96 public]

A customer has replicated his /.:/hosts directory to a secondary
clearing house and then tries to use the dcecp host unconfigure
command to delete the host.  This fails due to the replica of 
the /.:/hosts/hostname directory.  Here is the text from the
customer problem.

The customer uses the dcecp host unconfigure command to
unconfigure various nodes in his OSF DCE 1.1 cell.  This
cell includes HP's, Sun's and IBM boxes.  If the host's
host directory (e.g. /.:/hosts/<machine-name>) directory
is replicated beyond the initial CDS server, the
unconfigure will fail.  It is necessary to first remove
the replicas and then unconfigure.  In an environment
with multiple CDS servers and extensive replication, this
is a hassle.  This problem is exhibited on each of the
platforms that Mehrdad is using.  He is opening a PMR
with each vendor.



CR Number                     : 13290
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 13220
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : gssapi
Short Description             : better export version
Reported Date                 : 1/24/96
Found in Baseline             : 1.1
Found Date                    : 1/24/96
Severity                      : A
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1,1.1maint
Affected File(s)              : security/gssapi/gssapi.c
Sensitivity                   : public

[1/24/96 public]

If NOENCRYPTION is enabled, GSSAPI "turns off" the encryption flag
so that the privacy routine is not called.  It might be better if
#ifdef were used to disable the call altogether.  The DCE 1.2 code
does this; we should backport to DCE 1.1.

[1/25/96 public]
Marked fixed in 1.2.1, filled in file field.
Diff the 1.2.1 version against the 1.1maint version to see what additional
changes you need for this to patch 1.1.

[01/25/96 public]
Good idea.  It was a pain doing the diff since lots of unrelated
things changed between 1.1 and 1.2 (eg all serviceability messaging
is different) but I believe I got it right.  I did a diff between
1.1 and 1.2, found the additional NOENCRYPTION checks and applied them
to the 1.1 source.  The following is a diff between my fixed version
and the current 1.1.  This diff should go into 1.1-maint.
Also this is really an enhancement, so I marked it as such.

*** gssapi.c.OLD	Wed Oct  5 17:47:42 1994
--- gssapi.c.FIX	Thu Jan 25 11:03:47 1996
***************
*** 7194,7199 ****
--- 7194,7200 ----
      case TOK_ID_DELETE:
  	break;
      case TOK_ID_SEAL:
+ #ifndef NOENCRYPTION
  	if (seal_alg_type == SEAL_ALG_DES) {
  /* Encrypt data field in-place.						    */
  
***************
*** 7213,7218 ****
--- 7214,7220 ----
  		(unsigned char *)internal_buffer.value + data_start);
  							/* Output in place  */
  	};
+ #endif
  	break;
      };
  
***************
*** 8457,8465 ****
--- 8459,8471 ----
  	};
      };
  
+ #ifndef NOENCRYPTION
      if (seal_alg_type == SEAL_ALG_DES) {
  
  
+        if (conf_state) *conf_state = 1;
+ 
+ 
  /* Decrypt confounder, followed by data.				    */
  	gss_decrypt_DES_CBC(
  	    zero_block,		    /* IV				    */
***************
*** 8532,8538 ****
  #	endif
  */
  
!     } else if (seal_alg_type == SEAL_ALG_NONE) {
  	memcpy(confounder,
  	       (unsigned char *)token_buffer->value + data_offset,
  	       8);
--- 8538,8546 ----
  #	endif
  */
  
!     }
! #endif
!     else if (seal_alg_type == SEAL_ALG_NONE) {
  	memcpy(confounder,
  	       (unsigned char *)token_buffer->value + data_offset,
  	       8);



CR Number                     : 13278
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd, acldb
Short Description             : foreign group acl check bug (DIFF)
Reported Date                 : 1/10/96
Found in Baseline             : 1.1
Found Date                    : 1/10/96
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.2, 1.1maint
Affected File(s)              : security/server/rsdb/rsdb_daclmgr.c,dce/utils/acldb/acleval.c
Diff supplied by              : provider
Diff release                  : 1.2.2
Sensitivity                   : public

[1/10/96 public]

It appears that the conversion to EPAC's foreign groupset from PAC's list
of foreign groups in 1.1, wrt the ACL access algorithm in the above listed
files is incomplete (the code has not been and will still not be testable
until 1.2.2 is done).  To make DCE1.1 ACL mgrs understand foreign groupsets
once they start showing up, vendors should patch their 1.1 based products
with the fix that we come up with and list here (real soon now).

[2/2/96 public]
Here's the diff (hand diff since my source base is different) to fix the
bug in rsdb_daclmgr.c.  We should have the diff for the other fix real soon
now.

security/server/rsdb/rsdb_daclmgr.c

Routine sec__acl_mgr_access_check()

OLD:
                } else {
                    /* CHECK FOREIGN GROUPS */
                    int k;
                    /* For each foreign groupset that the caller belongs to */
                    for (j = 0; j < paP->num_foreign_groupsets; j++) {

                      /* If the entry's realm matches this groupset's realm */
                      if (uuid_equal(&paP->foreign_groupsets[j].realm.uuid,
!                                     &group_id->uuid, &st))

                        /* Then check each group within that foreign realm */
                        for (k = 0; k < paP->foreign_groupsets[j].num_groups;
                             k++) {
                            if (uuid_equal(
!                               &paP->foreign_groupsets[j].realm.uuid,
!                               &realm_id->uuid, &st)) {

                                one_group_found = true;
                                /* check the perms to see if access granted */
                                if (get_access(sec_acl_p->sec_acl_entries[i],
                                        mask_perms, &granted))
                                    group_access = (group_access | granted);
                            }

                        }
                    }

NEW:
                } else {
                    /* CHECK FOREIGN GROUPS */
                    int k;
                    /* For each foreign groupset that the caller belongs to */
                    for (j = 0; j < paP->num_foreign_groupsets; j++) {

                      /* If the entry's realm matches this groupset's realm */
                      if (uuid_equal(&paP->foreign_groupsets[j].realm.uuid,
!                                     &realm_id->uuid, &st))

                        /* Then check each group within that foreign realm */
                        for (k = 0; k < paP->foreign_groupsets[j].num_groups;
                             k++) {
                            if (uuid_equal(
!                               &paP->foreign_groupsets[j].groups[k].uuid,
!                               &group_id->uuid, &st)) {


                                one_group_found = true;
                                /* check the perms to see if access granted */
                                if (get_access(sec_acl_p->sec_acl_entries[i],
                                        mask_perms, &granted))
                                    group_access = (group_access | granted);
                            }

                        }
                    }

----------------------------

[7/24/96 public]
This shouuld have been done long ago, but slipped by...  I believe the following
is the correct fix for the rest of this problem (being reviewed now by jrr and
psn). (note: only one of the two above broken stmts were broken in acleval.c)

********************************
<<< file 1: /vob/dce/src/dce/utils/acldb/acleval.c@@/main/mb_u2u2/0
>>> file 2: acleval.c
********************************
-----[647 changed to 647]-----
<                        if (!uuid_equal(&gp->uuid, &realm->uuid, st))
---
>                       if (!uuid_equal(&fgs->realm.uuid, &realm->uuid, st))

[7/25/96 public]
Submitted to 1.2.2 locally, well be part of nexct drop.

[10/1/96 public]
Fixed in the 1.1 maintenance tree.



CR Number                     : 13274
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 9488,7606
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec binding
Short Description             : rgy update bindings don't rebind
if first binding is invalid
Reported Date                 : 1/6/96
Found in Baseline             : 1.1
Found Date                    : 1/6/96
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : security/client/rca/internal_bidning.c
Sensitivity                   : public

[1/6/96 public]

A support customer reported the following problem. 
OT's 9488 and 7606 also report binding issues which may
be helpful when reviewing this OT.

On Line Description : 	

rgy_edit -update does not rebind if first binding is invalid

Full Description : 	

If rgy_edit is executed with the -update and the first
binding to connect to secd is invalid, the next binding in
the cache is not tried.

How to recreate the problem : 
1. Edit the pe_site file to have as its first entry an
   unreachable ip address. Have as the second entry a valid
   ip address,
2. Set the environment variable BIND_PE_SITE to 1
3. Execute rgy_edit -update
4. The following error message appears after a delay:

?(rgy_edit) Unable to contact the registry - RPC daemon communications failure (
dce / rpc)

Problem solution : 

In the ./src/security/client/rca/internal_binding.c module,
in the routine rca_site_resolve_update, a call to
rca_check_binding_resolved should be made if the call to
rs_bind_get_update_site fails. This has not been tested.

[1/9/96 public]
Fixed in DCE1.2.1 version of internal_binding.c



CR Number                     : 13266
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : dce_config
Short Description             : Install fails with incorrect etc directory specified
Reported Date                 : 12/28/95
Found in Baseline             : 1.2.1
Found Date                    : 12/28/95
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : dce_config,dce_config_utils,dce_com_utils,dce_shutdown,dce_config_env
Sensitivity                   : public

[12/28/95 public]
dce_config is set to the install area when the install option is used.  
However, all of the other routines are set to /etc on the machine they
are on.  dce_config sets the DCE_ETC directory to "." for install, but
to "/etc" for regular configurations.  If the /opt/dcelocal area has
been removed before installation, install will not work.

It is possible to work around this by entering the following code
in all scripts EXCEPT dce_config,  which are used with dce_config:

: ${DCE_ETC:=/etc}
export DCE_ETC

[1/3/96 public]
The context diff of the fix is:

*** /vob/dce/src/config/dce_config@@/main/DCE_1.2/1     Wed Jan  3 14:04:19 1996
--- /vob/dce/src/config/dce_config@@/main/DCE_1.2/2     Wed Jan  3 16:42:08 1996
***************
*** 8,13 ****
--- 8,16 ----
  #
  # HISTORY
  # $Log:	c013266,v $
# Revision 1.2  96/01/03  17:09:41  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company   new/changed/deleted note(s) [psn 1/3/96 public]
# 
+ # Revision /main/DCE_1.2/2  1996/01/03  21:42 UTC  psn
+ #     Fix DCE_ETC install time setting.
+ #
  # Revision /main/DCE_1.2/1  1996/01/03  19:05 UTC  psn
  #     Fix a test..
  #     [1995/12/04  22:35 UTC  psn  /main/DCE1_1_WP/jrr_1.2_mothra/8]
***************
*** 643,653 ****
  if [ "$INSTALL" = "y" -o "$1" = "install" ]
  then
        ETC="."
  else
        ETC="/etc"
  fi

! export ETC

  # DEBUG?
  D=$1
--- 646,658 ----
  if [ "$INSTALL" = "y" -o "$1" = "install" ]
  then
        ETC="."
+       DCE_ETC="."
  else
        ETC="/etc"
+       DCE_ETC="/etc"
  fi

! export ETC DCE_ETC

  # DEBUG?
  D=$1
***************
*** 667,673 ****
  fi

  echo "*****************************************************************" >>$lo
gfile
! echo "dce_config V$Revision: 1.2 $($Date: 96/01/03 17:09:41 $)
executed: `date`" >>$logfile
  echo "*****************************************************************" >>$lo
gfile

  # Report the values of the environment variables to the config log file
--- 672,678 ----
  fi

  echo "*****************************************************************" >>$lo
gfile
! echo "dce_config V$Revision: 1.2 $($Date: 96/01/03 17:09:41 $)
executed: `date`" >>$logfile
  echo "*****************************************************************" >>$lo
gfile

  # Report the values of the environment variables to the config log file
***************
*** 3748,3754 ****
    log_msg DETAIL "Executing: $cmd"
    secval_status=`$cmd`
    rtn_status=$?
!   if [ "$saved_krb5ccname" != "" ]
    then
      KRB5CCNAME=$saved_krb5ccname
      export KRB5CCNAME
--- 3753,3759 ----
    log_msg DETAIL "Executing: $cmd"
    secval_status=`$cmd`
    rtn_status=$?
!   if [ "$saved_krb5ccname"XX != "XX" ]
    then
      KRB5CCNAME=$saved_krb5ccname
      export KRB5CCNAME
*** /vob/dce/src/config/dce_shutdown@@/main/DCE_1.2/1   Wed Jan  3 14:42:53 1996
--- /vob/dce/src/config/dce_shutdown@@/main/DCE_1.2/2   Wed Jan  3 16:42:27 1996
***************
*** 7,16 ****
  # src directory for the full copyright text.
  #
  # @HP_DCE_VERSION@
! # @(#)Module: dce_shutdown $Revision: 1.2 $ $Date: 1996/01/03 19:4
3 UTC $
  #
  # HISTORY
  # $Log:	c013266,v $
# Revision 1.2  96/01/03  17:09:41  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company   new/changed/deleted note(s) [psn 1/3/96 public]
# 
  # Revision /main/DCE_1.2/1  1996/01/03  19:43 UTC  psn
  #     Merge mothra changes into mainline for DCE 1.2.1 code base.
  #     [1995/12/01  19:14 UTC  psn  /main/jrr_1.2_mothra/1]
--- 7,19 ----
  # src directory for the full copyright text.
  #
  # @HP_DCE_VERSION@
! # @(#)Module: dce_shutdown $Revision: 1.2 $ $Date: 1996/01/03 21:4
3 UTC $
  #
  # HISTORY
  # $Log:	c013266,v $
# Revision 1.2  96/01/03  17:09:41  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company   new/changed/deleted note(s) [psn 1/3/96 public]
# 
+ # Revision /main/DCE_1.2/2  1996/01/03  21:43 UTC  psn
+ #     Fix DCE_ETC install time setting.
+ #
  # Revision /main/DCE_1.2/1  1996/01/03  19:43 UTC  psn
  #     Merge mothra changes into mainline for DCE 1.2.1 code base.
  #     [1995/12/01  19:14 UTC  psn  /main/jrr_1.2_mothra/1]
***************
*** 123,129 ****
      exit 1
  fi

! DCE_ETC="/etc"
  export DCE_ETC


--- 126,132 ----
      exit 1
  fi

! : ${DCE_ETC:="/etc"}
  export DCE_ETC


*** /vob/dce/src/config/dce_config_utils@@/main/DCE_1.2/1       Wed Jan  3 14:26
:29 1996
--- /vob/dce/src/config/dce_config_utils@@/main/DCE_1.2/2       Wed Jan  3 16:42
:25 1996
***************
*** 7,12 ****
--- 7,15 ----
  #
  # HISTORY
  # $Log:	c013266,v $
# Revision 1.2  96/01/03  17:09:41  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company   new/changed/deleted note(s) [psn 1/3/96 public]
# 
+ # Revision /main/DCE_1.2/2  1996/01/03  21:43 UTC  psn
+ #     Fix DCE_ETC install time setting.
+ #
  # Revision /main/DCE_1.2/1  1996/01/03  19:27 UTC  psn
  #     Set the DCE_ETC env
  #     [1995/12/04  20:02 UTC  psn  /main/jrr_1.2_mothra/2]
***************
*** 92,98 ****
        set -x
  fi

! DCE_ETC="/etc"
  export DCE_ETC

  SOURCE_CONFIG_UTILS=1
--- 95,101 ----
        set -x
  fi

! : ${DCE_ETC:="/etc"}
  export DCE_ETC

  SOURCE_CONFIG_UTILS=1
*** /vob/dce/src/config/dce_config_env@@/main/DCE_1.2/1 Wed Jan  3 14:26:25 1996
--- /vob/dce/src/config/dce_config_env@@/main/DCE_1.2/2 Wed Jan  3 16:42:22 1996
***************
*** 6,15 ****
  # src directory for the full copyright text.
  #
  # @HP_DCE_VERSION@
! # @(#)Module: dce_config_env $Revision: 1.2 $ $Date: 1996/01/03 19
:27 UTC $
  #
  # HISTORY
  # $Log:	c013266,v $
# Revision 1.2  96/01/03  17:09:41  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company   new/changed/deleted note(s) [psn 1/3/96 public]
# 
  # Revision /main/DCE_1.2/1  1996/01/03  19:27 UTC  psn
  #     Merge mothra changes to mainline for OSF DCE 1.2.1 code base.
  #     [1995/12/01  22:46 UTC  psn  /main/jrr_1.2_mothra/1]
--- 6,18 ----
  # src directory for the full copyright text.
  #
  # @HP_DCE_VERSION@
! # @(#)Module: dce_config_env $Revision: 1.2 $ $Date: 1996/01/03 21
:43 UTC $
  #
  # HISTORY
  # $Log:	c013266,v $
# Revision 1.2  96/01/03  17:09:41  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company   new/changed/deleted note(s) [psn 1/3/96 public]
# 
+ # Revision /main/DCE_1.2/2  1996/01/03  21:43 UTC  psn
+ #     Fix DCE_ETC install time setting.
+ #
  # Revision /main/DCE_1.2/1  1996/01/03  19:27 UTC  psn
  #     Merge mothra changes to mainline for OSF DCE 1.2.1 code base.
  #     [1995/12/01  22:46 UTC  psn  /main/jrr_1.2_mothra/1]
***************
*** 133,139 ****
  # If the user provided a config file to set up, use it
  # otherwise look in a 'standard' place for it
  #
! DCE_ETC=/etc
  export DCE_ETC

  : ${CONFIG_FILE:="${DCE_ETC}/dce_config.conf"}
--- 136,142 ----
  # If the user provided a config file to set up, use it
  # otherwise look in a 'standard' place for it
  #
! : ${DCE_ETC:="/etc"}
  export DCE_ETC

  : ${CONFIG_FILE:="${DCE_ETC}/dce_config.conf"}
*** /vob/dce/src/config/dce_com_utils@@/main/DCE_1.2/1  Wed Jan  3 14:26:19 1996
--- /vob/dce/src/config/dce_com_utils@@/main/DCE_1.2/2  Wed Jan  3 16:42:19 1996
***************
*** 6,15 ****
  # src directory for the full copyright text.
  #
  # @HP_DCE_VERSION@
! # @(#)Module: dce_com_utils $Revision: 1.2 $ $Date: 1996/01/03 19:
27 UTC $
  #
  # HISTORY
  # $Log:	c013266,v $
# Revision 1.2  96/01/03  17:09:41  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company   new/changed/deleted note(s) [psn 1/3/96 public]
# 
  # Revision /main/DCE_1.2/1  1996/01/03  19:27 UTC  psn
  #     Remove HP specific stuff.
  #     [1995/12/04  20:43 UTC  psn  /main/jrr_1.2_mothra/2]
--- 6,18 ----
  # src directory for the full copyright text.
  #
  # @HP_DCE_VERSION@
! # @(#)Module: dce_com_utils $Revision: 1.2 $ $Date: 1996/01/03 21:
43 UTC $
  #
  # HISTORY
  # $Log:	c013266,v $
# Revision 1.2  96/01/03  17:09:41  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company   new/changed/deleted note(s) [psn 1/3/96 public]
# 
+ # Revision /main/DCE_1.2/2  1996/01/03  21:43 UTC  psn
+ #     Fix DCE_ETC install time setting.
+ #
  # Revision /main/DCE_1.2/1  1996/01/03  19:27 UTC  psn
  #     Remove HP specific stuff.
  #     [1995/12/04  20:43 UTC  psn  /main/jrr_1.2_mothra/2]
***************
*** 223,229 ****
  set -x
  fi

! DCE_ETC="/etc"
  export DCE_ETC

  SOURCE_COM_UTILS=1
--- 226,232 ----
  set -x
  fi

! : ${DCE_ETC:="/etc"}
  export DCE_ETC

  SOURCE_COM_UTILS=1
*** /vob/dce/src/config/dce_shutdown@@/main/DCE_1.2/1   Wed Jan  3 14:42:53 1996
--- /vob/dce/src/config/dce_shutdown@@/main/DCE_1.2/2   Wed Jan  3 16:42:27 1996
***************
*** 7,16 ****
  # src directory for the full copyright text.
  #
  # @HP_DCE_VERSION@
! # @(#)Module: dce_shutdown $Revision: 1.2 $ $Date: 1996/01/03 19:4
3 UTC $
  #
  # HISTORY
  # $Log:	c013266,v $
# Revision 1.2  96/01/03  17:09:41  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company   new/changed/deleted note(s) [psn 1/3/96 public]
# 
  # Revision /main/DCE_1.2/1  1996/01/03  19:43 UTC  psn
  #     Merge mothra changes into mainline for DCE 1.2.1 code base.
  #     [1995/12/01  19:14 UTC  psn  /main/jrr_1.2_mothra/1]
--- 7,19 ----
  # src directory for the full copyright text.
  #
  # @HP_DCE_VERSION@
! # @(#)Module: dce_shutdown $Revision: 1.2 $ $Date: 1996/01/03 21:4
3 UTC $
  #
  # HISTORY
  # $Log:	c013266,v $
# Revision 1.2  96/01/03  17:09:41  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company   new/changed/deleted note(s) [psn 1/3/96 public]
# 
+ # Revision /main/DCE_1.2/2  1996/01/03  21:43 UTC  psn
+ #     Fix DCE_ETC install time setting.
+ #
  # Revision /main/DCE_1.2/1  1996/01/03  19:43 UTC  psn
  #     Merge mothra changes into mainline for DCE 1.2.1 code base.
  #     [1995/12/01  19:14 UTC  psn  /main/jrr_1.2_mothra/1]
***************
*** 123,129 ****
      exit 1
  fi

! DCE_ETC="/etc"
  export DCE_ETC


--- 126,132 ----
      exit 1
  fi

! : ${DCE_ETC:="/etc"}
  export DCE_ETC



CR Number                     : 13219
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : 
	This completes submission of XIDL code in the area of C interfacing
	to C++.  Fix will be in /afs/dce/project/dce/dec/ot13219tar.Z,
	which will include changed files hdgen.c and cstubmts.c.
Reported Date                 : 12/5/95
Found in Baseline             : 1.2.1
Found Date                    : 12/5/95
Severity                      : C
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : 
		src/rpc/idl/idl/compiler/{hdgen.c,cstubmts.c}
Sensitivity                   : public

[12/5/95 public]

Interface C to C++ will work on AIX with the addition of the two new
files hdgen.c and cstubmts.c.



CR Number                     : 13213
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : lm/server
Short Description             : DIFF: invalid parameter passed to rs_log_journal_activity_update
Reported Date                 : 12/2/95
Found in Baseline             : 1.1wp
Found Date                    : 12/2/95
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint, 1.2.2
Affected File(s)              : security/server/lm/lm_jrnl.c
Diff supplied by              : provider
Diff release                  : 1.2.2
Sensitivity                   : public

[12/2/95 public]
 
A support customer noted the following:
---------------------------------------

Component (Module):     security/server/lm/lm_jrnl.c

One Line Description:

lm_log_journal_activity_update invalid param to rs_log_journal_activity_update

Full Description:

The routine rs_log_journal_activity_update() expects the 6th parameter
to be a pointer to a uuid and is coded:  uuid_t *uuid_of_src.
The routine lm_log_journal_activity_update() passes this 6th parameter
as a pointer to a pointer to a uuid.  The code:

    uuid_t *client=NULL;

    rs_log_journal_activity_update(id, data, data_len, &now,
        master_info_p, &client, st);

[7/25/96 public]
Will be part of next 1.2.2 drop. Diffs are:
*** /vob/dce/src/security/server/lm/lm_jrnl.c@@/main/8  Mon Apr  8 21:49:13 1996
--- /vob/dce/src/security/server/lm/lm_jrnl.c@@/main/DCE_1.2.2/1        Thu Jul 25 12:45:17 1996
***************
*** 8,13 ****
--- 8,17 ----
  /*
   * HISTORY
   * $Log:	c013213,v $
# Revision 1.5  96/10/10  14:10:56  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mak 10/10/96 public]
# 
# Revision 1.4  96/07/25  13:12:25  root
# changed fields: Short Description  Status  Fixed In Baseline  Affected File(s)  Diff supplied by  Diff release  Responsible Engr.   new/changed/deleted note(s) [psn 7/25/96 public]
# 
+  * Revision /main/DCE_1.2.2/1  1996/07/25  16:45 UTC  psn
+  *    OT13213 - fix call to rs_log_journal_activity_update
+  *    [1995/12/14  15:12 UTC  hinxman  /main/HPDCE02/hinxman_ot13213_10/1]
+  * 
   * Revision 1.1.9.3  1996/02/18  00:16:32  marty
   *    Update OSF copyright years
   *    [1996/02/17  23:05:37  marty]
***************
*** 272,278 ****
  {
      sec_timeval_sec_t           now;
      rs_replica_master_info_t    *master_info_p = NULL;
!     uuid_t                      *client=NULL;
      rsdb_jrnl_rec_t             *data=NULL;
      int                         data_len=0,i=0;
  
--- 276,282 ----
  {
      sec_timeval_sec_t           now;
      rs_replica_master_info_t    *master_info_p = NULL;
!     uuid_t                      client;
      rsdb_jrnl_rec_t             *data=NULL;
      int                         data_len=0,i=0;
  
***************
*** 290,296 ****
      }
      memset((char *)data, NULL,data_len);
      data_len=import_jrnl_to_rsdb(journal,data,st);
!     CLEAR_STATUS(st);
      rs_log_journal_activity_update(id, data, data_len, &now,
          master_info_p, &client, st);
  
--- 294,300 ----
      }
      memset((char *)data, NULL,data_len);
      data_len=import_jrnl_to_rsdb(journal,data,st);
!     uuid_create_nil(&client, st);
      rs_log_journal_activity_update(id, data, data_len, &now,
          master_info_p, &client, st);

[10/10/96 public]

Fixed in 1.1 maintenance.



CR Number                     : 13210
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : cross-cell
Short Description             : Cross-realm tickets don't refresh properly
Reported Date                 : 11/21/95
Found in Baseline             : 1.1
Found Date                    : 11/21/95
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : src/security/krb5/lib/krb/gc_frm_kdc.c
Sensitivity                   : public
Transarc Deltas               : cox-16939-cross-realm-krbtgt-not-refreshed
Transarc Status               : 

[11/21/95 public]
This is a defect that Dan Nydick found.  I'm filing it for him here so that
it can be tracked at HP too.
-------------------------------
When I use DFS to access files in a remote cell, I see the following
behaviour:
    The first access is fine.  I get a ptgt for the remote cell and
	service tickets for the remote file servers.  Cdsls of the
	remote cell's namespace works properly.
    After several hours (ie: after the ptgt has expired) access starts
	to fail with code 382312679 "Authentication ticket expired".
	After this has happened, I can't access any files or see the
	CDS namespace in the remote cell.  Presumably nothing else
	works either.  At this time klist shows a tgt and ptgt to the
	remote cell, but no service tickets.
    Running kinit fixes everything (for another few hours, anyway).
 
klist while everything is working:
----------------
    DCE Identity Information:
    	Global Principal: /.../sparc30.dce.transarc.com/nydick
    	Cell:      40a4fc44-ce9a-11ce-96af-9e620c39aa77 /.../sparc30.dce.transarc.com
    	Principal: 00000517-cea0-21ce-a000-9e620c39aa77 nydick
    	Group:     0000000b-cea0-21ce-a001-9e620c39aa77 transarc
    	Local Groups:
    		0000271f-1b90-21cf-a001-9e620c39aa77 encina_admin_group
     
    Identity Info Expires: 95/11/15:19:43:21
    Account Expires:       never
    Passwd Expires:        never
     
    Kerberos Ticket Information:
    Ticket cache: /opt/dcelocal/var/security/creds/dcecred_41fffff6
    Default principal: nydick@sparc30.dce.transarc.com
    Server: krbtgt/sparc30.dce.transarc.com@sparc30.dce.transarc.com
    	valid 95/11/15:09:43:21 to 95/11/15:19:43:21
    Server: dce-rgy@sparc30.dce.transarc.com
    	valid 95/11/15:09:43:22 to 95/11/15:19:43:21
    Server: dce-ptgt@sparc30.dce.transarc.com
    	valid 95/11/15:09:43:23 to 95/11/15:11:43:23
    Client: dce-ptgt@sparc30.dce.transarc.com	Server: krbtgt/sparc30.dce.transarc.com@sparc30.dce.transarc.com
    	valid 95/11/15:09:43:23 to 95/11/15:11:43:23
    Client: dce-ptgt@sparc30.dce.transarc.com	Server: hosts/sparc30/self@sparc30.dce.transarc.com
    	valid 95/11/15:09:43:23 to 95/11/15:11:43:23
    Client: dce-ptgt@sparc30.dce.transarc.com	Server: dce-rgy@sparc30.dce.transarc.com
    	valid 95/11/15:09:43:25 to 95/11/15:11:43:23
    Server: krbtgt/transarc.com@sparc30.dce.transarc.com
    	valid 95/11/15:09:44:54 to 95/11/15:19:43:21
    Server: dce-ptgt@transarc.com
    	valid 95/11/15:09:44:54 to 95/11/15:11:44:54
    Client: dce-ptgt@sparc30.dce.transarc.com	Server: krbtgt/transarc.com@sparc30.dce.transarc.com
    	valid 95/11/15:09:44:54 to 95/11/15:11:43:23
    Client: dce-ptgt@sparc30.dce.transarc.com	Server: dce-ptgt@transarc.com
    	valid 95/11/15:09:44:54 to 95/11/15:11:43:23
    Client: dce-ptgt@transarc.com	Server: krbtgt/transarc.com@transarc.com
    	valid 95/11/15:09:44:55 to 95/11/15:11:43:23
    Client: dce-ptgt@transarc.com	Server: hosts/dfs1/dfs-server@transarc.com
    	valid 95/11/15:09:44:55 to 95/11/15:11:43:23
    Client: dce-ptgt@sparc30.dce.transarc.com	Server: hosts/sparc30/cds-server@sparc30.dce.transarc.com
    	valid 95/11/15:09:45:17 to 95/11/15:11:43:23
    Client: dce-ptgt@sparc30.dce.transarc.com	Server: hosts/sparc30/gda@sparc30.dce.transarc.com
    	valid 95/11/15:09:45:18 to 95/11/15:11:43:23
    Client: dce-ptgt@transarc.com	Server: dce-rgy@transarc.com
    	valid 95/11/15:09:45:20 to 95/11/15:11:43:23
    Client: dce-ptgt@transarc.com	Server: hosts/unix1/cds-server@transarc.com
    	valid 95/11/15:09:45:20 to 95/11/15:11:43:23
    Client: dce-ptgt@sparc30.dce.transarc.com	Server: hosts/sparc30/dfs-server@sparc30.dce.transarc.com
    	valid 95/11/15:09:45:46 to 95/11/15:11:43:23
    Client: dce-ptgt@sparc30.dce.transarc.com	Server: encina/sfs/sfs1@sparc30.dce.transarc.com
	valid 95/11/15:09:46:33 to 95/11/15:11:43:23
----------------
 
klist after the failures start:
 
----------------
    DCE Identity Information:
    	Global Principal: /.../sparc30.dce.transarc.com/nydick
    	Cell:      40a4fc44-ce9a-11ce-96af-9e620c39aa77 /.../sparc30.dce.transarc.com
	Principal: 00000517-cea0-21ce-a000-9e620c39aa77 nydick
	Group:     0000000b-cea0-21ce-a001-9e620c39aa77 transarc
	Local Groups:
		0000271f-1b90-21cf-a001-9e620c39aa77 encina_admin_group
    
    Identity Info Expires: 95/11/15:19:43:21
    Account Expires:       never
    Passwd Expires:        never
     
    Kerberos Ticket Information:
    Ticket cache: /opt/dcelocal/var/security/creds/dcecred_41fffff6
    Default principal: nydick@sparc30.dce.transarc.com
    Server: krbtgt/sparc30.dce.transarc.com@sparc30.dce.transarc.com
    	valid 95/11/15:09:43:21 to 95/11/15:19:43:21
    Server: dce-rgy@sparc30.dce.transarc.com
    	valid 95/11/15:09:43:22 to 95/11/15:19:43:21
    Server: dce-ptgt@sparc30.dce.transarc.com
    	valid 95/11/15:11:50:49 to 95/11/15:13:50:49
    Client: dce-ptgt@sparc30.dce.transarc.com	Server: krbtgt/sparc30.dce.transarc.com@sparc30.dce.transarc.com
    	valid 95/11/15:11:50:49 to 95/11/15:13:50:49
    Client: dce-ptgt@sparc30.dce.transarc.com	Server: dce-rgy@sparc30.dce.transarc.com
    	valid 95/11/15:11:51:15 to 95/11/15:13:50:49
    Server: krbtgt/transarc.com@sparc30.dce.transarc.com
    	valid 95/11/15:09:44:54 to 95/11/15:19:43:21
    Server: dce-ptgt@transarc.com
    	valid 95/11/15:11:50:50 to 95/11/15:13:50:50
----------------
 
Craig asked the folks at HP if they had any insight.  We got back the
following:
 
-------------
    Message-Id: <199511132135.AA201708508@relay.hp.com>
    Received: from nyc.ch.apollo.hp.com by it_750.ch.apollo.hp.com 
    	id AA109158506; Mon, 13 Nov 1995 16:35:06 -0500    
    To: Craig_Everhart@transarc.com, Daniel_Nydick@transarc.com,
            carl@austin.ibm.com
    Cc: burati@apollo.hp.com (Mike Burati)
    Subject: Re: A couple of DCE authn questions 
    In-Reply-To: Your message of "Mon, 13 Nov 1995 16:24:05 EST."
    Date: Mon, 13 Nov 1995 16:35:06 -0500
    From: Sean Mullan <mullan_s@apollo.hp.com>
 
    >    ...
    >       (c) Dan Nydick is seeing some odd behavior from (I think) dfsbind and I
    >       wonder if you had seen or known of a problem in this area.  He says
    >       that, for DFS CM access to non-local cells, the PTGT is being refreshed
    >       but the service ticket isn't.  Is there something special about using
    >       only DFS for cross-cell access (and not, say, a more ordinary user-space
    >       application) that would trigger this behavior? 
    >    
    >    Not that I can think of; it would be helpful to better understand
    >    what's going on there; we may have some strange corner cases in how we
    >    do PTGT caching..
    >
    >This sounds similar to a problem Sean was just telling me about, so I've
    >cc'd him on this too...
     
    Is this DCE 1.1?
         
    Check out OSF OT 13197 (KRB5_TC_MATCH_SRV_NAMEONLY flag broken), which I just opened. 
    This definitely sounds like it could be the same problem.
     
    --Sean
-----------
 
I created a build with Sean's fix (delta
nydick-ot13197-MATCH_SRV_NAMEONLY-matches-too-much), but that didn't
seem to solve the problem.
 
nydick-Wed, 15 Nov 1995 12:12:56
 
More mail received from the fellow at HP:
 
-----------
To: Daniel_Nydick@transarc.com
Cc: Sean Mullan <mullan_s@apollo.hp.com>, Craig_Everhart@transarc.com,
        burati@apollo.hp.com (Mike Burati)
Subject: Re: A couple of DCE authn questions 
In-Reply-To: Your message of "Wed, 15 Nov 1995 13:11:59 EST."
             <okeWpjmSMUkt04kXk0@transarc.com> 
Date: Wed, 15 Nov 1995 13:59:39 -0500
From: Sean Mullan <mullan_s@apollo.hp.com>
 
Hi Dan,
 
>	I tried your fix from OT13197, and it didn't seem to help my
>cross-cell problem.  Thanks anyway for the suggestion.  I'm not going
>to be able to follow up on this one, but if you'd like, I'll have
>which ever Transarcian that takes on the problem keep in touch with
>you.
>    Thanks,
>	Dan
 
Shucks, oh well.
 
Please (or have your colleague) open an OT with all the information you
have.  There is actually another dfs ticket refresh problem we have been
seeing in-house here which we have not yet been able to track down, so
they may be related.
 
Thanks,
Sean
 
----------------
 
Sounds like HP is interested.  I suggest we (ie: Ben) strike while the
iron is hot...
 
nydick-Thu, 16 Nov 1995 10:11:00
 
Extra info: when I re-kinit, I get the following on the console
(PID 383 is dfsbind).
 
1995-11-16-16:59:52.836-05:00I0.437 PID#383 NOTICE sec rgybind internal_binding.c 1742 0x0000000a
Attempting to rebind to an alternate registry site and retrying operation
1995-11-16-16:59:53.390-05:00I0.437 PID#383 NOTICE sec rgybind internal_binding.c 1744 0x0000000a
Rebound to site /.../transarc.com/subsys/dce/sec/master
 
nydick-Thu, 16 Nov 1995 17:02:16
 
-------------------------------------
When we saw Dan's problem again in DFS, I took a look to see what traces
were there.  The DFS CM was cacheing EACCES for the remote cell, since
that's what it was getting as an error code from dfsbind.  Dfsbind was
returning that error code since its call to sec_id_parse_name was
returning eror code 382312679 (rpc_s_auth_tkt_expired).  Now, dfsbind uses
the machine identity (the ..../self principal), so perhaps its credential
wasn't having its cross-cell service tickets refreshed or some such.
 
What might be interesting about this case is that the remote cell name is
a strict subset of the local name (as domain names).  The local cell is:
	/.../sparc30.dce.transarc.com
The remote cell is:
	/.../transarc.com
 
Here is a klist of the ..../self credential when the cross-cell stuff is
failing:
----------
DCE Identity Information:
	Global Principal: /.../sparc30.dce.transarc.com/hosts/sparc30/self
	Cell:      40a4fc44-ce9a-11ce-96af-9e620c39aa77 /.../sparc30.dce.transarc.com
	Principal: 00002711-ce9a-21ce-9600-9e620c39aa77 hosts/sparc30/self
	Group:     0000000c-ce9a-21ce-9601-9e620c39aa77 none
	Local Groups:
		0000000c-ce9a-21ce-9601-9e620c39aa77 none
		00002715-ce9a-21ce-a001-9e620c39aa77 subsys/dce/dts-servers
 
Identity Info Expires: 95/11/17:17:12:36
Account Expires:       never
Passwd Expires:        never
 
Kerberos Ticket Information:
Ticket cache: /opt/dcelocal/var/security/creds/dcecred_ffffffff
Default principal: hosts/sparc30/self@sparc30.dce.transarc.com
Server: krbtgt/sparc30.dce.transarc.com@sparc30.dce.transarc.com
	valid 95/11/17:07:12:36 to 95/11/17:17:12:36
Server: dce-rgy@sparc30.dce.transarc.com
	valid 95/11/17:07:12:37 to 95/11/17:17:12:36
Server: dce-ptgt@sparc30.dce.transarc.com
	valid 95/11/17:13:14:56 to 95/11/17:15:14:56
Client: dce-ptgt@sparc30.dce.transarc.com	Server: krbtgt/sparc30.dce.transarc.com@sparc30.dce.transarc.com
	valid 95/11/17:13:14:56 to 95/11/17:15:14:56
Client: dce-ptgt@sparc30.dce.transarc.com	Server: hosts/sparc30/self@sparc30.dce.transarc.com
	valid 95/11/17:13:14:56 to 95/11/17:15:14:56
Server: krbtgt/transarc.com@sparc30.dce.transarc.com
	valid 95/11/17:08:51:29 to 95/11/17:17:12:36
Server: dce-ptgt@transarc.com
	valid 95/11/17:13:29:13 to 95/11/17:15:29:13
Client: dce-ptgt@sparc30.dce.transarc.com	Server: dce-rgy@sparc30.dce.transarc.com
	valid 95/11/17:13:29:11 to 95/11/17:15:14:56
----------
When the problem recurred for Dan, he got it working again by shutting down
and restarting the SECVAL process in dced, with ``secval deactivate''
followed by ``secval activate''.  He flushed the CM cache of the dfsbind
result with ``cm check'' and was off and running again.
 
Hope that this helps.

[11/21/95 public]
Changed Interest List CC from `nydick@transarc.com, cox@transarc.com' to 
 `nydick@transarc.com, cox@transarc.com, mullan_s@apollo.hp.com, 
 burati@apollo.hp.com, carl@austin.ibm.com'

[12/22/95 public]
Routine krb5_get_cred_from_kdc was looking in the cache for a krbtgt
for the remote cell without regard to whether it was expired, then
blindly using it.  Added flag KRB5_TC_MATCH_TIMES to a call to
krb5_cc_retrieve_cred to ensure that only unexpired foreign krbtgt's
would be found in the inner loop.
Delta: cox-16939-cross-realm-krbtgt-not-refreshed
Change: security/krb5/lib/krb/gc_frm_kdc.c from 12.7 to 12.9
*** security/krb5/lib/krb/gc_frm_kdc.c
--- 12.9	1995/12/22 20:29:58
***************
*** 2,7 ****
--- 2,18 ----
   * @TRANSARC_COPYRIGHT@
   *
   * $TALog: gc_frm_kdc.c,v $
+  * Revision 12.9  1995/12/22  20:29:58  cox
+  * Tickets for servers in remote cells were not getting refreshed
+  * properly after expiration.
+  *
+  * The problem was caused by a missing flag in krb5_get_cred_from_kdc,
+  * which was looking in the credential cache for a krbtgt for the remote
+  * cell, and finding one and using it without regard to whether it was
+  * expired.  This change ensures that it will not use an expired foreign
+  * krbtgt, but rather try to get a new one.
+  * [from r12.7 by delta cox-16939-cross-realm-krbtgt-not-refreshed, r1.1]
+  *
   * Revision 12.7  1995/07/12  21:04:11  claire
   * [merge of changes from 12.4 to 12.6 into 12.5]
   *
***************
*** 49,55 ****
   */
  
  #if !defined(_NOIDENT) && !defined(lint)
! static char *TARCSId = "$Id: c013210,v 1.4 95/12/27 13:20:04 root Exp $";
  #endif
  
  /*
--- 60,66 ----
   */
  
  #if !defined(_NOIDENT) && !defined(lint)
! static char *TARCSId = "$Id: c013210,v 1.4 95/12/27 13:20:04 root Exp $";
  #endif
  
  /*
***************
*** 109,115 ****
  */
  /*
   * $Source: /project/ot/dce/d01/d32/RCS/c013210,v $
!  * $Author: root $
   *
   * Copyright (c) 1994 by the Massachusetts Institute of Technology.
   * Copyright (c) 1994 CyberSAFE Corporation
--- 120,126 ----
  */
  /*
   * $Source: /project/ot/dce/d01/d32/RCS/c013210,v $
!  * $Author: root $
   *
   * Copyright (c) 1994 by the Massachusetts Institute of Technology.
   * Copyright (c) 1994 CyberSAFE Corporation
***************
*** 141,147 ****
  
  #if !defined(lint) && !defined(SABER)
  static char rcsid_gcfkdc_c[] =
! "$Id: c013210,v 1.4 95/12/27 13:20:04 root Exp $";
  #endif  /* !lint & !SABER */
--- 152,158 ----
  
  #if !defined(lint) && !defined(SABER)
  static char rcsid_gcfkdc_c[] =
! "$Id: c013210,v 1.4 95/12/27 13:20:04 root Exp $";
  #endif  /* !lint & !SABER */
***************
*** 395,401 ****
  	  goto cleanup;
  
        if (retval = krb5_cc_retrieve_cred(ccache,
! 					 KRB5_TC_MATCH_SRV_NAMEONLY,
  					 &tgtq,
  					 &tgt)) {
      
--- 406,413 ----
  	  goto cleanup;
  
        if (retval = krb5_cc_retrieve_cred(ccache,
! 					 KRB5_TC_MATCH_SRV_NAMEONLY
! 					 | KRB5_TC_MATCH_TIMES,
  					 &tgtq,
  					 &tgt)) {
      
Filled in Affected File with `src/security/krb5/lib/krb/gc_frm_kdc.c' 
Added field Transarc Deltas with value 
 `cox-16939-cross-realm-krbtgt-not-refreshed' 
Added field Transarc Status with value `'

[12/27/95 public]

This suggested fix is actually already in the 1.2.1 sources. Marked as
fixed in 1.2.1



CR Number                     : 13199
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_login
Short Description             : Need sec_login_import_context_uid() to fix CDS security hole
Reported Date                 : 11/13/95
Found in Baseline             : 1.0
Found Date                    : 11/13/95
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : sec_login.idl, sec_login_pvt.h, sec_login.c, sec_login_pvt.c
Sensitivity                   : public

[11/13/95 public]

PROBLEM:  The cdsadv daemon runs as 'root', but does lots of
sec_login_import_context() calls to use the DCE credentials of the real
caller.  The channel between the caller and cdsadv is secured by the local
filesystem, but the protocol between the caller and cdsadv has no way of
providing absolute knowledge that the credentials it's asking the advertiser
to use are owned by that caller.

caller:
   export_context() (gets KRB5CCNAME equivalent to send across socket to adv)

cdsadv:
   knows uid of caller.
   gets buffer (cred name) from socket calls sec_login_import_context()

There was nothing stopping the caller from bypassing the CDS client agent
that did the sec_login_export_context(), and passing in the name of some
other users credentials.  Since the advertiser and clerk run as root, they
can open and read any credentials.

BUT!, the advertiser does know the uid of the caller (it's used to secure
the channel that the client talks to it on), so all it needs to do is
verify that the UID of the caller is also the owner of the credential file
that it's going to import.

BUT! the buffer passed to the advertiser/clerk is supposed to be opaque (nothing
other than the security internals are supposed to know that they can strip
off the FILE: and use the rest as a filename), so the advertiser couldn't
do that.

So, we added a sibling of sec_login_import_context() that now takes a UID
as an extra argument and checks that UID against the owner of the login
context's credential cache file.

BUT!, doing stat() every time through this routine kills performance (CDS
goes through here way more than it should), so we had to cache the owner
deeper in the sec_login code (wherever it creates the file, opens/reads it
for the first time, and/or chown()s it).

That's the description, code diffs coming as soon as I can get them (the
fix is already in 1.2.1, I'm trying to get diffs against the WP, so other
vendors can fix this sooner).

[11/13/95 public]
Diffs for sec_login.idl, sec_login_pvt.h and sec_login.c
(the diffs for sec_login_pvt.c aren't as obvious and will be included in a
context diff below).  These changes were all based on a starting point of
the latest WP version of the file that I could find, so start there if you're
applying the fix from these diffs.  I don't have a 1.1wp sandbox to build/test
these with, but they came straight from our 1.2.1 version which does build
and test.

********************************
<<< file 1: /vob/dce/src/security/idl/sec_login.idl@@/main/ot13199/0
>>> file 2: sec_login.idl
********************************
-----[after 878 inserted 879-894]-----
>     /* s e c _ l o g i n _ i m p o r t _ c o n t e x t _ u i d
>      *
>      * Import a context obtained via a call to sec_login_export_context
>      * performed on the same machine.  This function is generally reserved to
>      * the privileged user.  Pass in the UNIX ID of the original caller, to
>      * be checked against the actual owner of the credential storage.
>      */
>     void sec_login_import_context_uid (
>         [in]        unsigned32          buf_len,
>         [in, size_is(buf_len)]
>                     byte                buf[],
>         [in]        signed32            uid,
>         [out]       sec_login_handle_t  *login_context,
>         [out]       error_status_t      *st
>     );
> 

********************************
<<< file 1: /vob/dce/src/security/h/sec_login_pvt.h@@/main/ot13199/0
>>> file 2: sec_login_pvt.h
********************************
-----[265 changed to 265-266]-----
< } sec_login_context_t, *sec_login_context_p_t;
---
>     signed32                 owner_uid; /* owner of the credential files */
> } sec_login_context_t, *sec_login_context_p_t; 

********************************
<<< file 1: /vob/dce/src/security/client/login/sec_login.c@@/main/ot13199/0
>>> file 2: sec_login.c
********************************
-----[after 9 inserted 10-12]-----
>  * Merge fix for CHFts16467 from mb_mothra7
>  * [1995/10/23  17:20 UTC  burati  /main/HPDCE02/9]
>  *
-----[195 changed to 198]-----
<     "$Id: c013199,v 1.4 95/12/21 16:01:39 root Exp $";
---
>     "$Id: c013199,v 1.4 95/12/21 16:01:39 root Exp $";
-----[after 780 inserted 784-785]-----
>              * Also, must change the login context owner uid whenever
>              * we chown the krb5 cache file.
-----[after 784 inserted 790]-----
>               tlcp->owner_uid = UNIX_CREDS(tlcp).pwent->pw_uid;
-----[after 1714 inserted 1721-1754]-----
> 
> /* s e c _ _ l o g i n _ i m p o r t _ c o n t e x t
>  *
>  * Import a context obtained via a call to sec_login_export_context
>  * performed on the same machine.  This function is generally reserved to
>  * the privileged user.
>  *
>  * Internal base class rtn with extra boolean arg for cc access checking.
>  */
> PRIVATE void sec__login_import_context
>   (
>     unsigned32                buf_len,        /* [in]  */
>     ndr_byte          buf[],          /* [in]  */
>     signed32            uid,             /* [in]  */
>     sec_login_handle_t  *login_context, /* [out] */
>     error_status_t      *st             /* [out] */
>   )
> {
>     sec_login_context_t **lcap = (sec_login_context_t **) login_context;
>     sec_login_context_t *lcp;
>     char *cname;
>     int cname_len;
>     uuid_t  generation_id;
> 
>     CLEAR_STATUS(st);
> 
>     sec_login_pvt_parse_export_token(buf, buf_len, &cname, &cname_len, 
>                                    &generation_id, st);
>     if (BAD_STATUS(st)) {
>       *lcap = NULL;
>       return;
>     }
> 
>     /* Existing login context in cache with that cname? */
-----[deleted/moved 1715-1722 after 1754 (now at 1838-1845)]-----
< /* s e c _ l o g i n _ i m p o r t _ c o n t e x t
<  *
<  * Import a context obtained via a call to sec_login_export_context
<  * performed on the same machine.  This function is generally reserved to
<  * the privileged user.
<  *
<  */
< PUBLIC void sec_login_import_context
-----[deleted 1723-1752 after 1754]-----
< #ifndef __STDC__
<     ( buf_len, buf, login_context, st )
<     unsigned32          buf_len;        /* [in]  */
<     ndr_byte            buf[];           /* [in]  */
<     sec_login_handle_t  *login_context; /* [out] */
<     error_status_t      *st;            /* [out] */
< #else
<   (
<     unsigned32                buf_len,        /* [in]  */
<     ndr_byte          buf[],          /* [in]  */
<     sec_login_handle_t  *login_context, /* [out] */
<     error_status_t      *st             /* [out] */
<   )
< #endif
< {
<     sec_login_context_t **lcap = (sec_login_context_t **) login_context;
<     sec_login_context_t *lcp;
<     char *cname;
<     int cname_len;
<     uuid_t  generation_id;
< 
<     CLEAR_STATUS(st);
< 
<     sec_login_pvt_parse_export_token(buf, buf_len, &cname, &cname_len, 
<                                    &generation_id, st);
<     if (BAD_STATUS(st)) {
<       *lcap = NULL;
<       return;
<     }
< 
-----[after 1767 inserted 1770-1778]-----
> 
>         /* Make sure creds are owned by the specified UID before proceeding */
>         if ((uid != -1) && lcp->owner_uid != uid) {
>             SET_STATUS(st, sec_login_s_no_current_context);
>       *lcap = NULL;
>           sec_login_pvt_release_context(lcp);
>       return;
>     }
> 
-----[after 1773 inserted 1785]-----
> 
-----[1775-1781 changed to 1787-1798]-----
<       sec_login_pvt_allocate_login_context(false,
<                                           (unsigned_char_p_t) NULL,
<                                           cname,   /* cache name */
<                                          lcap,
<                                          st);
<     if (GOOD_STATUS(st))
< {
---
>     sec_login_pvt_allocate_login_context(false, (unsigned_char_p_t) NULL,
>         cname, lcap, st);
>     if (GOOD_STATUS(st))
> {
>         /* Make sure creds are owned by the specified UID before proceeding */
>         if ((uid != -1) && (*lcap)->owner_uid != uid) {
>             SET_STATUS(st, sec_login_s_no_current_context);
>           sec_login_pvt_release_context(*lcap);
>       *lcap = NULL;
>       return;
>     }
> 
-----[after 1797 inserted 1815-1837]-----
>     }
> 
> 
> /* s e c _ l o g i n _ i m p o r t _ c o n t e x t _ u i d
>  *
>  * Import a context obtained via a call to sec_login_export_context
>  * performed on the same machine.  This function is generally reserved to
>  * the privileged user.
>  *
>  */
> PUBLIC void sec_login_import_context_uid
>   (
>     unsigned32                buf_len,        /* [in]  */
>     ndr_byte          buf[],          /* [in]  */
>     signed32            uid,             /* [in]  */
>     sec_login_handle_t  *login_context, /* [out] */
>     error_status_t      *st             /* [out] */
>   )
> {
>     sec__login_import_context(buf_len, buf, uid, login_context, st);
>     }
> 
> 
-----[after 1797 inserted/moved 1838-1845 (was at 1715-1722)]-----
> /* s e c _ l o g i n _ i m p o r t _ c o n t e x t
>  *
>  * Import a context obtained via a call to sec_login_export_context
>  * performed on the same machine.  This function is generally reserved to
>  * the privileged user.
>  *
>  */
> PUBLIC void sec_login_import_context
-----[after 1797 inserted 1846-1853]-----
>   (
>     unsigned32                buf_len,        /* [in]  */
>     ndr_byte          buf[],          /* [in]  */
>     sec_login_handle_t  *login_context, /* [out] */
>     error_status_t      *st             /* [out] */
>   )
> {
>     sec__login_import_context(buf_len, buf, -1, login_context, st);


*** sec_login_pvt.c@@/main/DCE1_1_WP/ot13199/0  Mon Nov 13 19:18:35 1995
--- sec_login_pvt.c     Mon Nov 13 19:33:44 1995
***************
*** 2540,2548 ****
--- 2540,2558 ----
      if (cache_name) {
          int len = strlen(cache_name)+1;
          char *name_copy = malloc (len);
+       struct stat stb;
          memcpy(name_copy, cache_name, len);
          lcp->context_name = name_copy;
          lcp->context_name_len = len;
+         /*
+          * Find out who owns the credential cache file and set the
+          * owner_uid to it.
+          */
+         if (stat(krb5_cc_get_name(KRB_INFO(lcp).cache), &stb) == -1) {
+             SET_STATUS(stp, sec_login_s_no_current_context);
+           goto errout;
+         }
+       lcp->owner_uid = stb.st_uid;
      } else {
          /*
           * !!! should extract this from the context, and update it on
***************
*** 2849,2856 ****
          }
  
        /*
!        * change ownership of cache file if it is being created
!        * via proxy (default ownership is by euid).
         */             
        if (GOOD_STATUS(stp)) {
            if ((FLAG_SET(lcp->flags, sec_login_proxy_cred)) &&
--- 2859,2868 ----
          }
  
        /*
!        * change ownership of cache file if it is being created 
!        * via proxy (default ownership is by euid). 
!        * Also, must change the login context owner uid whenever
!        * we chown the krb5 cache file.
         */             
        if (GOOD_STATUS(stp)) {
            if ((FLAG_SET(lcp->flags, sec_login_proxy_cred)) &&
***************
*** 2858,2863 ****
--- 2870,2876 ----
                (geteuid() == 0)) {
                    if (chown(prev_cfn, UNIX_CREDS(lcp).pwent->pw_uid, -1) == -1)
                        *stp = errno;
+                   lcp->owner_uid = UNIX_CREDS(lcp).pwent->pw_uid;
            }
              /*
               * save pag in login context.
***************
*** 4145,4158 ****
      if (INFO_STATE(rcp) == info_certified) {
          char  *cfn;
          /*
!          * chown the credential cache and data file with the uid from
!          * context unix info.
           */
          cfn = krb5_cc_get_name(rcp->krb_info.cache);
        if (cfn != NULL && UNIX_CREDS(rcp).pwent != NULL && geteuid() == 0) {
            if (chown(cfn, UNIX_CREDS(rcp).pwent->pw_uid, -1) == -1)
!               *stp = errno;
!         }
      }
  
      rcp->refcount = 1;
--- 4158,4174 ----
      if (INFO_STATE(rcp) == info_certified) {
          char  *cfn;
          /*
!          * chown the credential cache and data file with the uid from 
!          * context unix info. 
!          * Also, must change the login context owner uid whenever
!          * we chown the krb5 cache file.
           */
          cfn = krb5_cc_get_name(rcp->krb_info.cache);
        if (cfn != NULL && UNIX_CREDS(rcp).pwent != NULL && geteuid() == 0) {
            if (chown(cfn, UNIX_CREDS(rcp).pwent->pw_uid, -1) == -1)
!               *stp = errno; 
!           rcp->owner_uid = UNIX_CREDS(rcp).pwent->pw_uid;
!         } 
      }
  
      rcp->refcount = 1;

[12/20/95 public]
This appears to have made it into 1.2.1 also, so I'm marking it fixed.
Whoever owns the security OTs at the OSF should make sure that the above
mentioned API (sec_login_import_context_uid() ) shows up in the 1.2.1
code, and then move this from 'fix' to closed.

[12/21/95 public]
Don't close this yet.  The security part should be in 1.2.1, but the
changes to CDS that make the above call are not in 1.2.1.  This is because
we had difficulty building pre-1.2.1 + changes on AIX.  Now that the
1.2.1 core is available, we'll try it again.  We'll post the CDS diffs
once we verify on AIX.



CR Number                     : 13137
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : security functional test failures
Reported Date                 : 10/3/95
Found in Baseline             : 1.2.1
Found Date                    : 9/22/95
Severity                      : C
Priority                      : 3
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : test/functional/security/...
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/3/95 public]

	The following security functional tests fail in 1.2.1 
	DCE (both versions previous to Xidl/regy_sync and with 
	Xidl/regy_sync).  Logs are available for the owner of 
	the "assigned to" person, which will be here at HP since 
	this bug is in the security area.  
	 

                fail sec_rgy_attr_sch_create_entry()
                fail password strength startup: rpc_binding_set_auth_info()
                fail tp1: sec_pwd_mgmt_gen_pwd
                fail tp2: sec_pwd_mgmt_gen_pwd
                fail Bin compat: sec_login_import_context
                fail Bin compat setup: sec_key_mgmt_set_key
                fail Bin compat: sec_key_mgmt_get_key (vno:1)

[6/26/96 public]

The first 4 tests above now pass for 1.2.2. The last 3 (Bin compat)
are vendor-specific tests and should not be run.



CR Number                     : 12998
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : cm
Short Description             : panic due to bad uniquifier in dcache entry
Reported Date                 : 8/2/95
Found in Baseline             : 1.0.3
Found Date                    : 8/2/95
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : file/cm/cm_dcache.c
Sensitivity                   : public

[8/2/95 public]

A panic with string "dcache hc" was observed.  The dcache entry in question
had -1 in the f.fid.Unique field.  From this we infer that there had earlier
been a race:

- Process A was in MarkBadSCache and setting an scp's Unique to -1.
- Process B was in GetDCache, and doing the sequence:
   (1) use scp's fid to compute dc hash function;
   (2) get dcp;
   (3) copy scp's fid to dcp's fid.
While B was sleeping in step (2), A did its thing.  So the dcp ended up with
a Unique of -1, but was hashed as if it had some other Unique.  Thus a later
call to FlushDCache could not find it on the hash chain that it should have
been on.

In the long term, there is a fundamental weakness in GetDCache, which is
repeatedly accessing the scp without having it locked.  This is addressed by
bug number 4863.

In the short term, we can eliminate this panic by fixing the dc hash function
to ignore the scp's Unique.  We likewise fix the dv hash function, which would
have the same problem.

More...

Delta bwl-db4865-constant-fid-in-getdcache 1.1

Note that another delta with this number was created, but then defuncted.
Our original plan was to change the hash functions to not use the uniquifier,
but it was pointed out that this would cause a serious performance problem
(the uniquifier was added to the hash functions for precisely this reason).
So instead, we modified GetDCache to use a local copy of the fid.  The basic
problem of using the scache entry's fid without locking the scache entry is
not addressed by this; see bug # 4863.

More...

This delta has been reviewed and a CM with this delta has been smoke-tested,
but the delta itself has not been tested.  The bug was found by heavy stress
during system test.

[8/3/95 public]

Delta: bwl-db4865-constant-fid-in-getdcache
Change: file/cm/cm_dcache.c from 4.346 to 4.352
*** file/cm/cm_dcache.c
--- 4.352	1994/01/20 21:18:52
***************
*** 672,677 ****
--- 672,678 ----
      long byteOffset;
  {
      long index, chunk;
+     afsFid fid;
      register struct cm_dcache *dcp;
      register long i;
  
***************
*** 684,695 ****
  	chunk = byteOffset;
      else
  	chunk = cm_chunk(byteOffset);
!     i = DC_CHASH(&scp->fid, chunk);		/* Hash on [fid, chunk] */
      lock_ObtainWrite(&cm_dcachelock);
    retry:
      for (index = cm_dchashTable[i]; index != DC_NULLIDX;) {
  	dcp = cm_GetDSlot(index, (struct cm_dcache *)0);
! 	if (!FidCmp(&dcp->f.fid, &scp->fid) && chunk == dcp->f.chunk) {
  	    lock_ReleaseWrite(&cm_dcachelock);
  	    break;		/* leaving refCount high for caller */
  	}
--- 685,697 ----
  	chunk = byteOffset;
      else
  	chunk = cm_chunk(byteOffset);
!     fid = scp->fid;			/* structure assignment */
!     i = DC_CHASH(&fid, chunk);	/* Hash on [fid, chunk] */
      lock_ObtainWrite(&cm_dcachelock);
    retry:
      for (index = cm_dchashTable[i]; index != DC_NULLIDX;) {
  	dcp = cm_GetDSlot(index, (struct cm_dcache *)0);
! 	if (!FidCmp(&dcp->f.fid, &fid) && chunk == dcp->f.chunk) {
  	    lock_ReleaseWrite(&cm_dcachelock);
  	    break;		/* leaving refCount high for caller */
  	}
***************
*** 739,745 ****
  	/* 
  	 * Fill in the newly-allocated dcache record. 
  	 */
! 	dcp->f.fid = scp->fid;
  	hones(dcp->f.versionNo);		/* invalid value */
  	hzero(dcp->f.tokenID);			/* invalid value */
  	dcp->f.chunk = chunk;
--- 741,747 ----
  	/* 
  	 * Fill in the newly-allocated dcache record. 
  	 */
! 	dcp->f.fid = fid;
  	hones(dcp->f.versionNo);		/* invalid value */
  	hzero(dcp->f.tokenID);			/* invalid value */
  	dcp->f.chunk = chunk;
***************
*** 750,756 ****
  	 */
  	dcp->f.hcNextp = cm_dchashTable[i];	
  	cm_dchashTable[i] = dcp->index;
! 	i = DC_VHASH(&scp->fid);
  	dcp->f.hvNextp = cm_dvhashTable[i];
  	cm_dvhashTable[i] = dcp->index;
  	dcp->f.states = 0;
--- 752,758 ----
  	 */
  	dcp->f.hcNextp = cm_dchashTable[i];	
  	cm_dchashTable[i] = dcp->index;
! 	i = DC_VHASH(&fid);
  	dcp->f.hvNextp = cm_dvhashTable[i];
  	cm_dvhashTable[i] = dcp->index;
  	dcp->f.states = 0;
***************
*** 795,800 ****
--- 797,803 ----
      long needed;	/* how many chunks we need */
      long code;
      long index;
+     afsFid fid;
      register struct cm_dcache *dcp;
  
      /* lock a global mutex indicating that we're trying to get one
***************
*** 804,809 ****
--- 807,813 ----
       * running under high load.
       */
      needed = last - first;
+     fid = scp->fid;
      lock_ObtainWrite(&cm_getdcachelock);
      lock_ObtainWrite(&cm_dcachelock);
      while (1) {
***************
*** 833,839 ****
  		    /* 
  		     * Fill in the newly-allocated dcache record. 
  		     */
! 		    dcp->f.fid = scp->fid;
  		    hones(dcp->f.versionNo);	/* invalid value */
  		    hzero(dcp->f.tokenID);	/* invalid value */
  		    dcp->f.chunk = i;
--- 837,843 ----
  		    /* 
  		     * Fill in the newly-allocated dcache record. 
  		     */
! 		    dcp->f.fid = fid;
  		    hones(dcp->f.versionNo);	/* invalid value */
  		    hzero(dcp->f.tokenID);	/* invalid value */
  		    dcp->f.chunk = i;
***************
*** 842,851 ****
  		    /* 
  		     * Now add to the two hash chains 
  		     */
! 		    index = DC_CHASH(&scp->fid, i);
  		    dcp->f.hcNextp = cm_dchashTable[index];
  		    cm_dchashTable[index] = dcp->index;
! 		    index = DC_VHASH(&scp->fid);	/* and per-file hash */
  		    dcp->f.hvNextp = cm_dvhashTable[index];
  		    cm_dvhashTable[index] = dcp->index;
  		    dcp->f.states = 0;
--- 846,855 ----
  		    /* 
  		     * Now add to the two hash chains 
  		     */
! 		    index = DC_CHASH(&fid, i);
  		    dcp->f.hcNextp = cm_dchashTable[index];
  		    cm_dchashTable[index] = dcp->index;
! 		    index = DC_VHASH(&fid);	/* and per-file hash */
  		    dcp->f.hvNextp = cm_dvhashTable[index];
  		    cm_dvhashTable[index] = dcp->index;
  		    dcp->f.states = 0;



CR Number                     : 12997
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : dfs
Subcomponent Name             : episode
Short Description             : panic in exec'ing from locally mounted Episode
Reported Date                 : 8/2/95
Found in Baseline             : 1.0.3
Found Date                    : 8/2/95
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : file/episode/vnops/efs_vnodeops.c
Sensitivity                   : public

[8/2/95 public]

From Transarc:

I did the following sequence on a Solaris machine:

 - (DFS exporting an Episode fileset)
   copy an executable into DFS
 - execute it
 - locally mount the fileset
 - try to execute the same executable via the local path

There was a panic.  The problem was traceable to the fact that the vnode of
the executable had a null v_vfsp field.  This in turn was because, when
efs_lookup gets a vnode from the dnlc, it doesn't update the vnode's v_vfsp;
thus, vnodes that are created by the exporter and put into the dnlc, and
then retrieved from the dnlc on behalf of the local user, don't have proper
vfs pointers as they would if they had been created on behalf of the local
user (or if they had not been in the dnlc).

This is a Sun-only bug since our other platforms have only stubs for the
dnlc calls.  It should be applicable to the Solaris 2.2 release as well as
the Solaris 2.3 release that I am currently testing.

More....

Delta bwl-db4850-update-vfsp 1.1.

The validation procedure is as suggested in the bug description:
  - run an executable in DFS;
  - mount the fileset locally and immediately run the same executable via
      the local path.
If the second step causes a panic, you lose.

[8/3/95 public]

Delta: bwl-db4850-update-vfsp
Change: file/episode/vnops/efs_vnodeops.c from 4.609 to 4.614
*** file/episode/vnops/efs_vnodeops.c
--- 4.614	1994/01/18 21:14:04
***************
*** 49,55 ****
  #endif /* !KERNEL */
  
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012997,v 1.3 96/01/23 13:36:57 root Exp $")
  
  /*
   * We follow the conventions of the original Sun vfs/vnode interface:
--- 49,55 ----
  #endif /* !KERNEL */
  
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012997,v 1.3 96/01/23 13:36:57 root Exp $")
  
  /*
   * We follow the conventions of the original Sun vfs/vnode interface:
***************
*** 855,865 ****
--- 855,867 ----
      struct epif_status fstat;		/* file status for access checking */
      epi_volFileId_t efid;		/* fid for entry */
      struct evnode *devp;		/* directory evnode */
+     struct osi_vfs *vfsp;		/* vfs pointer of devp */
      struct evnode *evp = NULL;		/* entry vnode */
      struct vnode *vp;
  
      devp = VTOEV(dvp);
      EV_DEPHANTOM (devp);
+     vfsp = EVTOVFSP (devp);
  
      /* Sanity check -- is vnode a directory? */
      if (!EV_ISDIR (devp)) {
***************
*** 912,917 ****
--- 914,921 ----
      vp = osi_dnlc_lookup(dvp, name);
      if (vp != NULL) {
  	evp = VTOEV(vp);
+ 	if (!EPI_ISNULLVFSP (vfsp))
+ 	    osi_vSetVfsp(vp, vfsp);
  	goto out1;
      }
  
***************
*** 934,940 ****
      }
  
      /* Turn the fid into a vnode */
!     code = vnm_FindVnode (&efid, devp->vd_volp, EVTOVFSP (devp), &evp);
      if (code) {
  	icl_Trace4(efs_iclSet, EFS_TRACE_LOOKUP_FIDTOVNODE,
  		   ICL_TYPE_LONG, efid.index,
--- 938,944 ----
      }
  
      /* Turn the fid into a vnode */
!     code = vnm_FindVnode (&efid, devp->vd_volp, vfsp, &evp);
      if (code) {
  	icl_Trace4(efs_iclSet, EFS_TRACE_LOOKUP_FIDTOVNODE,
  		   ICL_TYPE_LONG, efid.index,



CR Number                     : 12996
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : dfsbind
Short Description             : dfsbind core dumped
Reported Date                 : 8/2/95
Found in Baseline             : 1.0.3
Found Date                    : 8/2/95
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : auth_helper.c
Sensitivity                   : public

[8/2/95 public]

From Transarc:

SYNOPSIS: dfsbind core dumped.

Well I have cranked  a 3 machine cell.

Reckless server
montana, and testlab22 are client and file exprtest

I I was able to access dfs from all machines in the cell.   Then I got
a connection time out for /: on monatan.   A few minutes later I got a
connecttion time out on testlab22.   At this point I was still able to
access dfs on reckless.  Then a few minutes later DFSBIND core dumped.

More ....

here's the DBX data.

detected a multithreaded program
t@11 (l@4) terminated by signal SEGV (no mapping at the fault address)
(dbx) where
=>[1] strcmp(0xffdba0d4, 0x245f2c, 0x1b6214, 0x0, 0x41fffff8, 0x2f2e2e2e), at 0x
ef256194
  [2] find_context_cache(pag = 1107296248, server = 0x245f2c "/.../reckless.dce.
transarc.com/hosts/reckless/dfs-server"), line 294 in "/afs/transarc.com/project
/alpine/dev/rel/09.028/src/security/helper/auth_helper.c"
  [3] get_context_from_pag(pag = 1107296248, euid = 0, server = 0x245f2c "/.../r
eckless.dce.transarc.com/hosts/reckless/dfs-server", login_context = 0xee9bdb58,
 st = 0xee9bdb6c), line 456 in "/afs/transarc.com/project/alpine/dev/rel/09.028/
src/security/helper/auth_helper.c"
  [4] cred_from_cred_rep(credrep = 0xee9bdbe4, cred = 0xee9bdbfc, cred_context =
 0xee9bdbe0, cache_slot = 0xee9bdbdc), line 617 in "/afs/transarc.com/project/al
pine/dev/rel/09.028/src/security/helper/auth_helper.c"
  [5] handle_sec_krb_get_cred(inptr = 0x245f6d "/dfs-server", inlen = 81, outbuf
 = 0x246f1c ""), line 749 in "/afs/transarc.com/project/alpine/dev/rel/09.028/sr
c/security/helper/auth_helper.c"
  [6] do_auth_request(inptr = 0x245f20 x", inlen = 81, outbuf = 0x246f1c "", out
size = 0x245f0c), line 1043 in "/afs/transarc.com/project/alpine/dev/rel/09.028/
src/security/helper/auth_helper.c"
  [7] ProcessRequest(req = 0x245f04), line 386 in "/afs/transarc.com/project/alp
ine/dev/rel/09.028/src/file/dfsbind/main_helper.c"
  [8] service_thread(addr = 0x1b4f70), line 280 in "/afs/transarc.com/project/al
pine/dev/rel/09.028/src/file/dfsbind/main_helper.c"
  [9] myStartRoutine(tcb = 0x250070), line 1135 in "/afs/transarc.com/project/al
pine/dev/rel/09.028/src/sol_pth/pthread.c"
  [10] _thread_start(0x250070, 0x0, 0x0, 0x0, 0x0, 0x0), at 0xef2dd68c
(dbx) down
dbx: Already at the bottom call level
(dbx) up
Current function is find_context_cache
  294               (context_cache[i].discard == 0)) {
(dbx) print server
server = 0x245f2c "/.../reckless.dce.transarc.com/hosts/reckless/dfs-server"
(dbx) print i
i = 1
(dbx) print context_cache[0]
context_cache[0] = {
    pag            = 4294967295
    euid           = 0
    refcount       = '\0'
    valid          = '^A'
    cred_valid     = '^A'
    discard        = '\0'
    context        = 0x25dd60
    credrep        = {
        pag         = 4294967295
        euid        = 0
        server_name = 0x268050 "/.../reckless.dce.transarc.com/hosts/reckless/df
s-server"
        authn_level = 4
        authz_proto = 2
        expiration  = 758397534
    }
    cred           = 0x268298
    tstamp         = 11
    cc_entry_mutex = 0x200b00
}
(dbx) print context_cache[1]
context_cache[1] = {
    pag            = 1107296248
    euid           = 5083
    refcount       = '\0'
    valid          = '\0'
    cred_valid     = '\0'
    discard        = '\0'
    context        = (nil)
    credrep        = {
        pag         = 1107296248
        euid        = 5083
        server_name = (nil)
        authn_level = 4
        authz_proto = 2
        expiration  = 758398043
    }
    cred           = (nil)
    tstamp         = 14
    cc_entry_mutex = 0x200f50
}
(dbx)

Delta: cfe-4842-dfsbind-coredump-on-namemanip 1.2

[8/3/95 public]

RCS file: RCS/auth_helper.c,v
retrieving revision 9.5
retrieving revision 9.7
diff -c -r9.5 -r9.7
*** /tmp/,RCSt1a15980	Thu Aug  3 12:45:14 1995
--- /tmp/,RCSt2a15980	Thu Aug  3 12:45:15 1995
***************
*** 2,7 ****
--- 2,28 ----
   * @TRANSARC_COPYRIGHT@
   *
   * $TALog: auth_helper.c,v $
+  * Revision 9.6  1994/01/12  20:29:28  cfe
+  * Core dump from passing a null to strcmp()
+  *
+  * Looks like it's because it was calling strcmp() before checking whether a
+  * local context was supposed to be valid or not.
+  * [from r9.5 by delta cfe-4842-dfsbind-coredump-on-namemanip, r1.1]
+  *
+  * Revision 9.5  1993/12/25  05:20:25  bww
+  * Picked up dfsbind memory leak workaround (OT9619).
+  *
+  * Modified find_context_cache() and add_context_cache()
+  * to check for a matching PAG and server as the criteria
+  * for a cache hit rather than just PAG alone.  This reduces
+  * the number of times we need to import the login context,
+  * and taking this code path less often seems to have the
+  * effect of reducing the rate at which dfsbind consumes memory.
+  *
+  * Note that there is still some growth in dfsbind, however it
+  * is about half the rate.
+  * [from r9.4 by delta bww-ot9619-sec-dfsbind-leak, r1.1]
+  *
   * Revision 9.4  1993/11/04  14:37:46  travis
   *   Change the array index variable to be the loop counter,
   *   not an incorrect variable which is known to be equal to -1.
***************
*** 22,28 ****
   */
  
  #if !defined(_NOIDENT) && !defined(lint)
! static char *TARCSId = "$Id: c012996,v 1.3 95/12/21 16:12:17 root Exp $";
  #endif
  
  /*
--- 43,49 ----
   */
  
  #if !defined(_NOIDENT) && !defined(lint)
! static char *TARCSId = "$Id: c012996,v 1.3 95/12/21 16:12:17 root Exp $";
  #endif
  
  /*
***************
*** 35,54 ****
  /*
   * HISTORY
   * $Log:	c012996,v $
# Revision 1.3  95/12/21  16:12:17  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company  
# 
# Revision 1.2  95/08/03  17:52:25  root
# changed fields:  new/changed/deleted note(s) [biyani 8/3/95 public]
# 
!  * Revision 9.5  93/12/25  05:20:25  bww
!  * Picked up dfsbind memory leak workaround (OT9619).
   * 
-  * Modified find_context_cache() and add_context_cache()
-  * to check for a matching PAG and server as the criteria
-  * for a cache hit rather than just PAG alone.  This reduces
-  * the number of times we need to import the login context,
-  * and taking this code path less often seems to have the
-  * effect of reducing the rate at which dfsbind consumes memory.
-  * 
-  * Note that there is still some growth in dfsbind, however it
-  * is about half the rate.
-  * [from r9.4 by delta bww-ot9619-sec-dfsbind-leak, r1.1]
-  * 
   * Revision 1.1.6.3  1993/06/02  21:22:29  delgado
   * 	The new auth_helper from IBM
   * 	[1993/06/02  21:21:29  delgado]
--- 56,65 ----
  /*
   * HISTORY
   * $Log:	c012996,v $
# Revision 1.3  95/12/21  16:12:17  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company  
# 
# Revision 1.2  95/08/03  17:52:25  root
# changed fields:  new/changed/deleted note(s) [biyani 8/3/95 public]
# 
!  * Revision 9.7  94/01/13  14:59:33  cfe
!  * Not done yet--more checks on the strcmp() args necessary.
!  * [from r9.6 by delta cfe-4842-dfsbind-coredump-on-namemanip, r1.2]
   * 
   * Revision 1.1.6.3  1993/06/02  21:22:29  delgado
   * 	The new auth_helper from IBM
   * 	[1993/06/02  21:21:29  delgado]
***************
*** 288,297 ****
      LOCK_CACHE();
      tstamp++;
      for (i=0; i<CCSIZE; i++) {
!         if ((context_cache[i].pag == pag) && 
!             (strcmp(context_cache[i].credrep.server_name, server) == 0) &&
! 	    (context_cache[i].valid) &&
! 	    (context_cache[i].discard == 0)) {
  	    if (context_cache[i].refcount < 0) {
  		dprintf("bogus refcount in context_cache!\n");
  		abort();
--- 299,310 ----
      LOCK_CACHE();
      tstamp++;
      for (i=0; i<CCSIZE; i++) {
!             if ((context_cache[i].pag == pag) &&
!                  (context_cache[i].valid) &&
!                  (context_cache[i].discard == 0) && 
!                  (context_cache[i].cred_valid) &&
!                  (context_cache[i].credrep.server_name != NULL) &&
!                  (strcmp(context_cache[i].credrep.server_name, server) == 0)) {
  	    if (context_cache[i].refcount < 0) {
  		dprintf("bogus refcount in context_cache!\n");
  		abort();
***************
*** 335,343 ****
      for (i=0; i<CCSIZE; i++) {
  	/* Check to see if entry has already been added. */
          if ((context_cache[i].pag == pag) &&
-             (strcmp(context_cache[i].credrep.server_name, server) == 0) &&
  	    (context_cache[i].valid) &&
! 	    (context_cache[i].discard == 0)) {
              if (context_cache[i].refcount < 0) {
                  dprintf("bogus refcount in context_cache!\n");
                  abort();
--- 348,358 ----
      for (i=0; i<CCSIZE; i++) {
  	/* Check to see if entry has already been added. */
          if ((context_cache[i].pag == pag) &&
  	    (context_cache[i].valid) &&
! 	    (context_cache[i].discard == 0) &&
!                  (context_cache[i].cred_valid) &&
!                  (context_cache[i].credrep.server_name != NULL) &&
!             (strcmp(context_cache[i].credrep.server_name, server) == 0)) {
              if (context_cache[i].refcount < 0) {
                  dprintf("bogus refcount in context_cache!\n");
                  abort();



CR Number                     : 12995
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : cm
Short Description             : cthon test8 fails with fileset move
Reported Date                 : 8/2/95
Found in Baseline             : 1.0.3
Found Date                    : 8/2/95
Severity                      : B
Priority                      : 3
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : file/ftutil/ftu_dumpops.h
Sensitivity                   : public

[8/2/95 public]

From Transarc:

Got errors like the following when running connectathon test8, which
deals in lots of symlink/readlink calls, and moving the fileset:

/afs/transarc.com/usr/cfe/logs/test8: symlink and readlink
dfs: fileset (0,,119) is busy with code 691089510 on server 158.98.7.36 in cell
hoosh.dce.transarc.com.
        /afs/transarc.com/usr/cfe/logs/test8: readlink file.3 returned bad linkn
ame (/this/is/a/symlink7 instead of /this/is/a/symlink3)


More.....

The problem turned out to be that (vnode,unique) pairs were getting re-used
and that the CM thought that symlink data was immutable.  The v,u pairs
were re-used because dump/restore wasn't saving and restoring any kind of
uniquifier-generator, so Episode uniquifiers were starting out at 1 after
every restoration.

Thus, the following scenario showed the failure:
        - move a fileset
        - create a symlink A with contents X
        - delete the symlink
        - move the fileset again
        - create a symlink B with contents Y
At this point, a readlink(B) call would return X, since files A and B shared
a vnode index (the first free one) and the uniquifier value (1).

The solution was to dump and restore a uniquifier-generator field, which
was conveniently already present in the vol_status structure (vol_dy.unique).

Delta: cfe-db4693-dump-and-restore-fileset-unique-counter

More.....

Regression test information:
- backed by build: dfs-103 3.38
- tests passed: fileset move of a running connectathon
- test configuration
        two LFS Solaris machines

[8/3/95 public]

Delta: cfe-db4693-dump-and-restore-fileset-unique-counter
Change: file/ftutil/dumpops.c from 1.34 to 1.39
*** file/ftutil/dumpops.c
--- 1.39	1993/11/16 20:16:57
***************
*** 31,37 ****
  #include "ftu_syscalls.h"
  #include "ftu_trace.h"
  
! RCSID("$Header: /project/ot/dce/d01/d29/RCS/c012995,v 1.3 96/01/23 13:38:49 root Exp $")
  
  struct aclHashEnt {
      struct aclHashEnt *next;
--- 31,37 ----
  #include "ftu_syscalls.h"
  #include "ftu_trace.h"
  
! RCSID("$Header: /project/ot/dce/d01/d29/RCS/c012995,v 1.3 96/01/23 13:38:49 root Exp $")
  
  struct aclHashEnt {
      struct aclHashEnt *next;
***************
*** 790,795 ****
--- 790,801 ----
      if (code = vols_DumpShortOpcode(pipeP, VOLS_DUMP_HEADER_INDEX_MAX, 4))
  	goto done;
      if (code = vols_DumpLong(pipeP, (u_long) volStatus.vol_dy.nodeMax))
+ 	goto done;
+ 
+     /* dump the fileset uniquifier */
+     if (code = vols_DumpShortOpcode(pipeP, VOLS_DUMP_HEADER_N_UNIQUEGEN, 4))
+ 	goto done;
+     if (code = vols_DumpLong(pipeP, (u_long) volStatus.vol_dy.unique))
  	goto done;
  
      /* dump the MOTD */
Delta: cfe-db4693-dump-and-restore-fileset-unique-counter
Change: file/ftutil/ftu_dumpops.h from 1.4 to 1.5
*** file/ftutil/ftu_dumpops.h
--- 1.5	1993/11/16 20:17:02
***************
*** 252,257 ****
--- 252,266 ----
   */
  #define VOLS_DUMP_HEADER_DUMP_DATE	0x114
  
+ /* 
+  * This new uniquifier-generator provides the data on which a filesystem can
+  * base the uniquifier portion of file IDs, in case it's generating entire
+  * vnode+unique pairs via some obscure encryption.  The data must be a
+  * multiple of 4 bytes in length.
+  * The older VOLS_DUMP_HEADER_UNIQUEGEN has been co-opted for other uses.
+  */
+ #define VOLS_DUMP_HEADER_N_UNIQUEGEN	0x115
+ 
  
  /* 
   * The next set of opcodes are found in the vnode area of a dump itself. The
Delta: cfe-db4693-dump-and-restore-fileset-unique-counter
Change: file/ftutil/restoreops.c from 1.22 to 1.28
*** file/ftutil/restoreops.c
--- 1.28	1993/11/16 20:17:07
***************
*** 24,30 ****
  #include "ftu_private.h"
  #include "ftu_syscalls.h"
  
! RCSID("$Header: /project/ot/dce/d01/d29/RCS/c012995,v 1.3 96/01/23 13:38:49 root Exp $")
  
  static int verbose = 0;
  
--- 24,30 ----
  #include "ftu_private.h"
  #include "ftu_syscalls.h"
  
! RCSID("$Header: /project/ot/dce/d01/d29/RCS/c012995,v 1.3 96/01/23 13:38:49 root Exp $")
  
  static int verbose = 0;
  
***************
*** 971,977 ****
       ftu_kaProc_t kaProc;
       void *kaArg;
  { 
!     long temp, i, minQuota, volOwner, maxNodeIx;
      struct afsHyper visLimit, allocLimit;
      struct afsHyper junkHyper;
      unsigned long codesetTag;
--- 971,977 ----
       ftu_kaProc_t kaProc;
       void *kaArg;
  { 
!     long temp, i, minQuota, volOwner, maxNodeIx, volUniqueGen;
      struct afsHyper visLimit, allocLimit;
      struct afsHyper junkHyper;
      unsigned long codesetTag;
***************
*** 1063,1068 ****
--- 1063,1087 ----
  			break;
  		}
  		break;
+ 	    case VOLS_DUMP_HEADER_N_UNIQUEGEN:
+ 		/* this opcode is followed by some number of longs, which are
+ 		 * to be passed into the virtual file system for its unique ID
+ 		 * generator, if it wants one.
+ 		 */
+ 		if (vopcode.f.s.length % 4) {
+ 		    Log("vols_RestoreNUnique: expected multiple of 4, not %u",
+ 			vopcode.f.s.length);
+ 		    code = FTU_E_BAD_DUMP;
+ 		    break;
+ 		}
+ 		for (i = (vopcode.f.s.length / 4); i > 0; --i) {
+ 		    if (code = vols_RestoreLong(afsPipeP, &volUniqueGen,
+ 						sizeof(volUniqueGen)))
+ 			break;
+ 		}
+ 		/* This implementation only really deals with a single long */
+ 		if (vopcode.f.s.length == 4) flags |= VOL_STAT_UNIQUE;
+ 		break;
  	    case VOLS_DUMP_HEADER_MOTD_CODESET:
  		code = vols_RestoreLong(afsPipeP, &codesetTag, vopcode.f.s.length);
  		break;
***************
*** 1163,1175 ****
  		     * restore from failing.  We'll reset them to their
  		     * intended values below.
  		     */
!                     if (flags & VOL_STAT_VISLIMIT) {
  			hset(vstatus.vol_dy.visQuotaLimit, ftu_unlimitedQuota);
!                         mask |= VOL_STAT_VISLIMIT;
!                     }
!                     if (flags & VOL_STAT_ALLOCLIMIT) {
  			hset(vstatus.vol_dy.allocLimit, ftu_unlimitedQuota);
!                         mask |= VOL_STAT_ALLOCLIMIT;
  		    }
  		    if (flags & VOL_STAT_NODEMAX) {
  			vstatus.vol_dy.nodeMax = maxNodeIx;
--- 1182,1194 ----
  		     * restore from failing.  We'll reset them to their
  		     * intended values below.
  		     */
! 		    if (flags & VOL_STAT_VISLIMIT) {
  			hset(vstatus.vol_dy.visQuotaLimit, ftu_unlimitedQuota);
! 			mask |= VOL_STAT_VISLIMIT;
! 		    }
! 		    if (flags & VOL_STAT_ALLOCLIMIT) {
  			hset(vstatus.vol_dy.allocLimit, ftu_unlimitedQuota);
! 			mask |= VOL_STAT_ALLOCLIMIT;
  		    }
  		    if (flags & VOL_STAT_NODEMAX) {
  			vstatus.vol_dy.nodeMax = maxNodeIx;
***************
*** 1328,1334 ****
  	if (flags & VOL_STAT_OWNER) {
  	    vstatus.vol_dy.owner = volOwner;
  	    mask |= VOL_STAT_OWNER;
!         }
  	code = VOL_SETSTATUS(fsetDesc, mask, &vstatus, 0);
  	if (verbose) {
  	    if (code != 0) printf("ftserver restore: VOL_SETSTATUS failed with %lu\n", code);
--- 1347,1357 ----
  	if (flags & VOL_STAT_OWNER) {
  	    vstatus.vol_dy.owner = volOwner;
  	    mask |= VOL_STAT_OWNER;
! 	}
! 	if (flags & VOL_STAT_UNIQUE) {
! 	    vstatus.vol_dy.unique = volUniqueGen;
! 	    mask |= VOL_STAT_UNIQUE;
! 	}
  	code = VOL_SETSTATUS(fsetDesc, mask, &vstatus, 0);
  	if (verbose) {
  	    if (code != 0) printf("ftserver restore: VOL_SETSTATUS failed with %lu\n", code);



CR Number                     : 12994
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : osi
Short Description             : global lock panic in osi_Alloc
Reported Date                 : 8/2/95
Found in Baseline             : 1.0.3
Found Date                    : 8/2/95
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : file/osi/osi_misc.c
Sensitivity                   : public

[8/2/95 public]

From Transarc:

In the recordkeeping function update_allocrec, called from osi_Alloc,
we may drop and reacquire the global lock while holding the osi_alloc_mutex.
If another thread acquires the global lock after we drop it and then
blocks trying to acquire osi_alloc_mutex, a deadlock will result.  SunOS
detects this and panics.

More....

Instead of using a bare mutex, we now use a standard "data lock",
since the lock_ObtainXXX functions know how to avoid global lock
troubles.

blake-db4569-osi_alloc_mutex-bug

[8/3/95 public]

Delta: blake-db4569-osi_alloc_mutex-bug
Change: file/osi/osi_misc.c from 4.60 to 4.62
*** file/osi/osi_misc.c
--- 4.62	1993/11/10 22:14:45
***************
*** 31,43 ****
  #endif
  #endif
  
! RCSID("$Header: /project/ot/dce/d01/d29/RCS/c012994,v 1.3 95/12/21 16:13:57 root Exp $")
  
  static long osi_memUsage = 0;
  static long osi_allocCnt = 0;
  static long osi_BuffersAlloced = 0;
  static struct osi_buffer *osi_freeBufferList = 0;
! static osi_mutex_t osi_alloc_mutex;
  
  static char memZero;		/* address of 0 bytes of memory for osi_Alloc */
  
--- 31,43 ----
  #endif
  #endif
  
! RCSID("$Header: /project/ot/dce/d01/d29/RCS/c012994,v 1.3 95/12/21 16:13:57 root Exp $")
  
  static long osi_memUsage = 0;
  static long osi_allocCnt = 0;
  static long osi_BuffersAlloced = 0;
  static struct osi_buffer *osi_freeBufferList = 0;
! static osi_dlock_t osi_alloc_mutex;
  
  static char memZero;		/* address of 0 bytes of memory for osi_Alloc */
  
***************
*** 233,242 ****
      size += sizeof (struct osimem);
  #endif
  
!     osi_mutex_enter(&osi_alloc_mutex);
      osi_allocCnt++;
      osi_memUsage += size;
!     osi_mutex_exit(&osi_alloc_mutex);
  
      p = (opaque) osi_kalloc(size);
  
--- 233,242 ----
      size += sizeof (struct osimem);
  #endif
  
!     lock_ObtainWrite(&osi_alloc_mutex);
      osi_allocCnt++;
      osi_memUsage += size;
!     lock_ReleaseWrite(&osi_alloc_mutex);
  
      p = (opaque) osi_kalloc(size);
  
***************
*** 249,259 ****
      tm->size = asize;
      tm->caller = osi_caller();
      hash = OSI_MEMHASH(p);
!     osi_mutex_enter(&osi_alloc_mutex);
      tm->next = osi_memhash[hash];
      osi_memhash[hash] = tm;
      update_allocrec(tm->caller, tm->size, 1);
!     osi_mutex_exit(&osi_alloc_mutex);
      return ((caddr_t)p + sizeof (struct osimem));
  #else	/* AFSDEBMEM */
      return p;
--- 249,259 ----
      tm->size = asize;
      tm->caller = osi_caller();
      hash = OSI_MEMHASH(p);
!     lock_ObtainWrite(&osi_alloc_mutex);
      tm->next = osi_memhash[hash];
      osi_memhash[hash] = tm;
      update_allocrec(tm->caller, tm->size, 1);
!     lock_ReleaseWrite(&osi_alloc_mutex);
      return ((caddr_t)p + sizeof (struct osimem));
  #else	/* AFSDEBMEM */
      return p;
***************
*** 282,288 ****
  #ifdef	AFSDEBMEM
      tm = (struct osimem *)((caddr_t)p - sizeof (struct osimem));
      lm = &osi_memhash[OSI_MEMHASH(tm)];
!     osi_mutex_enter(&osi_alloc_mutex);
      um = *lm;
      while (um != NULL && um != tm) {
  	lm = &um->next;
--- 282,288 ----
  #ifdef	AFSDEBMEM
      tm = (struct osimem *)((caddr_t)p - sizeof (struct osimem));
      lm = &osi_memhash[OSI_MEMHASH(tm)];
!     lock_ObtainWrite(&osi_alloc_mutex);
      um = *lm;
      while (um != NULL && um != tm) {
  	lm = &um->next;
***************
*** 296,312 ****
  	 p, asize, called_from, um->size, um->caller));
      *lm = tm->next;
      update_allocrec(tm->caller, tm->size, 0);
!     osi_mutex_exit(&osi_alloc_mutex);
      size += sizeof (struct osimem);
      p = (opaque)tm;
      for (q = (char *)p; q != (char *)p + size; q++)
  	*q = (char) -1;
  
  #endif /* AFSDEBMEM */
!     osi_mutex_enter(&osi_alloc_mutex);
      osi_allocCnt--;
      osi_memUsage -= size;
!     osi_mutex_exit(&osi_alloc_mutex);
      osi_kfree(p, size);
  }
  
--- 296,312 ----
  	 p, asize, called_from, um->size, um->caller));
      *lm = tm->next;
      update_allocrec(tm->caller, tm->size, 0);
!     lock_ReleaseWrite(&osi_alloc_mutex);
      size += sizeof (struct osimem);
      p = (opaque)tm;
      for (q = (char *)p; q != (char *)p + size; q++)
  	*q = (char) -1;
  
  #endif /* AFSDEBMEM */
!     lock_ObtainWrite(&osi_alloc_mutex);
      osi_allocCnt--;
      osi_memUsage -= size;
!     lock_ReleaseWrite(&osi_alloc_mutex);
      osi_kfree(p, size);
  }



CR Number                     : 12991
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : episode
Short Description             : Turn off support for all but 8k/1k filesystems
Reported Date                 : 8/2/95
Found in Baseline             : 1.0.3
Found Date                    : 8/2/95
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : file/episode/anode/newaggr.c
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[8/2/95 public]

From Transarc:

Disable the ability to create anything but 8k/1k aggregates. This presumably
affects newaggr. Any other tools or implications need to be identified.

NOTE:
This should NOT be done by using the AFSDEBUG ifdef. The implementation may
be via ifdef or may be done so that the feature can be re-enabled via adb.
The AFSDEBUG ifdef will most likely remain turned on for shipped code, so
it should not be used to disable this feature.

More...

We decided that it would be good enough to have newaggr print a
warning if the user picked numbers other than 8192 and 1024 as the
block and fragment sizes.  A higher level script, configAggr, will
always use 8192 and 1024 without giving the user a choice.

More...

I newaggr'd a partition with 4k/4k, and sure enough, it printed a
warning.

[8/3/95 public]

Delta: jdp-db4382-have-newaggr-warn-about-unsupported-sizes
Change: file/episode/anode/newaggr.c from 4.49 to 4.55
*** file/episode/anode/newaggr.c
--- 4.55        1993/10/07 18:53:07
***************
*** 55,61 ****
  
  #include <errno.h>
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012991,v 1.4 95/12/21 15:55:13 root Exp $")
  
  static long arg_BlkSize;
  static long arg_FragSize;
--- 55,61 ----
  
  #include <errno.h>
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012991,v 1.4 95/12/21 15:55:13 root Exp $")
  
  static long arg_BlkSize;
  static long arg_FragSize;
***************
*** 184,189 ****
--- 184,193 ----
                    "Episode fragment size (%ld) must be at least 1k (%ld).\n",
                    fragSize, 1024);
            ++Problems;
+       }
+       if (blkSize != 8192 || fragSize != 1024) {
+           fprintf(stderr,
+                   "Warning: The only supported block size/fragment size combination is 8k/1k.\n");
        }
      }

[8/7/95 public]
Just a comment on this one... IBM has been shipping DCE LFS for
several years now with multiple block and frag sizes enabled. We
have done some testing with various sizes (although not as extensive
as we would like), and have customers using multiple block and frag
sizes successfully. We prefer leaving this flexibility in LFS to
allow customers to tailor their filesystems to the type of data
they have.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'



CR Number                     : 12990
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : episode
Short Description             : Treat network root same as local root
Reported Date                 : 8/2/95
Found in Baseline             : 1.0.3
Found Date                    : 8/2/95
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : file/episode/vnops/efs_access.c
Sensitivity                   : public

[8/2/95 public]

From Transarc:

After much discussion, we've decided that the proper approach to the "tar"
problem is to have Episode treat network root as a fully privileged account,
just like "local root" is treated.

There was also discussion about having a user interface for disabling this
behavior on a fileset-by-fileset basis, but this bug *does* not cover
that new feature.  This bug describes simply changing the default behavior
for the interpretation of "network root" from "unprivileged" to "privileged."

More ....:

This has been tested on a 103 3.31+ configuration.
I have tried various operations manually to ensure that the network
root can perform all operations(read, write, change modes, owner, group,
ACLS) on objects that it has no explicit permissions for. I can
now untar a tar file containing a 444 protected dir with files.

I also ran the ACL tests to serve as a regression test and tried
various operations manually to ensure that cell_admin and regular
users have not suffered any regressions.

[8/3/95 public]

Delta: rajesh-db3983-treat-network-root-as-superuser
Change: file/episode/vnops/Makefile from 4.51 to 4.52
*** file/episode/vnops/Makefile
--- 4.52	1993/09/19 01:47:30
***************
*** 236,241 ****
--- 236,249 ----
  # $EndLog$
  #
  
+ #
+ # NOTE - NETWORK ROOT ACCESS RIGHTS	
+ #
+ # By default, a network root now is a superuser.
+ # To turn this off, set CFLAGS to include "-DNETWORK_ROOT_NOT_SUPERUSER"
+ # in this Makefile or in the top level makefile. 
+ #
+ 
  INCLUDES		= efs_opcode.h efsmount.h efs_debug.h efs_trace.h
  PROGRAMS		= newvol growaggr test_vnodeops
  LIBRARIES		= libefsops.a
Delta: rajesh-db3983-treat-network-root-as-superuser
Change: file/episode/vnops/efs_access.c from 4.70 to 4.72
*** file/episode/vnops/efs_access.c
--- 4.72	1993/09/19 01:47:31
***************
*** 294,300 ****
  #include "efs_misc.h"
  #include "efs_access.h"
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012990,v 1.3 95/12/21 15:53:04 root Exp $")
  
  extern int afsdb_episode_vnops;        /* the trace control variable */
  #define DEBUG_THIS_FILE EFS_DEBUG_ACCESS
--- 294,300 ----
  #include "efs_misc.h"
  #include "efs_access.h"
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012990,v 1.3 95/12/21 15:53:04 root Exp $")
  
  extern int afsdb_episode_vnops;        /* the trace control variable */
  #define DEBUG_THIS_FILE EFS_DEBUG_ACCESS
***************
*** 504,510 ****
--- 504,514 ----
      epi_principal_id_t groupObj;	/* GROUP_OBJ principal */
      dacl_t * aclP;			/* ACL structure */
      epi_uuid_t sysAdminGroupID;		/* privileged ID */
+     epi_uuid_t localCellID;
+ 
+     dacl_GetLocalCellID((afsUUID*)&localCellID);
  
+     bzero((caddr_t)&pac, sizeof(sec_id_pac_t));
      pacP = &pac;
      pacP->groups = groups;
      pacP->num_foreign_groups = 0;
***************
*** 512,520 ****
      dacl_FindPac (credP, &pacP);
  
      /*
!      * We don't check for local super-user, since we are called only on behalf
!      * of remote users.
!      *
       * If there is an ACL, the DACL package will check for system
       * administrator.  If there is no ACL, this function will check.
       */
--- 516,538 ----
      dacl_FindPac (credP, &pacP);
  
      /*
!      * The following comment is a modified form of an earlier comment.
!      * We should only reach here if we are called on behalf of remote users.
!      */
! 
! #ifndef NETWORK_ROOT_NOT_SUPERUSER
!      /* Check for network root */
!     if (pacP->authenticated && 
! 	(bcmp((char *) &pacP->realm.uuid, (char *) &localCellID, 
! 	      sizeof (epi_uuid_t)) == 0) &&
! 	(osi_GetUID(credP) == 0)) {
! 	*permP = dacl_perm_control | dacl_perm_read | dacl_perm_execute |
! 	    dacl_perm_write |dacl_perm_insert | dacl_perm_delete;
!     } 
!     return 0;
! #endif
! 
!     /*
       * If there is an ACL, the DACL package will check for system
       * administrator.  If there is no ACL, this function will check.
       */
***************
*** 559,573 ****
  	    }
  	return code;
      } else {				/* File does not have an ACL */
- 	epi_uuid_t localCellID;
- 
  	*permP = 0;
  
  	/* No bits set for unauthenticated principal */
  	if (!(pacP->authenticated)) return 0;
  
  	/* First set Unix standard access bits, plus C if we are owner */
- 	dacl_GetLocalCellID((afsUUID*)&localCellID);
  
  	/* 
  	 * Requests from a different cell receive no rights in the null ACL
--- 577,588 ----
***************
*** 579,584 ****
--- 594,600 ----
  	    sizeof (epi_uuid_t)) != 0) {
  	    return 0;
  	}
+ 
  	if (Epi_PrinId_Cmp (&pacP->principal.uuid, &fstatP->oid) == 0) {
  	    *permP |= dacl_perm_control;
  	    bits = fstatP->mode & 0700;
***************
*** 644,649 ****
--- 660,666 ----
      epi_principal_id_t userObj;		/* USER_OBJ principal */
      epi_principal_id_t groupObj;	/* GROUP_OBJ principal */
      dacl_t * aclP;			/* ACL structure */
+     epi_uuid_t localCellID;
  
      if (aperm & dacl_perm_write) {
  	/*
***************
*** 663,685 ****
  #endif /* AFS_SUNOS5_ENV, AFS_AIX31_ENV */
      }
  
      /*
       * Pull out the caller's PAC information before doing the
       * true access check.
       */
      pacP = &pac;
      pacP->groups = groups;
      pacP->num_foreign_groups = 0;
      pacP->foreign_groups = (sec_id_foreign_t *) 0;
      dacl_FindPac (aucredP, &pacP);
  
      if (pacP == &pac) {			/* If called on behalf of local user */
- 	/*
- 	 * Check for local superuser
- 	 */
  	if (osi_GetUID(aucredP) == 0)
  	    return(0);
      }
  
      /*
       * We don't check for system administrator, since aperm can be
--- 680,715 ----
  #endif /* AFS_SUNOS5_ENV, AFS_AIX31_ENV */
      }
  
+     dacl_GetLocalCellID((afsUUID*)&localCellID);
+ 
      /*
       * Pull out the caller's PAC information before doing the
       * true access check.
       */
+     bzero((caddr_t)&pac, sizeof(sec_id_pac_t));
      pacP = &pac;
      pacP->groups = groups;
      pacP->num_foreign_groups = 0;
      pacP->foreign_groups = (sec_id_foreign_t *) 0;
      dacl_FindPac (aucredP, &pacP);
  
+     /*
+      * Check for superuser 
+      *   local always
+      *   network root if NETWORK_ROOT_NOT_SUPERUSER macro not defined
+      */
      if (pacP == &pac) {			/* If called on behalf of local user */
  	if (osi_GetUID(aucredP) == 0)
  	    return(0);
+     } 
+ #ifndef NETWORK_ROOT_NOT_SUPERUSER
+     else if (pacP->authenticated && 
+ 	     (bcmp((char *) &pacP->realm.uuid, (char *) &localCellID, 
+ 		   sizeof (epi_uuid_t)) == 0) &&
+ 	     (osi_GetUID(aucredP) == 0)) {
+ 	return(0);
      }
+ #endif
  
      /*
       * We don't check for system administrator, since aperm can be
***************
*** 729,735 ****
  		    code = EIO;
  	    }
      } else {				/* File does not have an ACL */
- 	epi_uuid_t localCellID;
  
  	/*
  	 * ** TO DO ** What are the semantics of not having an ACL?
--- 759,764 ----
***************
*** 741,747 ****
  
  	bits = 0;
  	dacl_OnePermsetToPermBits (aperm, &bits);
- 	dacl_GetLocalCellID((afsUUID*)&localCellID);
  
  	/* 
  	 * Requests from a different cell are denied access in the null ACL
--- 770,775 ----
***************
*** 858,882 ****
      int code;				/* error return code */
      dacl_permset_t perm;		/* Temporary permset */
      epi_uuid_t sysAdminGroupID;		/* privilaged ID */
  
      pacP = &pac;
      pacP->groups = groups;
      pacP->num_foreign_groups = 0;
      pacP->foreign_groups = (sec_id_foreign_t *) 0;
      dacl_FindPac (cred, &pacP);
  
!     if (pacP == &pac) {			/* If called on behalf of local user */
! 	/*
! 	 * Check for local superuser
! 	 */
  	if (osi_GetUID(cred) == 0) {
  	    *issuperP = 1;
  	    *ingroupsP = 1;
  	    return(0);
  	}
!     } else {				/* If called on behalf of remote user */
  	/*
! 	 * Check for system administrator
  	 */
  	dacl_GetSysAdminGroupID((afsUUID*)&sysAdminGroupID);
  	if (vnax_GroupInPAC((epi_principal_id_t *)&sysAdminGroupID, pacP)) {
--- 886,926 ----
      int code;				/* error return code */
      dacl_permset_t perm;		/* Temporary permset */
      epi_uuid_t sysAdminGroupID;		/* privilaged ID */
+     epi_uuid_t localCellID;
+ 
+     dacl_GetLocalCellID((afsUUID*)&localCellID);
  
+     bzero((caddr_t)&pac, sizeof(sec_id_pac_t));
      pacP = &pac;
      pacP->groups = groups;
      pacP->num_foreign_groups = 0;
      pacP->foreign_groups = (sec_id_foreign_t *) 0;
      dacl_FindPac (cred, &pacP);
  
!     /*
!      * Check for superuser 
!      *   local always
!      *   network root if NETWORK_ROOT_NOT_SUPERUSER macro not defined
!      */
!     if (pacP == &pac) {		/* If called on behalf of local user */
  	if (osi_GetUID(cred) == 0) {
  	    *issuperP = 1;
  	    *ingroupsP = 1;
  	    return(0);
  	}
!     } else {                    /* If called on behalf of remote user */
! #ifndef NETWORK_ROOT_NOT_SUPERUSER
! 	if (pacP->authenticated && 
! 	    (bcmp((char *) &pacP->realm.uuid, (char *) &localCellID, 
! 		  sizeof (epi_uuid_t)) == 0) &&
! 	    (osi_GetUID(cred) == 0)) {
! 	    *issuperP = 1;
! 	    *ingroupsP = 1;
! 	    return(0);
! 	}
! #endif
  	/*
! 	 * Check for network system administrator
  	 */
  	dacl_GetSysAdminGroupID((afsUUID*)&sysAdminGroupID);
  	if (vnax_GroupInPAC((epi_principal_id_t *)&sysAdminGroupID, pacP)) {
***************
*** 884,890 ****
  	    *ingroupsP = 1;
  	    return(0);
  	}
!     }
  
      /*
       * If there is an ACL, the DACL package will check for system
--- 928,934 ----
  	    *ingroupsP = 1;
  	    return(0);
  	}
!      }
  
      /*
       * If there is an ACL, the DACL package will check for system
Delta: rajesh-db3983-treat-network-root-as-superuser
Change: file/episode/vnops/Makefile from 4.52 to 4.53
*** file/episode/vnops/Makefile
--- 4.53	1993/09/22 11:33:08
***************
*** 239,247 ****
  #
  # NOTE - NETWORK ROOT ACCESS RIGHTS	
  #
! # By default, a network root now is a superuser.
! # To turn this off, set CFLAGS to include "-DNETWORK_ROOT_NOT_SUPERUSER"
! # in this Makefile or in the top level makefile. 
  #
  
  INCLUDES		= efs_opcode.h efsmount.h efs_debug.h efs_trace.h
--- 239,251 ----
  #
  # NOTE - NETWORK ROOT ACCESS RIGHTS	
  #
! # By default, a network root now is a superuser. This can be turned off
! # at runtime by setting kernel global variable efs_networkRootSuperUser 
! # to zero.
! #
! # To turn off availability of this feature, set CFLAGS to include
! # "-DNETWORK_ROOT_NOT_SUPERUSER" in this Makefile or in the top level
! #  makefile. 
  #
  
  INCLUDES		= efs_opcode.h efsmount.h efs_debug.h efs_trace.h
Delta: rajesh-db3983-treat-network-root-as-superuser
Change: file/episode/vnops/efs_access.c from 4.72 to 4.73
*** file/episode/vnops/efs_access.c
--- 4.73	1993/09/22 11:33:09
***************
*** 294,304 ****
  #include "efs_misc.h"
  #include "efs_access.h"
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012990,v 1.3 95/12/21 15:53:04 root Exp $")
  
  extern int afsdb_episode_vnops;        /* the trace control variable */
  #define DEBUG_THIS_FILE EFS_DEBUG_ACCESS
  
  static vnax_GroupInPAC(epi_principal_id_t * agroup, sec_id_pac_t *apacP);
  static vnax_GidInPAC(u_long * agidP, sec_id_pac_t * apacP);
  
--- 294,312 ----
  #include "efs_misc.h"
  #include "efs_access.h"
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012990,v 1.3 95/12/21 15:53:04 root Exp $")
  
  extern int afsdb_episode_vnops;        /* the trace control variable */
  #define DEBUG_THIS_FILE EFS_DEBUG_ACCESS
  
+ /* Provide means of turning off superuser privileges for network root
+  * under the control of a kernel variable efs_networkRootSuperUser. Turn
+  * this feature on by default.
+  */
+ #ifndef NETWORK_ROOT_NOT_SUPERUSER
+ int efs_networkRootSuperUser = 1;
+ #endif
+ 
  static vnax_GroupInPAC(epi_principal_id_t * agroup, sec_id_pac_t *apacP);
  static vnax_GidInPAC(u_long * agidP, sec_id_pac_t * apacP);
  
***************
*** 522,535 ****
  
  #ifndef NETWORK_ROOT_NOT_SUPERUSER
       /* Check for network root */
!     if (pacP->authenticated && 
  	(bcmp((char *) &pacP->realm.uuid, (char *) &localCellID, 
  	      sizeof (epi_uuid_t)) == 0) &&
  	(osi_GetUID(credP) == 0)) {
  	*permP = dacl_perm_control | dacl_perm_read | dacl_perm_execute |
  	    dacl_perm_write |dacl_perm_insert | dacl_perm_delete;
      } 
-     return 0;
  #endif
  
      /*
--- 530,544 ----
  
  #ifndef NETWORK_ROOT_NOT_SUPERUSER
       /* Check for network root */
!     if (efs_networkRootSuperUser &&
! 	pacP->authenticated && 
  	(bcmp((char *) &pacP->realm.uuid, (char *) &localCellID, 
  	      sizeof (epi_uuid_t)) == 0) &&
  	(osi_GetUID(credP) == 0)) {
  	*permP = dacl_perm_control | dacl_perm_read | dacl_perm_execute |
  	    dacl_perm_write |dacl_perm_insert | dacl_perm_delete;
+ 	return 0;
      } 
  #endif
  
      /*
***************
*** 703,709 ****
  	    return(0);
      } 
  #ifndef NETWORK_ROOT_NOT_SUPERUSER
!     else if (pacP->authenticated && 
  	     (bcmp((char *) &pacP->realm.uuid, (char *) &localCellID, 
  		   sizeof (epi_uuid_t)) == 0) &&
  	     (osi_GetUID(aucredP) == 0)) {
--- 712,719 ----
  	    return(0);
      } 
  #ifndef NETWORK_ROOT_NOT_SUPERUSER
!     else if (efs_networkRootSuperUser &&
! 	     pacP->authenticated && 
  	     (bcmp((char *) &pacP->realm.uuid, (char *) &localCellID, 
  		   sizeof (epi_uuid_t)) == 0) &&
  	     (osi_GetUID(aucredP) == 0)) {
***************
*** 910,916 ****
  	}
      } else {                    /* If called on behalf of remote user */
  #ifndef NETWORK_ROOT_NOT_SUPERUSER
! 	if (pacP->authenticated && 
  	    (bcmp((char *) &pacP->realm.uuid, (char *) &localCellID, 
  		  sizeof (epi_uuid_t)) == 0) &&
  	    (osi_GetUID(cred) == 0)) {
--- 920,927 ----
  	}
      } else {                    /* If called on behalf of remote user */
  #ifndef NETWORK_ROOT_NOT_SUPERUSER
! 	if (efs_networkRootSuperUser &&
! 	    pacP->authenticated && 
  	    (bcmp((char *) &pacP->realm.uuid, (char *) &localCellID, 
  		  sizeof (epi_uuid_t)) == 0) &&
  	    (osi_GetUID(cred) == 0)) {



CR Number                     : 12989
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : episode
Short Description             : Cache mtime/ctime in vnode
Reported Date                 : 8/2/95
Found in Baseline             : 1.0.3
Found Date                    : 8/2/95
Severity                      : B
Priority                      : 3
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : see below
Sensitivity                   : public

[8/2/95 public]

From Transarc:

The mtime and ctime should be cached in the vnode, as the atime is.  To insure
good crash semantics for the atime, we update the anode at sync, fsync,
unmount, recycle, and phantomize.  For mtime and ctime, we should update the
anode at all the same places, PLUS at stat (vnva_GetAttr) and in the strategy
code (efs_strategy).  The additional updates are because someone may be using
the mtime as a version number.

Delta bwl-3911-cache-mtime-ctime 1.2.
Make that 1.3.

[8/3/95 public]

Delta: bwl-3911-cache-mtime-ctime
Change: file/episode/vnops/RIOS/efs_aixvmm.c from 1.71 to 1.79
*** file/episode/vnops/RIOS/efs_aixvmm.c
--- 1.79	1994/03/16 19:44:29
***************
*** 294,300 ****
  				(VTOEV (vp))->vd_reservation.lastReserved,
  				credp);
  	efs_getlength(vp, &fileSize, &blockSize, credp);
! 	vnm_SetMCtime (VTOEV (vp), credp);
  	efs_unlock(vp);
  	if (fileSize & (PAGESIZE-1))
  	    vm_protectp(sid, fileSize >> PGSHIFT, 1, RDONLY);
--- 294,304 ----
  				(VTOEV (vp))->vd_reservation.lastReserved,
  				credp);
  	efs_getlength(vp, &fileSize, &blockSize, credp);
! 	vnm_SetMCtime (VTOEV (vp));
!         /* Clear SUID and SGID bits if necessary */
!         if (osi_GetUID (credp) != 0 &&
!             (epif_GetMode (EVTOA (VTOEV (vp))) & (VSUID | VSGID)))
!             vnm_ClearSUID (VTOEV (vp));
  	efs_unlock(vp);
  	if (fileSize & (PAGESIZE-1))
  	    vm_protectp(sid, fileSize >> PGSHIFT, 1, RDONLY);
Delta: bwl-3911-cache-mtime-ctime
Change: file/episode/vnops/SUNOS5/efs_sun5map.c from 1.10 to 1.12
*** file/episode/vnops/SUNOS5/efs_sun5map.c
--- 1.12	1994/03/16 19:44:38
***************
*** 219,225 ****
  
      /* Update mtime */
      if (!code)
! 	vnm_SetMCtime(evp, credp);
  
  done:
      /* Unlock file */
--- 219,225 ----
  
      /* Update mtime */
      if (!code)
! 	vnm_SetMCtime(evp);
  
  done:
      /* Unlock file */
Delta: bwl-3911-cache-mtime-ctime
Change: file/episode/vnops/SUNOS5/efs_sun5vmm.c from 1.128 to 1.134
*** file/episode/vnops/SUNOS5/efs_sun5vmm.c
--- 1.134	1994/03/16 19:44:41
***************
*** 13,18 ****
--- 13,19 ----
  #include <dcedfs/osi_buf.h>
  #include <dcedfs/osi_vmm.h>
  #include <dcedfs/debug.h>
+ #include <dcedfs/episode/file.h>		/* epif_GetMode */
  
  #include "efs_evnode.h"
  #include "efs_misc.h"
***************
*** 20,26 ****
  
  extern void hat_setmod(page_t *);
  
! RCSID("$Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $")
  
  /* Arbitrary constants */
  
--- 21,27 ----
  
  extern void hat_setmod(page_t *);
  
! RCSID("$Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $")
  
  /* Arbitrary constants */
  
***************
*** 287,293 ****
     }
  
      /* Update mtime and ctime */
!     vnm_SetMCtime(VTOEV(vp), credp);
  
      efs_unlock(vp);
  
--- 288,299 ----
     }
  
      /* Update mtime and ctime */
!     vnm_SetMCtime(VTOEV(vp));
! 
!     /* Clear SUID and SGID bits if necessary */
!     if (osi_GetUID(credp) != 0 &&
! 	(epif_GetMode(EVTOA(VTOEV(vp))) & (VSUID | VSGID)))
! 	 vnm_ClearSUID(VTOEV(vp));
  
      efs_unlock(vp);
  
Delta: bwl-3911-cache-mtime-ctime
Change: file/episode/vnops/efs_dir.c from 4.74 to 4.82
*** file/episode/vnops/efs_dir.c
--- 4.82	1994/03/16 19:44:52
***************
*** 120,126 ****
  static struct efsdircache efsdircache;		/* dir cache statistics */
  
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $")
  
  /*
   * vnd_Create - add an entry to a directory
--- 120,126 ----
  static struct efsdircache efsdircache;		/* dir cache statistics */
  
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $")
  
  /*
   * vnd_Create - add an entry to a directory
***************
*** 174,180 ****
  	epif_ChangeLink (transId, EVTOA (devp), 1, 0, (u_int *) 0);
  
      /* Update target's mtime and ctime */
!     epif_Mark (transId, EVTOA (devp), EPIF_SFLAGS_MTIME | EPIF_SFLAGS_CTIME);
  
      /* Increment source's link count if requested */
      if (flags & DC_CHANGELINK)
--- 174,180 ----
  	epif_ChangeLink (transId, EVTOA (devp), 1, 0, (u_int *) 0);
  
      /* Update target's mtime and ctime */
!     vnm_MarkMCtime (transId, devp, 1);
  
      /* Increment source's link count if requested */
      if (flags & DC_CHANGELINK)
***************
*** 182,188 ****
  
      /* Update source's ctime if requested */
      if (flags & DC_MARKCTIME)
! 	epif_Mark (transId, EVTOA (nevp), EPIF_SFLAGS_CTIME);
  
      return (0);
  }
--- 182,188 ----
  
      /* Update source's ctime if requested */
      if (flags & DC_MARKCTIME)
! 	vnm_MarkMCtime (transId, nevp, 0);
  
      return (0);
  }
***************
*** 258,264 ****
      }
  
      /* Update parent directory's mtime and ctime */
!     code = epif_Mark (transId, dap, EPIF_SFLAGS_MTIME | EPIF_SFLAGS_CTIME);
      MBZ(code);
  
      /* Decrement child's link count */
--- 258,264 ----
      }
  
      /* Update parent directory's mtime and ctime */
!     code = vnm_MarkMCtime (transId, devp, 1);
      MBZ(code);
  
      /* Decrement child's link count */
***************
*** 266,272 ****
      MBZ(code);
  
      /* Update child's ctime */
!     code = epif_Mark (transId, oap, EPIF_SFLAGS_CTIME);
      MBZ(code);
  
      return (0);
--- 266,272 ----
      MBZ(code);
  
      /* Update child's ctime */
!     code = vnm_MarkMCtime (transId, oevp, 0);
      MBZ(code);
  
      return (0);
***************
*** 339,357 ****
  	return (code);
  
      /* Update parent directory's mtime and ctime */
!     epif_Mark (transId, dap, EPIF_SFLAGS_MTIME | EPIF_SFLAGS_CTIME);
  
      /* Decrement old child's link count */
      epif_ChangeLink (transId, ooap, lcdelta, 0, (u_int *) 0);
  
      /* Update old child's ctime */
!     epif_Mark (transId, ooap, EPIF_SFLAGS_CTIME);
  
      /* Increment new child's link count */
      epif_ChangeLink (transId, noap, 1, 0, (u_int *) 0);
  
      /* Update new child's ctime */
!     epif_Mark (transId, noap, EPIF_SFLAGS_CTIME);
  
      return 0;
  }
--- 339,357 ----
  	return (code);
  
      /* Update parent directory's mtime and ctime */
!     vnm_MarkMCtime (transId, devp, 1);
  
      /* Decrement old child's link count */
      epif_ChangeLink (transId, ooap, lcdelta, 0, (u_int *) 0);
  
      /* Update old child's ctime */
!     vnm_MarkMCtime (transId, ooevp, 0);
  
      /* Increment new child's link count */
      epif_ChangeLink (transId, noap, 1, 0, (u_int *) 0);
  
      /* Update new child's ctime */
!     vnm_MarkMCtime (transId, noevp, 0);
  
      return 0;
  }
Delta: bwl-3911-cache-mtime-ctime
Change: file/episode/vnops/efs_evnode.h from 4.90 to 4.107
*** file/episode/vnops/efs_evnode.h
--- 4.107	1994/03/16 19:45:05
***************
*** 6,12 ****
   * src directory for the full copyright text.
   */
  
! /* $Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $ */
  /*
   * Copyright (C) 1993, 1990 Transarc Corporation
   * All rights reserved.
--- 6,12 ----
   * src directory for the full copyright text.
   */
  
! /* $Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $ */
  /*
   * Copyright (C) 1993, 1990 Transarc Corporation
   * All rights reserved.
***************
*** 52,57 ****
--- 52,59 ----
      } vd_ident;
      int vd_flags;			/* miscellaneous flags */
      struct timeval vd_lastAtime;        /* Last access time */
+     struct timeval vd_lastMtime;	/* Last mod time */
+     struct timeval vd_lastCtime;	/* Last change time */
      hyper vd_len;			/* length */
      dacl_t * vd_acl;			/* ACL */
      struct epia_reservation vd_reservation; /* storage reserved (VM systems) */
***************
*** 112,119 ****
  #define VD_FOUNDHOLE	0x1000		/* efs_strategy read from a hole */
  #define VD_NOIDENTITY   0x2000          /* the vnode is no longer associated
  					   with a filesytem object */
! 
! #define VD_OUTOFDATE	VD_OLDATIME	/* other bits or'ed in as needed */
  
  #define EVTOA(evp) (evp->vd_ap)		/* get anode pointer of vnode. */
  #define EVTOV(evp) ((struct vnode *) (evp)) /* convert evnode to vnode; cheat
--- 114,124 ----
  #define VD_FOUNDHOLE	0x1000		/* efs_strategy read from a hole */
  #define VD_NOIDENTITY   0x2000          /* the vnode is no longer associated
  					   with a filesytem object */
! #define VD_OLDMTIME	0x4000		/* anode has older mtime than vnode */
! #define VD_OLDCTIME	0x8000		/* anode has older ctime than vnode */
! #define VD_OLDMCTIME	(VD_OLDMTIME | VD_OLDCTIME)
! #define VD_OUTOFDATE	(VD_OLDATIME | VD_OLDMCTIME)
! 					/* other bits or'ed in as needed */
  
  #define EVTOA(evp) (evp->vd_ap)		/* get anode pointer of vnode. */
  #define EVTOV(evp) ((struct vnode *) (evp)) /* convert evnode to vnode; cheat
Delta: bwl-3911-cache-mtime-ctime
Change: file/episode/vnops/efs_misc.c from 4.422 to 4.427
*** file/episode/vnops/efs_misc.c
--- 4.427	1994/03/16 19:45:08
***************
*** 22,27 ****
--- 22,29 ----
      vnm_Unreserve
      vnm_SetAtime, vnm_SetMCtime
      vnm_Update_Anode
+     vnm_MarkMCtime
+     vnm_ClearSUID
      vnm_Init, vnm_VInit, vnm_VReinit
      vnm_Rouse, vnm_Unrouse
      Recycle
***************
*** 76,82 ****
  
  #define DEBUG_THIS_FILE EFS_DEBUG_MISC
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $")
  
  /* Flags to pass to epia_Truncate */
  #if	defined(AFS_SUNOS5_ENV) || defined(AFS_AIX31_VM)
--- 78,84 ----
  
  #define DEBUG_THIS_FILE EFS_DEBUG_MISC
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $")
  
  /* Flags to pass to epia_Truncate */
  #if	defined(AFS_SUNOS5_ENV) || defined(AFS_AIX31_VM)
***************
*** 497,540 ****
  }
  
  /*
!  * vnm_SetMCtime -- update mtime and ctime on behalf of writing
   *
   * LOCKS: called with vnode lock held for writing
   */
  /* EXPORT */
! void vnm_SetMCtime (evp, credp)
      struct evnode *evp;			/* Episode vnode */
-     osi_cred_t *credp;			/* credential structure */
  {
!     int code;
!     buffer_TranRec_t transId;		/* transaction ID */
!     epi_anode_t ap;			/* anode handle for evp */
!     struct epif_status fstat;		/* file status info for evp */
! 
!     ap = EVTOA (evp);
! 
!     /* Start transaction */
!     code = epia_StartTran ("vnm_SetMCtime", ap, &transId);
!     MBZ (code);
! 
!     /* Clear SUID and SGID bits if necessary */
!     if (osi_GetUID (credp) != 0)
! 	if (epif_GetMode (ap) & (VSUID | VSGID)) {
! 	    fstat.mode = epif_GetMode(ap) & ~(VSUID | VSGID);
! 	    code = epif_SetStatus (transId, ap, EPIF_SFLAGS_MODE, &fstat);
! 	    MBZ (code);
! 	}
! 
!     /* Update mtime and ctime */
!     code = epif_Mark (transId, ap, EPIF_SFLAGS_MTIME | EPIF_SFLAGS_CTIME);
!     MBZ (code);
! 
!     /* Merge transaction */
!     tlock_EquivAssign (transId, &evp->vd_tlock);
! 
!     /* End transaction */
!     code = epia_EndTran (ap, transId);
!     MBZ (code);
  }
  
  /*
--- 499,515 ----
  }
  
  /*
!  * vnm_SetMCtime -- update vnode copy of mtime and ctime on behalf of writing
   *
   * LOCKS: called with vnode lock held for writing
   */
  /* EXPORT */
! void vnm_SetMCtime (evp)
      struct evnode *evp;			/* Episode vnode */
  {
!     osi_GetTime (&evp->vd_lastMtime);
!     evp->vd_lastCtime = evp->vd_lastMtime;
!     evp->vd_flags |= VD_OLDMCTIME;
  }
  
  /*
***************
*** 553,558 ****
--- 528,534 ----
  {
      buffer_tranRec_t transId;		/* transaction ID */
      int code;
+     long flags = 0;			/* flags arg for epif_SetStatus */
      struct epif_status fstat;		/* status info about evp */
      epi_anode_t ap;			/* anode for evp */
  
***************
*** 568,576 ****
  
      if (evp->vd_flags & VD_OLDATIME) {
  	fstat.aTime = evp->vd_lastAtime;
! 	epif_SetStatus (transId, ap, EPIF_SFLAGS_ATIME, &fstat);
      }
  
      /* Clean up */
  
      evp->vd_flags &= ~VD_OUTOFDATE;
--- 544,569 ----
  
      if (evp->vd_flags & VD_OLDATIME) {
  	fstat.aTime = evp->vd_lastAtime;
! 	flags |= EPIF_SFLAGS_ATIME;
!     }
! 
!     /* Mtime */
! 
!     if (evp->vd_flags & VD_OLDMTIME) {
! 	fstat.mTime = evp->vd_lastMtime;
! 	flags |= EPIF_SFLAGS_MTIME;
      }
  
+     /* Ctime */
+ 
+     if (evp->vd_flags & VD_OLDCTIME) {
+ 	fstat.cTime = evp->vd_lastCtime;
+ 	flags |= (EPIF_SFLAGS_CTIME);
+     }
+ 
+     if (evp->vd_flags & (VD_OLDATIME | VD_OLDMCTIME))
+ 	epif_SetStatus (transId, ap, flags, &fstat);
+ 
      /* Clean up */
  
      evp->vd_flags &= ~VD_OUTOFDATE;
***************
*** 584,589 ****
--- 577,646 ----
  }
  
  /*
+  * vnm_MarkMCtime -- update ctime and possibly mtime under a transaction
+  *
+  * We are updating the anode's times, and so we clear VD_OLDMCTIME.
+  *
+  * LOCKS: called with vnode lock held for writing
+  */
+ 
+ /* EXPORT */
+ int vnm_MarkMCtime (transId, evp, markM)
+     buffer_TranRec_t transId;		/* transaction ID */
+     struct evnode *evp;			/* Episode vnode */
+     int markM;				/* 0 for just ctime, 1 for both */
+ {
+     int code;
+     epi_anode_t ap;			/* anode handle for evp */
+ 
+     ap = EVTOA (evp);
+ 
+     if (markM) {
+ 	code = epif_Mark (transId, ap, EPIF_SFLAGS_MTIME | EPIF_SFLAGS_CTIME);
+ 	evp->vd_flags &= ~VD_OLDMCTIME;
+     } else {
+ 	code = epif_Mark (transId, ap, EPIF_SFLAGS_CTIME);
+ 	evp->vd_flags &= ~VD_OLDCTIME;
+     }
+ 
+     return code;
+ }
+ 
+ /*
+  * vnm_ClearSUID -- clear SUID and SGID bits on behalf of writing
+  *
+  * LOCKS: called with vnode lock held for writing
+  */
+ 
+ /* EXPORT */
+ void vnm_ClearSUID (evp)
+     struct evnode *evp;			/* Episode vnode */
+ {
+     int code;
+     epi_anode_t ap;			/* anode handle for evp */
+     buffer_TranRec_t transId;		/* transaction ID */
+     struct epif_status fstat;		/* file status info for evp */
+ 
+     ap = EVTOA (evp);
+ 
+     /* Start transaction */
+     code = epia_StartTran ("vnm_ClearSUID", ap, &transId);
+     MBZ (code);
+ 
+     /* Clear the bits */
+     fstat.mode = epif_GetMode (ap) & ~(VSUID | VSGID);
+     code = epif_SetStatus (transId, ap, EPIF_SFLAGS_MODE, &fstat);
+     MBZ (code);
+ 
+     /* Merge transaction */
+     tlock_EquivAssign (transId, &evp->vd_tlock);
+ 
+     /* End transaction */
+     code = epia_EndTran (ap, transId);
+     MBZ (code);
+ }
+ 
+ /*
   * vnm_Init -- initialize the vnode pool, free list, and hash table
   */
  
***************
*** 763,768 ****
--- 820,827 ----
      evp->vd_flags &= ~(VD_STALE | VD_RDONLY | VD_ROOT);
      evp->vd_validFlag = 0;
      evp->vd_lastAtime = epif_GetATime (ap);
+     evp->vd_lastMtime = epif_GetMTime (ap);
+     evp->vd_lastCtime = epif_GetCTime (ap);
  
      /* Set ROOT bit(s) */
  
Delta: bwl-3911-cache-mtime-ctime
Change: file/episode/vnops/efs_misc.h from 1.13 to 1.19
*** file/episode/vnops/efs_misc.h
--- 1.19	1994/03/16 19:45:39
***************
*** 6,12 ****
   * src directory for the full copyright text.
   */
  
! /* $Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $ */
  /*
   * Copyright (C) 1993 Transarc Corporation
   * All rights reserved.
--- 6,12 ----
   * src directory for the full copyright text.
   */
  
! /* $Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $ */
  /*
   * Copyright (C) 1993 Transarc Corporation
   * All rights reserved.
***************
*** 52,59 ****
  extern int vnm_Truncate(struct evnode *evp, u_long len, osi_cred_t *credp);
  extern void vnm_Unreserve(struct evnode *evp);
  extern void vnm_SetAtime(struct evnode *evp, int flags);
! extern void vnm_SetMCtime(struct evnode *evp, osi_cred_t *credp);
  extern void vnm_Update_Anode(struct evnode *evp);
  extern int vnm_Init(long nvnodes, long noXvfs);
  extern void vnm_Rouse(struct evnode *evp);
  extern void vnm_Unrouse(struct evnode *evp);
--- 52,65 ----
  extern int vnm_Truncate(struct evnode *evp, u_long len, osi_cred_t *credp);
  extern void vnm_Unreserve(struct evnode *evp);
  extern void vnm_SetAtime(struct evnode *evp, int flags);
! extern void vnm_SetMCtime(struct evnode *evp);
  extern void vnm_Update_Anode(struct evnode *evp);
+ extern int vnm_MarkMCtime(
+     buffer_TranRec_t transId,
+     struct evnode *evp,
+     int markM
+ );
+ extern void vnm_ClearSUID(struct evnode *evp);
  extern int vnm_Init(long nvnodes, long noXvfs);
  extern void vnm_Rouse(struct evnode *evp);
  extern void vnm_Unrouse(struct evnode *evp);
Delta: bwl-3911-cache-mtime-ctime
Change: file/episode/vnops/efs_vattr.c from 4.75 to 4.79
*** file/episode/vnops/efs_vattr.c
--- 4.79	1994/03/16 19:45:42
***************
*** 261,267 ****
  #include "efs_misc.h"
  #include "efs_vattr.h"
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $")
  
  #ifndef	KERNEL
  #ifdef	AFS_AIX31_ENV
--- 261,267 ----
  #include "efs_misc.h"
  #include "efs_vattr.h"
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $")
  
  #ifndef	KERNEL
  #ifdef	AFS_AIX31_ENV
***************
*** 719,724 ****
--- 719,728 ----
  		evp->vd_lastAtime = epif_GetATime (ap);
  		evp->vd_flags &= ~VD_OLDATIME;
  	    }
+ 	    if (markmask & EPIF_SFLAGS_MTIME)
+ 		evp->vd_flags &= ~VD_OLDMTIME;
+ 	    if (markmask & EPIF_SFLAGS_CTIME)
+ 		evp->vd_flags &= ~VD_OLDCTIME;
  	}
  	tlock_ReleaseWrite (transId, &evp->vd_tlock);
  	ccode = epia_EndTran (ap, transId);
Delta: bwl-3911-cache-mtime-ctime
Change: file/episode/vnops/efs_vnodeops.c from 4.618 to 4.621
*** file/episode/vnops/efs_vnodeops.c
--- 4.621	1994/03/16 19:45:51
***************
*** 45,51 ****
  #endif /* AFS_SUNOS5_ENV */
  
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $")
  
  /*
   * We follow the conventions of the original Sun vfs/vnode interface:
--- 45,51 ----
  #endif /* AFS_SUNOS5_ENV */
  
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $")
  
  /*
   * We follow the conventions of the original Sun vfs/vnode interface:
***************
*** 657,664 ****
  		VNM_MAP_COMMON_ERROR(code, DEBUG_THIS_FILE);
  	    } else {			/* write succeeded */
  		/* Update mtime and ctime */
! 		vnm_SetMCtime (evp, cred);
  
  		/* May clear VD_LENVALID (don't know if this can happen) */
  		hset (hlen, epia_GetLength (ap));
  		if (evp->vd_flags & VD_LENVALID)
--- 657,669 ----
  		VNM_MAP_COMMON_ERROR(code, DEBUG_THIS_FILE);
  	    } else {			/* write succeeded */
  		/* Update mtime and ctime */
! 		vnm_SetMCtime (evp);
  
+ 		/* Clear SUID and SGID bits if necessary */
+ 		if (osi_GetUID (cred) != 0 &&
+ 		    (epif_GetMode (ap) & (VSUID | VSGID)))
+ 		    vnm_ClearSUID (evp);
+ 
  		/* May clear VD_LENVALID (don't know if this can happen) */
  		hset (hlen, epia_GetLength (ap));
  		if (evp->vd_flags & VD_LENVALID)
***************
*** 700,705 ****
--- 705,718 ----
      evp = VTOEV(vp);
      EV_DEPHANTOM (evp);
  
+     /*
+      * If the Mtime or Ctime are new, update the anode now.
+      * This is supposed to keep clients from seeing these times go backward.
+      * To put teeth in this precaution, shouldn't we commit the transaction?
+      */
+     if (evp->vd_flags & VD_OLDMCTIME)
+ 	vnm_Update_Anode (evp);
+ 
      tlock_ObtainRead (&evp->vd_tlock);
      code = vnva_GetAttr (evp, vap, cred, 0);
      if (code) {
***************
*** 726,731 ****
--- 739,752 ----
      evp = VTOEV(vp);
      EV_DEPHANTOM (evp);
  
+     /*
+      * If the Mtime or Ctime are new, update the anode now.
+      * This is supposed to keep clients from seeing these times go backward.
+      * To put teeth in this precaution, shouldn't we commit the transaction?
+      */
+     if (evp->vd_flags & VD_OLDMCTIME)
+ 	vnm_Update_Anode (evp);
+ 
      tlock_ObtainRead (&evp->vd_tlock);
      code = vnva_GetAttr (evp, vap, cred, flag);
      if (code) {
***************
*** 3595,3601 ****
      }
  
      /* Update ctime */
!     epif_Mark (transId, ap, EPIF_SFLAGS_CTIME);
  
      /* For a file/dir's regular ACL,
       *     invalidate cached ACL if necessary and cache new acl if we get
--- 3616,3622 ----
      }
  
      /* Update ctime */
!     vnm_MarkMCtime (transId, evp, 0);
  
      /* For a file/dir's regular ACL,
       *     invalidate cached ACL if necessary and cache new acl if we get
***************
*** 3752,3767 ****
      int ioflag;
      osi_cred_t *cred;
  {
-     epi_anode_t ap;			/* anode handle for evp */
-     logTranRec_t transId;		/* transaction ID */
      struct evnode *evp;			/* evnode */
  
      evp = VTOEV(vp);
!     ap = EVTOA (evp);
!     elbb_StartTran("efs_rdwr", 0, epia_AnodeDevice (ap), &transId);
!     epif_Mark (transId, ap, EPIF_SFLAGS_MTIME | EPIF_SFLAGS_CTIME);
!     elbb_EndTran(transId);
! 
      return (spec_write(vp, uio, ioflag, cred));
  }
  
--- 3773,3782 ----
      int ioflag;
      osi_cred_t *cred;
  {
      struct evnode *evp;			/* evnode */
  
      evp = VTOEV(vp);
!     vnm_SetMCtime (evp, cred);
      return (spec_write(vp, uio, ioflag, cred));
  }
  
***************
*** 3803,3818 ****
      int ioflag;
      osi_cred_t *cred;
  {
-     epi_anode_t ap;			/* anode handle for evp */
-     logTranRec_t transId;		/* transaction ID */
      struct evnode *evp;			/* evnode */
  
      evp = VTOEV(vp);
!     ap = EVTOA (evp);
!     elbb_StartTran("efs_rdwr", 0, epia_AnodeDevice (ap), &transId);
!     epif_Mark (transId, ap, EPIF_SFLAGS_MTIME | EPIF_SFLAGS_CTIME);
!     elbb_EndTran(transId);
! 
      return (fifo_write(vp, uio, ioflag, cred));
  }
  
--- 3818,3827 ----
      int ioflag;
      osi_cred_t *cred;
  {
      struct evnode *evp;			/* evnode */
  
      evp = VTOEV(vp);
!     vnm_SetMCtime (evp, cred);
      return (fifo_write(vp, uio, ioflag, cred));
  }
  
Delta: bwl-3911-cache-mtime-ctime
Change: file/episode/anode/file.c from 4.69 to 4.79
*** file/episode/anode/file.c
--- 4.79	1994/03/25 19:17:43
***************
*** 10,16 ****
   * $Log:	c012989,v $
# Revision 1.4  96/01/23  13:42:13  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company  
# 
# Revision 1.3  95/08/03  17:45:05  root
# changed fields:  new/changed/deleted note(s) [biyani 8/3/95 public]
# 
   * $EndLog$
   */
! /* Copyright (C) 1993, 1990 Transarc Corporation - All rights reserved */
  
  /* file.c -- contains procedures to needed by the vnode layer to implement Unix
   *     files.  Basic read and write operations are handled directly by lower
--- 10,16 ----
   * $Log:	c012989,v $
# Revision 1.4  96/01/23  13:42:13  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company  
# 
# Revision 1.3  95/08/03  17:45:05  root
# changed fields:  new/changed/deleted note(s) [biyani 8/3/95 public]
# 
   * $EndLog$
   */
! /* Copyright (C) 1994, 1990 Transarc Corporation - All rights reserved */
  
  /* file.c -- contains procedures to needed by the vnode layer to implement Unix
   *     files.  Basic read and write operations are handled directly by lower
***************
*** 35,41 ****
  #include "volume.h"
  #include "file.h"
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $")
  
  #define DEBUG_THIS_FILE EPIA_DEBUG_FILE
  
--- 35,41 ----
  #include "volume.h"
  #include "file.h"
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $")
  
  #define DEBUG_THIS_FILE EPIA_DEBUG_FILE
  
***************
*** 1875,1915 ****
      return 0;
  }
  
! /* epif_SetStatus -- Changes those fields of the file's status that are
!  *     selected by the \arg{flags} to have the values specified in
!  *     \arg{status}.  The valid bits that maybe combined to form
!  *     \arg{flags} are defined by the constants using the
!  *     \prefix{\cst{EPIF_SFLAGS_}} in file.h.
   *
   * PARAMETERS --
   *     trans -- transaction to use for the operation.
   *     f -- file's open handle.
!  *     flags -- mask used to select the fields in the status.
   *     status -- file's new status.
   *
!  * PERFORMANCE -- See the SET_FIELDS macro below. */
  
  /* EXPORT */
! long epif_SetStatus(
    IN elbb_tranRec_t trans,
    IN epi_anode_t f,
!   IN long flags,			/* which fields to set */
    IN struct epif_status *status)
  {
      long code;
      struct fileHandle *h;
      long first, last;			/* offsets bracketing modifications */
  
!     /* SET_FIELD -- does most of the work in modiying a particular field in the
!      *     status area.  It maintains a low and high water mark so all updates
!      *     can be merged into a single call to elbb_Modify.  It may be that it
!      *     would be more efficient to do separate Modifies if two widely
!      *     separated fields are being updated.
       *
       *     A code block corresponding to each field is maintained by passing
       *     the block to the SET_FIELD macro. */
  
! #define SET_FIELD(b,f,v,n) if (flags & (b)) { \
      int o = offsetof (struct diskStatus, f); \
      epix_EnterCodeBlock /* */ (n); \
      if (o < first) first = o; \
--- 1875,1938 ----
      return 0;
  }
  
! /* epif_SetStatusAndMark -- Changes those fields of the file's status that
!  *     are selected by the setStatusFlags to have the values specified in
!  *     status.  Changes those (time-stamp) fields of the file's status that
!  *     are selected by the markFlags to have the value of the current time.
!  *     (These include one or more of:  atime, mtime, ctime.)
!  *     Either setStatusFlags or markFlags may be zero; if setStatusFlags is
!  *     zero, status will be a null pointer.  The valid bits that may be
!  *     combined to form setStatusFlags and markFlags are defined by the
!  *     constants using the prefix EPIF_SFLAGS_ in file.h.
!  *
!  *     The caller may also wish to update the file data version number.  This
!  *     can be specified explicitly, by setting EPIF_SFLAGS_DVERSION in
!  *     markFlags.  It is also specified implicitly when EPIF_SFLAGS_MTIME is
!  *     set in markFlags.  It is NOT specified implicitly when EPIF_SFLAGS_MTIME
!  *     is set in setStatusFlags.
!  *
!  *     If any flag in markFlags is set, the fileset version number is updated.
!  *     SPECIAL HACK used only by test_anode:
!  *	  If setStatusFlags and markFlags are both zero and status is null,
!  *	  it is assumed that macro epif_Mark was invoked with flags set to
!  *	  zero, with the intention of solely updating the fileset version
!  *	  number.
   *
   * PARAMETERS --
   *     trans -- transaction to use for the operation.
   *     f -- file's open handle.
!  *     markFlags -- mask used to select timestamp fields in the status.
!  *     setStatusFlags -- mask used to select fields in the status.
   *     status -- file's new status.
   *
!  * PERFORMANCE -- See the SET_FIELDS macro below.
!  */
  
  /* EXPORT */
! long epif_SetStatusAndMark(
    IN elbb_tranRec_t trans,
    IN epi_anode_t f,
!   IN long markFlags,
!   IN long setStatusFlags,		/* which fields to set */
    IN struct epif_status *status)
  {
      long code;
      struct fileHandle *h;
+     hyper vv;				/* volume version number */
+     epi_volume_t vol;
+     struct timeval t;
      long first, last;			/* offsets bracketing modifications */
  
!     /* SET_FIELD -- does most of the work in modifying a particular field in
!      *     the status area.  It maintains a low and high water mark so all
!      *     updates can be merged into a single call to elbb_Modify.  It may be
!      *     that it would be more efficient to do separate Modifies if two
!      *     widely separated fields are being updated.
       *
       *     A code block corresponding to each field is maintained by passing
       *     the block to the SET_FIELD macro. */
  
! #define SET_FIELD(b,f,v,n) if (setStatusFlags & (b)) { \
      int o = offsetof (struct diskStatus, f); \
      epix_EnterCodeBlock /* */ (n); \
      if (o < first) first = o; \
***************
*** 1920,1925 ****
--- 1943,1972 ----
      if (!GetOKfile (h, f)) return EPI_E_BADFILE;
      first = sizeof(struct diskStatus);
      last = 0;
+ 
+     /* SPECIAL HACK -- see comments above */
+     if (setStatusFlags == 0 && markFlags == 0 && !status)
+ 	markFlags = EPIF_SFLAGS_VVERSION;
+ 
+     if (markFlags) {
+ 	/* This code depends on the fields being in this order:
+ 	 *   volumeVersionNumber, dataVersionNumber, mTime, cTime, aTime. */
+ 
+ 	if (markFlags & EPIF_SFLAGS_ATIME)
+ 	    last = offsetof(struct diskStatus, aTime) + sizeof(t);
+ 	else if (markFlags & EPIF_SFLAGS_CTIME)
+ 	    last = offsetof(struct diskStatus, cTime) + sizeof(t);
+ 	else if (markFlags & EPIF_SFLAGS_MTIME)
+ 	    last = offsetof(struct diskStatus, mTime) + sizeof(t);
+ 	else if (markFlags & EPIF_SFLAGS_DVERSION)
+ 	    last = offsetof(struct diskStatus, dataVersionNumber)
+ 			+ sizeof(h->status.dataVersionNumber);
+ 	else if (markFlags & EPIF_SFLAGS_VVERSION)
+ 	    last = offsetof(struct diskStatus, volumeVersionNumber)
+ 			+ sizeof(h->status.volumeVersionNumber);
+ 	else return (EPI_E_BADFLAGS);
+ 	first = offsetof(struct diskStatus, volumeVersionNumber);
+     }
      BEGIN_TLOCK_WRITE (trans, &h->lock) {
  	struct diskStatus oldStatus = h->status;
  
***************
*** 1951,1956 ****
--- 1998,2029 ----
  		   parent, status->parent, /* CodeBlock(*/55);
  #endif
  
+ 	if (markFlags) {
+ 	    vol = epiv_GetVolume (f);
+ 	    code = epiv_NewVolumeVersion (trans, vol, &vv);
+ 	    if (code) continue;
+ 	    hset (h->status.volumeVersionNumber, vv);
+ 
+ 	    UniqueTime (&t);
+ 
+ 	    if (markFlags & EPIF_SFLAGS_MTIME) {
+ 		epix_EnterCodeBlock(57);
+ 		h->status.mTime = t;
+ 	    }
+ 	    if (markFlags & EPIF_SFLAGS_CTIME) {
+ 		epix_EnterCodeBlock(58);
+ 		h->status.cTime = t;
+ 	    }
+ 	    if (markFlags & EPIF_SFLAGS_ATIME) {
+ 		epix_EnterCodeBlock(59);
+ 		h->status.aTime = t;
+ 	    }
+ 	    if (markFlags & (EPIF_SFLAGS_DVERSION | EPIF_SFLAGS_MTIME)) {
+ 		epix_EnterCodeBlock(56);
+ 		h->status.dataVersionNumber++;
+ 	    }
+ 	}
+ 
  	if (first < last) {
  	    code = epia_SetStatus (trans, f, first, last-first,
  				   (char *)(&h->status) + first);
***************
*** 1960,2033 ****
  		continue;
  	    }
  	}
-     } END_LOCK;
-     return code;
- }
- 
- /* epif_Mark -- Sets various fields of a file that change often.  The
-  *     \arg{flags} argument specifies which time values to update.  If
-  *     \cst{EPIF_SFLAGS_MTIME} is specified, the file data version number
-  *     is also updated.  In every case (even if flags is 0), the fileset
-  *     version number is updated.
-  *
-  * PARAMTERS --
-  *     trans -- transaction to use for this operation.
-  *     f -- file handle.
-  *     flags -- this determines which fields to change. */
- 
- EXPORT long epif_Mark (trans, f, flags)
-   IN elbb_tranRec_t trans;
-   IN epi_anode_t f;
-   IN long flags;
- {
-     long code;
-     struct fileHandle *h;
-     hyper vv;
-     epi_volume_t vol;
-     struct timeval t;
-     long first, last;			/* offsets bracketing modifications */
- 
-     epix_EnterCodeBlock(56);
-     if (!GetOKfile (h, f)) return EPI_E_BADFILE;
- 
-     /* This code depends on the fields being in this order:
-      *   volumeVersionNumber, dataVersionNumber, mTime, cTime, aTime. */
- 
-     if (flags & EPIF_SFLAGS_ATIME)
- 	last = offsetof(struct diskStatus, aTime);
-     else if (flags & EPIF_SFLAGS_CTIME)
- 	last = offsetof(struct diskStatus, cTime);
-     else if (flags & EPIF_SFLAGS_MTIME)
- 	last = offsetof(struct diskStatus, mTime);
-     else if (flags == 0)
- 	last = offsetof(struct diskStatus, volumeVersionNumber);
-     else return (EPI_E_BADFLAGS);
- 
-     BEGIN_TLOCK_WRITE (trans, &h->lock) {
- 	vol = epiv_GetVolume (f);
- 	code = epiv_NewVolumeVersion (trans, vol, &vv);
- 	if (code) continue;
- 	hset (h->status.volumeVersionNumber, vv);
- 	first = offsetof(struct diskStatus, volumeVersionNumber);
- 
- 	UniqueTime (&t);
- 
- 	if (flags & EPIF_SFLAGS_MTIME) {
- 	    epix_EnterCodeBlock(57);
- 	    h->status.dataVersionNumber++;
- 	    h->status.mTime = t;
- 	}
- 	if (flags & EPIF_SFLAGS_CTIME) {
- 	    epix_EnterCodeBlock(58);
- 	    h->status.cTime = t;
- 	}
- 	if (flags & EPIF_SFLAGS_ATIME) {
- 	    epix_EnterCodeBlock(59);
- 	    h->status.aTime = t;
- 	}
- 	code = epia_SetStatus (trans, f, first, last-first + sizeof(t),
- 			       (char *)&h->status + first);
- 	afsl_MBZ (code);
      } END_LOCK;
      return code;
  }
--- 2033,2038 ----
Delta: bwl-3911-cache-mtime-ctime
Change: file/episode/anode/file.h from 4.17 to 4.18
*** file/episode/anode/file.h
--- 4.18	1994/03/25 19:17:59
***************
*** 8,70 ****
  /*
   * HISTORY
   * $Log:	c012989,v $
# Revision 1.4  96/01/23  13:42:13  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company  
# 
# Revision 1.3  95/08/03  17:45:05  root
# changed fields:  new/changed/deleted note(s) [biyani 8/3/95 public]
# 
-  * Revision 1.1.5.6  1993/01/18  22:03:56  cjd
-  * 	embedded copyright notice
-  * 	[1993/01/18  21:43:29  cjd]
-  *
-  * Revision 1.1.5.5  1993/01/13  16:39:03  shl
-  * 	Transarc delta: cfe-ot6051-four-bits-o-spares 1.1
-  * 	  Selected comments:
-  * 	    Create spares for various non-Unix clients (that will probably never be
-  * 	    ser

CR Number                     : 12988
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : episode
Short Description             : Need error code tracing in efs_agops.c
Reported Date                 : 8/2/95
Found in Baseline             : 1.0.3
Found Date                    : 8/2/95
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : file/episode/vnops/efs_agops.c
Sensitivity                   : public

[8/2/95 public]

FROM Transarc:
SYNOPSIS: Use icl to report error code mapping in efs_agops.c

The file episode/vnops/efs_agops.c has only a single call to
EFS_TRACE_VNOPS yet there are many cases where error codes are being
mapped.  Especially note that failures from epig_InitAggregate are being
mapped silently.  The file needs to be checked for all error code
mapping and a trace entry added to each.

Delta bwl-2621-trace-in-agops 1.2.

[8/3/95 public]


Delta: bwl-2621-trace-in-agops
Change: file/episode/vnops/efs_agops.c from 4.77 to 4.78
*** file/episode/vnops/efs_agops.c
--- 4.78	1994/03/07 22:23:03
***************
*** 40,46 ****
  #include "efs_dirhandle.h"              /* epi_Dir_Handle */
  #include "efs_vfsops.h"			/* efs_sync() */
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012988,v 1.5 95/12/21 15:49:39 root Exp $")
  
  extern struct volumeops vol_efsops;
  extern int afsdb_episode_vnops;	/* the trace control variable */
--- 40,46 ----
  #include "efs_dirhandle.h"              /* epi_Dir_Handle */
  #include "efs_vfsops.h"			/* efs_sync() */
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012988,v 1.5 95/12/21 15:49:39 root Exp $")
  
  extern struct volumeops vol_efsops;
  extern int afsdb_episode_vnops;	/* the trace control variable */
***************
*** 299,306 ****
  
      code = epig_InitAggregate(
  	osi_major(dev), osi_minor(dev), 1, &asdev, &aggh);
!     if (code)
! 	code = ENXIO;
  
      if (code == 0) {
  	dat = (struct ag_efsData *) osi_Alloc(sizeof(struct ag_efsData));
--- 299,308 ----
  
      code = epig_InitAggregate(
  	osi_major(dev), osi_minor(dev), 1, &asdev, &aggh);
!     if (code) {
!         EFS_TRACE_VNOPS(DEBUG_THIS_FILE, code, ENXIO);
!         return ENXIO;
!     }
  
      if (code == 0) {
  	dat = (struct ag_efsData *) osi_Alloc(sizeof(struct ag_efsData));
Delta: bwl-2621-trace-in-agops
Change: file/episode/vnops/efs_agops.c from 4.78 to 4.79
*** file/episode/vnops/efs_agops.c
--- 4.79	1994/03/10 16:01:51
***************
*** 5,11 ****
   * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE in the
   * src directory for the full copyright text.
   */
! /* Copyright (C) 1990 Transarc Corporation
     All rights reserved.
   */
  
--- 5,11 ----
   * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE in the
   * src directory for the full copyright text.
   */
! /* Copyright (C) 1994, 1990 Transarc Corporation
     All rights reserved.
   */
  
***************
*** 40,46 ****
  #include "efs_dirhandle.h"              /* epi_Dir_Handle */
  #include "efs_vfsops.h"			/* efs_sync() */
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012988,v 1.5 95/12/21 15:49:39 root Exp $")
  
  extern struct volumeops vol_efsops;
  extern int afsdb_episode_vnops;	/* the trace control variable */
--- 40,46 ----
  #include "efs_dirhandle.h"              /* epi_Dir_Handle */
  #include "efs_vfsops.h"			/* efs_sync() */
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012988,v 1.5 95/12/21 15:49:39 root Exp $")
  
  extern struct volumeops vol_efsops;
  extern int afsdb_episode_vnops;	/* the trace control variable */
Delta: bwl-2621-trace-in-agops
Change: file/episode/vnops/efs_agops.c from 4.79 to 4.82
*** file/episode/vnops/efs_agops.c
--- 4.82	1994/03/16 21:40:04
***************
*** 40,46 ****
  #include "efs_dirhandle.h"              /* epi_Dir_Handle */
  #include "efs_vfsops.h"			/* efs_sync() */
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012988,v 1.5 95/12/21 15:49:39 root Exp $")
  
  extern struct volumeops vol_efsops;
  extern int afsdb_episode_vnops;	/* the trace control variable */
--- 40,46 ----
  #include "efs_dirhandle.h"              /* epi_Dir_Handle */
  #include "efs_vfsops.h"			/* efs_sync() */
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012988,v 1.5 95/12/21 15:49:39 root Exp $")
  
  extern struct volumeops vol_efsops;
  extern int afsdb_episode_vnops;	/* the trace control variable */
***************
*** 301,307 ****
  	osi_major(dev), osi_minor(dev), 1, &asdev, &aggh);
      if (code) {
          EFS_TRACE_VNOPS(DEBUG_THIS_FILE, code, ENXIO);
!         return ENXIO;
      }
  
      if (code == 0) {
--- 301,307 ----
  	osi_major(dev), osi_minor(dev), 1, &asdev, &aggh);
      if (code) {
          EFS_TRACE_VNOPS(DEBUG_THIS_FILE, code, ENXIO);
!         code = ENXIO;
      }
  
      if (code == 0) {



CR Number                     : 12959
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : secd deadlocks against itself when all cthreads are blocked forever
Reported Date                 : 1/26/95
Found in Baseline             : 1.1
Found Date                    : 1/26/95
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : security/server/rs/rs_misc.c
Sensitivity                   : public

[7/19/95 public]

(from Charlie Rusman at Hitachi)

In DCE1.1 (not sure about 1.0) we find that we can,
under a fairly extreme load, deadlock secd against itself by causing
all cthreads to block forever.  We can make this happen if we run
the rpc.sec.2 system test, for example, in which many clients processes
of the same principal try to login to DCE.  In this case they all
serialize on the same context->mutex in rca_lock_handle() via sec_id_parse().
All but one are blocked on the mutex, and the one holding the lock
tries an RPC to secd, and blocks for it's completeion.  The RPC is for secd
itself, however, and that's where things get stuck as there are no
cthreads available to process it.
We realize that we can simply call rpc_server_listen() and establish
a pool of more than 5 cthreads (as the sources are set up to do), but
we are wondering if anyone has thought about addressing this a bit
more gracefully by dynamically growing and shrinking the pool at runtime.


I'm opening this as a medium priority bug since it is clearly a scaling 
issue and therefore important to DCE 1.2.

[12/8/95 public]
This has been fixed in the DCE1.2.1 code.



CR Number                     : 12957
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : dfs
Short Description             : replica not current after aggr. detach
Reported Date                 : 7/18/95
Found in Baseline             : 1.1
Found Date                    : 7/18/95
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 1.2.1
Affected File(s)              : several
Sensitivity                   : public

[7/18/95 public]
In a release-replicated environment, a condition occurs which caused the
replica to go bad and the user is unable to get at the replicated data
if the RW and staging replicas are unavailable.
Here is the test scenario:
Machine A:  dfsexport -detach aggregate with R/W and staging replica
            cm checkfilesets
            ls the replicated path - goes to R/O on Machine B
Machine B:  dfsexport -detach aggregate with R/O
Machine A:  dfsexport aggregate with R/W and staging replica
            cm checkf
            ls the replicated path - goes to Machine A
Machine B:  dfsexport aggregate with R/O
Machine A:  dfsexport -detach aggregate with R/W and staging replica
            cm checkf
            ls the replicated path - goes to R/O on Machine B but
            fails with VOLERR_PERS_AGEOLD
The VOLERR_PERS_AGEOLD is due to VVCurrentTime being set to zero.
I placed printf's in the volume detach and attach code and it showed
VVCurrentTime has a valid time the first time the aggregate is detached.
When the aggregate is reattached, the volume's VVCurrentTime is 0.
It appears the repserver cannot "refresh" itself when the aggregate
with replicas on it is detached and reattached when it is using release
replication.  I retried this test using scheduled replication and I do
not see the same failure if I wait a few minutes before trying to access
the data (the time it takes the repserver to do its periodic check?).
 
Added field #Transarc Deltas with value `' 
Added field #Transarc Herder with value `cfe@transarc.com' 
Added field #Transarc Status with value `open'
[1 Aug 1995 public]
I have two deltas that should fix this problem.

[8/16/95 public]
Actually, there are three deltas for the problem.  To fix the base problem,
which is that Episode isn't using the saved ``currtime'' when reattaching
aggregates, you'd need:
	cfe-ot12957-VolInfo-needs-to-set-currtime
To fix some other problems, and to make release-style replication not
cause all sites to fall back to the staging replica after 24 hours, you'll
need the two deltas:
	cfe-ot12957-more-active-repserver-mgt-of-release-replicas
	cfe-ot12957-more-robust-fix
I can make these fixes available to those who request them.

[12/22/95 public]
These deltas are included in what's to be dropped to the OSF in the
1.2.1 drop.



CR Number                     : 12881
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : bos
Short Description             : Bad 'bos lsadmin' output - Unknown message number
Reported Date                 : 5/19/95
Found in Baseline             : 1.1
Found Date                    : 5/18/95
Severity                      : E
Priority                      : 3
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : src/file/userInt/bos/bos_main.c
Sensitivity                   : public

[5/19/95 public]

[5/19/95 public]

(Sorry about the lack of description when ot created, novice ot user)


The bos lsadmin command has bad output:

root@tub> bos lsadmin -server /.:/hosts/tub -adminlist admin.bos
Unknown message number 0x000254c8group: subsys/dce/dfs-admin


This is because a string pointer is being used as an argument to
dce_fprintf() instead of a message index in bos_DoLsUsers().  Also,
charsSoFarOnLine looks like it's being assigned incorrectly.

original code (1.1):

      if (printHeading) {
        error_status_t  st;
        unsigned char   *cmd_explanation;
        cmd_explanation = dce_msg_get_msg(bos_s_admin_users_heading1, &st);
        dce_fprintf(stdout, cmd_explanation);
        free(cmd_explanation);
        charsSoFarOnLine = strlen(headingString);
        /* can't reset printHeading here, because we need it a little later */
      }


proposed new code:

      if (printHeading) {
        error_status_t  st;
        unsigned char   *cmd_explanation;
        cmd_explanation = dce_msg_get_msg(bos_s_admin_users_heading1, &st);
        dce_fprintf(stdout, bos_s_admin_users_heading1);
        charsSoFarOnLine = strlen(cmd_explanation);
        free(cmd_explanation);
        /* can't reset printHeading here, because we need it a little later */
      }



        Steve Strange 5/19/95
        Digital Equipment Corp, DCE DFS on Digital UNIX - Development
        strange@zk3.dec.com



CR Number                     : 12877
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : rgy_edit
Short Description             : dceseacl systest dumps core in certain cases
Reported Date                 : 5/18/95
Found in Baseline             : 1.1wp
Found Date                    : 5/18/95
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1,1.1maint
Affected File(s)              : rgy_edit/tty_pgo.c
Sensitivity                   : public

[5/18/95 public]

Warranty patch built on RIOS has failures when running security system
test dceseacl:

# run.sec -l 1 -m pierrot dceseacl

causes rgy_edit to dump core in following instances:

Case 1:
+ dce_auth seaclclipierrot1 testpw
+ change_neg_prin_quota seaclclipierrot0prin 999
Dumping core after receiving signal SIGSEGV
Current site is: registry server at /.../pierrot_cell/subsys/dce/sec/master
Domain changed to: principal
+ change_neg_group_project_list seaclclipierrot0group nl
+ change_neg_org_management_info seaclclipierrot0org pna pns
+ kdestroy

Case 2:
+ dce_auth seaclclipierrot1 testpw
+ change_prin_quota seaclclipierrot0prin 999
Dumping core after receiving signal SIGSEGV
Current site is: registry server at /.../pierrot_cell/subsys/dce/sec/master
Domain changed to: principal
+ change_neg_group_project_list seaclclipierrot0group nl
+ change_neg_org_management_info seaclclipierrot0org pna pns
+ kdestroy

Case 3:
+ dce_auth seaclclipierrot1 testpw
+ change_neg_prin_quota seaclclipierrot0prin unlimited
Dumping core after receiving signal SIGSEGV
Current site is: registry server at /.../pierrot_cell/subsys/dce/sec/master
Domain changed to: principal
+ change_group_project_list seaclclipierrot0group nl
+ change_neg_org_management_info seaclclipierrot0org pna pns
+ kdestroy

Case 4:
+ dce_auth seaclclipierrot1 testpw
+ change_neg_group_project_list seaclclipierrot0group l
+ change_org_management_info seaclclipierrot0org n n
Dumping core after receiving signal SIGSEGV
Current site is: registry server at /.../pierrot_cell/subsys/dce/sec/master
Domain changed to: org
+ kdestroy

The stack trace from the core is:

# dbx /opt/dcelocal/bin/rgy_edit core
dbx Version 3.1.
Type 'help' for help.
reading symbolic information ...
[memory image in core]

segmentation violation in tty_get_pgo_args at 0x10020d58 ($t1)
0x10020d58 (tty_get_pgo_args+0x11c) 907d0000         st   r3,0x0(r29)
(dbx) where
tty_get_pgo_args(0x0, 0x200ca458, 0x17083076, 0x177e0000, 0x200aebf0, 0x200aebf0, 0x200aebf0, 0x1) at 0x10020d58
tty_do_change_pgo(0x0, 0x200ca458) at 0x10022664
tty_do_change(0x0) at 0x100006b0
procs_cmds(0x0, 0x200ca458) at 0x1002a8b8
main(0x0, 0x200ca458) at 0x100035fc
(dbx) quit
#

[5/19/95 public]

Yet another core dump:

# run.sec -l 1 -m pierrot dcesepol

cases following core dumps:

+ add_org sepolpierrot1o 697
+ + expr 697 + 1
ORG_ID=698
+ add_org sepolpierrot2o 698
+ + expr 698 + 1
ORG_ID=699
+ add_org sepolpierrot3o 699
+ set_policies sepolpierrot1o 15 -pls
Dumping core after receiving signal SIGSEGV
+ + calc_valid_date 1
PED_VALID_DATE=95/5/20
+ set_policies sepolpierrot2o 95/5/20 -ped
Dumping core after receiving signal SIGSEGV
+ set_policies sepolpierrot3o 15 -als
Dumping core after receiving signal SIGSEGV

The stack trace from the last core dump:

# pwd
/dcetest/dcelocal/test/tet/system/security/ts/dcesepol
# dbx /opt/dcelocal/bin/rgy_edit core
dbx Version 3.1.
Type 'help' for help.
reading symbolic information ...
[memory image in core]

segmentation violation in tty_get_pgo_args at 0x10020d58 ($t1)
0x10020d58 (tty_get_pgo_args+0x11c) 907d0000         st   r3,0x0(r29)
(dbx) where
tty_get_pgo_args(0x0, 0x200ca458, 0x17083076, 0x177e0000, 0x200aebf0, 0x200aebf0, 0x200aebf0, 0x1) at 0x10020d58
tty_do_change_pgo(0x0, 0x200ca458) at 0x10022664
tty_do_change(0x0) at 0x100006b0
procs_cmds(0x0, 0x200ca458) at 0x1002a8b8
main(0x0, 0x200ca458) at 0x100035fc
(dbx)

[5/23/95 public]
The problem is legacy brain damage. HP took the __STDC__ path. For some
reason IBM doesn't define __STDC__. The __STDC__ function delcaration was
wrong for tty_pgo.c:tty_get_pgo_args . Apply this diff (remove the #ifndef
__STDC__ crud) and rgy_edit will work (and the tests will pass).

*** tty_pgo.c@@/main/LATEST     Wed Sep 21 20:53:57 1994
--- tty_pgo.c   Tue May 23 17:49:13 1995
***************
*** 390,405 ****
   * only prompts for a new name value on a change.
   */
  PRIVATE boolean32 tty_get_pgo_args
- #ifndef __STDC__
-     (op_handle, domain, show_defaults, reserved, is_alias, pgo_name,
prompts, stp)
-     ek_op_handle_t  op_handle;
-     eif_domain_t    domain;
-     boolean32       show_defaults;
-     boolean32       reserved;
-     boolean32       is_alias;
-     char            **prompts;
-     error_status_t  *stp;
- #else
    (
      ek_op_handle_t  op_handle,
      eif_domain_t    domain,
--- 390,395 ----
***************
*** 409,415 ****
      char            **prompts,
      error_status_t  *stp
    )
- #endif
  {
      error_status_t  st;
      boolean32       one_field_written = false,   /* assume no new data
entered */
--- 399,404 ----


I'm marking this CR as 'fix' with the fixedin as '1.2' `cuz I don't have a
clue as to what the right answer is. This fix has been rolled into the
start of the 1.2 work here at HP and will therefore get to OSF during the
first drop.

Sigh. 1.2 isn't a valid 'fixedin'. OSF, please fix asap. 1.1 until I get
some better choices.

[7/19/95 public]
Submitted to 1.1-maint as suggested above.



CR Number                     : 12823
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12729
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : wrappers?
Short Description             : read() on pipe fails after fork-execlp
Reported Date                 : 3/24/95
Found in Baseline             : 1.1
Found Date                    : 3/24/95
Severity                      : A
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.2
Affected File(s)              : threads/{RIOS,HP800}/cma_thread_io.c
Sensitivity                   : public

[3/24/95 public]

Here is the test program from IBM that demonstrates CMA problem in
DCE 1.1. Weidong has tried this test on AIX, HP-UX and OSF/1 DCE1.1
and DCE 1.03. He has observed problems on both AIX and HP-UX. OSF/1
does not exibit the problem. He also modified the program a little
bit to remove dup2 for fd 25. The problem still exists.

The errno 9 is set with child's first read (cma wrapped). However, with
native read it works. Comments!

----DEFECT BEGINS-----------------------------------------------------
We are trying to run VTS but we are having a problem with the programs
that are being execed by remote. When remote execs a program it opens
pipes between the parent and child and this is what is causing the
problem. Below is a sample program that illustrates the problem.
When the child program is compiled with dce it fails.
We are running on AIX 3.2.5 with the OSF DCE 1.0.3 base.

parent program
------------------------------------------------------------------
#include	<stdio.h>
#include	<errno.h>

void my_perror (char *);

main ()
{
	int	rc;
	char	buf[50];
	int	io_pipe[2];

	rc = pipe (io_pipe);
	if (rc == -1)
		my_perror ("write");
	rc = fork ();

	if (rc == 0) {
		int	fd;
		close (io_pipe[1]);
		fd = dup2 (io_pipe[0], 25);
		close (io_pipe[0]);
		printf ("call read before exec\n");
		rc = read (fd, buf, 10);

		printf ("read rc = %d  buf = <%s>\n", rc, buf);
		if (rc == -1)
			my_perror ("read");
		sprintf (buf, "%d", fd);
		printf ("pipe read fd = %s\n", buf);
		execlp ("bmw_c", "bmw_c", buf, 0);
		perror ("exec failed\n");
		exit (errno);
	} else {
		close (io_pipe[0]);
		printf ("write to pipe BEFORE exec\n");
		sprintf (buf, "0123456789");
		rc = write (io_pipe[1], buf, strlen(buf));
		if (rc == -1)
			my_perror ("write");

		printf ("write to pipe AFTER exec\n");
		sprintf (buf, "PIPE WRITE");
		rc = write (io_pipe[1], buf, strlen(buf));
		if (rc == -1)
			my_perror ("write");

		wait ();
	}

	exit (0);
}

void my_perror (char *s)
{
	perror (s);
	exit (errno);
}

-----------------------------------------------------------------------
child program
-----------------------------------------------------------------------

#ifdef	DCE
#include	<pthread.h>
#endif
#include	<fcntl.h>

main (int argc, char **argv)
{
	int	rc;
	char	buf[50];
	int	fd = 25;

#ifdef	DCE
	cma_init();
#endif

	printf ("%s start\n", argv[0]);
	printf ("pipe fd = %d\n", fd);
	rc = fcntl (fd, F_GETFL, 0);
	printf ("fcntl rc = %d\n", rc);
	printf ("call read on pipe\n");
	rc = read (fd, buf, 10);

	printf ("read rc = %d  buf = <%s>\n", rc, buf);
	if (rc == -1)
		perror ("read");

#undef	fcntl
#undef	read
	printf ("NATIVE calls\n");
	rc = fcntl (fd, F_GETFL, 0);
	printf ("fcntl rc = %d\n", rc);
	printf ("call read on pipe\n");
	rc = read (fd, buf, 10);

	printf ("read rc = %d  buf = <%s>\n", rc, buf);
	if (rc == -1)
		perror ("read");

	exit (0);
}

[3/24/95 public]
It looks like that cma dos not handle the already-opened file descriptors
correctly.

With this in mind, we checked the cma_init() code to see how it initializes
its internal file descriptor table. In cma__init_thread_io(), we found that
CMA only reopens the thre well known files (0, 1, 2). Except for SVR4 code,
CMA does not bother to check what other file descriptors that could have been
opened when the process starts (in this case, the parent opens a pipe, exec
the child, so the child starts with some file descriptors open).

I changed the code a little bit so that the child, before exec(), closes 0 and 
1, then dup its pipes' read and write descriptos to 0 and 1. As expected, the
code then works.

We still cannot explain why the original code would work on an OSF/1 platform.

We are going to try a fix to use fstat to go through all the file descriptors
to see whether any files are already opened.

As for VTS failure, Parul (our VTS expert) will get back to IBM folks.

[3/24/95 public]
We also tried with IBM DCE 1.2. With that, the above original code works.
Apparently, IBM's pthread package does the right thing.

Why the ibm folks are not using ibm's own pthread?

[3/24/95 public]

Iknow why OSF/1 was working with that code. I was using the OSF/1 system
pthread.h, not the DCE one. My fault.

So at least we see a consistent failure now.

[3/27/95 public]
Here is a fix to the problem. Basically, after reopening 0, 1, and 2 , we
go through all the possible file descriptors (up to cma__g_mx_file. Even
though getrlimit() with RLIMIT_NOFILE may be a more accurate way to find 
the number of files that can be opened currently, but it is not portable,
not every system supports it.), use fstat() to check whether this file is
currently open. If so, call cma__open_general() to set up the cma internal
data structures for this file descriptor.

I have tested the fix with 1.0.3 OSF/1, HP-UX,and AIX. THe above test code
can work now.

This is fix for DCE 1.0.3:

*** cma_thread_io.c.orig	Mon Oct 25 15:03:22 1993
--- cma_thread_io.c	Mon Mar 27 13:21:22 1995
***************
*** 639,644 ****
--- 639,645 ----
      {
  #if _CMA_UNIX_TYPE != _CMA__SVR4
      struct sigvec   vec, ovec;
+     struct stat sbuf;
  #else
      size_t	    	nfds, cur_fd, max_fds;
  	cma_t_integer	poll_status;
***************
*** 834,839 ****
--- 835,861 ----
  	    0;
  	ENDTRY
  	}
+ 
+     /* Need to find out what are the file descriptors that are currently
+        open */
+ 
+     /* Note: getrlimit() may be a more accurate way to find the number
+ 	of files that can be opened currently, but it is not portable,
+ 	not every system supports it. */
+ 
+     for (i = 3; i < cma__g_mx_file; i++) {
+ 	if ((fstat (i, &sbuf) == -1) && (errno == EBADF)) {
+ 	    continue;
+ 	}
+ 
+ 	/* file descriptor i is open, we need to let cma know */
+ 	TRY
+ 	    cma__open_general (i);
+ 	CATCH (cma_e_badparam)
+ 	    0;
+ 	ENDTRY
+     }
+ 
  #endif /* (_CMA_UNIX_TYPE ==  _CMA__SVR4) */
      }

[3/27/95 public]

Forgot to mention that DCE 1.1 thread code has the same problem. The fix
should be the same, except now since all platform specific (cma_thread_io.c
is one of them) code have been moved to each platform directory, I don't
want to put fix for each platform here. But the above should work.

[03/27/95 public]
Wow, are you really going to fstat every possible descriptor each time
a DCE program starts?  That can be very expensive...

[03/27/95 public]
That is just a start-up time cost, right?

Here is another possible way to fix it:

	Instead of calling fstat() to actually find out whether a file 
	descriptor is open, just mark internally that all files are open.
	CMA has the functionality built-in that will handle a bad file
	descriptor: when a EBADF is returned, CMA will loop through all
	possible file descriptors to do fstat() to find out ...
	Well, it is the same thing.

Another other fix?

[03/27/95 public]
Sure it is only startup.  But think:  should every DCE program start off
by doing "n" (n is 24...1024 depending on the OS) system calls?  I think
this is a bad thing.

Think of what the common cases are:  a server started by the system (or
dced) or a client program started by the user.  What % of DCE programs
will be started like this OT CR shows?  My bet is under 10%.  **Optimize
the common case.**

Perhaps CMA should only do the scan if/when it gets some descriptor that
it hasn't heard about.  This makes failures more expensive, but maybe only
the first one, and much less since it already will know about many descriptors.

Perhaps CMA's fork and exec could set an environment variable that somehow
specified which descriptors were open and CMA init could read that.
(Somehow encode the pid so the child can know it's got data from its parent).
Of course the envvar should be printable so the user doesn't get screwed up.

[03/27/95 public]
The setting env var approach puts the burden on the programmer. Like the test
case given above, the parent program is not a DCE one, so its fork()/execl()
cannot be made to pass anything, unless the programmer does it.

The problem with the current code is that cma will simply check its own fd
table to determine whether the file is open or not. In this case, since the
file was not opened through cma, the cma has no knowledge of it. So when the
file is used, cma simply says it is a bad number.

Maybe the more reasonable fix is to add a new field to the fd table:
fd_table[i].file_checked, which is initialized to be false. Every time a file
is accessed, cma should first check this field to see if it is true. If it is
flase, then regardless of what other fields say, cma should use fstat() to
check whether the file is really open and set the proper fileds for the table.
Then it sets the file_checked field to true. From then on, it depends on its
own field to detemrine if the file is open. This way cma will only fstat() the
files that the program uses, not everything. Comments?

[03/27/95 public]
It appears you didn't understand me.  The envvar would be set by CMA when
CMA was used in the parent.  The programmer couldn't (and in fact should
not be able to) set the envvar.

As for your "file_checked" field, that seems like a pretty good way to
implement my second suggestion.

[08/07/95 public]

This is so much fun ;)

Try this:

#include <pthread.h>

main()
{
        char c;
        if (read(0, &c, 1) < 0)
                exit(1);
        exit(0);
}

Well you guessed it, it does not work! It turns out that the cma__ts_func
macro does not initialize cma so you don't even get 0,1,2 if a read happens
to be the first cma wrapped call in your program. I think I'll open another
CR for this one.

[3/27/96 public]
Fix submitted to 1.2.2. This fix is required for fix in OT 13409 - cds-clerk
problem.

DIFF:
*** cma_thread_io.c@@/main/DCE_1.2/0    Fri Mar  8 15:37:52 1996
--- cma_thread_io.c     Fri Mar  8 16:53:16 1996
***************
*** 11,16 ****
--- 11,19 ----
  /*
   * HISTORY
   * $Log:	c012823,v $
# Revision 1.14  96/03/27  11:03:46  root
# changed fields:  new/changed/deleted note(s) [bissen 3/27/96 public] [bissen 3/27/96 public]
# 
+  * Revision /main/DCE_1.2/1  1996/03/08  21:53 UTC  bissen
+  *    OT 12823 fix for cma__init_thread_io
+  *
   * Revision 1.1.2.2  1994/06/09  13:35:50  devsrc
   *     CR10892 - fix copyright in file
   *    [1994/06/09  13:26:22  devsrc]
***************
*** 620,637 ****
        }

      /*
!      * "Open" the files (ie, within CMA) which are open by default:
!      *                stdin, stdout, stderr.
       *
!      * Ignore errors resulting from these files having been closed already.
       */
!     for (i = 0; i < 3; i++) {
!       TRY
!           cma__open_general (i);
!       CATCH (cma_e_badparam)
!           0;
!       ENDTRY
!       }
      }

  /*
--- 623,647 ----
        }

      /*
!      * "Open" all files that may have been passed across
!      * the exec, not just stdin, stdout, stderr.
       *
!      * While we're at it, we want to use cma__g_mx_file instead
!      * of cma__c_mx_file (which is defined to be FD_SETSIZE, a
!      * very large [2048] number).  Assert that cma__g_mx_file
!      * is no larger than cma__c_mx_file, since we created
!      * cma__g_file and cma__g_file_obj using cma__c_mx_file.
       */
!
!     cma__assert_fail (
!         cma__g_mx_file <= cma__c_mx_file,
!         "cma__init_thread_io: cma__g_mx_file > cma__c_mx_file" );
!
!     for (i = 0; i < cma__g_mx_file; i++) {
!         if( fcntl(i, F_GETFL, 0) == -1 && errno == EBADF )
!             continue;
!         cma__open_general (i);
!         }
      }

  /*



CR Number                     : 12775
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : DCE Backing Store Library : dce_db_open
Short Description             : Missing crucial parameters
Reported Date                 : 1/11/95
Found in Baseline             : 1.1
Found Date                    : 1/11/95
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : src/dce/utils/acldb/dbopen.c
Sensitivity                   : public

[1/11/95 public]

dce_db_open really needs 2 additional parameters to be maximally useful.
One is the file mode argument so that a caller can specify the mods to
be set when the file is created. Depending on the umask is not safe when
the information to be stored is confidential. Also, the dce_db_open API
should allow the user to specify access method specific data to the backend
selected. This would enable the caller to change important values such
as the in-memory cachesize or the on-disk page-size, which can improve
performance and save disk space, depending on what type of data you are
working with.

So I would suggest changing the API signature to:

void
dce_db_open(
    const char          *filename,
    const char          *backend_type,
    unsigned32          flags,
    int                 mode,
    void                *openinfo,
    dce_db_convert_func_t convert,
    dce_db_handle_t     *h,
    error_status_t      *st
)

Of course, you would probably need to change the name of the API to
preserve upwards compatibility.

[01/11/95 public]
I don't understand the "umask isn't safe" model.  Why doesn't
	u = umask(0077);
	dce_db_open(....)
	umask(u)
work?

That's a trick question. :-)  It doesn't work because dce_db_XXX makes no
guarantees about the underlying backend.  The API was designed so that
the BSD DB library could be ripped out and replaced, say, by a table in
an off-the-shelf relational database.

On the other hand, a generic openinfo argument is kind of neat, and might
be cleaner then what I always thought people would do:  use ",key=value"
substrings as part of the "backend_type" argument, viz:
	"db44-hash,cachesize=12"
Analogous to string bindings (and VMS fopen parameters :-).

Given the genericity (?) of the API, I'd support a dce_db_open_with_params
that had Sean's openinfo parameter, but not his mode parameter.

[2/9/96 public]

Hmm, I regret I never saw the response above till now, because now
I understand your "genericity" concerns. Anyway, we ended up fixing
this problem locally and it went in to 1.2.1 as part of a
bugfix drop. It's currently named dce_db_open_file() - to imply that 
the operation is for a file, and it adds the openinfo and mode
arguments. It's undocumented so we can always drop the mode argument
if there is further disagreement or it could return an "unsupported"
error if the backend is ever replaced. I was concerned of the implications
of a umask() switch in a multi-threaded environment. I'm marking
as 'fix' for now.



CR Number                     : 12762
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : Piece of FLDB entry being written in host-order, should be network-order
Reported Date                 : 12/6/94
Found in Baseline             : 1.0.3
Found Date                    : 12/6/94
Severity                      : C
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : file/flserver/flprocs.c
Sensitivity                   : public

[12/6/94 public]
Fts test13 was intermittently hanging because of a problem in
VL_CreateServer() path. This routine calls EnsureAddrEntry()
to make sure that an FLDB entry doesn't already exist for the
specified server. For this we need to read server information
from the FLDB and convert it into host format (little endian
for alpha machines). The problem was being caused by a
previous write to the FLDB having written data in the host
format instead of network format. As a result, one of the loop
counters that should have been 0x40 was turning out to be
0x04000000. Not only was this causing us to spend a lot longer
in one of the loops, but when used as an array index, it was
also resulting in bad data accesses.
 
The problem has been fixed by making sure we do an ntohl()
when we read data from the FLDB and an htonl() before writing
stuff back.
 
The fix is in ./file/flserver/flprocs.c
 
Lines marked with '>' are the three new lines added to the code (search for
"firstEmptyBlock = &NextBlock;"):
 
--------------------------
	    }
	    firstEmptyBlock = &NextBlock;
	    firstEmpty = &(firstEmptyBlock->Sites[firstEmptyIndex]);
>	    firstEmptyBlock->NextPtr = ntohl(firstEmptyBlock->NextPtr);
>           firstEmptyBlock->AllocHere = ntohl(firstEmptyBlock->AllocHere);
>           firstEmptyBlock->UsedHere = ntohl(firstEmptyBlock->UsedHere);
	    NextBlockAddr = firstBlockAddr;
	}
 
	bcopy ((char *)Addr, (char *)&(firstEmpty->Addr[0]), 
	       sizeof(afsNetAddr));
--------------------------
 
	Steve Strange, Digital Equipment Corp., 12/6/94

[12/7/94 public]
Oops.  The fix is correct.



CR Number                     : 12760
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : synchronization problems between processes on one client
Reported Date                 : 12/6/94
Found in Baseline             : 1.0.3, 1.1
Found Date                    : 6/6/94
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : several
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : 

[12/6/94 public]
 
We (Digital) have a file exerciser test that attempts to do
open/write/read/close cycles on files.  One option specifies that a number
of processes should try to perform this cycle all on the same file at the
same time.  This results in a number of different errors that can be traced
to race conditions between the processes that are caused by dfs.  We have
made two changes to the dfs code that attempt to eliminate these race
conditions, but it appears that a basic design change would be needed to
address the problem more generally.  In other words, our fixes make the
problem more rare, but don't eliminate it.  I should add that the
problem is very unlikely to occur in normal use of dfs, we just happen to
have a test that induces it.
Problem description
-------------------
 
We have noticed a couple of problems with single-site semantics between
processes accessing the same file on the same client. We have not changed
anything significantly from the reference platform client in our
implementation so we suspect these problems exist in the reference port
as well.
 
The problems have to do with race conditions when opening a file. The
first problem occurs when two processes are creating the same file
simultaneously (QAR 23844), the second problem when one process is
unlinking a file while another is creating a file of the same name
(QAR 24022). The later is the the more significant and difficult to fix
problem. We have fixes for both problems though we're not sure they are
ideal.  
 
An interesting common factor to these problems is that when the two client
processes race for the same or conflicting operations at the server,
the first RPC to reach the server and "succeed" is also the last to
return back to the client presumably because a it is doing more work
there. In the mean time the RPC for the process that losses the race is
already back to the client and potentially finds inconsistent state between
what it just was told on the server and what exists on the client.
I assume that the merge status operations on the client are suppose to
manage this issue but they don't appear in to handle all the possible
same host client to client race-conditions.
 
Creation Race:
 
Two process are trying to simultaneously create a file of the same name.
One process succeeds and the other gets a ENOENT (bad path or file name).
 
What happens
 
The process that fails, first does an RPC to the server and gets that the
file already exists. Because the process that beat it to the server for the
create hasn't yet returned, the failing process finds bogus fid information
for the file on the client in the name hash and returns ENOENT.
 
On the client the sequence is as follows;
 
 Process 1,                     Process 2,
 open(OCREAT) succeeds          open(OCREAT) fails
 ---------------------          --------------------
 
 open(OCREAT, ...)
  cm_lookup()
   nh_dolookup()
    Calls AFS_Lookup()
                                open(O_CREATE, ...)
                                  cm_lookup()
                                   nh_dolookup()
                                    Calls AFS_Lookup()
    AFS_Lookup() rtns no such file
*   nh_enter() enters fid with Vnode set to 0
  cm_create()
   Calls AFS_CreateFile()
                                    AFS_Lookup() rtns no such file
*                                   nh_enter() enters fid with Vnode set to
                                  cm_create()
                                   Calls AFS_CreateFile()
                                   AFS_CreateFile rtns 22 already exists
                                   cm_lookup()
                                    ns_dolookup()
                                        FAILURE
                                        - Finds fid for file with a 0
vnode,
                                        rtns ENOENT.-
   AFS_CreateFile rtns success
   ....
   goes on to successfully create
   the file (and name hash entry and
   scp).
Solution;
 
I removed the call to nh_enter() in nh_dolookup() when AFS_Lookup()
returns ENOENT (*). The AFS_CreateFile by process 2 still fails but
now the ns_dolookup() that follows goes all the way to the server
to get the fid for the file. The fid is then used to either
find or create an scp for the file and process 2's  open
returns success.
 
Code Change;
 
cm_dnamhash.c
 
nh_dolookup()
 
425,439c425,427
<           fidp->Vnode = 0;
<           /* UpdateStatus explains fundamental cache algorithm here.
<            * Note how this works: if dirRevokes increases, it tells us
<            * that a modification occurred to the directory *by some
<            * other client* while our call was running (with the vnode
<            * unlocked).  If startDirChangeTime changes, it tells us
<            * that some other thread on this client made an RPC that
<            * modified the directory (and potentially this name mapping).
<            * If this modification occurred before our lookup, the results
<            * of our lookup are fine.  Since AFS_Lookup doesn't change the
<            * inode change time, the startDirChangeTime should represent
<            * the changeTime at the server when our AFS_Lookup call
executed.
<            * Even if our call changed the ctime, we'd just take the
<            * "invalidate" (nh_delete) branch below, which is always
<            * safe to do.
---
>           /*
>            * Always delete entry. solves race on multiple open(OCREAT..)
>            * by client processes of the same file.
441,445c429
<           if (irevcnt == dscp->dirRevokes &&
<               cm_tcmp(dscp->m.ServerChangeTime, startDirChangeTime) <= 0)
<               nh_enter(dscp, namep, fidp);
<           else
<               nh_delete(dscp, namep);
---
>            nh_delete(dscp, namep);
 
Brad Nichols, 6/29/94
Open Unlink Race:
 
One process is trying to unlink a pre-existent file while another is trying
to
open it with an O_CREAT flag. The unlink succeeds and the opening process
gets
EINVAL (invalid argument).
 
What happens;
 
As with the other problem the failing process gets the late start. A lookup
says that the file exists on the server. The process then goes for tokens
also at the server but buy this time the AFS_RemoveFile() by the other
process
has nuked the vnode on the server. The get tokens operation on the server
fails because of invalid argument, the non-existent vnode.
 
On the client the sequence is;
 
        Process 1,                      Process 2,
        unlink() succeeds               open(O_CREAT) fails
        ---------------------           --------------------
 
                                        close()
 
        close()
        unlink()
         AFS_RemoveFile()
 
                                        unlink()
                                         AFS_Remove()
                                         AFS_Remove() rtns ENOENT
 
                                        open()
                                         cm_lookup(), finds fid in name
hash
                                         cm_open()
                                          cm_GetToken()
                                           AFS_GetToken()
 
         AFS_RemoveFile() rtns success
         merge status of parent dir
         merge status of file
 
                                           AFS_GetToken() rtns invalid arg
                                           FAILURE
                                           - because a VOL_VGET() on server
                                           couldn't find the vnode of the
fid. 
 
        .....
Solution;
 
The open() wants to use a fid/scp to get tokens on the
file. The unlink() may invalidate them (the fid specifically)
but won't do so on the client until its AFS_RemoveFile() returns.
 
To prevent the open() processes from using fid/scp data that
may be invalid on the server. I added code to mark a scp
as the target of an in-progress remove on the server. The
cm_remove() puts the mark on and the cm_lookup() watches for
the mark. The mark is an additional flag named SC_UNLINKING to
the scp states field.
 
To add this feature the cm_remove() was modified to lookup the
fid of the file it is deleting, retrieve the scp and mark it,
all before it makes the AFS_RemoveFile(). Previously the
cm_remove() only need the file fid and scp after the
AFS_RemoveFile() returned. When the RPC returns, regardless of
success or failure, cm_remove() removes the mark from the file
scp and wakes any threads that might be waiting on that flag.
 
The cm_lookup was modified to check for an unlinking mark
before using a scp. If the unlinking flag is set, cm_lookup()
sleeps waiting for it to clear.
Code
 
cm_scache.h
 
550a551
> #define SC_UNLINKING    0x400000        /* A client is doing a
AFS_remove() o
cm_vnodeops.c
 
cm_lookup()
2665a2666,2672
>           /* Check to see if a cm_remove() is trying to unlink this
>            * same file. If so wait till it clears.
>            */
>           while (tscp->states & SC_UNLINKING)  {
>             osi_SleepW((opaque)(&tscp->states),&tscp->llock);
>             lock_ObtainWrite(&tscp->llock);
>           }
cm_remove()
 
3060a3068
>     afsFid tfid;
3098a3107,3133
>
>     /* Lookup fid for file. (may mean rpc to server) if there is
>      * no fid, we'll return no such file.
>      */
>     code = nh_dolookup(dscp, namep, &tfid, &rreq);
>     if (code == ENOENT) {
>       /*
>        * Name is known not to exist.
>        */
>       code = ENOENT;
>       goto done;
>     }
>
>     /* Grab an scache entry for the fid.
>      */
>     scp = cm_GetSCache(&tfid, &rreq);
>     if (!scp) {
>       code = ENOMEM;
>       goto done;
>     }
>
>     /* Mark scp as having a unlink attempt in-progress.
>      */
>     lock_ObtainWrite(&scp->llock);
>     scp->states |= SC_UNLINKING;
>     lock_ReleaseWrite(&scp->llock);
>
3115c3150
<       goto done;
---
>       goto bad1;
3126c3161
<       goto done;
---
>       goto bad1;
3129c3164
<      * Now, get vnode for unlinked dude, and see if we should force it
from
---
>      * Now, look at vnode for unlinked dude, and see if we should force
it fr
3134,3140d3168
<     lock_ObtainWrite(&cm_scachelock);
<     scp = cm_FindSCache(&OutDelFileFid);
<     if (!scp) {
<       scp = cm_NewSCache(&OutDelFileFid, dscp->volp);
<     }
<     lock_ReleaseWrite(&cm_scachelock);
<     if (scp) {
3155a3184,3192
> bad1:
>     /* Unmark scp as being in an unlink.
>      */
>     scp->states &= ~SC_UNLINKING;
>
>     /* Wakeup anybody waiting for unlink to complete
>      */
>     osi_Wakeup(&scp->states);
>
3160c3197
<     }
---
>
----------------
end descriptions
As I mentioned at the top of this file, these two fixes help the race
situation, but don't completely eliminate it.  I believe the problem lies
in the fact that DFS maintains an active file reference count of the number
of different client hosts accessing a given file, rather than the total
number of processes accessing a given file.  In other words, if two
processes on a single client are accessing a single file, the server sees
it as only one process, because all the requests are coming from one
client.  The server cannot distinguish between different processes on a
single client.  I hope that someone will correct me if I have made the
wrong conclusion from investigating the code and icl traces here.
 
	Steve Strange, Digital Equipment Corp.  12/6/94

[12/6/94 public]
These analyses are pretty much on the money.  Transarc has found these and
several other comparable bugs that have required this kind of fix.
I believe, though, that we've fixed them with a minimum of un-cacheing.
It would take some analysis to go back and reconstruct exactly what we've
done to deal with these two scenarios.  I think that for the first one,
when we get EEXIST from AFS_CreateFile, we do some further analysis
and hook into the race at that point, rather than never cacheing the
ENOENT from AFS_Lookup.  (Avoiding that cacheing will have a significant
performance penalty.)  I don't remember what we did for the second case,
but I believe that we handled it in another way.
 
It's true that, generally, token conflicts are used to assure consistency
for these matters between clients, while the problems for multiple processes
within a single client are addressed in other ways, like careful updates
to the DNLC mediated by these time progressions and numbers of revocations.

[12/7/94 public]
.
I'll elaborate on Craig's reply, which is correct as far as it goes.
.
We have discovered the same problems.  Internally at Transarc, the defect has
reference number 5758, although there is also some connection with 5418.
.
In general, there are races between lookups, creations, and deletions.  The
two you have mentioned are by no means the only ones.
.
Our defect 5418 observed that if a client had a reference to a vnode, but
didn't have the vnode open, another client might delete the file, and the
first client's reference might become stale.  We fixed this by adding new
semantics to TKN_OPEN_PRESERVE, so that a client would not return this token
type or allow it to be revoked if there the vnode had a high reference count.
The server, in turn, would not delete the file unless it could revoke this
token.  Changes to implement this were extensive.  Among other changes, both
cm_GetSCache and nh_dolookup check for TKN_OPEN_PRESERVE after merging the
status of the RPC.  Thus those functions now systematically detect races of
the kinds described in this OT report.
.
cm_lookup calls first nh_dolookup, then cm_GetSCache.  Either of these can
uncover a stale vnode.  The straightforward recovery is simply to retry, i.e.
go back and call nh_dolookup again, etc.  This was the first change I
implemented under defect 5758.  cm_create, which follows the same sequence,
will retry similarly.  An arbitrary limit on the number of retries (10) was
set, in order to avoid non-interruptible infinite loops.  Also, the retry is
done only if nh_dolookup returns a different fid each time, since if it keeps
returning the same fid, the likelihood is that the directory on the server is
damaged and the directory entry is giving a bogus fid.
.
Of course, it was necessary to change the signature of cm_GetSCache, so that
in case of failure, the caller could determine whether the failure was due to
a race (ESTALE) or some other condition (e.g. ETIMEDOUT).  The retry would be
done only for ESTALE.
.
This retrying doesn't help in the case where cm_create does the AFS_CreateFile
RPC and it returns successfully, but the subsequent MergeStatus leaves us with
a stale vnode (because in the mean time the file has been deleted).  There is
no completely correct recovery in this case.  However we found that many of
these races could be avoided by suitably modifying cm_remove and cm_rmdir.  In
those functions we now call nh_delete() before doing the RPC, rather than
waiting until after.  (We still call nh_delete() after the RPC, but it is now
usually redundant.)  The advantage of calling nh_delete() before the RPC is
that if there is a create on the same client concurrently with the remove or
rmdir, the nh_dolookup call done by the create will go to the server, rather
than relying on a name-hash entry that is in the process of becoming invalid.
It's still possible for a race to occur, but it's less likely.
.
Looking at the changes you (DEC) have suggested, I believe that our changes
are more systematic, but I think that your changes would be a reasonable
stopgap measure.
.
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `'

[12/7/94 public]
In the above note, I mentioned that we added new semantics to TKN_OPEN_PRESERVE.
I forgot to add that this was a client-only change.  The server code already
handles TKN_OPEN_PRESERVE the way we wanted it to (i.e. it conflicts with
TKN_OPEN_DELETE).  So our change did not create an interoperability problem.
.

[12/27/94 public]
This sounds like an important testcase to run for regression testing and, as
Bruce pointed out, for interoperability testing. Rich, can we add either the
Dec test or the similar testcases Transarc uses to the FVTs you are planning
on delivering with 1.2? The ideal case would be to submit it early enough for
the ILab to have access to it in time for IFEST (which is in June?) - Let
me know - thanks.



CR Number                     : 12740
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : flserver
Short Description             : UHYP: flserver fails to startup during config
Reported Date                 : 11/1/94
Found in Baseline             : 1.1b23
Found Date                    : 11/1/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 1.1unintegrated, 1.1maint
Affected File(s)              : flutils.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/1/94 public]

During startup flserver looks for the dfs-server principal to make
sure it exists.  It does this with a call to
sec_rgy_pgo_get_by_name().  Unfortunatly the cursor handle was never
inititalized, causing flserver to not find the principal in some
cases.  The following change to flutils.c fixes this problem.

*** ./flutils.c	Wed Jul 13 18:19:22 1994
--- /tmp/flutils.c	Mon Oct 31 15:04:06 1994
***************
*** 1017,1022 ****
--- 1017,1023 ----
     sec_rgy_site_open((unsigned_char_t *) NULL, &sechandle, &st);
     if (st != 0)
         return(st);
+    sec_rgy_cursor_reset(&cursor);
     sec_rgy_pgo_get_by_name(sechandle, sec_rgy_domain_person,
                             princp, &cursor, &pgo_item, &st);
     sec_rgy_site_close(sechandle, &st2);

[10/4/96 public]

  This fix was included in 1.1 maintenance tree in Feb. 1996.



CR Number                     : 12736
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : 
Short Description             : UHYP:dce1.1 unintegrated - cdscp show server core dumped -  2759 Floating exception
Reported Date                 : 10/27/94
Found in Baseline             : 1.1
Found Date                    : 10/27/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : admin/dced/server/epops.c
Sensitivity                   : public

[10/27/94 public]
Core smoketest failed on all platforms:

extract from file run_commands.log in directory /u1/RAT_tools on budapest:

Password must be changed!
cdscp show server
/u1/RAT_tools/run_commands: 2759 Floating exception - core dumped

[10/27/94 public]
Fix was to use a local variable for status code in utility functions.



CR Number                     : 12731
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : UHYP: dce_aud_next writes on what should be a read only argument
Reported Date                 : 10/26/94
Found in Baseline             : 1.1b22
Found Date                    : 10/26/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : evt_read.c
Sensitivity                   : public

[10/26/94 public]
The public api, dce_aud_next, while parsing it input "predicate" list
argument, attempts to write a NULL into this string.  Doing so on
the 486 causes a segment fault.  Instead of writing on "predicate",
a copy of it should be made.

[10/26/94 public]
Submitted.



CR Number                     : 12729
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12627,12823
Project Name                  : dce
H/W Ref Platform              : mx300,other
S/W Ref Platform              : sinix,other
Component Name                : dced
Subcomponent Name             : secval
Short Description             : dced_wait_for_sec() calls sec_rgy_site_bind() little too early
Reported Date                 : 10/26/94
Found in Baseline             : 1.1unintegrated
Found Date                    : 10/25/94
Severity                      : A
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 1.1maint
Affected File(s)              : admin/dced/server/main.c
Sensitivity                   : public

[10/26/94 public]

   The dced is exibiting some time synchronization problem. The function
   dced_wait_for_sec() calls sec_rgy_site_bind() little too early as it
   hangs because secd was not in a good state by then. By putting a
   dced_sleep() of 30 seconds helped prevent this problem. This fix is adhoc
   and needs a better solution.

   This problem was causing the dce_config to loop that checks for the
   creation of the file sec_client.binding.

[10/26/94 public]
It needs to be determined if calling sec_rgy_site_bind() with the secd
not up is a valid thing to do, if so then this should be a security
bug.  Note that there is another OT (12627) which demonstrates a hang
in a call by dced to secd (that call is different, sec_login_validate_first())

As discussed, if this use of sec_rgy_site_bind() is invalid:

  a. It should be documented with a big, red stamp across the man page.
  b. It might be possible to use ...is_server_listening() to the secd

Why does hang not occur on the other platforms?  Certainly the speed
of the platforms may be different (isn't SNI a 486?, different clock?)
but possibly the PROT_SEQ is differnt or maybe the TCP/IP implementation
causes it to behave differently?  Someone pointed out that SVR4 would be
using a streams implementation of TCP whereas OSF/1 would be more Berkeley-ish.
Have other RPC bevahiour differences been noted on the SNI?

[03/22/95 public]

After some investigation, we have figured that the svc routines causes
initialization of thread environment before the fork is called in
background() invoked in main(). This was sometimes causing hang in the
child. So the proposed solution is to move the fork well ahead of using
all *svc* routines. I have split the background() routine into
1) background_parent() to fork out a child and then wait for its initialization,
and 2) background_child() to start up dced environment in the order it
was meant to be done. Additional routine need_background() checks to see
if dced needs to be put into background.

Following is the diff of proposed change. Please review and give us
feedback before we make it a part of 1.1 maintenance code. The changes
are conditionalized using '#ifdef SNI_SVR4' for convenience:

*** /project/dce/build/dce1.1-maint/src/admin/dced/server/main.c	Thu Feb 16 16:53:11 1995
--- main.c	Tue Mar 21 17:32:21 1995
***************
*** 298,304 ****
--- 288,300 ----
  static void	register_servers(service_table_t*, int,error_status_t*);
  static void	unregister_server(service_table_t*, error_status_t*);
  static void	*signal_catcher(void *);
+ #ifdef SNI_SVR4
+ static void	background_parent(void);
+ static void	background_child(void);
+ static int	need_background(int, char **);
+ #else
  static void	background(void);
+ #endif
  static void 	*bootstrap_mgmt(void *arg);
  
  /* Global definitions. */
***************
*** 439,444 ****
--- 435,444 ----
      int			i;
      char		**pp;
  
+ #ifdef SNI_SVR4
+     if (need_background(ac, av))
+ 	background_parent();
+ #endif
      /* Basic setup. */
      dce_svc_set_progname("dced", &st);
      dce_msg_define_msg_table(dced_svc_g_table,
***************
*** 452,458 ****
--- 452,462 ----
      if (!debug && chdir(dced_dir) < 0)
  	dce_svc_printf(DCED_S_CANT_INIT_SOMETHING_MSG, "working directory", (long)errno);
      if (!in_foreground)
+ #ifdef SNI_SVR4
+ 	background_child();
+ #else
  	background();
+ #endif
  
      if (!initialize_databases) {
  	read_object_uuid(&st);
***************
*** 671,677 ****
  #endif	/* defined(SIGDANGER) */
  	SIGHUP, SIGINT, SIGQUIT, SIGTERM
      };
!     sigset_t		catch_these;
      int			i;
      error_status_t	st;
  
--- 675,681 ----
  #endif	/* defined(SIGDANGER) */
  	SIGHUP, SIGINT, SIGQUIT, SIGTERM
      };
!     sigset_t		catch_these, old_set;
      int			i;
      error_status_t	st;
  
***************
*** 680,686 ****
--- 684,696 ----
  	sigemptyset(&catch_these);
  	for (i = 0; i < sizeof catch_sigs / sizeof catch_sigs[0]; i++)
  	    sigaddset(&catch_these, catch_sigs[i]);
+ #ifdef SNI_SVR4
+ 	sigprocmask (SIG_BLOCK, &catch_these, &old_set);
+ #endif
  	i = sigwait(&catch_these);
+ #ifdef SNI_SVR4
+ 	sigprocmask (SIG_SETMASK, &old_set, NULL);
+ #endif
  	/* Note continue below, to re-do the loop. */
  	switch (i) {
  	default:
***************
*** 754,760 ****
--- 764,850 ----
      dce_svc_printf(DCED_S_IS_LISTENING_MSG);
  }
  
+ #ifdef SNI_SVR4
+ static int		pipes[2];
+ 
  static void
+ background_parent(
+     void
+ )
+ {
+     pid_t		pid;
+     char		dummy;
+     int			i, child;
+ 
+     if (pipe(pipes) < 0)
+ 	exit(1);
+ 
+     pid = fork();
+ 
+     if (pid < 0)
+ 	fprintf(stderr, "dced failed fork fork with error:%s.\n",
+                 strerror(errno));
+ 
+     if (pid > 0) {
+ 	/* We're the parent.  Block in read() until the child exits. */
+ 	close(pipes[1]);
+ 	read(pipes[0], &dummy, sizeof dummy);
+ 
+ 	/* How is the child? */
+ 	child = waitpid(pid, &i, WNOHANG);
+ 	if (child == 0) {
+ 	    /* No child exited, so dced is still running.  Good. */
+ 	    _exit(0);
+ 	}
+ 
+ 	if (child == pid)
+ 	    fprintf(stderr, "dced child (pid %l) exited with status %d.\n",
+                     (long)pid, i);
+ 	else
+ 	    fprintf(stderr, "dced wait for pid %l returned %d and error:%s.\n",
+                     (long)pid, child, strerror(errno));
+ 	fflush(stderr);
+ 	_exit(1);
+     }
+ }
+ 
+ static void
+ background_child(
+     void
+ )
+ {
+     pthread_t		tid;
+     int			i;
+     pthread_attr_t	my_attr;
+ 
+     /* Child.  Close pipe, spawn listener-checker. */
+     close(pipes[0]);
+ #if	defined(THREAD_STACK_SIZE)
+     pthread_attr_create(&my_attr);
+     pthread_attr_setstacksize(&my_attr, THREAD_STACK_SIZE);
+ #else
+     my_attr = pthread_attr_default;
+ #endif	/* defined(THREAD_STACK_SIZE) */
+     if (pthread_create(&tid, my_attr, check_listener, (void *)pipes) < 0)
+ 	dce_svc_printf(DCED_S_CANT_INIT_SOMETHING_MSG, "check_listener", (long)errno);
+     pthread_detach(&tid);
+ 
+     /* Go away, tty. */
+     if ((i = open("/dev/null", O_RDONLY)) >= 0) {
+ 	(void)dup2(i, 0);
+ 	(void)close(i);
+     }
+     if ((i = open("dced.log", O_WRONLY | O_CREAT | O_TRUNC, 0644)) >= 0) {
+ 	(void)dup2(i, 1);
+ 	(void)dup2(i, 2);
+ 	(void)close(i);
+     }
+     setsid();
+ }
+ 
+ #else /* SNI_SVR4 */
+ 
+ static void
  background(
      void
  )
***************
*** 822,827 ****
--- 912,919 ----
      setsid();
  }
  
+ #endif /* SNI_SVR4 */
+ 
  static void
  dced_wait_for_secval(
      error_status_t	*st
***************
*** 882,887 ****
--- 974,994 ----
  
      return NULL;
  }
+ 
+ #ifdef SNI_SVR4
+ static int
+ need_background(int ac, char **av)
+ {
+     int i, res = TRUE;
+ 
+     for (i=1; res && i<ac; i++) {
+ 	if (strlen(av[i]) == 2 && av[i][0] == '-' &&
+             (av[i][1] == 'd' || av[i][1] == 'f' || av[i][1] == 'i'))
+ 	   res = FALSE;
+     }
+     return(res);
+ }
+ #endif
  
  static void
  parse_args(int ac, char **av)

[03/22/95 public]
That need_background hack is awful.   It won't work since it requires
the -[dfi] flags to be written by themselves.  Legal invocations,
	dced -pd
aren't caught.

Too bad, since the rest of the work-around is palatable.

I think this is basically an SVR4 threads issue.

[03/22/95 public]
OK. I have changed need_background() hack with a smaller hack with optind.
The new need_background looks like this:

#ifdef SNI_SVR4
static int
need_background(int ac, char **av)
{
    int c, res = TRUE;

    while (res && (c = getopt(ac, av, "bdefhipsw:c")) != -1) {
        switch (c) {
        default:
            break;
        case 'd':
        case 'f':
        case 'i':
            res = FALSE;
            break;
        }
    }

    /* Restore optind to reparse the arguments */
    optind = 1;
    return(res);
}
#endif

Rich, looking at the related OT12627 that Rob mentioned, it may not be SVR4
only problem or even they may not be related.

[03/22/95 public]
Mucking with the internals of getopt is worse then what you originally had.
It should be possible to restruct parse_args so that it can be called earlier.
(It's okay to init SVC in the failure case since we're going to exit.)
I believe 12627 is unrelated as it refers to a hang after work has
been done.  There is no evidence that this is other then an SVR4/threads
porting issue.

[03/24/95 public]
Re: parse_args, I'll come up with the fix that don't require getopt mucking.
However some interesting test came from IBM that indicates CMA problems with
pipe, read, fork, exec combination on AIX and HP-UX. OT# 12823. Please check
it out.

[03/27/95 public]
OK. Last try:
#ifdef SNI_SVR4
static int
need_background(int ac, char **av)
{
    int idx, res = TRUE;

    for (idx=1; res && idx<ac; idx++) {
        if (av[idx][0] == '-' && av[idx][1] != 'w' &&
            ( strchr(av[idx], 'd') ||
              strchr(av[idx], 'f') ||
              strchr(av[idx], 'i') )) {
            res = FALSE;
        }
    }
    return(res);
 }
#endif

By the way, if after putting fix for OT 12823 makes dced hang after fork, then
we would have to make this ifdef'ed solution generally available.

[03/28/95 public]
Sigh.  Please don't hack arg-parsing.

Change parse_args so that instead of doing anything it sets a few new
global variables.  (Hint:  you don't need an array of strings to hold
any protseqs, just a single char** set to argv.)

[03/28/95 public]
Here is the final version of the fix. I was trying to avoid globals as much
possible.

*** /project/dce/build/dce1.1-maint/src/admin/dced/server/main.c	Thu Feb 16 16:53:11 1995
--- main.c	Tue Mar 28 13:20:22 1995
***************
*** 298,304 ****
--- 298,310 ----
  static void	register_servers(service_table_t*, int,error_status_t*);
  static void	unregister_server(service_table_t*, error_status_t*);
  static void	*signal_catcher(void *);
+ #ifdef SNI_SVR4
+ static void	background_parent(void);
+ static void	background_child(void);
+ static void	process_args(int, char **);
+ #else
  static void	background(void);
+ #endif
  static void 	*bootstrap_mgmt(void *arg);
  
  /* Global definitions. */
***************
*** 340,346 ****
--- 346,360 ----
  static boolean		in_foreground;		/* run in foreground? */
  static boolean		endpoints = TRUE;
  static char		**protseqs;
+ #ifdef SNI_SVR4
+ static boolean          purging;
+ static int              showusage;
+ static idl_char         *svcroute;
  
+ #define HELPUSAGE	1
+ #define ERRORUSAGE	2
+ #endif /* SNI_SVR4 */
+ 
  /* ______________________________________________________________________ */
  
  static void
***************
*** 439,444 ****
--- 453,463 ----
      int			i;
      char		**pp;
  
+ #ifdef SNI_SVR4
+     parse_args(ac, av);
+     if (!in_foreground)
+ 	background_parent();
+ #endif
      /* Basic setup. */
      dce_svc_set_progname("dced", &st);
      dce_msg_define_msg_table(dced_svc_g_table,
***************
*** 448,458 ****
--- 467,485 ----
      if (st != error_status_ok)
  	dce_svc_printf(DCED_S_CANT_INIT_SOMETHING_MSG, "global data", (long)st);
  
+ #ifdef SNI_SVR4
+     process_args(ac, av);
+ #else
      parse_args(ac, av);
+ #endif
      if (!debug && chdir(dced_dir) < 0)
  	dce_svc_printf(DCED_S_CANT_INIT_SOMETHING_MSG, "working directory", (long)errno);
      if (!in_foreground)
+ #ifdef SNI_SVR4
+ 	background_child();
+ #else
  	background();
+ #endif
  
      if (!initialize_databases) {
  	read_object_uuid(&st);
***************
*** 671,677 ****
  #endif	/* defined(SIGDANGER) */
  	SIGHUP, SIGINT, SIGQUIT, SIGTERM
      };
!     sigset_t		catch_these;
      int			i;
      error_status_t	st;
  
--- 698,704 ----
  #endif	/* defined(SIGDANGER) */
  	SIGHUP, SIGINT, SIGQUIT, SIGTERM
      };
!     sigset_t		catch_these, old_set;
      int			i;
      error_status_t	st;
  
***************
*** 680,686 ****
--- 707,715 ----
  	sigemptyset(&catch_these);
  	for (i = 0; i < sizeof catch_sigs / sizeof catch_sigs[0]; i++)
  	    sigaddset(&catch_these, catch_sigs[i]);
+ 	sigprocmask (SIG_BLOCK, &catch_these, &old_set);
  	i = sigwait(&catch_these);
+ 	sigprocmask (SIG_SETMASK, &old_set, NULL);
  	/* Note continue below, to re-do the loop. */
  	switch (i) {
  	default:
***************
*** 754,760 ****
--- 783,869 ----
      dce_svc_printf(DCED_S_IS_LISTENING_MSG);
  }
  
+ #ifdef SNI_SVR4
+ static int		pipes[2];
+ 
  static void
+ background_parent(
+     void
+ )
+ {
+     pid_t		pid;
+     char		dummy;
+     int			i, child;
+ 
+     if (pipe(pipes) < 0)
+ 	exit(1);
+ 
+     pid = fork();
+ 
+     if (pid < 0)
+ 	fprintf(stderr, "dced failed fork fork with error:%s.\n",
+                 strerror(errno));
+ 
+     if (pid > 0) {
+ 	/* We're the parent.  Block in read() until the child exits. */
+ 	close(pipes[1]);
+ 	read(pipes[0], &dummy, sizeof dummy);
+ 
+ 	/* How is the child? */
+ 	child = waitpid(pid, &i, WNOHANG);
+ 	if (child == 0) {
+ 	    /* No child exited, so dced is still running.  Good. */
+ 	    _exit(0);
+ 	}
+ 
+ 	if (child == pid)
+ 	    fprintf(stderr, "dced child (pid %l) exited with status %d.\n",
+                     (long)pid, i);
+ 	else
+ 	    fprintf(stderr, "dced wait for pid %l returned %d and error:%s.\n",
+                     (long)pid, child, strerror(errno));
+ 	fflush(stderr);
+ 	_exit(1);
+     }
+ }
+ 
+ static void
+ background_child(
+     void
+ )
+ {
+     pthread_t		tid;
+     int			i;
+     pthread_attr_t	my_attr;
+ 
+     /* Child.  Close pipe, spawn listener-checker. */
+     close(pipes[0]);
+ #if	defined(THREAD_STACK_SIZE)
+     pthread_attr_create(&my_attr);
+     pthread_attr_setstacksize(&my_attr, THREAD_STACK_SIZE);
+ #else
+     my_attr = pthread_attr_default;
+ #endif	/* defined(THREAD_STACK_SIZE) */
+     if (pthread_create(&tid, my_attr, check_listener, (void *)pipes) < 0)
+ 	dce_svc_printf(DCED_S_CANT_INIT_SOMETHING_MSG, "check_listener", (long)errno);
+     pthread_detach(&tid);
+ 
+     /* Go away, tty. */
+     if ((i = open("/dev/null", O_RDONLY)) >= 0) {
+ 	(void)dup2(i, 0);
+ 	(void)close(i);
+     }
+     if ((i = open("dced.log", O_WRONLY | O_CREAT | O_TRUNC, 0644)) >= 0) {
+ 	(void)dup2(i, 1);
+ 	(void)dup2(i, 2);
+ 	(void)close(i);
+     }
+     setsid();
+ }
+ 
+ #else /* SNI_SVR4 */
+ 
+ static void
  background(
      void
  )
***************
*** 822,827 ****
--- 931,938 ----
      setsid();
  }
  
+ #endif /* SNI_SVR4 */
+ 
  static void
  dced_wait_for_secval(
      error_status_t	*st
***************
*** 883,892 ****
--- 994,1087 ----
      return NULL;
  }
  
+ #ifdef SNI_SVR4
+ 
  static void
  parse_args(int ac, char **av)
  {
      int			c;
+     error_status_t	st;
+ 
+     bootstrap = FALSE;
+     do_secval = TRUE;
+     purging = FALSE;
+     privacy_required = TRUE;
+     while ((c = getopt(ac, av, "bdefhipsw:c")) != -1) {
+ 	switch (c) {
+ 	default:
+             showusage = ERRORUSAGE;
+             return;
+ 	    /* NOTREACHED */
+ 	case 'b':	bootstrap = TRUE;		break;
+ 	case 'd':	debug = TRUE;			break;
+ 	case 'e':	endpoints = FALSE;		break;
+ 	case 'f':	in_foreground = TRUE;		break;
+ 	case 'h':
+             showusage = HELPUSAGE;
+             return;
+ 	    /* NOTREACHED */
+ 	case 'i':	initialize_databases = TRUE;	break;
+ 	case 'p':	purging = TRUE;			break;
+ 	case 's':	do_secval = FALSE;		break;
+ 	case 'c':	privacy_required = FALSE;	break;
+ 	case 'w':
+             svcroute = (idl_char *)optarg;
+             break;
+ 	}
+     }
+     if ((purging && (!do_secval || initialize_databases))
+      || (av[optind] && !endpoints)) {       /* av[optind] would be *protseqs */
+         showusage = ERRORUSAGE;
+         return;
+     }
+     if (initialize_databases || debug)
+ 	in_foreground = TRUE;
+ }
+ 
+ static void
+ process_args(int ac, char **av)
+ {
+     error_status_t	st;
+ 
+     if (showusage == ERRORUSAGE) {
+         dce_pgm_fprintf(stderr, dced_s_usage);
+         exit(1);
+     }
+ 
+     if (showusage == HELPUSAGE) {
+ 	dce_printf(dced_s_usage);
+ 	exit(0);
+     }
+ 
+     if (svcroute) {
+ 	dce_svc_routing(svcroute, &st);
+ 	if (st != error_status_ok) {
+             dce_pgm_fprintf(stderr, st);
+             exit(1);
+         }
+     }
+ 
+     ac -= optind;
+     av += optind;
+     if (av[0])
+ 	for (protseqs = av; *av; av++) {
+ 	    rpc_network_is_protseq_valid((idl_char *)*av, &st);
+ 	    if (st != error_status_ok)
+ 		dce_svc_printf(DCED_S_BAD_PROTSEQ_MSG, *av);
+ 	}
+ 
+     if (purging || do_secval) {
+       sv_purge_context();
+       remove_bindings_file();
+     }
+ }
+ 
+ #else
+ 
+ static void
+ parse_args(int ac, char **av)
+ {
+     int			c;
      boolean		purging;
      error_status_t	st;
  
***************
*** 942,947 ****
--- 1137,1144 ----
  	in_foreground = TRUE;
        
  }
+ 
+ #endif /* SNI_SVR4 */
  
  void
  export_to_namespace(

[7/14/95 public]

Has anyone looked at a possible atfork() problem on SVR4?

[7/28/95 public]

FROM DEC:

	It seems to me that there's a race condition between the
bootstrap_mgmt() thread in dced and dce_config.  I think we've
actually run into the wrong side of it, too.  Briefly, when started in
bootstrap mode ('dced -b'), and using the default value of 'do_secval',
the bootstrap_mgmt() thread does

	wait for security to come up
	patch acls
	keep trying to start the secval service until we succeed
	keep trying to register our authentication information until we succeed
	register any remaining server IFs that are still unregistered, namely
		rsec_cert
		rsec_login
		roverride
		secval
		hostdata
		rkeytab
		srvrconf
		srvrexec
		serviceability
	export services to CDS namespace.

The problem is that while this is going on, dce_config reaches the point
where it tries to start the secval service; as a prerequisite for this
attempt, it checks for the existence of the sec_clientd.bindings file;
as soon as that file exists, it attempts to do a 'dcecp secval activate'
(or a 'dcecp secval status').  But sec_clientd.bindings is written during
the

	'keep trying to start the secval service until we succeed'

line in bootstrap_mgmt(); so the file appears before the secval server
interface is registered with the RPC runtime, and (as we've found out)
this can cause the 'dcecp secval status' to give an unexpected error.
	We've solved this locally by moving the call to write_bindings()
into dced/server/main.c, immediately following the 

	'register any remaining server IFs'

line in bootstrap_mgmt().  That way, we are assured that all of the
server interfaces are registered with the RPC runtime before dce_config
tries to use them.

========================= src/admin/dced/server/main.c ======================

*** back/main.c	Sun Jul  2 23:16:22 EDT 1995
--- ./main.c	Thu Jul 27 19:34:26 EDT 1995
***************
*** 932,941 ****		(In bootstrap_mgmt())
--- 940,951 ----
  	    dce_svc_printf(DCED_S_CANT_INIT_SOMETHING_MSG, "wait_for_register", (long)st);
  	register_servers(&services[i], sizeof_services_table - i, &st);
  	if (st != error_status_ok)
  	    dce_svc_printf(DCED_S_CANT_INIT_SOMETHING_MSG, "register servers", (long)st);
      }
+ 
+     write_dced_bindings(&st);
  
      export_to_namespace(&services[i], sizeof_services_table - i, &st);
      if (st != error_status_ok)
  	dce_svc_printf(DCED_S_CANT_INIT_SOMETHING_MSG, "NS export", (long)st);
  
====================== src/admin/dced/server/sv_clientd.c ===================

*** back/sv_clientd.c	Wed Jan 11 09:58:19 EST 1995
--- ./sv_clientd.c	Thu Jul 27 19:34:43 EDT 1995
***************
*** 157,167 ****
  char			*sv_override_file_name;
  char			*sv_group_override_file_name;
  char			*sv_clientd_binding;
  char			*sv_preauth_dir;

! static void write_bindings( error_status_t * );
  
  /*
   * Tack DCELOCAL in front of path
   */
  static char * 
--- 162,172 ----
  char			*sv_override_file_name;
  char			*sv_group_override_file_name;
  char			*sv_clientd_binding;
  char			*sv_preauth_dir;
  
! void write_dced_bindings( error_status_t * );
  
  /*
   * Tack DCELOCAL in front of path
   */
  static char * 
***************
*** 528,541 ****
  
    unlink(sv_clientd_binding);
  }
  
  /*
!  *  write_bindings - Record bindings in local file.
   */
! static void
! write_bindings( error_status_t	*st )
  {
    int	fd;
    FILE	*F;
  
    fd = open(sv_clientd_binding, O_WRONLY | O_CREAT | O_TRUNC, 0644);
--- 533,546 ----
  
    unlink(sv_clientd_binding);
  }
  
  /*
!  *  write_dced_bindings - Record bindings in local file.
   */
! void
! write_dced_bindings( error_status_t	*st )
  {
    int	fd;
    FILE	*F;
  
    fd = open(sv_clientd_binding, O_WRONLY | O_CREAT | O_TRUNC, 0644);
***************
*** 574,585 ****
    load_override_files(st);
    if (*st != error_status_ok) {
      dce_svc_printf(DCED_S_SV_LOAD_OVERRIDE_FAIL_MSG, *st);
      return;
    }
-   write_bindings(st);
-   if (*st != error_status_ok) return;
  
    if (pthread_create(&mcontext_handle, thread_attr,
  		     maintain_machine_context, NULL) < 0) {
      dce_svc_printf(DCED_S_THREAD_ERROR_MSG, strerror(errno));
      return;
--- 579,588 ----



CR Number                     : 12725
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : UHYP: fopen without fclose, running out of file descriptors
Reported Date                 : 10/25/94
Found in Baseline             : 1.1
Found Date                    : 10/25/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : dmn_updt_inform.c
Sensitivity                   : public

[10/25/94 public]
When audit daemon notifies its clients of any filter changes, it opens
the files containing clients' bindings, but does not close them, once 
it read the info.  Causes cp_filter test suite to fail on OSF1.

[10/26/94 public]
fixed.



CR Number                     : 12721
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : msg
Short Description             : UHYP:error_status_ok not translateable
Reported Date                 : 10/25/94
Found in Baseline             : 1.1
Found Date                    : 10/25/94
Severity                      : B
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : dce/utils/svc/msggetmsg.c
Sensitivity                   : public

[10/25/94 public]
Message catalogs can't have a message numbered zero in them.
dce_error_inq_text works around this by doing
    if (status_to_convert == 0)
	status_to_convert = msg_s_ok_text;
This should also be done for dce_msg_get_cat_msg.  (Maybe others, someone
will have to look -- that msg API makes my head hurt.:)  It should also
happen for the dce_msg_get_default_msg routine.
There is no work-around, but it's hard to see how this is an A0.
If this fix is not made, then any attempt to get the text for error_status_ok
through the MSG API will always get the C/English.

There is a latent bug caused by dce_cf_* API.  It defines a 0 status code.
It shouldn't, but we can't change that.  In dce/utils/svc/msgtable.c,
we should put a comment making sure that the svc_msg_table comes before
the the dce_cfg_table so that when status code 0 is translated, you
always get the SVC version.

[1/25/94 public]
I adjusted dce_msg_get_default_msg() and dce_msg_get_cat_msg() to use the
same scheme to map status=0 to a known "success" message.



CR Number                     : 12714
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : 
Short Description             : UHYP:dced restart on failure doesn't
Reported Date                 : 10/24/94
Found in Baseline             : 1.1b23
Found Date                    : 10/24/94
Severity                      : B
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : admin/dced/server/sxops.c,main.c
Sensitivity                   : public

[10/24/94 public]

When DCDREL002 is run on a single node the "restart on failure" function
does not appear to work as expected for the DCDREL002 test servers. Repeating
the same sequence of events manually with logging turned on shows that the
server is being restarted and that it then exits (or gets removed?). The 
log file for NOTICEs contains the lines:

1994-10-24-17:43:17.056-04:00I0.911 dced NOTICE dhd srvrexec sxops.c 315
0x40028a28 Re-starting server 'dcdrel002_server.1'
1994-10-24-17:43:17.060-04:00I0.911 dced NOTICE dhd srvrexec sxops.c 221
0x40028a28 Reaping exiting server 'dcdrel002_server.1'

Which followed the initial exit of the server on request, noted in the 
WARNING log:

1994-10-24-17:43:17.042-04:00I0.911 dced WARNING dhd srvrexec sxops.c 304
0x40028a28 Server 'dcdrel002_server.1' exited with status 255

[10/24/94 public]
Potential problem from brief code inspection:

In sxops.c, Line 305 in BL-23 (line 320 in unintegrated), the call to
remove_server() preceeds the use of an element of the structure.  
remove_server() sets structure ptr to point to s_null_server which is
a zero filled copy of a server struct.  The next statement (call to
serverconf_start()) references elements in the structure.

This seems like a bad thing to do, the fix might be to call remove_server()
after the srvrconf_start()?

[10/24/94 public]
Rob's right, the sxops.c:241 calls dced_server_free_ptrs() which in 
turn zeros everything. 
The fix is to copy sp->data.exec_data.tagged_union.running_data.sc_uuid
to a new variable sc_uuid at the time sp->data.fixed and sp->data.attributes
got copied and then use this sc_uuid to call srvrconf_start().

[10/25/94 public]

Ping, can we get this fixed/tested today or early tomorrow?  Let me know...

[10/25/94 public]
Well, the fix seems to unveil another problem -): dced server dumps core 
with segmentation fault. The core file doesn't give any useful information 
at this point.

[10/26/94 public]
Ping's fix was the first part; the second part was to call
rpc_ss_enable_allocate() in the function who calls srvrexec__reap.  I'm
submitting both parts.

[10/26/94 public]
Although the fix works, as Rob points out, it could be a bad thing to
have the signal_catcher to call this srvrconf_start() and it in turn calls
rpc_sm_allocate()s. It makes code not reentrantable and in danger of deadlock.
A better solution could be to have the srvrexec__reap() triggered a restart
instead of restart by the srvrexec__reap() itself.

[10/26/94 public]
This is not an issue.  The reap() function is not really a signal handler
that Rob is concerned about.  Handling signals via a dedicated thread and
calling sigwait() are safe.  So Ping's note of 10/26 is not an issue.



CR Number                     : 12713
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : UHYP: Attribute schema updates not logged or propagated
Reported Date                 : 10/24/94
Found in Baseline             : 1.1
Found Date                    : 10/24/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : See below
Sensitivity                   : public

[10/24/94 public]
Somehow, this work slipped through the cracks...
Attribute schema update functionality was submitted to unintegrated, but it
didn't include log/replay or propagation of schema updates.

Sally, MaryannePT suggested that I let you know about the following:
The replication protocol includes a routine for this, but it is incomplete/
wrong.  This has to be on the MUST TAKE list (in the release notes, for things
that have to be taken from the Unintegrated tree and applied to DCE1.1 if the
vendor decides not to apply the entire Unintegrated tree).

At least the following files need to change:
security/h/rrs_prop_attr_schema.h
security/idl/rs_prop_attr_schema.idl
security/server/rrs/rrs_prop_attr_schema.c
security/server/rs/rs_attr_schema.c
security/server/rs/rs_log_attr_schema.c
security/server/rs/rs_prop_attr_schema.c

Susan,  This needs to be UHYP'd asap.  Building/testing starting now.

[10/25/94 public]
Submitted fixes, marked 'fix'.

[02/08/95 public]
Changed security/server/rs/rrs_prop_attr_schema.c above to
security/server/rrs/rrs_prop_attr_schema.c



CR Number                     : 12708
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : unknown
Short Description             : RIOS crashed w/in 1 hour of CHO
Reported Date                 : 10/24/94
Found in Baseline             : 1.1b23
Found Date                    : 10/24/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public

[10/24/94 public]

In what was to be the final run of CHO for DCE 1.1 DFS, the RIOS
crashed w/in 1 hour. The crash dump was not useful, even though
there was plenty of space to collect one. The CHO config is:

1 RIOS X 3 HP
m1 (R) = security server, dts server, flserver, fileserver (native and lfs)
m2 (H) = cds server, dts server, flserver, fileserver (native and lfs)
m3 (H) = dts server, flserver, fileserver (native and lfs)
m4 (H) = client-only.

test    run on          to fileset on   fileset type
----    ------          -------------   ------------
repfs   m1 (R)          m1 (R), m3 (H)  lfs

acl     m2 (H)          m1 (H)          lfs
cthon   m2 (H)          m3 (H)          hfs

repfs   m3 (H)          m3 (H), m1 (H)  lfs

acl     m4 (H)          m2 (H)          lfs
cthon   m4 (H)          m1 (R)          jfs
fts     m4 (H)          m3 (H), m1 (R)  lfs

NOTE: the 2 copies of the ACL functional tests were NOT running
at the time of the crash. IBM mentioned that they had been seeing
crashes recently so I'm hoping they can supply more information here.

[10/26/94 public]
Reluctantly defer'ed.

[2/16/96]

We believe this won't recure.  Please reopen the defect if it does.



CR Number                     : 12682
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : i18n
Short Description             : UHYP: small memory leak in the character compat check routine
Reported Date                 : 10/20/94
Found in Baseline             : 1.1b22
Found Date                    : 10/20/94
Severity                      : B
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : cs_s_eval.c
Sensitivity                   : public

[10/20/94 public]

  I found a small memory leak within RPC runtime rpc_cs_char_set_compat_check()
routine.  This routine accesses OSF code set registry to get an array of 
character sets which a code set encodes.  The code set registry access 
routine (dce_cs_rgy_to_loc) will allocate a space for the supported character 
sets array, and the user of the routine should free it after it is used.
(Since a user needs to free the space, dce_cs_rgy_to_loc() uses malloc to
allocate the space, instead of using RPC_MEM_ALLOC macro.)

  The rpc_cs_char_set_compat_check() routine should have freed the space
after it finished the character sets compatibility checking, but currently it 
does not.

  The fix is the following.  I already fixed the problem within my sandbox,
built libdce of both HP and 486, then executed the RPC I18N API functional
tests to verify the fix does not break anything.

diff cs_s_eval.c /project/dce/build/dce1.1/src/rpc/runtime/cs_s_eval.c
908c908
<       unsigned16      *client_char_sets_value, *c_sets_save;
---
>       unsigned16      *client_char_sets_value;
910c910
<       unsigned16      server_char_sets_number, *s_sets_save;
---
>       unsigned16      server_char_sets_number;
922,924c922
<
<       c_sets_save = client_char_sets_value;
<
---
>
933,934d930
<       {
<               free(c_sets_save);
936d931
<       }
938,939d932
<       s_sets_save = server_char_sets_value;
<
973,975d965
<
<       free(c_sets_save);
<       free(s_sets_save);

  I think this CR deserves UHYP category, but I leave the decision to OSF 
management.  (I left the priority to 1).

[10/20/94 public]

Approved for UHYP, upgraded to P0.

[10/20/94 public]

  Fix was submitted.



CR Number                     : 12677
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : UHYP:wrong flag to dce_aud_open causes auditd to hang
Reported Date                 : 10/19/94
Found in Baseline             : 1.1
Found Date                    : 10/19/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : dmn_main.c
Sensitivity                   : public

[10/19/94 public]
If auditd is invoked without the -a option, then dmn_main.c should
call dce_aud_open with the flag aud_c_trl_open_write_no_filter
instead of aud_c_trl_open_write.

[10/20/94 public]

Approved for unintegrated tree.

[10/21/94 public]
Fixed.



CR Number                     : 12670
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd and libdce
Short Description             : couple of instances of missing return values.
Reported Date                 : 10/19/94
Found in Baseline             : 1.1b23
Found Date                    : 10/19/94
Severity                      : C
Priority                      : 3
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : see below
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/19/94 public]

In sec_rgy_name_complete() (client/rca/sec_rgy_attr.c) the return in the
first if-statement does not return a value.

In rsdb_acl_mgr_perms_valid() (server/rsdb/rsdb_acl.c) the return in the
first if-statement does not return a value.

In rsdb_pgo_util_delete_member() (server/rsdb/rsdb_pgo_util.c) the return
in the first if-statement does not return a value.

copy_dlg_token_set() (client/login/sec_login_pvt.c) should be declared as
type void.

[12/21/95 public]
The first one above is still broken (sec_rgy_attr.c)
The second one was fixed in 1.1.    (rsdb_acl.c)
The third  one is still broken      (rsdb_pgo_util.c) (doesn't need to be bool)
The fourth one was fixed in 1.2.1   (sec_login_pvt.c)

[6/18/96 public]
Fixed in 1.2.2 for next drop to OSF.



CR Number                     : 12662
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa, i486
S/W Ref Platform              : osf1, hpux
Component Name                : dced
Subcomponent Name             : /test/functional/admin/dced/ts/util_api
Short Description             : UHYP:dced FVT compile errors
Reported Date                 : 10/19/94
Found in Baseline             : 1.1
Found Date                    : 10/19/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : 
./test/functional/admin/dced/ts/util_api/common.c ./test/functional/admin/dced/ts/util_api/dce_util_test_server.h
Sensitivity                   : public

[10/19/94 public]

c89 -c    -D_SHARED_LIBRARIES    -DDEBUG -D__hppa -Dhp9000s800 -Dhp9000s700 -D__hp9000s800 -D__hp9000s700 -DHPUX -D__hpux -Dunix +DA1.0 -D_HPUX_SOURCE    -I. -I/u2/devobj/sb/nb_unintegrated_ux/src/test/functional/admin/dced/ts/util_api -I/project/dce/build/unintegrated-snap/src/test/functional/admin/dced/ts/util_api   -I/u2/devobj/sb/nb_unintegrated_ux/export/hp800/usr/include -I/project/dce/build/unintegrated-snap/export/hp800/usr/include    /project/dce/build/unintegrated-snap/src/test/functional/admin/dced/ts/util_api/inq_uuids_t.c
c89 -c    -D_SHARED_LIBRARIES    -DDEBUG -D__hppa -Dhp9000s800 -Dhp9000s700 -D__hp9000s800 -D__hp9000s700 -DHPUX -D__hpux -Dunix +DA1.0 -D_HPUX_SOURCE    -I. -I/u2/devobj/sb/nb_unintegrated_ux/src/test/functional/admin/dced/ts/util_api -I/project/dce/build/unintegrated-snap/src/test/functional/admin/dced/ts/util_api   -I/u2/devobj/sb/nb_unintegrated_ux/export/hp800/usr/include -I/project/dce/build/unintegrated-snap/export/hp800/usr/include    /project/dce/build/unintegrated-snap/src/test/functional/admin/dced/ts/util_api/common.c
common.c: 16: Unable to find include file 'sys/mode.h'.
*** Error code 1

c89 -c    -D_SHARED_LIBRARIES    -DDEBUG -D__hppa -Dhp9000s800 -Dhp9000s700 -D__hp9000s800 -D__hp9000s700 -DHPUX -D__hpux -Dunix +DA1.0 -D_HPUX_SOURCE    -I. -I/u2/devobj/sb/nb_unintegrated_ux/src/test/functional/admin/dced/ts/util_api -I/project/dce/build/unintegrated-snap/src/test/functional/admin/dced/ts/util_api   -I/u2/devobj/sb/nb_unintegrated_ux/export/hp800/usr/include -I/project/dce/build/unintegrated-snap/export/hp800/usr/include    /project/dce/build/unintegrated-snap/src/test/functional/admin/dced/ts/util_api/dce_util_test_server.c
dce_util_test_server.h: 15: Unable to find include file 'dce/pthread.h'.
*** Error code 1

c89 -c    -D_SHARED_LIBRARIES    -DDEBUG -D__hppa -Dhp9000s800 -Dhp9000s700 -D__hp9000s800 -D__hp9000s700 -DHPUX -D__hpux -Dunix +DA1.0 -D_HPUX_SOURCE    -I. -I/u2/devobj/sb/nb_unintegrated_ux/src/test/functional/admin/dced/ts/util_api -I/project/dce/build/unintegrated-snap/src/test/functional/admin/dced/ts/util_api   -I/u2/devobj/sb/nb_unintegrated_ux/export/hp800/usr/include -I/project/dce/build/unintegrated-snap/export/hp800/usr/include    /project/dce/build/unintegrated-snap/src/test/functional/admin/dced/ts/util_api/inq_uuids_s.c
dce_util_test_server.h: 15: Unable to find include file 'dce/pthread.h'.
*** Error code 1

c89 -c    -D_SHARED_LIBRARIES    -DDEBUG -D__hppa -Dhp9000s800 -Dhp9000s700 -D__hp9000s800 -D__hp9000s700 -DHPUX -D__hpux -Dunix +DA1.0 -D_HPUX_SOURCE    -I. -I/u2/devobj/sb/nb_unintegrated_ux/src/test/functional/admin/dced/ts/util_api -I/project/dce/build/unintegrated-snap/src/test/functional/admin/dced/ts/util_api   -I/u2/devobj/sb/nb_unintegrated_ux/export/hp800/usr/include -I/project/dce/build/unintegrated-snap/export/hp800/usr/include    /project/dce/build/unintegrated-snap/src/test/functional/admin/dced/ts/util_api/inq_uuids_s.c
dce_util_test_server.h: 15: Unable to find include file 'dce/pthread.h'.
*** Error code 1

[10/19/94 public]
Please note that that on the HP platform, there is no such include
file /usr/include/sys/mode.h.  However, this does exist on a RIOS
and an OSF/1.  You can try /usr/include/sys/inode.h or 
/usr/include/sys/types.h .

thanks
annie

[10/20/94 public]
pthread.h, not dce/pthread.h
Like annie says, sys/mode.h is a nono.  What's it supposed to do, provide
file modes like in sys/stat?



CR Number                     : 12659
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : login
Short Description             : UHYP: machine identity missing new info
Reported Date                 : 10/18/94
Found in Baseline             : 1.1
Found Date                    : 10/18/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : security/client/login/sec_login_pvt.c
Sensitivity                   : public

[10/18/94 public]
sec_login_pvt_allocate_first(), used by dced to create the host machine
context, isn't filling in the new 1.1 fields.  One result of this:
lacking the expected v1_1_info.compat_mode value means that unauthenticated
requests by root will always fail between two 1.1 cells with the odd error
"security service does not support version 1.1 security features", because
of the check at the end of sec_login_util_ptgt_compat()...

[10/19/94 public]
Since this has serious implications for intercell operation and since we
know exactly what is wrong and exactly how to fix it (a new line of code was
added to sec_login_pvt_allocate_login_context() but not to the equivalent
routine sec_login_pvt_allocate_first() that sets up the machine's context)
I'll be asking that this be made a UHYP as soon as I can test my fix (building
now).

[10/20/94 public]

Updating this to UHYP for Susan.

[10/21/94 public]
Fixed-At-HP



CR Number                     : 12653
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : UHYPE:Old cellname isn't recognized when doing hostdata update.
Reported Date                 : 10/18/94
Found in Baseline             : 1.1
Found Date                    : 10/18/94
Severity                      : C
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : cdsd
Sensitivity                   : public

[10/18/94 public]


I am unable to show/modify the hostdata cell_name and cell_alias information 
when the cell alias name has been switched to the cell primary name. 

That is I have two cell names. /.../original and /.../alias 
where /.../alias has two RDN's. I have done a 

dcecp> cdsalias create /.../alias 
dcecp> principal create krbtgt/alias -alias yes -uid {uid from krbtgt/original}

dcecp> hostdata modify /.../original/hosts/drkstr/config/hostdata/cell_aliases \
        -data {/.../alias}

dcecp> hostdata modify /.../original/hosts/drkstr/config/hostdata/pe_site \
        -data {
{/.../alias 9d160ed0-e860-11cd-b899-0000c0f7de56@ncacn_ip_tcp:130.105.5.16[]}
{/.../alias 9d160ed0-e860-11cd-b899-0000c0f7de56@ncadg_ip_udp:130.105.5.16[]}}

Then I attempted to change the primary cell name from /.../original to 
/.../alias. This failed in the hostdata modify sequence. First 

dcecp> cdsalias set /.../alias

Modified the cds notion of primary and alias names correctly.

dcecp> principal modify /.../orginal/krbtgt/alias -alias no

Modified both the krbtgt/alias and krbtgt/original principal values correctly.

But when I tried to modify the hostdata information I got this error:

dcecp> hostdata modify /.../original/hosts/drkstr/config/hostdata/cell_aliases \
        -data {/.../alias /.../original} 
Error: Requested operation would result in lost connectivity to root directory

I was however able to modify the hostdata with:

dcecp> hostdata modify /.../alias/hosts/drkstr/config/hostdata/cell_aliases \
        -data {/.../alias /.../original} 
dcecp> hostdata modify /.../alias/hosts/drkstr/config/hostdata/cell_name \
        -data {/.../alias} 

So it would appear that the new alias name is now accepted as a path to the 
hostdata information but the original name is not.

[10/18/94 public]

> Error: Requested operation would result in lost connectivity to root directory

This error is returned from cdsd (CDS_ROOTLOST) while the dced_binding_create()
calls the rpc_ns_entry_inq_resolution() to resolve the input name 
/.../original/hosts/drkstr/config/hostdata, so I suspect this is a cds related
problem.

[10/19/94 public]
Right.  Not a dced API problem.

[10/26/94 public]
By registering both the original cell name and the new cell alias in DNS,
I've gotten a somewhat different error on the hostdata command. Roger has 
identified that part of the above problem is a gdad reference going beyond
the cell when it doesn't need to. The error which I receive on various
dcecp hostdata operations using the original cell name or "/.:" is 

"Bad or invalid dce attr schema object name(s)"

This suggests that there might be another problem beyond the cds problem.

[10/26/94 public]
Susan has ok'd the uhype and Roger has a fix comming momentarily.

[10/26/94 public]
I've submitted a fix.  The problem was larger than what this OT states.
Basically, you had to be lucky in your use of cell aliases for the server
to answer your query.  Often, a cell alias in the name was not recognized
as such, so the server passed it along to the GDA.



CR Number                     : 12634
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : tkm
Short Description             : potential for free() on bogus ptr
Reported Date                 : 10/17/94
Found in Baseline             : 1.1
Found Date                    : 10/17/94
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public

[10/17/94 public]
Daryl Kinney at HP found this.  Here's his mail.  Susan, I think this
should be a UHYP.

> From kinney@apollo.hp.com Thu Oct 13 15:41:57 1994
> Received: from relay.hp.com (relay.hp.com [15.255.152.2]) by postman.osf.org (8.6.9/8.6.x) with ESMTP
> 	id PAA12111 for <rsarbo@osf.org>; Thu, 13 Oct 1994 15:41:55 -0400
> Received: from it_750.ch.apollo.hp.com by relay.hp.com with SMTP
> 	(1.37.109.11/15.5+ECS 3.3) id AA044377314; Thu, 13 Oct 1994 12:41:54 -0700
> Message-Id: <199410131941.AA044377314@relay.hp.com>
> Received: from seki.ch.apollo.hp.com by it_750.ch.apollo.hp.com 
> 	for rsarbo@osf.org
> 	id AA17821; Thu, 13 Oct 1994 15:41:53 -0400    
> To: rsarbo@osf.org
> Subject: DFS bug we just found
> Date: Thu, 13 Oct 1994 15:41:53 -0400
> From: Daryl Kinney <kinney@apollo.hp.com>
> Status: R
> 
> 
> Hi Ron (assuming you're still there)
> 
> While looking for a token manager bug, we stumbled on the
> following (our problem ended up being a bug in some 1.0.2a clients
> here).  I leave it up to you (or someone else there) to decide
> what to do with it -- given the 1.1 state.
> 
> The bug was found in 1.0.3a ... although it appears to exist in 1.1
> as well.  Note that the bug appears to be potentially serious, I can't
> say for certain that it ever bit us.
> 
> The bug is in tkm_Byterange_Complement() in tkm_range.c.  Specifically:
> if the two ranges it is given are identical, it sets resultP->lo to
> point at one of the ranges passed to it.  Unfortunately: its caller (in
> tkm_fidHash.c) will osi_Free() anything it finds there ..... specifically,
> it will end up osi_Free()'ng the middle of a tkm_internalToken_t.  This
> routine has to allocate whatever it wants the resultP->lo,hi pointers to
> point at.
> 
> I changed this routine to the following (below my signature).
> 
> -Daryl
> 
>  +--------------------------------------------------------+
>  |  Daryl Kinney               Hewlett Packard, OSSD/CSSL |
>  |  kinney@ch.hp.com           PHONE:  (508) 436-4922     |
>  |                             FAX:    (508) 436-5122     |
>  |                             TELNET:       436-4922     |
>  +--------------------------------------------------------+
> 
> 
> EXPORT void tkm_Byterange_Complement(universeRangeP, partiallyEnclosedRangeP, resultP)
>      IN tkm_byterange_p 	universeRangeP;
>      IN tkm_byterange_p 	partiallyEnclosedRangeP;
>      OUT tkm_byterangePair_p	resultP;
> {
>   tkm_byterange_t enclosedRange;
> 
>   /*
>    * Note: our caller will osi_Free() anything it finds in these two pointers!
>    */
>   resultP->lo = (tkm_byterange_p)NULL;
>   resultP->hi = (tkm_byterange_p)NULL;
> 
>   /*
>    * If the ranges are the same, there is no complement, so only do anything
>    * if it is NOT true that both bounds coincide.
>    */
>   if ((hcmp(universeRangeP->lowBnd, partiallyEnclosedRangeP->lowBnd) != 0) ||
>       (hcmp(universeRangeP->upBnd, partiallyEnclosedRangeP->upBnd) != 0)) {
> 
>     tkm_Byterange_Intersection(universeRangeP, partiallyEnclosedRangeP, &enclosedRange);
> 
>     tkm_Byterange_New((tkm_byterange_p)NULL, &(resultP->lo));
>     TKM_BYTERANGE_SET_RANGE(resultP->lo,
> 			    &(universeRangeP->lowBnd), &(universeRangeP->upBnd));
>     
>     if (! TKM_BYTERANGE_IS_EMPTY(&enclosedRange)) {
>       
>       if (hcmp(universeRangeP->lowBnd, enclosedRange.lowBnd) == 0) {
> 	hset(resultP->lo->lowBnd, enclosedRange.upBnd);
> 	hadd32(resultP->lo->lowBnd, 1);
>       }
>       else {
> 	if (hcmp(universeRangeP->upBnd,  enclosedRange.upBnd) == 0) {
> 	  hset(resultP->lo->upBnd, enclosedRange.lowBnd);
> 	  tkm_hyper_Decrement(&(resultP->lo->upBnd));
> 	}
> 	else {
> 	  /* the enclosed range is strictly enclosed by the universe, so there will be 
> 	     two pieces to the complement range */
> 	  TKM_BYTERANGE_SET_RANGE(resultP->lo,
> 				  &(universeRangeP->lowBnd),
> 				  &(enclosedRange.lowBnd));
> 	  tkm_hyper_Decrement(&(resultP->lo->upBnd));
> 
> 	  tkm_Byterange_New((tkm_byterange_p)NULL, &(resultP->hi));
> 	  TKM_BYTERANGE_SET_RANGE(resultP->hi,
> 				  &(enclosedRange.upBnd),
> 				  &(universeRangeP->upBnd));
> 	  hadd32(resultP->hi->lowBnd, 1);
> 	}
>       }
>     }
>   }
> }
> 
> 
> 
> 
>



CR Number                     : 12633
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : UYHP:anonymous uuid mapping not done
Reported Date                 : 10/17/94
Found in Baseline             : 1.1
Found Date                    : 10/17/94
Severity                      : B
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : src/file/fshost/fshs_deleg.c, src/file/fshost/fshs_subr.c, src/file/fshost/fshs_prutils.c
Sensitivity                   : public

[10/17/94 public]
Enforcing target or delegate restrictions in security means mapping
certain identities to a well known "anonymous uuid".  Unfortunately,
that anonymous uuid is not compatible with DFS.  A mapping needs
to be implemented in DFS to the DFS anonymous uuid in these cases.  
Susan, I think this should be a UHYP.



CR Number                     : 12629
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa, i486
S/W Ref Platform              : hpux, osf1
Component Name                : dfs
Subcomponent Name             : unintegrated multi machine Smoketest
Short Description             : UHYP: you are not authorized for this operation
Reported Date                 : 10/14/94
Found in Baseline             : 1.1
Found Date                    : 10/14/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : src/config/dfs_config
Sensitivity                   : public

[10/14/94 public]

Rich, 

	Is this an acl problem or has this been backed out

				Regards,

					Pete

Too few servers (2), need 3 servers
/opt/dcelocal/bin/bos: failed to add group 'subsys/dce/dfs-admin' (you are not authorized for this operation (dfs / bbs
))
/opt/dcelocal/bin/bos: failed to create new server instance flserver of type 'simple' (you are not authorized for this
operation (dfs / bbs))
Checking for a Ubik sync site in  hosts/berlin
udebug: failed to obtain ubik server information; Communications failure (dce / rpc)
Checking for a Ubik sync site in  hosts/berlin
udebug: failed to obtain ubik server information; Communications failure (dce / rpc)
Checking for a Ubik sync site in  hosts/berlin
udebug: failed to obtain ubik server information; Communications failure (dce / rpc)
Checking for a Ubik sync site in  hosts/berlin
udebug: failed to obtain ubik server information; Communications failure (dce / rpc)
Checking for a Ubik sync site in  hosts/berlin
udebug: failed to obtain ubik server information; Communications failure (dce / rpc)
Checking for a Ubik sync site in  hosts/berlin
udebug: failed to obtain ubik server information; Communications failure (dce / rpc)
Checking for a Ubik sync site in  hosts/berlin
udebug: failed to obtain ubik server information; Communications failure (dce / rpc)
1994-10-14-13:42:44.225-04:00I----- dtsd WARNING dts config logevent_v_ultrix.c 269 0x7aff92c0
Too few servers (2), need 3 servers

[10/15/94 public]
The ACL changes were backed out.  Not sure what this is.

[10/17/94 sally]
This seems to have gotten lossed - and shouldn't have.  We saw this problem
again this morning in the multi-machine smoketest.  I added UHYP to the
short description so it doesn't get lossed again, we are investigating whether
or not this is a setup problem with unintegrated, could someone else 
investigate whether or not they think this could be a code defect.  Please
consider the fact that the unintegrated tree opened on the 6th, and any of
the changes that were made to the mainline tree after that may need to be
submitted to unintegrated as well.

[10/17/94 sally]
Some lines were dropped in the HP dfs_config submit for the gateway
enhancements.  I'm wondering if this was just an oversight or if there
was a reason?  These lines need to show up at the end of dfs_rgy_init().

+     # We need to dce_login here, even if we are already, to pick up
+     # the fact that cell_admin is now a member of the
+     # subsys/dce/dfs-admin group (which is used in ACL's that, e.g.
+     # bosserver, checks).
+     log_msg DEBUG "Log in again to pick up changes to the registry for DFS."
+     dcelogin || exit 1

I'll be submitting this tonight to get the smoketest working again even if
I don't hear back from HP.



CR Number                     : 12628
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : fts
Short Description             : UHYP: memory alloc error causes core dump
Reported Date                 : 10/14/94
Found in Baseline             : 1.1b22
Found Date                    : 10/14/94
Severity                      : B
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 1.1unintegrated, 1.1maint
Affected File(s)              : file/userInt/fts/volc_main.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/14/94 public]

when the fts command allocates memory for default path names in the
defaultPath() routine it uses osi_Alloc.  The memory is then released
with the free() routine which causes a bus error.  Instead malloc
should be used in place of osi_Alloc.

This is causing numerous errors in the fts functional tests

The changes needed are:

*** /project/dce/build/dce1.1/src/file/userInt/fts/volc_main.c  Thu Sep 29 17:04:35 1994
--- volc_main.c Fri Oct 14 11:17:28 1994
***************
*** 845,853 ****
      if (oelt >= 0 && as->parms[oelt].items != NULL) return;
      if (as->parms[pelt].items == NULL) {
        /* allocate an item representing "." */
!       ti = (struct cmd_item *) osi_Alloc(sizeof(struct cmd_item));
        ti->next = (struct cmd_item *) 0;
!       ti->data = (char *) osi_Alloc(2);
        strcpy(ti->data, ".");
        /* and push it into place */
        as->parms[pelt].items = ti;
--- 845,853 ----
      if (oelt >= 0 && as->parms[oelt].items != NULL) return;
      if (as->parms[pelt].items == NULL) {
        /* allocate an item representing "." */
!       ti = (struct cmd_item *) malloc(sizeof(struct cmd_item));
        ti->next = (struct cmd_item *) 0;
!       ti->data = (char *) malloc(2);
        strcpy(ti->data, ".");
        /* and push it into place */
        as->parms[pelt].items = ti;

[10/4/96 public]

  This fix was included in 1.1 maintenance tree in Feb. 1996.



CR Number                     : 12625
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : UHYP:seg violation due to mismatched nr of parameters
Reported Date                 : 10/13/94
Found in Baseline             : 1.1
Found Date                    : 10/13/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : esl_sync.c
Sensitivity                   : public

[10/13/94 public]
Routine aud_esl_clean_table has two parameters, but is called by update_esl_check
(in esl_sync.c) with a single parameter, causing a wrong assignement which then causes
the segmentation violation.

[10/17/94 public]
Fixed.



CR Number                     : 12617
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : UHYP:reset of login_activity does
not propagate to replicas
Reported Date                 : 10/13/94
Found in Baseline             : 1.1
Found Date                    : 10/13/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : 
./nosupport/security/login_reset/Makefile
./nosupport/security/login_reset/glob.h
./nosupport/security/login_reset/login_reset.c
./nosupport/security/login_reset/types.h
./security/h/rs_log.h
./security/idl/rs_prop_login_reset.idl
./security/idl/sec_rgy_login_activity.idl
./security/server/lm/lm_jrnl.c
./security/server/lm/lm_login.c
./security/server/rrs/Makefile
./security/server/rrs/rrs_prop_login_reset.c
./security/server/rrs/rs_prop_login_reset.acf
./security/server/rs/Makefile
./security/server/rs/rs.c
./security/server/rs/rs_log.c
./security/server/rs/rs_log_login_reset.c
./security/server/rs/rs_login_activity.c
./security/server/rs/rs_prop_login_reset.c
./security/server/rsdb/rsdb_login.c
Sensitivity                   : public

[10/13/94 public]

In testing the reset of the login activity, it was discovered that
the reset is not being propagated to replicas.

This means that a user could get locked out if their login binds
to a replica (bindings are assigned randomly) instead of a master, 
even if the login was reset by the administrator.

[10/13/94 public]

I don't know the number of lines of code that need to be changed but
the changes will be limited to server login activity code
(security/lm/lm_login.c,security/rs,security/rrs 
and a one line definition added to security/h/rs_log.h) and this will
not impact any users interfaces or apis.

[10/14/94 public]

Rich S and Rajendra, can you please comment w.r.t the criticality of
this problem?  Ie: if the change turns out to be a non-risky one,
does this meet the criteria of 'very valuable to our licensees?"
Thanks, Maryann, for the update.

[10/14/94 public]
Whoops, sorry, just got caught up in my email.  Slated for
unintegrated per Desai and mpt.



CR Number                     : 12611
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : svc
Short Description             : UHYP: no usage for svcdumplog
Reported Date                 : 10/13/94
Found in Baseline             : 1.1
Found Date                    : 10/13/94
Severity                      : E
Priority                      : 4
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : dce/utils/svc/svc.sams
Sensitivity                   : public

[10/13/94 public]

Calling "svcdumplog -x" I get:

svcdumplog: illegal option -- x
Unknown message number 0x173ca00e

The reason seems to be that svc_s_dump_usage from svc.sams is
not in dcesvc.cat.
Sorry for this totally uninteresting OT.

[1/13/94 public]
Added "intable" to that slot in the sams file.

[1/14/94 public]
Works in nightly unintegrated build (Oct 20).

[10/26/94 public]
Marking as UHYP so bug summaries don't get confusing.



CR Number                     : 12608
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : utils
Subcomponent Name             : svc
Short Description             : UHYP:missing semaphore in dce_svc__debug_fillin()
Reported Date                 : 10/12/94
Found in Baseline             : 1.1b21
Found Date                    : 10/12/94
Severity                      : C
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : dce/utils/svc/{svcprintf.c,svcroute.c}
Sensitivity                   : public

[10/12/94 public]
           (IBM svc defect 10732):

           Missing semaphore in dce_svc__debug_fillin()


           dce_svc__debug_fillin() should have a lock around the table
           access, analogous to the one in dce_svc_register(), i.e.:

           boolean
           dce_svc__debug_fillin(
               dce_svc_handle_t            handle,
               error_status_t              *status
           )
           {
               char                        buff[SMBUF];
               char                        *p;
               char                        *flags;
               char                        *freeme;


               /* Add the table, translate its strings. */
               LOCK();
               if (!dce_svc__add_to_table(handle, status)) {
                   UNLOCK();
                   return FALSE;
               }
               UNLOCK();

[1/12/94 public]
Be careful.  dce_svc_printf() calls dce_svc__debug_fillin(), but already
does LOCK/UNLOCK.

[10/13/94 public]
Yeah, be careful.  Here is what I think is the right way to fix this.
	dce_svc__debug_fillin2 should use LOCK/UNLOCK around its
	call to dce_svc__debug_fillin.

	dce_svc__debug and dce_svc_log should use LOCK/UNLOCK the
	same way dce_svc_printf does.  (I don't know why they don't)

[1/14/94 public]
Added LOCK/UNLOCK to dce_svc_debug_fillin2(), dce_svc__debug(), and
dce_svc_bin_log().



CR Number                     : 12594
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : UHYP:cellalias create using hierarchical name fails
Reported Date                 : 10/12/94
Found in Baseline             : 1.1b21
Found Date                    : 10/12/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : directory/cds/server/
Sensitivity                   : public

[10/12/94 public]

(This occurred using last night's build.)

I setup a one-node cell on an HP system, upgraded the CDS directory
version to 4.0, updated DNS, and brought down and restarted DCE.
Then, as cell_admin, I attempted to create an alias using a 
"child" name (containing two simple names) so that I could create 
a hierarchical cell. The output was:

dcecp> cellalias create /.../oceans.qadce.osf.org/streams
1994-10-12-12:04:13.684-04:00I0.532 cdsclerk(8044) ERROR cds general
  clerk_bind.c 490 0x40036080
Routine rpc_binding_set_auth_info(3rpc) failed : status = 387063930.
1994-10-12-12:04:13.870-04:00I0.532 cdsclerk(8044) ERROR cds general
  clerk_bind.c 490 0x40036080
Routine rpc_binding_set_auth_info(3rpc) failed : status = 387063930.
dcecp> cdsalias cat
{CDS_CellAliases {}}
dcecp>

Then I tried creating an alias with a single simple name:

dcecp> cellalias create /.../streams
dcecp> cdsalias cat
{CDS_CellAliases 
{Alias /.../streams}
{Primary /.../lakes.qadce.osf.org}}
dcecp>

[kevins 10/13/94 public] 

There are some problems with attempting to create an alias name for 
hierarchical cell configuration with DNS configured. I have been
able to circumvent this problem with gdad by updating the pe_site 
file with the necessary information. 

I have been able to:

1.) modify the pe_site with necessary foreign cell information
2.) perform the cellalias create command:
        dcecp> cellalias create /.../foreign_cell_name/rdn
3.) perform the cellalias set command:
        dcecp> cellalias set /.../foreign_cell_name/rdn

While both commands appear to have completed successfully the
cellname has not been changed. I currently think I have corrupted data 
in both the:
/.../garcia.cell.osf.org/hosts/drkstr/config/hostdata/cell_name
/.../garcia.cell.osf.org/hosts/drkstr/config/hostdata/cell_aliases

When attempting to access them with:
/.:/hosts....
or (original cell name)
/.../garcia.cell.osf.org/hosts/....
or (new preffered cell name)
/.../lesh.cell.osf.org/garcia/hosts/...

I get:
dcecp> hostdata show /.:/hosts/drkstr/config/hostdata/cell_aliases
Error: Bad or invalid dce attr schema object name(s)
dcecp> hostdata show /.:/hosts/drkstr/config/hostdata/cell_name   
Error: Bad or invalid dce attr schema object name(s)

I have restarted the cell also. That is, I have shutdown the cell
and restarted it. Currently the /opt/dcelocal/dce_cf.db file is not
updated to reflect the new cell name nor is the 
/opt/dcelocal/etc/security/pe_site file. They both have been
updated to show the new alias name though.

[10/13/94 public]

It would seem that after some period of time. ~1hr. I can now 
access the hostdata information: 
dcecp> hostdata show /.../lesh.cell.osf.org/garcia/hosts/drkstr/config/hostdata/cell_name
{uuid 00174f6c-6eca-1d6a-bf90-0000c09ce054}
{annotation  {Name of cell}}
{storage cell_name}
{hostdata/data /.../garcia.cell.osf.org}

dcecp> hostdata show /.../lesh.cell.osf.org/garcia/hosts/drkstr/config/hostdata/cell_aliases
{uuid 002817df-6eca-1d6a-b08a-0000c09ce054}
{annotation  {Cell aliases}}
{storage cell_aliases}
{hostdata/data /.../lesh.cell.osf.org/garcia}

It would appear that the cell is at this point somewhat confused as to what 
it's name is. Well I took a bold step to force the modification of the 
host config data.

[10/13/94 public]
Assigning this to Roger along with 12583.

[10/14/94 public]
(From Rick:)
The CR is locked at the moment so I can't update it. 
I reinstalled and configured two cells. Executed principal
create of new account for alias fine; principal cat and
principal show look okay to me. Executed registry verify
(probably not needed in my case). Fine.

Executed cdsalias create <alias> and got the same errors
as reported in the CR: 

dcecp> cdsalias create /.../oceans.qadce.osf.org/streams
1994-10-13-16:36:25.224-04:00I0.874 cdsclerk(11333) ERROR cds general
clerk_bind.c 490 0x40033190
Routine rpc_binding_set_auth_info(3rpc) failed : status = 387063930.
1994-10-13-16:36:25.373-04:00I0.874 cdsclerk(11333) ERROR cds general
clerk_bind.c 490 0x40033190
Routine rpc_binding_set_auth_info(3rpc) failed : status = 387063930.
Error: Requested entry does not exist

[10/20/94 public]
Roger fixed this a couple of days ago. He pulled an unnecessary cycle
check. I'll have him update this with something more specific but it is
fixed in the unintegrated tree.



CR Number                     : 12584
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : gds
Subcomponent Name             : dsa
Short Description             : UHYP: DSA core dump for search
Reported Date                 : 10/12/94
Found in Baseline             : 1.1
Found Date                    : 10/12/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : gds/dsa/retutil.c
Sensitivity                   : public

[10/12/94 public]

Doing the following:

- Use the configuration as it is used in the FVT

- gdscp

bind -dirid 2 -dsa /C=de/O=dbp/OU=dap11/CN=dsa/CN=dsa-m2
search / -subtree

This dumps core on both HP and AT386.
The fix is available in Munich - some initializations in retutil.c
(about 5 lines).
Rich: I'd like to call it "HYP". What do you think?

[10/13/94 public]
Fix submitted to unintegrated tree.



CR Number                     : 12570
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : Trigger binding
Short Description             : UHYP: Trigger binding has some minor bugs which might core secd or generate "fault invalid tag" error.
Reported Date                 : 10/10/94
Found in Baseline             : 1.1b21
Found Date                    : 10/10/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : 
 ./security/idl/sec_attr_base.idl; ./security/server/rs/rpriv_attr.c
Sensitivity                   : public

[10/10/94 public]
Sec_attr_base.idl: Missing sec_attr_enc_trig_binding (tag) in sec_attr_value_t.
 This will generate "fault invalid tag" when client calls rs_attr_lookup_by_id
 and triggered a binding call out.
rpriv_attr.c: Some minor bugs which might core secd if generic trigger used.

[10/11/94 public]
Code has been fixed locally.

[10/17/94 public]
Files submitted.  Marked fix.



CR Number                     : 12568
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12496
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : utility functions
Short Description             : UHYP: dced utility function problems
Reported Date                 : 10/7/94
Found in Baseline             : 1.1
Found Date                    : 10/7/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : api/register.c server/sxops.c
Sensitivity                   : public

[10/7/94 public]

Follows the description of 3 separate problems.
The last problem makes dce_server_use_protseq unusable.


1

Inside dce_server_disable_service the call to
	*srvrexec_v1_0_c_epv.srvrexec_disable_service
fails with the error "No bindings".
Previous call to dce_server_register completed successfully.
One peculiar point is that I am disabling my only interface.
I will soon try with two interfaces.

2

Calling dce_server_inq_server after having unregistered will
return error.
Fix by setting the 'got_server' flag.  It's there for this
purpose right ?


3

After successfull call to dce_server_use_protseq("nca...", &st),
calling dce_server_register coredumps.
Specifically inside dce_server_register I get a segfault when
*srvrexec_v1_0_c_epv.srvrexec_started
is called.

[10/19/94 public]

Add other 2

4

In register.c line 230
    else if (*st = dced_s_not_started_by_dced)
should have == .


5

In srvrexc.idl no parameters have the ptr attribute.  This is wrong
at least in the case of srvrexec_started as we call it from
dce_server_register with some NULL pointers.
I can check and change it at least for srvrexec_started.  Yet I
would recommend that someone who really breaths the spirit of this interface,
check the other functions.

[10/20/94 public]
There should be "pointer_default(ptr)" in the start of the IDL file.
But, isn't that the default?  If so, cancel this.

[10/20/94 public]
At least for pointers which are function parameters, I'm not as sure about
pointers inside IDL defined structures, I think the default is actually
'ref'.

[10/20/94 public]
This is how I know it.  If things have not changed very much in the IDL
syntax (and semantics), unless specified, top level pointers default to
ref semantics.  Also pointer_default(ptr) does not apply to them.
So one has to specify them one at a time.
Just to be sure I looked.  See Dev Guide v1 pag 17-40  for DCE 1.0.2
(I do not have DCE 1.0.3 docs handy).
Of course I can just set the ptr attribute on all input pointers just
to be sure.

[10/20/94 public]
A partial fix to the idl got rid of a core dump.

6
In register.c function get_our_bindings need to move
"h->where_bound = i"; inside the loop to execute together
with "bound=TRUE".  As it is, the index will point, beyond
the right binding, most often beyond the last binding.

[10/25/94 public]

2, 3, 5, 6 are fixed.

1 is still in the same state.  Only it cannot work right
now because we do not pass endpoint info srvrexec_started,
from dce_server_register.

4 was not submitted because of an oversight.
I'll send a drb for it tonight.

[10/26/94 public]
I will submit the fix for 4 as part of my work.
I also fixed 1 in dced.  Marking as fix for unintegrated tree.



CR Number                     : 12545
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : dce_login
Short Description             : UHYP:X.500 intercell password failure
Reported Date                 : 10/6/94
Found in Baseline             : 1.1
Found Date                    : 10/6/94
Severity                      : B
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : admin/dced/server/sv_preauth.c,security/h/sec_krb_util.h, security/utils/sec_krb_util.c
Sensitivity                   : public

[10/6/94 public]
Scenario #1
-----------
Configuring intercell between two single-machine cells with X.500 names:

	/c=us/o=osf/ou=dce/cn=gemini (486)
	/c=us/o=osf/ou=dce/cn=prague (UX)

GDAD running on both machines.

GDS is brought on gemini and intercell connection established.  Basic
'cdscp show dir /.../c=us/o=osf/ou=dce/cn=prague' (done authenticated)
works. 

Keys exchanged via rgy_edit successfully.

On gemini, dce_login /.../c=us/o=osf/ou=dce/cn=prague/cell_admin fails with
"Password Validation Failure. - Invalid password (dce / sec) "

(Yes, password used was correct.)  

Machines times are about 1 minute apart.  (Gemini is ahead.)

Scenario #2
-----------

Same machines, but GDS is brought up on prague.  'cdscp show dir
/.../c=us/o=osf/ou=dce/cn=gemini' (authenticated) works.

Key exchange via rgy_edit failed on 'incomplete cell add -- invalid
password'

[10/12/94 public]

Please try the following to narrow it down:

Stop the secval thread of dced. There is an option to dced to do
this, but I forget what it is.

Try logging in as before. If it *succeeds*, then this bug is 
probably in the preauth code.

What this does essentially is default to the Kerberos V5 method of
preauthentication.

Please let us know the outcome of this test.

[10/12/94 public]

While this problem is critical to get into unintegrated, we will hold
off on slating it as such until it is understood more (what the fix is).
Hence, leaving it as a priority 0, but removing UHYP designation.

[10/13/94 public]
Hot diggity, it worked without secval:

Followed Scenario #1.  Turned off sec_val in the gemini cell (the one in
which GDS is running) via 'dcecp secval deactivate'.

dce_logged into foreign cell successfully and created object in foreign
cell.


root@gemini $ dcecp -c secval status
0
root@gemini $ dce_login /.../c=us/o=osf/ou=dce/cn=prague/cell_admin dce
root@gemini $ cdscp
cdscp> create obj /.../c=us/o=osf/ou=dce/cn=prague/foo
cdscp> show obj /.../c=us/o=osf/ou=dce/cn=prague/foo

                        SHOW
                      OBJECT   /.../c=us/o=osf/ou=dce/cn=prague/foo
                          AT   1994-10-13-11:55:17
                     CDS_CTS = 1994-10-13-15:53:48.455469100/08-00-09-25-43-e8
                     CDS_UTS = 1994-10-13-15:53:48.557139100/08-00-09-25-43-e8
cdscp> quit

[10/13/94 public]

Ok, I'll take an educated guess as to what is occuring. The client's dced requests
a TGT to the remote cell, prague. This TGT is involved in the DCE preauth
protocol. When prague's secd receives the login request, it deconstructs the
preauth data and verifies that the machine key information is correct. My guess
is that this check is failing. Will need to debug this to see exactly what is wrong.

[10/19/94 public]

We found the problem. The dced preauthentication code calls krb5_parse_name()
to convert string representations of principal names to the krb5_principal
data type. However, krb5_parse_name() does not properly parse GDA names,
and we end up with a krb5_principal structure, which when sent to the
remote cell's secd as part of the preauthentication data, does not match 
any entry that is stored in its database.

Fix is to correctly convert GDA names to krb5_principal.

[10/25/94 public]
Fix submitted.  Marked OT "fix".



CR Number                     : 12531
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : UHYP:Enable denial status for audit events
Reported Date                 : 10/5/94
Found in Baseline             : 1.1
Found Date                    : 10/5/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : src/security/server/rs/rs_util.c
Sensitivity                   : public

[10/5/94 public]

Enable denial status codes to be returned for audit events.  Currently
all secd audit events return a failure status on all non-successful 
audit records generated.  Open with a A1 priority as this is currently
tentatively planned to be fixed in the unintegrated tree.

[10/12/94 public[]

removing from unintegrated list, but leaving at priority 0 pending
information from HP re: what this fix involves.

[10/12/94 public]

The fix involves one file (rs_util.c) and requires that a case statement
be added that evaluates the audit events and correctly sets the status
code to be denial or failure.  This enables filtering on denial status -
and actually getting some output.  Without this change, you are unable to
filter based on status.

[10/26/94 public]
rs_util.c function rs_util_status_is_denial now returns "true" (denial)
rather than "false" (failure) for the following error statuses:
      case ek_err_passwd_invalid:       /* Invalid password (Registry Edit Kernel) */
      case ek_err_g_mbr_unauth:         /* Not authorized to modify group membership (Registry Edit Kernel) */
      case ek_err_o_mbr_unauth:         /* Not authorized to modify org membership (Registry Edit Kernel) */
      case ek_err_auth_plcy_unauth:     /* Not authorized to modify the authentication policy (Registry Edit Kernel) */
      case ek_misc_not_authorized:      /* User not authorized to perform operation (Registry Edit Kernel) */
      case pwd_imp_err_auth:            /*  - Authentication failure */
      case sec_s_bad_nonce:             /* incorrect response to challenge */
      case sec_s_not_trustworthy:       /* data originated by untrustworthy security/privilege server */
      case sec_acl_unable_to_authenticate: /* unable to authenticate on acl operation */
      case sec_acl_not_authorized:	/* operation on acl not authorized */
      case sec_key_mgmt_e_unauthorized:	/* The caller is unauthorized to perform operation */
      case sec_priv_s_deleg_token_exp:	/* delegation token has expired */
      case sec_rgy_passwd_invalid:	/* Invalid password */
      case sec_rgy_not_authorized:	/* User is not authorized to update record */
      case sec_rgy_rep_init_ekey_invalid: /* initialization encryption key not valid */
      case sec_login_s_privileged:	/* privileged operation invoked in unprivileged process */
      case sec_login_s_acct_invalid:	/* account not valid for login */
      case sec_login_s_null_password:	/* cannot log in with zero-length password */
      case sec_login_s_invalid_password: /* Invalid password. */
      case sec_login_s_preauth_failed:	/* Preauthentication failure. */
      case sec_attr_unauthorized:	/* unauthorized to perform this operation */
      case sec_pwd_mgmt_str_check_failed: /* password failed password strength server checking policy */
      case sec_pwd_mgmt_not_authorized:	/* unauthorized to call password management server */
      case sec_svc_not_authorized:      /* Not authorized to perform serviceability operation */
      case sec_rgy_not_root:	        /* Not a privileged user */

These are the error codes from sad.sams and sec.sams that imply a failure
due to lack of authorization.  I included a few ambiguous cases (sec_priv_s_deleg_token_exp,
sec_pwd_mgmt_str_check_failed) because they can be caused by replay or attempt
to guess passwords.



CR Number                     : 12530
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : SAMS files
Short Description             : UHYP: SAMS file updates to be placed in unintegrated tree
Reported Date                 : 10/5/94
Found in Baseline             : 1.1b20
Found Date                    : 10/5/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : src/security/idl/sec.sams
Sensitivity                   : public

[10/5/94 public]

This OT is a placeholder for the SAMS file updates that are planned
for the unintegrated tree.



CR Number                     : 12528
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12343
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : UHYP: secd's ec files missing ERA and Delegation points
Reported Date                 : 10/5/94
Found in Baseline             : 1.1
Found Date                    : 10/5/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : dce_sec_authent, dce_sec_control,
dce_sec_modify, dce_sec_query
Sensitivity                   : public

[10/5/94 public]

Secd's ec (event configuration) files for audit's filtering of events do
not include ERA and Delegation audit events.  This OT is opened with a
A1 priority as it tentatively planned to be fixed in the unintegrated
tree.

[10/13/94 public]
Linked this bug to 12343, enabling of delegation audit points.  Should also
be linked to a bug yet to be open on enabling of ERA audit points.

[10/19/94 public]
Disregard the last sentence about ERA audit points.  They have been enabled
for a long time.

[10/24/94 public]
Fix submitted to unintegrated tree.



CR Number                     : 12517
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : flserver
Short Description             : flserver coredump - relock of mutex
Reported Date                 : 10/5/94
Found in Baseline             : 1.1b20
Found Date                    : 10/5/94
Severity                      : A
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public

[10/5/94 public]

3 machine/flserver cell (2 HPs, 1 Rios) - dfs.read_write_all.main test
running w/ 4 users. The flserver on one of the HPs coredumped with a
cma_dump.log. The core file was not useable BUT the cma_dump.log was
full of details ... Is there any way to track the problem using this
(and the bl-20 flserver and libdce?)

[2/16/96]

We believe this won't recur.  Please reopen the defect if it does.



CR Number                     : 12508
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_salvage_db
Short Description             : UHYP:enhancement work for
sec_salvage_db to work on DCE 1.1 database, i.e. ERA.
Reported Date                 : 10/5/94
Found in Baseline             : 1.1b0
Found Date                    : 10/5/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : 
.../src/security/h/sec_svg.h
.../src/security/h/sec_svg_tokens.h
.../src/security/server/sec_salvage_db/sec_svg_db.c
.../src/security/server/sec_salvage_db/sec_svg_prt.c
.../src/security/server/sec_salvage_db/sec_svg_rec.c
.../src/security/server/sec_salvage_db/sec_svg_util.c
Sensitivity                   : public

[10/5/94 public]

In order for sec_salvage_db to work on a DCE 1.1 rgy database,
new codes for printing and reconstructing ERA data type ( schema 
attribute and attributes ) are required.  This work was decided
by the management team to be included in the unintegrated tree.

[10/17/94 public]
Bumping the priority of this CR to 0 and making it UHYP (as per Susan) for 
tracking purposes.

[10/26/94 public]

Submit enhancement work for attribute schema and attributes.  There is a
new file attr_schema.prt created for printed attribute schema entries.
Attribute instances are printed together with its associated pgo prt files.

Security  functional tests for sec_salvage_db is not going to work because
the canned comparison files are not updated accordingly.



CR Number                     : 12506
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : schema update_entry
Short Description             : UHYP: Schema update_entry routines
needed to sbumitted to unintegrated tree.
Reported Date                 : 10/5/94
Found in Baseline             : 1.1b20
Found Date                    : 10/5/94
Severity                      : B
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : 
./security/h/rgymacro.h
./security/h/rs_attr_pvt.h
./security/h/rsdb_attr_pvt.h
./security/h/sec_attr_tools.h
./security/idl/sec.sams
./security/idl/sec_attr_base.idl
./security/idl/sec_attr_util.idl
./security/server/rs/rs_attr_schema.c
./security/server/rsdb/rsdb_acl.c
./security/server/rsdb/rsdb_attr_schema.c
./security/utils/sec_attr_util.c
Sensitivity                   : public

[10/5/94 public]
Ann already finished coding and tested.  However, her code is based
on very old baselevel.  Needed more testing and merge, then submit
to unintegrated tree.


[10/17 public]
Files submitted.  Marked fix.



CR Number                     : 12493
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12446,12498
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : UHYP: secd hangs/coredumps if filtering enabled
Reported Date                 : 10/4/94
Found in Baseline             : 1.1b20
Found Date                    : 10/3/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : audit.h, evt_write.c, rs_main.c
Sensitivity                   : public

[10/4/94 public]
In trying to create default cell-wide filters for sec, dts, and audit, 
I found that when filtering was turned (DCEAUDITFILTERON = 1) before
dce was started using dce_config, secd hung and did not complete the
startup.  Note, no filters had yet been installed for secd.  Therefore,
logging was effectively turned off.

I will be getting more information today.  I want to find out:

  1) if secd comes up when filters have been installed
  2) if dtsd comes up when filters have not been installed
  3) if dtsd comes up when filters have been installed

[10/4/94 public]

My bet is that all 3 of these will fail.  I tried to reproduce this
problem locally (using BL18 bits) and can reproduce secd's hanging
(actually it occurs during sec_clientd startup).  My inclination is the
problem is occuring somewhere in dce_aud_start, such that a call to auditd
is being invoked due to the filtering env var being set, but auditd is not
yet up and running - hence the hanging.  Suggest reassigning to aud.

[10/04/94 public]
I finished my testing.  I was never able to get secd to not hang while
I was starting dce.  So test #1 above failed.

I was able to get dtsd to pass tests #2 and #3.  BUT, this only happened
while auditd was running.  If I tried either when auditd was not running,
I saw the following:

[nodoz]:# dtsd -s                  
1994-10-04-15:06:50.645-04:00I0.186 dtsd ERROR dts general
dtss_service_main.c 654 0xa44dd9c8
Cannot open the audit trail file
[nodoz]:#

dtsd never came all the way up.  So, I believe that the problem lies
somewhere in libaudit or both dts and sec are not handling some return
code properly.  That is, when you ask to filter events when auditd is
not running, either there is a bug in libaudit or an error code is
returned that dts and sec trip over.  

I have assigned this to audit.

[10/4/94 public]

Jerry and I have found suspect code, after fixing dtsd to call dce_aud_open
in the correct place, we still get a core dump:
Dtsd no longer print out that opening the trail file fails.

#0  0x429358 in dce_aud_start_with_name
    (529, 5009224, 0, 0, 0, 6823540, 6823544)
#1  0x428f3b in dce_aud_start_with_server_binding
    (529, 6304672, 0, 0, 6823540, 6823544)
#2  0x4201c9 in GetTimeFromProvider (argPtr=0x4c0a18)
    at /project/dce/build/dce1.1/src/time/service/provider_interface.c:710

Looking at the code we see this in dce_aud_start_with_name():
    dce_aud_start_with_pac(event, pac, address, options, outcome, ard, status);
    (*ard)->header.authz_st = rpc_c_authz_name;
    free(pac);

The status return is not checked!!

Looking at dce_aud_start_with_pac():

    if ((options & aud_c_evt_always_log) == 0 &&
        (options & aud_c_evt_always_alarm) == 0 &&
        (aud_g_cli_filter_on))
    {
        pthread_mutex_lock(&esl_mutex);
        aud_esl_get_actions(event, pac, outcome, &as, status);
        pthread_mutex_unlock(&esl_mutex);
        if (as == NULL) {
            *ard = NULL;
#ifdef DCE_AUD_DEBUG
            DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
                "dce_aud_start_with_pac: event needs not auditing \n"));
#endif
            return;
        }
    }

Where *ard is set to NULL and then we return.
We are assuming the by setting DCEAUDITFILTERON, we will trigger
the above code in dce_aud_start_with_pac().

[10/4/94 public]
I'm not sure if this status check fix will rectify secd's hanging problem.

Another possible area that may be causing problems is the calling
sequence of dce_aud_start_with_pac() -> aud_esl_get_actions() ->
sec_rgy_site_open() and sec_rgy_properties_get_info().  This calling
sequence is only occurring if filtering is turned on.  Since the
hang is occurring during sec_clientd startup, chances are that a
audit event is being generated within secd (during sec_clientd startup)
which is causing this hang. - The audit library is trying to
make a sec_rgy_*() call, but sec_clientd isn't available yet.

One other thing I noted was that the sec_audit_trail is empty when this
failure/hang occurs.

[10/04/94 public]
It won't.  dtsd was coredumping, not hanging, so I don't think the two problems 
are related.
The second scenario you are describing sounds more likely, but we need to know
exactly where the hang is.  I wonder if maybe another place in secd needs to use the
dce_aud_start_with_uuid API...

[10/04/94 public]
I don't think the dce_aud_start_with_uuid() API is going to help as it calls
dce_aud_start_with_pac(), which is where I think the problem might be
starting from as I mentioned above.

Just to satisfy my curiosity, I generated a secd audit trail up to the point
where sec_clientd is started, but the registry database has not yet been
initialized, with no audit filtering specified.  The following audit events
were generated:
--- Dumping an event record --- Event Number: 297
--- Dumping an event record --- Event Number: 275
--- Dumping an event record --- Event Number: 275
--- Dumping an event record --- Event Number: 298
--- Dumping an event record --- Event Number: 298
--- Dumping an event record --- Event Number: 297
--- Dumping an event record --- Event Number: 297
--- Dumping an event record --- Event Number: 275
--- Dumping an event record --- Event Number: 298

where 297 = SECID_ParseName
      275 = LOGIN_GetInfo
and   298 = SECID_GenName

(This is using the latest bits, which has the SECID aud points included.)       
Some of these events, are probably being generated by audit itself
especially SECID_ParseName, which is called by dce_aud_start_with_name().

Robert - let me know if seeing the entire aud dump for the above would
be helpful and if so, I'll email it to you.

[10/11/94 public]

Designated for  unintegrated tree.

[10/11/94 public]
According to a note that Sue K. sent me, the hang has disappeared after she made use of
the new dce_aud_set_local_cell_uuid.  Proceeding further, secd hits a core dump,
as described by the following trace sent by Sue:

..........
 This is the traceback I'm getting:
 > trace
  0 dce_aud_start_with_name + 0x000001b8 (0x113, 0x40329750, 0, 0)
  1 dce_aud_start + 0x00000178 (0x113, 0x4032fbd0, 0, 0)
  2 rs_login_get_info + 0x0000006c (0x4032fbd0, 0x4027b854, 0x4027c458,
 0x4027c474)
  3 op0_ssr + 0x0000028c (0x4032fbd0, 0x40194208, 0x4027b51c, 0x40333f58)
  4 rpc__cn_call_executor@libdce + 0x000007c8 (0x40194208, 0, 0, 0)
  5 cthread_call_executor@libdce + 0x000002d4 (0x401fc250, 0x7af3e2a0,
 0x4004b6d0, 0xf)
  6 cma__thread_base@libdce + 0x0000021c (0x4004b6d0, 0, 0, 0)
  7 cma__thread_start1@libdce + 0x0000004c (0x4004b6d0, 0, 0, 0)
  8 cma__thread_start0@libdce + 0x00000008 (0x4004b6d0, 0, 0, 0)
  9 dce_aud_start_with_name + 0x000001b8 (0, 0, 0, 0)
 > 
...............

my analysis of this traceback is as follows:

The traceback shows the "old" loop, the one where dce_aud_start_with_name at
step 9, calls eventually rs_login_get_info, which has a codepoint dce_aud_start
calling dce_aud_start_with_name etc.... (then it crashes.)
I think this is another spot in secd that needs to use dce_aud_start_with_uuid.
Robert.
Assigning to sec component.  (I think this CR should be marked as fixed, and 
another one opened, to deal with the new issue since it is independent of the hang.)

[10/12/94 public]

If fix is clearly understood and fits into unintegrated tree requirements
then this will be marked 'UHYP'.  For now, leave as priority 0.  Maryanne
will prune this bug as well as 12446 if solution is not understood on 10/14.

[10/13/94 public]

Fix being submitted today to unintegrated.

[10/13/94]
Fix submitted.  Also noted in short description that this is a hang/crash.
Initially we only saw the hang which this fix corrects.  Sue reported a
crash on the HP, but we are unable to duplicate the crash at OSF.
Therefore I have marked it as fixed.  If the crash returns, then this
CR should be reopened.

[10/13/94 public]
Just to close the loop on this - using the latest 21.1 bits along with the
changes that Jerry just submitted, I'm now observing secd successfully
startup up when audit filtering is enabled.  Suggest that if this core
dump problem occurs again, a separate/new CR should be opened.  Jerry's
submission does correct the originally reported problem of secd hanging
when audit filtering is enabled.



CR Number                     : 12446
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : aud
Short Description             : UHYP:Need cell-wide default filters
Reported Date                 : 9/30/94
Found in Baseline             : 1.1b20
Found Date                    : 9/30/94
Severity                      : C
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : dce_config
Sensitivity                   : public

[9/30/94 public]
We should create and install default filters cell-wide for dts and
sec.  If not, then all events will go to the respective trail files
and much disk space will be eaten up.

[10/3/94 public]
On hypercritical list.

[10/11/94 public]
Designated for unintegrated tree.

[10/13/94 public]
Fixed.  Added default filters for sec, dts, and audit.  This will be
installed automatically when audit is configured.



CR Number                     : 12385
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : tpq_trace.h should NOT be in export/<context>/usr/lib
Short Description             : tpq_trace.h should NOT be in export/<context>/usr/lib but in export/<context>/usr/include
Reported Date                 : 9/28/94
Found in Baseline             : 1.1
Found Date                    : 9/28/94
Severity                      : D
Priority                      : 3
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public

[9/28/94 public]
tpq_trache.h which gets build from the file/tpq directory should
not be in export/<context>/usr/lib but export /<context>/usr/include.

To fix it, there should be a line in the file/tpq/Makefile as such:
    tpq_trace.h_EXPDIR=/usr/include/???

(I am not sure whether it should just be in /usr/include or 
/usr/include/dcedfs). 

The problem that this header file gets put in the export /usr/lib 
is because of EXPDIR which is set to /usr/lib.



CR Number                     : 12343
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 11884
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : secd
Short Description             : UHYP: Delegation audit points not enabled
Reported Date                 : 9/26/94
Found in Baseline             : 1.1
Found Date                    : 9/26/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : 
./security/server/rs/rpriv.c
./security/server/rs/rpriv_util.c
./security/server/rs/rpriv_util.h
./security/server/rs/rpriv_v1_1_mgrs.c
./security/h/sec_aud_evts.h
Sensitivity                   : public

[9/26/94 public]

Due to OT 11884 (audit subsystem causing secd to go into infinite loop),
the delegation audit points were not fully enabled.  IBM has supplied
a new API, but the delegation code was never subsequently enhanced to
use the new audit API (dce_aud_start_with_uuid).  Am assigning this OT
to myself to correct.

[10/24/94 public]
Fix submitted in unintegrated tree.



CR Number                     : 12292
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cfg
Subcomponent Name             : dfs_config,dfs.clean
                                             config.env
Short Description             : UHYP:cannot config dfsgwd if dfs client daemons running, no bosserver setup/use during dfsgwd config, xtra groups added to rgy
Reported Date                 : 9/21/94
Found in Baseline             : 1.1b16
Found Date                    : 9/21/94
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : dfs.clean, dfs_config, config.env
Sensitivity                   : public

[9/21/94 public]
The DFS/NFS Secure Gateway Appendix A section
A.1.2.2 Configuring the Gateway Server Process
item 13. Create a simple BOS Server process......

is not implemented via the dce_config process for
dfs client configure dfs-nfs gateway server

the gateway server should be maintained as all other
dfs servers (flserver, ftserver, bakserver, repserver, etc)
via the boss server, although this particular server
is configured on a dfs client the bosserver can be
configured to run there also, the machine could in fact
also be a dfs server anyway, omitting bosserver 
from starting, shutdown as well as other operations 
available to the user and administrator leaves the
gateway server with a less friendly user/admin 
environment

the changes to fix this are trivial and should be included
in the dce 1.1 product

[9/26/94 public]
I've changed this to a P1 bug since either reconfig
of the dfs client (causing reboot, I could set this as
a P0 I suppose) must be performed to config the gateway
server at some time other than when initial dfs client
config occurred...

I've also 'optionally' allowed the user to make use of
the bosserver on the dfs client to control/monitor
the gateway server process.

[10/13/94 public]
I've completed the changes and submitted them to the
unintegrated tree.



CR Number                     : 12222
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : clerk
Short Description             : UHYP: more cdsclerk BUS ERROR coredumps
Reported Date                 : 9/16/94
Found in Baseline             : 1.1b17
Found Date                    : 9/16/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : directory/cds/library/deb_ascii.c
Sensitivity                   : public

[9/16/94 public]
Build:	bl-17 PLUS cdsadv and cdsclerk built with "cache paranoid"
Config: rios sec master, cds replica, dts local server
	hp cds master, sec replica, dts local server, dfs flserver
	hp sec replica, dts local server

Stopping and restarting DCE on the RIOS causes cdsclerk coredumps on
the hp cds master machine. Traces differ from previous "corrupted
cache" traces so logging as a separate CR. Note that these coredumps
occurred even WITHOUT the cache paranoid build (core.1 and core.2).
Including all 3 coredumps (3,4 and 5) per John's request.

-rw-rw-rw-   1 root     sys      5403516 Sep 16 10:21 core.5
-rw-rw-rw-   1 root     sys      5006204 Sep 16 10:09 core.4
-rw-rw-rw-   1 root     sys      6554492 Sep 16 09:58 core.3
-rw-rw-rw-   1 root     sys      8049532 Sep 15 19:18 core.2
-rw-rw-rw-   1 root     sys      6992764 Sep 15 19:03 core.1

Copyright Hewlett-Packard Co. 1985,1987-1992. All Rights Reserved.
<<<< XDB Version A.09.01 HP-UX >>>>
Core file from:  cdsclerk
Child died due to: bus error
Procedures:      0
Files: 0
 0 uuid_to_string@libdce + 0x0000010c (0x402c58db, 0x403e8b5c, 0x403e8b60, 0x2d2d2d00)
 1 deb_ascii_uuid@libdce + 0x0000004c (0x403e8aa8, 0x402c58db, 0x402c6100, 0x403e8a04)
 2 get_cached_handle + 0x0000002c (0x403e89f0, 0x402c58db, 0x4043336c, 0x403e8a04)
 3 DoUpdateRPC + 0x000000d0 (0x4043336c, 0x402c58eb, 0x402c58db, 0x400049e8)
 4 send_msg + 0x0000022c (0x4043336c, 0x403e82ec, 0x402c58db, 0x402c58eb)
 5 sendCH + 0x000002ac (0x4043336c, 0x402c5a6d, 0x402c58db, 0x40004b3c)
 6 sendToReplica + 0x00000110 (0x4043336c, 0x402c58db, 0x4, 0x40008ae8)
 7 nsclerkDoUpdate + 0x000000c0 (0x4043336c, 0x1, 0x3, 0x40003c88)
 8 clerk_request + 0x000005dc (0x402c7788, 0x4042bed8, 0x9, 0x400194f0)
 9 th_start + 0x000000cc (0x4042bed8, 0x7af4e478, 0x401c6c98, 0x19)
 10 cma__thread_base@libdce + 0x0000021c (0x401c6c98, 0, 0, 0)
 11 cma__thread_start1@libdce + 0x0000004c (0x401c6c98, 0, 0, 0)
 12 cma__thread_start0@libdce + 0x00000008 (0x401c6c98, 0, 0, 0)
 13 uuid_to_string@libdce + 0x0000010c (0, 0, 0, 0)
----------------------------------------------------------------
Copyright Hewlett-Packard Co. 1985,1987-1992. All Rights Reserved.
<<<< XDB Version A.09.01 HP-UX >>>>
Core file from:  cdsclerk
Child died due to: bus error
Procedures:      0
Files: 0
 0 uuid_to_string@libdce + 0x0000010c (0x401d5893, 0x4030bb5c, 0x4030bb60, 0x2d2d2d00)
 1 deb_ascii_uuid@libdce + 0x0000004c (0x4030baa8, 0x401d5893, 0x401d60b8, 0x4030ba04)
 2 get_cached_handle + 0x0000002c (0x4030b9f0, 0x401d5893, 0x402c966c, 0x4030ba04)
 3 DoUpdateRPC + 0x000000d0 (0x402c966c, 0x401d58a3, 0x401d5893, 0x400049e8)
 4 send_msg + 0x0000022c (0x402c966c, 0x4030b2ec, 0x401d5893, 0x401d58a3)
 5 sendCH + 0x000002ac (0x402c966c, 0x401d5a25, 0x401d5893, 0x40004b3c)
 6 sendToReplica + 0x00000110 (0x402c966c, 0x401d5893, 0x4, 0x40008ae8)
 7 nsclerkDoUpdate + 0x000000c0 (0x402c966c, 0x1, 0x3, 0x40003c88)
 8 clerk_request + 0x000005dc (0x402b7eb0, 0x402bf330, 0x9, 0x400194f0)
 9 th_start + 0x000000cc (0x402bf330, 0x7af4e478, 0x401bf0d8, 0x13)
 10 cma__thread_base@libdce + 0x0000021c (0x401bf0d8, 0, 0, 0)
 11 cma__thread_start1@libdce + 0x0000004c (0x401bf0d8, 0, 0, 0)
 12 cma__thread_start0@libdce + 0x00000008 (0x401bf0d8, 0, 0, 0)
 13 uuid_to_string@libdce + 0x0000010c (0, 0, 0, 0)
----------------------------------------------------------------
Copyright Hewlett-Packard Co. 1985,1987-1992. All Rights Reserved.
<<<< XDB Version A.09.01 HP-UX >>>>
Core file from:  cdsclerk
Child died due to: bus error
Procedures:      0
Files: 0
 0 uuid_to_string@libdce + 0x0000010c (0x401d804b, 0x40311b5c, 0x40311b60, 0x2d2d2d00)
 1 deb_ascii_uuid@libdce + 0x0000004c (0x40311aa8, 0x401d804b, 0x401d9638, 0x40311a04)
 2 get_cached_handle + 0x0000002c (0x403119f0, 0x401d804b, 0x401dd014, 0x40311a04)
 3 DoUpdateRPC + 0x000000d0 (0x401dd014, 0x401d805b, 0x401d804b, 0x400049e8)
 4 send_msg + 0x0000022c (0x401dd014, 0x403112ec, 0x401d804b, 0x401d805b)
 5 sendCH + 0x000002ac (0x401dd014, 0x401d81dd, 0x401d804b, 0x40004b3c)
 6 sendToReplica + 0x00000110 (0x401dd014, 0x401d804b, 0x4, 0x40008ae8)
 7 nsclerkDoUpdate + 0x000000c0 (0x401dd014, 0x1, 0x3, 0x40003c88)
 8 clerk_request + 0x000005dc (0x400a9338, 0x400a9908, 0x9, 0x400194f0)
 9 th_start + 0x000000cc (0x400a9908, 0x7af4e478, 0x401be2f8, 0x13)
 10 cma__thread_base@libdce + 0x0000021c (0x401be2f8, 0, 0, 0)
 11 cma__thread_start1@libdce + 0x0000004c (0x401be2f8, 0, 0, 0)
 12 cma__thread_start0@libdce + 0x00000008 (0x401be2f8, 0, 0, 0)
 13 uuid_to_string@libdce + 0x0000010c (0, 0, 0, 0)
----------------------------------------------------------------
----------------------------------------------------------------

[9/19/94 public]
U believe this is due to a reference to an unaligned uuid pointer being
passed to to get_cached_handle which in turn passes it on. I copied the
uuid into a uuid_t buffer in get_cached_handle before it passes it on and
am waiting to see if that gets by the system test problem.

[9/19/94 public]
John - you have the scenario to test this - let me know how it's going.

[9/30/94 public]
After creating the same configuration with a 486 in place of the rios I was
unable to replicate the problem. I won't cancel it but will drop the
priority to a 1. I only tried once and if I get time next week I will try 
again and do run some functional tests against this configuration.

[10/6/94 public]
Hit it again.

>trace
 0 uuid_to_string@libdce + 0x0000010c (0x4031da35, 0x4010fbdc, 0x4010fbe0, 0x134)
 1 deb_ascii_uuid@libdce + 0x0000004c (0x4010fb28, 0x4031da35, 0, 0x4000b2c0)
 2 get_cached_handle + 0x0000002c (0x4010fa18, 0x4031da35, 0x4019004c, 0x4010fa84)
 3 ModifyReplicaRPC + 0x000000d0 (0x4019004c, 0x4031da45, 0x4031da35, 0x400049e8)
 4 send_msg + 0x0000022c (0x4019004c, 0x4010f2ec, 0x4031da35, 0x4031da45)
 5 sendCH + 0x000002ac (0x4019004c, 0x4031db09, 0x4031da35, 0x40004b3c)
 6 sendToReplica + 0x00000110 (0x4019004c, 0x4031da35, 0x4, 0x40008f40)
 7 nsclerkModifyReplica + 0x000000ec (0x4019004c, 0x1, 0x3, 0x40003c88)
 8 clerk_request + 0x000005dc (0x400a6cd8, 0x400a70d0, 0x9, 0x40018e50)
 9 th_start + 0x000000cc (0x400a70d0, 0x7af422b0, 0x4003ed48, 0x8)


Newly configured cell, Server(hp) - clien(hp)t configuration.
No replicas  either cds or security.

[10/12/94 public]
We think this may be an alignment problem. I will add a line
to deb_ascii_uuid aligning the uuid pointer by copying it to 
a local structure. This is very low risk and may fix the problem.
Up'ing it to a 0 and susan will mark it as UHYP.

[10/19/94 public]
Fixed the alignment problem. Its in the unintegrated tree.



CR Number                     : 12184
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : pwd_mgmt
Short Description             : UHYP: exporting to wrong place
Reported Date                 : 9/14/94
Found in Baseline             : 1.1b17
Found Date                    : 9/14/94
Severity                      : E
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : pwd_config,pwd_strengthd.c
Sensitivity                   : public

[9/14/94 public]
pwd_strengthd exports it's binding info /.:/pwd_mgmt/pwd_strength.  This
path should be under /.:/subsys/dce/.  How about
/.:/subsys/dce/pwd_mgmt/pwd_strength or should it be under sec/ as well? 

Also this info needs to be added to the namespace appendix of the admin
guide.

[10/05/94 public]
This is just wrong - we will fix this in the unintegrated tree because
we don't want to set a wrong precedent (breaking the rules about where 
in the namespace things should go) in DCE.

[10/25/94 public]
Fixed and submitted to unintegrated.  Binding is now exported to
/.:/subsys/dce/pwd_mgmt/pwd_strength.  This is hard-coded in pwd_strengthd,
and pwd_config supports it.  To configure a user principal to use this,

dcecp> principal modify <who> -change {pwd_val_type 1}
dcecp> principal modify <who> -change {pwd_mgmt_binding 
 {{dce /.:/pwd_strength pktprivacy secret name} ${cds_obj}}}

Due to caching, secd must be stopped and restarted if you switch strength
servers that export to different locations.



CR Number                     : 12159
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 11462
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec cntx cache/cdsclerk
Short Description             : UHYP:self principal changes not applying to CDS operations (cdsclerk)
Reported Date                 : 9/12/94
Found in Baseline             : 1.1b16
Found Date                    : 9/12/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : sec_login.c sec_login_cache.c
sec_login_pvt.c sec_login_pvt.h rs_rep_auth.c
Sensitivity                   : public

[9/12/94 public]

Hoping to get feedback from CDS/SEC folks:

Using secval instead of sec_clientd, CDS operations expecting to pass ACL
checks based on the self principal's inclusion in a group fail sometimes.  In
particular, dtsd add an element to /.:/lan-profile.

It looks to be somehow related to the cdsclerk and the way it imports the
client login context (remember that the clerk is the one doing the RPC to
the cdsd, not the client).  If I kill the running cdsclerk and re-try the
failing CDS operation, a new clerk is spawned and the operation succeeds.

Why this happens with secval and not sec_clientd I believe has something
to do with the fact that in
the secval case, the first SELF principal access made to CDS does not
contain the new group membership (dced attempts to connect with CDS early
on).  Yet with sec_clientd running, the first SELF access to the CDS is
by dtsd and therefore WITH the groups membership already in place in the
SELF creds.

I have instrumented cdsclerk to show me when it does context imports.  It
appears to be doing it at the right time, the question then becomes why the
login context imported the *2nd time*, does not seem to be the one getting
to the cdsd in teh form of teh PAC for the ACL check.  Maybe something in 
the context cache  maintained by the SEC client side API's is using the 
wrong/old cached creds info (or not going to read the creds file again)

Mike B, when does the SEC cache logic in a client decide to re-read the
creds file to get changes?  Should the cdsclerk be doing a 
sec_login_refresh_identity() every time it imports a context?

[9/12/94 public]
Put a sec_login_inquire_net_info() in the cdsclerk afetr it does its
sec_login_import_context() of the client login context.  This was so I
could display the contents of the PAC (ala klist) and see what group 
membership this context had.  Not only does this show the correct 
membership, but it also causes the CDS operation to succeed the ACL
check in cdsd.  I am guessing that the inquire_net_info() reads through
the in-memory context cache getting the correct information from the 
creds files.  I assume this should not be neccesary.  Therefore, for now,
I will reassign this from dced -> security.

[9/13/94 public]
It should *not* call refresh identity every time it imports a context.  That
would be a huge amount of overhead that shouldn't be necessary.  Refreshing
a context should not pick up any new groups added since the context was
created, so that shouldn't help anyway.  I'm baffled as to why the inquire
net info seems to have fixed the problem.  I'd say that it's a possibility
that it's just coincidence that it worked when you put that in there...  It
must be a timing related problem since dced/secval isn't that much different
from sec_clientd.  Is it possible that dced/secval is setting up the machine's
context earlier during the config than sec_clientd would have been able to
and is thus not picking up groups which dce_config was about to add when it
started?

[9/14/94 public]

An identity refresh is useless without subsequent validation, which 
requires knowledge of the password, so the cdsclerk couldn't
refresh the identity if it wanted to.  And, as Mike points out,
that wouldn't result in a larger groupset, in any case.

If the problem is a matter of when the secval thread in dced
establishes the host machine principal identity, then flushing and
recreating the host machine credentials prior to configuring
dtsd should fix the problem.  I seem to recall some recent mail
about a "secval  deactivate/activate" command in dcecp that
does exactly that.  Judicious placement of those dcecp operations
in dce_config might help.

[9/14/94 public]
The dcecep commands deactivate/activate are what the dce_config uses
instead of killing/restarting sec_clientd as it used to.  A klist 
immediately following this as self shows the new group membership.  The
cdsd access made by dtsd happens ~10 minutes later so I don;t know if
timing could be the problem. The sec_clientd and secval logic
are not different in what they do to the credentials cache but
as I mentioned, additional authenticated CDS operations take place in the
dced-secval case (unrelated to secval actually).  I think its these CDS
operations that are changing the picture.  The cdsclerk does not seem
to get updated with the new group membership even though it is re-importing
the login context.  With the refresh_identity() idea, I was just trying to
make any call that would ensure the creds file was re-read, the
inquire_net_info() may have done that?

Am I way off suspecting problems related to cached creds info?

[9/14/94 public]
I don't know.  Anything's possible at this stage...
I've added dce-ot-cds to the CC list in case they have any ideas...
I thought the cdsclerk cached contexts itself based on the name of the
credential cache file.  If so, then once you started and talked to a cdsclerk
as the machine, then it probably wouldn't reread it even if you stopped &
restarted the secval portion of dced.  I bet the reason that it wasn't a
problem before is that sec_clientd wasn't talking to CDS right away like
dced is.  When sec_clientd came up, CDS wasn't up yet, so it cached rgy
binding handles obtained from the pe_site configuration file.

[9/14/94 public]

Mike must be right.  The host machine principal context file name
is always the distinguished "ffffffff" file, so the CDS clerk can't
tell when the underlying credentials for the host machine
principal have changed.  Here's what we think is the right solution.

Add a "generation id" to the exported context byte string.  This will
cause the export byte strings for distinct generations of the "fffffff" 
credentials to compare differently.  Currently the export string
looks something like this.

   "FILE:/opt/dcelocal/var/security/creds/dcecred_ffffffff"

We propose changing it to something like this.

   "UUID:37aacf0a-cfdc-11cd-bc57-0800097086bf:FILE:/opt/dcelocal/var/security/creds/dcecred_ffffffff"

NOTE:  This will work only if the CDS clerk is treating the 
exported context as an opaque byte string.  If it is depending
on a particular format, this fix won't work.

Any comments from the CDS folks?

[9/14/94 public]
cdsclerk does have a cache mechanism which keeps them from re-importing the
context at each operation.  In this case though, I think the context (ffff*) is
being re-imported..... (see the first entry in this OT)

[9/14/94 public]

I'd like to suggest the possibility that the problem is due to
the rpc runtime auth_info cache, which I'll call
Acache to distinguish it from the krb identity cache Ccache.  
The Acache contains creds currently associated with rpc bindings.
The creds in the Acache are keyed by server principal and cache name.
The Acache is searched every time an rpc_binding_set_auth_info is called.

In the clerk case the first time through ...set_auth_info the
Acache is searched with key = ( principal=cds, Ccache=ffffffff ).  Nothing
is found. The cred for the cds is then searched in the Ccache ffffffff.
If it is found in the Ccache or has to be acquired over the network is
irrelevant.  What matters is that a copy of it ends in the Acache,
keyed by the above key.  Membership to the dts group is not part of the
authdata of this ticket.

The second time around even though a second context is imported by the
clerk, and it is essentially different (belongs to one more group), it
is still associated with the same Ccache.
The ...set_auth_info call will search the rpc runtime
Acache with the same keys as before, and WILL find the ticket for the cds
in it, UNLESS the previously authenticated binding has been freed or reset.

[9/14/94 public]
We have an outstanding OT 11462 which is this same problem.
I think it is as greg describes.  We are not re-importing the context.
CDS has a cache of binding handles.  I suspect once the connection
is established with the old creds it keeps using it.
The file name has to change for us to do a re-import.
I don't have a solution short of special casing fffffff, but his
means handles will never be cached for this use and performance
will suffer.

I suppose we could check the pac, would this work??  Would we only
have to do it of ffffff??

[9/15/94 public]

A couple of things.

Re: Rob's latest note.

I don't think the RPC auth info cache is at fault.  As nearly
as I can tell, the key is the server principal name and a 
sec_login_handle_t.  The latter is a pointer to an in-memory
login context structure, not a cache name.  

I think the problem of not being able to distinguish
between distinct generations of the ffffffff cache name 
is a generic security problem, so the CDS folks are off
the hook, unless I discover other problems while trying
to apply the "generation id" fix mentioned in my previous
note.

The fix is going to be a little more complicated than I
originally imagined, but I hope to get it coded today.

[9/15/94 public]

Greg is right. Rob should not provide such absurd opinions ...

[9/15/94 public]

Sorry guys.  The above note was a joke.  I am accessing the
ot database with Rob's ID, since I never got my own ID for it.
I offered the above auth info opinion which I recognize to be
wrong.  Rob is not to blame.

I don't know if I am in time to provide any more input, but
I'll try.
The uuid idea although would work, would basically
force cimcumventing the login cache every time. Right ? 

Checking the pac would seem the best thing to do.

Another possibility is to disregard a login context cache match
in ..import_context if the creation time of the
context to be imported is greater than the modtimes.cachefile of
the context in the cache.

The newly imported context would then be entered in the login cache
at the top and susequent lookups would never match older logins.

Both the file creation field and the uuid import-export do not seem
to solve the so far theoretical problem that dced itself cannot
enjoy the newly acquired previleges until the clerk dies or
the cds tickets expire. Right ?

[9/15/94 public]

> Sorry guys.  The above note was a joke.  I am accessing the
> ot database with Rob's ID, since I never got my own ID for it.
> I offered the above auth info opinion which I recognize to be
> wrong.  Rob is not to blame.

No fight, no blame.  Keep those cards and letters coming.

> The uuid idea although would work, would basically
> force cimcumventing the login cache every time. Right ?

No.  The generation uuid is part of the persistent state
of every login context.  The login context cache key is
a filename and a generation uuid.  You will continue to see
the same cache hits as before, minus the erroneous hits
due to the previous inability to differentiate succesive
generations of the host machine credential file.

> Checking the pac would seem the best thing to do.

I don't follow.  To check the PAC, wouldn't you have
to first import the login context?  The purpose of
the login context cache is to avoid unnecessary imports
(i.e. avoid going out to disk).

> Another possibility is to disregard a login context cache match
> in ..import_context if the creation time of the
> context to be imported is greater than the modtimes.cachefile of
> the context in the cache.

Again, the purpose of the login context cache is to avoid the
expense of disk reads.  But if we're already stat'ing the 
file for some reason during import, then, yes this would
be no added expense.  I don't think we are routinely doing so.
And the generation uuid has the advantage of being relatively
opaque.  It works for any sort of credential cache implementation.

> Both the file creation field and the uuid import-export do not seem
> to solve the so far theoretical problem that dced itself cannot
> enjoy the newly acquired previleges until the clerk dies or
> the cds tickets expire. Right ?

My tentative understanding is that the "secval decativate/activate" dcecp
command results in a new host machine credential cache (which now
also has a new generation uuid).  If that is true, the next 
CDS access by dced following such a command will cause a login
context cache miss in the root cds clerk.

[9/15/94 public]

I guess I do not understand.

When let's say dts comes up with uid=root, it gets the host creds.
Where does it find the current generation uuid in order to export
it to the clerk ?  Isn't it stored in the creds file ?
That seems the only place to get it.  Isn't this the meaning of 
' The generation uuid is part of the persistent state
 of every login context ' ?  If this is the case, instead of the
stat on import, one has to do a read on export.

In general, aside from the dced, which create the new creds file,
how is any other process running as root supposed to
know the current generation id of the host creds when doing
an export ?  Such generation id may in theory change at any time
underneath the process and the only way to get it is reading it in
the file. 

Also context imports and exports, as I see it, are a quite a rare
event.  For instance the clerk does an import for each client. But
that happens after the ipc has been estabilished and that's not
cheap stuff.   The clerk situation or the very rare customized
imports/exports are the only cases I have seen.  Is there
any idea of use of import/export in massive scale ?

If, as I see it, import/exports are rare, with respect
to ticket activities, the value of the login cache for login and 
creds sharing seems to be orders of magnitude higher than the 1
file access during import/export.

Am I off the mark ?  

Finally, let me say that I agree that the uuid is more independent
of credential cache implementation.  But, if the only way to let all
the root processes know the new generation id is by embedding it in
the credit cache file, then I do not see any file access advantage
(but I would not care much), and more importantly I do not like the
idea of a change in the creds file layout.   These are the reasons why I
was considering the stat option.

[9/15/94 public]
Greg's gone for the day, so I'll join the fun and make this CR even longer :-)
Addressing your comments above, Max:

Every client has the LC data in memory anyway (whether it got it through
a setup/validate or a sec_login_get_current_context()), so there's no extra
read necessary for an export.  A sec_login_handle_t is just an opaque pointer
to LC structures in memory, part of which is a filename for where that same
data is stored on disk.

You can create the Unique ID for the LC  ONCE when the cred files are created
so there's no chance of it changing out from under you as stated above.

When dtsd or any other process inherits a login context, it has to do a
sec_login_get_current_context().  That reads the login context data from
disk and that in memory creds data is used from then on by that process when
that LC is referenced.  The sec_login_export_context() call just gets the
filename out of that in memory data and passes it back.  The CDS library
code in libdce does the export (after doing a sec_login_get_current_context())
and passes the returned string to the clerk.  So, we're not generating any
extra reads from disk here.

The login context credential file format *has* already changed a lot because
there's a lot more data (delegation...) in there than there was at DCE1.0.X
and this new id will go in the new LC datastructure created for this new
data.  This new structure is written into the creds .data file *after* the
DCE1.0.X information, so it should be possible for a DCE1.0.X client to
read the creds file (it just ignores the extra data at the end of the file).
BUT!  The OSF has already stated that they do not intend to claim support
for 1.0.X binaries STATICALLY linked with libdce.a running on DCE1.1 systems.
A 1.0.X binary using shared libraries will be picking up the DCE1.1 version
of libdce, so in that case it'll be a DCE1.1 binary.

[9/16/94 public]

Mike pretty much covered it.  I'll just add that a single CDS clerk 
services all processes with a given uinx id, so imagine a dce_login
followed by a fork/exec of dcecp.  An admin can change their DCE
identity from within dcecp, and issue operations on any
of the dce core components.  All name service requests generated
during the above activity go through the same cdsclerk.  So
export/import operations may not be all that rare.

Max's suggestion has the advantage of not generating any 
export/import interoperability problems between statically
bound binaries of mixed DCE vintage.  I haven't yet
figured out if I can preserve interoperability in the
statically-bound 1.1 export --> pre1.1 import 
(static or shared) case.  I suspect not.  So if a
statically bound 1.1 DCE app is run on a pre-1.1
DCE host, CDS operations will fail because the pre-1.1
clerk won't understand the new export format.  The same 
is true for any DCE application architectures that make use of 
the import/export feature.

[9/16/94 public]

If changing the cache file format by adding the uuid is no
issue (or a small one), I am all for it.  Yet its being useless
in the general case makes it's impact look large to me.

And it is no clear cut solution as if the clerk imports a login
with an old uuid, you still would like it to match in the LC cache if
a login with a new uuid has already been imported (it's going
to read the current cache file anyway).  The uuid
solution would not find the match here, creating a duplicate
login (unless it check to see which uuid in currently in the
creds file).  A counter or a timestamp would be more effective.

I am still interested in hearing if anyone has ever seen the
import/export operation done in a larger scale of what 
happens in the case in question.  So far I see the case of one
per process connecting to the clerk as typical.
Considering the above example, of a dce_login and exec'ed dcecp
I think that a fork and exec typically involve considerable processing
and disk activity (process setup, reading an executable, setting up
dynamic links, etc.).
Add to it the ipc necessary to communicate the export buffer
(which usually requires disk activity to find the UNIX socket )  and
it still seems to me that an import/export disk read optimization
is not relevant (OK, I agree, it is still worth saving if it does
not compromise anything or create any incompatibilities).

[9/16/94 public]

Thanks for the bulldog tenacity Max.  You convinced
me.  What really did it was the realization that, in order
to tell whether or not the volatile copy of the generation
id was current would require (suprise!) a  file stat/read
operation.

So...

Back to the basic problem.

If I understand the CDS situation correctly, Max's 
suggestion of using the creation time of the
file is almost perfect, but not quite.  The problem is
that, regardless of what security may do under the covers
in the import logic, unless the actual contents of the 
exported byte stream for each generation of the "ffffffff" 
credentials differs, the CDS clerk bypasses the import step
and goes directly to its cache of previously established 
authenticated RPC binding handles and finds a match.  Since 
the necessary service ticket to cdsd is cached in memory in the 
RPC runtime, the credentials cache is not consulted, and the auth
rpc to cdsd takes place with the stale service ticket.

And even if CDS were not bypasing the import logic in this
fashion, it is a legitimate thing to do, and any DCE application
making use of the export/import facility could end up in 
the same boat.

New proposed solution.

Stat (sigh) the file during export to determine the creation time
and include the creation time in the export byte stream.
That ensures that any process using the export byte stream as a
key to an application-level import cache will never equate
distinct generations of the same credentials.

As long as the CDS clerk is comparing the export streams as 
bytes and not as C strings, I should be able to do this in 
way that preserves interoperability in all cases (Oh how I wish
we had put a sec_login_cmp_exported() call in the API...),
without requiring any changes in the CDS clerk.

[9/16/94 public]
Whoa, bringing this OT up in the editor is nearly exhauting the swap
space on my machine...

The latter design from Greg sounds like the way to go, I have this
minor comment though:

>> in the import logic, unless the actual contents of the 
>> exported byte stream for each generation of the "ffffffff" 
>> credentials differs, the CDS clerk bypasses the import step
>> and goes directly to its cache of previously established 
>> authenticated RPC binding handles and finds a match.  Since 

In the initial scenario I was investigating which caused me to open
this bug, the cdsclerk was in fact re-importing the *ffff* creds file.  
I don't see anything obvious in the cdsclerk cache logic (ie. pid or
tid as cache key) that would cause the re-import to happen but it does.  
(The import was on behalf of a differnt CDS client process...)

[9/19/94 public]

Hmm, how about denial of service attack, with large OT files ?
That would work with anybody running secd in the foreground off of
emacs.  Emacs coredumps, there goes secd ...

Seriuosly, I have a couple of remarks (oh no !).  If this discussion
is not of any help, but rather an impediment please let me know  and
I'll stop.

Browsing through the clerk code and asking John Dugas I formed this idea
of the clerk workings (can anyone from CDS land please confirm ?).
The clerk spawns a thread on accepting a client over the unix domain
socket.  The thread is dedicated to serve the accepted client
requests, coming over the accepted file descriptor.  The thread first
always imports the client context and uses that context to
authenticate the binding for CDS requests it will do on behalf of the
client (most of this code is in clerk_bind.c).  Nothing in the clerk
seems to prevent this first context import from a client.
If after a few ns calls the client changes the current context, the
subsequent ns call will send a new export buffer to the clerk.
The clerk DOES check if the export buffer is any different from the
one previously exported by this same client, before importing it.

This seems to agree with Robs findings, that the clerk does in fact
do an import of *fffffff from dts after having already imported it
from dced.

At first this made me think that a different export buffer was a
bit of an overkill.
What I had originally overlooked and makes me appreciate Greg's
solution is the fact that apps do tend to compare export buffers
before invalidating all the authenticated handles and importing
the new buffer.  Greg's solution will in fact, allow the dced 
itself to immediately acquire the new identity for ns calls, something
I was almost about to give up (let's remember that the original
problem was about dts not getting the new identity for ns calls,
not dced).

One final consideration.  Using the file creation time, is, as
Greg noticed, cache implementation dependent.  Is there still
room to consider putting the creation time in the cache content ?
This would replace the stat with a read.  A bit slower, but cache
implementation independent.
I have never looked at the problems related to cache layout changes.
But Mike seemed to be of the opinion that such change was a
no brainer.
Just as I am posing a question in favor of cache implementation
independence I wonder how much such independence is really worth to us
and have to admit reluctance to use a global change (cache layout)
for a very unique situation (host creds recreated having same name).

[9/22/94 public]

Well, stat won't give you the creation time of the file, so
I had to store something in the credential cache file and read
it on export.  I went with the uuid solution.  

Fix coded.  Will be submitted as soon as I can get it
built and tested, hopefully by early next week at the
lastest.

The cache layout is not an issue, since there are already
numerous changes additions to the cache layout required for
delegation.

[10/10/94 public]

To make a long CR even longer ...

The fix I coded is broken big time, and hard to debug, since the core
server freeze up almost immediately. 

In the event that I can't get the fix working soon, I'll begin
investigating the possibility of killing the clerk process anytime the host
principal identity is modified during config.  	It's a sledgehammer, but it
would work.

Any dce_config or cds experts out there object to this (on any grounds
other than its ugliness?). 

It is characteristic of all changes to a principal identity that the
changed identity is not immediately recognized by existing processes 
utilizing the identity.  For instance, if am am logged into a host via an
integrated DCE login, and my groupset is modified, that new groupset will
not be recognized until I run kinit.  Even then, long-lived processes
running on my behalf may have cached service tickets obtained under the old
identity and will continue to use those tickets until they expire.

It just so happens that the CDS client architecture makes use of the
sec_login_export/import path, and that there are steps that can be taken
within that particular path to help the situation. But those steps may
have confusing results.  A process utilizing the host machine login context
may cache some tickets (e.g. to DFS), then invoke a CDS operation.  The CDS
operation would recognize any changes to the host principal identity, but
other remote operations issued directly by the process itself may not.  So
the process might succesfully operate on CDS with the new identity, only to
fail later on in some other operation due to stale credentials.   The 
proposed fix, masticated so thoroughly  in previous entries, is by no means
a general solution--which is why I'm willing to consider the sledgehammer
mentioned above to get past the dce_config problem, in lieu of an
(apparently) destabilizing modifications in the guts of the sec_login code,
which are not likely to receive an adequate amount of system testing this
late in the game.

I'll keep trying for a while longer before I give up entirely.

[10/11/94 public]

If we were to weild the sledgehammer as described by Greg above, I believe 
the correct place in dce_config to kill the cds_clerk would be in
dts_rgyinit()  right after we deactivate/activate secval to get the changed
group ino into the creds cache.

Although, I'm sure how useful this is.  How would future group set changes
ever get recognized in the cds_clerk for self processes?  The current
problem (starting dtsd and it *not* getting the new groupset info from 
the creds cache) demonstrates that not only long running 'self' processes 
don;t see changes, *all* self processes don't see changes.  (This is, of
course, until cds_clerk sec_login_import_context() actually reads the *fff*
creds file which killing it and restarting would obviously force it to do)
I think we would have to kill cds_clerk every time an admin changes the
group membership of self to really make this effective, not only at config
time.  Probably not a workable solution.

[10/11/94 public]

It's usefulness consists solely of providing a workaround for the
DCE config problem at hand, in case I can't get the original fix working
to a reasonable degree of confidence in time for the unintegrated
tree.

On that score, I have successfully configured a cell up through
cdsd and kept it running overnight.  The minimal debug output I 
threw into the sec_login_export/import code indicates the clerk is
re-importing on every invocation of cdscp with any identity, regardless
of whether or not the underlying credentials have changed.  It might be
CDS problem, since security is just handing the clerk a byte buffer
and relying on the clerk logic to avoid uneccessary imports by
comparing the bits in the buffer to those in its cache.  I'm throwing 
in some more substantial serviceability debug statements in the sec_login
code to try and sort out exactly what's happening.

The fix helps only the cdsclerk, and only if the host machine credentials 
are manually recreated (dcecp secval deactivate/activate, I believe).  I'm 
not arguing against the fix, I'm just pointing out that, due to the
sluggish nature of credential changes in general, it's not as big a
deal as I originally thought.  That's why I am less offended by the
thought of the sledgehammer than I might have been earlier.  Even with
this fix, administrators will still have to intervene manually on a host
whenever they change the host machine credentials in order to get those
changes recognized by root processes on that host.

[10/11/94 public]
Any other processes using cds as root(everyone we ship) will see errors
if they happen to be making requsts when you kill the clerk.

It goes down quick and doesn't wait for outstanding requests to complete.

[10/11/94 public]
The binding handle cache is tied to the link between client and clerk.
When the application exits the link is broken and the cached handles
are discarded.  If you seeing lots of re-imports it may be cause of this.

[10/11/94 public]
Greg, this is good news that your fix is getting there.  Just a note that
may assist you;  when config'ing during your debugging don't forget to 
comment out the acl_edit's in dce_config:dts_rgyinit() that allow self full 
access to /.:/lan-profile & /.:/cell-profile.  This cheap workaround is
what enables dtsd to come up today.  

Also, I did not see the excessive cds_clerk imports when debugging this
way back when...

[10/13/94 public]

Put UHYP in the description and bumped the priority to o to 
get this bug back on the endgame radar scope.  

Janet was right in the money; each cdscp session reuires
a single import and within a session, no re-imports occur.

I've removed the dce_config workaround, config'd dtsd, and
verified that the clerk re-imports a new generation of the
host machine principal identity.

I'm currently backed by bl-18.  I'm going to rebuild against
bl-21.1 on hpux and the 486 and, if all goes well, will submit to
the unintegrated tree today or tomorrow.

[10/13/94 public]

Whoops.  You can make it a 0, but not a UHYP.  We can talk about
this at the tech conf call today to determine whether it meets
the unintegrated tree criteria.

[10/13/94 public]
Discussed at the tech conf call and approved for unintegrated.

[10/24/94 public]

fix submitted.



CR Number                     : 12061
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : srvrexec
Short Description             : UHYP: srvrexec endpoints aren't registered
Reported Date                 : 9/6/94
Found in Baseline             : 1.1
Found Date                    : 9/6/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : admin/dced/{server,api}
Sensitivity                   : public

[9/6/94 public]

A dced-started server cannot use dce_server_register to register its
endpoints but must still call rpc_ep_register.  The code was buggy and I
commented it out but the latest submit removed it.  This must be fixed.
It means various other functions (stop via RPC; dced shutdown) don't work
either.

[10/03/94 public]
As a result of a DCE review meeting, raising this to A0 so it can
be addressed this week.

[10/27/94 public]
Here is the status:
	client-side is done but compiled-out by default; see
	admin/dced/api/register.c
	DG server-side (admin/dce/server/epops.c) is done;
	CN server-side (also in epops.c) is not done
	Auto-start is not done



CR Number                     : 12038
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : assert panic in tkm_Token_SetNonSuccessTokenPosition()
Reported Date                 : 9/2/94
Found in Baseline             : 1.0.3
Found Date                    : 9/2/94
Severity                      : A
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public

[9/2/94 public]

A short while ago we experienced a panic in the function
tkm_Token_SetNonSuccessTokenPosition()  (in tkm_getToken.c).  The
problem is that it was passed a null theTokenP argument (1st arg) ...
and this triggered the osi_assert() near the top.

For unknown reasons, we weren't able to get a full stack trace ... so
I examined all 5 of its callers to try and deduce who called it.  It
wasn't hard to rule out 4 of the 5 (they were in paths that already
verified that the value being passed to it was non-NULL).  The 5th
appears to be the culprit ... with a bug.  NOTE: I don't pretend to
understand this code (and don't want to, given that it's being changed
for 1.2) -- so I might be missing something.

I believe that the bug is in the first (of four) call to
tkm_Token_SetNonSuccessTokenPosition() from within tkm_GetToken(). In
our case, the wvMarkerTokenP value passed as the first argument was NULL.
This wvMArkerTokenP value was obtained via an earlier call to
tkm_Token_EstablishFidPriority() ... which apparently returned/left it
as NULL.

   (Plausible since the console was littered with TKM_ERROR_NOMEM messages
    at the time.)

I see nothing protecting us from calling
tkm_Token_SetNonSuccessTokenPosition() with such a null pointer returned by
tkm_Token_EstablishFidPriority().

My current plan is to surround this call with a protective test on
the pointer - as shown below.  It seems safe and ought to fix this
particular panic (who knows what other problems there are when
tkm_TokenFreeList_ObtainToken() cannot conjure up a token to hand out).  If
this really is a bug, I'll leave it to someone at Transarc to come up with
a more thorough/clever fix if appropriate.

New lines are marked by a "*".

*    if (wvMarkerTokenP != NULL) {
	  (void)tkm_Token_SetNonSuccessTokenPosition(wvMarkerTokenP, 
		volFidHashCellP, /* forceRemove = */ 1, rtnVal);
	  tkm_Token_DisposeToken(wvMarkerTokenP);
*    }

Based on a quick glance, this code appears to be unchanged at 1.1.

[11/03/94 public]

Found a couple of bugs in tkm_Byterange_Complement().

(The first one of these, I think, was already entered by Ron into an
 OT.  I couldn't remember/find it, so I'm copying it here as well.)

(FIRST)
When given two equal byte ranges, it cannot set resultP->lo to point
at one of the ranges given it.  Why?  Because its caller in tkm_fidHash.c
will osi_Free() anything it finds in one of the resultP->lo,hi pointers.
This routine HAS to allocate anything that it wants these fields to
point at.

(SECOND)
To protect against the case where the partiallyEnclosedRange token is a
proper superset of the universeRange one, the check near the top should
be:

  if ((hcmp(universeRangeP->lowBnd, partiallyEnclosedRangeP->lowBnd) < 0) ||
      (hcmp(universeRangeP->upBnd, partiallyEnclosedRangeP->upBnd) > 0)) {

instead of

  if ((hcmp(universeRangeP->lowBnd, partiallyEnclosedRangeP->lowBnd) != 0) ||
      (hcmp(universeRangeP->upBnd, partiallyEnclosedRangeP->upBnd) != 0)) {

This was giving rise to bogus tokens with a lowBnd > upBnd.
This in turn was somehow giving rise to stranded tokens in a PENDING
state.  I don't know what this connection was, but I assume it has to do
with the cleanup of the slice-n-dice tokens left in a PENDING state
after the client call returns.  I suspect that "bogus looking tokens" are
somehow being forgotten about ... and hence not cleaned up.



CR Number                     : 11951
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : attr_delete
Short Description             : UHYP: description of attr_delete behavior in IDL files is wrong, misleading to developers
Reported Date                 : 8/30/94
Found in Baseline             : 1.1b14
Found Date                    : 8/30/94
Severity                      : C
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : sec_rgy_attr.idl, rs_attr.idl
Sensitivity                   : public

[8/30/94 public]
The comment for the attr_delete operations in both sec_rgy_attr.idl and
rs_attr.idl describes behavior that was originally in the functional
spec but was removed.  In both files, in the header comment
for the attr_delete operaiont, the following comment:
     * If the type alone is ambiguous, as may be the case with
     * a multi-instanced attribute, a type-value pair may be used
     * to identify the attribute.
     *

should be replaced with something like:
     * This operation deletes every attribute instance of
     * the input type.  The input value is ignored.  

Also, the following comment in the "Multi-valued Attributes"
paragraph:
     * If a type uuid and value are provided, only an instance with
     * the same uuid and identical value will be deleted.

should be replaced with:
     * To perform a delete of just one instance of a 
     * multi-valued attribute, use the attr_update command.

The man page for sec_rgy_attr_delete should reflect this
behavior.

[10/17/94 public]
Files submitted, change status to "fix".



CR Number                     : 11708
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 11913
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : fts
Short Description             : fts tests 12 and 14 FAILING
Reported Date                 : 8/15/94
Found in Baseline             : 1.1b14
Found Date                    : 8/15/94
Severity                      : A
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public

[8/15/94 public]

The fts tests 12 and 14 used for CHO fail with:

 Aug 12 22:13:24 EDT 1994
 Iteration 1.1 of move...
 fts_DeleteVolume: 0,,235 is unattachable (code 691089523).
 Error in move: communications failure (dce / rpc)
 - fts move failed (errno 22) (test14: E23)
 Fileset 0,,232 is already on server dce11.osf.org (aggr m3.aggr2).
 Fileset 0,,232 moved from /.:/hosts/cobbler m1.aggr2 to /.:/hosts/dce11 m3.aggr2

 a previous iteration succeeded:

 Fri Aug 12 18:45:27 EDT 1994
 Iteration 1.1 of move...
 Fileset 0,,61 moved from /.:/hosts/dce11 m3.aggr2 to /.:/hosts/cobbler m1.aggr2
 Fileset 0,,61 moved from /.:/hosts/cobbler m1.aggr2 to /.:/hosts/dce11 m3.aggr2

Ticket lifetimes in the cell had been adjusted to a default of 4d
(including the dce-ptgt account's, which is normally 2h)

Next failure was:

Fri Aug 12 23:24:36 EDT 1994
Iteration 1.1 of move...
Error in move: who are you failed (dce / rpc)
- fts move failed (errno 95) (test14: E23)
Fileset 0,,288 is already on server dce11.osf.org (aggr m3.aggr2).
Fileset 0,,288 moved from /.:/hosts/cobbler m1.aggr2 to /.:/hosts/dce11 m3.aggr2

And then:

Fri Aug 12 23:33:58 EDT 1994

Running cm lsstores...
No failed stores are being retried.

Moving ft1.21098 from m3.aggr2 to m1.aggr2...
Error in move: who are you failed (dce / rpc)
- fts move failed (errno 95) (test12: E64)
BAILING OUT of this part

some other "who are you" failures then:

Sat Aug 13 02:31:16 EDT 1994
Iteration 1.1 of move...
fts_DeleteVolume: 0,,443 is unattachable (code 691089523).
Error in move: communications failure (dce / rpc)
- fts move failed (errno 22) (test14: E23)
Fileset 0,,440 is already on server dce11.osf.org (aggr m3.aggr2).
Fileset 0,,440 moved from /.:/hosts/cobbler m1.aggr2 to /.:/hosts/dce11 m3.aggr2

more "who are you" failures

but manage to pass later:

All done at Sat Aug 13 06:04:57 EDT 1994.

test14 PASSED

All done at Sat Aug 13 06:18:16 EDT 1994.

test12 PASSED

Looking for a pattern ...

FTS test run 1 PASSED : Fri Aug 12 18:28:23 EDT 1994
FTS test run 2 PASSED : Fri Aug 12 18:51:03 EDT 1994
FTS test run 3 PASSED : Fri Aug 12 19:14:08 EDT 1994
FTS test run 4 PASSED : Fri Aug 12 19:37:21 EDT 1994
FTS test run 5 PASSED : Fri Aug 12 20:00:10 EDT 1994
FTS test run 6 PASSED : Fri Aug 12 20:23:16 EDT 1994
FTS test run 7 PASSED : Fri Aug 12 20:46:32 EDT 1994
FTS test run 8 PASSED : Fri Aug 12 21:09:29 EDT 1994
FTS test run 9 PASSED : Fri Aug 12 21:32:41 EDT 1994
FTS test run 10 PASSED : Fri Aug 12 21:55:56 EDT 1994

FTS test run 12 PASSED : Fri Aug 12 22:43:46 EDT 1994
FTS test run 13 PASSED : Fri Aug 12 23:06:57 EDT 1994

FTS test run 16 PASSED : Sat Aug 13 00:16:33 EDT 1994

FTS test run 19 PASSED : Sat Aug 13 01:26:07 EDT 1994
FTS test run 20 PASSED : Sat Aug 13 01:49:43 EDT 1994
FTS test run 21 PASSED : Sat Aug 13 02:13:20 EDT 1994

FTS test run 23 PASSED : Sat Aug 13 03:01:57 EDT 1994
FTS test run 24 PASSED : Sat Aug 13 03:25:36 EDT 1994
FTS test run 25 PASSED : Sat Aug 13 03:48:29 EDT 1994
FTS test run 26 PASSED : Sat Aug 13 04:11:52 EDT 1994

FTS test run 36 PASSED : Sat Aug 13 08:05:50 EDT 1994

FTS test run 39 PASSED : Sat Aug 13 09:15:24 EDT 1994
FTS test run 40 PASSED : Sat Aug 13 09:39:01 EDT 1994
FTS test run 41 PASSED : Sat Aug 13 10:02:14 EDT 1994
FTS test run 42 PASSED : Sat Aug 13 10:25:31 EDT 1994
FTS test run 43 PASSED : Sat Aug 13 10:49:00 EDT 1994

TS test run 45 PASSED : Sat Aug 13 11:40:44 EDT 1994

FTS test run 48 PASSED : Sat Aug 13 12:51:41 EDT 1994

FTS test run 51 PASSED : Sat Aug 13 14:02:37 EDT 1994
FTS test run 52 PASSED : Sat Aug 13 14:26:08 EDT 1994

FTS test run 55 PASSED : Sat Aug 13 15:36:50 EDT 1994

FTS test run 331 PASSED : Sun Aug 14 04:41:21 EDT 1994
FTS test run 332 PASSED : Sun Aug 14 05:05:32 EDT 1994
FTS test run 333 PASSED : Sun Aug 14 05:29:52 EDT 1994
FTS test run 334 PASSED : Sun Aug 14 05:54:12 EDT 1994
FTS test run 335 PASSED : Sun Aug 14 06:18:43 EDT 1994
FTS test run 336 PASSED : Sun Aug 14 06:42:48 EDT 1994
FTS test run 337 PASSED : Sun Aug 14 07:07:13 EDT 1994

FTS test run 340 PASSED : Sun Aug 14 08:19:32 EDT 1994

That's it ...

[8/26/94 public]
Greg's fix for "who are you/ticket refresh" (11423) in but
these tests still failing ...

In fact, test14 didn't pass AT ALL and test12 only passed
twice during my most recent run ... progress?

Errors include:
Error: no quorum elected (dfs / ubk)
Error in create: no quorum elected (dfs / ubk)
- fts create failed (errno 1); test14 ABORTING (test14: E4)
--------------------------------------
Could not get info about site dce11.osf.org (no quorum elected (dfs / ubk))
Error: no quorum elected (dfs / ubk)
connToServer(dce11.osf.org): no known principal for this connection; no quorum elected (dfs / ubk)
, proceeding...
----------------------------------------
(Warning) fts_DeleteVolume: 0,,122 doesn't exist.  Ignoring...
Error in move: communications failure (dce / rpc)
- fts move failed (errno 22) (test14: E23)
Fileset 0,,119 is already on server dce11.osf.org (aggr m3.aggr2).
Fileset 0,,119 moved from /.:/hosts/cobbler m1.aggr2 to /.:/hosts/dce11 m3.aggr2
------------------------------------------------
Removing filesets...
Fileset 0,,123 on aggregate m3.aggr2 server /.:/hosts/dce11 deleted
AFS_SetContext(cobbler.osf.org) fails: who are you failed (dce / rpc)
Error in delete: who are you failed (dce / rpc)
AFS_SetContext(cobbler.osf.org) fails: who are you failed (dce / rpc)
Error in delete: who are you failed (dce / rpc)
Fileset 0,,134 on aggregate m3.aggr2 server /.:/hosts/dce11 deleted
fts delmount: error removing mount point for /.../cho_cell.qadce.osf.org/fs/test/ft4.5377: Connection timed out

Don't know what to make of all this yet - quorum problems the 
biggest concern since these can be difficult to narrow down ...
I'll probably log a separate CR for the new/remaining "who are you"
errors. Comm failures could be related to 11070/11400 - timeouts
an unknown.

[8/29/94 public]
Rerun of test on BL16 came up with the following:

Ticket appeared to expire 3.5 days early since:

FTS test run 2 PASSED : Fri Aug 26 22:51:23 EDT 1994
/:/m3.lfs.fts/fts/runcho.fts starting at Fri Aug 26 22:51:23 EDT 1994
/:/m3.lfs.fts/fts/runcho.fts[53]: pwd: permission denied
sh: :/m3.lfs.fts/fts/runcho.fts[53]:: cannot open
FTS test run FAILED

BUT later the test passed again:

FTS test run 54705 PASSED : Sat Aug 27 14:33:25 EDT 1994

(Large run # due to tight loop caused by "permission denied" problem)

Permission continued to come and go throughout the test.
There were no quorum problems during this run (see CR 11708 for info
on previous run failures). This run did include something new though:

Moving ft1.1605 from m1.aggr2 back to m3.aggr2...
[find token with descriptor 3]
Error in move: Transaction doesn't exist (dfs / fts)
- fts move failed (errno 51) (test12: E71)
BAILING OUT of this part

I suspect the intermittent "permission denied" problems are the
culprit but so far, I'm stumped. I'm removing the RIOS from the
configuration and rerunning.

[8/29/94 public]
More data:

The ftserver core dumped at:

-rw-rw-rw-   1 root     sys      8704860 Aug 26 01:29 core.ftserver

The bosserver would have started a new one which may explain the
renewed ability to pass the tests ... timing isn't perfect since
the tests failed before the ftserver core dumped and continued
to fail for long after a new one started however.

Core file from:  ftserver
Child died due to: IOT instruction
Procedures:      0
Files: 0
 0 _kill@libc + 0x00000008 (hp-ux export stub)
 1 _raise@libc + 0x00000024 (0x40020b98, 0x400375c8, 0, 0)
 2 _abort@libc + 0x00000078 (0x33, 0x400375c8, 0, 0)
 3 _assert@libc + 0x00000128 (0x7aff0468, 0x3, 0x40149d60, 0)
 4 TMEM@libdce + 0x00313da0 (0x4073f6b8, 0, 0, 0)
 5 TMEM@libdce + 0x003145e4 (0x4073f6b8, 0x40149098, 0, 0)
 6 TMEM@libdce + 0x0031d1e4 (0x4073f6b8, 0x40149c98, 0x40149098, 0)
 7 TMEM@libdce + 0x003204e0 (0x4056acf0, 0x40149098, 0x40149098, 0x3a2f6b72)
 8 TMEM@libdce + 0x00310694 (0x4056acf0, 0x40642d28, 0x4014908c, 0x40149090)
 9 TMEM@libdce + 0x003119bc (0x4056acf0, 0x1, 0, 0)
10 dfsauth_client_EstablishLocalA + 0x00000888 (0x1, 0, 0, 0)
11 dfsauth_client_RefreshLocalAut + 0x00000018 (0x400bb8cc, 0x29ccb017, 0x1000000, 0)
12 dfsauth_client_InitAuthContext + 0x00000200 (0, 0x1, 0x1000000, 0x400375c8)
13 dfsauth_client_InitBindingAuth + 0x0000011c (0x40147db4, 0, 0x1, 0x40147dfc)
14 vols_Forward + 0x000006c8 (0x40579c10, 0x40573278, 0x8d, 0x40147930)
15 SFTSERVER_Forward + 0x00000240 (0x40573278, 0x8d, 0x40147930, 0x4014795c)
16 op7_ssr + 0x0000019c (0x40573278, 0x405f1308, 0x4014753c, 0x40147520)
17 TMEM@libdce + 0x00173070 (0x405f1308, 0, 0, 0)

BTW - the new "who are you" bug is 11913
The localauth routines in this trace may be related?

[8/30/94 public]
Tests still don't pass with bl-16.2 - however, 11913 not seen and 11925
kills dfsbind w/in 4 hours of starting test so we won't know much 'til
a fix for that comes in. Bizarre behavior over the weekend may be related
to network problems seen over the weekend.

[9/7/94 public]
Wow - I've put a lot of data in here ... oh well - here's more:

HP only CHO cell w/ bl-16.3

2 runs of fts tests 12 + 14 loops
1st run failed with "who are you" error (see 11913)
2nd run failed with:
Wed Sep 7 18:58:25 EDT 1994
Iteration 1.1 of move...
Error in move: Transaction doesn't exist (dfs / fts)
- fts move failed (errno 51) (test14: E23)
Fileset 0,,124 is already on server dce11.osf.org (aggr m3.aggr2).
Fileset 0,,124 moved from /.:/hosts/dce13 m1.aggr1 to /.:/hosts/dce11 m3.aggr2

then test has bizarre behavior:
/:/m3.lfs.fts/fts/runcho.fts starting at Wed Sep  7 21:14:31 EDT 1994

/.../cho_cell.qadce.osf.org/fs/test exists, chmod'ing it to 777
chmod: can't change /.../cho_cell.qadce.osf.org/fs/test: Connection timed out
/:/m3.lfs.fts/fts/runtests[324]: syntax error at line 332 : `"' unmatched
FTS test run FAILED
/:/m3.lfs.fts/fts/runcho.fts starting at Wed Sep  7 21:23:04 EDT 1994
/:/m3.lfs.fts/fts/runcho.fts[53]: pwd: permission denied
sh: :/m3.lfs.fts/fts/runcho.fts[53]:: cannot open
FTS test run FAILED
/:/m3.lfs.fts/fts/runcho.fts starting at Wed Sep  7 21:23:04 EDT 1994
/:/m3.lfs.fts/fts/runcho.fts[53]: pwd: permission denied
sh: :/m3.lfs.fts/fts/runcho.fts[53]:: cannot open
FTS test run FAILED

tight spin loop ...

This is at the 23 hour mark - dfsbind had logged quite a bit of time by
this point (even tho I caught the test spin w/in 10 minutes):
root@darkman> ps -ef|grep dfsbind
    root  1440     1 -95 22:30:00 ?       306:59 /opt/dcelocal/bin/dfsbind
    root  1439     0  0 22:30:00 ttys0    0:00 /opt/dcelocal/bin/dfsbind

/opt/dcelocal/var/dfs/adm/FtLog on dce11 contained:
1994-Sep-07 19:06:56 Dumping 2:fts.test14.4473.move-temp (0,,127)
1994-Sep-07 19:10:18 trans 406283e8 (Id=174, 0,,127/2) is 193 seconds old (ref c
ount 0)
1994-Sep-07 19:10:18 (trans 406283e8: desc=0, time=778979225, ctime=778979213, s
tates=0x10040006, accs=0x183, acce=691089523)
1994-Sep-07 19:10:48 trans 406283e8 (Id=174, 0,,127/2) is 223 seconds old (ref c
ount 0)
1994-Sep-07 19:10:48 (trans 406283e8: desc=0, time=778979225, ctime=778979213, s
tates=0x10040006, accs=0x183, acce=691089523)
1994-Sep-07 19:11:18 trans 406283e8 (Id=174, 0,,127/2) is 253 seconds old (ref c
ount 0)
1994-Sep-07 19:11:18 (trans 406283e8: desc=0, time=778979225, ctime=778979213, s
tates=0x10040006, accs=0x183, acce=691089523)
1994-Sep-07 19:11:48 trans 406283e8 (Id=174, 0,,127/2) is 283 seconds old (ref c
ount 0)
1994-Sep-07 19:11:48 (trans 406283e8: desc=0, time=778979225, ctime=778979213, s
tates=0x10040006, accs=0x183, acce=691089523)
1994-Sep-07 19:12:18 trans 406283e8 (Id=174, 0,,127/2) is 313 seconds old (ref c
ount 0)
1994-Sep-07 19:12:18 (trans 406283e8: desc=0, time=778979225, ctime=778979213, s
tates=0x10040006, accs=0x183, acce=691089523)
1994-Sep-07 19:12:18 trans 406283e8 (Id=174, 0,,127/2) is 313 seconds old (ref c
ount 0): GCing
1994-Sep-07 19:21:45 Destroying 2:fts.test14.4473.move-temp (0,,127)
1994-Sep-07 21:11:35 Destroying 2:fts.test14.4473 (0,,124)

/opt/dcelocal/var/dfs/adm/FtLog on dce13 contained:
1994-Sep-07 19:06:54 ftserver_CreateVolume: created fts.test14.4473 as 0,,124 on
 aggr 1
 1994-Sep-07 19:07:03 Restoring fileset 0,,124/1
 1994-Sep-07 19:07:03 Restoring 1:fts.test14.4473 (0,,124)
 1994-Sep-07 19:07:04 vols_Restore: returning 0
 1994-Sep-07 19:07:04 Restored fileset 0,,124/1: returned code 0
 1994-Sep-07 19:10:15 trans 400e5fe0 (Id=79, 0,,124/1) is 190 seconds old (ref co
 unt 0)
 1994-Sep-07 19:10:15 (trans 400e5fe0: desc=0, time=778979225, ctime=778979214, s
 tates=0x12810015, accs=0x1c4, acce=691089523)
 1994-Sep-07 19:10:45 trans 400e5fe0 (Id=79, 0,,124/1) is 220 seconds old (ref co
 unt 0)
 1994-Sep-07 19:10:45 (trans 400e5fe0: desc=0, time=778979225, ctime=778979214, s
 tates=0x12810015, accs=0x1c4, acce=691089523)
 1994-Sep-07 19:11:15 trans 400e5fe0 (Id=79, 0,,124/1) is 250 seconds old (ref co
 unt 0)
 1994-Sep-07 19:11:15 (trans 400e5fe0: desc=0, time=778979225, ctime=778979214, s
 tates=0x12810015, accs=0x1c4, acce=691089523)
 1994-Sep-07 19:11:45 trans 400e5fe0 (Id=79, 0,,124/1) is 280 seconds old (ref co
 unt 0)
 1994-Sep-07 19:11:45 (trans 400e5fe0: desc=0, time=778979225, ctime=778979214, s
 tates=0x12810015, accs=0x1c4, acce=691089523)
 1994-Sep-07 19:12:15 trans 400e5fe0 (Id=79, 0,,124/1) is 310 seconds old (ref co
 unt 0)
 1994-Sep-07 19:12:15 (trans 400e5fe0: desc=0, time=778979225, ctime=778979214, s
 tates=0x12810015, accs=0x1c4, acce=691089523)
 1994-Sep-07 19:12:15 trans 400e5fe0 (Id=79, 0,,124/1) is 310 seconds old (ref co
 unt 0): GCing
 1994-Sep-07 19:21:46 Destroying 1:fts.test14.4473 (0,,124)
 1994-Sep-07 19:35:26 Failed to open 1:0,,124, code = 572833799 (Fileset does not
  exist (dfs / ftu))
 1994-Sep-07 19:35:26 Failed to open 1:0,,126, code = 572833799 (Fileset does not
   exist (dfs / ftu))
 1994-Sep-07 19:35:26 Failed to open 1:0,,124, code = 572833799 (Fileset does not
   exist (dfs / ftu))

I have icl.bind logs but I think there's enough info here already :-) - I'm clearly
at a loss on this one ... help!

[10/3/94 public]
The performance problems seem to have been solved (yeah!) and the fts
tests 12 + 14 were humming along for 29 hours when:

Sat Oct  1 23:37:23 EDT 1994

Restoring (and creating) ft3.3521 from /tmp/dump.3521...
Fileset ft3.3521 does not exist, creating it in m3.aggr1 of sarpa.osf.org
        readWrite   ID 0,,921  valid
        readOnly    ID 0,,922  invalid
        backup      ID 0,,923  invalid
number of sites: 1
   server           flags     aggr   siteAge principal      owner
sarpa.osf.org       RW       m3.aggr1 0:00:00 hosts/sarpa    <nil>

Fileset 0,,921 created on aggregate m3.aggr1 of /.:/hosts/sarpa
AFS_SetContext(sarpa.osf.org) fails: Internal corruption (dfs / fsh)
Error in restore: Internal corruption (dfs / fsh)
- fts restore failed (errno 2) (test12: E94)
BAILING OUT of this part

a few hours later:
Sun Oct 2 02:34:24 EDT 1994
Iteration 1.1 of move...
Fileset 0,,965 moved from /.:/hosts/dce13 m1.aggr1 to /.:/hosts/sarpa m3.aggr1
AFS_SetContext(sarpa.osf.org) fails: Communications failure (dce / rpc)
(Warning) fts_DeleteVolume: 0,,969 doesn't exist.  Ignoring...
Error in move: Communications failure (dce / rpc)
- fts move failed (errno 22) (test14: E24)

quorum lost 1.5 hours later:
Removing mount points and filesets...
Could not lock FLDB entry (id=0,,984, type=-1, op=128)
Error: no quorum elected (dfs / ubk)
Error in delete: no quorum elected (dfs / ubk)

Done with cleanup.

All done at Sun Oct  2 04:03:02 EDT 1994.

and then again, much later:
Re-cloning using clonesys...
Could not release lock on FLDB entry (id=0,,1103, type=0)
Error: no quorum elected (dfs / ubk)
----------------------
Total FLDB entries that were successfully backed up: 0 (1 failed; 0 wrong aggr t
ype)
- fts clonesys failed (errno 1) (test12: E56)
BAILING OUT of this part

Part 3: move
============
Sun Oct  2 13:20:27 EDT 1994

There are no ftserver core dumps around and the dfsbind process has only
logged :
    root  5037     1  3  Sep 30  ?       74:23 /opt/dcelocal/bin/dfsbind
since it was started on Friday Sep 30.
The dfsbind process on Sarpa (server_2 in the test) only had:
    root  3847     1  0  Sep 30  ?        1:26 /opt/dcelocal/bin/dfsbind
so dfsbind doesn't seem to be involved in the problem ... still looking
around - ideas welcome.

Dropping back to a 1 to reflect that it is unlikely that this will
be addressed by the freeze. Also, please note that the problems
began after 29 hours of CHO so this is not a simple functional failure.
This will be investigated and if possible, a fix will be submitted
to the unintegrated tree.



CR Number                     : 11356
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : dacl
Short Description             : Disallow addition of vestigial unauth mask entry
Reported Date                 : 7/19/94
Found in Baseline             : 1.0.2a
Found Date                    : 7/19/94
Severity                      : C
Priority                      : 3
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : andi@transarc.com
Transarc Status               : open

[7/19/94 public]
Prevent addition of unauth mask entry. Details below:
The unauthenticated mask ACL entry is not used in DFS for
authorization. But it can still be set. This causes the following
problems.
 
It creates cause for confusion for users.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `andi@transarc.com' 
Added field Transarc Status with value `open'

[7/19/94 public]
Changed Interest List CC from `cfe@transar.com, dws@transarc.com, gmd@osf.org' 
 to `cfe@transar.com, dws@transarc.com, gmd@osf.org, jeff@transarc.com'

[7/19/94 public]
This corresponds to Transac defect 5716. Its fixed by delta
Delta rajesh-db5716-disallow-unauth-mask-entry. 
Tested as follows.
Can't add an unauth mask entry in an ACL now. 
If a file/dir ACL already had an unauth entry then that did not
affect access or operation. The entry could be deleted.
A restore of a dump of a fileset containing ACLS with unauth entries
was successfull with the unauth entries being stripped out. Also the
episode/vnopsVerbose log had trace messages for the unauth mask
entries being stripped out.  Normal operation including acl
manipulation could be done in the restored fileset.
Reviewed by Ted.



CR Number                     : 10685
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : sec_rgy_acct
Short Description             : UHYP:canonicalize homedir in acct API
Reported Date                 : 5/18/94
Found in Baseline             : 1.1
Found Date                    : 5/18/94
Severity                      : D
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : ./security/idl/sec.sams
./security/client/rca/acct.c
Sensitivity                   : public

[melman 5/18/94 public] 
There are problems with putting things like /.: and /: in HOMEDIR on
some systems because of the ':'.  Mike B. had the suggestion that dcecp
should canonicalize the values for HOMEDIR before calling the sec_rgy
API.  There would also be a doc impact since anyone calling the sec_rgy
API should do this as well.

My understanding is that /.: and /: were meant only for interactive use.
The NSI and CDSPI canonicalize names on input, I think the sec_rgy API
should do this as well.  Yes this would mean you can't store relative
names in the database.  I think it just adding a call to
rpc_ns_entry_name_expand() in the code for
  sec_rgy_acct_add()
  sec_rgy_acct_lookup()
  sec_rgy_acct_replace_all()
  sec_rgy_acct_user_replace()

[10/12/94 public]

Removing from unintegrated list, but leaving at priority 0 to
denote that we still need to discuss this.  See below email...

From: burati@apollo.hp.com

Not fixing this will cause users *LOTS* of headaches if they use /: and/or
/.: in home directories on accounts.  Yes, those were only meant for interactive
use, but rgy_edit and dcecp ARE interactive tools and people do use these
names (rather than typing in a long name like /.../cssl.cell.ch.hp.com/fs all
the time).  We know this from experience, it has happened several times in our
own cell.

Need to know more about what the fix entails.

[10/21/94 public]
Files submitted.  Marked fix.

The call added is rpc_ns_entry_expand_name().  The routines changed are
sec_rgy_acct_add(), sec_rgy_acct_replace_all() and sec_rgy_acct_user_replace().



CR Number                     : 10455
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : sec
Subcomponent Name             : client
Short Description             : UHYP:possible use of uninitialized
auto var (internal_binding.c)
Reported Date                 : 4/25/94
Found in Baseline             : 1.0.3
Found Date                    : 4/25/94
Severity                      : C
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : .../src/security/client/rca/internal_binding.c
Sensitivity                   : public

[4/25/94 public]

 The rca_rebind() routine in internal_binding.c uses an automatic variable
named "h". It is possible that this variable could be used before it is
set, The problem is in the following code: 

	,
	.
	.

    rpc_binding_handle_t h;
    
    /* 
     * !!! should free up context->rpc_handle here
     */
    
    /* 
     * Fall back on additional handles, if any..
     */

    for (;;)
    {
        for (i = context->hindex; i<RCA_MAX_HANDLES; i++) 
        {
            h = context->alt_handles[i];
            
            if (h != NULL) 
            {
                context->alt_handles[i] = NULL;
                context->hindex = i+1;
                break;
            }
        }

        if (h == NULL)

	,
	.
	.
  

 If the value of context->hindex equals RCA_MAX_HANDLES when the routine is
entered, then control will immediately fall through the statement

        for (i = context->hindex; i<RCA_MAX_HANDLES; i++) 

The variable "h" will not be set, but will be tested against NULL in the if
statement immediately following the for loop.

[10/12/94 public]

Removed from unintegrated list.

[10/12/94 public]
Just registering my disagreement with the removal of this CR from the
unintegrated list.  This is an obvious bug that could cause unpredictable
behavior, and has a one line fix.  Why would you not want it?

[ sekhar 10/18/94 public ]
Fixed.



CR Number                     : 10443
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : fts syncfldb invalidates valid backup entries in the fldb.
Reported Date                 : 4/22/94
Found in Baseline             : 1.0.3a
Found Date                    : 4/22/94
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : src/file/userInt/fts/volc_queue.c
Sensitivity                   : public

[4/22/94 public]
 
Full Description:
        When running a fts syncfldb command against a servers
        aggregate that contains valid .backup volumes, the .backup
        is *always* marked invalid in the fldb and the .backup 
        is *not* deleted.
 
Repeat By:
 
        fts clone  -fileset {<name> | <ID>}
        fts syncfldb -server <machine> [-aggregate <name>]
 
        Aggregate name does not need to be specified.  Only requirement
        is that a valid .backup volume exists on an aggregate to
        be synced with the fldb.
 
Proposed Solution:
 
        In src/file/userInt/fts/volc_queue.c function ProcessEntries,
        when finding a valid backup volume who has a valid RW on the
        same site, the entry.flags should be updated to include the
        valid backup.
                        ...
                        ...
if (qvol.isValid.BACKVOL.) { 
    if ((i = vldb_FindRepSite(&entry, (struct sockaddr *)0, -1,
                            VLSF_ZEROIXHERE >> xl.RWVOL.)) != -1) { 
        if (entry.flags & VLF_RWEXISTS) { 
            /* Check whether the entry's RW is on the site of this backvol.
*/  
            k = 0;
            for (j = i; j < entry.nServers; ++j) { 
                if (j > i && (entry.siteFlags.j. & VLSF_SAMEASPREV) == 0)
break;
                if (bcmp(servAddrp, &entry.siteAddr.j., sizeof(struct
sockaddr))
                    && entry.sitePartition.j. == aggrId) { 
                    k = 1;
=== FIX ===>>>      entry.flags |= VLF_BACKEXISTS;
                    break;
                } 
            }

[4/22/94 public]
In other spots in this code, vldb_AssignSite is used, rather than
simply OR-ing in bits to the entry, and that should be done here as
well.  This will also correct how the code is clearing the
VLSF_ZEROIXHERE>>xl[BACKVOL] flag.
 
Actually, I'd replace the existing ``entry.flags |= VLF_BACKEXISTS''
code with a vldb_AssignSite, as well.

[2/19/96]
Fixed as of 1.2.1 code drop.



CR Number                     : 10303
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : dfs
Subcomponent Name             : repserver
Short Description             : repserver needs to reset volume info after RW move
Reported Date                 : 4/6/94
Found in Baseline             : 1.1a
Found Date                    : 4/6/94
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : 

[4/6/94 public]
 
Sometimes after the RW is moved the repserver will spin because it
keeps getting the error VOL_PERS_DELETED, and is unable to update the
RO volume.  In the AFS_GetToken call will return error code 691089410.
We were wondering if clearing the repflag_KnowVLDB when we get this
error would fix the problem by forcing the repserver to re-read the
information from the vldb.  The workaround right now is to restart the
repserver.
 
Here's the icl tracing:
 
time 893.005890, pid 10: 0,,8: Attempting to get token (0x404) for 0,,7 on primary
time 893.024417, pid 10: GetToken result: 691089410
time 893.024790, pid 10: NeedSetVol figuring VV
time 893.025079, pid 10: NeedSetVol TRUE: new PingCurr time 765629272.005497 -> 765629309.005581
time 893.025327, pid 10: UpdateLocal calling AGOPEN
time 893.026013, pid 10: UpdateLocal: calling SetOpenVol
time 893.026237, pid 10: SetOpenVol calling SETVV
time 893.027509, pid 10: SetOpenVol: Set VV for 0,,8: flags 1000, mask 3000, curr 765583749.015955,
pc 765629309.005581, TO 765583750.011893
time 893.027873, pid 10: SetOpenVol returning 0
time 893.028104, pid 10: UpdateLocal: calling CLOSE
time 893.028589, pid 10: UpdateLocal: returning 0
nVol
time 893.031188, pid 10: [0,,8: delay 37 secs: TryForWVTRead: fileset not present and exported on se
rver: already deleted/moved (dfs / xvl)]
time 893.031779, pid 10: bkg: StartImporting sleeps 37 secs
time 893.032007, pid 10: repserver: ForceKeepAlive() called
time 893.032719, pid 10: Sleeping for 37 seconds (on actNowCond)
time 930.002748, pid 10: bkg: now 765629346, tgt 765629346, timed out: on time.
time 930.003975, pid 10: 0,,8: Attempting to get token (0x404) for 0,,7 on primary
time 930.023395, pid 10: GetToken result: 691089410
time 930.023768, pid 10: NeedSetVol figuring VV
time 930.024054, pid 10: NeedSetVol TRUE: new PingCurr time 765629309.005581 -> 765629346.003666
time 930.024302, pid 10: UpdateLocal calling AGOPEN
time 930.024973, pid 10: UpdateLocal: calling SetOpenVol

[4/6/94 public]
This is supposed to be fixed by the fts process doing the move calling
vldb_TellAllReplicas (or something like that) after the move
completes; this should call REP_AllCheckRepConfig on a repserver,
which should call REP_CheckRepConfig on each repserver for the
fileset.  Does the problem not get better within a few minutes?  Is
there any evidence for these calls being made?
 
It could be that the repserver could react to the VOLERR_PERS_xxx code
in the same way that the CM does, which is by re-reading the FLDB
information.  It could do this most sensibly by clearing
repflag_KnowVLDB.
 
I've added Jeff to the CC: list in case he has other comments.
Changed Interest List CC from `cfe@transarc.com' to `cfe@transarc.com, 
 jdp@transarc.com'

[4/6/94 public]
The repserver doesn't have any code that notices that a R/W has moved.
The two routines that should be doing this checking, CheckWithVLDB and
CheckVLDBRelationship, only check whether a given replica should or
shouldn't exist on the local server.  These routines need to check the
R/W location and use that information to update the replica's primary
host/connection data.
The only thing I'm puzzled by is the statement that "Sometimes after
the RW is moved the repserver will spin".  I'm surprised that it would
ever work, except for intra-server moves.
A fix for this high priority defect will be made in the near future
under the Transarc defect 5012 (5012 01/26/94 Numerous problems with
moving replicated filesets).
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `'

[4/6/94 public]
I should add that the propsal to unset repflag_KnowVLDB is a fine idea
from the point of view of increasing robustness, but it will not fix the
problem until the fix I discussed above is made.



CR Number                     : 9989
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : dfs
Subcomponent Name             : fts test8
Short Description             : exp stat incorrect for E44,58,60,64
Reported Date                 : 2/22/94
Found in Baseline             : 1.0.3a
Found Date                    : 2/22/94
Severity                      : D
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2
Affected File(s)              : file/fts/test8
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[2/22/94 public]

I realize that jaffe is probably not the correct person and 
that tarc will probably give this to osf, but I don't have
a tarc mailname to use in place of elliot...

fts/test8 has been changed on the 1.0.3a src tree to
expect nonzero status from the following ops...

   E27 fts lsfldb -locked $av_arg
   E82 fts ulockfldb $av_arg
   E84 fts lsfldb -locked $av_arg

and in fact a status of 1 is returned

the following ops however are still expecting a status
of 0...

   E44 fts lsfldb -locked $av_arg
   E58 fts lsfldb -locked $av_arg
   E60 fts unlockfldb $av_arg
   E64 fts unlockfldb $dns_server_prefix$SERVER_1 $av_arg

in fact when running this test on a ufs exported dfs system
the status returned is 1, as the ops listed above...

I've run this on a build done here since the tarc drop..
Test passed on version built prior to this...
looks like fts has changed but the test has not...

[3/1/94 public]
It sounds like you are missing the set of fts changes for OT 5694,
but have the accompanying testcase changes.  Its been a while,
but if I remember correctly, OT 5694 changed the way the bulk
fts commands handled the case where there were no hits and the
way wrong aggregate type was handled.  For example in the case
of test8 assertion E27, it should return 1 because it found
no locked filesets:
# fts lsfldb -locked
----------------------
Total FLDB entries that were successfully enumerated: 0 (0 failed; 0 wrong aggr 
type)
# echo $?
1

In E44 and E58, filesets have been locked, so the expected result
is that they will successfully be listed and a 0 is returned.

These changes also effected clonesys, delfldbentry, etc, so I
would expect you to have similar problems with other fts tests
(I think test7 does the clonesys testing) if you really do have
the testcases and fts commands out of sync.  Otherwise, we need
to make sure these changes have not somehow been lost from the
fts code in 1.0.3a. I am not seeing this problem here.

Part of this work was also to start treating wrong aggregate
type as a 'soft' failure and just list the number of wrong
aggregates but still return 0.  For example:

# fts clonesys
Backup is supported only on LFS or VXFS filesets (e.g. not on this non-LFS one).
Backup is supported only on LFS or VXFS filesets (e.g. not on this non-LFS one).
Backup is supported only on LFS or VXFS filesets (e.g. not on this non-LFS one).
----------------------
Total FLDB entries that were successfully backed up: 40 (0 failed; 3 wrong aggr
type)
# echo $?
0

Do you have this change? These were primarily made in
src/file/userInt/fts/volc_vldbsubr.c:vldb_HandleBulkEntries.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'

[9/15/94 public]
Andy, I think this can be cancelled.  Can you do so once you've
verified fts test3, test7 and test8 all pass?  Thx.

[2/16/96]
Fixed as of 1.2.1 code drop.



CR Number                     : 9831
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : dfs
Subcomponent Name             : fts
Short Description             : fts restore fails
Reported Date                 : 1/27/94
Found in Baseline             : 1.0.3a
Found Date                    : 1/27/94
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[1/27/94 public]
 
I used fts dump to dump a 300MB UFS aggregate to a file within an
Episode fileset.  Then I used fts restore to restore to a new
fileset within the same Episode aggregate. The restore worked
for more than an hour, then I happened to rlogin into the server
machine and apparently at that instant the restore died:
 
(Note that t2 did not exist when the restore started)
 
# fts restore -ftname t2 -server booboo -aggregate test.dfs -file u1.dump
Fileset t2 does not exist, creating it in test.dfs of booboo.osf.org
        readWrite   ID 0,,19  valid
        readOnly    ID 0,,20  invalid
        backup      ID 0,,21  invalid
number of sites: 1
   server           flags     aggr   siteAge principal      owner               
booboo.osf.org      RW       test.dfs 0:00:00 hosts/booboo   <nil>               
Fileset 0,,19 created on aggregate test.dfs of booboo
Caught exception writing to ftserver: (rpc_x_ss_pipe_discipline_error) exception raised
Error in restore: I/O error in pipe (dfs / fts)
 
It might be a resource problem caused by the rlogin cosuming more
virtual memory (or swap).
 
The output of 'fts lsheader' on the affected aggregate is:
 
# fts lsheader -aggregate 30
fts: Missing required parameter '-server'
# fts lsheader -aggregate 30 -server booboo
Total filesets on server booboo aggregate test.dfs (id 30): 2
t1                       0,,16 RW 209338 K alloc 209338 K quota On-line
t2                       0,,19 RW 183783 K alloc 183783 K quota **Off-line (inconsistent--being updated)
Total filesets on-line 1; total off-line 1; total busy 0

[1/27/94 public]
We hit something similar last summer doing large fileset moves
(on the order of 450M fileset).  I'll include output from our
internal bug report below.  The problem was fixed, as well as
several related problems (dfsexport -detach panic on fileset
left in this state, and ftserver not closing transaction on
this error), but I don't know the OT numbers.  I'll see if
Carl remembers tomorrow.
 
    <Note by dstokes (Dawn C. Stokes), 93/06/11 16:55:50, action: note>
 
Hit this last night moving a fileset which I was at the
same time copying a build into.  What appears to be the
failure condition in the FtLog is:
 
93-Jun-10 20:47:13 ftserver_CreateVolume: created dce.build.22e as 0,,742 on aggr 21
93-Jun-10 21:01:54 ftserver_CreateVolume: created sshi_fs1 as 0,,746 on aggr 14
93-Jun-10 21:02:08 Restoring fileset 0,,746/14
93-Jun-10 21:36:19 vols_Restore: returning 0
93-Jun-10 21:36:19 Restored fileset 0,,746/14: returned code 0
93-Jun-10 21:38:15 Restoring fileset 0,,746/14
93-Jun-10 21:38:16 vols_Restore: returning 0
93-Jun-10 21:38:16 Restored fileset 0,,746/14: returned code 0
93-Jun-10 21:44:25 ftserver_CreateVolume: created dce.build.22e as 0,,748 on aggr 20
93-Jun-10 21:44:29 Restoring fileset 0,,748/20
93-Jun-10 22:45:40 SFTSERVER_Restore: Exception while restore-terminating: (rpc_x_ss_pipe_comm_error) exception raised
93-Jun-10 22:49:10 trans 2014b928 (Id=74, 0,,748/20) is 208 seconds old (ref count 1)
93-Jun-10 22:49:11 (trans 2014b928: desc=1, time=739770342, ctime=739766665, states=0x12010015, accs=0x1c4, acce=691089523)
 
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'

[1/28/94 public]
I think it was probably OT 8042.  The idea is that there are two threads in the ftserver
that cooperatively do the dump/restore/move/whatever, and that if one of the threads
takes an exception, it has to tell the other thread to terminate so as to release the
reference to the fileset.  At least, that was the idea behind the 8042 fix.
 
Of course, that's a bug that's closed now, and presumably you have the fix for it.
It would have been a good idea to capture part or all of the FtLog information when this
odd event occurred at the OSF.

[2/16/96]
We believe this won't recur.  Please reopen the defect if it does.



CR Number                     : 9737
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 9631
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : dfsexport
Short Description             : should report bad fileset on attach
Reported Date                 : 1/13/94
Found in Baseline             : 1.0.3a
Found Date                    : 1/13/94
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1
Sensitivity                   : public

[1/13/94 public]
For 1.1 ...
From 9631, the remaining work to address the case of "bad fileset
on aggregate during attach":

[1/7/94 public]
What happens now (after the fix) is that AG_VOLINFO, called from 
ag_RegisterVolumes, returns EIO.  Note that ag_RegisterVolumes throws this
value away but does a "continue", which means that it doesn't try to register
the fileset in the fileset registry.
.
So if you try to do something like fts lsquota, or try to access the fileset
through a mountpoint, you will error codes and messages.  You can't crash the
machine this way.
.
However, it could appear mysterious.  There should be an error message of some
kind.  ag_RegisterVolumes is already printing a message to the console in
another case.  (It might be more useful to pass the error code back out to
the process and let the process print a message on stderr, but this would
require a change to the interface, since more than one fileset in a single
aggregate can fail to register.)



CR Number                     : 9707
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : cm
Short Description             : There appears to be no limit
to the number of cm_vdirent elements that might be instantiated in memory.
Reported Date                 : 1/10/94
Found in Baseline             : 1.0.3
Found Date                    : 1/10/94
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public

[1/10/94 public]
 
While using our kernel debugger to poke around at various DFS kernel
structures, I noticed the following.
 
If cm_TryBind() {in cm_vdirent.c} is asked to look up a non-existant name,
it creates a cm_vdirent entry for it and threads it onto its directory
any way.  (This via its call to cm_AddVDirElement() in the ENOENT path.)
 
There's no limit to the number of these that there can be ... and no way
to get automatically get rid of them.  If I sit in user space and run a
script that attempts to access zillions of different things in this space
(e.g.:  /.../aaaaaaaa, /.../aaaaaaab, /.../aaaaaaac, etc.), an arbitrary
amount of kernel memory (wired for HPUX) will be consumed.  Presumably
leading to a crash or hang at some point.
 
Shouldn't there be a limit on the number of these entries that exist ...
even if only for ENOENT ones?

[3/4/94 public]
Daryl at HP plans to fix this.

[3/4/94 public]
I'm glad that Daryl plans to do something about this.  I wanted to
raise an issue or two, though.  If the CM is to disallow keeping lots
of these cm_vdirent structures around, what will it do when it reaches
its limit?  It seems senseless to deny the creation of new structures;
perhaps instead when a new structure is needed, the LRU comparable
structure could be recycled.  Thus, there could be two global lists:
one for the valid ones and one for the ENOENT and other error cases.
(Standard stuff: on reference, a structure is removed from the place
where it is and put on the head of the proper list; this lets it be
moved to a new list if conditions change.)
 
Anyway, I hoped that Daryl's work didn't amount to adding a new error
condition for cm_TryBind()--you know, returning a code like ENOMEM or
ENFILE or whatever, and failing.



CR Number                     : 9700
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 9661, 9352
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : cds
Subcomponent Name             : 
Short Description             : UHYP:Do whatever needs to be done
to fix-up name space after ip address change.
Reported Date                 : 1/7/94
Found in Baseline             : 1.1
Found Date                    : 1/7/94
Severity                      : B
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : db_common.c,dump_navigator.c,back_ground.c,ta_cle.c,unix_cds_net.c
Diff supplied by              : 
Diff release                  : 1.2.2
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[1/7/94 public]
The short description says it all.

[8/30/94 public]
Changed Interest List CC from `mp@osf.org' to `mp@osf.org, 
 dstokes@austin.ibm.com' 
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'

[9/23/94 public]

Will go into unintegrated.

[10/13/94 public]

Slated for unintegrated tree via UHYP and P0.

[10/14/94 public]
Jackie is merging the code up to the unintegrated tree. Assigned to her.

[10/14/94 public]
Could someone add some detail to this defect wrt what the
problem and symptoms of the problems are?  What is CDS not
handling, and what is a general decription of the fix?

We attempted an address change in our production cell last
night, and finally gave up and reverted our primary CDS
server back to the old address because we just couldn't get
it to work.  It would be nice to know if we were doing something
wrong or hitting a limitation.

We updated the cds_config and pe_site files, removed all CDS
caches, security creds, etc., and rebooted the system.  Everything
would come up fine, but the minute you tried to access CDS, it
would pull directories into its cache with the old addresses.
Where is this coming from?

[10/17/94 public]

The way it should work is that you just issue a 
"cdscp clear clearinghouse /.:/my_ch" or whatever the dcecp equivalent is, 
move the version,tlog & checkpoint files from the directory at
/opt/dcelocal/var/directory/cds on the "old" node to same on the "new" node
and then issue "create clearinghouse /.:/my_ch" on the "new" node.

Currently, (before I submit the change into unintegrated) the 
clearinghouse object and the internal data structures are corrected, but
until the background runs the changes won't propogate to all the other
clearinghouses in the cell.  Also, if I remember correctly, the directory
replica pointers aren't fixed properly -- this is what you're seeing.  
I'll have the fix in shortly that uses the background thread to do all
this fix-up immediately after the clearinghouse arrives at its new home, 
and you can try it out.

[07/25/96 public]
This was originally checked into the R1.1 unintegrated tree.  HP has
merged the R1.1 unintegrated into R1.2.2 (I checked the sources and
saw that this change was there).  So, I'm changing the status of
this OT to fixed.



CR Number                     : 9693
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : deadlock caused by failed pageouts
Reported Date                 : 1/6/94
Found in Baseline             : 1.0.3a
Found Date                    : 1/6/94
Severity                      : C
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[1/6/94 public]
If a pageout triggered by vnvm_purgereserved fails, the process(es) waiting for
the reservation to clear will deadlock indefinitely.
This failure is only supposed to happen on I/O errors, but we observed a
deadlock of this type once while running fts/test21, and it seems to have
been caused by an out-of-space error (ENOSPC).  Pageouts aren't supposed to
run out of space (this is what reservation is supposed to be for), but it
seems to have happened.
In any case, when there is a pageout failure, any space reserved for the
corresponding vnode should be given back (vnm_Unreserve).  This may lead
to under-reservation, but that is much more acceptable than deadlock.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[2/16/96]
Reservation code is gone.



CR Number                     : 9675
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : dfs
Subcomponent Name             : 
Short Description             : Bug in non-blocking lockctl()
interaction with tkc manager.
Reported Date                 : 1/3/94
Found in Baseline             : 1.0.3
Found Date                    : 1/3/94
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 Code drop
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : andi
Transarc Status               : open

[1/3/94 public]
 
There appears to be a bug in the interaction between file locking and the
tkc manager.
 
The following sequence of operations exhibits the problem:
 
  (a) On machine A, let there be an exported UFS fileset ... with a file
      foo.
 
  (b) On machine A, process P1: open this file via its local (ufs mount)
      pathname and lock byte range 0..1000.  (via fcntl(..F_SETLK..))
 
  (c) On machine A, process P2: open this file via its local pathname and
      try to lock this same byte range again via a non-blocking operation.
      (fcntl(...F_SETLK..) again)
 
      This non-blocking operation will fail due to the conflict with (b).
 
  (d) Exit both of these processes.
 
  (e) Go to machine B and try to lock this byte range of the file (since
      the file is no longer local, use a DFS pathname this time).  This
      will fail!
 
I claim that this is due to the following bug in xglue_lockctl().
 
  xglue_lockctl() currently does the following -- for both HPUX and other
  platforms.
 
     .....
     code = tkc_GetLocks()
     if (code == 0) {
       code = VOPN_LOCKCTL()
 
  The tkc_GetLocks() call grabs a DFS token/lock -- failing ONLY if the
  desired use conflicts with what some other node is doing.  Conflicts with
  what's happening at THIS node are supposed to be caught by
  VOPN_LOCKCTL().  If the VOPN_LOCKCTL() fails (as it does  in step (c)
  above), the code returns ---- without giving back the DFS token/lock it
  got from tkc_GetLocks().
 
  This "stranded" token/lock is what is interfering with the operation in
  step (e).  Since the fcntl() call in (c) failed, HPUX never set the
  "better-release-locks-at-file-close-time" flag for the process ...
  causing this token/lock to "never" be released.
 
  As a simple experiment, I changed the code as follows:
 
    .....
    code = tkc_GetLocks()
    if (code == 0) {
      code = VOPN_LOCKCTL()
      if (code && cmd != F_GETLK))
        tkc_PutLocks()
 
  My test worked properly with it this way.
 
Of course, calling tkc_PutLocks() like this isn't right either since it
will release ALL tokens over the byte range in question -- not just the one
we got above.  How about using a new call, e.g. tkc_PutLockExact(), which
releases the first token/lock on exactly the specified byte range and no
other?
 
I assigned Bruce Leverett's name to this ... although I have no reason to
believe that he's the right person at Transarc for this.  I'm perfectly
willing to "fix" this (assuming people agree with my fix) if that's what
you want ... although it'll be a few weeks before we are merged up to
the latest 1.0.3a level.
 
While I was looking at the tkc code, the following "improvements" occurred
to me as well.
 
  () The TKC_VHASH() macro in tkc.h  (== (long)vp & (TKC_VHASHSIZE-1))
     seems less than optimal given that vp is always going to be a multiple
     of 4 (TKC_VHASHSIZE == 256).  Perhaps the following would be better:
        ((long(vp) / 4) & (TKC_VHASHSIZE-1)
 
  () The functions tkc_Get() and tkc_GetTokens() do the wrong thing if
     asked for an ordinary read/write token with a byte range.  Because
     tkc_HaveTokens() doesn't take into account these byte ranges at all in
     deciding if an appropriate token is already held.
 
     This is all ok since people who call these ALWAYS pass in a byte range
     argument of NULL ... causing them to grab a token for the entire file.
     In the interest of safety, it might be safer to explicitly ignore the
     byte range argument passed in instead of half using it:  using it to
     actually grab a token ... but ignoring it in tkc_HaveTokens().
Filled in Interest List CC with `kazar@transarc.com, cfe@transarc.com' 
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'

[1/20/94 public]
I just did a little code reading in the tkc layer, and it looks
like tkc_PutLocks(vp, byteRangep) will do what you want.  It seems
to check the process id against the tlp->procid and therefore only
releases tokens over the range which are held by the calling process.
So tokens held by other local processes should not be affected.
At least thats the way it looks to me.  So the resulting bug fix would
like something like:
xvfs_osglue.c:
.
.
.
        code = VOPN_LOCKCTL(vp, lckdat, cmd, cred, fp, LB, UB);
	if (code)
	    tkc_PutLocks(vp, &byteRange);
    }
lckerr:
    xvfs_PutVolume(volp);
    AFSLOG(XGLUE_DEBUG, 1, ("END xglue_lockctl (code %d)\n", code));
    return (code);
}
I think this is what Daryl tried above.  Given the way tkc_PutLocks() works,
I do not believe tkc_PutLockExact() is needed. What do you think Daryl?

[1/20/94 public]
Actually there is a scenario where using tkc_PutLocks fails.
proc 1 gets lock on 0-1000
proc 2 gets lock on 1500-2000
proc 2 trys lock on 1-2000 and fails.
    tkc_Putlocks would return all tokens over 0-2000 for proc2
    including the one for the successful 1500-2000. NOT good.
    So it looks like some work is required.

[3/4/94 public]
Daryl at HP plans to fix this.

[3/14/94 public]
Filled in Reported by Company's Ref. Number with `5002' 
Filled in Transarc Herder with `andi' 
Filled in Transarc Status with `open'

[4/11/94 public]
First a minor correction:  the "Reported by Company's Ref. Number" (5002) is
actually Transarc's ref. number, not HP's.
The way the CM solves this problem is to keep the tokens, but to return them
if asked politely.  For instance, in Carl's example:
   proc 1 gets lock on 1-1000
   proc 2 gets lock on 1500-2000
   proc 2 tries lock on 1-2000 and fails
The client would be left with a lock token for 1-2000.  Another client
trying to get a lock for 1100-1400 would cause a revoke request, and the CM
would look at its lock database and agree to return the token.
Perhaps the tkc should do something similar.  It doesn't have its own lock
database to look at; instead it could call VOP_LOCKCTL (...F_GETLK...).
Changed Interest List CC from `kazar@transarc.com, cfe@transarc.com' to 
 `kazar@transarc.com, cfe@transarc.com, bwl@transarc.com'

[4/13/94 public]
It should be noted that the implementation of F_GETLK has the same problem,
i.e. we get a token and then never give it back.
.
I am working on a solution based on the idea I outlined above, revocable
lock tokens.



CR Number                     : 9673
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : window for races in vnvm_truncate
Reported Date                 : 1/3/94
Found in Baseline             : 1.0.3a
Found Date                    : 1/3/94
Severity                      : C
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[1/3/94 public]
vnvm_truncate calls vms_iowait with the vnode unlocked.  The reason it drops
the lock is so that the strategy daemon can pick it up when processing the
I/O requests.  The problem is that when vnvm_truncate tries to re-obtain the
lock, it may go to sleep, and while it is sleeping, pages of VM in the
indicated range may be created (e.g. by page faults).  Thus we could end up
with a file that has been truncated to length L, and pages of VM representing
bytes of the file far beyond L.
.
The basic problem is overloading of the vnode lock.  It is necessary for the
locking structure to be such that, while the vms_iowait is in progress,
activity that would create new VM pages in the indicated range is blocked,
while the processing of pageout requests that were in progress can complete.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[1/6/94 public]
Defer'ing to 1.1.  Here's an e-mail from Bruce with more info.

> From: Bruce_Leverett@transarc.com
> To: rsarbo@osf.org
> Subject: Re: OT9673
> Cc:
> In-Reply-To: <9401061855.AA06718@kenmore.osf.org.osf.org>
> References: <9401061855.AA06718@kenmore.osf.org.osf.org>
> Status: R
> 
> Let me clarify what the symptoms would be.  Suppose that one process mmap'ed
> a file and started accessing memory, so that gradually all the file's data
> would be in VM.  Now another process truncates the file.  The truncation is
> supposed to invalidate some of the pages of VM, so that if the first process
> tries to access memory that is mapped beyond EOF, it gets a SIGBUS signal.
> It does--generally this works fine.  But there is a race, and if the truncating
> process is invalidating some page while the mapping process is accessing it,
> the page might just stay around after the truncation, so that the mapping
> process will get old data rather than a SIGBUS signal.
> 
> It's not a memory leak (VM will be discarded when the memory is unmapped
> anyhow) or any other kind of resource leak.  I don't think it can lead to a
> crash or corruption of the file system.  We have never actually seen this
> race; I found it by reading the code (actually I should say re-reading it,
> since I wrote that code in the first place).  To fix it, it would be necessary
> to designate some new bit in the vnode flags word, and to use that bit in
> wait/proceed decisions similarly to how we currently use VD_ALLOWSTRAT.  That
> is what I meant by changing the "locking structure".  This is a non-trivial
> change.  All these factors strongly suggest deferring.



CR Number                     : 9648
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Wrong error codes for some Episode ops
Reported Date                 : 12/23/93
Found in Baseline             : 1.0.3a
Found Date                    : 12/23/93
Severity                      : C
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[12/23/93 public]
VOP_REMOVE should return EPERM, not EISDIR, if non-root attempts to unlink
a directory.
VOP_LINK should return EPERM, not EISDIR, if non-root attempts to hard-link
a directory.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[12/29/93 public]
defer to 1.1.  this is a candidate for the 1.0.3a unintegrated
tree



CR Number                     : 9618
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : assertion failure in test_anode in HandleLogFull
Reported Date                 : 12/15/93
Found in Baseline             : 1.0.3a
Found Date                    : 12/15/93
Severity                      : C
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2
Affected File(s)              : file/episode/logbuf/log.c,tran.c
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[12/15/93 public]
Not the same assertion as OT CR 9612.  The tail of the log of running test_anode
on all_tests is:
Running with debugging on 0x0, 0x0 (test), 0x0 (verify), 0x0 (async), 0x80 (logbuf) 0x0 (osi); 0x0 (tr_global).
Running test multi-block-frag from file multi-block-frag.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Test multi-block-frag completed successfully
1465.45u 298.58s 1:10:56 41% 527+2066k 0+0io 64534pf+0w
assertion failed: line 4214, file /project/dce/build/dce1.0.3a-snap/src/file/episode/logbuf/buffer.c
Running with debugging on 0x0, 0x0 (test), 0x0 (verify), 0x0 (async), 0x80 (logbuf) 0x0 (osi); 0x0 (tr_global).
Running test buffer-deadlock from file buffer-deadlock.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Abort process (core dumped)
23.29u 2.49s 0:41 62% 599+2199k 0+0io 97pf+0w
Note that we passed multi-block-frag although we haven't fixed 9612, indicating
that 9612 is not reliably reproducible.
The assertion is at the end of function HandleLogFull:
      /* Signal the transaction system to cleanup ended transactions. */
      elbt_GCTran(dP, /*force*/1);
      if (!action) {
4214:     afsl_Assert (wait == 2);
      }
      return (action != 0);
}
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[12/15/93 public]
This bug is not reliably reproducible, due to thread scheduling variability.
Filled in Reported by Company's Ref. Number with `4745'

[12/16/93 public]
Changed to priority 1 since all functional tests must pass for 1.0.3a release.

[12/16/93 public]
Changing fixby to 1.1.  Dropping priority after discussion w/
Transarc since this problem only shows up in the user-level 
emulation environment and cannot be reproduced using any known 
combination of tests "in the real world" :^>.

[2/16/96]
Fix submitted as part of the 1.2.1 code drop.



CR Number                     : 9613
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : ftserver
Short Description             : ftserver can't recover from pipe exception during move
Reported Date                 : 12/14/93
Found in Baseline             : 1.0.3a
Found Date                    : 12/14/93
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public

[12/14/93 public]
 
We set up an active fileset to move between an HPUX server and a RIOS server.
During the course of one of the moves, the ftserver on the HPUX
got a rpc pipe exception during the SFTSERVER_Restore operation.
Since then, we have be unable to move the fileset onto the HPUX
machine (No, retrying the move does not fix the problem.)  There
seems to be a trasaction on the HPUX ftserver's queue which is
"stuck".
Here's the error we get:
move from alcatraz to explorer
fts_DeleteVolume: 0,,18772 is unattachable (code 382312470).
fts_DeleteVolume: 0,,18573 is unattachable (code 691089523).
Error in move: communications failure (dce / rpc)
move failed date
move from alcatraz to explorer
Cannot check for an existing target fileset 0,,18573 on explorer.osf.org/epi1: copy the
 clone to a new location (dfs / xvl)
Error in move: copy the clone to a new location (dfs / xvl)
Fileset lives on:
gypsy.ft
        readWrite   ID 0,,18573  valid
        readOnly    ID 0,,18574  invalid
        backup      ID 0,,18575  invalid
number of sites: 1
   server           flags     aggr   siteAge principal      owner
alcatraz.osf.org    RW       epi1    0:00:00 hosts/alcatraz <nil> 
statft -server explorerer
Total transactions: 1
--------------------------------------
trans: 998  created: Tue Dec 14 09:46:20 1993
descriptor: 0; ref count 1;  last call: Tue Dec 14 09:51:29 1993
fileset: 0,,18573  aggregate Id: 1   aggrtype: 2/1
action: copy the clone to a new location (dfs / xvl); ops: Restore, SetFlags, GetStatus, SetStatus
Fileset status 0x12810015: R/W, busy, delOnSalvage, move-target, zap-me, type-RW; transDeleted
--------------------------------------
# fts statft -server alcatraz
No active transactions on alcatraz
#
Seems we got a pipe exception and can't recover:
 
1993-Dec-14 09:46:13 Creating fileset gypsy.ft (0,,18573) on aggr 1
1993-Dec-14 09:46:13 Failed to open 1:0,,18573, code = 572833799 (Fileset does not exist (dfs / ftu))
1993-Dec-14 09:46:13 ftserver_CreateVolume: created gypsy.ft as 0,,18573 on aggr 1
1993-Dec-14 09:46:23 Restoring fileset 0,,18573/1
1993-Dec-14 09:46:23 Restoring 1:gypsy.ft (0,,18573)
1993-Dec-14 09:49:22 SFTSERVER_Restore: Exception while restore-terminating: (rpc_x_ss_pipe_comm_error) exceptio
n raised
1993-Dec-14 09:54:47 trans 40602068 (Id=998, 0,,18573/1) is 198 seconds old (ref count 1)
1993-Dec-14 09:54:47 (trans 40602068: desc=0, time=755880689, ctime=755880380, states=0x12810015, accs=0x1c4, ac
ce=691089523)
1993-Dec-14 09:55:17 trans 40602068 (Id=998, 0,,18573/1) is 228 seconds old (ref count 1)
1993-Dec-14 09:55:17 (trans 40602068: desc=0, time=755880689, ctime=755880380, states=0x12810015, accs=0x1c4, ac
ce=691089523)
There are many more lines of like this.
The tail end of the FtLog on explorere:
 
993-Dec-14 10:55:19 trans 40602068 (Id=998, 0,,18573/1) is 3830 seconds old (ref count 1)
1993-Dec-14 10:55:19 (trans 40602068: desc=0, time=755880689, ctime=755880380, states=0x12810015, accs=0x1c4, ac
ce=691089523)
1993-Dec-14 10:55:50 trans 40602068 (Id=998, 0,,18573/1) is 3861 seconds old (ref count 1)
1993-Dec-14 10:55:50 (trans 40602068: desc=0, time=755880689, ctime=755880380, states=0x12810015, accs=0x1c4, ac
ce=691089523)
1993-Dec-14 10:56:20 trans 40602068 (Id=998, 0,,18573/1) is 3891 seconds old (ref count 1)
1993-Dec-14 10:56:20 (trans 40602068: desc=0, time=755880689, ctime=755880380, states=0x12810015, accs=0x1c4, ac
ce=691089523)
1993-Dec-14 10:56:50 trans 40602068 (Id=998, 0,,18573/1) is 3921 seconds old (ref count 1)
1993-Dec-14 10:56:50 (trans 40602068: desc=0, time=755880689, ctime=755880380, states=0x12810015, accs=0x1c4, ac
ce=691089523)
1993-Dec-14 10:57:20 trans 40602068 (Id=998, 0,,18573/1) is 3951 seconds old (ref count 1)
1993-Dec-14 10:57:20 (trans 40602068: desc=0, time=755880689, ctime=755880380, states=0x12810015, accs=0x1c4, ac
ce=691089523)
1993-Dec-14 10:57:50 trans 40602068 (Id=998, 0,,18573/1) is 3981 seconds old (ref count 1)
1993-Dec-14 10:57:50 (trans 40602068: desc=0, time=755880689, ctime=755880380, states=0x12810015, accs=0x1c4, ac
ce=691089523)
1993-Dec-14 10:58:20 trans 40602068 (Id=998, 0,,18573/1) is 4011 seconds old (ref count 1)
1993-Dec-14 10:58:20 (trans 40602068: desc=0, time=755880689, ctime=755880380, states=0x12810015, accs=0x1c4, ac
ce=691089523)
Setup:
 
  1 fileset with connectathon.  Two clients from different machines
  run connectathon while fileset moves every 5 minutes between a RIOS
  server and an HPUX server.  The fileset also has a large
  file on it (don't know if that makes a difference) and its size is
  10315952 bytes;

[12/16/93 public]
This is a serious problem BUT we've made the decision to defer the
fix to 1.1 for now and add a release note for 1.0.3a. If this problem
occurs under more common testing/usage circumstances, we may have to
reconsider.



CR Number                     : 9612
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : EPISODE
Short Description             : Buffer unexpectedly held in elbb_Shutdown
Reported Date                 : 12/14/93
Found in Baseline             : 1.0.3a
Found Date                    : 12/14/93
Severity                      : C
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : ?
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[12/14/93 public]
The last lines of the log file running all_tests are as follows:
.
assertion failed: line 2603, file /project/dce/build/dce1.0.3a-snap/src/file/episode/logbuf/buffer.c
Running with debugging on 0x0, 0x0 (test), 0x0 (verify), 0x0 (async), 0x80 (logbuf) 0x0 (osi); 0x0 (tr_global).
Running test buffer-deadlock from file buffer-deadlock.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Abort process (core dumped)
81.88u 7.26s 1:46 83% 613+2550k 0+0io 101pf+0w
.
The reason the assertion failure message comes before the output is that stderr
and stdout do not get flushed to the log file at the same time.
.
Line 2603 in buffer.c is in function elbb_Shutdown.  Here it is:
.
	   * we now walk the chain of buffers for this buffer block.  When
	   * we find a device field match we always remove it from the
	   * address hash and then:
	   *
	   *   (1) we schedule the buffer for write; or
	   *   (2) we mark the buffer as killed.
	   */
	  for (bP = (struct buffer *)FIFO_LookAtOldest(&bbP->buffers,
				offsetof(struct buffer, blockThread));
	       bP;
	       bP = (struct buffer *)FIFO_NextOldest(&bbP->buffers, bP,
						     &bP->blockThread)) {
	      if (bP->adev != dP)
		  continue; /* move on */
.
	      /*
	       * since we've started shutting down, we afsl_Assert that
	       * there are no active references for this buffer.
	       */
2603:	      afsl_Assert (bP->refCount == 0);
.
	      /*
	       * remove from address hash; zero field.
	       */
	      (void) epih_HashOut(&addrHashTable, (epih_hashEntry_t)bP);
	      bP->addrHashNext = (struct buffer *)0;
.
	      /*
	       * if the fh is set (magic #) we clear it
	       * and remove this entry from the hash table.
	       */
	      SetFHLocked(bP, 0);
.
	      /*
	       * if it is dirty, schedule it for write.  Remove it from
	       * the free list for the pool.
	       */
	      if (bufferIsDirty(bP)) {
		  if (!bufferIsWritep(bP)) {
		      /*
		       * we have turned off the log, so now we must
		       * "unlog" this buffer.
		       * XXX: this is probably wrong, why not shut
		       * down the log *after* writing? - wam 080791
		       */
		      bufferClearLogged(bP);
		      retval = Write(bP);
		      afsl_MBZ(retval);
		  } /* !bufferIsWritep */
		  RemoveFromFreeList(bpeP, bP);
		  retval = asevent_AddToSet(aset, bP->aevent);
		  afsl_MBZ(retval);
	      } /* bufferIsDirty */
	      else {
		  retval = elbb_SetKilled(bP);
		  afsl_MBZ(retval);
		  afsl_Assert(!bufferIsInuse(bP));
		  bufferClearDelete(bP);
		  bP->delTran = elbt_NullTranId;
	      }
	  } /* for (buffers) */
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[12/14/93 public]
I believe the assertion is incorrect because another thread could be
pulling buffers out of this pool and writing dirty buffers in the
process.  We hold dirty buffers while waiting for thiem so Shutdown may
see these transiently held buffers.  On the other hand I imagine the
code depends on the buffers being unused, so just removing the assert
isn't the appropriate fix.
I've been looking for an excuse to rewrite shutdown (it is riddled with
small problems like this) so maybe this is it!
Filled in Interest List CC with `ota'

[12/15/93 public]
This bug is not reliably reproducible, due to thread scheduling variability.

[12/16/93 public]
Priority changed to 1 since all functional tests must pass for 1.0.3a release.

[12/16/93 public]
Changing fixby to 1.1.  Dropping priority since this problem only 
shows up under high load in the user-level emulation environment
and has not been reproduced even under high load in the "real 
world" :^>.

[1/28/94 public]
I just realized that fixing shutdown is really easy!  All I have to do
is call elbb_QuiesceSystem at full power at the very beginning of
shutdown.  Quiesce has already been rewritten to do all this writing and
waiting safely.  When it returns then everything should be cleaned out
and stay that way (if shutdown is really being called correctly).
Shutdown can then safely assert that all the buffers are clean and
unreferenced.
Changed Interest List CC from `ota' to `ota,rajesh'

[2/10/94 public]
Unfortunately, it is not quite as rosy as I describe above.  Another
thread can get stuck for an indeterminate time, at least in principle,
with a held buffer in WaitForWrite.  So we need to explicitly wait for
these held buffers to be released.  There is code at the end of
GetMoreBufferSpace which does just this.
Changed Short Description from `assertion failure during test_anode on RIOS' to 
 `Buffer unexpectedly held in elbb_Shutdown'

[3/24/94 public]
Opening in Transarc's DB as 5242 for fixing.  The delta name will be:
    ota-db5242-fix-shutdown-buffer-refCount-assert
Changed Subcomponent Name from `lfs' to `EPISODE' 
Filled in Reported by Company's Ref. Number with `5242'



CR Number                     : 9602
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : px
Short Description             : stale data in CM for backup filesets
Reported Date                 : 12/8/93
Found in Baseline             : 1.0.2a
Found Date                    : 12/8/93
Severity                      : C
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : ?
Sensitivity                   : public
Transarc Deltas               : bwl-ot9602-sync-info-for-backup-filesets
Transarc Herder               : jaffe@transarc.com
Transarc Status               : export

[12/8/93 public]
There is no way to tell the CM that a backup fileset has been changed
(i.e. by a reclone), if the RW version happens to be lazily replicated.
For instance, after the following sequence:
  fts create bwl                     ; create fileset
  fts setrepinfo bwl -scheduled      ; make it lazily replicated
  fts crmount bwl bwl                ; create junction for it
  <create and edit> bwl/foo          ; create and edit a file in it
  fts clone bwl                      ; create a backup fileset
  fts crmount bwl.backup bwl.backup  ; create junction for backup
  more bwl.backup/foo                ; get backup version of file into cache
  <edit> bwl/foo                     ; put new data in rw version of file
  fts clone bwl                      ; reclone
  fts checkfilesets                  ; tell CM to update cache
  more bwl.backup/foo                ; look at backup version of file
At this point bwl.backup/foo should contain the new data, but instead it has
the old data.  This incorrect behavior only happens if the rw fileset is
lazily replicated; for non-replicated filesets, the new data are propagated
correctly.
The problem seems to be that px_SetSync in px/px_subr.c does not recognize
backup volumes.  It mistakes them for incomplete replicas.  Therefore it
sends a zero VV to the client, and cm_CheckVolSync in the cache manager takes
this as a signal to bail out.
This was reported and diagnosed by Daryl Kinney at HP.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[12/20/93 public]
Defect Closure Form
-------------------
--Verification procedure below--
The verification procedure is given above.
Associated information:
Tested on TA build:  
dfs-osf-1.12
Tested with backing build:  
dce1.0.3ab1
Filled in Transarc Deltas with `bwl-ot9602-sync-info-for-backup-filesets' 
Changed Transarc Status from `open' to `export'



CR Number                     : 8175
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : cm
Short Description             : rpc binding has nil object uuid
Reported Date                 : 6/18/93
Found in Baseline             : 1.0.2a
Found Date                    : 6/18/93
Severity                      : C
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : ?
Sensitivity                   : public

[6/18/93 public]
We have seen this twice during two days of cho, and always on machine 1:
 
dfs: rpc binding to server 130.105.5.3 in cell leprosy has a nil object uuid!
We will attempt to collect more data on this, but for now that's all we
have.

[7/7/93 public]
We've been unable to reproduce this.  Moving to fixby 1.0.3.

[8/3/93 public]
Cancelling since there's no useful information to be retained 
here.  If it happens again, we'll open another bug.

[10/05/93 public]
 
Well we've now seen it during 1.0.3 cho from rios client
with HPUX server.
 
# kinit -l96h
Enter password:
# kldfs: rpc binding to server 130.105.5.58 in cell headache.qadce.oisf.org has a nil o
bject uuid!
st
 
I really don't know if the kinit has anything to do with this, but right
after I issued kinit the message poped up on the screen.

[10/08/93 public]
 
Aged relative to Aug 1.

[11/09/93 public]
Re-assigning to Jaffe since the fix is in Pittsburgh and we
need to get it here.

[2/09/96 public]
If the fix was in Pittsburgh on 11/09/93, then it is in DCE 1.2.1.
We have not seen this type of problems in our CHO testing for DFS 1.2.1.



CR Number                     : 7712
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : sec
Subcomponent Name             : kdestroy
Short Description             : kdestroy should not remove machine context without force option
Reported Date                 : 4/13/93
Found in Baseline             : 1.0.2b22
Found Date                    : 4/13/93
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : security/krb5/clients/kdestroy/kdestroy.c
Sensitivity                   : public

[4/13/93 public]
Given that kdestroy can be run in a script by root, it would be possible for a 
machine administrator on a CDS or DTS server to damage the cell by mistake.  It
would be good to disallow kdestroy of a machine context, unless a -f option were
given.

[4/30/96 public]

Fixed in DCE 1.2.1. In order to kdestroy the machine credentials, the -c
option must be used. Ex: 
	kdestroy -c FILE:/opt/dcelocal/var/security/creds/dcecred_ffffffff



CR Number                     : 7024
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : endpoint mapper
Short Description             : UDP binding info disappears under stress
Reported Date                 : 1/26/93
Found in Baseline             : 1.0.2b10
Found Date                    : 1/26/93
Severity                      : D
Priority                      : 3
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : admin/dced/server/oeops.c
Sensitivity                   : public

[mhickey 1/26/93 public] 
  While running the rpc.sec.2 system test, the UDP binding in the
endpoint map disappears during the run.  The information usually
disappears in the first couple of hours of the run.

  If this is really an RPC  stress related issue, then it is a serious
problem, hence the high priority assigned.

  Configuration:

       Cell:   1 PMAX (dce3) 
                   SEC and CDS server
               1 RIOS (soldier)
                   DCE client

       Test:   4 TCP and 1 UDP clients on PMAX (dce3)
               1 TCP and 3 UDP clients on RIOS (soldier)
               test server is running on PMAX (dce3)

               For security stress, maximum ticket lifetime 
               is 5 minutes, and all clients and the server
               were refreshing their id's at 4 minute intervals.

               For RPC stress, all calls are fully authenticated
               (ie: protection level is pkt_level_privacy).

  I can provide logs on request, they are a bit much for the 
  defect report.

[2/1/93 public]

It is possible that what you are seeing is rpcd deleting the  endpoints
because it unsuccessfully pings the server the endpoint belongs to.
The slive1 & s slive2 threads  call rpc_mgmt_is_server_listening about 5
times (the first with a short com timeout) and if the server does not
respond t, that endpoint gets removed from the map.  Under stress, we have
seen this happen on a regular basis (apparently the server's call queue
gets backed up and  the ping packets get dropped like any other rpc's,
that is they are not out-of-band or anything exotic like that).  Our
creative solution was to double the total number of tries to 10 and  set
the com timeout for the last nine to 60 seconds.  Because a single thread,
slive2, does the final 9 pings, and spends alot of time waiting for 
the com timeouts to occur, a few crashed servers render "stale endpoint
deletion" feature ofof rpcd rather  non-real time.  If you discover this
(rpcd deleting the endpoints) to be your problem, you may find yourself
digressing into a nasty architectural debate pretty quickly.  I'd be
happy to share our thoughts on the issue as a 1.1 sort of enhancement.
For the time being, you might try the longer timeout.

I apologize for textual errors.  I'm trying toedit this over the internet
since DCEnet is down.

[2/3/93 public]

This does appear to be a case of the rpcd pulling the entry out of the 
endpoint map when it is not able to make the is_server_listening call to
the server.  Mark Hickey informs me that he is seeing failures from the
clients also, so it's not too suprising that the rpcd would not be able
to reach the server.

I think the 'real' solution to this problem would be to make rpcd find
some other way of determining if a server is still alive, since it is *not*
the case that it will always be able to make an rpc to an overloaded 
server.  (Imagine a server with 1 call executor thread, running calls that
take 30 minutes to finish.)   There are several ways to do this, none of 
them simple.

In the meantime, I think the work-around Scott describes is sufficient.
Except that rather than making 9 calls with 60 second timeouts, I think
it would be better to make 20 calls with the normal  30 second timeout.
Spacing the calls over a longer period of time will increase the chances
that any one call will get through.

[2/10/93 public]

I've submitted the work-around/fix described above.  However, I still have 
reservations about the assumptions rpcd is making in regard to its ability to reach
servers.  If we want to make this a safe assumption, then we need to make some
provision for giving priority to these is_server_listening calls (and possiby
all of the mgmt operations).  Currently, I think the best solution would be
to have the runtime create a private thread pool (with 1 thread) for handling
the mgmt interface.

On the other hand, creating a private thread pool may be too heavy-handed for
this problem.  For now, I'm changing this CR to an enhancement because it
probably deserves more thought before actually closing it.

[8/27/93 public]

The current plan is for the dced to maintain server process IDs.  If this
is the case, the dced should use this information for deciding whether
servers are still alive, rather than trying to actually call them.

[2/8/96 public]

dced now listens to the ICMP port unreachable message. It removes a DG
endpoint only if it receives this message. Also, it does not remove a CN
endpoint if the server is too busy or TCP/IP listen backlog is full.



CR Number                     : 6771
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : security/client/login
Short Description             : cred caches grow forever
Reported Date                 : 1/8/93
Found in Baseline             : 1.0.2
Found Date                    : 1/8/93
Severity                      : D
Priority                      : 4
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : security/krb5/lib/ccache/file/fcc_nseq.c,fcc_read.c,fcc_retrv.c,fcc_store.c,fcc_write.c
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[1/8/93 public]
  Long-running servers generate credential caches which are
artificially large: they contain a large number of expired tickets.
These expired tickets could be collapsed out of the credential cache
at intervals, perhaps during sec_login_refresh_identity(). Currently
the servers have no way of cleaning these files.

Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[4/30/96 public]

Fixed in DCE 1.2.1. Expired ticket slots in credential cache files
are now reused if the new ticket is the same size as the expired one.



CR Number                     : 5750
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : sec
Subcomponent Name             : 
Short Description             : UHYP:"Registry sever unavailable (dce /sec)" masks real cause of error
Reported Date                 : 10/21/92
Found in Baseline             : 1.0.2
Found Date                    : 10/21/92
Severity                      : C
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : security/client/rca/internal_binding.c, security/idl/sec.sams
Sensitivity                   : public

[10/21/92 public]

The "Registry server unavailable (dce / sec)" is a very widely seen
error (because the actual error code has been masked). Unfortunately 
this gives absolutely no indication whatsoever as to what the real 
cause of the problem is and hence there is no clue as to how to 
proceed/debug. A real error should be returned instead. 

A frequently used workaround is to set the environment variable 
DEBUG_SEC (to 1 or 5). This is acceptable where the problem is 
readily reproducable. However turning on DEBUG_SEC is not a 
feasible solution when this error occurs after many hours of 
testing (OT 5611 is an example of this). Also this is not a documented
feature so many people may be unaware of it.

The following is a list of OT reports where this error was seen 
or the question was asked  "What does this mean ? How can we proceed ?"

   OT reports: 5684, 5611, 5498, 4911, 4735, 5041

I have been asked the same question often here at OSF. In terms of 
priority , I consider this higher in priority than most of the 1's 
except for perhaps OT 5374.

[ pato 10/22/92 public]

I've marked this "defer" (sekhar's comments above notwithstanding).
We believe that the right way to handle this is to add a 
sec_rgy_inq_error function to obtain the underlying cause of the 
failure.  There are many reasons why an operation to a security server
might fail - but many of these will be invisible to the application
once replication is in place (i.e., most failures will not actually
occur since the client code will automatically rebind to a different
server).  In this environment we expect to store the first error that
forced a rebind, but then continue rebinding until no more alternatives
are available.

[10/26/92 public]

Status changed back to open.

Reason: This defect as well as several other enhancements raise the
a general issue of the importance of better error handling (this 
applies not only to security but to other components - in my opinion).
I would like to raise this as an issue here at OSF for review and 
get answers to questions such as : what priority should be given
to better error handling and what release should these be fixed
in 1.0.2, 1.0.3 or 1.1 ? 

Also Joe what was the reason for deferring this ? Could you please update
this OT report with that info ? 

I would like to keep this OT report open until I have answers to my 
questions.

[11/19/92 public]

The reason for deferring this bug is that to fix it the way Joe suggests
(by adding a mechanism for finding out the real error message underneath
the generic server unavailable message), is adding new functionality that 
will take some real amount of time to implement.  We believe that 
this is the correct approach and are happy to add this functionality, but
given the 1.0.2 schedule, we don't believe it feasible for this release.
As far as what release we should get this fixed in, that's for the OSF
to decide.
the OSF to decide
this fixed in, that's your call.

[12/3/92 public]

Changed the status to defer (because of lack of time to implement in 1.0.2)
In my opinion this should be fixed in 1.0.3.

[12/3/92 public]
Just wanted to add one more note to the readers of this OT. The decision to
defer the defect (because of lack of time to fix this in 1.0.2 release) was
agreed upon in the weekly tech conference call two weeks ago (Brad and 
Dave Lounsbury were at this meeting). That this should be fixed in 1.0.3 is
my recommendation.

[9/2/93 public]
Sekhar - now that you own this bug :), you might want to defer it to 1.1,
since it is part of the planned serviceability work you're doing there.

[7/13/94 public]

years in the making.... Any update on this?  Can we close or defer to 1.2?

[7/13/94 public]
No, this needs (& is yet) to be addressed in 1.1 serviceability.

[ sekhar 10/5/94 public ]

Bumped priority back to 1 to indicate that we are tentatively planning
this for the unintegrated tree. The fix will be to log SVC messages 
(lower risk) and not what is outlined in the OT .

[10/12/94 public]

Removed from unintegrated list until fix is known and can be evaluated.
Leaving at priority 0 so it stays on the list...

[ sekhar 10/13/94 public ]

The fix simply logs the actual error status before it is mapped to 
the Registry Server Unavailable.

The files which will change are internal_binding.c (about 10 lines) 
and sec.sams - for 5 new messages logged by the binding code . These 
messages are not returned as status codes by the security API. 

The fix is really useful because it will give more information about
why a registry server was unavailable.

The fix in more detail :

   Informational messages (severity level NOTICE) will be logged on
   binding failure , attempts to rebind and the success/failure of rebinding.

   The following is an example

   rgy_edit>
   Current site is: registry server at /.../cell_svc/subsys/dce/sec/master
   rgy_edit=> do p
   rgy_edit=> v
   1994-09-19-12:21:11.855-04:00I----- rgy_edit NOTICE sec rgybind internal_binding.c 2891 0x7aff3d80
   Registry operation failed ( /.../cell_svc/subsys/dce/sec/master ) : Communications failure
   1994-09-19-12:21:11.858-04:00I----- rgy_edit NOTICE sec rgybind internal_binding.c 1670 0x7aff3d80
   Attempting to rebind to an alternate registry site and retrying operation
   1994-09-19-12:21:11.873-04:00I----- rgy_edit NOTICE sec rgybind internal_binding.c 1672 0x7aff3d80
   Rebound to site /.../cell_svc/subsys/dce/sec/hot_joe
   nobody [nogroup none]:*:-2:-2::/::
   root [system none]:*:0:0::/::
   .....
   rgy_edit=>


   If the rebind fails , then instead of

     "Rebound to site /.../cell_svc/subsys/dce/sec/hot_joe"

   the message

     1994-09-19-13:26:37.783-04:00I----- rgy_edit NOTICE sec rgybind internal_binding.c 1672 0x7aff3d80
     Failed to rebind to an alternate registry to retry operation

   would be logged.

   The above sequence may be repeated up to 5 ( RETRY_LIMIT defined in
   rca_pvt.h - the no of times an operation is retried ).

   NOTES:
   a. The NOTICE messages are logged according as per the current routing
      which is in effect.
   b. The NOTICE messages log the program name as part of the message -
      provided the client has called the function dce_svc_set_progname() .

      All the current security clients such as rgy_edit , sec_admin do
      call dce_svc_set_progname() ( since day the first SVC code drop ).

      So when all SVC messages are being logged to the same file, there
      is no problem is distinguishing the origin of the Registry Server
      Unavailable SVC messages from different clients.

      However, if dce_svc_set_progname() is not called by a client, then
      the PID is logged instead of the program name.
   c. Side effects/gotchas :

      Until a security server is configured, these messages would be logged.
      For e.g. dced would like something like :

         1994-09-16-16:32:33.822-04:00I----- dced NOTICE sec rgybind internal_binding.c 2512 0x40023c20Registry
operation failed (  ) : Invalid network address

      In such a case, these errors should be ignored.

[ sekhar 10/17/94 public ]

Fixed.



