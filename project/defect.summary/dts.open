CR Number                     : 13443
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : admin_gd
Short Description             : dts modify and clock set examples are wrong
Reported Date                 : 4/22/96
Found in Baseline             : 1.2.1
Found Date                    : 4/22/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : admin_gd/dts/dts/3_managing_dts.gpsml
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : open

[4/22/96 public]
On page 25-19 of the Admin Guide-Core, the example:
	dts modify /.:/hosts -change {checkinterval 00-00:00:30.000]
is incorrect.  Instead of /.:/hosts, it should say,
/.:/hosts/<hostname>/dts-entity.  Also, the delimiters around the
checkinterval attribute should match.
On pages 25-20 and 25-21 of the Admin Guide-Core, the clock set
examples should use the -to switch, as in:
	clock set -to <timestamp>
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `open'

[5/16/96 public]

Assigned to HP. I could be wrong about this; if so, just assign it
back to me.



CR Number                     : 13272
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dts
Subcomponent Name             : 
Short Description             : test_dtscp-server test fails
Reported Date                 : 12/29/95
Found in Baseline             : 1.2.1
Found Date                    : 12/29/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[12/29/95 public]

Found when running DCE 1.2.1 functional tests on AIX 3.2.

From the dtscp_tet.log/journal file:
520|0 1 20649 1 7|Expected output is in file /tmp/test_dtscp_server.exp
520|0 1 20649 1 8|Differences between the two are in file /tmp/test_dtscp.diff
520|0 1 20649 1 9|Compare actual output to expected output
520|0 1 20649 1 10|ERROR: Actual output does not match expected output

Comparing the expected vs. actual files shows that the difference is 
caused by the following -

Expected:
   dtscp show acting courier role
   Acting Courier Role       = Courier
Actual:
   dtscp show acting courier role
   Acting Courier Role       = NonCourier



CR Number                     : 13136
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : 
Short Description             : fails functional test zonecvt, dtsdate
Reported Date                 : 10/3/95
Found in Baseline             : 1.2.1
Found Date                    : 09/22/95
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/3/95 public]



CR Number                     : 12861
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12862
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : dtsd
Short Description             : dtsd frees memory that the rpc runtime has already free'd.
Reported Date                 : 5/4/95
Found in Baseline             : 1.1
Found Date                    : 5/04/95
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : dtss_service_global_set.c
Sensitivity                   : public

[5/10/95 public]

In dtss_service_global_set.c, when the dts server is unable to call 
rpc_mgmt_inq_server_princ_name(), it free's the variable serverPrincName.
The rpc runtime already does this if the call fails.  This is undocumented
in the rpc_mgmt_inq_server_princ_name() manpage.

Repeat By:

        Run dtsd in 'bad' conditions so rpc_mgmt_inq_server_princ_name fails
and notice a bad free.

Proposed Solution:

The rpc_mgmt_inq_server_princ_name() man page should document the
fact that the server_pric_name argument does not need to be free'd
if an error occurrs.

Code in src/time/service/dtss_service_global_set.c should be changed:

*** /animal/build/dce1.1/src/time/service//dtss_service_global_set.c	Tue Dec 13 11:24:05 1994
--- dtss_service_global_set.c	Thu May  4 15:04:50 1995
***************
*** 8,20 ****
  /*
   * HISTORY
   * $Log:	c012861,v $
# Revision 1.2  95/05/10  11:36:52  root
# changed fields: Inter-dependent CRs  
# 
# Revision 1.1  95/05/10  11:25:21  root
# new CR
# 
!  * Revision 2.1  1994/12/13  16:21:37  devrcs
!  * OSF DCE 1.1 Source
   *
   * Revision 1.1.4.7  1994/08/23  20:32:26  cbrooks
   * 	Code Cleanup Checkpoint
   * 	[1994/08/23  13:57:02  cbrooks]
!  *
   * Revision 1.1.4.6  1994/08/05  20:47:40  cbrooks
   * 	CR11240 - add dced config functionality
   * 	[1994/08/05  20:23:39  cbrooks]
--- 8,24 ----
  /*
   * HISTORY
   * $Log:	c012861,v $
# Revision 1.2  95/05/10  11:36:52  root
# changed fields: Inter-dependent CRs  
# 
# Revision 1.1  95/05/10  11:25:21  root
# new CR
# 
!  * Revision 2.1.1.2  1995/05/04  19:04:46  tomj
!  * 	Don't free serverPrincName if inq_server_princ_name fails
!  * 	since the runtime does this for us.
   *
+  * Revision 2.1  1994/12/13  16:21:37  devrcs
+  * 	OSF DCE 1.1 Source
+  * 
   * Revision 1.1.4.7  1994/08/23  20:32:26  cbrooks
   * 	Code Cleanup Checkpoint
   * 	[1994/08/23  13:57:02  cbrooks]
!  * 
   * Revision 1.1.4.6  1994/08/05  20:47:40  cbrooks
   * 	CR11240 - add dced config functionality
   * 	[1994/08/05  20:23:39  cbrooks]
***************
*** 480,485 ****
--- 484,490 ----
  		dce_error_string_t tempstring;
  		dce_svc_printf(DTS_S_INQ_SERVER_PRINC_MSG, 
  			       dce_dts_error_text( rpcStatus, tempstring));
+ 		serverPrincName = NULL;		/* runtime frees on error */
  		goto DoNotAdd;
  	    }



CR Number                     : 12472
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : dtsd
Short Description             : Clock was set an ERROR message
Reported Date                 : 10/3/94
Found in Baseline             : 1.1b20
Found Date                    : 10/3/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : dts.sams
Sensitivity                   : public

[10/3/94 public]

Dtsd will print a message like this when it sets the clock:

1994-10-03-13:49:24.936-04:00I5.675 dtsd ERROR dts events logevent_v_ultrix.c 129 0x7affa020
Clock was set: old time = 1994-10-03-13:49:25.221-04:00I5.995, new time = 1994-10-03-13:49:24.896-04:00I5.665

Since setting the clock is not really an error, dtsd should
only report this as (at most) a WARNING, probably just a NOTICE.

The fix is to change the following in dts.sams to svc_c_sev_[warning,notice]:

start
code            dts_s_clockset
text            "Clock was set: old time = %s, new time = %s"
explanation     "The server has set the clock."
action          "None required."
sub-component   dts_s_events
attributes      svc_c_sev_error
		^^^^^^^^^^^^^^^  - change to correct severity
end

This message shows up twice when running the control/test_dtscp.ksh 
test on a clerk machine.



CR Number                     : 12469
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : dtsd
Short Description             : dtsd doesn't export its acl managerwhen server entry name changed
Reported Date                 : 10/3/94
Found in Baseline             : 1.1b20
Found Date                    : 10/3/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/3/94 public]

While running the dtscp tests, dtsd generates error messages to the effect
that it can't unregister its acl manager interfaces.  I believe
the dtscp dts functional test will also see this problem.

The dtscp tests modify the server entry name attribute, calling
the routine UnexportTimeService(), and then calling ExportTServiceToNS().
The unexport routine remove the acl manager interfaces from the endpoint
map however the export routine does not put them back.

This causes an error on shutdown or the next time 
UnexportTimeService is called:

root@tsunami % dcecp -c dts stop

1994-10-03-12:55:14.149-04:00I----- dtsd ERROR dts dtserror mgtacl.c 630 0x7affa020
Couldn't unregister the version 1.0 rdacl interface from the endpoint map: Not registered in endpoint map (dce / rpc)
1994-10-03-12:55:14.168-04:00I----- dtsd ERROR dts dtserror transport_rpc.c 1873 0x7affa020
Failed to unregister dtsd ACL manager interface: Not registered in endpoint map (dce / rpc)


The fix would be to move the export of the acl interfaces to 
ExportTServiceToNS() from DirectiveCreate().

[10/03/94 public]
DTS shouldn't need to export its ACL interface at all, since sec_acl_bind
imports with a NULL interface uuid.

[10/3/94 public]
Perhaps a poor choice of terms, dtsd needs to at least register
its acl manager with the endpoint map, which if you look closely
at the error above, is the real problem.  Right?

[10/03/94 public]
Right.  Sorry for the mis-lead.



CR Number                     : 12458
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : dtsd
Short Description             : serverentry change completes, but with error
Reported Date                 : 9/30/94
Found in Baseline             : 1.1b20
Found Date                    : 9/30/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : dtss_service_ncl.c
Sensitivity                   : public

[9/30/94 public]
The following command returns an error, but changes the serverentry 
attribute anyway

dcecp> dts modify -serverentry foo
Error: No permission for name service operation

dcecp> dts show
[...]
{serverprincipal hosts/ninja/self}
{serverentry foo}
{servergroup subsys/dce/dts-servers}
[[tom 10/3/94 public]
This is caused by the DirectiveSet() code in dtss_service_ncl.c.
The code unexports dtsd's bindings from the name space,
copies the new name in to the global variable, and then tries
to re-export itself to the new name.  If this fails (for instance with no
permissions), it returns this error without exporting again to the old name.

The correct code would probably save the original name, and if the
ExportToNS() call fails, restore the original name and call ExportToNS()
again.  I don't believe there is any other way to check for permissions
before unexporting from the original name.



CR Number                     : 12289
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : dtsdate
Short Description             : dtsdate does unfriendly and uncomplete error reporting
Reported Date                 : 9/21/94
Found in Baseline             : 1.1b16
Found Date                    : 9/21/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/21/94 public]
The dtsdate command prints errors in an unfriendly manor. We all
love serviceability, but a user should never see svc headers.

    % dtsdate -bogus-option
    1994-09-21-19:54:35.016+00:00I----- dtsdate ERROR dts dtsdate dtss_service_main.c 1571 0xa44dc9a8
    Usage: dtsdate [-s] [-q] [-u] hostname [skew-seconds]

    % dtsdate host-not-running-dtsd
    1994-09-21-19:55:40.702+00:00I----- dtsdate ERROR dts dtsdate dtss_service_main.c 1661 0xa44dc9a8
    Couldn't obtain binding to remote time server acme using protocol ncacn_ip_tcp: Not registered in endpoint map (dce / rpc)
    1994-09-21-19:55:40.982+00:00I----- dtsdate ERROR dts dtsdate dtss_service_main.c 1661 0xa44dc9a8
    Couldn't obtain binding to remote time server acme using protocol ncadg_ip_udp: Not registered in endpoint map (dce / rpc)
(yes, printed twice)

    % dtsdate bogus-host-name
does not report an error.  It should.

At least when you get an error, it prints the date (in the svc message)...



CR Number                     : 12241
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : dts
Subcomponent Name             : libutc-user
Short Description             : Inacuracy not adjusted
Reported Date                 : 9/19/94
Found in Baseline             : 1.1
Found Date                    : 9/19/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/19/94 public]

When running the test_kernel test on a platform (such as HPUX)
which uses the user-mode libutc, the following behavior is seen.

Normally (aka on OSF/1 kernel mode implementation) when the clock
is moved forward due to a leap second, the inacuaracy value
of the clock should be increased.  This does not seem to happen
with libutc-user

Sample output of test_kernel on OSF/1:

Setting time forward 1 second
Leap second set to: 1994-09-19 15:58:17.537724000 +/- 0 00:00:00.000000000 (UTC)
1994-09-19 15:58:13.537724
1994-09-19 15:58:13.537724000 +/- 0 00:00:00.011010000 (UTC)
1994-09-19 11:58:13.537724000 +/- 0 00:00:00.011010000 (GMT-4:00 = -14400)
1994-09-19 15:58:16.537724
1994-09-19 15:58:16.537724000 +/- 0 00:00:00.014010000 (UTC)
1994-09-19 11:58:16.537724000 +/- 0 00:00:00.014010000 (GMT-4:00 = -14400)
1994-09-19 15:58:19.537724
1994-09-19 15:58:19.537724000 +/- 0 00:00:01.017010000 (UTC)
1994-09-19 11:58:19.537724000 +/- 0 00:00:01.017010000 (GMT-4:00 = -14400)
1994-09-19 15:58:19.537724


Sample output of test_kernel on HP-UX:

Setting time forward 1 second
Leap second set to: 1994-09-19 15:57:15.575735000 +/- 0 00:00:00.000000000 (EST)
1994-09-19 15:57:11.601575
1994-09-19 15:57:11.601856000 +/- 0 00:00:00.011026200 (EST)
1994-09-19 11:57:11.601856000 +/- 0 00:00:00.011026200 (GMT-4:00 = -14400)
1994-09-19 15:57:14.706471
1994-09-19 15:57:14.706705000 +/- 0 00:00:00.014131000 (EST)
1994-09-19 11:57:14.706705000 +/- 0 00:00:00.014131000 (GMT-4:00 = -14400)
1994-09-19 15:57:17.706478
1994-09-19 15:57:17.706713000 +/- 0 00:00:00.017131000 (EST)
1994-09-19 11:57:17.706713000 +/- 0 00:00:00.017131000 (GMT-4:00 = -14400)
1994-09-19 15:57:17.712891


Notice is the last time stamp, the inacuracy value doesn't get incremented
when the leap second occurs.

This is probably a bug in the user mode code.



CR Number                     : 12082
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : dtsd
Short Description             : dce_svc_printf with error executed unconditionally
Reported Date                 : 9/7/94
Found in Baseline             : 1.1
Found Date                    : 9/7/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : time/service/dtss_service_main.c
Sensitivity                   : public

[9/7/94 public]
In time/service/dtss_service_main.c, line 614, there is a dce_svc_printf reporting
an error, without checking whether the previous call to dce_aud_open fails or not.



CR Number                     : 11907
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 11905
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : libutc
Short Description             : semaphore code needs rework
Reported Date                 : 8/26/94
Found in Baseline             : 1.1b16
Found Date                    : 8/26/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/26/94 public]

The user-mode implementation of the utc_gettime() and utc_adjtime()
calls utilize a shared memory segment protected by a read and write
semaphore. There are a couple latent problems with this code as
written.

+ No return values are checked for the semaphore operations code.

+ The semaphore operations need SEM_UNDO in order to avoid leaving the 
semaphores in an wrong state should the calling program crash during 
the lock/unlock operations (filed as a defect in related bug)



CR Number                     : 11335
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : 
Short Description             : RPC call ClerkRequstTime() to
remote server failed: unknown interface reported by dtsd at start up
Reported Date                 : 7/15/94
Found in Baseline             : 1.1b12
Found Date                    : 7/15/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/15/94 public]

Using BL-12

I noticed today that when I started DCE, using /etc/rc.dce, and 
before all the 3 DTS servers were running, the first two machines (HPUX, RIOS) 
to start dtsd reported the following error:

root@west> 1994-07-15-15:33:51.682-04:00I107.173 dtsd ERROR dts dtsdate
time_request.c 658 0x4002ccf8
RPC call ClerkRequstTime() to remote server failed: unknown interface 
(dce/ rpc)
1994-07-15-15:33:56.076-04:00I107.178 dtsd WARNING dts config 
logevent_v_ultrix.c 259 0x7aff8a08
Too fews servers (2), need 3 servers

I am opening this OT to record this event. 

The error "unknown interface (dce / rpc)" does not help me 
diagnoze what could be wrong with DTS at this point, and
how to proceed.

[7/19/94 public]

First, as to what this means: the server tried to issue a call to the 
remote (local) server to retrieve its current time. The RPC call
failed for the stated reason: unknown interface. Since there server
would have retrieved the binding information from the namespace, I
suspect that this occurs because the server in question has not
not (yet) registered with the endpoint mapper. 

If this error message is only generated once, then the proper action
is to ignore the error. 

Note also that starting a server is a two phase process: the server is
first "created" via the "create type server" directive, and then enabled
via the "enable" directive. I will verify that the appropriate ordering
of rpc_ep_register() rpc_ns_binding_export() exists.

[07/19/94 public]
I think the problem is not "registered with EP map" but that the server
hasn't registered the interface with its own runtime.  I would check
rpc_server_register_if calls before rpc_ep_register calls.

[8/19/94 public]

Rich (as usual) is correct. This is the result of the "two phase"
creation of a clerk or a server: specifically, the creation of a
server (the old dtscp "create type server" directive) and the actual
starting of the server via the "enable" directive are two distinct 
steps. The "create type server" command actually causes the bindings
to be exported to the namespace, and the daemon to register it's
endpoints with the endpoint mapper; the "enable" directive 
cause the daemon to register its interface with the RPC runtime.
Hence, there is a window where an RPC request can make it all the way
to the daemon before being refused. 

One possible solution is to have the entire "create type server"
command simply set a flag to indicate that it should play the server
role, and the enable command should then perform the canonical three 
step process 

1. register interface with the RPC runtime 
2. register interface and binding with the endpoint mapper 
3. export interface and bindings to the namespace. 

This guarantees that if I can find the server in the namespace, I can
find it in the endpoint map, and I can utilize that interface. Other 
sequences don't provide the same degree of "cleanliness" (e.g. if 
I crash after 1, no-body else knows about me; if I crash after 2, 
the endpoint-mapper will delete me after a period of time...)

Note as well that the "create type server" and "enable" directives are
holdovers from the original DEC implemenation; the entire notion of 
state changes and transition might want to be re-thought as well. In
any event, I'm marking this as an enhancement.



CR Number                     : 10943
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : port_gd
Short Description             : Improve description for sync testing
Reported Date                 : 6/14/94
Found in Baseline             : 1.0.3
Found Date                    : 6/14/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/14/94 public]

Section 6.4.5 of Porting and Testing Guide describes a dts sync testing, 
where you collect trace info and then use dtss-graph to generate a ps report.

What this section does not tell is how to interpret the ps report. 
Also the section says that one can find a sample dtss-graph output 
in the distribution tape.

I tried going through 1.0.1, 1.0.2, 1.0.3 tapes, 
but I could not find a sample output of dtss-graph.

[7/25/94 public]

Assigned this CR to Doug Weir (OSF porting guide writer).

[08/25/94 public]
Filled in Fix By Baseline field for housekeeping purposes.

[10/26/94 public]
I removed the erroneous reference to an example file, but the explanation
will have to wait for 1.2.



CR Number                     : 10723
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : dts
Short Description             : Perf enh. use of threads
Reported Date                 : 5/20/94
Found in Baseline             : 1.0.3
Found Date                    : 5/20/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[01/01/93 public]
[5/20/94 public  sikkema]
[public sikkema]
(a). DTSD creates a GetTimeFromProvider thread on each synchronization.
Once synchronization is done this threads is destroyed and respective
data structures deleted.  This creation and destruction of this
threads happen on each synchronization. Therefore, there is lot of
thread activity going on this component.

Solution: DTS should look at keeping this threads around so that this is
========  used on each synchronization.  This will cut down the overhead
of thread creation and destruction during each synchronization.  This
can be achieved by suspending a thread on a condition variable, and
during synchronization this condition variable is signalled to wake
b).DTS should look at why there needs to be a thread(GetTimeFromServerRPC)
to request time from servers via RPC.



CR Number                     : 10660
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : 
Short Description             : header file org. needs work
Reported Date                 : 5/16/94
Found in Baseline             : 1.1
Found Date                    : 5/16/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/16/94 public]
The dts header file organization has some problems when it comes
to exporting information to client control programs, namely it
doesn't.

time/common/dtssdef.h and time/common/dtss_mgmt_support.h redefine
many things that are in the idl generated dtss_ctrl.h . What needs 
to happen is that all information duplicated in dtss_ctrl.h should
be removed from the other header files and have them include it
instead. 

All #defines needed for control client operation (like K_*) should be
moved to a common file or possibly included into dtss_ctrl.idl. This
will allow a client (like dcecp) to include dtss_ctrl.h and possibly
one other header file and have everything it needs.

With the dts control API now able to manage remote dts daemons, it 
should also be considered if this API should be made public.

[7/16/94 public]

Changing this from a defect to an enhancement. The current
implementation works for both dts and dcecp.



CR Number                     : 10597
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : dtsd
Short Description             : dtsd fails to initiallize if the security server is not available
Reported Date                 : 5/10/94
Found in Baseline             : 1.0.3
Found Date                    : 5/10/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : dtss_service_main.c
Sensitivity                   : public

[5/10/94 public]


From: pare@apollo.hp.com
Subject: DTSD re-try fix

I fixed a dtsd initiallization problem -- you may be interested
in implementing the change. Let me know your thoughts.



PROBLEM
dtsd fails to initiallize if the security server is not available --
dtsd exits with the following error message:

   Error in initialization: No currently established network identity for 
   which context exists (dce / sec)

Since it is conceivable that client nodes can re-boot before server nodes
(as in a power fail/restore situation) it make sense to re-try during
dtsd initiallization.




SOLUTION
Add re-try loop to InitializeService () in dtss_service_main.c, 
re-try every minute for 5 minutes.



DIFFS

10a11,13
>  * Revision /main/HPDCE01/pare_rodan/1  1994/05/03  18:06 UTC  pare
>  * 	Add wait loop for DCE services
>  * 
253a257,259
> #ifdef __hpux
> #include <syslog.h>
> #endif
749a756,758
>     int count;
> #define FIVE 5
> #define ONE_MINUTE 60
778a788,793
> #ifdef __hpux
> openlog("dtsd", LOG_PID, LOG_LOCAL0);
> syslog(LOG_INFO, "main: start");
> if (debug_mode)
>     printf("dtsd: main: start \n");
> #endif
780d794
< 
---
> 
> #ifdef __hpux
> /* Add security re-try loop -- try every minute for five minutes
>  * during initialization. This is necessary for the case where the
>  * DCE client machine comes up before the server.
> */
>     count = 0;
>     do
>     {
>         get_security_config_info (&rpcBuf.host_principal,
>                            &rpcBuf.my_cell,
>	        	     &rpcStatus);
>         if (rpcStatus != error_status_ok) {
>           ++count;
>           dce_error_inq_text(rpcStatus, tempString, &locstat);
> 	    syslog(LOG_WARNING, tempString);
> 	    fprintf(stderr, "\tError in initialization: %s \n",tempString);
> 	    fprintf(stderr, "\tWaiting one minute for DCE security services -- retries remaining: %d\n", FIVE-count);
> 	    sleep(ONE_MINUTE);
>         }
> 	  else {
> 	    syslog(LOG_INFO, "Security initialization successful.");
> 	    fprintf(stderr, "\tSecurity initialization successful.\n");
> 	    break;
>         }
>      }
>      while( count < FIVE);
> #else
> 	get_security_config_info (&rpcBuf.host_principal,
> 				      &rpcBuf.my_cell, &rpcStatus);
> #endif /* __hpux */
> 
833c876
< 	fprintf(stderr, "Error in initialization: %s \n",tempString);
---
> 	fprintf(stderr, "\tError in initialization: %s \n",tempString); 
1074a1118,1122
> 
> #ifdef __hpux
>     syslog(LOG_INFO, "terminate");
>     closelog();
> #endif




Regards,
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Larry Pare                    Chelmsford Systems Software Lab
(508) 436-4378                Hewlett-Packard Corporation
pare@ch.hp.com                Chelmsford, MA 01824
                              FAX 508-436-5119
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

----- End of forwarded message -----

[8/31/94 public]

There are a couple of problems and issues with the above solution. 

1. get_security_config_info() does a couple of other things beside 
calling the DCE security service; one of them is retrieving the cell 
name. If this fails, it doesn't make sense to keep trying for 5
minutes: the response will always be the same. If this looping
behavior is desired, then it should be implemented inside of the 
the get_security_config_info() call. 

2. That having been said, it's not clear to me that this is in fact
the desired behavior. The question to ask, is: do I want my {rc.dce
script, config script} to wait for 5 minutes before telling me that 
the security service isn't available, or do I want to know that
immediately? I don't know what the correct solution is, and I believe
that reasoned arguments can be made for both cases.

Marking this as an enhancement: DCE 1.2 can sort this out.



CR Number                     : 9510
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : dts_ntp_provider
Short Description             : Bad use of NTP-provided information
Reported Date                 : 11/18/93
Found in Baseline             : 1.0.2
Found Date                    : 11/18/93
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[11/18/93 public]
The code in dts_ntp_provider.c does not handle its incoming NTP packet
correctly.  There are two flaws:
	- it uses the time that the NTP server received the query packet, not
	  the time that the NTP receiver transmitted the response; and
	- it uses the inaccuracy figure that the NTP server reports for
	  itself, not the inaccuracy that it should compute based on the
	  communication time.
 
dts_ntp_provider.c correctly determines the four timestamps for the NTP
transaction: (t1) when the client sent the request, (t2) when the server
received the request, (t3) when the server sent the reply, (t4) when the
client received the reply.  It also correctly uses the NTP server's
``distance'' (time distance from time source) in computing the DTS
inaccuracy.
 
The two flaws could be ameliorated by the following:
	- using (t3) rather than (t2) as the basis for the reported time,
	  since that must necessarily be closer to the time that will be
	  reported;
	- adding ((t4-t1) - (t3-t2)) to the inaccuracy figure, since that
	  represents the time that the packet was in transit, and
	  the client (dts_ntp_provider) cannot tell what proportion of the
	  transit time was consumed by the request packet vs. that consumed
	  by the reply packet.
 
It is conceivable that dts_ntp_provider could choose to report a time like
the following:
	define delay=((t4-t1) - (t3-t2));
	when the packet was received (t4), the NTP server's time was
	somewhere in the interval [(t3-delay), t3];
	define the DTS representation of this as (t3-(delay/2)) with
	an inaccuracy of (delay/2), except then you can add in the server's
	synchronization distance, giving ((delay/2) + distance) for the
	DTS inaccuracy.
 
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'
Changed Interest List CC from `cfe@transarc.com, jdp@transarc.com' to 
 `cfe@transarc.com, jdp@transarc.com, dce-ot-dfs'



CR Number                     : 9187
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dts
Subcomponent Name             : libutc
Short Description             : utc_asc*time rounds fractions of seconds incorrectly.
Reported Date                 : 10/18/93
Found in Baseline             : 1.0.3
Found Date                    : 10/18/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/18/93 public]
utc_ascanytime, utc_ascgmtime, utc_asclocaltime and utc_ascreltime
round up .9999 seconds (on either time or inaccuracy) incorrectly
to .1000 rather than incrementing by one second and setting the
fractional field to .000.
Test case:
#include <dce/utc.h>
main()
{
        utc_t   utc;
        char    timestr[UTC_MAX_STR_LEN];
        utc_mkasctime(&utc, "1993-10-14-15:15:15.9999-05:00I1.00");
        utc_ascanytime(timestr, UTC_MAX_STR_LEN, &utc);
        printf("utc_ascanytime: timestr = %s\n", timestr);
}

The error is in common/utc_cvt, where utc_asc*time does:
/* in utc_ascanytime */
    (void) sprintf(timestr,
                   "%04d-%02d-%02d-%02d:%02d:%02d.%03d",
                   tmTime.tm_year+1900,
                   ++tmTime.tm_mon,
                   tmTime.tm_mday,
                   tmTime.tm_hour,
                   tmTime.tm_min,
                   tmTime.tm_sec,
                   ((tns + K_NS_PER_MS/2)/K_NS_PER_MS));

(tns + K_NS_PER_MS/2)/K_NS_PER_MS will be 1000 if tns = .9999.

this could be fixed by something like :
/* in utc_ascanytime (fixes time part only) */
....
    struct utc tmputc, utc_1sec;
    reltimespec_t tm_1sec = {1, 0};
    timespec_t tzero = {0, 0};
....

    if ((tns = (tns + K_NS_PER_MS/2)/K_NS_PER_MS) >= 1000) {
        /* create a timestamp that represents 1 second */
        utc_mkbinreltime(&utc_1sec, &tm_1sec, &tzero);

	/* add 1 second to time */
        utc_addtime(&tmputc, utcTime, &utc_1sec);

        /* get tm struct again */
        utc_anytime(&tmTime, &tns, &tmInacc, &ins, &tdf, &tmputc);

        /* set fraction tns to zero */
        tns = 0;
    }
 
    (void) sprintf(timestr,
                   "%04d-%02d-%02d-%02d:%02d:%02d.%03d",
                   tmTime.tm_year+1900,
                   ++tmTime.tm_mon,
                   tmTime.tm_mday,
                   tmTime.tm_hour,
                   tmTime.tm_min,
                   tmTime.tm_sec,
                   tns);



CR Number                     : 9081
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : 
Short Description             : simplify UTCabsVal
Reported Date                 : 10/10/93
Found in Baseline             : 1.0.2
Found Date                    : 10/10/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : time/common/utc_arith.h
Sensitivity                   : public

[10/10/93 public]

The macro UTCabsVal should directly call UTCnegate instead of calling it
indirectly. This will avoid unnecessary allocation of automatic variables
and unnecessary operations.

Proposed Solution:

/*
 * UTCValue Absolute Value.  result = sub1 if sub1 is positive
 * or the absolute value of sub1 if it was negative.
 */
#define UTCabsVal(sub1,result)                  \
    {                                           \
        UTCValue _utcZero;                      \
        _utcZero.lo = _utcZero.hi = 0;          \
                                                \
        if ((sub1)->hi & 0x80000000)            \
           UTCsub(&_utcZero, (sub1), (result))  \
        else                                    \
           *(result) = *(sub1);                 \
    }

can be changed to:

/*
 * UTCValue Absolute Value.  result = sub1 if sub1 is positive
 * or the absolute value of sub1 if it was negative.
 */
#define UTCabsVal(sub1,result)                  \
    {                                           \
        if ((sub1)->hi & 0x80000000)            \
           UTCnegate((sub1), (result))  \
        else                                    \
           *(result) = *(sub1);                 \
    }



CR Number                     : 8877
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dts
Subcomponent Name             : dtscp
Short Description             : Wish to use '?' for help.
Reported Date                 : 9/29/93
Found in Baseline             : 1.0.3
Found Date                    : 9/29/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/29/93 public]
Customer wish dtscp to recognize question mark as equivalent to "help".

[10/25/93 public]
In control/dtsscp.cdt, I added the line
	CHAR ?  GOTO argHelp
after the line 
        WORD HELP        MIN 3                                  GOTO argHelp
That seems to do it.



CR Number                     : 8626
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : dts
Subcomponent Name             : dtscp
Short Description             : show counters in sorted order
Reported Date                 : 9/17/93
Found in Baseline             : 1.0.2
Found Date                    : 9/17/93
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/17/93 public]
I did a dtscp show all counters and got back a long list that's hard to
read.  It's even harder to compare it to the documentation since the
documentation lists the counters in alphabetical order and dtscp does not.

dtscp should list all counters, characteristics, etc. in sorted order.



CR Number                     : 8573
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : 
Short Description             : compiler warnings (ints compared with unsints)
Reported Date                 : 9/8/93
Found in Baseline             : 1.0.3
Found Date                    : 9/8/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : time/common/dpeaclaccess.c,tzset.cc,utcapi.c
Sensitivity                   : public

[9/8/93 public]

at lines 351 and 359 in file time/common/dpeaclaccess.c, there are
for loop contriol stuctures of the form 

for (j = 0; (j < accessor_info->num_groups); j++)

and 

for (j = 0; (j < accessor_info->num_foreign_groups); j++)

the test expressions in these loop control expressions attemp to
compare a signed loop counter variable, j, with an unsigned variable;
either accessor_info->num_groups or accessor_info->num_foreign_groups.

The compilation of this implementation produces compiler warnings which 
should be eliminated by changing the declaration of the loop counter
variable, j, to be of the appropriate unsigned type.

------------------

at line 327 of file time/common/tzset.c a comparison is made between
an unsigned char and an integer. the result is a compiler warning which 
should be eliminated.

	if (lclstate.types[i] >= lclstate.typecnt)

The compiler complains because it assumes that
the positive precision of an unsigned container may exceed that of an
integer, regardless of our general assumptions about the relative precision
of characters and integers. Although one would be tempted to employ a cast
to silence the compiler the more correct, although also more tedious,
method of correcting this situation would either be to change the type of 
the integer to unsigned or the type of the unsigned to an integer. 

-----------------

at line 981 of file time/common/utcapi.c the following expression was
reported to have resulted in a compiler warning. Iwas not able to
demonstrate this to be the case, although the fact that the litlle endian
case of the same instruction has been modified with a cast, is evidence
tht someone else saw the same warning in the little endian case.

#ifdef BIG_ENDIAN_ARCHITECTURE
    if (((autc.endian.big.flags & VERSION_MASK) >> VERSION_SHIFT) !=
	K_BINTIME_VERSION)

since autc.endian.big.flags is typed to be an unsigned char, I suspect that
their compiler is complaining that the expression derived form flags is
incompatible with the constant K_BINTIME_VERSION, which is treated as an
the integer value 1. Their compiler should probably be sophisticated enough
to deal with this situation since the integer is a positive constant. In
any case however, we should change the code to be consistent in the big and
little endian cases. I suspect that casting the definition of the
constant K_BINTIME_VERSION to an unisgned is probably the correct thing to
do (also remove the cast from the little endian case).



CR Number                     : 8146
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : dts
Subcomponent Name             : 
Short Description             : dtsd error messages
Reported Date                 : 6/11/93
Found in Baseline             : 1.0.2
Found Date                    : 6/11/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/11/93 public]

I think the following reported problem falls into the 1.1 servicability
issue of better error messages"

"It appears that the error messages from dtsd are inconsistent.

If DTSd (1.0.2 version) is started by a user who is not UNIX root, 
the message "No current network identity......" is displayed. 

This does not describe the "root" cause of the problem.

It is true that DTS will fail for all but root users because 
1.0.2 DTS removes the callers context, so the machine identity
is used for the root user, and no identity for a non root user, 
but maybe the error message should be more explicit.

The immediate response to the above error message is to do a dce_login
which is not the correct response.

All the other DCE daemons return a "not priviledged user" type error
message, is it possible to do the same for DTS?"



CR Number                     : 6879
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dts
Subcomponent Name             : 
Short Description             : Request for utc_verify_tm() routine
Reported Date                 : 1/18/93
Found in Baseline             : 1.0.2
Found Date                    : 1/18/93
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/18/93 public]

From IBM:

abstract      utc_mkanytime accepts and processes bogus input

the dts api utc_mkanytime will accept and process bad input such as:
too many days, years out of range, and Feb 29 during nonleapyear.

abstract      utc_mkasctime accepts and processes bogus input
the dts api utc_mkasctime will accept and process bad input such as:
0000-00-00-00:00:00.00-0:00I242.8.

abstract      dtscp update command accepts bad input.
The dtscp command "update" will accept bad input, and attempt to process it.
Some examples of the input:
update time 1991108-12-08:40:00.000-06:00I0.000
update time 1991-13-12-08:40:00.000-06:00I0.000
update time 1991-08-12-08:99:00.000-06:00I0.000
update time 9999-99-99-99:99:99.999-99:99I99.999

abstract      utc_mkgmtime accepts Feb 29 date during non-leapyear.
utc_mkgmtime accepts and processes 1900-2-29.

abstract      utc_mklocaltime accepts bad input.
utc_mklocaltime accepts bad input such as the nonleapyear 1900-2-29,
bad tm structs containing negative numbers, values too large or small.

abstract      utc_mkreltime accepts input timetm that are too large/too small
utc_mkreltime accepts input timetms that are too large or too small, returns
a zero, and gives a result that has rolled over.

abstract      utc_mkgmtime accepts timetm structs with bad elements.
utc_mkgmtime accepts timetm structs with bad elements, for example
tm_sec=90, tm_day=32.

abstract      dtscp change command accepts invalid leapyear.
dtscp change epoch epoch_number time new_time accepts invalid leapyears
for the new_time argument.  For example, entering Feb 29, 1993 will
update the time to March 1, 1993.


abstract      utc_mkgmtime accempts inacctm structs with bad elements.
utc_mkgmtime accepts inacctm structs with bad elements, for example,
tm_sec=60 , tm_min=60 (range for both is 0-59).

From Craig Yankes @ DEC:

                My suggestion for all 9 of these is to open a single
        enhancement request for the creation of a new "int utc_verify_tm
        (tm *timetm)" routine that returns happy or unhappy status depending
        upon whether all the fields within the structure are within the proper
        bounds for the proposed time.  This way, if someone wants to confirm
        a tm as being valid as is, the capability is there.  The reasons we
        are not suggesting that this functionality be added directly to the
        routines mentioned in the bug reports are the following:

        1) As shown by the "NULL discussions", the philosophy of DCE is to
           not slow down properly formed programs to check for improperly
           formed conditions.  Verifying a tm structure is not a simple task
           (all the rules for leap years, the switch to Julian time, etc.)
           and consumes cpu time.

        2) As a functional matter, if a program wants to calculate a time that
           is, say, 10 days from the current time, it is handy to just be able
           to say "tmtime.tm_day = tmtime.tm_day + 10;" and to be able to make
           the presumption that the underlying routines will do the right
           thing with this time.  Validating tm structures means that doing
           this "plus 10" example during the latter third of the month will
           cause an invalid tm structure and force the application program
           into performing all the carry propagations into the next fields
           (requiring, of course, all the knowledge embedded in DTS about
           leap years, Julian day conversion, etc., to be fully correct) that
           is done automatically by DTS today.

        3) As a compatability matter, I don't believe that Posix (where the
           tm structure comes from and from where it is defined) performs
           such field validations in its API.



