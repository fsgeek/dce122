CR Number                     : 13691
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : command_ref
Short Description             : dced documentation needed for
-r option, partial service mode
Reported Date                 : 1/3/97
Found in Baseline             : 1.2.1
Found Date                    : 1/3/97
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/3/97 public]

dced 1.2.1 has an important new feature, partial service mode, and
a new option, -r, that enables remote administration of host objects.
The man page for dced has no discussion of these features, and the
man pages for dcecp and cell make only passing reference.

When documentation is added for how to toggle dced between full
and partial service, it should be noted that the SIGUSR1 mechanism
is specific to the UNIX implementations and that other implementations
will toggle the state in a different way.

Seichi Tatsu, formerly of HP, put a very informative design document
for these features in dce-tech a while back, that can be used for
reference.



CR Number                     : 13666
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : 
Short Description             : rutc_gettime manager routine
lacks status argument
Reported Date                 : 11/14/96
Found in Baseline             : 1.2.1
Found Date                    : 11/14/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : dced/server/rutcops.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/14/96 public]

dced/idl/rutc.acf brings in a new status parameter to rutc_gettime.
Yet this argument is not declared in the rutc_gettime function
definition.  This causes link errors.  I've worked around it
by inserting "error_status *st" in the rutc_gettime definition in 
rutcops.c



CR Number                     : 13662
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 13045
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : database files
Short Description             : 1.1/1.2.1 version mismatch
Reported Date                 : 11/6/96
Found in Baseline             : 1.2.1
Found Date                    : 11/6/96
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/6/96 public]

Dick Sikkema has found a problem with the fix for OT 13045.
Licensees with installed 1.1 hosts will fail when a 1.2.1 (or
later) dced tries to start up because the IDL file describing
the backing store has a new major version number.

Our planned fix is to add code that traps the "unknown interface"
code, and rewrite the old->new format on the fly.



CR Number                     : 13658
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 13647
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : dced
Subcomponent Name             : dced_hostdata_create
Short Description             : dced_hostdata_create test expects wrong status.
Reported Date                 : 10/18/96
Found in Baseline             : 1.2.2
Found Date                    : 10/17/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : provider
Diff release                  : 1.2.2
Sensitivity                   : private

[01/01/93 public]
[Bart Fenerty 10/19/96 private]



CR Number                     : 13647
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : dced acls
Short Description             : dced acl code returns wrong error on unauthz
Reported Date                 : 10/2/96
Found in Baseline             : 1.1
Found Date                    : 10/2/96
Severity                      : A
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : admin/dced/libdcedpvt/acls.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/2/96 public]

dced authorization check code in acls.c returns the wrong error
(sec_acl_invalid_permission) all over the place, when some operation
is not authorization to occur, where it should be returning
sec_acl_not_authorized:

(see the following explanations from sec.sams)
start
code    sec_acl_invalid_permission
text    "permission not valid for this acl"
explanation    "One or more specified permissions not valid for this ACL."
action         "Determine correct permissions and retry the operation."
end

start
code    sec_acl_not_authorized
text    "operation on acl not authorized"
explanation    "Not authorized to perform the requested operation on this
		object."
action         "Identity with control rights to ACL should perform the
		operation."
end

I would consider this a showstopper (these error codes are passed over the
wire and thus become part of the protocol) which *must* be fixed for 1.2.2
and must be patched for all previous releases.



CR Number                     : 13494
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : dced_wait_for_sec
Short Description             : dced_wait_for_sec can hang if a secd is down
Reported Date                 : 6/6/96
Found in Baseline             : 1.1
Found Date                    : 6/6/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/admin/dced/server/main.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[6/6/96 public]

In dced_wait_for_sec, if the sec_rgy_site_bind() returns a handle to
a server that is unavailable (which it shouldn't, but that's another
story), or if the server goes down before the call to
sec_rgy_pgo_name_to_id(), the sec_rgy_pgo_name_to_id() loop will loop
until that server comes back up.

It should dispose of the binding it has and try to get another one.
The diffs included in this OT will make it do so.  (However, that will
not fix the problem, because currently, sec_rgy_site_bind() will keep
returning the same cached handle to the same unavailable server.  I am
working on a fix for that too, which I will submit when it's done.
When that's fixed, the advantage that this diff gives will kick in.)
Given, if _all_ secds are down, then it should wait, but if one
of them is up, it should get the opportunity to find it.

To exploit the problem: configure a cell with one slave security
server, and ensure that the pe_site file on the master machine has
both sites' info in it.  Stop all DCE services on both machines,
and then try to restart DCE on the master machine.  dced will bind
to the slave, and the secval service will never activate until the
slave comes up, because it will loop in dced_wait_for_sec.  (Note
the caveat above that this is only half of the solution for that.)

Also, some dce_svc_printf() calls were missing a status parameter.

This diff is against the 1.1 code, but the 1.2.1 base has the same set
of problems.


*** 12.11	1995/09/29 15:59:52
--- 12.15	1996/06/06 14:36:27
***************
*** 441,453 ****
      uuid_create_nil(&thishost_prin_uuid, st);
      uuid_create_nil(&this_cell_uuid, st);
  
      /* Wait for secd to show up */
      for ( ; ; ) {
          auth.info_type = sec_rgy_bind_auth_none;
          sec_rgy_site_bind(NULL, &auth, &rh, st);
          if (*st == error_status_ok)
              break;
!         dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG, "secd");
          dced_sleep(10);
      }
  
--- 458,471 ----
      uuid_create_nil(&thishost_prin_uuid, st);
      uuid_create_nil(&this_cell_uuid, st);
  
+   do {
      /* Wait for secd to show up */
      for ( ; ; ) {
          auth.info_type = sec_rgy_bind_auth_none;
          sec_rgy_site_bind(NULL, &auth, &rh, st);
          if (*st == error_status_ok)
              break;
!         dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG, "secd", (long)*st);
          dced_sleep(10);
      }
  
***************
*** 456,467 ****
          strcpy((char *)prin_in_rgy, thishost_prin);
          sec_rgy_pgo_name_to_id(rh, sec_rgy_domain_person, prin_in_rgy,
                  &thishost_prin_uuid, st);
!         if (*st == error_status_ok)
              break;
!         dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG, "machine principal");
          dced_sleep(10);
      }
  
      /* Wait for HOST/self keytab to be available */
      for ( ; ; ) {
          strcpy((char *)prin_in_rgy, thishost_prin);
--- 474,492 ----
          strcpy((char *)prin_in_rgy, thishost_prin);
          sec_rgy_pgo_name_to_id(rh, sec_rgy_domain_person, prin_in_rgy,
                  &thishost_prin_uuid, st);
!         if (*st == error_status_ok || *st == sec_rgy_server_unavailable)
              break;
!         dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG,
!                        "machine principal", (long)*st);
          dced_sleep(10);
      }
  
+     if (*st == sec_rgy_server_unavailable) {
+         error_status_t lst;
+         sec_rgy_site_close(rh, &lst);
+     }
+   } while (*st == sec_rgy_server_unavailable);
+ 
      /* Wait for HOST/self keytab to be available */
      for ( ; ; ) {
          strcpy((char *)prin_in_rgy, thishost_prin);
***************
*** 471,477 ****
              sec_key_mgmt_free_key(key, st);
              break;
          }
!         dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG, "machine keytab");
          dced_sleep(10);
      }
  
--- 496,503 ----
              sec_key_mgmt_free_key(key, st);
              break;
          }
!         dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG,
!                        "machine keytab", (long)*st);
          dced_sleep(10);
      }
  
***************
*** 496,502 ****
              rpc_c_authn_dce_secret, NULL, NULL, st);
          if (*st == error_status_ok)
              break;
!         dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG, "rpc_server_register_auth_info");
          dced_sleep(10);
      }
  }
--- 522,529 ----
              rpc_c_authn_dce_secret, NULL, NULL, st);
          if (*st == error_status_ok)
              break;
!         dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG,
!                        "rpc_server_register_auth_info", (long)*st);
          dced_sleep(10);
      }
  }



CR Number                     : 13474
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : 
Short Description             : dced_object_read_all fails
Reported Date                 : 5/17/96
Found in Baseline             : 1.1
Found Date                    : 5/17/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/17/96 public]

When using the dced_object_read_all the call fails.  This is because there are hostdata
objects that do not have storage files associated with it.  For example there are objects
for the dfs cache info, group override, and password override.  There are no files associated
with this (except for DFS cache, if DFS is configured).  I would think that the information
that could be retrieved would be returned instead of just failing and returning nothing.



CR Number                     : 13432
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : 
Short Description             : dced dumps core if malloctype not set
Reported Date                 : 4/18/96
Found in Baseline             : 1.2.1
Found Date                    : 4/18/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/18/96 public]

This problem has been discussed at length, but I am not aware of
a defect report in the database to document it, so here goes.

dced dumps core after several hours on AIX 3.2.5 unless MALLOCTYPE is
set as described below. Below is an explanation from IBM:
 
-----------------------------------------------------
If you plan to run the OSF DCE 1.2.x reference platform code on AIX
3.2.5, you must export MALLOCTYPE=3.1 when you execute the code.
 
The reason for this is that the malloc algorithm changed from AIX 3.1 to
AIX 3.2. The malloc algorithm in AIX 3.1 returns a fresh, zero-
initialized space. DCE depends on this behavior. AIX 3.2 malloc does not
guarantee a zero-initialized space.
 
So, before you execute your DCE code on AIX 3.2.5, do the following:
 
export MALLOCTYPE=3.1
 
The procedure step will cause all applications to revert back to the old
malloc. Setting this variable to any other value will cause the new
malloc to be in effect.
----------------------------------------------------- -- Gerry Thome

I (biyani@transarc.com) was not able to discover a way to force malloc()
to return a zero-initialized space on other important unixes
like HP/UX 9, Solaris 2.3, Digital Unix 3.2, and AIX 4. Undoubtedly,
there are many other platforms that DCE 1.2.1 will be ported to.

If indeed there is no workaround on each of these platforms, this will
turn out to be a really severe problems as licensees attempt to
port DCED 1.2.1.

If you know of workarounds, please document them here.



CR Number                     : 13429
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : 
Short Description             : dced overwrites dce_acl* status withbogus 'sec_acl_invalid_permission'
Reported Date                 : 4/16/96
Found in Baseline             : 1.1
Found Date                    : 4/16/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/16/96 public]
The dced code makes calls to the dce_acl_is_client_authorized() API
and overwrites any error status returned from that routine.  Not
only does that hide any errors at the dce_acl* level, but the 
error status that dced overwrites real errors with is
'sec_acl_invalid_permission'.  This is misleading; based on the 
logic in dced at these access checks, the error status (if appropriate
to set one in the dced code at all) should be 'sec_acl_not_authorized'. 
(See sec.sams.)

See
src/admin/dced/server/misc.c (dced_authorized())
src/admin/dced/server/acls.c (dced_server_auth())



CR Number                     : 13426
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : sec
Short Description             : rpc_ss_allocate() memory freed using free()
Reported Date                 : 4/3/96
Found in Baseline             : 1.1
Found Date                    : 4/3/96
Severity                      : A
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : ./admin/dced/server/misc.c
Sensitivity                   : public

[4/3/96 public]

In name_cache_schema_init() (./dced/server/misc.c), memory allocated
by dce_db_fetch_by_uuid() is freed using sec_attr_util_sch_ent_free_ptrs().
dce_db_fetch_by_uuid() calls stub routines in dced_convert_cstub.o which
uses rpc_ss_allocate() even though it is not a network RPC.
sec_attr_util_sch_ent_free_ptrs() in ./security/utils/sec_attr_utils.c
uses free() as rest of security uses it for local calls.

One solution would be to add a new parameter to 
sec_attr_util_sch_ent_free_ptrs() specifying the deallocation function
and then specify rpc_ss_free() in name_cache_schema_init().  The following
files may need to be modified if this route is taken:

./admin/dcecp/dhd_hostdata.c
./admin/dcecp/dhd_util.c
./admin/dcecp/rgy_pgo_utils.c
./admin/dcecp/rgy_utils.c
./admin/dcecp/schema_ops.c
./admin/dcecp/schema_utils.c
./admin/dced/server/misc.c
./security/idl/sec_attr_util.idl
./security/server/rrs/rrs_prop_attr_schema.c
./security/server/rs/rpriv_attr.c
./security/server/rs/rs_attr.c
./security/server/rs/rs_attr_schema.c
./security/server/rs/rs_log_attr.c
./security/server/rsdb/rsdb_attr.c
./security/server/rsdb/rsdb_attr_schema.c
./security/server/sec_salvage_db/sec_svg_prt.c
./security/server/sec_salvage_db/sec_svg_util.c
./security/utils/sec_attr_util.c
./test/dce/utils/attr/ts/attr_sch/dce_attr_sch_fvt.c

I don't think the content of sec_attr_utils.idl is listed as
supported API calls.  Otherwise, duplicate functions using the rpc_*_free()
need to be implemented.

							- Mustie

[4/4/96 public]

Are you sure that dce_db_fetch_by_uuid() is using rpc_ss_allocate()? Since
name_cache_schema_init() is called by the main thread where the stub memory
management is disabled, I believe pickling uses malloc().

[4/5/96 public]

You're right.  The change in behavior was due to our code.  rpc_ss_allocate()
was moved up to where we initialize implementation specific signal
handling code.  I've moved rpc_ss_allocate() back into signal_catcher()
and verified the correct behavior.  Thanks for the clarification.

However, in looking through the code I've found another instance of
rpc_ss_allocate() in acl_patcher() in acls.c in addition to the one
in signal_catcher() in main.c.  The one in main.c was added as part
of the 1.1-maintanence release.  History logs in main.c has a comment
*thinking* it was part of OT 12714 which seems misleading.  I have not
yet followed the rpc_ss_allocate() code path completely but I am wondering
if calling rpc_ss_allocate() multiple times without calling corresponding
rpc_ss_disable_allocate() can have erroneous side affects other than
wasting memory reources?  Currently, rpc_ss_allocate() is being called
by two different threads.  I don't think the additional call in
signal_catcher() is necessary.

							- Mustie



CR Number                     : 13398
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : api
Short Description             : login-refresh in dce_server_sec_begin
Reported Date                 : 3/21/96
Found in Baseline             : 1.1
Found Date                    : 3/21/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/21/96 public]

The dce_server_sec_begin API has a  flag to manage the server's key
(i.e., by randomizing it).  There should be a flag that lets users
keep the server key unchanged, but refresh/revalidate the login
context.



CR Number                     : 13342
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : keytab
Short Description             : privacy not always needed
Reported Date                 : 2/20/96
Found in Baseline             : 1.1,1.2.1
Found Date                    : 2/20/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/20/96 public]

{Note the interest list.}

All keytab operations require privacy.  Only those that actually
transmit keys should really require it.  Those that don't need it:
	create/import
	delete
	get_list
The last two are a simple matter of remove the
    if (!dced_privacy_ok(h, st))
	return;
statement.  The first will require moving it around a bit.

Without doing this a server that wants to be totally integrated with
must do something like use an ERA to store the keytab for the time
when it is started w/o DCED.



CR Number                     : 13333
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : dce_server_sec_begin
Short Description             : should maintain context
Reported Date                 : 2/17/96
Found in Baseline             : 1.1
Found Date                    : 2/17/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/17/96 public]

The dce_server_sec_begin routine, if asked to do a "login", should
spawn a thread to maintain the login context.



CR Number                     : 13328
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : admin_gd
Short Description             : Use of port 135 is not documented
Reported Date                 : 2/16/96
Found in Baseline             : 1.1
Found Date                    : 2/16/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : src/dce_books/command_ref/man8dce/dced.8dce
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 16702
Transarc Status               : open

[2/16/96 public]
The use of port 135 is not documented in the ref pages (or anywhere,
apparently). This fact is becoming more important to administrators in
light of increased use of firewalls and support for
RPC_RESTRICTED_PORTS.
Added field Transarc Deltas with value `16702' 
Added field Transarc Status with value `open'

[2/20/96 public]

Moved from component dcecp to dced.

[8/9/96 public]

Changed responsible to sherman.  This Port 135 should 
be documented in the admin guide according to 
developers here.  In the AES it is appendix H.



CR Number                     : 13215
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : 
Short Description             : dcerpcrun occasional test failure
Reported Date                 : 12/5/95
Found in Baseline             : 1.2
Found Date                    : 11/29/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[12/5/95 public]
 
This problem occurred in one run out of a total of 22 during a 
continuous hours of operation test run that stressed the cell for 36 hours. 
It occurred in 1 iteration out of 9 that occurred during that particular 
run of the test.  In other words this problem is seen very seldom even 
under a considerable DCE stress. 

The client fails to report status for each rpcrun loop executed. 

The portion of the journal for the iteration with error is included here: 

520|0 1 19487 1 134|\nBEGIN ITERATION 6
520|0 1 19487 1 135|\n\nStarting sync process on clients:\n
520|0 1 19487 1 136|\tblu2\c
520|0 1 19487 1 137|\tibm_l3\c
520|0 1 19487 1 138|\tpoly\c
520|0 1 19487 1 139|\n\nStarting client wrapper process on clients:\n
520|0 1 19487 1 140|\tblu2\c
520|0 1 19487 1 141|\tibm_l3\c
520|0 1 19487 1 142|\tpoly\c
520|0 1 19487 1 143|\n\nStopping sync/wait process on clients:\n
520|0 1 19487 1 144|\tblu2\c
520|0 1 19487 1 145|\tibm_l3\c
520|0 1 19487 1 146|\tpoly\c
520|0 1 19487 1 147|\n\nWaiting for clientwait pid(s) to exit.\c
520|0 1 19487 1 148|.\c
520|0 1 19487 1 149|.\c
520|0 1 19487 1 150|\n\n
520|0 1 19487 1 151|\n\nWaiting for clientwrapper pid(s) to exit.\c
520|0 1 19487 1 152|.\c
520|0 1 19487 1 153|.\c
520|0 1 19487 1 154|\n\n
520|0 1 19487 1 155|Getting test results from database.
520|0 1 19487 1 156|D_STATUS=1, D_HOSTS=3, 89 divideby 6, CLIENTLOOPSxCONCURRENT
=15
520|0 1 19487 1 157|\nERROR: A client failed to report status for each loop exec
uted.\n
520|0 1 19487 1 158|\nEND ITERATION 6



CR Number                     : 13159
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000,hppa
S/W Ref Platform              : aix,hpux
Component Name                : dced
Subcomponent Name             : server stop
Short Description             : servr stop -method rpc causes secd segv
Reported Date                 : 10/23/95
Found in Baseline             : 1.1
Found Date                    : 10/23/95
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/admin/dced/api/dced_server.c
Sensitivity                   : public

[10/23/95 public]

I was running the dcecp server ping tests in order to verify a fix
for OT 12834, and noticed that the last ic of server_ping_P.tcl did
a server stop -method rpc which caused secd to do the following

 Dumping core after receiving signal SIGSEGV

I used the debugger to trace the execution of dcecp and it appeared as
if the stack had been corrupted, and that when dced_server_stop was
execueted, that the uuid comparison for "all_services" passed causing
the shutdown all of dce rpc to be issued.

The problem also exists on the HP, but the consequence is less serious.
On the HP, the following error message appearss in the dcecp session.

dcecp> stop server tserver -method rpc
Error: Unknown message number 0x14129007
dcecp>

REPEAT BY:

install the dcecp server functional tests
run ic4 of server_ping_P.tcl



CR Number                     : 13115
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : dced
Subcomponent Name             : server
Short Description             : Pass status to waiting for something message
Reported Date                 : 9/11/95
Found in Baseline             : 1.1
Found Date                    : 9/11/95
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/11/95 public]

SVR4 porting changes from support customer:

Client Software:        Unixware 2.0

*** /animal/build/dce1.1/src/./admin/dced/server/main.c	Thu Dec 15 14:25:29 1994
--- ./admin/dced/server/main.c	Tue May  2 12:06:36 1995
***************
*** 8,17 ****
  /*
   * HISTORY
   * $Log:	c013115,v $
# Revision 1.1  95/09/11  15:50:44  root
# new CR
# 
   * Revision 2.1.2.1  1994/12/15  19:23:29  tom
   * 	DCE 1.1 Unintegrated source from OSF
   * 	[1994/12/15  17:50:18  tom]
!  *
   * Revision 1.1.4.1  1994/10/26  19:54:40  rsalz
   * 	Add rpc_ss_enable_allocate call to signal_catcher (OT CR 12714?).
   * 	Call srvrexec_init for kill(2)-based pinging.
--- 8,20 ----
  /*
   * HISTORY
   * $Log:	c013115,v $
# Revision 1.1  95/09/11  15:50:44  root
# new CR
# 
+  * Revision 2.1.3.2  1995/05/02  16:06:32  tomj
+  * 	Pass status to waiting for something message.
+  *
   * Revision 2.1.2.1  1994/12/15  19:23:29  tom
   * 	DCE 1.1 Unintegrated source from OSF
   * 	[1994/12/15  17:50:18  tom]
!  * 
   * Revision 1.1.4.1  1994/10/26  19:54:40  rsalz
   * 	Add rpc_ss_enable_allocate call to signal_catcher (OT CR 12714?).
   * 	Call srvrexec_init for kill(2)-based pinging.
***************
*** 374,380 ****
  		&thishost_prin_uuid, st);
  	if (*st == error_status_ok)
  	    break;
! 	dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG, "machine principal");
  	dced_sleep(10);
      }
  
--- 381,387 ----
  		&thishost_prin_uuid, st);
  	if (*st == error_status_ok)
  	    break;
! 	dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG, "machine principal", *st);
  	dced_sleep(10);
      }
  
***************
*** 387,393 ****
  	    sec_key_mgmt_free_key(key, st);
  	    break;
  	}
! 	dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG, "machine keytab");
  	dced_sleep(10);
      }
  
--- 394,400 ----
  	    sec_key_mgmt_free_key(key, st);
  	    break;
  	}
! 	dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG, "machine keytab", *st);
  	dced_sleep(10);
      }
  
***************
*** 412,418 ****
  	    rpc_c_authn_dce_secret, NULL, NULL, st);
  	if (*st == error_status_ok)
  	    break;
! 	dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG, "rpc_server_register_auth_info");
  	dced_sleep(10);
      }
  }
--- 419,425 ----
  	    rpc_c_authn_dce_secret, NULL, NULL, st);
  	if (*st == error_status_ok)
  	    break;
! 	dce_svc_printf(DCED_S_WAITING_FOR_SOMETHING_MSG, "rpc_server_register_auth_info", *st);
  	dced_sleep(10);
      }
  }



CR Number                     : 13046
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : keytab/hostdata
Short Description             : dced created files are always owned by dced ("root").
Reported Date                 : 8/21/95
Found in Baseline             : 1.1
Found Date                    : 8/21/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/21/95 public]

keytab and hostdata storage files created by dced are always owned by
"root". There is no way to specify the ownership. It should probably be a
part of variable attributes. Note: Currently, keytab and hostdata, i.e.,
dced_entry_t, have no variable attribute. Lack of this makes obsoleting
rgy_edit impossible.

[8/21/95 public]

Oops, I missed dced_c_binding_syntax_bypass. The last sentence in the above
comment is false.



CR Number                     : 13042
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : 
Short Description             : detecting tampering
Reported Date                 : 8/17/95
Found in Baseline             : 1.1
Found Date                    : 8/17/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/17/95 public]

If someone breaks into the master security server (e.g., they have
root access on the host where the master secd is running) they can
become root on any machine running dced.  They can do this by changing
the victim machine principal's password, log in as that principal, create
a "passwd_override" hostdata object, and then log into the victim machine.

dced changes the machine principal key often.  Suppose if it got a
"wrong key version" message back, it then "shut down" the remote
interfaces to hostdata, keytab, etc?



CR Number                     : 12960
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12854
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : server
Short Description             : code is incomplete
Reported Date                 : 7/20/95
Found in Baseline             : 1.1
Found Date                    : 7/20/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/20/95 public]

According to the dced 'server' man page, dced is supposed to be able
to start servers automatically when an RPC to an interface managed
by the server arrives ('auto' in the 'starton' server configuration
attribute).  Code to pass the 'auto' attribute value exists in dcecp,
but dced does not do anything with it.
	This is related to OT 12854 ('server disable' doesn't work)
because both are concerned with the transition from the old endpoint
database to the new (in a way).  'server disable' updates the 'endpoint
valid' flag in the new database, but the endpoint mapper code uses the
old database, and thus the 'endpoint valid' flag is ignored; the 'auto'
code should presumably scan the endpoint map, find no match, and check
the server configuration list for a matching server.  Thus, both problems
are really problems with the endpoint mapper code not having been upgraded.
	I listed OT 12854 as priority 'C1' because the lack of the
'server disable' isn't particularly ugly; I perceive it as a relatively
minor feature.  But 'auto'-starting servers is a major feature, and one
on which some of our customers depend; and there is no indication elsewhere
that it is not meant to be supported in OSF DCE 1.1; hence I'm giving this OT
an "A1" priority.

[2/5/96 public]

I'm downgrading this since there are no current DCE dependencies on this 
functionality and its absence is not a fatal problem.



CR Number                     : 12923
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : server exec
Short Description             : in dced_fork need to set new
pid entries to 0 when realloc'ing the pid table
Reported Date                 : 6/18/95
Found in Baseline             : 1.1
Found Date                    : 6/18/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/18/95 public]

In dced_fork the table is expanded if no free entries are
found.  The expansion is done with realloc.
If the new entries are not set to 0 they will appear already
in use.



CR Number                     : 12921
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : srvrconf
Short Description             : Assorted ACL problems
Reported Date                 : 6/16/95
Found in Baseline             : 1.1
Found Date                    : 6/16/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/16/95 public]

dced has problems dealing with ACLs on its objects.  I have seen two
errors so far;

1) Adding a 'user_obj' entry to the srvrconf initial object ACL causes
   subsequent attempts to change the initial object ACL to fail; as in

	dcecp> acl show /.:/hosts/itsit/config/srvrconf -io
	{unauthenticated ---r--}
	{user hosts/itsit/self cdfrwx}
	{user cell_admin cdfrwx}
	{any_other ---r--}
	dcecp> acl modify /.:/hosts/itsit/config/srvrconf -io -add {user_obj cdfrwx}
	dcecp> acl show /.:/hosts/itsit/config/srvrconf -io
	{unauthenticated ---r--}
	{user_obj cdfrwx}
	{user hosts/itsit/self cdfrwx}
	{user cell_admin cdfrwx}
	{any_other ---r--}
	dcecp> acl check /.:/hosts/itsit/config/srvrconf
	criI
	dcecp> acl modify /.:/hosts/itsit/config/srvrconf -io -remove {user_obj}
	Error: permission not valid for this acl
	dcecp> acl modify /.:/hosts/itsit/config/srvrconf -io -remove {user cell_admin}
	Error: permission not valid for this acl
	dcecp>

2) cell_admin is able to delete srvrconf objects created by self _if_
   {user_obj cdfrwx} is in the srvrconf initial object ACL or is added
   to the particular srvrconf object.
	I'm not sure whether this is a bug; I would have assumed that
   the "owner" of the srvrconf object was the principal that created it,
   in this case self; but it may be that the "owner" is cell_admin
   (inherited from the CDS entry /.:/hosts/itsit) which case this makes
   perfect sense.

    As self:
	dcecp> acl show /.:/hosts/itsit/config/srvrconf -io
	{unauthenticated ---r--}
	{user_obj cdfrwx}
	{user hosts/itsit/self cdfrwx}
	{any_other ---r--}
	dcecp> server create /.:/hosts/itsit/config/server/Perf -program /etc/perfServer -starton explicit

    As cell_admin:
	dcecp> acl show /.:/hosts/itsit/config/srvrconf/Perf
	{unauthenticated ---r--}
	{user_obj cdfrwx}
	{user hosts/itsit/self cdfrwx}
	{any_other ---r--}
	dcecp> acl check /.:/hosts/itsit/config/srvrconf/Perf
	cdfrwx
	dcecp> server delete /.:/hosts/itsit/config/srvrconf/Perf
	dcecp>

[6/22/95 public]

Problem (1) above is due to buggy code somewhere within the following
stack trace:

(dbx) where
>  0 dce_acl__permset_alg(
        do_deleg = '^@',
        auth = '^A',
        pa_p = 0x661c10,
        ap = 0x24d048,
        own_id = (nil),
        grp_id = (nil),
        mask_perms = 0x24cfd8,
        unauth_mask = 0x24cfd0,
        posix_semantics = 0,
        perms = 0x24d0e8,
        st = 0x24d590
     ) ["/project/dce/build/decdce2.0/src/dce/utils/acldb/acleval.c":529]
   1 dce_acl_inq_permset_for_creds(
        cred_h = (...),
        ap = 0x24d048,
        own_id = (nil),
        grp_id = (nil),
        posix_semantics = 0,
        perms = 0x24d0e8,
        st = 0x24d590
     ) ["/project/dce/build/decdce2.0/src/dce/utils/acldb/acleval.c":759]
   2 dce_acl_inq_client_permset(
        h = 0x363e08,
        mgr_type = 0x24d5a0,
        acl_uuid = 0x24d170,
        own_id = (nil),
        grp_id = (nil),
        permset = 0x24d0e8,
        st = 0x24d590
     ) ["/project/dce/build/decdce2.0/src/dce/utils/acldb/acleval.c":186]
   3 dce_acl_is_client_authorized(
        h = 0x363e08,
        mgr_type = 0x24d5a0,
        acl_uuid = 0x24d170,
        own_id = (nil),
        grp_id = (nil),
        desired_perms = 8,
        authorized = 0x24d160,
        st = 0x24d590
     ) ["/project/dce/build/decdce2.0/src/dce/utils/acldb/acleval.c":122]
   4 dce_rdacl_replace(
        h = 0x363e08,
        component_name = 0x662530,
        mgr_type = 0x24d5a0,
        sec_acl_type = sec_acl_type_default_object,
        sec_acl_list = 0x697530,
        st = 0x24d590
     ) ["/project/dce/build/decdce2.0/src/dce/utils/acldb/aclimpl.c":360]
   5 op1_ssr(...)

The relevant portion of dce_rdacl_replace() is

   358      LOCK;
   359      if (h) {
>  360          dce_acl_is_client_authorized(h, mgr_type, &auuid, NULL, NULL,
   361                  am_info->control_perm, &ok, st);
   362          if (!ok) {
   363              UNLOCK;
   364              *st = sec_acl_invalid_permission;
   365              return;
   366          }
   367      }

Note that dce_acl_is_client_authorized is passed an owner ID and group ID of
NULL.

The relevant portion of dce_acl__permset_alg() is

   521      /* Now that we know which entries match the user described in the PAC,
   522       * check the permissions corresponding to each entry until access is
   523       * granted by one of them. */
   524
   525      /* USER_OBJ check (masking is differnt than the others) */
   526      if (user_obj_ep) {
   527          /* If user_obj entry exists, owner cannot be NULL */
   528          if (own_id == NULL) {
>* 529              *st = sec_acl_expected_user_obj;
   530              return TRUE;
   531          }

Note that if a user_obj entry exists in the ACL, then dce_acl__permset_alg()
will reject any call that contains a NULL owner ID; also, from the stack
trace, the owner ID is not filled in anywhere on the way to the call to
dce_acl__permset_alg().

	So, is dce_rdacl_replace() wrong to pass NULL owner and group
IDs, or is dce_acl__permset_alg() wrong to reject the call?

[9/11/95 public]

Or aclmgr is broken for user/group_obj. :-) Seriously, aclmgr's
user/group_obj implementation is incomplete. (Not surprisingly, because the
security AES discourages the use of user/group_obj.)

[09/11/95 public]
Yes, user/group_obj support was added to the ACL lib at the "last minute."
It involved many quick trips among the offices of the person who wrote
the spec, was writing the code, and who wrote the security AES. :)



CR Number                     : 12854
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12696
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : epops
Short Description             : dcecp 'server disable' fails silently
Reported Date                 : 4/28/95
Found in Baseline             : 1.1
Found Date                    : 4/28/95
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/28/95 public]

The dcecp command 'server disable' returns {0 {}}, indicating success,
but clients can still use the disabled interface.  This can be verified
with the included script (created from the server_disable_8_P Tcl code)
properly modified for your particular environment.
	The underlying problem is that while 'server disable' successfully
updates an endpoint map structure, it is not the endpoint map structure used
by dced_ept_map().  The endpoint mapping code seems to be in a transitional
state between new and old data structures; the migration to the new structures
isn't complete (dced_ept_map() calls old_ept_map()).
	Investigating this also led me to question the validity of using
'server ping' to test whether the interface is enabled, as is done in the
server_disable_8_P test.  This is why I use tclient rather than 'server ping'
in the script provided here.  Upon further reflection, this may not be
necessary -- the rpc_mgmt_is_server_listening() must piggyback on the tserver's
interface endpoint, and if that is disabled, the ping should fail, so 'server
ping' should work just as well.

------------------------------ Begin 'disable.dcecp' -------------------------
#!/usr/bin/dcecp
set CELL_ADMIN <your cell admin principal>
set PASSWORD <password for your cell admin principal>
set HOST <your host name (no domain)>
set BINDING <protseq:addr for your host>
set DIRECTORY <the directory where you've stashed tserver and tclient>
puts stderr "Setting up..."
login $CELL_ADMIN -p $PASSWORD
catch {server delete tserver} dontcare
puts stderr [list principal create : [catch "principal create tserver" msg] $msg]
puts stderr [list group add : [catch "group add none -member tserver" msg] $msg]
puts stderr [list organization add : [catch "organization add none -member tserver" msg] $msg]
puts stderr [list account create : [catch "account create tserver -group none -org none -mypwd -dce- -password foobar" msg] $msg]
puts stderr [list keytab add : [catch "keytab add /.:/hosts/$HOST/config/keytab/self -member tserver -version 1 -key foobar" msg] $msg]
puts stderr [list server create : [catch "server create tserver -attr {{arguments /.:/hosts/$HOST/test_server} {program tserver} {entryname /.:/hosts/$HOST/test_server} {services {{annotation {dcecp server object test program}} {bindings $BINDING} {ifname {test server}} {interface 008bebed-c7c1-1ddc-9cb3-0000c0ba4944,1.0} {objects 0073f23a-2e1a-1ddd-b73a-0000c0ba4944} {entryname /.:/hosts/$HOST/test_server}}} {principals tserver} {starton explicit} {uuid 00469db2-231c-1de5-80de-0000c0ba4944} {directory $DIRECTORY}}" msg] $msg]
puts stderr [list server start : [catch "server start tserver" msg] $msg]
exec sleep 20
puts stderr "Setup complete.  Type <return> to disable interface..."
exec read ans
puts stderr "Disabling the interface..."
puts stderr [list server disable : [catch "server disable tserver -interface {008bebed-c7c1-1ddc-9cb3-0000c0ba4944,1.0}" msg] $msg]
puts stderr "Interface disabled.  Type <return> to test the client..."
exec read ans
puts stderr "Trying the client... Should yield {1 {tclient: tserver_v1_0_c_epv.server_stop failed}}..."
puts stderr [list tclient : [catch "exec $DIRECTORY/tclient /.:/hosts/$HOST/test_server 42" msg] $msg]
puts stderr "Client tested.  Type <return> to clean up..."
exec read ans
puts stderr "Cleaning up..."
catch "server stop tserver -method hard" dontcare
puts stderr [list server delete : [catch "server delete tserver" msg] $msg]
puts stderr [list keytab remove : [catch "keytab remove /.:/hosts/$HOST/config/keytab/self -member tserver" msg] $msg]
puts stderr [list account delete : [catch "account delete tserver" msg] $msg]
puts stderr [list organization remove : [catch "organization remove none -member tserver" msg] $msg]
puts stderr [list group remove : [catch "group remove none -member tserver" msg] $msg]
puts stderr [list principal delete : [catch "principal delete tserver" msg] $msg]
logout
------------------------------ End 'disable.dcecp' -------------------------



CR Number                     : 12849
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12848
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : sxops.c
Short Description             : get_random_binding() should use
					     object UUID if one is present.
Reported Date                 : 4/25/95
Found in Baseline             : 1.1
Found Date                    : 4/25/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : src/admin/dced/server/sxops.c
Sensitivity                   : public

[4/25/95 public]

get_random_binding() in sxops.c just picks a random binding out of the list
of bindings for a random service for the given server exec object.  If the
binding does not have an endpoint, the kill_server() function (which is the
only caller of get_random_binding()) will fail, because the RPC routine
rpc_mgmt_stop_server_listening() will not accept a binding without either
an endpoint or an object UUID (or both).  This happens EVEN IF an object UUID
was specified as part of the services attribute in the dcecp command that
created the server config object.
	The get_random_binding() routine should not ignore the object UUID
(if one is present); rather, it should set the object UUID in the binding
handle to one of the object UUIDs present for that service in the srvrexec
object.

	Here are some diffs; the line numbers are off, but are close enough...
The new variable is added at the end of the local variables for the routine
get_random_binding(), and the new code is added just after the binding has
been set in the binding handle:

536a537
>     uuid_t                    *o;
560a562,569
>
>     /* Pick a random object */
>     if (s->objects.count == 0) {
>       return;
>     }
>     i = RPC_RANDOM_GET(0, s->objects.count - 1);
>     o = &s->objects.list[i];
>     rpc_binding_set_object(*bh, o, st);

Note that this change is necessary to allow the workaround ("assigning a unique
object UUID for each server config object") mentioned in OT CR 12848.



CR Number                     : 12834
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12837
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : server/(lock.c and dce_lock.h)
Short Description             : lock management is broken.
Reported Date                 : 4/4/95
Found in Baseline             : 1.1
Found Date                    : 4/4/95
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1maint
Affected File(s)              : src/admin/dced/server/lock.c,
					     src/admin/dced/server/dce_lock.h
Sensitivity                   : public

[4/4/95 public]

dce_lock__write() allows the calling thread to acquire a write lock if
the following loop is exited --

    while (lock->state != lock_state_riw
        && lock->have_writer
        && pthread_equal(me, lock->riwer) != 0
        && lock->readers > 1) {
        BLOCK_OR_RETURN(lock, st);
    }

Unfortunately, this loop will exit if other threads still have read locks,
because lock->have_writer can be false (e.g., thread A acquires a read lock;
thread B acquires a RIW lock; thread B calls dce_lock__write()).  In fact,
this code would also allow a thread to acquire a write lock without having
previously called dce_lock__riw() (pthread_equal(me, lock->riwer) will be
0), etc., etc.
    The documentation in lock.h does not clearly describe the intent of the
lock manager, specifically whether a thread is obliged to call dce_lock__riw()
before calling dce_lock__write() -- but the code in lock.c defintely leans
toward this requirement.  I've got a version of lock.c that enforces this
requirement correctly -- mail me for details.
    The "write lock granted even when other threads still have read locks"
actually happened during execution of the functional/admin/dcecp TET test
suite (the "server" case); srvrexec_stop() grabs a read lock on sx_table.lock,
and then proceeds to call (via kill_server()) rpc_binding_set_auth_info(),
which ends up calling (indirectly) rpc_mgmt_inq_server_princ_name(), which
is an RPC call requiring an endpoint lookup, which is an RPC call to dced
itself, which is handled by dced_ept_map(), which calls dced_ept_lock_server(),
which grabs a write lock on sx_table.lock.  The original code grants the
write lock, setting readers=0, so when srvrexec_stop() frees the lock, the
thread encounters an assert failure which kills JUST THAT THREAD, not the
entire process, and also leaves the mutex locked on sx_table.lock, resulting
in deadlock later.

[04/05/95 public]
Yes the intent is that you get a RIW lock before you can get a write
lock.  Sounds like there are two bugs:  the ept_map should only
get a read lock (fixing that will be hard, I know); and your fix on
the locking code, which I'd be happy to review.

[04/13/95 public]

Here's a replacement dced/server/lock.c file that seems (visual inspection
only!) to be right.  Thanks, Karl!
/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
 * the full copyright text.
 * 
 */
/*
 * HISTORY
 * $Log:	c012834,v $
# Revision 1.9  96/01/24  16:08:56  root
# changed fields: Fixed In Baseline  
# 
# Revision 1.8  95/10/18  17:26:27  root
# changed fields:  new/changed/deleted note(s) [monzillo 10/17/95 ] [monzillo 10/18/95 ] [monzillo 10/17/95 ]
# 
# Revision 1.7  95/10/18  10:08:24  root
# changed fields:  new/changed/deleted note(s) [monzillo 10/18/95 ]
# 
# Revision 1.6  95/10/17  17:08:33  root
# changed fields: Inter-dependent CRs  Subcomponent Name   new/changed/deleted note(s) [monzillo 10/6/95 ] [monzillo 10/17/95 ] [monzillo 6/10/95 ]
# 
# Revision 1.5  95/10/06  16:47:14  root
# changed fields: Affected File(s)   new/changed/deleted note(s) [monzillo 6/10/95 ]
# 
# Revision 1.4  95/09/12  18:43:29  root
# changed fields: Interest List CC  
# 
# Revision 1.3  95/04/13  10:31:14  root
# changed fields:  new/changed/deleted note(s) [rsalz 04/13/95 public]
# 
 * Revision 1.1.1.5  1995/04/06  03:41:15  karlz
 * 	Removed thread ID from debug messages; serviceability inserts the thread
 * 	ID anyways.
 *
 * Revision 1.1.1.4  1995/04/04  20:12:00  karlz
 * 	Just adjusted debug levels.
 * 	Component = dhd, subcomponent = locks,
 * 		level 1	: assert failures
 * 		level 2 : lock creation/deletion
 * 		level 3 : read,riw,write,unlock
 * 
 * Revision 1.1.1.3  1995/04/04  19:20:55  karlz
 * 	Fixed lock management (see OT CR 12834).  Original code would grant a write
 * 	lock even if threads still held read locks.
 * 
 * Revision 1.1.1.2  1995/04/04  18:23:11  karlz
 * 	DCE for Digital UNIX: populate from OSF DCE R1.1
 * 
 * Revision 1.1.2.8  1994/09/26  17:49:21  rsalz
 * 	Convert to true SVC functions (OT CR 11725).
 * 	[1994/09/26  17:12:17  rsalz]
 * 
 * Revision 1.1.2.7  1994/08/03  20:36:18  rsalz
 * 	Fix OT CR 11506.
 * 	[1994/08/03  20:32:24  rsalz]
 * 
 * Revision 1.1.2.6  1994/08/02  05:45:34  rsalz
 * 	Undo in-line version of dce_lock_justwrite.
 * 	[1994/08/02  05:36:20  rsalz]
 * 
 * Revision 1.1.2.5  1994/07/05  16:03:23  rsalz
 * 	Add dce_lock_justwrite (part of OT CR 11173).
 * 	[1994/07/05  15:57:18  rsalz]
 * 
 * Revision 1.1.2.4  1994/06/09  16:03:06  devsrc
 * 	cr10892 - fix copyright
 * 	[1994/06/09  15:48:44  devsrc]
 * 
 * Revision 1.1.2.3  1994/05/10  20:15:13  rsalz
 * 	Cleanup and more functionality
 * 	[1994/05/10  20:10:43  rsalz]
 * 
 * Revision 1.1.2.2  1994/04/28  18:38:45  rsalz
 * 	Clean up some compiler warnings; remove dead code.
 * 	[1994/04/28  18:37:53  rsalz]
 * 
 * Revision 1.1.2.1  1994/04/27  19:41:35  rsalz
 * 	Add dce_assert, set up headers right
 * 	[1994/04/27  19:38:06  rsalz]
 * 
 * 	Add lock manager.
 * 	[1994/04/27  19:00:21  rsalz]
 * 
 * $EndLog$
 */

/*
** Lock manager.  Based on code by Jonathan E. Chinitz <jec@isoft.com>.
*/
#include <dcedimpl.h>


/*
**  The lock datatype.
*/
typedef struct lock_where_s_t {
    char	*file;
    int		line;
} lock_where_t;

struct dce_lock_s_t {
    pthread_mutex_t	m;
    pthread_cond_t	cv;
    int			readers;
    enum {
	lock_state_nonexistent=0, lock_state_none, lock_state_read, lock_state_riw, lock_state_write
    }			state;
    pthread_t		writer;		/* who is the writer */
    lock_where_t	the_creator;
    lock_where_t	the_writer;
};

static char	*stateNames[] = {
	"nonexistent",
	"free",
	"read",
	"riw",
	"write"
};

/*
**  Concurrency convenience macros.
*/
#define LOCK_OR_RETURN(l, st)		\
    if (pthread_mutex_lock(&l->m) < 0) { \
	*st = dced_s_mutex_lock_failed; \
	return; \
    }
#define UNLOCK_OR_RETURN(l, st)		\
    if (pthread_mutex_unlock(&l->m) < 0) { \
	*st = dced_s_mutex_unlock_failed; \
	return; \
    }
#define BLOCK_OR_RETURN(l, st)		\
    if (pthread_cond_wait(&l->cv, &l->m) < 0) { \
	 *st = dced_s_cond_wait_failed; \
	 return; \
    }
#define WAKE_ONE_OR_RETURN(l, st)	\
    if (pthread_cond_signal(&l->cv) < 0) { \
	 *st = dced_s_cond_signal_failed; \
	 return; \
    }
#define WAKE_ALL_OR_RETURN(l, st)	\
    if (pthread_cond_broadcast(&l->cv) < 0) { \
	 *st = dced_s_cond_bcast_failed; \
	 return; \
    }


/*
**  Create a lock.
*/
void
dce_lock__create(
    dce_lock_t		*lock,
    error_status_t	*st,
    char		*file,
    int			line
)
{
    dce_lock_t		new;

    if ((new = (dce_lock_t)malloc(sizeof *new)) == NULL) {
	*st = dced_s_no_memory;
	return;
    }

    if (pthread_mutex_init(&new->m, pthread_mutexattr_default) < 0) {
	free(new);
	*st = dced_s_mutex_init_fail;
	return;
    }
    if (pthread_cond_init(&new->cv, pthread_condattr_default) < 0) {
	pthread_mutex_destroy(&new->m);
	free(new);
	*st = dced_s_cond_init_fail;
	return;
    }

    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug2,
	"\n%s:%d\nLOCK: 0x%x (%s): create\n",
	file, line, new, stateNames[ lock_state_nonexistent ]));

    new->readers = 0;
    new->state = lock_state_none;
    new->the_creator.file = file;
    new->the_creator.line = line;
    *lock = new;

    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug2,
	"\nLOCK: 0x%x (--> %s)\n",
	new, stateNames[ new->state ]));

    *st = error_status_ok;
}


/*
**  Free a lock.  Ignores failures.
*/
void
dce_lock__delete(
    dce_lock_t		lock,
    error_status_t	*st,
    char		*file,
    int			line
)
{
    /* The lock must be free in order to remove it! */
    if (lock->state != lock_state_none) {
        DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug1,
        "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): ERRONEOUS delete WHEN HELD\n",
        file, line, lock, stateNames[ lock->state ], lock->readers));

    }
    dce_assert(dhd_svc_handle, lock->state == lock_state_none);

    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug2,
        "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): delete\n",
        file, line, lock, stateNames[ lock->state ], lock->readers));

    pthread_mutex_destroy(&lock->m);
    pthread_cond_destroy(&lock->cv);
    free((char *)lock);

    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug2,
        "\nLOCK: 0x%x (--> %s)\n",
        lock, stateNames[ lock_state_nonexistent ]));

    *st = error_status_ok;
}


/*
**  Get a read-lock.
*/
void
dce_lock__read(
    dce_lock_t		lock,
    error_status_t	*st,
    char		*file,
    int			line
)
{
    LOCK_OR_RETURN(lock, st);

    /* Readers have to wait for the writer to finish */
    while (lock->state == lock_state_write) {
	BLOCK_OR_RETURN(lock, st);
    }

    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
        "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): read\n",
        file, line, lock, stateNames[ lock->state ], lock->readers));

    /* Increment the number of readers. If first reader, set state. */
    lock->readers++;
    if (lock->state == lock_state_none)
	lock->state = lock_state_read;

    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
        "\nLOCK: 0x%x (--> %s, nreaders = %d)\n",
        lock, stateNames[ lock->state ], lock->readers));

    UNLOCK_OR_RETURN(lock, st);

    *st = error_status_ok;
}


/*
** Get a read-with-intent-to-write lock.
*/
void
dce_lock__riw(
    dce_lock_t		lock,
    error_status_t	*st,
    char		*file,
    int			line
)
{
    LOCK_OR_RETURN(lock, st);

    /* Readers have to wait for the writer to finish. */
    while (lock->state == lock_state_write || lock->state == lock_state_riw) {
	BLOCK_OR_RETURN(lock, st);
    }

    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
        "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): riw\n",
        file, line, lock, stateNames[ lock->state ], lock->readers));

    /* Update state. */
    lock->the_writer.file = file;
    lock->the_writer.line = line;
    lock->readers++;
    lock->state = lock_state_riw;
    lock->writer = pthread_self();

    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
        "\nLOCK: 0x%x (--> %s, nreaders = %d)\n",
        lock, stateNames[ lock->state ], lock->readers));

    UNLOCK_OR_RETURN(lock, st);

    *st = error_status_ok;
}


void
dce_lock__write(
    dce_lock_t		lock,
    error_status_t	*st,
    char		*file,
    int			line
)
{
    pthread_t		me = pthread_self();

    LOCK_OR_RETURN(lock, st);

    /* One is only allowed to request write lock if one has previously
     * obtained a riw lock!  Note that this requires two tests;
     * 1) Verify that lock state is riw, and
     * 2) Verify that this is in fact the thread that owns the riw.
     */
    if ((lock->state != lock_state_riw) || !pthread_equal(me, lock->writer)) {
        DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug1,
	"\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): ERRONEOUS write WHEN NOT OWNER\n",
	file, line, lock, stateNames[ lock->state ], lock->readers));
    }
    dce_assert(dhd_svc_handle, ((lock->state == lock_state_riw) && pthread_equal(me, lock->writer)));

    /* Readers and Writers block. The only question here is if the state
     * was RIW and this is the owner of the lock and there are no other 
     * readers, then we can proceed to write. Otherwise we have to wait. */
    while (lock->readers > 1) {
	BLOCK_OR_RETURN(lock, st);
    }

    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
        "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): write\n",
        file, line, lock, stateNames[ lock->state ], lock->readers));

    /* The last riwer becomes a writer now. */
    lock->readers = 0;
    lock->state = lock_state_write;
    lock->writer = me;
    lock->the_writer.file = file;
    lock->the_writer.line = line;

    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
        "\nLOCK: 0x%x (--> %s, nreaders = %d)\n",
        lock, stateNames[ lock->state ], lock->readers));

    UNLOCK_OR_RETURN(lock, st);

    *st = error_status_ok;
}


void
dce_lock__justwrite(
    dce_lock_t		lock,
    error_status_t	*st,
    char		*file,
    int			line
)
{
    error_status_t	st2;

    dce_lock__riw(lock, st, file, line);
    if (*st == error_status_ok) {
	dce_lock__write(lock, st, file, line);
	if (*st != error_status_ok)
	    dce_lock__unlock(lock, &st2, file, line);
    }
}


void
dce_lock__unlock(
    dce_lock_t		lock,
    error_status_t	*st,
    char		*file,
    int			line
)
{
    pthread_t		me = pthread_self();

    LOCK_OR_RETURN(lock, st);

    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
        "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): unlock\n",
        file, line, lock, stateNames[ lock->state ], lock->readers));

    switch (lock->state) {
    case lock_state_none:
	/* The lock must be held in order to release it! */
	DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug1,
	"\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): ERRONEOUS unlock WHEN NOT HELD\n",
	file, line, lock, stateNames[ lock->state ], lock->readers));
	dce_assert(dhd_svc_handle, lock->state != lock_state_none);
	/* NOTREACHED */
    case lock_state_read:
	/* Decrement the readers. If zero, then only a writer might be
	 * sleeping on the cv, so wake it up. */
	lock->readers--;
	if (lock->readers == 0) {
	    WAKE_ONE_OR_RETURN(lock, st);
	    lock->state = lock_state_none;
	}
	break;
    case lock_state_riw:
	/* Decrement the readers. If zero, might be another RIW or a W so 
	 * must broadcast. If I was the owner of the lock, then unmark
	 * me and make the RIW lock a R lock. */
	lock->readers--;
	if (lock->readers == 0) {
	    /* If we're not the writer, this is an error! */
	    if (!pthread_equal( me, lock->writer )) {
		DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug1,
		"\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): ERRONEOUS unlock WHEN NOT RIWER\n",
		file, line, lock, stateNames[ lock->state ], lock->readers));
	    }
	    dce_assert(dhd_svc_handle, pthread_equal( me, lock->writer ));
	    WAKE_ALL_OR_RETURN(lock, st);
	    lock->state = lock_state_none;
	}
	else if (pthread_equal(me, lock->writer)) {
	    lock->state = lock_state_read;
	}
	break;
    case lock_state_write:
	/* Writer resets the lock and wakes up any RIW or R that might be
	 * sleeping. */
	/* If we're not the writer, this is an error! */
	if (!pthread_equal( me, lock->writer )) {
	    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug1,
	    "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): ERRONEOUS unlock WHEN NOT WRITER\n",
	    file, line, lock, stateNames[ lock->state ], lock->readers));
	}
	dce_assert(dhd_svc_handle, pthread_equal( me, lock->writer ));
	lock->readers = 0;
	lock->state = lock_state_none;
	WAKE_ALL_OR_RETURN(lock, st);
	break;
    }

    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
        "\nLOCK: 0x%x (--> %s, nreaders = %d)\n",
        lock, stateNames[ lock->state ], lock->readers));

    UNLOCK_OR_RETURN(lock, st);

    *st = error_status_ok;
}

void
dce_lock__hold_lock(
    dce_lock_t		lock,
    boolean32		*b,
    error_status_t	*st,
    char		*file,
    int			line
)
{
    *b = FALSE;
    LOCK_OR_RETURN(lock, st);

    switch (lock->state) {
    case lock_state_none:
    case lock_state_read:
	break;
    case lock_state_riw:
    case lock_state_write:
	*b = pthread_equal(pthread_self(), lock->writer);
	break;
    }

    UNLOCK_OR_RETURN(lock, st);

    *st = error_status_ok;
}

[10/6/95]

I tested with Karl's fix, and learned that at least scops.c line 234 calls
for a write lock without having acquired a riw. This causes an assertion
and a core dump of dced. I looked closed at the lock manager, and the best
I can figure The main advantaga of having this intermediate lock, is that in contrast to an
implementation
     * which would allow any read lock to be promoted, this implementation
     * requires that only the name of one special reader (special in that
     * its lock can be promoted) need be remembered (the reader is
remembered
     * in the writer field of the structure).

I am testing a fix that will relax the requirement for a riw befor a write
lock.

[10/17/95]

Karl pointed out that there are related changes in OT 12837 which must be
applied in order for his fix to work. Having applied the changes in 12837,
I made the following changes to Karl's fix for OT 12834. The result is a
lock manager which is able to promote a riw lock to a write lock (which
is desirable functionality for view serializability), but does not require
that a riw lock be acquired before acquiring a write lock. In making these
changes, I also noticed that 

	1. the use of pthread_equal in the lock descision
	making code, was subject to error, since the writer field of the lock
	structure was not being reset. To correct for this potential
	problem, I reinstitued the have_writer mechanism present in Jec's
	original implementation (see THIS_THREAD_IS_WRITER macro).

!!!	see notes [monzillo 10/18/95] this change has been reverted to it's
	original form, and removed form the enclosed diffs.

	2. I removed the dce_lock__justwrite function, and made a
        corresponding change in dce_lock.h such that existing calls
        to dce_lock_justwrite will result in calls to dce_lock__write.
	The future use of justwrite should be discouraged.

*** /project/dce/build/dce1.1/src/admin/dced/server/dce_lock.h  Mon Sep 26
13::19 1994
--- ./dce_lock.h        Mon Oct 16 11:52:00 1995
***************
*** 101,107 ****
  #define dce_lock_write(l,s)   \
        dce_lock__write(l, s, LOCK__FILE__, __LINE__)
  #define dce_lock_justwrite(l,s)       \
!       dce_lock__justwrite(l, s, LOCK__FILE__, __LINE__)
  #define dce_lock_unlock(l,s)  \
        dce_lock__unlock(l, s, LOCK__FILE__, __LINE__)
  #define dce_lock_hold_lock(l,b,s)     \
--- 101,107 ----
  #define dce_lock_write(l,s)   \
        dce_lock__write(l, s, LOCK__FILE__, __LINE__)
  #define dce_lock_justwrite(l,s)       \
!       dce_lock__write(l, s, LOCK__FILE__, __LINE__)
  #define dce_lock_unlock(l,s)  \
        dce_lock__unlock(l, s, LOCK__FILE__, __LINE__)
  #define dce_lock_hold_lock(l,b,s)     \
***************
*** 137,149 ****
  
  extern void dce_lock__write(
      dce_lock_t                        /* lock */,
-     error_status_t*           /* st */,
-     char*                     /* file */,
-     int                               /* line */
- );
- 
- extern void dce_lock__justwrite(
-     dce_lock_t                        /* lock */,
      error_status_t*           /* st */,
      char*                     /* file */,
      int                               /* line */
--- 137,142 ----

	3. In the unlock code for state riw, I noticed that the release
        of a riw lock while there are other readers would miss an opportunity
        to wake a thread waiting for the riw lock.

The following diff was performed against the implementation proposed by
Karl, note that of the 3 problems types of changes listed above, #1 is
by far the most significant. Also the fact that the implementation no
longer requires that a riw be acquired before acquiring a write lock,
should result in some increased efficiency.

!! change 1 was reverted, see notes [monzillo 10/18/95]

In addition to the changes recorded in the following diff, it occurred to
me that the scheduling alogorithm employed by the lock manager is
particularly unfair with respect to writers, such that it would be possible
for a succession of readers to affectively starve any thread wishing to
acquire a write lock. I spent some time trying to set up a test which
would demonstrate such an occurance, but was not able to do so.
I am including a second diff which will eliminate the potential for
writer starvation. In the event that someone else observes the problem,
or devises a test to demonstrate the problem, a fix will be at hand
(see WRITER STARVATION DIFF below).

*** lock.c.ot	Fri Oct  6 16:22:56 1995
--- lock.c.next	Wed Oct 18 12:05:30 1995
***************
*** 307,328 ****
  
      LOCK_OR_RETURN(lock, st);
  
!     /* One is only allowed to request write lock if one has previously
!      * obtained a riw lock!  Note that this requires two tests;
!      * 1) Verify that lock state is riw, and
!      * 2) Verify that this is in fact the thread that owns the riw.
       */
-     if ((lock->state != lock_state_riw) || !pthread_equal(me, lock->writer)) {
-         DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug1,
- 	"\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): ERRONEOUS write WHEN NOT OWNER\n",
- 	file, line, lock, stateNames[ lock->state ], lock->readers));
-     }
-     dce_assert(dhd_svc_handle, ((lock->state == lock_state_riw) && pthread_equal(me, lock->writer)));
  
!     /* Readers and Writers block. The only question here is if the state
!      * was RIW and this is the owner of the lock and there are no other 
!      * readers, then we can proceed to write. Otherwise we have to wait. */
!     while (lock->readers > 1) {
  	BLOCK_OR_RETURN(lock, st);
      }
  
--- 307,323 ----
  
      LOCK_OR_RETURN(lock, st);
  
!     /* a write lock may only be granted if all of the following are true.
!      * no other thread holds a read lock
!      * no thread holds a write lock (note that allowing the same thread to
!      *          reacquire a write lock will likely lead to problems when the
!      *          lock is released)
!      * no other thread holds a read_intent_to_write lock.
       */
  
!     while (lock->state == lock_state_read || lock->state == lock_state_write ||
! 	(lock->state == lock_state_riw && 
! 	(!pthread_equal(me, lock->writer) || lock->readers > 1))) {
  	BLOCK_OR_RETURN(lock, st);
      }
  
***************
*** 347,370 ****
  }
  
  
- void
- dce_lock__justwrite(
-     dce_lock_t		lock,
-     error_status_t	*st,
-     char		*file,
-     int			line
- )
- {
-     error_status_t	st2;
- 
-     dce_lock__riw(lock, st, file, line);
-     if (*st == error_status_ok) {
- 	dce_lock__write(lock, st, file, line);
- 	if (*st != error_status_ok)
- 	    dce_lock__unlock(lock, &st2, file, line);
-     }
- }
- 
  
  void
  dce_lock__unlock(
--- 342,347 ----
***************
*** 395,423 ****
  	 * sleeping on the cv, so wake it up. */
  	lock->readers--;
  	if (lock->readers == 0) {
- 	    WAKE_ONE_OR_RETURN(lock, st);
  	    lock->state = lock_state_none;
  	}
  	break;
      case lock_state_riw:
! 	/* Decrement the readers. If zero, might be another RIW or a W so 
! 	 * must broadcast. If I was the owner of the lock, then unmark
! 	 * me and make the RIW lock a R lock. */
  	lock->readers--;
! 	if (lock->readers == 0) {
! 	    /* If we're not the writer, this is an error! */
! 	    if (!pthread_equal( me, lock->writer )) {
! 		DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug1,
! 		"\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): ERRONEOUS unlock WHEN NOT RIWER\n",
! 		file, line, lock, stateNames[ lock->state ], lock->readers));
! 	    }
! 	    dce_assert(dhd_svc_handle, pthread_equal( me, lock->writer ));
! 	    WAKE_ALL_OR_RETURN(lock, st);
! 	    lock->state = lock_state_none;
  	}
! 	else if (pthread_equal(me, lock->writer)) {
! 	    lock->state = lock_state_read;
  	}
  	break;
      case lock_state_write:
  	/* Writer resets the lock and wakes up any RIW or R that might be
--- 372,402 ----
  	 * sleeping on the cv, so wake it up. */
  	lock->readers--;
  	if (lock->readers == 0) {
  	    lock->state = lock_state_none;
+ 	    WAKE_ONE_OR_RETURN(lock, st);
  	}
  	break;
      case lock_state_riw:
! 	/* Decrement the readers. If this thread was the holder of the riw
! 	 * lock, then select the new state according to the number of remaining
!          * readers (wake everybody else up, since this thread might have been
!          * blocking threads waiting for either a riw or a write lock).
!          * Otherwise, there better be at least 1 remaining reader;
!          * the holder of the riw lock.
! 	 */
  	lock->readers--;
! 	if (pthread_equal(me, lock->writer)) {
! 	    if (lock->readers == 0) lock->state = lock_state_none;
! 	    else lock->state = lock_state_read;
  	}
! 	else if (lock->readers == 0) {
!             DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug1,
!             "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): ERRONEOUS unlock WHEN NOT RIWER\n",
!             file, line, lock, stateNames[ lock->state ], lock->readers));
!             dce_assert(dhd_svc_handle, pthread_equal(lock->writer,me));
!             /* NOTREACHED */
  	}
+ 	WAKE_ALL_OR_RETURN(lock, st);
  	break;
      case lock_state_write:
  	/* Writer resets the lock and wakes up any RIW or R that might be
***************
*** 427,435 ****
  	    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug1,
  	    "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): ERRONEOUS unlock WHEN NOT WRITER\n",
  	    file, line, lock, stateNames[ lock->state ], lock->readers));
  	}
- 	dce_assert(dhd_svc_handle, pthread_equal( me, lock->writer ));
- 	lock->readers = 0;
  	lock->state = lock_state_none;
  	WAKE_ALL_OR_RETURN(lock, st);
  	break;
--- 406,413 ----
  	    DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug1,
  	    "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): ERRONEOUS unlock WHEN NOT WRITER\n",
  	    file, line, lock, stateNames[ lock->state ], lock->readers));
+ 	    dce_assert(dhd_svc_handle, pthread_equal( me, lock->writer ));
  	}
  	lock->state = lock_state_none;
  	WAKE_ALL_OR_RETURN(lock, st);
  	break;

WRITER STARVATION DIFF:

*** lock.c.next	Wed Oct 18 12:05:30 1995
--- lock.c.fix	Wed Oct 18 12:31:24 1995
***************
*** 89,94 ****
--- 89,96 ----
      pthread_mutex_t	m;
      pthread_cond_t	cv;
      int			readers;
+     unsigned32		short_cutting_readers;
+     unsigned32		waiting_writers;
      enum {
  	lock_state_nonexistent=0, lock_state_none, lock_state_read, lock_state_riw, lock_state_write
      }			state;
***************
*** 134,140 ****
--- 136,154 ----
  	 return; \
      }
  
+ /*
+ **  fairness threshold, the number of readers which may
+ **  short cut a waiting writer. This limit exists to insure that
+ **  in a highly utilized system, readers are not able to starve
+ **  (prevent them from ever acquiring the lock) out writers.
+ */
+ #define MAXIMUM_SHORT_CUTTING_READERS 9
  
+ #define FAIRNESS_THRESHOLD \
+     (lock->waiting_writers > 0 ? \
+        (MAXIMUM_SHORT_CUTTING_READERS + lock->waiting_writers)/ \
+         lock->waiting_writers : MAXIMUM_SHORT_CUTTING_READERS)
+ 
  /*
  **  Create a lock.
  */
***************
*** 170,175 ****
--- 184,191 ----
  	file, line, new, stateNames[ lock_state_nonexistent ]));
  
      new->readers = 0;
+     new->short_cutting_readers = 0;
+     new->waiting_writers = 0;
      new->state = lock_state_none;
      new->the_creator.file = file;
      new->the_creator.line = line;
***************
*** 230,246 ****
      int			line
  )
  {
      LOCK_OR_RETURN(lock, st);
  
!     /* Readers have to wait for the writer to finish */
!     while (lock->state == lock_state_write) {
! 	BLOCK_OR_RETURN(lock, st);
      }
  
!     DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
!         "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): read\n",
!         file, line, lock, stateNames[ lock->state ], lock->readers));
  
      /* Increment the number of readers. If first reader, set state. */
      lock->readers++;
      if (lock->state == lock_state_none)
--- 246,277 ----
      int			line
  )
  {
+     boolean32		delayed = FALSE;
+ 
      LOCK_OR_RETURN(lock, st);
  
!     /* Readers have to wait for the writer to finish, and should defer
!      * at some threshold to waiting writers to avoid writer starvation.
!      * This fairness policy is simply intended to eliminate the potential
!      * for readers to starve out writers. It will only come into play when
!      * readers are jumping in front of waiting writers. Once the threshold
!      * is reached, a writer will be the next to get the lock. After that
!      * the short cut counter is reset (see dce_lock_write).
!      */
! 
!     while (lock->state == lock_state_write || 
!         lock->short_cutting_readers > FAIRNESS_THRESHOLD) {
!         delayed = TRUE;
!         BLOCK_OR_RETURN(lock, st);
      }
  
!     if (!delayed && lock->waiting_writers > 0) lock->short_cutting_readers++;
  
+     DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
+ 	"\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d, cutters = %d): read\n",
+ 	file, line, lock, stateNames[ lock->state ], lock->readers,
+ 	lock->short_cutting_readers));
+  
      /* Increment the number of readers. If first reader, set state. */
      lock->readers++;
      if (lock->state == lock_state_none)
***************
*** 267,279 ****
      int			line
  )
  {
      LOCK_OR_RETURN(lock, st);
  
!     /* Readers have to wait for the writer to finish. */
!     while (lock->state == lock_state_write || lock->state == lock_state_riw) {
! 	BLOCK_OR_RETURN(lock, st);
      }
  
      DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
          "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): riw\n",
          file, line, lock, stateNames[ lock->state ], lock->readers));
--- 298,327 ----
      int			line
  )
  {
+     boolean32		delayed = FALSE;
+ 
      LOCK_OR_RETURN(lock, st);
  
!     /* At most one thread is allowed to hold a read-intent-to-write lock,
!      * and only when no other thread already holds a write lock.
!      * Note that this is the only kind of read lock which can subsequently
!      * be promoted to a write lock, but that does not mean that you need to
!      * acquire a riw lock in order to get a write lock. The main advantage
!      * of having this intermediate lock, is that in contrast to an implementation
!      * which would allow any read lock to be promoted, this implementation
!      * requires that only the name of one special reader (special in that
!      * its lock can be promoted) need be remembered (the reader is remembered
!      * in the writer field of the structure).
!      */
!    
!     while (lock->state == lock_state_write || lock->state == lock_state_riw ||
!         lock->short_cutting_readers > FAIRNESS_THRESHOLD) {
!         delayed = TRUE;
!         BLOCK_OR_RETURN(lock, st);
      }
  
+     if (!delayed && lock->waiting_writers > 0) lock->short_cutting_readers++;
+ 
      DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
          "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): riw\n",
          file, line, lock, stateNames[ lock->state ], lock->readers));
***************
*** 315,326 ****
--- 363,379 ----
       * no other thread holds a read_intent_to_write lock.
       */
  
+     lock->waiting_writers++;
+ 
      while (lock->state == lock_state_read || lock->state == lock_state_write ||
  	(lock->state == lock_state_riw && 
  	(!pthread_equal(me, lock->writer) || lock->readers > 1))) {
  	BLOCK_OR_RETURN(lock, st);
      }
  
+     lock->waiting_writers--;
+     lock->short_cutting_readers = 0;
+   
      DCE_SVC_DEBUG((dhd_svc_handle, dhd_s_lock, svc_c_debug3,
          "\n%s:%d\nLOCK: 0x%x (%s, nreaders = %d): write\n",
          file, line, lock, stateNames[ lock->state ], lock->readers));
***************
*** 368,379 ****
  	dce_assert(dhd_svc_handle, lock->state != lock_state_none);
  	/* NOTREACHED */
      case lock_state_read:
! 	/* Decrement the readers. If zero, then only a writer might be
! 	 * sleeping on the cv, so wake it up. */
  	lock->readers--;
  	if (lock->readers == 0) {
  	    lock->state = lock_state_none;
! 	    WAKE_ONE_OR_RETURN(lock, st);
  	}
  	break;
      case lock_state_riw:
--- 421,434 ----
  	dce_assert(dhd_svc_handle, lock->state != lock_state_none);
  	/* NOTREACHED */
      case lock_state_read:
!       /* Decrement the readers. If zero, then wake everybody up.
!        * Note that both readers and writers may be waiting (based on
!        * fairness algorithm).
!        */
  	lock->readers--;
  	if (lock->readers == 0) {
  	    lock->state = lock_state_none;
! 	    WAKE_ALL_OR_RETURN(lock, st);
  	}
  	break;
      case lock_state_riw:

[10/18/95]

The problem reported above as follows, was at least overstated.
I will correct the diff to remove the have_writer change.

	1. the use of pthread_equal in the lock descision
	making code, was subject to error, since the writer field of the lock
	structure was not being reset. To correct for this potential
	problem, I reinstitued the have_writer mechanism present in Jec's
	original implementation (see THIS_THREAD_IS_WRITER macro).

[10/18/95]

the preceeding diffs have been corrected.



CR Number                     : 12813
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : endpoint mapper
Short Description             : endpoint mapper not AES compliant
Reported Date                 : 3/3/95
Found in Baseline             : 1.1
Found Date                    : 3/3/95
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : admin/dced/server/oeops.c
Sensitivity                   : public

[3/3/95 public]

Ken Vineleaf at Digital found this problem.  

The fix (no I don't have a diff nor do I know who will be fixing this or
when) is that the map() routine in oeops.c should only fall into pass2 if
pass1 finds nothing.  NOT if pass1 finds less then max_ents.  Seiichi at
HP agrees with the diagnosis and fix.

This is also a problem in the map() routine of 1.0.3 rpcd (file
rpcdepdb.c).

Excerpts of Ken's mail follow.

>From vineleaf@microw.enet.dec.com Fri Feb 17 12:39:04 1995
  - 2 servers on the same node, both offering the same interface
  - Each server has its own object UUID
  - Both servers also register the NIL object UUID

After the first server (ServerA) starts up, the endpoint data base on the 
server node contains the following endpoints (among others):

  <object>         nil
  <interface id>   90E53BE1-2C49-11CE-80FE-08002B189651,1.0
  <string binding> ncacn_dnet_nsp:9.476[RPC40B0740001]
  <annotation>     ServerA

  <object>         36156366-41E4-11CE-82A2-08002B1BCD1E
  <interface id>   90E53BE1-2C49-11CE-80FE-08002B189651,1.0
  <string binding> ncacn_dnet_nsp:9.476[RPC40B0740001]
  <annotation>     ServerA

After the second server (ServerB) starts, the endpoint database contains the 
following endpoints (among others):

  <object>         nil
  <interface id>   90E53BE1-2C49-11CE-80FE-08002B189651,1.0
  <string binding> ncacn_dnet_nsp:9.476[RPC4270E20001]
  <annotation>     ServerB

  <object>         36156366-41E4-11CE-82A2-08002B1BCD1E
  <interface id>   90E53BE1-2C49-11CE-80FE-08002B189651,1.0
  <string binding> ncacn_dnet_nsp:9.476[RPC40B0740001]
  <annotation>     ServerA

  <object>         4C88B8FE-41FE-11CE-8C75-08002B1BCD1E
  <interface id>   90E53BE1-2C49-11CE-80FE-08002B189651,1.0
  <string binding> ncacn_dnet_nsp:9.476[RPC4270E20001]
  <annotation>     ServerB

Note that the endpoint with the nil object changed from ServerA to ServerB.
This is because our servers register their endpoints by calling rpc_ep_register
instead of calling rpc_register_no_replace.

Now suppose that I have a client that wants to call ServerA. It looks up ServerA
in the namespace, and it gets a partially bound handle to ServerA. The binding
handle contains ServerA's object UUID. To get ServerA's endpoint, the client
calls rpc_ep_resolve_binding resulting in an RPC to the endpoint mapper on the
target node. 

My question to you is: What endpoint(s) should the endpoint mapper return?

The algorithm described in the OSF DCE Application Development Guide (on 
page 14-29) states that when a client requests a non-nil object UUID, the
endpoint mapper searches for map elements with a matching object UUID and
interface UUID. If a match is found, then the endpoint is selected. It then 
goes on to say that if no map element contains both the object UUID and 
interface UUID, then the object UUID is discarded and the search starts over.

This suggests to me that the only endpoint that should be returned is this 
one:

  <object>         36156366-41E4-11CE-82A2-08002B1BCD1E
  <interface id>   90E53BE1-2C49-11CE-80FE-08002B189651,1.0
  <string binding> ncacn_dnet_nsp:9.476[RPC40B0740001]
  <annotation>     ServerA

In reality, however, the endpoint mapper is returning this endpoint *plus*
the endpoint for the matching interface and the nil object UUID. When 
rpc_ep_resolve_binding detects that more than one endpoint is returned, it
randomly chooses which endpoint it will use. This causes my client program
to randomly call ServerA or ServerB each time it is run, even though the
binding handle contains a handle to ServerA.

I have looked at the code (both the 1.0.3 and 1.1 code base) and found that
this is exactly what the code was designed to do. That is, is makes a two pass
search though the endpoint database whenever a non-nil object UUID is passed
to the endpoint mapper. The comments at the top of the code describe this
behavior. The code modules are RPCDEPDB.C and OEOPS.C, respectively. The
name of the routine that selects the endpoints is called "map".



CR Number                     : 12788
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : 
Short Description             : Logic mismatch between sec_clientd and dced
Reported Date                 : 1/30/95
Found in Baseline             : 1.1
Found Date                    : 1/30/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1maint
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/30/95 public]
The grp_override functional test was failing with an unexpected 
status code.   I belive the following is the fix that's needed,
based on looking at the previous roverride_get_group_info() code.


diff -c sv_rover.c@@/main/mdf_MOTHRA_3/0 sv_rover.c
*** sv_rover.c@@/main/mdf_MOTHRA_3/0    Mon Jan 30 09:30:49 1995
--- sv_rover.c  Mon Jan 30 10:05:28 1995
***************
*** 8,13 ****
--- 8,18 ----
  /*
   * HISTORY
   * $Log:	c012788,v $
# Revision 1.3  96/10/08  14:40:52  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 10/8/96 public]
# 
# Revision 1.2  95/08/15  15:14:23  root
# changed fields:  new/changed/deleted note(s) [karlz 08/15/95 public]
# 
# Revision 1.1  95/01/30  10:38:31  root
# new CR
# 
+  * Revision /main/mdf_MOTHRA_3/1  1995/01/30  15:09 UTC  mdf
+  *    Correction for CHFts14193.  When the roverride_get_group_info call was
+  *    moved from roverride.c to here, the functional test started failing 
+  *    due to the change in the logic when checking for number_members.
+  * 
   * Revision 1.1.2.9  1994/09/29  13:42:03  hasbrouc
   *    Fix group override support that broke when this code moved
   *    from roverride.c and was cleaned up
***************
*** 812,818 ****
        (*number_members)++;
      if (*number_members) {
        if (cursor->valid) {
!           if (cursor->handle > *number_members) {
                dce_lock_unlock(group_lock, st);
                *st = sec_rgy_no_more_entries;
                return;
--- 817,823 ----
        (*number_members)++;
      if (*number_members) {
        if (cursor->valid) {
!           if (cursor->handle >= *number_members) {
                dce_lock_unlock(group_lock, st);
                *st = sec_rgy_no_more_entries;
                return;

[08/15/95 public]

Isn't this a dup of 12786 ?

[10/8/96 public]

  Fix was submitted to 1.1 maintenance tree as the fix for OT12786



CR Number                     : 12786
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : sec_clientd
Short Description             : group override test fails
Reported Date                 : 1/27/95
Found in Baseline             : 1.1
Found Date                    : 1/27/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1maint
Affected File(s)              : dced/server/sv_rover.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/27/95 public]

                          DCE Problem Report
                  =================================


Submitter Information 
----------------------

Submitter Name:           rusman
Organization:             Hitachi Computer Products (America), Inc. 
Email Address:            osd.dce@hi.com rusman@hi.com 
Phone:                    617-890-0444 
DCE License Number:       1616-MDCE-92
Licensee's Defect Number: OSDqa10287


Hardware/Software Configuration
--------------------------------

Offering and Version:   DCEunk 
Component (Module):     dced/server/sv_rover.c 
Client Hardware:        see below 
Client Software:        see below 
Server Hardware:        see below 
Server Software:        see below 
Compiler:               n/a

Problem Description
--------------------

Severity Level: Severe

Date of First Occurrence: 01/03/95

One Line Description:
   OSDqa10287 group override test fails

Full Description:

Related-file::Modified 950103 by rusman:: Problem
 DESCRIPTION:
 
 The group override test fails reproducibly, as indicated in OSF's
 test results (OT 12676). We think we have a fix as follows (seems same
 as code in old sec_clientd...):
Related-file::Added 950103 by ddts:: /build/hiosfm/RCS/dce1.1/src/admin/dced/server/./sv_rover.c,v 7.5
 /build/hiosfm/RCS/dce1.1/src/admin/dced/server/./sv_rover.c,v 7.5
 rusman 1995/01/03 15:45:03 +10 -3
 Reason:  OSDqa10287 (new bug)
 fix boundary check causing test failure in group override tests
 
     *** /tmp/ci.12058..sv_rover.c.12093.1	Tue Jan  3 10:45:06 1995
     --- /tmp/sv_rover.c.12093.2	Tue Jan  3 10:45:06 1995
     ***************
     *** 18,27 ****
     --- 18,31 ----
        * src directory for the full copyright text.
        */
       /*
        * HISTORY
        * $Log:	c012786,v $
# Revision 1.2  96/10/08  14:35:14  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 10/8/96 public]
# 
# Revision 1.1  95/01/27  15:20:02  root
# new CR
# 
     +  * Revision 7.5  1995/01/03  15:45:03  rusman
     +  * Reason:  OSDqa10287 (new bug)
     +  * fix boundary check causing test failure in group override tests
     +  *
        * Revision 7.4  1994/11/04  21:06:51  rusman
        * remove use of stat_r
        *
        * Revision 7.3  1994/11/03  23:05:59  warnick
        * Rolled in beta2 changes.
     ***************
     *** 828,838 ****
           /* Parse the members. */
           for (m = group->members; m != NULL; m = m->next)
       	(*number_members)++;
           if (*number_members) {
       	if (cursor->valid) {
     ! 	    if (cursor->handle > *number_members) {
       		dce_lock_unlock(group_lock, st);
       		*st = sec_rgy_no_more_entries;
       		return;
       	    }
       	    count = cursor->handle;
     --- 832,846 ----
           /* Parse the members. */
           for (m = group->members; m != NULL; m = m->next)
       	(*number_members)++;
           if (*number_members) {
       	if (cursor->valid) {
     ! #ifdef hitm
     ! 	    if (cursor->handle >= *number_members) { 
     ! #else
     ! 	    if (cursor->handle > *number_members) { 
     ! #endif
       		dce_lock_unlock(group_lock, st);
       		*st = sec_rgy_no_more_entries;
       		return;
       	    }
       	    count = cursor->handle;

[10/8/96 public]

  Fix was submitted to 1.1 maintenance tree.

./admin/dced/server/sv_rover.c
Comparing revision 1.1.2.9 with revision 1.1.6.1.
***************
*** 812,818 ****
        (*number_members)++;
      if (*number_members) {
        if (cursor->valid) {
!           if (cursor->handle > *number_members) {
                dce_lock_unlock(group_lock, st);
                *st = sec_rgy_no_more_entries;
                return;
--- 816,822 ----
        (*number_members)++;
      if (*number_members) {
        if (cursor->valid) {
!           if (cursor->handle >= *number_members) {    /* OT 12786 */
                dce_lock_unlock(group_lock, st);
                *st = sec_rgy_no_more_entries;
                return;



CR Number                     : 12733
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : 
Short Description             : Remove -g from Makefiles
Reported Date                 : 10/26/94
Found in Baseline             : 1.1b19
Found Date                    : 10/26/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/26/94 public]
From Rob Stanzel.  Remove the -g in:

admin/dced/server/Makefile:
    # Remove this line when all the bugs are gone:
    CC_OPT_LEVEL = -g

and admin/dced/api/Makefile:

    # compiler flags
    CFLAGS                  = ${${TARGET_MACHINE}_CFLAGS}  \
			      ${STRICT_COMPILER_WARNINGS} -g



CR Number                     : 12701
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dced
Subcomponent Name             : 
Short Description             : dced srvrconf test fails
Reported Date                 : 10/21/94
Found in Baseline             : 1.1b22
Found Date                    : 10/21/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/21/94 public]

The following failures were found in the journal file:

...
520|0 1 18929 1 1|dced_server_create_1, Assertion 01(A):
520|0 1 18929 1 2|When a srvrconf dced binding handle is supplied to
520|0 1 18929 1 3|dced_server_create along with the server object,
520|0 1 18929 1 4|its entry will be created and the status is set to error_statu
s_ok.
520|0 1 18929 1 5|enter: dced_server_create
520|0 1 18929 1 6|leave: dced_server_create 289255630
520|0 1 18929 1 7|dced_server_create failed:
520|0 1 18929 1 8|dced_util_printerr: printing text for status = 289255630
520|0 1 18929 1 9|Cannot create object; already exists (dce / dhd)
220|0 1 1 14:21:21|FAIL


There are also several UNRESOLVED tet codes:

...
520|1 1 18930 1 1|dced_server_delete_1, Assertion 01(A):
520|1 1 18930 1 2|When a srvrconf dced binding handle is supplied to
520|1 1 18930 1 3|dced_server_delete along with the server object id,
520|1 1 18930 1 4|its entry will be deleted and the status is set to error_statu
s_ok.
520|1 1 18930 1 5|dced_server_create failed:
520|1 1 18930 1 6|dced_util_printerr: printing text for status = 289255630
520|1 1 18930 1 7|Cannot create object; already exists (dce / dhd)
220|1 1 2 14:21:24|UNRESOLVED
...
10|2 /ts/api/server_mod_attr 14:21:25|TC Start, scenario ref 133-1
15|2 1.10 3|TCM Start
520|2 0 18931 1 1|dced_server_create failed:
520|2 0 18931 1 2|dced_util_printerr: printing text for status = 289255630
520|2 0 18931 1 3|Cannot create object; already exists (dce / dhd)
400|2 1 1 14:21:27|IC Start
200|2 1 14:21:27|TP Start
520|2 1 18931 1 1|dced_server_modify_attributes_1, Assertion 01(A):
520|2 1 18931 1 2|When a srvrconf dced binding handle is supplied to
520|2 1 18931 1 3|dced_server_modify_attributes along with the server object,
520|2 1 18931 1 4|its entry will be created and the status is set to error_statu
s_ok.
220|2 1 2 14:21:28|UNRESOLVED
...
520|2 3 18931 1 1|dced_server_modify_attributes_3, Assertion 02(A):
520|2 3 18931 1 2|When a srvrconf dced binding handle is supplied to
520|2 3 18931 1 3|dced_server_modify_attributes along with a non-existant server
 object id,
520|2 3 18931 1 4|dced_s_not_found is returned.
220|2 3 2 14:21:28|UNRESOLVED

[10/20/94 public]
I can understand why this is giving you problems.

  1. Unlike the dcecp tests, the dced *require* you to be dce_logged'in as
     cell_admin
  2. They don't clean up well if they fail.  So, if they FAIL once, you're
     probably stuck until you do manual cleanup.  In the case of srvrconf,
     do a dcecp -c server cat and look for something with
     'dced_test_server' in the name.  If there, do a dcecp -c server del
     to get rid of it.  Then dce_login cell_admin and re-run.

[10/20/94 public]
I can see the "manual cleanup" as a workaround but not a permanent fix.
Why cannot we do a "could-be-wasted-cleanup" in IC setup procedure to
cleanup the possble mess left over by a possible failure?

[10/20/94/public]
We could and we should be I doubt this will be given UHYP status at this
point. I will ask Susan/mpt/sally about it.



CR Number                     : 12578
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : api fvt test
Short Description             : dced_g_uuid_fileattr is redefined in api fvt tests
Reported Date                 : 10/11/94
Found in Baseline             : 1.1
Found Date                    : 10/11/94
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 1.1maint
Affected File(s)              : dtapi_utils.c
Sensitivity                   : public

[10/11/94 public]
dced_g_uuid_fileattr is redefined in dtapi_utils.c. The fix is
to remove the definition.

[11/14/95 public]
----------BEGIN SUBMISSION REQUEST-----------------------
OT CR #:     12578

OT Summary:      redefinition of dced_g_uuid_fileattr in dced tests

Components:      test / dced

Fix summary:     Remove redefinition 

Files modified:  dtapi_utils.c

How tested:     code review, compile and link on hp800

Platforms:    all

Tested against: 1.1GA + unintegrated + Warranty Patch

How to verify:   Code review

Diff:           

*** dtapi_utils.c       Sun Oct 29 17:36:01 1995
--- /u0/sandboxes/bhandaru/ot12578/link/src/test/functional/admin/dced/ts/api/dtapi_utils.c     Fri Sep 30 18:55:41 1994
***************
*** 72,80 ****
  #include <dtapi_1_srvr.h>
  
  #define         CONFIG_NM       (dced_string_t)"/config/"
! 
! /* Defined in src/dced/api/dced_data.c */
! extern uuid_t dced_g_uuid_fileattr;
  
  /* from the idl file */
  uuid_t DTAPI_IF_1_UUID  = { /* 002d2117-7062-1dd2-a9bb-0000c03cd04c */
--- 72,81 ----
  #include <dtapi_1_srvr.h>
  
  #define         CONFIG_NM       (dced_string_t)"/config/"
! uuid_t dced_g_uuid_fileattr = { /* 008b47dd-6ec9-1d6a-9ac7-0000c09ce054 */
!     0x008b47dd, 0x6ec9, 0x1d6a, 0x9a, 0xc7,
!     {0x00, 0x00, 0xc0, 0x9c, 0xe0, 0x54}
! };
  
  /* from the idl file */
  uuid_t DTAPI_IF_1_UUID  = { /* 002d2117-7062-1dd2-a9bb-0000c03cd04c */

--------END SUBMISSION REQUEST-------------------



CR Number                     : 12503
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : 
Short Description             : need to include stdio.h to pick up FILE type
Reported Date                 : 10/5/94
Found in Baseline             : 1.1
Found Date                    : 10/5/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/5/94 public]

The file dce_server_sec.c needs to include stdio.h to pick up the
FILE typedef.  This file will not compile with the ANSI compiler
on DEC OSF/1 AXP unless stdio.h is included.

[10/05/94 public]
This is arguably a DEC OSF/1 threads porting bug.  Doesn't pthread.h
include cma.h which includes stdio.h?  Trivial tho the change may be
it is almost definitely way too late, but I'll see.



CR Number                     : 12470
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dced
Subcomponent Name             : servers
Short Description             : add "who started you"
Reported Date                 : 10/3/94
Found in Baseline             : 1.1
Found Date                    : 10/3/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/3/94 public]
I think it would be useful if, when dced started a server, it passed
down the UUID of the principal that issued the srvrconf_start call.
It would pass a NIL uuid if dced itself started the server (e.g., because
it's a boot-time startup).

[10/03/94 public]
Oops, meant to create this as deferred.



