CR Number                     : 12998
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : cm
Short Description             : panic due to bad uniquifier in dcache entry
Reported Date                 : 8/2/95
Found in Baseline             : 1.0.3
Found Date                    : 8/2/95
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : file/cm/cm_dcache.c
Sensitivity                   : public

[8/2/95 public]

A panic with string "dcache hc" was observed.  The dcache entry in question
had -1 in the f.fid.Unique field.  From this we infer that there had earlier
been a race:

- Process A was in MarkBadSCache and setting an scp's Unique to -1.
- Process B was in GetDCache, and doing the sequence:
   (1) use scp's fid to compute dc hash function;
   (2) get dcp;
   (3) copy scp's fid to dcp's fid.
While B was sleeping in step (2), A did its thing.  So the dcp ended up with
a Unique of -1, but was hashed as if it had some other Unique.  Thus a later
call to FlushDCache could not find it on the hash chain that it should have
been on.

In the long term, there is a fundamental weakness in GetDCache, which is
repeatedly accessing the scp without having it locked.  This is addressed by
bug number 4863.

In the short term, we can eliminate this panic by fixing the dc hash function
to ignore the scp's Unique.  We likewise fix the dv hash function, which would
have the same problem.

More...

Delta bwl-db4865-constant-fid-in-getdcache 1.1

Note that another delta with this number was created, but then defuncted.
Our original plan was to change the hash functions to not use the uniquifier,
but it was pointed out that this would cause a serious performance problem
(the uniquifier was added to the hash functions for precisely this reason).
So instead, we modified GetDCache to use a local copy of the fid.  The basic
problem of using the scache entry's fid without locking the scache entry is
not addressed by this; see bug # 4863.

More...

This delta has been reviewed and a CM with this delta has been smoke-tested,
but the delta itself has not been tested.  The bug was found by heavy stress
during system test.

[8/3/95 public]

Delta: bwl-db4865-constant-fid-in-getdcache
Change: file/cm/cm_dcache.c from 4.346 to 4.352
*** file/cm/cm_dcache.c
--- 4.352	1994/01/20 21:18:52
***************
*** 672,677 ****
--- 672,678 ----
      long byteOffset;
  {
      long index, chunk;
+     afsFid fid;
      register struct cm_dcache *dcp;
      register long i;
  
***************
*** 684,695 ****
  	chunk = byteOffset;
      else
  	chunk = cm_chunk(byteOffset);
!     i = DC_CHASH(&scp->fid, chunk);		/* Hash on [fid, chunk] */
      lock_ObtainWrite(&cm_dcachelock);
    retry:
      for (index = cm_dchashTable[i]; index != DC_NULLIDX;) {
  	dcp = cm_GetDSlot(index, (struct cm_dcache *)0);
! 	if (!FidCmp(&dcp->f.fid, &scp->fid) && chunk == dcp->f.chunk) {
  	    lock_ReleaseWrite(&cm_dcachelock);
  	    break;		/* leaving refCount high for caller */
  	}
--- 685,697 ----
  	chunk = byteOffset;
      else
  	chunk = cm_chunk(byteOffset);
!     fid = scp->fid;			/* structure assignment */
!     i = DC_CHASH(&fid, chunk);	/* Hash on [fid, chunk] */
      lock_ObtainWrite(&cm_dcachelock);
    retry:
      for (index = cm_dchashTable[i]; index != DC_NULLIDX;) {
  	dcp = cm_GetDSlot(index, (struct cm_dcache *)0);
! 	if (!FidCmp(&dcp->f.fid, &fid) && chunk == dcp->f.chunk) {
  	    lock_ReleaseWrite(&cm_dcachelock);
  	    break;		/* leaving refCount high for caller */
  	}
***************
*** 739,745 ****
  	/* 
  	 * Fill in the newly-allocated dcache record. 
  	 */
! 	dcp->f.fid = scp->fid;
  	hones(dcp->f.versionNo);		/* invalid value */
  	hzero(dcp->f.tokenID);			/* invalid value */
  	dcp->f.chunk = chunk;
--- 741,747 ----
  	/* 
  	 * Fill in the newly-allocated dcache record. 
  	 */
! 	dcp->f.fid = fid;
  	hones(dcp->f.versionNo);		/* invalid value */
  	hzero(dcp->f.tokenID);			/* invalid value */
  	dcp->f.chunk = chunk;
***************
*** 750,756 ****
  	 */
  	dcp->f.hcNextp = cm_dchashTable[i];	
  	cm_dchashTable[i] = dcp->index;
! 	i = DC_VHASH(&scp->fid);
  	dcp->f.hvNextp = cm_dvhashTable[i];
  	cm_dvhashTable[i] = dcp->index;
  	dcp->f.states = 0;
--- 752,758 ----
  	 */
  	dcp->f.hcNextp = cm_dchashTable[i];	
  	cm_dchashTable[i] = dcp->index;
! 	i = DC_VHASH(&fid);
  	dcp->f.hvNextp = cm_dvhashTable[i];
  	cm_dvhashTable[i] = dcp->index;
  	dcp->f.states = 0;
***************
*** 795,800 ****
--- 797,803 ----
      long needed;	/* how many chunks we need */
      long code;
      long index;
+     afsFid fid;
      register struct cm_dcache *dcp;
  
      /* lock a global mutex indicating that we're trying to get one
***************
*** 804,809 ****
--- 807,813 ----
       * running under high load.
       */
      needed = last - first;
+     fid = scp->fid;
      lock_ObtainWrite(&cm_getdcachelock);
      lock_ObtainWrite(&cm_dcachelock);
      while (1) {
***************
*** 833,839 ****
  		    /* 
  		     * Fill in the newly-allocated dcache record. 
  		     */
! 		    dcp->f.fid = scp->fid;
  		    hones(dcp->f.versionNo);	/* invalid value */
  		    hzero(dcp->f.tokenID);	/* invalid value */
  		    dcp->f.chunk = i;
--- 837,843 ----
  		    /* 
  		     * Fill in the newly-allocated dcache record. 
  		     */
! 		    dcp->f.fid = fid;
  		    hones(dcp->f.versionNo);	/* invalid value */
  		    hzero(dcp->f.tokenID);	/* invalid value */
  		    dcp->f.chunk = i;
***************
*** 842,851 ****
  		    /* 
  		     * Now add to the two hash chains 
  		     */
! 		    index = DC_CHASH(&scp->fid, i);
  		    dcp->f.hcNextp = cm_dchashTable[index];
  		    cm_dchashTable[index] = dcp->index;
! 		    index = DC_VHASH(&scp->fid);	/* and per-file hash */
  		    dcp->f.hvNextp = cm_dvhashTable[index];
  		    cm_dvhashTable[index] = dcp->index;
  		    dcp->f.states = 0;
--- 846,855 ----
  		    /* 
  		     * Now add to the two hash chains 
  		     */
! 		    index = DC_CHASH(&fid, i);
  		    dcp->f.hcNextp = cm_dchashTable[index];
  		    cm_dchashTable[index] = dcp->index;
! 		    index = DC_VHASH(&fid);	/* and per-file hash */
  		    dcp->f.hvNextp = cm_dvhashTable[index];
  		    cm_dvhashTable[index] = dcp->index;
  		    dcp->f.states = 0;



CR Number                     : 12997
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : dfs
Subcomponent Name             : episode
Short Description             : panic in exec'ing from locally mounted Episode
Reported Date                 : 8/2/95
Found in Baseline             : 1.0.3
Found Date                    : 8/2/95
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : file/episode/vnops/efs_vnodeops.c
Sensitivity                   : public

[8/2/95 public]

From Transarc:

I did the following sequence on a Solaris machine:

 - (DFS exporting an Episode fileset)
   copy an executable into DFS
 - execute it
 - locally mount the fileset
 - try to execute the same executable via the local path

There was a panic.  The problem was traceable to the fact that the vnode of
the executable had a null v_vfsp field.  This in turn was because, when
efs_lookup gets a vnode from the dnlc, it doesn't update the vnode's v_vfsp;
thus, vnodes that are created by the exporter and put into the dnlc, and
then retrieved from the dnlc on behalf of the local user, don't have proper
vfs pointers as they would if they had been created on behalf of the local
user (or if they had not been in the dnlc).

This is a Sun-only bug since our other platforms have only stubs for the
dnlc calls.  It should be applicable to the Solaris 2.2 release as well as
the Solaris 2.3 release that I am currently testing.

More....

Delta bwl-db4850-update-vfsp 1.1.

The validation procedure is as suggested in the bug description:
  - run an executable in DFS;
  - mount the fileset locally and immediately run the same executable via
      the local path.
If the second step causes a panic, you lose.

[8/3/95 public]

Delta: bwl-db4850-update-vfsp
Change: file/episode/vnops/efs_vnodeops.c from 4.609 to 4.614
*** file/episode/vnops/efs_vnodeops.c
--- 4.614	1994/01/18 21:14:04
***************
*** 49,55 ****
  #endif /* !KERNEL */
  
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012997,v 1.3 96/01/23 13:36:57 root Exp $")
  
  /*
   * We follow the conventions of the original Sun vfs/vnode interface:
--- 49,55 ----
  #endif /* !KERNEL */
  
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012997,v 1.3 96/01/23 13:36:57 root Exp $")
  
  /*
   * We follow the conventions of the original Sun vfs/vnode interface:
***************
*** 855,865 ****
--- 855,867 ----
      struct epif_status fstat;		/* file status for access checking */
      epi_volFileId_t efid;		/* fid for entry */
      struct evnode *devp;		/* directory evnode */
+     struct osi_vfs *vfsp;		/* vfs pointer of devp */
      struct evnode *evp = NULL;		/* entry vnode */
      struct vnode *vp;
  
      devp = VTOEV(dvp);
      EV_DEPHANTOM (devp);
+     vfsp = EVTOVFSP (devp);
  
      /* Sanity check -- is vnode a directory? */
      if (!EV_ISDIR (devp)) {
***************
*** 912,917 ****
--- 914,921 ----
      vp = osi_dnlc_lookup(dvp, name);
      if (vp != NULL) {
  	evp = VTOEV(vp);
+ 	if (!EPI_ISNULLVFSP (vfsp))
+ 	    osi_vSetVfsp(vp, vfsp);
  	goto out1;
      }
  
***************
*** 934,940 ****
      }
  
      /* Turn the fid into a vnode */
!     code = vnm_FindVnode (&efid, devp->vd_volp, EVTOVFSP (devp), &evp);
      if (code) {
  	icl_Trace4(efs_iclSet, EFS_TRACE_LOOKUP_FIDTOVNODE,
  		   ICL_TYPE_LONG, efid.index,
--- 938,944 ----
      }
  
      /* Turn the fid into a vnode */
!     code = vnm_FindVnode (&efid, devp->vd_volp, vfsp, &evp);
      if (code) {
  	icl_Trace4(efs_iclSet, EFS_TRACE_LOOKUP_FIDTOVNODE,
  		   ICL_TYPE_LONG, efid.index,



CR Number                     : 12996
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : dfsbind
Short Description             : dfsbind core dumped
Reported Date                 : 8/2/95
Found in Baseline             : 1.0.3
Found Date                    : 8/2/95
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : auth_helper.c
Sensitivity                   : public

[8/2/95 public]

From Transarc:

SYNOPSIS: dfsbind core dumped.

Well I have cranked  a 3 machine cell.

Reckless server
montana, and testlab22 are client and file exprtest

I I was able to access dfs from all machines in the cell.   Then I got
a connection time out for /: on monatan.   A few minutes later I got a
connecttion time out on testlab22.   At this point I was still able to
access dfs on reckless.  Then a few minutes later DFSBIND core dumped.

More ....

here's the DBX data.

detected a multithreaded program
t@11 (l@4) terminated by signal SEGV (no mapping at the fault address)
(dbx) where
=>[1] strcmp(0xffdba0d4, 0x245f2c, 0x1b6214, 0x0, 0x41fffff8, 0x2f2e2e2e), at 0x
ef256194
  [2] find_context_cache(pag = 1107296248, server = 0x245f2c "/.../reckless.dce.
transarc.com/hosts/reckless/dfs-server"), line 294 in "/afs/transarc.com/project
/alpine/dev/rel/09.028/src/security/helper/auth_helper.c"
  [3] get_context_from_pag(pag = 1107296248, euid = 0, server = 0x245f2c "/.../r
eckless.dce.transarc.com/hosts/reckless/dfs-server", login_context = 0xee9bdb58,
 st = 0xee9bdb6c), line 456 in "/afs/transarc.com/project/alpine/dev/rel/09.028/
src/security/helper/auth_helper.c"
  [4] cred_from_cred_rep(credrep = 0xee9bdbe4, cred = 0xee9bdbfc, cred_context =
 0xee9bdbe0, cache_slot = 0xee9bdbdc), line 617 in "/afs/transarc.com/project/al
pine/dev/rel/09.028/src/security/helper/auth_helper.c"
  [5] handle_sec_krb_get_cred(inptr = 0x245f6d "/dfs-server", inlen = 81, outbuf
 = 0x246f1c ""), line 749 in "/afs/transarc.com/project/alpine/dev/rel/09.028/sr
c/security/helper/auth_helper.c"
  [6] do_auth_request(inptr = 0x245f20 x", inlen = 81, outbuf = 0x246f1c "", out
size = 0x245f0c), line 1043 in "/afs/transarc.com/project/alpine/dev/rel/09.028/
src/security/helper/auth_helper.c"
  [7] ProcessRequest(req = 0x245f04), line 386 in "/afs/transarc.com/project/alp
ine/dev/rel/09.028/src/file/dfsbind/main_helper.c"
  [8] service_thread(addr = 0x1b4f70), line 280 in "/afs/transarc.com/project/al
pine/dev/rel/09.028/src/file/dfsbind/main_helper.c"
  [9] myStartRoutine(tcb = 0x250070), line 1135 in "/afs/transarc.com/project/al
pine/dev/rel/09.028/src/sol_pth/pthread.c"
  [10] _thread_start(0x250070, 0x0, 0x0, 0x0, 0x0, 0x0), at 0xef2dd68c
(dbx) down
dbx: Already at the bottom call level
(dbx) up
Current function is find_context_cache
  294               (context_cache[i].discard == 0)) {
(dbx) print server
server = 0x245f2c "/.../reckless.dce.transarc.com/hosts/reckless/dfs-server"
(dbx) print i
i = 1
(dbx) print context_cache[0]
context_cache[0] = {
    pag            = 4294967295
    euid           = 0
    refcount       = '\0'
    valid          = '^A'
    cred_valid     = '^A'
    discard        = '\0'
    context        = 0x25dd60
    credrep        = {
        pag         = 4294967295
        euid        = 0
        server_name = 0x268050 "/.../reckless.dce.transarc.com/hosts/reckless/df
s-server"
        authn_level = 4
        authz_proto = 2
        expiration  = 758397534
    }
    cred           = 0x268298
    tstamp         = 11
    cc_entry_mutex = 0x200b00
}
(dbx) print context_cache[1]
context_cache[1] = {
    pag            = 1107296248
    euid           = 5083
    refcount       = '\0'
    valid          = '\0'
    cred_valid     = '\0'
    discard        = '\0'
    context        = (nil)
    credrep        = {
        pag         = 1107296248
        euid        = 5083
        server_name = (nil)
        authn_level = 4
        authz_proto = 2
        expiration  = 758398043
    }
    cred           = (nil)
    tstamp         = 14
    cc_entry_mutex = 0x200f50
}
(dbx)

Delta: cfe-4842-dfsbind-coredump-on-namemanip 1.2

[8/3/95 public]

RCS file: RCS/auth_helper.c,v
retrieving revision 9.5
retrieving revision 9.7
diff -c -r9.5 -r9.7
*** /tmp/,RCSt1a15980	Thu Aug  3 12:45:14 1995
--- /tmp/,RCSt2a15980	Thu Aug  3 12:45:15 1995
***************
*** 2,7 ****
--- 2,28 ----
   * @TRANSARC_COPYRIGHT@
   *
   * $TALog: auth_helper.c,v $
+  * Revision 9.6  1994/01/12  20:29:28  cfe
+  * Core dump from passing a null to strcmp()
+  *
+  * Looks like it's because it was calling strcmp() before checking whether a
+  * local context was supposed to be valid or not.
+  * [from r9.5 by delta cfe-4842-dfsbind-coredump-on-namemanip, r1.1]
+  *
+  * Revision 9.5  1993/12/25  05:20:25  bww
+  * Picked up dfsbind memory leak workaround (OT9619).
+  *
+  * Modified find_context_cache() and add_context_cache()
+  * to check for a matching PAG and server as the criteria
+  * for a cache hit rather than just PAG alone.  This reduces
+  * the number of times we need to import the login context,
+  * and taking this code path less often seems to have the
+  * effect of reducing the rate at which dfsbind consumes memory.
+  *
+  * Note that there is still some growth in dfsbind, however it
+  * is about half the rate.
+  * [from r9.4 by delta bww-ot9619-sec-dfsbind-leak, r1.1]
+  *
   * Revision 9.4  1993/11/04  14:37:46  travis
   *   Change the array index variable to be the loop counter,
   *   not an incorrect variable which is known to be equal to -1.
***************
*** 22,28 ****
   */
  
  #if !defined(_NOIDENT) && !defined(lint)
! static char *TARCSId = "$Id: c012996,v 1.3 95/12/21 16:12:17 root Exp $";
  #endif
  
  /*
--- 43,49 ----
   */
  
  #if !defined(_NOIDENT) && !defined(lint)
! static char *TARCSId = "$Id: c012996,v 1.3 95/12/21 16:12:17 root Exp $";
  #endif
  
  /*
***************
*** 35,54 ****
  /*
   * HISTORY
   * $Log:	c012996,v $
# Revision 1.3  95/12/21  16:12:17  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company  
# 
# Revision 1.2  95/08/03  17:52:25  root
# changed fields:  new/changed/deleted note(s) [biyani 8/3/95 public]
# 
!  * Revision 9.5  93/12/25  05:20:25  bww
!  * Picked up dfsbind memory leak workaround (OT9619).
   * 
-  * Modified find_context_cache() and add_context_cache()
-  * to check for a matching PAG and server as the criteria
-  * for a cache hit rather than just PAG alone.  This reduces
-  * the number of times we need to import the login context,
-  * and taking this code path less often seems to have the
-  * effect of reducing the rate at which dfsbind consumes memory.
-  * 
-  * Note that there is still some growth in dfsbind, however it
-  * is about half the rate.
-  * [from r9.4 by delta bww-ot9619-sec-dfsbind-leak, r1.1]
-  * 
   * Revision 1.1.6.3  1993/06/02  21:22:29  delgado
   * 	The new auth_helper from IBM
   * 	[1993/06/02  21:21:29  delgado]
--- 56,65 ----
  /*
   * HISTORY
   * $Log:	c012996,v $
# Revision 1.3  95/12/21  16:12:17  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company  
# 
# Revision 1.2  95/08/03  17:52:25  root
# changed fields:  new/changed/deleted note(s) [biyani 8/3/95 public]
# 
!  * Revision 9.7  94/01/13  14:59:33  cfe
!  * Not done yet--more checks on the strcmp() args necessary.
!  * [from r9.6 by delta cfe-4842-dfsbind-coredump-on-namemanip, r1.2]
   * 
   * Revision 1.1.6.3  1993/06/02  21:22:29  delgado
   * 	The new auth_helper from IBM
   * 	[1993/06/02  21:21:29  delgado]
***************
*** 288,297 ****
      LOCK_CACHE();
      tstamp++;
      for (i=0; i<CCSIZE; i++) {
!         if ((context_cache[i].pag == pag) && 
!             (strcmp(context_cache[i].credrep.server_name, server) == 0) &&
! 	    (context_cache[i].valid) &&
! 	    (context_cache[i].discard == 0)) {
  	    if (context_cache[i].refcount < 0) {
  		dprintf("bogus refcount in context_cache!\n");
  		abort();
--- 299,310 ----
      LOCK_CACHE();
      tstamp++;
      for (i=0; i<CCSIZE; i++) {
!             if ((context_cache[i].pag == pag) &&
!                  (context_cache[i].valid) &&
!                  (context_cache[i].discard == 0) && 
!                  (context_cache[i].cred_valid) &&
!                  (context_cache[i].credrep.server_name != NULL) &&
!                  (strcmp(context_cache[i].credrep.server_name, server) == 0)) {
  	    if (context_cache[i].refcount < 0) {
  		dprintf("bogus refcount in context_cache!\n");
  		abort();
***************
*** 335,343 ****
      for (i=0; i<CCSIZE; i++) {
  	/* Check to see if entry has already been added. */
          if ((context_cache[i].pag == pag) &&
-             (strcmp(context_cache[i].credrep.server_name, server) == 0) &&
  	    (context_cache[i].valid) &&
! 	    (context_cache[i].discard == 0)) {
              if (context_cache[i].refcount < 0) {
                  dprintf("bogus refcount in context_cache!\n");
                  abort();
--- 348,358 ----
      for (i=0; i<CCSIZE; i++) {
  	/* Check to see if entry has already been added. */
          if ((context_cache[i].pag == pag) &&
  	    (context_cache[i].valid) &&
! 	    (context_cache[i].discard == 0) &&
!                  (context_cache[i].cred_valid) &&
!                  (context_cache[i].credrep.server_name != NULL) &&
!             (strcmp(context_cache[i].credrep.server_name, server) == 0)) {
              if (context_cache[i].refcount < 0) {
                  dprintf("bogus refcount in context_cache!\n");
                  abort();



CR Number                     : 12995
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : cm
Short Description             : cthon test8 fails with fileset move
Reported Date                 : 8/2/95
Found in Baseline             : 1.0.3
Found Date                    : 8/2/95
Severity                      : B
Priority                      : 3
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : file/ftutil/ftu_dumpops.h
Sensitivity                   : public

[8/2/95 public]

From Transarc:

Got errors like the following when running connectathon test8, which
deals in lots of symlink/readlink calls, and moving the fileset:

/afs/transarc.com/usr/cfe/logs/test8: symlink and readlink
dfs: fileset (0,,119) is busy with code 691089510 on server 158.98.7.36 in cell
hoosh.dce.transarc.com.
        /afs/transarc.com/usr/cfe/logs/test8: readlink file.3 returned bad linkn
ame (/this/is/a/symlink7 instead of /this/is/a/symlink3)


More.....

The problem turned out to be that (vnode,unique) pairs were getting re-used
and that the CM thought that symlink data was immutable.  The v,u pairs
were re-used because dump/restore wasn't saving and restoring any kind of
uniquifier-generator, so Episode uniquifiers were starting out at 1 after
every restoration.

Thus, the following scenario showed the failure:
        - move a fileset
        - create a symlink A with contents X
        - delete the symlink
        - move the fileset again
        - create a symlink B with contents Y
At this point, a readlink(B) call would return X, since files A and B shared
a vnode index (the first free one) and the uniquifier value (1).

The solution was to dump and restore a uniquifier-generator field, which
was conveniently already present in the vol_status structure (vol_dy.unique).

Delta: cfe-db4693-dump-and-restore-fileset-unique-counter

More.....

Regression test information:
- backed by build: dfs-103 3.38
- tests passed: fileset move of a running connectathon
- test configuration
        two LFS Solaris machines

[8/3/95 public]

Delta: cfe-db4693-dump-and-restore-fileset-unique-counter
Change: file/ftutil/dumpops.c from 1.34 to 1.39
*** file/ftutil/dumpops.c
--- 1.39	1993/11/16 20:16:57
***************
*** 31,37 ****
  #include "ftu_syscalls.h"
  #include "ftu_trace.h"
  
! RCSID("$Header: /project/ot/dce/d01/d29/RCS/c012995,v 1.3 96/01/23 13:38:49 root Exp $")
  
  struct aclHashEnt {
      struct aclHashEnt *next;
--- 31,37 ----
  #include "ftu_syscalls.h"
  #include "ftu_trace.h"
  
! RCSID("$Header: /project/ot/dce/d01/d29/RCS/c012995,v 1.3 96/01/23 13:38:49 root Exp $")
  
  struct aclHashEnt {
      struct aclHashEnt *next;
***************
*** 790,795 ****
--- 790,801 ----
      if (code = vols_DumpShortOpcode(pipeP, VOLS_DUMP_HEADER_INDEX_MAX, 4))
  	goto done;
      if (code = vols_DumpLong(pipeP, (u_long) volStatus.vol_dy.nodeMax))
+ 	goto done;
+ 
+     /* dump the fileset uniquifier */
+     if (code = vols_DumpShortOpcode(pipeP, VOLS_DUMP_HEADER_N_UNIQUEGEN, 4))
+ 	goto done;
+     if (code = vols_DumpLong(pipeP, (u_long) volStatus.vol_dy.unique))
  	goto done;
  
      /* dump the MOTD */
Delta: cfe-db4693-dump-and-restore-fileset-unique-counter
Change: file/ftutil/ftu_dumpops.h from 1.4 to 1.5
*** file/ftutil/ftu_dumpops.h
--- 1.5	1993/11/16 20:17:02
***************
*** 252,257 ****
--- 252,266 ----
   */
  #define VOLS_DUMP_HEADER_DUMP_DATE	0x114
  
+ /* 
+  * This new uniquifier-generator provides the data on which a filesystem can
+  * base the uniquifier portion of file IDs, in case it's generating entire
+  * vnode+unique pairs via some obscure encryption.  The data must be a
+  * multiple of 4 bytes in length.
+  * The older VOLS_DUMP_HEADER_UNIQUEGEN has been co-opted for other uses.
+  */
+ #define VOLS_DUMP_HEADER_N_UNIQUEGEN	0x115
+ 
  
  /* 
   * The next set of opcodes are found in the vnode area of a dump itself. The
Delta: cfe-db4693-dump-and-restore-fileset-unique-counter
Change: file/ftutil/restoreops.c from 1.22 to 1.28
*** file/ftutil/restoreops.c
--- 1.28	1993/11/16 20:17:07
***************
*** 24,30 ****
  #include "ftu_private.h"
  #include "ftu_syscalls.h"
  
! RCSID("$Header: /project/ot/dce/d01/d29/RCS/c012995,v 1.3 96/01/23 13:38:49 root Exp $")
  
  static int verbose = 0;
  
--- 24,30 ----
  #include "ftu_private.h"
  #include "ftu_syscalls.h"
  
! RCSID("$Header: /project/ot/dce/d01/d29/RCS/c012995,v 1.3 96/01/23 13:38:49 root Exp $")
  
  static int verbose = 0;
  
***************
*** 971,977 ****
       ftu_kaProc_t kaProc;
       void *kaArg;
  { 
!     long temp, i, minQuota, volOwner, maxNodeIx;
      struct afsHyper visLimit, allocLimit;
      struct afsHyper junkHyper;
      unsigned long codesetTag;
--- 971,977 ----
       ftu_kaProc_t kaProc;
       void *kaArg;
  { 
!     long temp, i, minQuota, volOwner, maxNodeIx, volUniqueGen;
      struct afsHyper visLimit, allocLimit;
      struct afsHyper junkHyper;
      unsigned long codesetTag;
***************
*** 1063,1068 ****
--- 1063,1087 ----
  			break;
  		}
  		break;
+ 	    case VOLS_DUMP_HEADER_N_UNIQUEGEN:
+ 		/* this opcode is followed by some number of longs, which are
+ 		 * to be passed into the virtual file system for its unique ID
+ 		 * generator, if it wants one.
+ 		 */
+ 		if (vopcode.f.s.length % 4) {
+ 		    Log("vols_RestoreNUnique: expected multiple of 4, not %u",
+ 			vopcode.f.s.length);
+ 		    code = FTU_E_BAD_DUMP;
+ 		    break;
+ 		}
+ 		for (i = (vopcode.f.s.length / 4); i > 0; --i) {
+ 		    if (code = vols_RestoreLong(afsPipeP, &volUniqueGen,
+ 						sizeof(volUniqueGen)))
+ 			break;
+ 		}
+ 		/* This implementation only really deals with a single long */
+ 		if (vopcode.f.s.length == 4) flags |= VOL_STAT_UNIQUE;
+ 		break;
  	    case VOLS_DUMP_HEADER_MOTD_CODESET:
  		code = vols_RestoreLong(afsPipeP, &codesetTag, vopcode.f.s.length);
  		break;
***************
*** 1163,1175 ****
  		     * restore from failing.  We'll reset them to their
  		     * intended values below.
  		     */
!                     if (flags & VOL_STAT_VISLIMIT) {
  			hset(vstatus.vol_dy.visQuotaLimit, ftu_unlimitedQuota);
!                         mask |= VOL_STAT_VISLIMIT;
!                     }
!                     if (flags & VOL_STAT_ALLOCLIMIT) {
  			hset(vstatus.vol_dy.allocLimit, ftu_unlimitedQuota);
!                         mask |= VOL_STAT_ALLOCLIMIT;
  		    }
  		    if (flags & VOL_STAT_NODEMAX) {
  			vstatus.vol_dy.nodeMax = maxNodeIx;
--- 1182,1194 ----
  		     * restore from failing.  We'll reset them to their
  		     * intended values below.
  		     */
! 		    if (flags & VOL_STAT_VISLIMIT) {
  			hset(vstatus.vol_dy.visQuotaLimit, ftu_unlimitedQuota);
! 			mask |= VOL_STAT_VISLIMIT;
! 		    }
! 		    if (flags & VOL_STAT_ALLOCLIMIT) {
  			hset(vstatus.vol_dy.allocLimit, ftu_unlimitedQuota);
! 			mask |= VOL_STAT_ALLOCLIMIT;
  		    }
  		    if (flags & VOL_STAT_NODEMAX) {
  			vstatus.vol_dy.nodeMax = maxNodeIx;
***************
*** 1328,1334 ****
  	if (flags & VOL_STAT_OWNER) {
  	    vstatus.vol_dy.owner = volOwner;
  	    mask |= VOL_STAT_OWNER;
!         }
  	code = VOL_SETSTATUS(fsetDesc, mask, &vstatus, 0);
  	if (verbose) {
  	    if (code != 0) printf("ftserver restore: VOL_SETSTATUS failed with %lu\n", code);
--- 1347,1357 ----
  	if (flags & VOL_STAT_OWNER) {
  	    vstatus.vol_dy.owner = volOwner;
  	    mask |= VOL_STAT_OWNER;
! 	}
! 	if (flags & VOL_STAT_UNIQUE) {
! 	    vstatus.vol_dy.unique = volUniqueGen;
! 	    mask |= VOL_STAT_UNIQUE;
! 	}
  	code = VOL_SETSTATUS(fsetDesc, mask, &vstatus, 0);
  	if (verbose) {
  	    if (code != 0) printf("ftserver restore: VOL_SETSTATUS failed with %lu\n", code);



CR Number                     : 12994
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : osi
Short Description             : global lock panic in osi_Alloc
Reported Date                 : 8/2/95
Found in Baseline             : 1.0.3
Found Date                    : 8/2/95
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : file/osi/osi_misc.c
Sensitivity                   : public

[8/2/95 public]

From Transarc:

In the recordkeeping function update_allocrec, called from osi_Alloc,
we may drop and reacquire the global lock while holding the osi_alloc_mutex.
If another thread acquires the global lock after we drop it and then
blocks trying to acquire osi_alloc_mutex, a deadlock will result.  SunOS
detects this and panics.

More....

Instead of using a bare mutex, we now use a standard "data lock",
since the lock_ObtainXXX functions know how to avoid global lock
troubles.

blake-db4569-osi_alloc_mutex-bug

[8/3/95 public]

Delta: blake-db4569-osi_alloc_mutex-bug
Change: file/osi/osi_misc.c from 4.60 to 4.62
*** file/osi/osi_misc.c
--- 4.62	1993/11/10 22:14:45
***************
*** 31,43 ****
  #endif
  #endif
  
! RCSID("$Header: /project/ot/dce/d01/d29/RCS/c012994,v 1.3 95/12/21 16:13:57 root Exp $")
  
  static long osi_memUsage = 0;
  static long osi_allocCnt = 0;
  static long osi_BuffersAlloced = 0;
  static struct osi_buffer *osi_freeBufferList = 0;
! static osi_mutex_t osi_alloc_mutex;
  
  static char memZero;		/* address of 0 bytes of memory for osi_Alloc */
  
--- 31,43 ----
  #endif
  #endif
  
! RCSID("$Header: /project/ot/dce/d01/d29/RCS/c012994,v 1.3 95/12/21 16:13:57 root Exp $")
  
  static long osi_memUsage = 0;
  static long osi_allocCnt = 0;
  static long osi_BuffersAlloced = 0;
  static struct osi_buffer *osi_freeBufferList = 0;
! static osi_dlock_t osi_alloc_mutex;
  
  static char memZero;		/* address of 0 bytes of memory for osi_Alloc */
  
***************
*** 233,242 ****
      size += sizeof (struct osimem);
  #endif
  
!     osi_mutex_enter(&osi_alloc_mutex);
      osi_allocCnt++;
      osi_memUsage += size;
!     osi_mutex_exit(&osi_alloc_mutex);
  
      p = (opaque) osi_kalloc(size);
  
--- 233,242 ----
      size += sizeof (struct osimem);
  #endif
  
!     lock_ObtainWrite(&osi_alloc_mutex);
      osi_allocCnt++;
      osi_memUsage += size;
!     lock_ReleaseWrite(&osi_alloc_mutex);
  
      p = (opaque) osi_kalloc(size);
  
***************
*** 249,259 ****
      tm->size = asize;
      tm->caller = osi_caller();
      hash = OSI_MEMHASH(p);
!     osi_mutex_enter(&osi_alloc_mutex);
      tm->next = osi_memhash[hash];
      osi_memhash[hash] = tm;
      update_allocrec(tm->caller, tm->size, 1);
!     osi_mutex_exit(&osi_alloc_mutex);
      return ((caddr_t)p + sizeof (struct osimem));
  #else	/* AFSDEBMEM */
      return p;
--- 249,259 ----
      tm->size = asize;
      tm->caller = osi_caller();
      hash = OSI_MEMHASH(p);
!     lock_ObtainWrite(&osi_alloc_mutex);
      tm->next = osi_memhash[hash];
      osi_memhash[hash] = tm;
      update_allocrec(tm->caller, tm->size, 1);
!     lock_ReleaseWrite(&osi_alloc_mutex);
      return ((caddr_t)p + sizeof (struct osimem));
  #else	/* AFSDEBMEM */
      return p;
***************
*** 282,288 ****
  #ifdef	AFSDEBMEM
      tm = (struct osimem *)((caddr_t)p - sizeof (struct osimem));
      lm = &osi_memhash[OSI_MEMHASH(tm)];
!     osi_mutex_enter(&osi_alloc_mutex);
      um = *lm;
      while (um != NULL && um != tm) {
  	lm = &um->next;
--- 282,288 ----
  #ifdef	AFSDEBMEM
      tm = (struct osimem *)((caddr_t)p - sizeof (struct osimem));
      lm = &osi_memhash[OSI_MEMHASH(tm)];
!     lock_ObtainWrite(&osi_alloc_mutex);
      um = *lm;
      while (um != NULL && um != tm) {
  	lm = &um->next;
***************
*** 296,312 ****
  	 p, asize, called_from, um->size, um->caller));
      *lm = tm->next;
      update_allocrec(tm->caller, tm->size, 0);
!     osi_mutex_exit(&osi_alloc_mutex);
      size += sizeof (struct osimem);
      p = (opaque)tm;
      for (q = (char *)p; q != (char *)p + size; q++)
  	*q = (char) -1;
  
  #endif /* AFSDEBMEM */
!     osi_mutex_enter(&osi_alloc_mutex);
      osi_allocCnt--;
      osi_memUsage -= size;
!     osi_mutex_exit(&osi_alloc_mutex);
      osi_kfree(p, size);
  }
  
--- 296,312 ----
  	 p, asize, called_from, um->size, um->caller));
      *lm = tm->next;
      update_allocrec(tm->caller, tm->size, 0);
!     lock_ReleaseWrite(&osi_alloc_mutex);
      size += sizeof (struct osimem);
      p = (opaque)tm;
      for (q = (char *)p; q != (char *)p + size; q++)
  	*q = (char) -1;
  
  #endif /* AFSDEBMEM */
!     lock_ObtainWrite(&osi_alloc_mutex);
      osi_allocCnt--;
      osi_memUsage -= size;
!     lock_ReleaseWrite(&osi_alloc_mutex);
      osi_kfree(p, size);
  }



CR Number                     : 12991
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : episode
Short Description             : Turn off support for all but 8k/1k filesystems
Reported Date                 : 8/2/95
Found in Baseline             : 1.0.3
Found Date                    : 8/2/95
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : file/episode/anode/newaggr.c
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[8/2/95 public]

From Transarc:

Disable the ability to create anything but 8k/1k aggregates. This presumably
affects newaggr. Any other tools or implications need to be identified.

NOTE:
This should NOT be done by using the AFSDEBUG ifdef. The implementation may
be via ifdef or may be done so that the feature can be re-enabled via adb.
The AFSDEBUG ifdef will most likely remain turned on for shipped code, so
it should not be used to disable this feature.

More...

We decided that it would be good enough to have newaggr print a
warning if the user picked numbers other than 8192 and 1024 as the
block and fragment sizes.  A higher level script, configAggr, will
always use 8192 and 1024 without giving the user a choice.

More...

I newaggr'd a partition with 4k/4k, and sure enough, it printed a
warning.

[8/3/95 public]

Delta: jdp-db4382-have-newaggr-warn-about-unsupported-sizes
Change: file/episode/anode/newaggr.c from 4.49 to 4.55
*** file/episode/anode/newaggr.c
--- 4.55        1993/10/07 18:53:07
***************
*** 55,61 ****
  
  #include <errno.h>
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012991,v 1.4 95/12/21 15:55:13 root Exp $")
  
  static long arg_BlkSize;
  static long arg_FragSize;
--- 55,61 ----
  
  #include <errno.h>
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012991,v 1.4 95/12/21 15:55:13 root Exp $")
  
  static long arg_BlkSize;
  static long arg_FragSize;
***************
*** 184,189 ****
--- 184,193 ----
                    "Episode fragment size (%ld) must be at least 1k (%ld).\n",
                    fragSize, 1024);
            ++Problems;
+       }
+       if (blkSize != 8192 || fragSize != 1024) {
+           fprintf(stderr,
+                   "Warning: The only supported block size/fragment size combination is 8k/1k.\n");
        }
      }

[8/7/95 public]
Just a comment on this one... IBM has been shipping DCE LFS for
several years now with multiple block and frag sizes enabled. We
have done some testing with various sizes (although not as extensive
as we would like), and have customers using multiple block and frag
sizes successfully. We prefer leaving this flexibility in LFS to
allow customers to tailor their filesystems to the type of data
they have.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'



CR Number                     : 12990
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : episode
Short Description             : Treat network root same as local root
Reported Date                 : 8/2/95
Found in Baseline             : 1.0.3
Found Date                    : 8/2/95
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : file/episode/vnops/efs_access.c
Sensitivity                   : public

[8/2/95 public]

From Transarc:

After much discussion, we've decided that the proper approach to the "tar"
problem is to have Episode treat network root as a fully privileged account,
just like "local root" is treated.

There was also discussion about having a user interface for disabling this
behavior on a fileset-by-fileset basis, but this bug *does* not cover
that new feature.  This bug describes simply changing the default behavior
for the interpretation of "network root" from "unprivileged" to "privileged."

More ....:

This has been tested on a 103 3.31+ configuration.
I have tried various operations manually to ensure that the network
root can perform all operations(read, write, change modes, owner, group,
ACLS) on objects that it has no explicit permissions for. I can
now untar a tar file containing a 444 protected dir with files.

I also ran the ACL tests to serve as a regression test and tried
various operations manually to ensure that cell_admin and regular
users have not suffered any regressions.

[8/3/95 public]

Delta: rajesh-db3983-treat-network-root-as-superuser
Change: file/episode/vnops/Makefile from 4.51 to 4.52
*** file/episode/vnops/Makefile
--- 4.52	1993/09/19 01:47:30
***************
*** 236,241 ****
--- 236,249 ----
  # $EndLog$
  #
  
+ #
+ # NOTE - NETWORK ROOT ACCESS RIGHTS	
+ #
+ # By default, a network root now is a superuser.
+ # To turn this off, set CFLAGS to include "-DNETWORK_ROOT_NOT_SUPERUSER"
+ # in this Makefile or in the top level makefile. 
+ #
+ 
  INCLUDES		= efs_opcode.h efsmount.h efs_debug.h efs_trace.h
  PROGRAMS		= newvol growaggr test_vnodeops
  LIBRARIES		= libefsops.a
Delta: rajesh-db3983-treat-network-root-as-superuser
Change: file/episode/vnops/efs_access.c from 4.70 to 4.72
*** file/episode/vnops/efs_access.c
--- 4.72	1993/09/19 01:47:31
***************
*** 294,300 ****
  #include "efs_misc.h"
  #include "efs_access.h"
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012990,v 1.3 95/12/21 15:53:04 root Exp $")
  
  extern int afsdb_episode_vnops;        /* the trace control variable */
  #define DEBUG_THIS_FILE EFS_DEBUG_ACCESS
--- 294,300 ----
  #include "efs_misc.h"
  #include "efs_access.h"
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012990,v 1.3 95/12/21 15:53:04 root Exp $")
  
  extern int afsdb_episode_vnops;        /* the trace control variable */
  #define DEBUG_THIS_FILE EFS_DEBUG_ACCESS
***************
*** 504,510 ****
--- 504,514 ----
      epi_principal_id_t groupObj;	/* GROUP_OBJ principal */
      dacl_t * aclP;			/* ACL structure */
      epi_uuid_t sysAdminGroupID;		/* privileged ID */
+     epi_uuid_t localCellID;
+ 
+     dacl_GetLocalCellID((afsUUID*)&localCellID);
  
+     bzero((caddr_t)&pac, sizeof(sec_id_pac_t));
      pacP = &pac;
      pacP->groups = groups;
      pacP->num_foreign_groups = 0;
***************
*** 512,520 ****
      dacl_FindPac (credP, &pacP);
  
      /*
!      * We don't check for local super-user, since we are called only on behalf
!      * of remote users.
!      *
       * If there is an ACL, the DACL package will check for system
       * administrator.  If there is no ACL, this function will check.
       */
--- 516,538 ----
      dacl_FindPac (credP, &pacP);
  
      /*
!      * The following comment is a modified form of an earlier comment.
!      * We should only reach here if we are called on behalf of remote users.
!      */
! 
! #ifndef NETWORK_ROOT_NOT_SUPERUSER
!      /* Check for network root */
!     if (pacP->authenticated && 
! 	(bcmp((char *) &pacP->realm.uuid, (char *) &localCellID, 
! 	      sizeof (epi_uuid_t)) == 0) &&
! 	(osi_GetUID(credP) == 0)) {
! 	*permP = dacl_perm_control | dacl_perm_read | dacl_perm_execute |
! 	    dacl_perm_write |dacl_perm_insert | dacl_perm_delete;
!     } 
!     return 0;
! #endif
! 
!     /*
       * If there is an ACL, the DACL package will check for system
       * administrator.  If there is no ACL, this function will check.
       */
***************
*** 559,573 ****
  	    }
  	return code;
      } else {				/* File does not have an ACL */
- 	epi_uuid_t localCellID;
- 
  	*permP = 0;
  
  	/* No bits set for unauthenticated principal */
  	if (!(pacP->authenticated)) return 0;
  
  	/* First set Unix standard access bits, plus C if we are owner */
- 	dacl_GetLocalCellID((afsUUID*)&localCellID);
  
  	/* 
  	 * Requests from a different cell receive no rights in the null ACL
--- 577,588 ----
***************
*** 579,584 ****
--- 594,600 ----
  	    sizeof (epi_uuid_t)) != 0) {
  	    return 0;
  	}
+ 
  	if (Epi_PrinId_Cmp (&pacP->principal.uuid, &fstatP->oid) == 0) {
  	    *permP |= dacl_perm_control;
  	    bits = fstatP->mode & 0700;
***************
*** 644,649 ****
--- 660,666 ----
      epi_principal_id_t userObj;		/* USER_OBJ principal */
      epi_principal_id_t groupObj;	/* GROUP_OBJ principal */
      dacl_t * aclP;			/* ACL structure */
+     epi_uuid_t localCellID;
  
      if (aperm & dacl_perm_write) {
  	/*
***************
*** 663,685 ****
  #endif /* AFS_SUNOS5_ENV, AFS_AIX31_ENV */
      }
  
      /*
       * Pull out the caller's PAC information before doing the
       * true access check.
       */
      pacP = &pac;
      pacP->groups = groups;
      pacP->num_foreign_groups = 0;
      pacP->foreign_groups = (sec_id_foreign_t *) 0;
      dacl_FindPac (aucredP, &pacP);
  
      if (pacP == &pac) {			/* If called on behalf of local user */
- 	/*
- 	 * Check for local superuser
- 	 */
  	if (osi_GetUID(aucredP) == 0)
  	    return(0);
      }
  
      /*
       * We don't check for system administrator, since aperm can be
--- 680,715 ----
  #endif /* AFS_SUNOS5_ENV, AFS_AIX31_ENV */
      }
  
+     dacl_GetLocalCellID((afsUUID*)&localCellID);
+ 
      /*
       * Pull out the caller's PAC information before doing the
       * true access check.
       */
+     bzero((caddr_t)&pac, sizeof(sec_id_pac_t));
      pacP = &pac;
      pacP->groups = groups;
      pacP->num_foreign_groups = 0;
      pacP->foreign_groups = (sec_id_foreign_t *) 0;
      dacl_FindPac (aucredP, &pacP);
  
+     /*
+      * Check for superuser 
+      *   local always
+      *   network root if NETWORK_ROOT_NOT_SUPERUSER macro not defined
+      */
      if (pacP == &pac) {			/* If called on behalf of local user */
  	if (osi_GetUID(aucredP) == 0)
  	    return(0);
+     } 
+ #ifndef NETWORK_ROOT_NOT_SUPERUSER
+     else if (pacP->authenticated && 
+ 	     (bcmp((char *) &pacP->realm.uuid, (char *) &localCellID, 
+ 		   sizeof (epi_uuid_t)) == 0) &&
+ 	     (osi_GetUID(aucredP) == 0)) {
+ 	return(0);
      }
+ #endif
  
      /*
       * We don't check for system administrator, since aperm can be
***************
*** 729,735 ****
  		    code = EIO;
  	    }
      } else {				/* File does not have an ACL */
- 	epi_uuid_t localCellID;
  
  	/*
  	 * ** TO DO ** What are the semantics of not having an ACL?
--- 759,764 ----
***************
*** 741,747 ****
  
  	bits = 0;
  	dacl_OnePermsetToPermBits (aperm, &bits);
- 	dacl_GetLocalCellID((afsUUID*)&localCellID);
  
  	/* 
  	 * Requests from a different cell are denied access in the null ACL
--- 770,775 ----
***************
*** 858,882 ****
      int code;				/* error return code */
      dacl_permset_t perm;		/* Temporary permset */
      epi_uuid_t sysAdminGroupID;		/* privilaged ID */
  
      pacP = &pac;
      pacP->groups = groups;
      pacP->num_foreign_groups = 0;
      pacP->foreign_groups = (sec_id_foreign_t *) 0;
      dacl_FindPac (cred, &pacP);
  
!     if (pacP == &pac) {			/* If called on behalf of local user */
! 	/*
! 	 * Check for local superuser
! 	 */
  	if (osi_GetUID(cred) == 0) {
  	    *issuperP = 1;
  	    *ingroupsP = 1;
  	    return(0);
  	}
!     } else {				/* If called on behalf of remote user */
  	/*
! 	 * Check for system administrator
  	 */
  	dacl_GetSysAdminGroupID((afsUUID*)&sysAdminGroupID);
  	if (vnax_GroupInPAC((epi_principal_id_t *)&sysAdminGroupID, pacP)) {
--- 886,926 ----
      int code;				/* error return code */
      dacl_permset_t perm;		/* Temporary permset */
      epi_uuid_t sysAdminGroupID;		/* privilaged ID */
+     epi_uuid_t localCellID;
+ 
+     dacl_GetLocalCellID((afsUUID*)&localCellID);
  
+     bzero((caddr_t)&pac, sizeof(sec_id_pac_t));
      pacP = &pac;
      pacP->groups = groups;
      pacP->num_foreign_groups = 0;
      pacP->foreign_groups = (sec_id_foreign_t *) 0;
      dacl_FindPac (cred, &pacP);
  
!     /*
!      * Check for superuser 
!      *   local always
!      *   network root if NETWORK_ROOT_NOT_SUPERUSER macro not defined
!      */
!     if (pacP == &pac) {		/* If called on behalf of local user */
  	if (osi_GetUID(cred) == 0) {
  	    *issuperP = 1;
  	    *ingroupsP = 1;
  	    return(0);
  	}
!     } else {                    /* If called on behalf of remote user */
! #ifndef NETWORK_ROOT_NOT_SUPERUSER
! 	if (pacP->authenticated && 
! 	    (bcmp((char *) &pacP->realm.uuid, (char *) &localCellID, 
! 		  sizeof (epi_uuid_t)) == 0) &&
! 	    (osi_GetUID(cred) == 0)) {
! 	    *issuperP = 1;
! 	    *ingroupsP = 1;
! 	    return(0);
! 	}
! #endif
  	/*
! 	 * Check for network system administrator
  	 */
  	dacl_GetSysAdminGroupID((afsUUID*)&sysAdminGroupID);
  	if (vnax_GroupInPAC((epi_principal_id_t *)&sysAdminGroupID, pacP)) {
***************
*** 884,890 ****
  	    *ingroupsP = 1;
  	    return(0);
  	}
!     }
  
      /*
       * If there is an ACL, the DACL package will check for system
--- 928,934 ----
  	    *ingroupsP = 1;
  	    return(0);
  	}
!      }
  
      /*
       * If there is an ACL, the DACL package will check for system
Delta: rajesh-db3983-treat-network-root-as-superuser
Change: file/episode/vnops/Makefile from 4.52 to 4.53
*** file/episode/vnops/Makefile
--- 4.53	1993/09/22 11:33:08
***************
*** 239,247 ****
  #
  # NOTE - NETWORK ROOT ACCESS RIGHTS	
  #
! # By default, a network root now is a superuser.
! # To turn this off, set CFLAGS to include "-DNETWORK_ROOT_NOT_SUPERUSER"
! # in this Makefile or in the top level makefile. 
  #
  
  INCLUDES		= efs_opcode.h efsmount.h efs_debug.h efs_trace.h
--- 239,251 ----
  #
  # NOTE - NETWORK ROOT ACCESS RIGHTS	
  #
! # By default, a network root now is a superuser. This can be turned off
! # at runtime by setting kernel global variable efs_networkRootSuperUser 
! # to zero.
! #
! # To turn off availability of this feature, set CFLAGS to include
! # "-DNETWORK_ROOT_NOT_SUPERUSER" in this Makefile or in the top level
! #  makefile. 
  #
  
  INCLUDES		= efs_opcode.h efsmount.h efs_debug.h efs_trace.h
Delta: rajesh-db3983-treat-network-root-as-superuser
Change: file/episode/vnops/efs_access.c from 4.72 to 4.73
*** file/episode/vnops/efs_access.c
--- 4.73	1993/09/22 11:33:09
***************
*** 294,304 ****
  #include "efs_misc.h"
  #include "efs_access.h"
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012990,v 1.3 95/12/21 15:53:04 root Exp $")
  
  extern int afsdb_episode_vnops;        /* the trace control variable */
  #define DEBUG_THIS_FILE EFS_DEBUG_ACCESS
  
  static vnax_GroupInPAC(epi_principal_id_t * agroup, sec_id_pac_t *apacP);
  static vnax_GidInPAC(u_long * agidP, sec_id_pac_t * apacP);
  
--- 294,312 ----
  #include "efs_misc.h"
  #include "efs_access.h"
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012990,v 1.3 95/12/21 15:53:04 root Exp $")
  
  extern int afsdb_episode_vnops;        /* the trace control variable */
  #define DEBUG_THIS_FILE EFS_DEBUG_ACCESS
  
+ /* Provide means of turning off superuser privileges for network root
+  * under the control of a kernel variable efs_networkRootSuperUser. Turn
+  * this feature on by default.
+  */
+ #ifndef NETWORK_ROOT_NOT_SUPERUSER
+ int efs_networkRootSuperUser = 1;
+ #endif
+ 
  static vnax_GroupInPAC(epi_principal_id_t * agroup, sec_id_pac_t *apacP);
  static vnax_GidInPAC(u_long * agidP, sec_id_pac_t * apacP);
  
***************
*** 522,535 ****
  
  #ifndef NETWORK_ROOT_NOT_SUPERUSER
       /* Check for network root */
!     if (pacP->authenticated && 
  	(bcmp((char *) &pacP->realm.uuid, (char *) &localCellID, 
  	      sizeof (epi_uuid_t)) == 0) &&
  	(osi_GetUID(credP) == 0)) {
  	*permP = dacl_perm_control | dacl_perm_read | dacl_perm_execute |
  	    dacl_perm_write |dacl_perm_insert | dacl_perm_delete;
      } 
-     return 0;
  #endif
  
      /*
--- 530,544 ----
  
  #ifndef NETWORK_ROOT_NOT_SUPERUSER
       /* Check for network root */
!     if (efs_networkRootSuperUser &&
! 	pacP->authenticated && 
  	(bcmp((char *) &pacP->realm.uuid, (char *) &localCellID, 
  	      sizeof (epi_uuid_t)) == 0) &&
  	(osi_GetUID(credP) == 0)) {
  	*permP = dacl_perm_control | dacl_perm_read | dacl_perm_execute |
  	    dacl_perm_write |dacl_perm_insert | dacl_perm_delete;
+ 	return 0;
      } 
  #endif
  
      /*
***************
*** 703,709 ****
  	    return(0);
      } 
  #ifndef NETWORK_ROOT_NOT_SUPERUSER
!     else if (pacP->authenticated && 
  	     (bcmp((char *) &pacP->realm.uuid, (char *) &localCellID, 
  		   sizeof (epi_uuid_t)) == 0) &&
  	     (osi_GetUID(aucredP) == 0)) {
--- 712,719 ----
  	    return(0);
      } 
  #ifndef NETWORK_ROOT_NOT_SUPERUSER
!     else if (efs_networkRootSuperUser &&
! 	     pacP->authenticated && 
  	     (bcmp((char *) &pacP->realm.uuid, (char *) &localCellID, 
  		   sizeof (epi_uuid_t)) == 0) &&
  	     (osi_GetUID(aucredP) == 0)) {
***************
*** 910,916 ****
  	}
      } else {                    /* If called on behalf of remote user */
  #ifndef NETWORK_ROOT_NOT_SUPERUSER
! 	if (pacP->authenticated && 
  	    (bcmp((char *) &pacP->realm.uuid, (char *) &localCellID, 
  		  sizeof (epi_uuid_t)) == 0) &&
  	    (osi_GetUID(cred) == 0)) {
--- 920,927 ----
  	}
      } else {                    /* If called on behalf of remote user */
  #ifndef NETWORK_ROOT_NOT_SUPERUSER
! 	if (efs_networkRootSuperUser &&
! 	    pacP->authenticated && 
  	    (bcmp((char *) &pacP->realm.uuid, (char *) &localCellID, 
  		  sizeof (epi_uuid_t)) == 0) &&
  	    (osi_GetUID(cred) == 0)) {



CR Number                     : 12989
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : episode
Short Description             : Cache mtime/ctime in vnode
Reported Date                 : 8/2/95
Found in Baseline             : 1.0.3
Found Date                    : 8/2/95
Severity                      : B
Priority                      : 3
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : see below
Sensitivity                   : public

[8/2/95 public]

From Transarc:

The mtime and ctime should be cached in the vnode, as the atime is.  To insure
good crash semantics for the atime, we update the anode at sync, fsync,
unmount, recycle, and phantomize.  For mtime and ctime, we should update the
anode at all the same places, PLUS at stat (vnva_GetAttr) and in the strategy
code (efs_strategy).  The additional updates are because someone may be using
the mtime as a version number.

Delta bwl-3911-cache-mtime-ctime 1.2.
Make that 1.3.

[8/3/95 public]

Delta: bwl-3911-cache-mtime-ctime
Change: file/episode/vnops/RIOS/efs_aixvmm.c from 1.71 to 1.79
*** file/episode/vnops/RIOS/efs_aixvmm.c
--- 1.79	1994/03/16 19:44:29
***************
*** 294,300 ****
  				(VTOEV (vp))->vd_reservation.lastReserved,
  				credp);
  	efs_getlength(vp, &fileSize, &blockSize, credp);
! 	vnm_SetMCtime (VTOEV (vp), credp);
  	efs_unlock(vp);
  	if (fileSize & (PAGESIZE-1))
  	    vm_protectp(sid, fileSize >> PGSHIFT, 1, RDONLY);
--- 294,304 ----
  				(VTOEV (vp))->vd_reservation.lastReserved,
  				credp);
  	efs_getlength(vp, &fileSize, &blockSize, credp);
! 	vnm_SetMCtime (VTOEV (vp));
!         /* Clear SUID and SGID bits if necessary */
!         if (osi_GetUID (credp) != 0 &&
!             (epif_GetMode (EVTOA (VTOEV (vp))) & (VSUID | VSGID)))
!             vnm_ClearSUID (VTOEV (vp));
  	efs_unlock(vp);
  	if (fileSize & (PAGESIZE-1))
  	    vm_protectp(sid, fileSize >> PGSHIFT, 1, RDONLY);
Delta: bwl-3911-cache-mtime-ctime
Change: file/episode/vnops/SUNOS5/efs_sun5map.c from 1.10 to 1.12
*** file/episode/vnops/SUNOS5/efs_sun5map.c
--- 1.12	1994/03/16 19:44:38
***************
*** 219,225 ****
  
      /* Update mtime */
      if (!code)
! 	vnm_SetMCtime(evp, credp);
  
  done:
      /* Unlock file */
--- 219,225 ----
  
      /* Update mtime */
      if (!code)
! 	vnm_SetMCtime(evp);
  
  done:
      /* Unlock file */
Delta: bwl-3911-cache-mtime-ctime
Change: file/episode/vnops/SUNOS5/efs_sun5vmm.c from 1.128 to 1.134
*** file/episode/vnops/SUNOS5/efs_sun5vmm.c
--- 1.134	1994/03/16 19:44:41
***************
*** 13,18 ****
--- 13,19 ----
  #include <dcedfs/osi_buf.h>
  #include <dcedfs/osi_vmm.h>
  #include <dcedfs/debug.h>
+ #include <dcedfs/episode/file.h>		/* epif_GetMode */
  
  #include "efs_evnode.h"
  #include "efs_misc.h"
***************
*** 20,26 ****
  
  extern void hat_setmod(page_t *);
  
! RCSID("$Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $")
  
  /* Arbitrary constants */
  
--- 21,27 ----
  
  extern void hat_setmod(page_t *);
  
! RCSID("$Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $")
  
  /* Arbitrary constants */
  
***************
*** 287,293 ****
     }
  
      /* Update mtime and ctime */
!     vnm_SetMCtime(VTOEV(vp), credp);
  
      efs_unlock(vp);
  
--- 288,299 ----
     }
  
      /* Update mtime and ctime */
!     vnm_SetMCtime(VTOEV(vp));
! 
!     /* Clear SUID and SGID bits if necessary */
!     if (osi_GetUID(credp) != 0 &&
! 	(epif_GetMode(EVTOA(VTOEV(vp))) & (VSUID | VSGID)))
! 	 vnm_ClearSUID(VTOEV(vp));
  
      efs_unlock(vp);
  
Delta: bwl-3911-cache-mtime-ctime
Change: file/episode/vnops/efs_dir.c from 4.74 to 4.82
*** file/episode/vnops/efs_dir.c
--- 4.82	1994/03/16 19:44:52
***************
*** 120,126 ****
  static struct efsdircache efsdircache;		/* dir cache statistics */
  
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $")
  
  /*
   * vnd_Create - add an entry to a directory
--- 120,126 ----
  static struct efsdircache efsdircache;		/* dir cache statistics */
  
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $")
  
  /*
   * vnd_Create - add an entry to a directory
***************
*** 174,180 ****
  	epif_ChangeLink (transId, EVTOA (devp), 1, 0, (u_int *) 0);
  
      /* Update target's mtime and ctime */
!     epif_Mark (transId, EVTOA (devp), EPIF_SFLAGS_MTIME | EPIF_SFLAGS_CTIME);
  
      /* Increment source's link count if requested */
      if (flags & DC_CHANGELINK)
--- 174,180 ----
  	epif_ChangeLink (transId, EVTOA (devp), 1, 0, (u_int *) 0);
  
      /* Update target's mtime and ctime */
!     vnm_MarkMCtime (transId, devp, 1);
  
      /* Increment source's link count if requested */
      if (flags & DC_CHANGELINK)
***************
*** 182,188 ****
  
      /* Update source's ctime if requested */
      if (flags & DC_MARKCTIME)
! 	epif_Mark (transId, EVTOA (nevp), EPIF_SFLAGS_CTIME);
  
      return (0);
  }
--- 182,188 ----
  
      /* Update source's ctime if requested */
      if (flags & DC_MARKCTIME)
! 	vnm_MarkMCtime (transId, nevp, 0);
  
      return (0);
  }
***************
*** 258,264 ****
      }
  
      /* Update parent directory's mtime and ctime */
!     code = epif_Mark (transId, dap, EPIF_SFLAGS_MTIME | EPIF_SFLAGS_CTIME);
      MBZ(code);
  
      /* Decrement child's link count */
--- 258,264 ----
      }
  
      /* Update parent directory's mtime and ctime */
!     code = vnm_MarkMCtime (transId, devp, 1);
      MBZ(code);
  
      /* Decrement child's link count */
***************
*** 266,272 ****
      MBZ(code);
  
      /* Update child's ctime */
!     code = epif_Mark (transId, oap, EPIF_SFLAGS_CTIME);
      MBZ(code);
  
      return (0);
--- 266,272 ----
      MBZ(code);
  
      /* Update child's ctime */
!     code = vnm_MarkMCtime (transId, oevp, 0);
      MBZ(code);
  
      return (0);
***************
*** 339,357 ****
  	return (code);
  
      /* Update parent directory's mtime and ctime */
!     epif_Mark (transId, dap, EPIF_SFLAGS_MTIME | EPIF_SFLAGS_CTIME);
  
      /* Decrement old child's link count */
      epif_ChangeLink (transId, ooap, lcdelta, 0, (u_int *) 0);
  
      /* Update old child's ctime */
!     epif_Mark (transId, ooap, EPIF_SFLAGS_CTIME);
  
      /* Increment new child's link count */
      epif_ChangeLink (transId, noap, 1, 0, (u_int *) 0);
  
      /* Update new child's ctime */
!     epif_Mark (transId, noap, EPIF_SFLAGS_CTIME);
  
      return 0;
  }
--- 339,357 ----
  	return (code);
  
      /* Update parent directory's mtime and ctime */
!     vnm_MarkMCtime (transId, devp, 1);
  
      /* Decrement old child's link count */
      epif_ChangeLink (transId, ooap, lcdelta, 0, (u_int *) 0);
  
      /* Update old child's ctime */
!     vnm_MarkMCtime (transId, ooevp, 0);
  
      /* Increment new child's link count */
      epif_ChangeLink (transId, noap, 1, 0, (u_int *) 0);
  
      /* Update new child's ctime */
!     vnm_MarkMCtime (transId, noevp, 0);
  
      return 0;
  }
Delta: bwl-3911-cache-mtime-ctime
Change: file/episode/vnops/efs_evnode.h from 4.90 to 4.107
*** file/episode/vnops/efs_evnode.h
--- 4.107	1994/03/16 19:45:05
***************
*** 6,12 ****
   * src directory for the full copyright text.
   */
  
! /* $Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $ */
  /*
   * Copyright (C) 1993, 1990 Transarc Corporation
   * All rights reserved.
--- 6,12 ----
   * src directory for the full copyright text.
   */
  
! /* $Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $ */
  /*
   * Copyright (C) 1993, 1990 Transarc Corporation
   * All rights reserved.
***************
*** 52,57 ****
--- 52,59 ----
      } vd_ident;
      int vd_flags;			/* miscellaneous flags */
      struct timeval vd_lastAtime;        /* Last access time */
+     struct timeval vd_lastMtime;	/* Last mod time */
+     struct timeval vd_lastCtime;	/* Last change time */
      hyper vd_len;			/* length */
      dacl_t * vd_acl;			/* ACL */
      struct epia_reservation vd_reservation; /* storage reserved (VM systems) */
***************
*** 112,119 ****
  #define VD_FOUNDHOLE	0x1000		/* efs_strategy read from a hole */
  #define VD_NOIDENTITY   0x2000          /* the vnode is no longer associated
  					   with a filesytem object */
! 
! #define VD_OUTOFDATE	VD_OLDATIME	/* other bits or'ed in as needed */
  
  #define EVTOA(evp) (evp->vd_ap)		/* get anode pointer of vnode. */
  #define EVTOV(evp) ((struct vnode *) (evp)) /* convert evnode to vnode; cheat
--- 114,124 ----
  #define VD_FOUNDHOLE	0x1000		/* efs_strategy read from a hole */
  #define VD_NOIDENTITY   0x2000          /* the vnode is no longer associated
  					   with a filesytem object */
! #define VD_OLDMTIME	0x4000		/* anode has older mtime than vnode */
! #define VD_OLDCTIME	0x8000		/* anode has older ctime than vnode */
! #define VD_OLDMCTIME	(VD_OLDMTIME | VD_OLDCTIME)
! #define VD_OUTOFDATE	(VD_OLDATIME | VD_OLDMCTIME)
! 					/* other bits or'ed in as needed */
  
  #define EVTOA(evp) (evp->vd_ap)		/* get anode pointer of vnode. */
  #define EVTOV(evp) ((struct vnode *) (evp)) /* convert evnode to vnode; cheat
Delta: bwl-3911-cache-mtime-ctime
Change: file/episode/vnops/efs_misc.c from 4.422 to 4.427
*** file/episode/vnops/efs_misc.c
--- 4.427	1994/03/16 19:45:08
***************
*** 22,27 ****
--- 22,29 ----
      vnm_Unreserve
      vnm_SetAtime, vnm_SetMCtime
      vnm_Update_Anode
+     vnm_MarkMCtime
+     vnm_ClearSUID
      vnm_Init, vnm_VInit, vnm_VReinit
      vnm_Rouse, vnm_Unrouse
      Recycle
***************
*** 76,82 ****
  
  #define DEBUG_THIS_FILE EFS_DEBUG_MISC
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $")
  
  /* Flags to pass to epia_Truncate */
  #if	defined(AFS_SUNOS5_ENV) || defined(AFS_AIX31_VM)
--- 78,84 ----
  
  #define DEBUG_THIS_FILE EFS_DEBUG_MISC
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $")
  
  /* Flags to pass to epia_Truncate */
  #if	defined(AFS_SUNOS5_ENV) || defined(AFS_AIX31_VM)
***************
*** 497,540 ****
  }
  
  /*
!  * vnm_SetMCtime -- update mtime and ctime on behalf of writing
   *
   * LOCKS: called with vnode lock held for writing
   */
  /* EXPORT */
! void vnm_SetMCtime (evp, credp)
      struct evnode *evp;			/* Episode vnode */
-     osi_cred_t *credp;			/* credential structure */
  {
!     int code;
!     buffer_TranRec_t transId;		/* transaction ID */
!     epi_anode_t ap;			/* anode handle for evp */
!     struct epif_status fstat;		/* file status info for evp */
! 
!     ap = EVTOA (evp);
! 
!     /* Start transaction */
!     code = epia_StartTran ("vnm_SetMCtime", ap, &transId);
!     MBZ (code);
! 
!     /* Clear SUID and SGID bits if necessary */
!     if (osi_GetUID (credp) != 0)
! 	if (epif_GetMode (ap) & (VSUID | VSGID)) {
! 	    fstat.mode = epif_GetMode(ap) & ~(VSUID | VSGID);
! 	    code = epif_SetStatus (transId, ap, EPIF_SFLAGS_MODE, &fstat);
! 	    MBZ (code);
! 	}
! 
!     /* Update mtime and ctime */
!     code = epif_Mark (transId, ap, EPIF_SFLAGS_MTIME | EPIF_SFLAGS_CTIME);
!     MBZ (code);
! 
!     /* Merge transaction */
!     tlock_EquivAssign (transId, &evp->vd_tlock);
! 
!     /* End transaction */
!     code = epia_EndTran (ap, transId);
!     MBZ (code);
  }
  
  /*
--- 499,515 ----
  }
  
  /*
!  * vnm_SetMCtime -- update vnode copy of mtime and ctime on behalf of writing
   *
   * LOCKS: called with vnode lock held for writing
   */
  /* EXPORT */
! void vnm_SetMCtime (evp)
      struct evnode *evp;			/* Episode vnode */
  {
!     osi_GetTime (&evp->vd_lastMtime);
!     evp->vd_lastCtime = evp->vd_lastMtime;
!     evp->vd_flags |= VD_OLDMCTIME;
  }
  
  /*
***************
*** 553,558 ****
--- 528,534 ----
  {
      buffer_tranRec_t transId;		/* transaction ID */
      int code;
+     long flags = 0;			/* flags arg for epif_SetStatus */
      struct epif_status fstat;		/* status info about evp */
      epi_anode_t ap;			/* anode for evp */
  
***************
*** 568,576 ****
  
      if (evp->vd_flags & VD_OLDATIME) {
  	fstat.aTime = evp->vd_lastAtime;
! 	epif_SetStatus (transId, ap, EPIF_SFLAGS_ATIME, &fstat);
      }
  
      /* Clean up */
  
      evp->vd_flags &= ~VD_OUTOFDATE;
--- 544,569 ----
  
      if (evp->vd_flags & VD_OLDATIME) {
  	fstat.aTime = evp->vd_lastAtime;
! 	flags |= EPIF_SFLAGS_ATIME;
!     }
! 
!     /* Mtime */
! 
!     if (evp->vd_flags & VD_OLDMTIME) {
! 	fstat.mTime = evp->vd_lastMtime;
! 	flags |= EPIF_SFLAGS_MTIME;
      }
  
+     /* Ctime */
+ 
+     if (evp->vd_flags & VD_OLDCTIME) {
+ 	fstat.cTime = evp->vd_lastCtime;
+ 	flags |= (EPIF_SFLAGS_CTIME);
+     }
+ 
+     if (evp->vd_flags & (VD_OLDATIME | VD_OLDMCTIME))
+ 	epif_SetStatus (transId, ap, flags, &fstat);
+ 
      /* Clean up */
  
      evp->vd_flags &= ~VD_OUTOFDATE;
***************
*** 584,589 ****
--- 577,646 ----
  }
  
  /*
+  * vnm_MarkMCtime -- update ctime and possibly mtime under a transaction
+  *
+  * We are updating the anode's times, and so we clear VD_OLDMCTIME.
+  *
+  * LOCKS: called with vnode lock held for writing
+  */
+ 
+ /* EXPORT */
+ int vnm_MarkMCtime (transId, evp, markM)
+     buffer_TranRec_t transId;		/* transaction ID */
+     struct evnode *evp;			/* Episode vnode */
+     int markM;				/* 0 for just ctime, 1 for both */
+ {
+     int code;
+     epi_anode_t ap;			/* anode handle for evp */
+ 
+     ap = EVTOA (evp);
+ 
+     if (markM) {
+ 	code = epif_Mark (transId, ap, EPIF_SFLAGS_MTIME | EPIF_SFLAGS_CTIME);
+ 	evp->vd_flags &= ~VD_OLDMCTIME;
+     } else {
+ 	code = epif_Mark (transId, ap, EPIF_SFLAGS_CTIME);
+ 	evp->vd_flags &= ~VD_OLDCTIME;
+     }
+ 
+     return code;
+ }
+ 
+ /*
+  * vnm_ClearSUID -- clear SUID and SGID bits on behalf of writing
+  *
+  * LOCKS: called with vnode lock held for writing
+  */
+ 
+ /* EXPORT */
+ void vnm_ClearSUID (evp)
+     struct evnode *evp;			/* Episode vnode */
+ {
+     int code;
+     epi_anode_t ap;			/* anode handle for evp */
+     buffer_TranRec_t transId;		/* transaction ID */
+     struct epif_status fstat;		/* file status info for evp */
+ 
+     ap = EVTOA (evp);
+ 
+     /* Start transaction */
+     code = epia_StartTran ("vnm_ClearSUID", ap, &transId);
+     MBZ (code);
+ 
+     /* Clear the bits */
+     fstat.mode = epif_GetMode (ap) & ~(VSUID | VSGID);
+     code = epif_SetStatus (transId, ap, EPIF_SFLAGS_MODE, &fstat);
+     MBZ (code);
+ 
+     /* Merge transaction */
+     tlock_EquivAssign (transId, &evp->vd_tlock);
+ 
+     /* End transaction */
+     code = epia_EndTran (ap, transId);
+     MBZ (code);
+ }
+ 
+ /*
   * vnm_Init -- initialize the vnode pool, free list, and hash table
   */
  
***************
*** 763,768 ****
--- 820,827 ----
      evp->vd_flags &= ~(VD_STALE | VD_RDONLY | VD_ROOT);
      evp->vd_validFlag = 0;
      evp->vd_lastAtime = epif_GetATime (ap);
+     evp->vd_lastMtime = epif_GetMTime (ap);
+     evp->vd_lastCtime = epif_GetCTime (ap);
  
      /* Set ROOT bit(s) */
  
Delta: bwl-3911-cache-mtime-ctime
Change: file/episode/vnops/efs_misc.h from 1.13 to 1.19
*** file/episode/vnops/efs_misc.h
--- 1.19	1994/03/16 19:45:39
***************
*** 6,12 ****
   * src directory for the full copyright text.
   */
  
! /* $Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $ */
  /*
   * Copyright (C) 1993 Transarc Corporation
   * All rights reserved.
--- 6,12 ----
   * src directory for the full copyright text.
   */
  
! /* $Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $ */
  /*
   * Copyright (C) 1993 Transarc Corporation
   * All rights reserved.
***************
*** 52,59 ****
  extern int vnm_Truncate(struct evnode *evp, u_long len, osi_cred_t *credp);
  extern void vnm_Unreserve(struct evnode *evp);
  extern void vnm_SetAtime(struct evnode *evp, int flags);
! extern void vnm_SetMCtime(struct evnode *evp, osi_cred_t *credp);
  extern void vnm_Update_Anode(struct evnode *evp);
  extern int vnm_Init(long nvnodes, long noXvfs);
  extern void vnm_Rouse(struct evnode *evp);
  extern void vnm_Unrouse(struct evnode *evp);
--- 52,65 ----
  extern int vnm_Truncate(struct evnode *evp, u_long len, osi_cred_t *credp);
  extern void vnm_Unreserve(struct evnode *evp);
  extern void vnm_SetAtime(struct evnode *evp, int flags);
! extern void vnm_SetMCtime(struct evnode *evp);
  extern void vnm_Update_Anode(struct evnode *evp);
+ extern int vnm_MarkMCtime(
+     buffer_TranRec_t transId,
+     struct evnode *evp,
+     int markM
+ );
+ extern void vnm_ClearSUID(struct evnode *evp);
  extern int vnm_Init(long nvnodes, long noXvfs);
  extern void vnm_Rouse(struct evnode *evp);
  extern void vnm_Unrouse(struct evnode *evp);
Delta: bwl-3911-cache-mtime-ctime
Change: file/episode/vnops/efs_vattr.c from 4.75 to 4.79
*** file/episode/vnops/efs_vattr.c
--- 4.79	1994/03/16 19:45:42
***************
*** 261,267 ****
  #include "efs_misc.h"
  #include "efs_vattr.h"
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $")
  
  #ifndef	KERNEL
  #ifdef	AFS_AIX31_ENV
--- 261,267 ----
  #include "efs_misc.h"
  #include "efs_vattr.h"
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $")
  
  #ifndef	KERNEL
  #ifdef	AFS_AIX31_ENV
***************
*** 719,724 ****
--- 719,728 ----
  		evp->vd_lastAtime = epif_GetATime (ap);
  		evp->vd_flags &= ~VD_OLDATIME;
  	    }
+ 	    if (markmask & EPIF_SFLAGS_MTIME)
+ 		evp->vd_flags &= ~VD_OLDMTIME;
+ 	    if (markmask & EPIF_SFLAGS_CTIME)
+ 		evp->vd_flags &= ~VD_OLDCTIME;
  	}
  	tlock_ReleaseWrite (transId, &evp->vd_tlock);
  	ccode = epia_EndTran (ap, transId);
Delta: bwl-3911-cache-mtime-ctime
Change: file/episode/vnops/efs_vnodeops.c from 4.618 to 4.621
*** file/episode/vnops/efs_vnodeops.c
--- 4.621	1994/03/16 19:45:51
***************
*** 45,51 ****
  #endif /* AFS_SUNOS5_ENV */
  
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $")
  
  /*
   * We follow the conventions of the original Sun vfs/vnode interface:
--- 45,51 ----
  #endif /* AFS_SUNOS5_ENV */
  
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $")
  
  /*
   * We follow the conventions of the original Sun vfs/vnode interface:
***************
*** 657,664 ****
  		VNM_MAP_COMMON_ERROR(code, DEBUG_THIS_FILE);
  	    } else {			/* write succeeded */
  		/* Update mtime and ctime */
! 		vnm_SetMCtime (evp, cred);
  
  		/* May clear VD_LENVALID (don't know if this can happen) */
  		hset (hlen, epia_GetLength (ap));
  		if (evp->vd_flags & VD_LENVALID)
--- 657,669 ----
  		VNM_MAP_COMMON_ERROR(code, DEBUG_THIS_FILE);
  	    } else {			/* write succeeded */
  		/* Update mtime and ctime */
! 		vnm_SetMCtime (evp);
  
+ 		/* Clear SUID and SGID bits if necessary */
+ 		if (osi_GetUID (cred) != 0 &&
+ 		    (epif_GetMode (ap) & (VSUID | VSGID)))
+ 		    vnm_ClearSUID (evp);
+ 
  		/* May clear VD_LENVALID (don't know if this can happen) */
  		hset (hlen, epia_GetLength (ap));
  		if (evp->vd_flags & VD_LENVALID)
***************
*** 700,705 ****
--- 705,718 ----
      evp = VTOEV(vp);
      EV_DEPHANTOM (evp);
  
+     /*
+      * If the Mtime or Ctime are new, update the anode now.
+      * This is supposed to keep clients from seeing these times go backward.
+      * To put teeth in this precaution, shouldn't we commit the transaction?
+      */
+     if (evp->vd_flags & VD_OLDMCTIME)
+ 	vnm_Update_Anode (evp);
+ 
      tlock_ObtainRead (&evp->vd_tlock);
      code = vnva_GetAttr (evp, vap, cred, 0);
      if (code) {
***************
*** 726,731 ****
--- 739,752 ----
      evp = VTOEV(vp);
      EV_DEPHANTOM (evp);
  
+     /*
+      * If the Mtime or Ctime are new, update the anode now.
+      * This is supposed to keep clients from seeing these times go backward.
+      * To put teeth in this precaution, shouldn't we commit the transaction?
+      */
+     if (evp->vd_flags & VD_OLDMCTIME)
+ 	vnm_Update_Anode (evp);
+ 
      tlock_ObtainRead (&evp->vd_tlock);
      code = vnva_GetAttr (evp, vap, cred, flag);
      if (code) {
***************
*** 3595,3601 ****
      }
  
      /* Update ctime */
!     epif_Mark (transId, ap, EPIF_SFLAGS_CTIME);
  
      /* For a file/dir's regular ACL,
       *     invalidate cached ACL if necessary and cache new acl if we get
--- 3616,3622 ----
      }
  
      /* Update ctime */
!     vnm_MarkMCtime (transId, evp, 0);
  
      /* For a file/dir's regular ACL,
       *     invalidate cached ACL if necessary and cache new acl if we get
***************
*** 3752,3767 ****
      int ioflag;
      osi_cred_t *cred;
  {
-     epi_anode_t ap;			/* anode handle for evp */
-     logTranRec_t transId;		/* transaction ID */
      struct evnode *evp;			/* evnode */
  
      evp = VTOEV(vp);
!     ap = EVTOA (evp);
!     elbb_StartTran("efs_rdwr", 0, epia_AnodeDevice (ap), &transId);
!     epif_Mark (transId, ap, EPIF_SFLAGS_MTIME | EPIF_SFLAGS_CTIME);
!     elbb_EndTran(transId);
! 
      return (spec_write(vp, uio, ioflag, cred));
  }
  
--- 3773,3782 ----
      int ioflag;
      osi_cred_t *cred;
  {
      struct evnode *evp;			/* evnode */
  
      evp = VTOEV(vp);
!     vnm_SetMCtime (evp, cred);
      return (spec_write(vp, uio, ioflag, cred));
  }
  
***************
*** 3803,3818 ****
      int ioflag;
      osi_cred_t *cred;
  {
-     epi_anode_t ap;			/* anode handle for evp */
-     logTranRec_t transId;		/* transaction ID */
      struct evnode *evp;			/* evnode */
  
      evp = VTOEV(vp);
!     ap = EVTOA (evp);
!     elbb_StartTran("efs_rdwr", 0, epia_AnodeDevice (ap), &transId);
!     epif_Mark (transId, ap, EPIF_SFLAGS_MTIME | EPIF_SFLAGS_CTIME);
!     elbb_EndTran(transId);
! 
      return (fifo_write(vp, uio, ioflag, cred));
  }
  
--- 3818,3827 ----
      int ioflag;
      osi_cred_t *cred;
  {
      struct evnode *evp;			/* evnode */
  
      evp = VTOEV(vp);
!     vnm_SetMCtime (evp, cred);
      return (fifo_write(vp, uio, ioflag, cred));
  }
  
Delta: bwl-3911-cache-mtime-ctime
Change: file/episode/anode/file.c from 4.69 to 4.79
*** file/episode/anode/file.c
--- 4.79	1994/03/25 19:17:43
***************
*** 10,16 ****
   * $Log:	c012989,v $
# Revision 1.4  96/01/23  13:42:13  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company  
# 
# Revision 1.3  95/08/03  17:45:05  root
# changed fields:  new/changed/deleted note(s) [biyani 8/3/95 public]
# 
   * $EndLog$
   */
! /* Copyright (C) 1993, 1990 Transarc Corporation - All rights reserved */
  
  /* file.c -- contains procedures to needed by the vnode layer to implement Unix
   *     files.  Basic read and write operations are handled directly by lower
--- 10,16 ----
   * $Log:	c012989,v $
# Revision 1.4  96/01/23  13:42:13  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company  
# 
# Revision 1.3  95/08/03  17:45:05  root
# changed fields:  new/changed/deleted note(s) [biyani 8/3/95 public]
# 
   * $EndLog$
   */
! /* Copyright (C) 1994, 1990 Transarc Corporation - All rights reserved */
  
  /* file.c -- contains procedures to needed by the vnode layer to implement Unix
   *     files.  Basic read and write operations are handled directly by lower
***************
*** 35,41 ****
  #include "volume.h"
  #include "file.h"
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $")
  
  #define DEBUG_THIS_FILE EPIA_DEBUG_FILE
  
--- 35,41 ----
  #include "volume.h"
  #include "file.h"
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012989,v 1.4 96/01/23 13:42:13 root Exp $")
  
  #define DEBUG_THIS_FILE EPIA_DEBUG_FILE
  
***************
*** 1875,1915 ****
      return 0;
  }
  
! /* epif_SetStatus -- Changes those fields of the file's status that are
!  *     selected by the \arg{flags} to have the values specified in
!  *     \arg{status}.  The valid bits that maybe combined to form
!  *     \arg{flags} are defined by the constants using the
!  *     \prefix{\cst{EPIF_SFLAGS_}} in file.h.
   *
   * PARAMETERS --
   *     trans -- transaction to use for the operation.
   *     f -- file's open handle.
!  *     flags -- mask used to select the fields in the status.
   *     status -- file's new status.
   *
!  * PERFORMANCE -- See the SET_FIELDS macro below. */
  
  /* EXPORT */
! long epif_SetStatus(
    IN elbb_tranRec_t trans,
    IN epi_anode_t f,
!   IN long flags,			/* which fields to set */
    IN struct epif_status *status)
  {
      long code;
      struct fileHandle *h;
      long first, last;			/* offsets bracketing modifications */
  
!     /* SET_FIELD -- does most of the work in modiying a particular field in the
!      *     status area.  It maintains a low and high water mark so all updates
!      *     can be merged into a single call to elbb_Modify.  It may be that it
!      *     would be more efficient to do separate Modifies if two widely
!      *     separated fields are being updated.
       *
       *     A code block corresponding to each field is maintained by passing
       *     the block to the SET_FIELD macro. */
  
! #define SET_FIELD(b,f,v,n) if (flags & (b)) { \
      int o = offsetof (struct diskStatus, f); \
      epix_EnterCodeBlock /* */ (n); \
      if (o < first) first = o; \
--- 1875,1938 ----
      return 0;
  }
  
! /* epif_SetStatusAndMark -- Changes those fields of the file's status that
!  *     are selected by the setStatusFlags to have the values specified in
!  *     status.  Changes those (time-stamp) fields of the file's status that
!  *     are selected by the markFlags to have the value of the current time.
!  *     (These include one or more of:  atime, mtime, ctime.)
!  *     Either setStatusFlags or markFlags may be zero; if setStatusFlags is
!  *     zero, status will be a null pointer.  The valid bits that may be
!  *     combined to form setStatusFlags and markFlags are defined by the
!  *     constants using the prefix EPIF_SFLAGS_ in file.h.
!  *
!  *     The caller may also wish to update the file data version number.  This
!  *     can be specified explicitly, by setting EPIF_SFLAGS_DVERSION in
!  *     markFlags.  It is also specified implicitly when EPIF_SFLAGS_MTIME is
!  *     set in markFlags.  It is NOT specified implicitly when EPIF_SFLAGS_MTIME
!  *     is set in setStatusFlags.
!  *
!  *     If any flag in markFlags is set, the fileset version number is updated.
!  *     SPECIAL HACK used only by test_anode:
!  *	  If setStatusFlags and markFlags are both zero and status is null,
!  *	  it is assumed that macro epif_Mark was invoked with flags set to
!  *	  zero, with the intention of solely updating the fileset version
!  *	  number.
   *
   * PARAMETERS --
   *     trans -- transaction to use for the operation.
   *     f -- file's open handle.
!  *     markFlags -- mask used to select timestamp fields in the status.
!  *     setStatusFlags -- mask used to select fields in the status.
   *     status -- file's new status.
   *
!  * PERFORMANCE -- See the SET_FIELDS macro below.
!  */
  
  /* EXPORT */
! long epif_SetStatusAndMark(
    IN elbb_tranRec_t trans,
    IN epi_anode_t f,
!   IN long markFlags,
!   IN long setStatusFlags,		/* which fields to set */
    IN struct epif_status *status)
  {
      long code;
      struct fileHandle *h;
+     hyper vv;				/* volume version number */
+     epi_volume_t vol;
+     struct timeval t;
      long first, last;			/* offsets bracketing modifications */
  
!     /* SET_FIELD -- does most of the work in modifying a particular field in
!      *     the status area.  It maintains a low and high water mark so all
!      *     updates can be merged into a single call to elbb_Modify.  It may be
!      *     that it would be more efficient to do separate Modifies if two
!      *     widely separated fields are being updated.
       *
       *     A code block corresponding to each field is maintained by passing
       *     the block to the SET_FIELD macro. */
  
! #define SET_FIELD(b,f,v,n) if (setStatusFlags & (b)) { \
      int o = offsetof (struct diskStatus, f); \
      epix_EnterCodeBlock /* */ (n); \
      if (o < first) first = o; \
***************
*** 1920,1925 ****
--- 1943,1972 ----
      if (!GetOKfile (h, f)) return EPI_E_BADFILE;
      first = sizeof(struct diskStatus);
      last = 0;
+ 
+     /* SPECIAL HACK -- see comments above */
+     if (setStatusFlags == 0 && markFlags == 0 && !status)
+ 	markFlags = EPIF_SFLAGS_VVERSION;
+ 
+     if (markFlags) {
+ 	/* This code depends on the fields being in this order:
+ 	 *   volumeVersionNumber, dataVersionNumber, mTime, cTime, aTime. */
+ 
+ 	if (markFlags & EPIF_SFLAGS_ATIME)
+ 	    last = offsetof(struct diskStatus, aTime) + sizeof(t);
+ 	else if (markFlags & EPIF_SFLAGS_CTIME)
+ 	    last = offsetof(struct diskStatus, cTime) + sizeof(t);
+ 	else if (markFlags & EPIF_SFLAGS_MTIME)
+ 	    last = offsetof(struct diskStatus, mTime) + sizeof(t);
+ 	else if (markFlags & EPIF_SFLAGS_DVERSION)
+ 	    last = offsetof(struct diskStatus, dataVersionNumber)
+ 			+ sizeof(h->status.dataVersionNumber);
+ 	else if (markFlags & EPIF_SFLAGS_VVERSION)
+ 	    last = offsetof(struct diskStatus, volumeVersionNumber)
+ 			+ sizeof(h->status.volumeVersionNumber);
+ 	else return (EPI_E_BADFLAGS);
+ 	first = offsetof(struct diskStatus, volumeVersionNumber);
+     }
      BEGIN_TLOCK_WRITE (trans, &h->lock) {
  	struct diskStatus oldStatus = h->status;
  
***************
*** 1951,1956 ****
--- 1998,2029 ----
  		   parent, status->parent, /* CodeBlock(*/55);
  #endif
  
+ 	if (markFlags) {
+ 	    vol = epiv_GetVolume (f);
+ 	    code = epiv_NewVolumeVersion (trans, vol, &vv);
+ 	    if (code) continue;
+ 	    hset (h->status.volumeVersionNumber, vv);
+ 
+ 	    UniqueTime (&t);
+ 
+ 	    if (markFlags & EPIF_SFLAGS_MTIME) {
+ 		epix_EnterCodeBlock(57);
+ 		h->status.mTime = t;
+ 	    }
+ 	    if (markFlags & EPIF_SFLAGS_CTIME) {
+ 		epix_EnterCodeBlock(58);
+ 		h->status.cTime = t;
+ 	    }
+ 	    if (markFlags & EPIF_SFLAGS_ATIME) {
+ 		epix_EnterCodeBlock(59);
+ 		h->status.aTime = t;
+ 	    }
+ 	    if (markFlags & (EPIF_SFLAGS_DVERSION | EPIF_SFLAGS_MTIME)) {
+ 		epix_EnterCodeBlock(56);
+ 		h->status.dataVersionNumber++;
+ 	    }
+ 	}
+ 
  	if (first < last) {
  	    code = epia_SetStatus (trans, f, first, last-first,
  				   (char *)(&h->status) + first);
***************
*** 1960,2033 ****
  		continue;
  	    }
  	}
-     } END_LOCK;
-     return code;
- }
- 
- /* epif_Mark -- Sets various fields of a file that change often.  The
-  *     \arg{flags} argument specifies which time values to update.  If
-  *     \cst{EPIF_SFLAGS_MTIME} is specified, the file data version number
-  *     is also updated.  In every case (even if flags is 0), the fileset
-  *     version number is updated.
-  *
-  * PARAMTERS --
-  *     trans -- transaction to use for this operation.
-  *     f -- file handle.
-  *     flags -- this determines which fields to change. */
- 
- EXPORT long epif_Mark (trans, f, flags)
-   IN elbb_tranRec_t trans;
-   IN epi_anode_t f;
-   IN long flags;
- {
-     long code;
-     struct fileHandle *h;
-     hyper vv;
-     epi_volume_t vol;
-     struct timeval t;
-     long first, last;			/* offsets bracketing modifications */
- 
-     epix_EnterCodeBlock(56);
-     if (!GetOKfile (h, f)) return EPI_E_BADFILE;
- 
-     /* This code depends on the fields being in this order:
-      *   volumeVersionNumber, dataVersionNumber, mTime, cTime, aTime. */
- 
-     if (flags & EPIF_SFLAGS_ATIME)
- 	last = offsetof(struct diskStatus, aTime);
-     else if (flags & EPIF_SFLAGS_CTIME)
- 	last = offsetof(struct diskStatus, cTime);
-     else if (flags & EPIF_SFLAGS_MTIME)
- 	last = offsetof(struct diskStatus, mTime);
-     else if (flags == 0)
- 	last = offsetof(struct diskStatus, volumeVersionNumber);
-     else return (EPI_E_BADFLAGS);
- 
-     BEGIN_TLOCK_WRITE (trans, &h->lock) {
- 	vol = epiv_GetVolume (f);
- 	code = epiv_NewVolumeVersion (trans, vol, &vv);
- 	if (code) continue;
- 	hset (h->status.volumeVersionNumber, vv);
- 	first = offsetof(struct diskStatus, volumeVersionNumber);
- 
- 	UniqueTime (&t);
- 
- 	if (flags & EPIF_SFLAGS_MTIME) {
- 	    epix_EnterCodeBlock(57);
- 	    h->status.dataVersionNumber++;
- 	    h->status.mTime = t;
- 	}
- 	if (flags & EPIF_SFLAGS_CTIME) {
- 	    epix_EnterCodeBlock(58);
- 	    h->status.cTime = t;
- 	}
- 	if (flags & EPIF_SFLAGS_ATIME) {
- 	    epix_EnterCodeBlock(59);
- 	    h->status.aTime = t;
- 	}
- 	code = epia_SetStatus (trans, f, first, last-first + sizeof(t),
- 			       (char *)&h->status + first);
- 	afsl_MBZ (code);
      } END_LOCK;
      return code;
  }
--- 2033,2038 ----
Delta: bwl-3911-cache-mtime-ctime
Change: file/episode/anode/file.h from 4.17 to 4.18
*** file/episode/anode/file.h
--- 4.18	1994/03/25 19:17:59
***************
*** 8,70 ****
  /*
   * HISTORY
   * $Log:	c012989,v $
# Revision 1.4  96/01/23  13:42:13  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company  
# 
# Revision 1.3  95/08/03  17:45:05  root
# changed fields:  new/changed/deleted note(s) [biyani 8/3/95 public]
# 
-  * Revision 1.1.5.6  1993/01/18  22:03:56  cjd
-  * 	embedded copyright notice
-  * 	[1993/01/18  21:43:29  cjd]
-  *
-  * Revision 1.1.5.5  1993/01/13  16:39:03  shl
-  * 	Transarc delta: cfe-ot6051-four-bits-o-spares 1.1
-  * 	  Selected comments:
-  * 	    Create spares for various non-Unix clients (that will probably never be
-  * 	    ser

CR Number                     : 12988
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : episode
Short Description             : Need error code tracing in efs_agops.c
Reported Date                 : 8/2/95
Found in Baseline             : 1.0.3
Found Date                    : 8/2/95
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : file/episode/vnops/efs_agops.c
Sensitivity                   : public

[8/2/95 public]

FROM Transarc:
SYNOPSIS: Use icl to report error code mapping in efs_agops.c

The file episode/vnops/efs_agops.c has only a single call to
EFS_TRACE_VNOPS yet there are many cases where error codes are being
mapped.  Especially note that failures from epig_InitAggregate are being
mapped silently.  The file needs to be checked for all error code
mapping and a trace entry added to each.

Delta bwl-2621-trace-in-agops 1.2.

[8/3/95 public]


Delta: bwl-2621-trace-in-agops
Change: file/episode/vnops/efs_agops.c from 4.77 to 4.78
*** file/episode/vnops/efs_agops.c
--- 4.78	1994/03/07 22:23:03
***************
*** 40,46 ****
  #include "efs_dirhandle.h"              /* epi_Dir_Handle */
  #include "efs_vfsops.h"			/* efs_sync() */
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012988,v 1.5 95/12/21 15:49:39 root Exp $")
  
  extern struct volumeops vol_efsops;
  extern int afsdb_episode_vnops;	/* the trace control variable */
--- 40,46 ----
  #include "efs_dirhandle.h"              /* epi_Dir_Handle */
  #include "efs_vfsops.h"			/* efs_sync() */
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012988,v 1.5 95/12/21 15:49:39 root Exp $")
  
  extern struct volumeops vol_efsops;
  extern int afsdb_episode_vnops;	/* the trace control variable */
***************
*** 299,306 ****
  
      code = epig_InitAggregate(
  	osi_major(dev), osi_minor(dev), 1, &asdev, &aggh);
!     if (code)
! 	code = ENXIO;
  
      if (code == 0) {
  	dat = (struct ag_efsData *) osi_Alloc(sizeof(struct ag_efsData));
--- 299,308 ----
  
      code = epig_InitAggregate(
  	osi_major(dev), osi_minor(dev), 1, &asdev, &aggh);
!     if (code) {
!         EFS_TRACE_VNOPS(DEBUG_THIS_FILE, code, ENXIO);
!         return ENXIO;
!     }
  
      if (code == 0) {
  	dat = (struct ag_efsData *) osi_Alloc(sizeof(struct ag_efsData));
Delta: bwl-2621-trace-in-agops
Change: file/episode/vnops/efs_agops.c from 4.78 to 4.79
*** file/episode/vnops/efs_agops.c
--- 4.79	1994/03/10 16:01:51
***************
*** 5,11 ****
   * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE in the
   * src directory for the full copyright text.
   */
! /* Copyright (C) 1990 Transarc Corporation
     All rights reserved.
   */
  
--- 5,11 ----
   * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE in the
   * src directory for the full copyright text.
   */
! /* Copyright (C) 1994, 1990 Transarc Corporation
     All rights reserved.
   */
  
***************
*** 40,46 ****
  #include "efs_dirhandle.h"              /* epi_Dir_Handle */
  #include "efs_vfsops.h"			/* efs_sync() */
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012988,v 1.5 95/12/21 15:49:39 root Exp $")
  
  extern struct volumeops vol_efsops;
  extern int afsdb_episode_vnops;	/* the trace control variable */
--- 40,46 ----
  #include "efs_dirhandle.h"              /* epi_Dir_Handle */
  #include "efs_vfsops.h"			/* efs_sync() */
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012988,v 1.5 95/12/21 15:49:39 root Exp $")
  
  extern struct volumeops vol_efsops;
  extern int afsdb_episode_vnops;	/* the trace control variable */
Delta: bwl-2621-trace-in-agops
Change: file/episode/vnops/efs_agops.c from 4.79 to 4.82
*** file/episode/vnops/efs_agops.c
--- 4.82	1994/03/16 21:40:04
***************
*** 40,46 ****
  #include "efs_dirhandle.h"              /* epi_Dir_Handle */
  #include "efs_vfsops.h"			/* efs_sync() */
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012988,v 1.5 95/12/21 15:49:39 root Exp $")
  
  extern struct volumeops vol_efsops;
  extern int afsdb_episode_vnops;	/* the trace control variable */
--- 40,46 ----
  #include "efs_dirhandle.h"              /* epi_Dir_Handle */
  #include "efs_vfsops.h"			/* efs_sync() */
  
! RCSID ("$Header: /project/ot/dce/d01/d29/RCS/c012988,v 1.5 95/12/21 15:49:39 root Exp $")
  
  extern struct volumeops vol_efsops;
  extern int afsdb_episode_vnops;	/* the trace control variable */
***************
*** 301,307 ****
  	osi_major(dev), osi_minor(dev), 1, &asdev, &aggh);
      if (code) {
          EFS_TRACE_VNOPS(DEBUG_THIS_FILE, code, ENXIO);
!         return ENXIO;
      }
  
      if (code == 0) {
--- 301,307 ----
  	osi_major(dev), osi_minor(dev), 1, &asdev, &aggh);
      if (code) {
          EFS_TRACE_VNOPS(DEBUG_THIS_FILE, code, ENXIO);
!         code = ENXIO;
      }
  
      if (code == 0) {



CR Number                     : 12957
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : dfs
Short Description             : replica not current after aggr. detach
Reported Date                 : 7/18/95
Found in Baseline             : 1.1
Found Date                    : 7/18/95
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 1.2.1
Affected File(s)              : several
Sensitivity                   : public

[7/18/95 public]
In a release-replicated environment, a condition occurs which caused the
replica to go bad and the user is unable to get at the replicated data
if the RW and staging replicas are unavailable.
Here is the test scenario:
Machine A:  dfsexport -detach aggregate with R/W and staging replica
            cm checkfilesets
            ls the replicated path - goes to R/O on Machine B
Machine B:  dfsexport -detach aggregate with R/O
Machine A:  dfsexport aggregate with R/W and staging replica
            cm checkf
            ls the replicated path - goes to Machine A
Machine B:  dfsexport aggregate with R/O
Machine A:  dfsexport -detach aggregate with R/W and staging replica
            cm checkf
            ls the replicated path - goes to R/O on Machine B but
            fails with VOLERR_PERS_AGEOLD
The VOLERR_PERS_AGEOLD is due to VVCurrentTime being set to zero.
I placed printf's in the volume detach and attach code and it showed
VVCurrentTime has a valid time the first time the aggregate is detached.
When the aggregate is reattached, the volume's VVCurrentTime is 0.
It appears the repserver cannot "refresh" itself when the aggregate
with replicas on it is detached and reattached when it is using release
replication.  I retried this test using scheduled replication and I do
not see the same failure if I wait a few minutes before trying to access
the data (the time it takes the repserver to do its periodic check?).
 
Added field #Transarc Deltas with value `' 
Added field #Transarc Herder with value `cfe@transarc.com' 
Added field #Transarc Status with value `open'
[1 Aug 1995 public]
I have two deltas that should fix this problem.

[8/16/95 public]
Actually, there are three deltas for the problem.  To fix the base problem,
which is that Episode isn't using the saved ``currtime'' when reattaching
aggregates, you'd need:
	cfe-ot12957-VolInfo-needs-to-set-currtime
To fix some other problems, and to make release-style replication not
cause all sites to fall back to the staging replica after 24 hours, you'll
need the two deltas:
	cfe-ot12957-more-active-repserver-mgt-of-release-replicas
	cfe-ot12957-more-robust-fix
I can make these fixes available to those who request them.

[12/22/95 public]
These deltas are included in what's to be dropped to the OSF in the
1.2.1 drop.



CR Number                     : 12881
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : bos
Short Description             : Bad 'bos lsadmin' output - Unknown message number
Reported Date                 : 5/19/95
Found in Baseline             : 1.1
Found Date                    : 5/18/95
Severity                      : E
Priority                      : 3
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : src/file/userInt/bos/bos_main.c
Sensitivity                   : public

[5/19/95 public]

[5/19/95 public]

(Sorry about the lack of description when ot created, novice ot user)


The bos lsadmin command has bad output:

root@tub> bos lsadmin -server /.:/hosts/tub -adminlist admin.bos
Unknown message number 0x000254c8group: subsys/dce/dfs-admin


This is because a string pointer is being used as an argument to
dce_fprintf() instead of a message index in bos_DoLsUsers().  Also,
charsSoFarOnLine looks like it's being assigned incorrectly.

original code (1.1):

      if (printHeading) {
        error_status_t  st;
        unsigned char   *cmd_explanation;
        cmd_explanation = dce_msg_get_msg(bos_s_admin_users_heading1, &st);
        dce_fprintf(stdout, cmd_explanation);
        free(cmd_explanation);
        charsSoFarOnLine = strlen(headingString);
        /* can't reset printHeading here, because we need it a little later */
      }


proposed new code:

      if (printHeading) {
        error_status_t  st;
        unsigned char   *cmd_explanation;
        cmd_explanation = dce_msg_get_msg(bos_s_admin_users_heading1, &st);
        dce_fprintf(stdout, bos_s_admin_users_heading1);
        charsSoFarOnLine = strlen(cmd_explanation);
        free(cmd_explanation);
        /* can't reset printHeading here, because we need it a little later */
      }



        Steve Strange 5/19/95
        Digital Equipment Corp, DCE DFS on Digital UNIX - Development
        strange@zk3.dec.com



CR Number                     : 12762
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : Piece of FLDB entry being written in host-order, should be network-order
Reported Date                 : 12/6/94
Found in Baseline             : 1.0.3
Found Date                    : 12/6/94
Severity                      : C
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : file/flserver/flprocs.c
Sensitivity                   : public

[12/6/94 public]
Fts test13 was intermittently hanging because of a problem in
VL_CreateServer() path. This routine calls EnsureAddrEntry()
to make sure that an FLDB entry doesn't already exist for the
specified server. For this we need to read server information
from the FLDB and convert it into host format (little endian
for alpha machines). The problem was being caused by a
previous write to the FLDB having written data in the host
format instead of network format. As a result, one of the loop
counters that should have been 0x40 was turning out to be
0x04000000. Not only was this causing us to spend a lot longer
in one of the loops, but when used as an array index, it was
also resulting in bad data accesses.
 
The problem has been fixed by making sure we do an ntohl()
when we read data from the FLDB and an htonl() before writing
stuff back.
 
The fix is in ./file/flserver/flprocs.c
 
Lines marked with '>' are the three new lines added to the code (search for
"firstEmptyBlock = &NextBlock;"):
 
--------------------------
	    }
	    firstEmptyBlock = &NextBlock;
	    firstEmpty = &(firstEmptyBlock->Sites[firstEmptyIndex]);
>	    firstEmptyBlock->NextPtr = ntohl(firstEmptyBlock->NextPtr);
>           firstEmptyBlock->AllocHere = ntohl(firstEmptyBlock->AllocHere);
>           firstEmptyBlock->UsedHere = ntohl(firstEmptyBlock->UsedHere);
	    NextBlockAddr = firstBlockAddr;
	}
 
	bcopy ((char *)Addr, (char *)&(firstEmpty->Addr[0]), 
	       sizeof(afsNetAddr));
--------------------------
 
	Steve Strange, Digital Equipment Corp., 12/6/94

[12/7/94 public]
Oops.  The fix is correct.



CR Number                     : 12760
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : synchronization problems between processes on one client
Reported Date                 : 12/6/94
Found in Baseline             : 1.0.3, 1.1
Found Date                    : 6/6/94
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : several
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : 

[12/6/94 public]
 
We (Digital) have a file exerciser test that attempts to do
open/write/read/close cycles on files.  One option specifies that a number
of processes should try to perform this cycle all on the same file at the
same time.  This results in a number of different errors that can be traced
to race conditions between the processes that are caused by dfs.  We have
made two changes to the dfs code that attempt to eliminate these race
conditions, but it appears that a basic design change would be needed to
address the problem more generally.  In other words, our fixes make the
problem more rare, but don't eliminate it.  I should add that the
problem is very unlikely to occur in normal use of dfs, we just happen to
have a test that induces it.
Problem description
-------------------
 
We have noticed a couple of problems with single-site semantics between
processes accessing the same file on the same client. We have not changed
anything significantly from the reference platform client in our
implementation so we suspect these problems exist in the reference port
as well.
 
The problems have to do with race conditions when opening a file. The
first problem occurs when two processes are creating the same file
simultaneously (QAR 23844), the second problem when one process is
unlinking a file while another is creating a file of the same name
(QAR 24022). The later is the the more significant and difficult to fix
problem. We have fixes for both problems though we're not sure they are
ideal.  
 
An interesting common factor to these problems is that when the two client
processes race for the same or conflicting operations at the server,
the first RPC to reach the server and "succeed" is also the last to
return back to the client presumably because a it is doing more work
there. In the mean time the RPC for the process that losses the race is
already back to the client and potentially finds inconsistent state between
what it just was told on the server and what exists on the client.
I assume that the merge status operations on the client are suppose to
manage this issue but they don't appear in to handle all the possible
same host client to client race-conditions.
 
Creation Race:
 
Two process are trying to simultaneously create a file of the same name.
One process succeeds and the other gets a ENOENT (bad path or file name).
 
What happens
 
The process that fails, first does an RPC to the server and gets that the
file already exists. Because the process that beat it to the server for the
create hasn't yet returned, the failing process finds bogus fid information
for the file on the client in the name hash and returns ENOENT.
 
On the client the sequence is as follows;
 
 Process 1,                     Process 2,
 open(OCREAT) succeeds          open(OCREAT) fails
 ---------------------          --------------------
 
 open(OCREAT, ...)
  cm_lookup()
   nh_dolookup()
    Calls AFS_Lookup()
                                open(O_CREATE, ...)
                                  cm_lookup()
                                   nh_dolookup()
                                    Calls AFS_Lookup()
    AFS_Lookup() rtns no such file
*   nh_enter() enters fid with Vnode set to 0
  cm_create()
   Calls AFS_CreateFile()
                                    AFS_Lookup() rtns no such file
*                                   nh_enter() enters fid with Vnode set to
                                  cm_create()
                                   Calls AFS_CreateFile()
                                   AFS_CreateFile rtns 22 already exists
                                   cm_lookup()
                                    ns_dolookup()
                                        FAILURE
                                        - Finds fid for file with a 0
vnode,
                                        rtns ENOENT.-
   AFS_CreateFile rtns success
   ....
   goes on to successfully create
   the file (and name hash entry and
   scp).
Solution;
 
I removed the call to nh_enter() in nh_dolookup() when AFS_Lookup()
returns ENOENT (*). The AFS_CreateFile by process 2 still fails but
now the ns_dolookup() that follows goes all the way to the server
to get the fid for the file. The fid is then used to either
find or create an scp for the file and process 2's  open
returns success.
 
Code Change;
 
cm_dnamhash.c
 
nh_dolookup()
 
425,439c425,427
<           fidp->Vnode = 0;
<           /* UpdateStatus explains fundamental cache algorithm here.
<            * Note how this works: if dirRevokes increases, it tells us
<            * that a modification occurred to the directory *by some
<            * other client* while our call was running (with the vnode
<            * unlocked).  If startDirChangeTime changes, it tells us
<            * that some other thread on this client made an RPC that
<            * modified the directory (and potentially this name mapping).
<            * If this modification occurred before our lookup, the results
<            * of our lookup are fine.  Since AFS_Lookup doesn't change the
<            * inode change time, the startDirChangeTime should represent
<            * the changeTime at the server when our AFS_Lookup call
executed.
<            * Even if our call changed the ctime, we'd just take the
<            * "invalidate" (nh_delete) branch below, which is always
<            * safe to do.
---
>           /*
>            * Always delete entry. solves race on multiple open(OCREAT..)
>            * by client processes of the same file.
441,445c429
<           if (irevcnt == dscp->dirRevokes &&
<               cm_tcmp(dscp->m.ServerChangeTime, startDirChangeTime) <= 0)
<               nh_enter(dscp, namep, fidp);
<           else
<               nh_delete(dscp, namep);
---
>            nh_delete(dscp, namep);
 
Brad Nichols, 6/29/94
Open Unlink Race:
 
One process is trying to unlink a pre-existent file while another is trying
to
open it with an O_CREAT flag. The unlink succeeds and the opening process
gets
EINVAL (invalid argument).
 
What happens;
 
As with the other problem the failing process gets the late start. A lookup
says that the file exists on the server. The process then goes for tokens
also at the server but buy this time the AFS_RemoveFile() by the other
process
has nuked the vnode on the server. The get tokens operation on the server
fails because of invalid argument, the non-existent vnode.
 
On the client the sequence is;
 
        Process 1,                      Process 2,
        unlink() succeeds               open(O_CREAT) fails
        ---------------------           --------------------
 
                                        close()
 
        close()
        unlink()
         AFS_RemoveFile()
 
                                        unlink()
                                         AFS_Remove()
                                         AFS_Remove() rtns ENOENT
 
                                        open()
                                         cm_lookup(), finds fid in name
hash
                                         cm_open()
                                          cm_GetToken()
                                           AFS_GetToken()
 
         AFS_RemoveFile() rtns success
         merge status of parent dir
         merge status of file
 
                                           AFS_GetToken() rtns invalid arg
                                           FAILURE
                                           - because a VOL_VGET() on server
                                           couldn't find the vnode of the
fid. 
 
        .....
Solution;
 
The open() wants to use a fid/scp to get tokens on the
file. The unlink() may invalidate them (the fid specifically)
but won't do so on the client until its AFS_RemoveFile() returns.
 
To prevent the open() processes from using fid/scp data that
may be invalid on the server. I added code to mark a scp
as the target of an in-progress remove on the server. The
cm_remove() puts the mark on and the cm_lookup() watches for
the mark. The mark is an additional flag named SC_UNLINKING to
the scp states field.
 
To add this feature the cm_remove() was modified to lookup the
fid of the file it is deleting, retrieve the scp and mark it,
all before it makes the AFS_RemoveFile(). Previously the
cm_remove() only need the file fid and scp after the
AFS_RemoveFile() returned. When the RPC returns, regardless of
success or failure, cm_remove() removes the mark from the file
scp and wakes any threads that might be waiting on that flag.
 
The cm_lookup was modified to check for an unlinking mark
before using a scp. If the unlinking flag is set, cm_lookup()
sleeps waiting for it to clear.
Code
 
cm_scache.h
 
550a551
> #define SC_UNLINKING    0x400000        /* A client is doing a
AFS_remove() o
cm_vnodeops.c
 
cm_lookup()
2665a2666,2672
>           /* Check to see if a cm_remove() is trying to unlink this
>            * same file. If so wait till it clears.
>            */
>           while (tscp->states & SC_UNLINKING)  {
>             osi_SleepW((opaque)(&tscp->states),&tscp->llock);
>             lock_ObtainWrite(&tscp->llock);
>           }
cm_remove()
 
3060a3068
>     afsFid tfid;
3098a3107,3133
>
>     /* Lookup fid for file. (may mean rpc to server) if there is
>      * no fid, we'll return no such file.
>      */
>     code = nh_dolookup(dscp, namep, &tfid, &rreq);
>     if (code == ENOENT) {
>       /*
>        * Name is known not to exist.
>        */
>       code = ENOENT;
>       goto done;
>     }
>
>     /* Grab an scache entry for the fid.
>      */
>     scp = cm_GetSCache(&tfid, &rreq);
>     if (!scp) {
>       code = ENOMEM;
>       goto done;
>     }
>
>     /* Mark scp as having a unlink attempt in-progress.
>      */
>     lock_ObtainWrite(&scp->llock);
>     scp->states |= SC_UNLINKING;
>     lock_ReleaseWrite(&scp->llock);
>
3115c3150
<       goto done;
---
>       goto bad1;
3126c3161
<       goto done;
---
>       goto bad1;
3129c3164
<      * Now, get vnode for unlinked dude, and see if we should force it
from
---
>      * Now, look at vnode for unlinked dude, and see if we should force
it fr
3134,3140d3168
<     lock_ObtainWrite(&cm_scachelock);
<     scp = cm_FindSCache(&OutDelFileFid);
<     if (!scp) {
<       scp = cm_NewSCache(&OutDelFileFid, dscp->volp);
<     }
<     lock_ReleaseWrite(&cm_scachelock);
<     if (scp) {
3155a3184,3192
> bad1:
>     /* Unmark scp as being in an unlink.
>      */
>     scp->states &= ~SC_UNLINKING;
>
>     /* Wakeup anybody waiting for unlink to complete
>      */
>     osi_Wakeup(&scp->states);
>
3160c3197
<     }
---
>
----------------
end descriptions
As I mentioned at the top of this file, these two fixes help the race
situation, but don't completely eliminate it.  I believe the problem lies
in the fact that DFS maintains an active file reference count of the number
of different client hosts accessing a given file, rather than the total
number of processes accessing a given file.  In other words, if two
processes on a single client are accessing a single file, the server sees
it as only one process, because all the requests are coming from one
client.  The server cannot distinguish between different processes on a
single client.  I hope that someone will correct me if I have made the
wrong conclusion from investigating the code and icl traces here.
 
	Steve Strange, Digital Equipment Corp.  12/6/94

[12/6/94 public]
These analyses are pretty much on the money.  Transarc has found these and
several other comparable bugs that have required this kind of fix.
I believe, though, that we've fixed them with a minimum of un-cacheing.
It would take some analysis to go back and reconstruct exactly what we've
done to deal with these two scenarios.  I think that for the first one,
when we get EEXIST from AFS_CreateFile, we do some further analysis
and hook into the race at that point, rather than never cacheing the
ENOENT from AFS_Lookup.  (Avoiding that cacheing will have a significant
performance penalty.)  I don't remember what we did for the second case,
but I believe that we handled it in another way.
 
It's true that, generally, token conflicts are used to assure consistency
for these matters between clients, while the problems for multiple processes
within a single client are addressed in other ways, like careful updates
to the DNLC mediated by these time progressions and numbers of revocations.

[12/7/94 public]
.
I'll elaborate on Craig's reply, which is correct as far as it goes.
.
We have discovered the same problems.  Internally at Transarc, the defect has
reference number 5758, although there is also some connection with 5418.
.
In general, there are races between lookups, creations, and deletions.  The
two you have mentioned are by no means the only ones.
.
Our defect 5418 observed that if a client had a reference to a vnode, but
didn't have the vnode open, another client might delete the file, and the
first client's reference might become stale.  We fixed this by adding new
semantics to TKN_OPEN_PRESERVE, so that a client would not return this token
type or allow it to be revoked if there the vnode had a high reference count.
The server, in turn, would not delete the file unless it could revoke this
token.  Changes to implement this were extensive.  Among other changes, both
cm_GetSCache and nh_dolookup check for TKN_OPEN_PRESERVE after merging the
status of the RPC.  Thus those functions now systematically detect races of
the kinds described in this OT report.
.
cm_lookup calls first nh_dolookup, then cm_GetSCache.  Either of these can
uncover a stale vnode.  The straightforward recovery is simply to retry, i.e.
go back and call nh_dolookup again, etc.  This was the first change I
implemented under defect 5758.  cm_create, which follows the same sequence,
will retry similarly.  An arbitrary limit on the number of retries (10) was
set, in order to avoid non-interruptible infinite loops.  Also, the retry is
done only if nh_dolookup returns a different fid each time, since if it keeps
returning the same fid, the likelihood is that the directory on the server is
damaged and the directory entry is giving a bogus fid.
.
Of course, it was necessary to change the signature of cm_GetSCache, so that
in case of failure, the caller could determine whether the failure was due to
a race (ESTALE) or some other condition (e.g. ETIMEDOUT).  The retry would be
done only for ESTALE.
.
This retrying doesn't help in the case where cm_create does the AFS_CreateFile
RPC and it returns successfully, but the subsequent MergeStatus leaves us with
a stale vnode (because in the mean time the file has been deleted).  There is
no completely correct recovery in this case.  However we found that many of
these races could be avoided by suitably modifying cm_remove and cm_rmdir.  In
those functions we now call nh_delete() before doing the RPC, rather than
waiting until after.  (We still call nh_delete() after the RPC, but it is now
usually redundant.)  The advantage of calling nh_delete() before the RPC is
that if there is a create on the same client concurrently with the remove or
rmdir, the nh_dolookup call done by the create will go to the server, rather
than relying on a name-hash entry that is in the process of becoming invalid.
It's still possible for a race to occur, but it's less likely.
.
Looking at the changes you (DEC) have suggested, I believe that our changes
are more systematic, but I think that your changes would be a reasonable
stopgap measure.
.
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `'

[12/7/94 public]
In the above note, I mentioned that we added new semantics to TKN_OPEN_PRESERVE.
I forgot to add that this was a client-only change.  The server code already
handles TKN_OPEN_PRESERVE the way we wanted it to (i.e. it conflicts with
TKN_OPEN_DELETE).  So our change did not create an interoperability problem.
.

[12/27/94 public]
This sounds like an important testcase to run for regression testing and, as
Bruce pointed out, for interoperability testing. Rich, can we add either the
Dec test or the similar testcases Transarc uses to the FVTs you are planning
on delivering with 1.2? The ideal case would be to submit it early enough for
the ILab to have access to it in time for IFEST (which is in June?) - Let
me know - thanks.



CR Number                     : 12740
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : flserver
Short Description             : UHYP: flserver fails to startup during config
Reported Date                 : 11/1/94
Found in Baseline             : 1.1b23
Found Date                    : 11/1/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 1.1unintegrated, 1.1maint
Affected File(s)              : flutils.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/1/94 public]

During startup flserver looks for the dfs-server principal to make
sure it exists.  It does this with a call to
sec_rgy_pgo_get_by_name().  Unfortunatly the cursor handle was never
inititalized, causing flserver to not find the principal in some
cases.  The following change to flutils.c fixes this problem.

*** ./flutils.c	Wed Jul 13 18:19:22 1994
--- /tmp/flutils.c	Mon Oct 31 15:04:06 1994
***************
*** 1017,1022 ****
--- 1017,1023 ----
     sec_rgy_site_open((unsigned_char_t *) NULL, &sechandle, &st);
     if (st != 0)
         return(st);
+    sec_rgy_cursor_reset(&cursor);
     sec_rgy_pgo_get_by_name(sechandle, sec_rgy_domain_person,
                             princp, &cursor, &pgo_item, &st);
     sec_rgy_site_close(sechandle, &st2);

[10/4/96 public]

  This fix was included in 1.1 maintenance tree in Feb. 1996.



CR Number                     : 12708
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : unknown
Short Description             : RIOS crashed w/in 1 hour of CHO
Reported Date                 : 10/24/94
Found in Baseline             : 1.1b23
Found Date                    : 10/24/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public

[10/24/94 public]

In what was to be the final run of CHO for DCE 1.1 DFS, the RIOS
crashed w/in 1 hour. The crash dump was not useful, even though
there was plenty of space to collect one. The CHO config is:

1 RIOS X 3 HP
m1 (R) = security server, dts server, flserver, fileserver (native and lfs)
m2 (H) = cds server, dts server, flserver, fileserver (native and lfs)
m3 (H) = dts server, flserver, fileserver (native and lfs)
m4 (H) = client-only.

test    run on          to fileset on   fileset type
----    ------          -------------   ------------
repfs   m1 (R)          m1 (R), m3 (H)  lfs

acl     m2 (H)          m1 (H)          lfs
cthon   m2 (H)          m3 (H)          hfs

repfs   m3 (H)          m3 (H), m1 (H)  lfs

acl     m4 (H)          m2 (H)          lfs
cthon   m4 (H)          m1 (R)          jfs
fts     m4 (H)          m3 (H), m1 (R)  lfs

NOTE: the 2 copies of the ACL functional tests were NOT running
at the time of the crash. IBM mentioned that they had been seeing
crashes recently so I'm hoping they can supply more information here.

[10/26/94 public]
Reluctantly defer'ed.

[2/16/96]

We believe this won't recure.  Please reopen the defect if it does.



CR Number                     : 12650
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : UHYP:README file needed for FVT directory
Reported Date                 : 10/18/94
Found in Baseline             : 1.1b22
Found Date                    : 10/18/94
Severity                      : C
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : src/test/file/README
Sensitivity                   : public

[10/18/94 public]

The test/file directory contains directories that are not used by
OSF.  This should be clarified for future project's use and for our
licensees.  Specifically, there are tests in that tree for user space
delegation, where that funcitonality is not supported in 1.1.



CR Number                     : 12634
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : tkm
Short Description             : potential for free() on bogus ptr
Reported Date                 : 10/17/94
Found in Baseline             : 1.1
Found Date                    : 10/17/94
Severity                      : B
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public

[10/17/94 public]
Daryl Kinney at HP found this.  Here's his mail.  Susan, I think this
should be a UHYP.

> From kinney@apollo.hp.com Thu Oct 13 15:41:57 1994
> Received: from relay.hp.com (relay.hp.com [15.255.152.2]) by postman.osf.org (8.6.9/8.6.x) with ESMTP
> 	id PAA12111 for <rsarbo@osf.org>; Thu, 13 Oct 1994 15:41:55 -0400
> Received: from it_750.ch.apollo.hp.com by relay.hp.com with SMTP
> 	(1.37.109.11/15.5+ECS 3.3) id AA044377314; Thu, 13 Oct 1994 12:41:54 -0700
> Message-Id: <199410131941.AA044377314@relay.hp.com>
> Received: from seki.ch.apollo.hp.com by it_750.ch.apollo.hp.com 
> 	for rsarbo@osf.org
> 	id AA17821; Thu, 13 Oct 1994 15:41:53 -0400    
> To: rsarbo@osf.org
> Subject: DFS bug we just found
> Date: Thu, 13 Oct 1994 15:41:53 -0400
> From: Daryl Kinney <kinney@apollo.hp.com>
> Status: R
> 
> 
> Hi Ron (assuming you're still there)
> 
> While looking for a token manager bug, we stumbled on the
> following (our problem ended up being a bug in some 1.0.2a clients
> here).  I leave it up to you (or someone else there) to decide
> what to do with it -- given the 1.1 state.
> 
> The bug was found in 1.0.3a ... although it appears to exist in 1.1
> as well.  Note that the bug appears to be potentially serious, I can't
> say for certain that it ever bit us.
> 
> The bug is in tkm_Byterange_Complement() in tkm_range.c.  Specifically:
> if the two ranges it is given are identical, it sets resultP->lo to
> point at one of the ranges passed to it.  Unfortunately: its caller (in
> tkm_fidHash.c) will osi_Free() anything it finds there ..... specifically,
> it will end up osi_Free()'ng the middle of a tkm_internalToken_t.  This
> routine has to allocate whatever it wants the resultP->lo,hi pointers to
> point at.
> 
> I changed this routine to the following (below my signature).
> 
> -Daryl
> 
>  +--------------------------------------------------------+
>  |  Daryl Kinney               Hewlett Packard, OSSD/CSSL |
>  |  kinney@ch.hp.com           PHONE:  (508) 436-4922     |
>  |                             FAX:    (508) 436-5122     |
>  |                             TELNET:       436-4922     |
>  +--------------------------------------------------------+
> 
> 
> EXPORT void tkm_Byterange_Complement(universeRangeP, partiallyEnclosedRangeP, resultP)
>      IN tkm_byterange_p 	universeRangeP;
>      IN tkm_byterange_p 	partiallyEnclosedRangeP;
>      OUT tkm_byterangePair_p	resultP;
> {
>   tkm_byterange_t enclosedRange;
> 
>   /*
>    * Note: our caller will osi_Free() anything it finds in these two pointers!
>    */
>   resultP->lo = (tkm_byterange_p)NULL;
>   resultP->hi = (tkm_byterange_p)NULL;
> 
>   /*
>    * If the ranges are the same, there is no complement, so only do anything
>    * if it is NOT true that both bounds coincide.
>    */
>   if ((hcmp(universeRangeP->lowBnd, partiallyEnclosedRangeP->lowBnd) != 0) ||
>       (hcmp(universeRangeP->upBnd, partiallyEnclosedRangeP->upBnd) != 0)) {
> 
>     tkm_Byterange_Intersection(universeRangeP, partiallyEnclosedRangeP, &enclosedRange);
> 
>     tkm_Byterange_New((tkm_byterange_p)NULL, &(resultP->lo));
>     TKM_BYTERANGE_SET_RANGE(resultP->lo,
> 			    &(universeRangeP->lowBnd), &(universeRangeP->upBnd));
>     
>     if (! TKM_BYTERANGE_IS_EMPTY(&enclosedRange)) {
>       
>       if (hcmp(universeRangeP->lowBnd, enclosedRange.lowBnd) == 0) {
> 	hset(resultP->lo->lowBnd, enclosedRange.upBnd);
> 	hadd32(resultP->lo->lowBnd, 1);
>       }
>       else {
> 	if (hcmp(universeRangeP->upBnd,  enclosedRange.upBnd) == 0) {
> 	  hset(resultP->lo->upBnd, enclosedRange.lowBnd);
> 	  tkm_hyper_Decrement(&(resultP->lo->upBnd));
> 	}
> 	else {
> 	  /* the enclosed range is strictly enclosed by the universe, so there will be 
> 	     two pieces to the complement range */
> 	  TKM_BYTERANGE_SET_RANGE(resultP->lo,
> 				  &(universeRangeP->lowBnd),
> 				  &(enclosedRange.lowBnd));
> 	  tkm_hyper_Decrement(&(resultP->lo->upBnd));
> 
> 	  tkm_Byterange_New((tkm_byterange_p)NULL, &(resultP->hi));
> 	  TKM_BYTERANGE_SET_RANGE(resultP->hi,
> 				  &(enclosedRange.upBnd),
> 				  &(universeRangeP->upBnd));
> 	  hadd32(resultP->hi->lowBnd, 1);
> 	}
>       }
>     }
>   }
> }
> 
> 
> 
> 
>



CR Number                     : 12633
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : UYHP:anonymous uuid mapping not done
Reported Date                 : 10/17/94
Found in Baseline             : 1.1
Found Date                    : 10/17/94
Severity                      : B
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : src/file/fshost/fshs_deleg.c, src/file/fshost/fshs_subr.c, src/file/fshost/fshs_prutils.c
Sensitivity                   : public

[10/17/94 public]
Enforcing target or delegate restrictions in security means mapping
certain identities to a well known "anonymous uuid".  Unfortunately,
that anonymous uuid is not compatible with DFS.  A mapping needs
to be implemented in DFS to the DFS anonymous uuid in these cases.  
Susan, I think this should be a UHYP.



CR Number                     : 12629
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa, i486
S/W Ref Platform              : hpux, osf1
Component Name                : dfs
Subcomponent Name             : unintegrated multi machine Smoketest
Short Description             : UHYP: you are not authorized for this operation
Reported Date                 : 10/14/94
Found in Baseline             : 1.1
Found Date                    : 10/14/94
Severity                      : A
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : src/config/dfs_config
Sensitivity                   : public

[10/14/94 public]

Rich, 

	Is this an acl problem or has this been backed out

				Regards,

					Pete

Too few servers (2), need 3 servers
/opt/dcelocal/bin/bos: failed to add group 'subsys/dce/dfs-admin' (you are not authorized for this operation (dfs / bbs
))
/opt/dcelocal/bin/bos: failed to create new server instance flserver of type 'simple' (you are not authorized for this
operation (dfs / bbs))
Checking for a Ubik sync site in  hosts/berlin
udebug: failed to obtain ubik server information; Communications failure (dce / rpc)
Checking for a Ubik sync site in  hosts/berlin
udebug: failed to obtain ubik server information; Communications failure (dce / rpc)
Checking for a Ubik sync site in  hosts/berlin
udebug: failed to obtain ubik server information; Communications failure (dce / rpc)
Checking for a Ubik sync site in  hosts/berlin
udebug: failed to obtain ubik server information; Communications failure (dce / rpc)
Checking for a Ubik sync site in  hosts/berlin
udebug: failed to obtain ubik server information; Communications failure (dce / rpc)
Checking for a Ubik sync site in  hosts/berlin
udebug: failed to obtain ubik server information; Communications failure (dce / rpc)
Checking for a Ubik sync site in  hosts/berlin
udebug: failed to obtain ubik server information; Communications failure (dce / rpc)
1994-10-14-13:42:44.225-04:00I----- dtsd WARNING dts config logevent_v_ultrix.c 269 0x7aff92c0
Too few servers (2), need 3 servers

[10/15/94 public]
The ACL changes were backed out.  Not sure what this is.

[10/17/94 sally]
This seems to have gotten lossed - and shouldn't have.  We saw this problem
again this morning in the multi-machine smoketest.  I added UHYP to the
short description so it doesn't get lossed again, we are investigating whether
or not this is a setup problem with unintegrated, could someone else 
investigate whether or not they think this could be a code defect.  Please
consider the fact that the unintegrated tree opened on the 6th, and any of
the changes that were made to the mainline tree after that may need to be
submitted to unintegrated as well.

[10/17/94 sally]
Some lines were dropped in the HP dfs_config submit for the gateway
enhancements.  I'm wondering if this was just an oversight or if there
was a reason?  These lines need to show up at the end of dfs_rgy_init().

+     # We need to dce_login here, even if we are already, to pick up
+     # the fact that cell_admin is now a member of the
+     # subsys/dce/dfs-admin group (which is used in ACL's that, e.g.
+     # bosserver, checks).
+     log_msg DEBUG "Log in again to pick up changes to the registry for DFS."
+     dcelogin || exit 1

I'll be submitting this tonight to get the smoketest working again even if
I don't hear back from HP.



CR Number                     : 12628
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : fts
Short Description             : UHYP: memory alloc error causes core dump
Reported Date                 : 10/14/94
Found in Baseline             : 1.1b22
Found Date                    : 10/14/94
Severity                      : B
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 1.1unintegrated, 1.1maint
Affected File(s)              : file/userInt/fts/volc_main.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/14/94 public]

when the fts command allocates memory for default path names in the
defaultPath() routine it uses osi_Alloc.  The memory is then released
with the free() routine which causes a bus error.  Instead malloc
should be used in place of osi_Alloc.

This is causing numerous errors in the fts functional tests

The changes needed are:

*** /project/dce/build/dce1.1/src/file/userInt/fts/volc_main.c  Thu Sep 29 17:04:35 1994
--- volc_main.c Fri Oct 14 11:17:28 1994
***************
*** 845,853 ****
      if (oelt >= 0 && as->parms[oelt].items != NULL) return;
      if (as->parms[pelt].items == NULL) {
        /* allocate an item representing "." */
!       ti = (struct cmd_item *) osi_Alloc(sizeof(struct cmd_item));
        ti->next = (struct cmd_item *) 0;
!       ti->data = (char *) osi_Alloc(2);
        strcpy(ti->data, ".");
        /* and push it into place */
        as->parms[pelt].items = ti;
--- 845,853 ----
      if (oelt >= 0 && as->parms[oelt].items != NULL) return;
      if (as->parms[pelt].items == NULL) {
        /* allocate an item representing "." */
!       ti = (struct cmd_item *) malloc(sizeof(struct cmd_item));
        ti->next = (struct cmd_item *) 0;
!       ti->data = (char *) malloc(2);
        strcpy(ti->data, ".");
        /* and push it into place */
        as->parms[pelt].items = ti;

[10/4/96 public]

  This fix was included in 1.1 maintenance tree in Feb. 1996.



CR Number                     : 12517
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : flserver
Short Description             : flserver coredump - relock of mutex
Reported Date                 : 10/5/94
Found in Baseline             : 1.1b20
Found Date                    : 10/5/94
Severity                      : A
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public

[10/5/94 public]

3 machine/flserver cell (2 HPs, 1 Rios) - dfs.read_write_all.main test
running w/ 4 users. The flserver on one of the HPs coredumped with a
cma_dump.log. The core file was not useable BUT the cma_dump.log was
full of details ... Is there any way to track the problem using this
(and the bl-20 flserver and libdce?)

[2/16/96]

We believe this won't recur.  Please reopen the defect if it does.



CR Number                     : 12385
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : tpq_trace.h should NOT be in export/<context>/usr/lib
Short Description             : tpq_trace.h should NOT be in export/<context>/usr/lib but in export/<context>/usr/include
Reported Date                 : 9/28/94
Found in Baseline             : 1.1
Found Date                    : 9/28/94
Severity                      : D
Priority                      : 3
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public

[9/28/94 public]
tpq_trache.h which gets build from the file/tpq directory should
not be in export/<context>/usr/lib but export /<context>/usr/include.

To fix it, there should be a line in the file/tpq/Makefile as such:
    tpq_trace.h_EXPDIR=/usr/include/???

(I am not sure whether it should just be in /usr/include or 
/usr/include/dcedfs). 

The problem that this header file gets put in the export /usr/lib 
is because of EXPDIR which is set to /usr/lib.



CR Number                     : 12038
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : assert panic in tkm_Token_SetNonSuccessTokenPosition()
Reported Date                 : 9/2/94
Found in Baseline             : 1.0.3
Found Date                    : 9/2/94
Severity                      : A
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public

[9/2/94 public]

A short while ago we experienced a panic in the function
tkm_Token_SetNonSuccessTokenPosition()  (in tkm_getToken.c).  The
problem is that it was passed a null theTokenP argument (1st arg) ...
and this triggered the osi_assert() near the top.

For unknown reasons, we weren't able to get a full stack trace ... so
I examined all 5 of its callers to try and deduce who called it.  It
wasn't hard to rule out 4 of the 5 (they were in paths that already
verified that the value being passed to it was non-NULL).  The 5th
appears to be the culprit ... with a bug.  NOTE: I don't pretend to
understand this code (and don't want to, given that it's being changed
for 1.2) -- so I might be missing something.

I believe that the bug is in the first (of four) call to
tkm_Token_SetNonSuccessTokenPosition() from within tkm_GetToken(). In
our case, the wvMarkerTokenP value passed as the first argument was NULL.
This wvMArkerTokenP value was obtained via an earlier call to
tkm_Token_EstablishFidPriority() ... which apparently returned/left it
as NULL.

   (Plausible since the console was littered with TKM_ERROR_NOMEM messages
    at the time.)

I see nothing protecting us from calling
tkm_Token_SetNonSuccessTokenPosition() with such a null pointer returned by
tkm_Token_EstablishFidPriority().

My current plan is to surround this call with a protective test on
the pointer - as shown below.  It seems safe and ought to fix this
particular panic (who knows what other problems there are when
tkm_TokenFreeList_ObtainToken() cannot conjure up a token to hand out).  If
this really is a bug, I'll leave it to someone at Transarc to come up with
a more thorough/clever fix if appropriate.

New lines are marked by a "*".

*    if (wvMarkerTokenP != NULL) {
	  (void)tkm_Token_SetNonSuccessTokenPosition(wvMarkerTokenP, 
		volFidHashCellP, /* forceRemove = */ 1, rtnVal);
	  tkm_Token_DisposeToken(wvMarkerTokenP);
*    }

Based on a quick glance, this code appears to be unchanged at 1.1.

[11/03/94 public]

Found a couple of bugs in tkm_Byterange_Complement().

(The first one of these, I think, was already entered by Ron into an
 OT.  I couldn't remember/find it, so I'm copying it here as well.)

(FIRST)
When given two equal byte ranges, it cannot set resultP->lo to point
at one of the ranges given it.  Why?  Because its caller in tkm_fidHash.c
will osi_Free() anything it finds in one of the resultP->lo,hi pointers.
This routine HAS to allocate anything that it wants these fields to
point at.

(SECOND)
To protect against the case where the partiallyEnclosedRange token is a
proper superset of the universeRange one, the check near the top should
be:

  if ((hcmp(universeRangeP->lowBnd, partiallyEnclosedRangeP->lowBnd) < 0) ||
      (hcmp(universeRangeP->upBnd, partiallyEnclosedRangeP->upBnd) > 0)) {

instead of

  if ((hcmp(universeRangeP->lowBnd, partiallyEnclosedRangeP->lowBnd) != 0) ||
      (hcmp(universeRangeP->upBnd, partiallyEnclosedRangeP->upBnd) != 0)) {

This was giving rise to bogus tokens with a lowBnd > upBnd.
This in turn was somehow giving rise to stranded tokens in a PENDING
state.  I don't know what this connection was, but I assume it has to do
with the cleanup of the slice-n-dice tokens left in a PENDING state
after the client call returns.  I suspect that "bogus looking tokens" are
somehow being forgotten about ... and hence not cleaned up.



CR Number                     : 11834
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : systest
Short Description             : UHYP: dfs.fmul has load but not fileset move
Reported Date                 : 8/23/94
Found in Baseline             : 1.1b16
Found Date                    : 8/23/94
Severity                      : B
Priority                      : 0
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1unintegrated
Affected File(s)              : fmul.server.c fmul.routines.c fmul.client.c
Sensitivity                   : public

[8/23/94 public]

The dfs.fmul (fileset move under load) test, which is based on
the IBM partial file locking test dcedflck, but which uses dce
rpc rather than the IBM test harness, needs to be submitted to
the 1.1 dfs system test tree. The test will be submitted in 2
phases:
	- initial submit (client and server code, IBM command file)
	- driver script and fixes to client and/or server code and command file

"Fixes" will include support for advanced fileset features such as
moving filesets, cloning filesets, etc.

[8/23/94 public]
dfs.fmul code compiles under both RIOS and HP, however it hasn't been
executed on RIOS yet.  Also there are some bugs with using on a single
machine cell.

[9/1/94 public]
dfs.fmul RPC now working, current problem is the l_lock call using
fork - this needs to be made threaded.

[9/27/94 public]
Changed from defect to enhancement.

[10/13/94 public]
Slated for unintegrated if time permits.

[10/24/94 public]
The current state of dfs.fmul:
 * The load code is working, but the fileset move code is not written.
 * There are still some minor errors.
     - The fmul_lockf.cf generates some errors (I suspect that the
       configuration file itself will need to be adjusted.)
     - The behavior of F_TLOCK seems to be different on RIOS than HP.
 * Built and tested on RIOS and HP, used onemachine.cf, twomachine.cf,
   threemachine.cf and fmul_lockf.cf configuration files (listed below).
 * Currently, this test will lock (with and without blocking), test,
   and unlock on different machines.
 * It should eventually use the locking to create a load to test
   fileset move under load.
 * Currently, to run:
     - DCE and DFS must be running on the server and client machines.
     - Start up the appropriate number of servers (it is not required
       that they be on different machines).  The only argument for
       fmul.server is the optional -d for debug.
     - Run the client test.  Required arguments are:
          fmul.client -f {configuration file} -s {number of servers}
          -n {name of file to lock}  -p {path to lock file}
       There is an optional argument for debugging, -d.





The configuration files:
------------------------ cut here : begin onemachine.cf ----------------------
#
# The name of the file to create and lock: (the line must begin with an F)
#
F <filename>

#
# The path to the lock file the parent uses
#
P <pathname>

#
# Client information:  defines how many different clients there are and where
# 		      they will be executing.
# where..
# Delimiter must be a C in the first column of each line.
# Number (1-n) is an identification number used by the parent to differentiate
#	clients from one another.
# Hostname is the name of the machine where the client will execute.
#
#Delimiter	Number (1-n)	Hostname	Pathname
#-----------------------------------------------------------------------------
C		1		machA		<path-to-file>

#Actor 	Action		Action Args
#-----------------------------------------------------------------------
l -----------------------------------------------------------------------------
l LOCKF - Same range
l -----------------------------------------------------------------------------
p	CLEAR_LOCKFILE
1	L_LOCK		0	100	a	p
p	L_LOCK_GRANTED	1
# the following L_TEST should fail because it is on the same server as the
# lock.  Locking is per process not per filedes.
1	L_TEST		0	100	f
1	L_ULOCK		0	100	
1	L_TEST		0	100	f
1	L_TLOCK		0	100	c	p
p	L_LOCK_GRANTED	1
# the following L_TEST should fail because it is on the same server as the
# lock.  Locking is per process not per filedes.
1	L_TEST		0	100	f
1	L_ULOCK		0	100	
1	L_TEST		0	100	f
p	CLEAR_CHILDREN
------------------------ cut here : end onemachine.cf ------------------------



------------------------ cut here : begin twomachine.cf ----------------------
#
# The name of the file to create and lock: (the line must begin with an F)
#
F <filename>

#
# The path to the lock file the parent uses
#
P <pathname>

#
# Client information:  defines how many different clients there are and where
# 		      they will be executing.
# where..
# Delimiter must be a C in the first column of each line.
# Number (1-n) is an identification number used by the parent to differentiate
#	clients from one another.
# Hostname is the name of the machine where the client will execute.
#
#Delimiter	Number (1-n)	Hostname	Pathname
#-----------------------------------------------------------------------------
C		1		machA		<path-to-file>

#Actor 	Action		Action Args
#-----------------------------------------------------------------------
l -----------------------------------------------------------------------------
l LOCKF - Same range
l -----------------------------------------------------------------------------
p	CLEAR_LOCKFILE
1	L_LOCK		0	100	a	p
p	L_LOCK_GRANTED	1
2	L_TEST		0	100	p
1	L_ULOCK		0	100	
2	L_TEST		0	100	f
1	L_TLOCK		0	100	c	p
p	L_LOCK_GRANTED	1
2	L_TEST		0	100	p
1	L_ULOCK		0	100	
2	L_TEST		0	100	f
p	CLEAR_CHILDREN
------------------------ cut here : end twomachine.cf ------------------------



------------------------ cut here : begin threemachine.cf --------------------
#
# The name of the file to create and lock: (the line must begin with an F)
#
F <filename>

#
# The path to the lock file the parent uses
#
P <pathname>

#
# Client information:  defines how many different clients there are and where
# 		      they will be executing.
# where..
# Delimiter must be a C in the first column of each line.
# Number (1-n) is an identification number used by the parent to differentiate
#	clients from one another.
# Hostname is the name of the machine where the client will execute.
#
#Delimiter	Number (1-n)	Hostname	Pathname
#-----------------------------------------------------------------------------
C		1		machA		<path-to-file>

#Actor 	Action		Action Args
#-----------------------------------------------------------------------
l -----------------------------------------------------------------------------
l LOCKF - Same range
l -----------------------------------------------------------------------------
p	CLEAR_LOCKFILE
1	L_LOCK		0	100	a	p
p	L_LOCK_GRANTED	1
2	L_TEST		0	100	p
1	L_ULOCK		0	100	
2	L_TEST		0	100	f
1	L_TLOCK		0	100	c	p
p	L_LOCK_GRANTED	1
2	L_TEST		0	100	p
1	L_ULOCK		0	100	
2	L_TEST		0	100	f
p	CLEAR_CHILDREN
# blocking tests
p CLEAR_LOCKFILE
1	L_LOCK		0	100	a	p
p	L_LOCK_GRANTED	1
2	L_TEST		0	100	p
3	L_LOCK		0	100	a	b
1	L_ULOCK		0	100	
2	L_TEST		0	100	p
p	L_LOCK_GRANTED	3
3	L_ULOCK		0	100	
2	L_TEST		0	100	f
p	CLEAR_CHILDREN
------------------------ cut here : end threemachine.cf ----------------------



------------------------ cut here : begin fmul_lockf.cf ----------------------
#
#	@OSF_COPYRIGHT@
#
# HISTORY
# $Log:	c011834,v $
# Revision 1.9  94/10/27  11:12:33  root
# changed fields: Short Description  
# 
# Revision 1.8  94/10/25  14:39:17  root
# changed fields: Fixed In Baseline  
# 
# Revision 1.7  94/10/25  12:49:33  root
# changed fields: Status  Fixed In Baseline  Affected File(s)   new/changed/deleted note(s) [rdl 10/25/94 public]
# 
# Revision 1.6  94/10/24  13:53:11  root
# changed fields: Short Description   new/changed/deleted note(s) [rdl 10/24/94 public]
# 
# Revision 1.1.2.2  1993/01/26  19:08:16  pellis
# 	Moved to ./src/nosupport/test/systest
# 	[1993/01/26  00:03:17  pellis]
#
# $EndLog$
#
#
# This is the config file used to test DFS ability to honor lockf() lock
# requests.
#

F lockfile
P /.../ascii/fs/lck

C	1	asciihead	/.../ascii/fs/lck
C	2	asciihead	/.../ascii/fs/lck
C	3	asciihead	/.../ascii/fs/lck
C	4	asciihead	/.../ascii/fs/lck

l -----------------------------------------------------------------------------
l LOCKF - Unlocking holes in a locked range
l -----------------------------------------------------------------------------
p	CLEAR_LOCKFILE
1	L_LOCK		0	1000	a	p
2	L_LOCK		10	291	b	b
3	L_LOCK		301	300	c	b
4	L_LOCK		601	390	d	b
1	L_ULOCK		301	300
p	L_LOCK_GRANTED	3
1	L_TEST		350	1		f
1	L_ULOCK		0	10
1	L_ULOCK		991	10
3	L_TEST		5	1		p
3	L_TEST		995	2		p
1	L_ULOCK		11	289
3	L_TEST		200	20		p
1	L_ULOCK		10	1
3	L_TEST		10	20		p
1	L_ULOCK		300	1
p	L_LOCK_GRANTED	2
1	L_TEST		300	-100		f
1	L_ULOCK		800	-100
2	L_TEST		710	50		p
1	L_ULOCK		801	0
2	L_TEST		850	0		p
1	L_ULOCK		1000	-800
p	L_LOCK_GRANTED	4
1	L_TEST		650	100		f
1	L_LOCK		0	1000	e	b
2	L_ULOCK		0	0	
2 	L_TEST		0	200		p
3	L_ULOCK		0	0
3	L_TEST		0	500		p
4	L_ULOCK		0	0
p	L_LOCK_GRANTED	1
4	L_TEST		0	0		f
1	L_ULOCK		0	0
4	L_TEST		0	0		p
p	CLEAR_CHILDREN
l -----------------------------------------------------------------------------
l LOCKF - Same range
l -----------------------------------------------------------------------------
p	CLEAR_LOCKFILE
1	L_LOCK		0	100	a	p
2	L_LOCK		0	100	b	b
3	L_TLOCK		0	100	c	f
1	L_ULOCK		0	100	
p	L_LOCK_GRANTED	2
2	L_ULOCK		0	100
3	L_TEST		0	0		p
p	CLEAR_CHILDREN
l -----------------------------------------------------------------------------
l LOCKF - Overlap at the beginning
l -----------------------------------------------------------------------------
p	CLEAR_LOCKFILE
1	L_LOCK		50	100	a	p
2	L_LOCK		0	100	b	b
3	L_TLOCK		0	100	c	f
1	L_ULOCK		50	100	
p	L_LOCK_GRANTED	2
2	L_ULOCK		0	100
3	L_TEST		0	0		p
p	CLEAR_CHILDREN
l -----------------------------------------------------------------------------
l LOCKF - Overlap at the end
l -----------------------------------------------------------------------------
p	CLEAR_LOCKFILE
1	L_LOCK		0	100	a	p
2	L_LOCK		50	100	b	b
3	L_TLOCK		50	100	c	f
1	L_ULOCK		0	100	
p	L_LOCK_GRANTED	2
2	L_ULOCK		50	100
3	L_TEST		0	0		p
p	CLEAR_CHILDREN
l -----------------------------------------------------------------------------
l LOCKF - Contained within
l -----------------------------------------------------------------------------
p	CLEAR_LOCKFILE
1	L_LOCK		0	100	a	p
2	L_LOCK		25	50	b	b
3	L_TLOCK		25	50	c	f
1	L_ULOCK		0	100	
p	L_LOCK_GRANTED	2
2	L_ULOCK		25	50
3	L_TEST		0	0		p
p	CLEAR_CHILDREN
l -----------------------------------------------------------------------------
l LOCKF - Surrounding
l -----------------------------------------------------------------------------
p	CLEAR_LOCKFILE
1	L_LOCK		25	50	a	p
2	L_LOCK		0	100	b	b
3	L_TLOCK		0	100	c	f
1	L_ULOCK		25	50	
p	L_LOCK_GRANTED	2
2	L_ULOCK		0	1000
3	L_TEST		0	0		p
p	CLEAR_CHILDREN
l -----------------------------------------------------------------------------
l LOCKF - Overlapping EOF
l -----------------------------------------------------------------------------
p	CLEAR_LOCKFILE
1	WRITE_RANGE	0	100	a	p
1	L_LOCK		25	100	a	p
2	L_LOCK		25	100	b	b
3	L_TLOCK		25	100	c	f
1	L_ULOCK		25	100	
p	L_LOCK_GRANTED	2
2	L_ULOCK		25	100
3	L_TEST		0	0		p
p	CLEAR_CHILDREN
l -----------------------------------------------------------------------------
l LOCKF - Beyond EOF
l -----------------------------------------------------------------------------
p	CLEAR_LOCKFILE
1	WRITE_RANGE	0	100	a	p
1	L_LOCK		125	100	a	p
2	L_LOCK		125	100	b	b
3	L_TLOCK		125	100	c	f
1	L_ULOCK		125	100	
p	L_LOCK_GRANTED	2
2	L_ULOCK		125	100
3	L_TEST		0	0		p
p	CLEAR_CHILDREN
l -----------------------------------------------------------------------------
l LOCKF - Before
l -----------------------------------------------------------------------------
p	CLEAR_LOCKFILE
1	L_LOCK		50	100	a	p
2	L_LOCK		0	40	b	p
3	L_TLOCK		0	40	c	f
1	L_ULOCK		50	100	
2	L_ULOCK		0	40
3	L_TEST		0	0		p
p	CLEAR_CHILDREN
l -----------------------------------------------------------------------------
l LOCKF - Before and adjacent
l -----------------------------------------------------------------------------
p	CLEAR_LOCKFILE
1	L_LOCK		50	100	a	p
2	L_LOCK		0	50	b	p
3	L_TLOCK		0	50	c	f
1	L_ULOCK		50	100	
2	L_ULOCK		0	50
3	L_TEST		0	0		p
p	CLEAR_CHILDREN
l -----------------------------------------------------------------------------
l LOCKF - After and adjacent
l -----------------------------------------------------------------------------
p	CLEAR_LOCKFILE
1	L_LOCK		0	50	a	p
2	L_LOCK		50	50	b	p
3	L_TLOCK		50	50	c	f
1	L_ULOCK		0	50	
2	L_ULOCK		50	50
3	L_TEST		0	0		p
p	CLEAR_CHILDREN
l -----------------------------------------------------------------------------
l LOCKF - After
l -----------------------------------------------------------------------------
p	CLEAR_LOCKFILE
1	L_LOCK		0	50	a	p
2	L_LOCK		60	50	b	p
3	L_TLOCK		60	50	c	f
1	L_ULOCK		0	50	
2	L_ULOCK		60	50
3	L_TEST		0	0		p
p	CLEAR_CHILDREN
l -----------------------------------------------------------------------------
l LOCKF - Beyond EOF with size of 0
l -----------------------------------------------------------------------------
p	CLEAR_LOCKFILE
1	L_LOCK		0	50	a	p
2	L_LOCK		100	0	b	p
3	L_LOCK		200	50	c	b
1	L_TLOCK		300	40	d	f
2	L_ULOCK		100	0	
p	L_LOCK_GRANTED	3
3	L_ULOCK		200	50
1	L_ULOCK		0	50	
1	L_TEST		0	0		p
p	CLEAR_CHILDREN
------------------------ cut here : end fmul_lockf.cf ------------------------

[10/25/94 public]
Changed to fix.



CR Number                     : 11708
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 11913
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : fts
Short Description             : fts tests 12 and 14 FAILING
Reported Date                 : 8/15/94
Found in Baseline             : 1.1b14
Found Date                    : 8/15/94
Severity                      : A
Priority                      : 1
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public

[8/15/94 public]

The fts tests 12 and 14 used for CHO fail with:

 Aug 12 22:13:24 EDT 1994
 Iteration 1.1 of move...
 fts_DeleteVolume: 0,,235 is unattachable (code 691089523).
 Error in move: communications failure (dce / rpc)
 - fts move failed (errno 22) (test14: E23)
 Fileset 0,,232 is already on server dce11.osf.org (aggr m3.aggr2).
 Fileset 0,,232 moved from /.:/hosts/cobbler m1.aggr2 to /.:/hosts/dce11 m3.aggr2

 a previous iteration succeeded:

 Fri Aug 12 18:45:27 EDT 1994
 Iteration 1.1 of move...
 Fileset 0,,61 moved from /.:/hosts/dce11 m3.aggr2 to /.:/hosts/cobbler m1.aggr2
 Fileset 0,,61 moved from /.:/hosts/cobbler m1.aggr2 to /.:/hosts/dce11 m3.aggr2

Ticket lifetimes in the cell had been adjusted to a default of 4d
(including the dce-ptgt account's, which is normally 2h)

Next failure was:

Fri Aug 12 23:24:36 EDT 1994
Iteration 1.1 of move...
Error in move: who are you failed (dce / rpc)
- fts move failed (errno 95) (test14: E23)
Fileset 0,,288 is already on server dce11.osf.org (aggr m3.aggr2).
Fileset 0,,288 moved from /.:/hosts/cobbler m1.aggr2 to /.:/hosts/dce11 m3.aggr2

And then:

Fri Aug 12 23:33:58 EDT 1994

Running cm lsstores...
No failed stores are being retried.

Moving ft1.21098 from m3.aggr2 to m1.aggr2...
Error in move: who are you failed (dce / rpc)
- fts move failed (errno 95) (test12: E64)
BAILING OUT of this part

some other "who are you" failures then:

Sat Aug 13 02:31:16 EDT 1994
Iteration 1.1 of move...
fts_DeleteVolume: 0,,443 is unattachable (code 691089523).
Error in move: communications failure (dce / rpc)
- fts move failed (errno 22) (test14: E23)
Fileset 0,,440 is already on server dce11.osf.org (aggr m3.aggr2).
Fileset 0,,440 moved from /.:/hosts/cobbler m1.aggr2 to /.:/hosts/dce11 m3.aggr2

more "who are you" failures

but manage to pass later:

All done at Sat Aug 13 06:04:57 EDT 1994.

test14 PASSED

All done at Sat Aug 13 06:18:16 EDT 1994.

test12 PASSED

Looking for a pattern ...

FTS test run 1 PASSED : Fri Aug 12 18:28:23 EDT 1994
FTS test run 2 PASSED : Fri Aug 12 18:51:03 EDT 1994
FTS test run 3 PASSED : Fri Aug 12 19:14:08 EDT 1994
FTS test run 4 PASSED : Fri Aug 12 19:37:21 EDT 1994
FTS test run 5 PASSED : Fri Aug 12 20:00:10 EDT 1994
FTS test run 6 PASSED : Fri Aug 12 20:23:16 EDT 1994
FTS test run 7 PASSED : Fri Aug 12 20:46:32 EDT 1994
FTS test run 8 PASSED : Fri Aug 12 21:09:29 EDT 1994
FTS test run 9 PASSED : Fri Aug 12 21:32:41 EDT 1994
FTS test run 10 PASSED : Fri Aug 12 21:55:56 EDT 1994

FTS test run 12 PASSED : Fri Aug 12 22:43:46 EDT 1994
FTS test run 13 PASSED : Fri Aug 12 23:06:57 EDT 1994

FTS test run 16 PASSED : Sat Aug 13 00:16:33 EDT 1994

FTS test run 19 PASSED : Sat Aug 13 01:26:07 EDT 1994
FTS test run 20 PASSED : Sat Aug 13 01:49:43 EDT 1994
FTS test run 21 PASSED : Sat Aug 13 02:13:20 EDT 1994

FTS test run 23 PASSED : Sat Aug 13 03:01:57 EDT 1994
FTS test run 24 PASSED : Sat Aug 13 03:25:36 EDT 1994
FTS test run 25 PASSED : Sat Aug 13 03:48:29 EDT 1994
FTS test run 26 PASSED : Sat Aug 13 04:11:52 EDT 1994

FTS test run 36 PASSED : Sat Aug 13 08:05:50 EDT 1994

FTS test run 39 PASSED : Sat Aug 13 09:15:24 EDT 1994
FTS test run 40 PASSED : Sat Aug 13 09:39:01 EDT 1994
FTS test run 41 PASSED : Sat Aug 13 10:02:14 EDT 1994
FTS test run 42 PASSED : Sat Aug 13 10:25:31 EDT 1994
FTS test run 43 PASSED : Sat Aug 13 10:49:00 EDT 1994

TS test run 45 PASSED : Sat Aug 13 11:40:44 EDT 1994

FTS test run 48 PASSED : Sat Aug 13 12:51:41 EDT 1994

FTS test run 51 PASSED : Sat Aug 13 14:02:37 EDT 1994
FTS test run 52 PASSED : Sat Aug 13 14:26:08 EDT 1994

FTS test run 55 PASSED : Sat Aug 13 15:36:50 EDT 1994

FTS test run 331 PASSED : Sun Aug 14 04:41:21 EDT 1994
FTS test run 332 PASSED : Sun Aug 14 05:05:32 EDT 1994
FTS test run 333 PASSED : Sun Aug 14 05:29:52 EDT 1994
FTS test run 334 PASSED : Sun Aug 14 05:54:12 EDT 1994
FTS test run 335 PASSED : Sun Aug 14 06:18:43 EDT 1994
FTS test run 336 PASSED : Sun Aug 14 06:42:48 EDT 1994
FTS test run 337 PASSED : Sun Aug 14 07:07:13 EDT 1994

FTS test run 340 PASSED : Sun Aug 14 08:19:32 EDT 1994

That's it ...

[8/26/94 public]
Greg's fix for "who are you/ticket refresh" (11423) in but
these tests still failing ...

In fact, test14 didn't pass AT ALL and test12 only passed
twice during my most recent run ... progress?

Errors include:
Error: no quorum elected (dfs / ubk)
Error in create: no quorum elected (dfs / ubk)
- fts create failed (errno 1); test14 ABORTING (test14: E4)
--------------------------------------
Could not get info about site dce11.osf.org (no quorum elected (dfs / ubk))
Error: no quorum elected (dfs / ubk)
connToServer(dce11.osf.org): no known principal for this connection; no quorum elected (dfs / ubk)
, proceeding...
----------------------------------------
(Warning) fts_DeleteVolume: 0,,122 doesn't exist.  Ignoring...
Error in move: communications failure (dce / rpc)
- fts move failed (errno 22) (test14: E23)
Fileset 0,,119 is already on server dce11.osf.org (aggr m3.aggr2).
Fileset 0,,119 moved from /.:/hosts/cobbler m1.aggr2 to /.:/hosts/dce11 m3.aggr2
------------------------------------------------
Removing filesets...
Fileset 0,,123 on aggregate m3.aggr2 server /.:/hosts/dce11 deleted
AFS_SetContext(cobbler.osf.org) fails: who are you failed (dce / rpc)
Error in delete: who are you failed (dce / rpc)
AFS_SetContext(cobbler.osf.org) fails: who are you failed (dce / rpc)
Error in delete: who are you failed (dce / rpc)
Fileset 0,,134 on aggregate m3.aggr2 server /.:/hosts/dce11 deleted
fts delmount: error removing mount point for /.../cho_cell.qadce.osf.org/fs/test/ft4.5377: Connection timed out

Don't know what to make of all this yet - quorum problems the 
biggest concern since these can be difficult to narrow down ...
I'll probably log a separate CR for the new/remaining "who are you"
errors. Comm failures could be related to 11070/11400 - timeouts
an unknown.

[8/29/94 public]
Rerun of test on BL16 came up with the following:

Ticket appeared to expire 3.5 days early since:

FTS test run 2 PASSED : Fri Aug 26 22:51:23 EDT 1994
/:/m3.lfs.fts/fts/runcho.fts starting at Fri Aug 26 22:51:23 EDT 1994
/:/m3.lfs.fts/fts/runcho.fts[53]: pwd: permission denied
sh: :/m3.lfs.fts/fts/runcho.fts[53]:: cannot open
FTS test run FAILED

BUT later the test passed again:

FTS test run 54705 PASSED : Sat Aug 27 14:33:25 EDT 1994

(Large run # due to tight loop caused by "permission denied" problem)

Permission continued to come and go throughout the test.
There were no quorum problems during this run (see CR 11708 for info
on previous run failures). This run did include something new though:

Moving ft1.1605 from m1.aggr2 back to m3.aggr2...
[find token with descriptor 3]
Error in move: Transaction doesn't exist (dfs / fts)
- fts move failed (errno 51) (test12: E71)
BAILING OUT of this part

I suspect the intermittent "permission denied" problems are the
culprit but so far, I'm stumped. I'm removing the RIOS from the
configuration and rerunning.

[8/29/94 public]
More data:

The ftserver core dumped at:

-rw-rw-rw-   1 root     sys      8704860 Aug 26 01:29 core.ftserver

The bosserver would have started a new one which may explain the
renewed ability to pass the tests ... timing isn't perfect since
the tests failed before the ftserver core dumped and continued
to fail for long after a new one started however.

Core file from:  ftserver
Child died due to: IOT instruction
Procedures:      0
Files: 0
 0 _kill@libc + 0x00000008 (hp-ux export stub)
 1 _raise@libc + 0x00000024 (0x40020b98, 0x400375c8, 0, 0)
 2 _abort@libc + 0x00000078 (0x33, 0x400375c8, 0, 0)
 3 _assert@libc + 0x00000128 (0x7aff0468, 0x3, 0x40149d60, 0)
 4 TMEM@libdce + 0x00313da0 (0x4073f6b8, 0, 0, 0)
 5 TMEM@libdce + 0x003145e4 (0x4073f6b8, 0x40149098, 0, 0)
 6 TMEM@libdce + 0x0031d1e4 (0x4073f6b8, 0x40149c98, 0x40149098, 0)
 7 TMEM@libdce + 0x003204e0 (0x4056acf0, 0x40149098, 0x40149098, 0x3a2f6b72)
 8 TMEM@libdce + 0x00310694 (0x4056acf0, 0x40642d28, 0x4014908c, 0x40149090)
 9 TMEM@libdce + 0x003119bc (0x4056acf0, 0x1, 0, 0)
10 dfsauth_client_EstablishLocalA + 0x00000888 (0x1, 0, 0, 0)
11 dfsauth_client_RefreshLocalAut + 0x00000018 (0x400bb8cc, 0x29ccb017, 0x1000000, 0)
12 dfsauth_client_InitAuthContext + 0x00000200 (0, 0x1, 0x1000000, 0x400375c8)
13 dfsauth_client_InitBindingAuth + 0x0000011c (0x40147db4, 0, 0x1, 0x40147dfc)
14 vols_Forward + 0x000006c8 (0x40579c10, 0x40573278, 0x8d, 0x40147930)
15 SFTSERVER_Forward + 0x00000240 (0x40573278, 0x8d, 0x40147930, 0x4014795c)
16 op7_ssr + 0x0000019c (0x40573278, 0x405f1308, 0x4014753c, 0x40147520)
17 TMEM@libdce + 0x00173070 (0x405f1308, 0, 0, 0)

BTW - the new "who are you" bug is 11913
The localauth routines in this trace may be related?

[8/30/94 public]
Tests still don't pass with bl-16.2 - however, 11913 not seen and 11925
kills dfsbind w/in 4 hours of starting test so we won't know much 'til
a fix for that comes in. Bizarre behavior over the weekend may be related
to network problems seen over the weekend.

[9/7/94 public]
Wow - I've put a lot of data in here ... oh well - here's more:

HP only CHO cell w/ bl-16.3

2 runs of fts tests 12 + 14 loops
1st run failed with "who are you" error (see 11913)
2nd run failed with:
Wed Sep 7 18:58:25 EDT 1994
Iteration 1.1 of move...
Error in move: Transaction doesn't exist (dfs / fts)
- fts move failed (errno 51) (test14: E23)
Fileset 0,,124 is already on server dce11.osf.org (aggr m3.aggr2).
Fileset 0,,124 moved from /.:/hosts/dce13 m1.aggr1 to /.:/hosts/dce11 m3.aggr2

then test has bizarre behavior:
/:/m3.lfs.fts/fts/runcho.fts starting at Wed Sep  7 21:14:31 EDT 1994

/.../cho_cell.qadce.osf.org/fs/test exists, chmod'ing it to 777
chmod: can't change /.../cho_cell.qadce.osf.org/fs/test: Connection timed out
/:/m3.lfs.fts/fts/runtests[324]: syntax error at line 332 : `"' unmatched
FTS test run FAILED
/:/m3.lfs.fts/fts/runcho.fts starting at Wed Sep  7 21:23:04 EDT 1994
/:/m3.lfs.fts/fts/runcho.fts[53]: pwd: permission denied
sh: :/m3.lfs.fts/fts/runcho.fts[53]:: cannot open
FTS test run FAILED
/:/m3.lfs.fts/fts/runcho.fts starting at Wed Sep  7 21:23:04 EDT 1994
/:/m3.lfs.fts/fts/runcho.fts[53]: pwd: permission denied
sh: :/m3.lfs.fts/fts/runcho.fts[53]:: cannot open
FTS test run FAILED

tight spin loop ...

This is at the 23 hour mark - dfsbind had logged quite a bit of time by
this point (even tho I caught the test spin w/in 10 minutes):
root@darkman> ps -ef|grep dfsbind
    root  1440     1 -95 22:30:00 ?       306:59 /opt/dcelocal/bin/dfsbind
    root  1439     0  0 22:30:00 ttys0    0:00 /opt/dcelocal/bin/dfsbind

/opt/dcelocal/var/dfs/adm/FtLog on dce11 contained:
1994-Sep-07 19:06:56 Dumping 2:fts.test14.4473.move-temp (0,,127)
1994-Sep-07 19:10:18 trans 406283e8 (Id=174, 0,,127/2) is 193 seconds old (ref c
ount 0)
1994-Sep-07 19:10:18 (trans 406283e8: desc=0, time=778979225, ctime=778979213, s
tates=0x10040006, accs=0x183, acce=691089523)
1994-Sep-07 19:10:48 trans 406283e8 (Id=174, 0,,127/2) is 223 seconds old (ref c
ount 0)
1994-Sep-07 19:10:48 (trans 406283e8: desc=0, time=778979225, ctime=778979213, s
tates=0x10040006, accs=0x183, acce=691089523)
1994-Sep-07 19:11:18 trans 406283e8 (Id=174, 0,,127/2) is 253 seconds old (ref c
ount 0)
1994-Sep-07 19:11:18 (trans 406283e8: desc=0, time=778979225, ctime=778979213, s
tates=0x10040006, accs=0x183, acce=691089523)
1994-Sep-07 19:11:48 trans 406283e8 (Id=174, 0,,127/2) is 283 seconds old (ref c
ount 0)
1994-Sep-07 19:11:48 (trans 406283e8: desc=0, time=778979225, ctime=778979213, s
tates=0x10040006, accs=0x183, acce=691089523)
1994-Sep-07 19:12:18 trans 406283e8 (Id=174, 0,,127/2) is 313 seconds old (ref c
ount 0)
1994-Sep-07 19:12:18 (trans 406283e8: desc=0, time=778979225, ctime=778979213, s
tates=0x10040006, accs=0x183, acce=691089523)
1994-Sep-07 19:12:18 trans 406283e8 (Id=174, 0,,127/2) is 313 seconds old (ref c
ount 0): GCing
1994-Sep-07 19:21:45 Destroying 2:fts.test14.4473.move-temp (0,,127)
1994-Sep-07 21:11:35 Destroying 2:fts.test14.4473 (0,,124)

/opt/dcelocal/var/dfs/adm/FtLog on dce13 contained:
1994-Sep-07 19:06:54 ftserver_CreateVolume: created fts.test14.4473 as 0,,124 on
 aggr 1
 1994-Sep-07 19:07:03 Restoring fileset 0,,124/1
 1994-Sep-07 19:07:03 Restoring 1:fts.test14.4473 (0,,124)
 1994-Sep-07 19:07:04 vols_Restore: returning 0
 1994-Sep-07 19:07:04 Restored fileset 0,,124/1: returned code 0
 1994-Sep-07 19:10:15 trans 400e5fe0 (Id=79, 0,,124/1) is 190 seconds old (ref co
 unt 0)
 1994-Sep-07 19:10:15 (trans 400e5fe0: desc=0, time=778979225, ctime=778979214, s
 tates=0x12810015, accs=0x1c4, acce=691089523)
 1994-Sep-07 19:10:45 trans 400e5fe0 (Id=79, 0,,124/1) is 220 seconds old (ref co
 unt 0)
 1994-Sep-07 19:10:45 (trans 400e5fe0: desc=0, time=778979225, ctime=778979214, s
 tates=0x12810015, accs=0x1c4, acce=691089523)
 1994-Sep-07 19:11:15 trans 400e5fe0 (Id=79, 0,,124/1) is 250 seconds old (ref co
 unt 0)
 1994-Sep-07 19:11:15 (trans 400e5fe0: desc=0, time=778979225, ctime=778979214, s
 tates=0x12810015, accs=0x1c4, acce=691089523)
 1994-Sep-07 19:11:45 trans 400e5fe0 (Id=79, 0,,124/1) is 280 seconds old (ref co
 unt 0)
 1994-Sep-07 19:11:45 (trans 400e5fe0: desc=0, time=778979225, ctime=778979214, s
 tates=0x12810015, accs=0x1c4, acce=691089523)
 1994-Sep-07 19:12:15 trans 400e5fe0 (Id=79, 0,,124/1) is 310 seconds old (ref co
 unt 0)
 1994-Sep-07 19:12:15 (trans 400e5fe0: desc=0, time=778979225, ctime=778979214, s
 tates=0x12810015, accs=0x1c4, acce=691089523)
 1994-Sep-07 19:12:15 trans 400e5fe0 (Id=79, 0,,124/1) is 310 seconds old (ref co
 unt 0): GCing
 1994-Sep-07 19:21:46 Destroying 1:fts.test14.4473 (0,,124)
 1994-Sep-07 19:35:26 Failed to open 1:0,,124, code = 572833799 (Fileset does not
  exist (dfs / ftu))
 1994-Sep-07 19:35:26 Failed to open 1:0,,126, code = 572833799 (Fileset does not
   exist (dfs / ftu))
 1994-Sep-07 19:35:26 Failed to open 1:0,,124, code = 572833799 (Fileset does not
   exist (dfs / ftu))

I have icl.bind logs but I think there's enough info here already :-) - I'm clearly
at a loss on this one ... help!

[10/3/94 public]
The performance problems seem to have been solved (yeah!) and the fts
tests 12 + 14 were humming along for 29 hours when:

Sat Oct  1 23:37:23 EDT 1994

Restoring (and creating) ft3.3521 from /tmp/dump.3521...
Fileset ft3.3521 does not exist, creating it in m3.aggr1 of sarpa.osf.org
        readWrite   ID 0,,921  valid
        readOnly    ID 0,,922  invalid
        backup      ID 0,,923  invalid
number of sites: 1
   server           flags     aggr   siteAge principal      owner
sarpa.osf.org       RW       m3.aggr1 0:00:00 hosts/sarpa    <nil>

Fileset 0,,921 created on aggregate m3.aggr1 of /.:/hosts/sarpa
AFS_SetContext(sarpa.osf.org) fails: Internal corruption (dfs / fsh)
Error in restore: Internal corruption (dfs / fsh)
- fts restore failed (errno 2) (test12: E94)
BAILING OUT of this part

a few hours later:
Sun Oct 2 02:34:24 EDT 1994
Iteration 1.1 of move...
Fileset 0,,965 moved from /.:/hosts/dce13 m1.aggr1 to /.:/hosts/sarpa m3.aggr1
AFS_SetContext(sarpa.osf.org) fails: Communications failure (dce / rpc)
(Warning) fts_DeleteVolume: 0,,969 doesn't exist.  Ignoring...
Error in move: Communications failure (dce / rpc)
- fts move failed (errno 22) (test14: E24)

quorum lost 1.5 hours later:
Removing mount points and filesets...
Could not lock FLDB entry (id=0,,984, type=-1, op=128)
Error: no quorum elected (dfs / ubk)
Error in delete: no quorum elected (dfs / ubk)

Done with cleanup.

All done at Sun Oct  2 04:03:02 EDT 1994.

and then again, much later:
Re-cloning using clonesys...
Could not release lock on FLDB entry (id=0,,1103, type=0)
Error: no quorum elected (dfs / ubk)
----------------------
Total FLDB entries that were successfully backed up: 0 (1 failed; 0 wrong aggr t
ype)
- fts clonesys failed (errno 1) (test12: E56)
BAILING OUT of this part

Part 3: move
============
Sun Oct  2 13:20:27 EDT 1994

There are no ftserver core dumps around and the dfsbind process has only
logged :
    root  5037     1  3  Sep 30  ?       74:23 /opt/dcelocal/bin/dfsbind
since it was started on Friday Sep 30.
The dfsbind process on Sarpa (server_2 in the test) only had:
    root  3847     1  0  Sep 30  ?        1:26 /opt/dcelocal/bin/dfsbind
so dfsbind doesn't seem to be involved in the problem ... still looking
around - ideas welcome.

Dropping back to a 1 to reflect that it is unlikely that this will
be addressed by the freeze. Also, please note that the problems
began after 29 hours of CHO so this is not a simple functional failure.
This will be investigated and if possible, a fix will be submitted
to the unintegrated tree.



CR Number                     : 11356
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : dacl
Short Description             : Disallow addition of vestigial unauth mask entry
Reported Date                 : 7/19/94
Found in Baseline             : 1.0.2a
Found Date                    : 7/19/94
Severity                      : C
Priority                      : 3
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : andi@transarc.com
Transarc Status               : open

[7/19/94 public]
Prevent addition of unauth mask entry. Details below:
The unauthenticated mask ACL entry is not used in DFS for
authorization. But it can still be set. This causes the following
problems.
 
It creates cause for confusion for users.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `andi@transarc.com' 
Added field Transarc Status with value `open'

[7/19/94 public]
Changed Interest List CC from `cfe@transar.com, dws@transarc.com, gmd@osf.org' 
 to `cfe@transar.com, dws@transarc.com, gmd@osf.org, jeff@transarc.com'

[7/19/94 public]
This corresponds to Transac defect 5716. Its fixed by delta
Delta rajesh-db5716-disallow-unauth-mask-entry. 
Tested as follows.
Can't add an unauth mask entry in an ACL now. 
If a file/dir ACL already had an unauth entry then that did not
affect access or operation. The entry could be deleted.
A restore of a dump of a fileset containing ACLS with unauth entries
was successfull with the unauth entries being stripped out. Also the
episode/vnopsVerbose log had trace messages for the unauth mask
entries being stripped out.  Normal operation including acl
manipulation could be done in the restored fileset.
Reviewed by Ted.



CR Number                     : 10443
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : 
Short Description             : fts syncfldb invalidates valid backup entries in the fldb.
Reported Date                 : 4/22/94
Found in Baseline             : 1.0.3a
Found Date                    : 4/22/94
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : src/file/userInt/fts/volc_queue.c
Sensitivity                   : public

[4/22/94 public]
 
Full Description:
        When running a fts syncfldb command against a servers
        aggregate that contains valid .backup volumes, the .backup
        is *always* marked invalid in the fldb and the .backup 
        is *not* deleted.
 
Repeat By:
 
        fts clone  -fileset {<name> | <ID>}
        fts syncfldb -server <machine> [-aggregate <name>]
 
        Aggregate name does not need to be specified.  Only requirement
        is that a valid .backup volume exists on an aggregate to
        be synced with the fldb.
 
Proposed Solution:
 
        In src/file/userInt/fts/volc_queue.c function ProcessEntries,
        when finding a valid backup volume who has a valid RW on the
        same site, the entry.flags should be updated to include the
        valid backup.
                        ...
                        ...
if (qvol.isValid.BACKVOL.) { 
    if ((i = vldb_FindRepSite(&entry, (struct sockaddr *)0, -1,
                            VLSF_ZEROIXHERE >> xl.RWVOL.)) != -1) { 
        if (entry.flags & VLF_RWEXISTS) { 
            /* Check whether the entry's RW is on the site of this backvol.
*/  
            k = 0;
            for (j = i; j < entry.nServers; ++j) { 
                if (j > i && (entry.siteFlags.j. & VLSF_SAMEASPREV) == 0)
break;
                if (bcmp(servAddrp, &entry.siteAddr.j., sizeof(struct
sockaddr))
                    && entry.sitePartition.j. == aggrId) { 
                    k = 1;
=== FIX ===>>>      entry.flags |= VLF_BACKEXISTS;
                    break;
                } 
            }

[4/22/94 public]
In other spots in this code, vldb_AssignSite is used, rather than
simply OR-ing in bits to the entry, and that should be done here as
well.  This will also correct how the code is clearing the
VLSF_ZEROIXHERE>>xl[BACKVOL] flag.
 
Actually, I'd replace the existing ``entry.flags |= VLF_BACKEXISTS''
code with a vldb_AssignSite, as well.

[2/19/96]
Fixed as of 1.2.1 code drop.



CR Number                     : 10303
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : dfs
Subcomponent Name             : repserver
Short Description             : repserver needs to reset volume info after RW move
Reported Date                 : 4/6/94
Found in Baseline             : 1.1a
Found Date                    : 4/6/94
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : 

[4/6/94 public]
 
Sometimes after the RW is moved the repserver will spin because it
keeps getting the error VOL_PERS_DELETED, and is unable to update the
RO volume.  In the AFS_GetToken call will return error code 691089410.
We were wondering if clearing the repflag_KnowVLDB when we get this
error would fix the problem by forcing the repserver to re-read the
information from the vldb.  The workaround right now is to restart the
repserver.
 
Here's the icl tracing:
 
time 893.005890, pid 10: 0,,8: Attempting to get token (0x404) for 0,,7 on primary
time 893.024417, pid 10: GetToken result: 691089410
time 893.024790, pid 10: NeedSetVol figuring VV
time 893.025079, pid 10: NeedSetVol TRUE: new PingCurr time 765629272.005497 -> 765629309.005581
time 893.025327, pid 10: UpdateLocal calling AGOPEN
time 893.026013, pid 10: UpdateLocal: calling SetOpenVol
time 893.026237, pid 10: SetOpenVol calling SETVV
time 893.027509, pid 10: SetOpenVol: Set VV for 0,,8: flags 1000, mask 3000, curr 765583749.015955,
pc 765629309.005581, TO 765583750.011893
time 893.027873, pid 10: SetOpenVol returning 0
time 893.028104, pid 10: UpdateLocal: calling CLOSE
time 893.028589, pid 10: UpdateLocal: returning 0
nVol
time 893.031188, pid 10: [0,,8: delay 37 secs: TryForWVTRead: fileset not present and exported on se
rver: already deleted/moved (dfs / xvl)]
time 893.031779, pid 10: bkg: StartImporting sleeps 37 secs
time 893.032007, pid 10: repserver: ForceKeepAlive() called
time 893.032719, pid 10: Sleeping for 37 seconds (on actNowCond)
time 930.002748, pid 10: bkg: now 765629346, tgt 765629346, timed out: on time.
time 930.003975, pid 10: 0,,8: Attempting to get token (0x404) for 0,,7 on primary
time 930.023395, pid 10: GetToken result: 691089410
time 930.023768, pid 10: NeedSetVol figuring VV
time 930.024054, pid 10: NeedSetVol TRUE: new PingCurr time 765629309.005581 -> 765629346.003666
time 930.024302, pid 10: UpdateLocal calling AGOPEN
time 930.024973, pid 10: UpdateLocal: calling SetOpenVol

[4/6/94 public]
This is supposed to be fixed by the fts process doing the move calling
vldb_TellAllReplicas (or something like that) after the move
completes; this should call REP_AllCheckRepConfig on a repserver,
which should call REP_CheckRepConfig on each repserver for the
fileset.  Does the problem not get better within a few minutes?  Is
there any evidence for these calls being made?
 
It could be that the repserver could react to the VOLERR_PERS_xxx code
in the same way that the CM does, which is by re-reading the FLDB
information.  It could do this most sensibly by clearing
repflag_KnowVLDB.
 
I've added Jeff to the CC: list in case he has other comments.
Changed Interest List CC from `cfe@transarc.com' to `cfe@transarc.com, 
 jdp@transarc.com'

[4/6/94 public]
The repserver doesn't have any code that notices that a R/W has moved.
The two routines that should be doing this checking, CheckWithVLDB and
CheckVLDBRelationship, only check whether a given replica should or
shouldn't exist on the local server.  These routines need to check the
R/W location and use that information to update the replica's primary
host/connection data.
The only thing I'm puzzled by is the statement that "Sometimes after
the RW is moved the repserver will spin".  I'm surprised that it would
ever work, except for intra-server moves.
A fix for this high priority defect will be made in the near future
under the Transarc defect 5012 (5012 01/26/94 Numerous problems with
moving replicated filesets).
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `'

[4/6/94 public]
I should add that the propsal to unset repflag_KnowVLDB is a fine idea
from the point of view of increasing robustness, but it will not fix the
problem until the fix I discussed above is made.



CR Number                     : 9989
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : dfs
Subcomponent Name             : fts test8
Short Description             : exp stat incorrect for E44,58,60,64
Reported Date                 : 2/22/94
Found in Baseline             : 1.0.3a
Found Date                    : 2/22/94
Severity                      : D
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2
Affected File(s)              : file/fts/test8
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[2/22/94 public]

I realize that jaffe is probably not the correct person and 
that tarc will probably give this to osf, but I don't have
a tarc mailname to use in place of elliot...

fts/test8 has been changed on the 1.0.3a src tree to
expect nonzero status from the following ops...

   E27 fts lsfldb -locked $av_arg
   E82 fts ulockfldb $av_arg
   E84 fts lsfldb -locked $av_arg

and in fact a status of 1 is returned

the following ops however are still expecting a status
of 0...

   E44 fts lsfldb -locked $av_arg
   E58 fts lsfldb -locked $av_arg
   E60 fts unlockfldb $av_arg
   E64 fts unlockfldb $dns_server_prefix$SERVER_1 $av_arg

in fact when running this test on a ufs exported dfs system
the status returned is 1, as the ops listed above...

I've run this on a build done here since the tarc drop..
Test passed on version built prior to this...
looks like fts has changed but the test has not...

[3/1/94 public]
It sounds like you are missing the set of fts changes for OT 5694,
but have the accompanying testcase changes.  Its been a while,
but if I remember correctly, OT 5694 changed the way the bulk
fts commands handled the case where there were no hits and the
way wrong aggregate type was handled.  For example in the case
of test8 assertion E27, it should return 1 because it found
no locked filesets:
# fts lsfldb -locked
----------------------
Total FLDB entries that were successfully enumerated: 0 (0 failed; 0 wrong aggr 
type)
# echo $?
1

In E44 and E58, filesets have been locked, so the expected result
is that they will successfully be listed and a 0 is returned.

These changes also effected clonesys, delfldbentry, etc, so I
would expect you to have similar problems with other fts tests
(I think test7 does the clonesys testing) if you really do have
the testcases and fts commands out of sync.  Otherwise, we need
to make sure these changes have not somehow been lost from the
fts code in 1.0.3a. I am not seeing this problem here.

Part of this work was also to start treating wrong aggregate
type as a 'soft' failure and just list the number of wrong
aggregates but still return 0.  For example:

# fts clonesys
Backup is supported only on LFS or VXFS filesets (e.g. not on this non-LFS one).
Backup is supported only on LFS or VXFS filesets (e.g. not on this non-LFS one).
Backup is supported only on LFS or VXFS filesets (e.g. not on this non-LFS one).
----------------------
Total FLDB entries that were successfully backed up: 40 (0 failed; 3 wrong aggr
type)
# echo $?
0

Do you have this change? These were primarily made in
src/file/userInt/fts/volc_vldbsubr.c:vldb_HandleBulkEntries.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'

[9/15/94 public]
Andy, I think this can be cancelled.  Can you do so once you've
verified fts test3, test7 and test8 all pass?  Thx.

[2/16/96]
Fixed as of 1.2.1 code drop.



CR Number                     : 9831
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : dfs
Subcomponent Name             : fts
Short Description             : fts restore fails
Reported Date                 : 1/27/94
Found in Baseline             : 1.0.3a
Found Date                    : 1/27/94
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[1/27/94 public]
 
I used fts dump to dump a 300MB UFS aggregate to a file within an
Episode fileset.  Then I used fts restore to restore to a new
fileset within the same Episode aggregate. The restore worked
for more than an hour, then I happened to rlogin into the server
machine and apparently at that instant the restore died:
 
(Note that t2 did not exist when the restore started)
 
# fts restore -ftname t2 -server booboo -aggregate test.dfs -file u1.dump
Fileset t2 does not exist, creating it in test.dfs of booboo.osf.org
        readWrite   ID 0,,19  valid
        readOnly    ID 0,,20  invalid
        backup      ID 0,,21  invalid
number of sites: 1
   server           flags     aggr   siteAge principal      owner               
booboo.osf.org      RW       test.dfs 0:00:00 hosts/booboo   <nil>               
Fileset 0,,19 created on aggregate test.dfs of booboo
Caught exception writing to ftserver: (rpc_x_ss_pipe_discipline_error) exception raised
Error in restore: I/O error in pipe (dfs / fts)
 
It might be a resource problem caused by the rlogin cosuming more
virtual memory (or swap).
 
The output of 'fts lsheader' on the affected aggregate is:
 
# fts lsheader -aggregate 30
fts: Missing required parameter '-server'
# fts lsheader -aggregate 30 -server booboo
Total filesets on server booboo aggregate test.dfs (id 30): 2
t1                       0,,16 RW 209338 K alloc 209338 K quota On-line
t2                       0,,19 RW 183783 K alloc 183783 K quota **Off-line (inconsistent--being updated)
Total filesets on-line 1; total off-line 1; total busy 0

[1/27/94 public]
We hit something similar last summer doing large fileset moves
(on the order of 450M fileset).  I'll include output from our
internal bug report below.  The problem was fixed, as well as
several related problems (dfsexport -detach panic on fileset
left in this state, and ftserver not closing transaction on
this error), but I don't know the OT numbers.  I'll see if
Carl remembers tomorrow.
 
    <Note by dstokes (Dawn C. Stokes), 93/06/11 16:55:50, action: note>
 
Hit this last night moving a fileset which I was at the
same time copying a build into.  What appears to be the
failure condition in the FtLog is:
 
93-Jun-10 20:47:13 ftserver_CreateVolume: created dce.build.22e as 0,,742 on aggr 21
93-Jun-10 21:01:54 ftserver_CreateVolume: created sshi_fs1 as 0,,746 on aggr 14
93-Jun-10 21:02:08 Restoring fileset 0,,746/14
93-Jun-10 21:36:19 vols_Restore: returning 0
93-Jun-10 21:36:19 Restored fileset 0,,746/14: returned code 0
93-Jun-10 21:38:15 Restoring fileset 0,,746/14
93-Jun-10 21:38:16 vols_Restore: returning 0
93-Jun-10 21:38:16 Restored fileset 0,,746/14: returned code 0
93-Jun-10 21:44:25 ftserver_CreateVolume: created dce.build.22e as 0,,748 on aggr 20
93-Jun-10 21:44:29 Restoring fileset 0,,748/20
93-Jun-10 22:45:40 SFTSERVER_Restore: Exception while restore-terminating: (rpc_x_ss_pipe_comm_error) exception raised
93-Jun-10 22:49:10 trans 2014b928 (Id=74, 0,,748/20) is 208 seconds old (ref count 1)
93-Jun-10 22:49:11 (trans 2014b928: desc=1, time=739770342, ctime=739766665, states=0x12010015, accs=0x1c4, acce=691089523)
 
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'

[1/28/94 public]
I think it was probably OT 8042.  The idea is that there are two threads in the ftserver
that cooperatively do the dump/restore/move/whatever, and that if one of the threads
takes an exception, it has to tell the other thread to terminate so as to release the
reference to the fileset.  At least, that was the idea behind the 8042 fix.
 
Of course, that's a bug that's closed now, and presumably you have the fix for it.
It would have been a good idea to capture part or all of the FtLog information when this
odd event occurred at the OSF.

[2/16/96]
We believe this won't recur.  Please reopen the defect if it does.



CR Number                     : 9737
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 9631
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : dfsexport
Short Description             : should report bad fileset on attach
Reported Date                 : 1/13/94
Found in Baseline             : 1.0.3a
Found Date                    : 1/13/94
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1
Sensitivity                   : public

[1/13/94 public]
For 1.1 ...
From 9631, the remaining work to address the case of "bad fileset
on aggregate during attach":

[1/7/94 public]
What happens now (after the fix) is that AG_VOLINFO, called from 
ag_RegisterVolumes, returns EIO.  Note that ag_RegisterVolumes throws this
value away but does a "continue", which means that it doesn't try to register
the fileset in the fileset registry.
.
So if you try to do something like fts lsquota, or try to access the fileset
through a mountpoint, you will error codes and messages.  You can't crash the
machine this way.
.
However, it could appear mysterious.  There should be an error message of some
kind.  ag_RegisterVolumes is already printing a message to the console in
another case.  (It might be more useful to pass the error code back out to
the process and let the process print a message on stderr, but this would
require a change to the interface, since more than one fileset in a single
aggregate can fail to register.)



CR Number                     : 9707
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : cm
Short Description             : There appears to be no limit
to the number of cm_vdirent elements that might be instantiated in memory.
Reported Date                 : 1/10/94
Found in Baseline             : 1.0.3
Found Date                    : 1/10/94
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public

[1/10/94 public]
 
While using our kernel debugger to poke around at various DFS kernel
structures, I noticed the following.
 
If cm_TryBind() {in cm_vdirent.c} is asked to look up a non-existant name,
it creates a cm_vdirent entry for it and threads it onto its directory
any way.  (This via its call to cm_AddVDirElement() in the ENOENT path.)
 
There's no limit to the number of these that there can be ... and no way
to get automatically get rid of them.  If I sit in user space and run a
script that attempts to access zillions of different things in this space
(e.g.:  /.../aaaaaaaa, /.../aaaaaaab, /.../aaaaaaac, etc.), an arbitrary
amount of kernel memory (wired for HPUX) will be consumed.  Presumably
leading to a crash or hang at some point.
 
Shouldn't there be a limit on the number of these entries that exist ...
even if only for ENOENT ones?

[3/4/94 public]
Daryl at HP plans to fix this.

[3/4/94 public]
I'm glad that Daryl plans to do something about this.  I wanted to
raise an issue or two, though.  If the CM is to disallow keeping lots
of these cm_vdirent structures around, what will it do when it reaches
its limit?  It seems senseless to deny the creation of new structures;
perhaps instead when a new structure is needed, the LRU comparable
structure could be recycled.  Thus, there could be two global lists:
one for the valid ones and one for the ENOENT and other error cases.
(Standard stuff: on reference, a structure is removed from the place
where it is and put on the head of the proper list; this lets it be
moved to a new list if conditions change.)
 
Anyway, I hoped that Daryl's work didn't amount to adding a new error
condition for cm_TryBind()--you know, returning a code like ENOMEM or
ENFILE or whatever, and failing.



CR Number                     : 9693
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : deadlock caused by failed pageouts
Reported Date                 : 1/6/94
Found in Baseline             : 1.0.3a
Found Date                    : 1/6/94
Severity                      : C
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[1/6/94 public]
If a pageout triggered by vnvm_purgereserved fails, the process(es) waiting for
the reservation to clear will deadlock indefinitely.
This failure is only supposed to happen on I/O errors, but we observed a
deadlock of this type once while running fts/test21, and it seems to have
been caused by an out-of-space error (ENOSPC).  Pageouts aren't supposed to
run out of space (this is what reservation is supposed to be for), but it
seems to have happened.
In any case, when there is a pageout failure, any space reserved for the
corresponding vnode should be given back (vnm_Unreserve).  This may lead
to under-reservation, but that is much more acceptable than deadlock.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[2/16/96]
Reservation code is gone.



CR Number                     : 9675
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : dfs
Subcomponent Name             : 
Short Description             : Bug in non-blocking lockctl()
interaction with tkc manager.
Reported Date                 : 1/3/94
Found in Baseline             : 1.0.3
Found Date                    : 1/3/94
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 Code drop
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : andi
Transarc Status               : open

[1/3/94 public]
 
There appears to be a bug in the interaction between file locking and the
tkc manager.
 
The following sequence of operations exhibits the problem:
 
  (a) On machine A, let there be an exported UFS fileset ... with a file
      foo.
 
  (b) On machine A, process P1: open this file via its local (ufs mount)
      pathname and lock byte range 0..1000.  (via fcntl(..F_SETLK..))
 
  (c) On machine A, process P2: open this file via its local pathname and
      try to lock this same byte range again via a non-blocking operation.
      (fcntl(...F_SETLK..) again)
 
      This non-blocking operation will fail due to the conflict with (b).
 
  (d) Exit both of these processes.
 
  (e) Go to machine B and try to lock this byte range of the file (since
      the file is no longer local, use a DFS pathname this time).  This
      will fail!
 
I claim that this is due to the following bug in xglue_lockctl().
 
  xglue_lockctl() currently does the following -- for both HPUX and other
  platforms.
 
     .....
     code = tkc_GetLocks()
     if (code == 0) {
       code = VOPN_LOCKCTL()
 
  The tkc_GetLocks() call grabs a DFS token/lock -- failing ONLY if the
  desired use conflicts with what some other node is doing.  Conflicts with
  what's happening at THIS node are supposed to be caught by
  VOPN_LOCKCTL().  If the VOPN_LOCKCTL() fails (as it does  in step (c)
  above), the code returns ---- without giving back the DFS token/lock it
  got from tkc_GetLocks().
 
  This "stranded" token/lock is what is interfering with the operation in
  step (e).  Since the fcntl() call in (c) failed, HPUX never set the
  "better-release-locks-at-file-close-time" flag for the process ...
  causing this token/lock to "never" be released.
 
  As a simple experiment, I changed the code as follows:
 
    .....
    code = tkc_GetLocks()
    if (code == 0) {
      code = VOPN_LOCKCTL()
      if (code && cmd != F_GETLK))
        tkc_PutLocks()
 
  My test worked properly with it this way.
 
Of course, calling tkc_PutLocks() like this isn't right either since it
will release ALL tokens over the byte range in question -- not just the one
we got above.  How about using a new call, e.g. tkc_PutLockExact(), which
releases the first token/lock on exactly the specified byte range and no
other?
 
I assigned Bruce Leverett's name to this ... although I have no reason to
believe that he's the right person at Transarc for this.  I'm perfectly
willing to "fix" this (assuming people agree with my fix) if that's what
you want ... although it'll be a few weeks before we are merged up to
the latest 1.0.3a level.
 
While I was looking at the tkc code, the following "improvements" occurred
to me as well.
 
  () The TKC_VHASH() macro in tkc.h  (== (long)vp & (TKC_VHASHSIZE-1))
     seems less than optimal given that vp is always going to be a multiple
     of 4 (TKC_VHASHSIZE == 256).  Perhaps the following would be better:
        ((long(vp) / 4) & (TKC_VHASHSIZE-1)
 
  () The functions tkc_Get() and tkc_GetTokens() do the wrong thing if
     asked for an ordinary read/write token with a byte range.  Because
     tkc_HaveTokens() doesn't take into account these byte ranges at all in
     deciding if an appropriate token is already held.
 
     This is all ok since people who call these ALWAYS pass in a byte range
     argument of NULL ... causing them to grab a token for the entire file.
     In the interest of safety, it might be safer to explicitly ignore the
     byte range argument passed in instead of half using it:  using it to
     actually grab a token ... but ignoring it in tkc_HaveTokens().
Filled in Interest List CC with `kazar@transarc.com, cfe@transarc.com' 
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'

[1/20/94 public]
I just did a little code reading in the tkc layer, and it looks
like tkc_PutLocks(vp, byteRangep) will do what you want.  It seems
to check the process id against the tlp->procid and therefore only
releases tokens over the range which are held by the calling process.
So tokens held by other local processes should not be affected.
At least thats the way it looks to me.  So the resulting bug fix would
like something like:
xvfs_osglue.c:
.
.
.
        code = VOPN_LOCKCTL(vp, lckdat, cmd, cred, fp, LB, UB);
	if (code)
	    tkc_PutLocks(vp, &byteRange);
    }
lckerr:
    xvfs_PutVolume(volp);
    AFSLOG(XGLUE_DEBUG, 1, ("END xglue_lockctl (code %d)\n", code));
    return (code);
}
I think this is what Daryl tried above.  Given the way tkc_PutLocks() works,
I do not believe tkc_PutLockExact() is needed. What do you think Daryl?

[1/20/94 public]
Actually there is a scenario where using tkc_PutLocks fails.
proc 1 gets lock on 0-1000
proc 2 gets lock on 1500-2000
proc 2 trys lock on 1-2000 and fails.
    tkc_Putlocks would return all tokens over 0-2000 for proc2
    including the one for the successful 1500-2000. NOT good.
    So it looks like some work is required.

[3/4/94 public]
Daryl at HP plans to fix this.

[3/14/94 public]
Filled in Reported by Company's Ref. Number with `5002' 
Filled in Transarc Herder with `andi' 
Filled in Transarc Status with `open'

[4/11/94 public]
First a minor correction:  the "Reported by Company's Ref. Number" (5002) is
actually Transarc's ref. number, not HP's.
The way the CM solves this problem is to keep the tokens, but to return them
if asked politely.  For instance, in Carl's example:
   proc 1 gets lock on 1-1000
   proc 2 gets lock on 1500-2000
   proc 2 tries lock on 1-2000 and fails
The client would be left with a lock token for 1-2000.  Another client
trying to get a lock for 1100-1400 would cause a revoke request, and the CM
would look at its lock database and agree to return the token.
Perhaps the tkc should do something similar.  It doesn't have its own lock
database to look at; instead it could call VOP_LOCKCTL (...F_GETLK...).
Changed Interest List CC from `kazar@transarc.com, cfe@transarc.com' to 
 `kazar@transarc.com, cfe@transarc.com, bwl@transarc.com'

[4/13/94 public]
It should be noted that the implementation of F_GETLK has the same problem,
i.e. we get a token and then never give it back.
.
I am working on a solution based on the idea I outlined above, revocable
lock tokens.



CR Number                     : 9673
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : window for races in vnvm_truncate
Reported Date                 : 1/3/94
Found in Baseline             : 1.0.3a
Found Date                    : 1/3/94
Severity                      : C
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[1/3/94 public]
vnvm_truncate calls vms_iowait with the vnode unlocked.  The reason it drops
the lock is so that the strategy daemon can pick it up when processing the
I/O requests.  The problem is that when vnvm_truncate tries to re-obtain the
lock, it may go to sleep, and while it is sleeping, pages of VM in the
indicated range may be created (e.g. by page faults).  Thus we could end up
with a file that has been truncated to length L, and pages of VM representing
bytes of the file far beyond L.
.
The basic problem is overloading of the vnode lock.  It is necessary for the
locking structure to be such that, while the vms_iowait is in progress,
activity that would create new VM pages in the indicated range is blocked,
while the processing of pageout requests that were in progress can complete.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[1/6/94 public]
Defer'ing to 1.1.  Here's an e-mail from Bruce with more info.

> From: Bruce_Leverett@transarc.com
> To: rsarbo@osf.org
> Subject: Re: OT9673
> Cc:
> In-Reply-To: <9401061855.AA06718@kenmore.osf.org.osf.org>
> References: <9401061855.AA06718@kenmore.osf.org.osf.org>
> Status: R
> 
> Let me clarify what the symptoms would be.  Suppose that one process mmap'ed
> a file and started accessing memory, so that gradually all the file's data
> would be in VM.  Now another process truncates the file.  The truncation is
> supposed to invalidate some of the pages of VM, so that if the first process
> tries to access memory that is mapped beyond EOF, it gets a SIGBUS signal.
> It does--generally this works fine.  But there is a race, and if the truncating
> process is invalidating some page while the mapping process is accessing it,
> the page might just stay around after the truncation, so that the mapping
> process will get old data rather than a SIGBUS signal.
> 
> It's not a memory leak (VM will be discarded when the memory is unmapped
> anyhow) or any other kind of resource leak.  I don't think it can lead to a
> crash or corruption of the file system.  We have never actually seen this
> race; I found it by reading the code (actually I should say re-reading it,
> since I wrote that code in the first place).  To fix it, it would be necessary
> to designate some new bit in the vnode flags word, and to use that bit in
> wait/proceed decisions similarly to how we currently use VD_ALLOWSTRAT.  That
> is what I meant by changing the "locking structure".  This is a non-trivial
> change.  All these factors strongly suggest deferring.



CR Number                     : 9648
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : Wrong error codes for some Episode ops
Reported Date                 : 12/23/93
Found in Baseline             : 1.0.3a
Found Date                    : 12/23/93
Severity                      : C
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[12/23/93 public]
VOP_REMOVE should return EPERM, not EISDIR, if non-root attempts to unlink
a directory.
VOP_LINK should return EPERM, not EISDIR, if non-root attempts to hard-link
a directory.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[12/29/93 public]
defer to 1.1.  this is a candidate for the 1.0.3a unintegrated
tree



CR Number                     : 9618
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : lfs
Short Description             : assertion failure in test_anode in HandleLogFull
Reported Date                 : 12/15/93
Found in Baseline             : 1.0.3a
Found Date                    : 12/15/93
Severity                      : C
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2
Affected File(s)              : file/episode/logbuf/log.c,tran.c
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[12/15/93 public]
Not the same assertion as OT CR 9612.  The tail of the log of running test_anode
on all_tests is:
Running with debugging on 0x0, 0x0 (test), 0x0 (verify), 0x0 (async), 0x80 (logbuf) 0x0 (osi); 0x0 (tr_global).
Running test multi-block-frag from file multi-block-frag.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Running test multi-block-frag.int from file multi-block-frag.int.test
Test multi-block-frag completed successfully
1465.45u 298.58s 1:10:56 41% 527+2066k 0+0io 64534pf+0w
assertion failed: line 4214, file /project/dce/build/dce1.0.3a-snap/src/file/episode/logbuf/buffer.c
Running with debugging on 0x0, 0x0 (test), 0x0 (verify), 0x0 (async), 0x80 (logbuf) 0x0 (osi); 0x0 (tr_global).
Running test buffer-deadlock from file buffer-deadlock.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Abort process (core dumped)
23.29u 2.49s 0:41 62% 599+2199k 0+0io 97pf+0w
Note that we passed multi-block-frag although we haven't fixed 9612, indicating
that 9612 is not reliably reproducible.
The assertion is at the end of function HandleLogFull:
      /* Signal the transaction system to cleanup ended transactions. */
      elbt_GCTran(dP, /*force*/1);
      if (!action) {
4214:     afsl_Assert (wait == 2);
      }
      return (action != 0);
}
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[12/15/93 public]
This bug is not reliably reproducible, due to thread scheduling variability.
Filled in Reported by Company's Ref. Number with `4745'

[12/16/93 public]
Changed to priority 1 since all functional tests must pass for 1.0.3a release.

[12/16/93 public]
Changing fixby to 1.1.  Dropping priority after discussion w/
Transarc since this problem only shows up in the user-level 
emulation environment and cannot be reproduced using any known 
combination of tests "in the real world" :^>.

[2/16/96]
Fix submitted as part of the 1.2.1 code drop.



CR Number                     : 9613
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : ftserver
Short Description             : ftserver can't recover from pipe exception during move
Reported Date                 : 12/14/93
Found in Baseline             : 1.0.3a
Found Date                    : 12/14/93
Severity                      : B
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2
Affected File(s)              : 1.2.1 code drop
Sensitivity                   : public

[12/14/93 public]
 
We set up an active fileset to move between an HPUX server and a RIOS server.
During the course of one of the moves, the ftserver on the HPUX
got a rpc pipe exception during the SFTSERVER_Restore operation.
Since then, we have be unable to move the fileset onto the HPUX
machine (No, retrying the move does not fix the problem.)  There
seems to be a trasaction on the HPUX ftserver's queue which is
"stuck".
Here's the error we get:
move from alcatraz to explorer
fts_DeleteVolume: 0,,18772 is unattachable (code 382312470).
fts_DeleteVolume: 0,,18573 is unattachable (code 691089523).
Error in move: communications failure (dce / rpc)
move failed date
move from alcatraz to explorer
Cannot check for an existing target fileset 0,,18573 on explorer.osf.org/epi1: copy the
 clone to a new location (dfs / xvl)
Error in move: copy the clone to a new location (dfs / xvl)
Fileset lives on:
gypsy.ft
        readWrite   ID 0,,18573  valid
        readOnly    ID 0,,18574  invalid
        backup      ID 0,,18575  invalid
number of sites: 1
   server           flags     aggr   siteAge principal      owner
alcatraz.osf.org    RW       epi1    0:00:00 hosts/alcatraz <nil> 
statft -server explorerer
Total transactions: 1
--------------------------------------
trans: 998  created: Tue Dec 14 09:46:20 1993
descriptor: 0; ref count 1;  last call: Tue Dec 14 09:51:29 1993
fileset: 0,,18573  aggregate Id: 1   aggrtype: 2/1
action: copy the clone to a new location (dfs / xvl); ops: Restore, SetFlags, GetStatus, SetStatus
Fileset status 0x12810015: R/W, busy, delOnSalvage, move-target, zap-me, type-RW; transDeleted
--------------------------------------
# fts statft -server alcatraz
No active transactions on alcatraz
#
Seems we got a pipe exception and can't recover:
 
1993-Dec-14 09:46:13 Creating fileset gypsy.ft (0,,18573) on aggr 1
1993-Dec-14 09:46:13 Failed to open 1:0,,18573, code = 572833799 (Fileset does not exist (dfs / ftu))
1993-Dec-14 09:46:13 ftserver_CreateVolume: created gypsy.ft as 0,,18573 on aggr 1
1993-Dec-14 09:46:23 Restoring fileset 0,,18573/1
1993-Dec-14 09:46:23 Restoring 1:gypsy.ft (0,,18573)
1993-Dec-14 09:49:22 SFTSERVER_Restore: Exception while restore-terminating: (rpc_x_ss_pipe_comm_error) exceptio
n raised
1993-Dec-14 09:54:47 trans 40602068 (Id=998, 0,,18573/1) is 198 seconds old (ref count 1)
1993-Dec-14 09:54:47 (trans 40602068: desc=0, time=755880689, ctime=755880380, states=0x12810015, accs=0x1c4, ac
ce=691089523)
1993-Dec-14 09:55:17 trans 40602068 (Id=998, 0,,18573/1) is 228 seconds old (ref count 1)
1993-Dec-14 09:55:17 (trans 40602068: desc=0, time=755880689, ctime=755880380, states=0x12810015, accs=0x1c4, ac
ce=691089523)
There are many more lines of like this.
The tail end of the FtLog on explorere:
 
993-Dec-14 10:55:19 trans 40602068 (Id=998, 0,,18573/1) is 3830 seconds old (ref count 1)
1993-Dec-14 10:55:19 (trans 40602068: desc=0, time=755880689, ctime=755880380, states=0x12810015, accs=0x1c4, ac
ce=691089523)
1993-Dec-14 10:55:50 trans 40602068 (Id=998, 0,,18573/1) is 3861 seconds old (ref count 1)
1993-Dec-14 10:55:50 (trans 40602068: desc=0, time=755880689, ctime=755880380, states=0x12810015, accs=0x1c4, ac
ce=691089523)
1993-Dec-14 10:56:20 trans 40602068 (Id=998, 0,,18573/1) is 3891 seconds old (ref count 1)
1993-Dec-14 10:56:20 (trans 40602068: desc=0, time=755880689, ctime=755880380, states=0x12810015, accs=0x1c4, ac
ce=691089523)
1993-Dec-14 10:56:50 trans 40602068 (Id=998, 0,,18573/1) is 3921 seconds old (ref count 1)
1993-Dec-14 10:56:50 (trans 40602068: desc=0, time=755880689, ctime=755880380, states=0x12810015, accs=0x1c4, ac
ce=691089523)
1993-Dec-14 10:57:20 trans 40602068 (Id=998, 0,,18573/1) is 3951 seconds old (ref count 1)
1993-Dec-14 10:57:20 (trans 40602068: desc=0, time=755880689, ctime=755880380, states=0x12810015, accs=0x1c4, ac
ce=691089523)
1993-Dec-14 10:57:50 trans 40602068 (Id=998, 0,,18573/1) is 3981 seconds old (ref count 1)
1993-Dec-14 10:57:50 (trans 40602068: desc=0, time=755880689, ctime=755880380, states=0x12810015, accs=0x1c4, ac
ce=691089523)
1993-Dec-14 10:58:20 trans 40602068 (Id=998, 0,,18573/1) is 4011 seconds old (ref count 1)
1993-Dec-14 10:58:20 (trans 40602068: desc=0, time=755880689, ctime=755880380, states=0x12810015, accs=0x1c4, ac
ce=691089523)
Setup:
 
  1 fileset with connectathon.  Two clients from different machines
  run connectathon while fileset moves every 5 minutes between a RIOS
  server and an HPUX server.  The fileset also has a large
  file on it (don't know if that makes a difference) and its size is
  10315952 bytes;

[12/16/93 public]
This is a serious problem BUT we've made the decision to defer the
fix to 1.1 for now and add a release note for 1.0.3a. If this problem
occurs under more common testing/usage circumstances, we may have to
reconsider.



CR Number                     : 9612
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : EPISODE
Short Description             : Buffer unexpectedly held in elbb_Shutdown
Reported Date                 : 12/14/93
Found in Baseline             : 1.0.3a
Found Date                    : 12/14/93
Severity                      : C
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : ?
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[12/14/93 public]
The last lines of the log file running all_tests are as follows:
.
assertion failed: line 2603, file /project/dce/build/dce1.0.3a-snap/src/file/episode/logbuf/buffer.c
Running with debugging on 0x0, 0x0 (test), 0x0 (verify), 0x0 (async), 0x80 (logbuf) 0x0 (osi); 0x0 (tr_global).
Running test buffer-deadlock from file buffer-deadlock.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Running test buffer-deadlock.int from file buffer-deadlock.int.test
Abort process (core dumped)
81.88u 7.26s 1:46 83% 613+2550k 0+0io 101pf+0w
.
The reason the assertion failure message comes before the output is that stderr
and stdout do not get flushed to the log file at the same time.
.
Line 2603 in buffer.c is in function elbb_Shutdown.  Here it is:
.
	   * we now walk the chain of buffers for this buffer block.  When
	   * we find a device field match we always remove it from the
	   * address hash and then:
	   *
	   *   (1) we schedule the buffer for write; or
	   *   (2) we mark the buffer as killed.
	   */
	  for (bP = (struct buffer *)FIFO_LookAtOldest(&bbP->buffers,
				offsetof(struct buffer, blockThread));
	       bP;
	       bP = (struct buffer *)FIFO_NextOldest(&bbP->buffers, bP,
						     &bP->blockThread)) {
	      if (bP->adev != dP)
		  continue; /* move on */
.
	      /*
	       * since we've started shutting down, we afsl_Assert that
	       * there are no active references for this buffer.
	       */
2603:	      afsl_Assert (bP->refCount == 0);
.
	      /*
	       * remove from address hash; zero field.
	       */
	      (void) epih_HashOut(&addrHashTable, (epih_hashEntry_t)bP);
	      bP->addrHashNext = (struct buffer *)0;
.
	      /*
	       * if the fh is set (magic #) we clear it
	       * and remove this entry from the hash table.
	       */
	      SetFHLocked(bP, 0);
.
	      /*
	       * if it is dirty, schedule it for write.  Remove it from
	       * the free list for the pool.
	       */
	      if (bufferIsDirty(bP)) {
		  if (!bufferIsWritep(bP)) {
		      /*
		       * we have turned off the log, so now we must
		       * "unlog" this buffer.
		       * XXX: this is probably wrong, why not shut
		       * down the log *after* writing? - wam 080791
		       */
		      bufferClearLogged(bP);
		      retval = Write(bP);
		      afsl_MBZ(retval);
		  } /* !bufferIsWritep */
		  RemoveFromFreeList(bpeP, bP);
		  retval = asevent_AddToSet(aset, bP->aevent);
		  afsl_MBZ(retval);
	      } /* bufferIsDirty */
	      else {
		  retval = elbb_SetKilled(bP);
		  afsl_MBZ(retval);
		  afsl_Assert(!bufferIsInuse(bP));
		  bufferClearDelete(bP);
		  bP->delTran = elbt_NullTranId;
	      }
	  } /* for (buffers) */
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[12/14/93 public]
I believe the assertion is incorrect because another thread could be
pulling buffers out of this pool and writing dirty buffers in the
process.  We hold dirty buffers while waiting for thiem so Shutdown may
see these transiently held buffers.  On the other hand I imagine the
code depends on the buffers being unused, so just removing the assert
isn't the appropriate fix.
I've been looking for an excuse to rewrite shutdown (it is riddled with
small problems like this) so maybe this is it!
Filled in Interest List CC with `ota'

[12/15/93 public]
This bug is not reliably reproducible, due to thread scheduling variability.

[12/16/93 public]
Priority changed to 1 since all functional tests must pass for 1.0.3a release.

[12/16/93 public]
Changing fixby to 1.1.  Dropping priority since this problem only 
shows up under high load in the user-level emulation environment
and has not been reproduced even under high load in the "real 
world" :^>.

[1/28/94 public]
I just realized that fixing shutdown is really easy!  All I have to do
is call elbb_QuiesceSystem at full power at the very beginning of
shutdown.  Quiesce has already been rewritten to do all this writing and
waiting safely.  When it returns then everything should be cleaned out
and stay that way (if shutdown is really being called correctly).
Shutdown can then safely assert that all the buffers are clean and
unreferenced.
Changed Interest List CC from `ota' to `ota,rajesh'

[2/10/94 public]
Unfortunately, it is not quite as rosy as I describe above.  Another
thread can get stuck for an indeterminate time, at least in principle,
with a held buffer in WaitForWrite.  So we need to explicitly wait for
these held buffers to be released.  There is code at the end of
GetMoreBufferSpace which does just this.
Changed Short Description from `assertion failure during test_anode on RIOS' to 
 `Buffer unexpectedly held in elbb_Shutdown'

[3/24/94 public]
Opening in Transarc's DB as 5242 for fixing.  The delta name will be:
    ota-db5242-fix-shutdown-buffer-refCount-assert
Changed Subcomponent Name from `lfs' to `EPISODE' 
Filled in Reported by Company's Ref. Number with `5242'



CR Number                     : 9602
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : dfs
Subcomponent Name             : px
Short Description             : stale data in CM for backup filesets
Reported Date                 : 12/8/93
Found in Baseline             : 1.0.2a
Found Date                    : 12/8/93
Severity                      : C
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : ?
Sensitivity                   : public
Transarc Deltas               : bwl-ot9602-sync-info-for-backup-filesets
Transarc Herder               : jaffe@transarc.com
Transarc Status               : export

[12/8/93 public]
There is no way to tell the CM that a backup fileset has been changed
(i.e. by a reclone), if the RW version happens to be lazily replicated.
For instance, after the following sequence:
  fts create bwl                     ; create fileset
  fts setrepinfo bwl -scheduled      ; make it lazily replicated
  fts crmount bwl bwl                ; create junction for it
  <create and edit> bwl/foo          ; create and edit a file in it
  fts clone bwl                      ; create a backup fileset
  fts crmount bwl.backup bwl.backup  ; create junction for backup
  more bwl.backup/foo                ; get backup version of file into cache
  <edit> bwl/foo                     ; put new data in rw version of file
  fts clone bwl                      ; reclone
  fts checkfilesets                  ; tell CM to update cache
  more bwl.backup/foo                ; look at backup version of file
At this point bwl.backup/foo should contain the new data, but instead it has
the old data.  This incorrect behavior only happens if the rw fileset is
lazily replicated; for non-replicated filesets, the new data are propagated
correctly.
The problem seems to be that px_SetSync in px/px_subr.c does not recognize
backup volumes.  It mistakes them for incomplete replicas.  Therefore it
sends a zero VV to the client, and cm_CheckVolSync in the cache manager takes
this as a signal to bail out.
This was reported and diagnosed by Daryl Kinney at HP.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[12/20/93 public]
Defect Closure Form
-------------------
--Verification procedure below--
The verification procedure is given above.
Associated information:
Tested on TA build:  
dfs-osf-1.12
Tested with backing build:  
dce1.0.3ab1
Filled in Transarc Deltas with `bwl-ot9602-sync-info-for-backup-filesets' 
Changed Transarc Status from `open' to `export'



CR Number                     : 8175
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : dfs
Subcomponent Name             : cm
Short Description             : rpc binding has nil object uuid
Reported Date                 : 6/18/93
Found in Baseline             : 1.0.2a
Found Date                    : 6/18/93
Severity                      : C
Priority                      : 2
Status                        : fix
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : ?
Sensitivity                   : public

[6/18/93 public]
We have seen this twice during two days of cho, and always on machine 1:
 
dfs: rpc binding to server 130.105.5.3 in cell leprosy has a nil object uuid!
We will attempt to collect more data on this, but for now that's all we
have.

[7/7/93 public]
We've been unable to reproduce this.  Moving to fixby 1.0.3.

[8/3/93 public]
Cancelling since there's no useful information to be retained 
here.  If it happens again, we'll open another bug.

[10/05/93 public]
 
Well we've now seen it during 1.0.3 cho from rios client
with HPUX server.
 
# kinit -l96h
Enter password:
# kldfs: rpc binding to server 130.105.5.58 in cell headache.qadce.oisf.org has a nil o
bject uuid!
st
 
I really don't know if the kinit has anything to do with this, but right
after I issued kinit the message poped up on the screen.

[10/08/93 public]
 
Aged relative to Aug 1.

[11/09/93 public]
Re-assigning to Jaffe since the fix is in Pittsburgh and we
need to get it here.

[2/09/96 public]
If the fix was in Pittsburgh on 11/09/93, then it is in DCE 1.2.1.
We have not seen this type of problems in our CHO testing for DFS 1.2.1.



