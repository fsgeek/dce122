CR Number                     : 13502
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : "DIFF" Need to sync the file cursor
                                             if the trail is rewound in another process
Reported Date                 : 6/12/96
Found in Baseline             : 1.2.1
Found Date                    : 6/12/96
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 1.2.2, 1.1maint
Affected File(s)              : ../src/security/audit/libaudit/evt_utils
Diff supplied by              : provider
Diff release                  : 1.2.2
Sensitivity                   : public

[6/12/96 public]
We have discovered that when an audit trail is rewound by an application
which is running in different process, the physical size of the file is
reset to 0.  However, the current file cursor of the current process 
which is kept in memory (at->trail_cursor) is still pointing to the old size.
Thus, when an audit record is committed later, it is misplaced. Therefore, any 
application that tries to read the trail after being rewound would not work.   

Here is the fix:

446d445
<     struct stat stbuf;
563,568d561
<
<    /* MUST reset the current file cursor if the file is rewound */
<    /* by an application which is running in different process   */
<    fstat(at->trail_fd, &stbuf);
<    if (stbuf.st_size != at->trail_cursor)
<        at->trail_cursor = stbuf.st_size;

The fix is also added to the current version (DCE1.2.2) which I currently 
place on afs cell (/afs.dce.osf.org/project/dce/ibm/audit/libaudit).

[7/18/96 public]
Fixed in DCE1.2.2 (BL03).

[09/30/96 public]
Fixed in 1.1 maintenance tree.

./security/audit/libaudit/evt_utils.c
Comparing revision 1.1.2.9 with revision 1.1.9.1.
*** 1.1.2.9     1994/09/27 00:27:17
--- 1.1.9.1     1996/09/30 15:12:45
***************
*** 9,18 ****
  /*
   * HISTORY
   * $Log:	c013502,v $
# Revision 1.3  96/09/30  18:45:35  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
   * Revision 1.1.2.9  1994/09/27  00:27:17  weisz
   *    CR 10703: in case of wrap, fopen flags should be wb+
   *    [1994/09/27  00:26:41  weisz]
!  *
   * Revision 1.1.2.8  1994/09/22  21:09:04  weisz
   *    CR 10703: handling of trail full situation.
   *    [1994/09/22  21:07:49  weisz]
--- 9,22 ----
  /*
   * HISTORY
   * $Log:	c013502,v $
# Revision 1.3  96/09/30  18:45:35  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
+  * Revision 1.1.9.1  1996/09/30  15:12:45  mariko
+  *    OT 13502: Need to sync the file cursor if the trail is rewound in another process
+  *    [1996/09/30  15:12:27  mariko]
+  *
   * Revision 1.1.2.9  1994/09/27  00:27:17  weisz
   *    CR 10703: in case of wrap, fopen flags should be wb+
   *    [1994/09/27  00:26:41  weisz]
!  * 
   * Revision 1.1.2.8  1994/09/22  21:09:04  weisz
   *    CR 10703: handling of trail full situation.
   *    [1994/09/22  21:07:49  weisz]
***************
*** 421,426 ****
--- 425,431 ----
      long trail_file_pos;
      long index_file_pos;
      int  rc = 0;
+     struct    stat stbuf;             /* OT 13502 */
  
      *status = aud_s_ok;
  
***************
*** 544,549 ****
--- 549,561 ----
          pthread_mutex_unlock(&at->mutex);
          return;
     }
+ 
+ 
+    /* OT 13502: MUST reset the current file pointer if the file is rewound */
+    /* by an application which is running in different process    */
+    fstat(at->trail_fd, &stbuf);
+    if (stbuf.st_size != at->trail_cursor)
+       at->trail_cursor = stbuf.st_size;
  
     fwrite((void *)&at->trail_cursor, sizeof(idl_byte), sizeof(unsigned32),
             at->md_index_fp);



CR Number                     : 13481
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : "DIFF" dce_aud_get_ev_info" must 
                                             return when it reaches the limit
Reported Date                 : 5/29/96
Found in Baseline             : 1.2.1
Found Date                    : 5/29/96
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 1.2.2, 1.1maint
Affected File(s)              : src/security/audit/libaudit/evt_read.c
Diff supplied by              : provider
Diff release                  : 1.2.2
Sensitivity                   : public

[5/29/96 public]
I have discovered that dce_aud_get_ev_info() must return when it
reaches the item_count limit.  Since the tail_read_cursor starts at
0 not 1, the routine must return when tail_read_cursor=item_count.
Otherwise, it may cause a core dump. Here is the diff:

987c987,989
<     if (ard->tail_read_cursor > ard->tail->item_count) {
---
>
>     /* return if it reaches the last item */
>     if (ard->tail_read_cursor >= ard->tail->item_count) {
990a993

[7/18/96 public]
Fixed in DCE.1.2.2 (BL03).

[09/30/96 public]
Fixed in 1.1 maintenance tree.

./security/audit/libaudit/evt_read.c
Comparing revision 1.1.8.3 with revision 1.1.8.4.
*** 1.1.8.3     1996/09/30 15:04:11
--- 1.1.8.4     1996/09/30 15:21:36
***************
*** 9,18 ****
  /*
   * HISTORY
   * $Log:	c013481,v $
# Revision 1.3  96/09/30  18:41:22  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
   * Revision 1.1.8.3  1996/09/30  15:04:11  mariko
   *    OT 12553: Print audit event numbers in hex
   *    [1996/09/30  15:03:48  mariko]
!  *
   * Revision 1.1.8.2  1995/10/07  00:24:16  parul
   *    Fix OT 13024: need sec_rgy_site_close() on error
   *    [1995/10/07  00:23:40  parul]
--- 9,22 ----
  /*
   * HISTORY
   * $Log:	c013481,v $
# Revision 1.3  96/09/30  18:41:22  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
+  * Revision 1.1.8.4  1996/09/30  15:21:36  mariko
+  *    OT 13481:  dce_aud_get_ev_info must return when it reaches the limit
+  *    [1996/09/30  15:21:12  mariko]
+  *
   * Revision 1.1.8.3  1996/09/30  15:04:11  mariko
   *    OT 12553: Print audit event numbers in hex
   *    [1996/09/30  15:03:48  mariko]
!  * 
   * Revision 1.1.8.2  1995/10/07  00:24:16  parul
   *    Fix OT 13024: need sec_rgy_site_close() on error
   *    [1995/10/07  00:23:40  parul]
***************
*** 481,487 ****
  
      *status = aud_s_ok;
  
!     if (ard->tail_read_cursor > ard->tail->item_count) {
        *ev_info = NULL;
        return;
      }
--- 485,492 ----
  
      *status = aud_s_ok;
  
!     /* OT 13481:  return if it reaches the last item */
!     if (ard->tail_read_cursor >= ard->tail->item_count) {
        *ev_info = NULL;
        return;
      }



CR Number                     : 13390
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : app_ref
Short Description             : Missing the manpages for Audit APIs
Reported Date                 : 3/15/96
Found in Baseline             : 1.2.1
Found Date                    : 3/15/96
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : app_ref
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[3/15/96 public]
The following APIs are missing the manpages:
  1) dce_aud_modify_sstrategy
  2) dce_aud_set_local_cell_uuid

[3/15/96 public]
Assigned to myself, and changed Fixby value to "1.2.2."

[4/29/96 public]
Doug,
Could you also use this OT to correct the man pages for dce_aud_prev() and 
dce_aud_rewind() and add the man page for dce_aud_reset() in DCE1.2.2.
I placed three files in AFS cell, /afs/dce.osf.org/project/dce/ibm/audit/doc,
newapi.ps (postscript), newapi.mif (frame), and newapi.text for your 
references.

Since dce_aud_next() and dce_aud_prev() are almost the same, please correct
dce_aud_next() too for whatever I changed in dce_aud_prev().
Thanks.

[5/29/96 public]

Reassigned to IBM on Willie's advice.

[5/30/96 public]

Made and submitted corrections to dce_aud_prev.3sec and dce_aud_rewind.3sec,
and created the new dce_aud_reset.3sec manpage.

[5/30/96 public]

Made and submitted the corrections to dce_aud_next.3sec.

[7/22/96 public]
Further investigation, I discovered that dce_aud_modify_sstrategy() and
dce_aud_set_local_cell_uuid() are not external APIs.  They were added
in Security API and DCECP for their internal purposes.  

Since dce_aud_next(), dce_aud_prev(), dce_aud_rewind(), and dce_aud_reset()
are done.  I am closing this OT.



CR Number                     : 13312
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : "diff" Coding errors in evt_read.c
Reported Date                 : 2/7/96
Found in Baseline             : 1.1
Found Date                    : 2/7/96
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 1.2.2, 1.1maint
Affected File(s)              : evt_read.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
*******************************************************************
*                            N O T I C E                          *
*******************************************************************
For DCE1.1 and DCE1.2.1, the operator for the predicate accepts only
the colon ":". For DCE1.2.2, it will accept both equal sign and
colon sign.

[2/7/96 public]
Coding errors found in evt_read.c:

  1) Duplicate checking: 
     if ((check_evt && evt_id != header->event) ||
         (check_evt && evt_id != header->event) ||

  2) Wrong logic (true) when checking the uuid of server, client, 
     and cell uuid to go to the next record: 
      (check_server && uuid_equal(&server_uuid, &header->server, status)) ||
      (check_client &&
            uuid_equal(&client_uuid, &header->client_id[0].client, status)) ||
      (check_cell &&
            uuid_equal(&cell_uuid, &header->client_id[0].cell, status)) ||

  3) The operator for predicate value in dce_aud_next() and dce_aud_prev()
     needs to recognize the equal sign (=) as stated in the dcocumentation.

[2/14/96 public]
Here is the diff file.  I also put the diff file and the new version of
evt_read.c in /afs/dce.osf.org/project/dce/ibm/audit cell:

129,148c129,148
<     idl_es_handle_t h;
<     unsigned32        i, j;
<     idl_byte       *ep;
<     idl_ulong_int   esize;
<     aud_esl_act_t actions;
<     aud_log_ev_info_list_t *tail_list;
<     aud_log_ev_info_list_t *retrieved_ev_info;
<     dce_aud_hdr_t  *header;
<     unsigned_char_t *alarm_message;
<     char           *commap;
<     unsigned32      authz_status;
<     unsigned32      evt_id, evt_outcome;
<     unsigned32      rec_start_pos;
<     utc_t           before_time, after_time;
<     uuid_t          server_uuid, client_uuid, cell_uuid, group_uuid;
<     boolean32       check_evt, check_outcome, check_authz_status, check_time_before, check_time_after, check_server, check_client, check_cell, check_group, check_addr;
<     unsigned_char_t *addr;
<     enum utc_cmptype time_relation;
<     char             *local_predicate = NULL;
<     char             *orig_predicate;
---
>     idl_es_handle_t         h;
>     unsigned32              i;
>     idl_byte               *ep;
>     idl_ulong_int           esize;
>     aud_esl_act_t           actions;
>     dce_aud_hdr_t          *header;
>     unsigned_char_t        *alarm_message;
>     char                   *commap;
>     unsigned32              authz_status;
>     unsigned32              evt_id, evt_outcome;
>     unsigned32              rec_start_pos;
>     utc_t                   before_time, after_time;
>     uuid_t                  server_uuid, client_uuid, cell_uuid, group_uuid;
>     boolean32               check_evt, check_outcome, check_authz_status;
>     boolean32               check_time_before, check_time_after;
>     boolean32               check_server, check_client, check_cell, check_group, check_addr;
>     unsigned_char_t        *addr;
>     enum utc_cmptype        time_relation;
>     char                   *local_predicate = NULL;
>     char                   *orig_predicate;
173,174c173,175
<       if (strncmp(local_predicate, "EVENT:", strlen("EVENT:")) == 0) {
<           evt_id = atoi(local_predicate + strlen("EVENT:"));
---
>       if (strncmp(local_predicate, "EVENT:", strlen("EVENT:")) == 0 ||
>           strncmp(local_predicate, "EVENT=", strlen("EVENT=")) == 0) {
>           evt_id = strtol(local_predicate + 6, NULL, 16);
176,177c177,180
<       } else if (strncmp(local_predicate, "OUTCOME:", strlen("OUTCOME:")) == 0) {
<           if (strcmp(local_predicate + strlen("OUTCOME:"), "SUCCESS") == 0) {
---
>       } else if (strncmp(local_predicate, "OUTCOME:", strlen("OUTCOME:")) == 0 ||
>                  strncmp(local_predicate, "OUTCOME=", strlen("OUTCOME=")) == 0) {
>           if (strcmp(local_predicate + strlen("OUTCOME:"), "SUCCESS") == 0 ||
>               strcmp(local_predicate + strlen("OUTCOME="), "SUCCESS") == 0) {
180c183,184
<           } else if (strcmp(local_predicate + strlen("OUTCOME:"), "FAILURE") == 0) {
---
>           } else if (strcmp(local_predicate + strlen("OUTCOME:"), "FAILURE") == 0 ||
>                      strcmp(local_predicate + strlen("OUTCOME="), "FAILURE") == 0) {
183c187,188
<           } else if (strcmp(local_predicate + strlen("OUTCOME:"), "DENIAL") == 0) {
---
>           } else if (strcmp(local_predicate + strlen("OUTCOME:"), "DENIAL") == 0 ||
>                      strcmp(local_predicate + strlen("OUTCOME="), "DENIAL") == 0) {
186c191,192
<           } else if (strcmp(local_predicate + strlen("OUTCOME:"), "PENDING") == 0) {
---
>           } else if (strcmp(local_predicate + strlen("OUTCOME:"), "PENDING") == 0 ||
>                      strcmp(local_predicate + strlen("OUTCOME="), "PENDING") == 0) {
190,191c196,199
<       } else if (strncmp(local_predicate, "STATUS:", strlen("STATUS:")) == 0) {
<           if (strcmp(local_predicate + strlen("STATUS:"), "DCE") == 0) {
---
>       } else if (strncmp(local_predicate, "STATUS:", strlen("STATUS:")) == 0 ||
>                  strncmp(local_predicate, "STATUS=", strlen("STATUS=")) == 0) {
>           if (strcmp(local_predicate + strlen("STATUS:"), "DCE") == 0 ||
>               strcmp(local_predicate + strlen("STATUS="), "DCE") == 0) {
194c202,203
<           } else if (strcmp(local_predicate + strlen("STATUS:"), "NAME") == 0) {
---
>           } else if (strcmp(local_predicate + strlen("STATUS:"), "NAME") == 0 ||
>                      strcmp(local_predicate + strlen("STATUS="), "NAME") == 0) {
198,199c207,208
<       } else if (strncmp(local_predicate, "TIME:>", strlen("TIME:>")) == 0) {
<           utc_mkasctime(&after_time, local_predicate + strlen("TIME:>"));
---
>       } else if (strncmp(local_predicate, "TIME>", strlen("TIME>")) == 0) {
>           utc_mkasctime(&after_time, local_predicate + 5);
201,202c210,215
<       } else if (strncmp(local_predicate, "TIME:<", strlen("TIME:<")) == 0) {
<           utc_mkasctime(&before_time, local_predicate + strlen("TIME:<"));
---
>       } else if (strncmp(local_predicate, "TIME:>", strlen("TIME:>")) == 0 ||
>                  strncmp(local_predicate, "TIME=>", strlen("TIME=>")) == 0) {
>           utc_mkasctime(&after_time, local_predicate + 6);
>           check_time_after = TRUE;
>       } else if (strncmp(local_predicate, "TIME<", strlen("TIME<")) == 0) {
>           utc_mkasctime(&before_time, local_predicate + 5);
204,205c217,223
<       } else if (strncmp(local_predicate, "SERVER:", strlen("SERVER:")) == 0) {
<           uuid_from_string((unsigned_char_t *)local_predicate + strlen("SERVER:"), &server_uuid, tatus);
---
>       } else if (strncmp(local_predicate, "TIME:<", strlen("TIME:<")) == 0 ||
>                  strncmp(local_predicate, "TIME=<", strlen("TIME=<")) == 0) {
>           utc_mkasctime(&before_time, local_predicate + 6);
>           check_time_before = TRUE;
>       } else if (strncmp(local_predicate, "SERVER:", strlen("SERVER:")) == 0 ||
>                  strncmp(local_predicate, "SERVER=", strlen("SERVER=")) == 0) {
>           uuid_from_string((unsigned_char_t *)local_predicate + 7, &server_uuid, status);
207,208c225,227
<       } else if (strncmp(local_predicate, "CLIENT:", strlen("CLIENT:")) == 0) {
<           uuid_from_string((unsigned_char_t *)local_predicate + strlen("CLIENT:"), &client_uuid, tatus);
---
>       } else if (strncmp(local_predicate, "CLIENT:", strlen("CLIENT:")) == 0 ||
>                  strncmp(local_predicate, "CLIENT=", strlen("CLIENT=")) == 0) {
>           uuid_from_string((unsigned_char_t *)local_predicate + 7, &client_uuid, status);
210,211c229,231
<       } else if (strncmp(local_predicate, "CELL:", strlen("CELL:")) == 0) {
<           uuid_from_string((unsigned_char_t *)local_predicate + strlen("CELL:"), &cell_uuid, stats);
---
>       } else if (strncmp(local_predicate, "CELL:", strlen("CELL:")) == 0 ||
>                  strncmp(local_predicate, "CELL=", strlen("CELL=")) == 0) {
>           uuid_from_string((unsigned_char_t *)local_predicate + 5, &cell_uuid, status);
213,214c233,235
<       } else if (strncmp(local_predicate, "GROUP:", strlen("GROUP:")) == 0) {
<           uuid_from_string((unsigned_char_t *)local_predicate + strlen("GROUP:"), &group_uuid, sttus);
---
>       } else if (strncmp(local_predicate, "GROUP:", strlen("GROUP:")) == 0 ||
>                  strncmp(local_predicate, "GROUP=", strlen("GROUP=")) == 0) {
>           uuid_from_string((unsigned_char_t *)local_predicate + 6, &group_uuid, status);
216,218c237,239
<       } else if (strncmp(local_predicate, "ADDR:", strlen("ADDR:")) == 0) {
<           addr = (unsigned_char_t *) malloc(strlen(local_predicate) -
<                                             strlen("ADDR:") + 1);
---
>       } else if (strncmp(local_predicate, "ADDR:", strlen("ADDR:")) == 0 ||
>                  strncmp(local_predicate, "ADDR=", strlen("ADDR=")) == 0) {
>           addr = (unsigned_char_t *) malloc(strlen(local_predicate) - 5 + 1);
350d370
<       (check_evt && evt_id != header->event) ||
353,357c373,377
<       (check_server && uuid_equal(&server_uuid, &header->server, status)) ||
<       (check_client &&
<           uuid_equal(&client_uuid, &header->client_id[0].client, status)) ||
<       (check_cell &&
<           uuid_equal(&cell_uuid, &header->client_id[0].cell, status)) ||
---
>         (check_server && !uuid_equal(&server_uuid, &header->server, status)) ||
>         (check_client &&
>           !uuid_equal(&client_uuid, &header->client_id[0].client, status)) ||
>         (check_cell &&
>           !uuid_equal(&cell_uuid, &header->client_id[0].cell, status)) ||

[07/18/96 public]
Fixed in 1.2.2 (BL03).

[09/30/96 public]
Fixed in 1.1 maintenance tree.

./security/audit/libaudit/evt_read.c
Comparing revision 1.1.8.4 with revision 1.1.8.5.
*** 1.1.8.4     1996/09/30 15:21:36
--- 1.1.8.5     1996/09/30 16:32:24
***************
*** 9,18 ****
  /*
   * HISTORY
   * $Log:	c013312,v $
# Revision 1.7  96/09/30  18:03:06  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
   * Revision 1.1.8.4  1996/09/30  15:21:36  mariko
   *    OT 13481:  dce_aud_get_ev_info must return when it reaches the limit
   *    [1996/09/30  15:21:12  mariko]
!  *
   * Revision 1.1.8.3  1996/09/30  15:04:11  mariko
   *    OT 12553: Print audit event numbers in hex
   *    [1996/09/30  15:03:48  mariko]
--- 9,22 ----
  /*
   * HISTORY
   * $Log:	c013312,v $
# Revision 1.7  96/09/30  18:03:06  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
+  * Revision 1.1.8.5  1996/09/30  16:32:24  mariko
+  *    OT 13312: Fixed several coding and logic errors
+  *    [1996/09/30  16:32:02  mariko]
+  *
   * Revision 1.1.8.4  1996/09/30  15:21:36  mariko
   *    OT 13481:  dce_aud_get_ev_info must return when it reaches the limit
   *    [1996/09/30  15:21:12  mariko]
!  * 
   * Revision 1.1.8.3  1996/09/30  15:04:11  mariko
   *    OT 12553: Print audit event numbers in hex
   *    [1996/09/30  15:03:48  mariko]
***************
*** 130,137 ****
      idl_byte       *ep;
      idl_ulong_int   esize;
      aud_esl_act_t actions;
-     aud_log_ev_info_list_t *tail_list;
-     aud_log_ev_info_list_t *retrieved_ev_info;
      dce_aud_hdr_t  *header;
      unsigned_char_t *alarm_message;
      char           *commap;
--- 134,139 ----
***************
*** 169,221 ****
        if (commap != NULL) {
            *commap = '\0';
        }
!       if (strncmp(local_predicate, "EVENT:", strlen("EVENT:")) == 0) {
            /* OT 12553: print audit event numbers in hex */
!           evt_id = strtoul(local_predicate + strlen("EVENT:"), NULL, 16);
            check_evt = TRUE;
!       } else if (strncmp(local_predicate, "OUTCOME:", strlen("OUTCOME:")) == 0) {
!           if (strcmp(local_predicate + strlen("OUTCOME:"), "SUCCESS") == 0) {
                evt_outcome = aud_c_esl_cond_success;
                check_outcome = TRUE;
!           } else if (strcmp(local_predicate + strlen("OUTCOME:"), "FAILURE") == 0) {
                evt_outcome = aud_c_esl_cond_failure;
                check_outcome = TRUE;
!           } else if (strcmp(local_predicate + strlen("OUTCOME:"), "DENIAL") == 0) {
                evt_outcome = aud_c_esl_cond_denial;
                check_outcome = TRUE;
!           } else if (strcmp(local_predicate + strlen("OUTCOME:"), "PENDING") == 0) {
                evt_outcome = aud_c_esl_cond_pending;
                check_outcome = TRUE;
            }
!       } else if (strncmp(local_predicate, "STATUS:", strlen("STATUS:")) == 0) {
            if (strcmp(local_predicate + strlen("STATUS:"), "DCE") == 0) {
                authz_status = rpc_c_authz_dce;
                check_authz_status = TRUE;
!           } else if (strcmp(local_predicate + strlen("STATUS:"), "NAME") == 0) {
                authz_status = rpc_c_authz_name;
                check_authz_status = TRUE;
            }
!       } else if (strncmp(local_predicate, "TIME:>", strlen("TIME:>")) == 0) {
!           utc_mkasctime(&after_time, local_predicate + strlen("TIME:>"));
            check_time_after = TRUE;
!       } else if (strncmp(local_predicate, "TIME:<", strlen("TIME:<")) == 0) {
!           utc_mkasctime(&before_time, local_predicate + strlen("TIME:<"));
            check_time_before = TRUE;
!       } else if (strncmp(local_predicate, "SERVER:", strlen("SERVER:")) == 0) {
!           uuid_from_string((unsigned_char_t *)local_predicate + strlen("SERVER:"), &server_uuid, status);
            check_server = TRUE;
!       } else if (strncmp(local_predicate, "CLIENT:", strlen("CLIENT:")) == 0) {
!           uuid_from_string((unsigned_char_t *)local_predicate + strlen("CLIENT:"), &client_uuid, status);
            check_client = TRUE;
!       } else if (strncmp(local_predicate, "CELL:", strlen("CELL:")) == 0) {
!           uuid_from_string((unsigned_char_t *)local_predicate + strlen("CELL:"), &cell_uuid, status);
            check_cell = TRUE;
!       } else if (strncmp(local_predicate, "GROUP:", strlen("GROUP:")) == 0) {
!           uuid_from_string((unsigned_char_t *)local_predicate + strlen("GROUP:"), &group_uuid, status);
            check_group = TRUE;
!       } else if (strncmp(local_predicate, "ADDR:", strlen("ADDR:")) == 0) {
!           addr = (unsigned_char_t *) malloc(strlen(local_predicate) -
!                                             strlen("ADDR:") + 1);
            strcpy((char *)addr, local_predicate + strlen("ADDR"));
            check_addr = TRUE;
        }
--- 171,246 ----
        if (commap != NULL) {
            *commap = '\0';
        }
!       /* OT 13312: operator for the predicate accepts both colon and equal sign */
!       if (strncmp(local_predicate, "EVENT:", 6) == 0 ||
!           strncmp(local_predicate, "EVENT=", 6) == 0) {
            /* OT 12553: print audit event numbers in hex */
!           evt_id = strtoul(local_predicate + 6, NULL, 16);
            check_evt = TRUE;
!       } else if (strncmp(local_predicate, "OUTCOME:", 8) == 0||
!                  strncmp(local_predicate, "OUTCOME=", 8) == 0) {
!           if (strcmp(local_predicate + 8, "SUCCESS") == 0) {
                evt_outcome = aud_c_esl_cond_success;
                check_outcome = TRUE;
!           } else if (strcmp(local_predicate + 8, "FAILURE") == 0) {
                evt_outcome = aud_c_esl_cond_failure;
                check_outcome = TRUE;
!           } else if (strcmp(local_predicate + 8, "DENIAL") == 0) {
                evt_outcome = aud_c_esl_cond_denial;
                check_outcome = TRUE;
!           } else if (strcmp(local_predicate + 8, "PENDING") == 0) {
                evt_outcome = aud_c_esl_cond_pending;
                check_outcome = TRUE;
            }
!       } else if (strncmp(local_predicate, "STATUS:", 7) == 0 ||
!                  strncmp(local_predicate, "STATUS=", 7) == 0) {
            if (strcmp(local_predicate + strlen("STATUS:"), "DCE") == 0) {
                authz_status = rpc_c_authz_dce;
                check_authz_status = TRUE;
!           } else if (strcmp(local_predicate + 7, "NAME") == 0) {
                authz_status = rpc_c_authz_name;
                check_authz_status = TRUE;
            }
!       } else if (strncmp(local_predicate, "TIME>", 5) == 0) {
!           utc_mkasctime(&after_time, local_predicate + 5);
            check_time_after = TRUE;
!       } else if (strncmp(local_predicate, "TIME:>", 6) == 0 ||
!                  strncmp(local_predicate, "TIME=>", 6) == 0) {
!           utc_mkasctime(&after_time, local_predicate + 6);
!           check_time_after = TRUE;
!       } else if (strncmp(local_predicate, "TIME<", 5) == 0) {
!           utc_mkasctime(&before_time, local_predicate + 5);
!           check_time_before = TRUE;
!       } else if (strncmp(local_predicate, "TIME:<", 6) == 0 ||
!                  strncmp(local_predicate, "TIME=<", 6) == 0) {
!           utc_mkasctime(&before_time, local_predicate + 6);
            check_time_before = TRUE;
!       } else if (strncmp(local_predicate, "SERVER:", 7) == 0 ||
!                  strncmp(local_predicate, "SERVER=", 7) == 0) {
!           uuid_from_string((unsigned_char_t *)local_predicate + 7, &server_uuid, status);
            check_server = TRUE;
!       } else if (strncmp(local_predicate, "CLIENT:", 7) == 0 ||
!                  strncmp(local_predicate, "CLIENT=", 7) == 0) {
!           uuid_from_string((unsigned_char_t *)local_predicate + 7, &client_uuid, status);
            check_client = TRUE;
!       } else if (strncmp(local_predicate, "CELL:", 5) == 0 ||
!                  strncmp(local_predicate, "CELL=", 5) == 0) {
!           uuid_from_string((unsigned_char_t *)local_predicate + 5, &cell_uuid, status);
            check_cell = TRUE;
!       } else if (strncmp(local_predicate, "GROUP:", 6) == 0 ||
!                  strncmp(local_predicate, "GROUP=", 6) == 0) {
!           uuid_from_string((unsigned_char_t *)local_predicate + 6, &group_uuid, status);
            check_group = TRUE;
!       } else if (strncmp(local_predicate, "ADDR:", 5) == 0 ||
!                  strncmp(local_predicate, "ADDR=", 5) == 0) {
!           addr = (unsigned_char_t *) malloc(strlen(local_predicate) - 5 + 1);
!           if (addr == NULL) {
!               dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, strlen(local_predicate) - 5 + 1);
!               *status = aud_s_cannot_allocate_memory;
!               if (local_predicate)
!                   free(orig_predicate);
!               return;
!           }
            strcpy((char *)addr, local_predicate + strlen("ADDR"));
            check_addr = TRUE;
        }
***************
*** 380,393 ****
        goto next_record;
      }
      if ((check_evt && evt_id != header->event) ||
-       (check_evt && evt_id != header->event) ||
        (check_outcome && evt_outcome != header->outcome) ||
        (check_authz_status && authz_status != header->authz_st) ||
!       (check_server && uuid_equal(&server_uuid, &header->server, status)) ||
!       (check_client && 
!           uuid_equal(&client_uuid, &header->client_id[0].client, status)) ||
!       (check_cell && 
!           uuid_equal(&cell_uuid, &header->client_id[0].cell, status)) ||
        (check_addr && strcmp((char *)addr, (char *)header->addr) == 0)) {
        goto next_record;
      }
--- 405,416 ----
        goto next_record;
      }
      if ((check_evt && evt_id != header->event) ||
        (check_outcome && evt_outcome != header->outcome) ||
        (check_authz_status && authz_status != header->authz_st) ||
!       /* OT 13312: logic error for checking the uuid of server, client, and cell */
!       (check_server && !uuid_equal(&server_uuid, &header->server, status)) ||
!       (check_client && !uuid_equal(&client_uuid, &header->client_id[0].client, status)) ||
!       (check_cell   && !uuid_equal(&cell_uuid, &header->client_id[0].cell, status)) ||
        (check_addr && strcmp((char *)addr, (char *)header->addr) == 0)) {
        goto next_record;
      }



./security/audit/libaudit/aud.sams
Comparing revision 1.1.7.3 with revision 1.1.7.4.
*** 1.1.7.3     1996/09/30 14:50:37
--- 1.1.7.4     1996/09/30 16:32:23
***************
*** 6,15 ****
  # 
  # HISTORY
  # $Log:	c013312,v $
# Revision 1.7  96/09/30  18:03:06  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
  # Revision 1.1.7.3  1996/09/30  14:50:37  mariko
  #     OT 13179:  hash_uuid_failed msg enhance
  #     [1996/09/30  14:50:00  mariko]
! #
  # Revision 1.1.7.2  1996/01/27  16:12:35  dlynch
  #     CR OT 13120 - changed auth info to pkt integrity
  #     from pkt privacy.
--- 6,20 ----
  # 
  # HISTORY
  # $Log:	c013312,v $
# Revision 1.7  96/09/30  18:03:06  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
+ # Revision 1.1.7.4  1996/09/30  16:32:23  mariko
+ #     OT 13312: coding errors in evt_read.c  Added "sub-compnent" and "attributes"
+ #               to 'aud_s_cannot_allocate_memory' to avoid compilation error.
+ #     [1996/09/30  16:30:59  mariko]
+ #
  # Revision 1.1.7.3  1996/09/30  14:50:37  mariko
  #     OT 13179:  hash_uuid_failed msg enhance
  #     [1996/09/30  14:50:00  mariko]
! # 
  # Revision 1.1.7.2  1996/01/27  16:12:35  dlynch
  #     CR OT 13120 - changed auth info to pkt integrity
  #     from pkt privacy.
***************
*** 1091,1096 ****
--- 1096,1103 ----
  
  start
  code          aud_s_cannot_allocate_memory
+ sub-component aud_s_general
+ attributes    "svc_c_sev_error"
  text          "Cannot allocate %d bytes memory"
  explanation   "The \*Lmalloc()\*O call failed."
  action                "Report to your system administrator for resolution."



CR Number                     : 13311
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : "diff" Audit Trail needs to be
                                             opened in binary mode
Reported Date                 : 2/7/96
Found in Baseline             : 1.1
Found Date                    : 2/7/96
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 1.2.2, 1.1maint
Affected File(s)              : trl_ops.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/7/96 public]
The Audit Trail file needs to be opened with "rb" mode in order
to read correctly the data that has value > 2**16 for some platforms.

[2/8/96 public]
Here is the diff.  The diff and new version of trl_ops.c are also
found in /afs/dce.osf.org/project/dce/ibm/audit subdir.

221c221
<           open_flags = "r";
---
>           open_flags = "rb";

[7/18/96 public]
Fixed in DCE1.2.2 (BL03).

[09/30/96 public]
Fixed in 1.1 maintenance tree.

./security/audit/libaudit/trl_ops.c
Comparing revision 1.1.6.2 with revision 1.1.6.3.
*** 1.1.6.2     1996/01/27 16:12:37
--- 1.1.6.3     1996/09/30 14:00:05
***************
*** 9,19 ****
  /*
   * HISTORY
   * $Log:	c013311,v $
# Revision 1.5  96/09/30  18:53:16  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [trant 7/18/96 public] [mariko 09/30/96 public] [trant 7/18/96 public]
# 
   * Revision 1.1.6.2  1996/01/27  16:12:37  dlynch
   *    CR OT 13120 - changed auth info from pkt privacy to
   *    pkt integrity.
   *    [1996/01/27  16:11:48  dlynch]
!  *
   * Revision 1.1.6.1  1995/12/01  19:10:10  dlynch
   *    Mutex not destroyed in dce_aud_close().  (OT CR 13139)
   *    [1995/12/01  19:09:44  dlynch]
--- 9,23 ----
  /*
   * HISTORY
   * $Log:	c013311,v $
# Revision 1.5  96/09/30  18:53:16  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [trant 7/18/96 public] [mariko 09/30/96 public] [trant 7/18/96 public]
# 
+  * Revision 1.1.6.3  1996/09/30  14:00:05  mariko
+  *    OT 13311  Audit Trail needs to be opened in binary mode
+  *    [1996/09/30  13:58:44  mariko]
+  *
   * Revision 1.1.6.2  1996/01/27  16:12:37  dlynch
   *    CR OT 13120 - changed auth info from pkt privacy to
   *    pkt integrity.
   *    [1996/01/27  16:11:48  dlynch]
!  * 
   * Revision 1.1.6.1  1995/12/01  19:10:10  dlynch
   *    Mutex not destroyed in dce_aud_close().  (OT CR 13139)
   *    [1995/12/01  19:09:44  dlynch]
***************
*** 227,233 ****
        }
      } else {
        if (open_for_read) {
!           open_flags = "r";
        } else {
            if (storage_strategy_wrap) {
                 open_flags = "wb+";
--- 231,237 ----
        }
      } else {
        if (open_for_read) {
!           open_flags = "rb";  /* OT13311: Open audit trail in binary mode */
        } else {
            if (storage_strategy_wrap) {
                 open_flags = "wb+";



CR Number                     : 13203
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : "diff" Improve dce_aud_rewind()
Reported Date                 : 11/15/95
Found in Baseline             : 1.1
Found Date                    : 11/15/95
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : 
../src/security/audit/libaudit/trl_ops.c
../src/security/audit/libaudit/aud.sams
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/15/95 public]
Improve the functionality of dce_aud_rewind() routine.

[11/15/95 public]
Here is the new version of dce_aud_rewind().  The diff files
of trl_ops.c and aud.sams are also placed in
/afs/dce.osf.org/project/dce/ibm/audit subdir

1) diff file for trl_ops.c:

149,153c149,175
<     ftruncate(at->trail_fd, 0); /* truncate the trail file */
<     ftruncate(at->md_index_fd, 0); /* truncate the index file */
<     at->trail_cursor = 0;
<     fseek(at->trail_fp, 0, SEEK_SET);  /* rewind the trail file */
<     fseek(at->md_index_fp, 0, SEEK_SET);  /* rewind the index file */
---
>     /* lock the mutex */
>     pthread_mutex_lock(&at->mutex);
>
>     /* rewind the trail file */
>      if (ftruncate(at->trail_fd, 0) == -1) {        /* truncate the trail file'size */
>          dce_svc_printf(AUD_S_REWIND_TRAIL_FILE_MSG, at->trail_file);
>          *stp = aud_s_rewind_trail_file;
>          pthread_mutex_unlock(&at->mutex);
>          return;
>     }
>
>     /* rewind the index file */
>      if (ftruncate(at->md_index_fd, 0) == -1) {     /* truncate the index file'size */
>          dce_svc_printf(AUD_S_REWIND_INDEX_FILE_MSG, at->index_file);
>          *stp = aud_s_rewind_index_file;
>          pthread_mutex_unlock(&at->mutex);
>          return;
>     }
>
>     at->index_cursor = 0;                           /* reset the index cursor       */
>     at->trail_cursor = 0;                           /* reset the trail cursor       */
>     fseek(at->trail_fp, 0, SEEK_SET);               /* reet the trail file handle   */
>     fseek(at->md_index_fp, 0, SEEK_SET);            /* reset the index file handle  */
>
>     /* unlock the mutex */
>     pthread_mutex_unlock(&at->mutex);
>     return;
243c265
<           fseek(trail_fp, 0, SEEK_END);  /* go to the end of the file */
---
>           fseek(trail_fp, 0, SEEK_END);     /* go to the end of the file */
262a285,286
>           (*at)->index_file = (char *) malloc(strlen(buf) + 1);
>           strcpy((*at)->index_file, buf);

2) diff file for aud.sams:

1346a1347,1364
> start
> code            aud_s_rewind_trail_file
> sub-component   aud_s_trl
> attributes      "svc_c_sev_error"
> text            "Could not rewind the Audit trail file"
> explanation     "The \*Lftruncate()\*O call on the trail file failed."
> action          "Contact your system administrator."
> end
>
> start
> code            aud_s_rewind_index_file
> sub-component   aud_s_trl
> attributes      "svc_c_sev_error"
> text            "Could not rewind the Audit index file"
> explanation     "The \*Lftruncate()\*O call on the index file failed."
> action          "Contact your system administrator."
> end
>

[7/18/96 public]
Fixed in DCE1.2.2 (BL03).



CR Number                     : 13196
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : "diff" Record instances when auditd is killed
Reported Date                 : 11/10/95
Found in Baseline             : 1.1
Found Date                    : 11/10/95
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : dmn_main.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/10/95 public]
Currently, audit daemon only is recorded when it is killed by
dcecp -c aud stop.  There is a need to record instances when
audit daemon is killed abnormally.

[11/17/95 public]
I made the enhancement.  The diff file and new version of dmn_main.c 
are also placed in /afs/dce.osf.org/project/dce/ibm/audit subdir.

Here is the diff file for dmn_main.c:

131,135c131,136
< #define CONCURRENCY_LEVEL   8
< #define ONE_MINUTE          60
< #define FIVE_MINUTES        300
< #define TEN_MINUTES         600
< #define NAME_BUF_SIZE     256
---
> #define CONCURRENCY_LEVEL          8
> #define ONE_MINUTE                 60
> #define FIVE_MINUTES               300
> #define TEN_MINUTES                600
> #define NAME_BUF_SIZE            256
> #define TASK_STACK_SIZE            64*1024
137c138
< #define ADMIN_DIR_SUBPATH  "/var/audit/adm"
---
> #define ADMIN_DIR_SUBPATH          "/var/audit/adm"
139c140
< #define AUD_DIRECTORY_NAME  "audit-server"
---
> #define AUD_DIRECTORY_NAME         "audit-server"
141c142,145
< serviceability_v1_0_epv_t dce_svc_ep;
---
> serviceability_v1_0_epv_t          dce_svc_ep;
> dce_aud_trail_t                    central_trail;
> pthread_attr_t                     attr;
> pthread_t                          distinguished_task;
143c147,150
< dce_aud_trail_t central_trail;
---
> boolean32 non_dt_fatal_error     = FALSE;
> boolean32 audit                  = FALSE;
> boolean32 got_login_context      = FALSE;
>
149,154d155
< #define TASK_STACK_SIZE     64*1024
< pthread_attr_t  attr;
< boolean32       non_dt_fatal_error = FALSE;
< pthread_t       distinguished_task;
<
< boolean32 audit = FALSE;
156,158c157,159
<                                   unsigned32 *, void ***,
<                                   aud_esl_guides_p_t *,
<                                   aud_esl_guides_p_t *);
---
>                                unsigned32 *, void ***,
>                                aud_esl_guides_p_t *,
>                                aud_esl_guides_p_t *);
161c162
<                                   unsigned32 *, void *** );
---
>                                       unsigned32 *, void *** );
186c187
< char *server_name = NULL;
---
> char *server_name     = NULL;
189c190
< boolean32 debug_mode = FALSE;
---
> boolean32 debug_mode  = FALSE;
190a192,193
> uuid_vector_t           ns_export_uuid_vector;
> char                  audit_export_name[NAME_BUF_SIZE];
235c238
<     char                    *count_string;
---
>     char                   *count_string;
331a335,408
> /* excepttion handler routine to handle the exception */
>
> void sig_handle()
> {
>    sigset_t         sigmask;
>    int              signal_num;
>    int              i;
>    dce_aud_rec_t    ard;
>    error_status_t   stp;
>    unsigned_char_t *addr;
>
>    sigemptyset(&sigmask);
>    sigaddset(&sigmask, SIGDANGER);
>    sigaddset(&sigmask, SIGINT);
>    sigaddset(&sigmask, SIGTERM);
>
>       while (signal_num = sigwait(&sigmask))
>         switch (signal_num) {
>              case SIGINT:
>              case SIGTERM:
>                     /* record the event */
>                     for (i = 0; i < bindings->count; i++) {
>                        if (got_login_context) {
>                          rpc_binding_set_auth_info(bindings->binding_h[i],
>                                                   (unsigned char *) auditd_identity,
>                                                    rpc_c_protect_level_pkt_integ,
>                                                    rpc_c_authn_default,
>                                                    NULL,
>                                                    rpc_c_authz_dce,
>                                                   &stp);
>                          if (stp == rpc_s_ok)
>                            dce_aud_start_with_server_binding(EVT_STOP,
>                                                              bindings->binding_h[i],
>                                                              aud_c_evt_all_info,
>                                                              aud_c_esl_cond_success,
>                                                              &ard,
>                                                              &stp);
>                        } else {
>                          rpc_binding_set_auth_info(bindings->binding_h[i],
>                                                   (unsigned char *) auditd_identity,
>                                                    rpc_c_authn_level_none,
>                                                    rpc_c_authn_none,
>                                                    NULL,
>                                                    rpc_c_authz_dce,
>                                                   &stp);
>                          rpc_binding_to_string_binding(bindings->binding_h[i], &addr, &stp);
>                          dce_aud_start_with_name(EVT_STOP,
>                                                 (unsigned char *) auditd_identity,
>                                                  addr,
>                                                  aud_c_evt_all_info,
>                                                  aud_c_esl_cond_success,
>                                                 &ard,
>                                                 &stp);
>                        }
>
>                        /* write to the trail file */
>                        if (ard != NULL && stp == aud_s_ok) {
>                          dce_aud_commit(central_trail, ard, 0, 0, aud_c_esl_cond_success, &stp);
>                        } /* endif */
>                     } /* endfor */
>
>                     /* close the trail file and stop listening */
>                     if (central_trail != NULL)
>                       dce_aud_close(central_trail, &stp);
>
>                     unregister_auditd_interfaces((unsigned_char_t *)audit_export_name, &ns_export_uuid_ector);
>                  exit(1);
>              case SIGDANGER:
>                  break;
>              default:        /* should not occur */
>                  abort();
>       }
> }
>
348d424
<     uuid_vector_t       ns_export_uuid_vector;
353a430
>     sigset_t            sigmask;
354a432,441
>     /* Set the process signal mask in the main thread. */
>
>     sigemptyset(&sigmask);
>     sigaddset(&sigmask, SIGINT);
>     sigaddset(&sigmask, SIGTERM);
>     sigaddset(&sigmask, SIGDANGER);
>     sigaddset(&sigmask, SIGUSR1);
>     sigaddset(&sigmask, SIGCHLD);
>     sigprocmask(SIG_BLOCK, &sigmask, NULL);
>
451a539
>     got_login_context = TRUE;
519c607,615
<
---
>
>     /* set up our signal handling code */
>     if (pthread_create(&sig_thread_id, pthread_attr_default,
>                       (pthread_startroutine_t)sig_handle,
>                       (pthread_addr_t)0) == -1) {
>         perror("Unable to create the thread for signal handling.");
>         exit(1);
>     }
>


[trant public]
updated some fields.

[trant public]
Changed the protect level from privacy to integ.

[7/18/96 public]
Fixed in DCE1.2.2 (BL03).



CR Number                     : 13195
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : "diff" Provide formatting capabilities 
                                             for audit report generation
Reported Date                 : 11/9/95
Found in Baseline             : 1.1
Found Date                    : 11/9/95
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : 
 ../src/security/audit/libaudit/evt_read.c
 ../src/test/security/audit/ts/api_log/aud_test_rpc_manager.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/9/95 public]
As requested by HP, the audit should provide a nice format for
audit report generation.

[11/10/95 public]
My suggestion for the new format of the audit record as followed:

--- Event Record number i ---
o Event Information:
  o Event Number:             hex and dce
  o Event Name:               ascii name
  o Event Class:              ascci name
  o Event Outcome:            ascii text
o Server:                     hostname or uuid
o Client and Cell:            client and cell uuid
o Number of groups:           number
o Authorization Status:       name or PAC
o Time to record (local):     yyyy-mm-dd-hh:mm:ss.nnn-nn:nnc
o Event specific information: 
  o item 1:                   type
  o item 2:                   type 
  o item 3:                   type
  o ...
--- End Event record number i ---

Please feedback for comments/suggestions.

[11/14/95 public]
I made the modification and here is the diff file foe evt_read.c.  
The diff file and the new version of evt_read.c are also placed
in /afs/dce.osf.org/project/dce/ibm/audit subdir.

If there is no objection, I would like to have this OT to merge
into DCE1.2 along with the other OTs submitted by HP and IBM
for this file.

Here is the diff:

100a101,103
> e_t            *e_table;
> static int      record_counter = 0;
> static char    *host = NULL;
102d104
<
566c568
<     dce_aud_hdr_t   header;
---
>     dce_aud_hdr_t           header;
568,581c570,585
<     int             i,j;
<     client_id_t     id;
<     int             id_count;
<     unsigned_char_t *sp;
<     char            buf[100];
<     sec_rgy_handle_t rgy_context;
<     sec_rgy_name_t  subject_name;
<     boolean32       output_uuids = TRUE;
<     char            *strbuf;
<     int                   index;
<     sec_login_handle_t login_context;
<     sec_login_net_info_t net_info;
<     boolean32       found = FALSE;
<     own_id_t        *secondary_group_ptr, *temp_group_ptr;
---
>     int                     i,j;
>     client_id_t             id;
>     int                     id_count;
>     unsigned_char_t        *sp;
>     char                    buf[100];
>     char                    event_name[80];
>     sec_rgy_handle_t        rgy_context;
>     sec_rgy_name_t          subject_name;
>     boolean32               output_uuids = TRUE;
>     char                   *strbuf;
>     int                           index;
>     sec_login_handle_t       login_context;
>     sec_login_net_info_t    net_info;
>     boolean32               found = FALSE;
>     own_id_t               *secondary_group_ptr, *temp_group_ptr;
>     error_status_t          stp;
662a667,670
>     if (host == NULL) {
>       dce_cf_get_host_name(&host, &stp);
>     } /* endif */
>
666a675,694
>
>     record_counter++;
>     sprintf(strbuf, "\n--- Event Record number %i ---\n", record_counter);
>     index = strlen(strbuf);
>     sprintf(strbuf+strlen(strbuf), "o Event Information:\n");
>     index = strlen(strbuf);
>     sprintf(strbuf+strlen(strbuf), "   %-27s %#lx /* %ld */\n",
>           "- Event Number:", header.event, header.event);
>     index = strlen(strbuf);
>     get_event_name_from_number(header.event, event_name);
>     sprintf(strbuf+strlen(strbuf), "   %-27s %s\n",
>           "- Event Name:", event_name);
>     index = strlen(strbuf);
>     sprintf(strbuf+index, "   %-27s", "- Event Outcome:");
>     for (i = 0; i < MAX_CONDITIONS - 1; i++) {
>       if ((audit_condition[i].number & header.outcome) != 0) {
>           index = strlen(strbuf);
>           sprintf(strbuf+index, " %s ", audit_condition[i].name);
>       }
>     }
668,669d695
<     sprintf(strbuf, "\n--- Dumping an event record --- ");
<     sprintf(strbuf+strlen(strbuf), "Event Number: %ld\n", header.event);
670a697,698
>     sprintf(strbuf+index, "\n");
>     index = strlen(strbuf);
676c704,708
<            sprintf(strbuf+index, "Server: NULL\n");
---
>          if (host == NULL)
>              sprintf(strbuf+index, "%-30s\n", "o Server: NULL");
>          else
>              sprintf(strbuf+index, "%-30s /.:/%s\n",
>                      "o Server:", host);
678c710
<        else
---
>        else
680,681c712,713
<            sec_rgy_pgo_id_to_name(rgy_context, sec_rgy_domain_person,
<                                &header.server, subject_name, status);
---
>          sec_rgy_pgo_id_to_name(rgy_context, sec_rgy_domain_person,
>                              &header.server, subject_name, status);
683,690c715,724
<            if (BAD_STATUS(status))
<            {
<                sprintf(strbuf+index, "Unknown server uuid \n");
<            }
<            else
<            {
<                sprintf(strbuf+index, "Server: %s\n", subject_name);
<            }
---
>          if (BAD_STATUS(status))
>          {
>              sprintf(strbuf+index, "%-30s %s\n",
>                      "o Server:", "Unknown server uuid");
>          }
>          else
>          {
>              sprintf(strbuf+index, "%-30s %s\n",
>                      "o Server:", subject_name);
>          }
695,697c729,731
<         uuid_to_string(&header.server, &sp, status);
<         sprintf(strbuf+index, "Server UUID: %s\n", sp);
<         rpc_string_free(&sp, status);
---
>       uuid_to_string(&header.server, &sp, status);
>       sprintf(strbuf+index, "%-30s %s\n", "o Server UUID:", sp);
>       rpc_string_free(&sp, status);
704c738
<         if (!output_uuids) {
---
>       if (!output_uuids) {
706,716c740,751
<             refresh_counter++;
<
<             if(uuid_equal(&id.client, &own_principal_uuid, status) &&
<                    uuid_equal(&id.cell, &own_cell_uuid, status))
<             {
<              sprintf(strbuf+index, "Client: %s\n", own_global_princ_name);
<             }
<             else
<             {
<              sec_id_gen_name(rgy_context, &id.cell, &id.client,
<                               subject_name, NULL, NULL, status);
---
>           refresh_counter++;
>
>           if(uuid_equal(&id.client, &own_principal_uuid, status) &&
>                  uuid_equal(&id.cell, &own_cell_uuid, status))
>           {
>              sprintf(strbuf+index, "%-30s %s\n",
>                      "o Client:", own_global_princ_name);
>           }
>           else
>           {
>              sec_id_gen_name(rgy_context, &id.cell, &id.client,
>                               subject_name, NULL, NULL, status);
718c753,754
<                  sprintf(strbuf+index, "Unknown client and cell uuids \n");
---
>                  sprintf(strbuf+index, "%-30s %s\n",
>                          "o Client:", "Unknown client and cell uuids");
720c756,757
<                  sprintf(strbuf+index, "Client: %s\n", subject_name);
---
>                  sprintf(strbuf+index, "%-30s %s\n",
>                          "o Client:", subject_name);
722,723c759,760
<             }
<         } else {
---
>           }
>       } else {
725c762
<           sprintf(strbuf+index, "Client UUID: %s\n", sp);
---
>           sprintf(strbuf+index, "%-30s %s\n", "o Client UUID", sp);
728,729c765,766
<             index = strlen(strbuf);
<           sprintf(strbuf+index, "Cell UUID: %s\n", sp);
---
>           index = strlen(strbuf);
>           sprintf(strbuf+index, "%-30s %s\n", "o Cell UUID", sp);
731,734c768,771
<         }
<         index = strlen(strbuf);
<         if (!((id.num_groups == 1) && (uuid_is_nil(&id.groups[0], status))))
<         {
---
>       }
>       index = strlen(strbuf);
>       if (!((id.num_groups == 1) && (uuid_is_nil(&id.groups[0], status))))
>       {
736,740c773,777
<            if ((flags & aud_c_evt_groups_info) != 0) {
<              sprintf(strbuf+index, "Number of groups: %ld\n",
<                      id.num_groups);
<            }
<            if (id.num_groups != 0 && (flags & aud_c_evt_groups_info) != 0) {
---
>          if ((flags & aud_c_evt_groups_info) != 0) {
>              sprintf(strbuf+index, "%-30s %ld\n",
>                      "o Number of groups:", id.num_groups);
>          }
>          if (id.num_groups != 0 && (flags & aud_c_evt_groups_info) != 0) {
742c779
<                  for (i = 0; i < id.num_groups; i++) {
---
>                  for (i = 0; i < id.num_groups; i++) {
744,745c781,782
<                        index = strlen(strbuf);
<                      sprintf(strbuf+index, "Group UUID: %s\n", sp);
---
>                      index = strlen(strbuf);
>                      sprintf(strbuf+index, "   %-30s %s\n", "o Group UUID:", sp);
747c784
<                  }
---
>                  }
749,787c786,824
<                  for (i = 0; i < id.num_groups; i++) {
<                        found = FALSE;
<                        index = strlen(strbuf);
<                        if(uuid_equal(&id.groups[i], &own_primary_group_id.group_uuid, status) &&
<                                              uuid_equal(&id.cell, &own_cell_uuid, status))
<                        {
<                         sprintf(strbuf+index, "Group %ld: %s\n", i,
<                                    own_primary_group_id.global_group_name);
<                           found = TRUE;
<                        }
<                        else
<                        {
<                          j = 0;
<                          secondary_group_ptr = own_primary_group_id.next;
<
<
<                        while ((secondary_group_ptr != NULL) && (j < own_num_of_groups) && (!ound))
<                          {
<                            if(uuid_equal(&id.groups[i], &secondary_group_ptr->group_uuid, sttus) &&
<                                          uuid_equal(&id.cell, &own_cell_uuid, status))
<                            {
<                             sprintf(strbuf+index, "Group %ld: %s\n", i,
<                                        secondary_group_ptr->global_group_name);
<                               found = TRUE;
<                            }
<                            j++;
<                            secondary_group_ptr = secondary_group_ptr->next;
<                          }
<                          if (!found)
<                          {
<                           sec_id_gen_group(rgy_context, &id.cell, &id.groups[i],
<                                              subject_name, NULL, NULL, status);
<                             if (BAD_STATUS(status)) {
<                               sprintf(strbuf+index, "Unknown group uuid \n");
<                           } else {
<                               sprintf(strbuf+index, "Group %ld: %s\n", i, subject_name);
<                           }
<                          }
<                      }
<                  }
---
>                  for (i = 0; i < id.num_groups; i++) {
>                      found = FALSE;
>                      if(uuid_equal(&id.groups[i], &own_primary_group_id.group_uuid, status) &
                                             uuid_equal(&id.cell, &own_cell_uuid, status))    >
>                      {
>                         sprintf(strbuf+index, "   - Group %ld:                  %s\n", i,
>                                  own_primary_group_id.global_group_name);
>                         found = TRUE;
>                      }
>                      else
>                      {
>                        j = 0;
>                        secondary_group_ptr = own_primary_group_id.next;
>
>                        while ((secondary_group_ptr != NULL) && (j < own_num_of_groups) && (!ound))
>                        {
>                          if(uuid_equal(&id.groups[i], &secondary_group_ptr->group_uuid, stats) &&
>                                        uuid_equal(&id.cell, &own_cell_uuid, status))
>                          {
>                             sprintf(strbuf+index, "   - Group %ld:                  %s\n", i,
>                                      secondary_group_ptr->global_group_name);
>                             found = TRUE;
>                          }
>                          j++;
>                          secondary_group_ptr = secondary_group_ptr->next;
>                        }
>                        if (!found)
>                        {
>                           sec_id_gen_group(rgy_context, &id.cell, &id.groups[i],
>                                            subject_name, NULL, NULL, status);
>                           if (BAD_STATUS(status)) {
>                               sprintf(strbuf+index, "Unknown group uuid \n");
>                           } else {
>                               sprintf(strbuf+index, "   - Group %ld:                  %s\n", i, subject_name);
>                           }
>                        }
>                      }
>                  }
789,794c826,831
<            }
<         }
<         else
<         {
<           sprintf(strbuf+index, "Number of groups:           Nil\n");
<         }
---
>          }
>       }
>       else
>       {
>           sprintf(strbuf+index, "o Number of groups: Nil\n");
>       }
799c836
<       if ((flags & aud_c_evt_delegates_info) == 0) break;
---
>       if ((flags & aud_c_evt_delegates_info) == 0) break;
800a838
>
802,808c840
<     sprintf(strbuf+index, "Event Outcome: ");
<     for (i = 0; i < MAX_CONDITIONS - 1; i++) {
<       if ((audit_condition[i].number & header.outcome) != 0) {
<             index = strlen(strbuf);
<           sprintf(strbuf+index, "%s ", audit_condition[i].name);
<       }
<     }
---
>     sprintf(strbuf+index, "%-30s", "o Authorization Status:");
810,813d841
<     sprintf(strbuf+index, "\n");
<     index = strlen(strbuf);
<     sprintf(strbuf+index, "Authorization Status: ");
<     index = strlen(strbuf);
815c843
<       sprintf(strbuf+index, "Authorized with a name\n");
---
>       sprintf(strbuf+index, " Authorized with a name\n");
817c845
<       sprintf(strbuf+index, "Authorized with a pac\n");
---
>       sprintf(strbuf+index, " Authorized with a pac\n");
821c849
<     sprintf(strbuf+index, "Local Time: %s\n", buf);
---
>     sprintf(strbuf+index, "%-30s %s\n", "o Date and Time recorded:", buf);
824c852
<       sprintf(strbuf+index, "Client Address: %s\n", header.addr);
---
>       sprintf(strbuf+index, "%-30s %s\n", "o Client Address:", header.addr);
829c857
<       sprintf(strbuf+index, "%ld event specific info items\n", tail->item_count);
---
>       sprintf(strbuf+index, "o %ld Event(s) specific:\n", tail->item_count);
831,833c859,861
<             index = strlen(strbuf);
<           sprintf(strbuf+index, "item %d: ", i + 1);
<             index = strlen(strbuf);
---
>           index = strlen(strbuf);
>           sprintf(strbuf+index, "   - item number %d %s", i + 1, "            ");
>           index = strlen(strbuf);
918a947
>
920c949
<     sprintf(strbuf+index, "--- End of an event record --- \n\n\n");
---
>     sprintf(strbuf+index, "--- End of Event record number %i --- \n\n\n", record_counter);


The old format and new format are also shown below:

  o Old format:


--- Dumping an event record --- Event Number: 113
Event Name: LOGIN_GetInfo
Server: /.:/hosts/dceos2.austin.ibm.com
Unknown client and cell uuids
Number of groups: 0
Event Outcome: success
Authorization Status: Authorized with a pac
Local Time: 1995-10-10-10:57:58.660-05:00I-----
1 event specific info items
item 1: char string hosts/aztec.austin.ibm.com/self
--- End of an event record ---



--- Dumping an event record --- Event Number: 113
Event Name: LOGIN_GetInfo
Server: /.:/hosts/dceos2.austin.ibm.com
Unknown client and cell uuids
Number of groups: 0
Event Outcome: success
Authorization Status: Authorized with a pac
Local Time: 1995-10-10-10:58:00.530-05:00I-----
1 event specific info items
item 1: char string dce-rgy
--- End of an event record ---

  o New format:


--- Event Record number 1 ---
o Event Information:
   - Event Number:             0x113 /* 275 */
   - Event Name:               LOGIN_getinfo
   - Event Outcome:            success
o Server:                      /.:/hosts/dceos2.austin.ibm.com
o Client:                      Unknown client and cell uuids
o Number of groups:            0
o Authorization Status:        Authorized with a pac
o Date and Time recorded:      1995-10-10-10:57:58.660-05:00I-----
o 1 Event(s) specific:
   - item number 1             char string hosts/aztec.austin.ibm.com/self
--- End of Event record number 1 ---



--- Event Record number 2 ---
o Event Information:
   - Event Number:             0x113 /* 275 */
   - Event Name:               LOGIN_getinfo
   - Event Outcome:            success
o Server:                      /.:/hosts/dceos2.austin.ibm.com
o Client:                      Unknown client and cell uuids
o Number of groups:            0
o Authorization Status:        Authorized with a pac
o Date and Time recorded:      1995-10-10-10:58:00.530-05:00I-----
o 1 Event(s) specific:
   - item number 1             char string dce-rgy
--- End of Event record number 2 ---

[11/27/95 public]
minor corrections on spaces.

[01/19/96 public]
Diff file for the api_log testcase, aud_test_rpc_manager.c:

83d82
< #define END_OF_REC_STR               "End of Event record number"
113,114d111
< char *end_in_buff, *end_out_buff;
<
350,352c347
<     end_in_buff = strstr((char *)in_buff, END_OF_REC_STR);
<     end_out_buff = strstr((char *)out_buff, END_OF_REC_STR);
<     if (strncmp(end_in_buff, end_out_buff, 26) != 0) {
---
>     if (strcmp((char *)in_buff, (char *)out_buff) != 0) {
580,582c575
<     end_in_buff = strstr((char *)in_buff, END_OF_REC_STR);
<     end_out_buff = strstr((char *)out_buff, END_OF_REC_STR);
<     if (strncmp(end_in_buff, end_out_buff, 26) != 0) {
---
>     if (strcmp((char *)in_buff, (char *)out_buff) != 0) {
671,673c664
<     end_in_buff = strstr((char *)in_buff, END_OF_REC_STR);
<     end_out_buff = strstr((char *)out_buff, END_OF_REC_STR);
<     if (strncmp(end_in_buff, end_out_buff, 26) != 0) {
---
>     if (strcmp((char *)in_buff, (char *)out_buff) != 0) {
879,881c870
<     end_in_buff = strstr((char *)in_buff, END_OF_REC_STR);
<     end_out_buff = strstr((char *)out_buff, END_OF_REC_STR);
<     if (strncmp(end_in_buff, end_out_buff, 26) != 0) {
---
>     if (strcmp((char *)in_buff, (char *)out_buff) != 0) {
1046,1048c1035
<     end_in_buff = strstr((char *)in_buff, END_OF_REC_STR);
<     end_out_buff = strstr((char *)out_buff, END_OF_REC_STR);
<     if (strncmp(end_in_buff, end_out_buff, 26) != 0) {
---
>     if (strcmp((char *)in_buff, (char *)out_buff) != 0) {
1144,1146c1131
<     end_in_buff = strstr((char *)in_buff, END_OF_REC_STR);
<     end_out_buff = strstr((char *)out_buff, END_OF_REC_STR);
<     if (strncmp(end_in_buff, end_out_buff, 26) != 0) {
---
>     if (strcmp((char *)in_buff, (char *)out_buff) != 0) {
1249,1251c1234
<     end_in_buff = strstr((char *)in_buff, END_OF_REC_STR);
<     end_out_buff = strstr((char *)out_buff, END_OF_REC_STR);
<     if (strncmp(end_in_buff, end_out_buff, 26) != 0) {
---
>     if (strcmp((char *)in_buff, (char *)out_buff) != 0) {
1354,1356c1337
<     end_in_buff = strstr((char *)in_buff, END_OF_REC_STR);
<     end_out_buff = strstr((char *)out_buff, END_OF_REC_STR);
<     if (strncmp(end_in_buff, end_out_buff, 26) != 0) {
---
>     if (strcmp((char *)in_buff, (char *)out_buff) != 0) {
1458,1460c1439
<     end_in_buff = strstr((char *)in_buff, END_OF_REC_STR);
<     end_out_buff = strstr((char *)out_buff, END_OF_REC_STR);
<     if (strncmp(end_in_buff, end_out_buff, 26) != 0) {
---
>     if (strcmp((char *)in_buff, (char *)out_buff) != 0) {
1866,1868c1845
<     end_in_buff = strstr((char *)in_buff, END_OF_REC_STR);
<     end_out_buff = strstr((char *)out_buff, END_OF_REC_STR);
<     if (strncmp(end_in_buff, end_out_buff, 26) != 0) {
---
>     if (strcmp((char *)in_buff, (char *)out_buff) != 0) {
1971,1973c1948
<     end_in_buff = strstr((char *)in_buff, END_OF_REC_STR);
<     end_out_buff = strstr((char *)out_buff, END_OF_REC_STR);
<     if (strncmp(end_in_buff, end_out_buff, 26) != 0) {
---
>     if (strcmp((char *)in_buff, (char *)out_buff) != 0) {

[public]
Minor changes on the formatting.

[7/18/96 public]
Fixed in DCE1.2.2 (BL03).



CR Number                     : 13191
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : "diff" Server field should not be NULL
Reported Date                 : 11/9/95
Found in Baseline             : 1.1
Found Date                    : 11/9/95
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : evt_read.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/9/95 public]
As requested from HP, the Server field of the audit record should
be filled with the hostname where auditd is running. I will supply
the fix later today.

[11/09/95 public]
Fixed.  The diff file and the new version of evt_read.c are also
found in /afs/dce.osf.org/project/dce/ibm/audit.  Please include
this fix in the DCE1.2.1.

1) diff file for evt_read.c:

100a101
> static char    *host = NULL;
581a583
>     error_status_t  stp;
660a663,665
>     /* get the hostname of the auditd */
>     if (host == NULL)
>         dce_cf_get_host_name(&host, &stp);
676c681,684
<            sprintf(strbuf+index, "Server: NULL\n");
---
>            if (host == NULL)
>                sprintf(strbuf+index, "Server: NULL\n");
>            else
>                sprintf(strbuf+index, "Server: /.:/%s\n", host);

[7/18/96 public]
Fixed in DCE1.2.2 (BL03).
~



CR Number                     : 13186
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : secd deadlocks when auditing alarm events
Reported Date                 : 11/1/95
Found in Baseline             : 1.1wp
Found Date                    : 11/1/95
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : secd
Sensitivity                   : public

[11/1/95 public]

It was discovered that if certain audit events in secd had a filter that
specified an alarm action, secd would deadlock (out of call executor
threads) because the audit library would call back into secd to do security
service name resolution.

This fix _requires_ the new bypass routines for the sec_id calls supplied
with DCE1.2.1. 

HP has chased multiple instances where security calls in libaudit calling
back into secd would cause secd crashes or hangs. In order to remove these
problems with confidence, the following changes were implemented.

Remove the unnecessary name cache work inside of libaudit.

Remove a few bogus auditing points in the security server.

Make secd call the new bypass registration routines.

This OT references all the changes that HP did to audit. We are looking for
component owner approval before submitting to 1.2.1.

Included here are the diffs for all the files involved:

src/security/audit/libaudit/aud.sams
src/security/audit/libaudit/evt_read.c
src/security/audit/libaudit/evt_write.c
src/security/audit/libaudit/trl_ops.c
src/security/server/rs/rs_secidmap.c
src/security/server/rs/rs_main.c
src/security/client/rca/secidmap.c

*** aud.sams@@/main/HPDCE02/LATEST      Wed Jul 26 14:24:05 1995
--- aud.sams    Thu Sep 21 16:16:18 1995
***************
*** 1405,1410 ****
--- 1405,1421 ----
                   are not any filesystem problems."
  end
  
+ start
+ code            aud_s_got_server_uuid
+ sub-component   aud_s_evt
+ attributes    "svc_c_sev_error"
+ text          "dce_aud_print received a server UUID. This was not expected. UUID is %s"
+ explanation   "The dce_aud_print routine received a server UUID. This was not
+                  expected. The routine is expecting to always receive a NULL server
+                  UUID."
+ action                "Contact your DCE supplier."
+ end
+ 
  
  
  ## Messages for serviceability table




*** evt_read.c@@/main/HPDCE02/LATEST	Fri Jul 14 14:42:53 1995
--- evt_read.c	Fri Sep 22 10:20:13 1995
***************
*** 9,14 ****
--- 9,25 ----
  /*
   * HISTORY
   * $Log:	c013186,v $
# Revision 1.3  95/12/13  14:26:42  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company   new/changed/deleted note(s) [white_r 12/13/95 ]
# 
# Revision 1.2  95/11/03  17:04:14  root
# changed fields:  new/changed/deleted note(s) [trant 11/02/95 public]
# 
# Revision 1.1  95/11/01  11:32:09  root
# new CR
# 
+  * Revision /main/HPDCE02/sommerfeld_dfsperf/3  1995/09/22  14:20 UTC  jrr
+  * 	Recode the client_id loop correctly.
+  * 
+  * Revision /main/HPDCE02/sommerfeld_dfsperf/2  1995/09/20  21:18 UTC  sommerfeld
+  * 	Eliminate local cache.
+  * 
+  * Revision /main/HPDCE02/sommerfeld_dfsperf/1  1995/09/19  22:40 UTC  sommerfeld
+  * 	For John Rousseau: avoid explicit binds to rgy.
+  * 	clean up all compiler warnings.
+  * 	fix some indentation.
+  * 
   * Revision /main/HPDCE02/2  1995/07/14  18:42 UTC  jrr
   * 	Change dce_printf() to dce_svc_printf().
   * 	[1995/07/14  18:38 UTC  jrr  /main/HPDCE02/jrr_mothra_pure/1]
***************
*** 100,114 ****
  #include <evtp.h>
  #include <audit_alloc.h>
  
- uuid_t          own_principal_uuid;
- sec_rgy_name_t  own_global_princ_name;
- own_id_t        own_primary_group_id = {(own_id_t *) NULL}; 
- unsigned16      own_num_of_groups;
- uuid_t          own_cell_uuid;
- boolean32       own_id_initialized = FALSE;
- int             refresh_counter = 0;
- 
- 
  void
                  dce_aud_next
                  (
--- 111,116 ----
***************
*** 119,125 ****
  		                 unsigned32 * status
  ) {
      idl_es_handle_t h;
!     int             i, j;
      idl_byte       *ep;
      idl_ulong_int   esize;
      aud_esl_act_t actions;
--- 121,127 ----
  		                 unsigned32 * status
  ) {
      idl_es_handle_t h;
!     unsigned32	i, j;
      idl_byte       *ep;
      idl_ulong_int   esize;
      aud_esl_act_t actions;
***************
*** 267,273 ****
  	dce_aud_discard(*ard, status);
      };
      /* The trail might have been wrapped around. */
!     while (1) {
  	if (fread((void *)&rec_start_pos, sizeof(idl_byte), 
  		  sizeof(rec_start_pos), at->md_index_fp)
  	    != sizeof(rec_start_pos))
--- 269,275 ----
  	dce_aud_discard(*ard, status);
      };
      /* The trail might have been wrapped around. */
!     for (;;) {
  	if (fread((void *)&rec_start_pos, sizeof(idl_byte), 
  		  sizeof(rec_start_pos), at->md_index_fp)
  	    != sizeof(rec_start_pos))
***************
*** 549,589 ****
      if (ard == NULL) {
  	*status = aud_s_invalid_record_descriptor;
  	dce_svc_printf(AUD_S_INVALID_RECORD_DESCRIPTOR_MSG);
! 	return;
      }
  
      idl_es_encode_dyn_buffer(&ep, &esize, &h, status);
!     if (BAD_STATUS(status)) return;
  
      AUD_SET_ALLOC_FREE(enabled_allocator);
      audit_pickle_dencode_ev_info(h, &ard->header, &ard->tail, status);
      AUD_RESET_ALLOC_FREE(enabled_allocator, ep);
  
!     if (BAD_STATUS(status)) return;
  
      idl_es_handle_free(&h, status);
!     if (BAD_STATUS(status)) return;
  
      return (esize);
  }
  
  
! void
!                 dce_aud_print
!                 (
! 		                 dce_aud_rec_t ard,
! 		                 unsigned32 flags,
! 		                 unsigned_char_t **buffer,
! 		                 unsigned32 * status
! ) {
!     dce_aud_hdr_t   header;
      aud_log_ev_info_list_t *tail;
!     int             i,j;
!     client_id_t     id;
      int             id_count;
      unsigned_char_t *sp;
      char            buf[100];
-     sec_rgy_handle_t rgy_context;
      sec_rgy_name_t  subject_name;
      boolean32       output_uuids = TRUE;
      char            *strbuf;
--- 551,589 ----
      if (ard == NULL) {
  	*status = aud_s_invalid_record_descriptor;
  	dce_svc_printf(AUD_S_INVALID_RECORD_DESCRIPTOR_MSG);
! 	return 0;
      }
  
      idl_es_encode_dyn_buffer(&ep, &esize, &h, status);
!     if (BAD_STATUS(status)) return 0;
  
      AUD_SET_ALLOC_FREE(enabled_allocator);
      audit_pickle_dencode_ev_info(h, &ard->header, &ard->tail, status);
      AUD_RESET_ALLOC_FREE(enabled_allocator, ep);
  
!     if (BAD_STATUS(status)) return 0;
  
      idl_es_handle_free(&h, status);
!     if (BAD_STATUS(status)) return 0;
  
      return (esize);
  }
  
  
! void dce_aud_print (
!     dce_aud_rec_t ard,
!     unsigned32 flags,
!     unsigned_char_t **buffer,
!     unsigned32 * status
! )
! {
!     dce_aud_hdr_t   *header_p;
      aud_log_ev_info_list_t *tail;
!     unsigned32      i,j;
!     client_id_t     *id_p;
      int             id_count;
      unsigned_char_t *sp;
      char            buf[100];
      sec_rgy_name_t  subject_name;
      boolean32       output_uuids = TRUE;
      char            *strbuf;
***************
*** 591,597 ****
      sec_login_handle_t login_context;
      sec_login_net_info_t net_info;
      boolean32       found = FALSE;
-     own_id_t        *secondary_group_ptr, *temp_group_ptr;
  
      if (ard == NULL) {
  	*status = aud_s_invalid_record_descriptor; 
--- 591,596 ----
***************
*** 608,677 ****
      }
  
      if ((flags & aud_c_evt_raw_info) == 0) {
! 	sec_rgy_site_open(NULL, &rgy_context, status);
! 	if (GOOD_STATUS(status)) {
! 	    output_uuids = FALSE;
! 
!            if (refresh_counter > REFRESH_ID_LIMIT)
!            {   
!                own_id_initialized = FALSE;
!                refresh_counter = 0;
! 
!                secondary_group_ptr = own_primary_group_id.next;
! 
!                while (secondary_group_ptr != NULL)
!                {
!                   temp_group_ptr = secondary_group_ptr->next;
!                   free(secondary_group_ptr);
!                   secondary_group_ptr = temp_group_ptr;
!                }
!            }
! 
!            if (!own_id_initialized)
!            {
!               sec_login_get_current_context(&login_context, status);
!               if (*status != error_status_ok) return;
!               sec_login_inquire_net_info(login_context, &net_info, status);
!               if ((*status != error_status_ok) 
!                  && (*status != sec_login_s_not_certified)) return;
! 
!               own_cell_uuid = net_info.pac.realm.uuid;
! 
!               own_principal_uuid = net_info.pac.principal.uuid;
!               sec_id_gen_name(rgy_context, &own_cell_uuid, &own_principal_uuid, 	
!                               own_global_princ_name, NULL, NULL, status);
! 
!               own_primary_group_id.group_uuid = net_info.pac.group.uuid;
!               sec_id_gen_group(rgy_context, &own_cell_uuid, &own_primary_group_id.group_uui
d, 	
!                               own_primary_group_id.global_group_name, NULL, NULL, status);
!             
!               own_primary_group_id.next = NULL;
! 
!               own_num_of_groups = net_info.pac.num_groups;
!  
!               if (own_num_of_groups > 0)
!                   temp_group_ptr = &own_primary_group_id;
! 
!               for (i=0; i < own_num_of_groups; i++)
!               {
!                  secondary_group_ptr = (own_id_t *) malloc(sizeof(struct own_id)); 
!                  secondary_group_ptr->group_uuid = net_info.pac.groups[i].uuid;
!                  sec_id_gen_group(rgy_context, &own_cell_uuid,
!                                   &secondary_group_ptr->group_uuid,
!                          secondary_group_ptr->global_group_name, NULL, NULL, status);
!                  temp_group_ptr->next = secondary_group_ptr;
!                  secondary_group_ptr->next = NULL;
!                  temp_group_ptr = secondary_group_ptr;
!               } 
! 
!               own_id_initialized = TRUE;
!               sec_login_free_net_info(&net_info);
!            }
!               
!         }
      }
  
!     header = ard->header;
  
      /* AIX sprintf seems to have a bug.  It returns the starting address of
         the string, instead of the number of characters in the output string.
--- 607,616 ----
      }
  
      if ((flags & aud_c_evt_raw_info) == 0) {
! 	output_uuids = FALSE;
      }
  
!     header_p = &ard->header;
  
      /* AIX sprintf seems to have a bug.  It returns the starting address of
         the string, instead of the number of characters in the output string.
***************
*** 679,711 ****
       */
  
      sprintf(strbuf, "\n--- Dumping an event record --- ");
!     sprintf(strbuf+strlen(strbuf), "Event Number: %ld\n", header.event);
      index = strlen(strbuf);
  
      if (!output_uuids)
      {
!        if (uuid_is_nil(&header.server, status))
         {
             sprintf(strbuf+index, "Server: NULL\n");
         }
         else 
         {
!            sec_rgy_pgo_id_to_name(rgy_context, sec_rgy_domain_person,
!                                &header.server, subject_name, status);
! 
!            if (BAD_STATUS(status))
!            {
!                sprintf(strbuf+index, "Unknown server uuid \n");
!            }
!            else
!            {
!                sprintf(strbuf+index, "Server: %s\n", subject_name);
!            }
         }
      }
      else
      {
!         uuid_to_string(&header.server, &sp, status);
          sprintf(strbuf+index, "Server UUID: %s\n", sp);
          rpc_string_free(&sp, status);
      }
--- 618,643 ----
       */
  
      sprintf(strbuf, "\n--- Dumping an event record --- ");
!     sprintf(strbuf+strlen(strbuf), "Event Number: %ld\n", header_p->event);
      index = strlen(strbuf);
  
      if (!output_uuids)
      {
!        if (uuid_is_nil(&header_p->server, status))
         {
             sprintf(strbuf+index, "Server: NULL\n");
         }
         else 
         {
!            /* We should never get here! */
!            char *       suuid;
!            uuid_to_string(&header_p->server, &suuid, status);
!            dce_svc_printf(AUD_S_GOT_SERVER_UUID_MSG, suuid);
         }
      }
      else
      {
!         uuid_to_string(&header_p->server, &sp, status);
          sprintf(strbuf+index, "Server UUID: %s\n", sp);
          rpc_string_free(&sp, status);
      }
***************
*** 712,802 ****
  
      index = strlen(strbuf);
  
!     for (id_count = header.num_client_ids; id_count > 0; id_count--) {
! 	id = header.client_id[header.num_client_ids - id_count];
          if (!output_uuids) {
! 
!             refresh_counter++;
!    
!             if(uuid_equal(&id.client, &own_principal_uuid, status) &&
!                    uuid_equal(&id.cell, &own_cell_uuid, status))
!             {     
! 	       sprintf(strbuf+index, "Client: %s\n", own_global_princ_name);
              }
-             else
-             { 
- 	       sec_id_gen_name(rgy_context, &id.cell, &id.client, 
- 		        	subject_name, NULL, NULL, status);
- 	       if (BAD_STATUS(status)) {
- 	           sprintf(strbuf+index, "Unknown client and cell uuids \n");
- 	       } else {
- 	           sprintf(strbuf+index, "Client: %s\n", subject_name);
- 	       }
-             }
          } else {
! 	    uuid_to_string(&id.client, &sp, status);
  	    sprintf(strbuf+index, "Client UUID: %s\n", sp);
  	    rpc_string_free(&sp, status);
! 	    uuid_to_string(&id.cell, &sp, status);
              index = strlen(strbuf);
  	    sprintf(strbuf+index, "Cell UUID: %s\n", sp);
  	    rpc_string_free(&sp, status);
          }
          index = strlen(strbuf);
!         if (!((id.num_groups == 1) && (uuid_is_nil(&id.groups[0], status))))
          {
  
             if ((flags & aud_c_evt_groups_info) != 0) {
  	       sprintf(strbuf+index, "Number of groups: %ld\n", 
! 		       id.num_groups);
             }
!            if (id.num_groups != 0 && (flags & aud_c_evt_groups_info) != 0) {
  	       if (output_uuids) {
! 	           for (i = 0; i < id.num_groups; i++) {
! 		       uuid_to_string(&id.groups[i], &sp, status);
                         index = strlen(strbuf);
  	               sprintf(strbuf+index, "Group UUID: %s\n", sp);
  		       rpc_string_free(&sp, status);
  	           }
  	       } else {
! 	           for (i = 0; i < id.num_groups; i++) {
                         found = FALSE;
                         index = strlen(strbuf);
!                        if(uuid_equal(&id.groups[i], &own_primary_group_id.group_uuid, statu
s) &&
!                                              uuid_equal(&id.cell, &own_cell_uuid, status))
!                        {     
! 		          sprintf(strbuf+index, "Group %ld: %s\n", i,
!                                    own_primary_group_id.global_group_name);
!                           found = TRUE;
                         }
-                        else
-                        {
-                          j = 0;
-                          secondary_group_ptr = own_primary_group_id.next;
-  
- 	                 while ((secondary_group_ptr != NULL) && (j < own_num_of_groups) && (
!found))
-                          {
-                            if(uuid_equal(&id.groups[i], &secondary_group_ptr->group_uuid, s
tatus) &&
-                                          uuid_equal(&id.cell, &own_cell_uuid, status))
-                            {     
- 		              sprintf(strbuf+index, "Group %ld: %s\n", i,
-                                        secondary_group_ptr->global_group_name);
-                               found = TRUE;
-                            }
-                            j++;
-                            secondary_group_ptr = secondary_group_ptr->next;
-                          }
-                          if (!found)
-                          {
- 	                    sec_id_gen_group(rgy_context, &id.cell, &id.groups[i],
-                                              subject_name, NULL, NULL, status);
-                             if (BAD_STATUS(status)) {
- 		                sprintf(strbuf+index, "Unknown group uuid \n");
- 		            } else {
- 		                sprintf(strbuf+index, "Group %ld: %s\n", i, subject_name);
- 		            }
-                          }
- 		       }
  	           }
  	       }
             }
--- 644,695 ----
  
      index = strlen(strbuf);
  
!     for (id_count = 0; id_count < header_p->num_client_ids; id_count++) {
! 	id_p = &(header_p->client_id[id_count]);
          if (!output_uuids) {
!             sec_id_gen_name(NULL, &id_p->cell, &id_p->client, 
!                             subject_name, NULL, NULL, status);
!             if (BAD_STATUS(status)) {
!                 sprintf(strbuf+index, "Unknown client and cell uuids \n");
!             } else {
!                 sprintf(strbuf+index, "Client: %s\n", subject_name);
              }
          } else {
! 	    uuid_to_string(&id_p->client, &sp, status);
  	    sprintf(strbuf+index, "Client UUID: %s\n", sp);
  	    rpc_string_free(&sp, status);
! 	    uuid_to_string(&id_p->cell, &sp, status);
              index = strlen(strbuf);
  	    sprintf(strbuf+index, "Cell UUID: %s\n", sp);
  	    rpc_string_free(&sp, status);
          }
          index = strlen(strbuf);
!         if (!((id_p->num_groups == 1) && (uuid_is_nil(&id_p->groups[0], status))))
          {
  
             if ((flags & aud_c_evt_groups_info) != 0) {
  	       sprintf(strbuf+index, "Number of groups: %ld\n", 
! 		       id_p->num_groups);
             }
!            if (id_p->num_groups != 0 && (flags & aud_c_evt_groups_info) != 0) {
  	       if (output_uuids) {
! 	           for (i = 0; i < id_p->num_groups; i++) {
! 		       uuid_to_string(&id_p->groups[i], &sp, status);
                         index = strlen(strbuf);
  	               sprintf(strbuf+index, "Group UUID: %s\n", sp);
  		       rpc_string_free(&sp, status);
  	           }
  	       } else {
! 	           for (i = 0; i < id_p->num_groups; i++) {
                         found = FALSE;
                         index = strlen(strbuf);
!                        sec_id_gen_group(NULL, &id_p->cell, &id_p->groups[i],
!                                         subject_name, NULL, NULL, status);
!                        if (BAD_STATUS(status)) {
!                            sprintf(strbuf+index, "Unknown group uuid \n");
!                        } else {
!                            sprintf(strbuf+index, "Group %ld: %s\n", i, subject_name);
                         }
  	           }
  	       }
             }
***************
*** 814,820 ****
      index = strlen(strbuf);
      sprintf(strbuf+index, "Event Outcome: ");
      for (i = 0; i < MAX_CONDITIONS - 1; i++) {
! 	if ((audit_condition[i].number & header.outcome) != 0) {
              index = strlen(strbuf);
  	    sprintf(strbuf+index, "%s ", audit_condition[i].name);
  	}
--- 707,713 ----
      index = strlen(strbuf);
      sprintf(strbuf+index, "Event Outcome: ");
      for (i = 0; i < MAX_CONDITIONS - 1; i++) {
! 	if ((audit_condition[i].number & header_p->outcome) != 0) {
              index = strlen(strbuf);
  	    sprintf(strbuf+index, "%s ", audit_condition[i].name);
  	}
***************
*** 824,840 ****
      index = strlen(strbuf);
      sprintf(strbuf+index, "Authorization Status: ");
      index = strlen(strbuf);
!     if (header.authz_st == rpc_c_authz_name) {
  	sprintf(strbuf+index, "Authorized with a name\n");
!     } else if (header.authz_st == rpc_c_authz_dce) {
  	sprintf(strbuf+index, "Authorized with a pac\n");
      }
!     utc_asclocaltime(buf, 100, &header.time);
      index = strlen(strbuf);
      sprintf(strbuf+index, "Local Time: %s\n", buf);
      index = strlen(strbuf);
!     if (header.addr != NULL && (flags & aud_c_evt_address_info) != 0) {
! 	sprintf(strbuf+index, "Client Address: %s\n", header.addr);
      }
      index = strlen(strbuf);
      if (ard->tail != NULL && (flags & aud_c_evt_specific_info) != 0) {
--- 717,733 ----
      index = strlen(strbuf);
      sprintf(strbuf+index, "Authorization Status: ");
      index = strlen(strbuf);
!     if (header_p->authz_st == rpc_c_authz_name) {
  	sprintf(strbuf+index, "Authorized with a name\n");
!     } else if (header_p->authz_st == rpc_c_authz_dce) {
  	sprintf(strbuf+index, "Authorized with a pac\n");
      }
!     utc_asclocaltime(buf, 100, &header_p->time);
      index = strlen(strbuf);
      sprintf(strbuf+index, "Local Time: %s\n", buf);
      index = strlen(strbuf);
!     if (header_p->addr != NULL && (flags & aud_c_evt_address_info) != 0) {
! 	sprintf(strbuf+index, "Client Address: %s\n", header_p->addr);
      }
      index = strlen(strbuf);
      if (ard->tail != NULL && (flags & aud_c_evt_specific_info) != 0) {
***************
*** 939,948 ****
      }
      memcpy((char *)*buffer, strbuf, strlen(strbuf)+1);
      free(strbuf);
-     if (!output_uuids) {
- 	sec_rgy_site_close(rgy_context, status);
-     }
      *status = aud_s_ok;
      return;
  }
- 
--- 832,837 ----




*** evt_write.c@@/main/HPDCE02/LATEST	Thu Jun  8 19:21:54 1995
--- evt_write.c	Wed Sep 20 17:18:38 1995
***************
*** 9,14 ****
--- 9,24 ----
  /*
   * HISTORY
   * $Log:	c013186,v $
# Revision 1.3  95/12/13  14:26:42  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company   new/changed/deleted note(s) [white_r 12/13/95 ]
# 
# Revision 1.2  95/11/03  17:04:14  root
# changed fields:  new/changed/deleted note(s) [trant 11/02/95 public]
# 
# Revision 1.1  95/11/01  11:32:09  root
# new CR
# 
+  * Revision /main/HPDCE02/sommerfeld_dfsperf/3  1995/09/20  21:18 UTC  sommerfeld
+  * 	clean up compiler warnings.
+  * 	delete unused local variable.
+  * 
+  * Revision /main/HPDCE02/sommerfeld_dfsperf/2  1995/08/31  05:59 UTC  sommerfeld
+  * 	Rename functions.
+  * 
+  * Revision /main/HPDCE02/sommerfeld_dfsperf/1  1995/08/14  15:24 UTC  sommerfeld
+  * 	Performance: let secidmap do the rca_site_bind iff needed.
+  * 
   * Revision /main/HPDCE02/1  1995/06/08  23:21 UTC  jrr
   * 	Fix memory leak by using correct alloc/free for IDL es.
   * 	[1995/06/08  23:21 UTC  jrr  /main/jrr_sec_chfts15431/1]
***************
*** 122,128 ****
  #include <audit_alloc.h>
  #include <dce/sec_cred.h>
  
! aud__evt_add_id_to_header
  (
  sec_id_pac_t 	*pac,
  unsigned32	options,
--- 132,138 ----
  #include <audit_alloc.h>
  #include <dce/sec_cred.h>
  
! void aud__evt_add_id_to_header
  (
  sec_id_pac_t 	*pac,
  unsigned32	options,
***************
*** 131,137 ****
  {
      client_id_t *cidp;
      int		id_count;
!     int		i;
  
      id_count = ardp->header.num_client_ids + 1;
      cidp = (client_id_t *) malloc(sizeof(client_id_t) * id_count);
--- 141,147 ----
  {
      client_id_t *cidp;
      int		id_count;
!     int 	i;
  
      id_count = ardp->header.num_client_ids + 1;
      cidp = (client_id_t *) malloc(sizeof(client_id_t) * id_count);
***************
*** 267,273 ****
      /* store the delegation chain in the header */
      sec_login_cred_init_cursor(&cursor, stp);
   
!     while (1) {
  	pah = sec_cred_get_delegate(callers_identity, &cursor, stp);
  	if (*stp == sec_cred_s_no_more_entries) {
  	    *stp = aud_s_ok;
--- 277,283 ----
      /* store the delegation chain in the header */
      sec_login_cred_init_cursor(&cursor, stp);
   
!     for(;;) {
  	pah = sec_cred_get_delegate(callers_identity, &cursor, stp);
  	if (*stp == sec_cred_s_no_more_entries) {
  	    *stp = aud_s_ok;
***************
*** 362,368 ****
  
      if (outcome == 0)
      {
!        outcome = 0xFFFFFFFF;
      }
  
  
--- 372,378 ----
  
      if (outcome == 0)
      {
!        outcome--;
      }
  
  
***************
*** 422,428 ****
  		                 dce_aud_rec_t * ard,
  		                 unsigned32 * status
  ) {
-     sec_rgy_handle_t rgy_context;
      sec_rgy_name_t  princ_name, cell_name;
      uuid_t          princ_uuid, cell_uuid;
      sec_id_pac_t   *pac;
--- 432,437 ----
***************
*** 435,449 ****
  	return;
      }
  
!     sec_rgy_site_open(NULL, &rgy_context, status);
      if (BAD_STATUS(status)) {
  	return;
      }
-     sec_id_parse_name(rgy_context, client, cell_name, &cell_uuid, princ_name,
- 		      &princ_uuid, status);
-     if (BAD_STATUS(status)) {
- 	return;
-     }
      pac = (sec_id_pac_t *) malloc(sizeof(sec_id_pac_t));
      pac->principal.uuid = princ_uuid;
      pac->realm.uuid = cell_uuid;
--- 444,454 ----
  	return;
      }
  
!     sec_id_global_parse_name(NULL, client, cell_name, &cell_uuid, princ_name,
! 		       &princ_uuid, status);
      if (BAD_STATUS(status)) {
  	return;
      }
      pac = (sec_id_pac_t *) malloc(sizeof(sec_id_pac_t));
      pac->principal.uuid = princ_uuid;
      pac->realm.uuid = cell_uuid;
***************
*** 657,663 ****
      aud_esl_act_t actions = aud_c_esl_act_none;
      aud_log_ev_info_list_t *tail_list;
      aud_log_ev_info_list_t *retrieved_ev_info;
-     dce_aud_hdr_t   retrieved_header;
      unsigned_char_t * alarm_message;
      unsigned32 enabled_allocator;
      unsigned32 st;
--- 662,667 ----




*** trl_ops.c@@/main/HPDCE02/LATEST	Fri Aug 18 15:53:34 1995
--- trl_ops.c	Fri Sep 22 10:53:40 1995
***************
*** 131,138 ****
  #include <dceaudmac.h>
  #include <dceaudsvc.h>
  
- extern own_id_t own_primary_group_id;
- 
  boolean32 aud_g_cli_audit_on = TRUE;
  boolean32 aud_g_cli_filter_on = FALSE;
  aud_esl_guides_p_t aud_g_cli_world_guides = NULL;
--- 131,136 ----
***************
*** 220,227 ****
      *stp = aud_s_ok;
      *at  = NULL;
  
-     own_primary_group_id.next = NULL;
- 
      if ((flags == 0)
               ||
         (((flags & aud_c_trl_open_read) != 0) && ((flags & aud_c_trl_open_write) != 0)))
--- 218,223 ----
***************
*** 421,435 ****
  }
  
  
! void
!                 dce_aud_close
!                 (
! 		                 dce_aud_trail_t at,
! 		                 unsigned32 * status
  ) {
  
-     own_id_t        *secondary_group_ptr, *temp_group_ptr;
- 
      *status = aud_s_ok;
  
      if (
--- 417,427 ----
  }
  
  
! void dce_aud_close(
!     dce_aud_trail_t at,
!     unsigned32 * status
  ) {
  
      *status = aud_s_ok;
  
      if (
***************
*** 462,476 ****
      unregister_update_interface(status);
      if ( *status != aud_s_ok)
        *status = aud_s_ok;
- 
-     secondary_group_ptr = own_primary_group_id.next;
- 
-     while (secondary_group_ptr != NULL)
-     {
-        temp_group_ptr = secondary_group_ptr->next;
-        free(secondary_group_ptr);
-        secondary_group_ptr = temp_group_ptr;
-     }
  }
  
  
--- 454,459 ----



*** rs_secidmap.c@@/main/HPDCE02/LATEST	Thu Dec  8 12:36:57 1994
--- rs_secidmap.c	Fri Sep 15 12:00:46 1995
***************
*** 8,13 ****
--- 8,17 ----
  /*
   * HISTORY
   * $Log:	c013186,v $
# Revision 1.3  95/12/13  14:26:42  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company   new/changed/deleted note(s) [white_r 12/13/95 ]
# 
# Revision 1.2  95/11/03  17:04:14  root
# changed fields:  new/changed/deleted note(s) [trant 11/02/95 public]
# 
# Revision 1.1  95/11/01  11:32:09  root
# new CR
# 
+  * Revision /main/HPDCE02/sommerfeld_dfsperf/1  1995/09/15  16:00 UTC  sommerfeld
+  * 	flush *BOGUS* audit point.
+  * 	add loopback hook.
+  * 
   * Revision /main/HPDCE02/3  1994/12/08  17:37 UTC  mdf
   * 	
   * 
***************
*** 109,115 ****
  
  #ifdef MODULE_VERSION_ID
  static char *VersionID = 
!     "$Id: c013186,v 1.3 95/12/13 14:26:42 root Exp $";
  #endif
  
  #include <rs_secidmap.h>
--- 113,119 ----
  
  #ifdef MODULE_VERSION_ID
  static char *VersionID = 
!     "$Id: rs_secidmap.c,v /main/HPDCE02/sommerfeld_dfsperf/1 1995/09/15 16:00 UTC sommerfel
d Exp $";
  #endif
  
  #include <rs_secidmap.h>
***************
*** 391,401 ****
      sec_rgy_foreign_id_t    client_ids;                   
      error_status_t          tmp_status;
      uuid_t                  *mgr_type;
- #if defined(DCE_AUD_POINTS)
-     dce_aud_rec_t           ard;
-     dce_aud_ev_info_t       ev_info;
-     error_status_t          aud_status;
- #endif	/* defined(DCE_AUD_POINTS) */
  
      CLEAR_STATUS(status);
      /*
--- 395,400 ----
***************
*** 414,429 ****
          return;
      }
  
- #if defined(DCE_AUD_POINTS)
-     dce_aud_start(SECID_ParseName, h, 0, aud_c_esl_cond_unknown, 
-                   &ard, &aud_status);
-     if (ard) {
-         ev_info.format = aud_c_evt_info_char_string;
-         ev_info.data.char_string = global_namep;
-         dce_aud_put_ev_info(ard, ev_info, &aud_status);
-     }
- #endif	/* defined(DCE_AUD_POINTS) */
- 
      mgr_type = &(rsdb_acl_mgr_uuids[GET_MGR_BY_DOMAIN(domain)]);
  
      BEGIN_READ(lock_db, status) {
--- 413,418 ----
***************
*** 461,483 ****
  
      } END_READ
  
- #if defined(DCE_AUD_POINTS)
-     if (ard) {    
-         if (GOOD_STATUS(status)) {
-             dce_aud_commit(sec_aud_trail, ard, aud_c_evt_commit_sync_no_wait, 1, 
-                            aud_c_esl_cond_success, &aud_status); 
-         } else {  
-             if (rs_util_status_is_denial(*status)) {
-                 dce_aud_commit(sec_aud_trail, ard, aud_c_evt_commit_sync_no_wait, 1, 
-                                aud_c_esl_cond_denial, &aud_status);
-             } else {
-                 dce_aud_commit(sec_aud_trail, ard, aud_c_evt_commit_sync_no_wait, 1, 
-                                aud_c_esl_cond_failure, &aud_status);
-             } 
-         }
-     }
- #endif	/* defined(DCE_AUD_POINTS) */
- 
  }
  
  
--- 450,455 ----
***************
*** 624,634 ****
      sec_rgy_foreign_id_t    client_ids;                   
      error_status_t          tmp_status;
      uuid_t                  *mgr_type;
- #if defined(DCE_AUD_POINTS)
-     dce_aud_rec_t           ard;
-     dce_aud_ev_info_t       ev_info;
-     error_status_t          aud_status;
- #endif	/* defined(DCE_AUD_POINTS) */
  
      CLEAR_STATUS(status);
      memset (global_namep, 0, sizeof(sec_rgy_name_t));
--- 596,601 ----
***************
*** 641,652 ****
      }
  
  
- #if defined(DCE_AUD_POINTS)
-     dce_aud_start(SECID_GenName, h, 0, aud_c_esl_cond_unknown, 
-                   &ard, &aud_status);
-     /* Defer put until after the global name is generated. */
- #endif	/* defined(DCE_AUD_POINTS) */
- 
      mgr_type = &(rsdb_acl_mgr_uuids[GET_MGR_BY_DOMAIN(domain)]);
  
      BEGIN_READ(lock_db, status) {
--- 608,613 ----
***************
*** 682,708 ****
  
      } END_READ
  
- #if defined(DCE_AUD_POINTS)
-       if (ard) {
-         ev_info.format = aud_c_evt_info_char_string;
-         ev_info.data.char_string = global_namep;
-         dce_aud_put_ev_info(ard, ev_info, &aud_status);
- 
-         if (GOOD_STATUS(status)) {
-             dce_aud_commit(sec_aud_trail, ard, aud_c_evt_commit_sync_no_wait, 1, 
-                            aud_c_esl_cond_success, &aud_status); 
-         } else {  
-             if (rs_util_status_is_denial(*status)) {
-                 dce_aud_commit(sec_aud_trail, ard, aud_c_evt_commit_sync_no_wait, 1, 
-                                aud_c_esl_cond_denial, &aud_status);
-             } else {
-                 dce_aud_commit(sec_aud_trail, ard, aud_c_evt_commit_sync_no_wait, 1, 
-                                aud_c_esl_cond_failure, &aud_status);
-             } 
-         }
-     }
- #endif	/* defined(DCE_AUD_POINTS) */
- 
  }
  
  
--- 643,648 ----
***************
*** 717,719 ****
--- 657,736 ----
      /* do nothing */
  }    
      
+ /*
+  * parse bypass. !!! cut/paste shared with secidmap.c for now..
+  */
+ typedef void (*sec_id_parse_bypass_fn_t)(
+     sec_rgy_domain_t            domain,
+     sec_rgy_name_t              global_namep,
+     rsec_id_output_selector_t   selector,
+     sec_rgy_name_t              cell_namep,
+     uuid_t                      *cell_idp,
+     sec_rgy_name_t              princ_namep,
+     uuid_t                      *princ_idp,
+     error_status_t              *status
+ );
+ 
+ typedef void (*sec_id_gen_bypass_fn_t)(
+     sec_rgy_domain_t            domain,
+     uuid_t                      *cell_idp,
+     uuid_t                      *princ_idp,
+     rsec_id_output_selector_t   selector,
+     sec_rgy_name_t              global_namep,
+     sec_rgy_name_t              cell_namep,
+     sec_rgy_name_t              princ_namep,
+     error_status_t              *status
+ );
+ 
+ 
+ void sec_id_bypass (unsigned char *cell_name,
+     sec_id_parse_bypass_fn_t parse,
+     sec_id_gen_bypass_fn_t gen);
+ 
+ void rs_sec_id_bypass_parse_name(
+     sec_rgy_domain_t            domain,
+     sec_rgy_name_t              global_namep,
+     rsec_id_output_selector_t   selector,
+     sec_rgy_name_t              cell_namep,
+     uuid_t                      *cell_idp,
+     sec_rgy_name_t              princ_namep,
+     uuid_t                      *princ_idp,
+     error_status_t              *status
+ )
+ {
+     BEGIN_READ(lock_db, status) {
+         rs_sec_id_parse_name(domain, global_namep, selector,
+                      [trant 11/02/95 public]
John, Thanks for the fixes.  I have reviewed and like to have two
requests:
  1) in dce_aud_print(), I would like to change the following segment:
      /* We should never get here */
      char *    suuid;
      uuid_to_string(&header_p->server, &suuid, status);
      dce_svc_printf(AUD_S_GOT_SERVER_UUID_MSG, suuid);
to
      /* We should never get here */
      char *    suuid;
      uuid_to_string(&header_p->server, &suuid, status);
      sprintf(strbuf+index, "Server: %s\n", suuid);
      rpc_string_free(&suuid, status);

  2) in dce_aud_commit(), where you remove retrieved_header, also
     remove tail_list and retrieved_ev_info.  They are also not 
     used in this routine.

[12/13/95]
Fixed in DCE 1.2.1
Closed



CR Number                     : 13183
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : audit tests
Short Description             : audit tests fails in presence of replicated security
Reported Date                 : 10/31/95
Found in Baseline             : 1.1
Found Date                    : 10/31/95
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : security/audit/ts/{api_filter/startauditd,stopauditd},{cp_auditd/cp_auditd},{cp_filter/cp_filter},{ecfile_filter/startauditd,stopauditd}
Sensitivity                   : public

[10/31/95 public]

use rgy_edit option -update to do update with master wherever necessary....

*** /vob/dce.src.test/src/test/security/audit/ts/api_filter/startauditd@@/main/2        Thu Apr 28 14:33:37 1994
--- /vob/dce.src.test/src/test/security/audit/ts/api_filter/startauditd@@/main/HPDCE02/1        Tue Jun 27 17:20:34
1995
***************
*** 4,11 ****
  cellpw=-dce-

  #in order to run rgy_edit, there is need to dce_login as cell_admin
  print "add test principals, groups and accounts using rgy_edit\n"
!   dce_login cell_admin $cellpw -e rgy_edit <<EOF
  domain principal
  add aud_test_princ1
  add aud_test_princ2
--- 4,12 ----
  cellpw=-dce-

  #in order to run rgy_edit, there is need to dce_login as cell_admin
+ # use -up for rgy_edit to ensure master is updated.
  print "add test principals, groups and accounts using rgy_edit\n"
!   dce_login cell_admin $cellpw -e rgy_edit -up <<EOF
  domain principal
  add aud_test_princ1
  add aud_test_princ2
*** /vob/dce.src.test/src/test/security/audit/ts/api_filter/stopauditd@@/main/3 Thu Jun 23 16:48:42 1994
--- /vob/dce.src.test/src/test/security/audit/ts/api_filter/stopauditd@@/main/HPDCE02/1 Tue Jun 27 17:20:37 1995
***************
*** 4,11 ****
  cellpw=-dce-

  #in order to run rgy_edit, there is need to dce_login as cell_admin

!   dce_login cell_admin $cellpw -e rgy_edit <<EOF
  domain group
  del aud_test_group1
  del aud_test_group2
--- 4,12 ----
  cellpw=-dce-

  #in order to run rgy_edit, there is need to dce_login as cell_admin
+ # use -up for rgy_edit to ensure master is updated.

!   dce_login cell_admin $cellpw -e rgy_edit -up <<EOF
  domain group
  del aud_test_group1
  del aud_test_group2
*** /vob/dce.src.test/src/test/security/audit/ts/cp_auditd/cp_auditd@@/main/8   Tue Oct 25 16:57:26 1994
--- /vob/dce.src.test/src/test/security/audit/ts/cp_auditd/cp_auditd@@/main/HPDCE02/1   Tue Jun 27 17:19:10 1995
***************
*** 443,449 ****

  cellpw=-dce-

!   dce_login cell_admin $cellpw -e rgy_edit <<EOF
  domain principal
  add aud_test_princ1
  domain group
--- 443,450 ----

  cellpw=-dce-

! # use -up for rgy_edit to ensure master is updated.
!   dce_login cell_admin $cellpw -e rgy_edit -up <<EOF
  domain principal
  add aud_test_princ1
  domain group
***************
*** 510,516 ****
     print "\nOK: aud stop - failed"
   fi

!   dce_login cell_admin $cellpw -e rgy_edit <<EOF
  domain group
  del aud_test_group1
  domain principal
--- 511,518 ----
     print "\nOK: aud stop - failed"
   fi

! # use -up for rgy_edit to ensure master is updated.
!   dce_login cell_admin $cellpw -e rgy_edit -up <<EOF
  domain group
  del aud_test_group1
  domain principal
*** /vob/dce.src.test/src/test/security/audit/ts/cp_filter/cp_filter@@/main/10  Tue Oct 25 16:57:45 1994
--- /vob/dce.src.test/src/test/security/audit/ts/cp_filter/cp_filter@@/main/HPDCE02/1   Tue Jun 27 17:19:14 1995
***************
*** 33,40 ****
          fi

  #in order to run rgy_edit, there is need to dce_login as cell_admin

!   dce_login cell_admin $cellpw -e rgy_edit <<EOF
  domain principal
  add aud_test_princ1
  add aud_test_princ2
--- 33,41 ----
          fi

  #in order to run rgy_edit, there is need to dce_login as cell_admin
+ # use -up for rgy_edit to ensure master is updated.

!   dce_login cell_admin $cellpw -e rgy_edit -up <<EOF
  domain principal
  add aud_test_princ1
  add aud_test_princ2
***************
*** 1203,1210 ****
  cleanup() {

  #in order to run rgy_edit, there is need to dce_login as cell_admin

!   dce_login cell_admin $cellpw -e rgy_edit <<EOF
  domain group
  del aud_test_group1
  del aud_test_group2
--- 1204,1212 ----
  cleanup() {
  #in order to run rgy_edit, there is need to dce_login as cell_admin
+ # use -up for rgy_edit to ensure master is updated.

!   dce_login cell_admin $cellpw -e rgy_edit -up <<EOF
  domain group
  del aud_test_group1
  del aud_test_group2
*** /vob/dce.src.test/src/test/security/audit/ts/ecfile_filter/startauditd@@/main/3     Fri Jun 10 18:35:52 1994
--- /vob/dce.src.test/src/test/security/audit/ts/ecfile_filter/startauditd@@/main/HPDCE02/1     Tue Jun 27 17:19:48
1995
***************
*** 9,16 ****
  cellpw=-dce-

  #in order to run rgy_edit, there is need to dce_login as cell_admin
  print "add test principals, groups and accounts using rgy_edit\n"
!   dce_login cell_admin $cellpw -e rgy_edit <<EOF
  domain principal
  add aud_test_princ1
  domain group
--- 9,17 ----
  cellpw=-dce-

  #in order to run rgy_edit, there is need to dce_login as cell_admin
+ # use -up for rgy_edit to ensure master is updated.
  print "add test principals, groups and accounts using rgy_edit\n"
!   dce_login cell_admin $cellpw -e rgy_edit -up <<EOF
  domain principal
  add aud_test_princ1
  domain group
*** /vob/dce.src.test/src/test/security/audit/ts/ecfile_filter/stopauditd@@/main/5      Wed Jun 29 13:53:42 1994
--- /vob/dce.src.test/src/test/security/audit/ts/ecfile_filter/stopauditd@@/main/HPDCE02/1      Tue Jun 27 17:19:56
1995
***************
*** 17,24 ****


  #in order to run rgy_edit, there is need to dce_login as cell_admin
!
!   dce_login cell_admin $cellpw -e rgy_edit <<EOF
  domain group
  del aud_test_group1
  domain principal
--- 17,24 ----


  #in order to run rgy_edit, there is need to dce_login as cell_admin
! # use -up for rgy_edit to ensure master is updated.
!   dce_login cell_admin $cellpw -e rgy_edit -up <<EOF
  domain group
  del aud_test_group1
  domain principal

[11/01/95 public]
I would think this is a good testcase to test audit with and without 
security replication. I would like to have half of the testcase is 
added with -update or -up and leave the other half alone.  When 
security replica is not present, we expect all the testcases to pass.
When security replica is present, we expect half of them would fail.
However, these are good failures and we know why. How does it sound???

[11/2/95 public]
Tran, the fixes are for tests to gurantee success. While, it may be a
good idea to have some negative tests, I don't believe these were 
written for that purpose. Also by not specifying -update to rgy_edit does
not mean that it will always bind to a replica and so there may not be a
failure when it binds to master. Any way, at this time, I'd suggest we put
off splitting tests in such categories until someone (preferably component
owner) feels comfortable to add more tests.

[11/01/95 public]
ok, go for it, Parul.

[03/21/96 public]
Code included in the DCE 1.2.1 drop.  Closed with agreement of IBM.



CR Number                     : 13182
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 13119
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd tests
Short Description             : Changes in test associated with fix in OT13119
Reported Date                 : 10/31/95
Found in Baseline             : 1.1
Found Date                    : 10/31/95
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : security/audit/ts...api_filter/aud_testf_rpc_manager.c,aud_testf.c...api_log/aud_test.c,aud_test_rpc_manager.c...api_log_to_daemon/aud_testd.c,aud_testd_rpc_manager.c...ecfile_filter/aud_testec.c,aud_testec_rpc_manager.c
Sensitivity                   : public

[10/31/95 public]
These are the changes necessary to tests when fix for OT 13119 is made
as proposed in that OT under the tag "psn". These changes needs review
by IBM:

*** /vob/dce.src.test/src/test/security/audit/ts/api_filter/aud_testf_rpc_manager.c@@/main/4    Tue Oct  4 19:21:00
1994
--- /vob/dce.src.test/src/test/security/audit/ts/api_filter/aud_testf_rpc_manager.c@@/main/HPDCE02/2    Fri Aug 18 1
6:11:04 1995
***************
*** 8,13 ****
--- 8,25 ----
  /*
   * HISTORY
   * $Log:	c013182,v $
# Revision 1.4  96/03/21  11:25:59  root
# changed fields: Status  Fixed In Baseline   new/changed/deleted note(s) [white_r 03/21/96 public]
# 
# Revision 1.3  95/11/03  14:50:50  root
# changed fields:  new/changed/deleted note(s) [trant 11/02/95 public]
# 
# Revision 1.2  95/10/31  17:45:27  root
# changed fields: Affected File(s)  
# 
# Revision 1.1  95/10/31  17:23:07  root
# new CR
# 
+  * Revision /main/HPDCE02/2  1995/08/18  20:11 UTC  kline_s
+  *    Merge fix for CHFts16115
+  *
+  * Revision /main/kline_s_mothra/2  1995/08/17  21:32 UTC  kline_s
+  *    CHFts16115: Remove DES_HIDDEN conditional - only using integrity
+  *    protection level instead of using the privacy protection level
+  *    for Domestic.  Required to avoid conflicts due to singular
+  *    Domestic/Export release.
+  *
+  * Revision /main/kline_s_mothra/1  1995/07/06  19:45 UTC  kline_s
+  *    Enable tests to function properly using international (ie. non-DES) bits.
+  *
   * Revision 1.1.2.3  1994/10/04  21:23:38  weisz
   *    CR 12167: api_filter test suite fails.
   *    [1994/10/04  21:21:29  weisz]
***************
*** 93,99 ****
      rpc_binding_inq_auth_client(h, &privs, NULL, &authn_level,
                                &authn_svc, &authz_svc, stp);
      CHECK_STATUS("rpc_binding_inq_auth_client", stp);
!     if ((authn_level != rpc_c_protect_level_pkt_privacy) &&
            (authz_svc != rpc_c_authz_dce))
      {
         printf("wrong authn_level or wrong authz_svc, test failed\n");
--- 105,111 ----
      rpc_binding_inq_auth_client(h, &privs, NULL, &authn_level,
                                &authn_svc, &authz_svc, stp);
      CHECK_STATUS("rpc_binding_inq_auth_client", stp);
!     if ((authn_level != rpc_c_protect_level_pkt_integ) &&
            (authz_svc != rpc_c_authz_dce))
      {
         printf("wrong authn_level or wrong authz_svc, test failed\n");
***************
*** 182,188 ****
      rpc_binding_inq_auth_client(h, &privs, NULL, &authn_level,
                                &authn_svc, &authz_svc, stp);
      CHECK_STATUS("rpc_binding_inq_auth_client", stp);
!     if ((authn_level != rpc_c_protect_level_pkt_privacy) &&
            (authz_svc != rpc_c_authz_dce))
      {
        printf("wrong authn_level or wrong authz_svc, test failed, exiting\n");
--- 194,200 ----
      rpc_binding_inq_auth_client(h, &privs, NULL, &authn_level,
                                &authn_svc, &authz_svc, stp);
      CHECK_STATUS("rpc_binding_inq_auth_client", stp);
!     if ((authn_level != rpc_c_protect_level_pkt_integ) &&
            (authz_svc != rpc_c_authz_dce))
      {
        printf("wrong authn_level or wrong authz_svc, test failed, exiting\n");
***************
*** 269,275 ****
      rpc_binding_inq_auth_client(h, &privs, NULL, &authn_level,
                                &authn_svc, &authz_svc, stp);
      CHECK_STATUS("rpc_binding_inq_auth_client", stp);
!     if ((authn_level != rpc_c_protect_level_pkt_privacy) &&
            (authz_svc != rpc_c_authz_dce))
      {
        printf("wrong authn_level or wrong authz_svc, test failed, exiting\n");
--- 281,287 ----
      rpc_binding_inq_auth_client(h, &privs, NULL, &authn_level,
                                &authn_svc, &authz_svc, stp);
      CHECK_STATUS("rpc_binding_inq_auth_client", stp);
!     if ((authn_level != rpc_c_protect_level_pkt_integ) &&
            (authz_svc != rpc_c_authz_dce))
      {
        printf("wrong authn_level or wrong authz_svc, test failed, exiting\n");
***************
*** 355,361 ****
      rpc_binding_inq_auth_client(h, &privs, NULL, &authn_level,
                                &authn_svc, &authz_svc, stp);
      CHECK_STATUS("rpc_binding_inq_auth_client", stp);
!     if ((authn_level != rpc_c_protect_level_pkt_privacy) &&
            (authz_svc != rpc_c_authz_dce))
      {
        printf("wrong authn_level or wrong authz_svc, test failed, exiting\n");
--- 367,373 ----
      rpc_binding_inq_auth_client(h, &privs, NULL, &authn_level,
                                &authn_svc, &authz_svc, stp);
      CHECK_STATUS("rpc_binding_inq_auth_client", stp);
!     if ((authn_level != rpc_c_protect_level_pkt_integ) &&
            (authz_svc != rpc_c_authz_dce))
      {
        printf("wrong authn_level or wrong authz_svc, test failed, exiting\n");
***************
*** 441,447 ****
      rpc_binding_inq_auth_client(h, &privs, NULL, &authn_level,
                                &authn_svc, &authz_svc, stp);
      CHECK_STATUS("rpc_binding_inq_auth_client", stp);
!     if ((authn_level != rpc_c_protect_level_pkt_privacy) &&
            (authz_svc != rpc_c_authz_dce))
      {
        printf("wrong authn_level or wrong authz_svc, test failed, exiting\n");
--- 453,459 ----
      rpc_binding_inq_auth_client(h, &privs, NULL, &authn_level,
                                &authn_svc, &authz_svc, stp);
      CHECK_STATUS("rpc_binding_inq_auth_client", stp);
!     if ((authn_level != rpc_c_protect_level_pkt_integ) &&
            (authz_svc != rpc_c_authz_dce))
      {
        printf("wrong authn_level or wrong authz_svc, test failed, exiting\n");
***************
*** 527,533 ****
      rpc_binding_inq_auth_client(h, &privs, NULL, &authn_level,
                                &authn_svc, &authz_svc, stp);
      CHECK_STATUS("rpc_binding_inq_auth_client", stp);
!     if ((authn_level != rpc_c_protect_level_pkt_privacy) &&
            (authz_svc != rpc_c_authz_dce))
      {
        printf("wrong authn_level or wrong authz_svc, test failed, exiting\n");
--- 539,545 ----
      rpc_binding_inq_auth_client(h, &privs, NULL, &authn_level,
                                &authn_svc, &authz_svc, stp);
      CHECK_STATUS("rpc_binding_inq_auth_client", stp);
!     if ((authn_level != rpc_c_protect_level_pkt_integ) &&
            (authz_svc != rpc_c_authz_dce))
      {
        printf("wrong authn_level or wrong authz_svc, test failed, exiting\n");
***************
*** 613,619 ****
      rpc_binding_inq_auth_client(h, &privs, NULL, &authn_level,
                                &authn_svc, &authz_svc, stp);
      CHECK_STATUS("rpc_binding_inq_auth_client", stp);
!     if ((authn_level != rpc_c_protect_level_pkt_privacy) &&
            (authz_svc != rpc_c_authz_dce))
      {
        printf("wrong authn_level or wrong authz_svc, test failed, exiting\n");
--- 625,631 ----
      rpc_binding_inq_auth_client(h, &privs, NULL, &authn_level,
                                &authn_svc, &authz_svc, stp);
      CHECK_STATUS("rpc_binding_inq_auth_client", stp);
!     if ((authn_level != rpc_c_protect_level_pkt_integ) &&
            (authz_svc != rpc_c_authz_dce))
      {
        printf("wrong authn_level or wrong authz_svc, test failed, exiting\n");
***************
*** 703,709 ****
      rpc_binding_inq_auth_client(h, &privs, NULL, &authn_level,
                                &authn_svc, &authz_svc, stp);
      CHECK_STATUS("rpc_binding_inq_auth_client", stp);
!     if ((authn_level != rpc_c_protect_level_pkt_privacy) &&
            (authz_svc != rpc_c_authz_dce))
      {
         printf("wrong authn_level or wrong authz_svc, test failed\n");
--- 715,721 ----
      rpc_binding_inq_auth_client(h, &privs, NULL, &authn_level,
                                &authn_svc, &authz_svc, stp);
      CHECK_STATUS("rpc_binding_inq_auth_client", stp);
!     if ((authn_level != rpc_c_protect_level_pkt_integ) &&
            (authz_svc != rpc_c_authz_dce))
      {
         printf("wrong authn_level or wrong authz_svc, test failed\n");
***************
*** 798,804 ****
      rpc_binding_inq_auth_client(h, &privs, NULL, &authn_level,
                                &authn_svc, &authz_svc, stp);
      CHECK_STATUS("rpc_binding_inq_auth_client", stp);
!     if ((authn_level != rpc_c_protect_level_pkt_privacy) &&
            (authz_svc != rpc_c_authz_dce))
      {
         printf("wrong authn_level or wrong authz_svc, test failed\n");
--- 810,816 ----
      rpc_binding_inq_auth_client(h, &privs, NULL, &authn_level,
                                &authn_svc, &authz_svc, stp);
vc, stp);
      CHECK_STATUS("rpc_binding_inq_auth_client", stp);
!     if ((authn_level != rpc_c_protect_level_pkt_integ) &&
            (authz_svc != rpc_c_authz_dce))
      {
         printf("wrong authn_level or wrong authz_svc, test failed\n");
***************
*** 893,899 ****
      rpc_binding_inq_auth_client(h, &privs, NULL, &authn_level,
                                &authn_svc, &authz_svc, stp);
      CHECK_STATUS("rpc_binding_inq_auth_client", stp);
!     if ((authn_level != rpc_c_protect_level_pkt_privacy) &&
            (authz_svc != rpc_c_authz_dce))
      {
         printf("wrong authn_level or wrong authz_svc, test failed\n");
--- 905,911 ----
      rpc_binding_inq_auth_client(h, &privs, NULL, &authn_level,
                                &authn_svc, &authz_svc, stp);
      CHECK_STATUS("rpc_binding_inq_auth_client", stp);
!     if ((authn_level != rpc_c_protect_level_pkt_integ) &&
            (authz_svc != rpc_c_authz_dce))
      {
         printf("wrong authn_level or wrong authz_svc, test failed\n");
***************
*** 990,996 ****
      rpc_binding_inq_auth_client(h, &privs, NULL, &authn_level,
                                &authn_svc, &authz_svc, stp);
      CHECK_STATUS("rpc_binding_inq_auth_client", stp);
!     if ((authn_level != rpc_c_protect_level_pkt_privacy) &&
            (authz_svc != rpc_c_authz_dce))
      {
         printf("wrong authn_level or wrong authz_svc, test failed\n");
--- 1002,1008 ----
      rpc_binding_inq_auth_client(h, &privs, NULL, &authn_level,
                                &authn_svc, &authz_svc, stp);
      CHECK_STATUS("rpc_binding_inq_auth_client", stp);
!     if ((authn_level != rpc_c_protect_level_pkt_integ) &&
            (authz_svc != rpc_c_authz_dce))
      {
         printf("wrong authn_level or wrong authz_svc, test failed\n");
*** /vob/dce.src.test/src/test/security/audit/ts/api_filter/aud_testf.c@@/main/5        Tue Oct  4 19:20:49 1994
--- /vob/dce.src.test/src/test/security/audit/ts/api_filter/aud_testf.c@@/main/HPDCE02/3        Fri Aug 18 16:10:59
1995
***************
*** 8,13 ****
--- 8,29 ----
  /*
   * HISTORY
   * $Log:	c013182,v $
# Revision 1.4  96/03/21  11:25:59  root
# changed fields: Status  Fixed In Baseline   new/changed/deleted note(s) [white_r 03/21/96 public]
# 
# Revision 1.3  95/11/03  14:50:50  root
# changed fields:  new/changed/deleted note(s) [trant 11/02/95 public]
# 
# Revision 1.2  95/10/31  17:45:27  root
# changed fields: Affected File(s)  
# 
# Revision 1.1  95/10/31  17:23:07  root
# new CR
# 
+  * Revision /main/HPDCE02/3  1995/08/18  20:11 UTC  kline_s
+  *    Merge fix for CHFts16115
+  *
+  * Revision /main/kline_s_mothra/3  1995/08/17  21:32 UTC  kline_s
+  *    CHFts16115: Remove DES_HIDDEN conditional - only using integrity
+  *    protection level instead of using the privacy protection level
+  *    for Domestic.  Required to avoid conflicts due to singular
+  *    Domestic/Export release.
+  *
+  * Revision /main/kline_s_mothra/2  1995/07/06  19:45 UTC  kline_s
+  *    Enable tests to function properly using international (ie. non-DES) bits.
+  *
+  * Revision /main/kline_s_mothra/1  1995/06/27  01:58 UTC  kline_s
+  *    $TET_ROOT incorrectly assumes path of /tet/test instead of /tet.
+  *    Modify all impacted paths so that /test is included in path specifications.
+  *
   * Revision 1.1.2.4  1994/10/04  21:23:36  weisz
   *    CR 12167: api_filter test suite fails.
   *    [1994/10/04  21:21:20  weisz]
***************
*** 96,111 ****
        tet_infoline("ERROR: filtering environment variable DCEAUDITFILTERON not set\n");
        exit(1);
     }
!    system("$TET_ROOT/functional/security/audit/ts/api_filter/startauditd");
  }

   void cleanup()
  {
!    system("$TET_ROOT/functional/security/audit/ts/api_filter/stopauditd");
  #   system("rm /opt/dcelocal/var/audit/esl-* ");
     tet_infoline("End api_filter test suite");
     printf("End api_filter test suite\n");
  fflush(stdout);
  }
  */

--- 112,129 ----
        tet_infoline("ERROR: filtering environment variable DCEAUDITFILTERON not set\n");
        exit(1);
     }
!    system("$TET_ROOT/test/functional/security/audit/ts/api_filter/startauditd");
!    return(0);
  }

   void cleanup()
  {
!    system("$TET_ROOT/test/functional/security/audit/ts/api_filter/stopauditd");
  #   system("rm /opt/dcelocal/var/audit/esl-* ");
     tet_infoline("End api_filter test suite");
     printf("End api_filter test suite\n");
  fflush(stdout);
+    return(0);
  }
  */

***************
*** 141,146 ****
--- 159,165 ----
      non_dt_fatal_error = TRUE;
      pthread_cancel(distinguished_task);
      pthread_exit((void *)-1);
+     return(0);
  }


***************
*** 154,160 ****
    FILE *fptr;
    void (*test_case1) () = aud_testf_v1_0_c_epv.aud_testf_case1;

!   system("$TET_ROOT/functional/security/audit/ts/api_filter/addfilter.princ1");

    /* aud_client_server spins off a listener thread for the whole suite */
    rc = aud_client_server(test_case1, princ);
--- 173,179 ----
    FILE *fptr;
    void (*test_case1) () = aud_testf_v1_0_c_epv.aud_testf_case1;

!   system("$TET_ROOT/test/functional/security/audit/ts/api_filter/addfilter.princ1");

    /* aud_client_server spins off a listener thread for the whole suite */
    rc = aud_client_server(test_case1, princ);
***************
*** 161,167 ****
    if (rc != 0)
      overall_status |= tp1_error;

!   system("($TET_ROOT/functional/security/audit/ts/api_filter/delfilter.princ1)&");

    fptr = NULL;
    j = 0;
--- 180,186 ----
    if (rc != 0)
      overall_status |= tp1_error;

!   system("($TET_ROOT/test/functional/security/audit/ts/api_filter/delfilter.princ1)&");

    fptr = NULL;
    j = 0;
***************
*** 177,182 ****
--- 196,202 ----
      printf("deleting filter princ1 took: %i\n", j);
     fclose (fptr);
     remove (HANDSHAKE_FILE);
+    return(0);
  }


***************
*** 190,196 ****
    void (*test_case2) () = aud_testf_v1_0_c_epv.aud_testf_case2;


!   system("($TET_ROOT/functional/security/audit/ts/api_filter/addfilter.group1)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
--- 210,216 ----
    void (*test_case2) () = aud_testf_v1_0_c_epv.aud_testf_case2;


!   system("($TET_ROOT/test/functional/security/audit/ts/api_filter/addfilter.group1)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
***************
*** 211,217 ****
      overall_status |= tp2_error;

!   system("($TET_ROOT/functional/security/audit/ts/api_filter/delfilter.group1)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
--- 231,237 ----
      overall_status |= tp2_error;


!   system("($TET_ROOT/test/functional/security/audit/ts/api_filter/delfilter.group1)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
***************
*** 226,231 ****
--- 246,252 ----
      printf("deleting filter group1 took: %i\n", j);
      fclose (fptr);
      remove (HANDSHAKE_FILE);
+     return(0);

  }

***************
*** 240,246 ****
   void (*test_case3) () = aud_testf_v1_0_c_epv.aud_testf_case3;


!   system("($TET_ROOT/functional/security/audit/ts/api_filter/addfilter.cell)&");

    fptr = NULL;
    j = 0;
--- 261,267 ----
   void (*test_case3) () = aud_testf_v1_0_c_epv.aud_testf_case3;


!   system("($TET_ROOT/test/functional/security/audit/ts/api_filter/addfilter.cell)&");

    fptr = NULL;
    j = 0;
***************
*** 263,269 ****
      overall_status |= tp3_error;


!   system("($TET_ROOT/functional/security/audit/ts/api_filter/delfilter.cell)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
--- 284,290 ----
      overall_status |= tp3_error;


!   system("($TET_ROOT/test/functional/security/audit/ts/api_filter/delfilter.cell)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
***************
*** 279,284 ****
--- 300,306 ----
    fclose (fptr);
    remove (HANDSHAKE_FILE);

+   return(0);

  }

***************
*** 293,299 ****
    void (*test_case4) () = aud_testf_v1_0_c_epv.aud_testf_case4;


!   system("($TET_ROOT/functional/security/audit/ts/api_filter/addfilter.world)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
--- 315,321 ----
    void (*test_case4) () = aud_testf_v1_0_c_epv.aud_testf_case4;


!   system("($TET_ROOT/test/functional/security/audit/ts/api_filter/addfilter.world)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
***************
*** 315,321 ****
      overall_status |= tp4_error;


!   system("($TET_ROOT/functional/security/audit/ts/api_filter/delfilter.world)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
--- 337,343 ----
      overall_status |= tp4_error;


!   system("($TET_ROOT/test/functional/security/audit/ts/api_filter/delfilter.world)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
***************
*** 330,335 ****
--- 352,358 ----
       printf("deleting filter world took: %i\n", j);
    fclose (fptr);
    remove (HANDSHAKE_FILE);
+   return(0);

  }

***************
*** 345,351 ****



!   system("($TET_ROOT/functional/security/audit/ts/api_filter/addfilter.worldover)&");

    fptr = NULL;
    j = 0;
--- 368,374 ----



!   system("($TET_ROOT/test/functional/security/audit/ts/api_filter/addfilter.worldover)&");

    fptr = NULL;
    j = 0;
***************
*** 370,375 ****
--- 393,399 ----
  /*
     not removing the filter since needed in next test
  */
+   return(0);
  }


***************
*** 387,393 ****
    just adding principal filter with no action
  */

!   system("($TET_ROOT/functional/security/audit/ts/api_filter/addfilter.princ1noac)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
--- 411,417 ----
    just adding principal filter with no action
  */

!   system("($TET_ROOT/test/functional/security/audit/ts/api_filter/addfilter.princ1noac)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
***************
*** 409,415 ****
      overall_status |= tp6_error;


!   system("($TET_ROOT/functional/security/audit/ts/api_filter/delfilter.princ1)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
--- 433,439 ----
      overall_status |= tp6_error;


!   system("($TET_ROOT/test/functional/security/audit/ts/api_filter/delfilter.princ1)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
***************
*** 424,429 ****
--- 448,454 ----
        printf("deleting filter princ1 took: %i\n", j);
    fclose (fptr);
    remove (HANDSHAKE_FILE);
+   return(0);

  }

***************
*** 442,448 ****
    just adding group filter with no action, should override the world filter
  */

!   system("($TET_ROOT/functional/security/audit/ts/api_filter/addfilter.group1noac)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
--- 467,473 ----
    just adding group filter with no action, should override the world filter
  */
!   system("($TET_ROOT/test/functional/security/audit/ts/api_filter/addfilter.group1noac)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
***************
*** 465,471 ****



!   system("($TET_ROOT/functional/security/audit/ts/api_filter/delfilter.group1)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
--- 490,496 ----



!   system("($TET_ROOT/test/functional/security/audit/ts/api_filter/delfilter.group1)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
***************
*** 482,488 ****
    remove (HANDSHAKE_FILE);


!   system("($TET_ROOT/functional/security/audit/ts/api_filter/delfilter.worldover)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
--- 507,513 ----
    remove (HANDSHAKE_FILE);


!   system("($TET_ROOT/test/functional/security/audit/ts/api_filter/delfilter.worldover)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
***************
*** 497,502 ****
--- 522,528 ----
        printf("deleting filter world overridable took: %i\n", j);
    fclose (fptr);
    remove (HANDSHAKE_FILE);
+   return(0);

  }

***************
*** 513,519 ****
    void (*test_case8) () = aud_testf_v1_0_c_epv.aud_testf_case8;


!   system("($TET_ROOT/functional/security/audit/ts/api_filter/addfilter.princ1succalarm)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
--- 539,545 ----
    void (*test_case8) () = aud_testf_v1_0_c_epv.aud_testf_case8;


!   system("($TET_ROOT/test/functional/security/audit/ts/api_filter/addfilter.princ1succalarm)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
***************
*** 534,540 ****
      overall_status |= tp8_error;


!   system("($TET_ROOT/functional/security/audit/ts/api_filter/delfilter.princ1)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
--- 560,566 ----
      overall_status |= tp8_error;

!   system("($TET_ROOT/test/functional/security/audit/ts/api_filter/delfilter.princ1)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
***************
*** 549,554 ****
--- 575,581 ----
       printf("deleting filter princ1 took: %i\n", j);
      fclose (fptr);
      remove (HANDSHAKE_FILE);
+     return(0);

  }

***************
*** 564,570 ****
    void (*test_case9) () = aud_testf_v1_0_c_epv.aud_testf_case9;


!   system("($TET_ROOT/functional/security/audit/ts/api_filter/addfilter.princ1denialarm)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
--- 591,597 ----
    void (*test_case9) () = aud_testf_v1_0_c_epv.aud_testf_case9;


!   system("($TET_ROOT/test/functional/security/audit/ts/api_filter/addfilter.princ1denialarm)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
***************
*** 589,594 ****
--- 616,622 ----


  /*  not removing princ1 denial alarm filter since it is used by next test  */
+   return(0);
  }

***************
*** 612,617 ****
--- 640,646 ----


  /*  not removing princ1 denial alarm filter since it is used by next test  */
+   return(0);

  }

***************
*** 634,640 ****
      overall_status |= tp11_error;


!   system("($TET_ROOT/functional/security/audit/ts/api_filter/delfilter.princ1)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
--- 663,669 ----
      overall_status |= tp11_error;


!   system("($TET_ROOT/test/functional/security/audit/ts/api_filter/delfilter.princ1)&");
    fptr = NULL;
    j = 0;
    while (fptr == NULL)
***************
*** 649,654 ****
--- 678,684 ----
       printf("deleting filter princ1 took: %i\n", j);
      fclose (fptr);
      remove (HANDSHAKE_FILE);
+     return(0);

  }
***************
*** 799,805 ****

        rpc_binding_set_auth_info(bindings->binding_h[0],
                                  (unsigned_char_t *) server_name,
!                                   rpc_c_authn_level_pkt_privacy,
                                    rpc_c_authn_dce_private,
                                    (rpc_auth_identity_handle_t) login_context,
                                    rpc_c_authz_dce, &st);
--- 829,835 ----

        rpc_binding_set_auth_info(bindings->binding_h[0],
                                  (unsigned_char_t *) server_name,
!                                 rpc_c_authn_level_pkt_integrity,
                                    rpc_c_authn_dce_private,
                                    (rpc_auth_identity_handle_t) login_context,
                                    rpc_c_authz_dce, &st);
***************
*** 924,930 ****

        rpc_binding_set_auth_info(bindings->binding_h[0],
                                  (unsigned_char_t *) server_name,
!                                   rpc_c_authn_level_pkt_privacy,
                                    rpc_c_authn_dce_private,
                                    (rpc_auth_identity_handle_t) login_context,
                                    rpc_c_authz_dce, &st);
--- 954,960 ----

        rpc_binding_set_auth_info(bindings->binding_h[0],
                                  (unsigned_char_t *) server_name,
!                                 rpc_c_authn_level_pkt_integrity,
                                    rpc_c_authn_dce_private,
                                    (rpc_auth_identity_handle_t) login_context,
                                    rpc_c_authz_dce, &st);
***************
*** 959,965 ****

      }
      ENDTRY;
-
  }


--- 989,994 ----
*** /vob/dce.src.test/src/test/security/audit/ts/api_log/aud_test.c@@/main/7    Tue Sep 27 14:18:04 1994
--- /vob/dce.src.test/src/test/security/audit/ts/api_log/aud_test.c@@/main/HPDCE02/3    Fri Aug 18 16:10:17 1995
***************
*** 8,13 ****
--- 8,29 ----
  /*
   * HISTORY
   * $Log:	c013182,v $
# Revision 1.4  96/03/21  11:25:59  root
# changed fields: Status  Fixed In Baseline   new/changed/deleted note(s) [white_r 03/21/96 public]
# 
# Revision 1.3  95/11/03  14:50:50  root
# changed fields:  new/changed/deleted note(s) [trant 11/02/95 public]
# 
# Revision 1.2  95/10/31  17:45:27  root
# changed fields: Affected File(s)  
# 
# Revision 1.1  95/10/31  17:23:07  root
# new CR
# 
+  * Revision /main/HPDCE02/3  1995/08/18  20:10 UTC  kline_s
+  *    Merge fix for CHFts16115
+  *
+  * Revision /main/kline_s_mothra/3  1995/08/17  21:33 UTC  kline_s
+  *    CHFts16115: Remove DES_HIDDEN conditional - only using integrity
+  *    protection level instead of using the privacy protection level
+  *    for Domestic.  Required to avoid conflicts due to singular
+  *    Domestic/Export release.
+  *
+  * Revision /main/kline_s_mothra/2  1995/07/06  19:45 UTC  kline_s
+  *    Enable tests to function properly using international (ie. non-DES) bits.
+  *
+  * Revision /main/kline_s_mothra/1  1995/06/27  02:07 UTC  kline_s
+  *    Clean up functions to actually provide return values (and thereby
+  *    fixing all the compile-time warnings.
+  *
   * Revision 1.1.2.6  1994/09/27  17:32:37  weisz
   *    CR 10703: added tests for trail full situation.
   *    [1994/09/27  17:31:22  weisz]
***************
*** 118,123 ****
--- 134,140 ----
      non_dt_fatal_error = TRUE;
      pthread_cancel(distinguished_task);
      pthread_exit((void *)-1);
+     return(0);
  }

  compose_server_name
***************
*** 136,141 ****
--- 153,159 ----
          strcat(servername, name);
          strcat(servername, "/self");
  printf("servername= %s\n", servername);
+         return(0);
  }

  int tp1()
***************
*** 146,151 ****
--- 164,170 ----
   if (rc != 0)
     overall_status |= tp1_error;
  printf("tp1: rc= %i, overall_status= %lx\n", rc, overall_status);
+  return(0);
  }

  int tp2()
***************
*** 156,161 ****
--- 175,181 ----
   if (rc != 0)
     overall_status |= tp2_error;
  printf("tp2: rc= %i, overall_status= %lx\n", rc, overall_status);
+  return(0);
  }


***************
*** 167,172 ****
--- 187,193 ----
   if (rc != 0)
     overall_status |= tp3_error;
  printf("tp3: rc= %i, overall_status= %lx\n", rc, overall_status);
+  return(0);
  }

  int tp4()
***************
*** 177,182 ****
--- 198,204 ----
   if (rc != 0)
     overall_status |= tp4_error;
  printf("tp4: rc= %i, overall_status= %lx\n", rc, overall_status);
+  return(0);
  }

  int tp5()
***************
*** 187,192 ****
--- 209,215 ----
   if (rc != 0)
     overall_status |= tp5_error;
  printf("tp5: rc= %i, overall_status= %lx\n", rc, overall_status);
+  return(0);
  }


***************
*** 198,203 ****
--- 221,227 ----
   if (rc != 0)
     overall_status |= tp6_error;
  printf("tp6: rc= %i, overall_status= %lx\n", rc, overall_status);
+  return(0);
  }

  int tp7()
***************
*** 208,213 ****
--- 232,238 ----
   if (rc != 0)
     overall_status |= tp7_error;
  printf("tp7: rc= %i, overall_status= %lx\n", rc, overall_status);
+  return(0);
  }

  int tp8()
***************
*** 218,223 ****
--- 243,249 ----
   if (rc != 0)
     overall_status |= tp8_error;
  printf("tp8: rc= %i, overall_status= %lx\n", rc, overall_status);
+  return(0);
  }

  int tp9()
***************
*** 228,233 ****
--- 254,260 ----
   if (rc != 0)
     overall_status |= tp9_error;
  printf("tp9: rc= %i, overall_status= %lx\n", rc, overall_status);
+  return(0);
  }

  int tp10()
***************
*** 238,243 ****
--- 265,271 ----
   if (rc != 0)
     overall_status |= tp10_error;
  printf("tp10: rc= %i, overall_status= %lx\n", rc, overall_status);
+  return(0);
  }

  int tp11()
***************
*** 248,253 ****
--- 276,282 ----
   if (rc != 0)
     overall_status |= tp11_error;
  printf("tp11: rc= %i, overall_status= %lx\n", rc, overall_status);
+  return(0);
  }

  int tp12()
***************
*** 258,263 ****
--- 287,293 ----
   if (rc != 0)
     overall_status |= tp12_error;
  printf("tp12: rc= %i, overall_status= %lx\n", rc, overall_status);
+  return(0);
  }


***************
*** 269,274 ****
--- 299,305 ----
   if (rc != 0)
     overall_status |= tp13_error;
  printf("tp13: rc= %i, overall_status= %lx\n", rc, overall_status);
+  return(0);
  }


***************
*** 280,285 ****
--- 311,317 ----
   if (rc != 0)
     overall_status |= tp14_error;
  printf("tp14: rc= %i, overall_status= %lx\n", rc, overall_status);
+  return(0);
  }

  int tp15()
***************
*** 290,295 ****
--- 322,328 ----
   if (rc != 0)
     overall_status |= tp15_error;
  printf("tp15: rc= %i, overall_status= %lx\n", rc, overall_status);
+  return(0);
  }

  int tp16()
***************
*** 300,305 ****
--- 333,339 ----
   if (rc != 0)
     overall_status |= tp16_error;
  printf("tp16: rc= %i, overall_status= %lx\n", rc, overall_status);
+  return(0);
  }

  int tp17()
***************
*** 310,315 ****
--- 344,350 ----
   if (rc != 0)
     overall_status |= tp17_error;
  printf("tp17: rc= %i, overall_status= %lx\n", rc, overall_status);
+  return(0);
  }

  int tp18()
***************
*** 320,325 ****
--- 355,361 ----
   if (rc != 0)
     overall_status |= tp18_error;
  printf("tp18: rc= %i, overall_status= %lx\n", rc, overall_status);
+  return(0);
  }

  int tp19()
***************
*** 330,335 ****
--- 366,372 ----
   if (rc != 0)
     overall_status |= tp19_error;
  printf("tp19: rc= %i, overall_status= %lx\n", rc, overall_status);
+  return(0);
  }

  int tp20()
***************
*** 340,345 ****
--- 377,383 ----
   if (rc != 0)
     overall_status |= tp20_error;
  printf("tp20: rc= %i, overall_status= %lx\n", rc, overall_status);
+  return(0);
  }

  int tp21()
***************
*** 350,355 ****
--- 388,394 ----
   if (rc != 0)
     overall_status |= tp21_error;
  printf("tp21: rc= %i, overall_status= %lx\n", rc, overall_status);
+  return(0);
  }


***************
*** 361,366 ****
--- 400,406 ----
   if (rc != 0)
     overall_status |= tp22_error;
  printf("tp22: rc= %i, overall_status= %lx\n", rc, overall_status);
+  return(0);
  }


***************
*** 442,448 ****

        rpc_binding_set_auth_info(bindings->binding_h[0],
                                  (unsigned_char_t *) server_name,
!                                   rpc_c_authn_level_pkt_privacy,
                                    rpc_c_authn_dce_private,
                                    (rpc_auth_identity_handle_t) login_context,
                                    rpc_c_authz_dce, &st);
--- 482,488 ----

        rpc_binding_set_auth_info(bindings->binding_h[0],
                                  (unsigned_char_t *) server_name,
!                                 rpc_c_authn_level_pkt_integrity,
                                    rpc_c_authn_dce_private,
                                    (rpc_auth_identity_handle_t) login_context,
                                    rpc_c_authz_dce, &st);
***************
*** 482,488 ****

        rpc_binding_set_auth_info(bindings->binding_h[0],
                                  (unsigned_char_t *) server_name,
!                                   rpc_c_authn_level_pkt_privacy,
                                    rpc_c_authn_dce_private,
                                    (rpc_auth_identity_handle_t) login_context,
                                    rpc_c_authz_dce, &st);
--- 522,528 ----

        rpc_binding_set_auth_info(bindings->binding_h[0],
                                  (unsigned_char_t *) server_name,
!                                 rpc_c_authn_level_pkt_integrity,
                                    rpc_c_authn_dce_private,
                                    (rpc_auth_identity_handle_t) login_context,
                                    rpc_c_authz_dce, &st);
*** /vob/dce.src.test/src/test/security/audit/ts/api_log/aud_test_rpc_manager.c@@/main/16       Wed Oct 26 23:28:36
1994
--- /vob/dce.src.test/src/test/security/audit/ts/api_log/aud_test_rpc_manager.c@@/[trant 11/02/95 public]
For this OT, please ONLY pickup the changes to support 13119 and missing 
return statements.  For all "system("TET_ROOT/functional/...")" statements
which I think already mentioned in 13185, please do not change now.  There are
tet files under .../src/test/security/audit that I think we should use instead 
of .../src/test/functional/security.  In addition, OSF has noticed me that 
audit should be a part of security component.

[03/21/96 public]
Changes included in DCE1.2. Fixed/Closed



CR Number                     : 13180
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : Tighten permissions
Reported Date                 : 10/31/95
Found in Baseline             : 1.1
Found Date                    : 10/31/95
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1, 1.1maint
Affected File(s)              : audit/libaudit/trl_ops.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/31/95 public]

Tighten permissions on audit trail and associated index files to eliminate 
security hole.

*** /vob/dce/src/security/audit/libaudit/trl_ops.c@@/main/18    Tue Sep 27 00:01:00 1994
--- /vob/dce/src/security/audit/libaudit/trl_ops.c@@/main/HPDCE02/2     Tue Jun 20 13:45:10 1995
***************
*** 9,14 ****
--- 9,25 ----
  /*
   * HISTORY
   * $Log:	c013180,v $
# Revision 1.4  96/09/30  18:38:03  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
# Revision 1.3  96/03/21  11:41:24  root
# changed fields: Status  Fixed In Baseline   new/changed/deleted note(s) [white_r 03/21/96 public]
# 
# Revision 1.2  95/11/01  12:49:18  root
# changed fields:  new/changed/deleted note(s) [trant 11/01/95 public]
# 
# Revision 1.1  95/10/31  15:11:00  root
# new CR
# 
+  * Revision /main/HPDCE02/2  1995/06/20  17:45 UTC  kline_s
+  *    CHFts15485: Tighten permissions on audit trail and associated index
+  *    files to eliminate security hole.
+  *
+  * Revision /main/HPDCE02/kline_s_mothra/1  1995/06/13  20:53 UTC  kline_s
+  *    CHFts15485: Tighten permissions for audit trail and associated index
+  *    files to eliminate security hole.
+  *
+  * Revision /main/HPDCE02/1  1994/10/05  11:18 UTC  mothra
+  *    add limits.h
+  *
   * Revision 1.1.2.20  1994/09/27  00:27:19  weisz
   *    CR 10703: in case of wrap, fopen flags should be wb+
   *    [1994/09/27  00:26:49  weisz]
***************
*** 92,97 ****
--- 103,109 ----
  ** Implements audit-trail operation API.
  */

+ #include <limits.h>
  #include <evtp.h>
  #include <dceaudmsg.h>
  #include <dceaudmac.h>
***************
*** 242,247 ****
--- 254,263 ----
        if (!open_for_read) {
            fseek(trail_fp, 0, SEEK_END);  /* go to the end of the file */
            fseek(md_index_fp, 0, SEEK_END);  /* go to the end of the file */
+
+             /* CHFts15485: Tighten permissions on audit trail file and index */
+             chmod(description, 0640);
+             chmod(buf, 0640);
        }
      }

[11/01/95 public]
I definitely think this is the right thing to do.  We only want both files read/write
by owner and readonly by group.  Please include this enhancement in the next merge.

[03/21/96 public]
Code included in DCE 1.2.1.  Closed with IBM agreement.

[09/30/96 public]
Fix included in 1.1 maintenance tree.

./security/audit/libaudit/trl_ops.c
Comparing revision 1.1.6.4 with revision 1.1.6.5.
11a12,15
>  * Revision 1.1.6.5  1996/09/30  15:29:16  mariko
>  *    OT 13180: Tighten permissions on audit trail and associated index files
>  *    [1996/09/30  15:28:53  mariko]
>  *
15c19
<  *
---
>  * 
111a116
> #include <limits.h>                           /* OT 13180 */
264a270,273
> 
>             /* OT 13180: Tighten permissions on audit trail file and index */
>             chmod(description, 0640);
>             chmod(buf, 0640);



CR Number                     : 13179
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : merge hash_uuid_failed msg enhance
Reported Date                 : 10/31/95
Found in Baseline             : 1.1
Found Date                    : 10/31/95
Severity                      : E
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1, 1.1maint
Affected File(s)              : audit
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/31/95 public]

Some minor code change to get string error message. Need review.

*** /vob/dce/src/security/audit/libaudit/esl_in_core.c@@/main/HPDCE02/1 Fri Jul 14 14:42:40 1995
--- /vob/dce/src/security/audit/libaudit/esl_in_core.c@@/main/HPDCE02/2 Mon Sep 25 09:42:40 1995
***************
*** 9,14 ****
--- 9,26 ----
  /*
   * HISTORY
   * $Log:	c013179,v $
# Revision 1.4  96/09/30  19:05:18  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
# Revision 1.3  96/03/21  11:39:28  root
# changed fields: Status  Fixed In Baseline  Affected File(s)   new/changed/deleted note(s) [white_r 03/21/96 public]
# 
# Revision 1.2  95/11/01  18:18:45  root
# changed fields:  new/changed/deleted note(s) [trant 11/01/95 public]
# 
# Revision 1.1  95/10/31  14:58:22  root
# new CR
# 
+  * Revision /main/HPDCE02/2  1995/09/25  13:42 UTC  bartf
+  *    merge hash_uuid_failed msg enhance
+  *
+  * Revision /main/HPDCE02/bartf_sec_wc.10/3  1995/09/21  14:16 UTC  bartf
+  *    remove comments
+  *
+  * Revision /main/HPDCE02/bartf_sec_wc.10/2  1995/09/19  19:58 UTC  bartf
+  *    fix uuid_string in print
+  *
+  * Revision /main/HPDCE02/bartf_sec_wc.10/1  1995/09/18  17:40 UTC  bartf
+  *    add more info to uuid_hash_failed msg
+  *
   * Revision /main/HPDCE02/1  1995/07/14  18:42 UTC  jrr
   *    Change dce_printf() to dce_svc_printf().
   *    [1995/07/14  18:35 UTC  jrr  /main/jrr_mothra_pure/1]
***************
*** 40,45 ****
--- 52,58 ----
  */

  #include <dce/dce.h>
+ #include <dce/dce_error.h>
  #include <dce/dce_msg.h>
  #include <dce/audit.h>
  #include <stdarg.h>
***************
*** 649,657 ****
  ) {
      unsigned32      st;
      int             i;
      *probe = uuid_hash(&subject_uuid, &st) % HASH_TABLE_SIZE;
      if (st != uuid_s_ok) {
!       dce_svc_printf(AUD_S_UUID_HASH_FAILED_MSG);
        return(NULL);
      };

--- 662,679 ----
  ) {
      unsigned32      st;
      int             i;
+     unsigned32      string_st;
+     unsigned_char_t *uuid_string;
+     dce_error_string_t error_string;
+     int print_status;
+
+
      *probe = uuid_hash(&subject_uuid, &st) % HASH_TABLE_SIZE;
      if (st != uuid_s_ok) {
!       uuid_to_string(&subject_uuid, &uuid_string, & string_st );
!       dce_error_inq_text(st, error_string, &print_status);
!       dce_svc_printf(AUD_S_UUID_HASH_FAILED_MSG, (char *)uuid_string, error_string );
!       rpc_string_free(&uuid_string, & string_st );
        return(NULL);
      };

[11/01/95 public]
This would help explain the error. Please also add the same lines in
esl_file_read.c where subject_uuid is also hashed.  Thanks.

[03/21/96 public]
Code included in DCE 1.2.1.  Closed with IBM agreement.

[09/30/96 public]
Fixed in 1.1 maintenance tree.

./security/audit/libaudit/esl_in_core.c
Comparing revision 1.1.2.4 with revision 1.1.8.1.
*** 1.1.2.4     1994/03/11 22:48:37
--- 1.1.8.1     1996/09/30 14:50:33
***************
*** 9,18 ****
  /*
   * HISTORY
   * $Log:	c013179,v $
# Revision 1.4  96/09/30  19:05:18  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
   * Revision 1.1.2.4  1994/03/11  22:48:37  luan
   *    CR 9775 9776: Changed debug messages to use dce_svc_printf() or DCE_SVC_DEBUG.
   *    [1994/03/11  22:20:32  luan]
!  *
   * Revision 1.1.2.3  1994/02/22  16:47:29  luan
   *    CR 9775 9776 9860:  Defined DCE_AUD_DEBUG in audit.h.  Removed
   *    debug_mode and PRE_BETA_DEBUG or replaced it with DCE_DEBUG.
--- 9,22 ----
  /*
   * HISTORY
   * $Log:	c013179,v $
# Revision 1.4  96/09/30  19:05:18  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
+  * Revision 1.1.8.1  1996/09/30  14:50:33  mariko
+  *    OT 13179:  hash_uuid_failed msg enhance
+  *    [1996/09/30  14:49:10  mariko]
+  *
   * Revision 1.1.2.4  1994/03/11  22:48:37  luan
   *    CR 9775 9776: Changed debug messages to use dce_svc_printf() or DCE_SVC_DEBUG.
   *    [1994/03/11  22:20:32  luan]
!  * 
   * Revision 1.1.2.3  1994/02/22  16:47:29  luan
   *    CR 9775 9776 9860:  Defined DCE_AUD_DEBUG in audit.h.  Removed
   *    debug_mode and PRE_BETA_DEBUG or replaced it with DCE_DEBUG.
***************
*** 36,41 ****
--- 40,46 ----
  */
  
  #include <dce/dce.h>
+ #include <dce/dce_error.h>            /* OT 13179 */
  #include <dce/dce_msg.h>
  #include <dce/audit.h>
  #include <stdarg.h>
***************
*** 643,653 ****
                                 uuid_t cell_uuid,
                                 unsigned16 * probe
  ) {
!     unsigned32      st;
!     int             i;
      *probe = uuid_hash(&subject_uuid, &st) % HASH_TABLE_SIZE;
      if (st != uuid_s_ok) {
!       dce_printf(aud_s_uuid_hash_failed);
        return(NULL);
      };
  
--- 648,672 ----
                                 uuid_t cell_uuid,
                                 unsigned16 * probe
  ) {
!     unsigned32                st;
!     int                       i;
!     unsigned32                string_st;              /* OT 13179 */
!     unsigned_char_t   *uuid_string;           /* OT 13179 */
!     dce_error_string_t        error_string;           /* OT 13179 */
!     int                       print_status;           /* OT 13179 */
! 
      *probe = uuid_hash(&subject_uuid, &st) % HASH_TABLE_SIZE;
      if (st != uuid_s_ok) {
!       /* OT 13179: hash_uuid_failed msg enhance */
!       dce_error_inq_text(st, error_string, &print_status);
!       uuid_to_string(&subject_uuid, &uuid_string, & string_st );
!       if ( string_st != uuid_s_ok ) {
!               /* uuid bad from uuid_to string,
!               so print unknown instead of uuid garbage */
!               strcpy((char *)uuid_string, "?");
!       }
!       dce_svc_printf(AUD_S_UUID_HASH_FAILED_MSG, (char *)uuid_string, error_string );
!       rpc_string_free(&uuid_string, & string_st );
        return(NULL);
      };
  

Comparing revision 1.1.2.8 with revision 1.1.10.1.
*** 1.1.2.8     1994/04/10 19:57:52
--- 1.1.10.1    1996/09/30 14:50:35
***************
*** 9,19 ****
  /*
   * HISTORY
   * $Log:	c013179,v $
# Revision 1.4  96/09/30  19:05:18  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
   * Revision 1.1.2.8  1994/04/10  19:57:52  weisz
   *    CR 10320: used memcpy in aud_esl_input_file and aud_esl_input_update_file
   *              instead of cast *(unsigned32 *)data_p to avoid alignment problem
   *    [1994/04/10  19:57:15  weisz]
!  *
   * Revision 1.1.2.7  1994/03/11  22:48:36  luan
   *    CR 9775 9776: Changed debug messages to use dce_svc_printf() or DCE_SVC_DEBUG.
   *    [1994/03/11  22:17:45  luan]
--- 9,23 ----
  /*
   * HISTORY
   * $Log:	c013179,v $
# Revision 1.4  96/09/30  19:05:18  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
+  * Revision 1.1.10.1  1996/09/30  14:50:35  mariko
+  *    OT 13179:  hash_uuid_failed msg enhance
+  *    [1996/09/30  14:49:42  mariko]
+  *
   * Revision 1.1.2.8  1994/04/10  19:57:52  weisz
   *    CR 10320: used memcpy in aud_esl_input_file and aud_esl_input_update_file
   *              instead of cast *(unsigned32 *)data_p to avoid alignment problem
   *    [1994/04/10  19:57:15  weisz]
!  * 
   * Revision 1.1.2.7  1994/03/11  22:48:36  luan
   *    CR 9775 9776: Changed debug messages to use dce_svc_printf() or DCE_SVC_DEBUG.
   *    [1994/03/11  22:17:45  luan]
***************
*** 56,61 ****
--- 60,66 ----
  */
  
  #include <dce/dce.h>
+ #include <dce/dce_error.h>            /* OT 13179 */
  #include <dce/dce_msg.h>
  #include <dce/dceaudmsg.h>
  #include <dce/dceaudmac.h>
***************
*** 132,143 ****
                                 aud_esl_guides_p_t guides_ptr,
                                 void *** tables
  ) {
!     unsigned16      probe;
!     unsigned32            st;
  
      probe = uuid_hash(&subject_uuid, &st) % HASH_TABLE_SIZE;
      if (st != uuid_s_ok) {
!       dce_printf(aud_s_uuid_hash_failed);
        return;
      };
  
--- 137,160 ----
                                 aud_esl_guides_p_t guides_ptr,
                                 void *** tables
  ) {
!     unsigned16                probe;
!     unsigned32                st, string_st;          /* OT 13179 */
!     unsigned_char_t   *uuid_string;           /* OT 13179 */
!     dce_error_string_t        error_string;           /* OT 13179 */
!     int                       print_status;           /* OT 13179 */
  
      probe = uuid_hash(&subject_uuid, &st) % HASH_TABLE_SIZE;
      if (st != uuid_s_ok) {
!       /* OT 13179:  hash_uuid_failed msg enhance */
!       dce_error_inq_text(st, error_string, &print_status);
!       uuid_to_string(&subject_uuid, &uuid_string, & string_st );
!       if ( string_st != uuid_s_ok ) {
!               /* uuid bad from uuid_to string,
!               so print unknown instead of uuid garbage */
!               strcpy((char *)uuid_string, "?");
!       }
!       dce_svc_printf(AUD_S_UUID_HASH_FAILED_MSG, (char *)uuid_string, error_string );
!       rpc_string_free(&uuid_string, & string_st );
        return;
      };
  

./security/audit/libaudit/aud.sams
Comparing revision 1.1.7.2 with revision 1.1.7.3.
*** 1.1.7.2     1996/01/27 16:12:35
--- 1.1.7.3     1996/09/30 14:50:37
***************
*** 6,16 ****
  # 
  # HISTORY
  # $Log:	c013179,v $
# Revision 1.4  96/09/30  19:05:18  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
  # Revision 1.1.7.2  1996/01/27  16:12:35  dlynch
  #     CR OT 13120 - changed auth info to pkt integrity
  #     from pkt privacy.
  #     [1996/01/27  16:11:43  dlynch]
! #
  # Revision 1.1.7.1  1996/01/19  19:13:56  monzillo
  #     other part of fix for 13178
  #     [1996/01/19  16:19:53  monzillo]
--- 6,20 ----
  # 
  # HISTORY
  # $Log:	c013179,v $
# Revision 1.4  96/09/30  19:05:18  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
+ # Revision 1.1.7.3  1996/09/30  14:50:37  mariko
+ #     OT 13179:  hash_uuid_failed msg enhance
+ #     [1996/09/30  14:50:00  mariko]
+ #
  # Revision 1.1.7.2  1996/01/27  16:12:35  dlynch
  #     CR OT 13120 - changed auth info to pkt integrity
  #     from pkt privacy.
  #     [1996/01/27  16:11:43  dlynch]
! # 
  # Revision 1.1.7.1  1996/01/19  19:13:56  monzillo
  #     other part of fix for 13178
  #     [1996/01/19  16:19:53  monzillo]
***************
*** 1050,1056 ****
  start
  code          aud_s_uuid_hash_failed
  sub-component aud_s_esl
! attributes    "svc_c_error"
  text          "Cannot get the hash value of the subject uuid"
  explanation   "The \*Luuid_hash\*O call failed."
  action                "See the corresponding RPC error code."
--- 1054,1060 ----
  start
  code          aud_s_uuid_hash_failed
  sub-component aud_s_esl
! attributes    "svc_c_sev_error"
  text          "Cannot get the hash value of the subject uuid"
  explanation   "The \*Luuid_hash\*O call failed."
  action                "See the corresponding RPC error code."



CR Number                     : 13178
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : Check for bad returns from open()
Reported Date                 : 10/31/95
Found in Baseline             : 1.1
Found Date                    : 10/31/95
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1, 1.1maint
Affected File(s)              : audit/auditd/dmn_updt_inform.c
Sensitivity                   : public

[10/31/95 public]

To avoid core dump, before using the returned value, see if we have a sane
call to open(). Needs review.

*** /vob/dce/src/security/audit/auditd/dmn_updt_inform.c@@/main/HPDCE02/1       Fri May 19 12:41:27 1995
--- /vob/dce/src/security/audit/auditd/dmn_updt_inform.c@@/main/HPDCE02/2       Wed Jul 26 14:23:05 1995
***************
*** 9,14 ****
--- 9,18 ----
  /*
   * HISTORY
   * $Log:	c013178,v $
# Revision 1.4  96/02/28  15:38:17  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [jcarroll 02/28/96 ]
# 
# Revision 1.3  95/12/13  14:23:43  root
# changed fields: Status  Fixed In Baseline   new/changed/deleted note(s) [white_r 12/13/95 ]
# 
# Revision 1.2  95/11/01  12:24:54  root
# changed fields:  new/changed/deleted note(s) [trant 11/01/95 public]
# 
# Revision 1.1  95/10/31  14:50:14  root
# new CR
# 
+  * Revision /main/HPDCE02/2  1995/07/26  18:23 UTC  jrr
+  *    Check for bad returns from open()
+  *    [1995/07/26  18:22 UTC  jrr  /main/HPDCE02/jrr_mothra_pure/1]
+  *
   * Revision /main/HPDCE02/1  1995/05/19  16:41 UTC  jrr
   *    Merge work for CHFts15152.
   *
***************
*** 240,246 ****
      aud_esl_type_t esl_type
  )
  {
!     DIR            *lvl1_dir, *lvl2_dir;
      FILE           *file;
      struct dirent  *dir_lvl1_entry;
      struct dirent  *dir_lvl2_entry;
--- 244,250 ----
      aud_esl_type_t esl_type
  )
  {
!     DIR            *lvl1_dir = NULL, *lvl2_dir = NULL;
      FILE           *file;
      struct dirent  *dir_lvl1_entry;
      struct dirent  *dir_lvl2_entry;
***************
*** 250,255 ****
--- 254,264 ----
      error_status_t *stp = &st;

      lvl1_dir = opendir(CLIENT_BINDING_DIR);
+     if (lvl1_dir == NULL) {
+         /* Abort and try again later */
+         dce_svc_printf(AUD_S_UPDT_OPENDIR_FAIL_MSG, CLIENT_BINDING_DIR, errno);
+         return;
+     }

      while ((dir_lvl1_entry = readdir(lvl1_dir)) != NULL) {
        if (strcmp(".", dir_lvl1_entry->d_name)
***************
*** 259,264 ****
--- 268,280 ----
            strcat(binding_dname, dir_lvl1_entry->d_name);
            strcat(binding_dname, "/");
            lvl2_dir = opendir(binding_dname);
+             if (lvl2_dir == NULL) {
+                 /* Abort and try again later */
+                 dce_svc_printf(AUD_S_UPDT_OPENDIR_FAIL_MSG, binding_dname, errno);
+                 closedir(lvl1_dir);
+                 return;
+             }
+
            while ((dir_lvl2_entry = readdir(lvl2_dir)) != NULL) {
                if (strcmp(".", dir_lvl2_entry->d_name)
                    &&

[11/01/95 public]
This is a good check and we should include it in the next merge.

[12/13/95]
Fixed in DCE 1.2.1
Closed

[02/28/96]
Also fixed in 1.1maint.



CR Number                     : 13177
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : Fix memory leak and minor code cleanup
Reported Date                 : 10/31/95
Found in Baseline             : 1.1
Found Date                    : 10/31/95
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1, 1.1maint
Affected File(s)              : auditd/dmn_main.c, auditd/dmn_rpc_manager.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/31/95 public]

Fix memory leak by using correct alloc/free for IDL es.c. Some more code
cleanup. Needs to be reviewed by comp owner:

*** /vob/dce/src/security/audit/auditd/dmn_main.c@@/main/HPDCE02/2      Fri May 19 12:43:13 1995
--- /vob/dce/src/security/audit/auditd/dmn_main.c@@/main/HPDCE02/3      Thu Jul 20 16:18:14 1995
***************
*** 9,14 ****
--- 9,23 ----
  /*
   * HISTORY
   * $Log:	c013177,v $
# Revision 1.6  96/09/30  16:40:15  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
# Revision 1.5  96/03/21  11:35:29  root
# changed fields: Status  Fixed In Baseline   new/changed/deleted note(s) [white_r 03/21/96 public]
# 
# Revision 1.4  95/11/02  14:30:15  root
# changed fields:  new/changed/deleted note(s) [trant 11/01/95 public]
# 
# Revision 1.3  95/11/02  12:43:30  root
# changed fields:  new/changed/deleted note(s) [psn 11/2/95 public]
# 
# Revision 1.2  95/11/01  18:46:43  root
# changed fields:  new/changed/deleted note(s) [trant 11/01/95 public]
# 
# Revision 1.1  95/10/31  14:45:48  root
# new CR
# 
+  * Revision /main/HPDCE02/3  1995/07/20  20:18 UTC  cuti
+  *    Initialize uninitized varaible unveil by  compiling with +O2
+  *
+  * Revision /main/HPDCE02/cuti_mothra10_fix/2  1995/07/19  17:34 UTC  cuti
+  *    CHFts15455
+  *
+  * Revision /main/HPDCE02/cuti_mothra10_fix/1  1995/07/19  13:41 UTC  cuti
+  *    CHFts15455: Initialize unintialized variables unveil by +O2
+  *
   * Revision /main/HPDCE02/2  1995/05/19  16:43 UTC  jrr
   *    Merge work for CHFts15152.
   *
***************
*** 396,402 ****
    )
  {
      error_status_t      st;
!     void              **thread_status;
      int                       i;
      pthread_t           listener_handle;
      aud_esl_type_t      esl_type;
--- 405,412 ----
    )
  {
      error_status_t      st;
! /*    unsigned32          thread_status;  */
!     pthread_addr_t      thread_status;
      int                       i;
      pthread_t           listener_handle;
      aud_esl_type_t      esl_type;
***************
*** 770,776 ****
                  dce_aud_set_trail_size_limit(central_trail, trail_size, &st);

          /* Wait for thread to terminate */
!         if (pthread_join(listener_handle, thread_status) == -1) {
            dce_svc_printf(AUD_S_DMN_THREAD_JOIN_LISTENER_MSG, server_name);
          }

--- 780,786 ----
                  dce_aud_set_trail_size_limit(central_trail, trail_size, &st);

          /* Wait for thread to terminate */
!         if (pthread_join(listener_handle, &thread_status) == -1) {
            dce_svc_printf(AUD_S_DMN_THREAD_JOIN_LISTENER_MSG, server_name);
          }

*** /vob/dce/src/security/audit/auditd/dmn_rpc_manager.c@@/main/13      Thu Sep 29 20:23:26 1994
--- /vob/dce/src/security/audit/auditd/dmn_rpc_manager.c@@/main/HPDCE02/1       Thu Jun  8 19:18:31 1995
***************
*** 9,14 ****
--- 9,18 ----
  /*
   * HISTORY
   * $Log:	c013177,v $
# Revision 1.6  96/09/30  16:40:15  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
# Revision 1.5  96/03/21  11:35:29  root
# changed fields: Status  Fixed In Baseline   new/changed/deleted note(s) [white_r 03/21/96 public]
# 
# Revision 1.4  95/11/02  14:30:15  root
# changed fields:  new/changed/deleted note(s) [trant 11/01/95 public]
# 
# Revision 1.3  95/11/02  12:43:30  root
# changed fields:  new/changed/deleted note(s) [psn 11/2/95 public]
# 
# Revision 1.2  95/11/01  18:46:43  root
# changed fields:  new/changed/deleted note(s) [trant 11/01/95 public]
# 
# Revision 1.1  95/10/31  14:45:48  root
# new CR
# 
+  * Revision /main/HPDCE02/1  1995/06/08  23:18 UTC  jrr
+  *    Fix memory leak by using correct alloc/free for IDL es.
+  *    [1995/06/08  23:16 UTC  jrr  /main/jrr_sec_chfts15431/1]
+  *
   * Revision 1.1.2.18  1994/09/29  21:33:03  weisz
   *    CR 12304: check for disabled state if in selfaudit mode.
   *    [1994/09/29  21:32:30  weisz]
***************
*** 113,118 ****
--- 117,123 ----
  #include <error_statusp.h>
  #include <dmn_aud_evtsp.h>
  #include <esl_filep.h>
+ #include <audit_alloc.h>

  extern boolean32 debug_mode;

***************
*** 1008,1022 ****
                  /* [out] */ error_status_t * stp
  )
  {
!     idl_es_handle_t es_h;
!     idl_byte       *ep;
!     idl_ulong_int   esize;
!     boolean32       authz_ok;
!     unsigned32      authn_level, authn_svc, authz_svc;
!     error_status_t  lstp = 0;
      rpc_authz_cred_handle_t     callers_identity;
      sec_cred_pa_handle_t        pah;
      sec_id_pa_t                 *cred;

      CLEAR_STATUS(stp);

--- 1013,1028 ----
                  /* [out] */ error_status_t * stp
  )
  {
!     idl_es_handle_t             es_h;
!     idl_byte                    *ep;
!     idl_ulong_int               esize;
!     boolean32                   authz_ok;
!     unsigned32                  authn_level, authn_svc, authz_svc;
!     error_status_t              lstp = 0;
      rpc_authz_cred_handle_t     callers_identity;
      sec_cred_pa_handle_t        pah;
      sec_id_pa_t                 *cred;
+     boolean32                   enabled_allocator;

      CLEAR_STATUS(stp);

***************
*** 1057,1064 ****
      header_info->server = cred->principal.uuid;

      idl_es_encode_dyn_buffer(&ep, &esize, &es_h, stp);
      audit_pickle_dencode_ev_info(es_h, header_info, tail_info, stp);
!     if (BAD_STATUS(stp)) return;
  #ifdef DCE_DEBUG
      DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
                     "pickle size = %ld\n", esize));
--- 1063,1078 ----
      header_info->server = cred->principal.uuid;

      idl_es_encode_dyn_buffer(&ep, &esize, &es_h, stp);
+
+     AUD_SET_ALLOC_FREE(enabled_allocator);
      audit_pickle_dencode_ev_info(es_h, header_info, tail_info, stp);
!
!     if (BAD_STATUS(stp)) {
!         idl_es_handle_free(&es_h, stp);
!         AUD_RESET_ALLOC_FREE(enabled_allocator, ep);
!         return;
!     }
!
  #ifdef DCE_DEBUG
      DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
                     "pickle size = %ld\n", esize));
***************
*** 1066,1073 ****
                     "pickle address = %ld\n", ep));
  #endif
      aud_trl_file_write(central_trail, ep, esize, options, &lstp);
      idl_es_handle_free(&es_h, stp);
!     rpc_sm_client_free(ep, stp);
      if (BAD_STATUS(stp)) {
        dce_svc_printf(AUD_S_FREE_ENCODING_SERVICE_HANDLE_MSG);
      }
--- 1080,1089 ----
                     "pickle address = %ld\n", ep));
  #endif
      aud_trl_file_write(central_trail, ep, esize, options, &lstp);
+     AUD_RESET_ALLOC_FREE(enabled_allocator, ep);
+
      idl_es_handle_free(&es_h, stp);
!
      if (BAD_STATUS(stp)) {
        dce_svc_printf(AUD_S_FREE_ENCODING_SERVICE_HANDLE_MSG);
      }

[11/01/95 public]
For the first memory leak in dmn_main.c, we should fix it.  For the
second one in dmn_rpc_manager.c, I would like to know how the  
following MACRO (???) define:

  AUD_SET_ALLOC_FREE
  AUD_RESET_ALLOC_FREE

[11/2/95 public]
They are in a new file called audit_alloc.h as defined below:

#define AUD_SET_ALLOC_FREE(ea) {                        \
    volatile rpc_ss_thread_handle_t      thread_handle; \
    TRY                                                 \
        thread_handle = rpc_ss_get_thread_handle();     \
    CATCH(pthread_badparam_e);                          \
        thread_handle = NULL;                           \
    ENDTRY;                                             \
    if (thread_handle == NULL) {                        \
        ea = idl_true;                                  \
        rpc_ss_enable_allocate();                       \
    }                                                   \
    else                                                \
        ea = idl_false;                                 \
}

#define AUD_RESET_ALLOC_FREE(ea, data) {                \
    error_status_t st;                                  \
    if (ea)                                             \
        rpc_ss_disable_allocate();                      \
    else                                                \
        rpc_sm_client_free(data, &st);                  \
}

[11/01/95 public]
Reviewed.  Please include this fix in the next merge.  Thanks.

[03/21/96 public]
Fix included in DCE 1.2.1 code. Closed with IBM agreement.

[09/30/96 public]
Fix included in DCE 1.1 Maintenance code.

./security/audit/auditd/dmn_main.c
Comparing revision 1.1.10.1 with revision 1.1.10.2.
*** 1.1.10.1    1995/02/16 22:03:33
--- 1.1.10.2    1996/09/30 17:34:50
***************
*** 9,18 ****
  /*
   * HISTORY
   * $Log:	c013177,v $
# Revision 1.6  96/09/30  16:40:15  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
   * Revision 1.1.10.1  1995/02/16  22:03:33  levy
   *    Submission of 1.1 unintegrated.
   *    [1995/02/16  20:42:29  levy]
!  *
   * Revision 1.1.8.1  1994/10/20  14:17:30  weisz
   *    CR 12677: if not in selfaudit mode, use correct flag in dce_aud_open.
   *    [1994/10/20  14:16:46  weisz]
--- 9,22 ----
  /*
   * HISTORY
   * $Log:	c013177,v $
# Revision 1.6  96/09/30  16:40:15  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
+  * Revision 1.1.10.2  1996/09/30  17:34:50  mariko
+  *    OT 13177: Fix memory leak and minor code cleanup
+  *    [1996/09/30  17:34:10  mariko]
+  *
   * Revision 1.1.10.1  1995/02/16  22:03:33  levy
   *    Submission of 1.1 unintegrated.
   *    [1995/02/16  20:42:29  levy]
!  * 
   * Revision 1.1.8.1  1994/10/20  14:17:30  weisz
   *    CR 12677: if not in selfaudit mode, use correct flag in dce_aud_open.
   *    [1994/10/20  14:16:46  weisz]
***************
*** 340,346 ****
    )
  {
      error_status_t      st;
!     void              **thread_status;
      int                       i;
      pthread_t           listener_handle;
      aud_esl_type_t      esl_type;
--- 344,350 ----
    )
  {
      error_status_t      st;
!     pthread_addr_t      thread_status;                /* OT13177 */
      int                       i;
      pthread_t           listener_handle;
      aud_esl_type_t      esl_type;
***************
*** 658,664 ****
                  dce_aud_set_trail_size_limit(central_trail, trail_size, &st);
          
          /* Wait for thread to terminate */
!         if (pthread_join(listener_handle, thread_status) == -1) {
            dce_svc_printf(AUD_S_DMN_THREAD_JOIN_LISTENER_MSG, server_name);
          }
          
--- 662,669 ----
                  dce_aud_set_trail_size_limit(central_trail, trail_size, &st);
          
          /* Wait for thread to terminate */
!       /* OT13177:  thread_status changed to pthread_addr_t */
!         if (pthread_join(listener_handle, &thread_status) == -1) {
            dce_svc_printf(AUD_S_DMN_THREAD_JOIN_LISTENER_MSG, server_name);
          }
          

./security/audit/auditd/dmn_rpc_manager.c
Comparing revision 1.1.4.2 with revision 1.1.4.3.
*** 1.1.4.2     1996/01/27 16:17:01
--- 1.1.4.3     1996/09/30 17:34:51
***************
*** 9,19 ****
  /*
   * HISTORY
   * $Log:	c013177,v $
# Revision 1.6  96/09/30  16:40:15  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
   * Revision 1.1.4.2  1996/01/27  16:17:01  dlynch
   *    Fix CR OT 13120.  Changed auth info to pkt integrity from
   *    pkt privacy.
   *    [1996/01/27  16:16:25  dlynch]
!  *
   * Revision 1.1.4.1  1995/10/07  00:24:14  parul
   *    Fix OT 13024: need sec_rgy_site_close() on error
   *    [1995/10/07  00:23:24  parul]
--- 9,23 ----
  /*
   * HISTORY
   * $Log:	c013177,v $
# Revision 1.6  96/09/30  16:40:15  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
+  * Revision 1.1.4.3  1996/09/30  17:34:51  mariko
+  *    OT 13177: Fix memory leak and minor code cleanup
+  *    [1996/09/30  17:34:21  mariko]
+  *
   * Revision 1.1.4.2  1996/01/27  16:17:01  dlynch
   *    Fix CR OT 13120.  Changed auth info to pkt integrity from
   *    pkt privacy.
   *    [1996/01/27  16:16:25  dlynch]
!  * 
   * Revision 1.1.4.1  1995/10/07  00:24:14  parul
   *    Fix OT 13024: need sec_rgy_site_close() on error
   *    [1995/10/07  00:23:24  parul]
***************
*** 122,127 ****
--- 126,132 ----
  #include <error_statusp.h>
  #include <dmn_aud_evtsp.h>
  #include <esl_filep.h>
+ #include <audit_alloc.h>              /* OT13177 */
  
  extern boolean32 debug_mode;
  
***************
*** 1038,1043 ****
--- 1043,1049 ----
      rpc_authz_cred_handle_t     callers_identity;
      sec_cred_pa_handle_t        pah;
      sec_id_pa_t                 *cred;
+     boolean32                 enabled_allocator;
  
      CLEAR_STATUS(stp);
  
***************
*** 1084,1091 ****
      header_info->server = cred->principal.uuid;
  
      idl_es_encode_dyn_buffer(&ep, &esize, &es_h, stp);
      audit_pickle_dencode_ev_info(es_h, header_info, tail_info, stp);
!     if (BAD_STATUS(stp)) return;
  #ifdef DCE_DEBUG
      DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
                     "pickle size = %ld\n", esize));
--- 1090,1106 ----
      header_info->server = cred->principal.uuid;
  
      idl_es_encode_dyn_buffer(&ep, &esize, &es_h, stp);
+ 
+     /* OT13177:  fix memory leak */
+     AUD_SET_ALLOC_FREE(enabled_allocator);
      audit_pickle_dencode_ev_info(es_h, header_info, tail_info, stp);
! 
!     if (BAD_STATUS(stp)) {
!       idl_es_handle_free(&es_h, stp);
!       AUD_RESET_ALLOC_FREE(enabled_allocator, ep);
!       return;
!     }
! 
  #ifdef DCE_DEBUG
      DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
                     "pickle size = %ld\n", esize));
***************
*** 1093,1100 ****
                     "pickle address = %ld\n", ep));
  #endif
      aud_trl_file_write(central_trail, ep, esize, options, &lstp);
      idl_es_handle_free(&es_h, stp);
!     rpc_sm_client_free(ep, stp);
      if (BAD_STATUS(stp)) {
        dce_svc_printf(AUD_S_FREE_ENCODING_SERVICE_HANDLE_MSG);
      }
--- 1108,1119 ----
                     "pickle address = %ld\n", ep));
  #endif
      aud_trl_file_write(central_trail, ep, esize, options, &lstp);
+ 
+     /* OT13177:  fix memory leak */
+     AUD_RESET_ALLOC_FREE(enabled_allocator, ep);
+ 
      idl_es_handle_free(&es_h, stp);
! 
      if (BAD_STATUS(stp)) {
        dce_svc_printf(AUD_S_FREE_ENCODING_SERVICE_HANDLE_MSG);
      }


./security/audit/h/audit_alloc.h
Comparing revision 1.1 with revision 1.1.6.1.
*** 1.1 1990/01/01 00:00:00
--- 1.1.6.1     1996/09/30 17:34:52
***************
*** 0 ****
--- 1,53 ----
+ /*
+  * @OSF_COPYRIGHT@
+  * COPYRIGHT NOTICE
+  * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1996 Open Software Foundation, Inc.
+  * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE in the
+  * src directory for the full copyright text.
+  *
+  */
+ /*
+  * HISTORY
+  * $Log:	c013177,v $
# Revision 1.6  96/09/30  16:40:15  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
+  * Revision 1.1.6.1  1996/09/30  17:34:52  mariko
+  *    OT 13177: Fix memory leak and minor code cleanup
+  *    [1996/09/30  17:33:19  mariko]
+  *
+  * Revision 1.1.2.2  1996/02/18  22:57:32  marty
+  *    Update OSF copyright years
+  *    [1996/02/18  22:16:25  marty]
+  * 
+  * Revision 1.1.2.1  1995/12/08  17:39:44  root
+  *    Submit OSF/DCE 1.2.1
+  *    [1995/12/08  17:17:49  root]
+  * 
+  * $EndLog$
+  */
+ 
+ #ifndef _AUDIT_ALLOC_H
+ #define _AUDIT_ALLOC_H
+ 
+ #define AUD_SET_ALLOC_FREE(ea) {                        \
+     volatile rpc_ss_thread_handle_t      thread_handle; \
+     TRY                                                 \
+         thread_handle = rpc_ss_get_thread_handle();     \
+     CATCH(pthread_badparam_e);                          \
+         thread_handle = NULL;                           \
+     ENDTRY;                                             \
+     if (thread_handle == NULL) {                        \
+         ea = idl_true;                                  \
+         rpc_ss_enable_allocate();                       \
+     }                                                   \
+     else                                                \
+         ea = idl_false;                                 \
+ }
+ 
+ #define AUD_RESET_ALLOC_FREE(ea, data) {                \
+     error_status_t st;                                  \
+     if (ea)                                             \
+         rpc_ss_disable_allocate();                      \
+     else                                                \
+         rpc_sm_client_free(data, &st);                  \
+ }
+ 
+ #endif



CR Number                     : 13176
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : Register a well-known object UUID in the namespace.
Reported Date                 : 10/31/95
Found in Baseline             : 1.1
Found Date                    : 10/31/95
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : auditd/dmn_main.c
Sensitivity                   : public

[10/31/95 public]

When auditd comes up it registers object uuid that is created randomly.
So when it does not shutdown gracefully and the namespace entry is not
cleaned properly, it collects many object uuids that are not valid any more
and thus causes failures in client picking incorrect object id's. Here is
the diff that IBM should review and inform us if they have changes they
would like:

*** /vob/dce/src/security/audit/auditd/dmn_main.c@@/main/HPDCE02/3      Thu Jul 20 16:18:14 1995
--- /vob/dce/src/security/audit/auditd/dmn_main.c@@/main/HPDCE02/4      Thu Aug 17 15:53:20 1995
***************
*** 9,14 ****
--- 9,18 ----
  /*
   * HISTORY
   * $Log:	c013176,v $
# Revision 1.3  95/12/13  14:21:35  root
# changed fields: Status  Fixed In Baseline   new/changed/deleted note(s) [white_r 12/13/95 public]
# 
# Revision 1.2  95/11/01  12:16:28  root
# changed fields:  new/changed/deleted note(s) [trant 11/01/95 public]
# 
# Revision 1.1  95/10/31  14:39:58  root
# new CR
# 
+  * Revision /main/HPDCE02/4  1995/08/17  19:53 UTC  jrr
+  *    Register a well-known object UUID in the namespace.
+  *    [1995/08/16  14:39 UTC  jrr  /main/HPDCE02/jrr_dcecp_01/1]
+  *
   * Revision /main/HPDCE02/3  1995/07/20  20:18 UTC  cuti
   *    Initialize uninitized varaible unveil by  compiling with +O2
   *
***************
*** 225,230 ****
--- 229,239 ----
                                  (void **) dmn_esl_cell_overridable
  };

+ static uuid_t aud_g_object_uuid = { /* 86576546-d7d3-11ce-a9b3-08000992d971 */
+                                     0x86576546, 0xd7d3, 0x11ce, 0xa9, 0xb3,
+                                     { 0x08, 0x00, 0x09, 0x92, 0xd9, 0x71 }
+ };
+
  aud_esl_guides_p_t aud_g_dmn_world_guides = NULL;
  aud_esl_guides_p_t aud_g_dmn_world_overridable_guides = NULL;

***************
*** 416,422 ****
      char               *hostname;
      char               *locale;
      uuid_vector_t       ns_export_uuid_vector;
-     uuid_t              my_object_uuid;
      unsigned32                stostrategy = 0;
      char             *working_dir;
      char              audit_export_name[NAME_BUF_SIZE];
--- 425,430 ----
***************
*** 679,687 ****
        dce_cf_get_host_name(&hostname, &st);
          sprintf(audit_export_name, "/.:/%s/%s", hostname, AUD_DIRECTORY_NAME);

-       uuid_create(&my_object_uuid, &st);
        ns_export_uuid_vector.count = 1;
!       ns_export_uuid_vector.uuid[0] = &my_object_uuid;

          /* Export acl manager interface */
        acl_register_if(audit_export_name, bindings,
--- 687,694 ----
        dce_cf_get_host_name(&hostname, &st);
          sprintf(audit_export_name, "/.:/%s/%s", hostname, AUD_DIRECTORY_NAME);

        ns_export_uuid_vector.count = 1;
!         ns_export_uuid_vector.uuid[0] = &aud_g_object_uuid;

          /* Export acl manager interface */
        acl_register_if(audit_export_name, bindings,

[11/01/95 public]
I think this is the best solution to solve uuid's problem when auditd daemon is killed abnormally.
Although we can implement an exception handler routine to clean up the previous UUID, kill -9 <pid>
is not catchable signal.  Therefore, exception handler is not the best solution. Please support the 
fix in the next merge.

[12/13/95 public]
Fixed in DCE 1.2.1
Closed



CR Number                     : 13157
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : "diff"dce_aud_get_evt_info() causes a trap
Reported Date                 : 10/19/95
Found in Baseline             : 1.1
Found Date                    : 10/19/95
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : evt_read.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/19/95 public]
We at IBM discovered that when an event record does not contain
any tail information (info items), the following line in 
dce_aud_get_ev_info() would cause a core dump. 

 if (ard->tail_read_cursor > ard->tail->ietm_count)

[10/19/95 public]
A check is added to insure the field can be accessable.  The diff
file and the new version of evt_read.c are also found in
/afs/dce.osf.org/project/dce/ibm/audit.

1) The diff file for evt_read.c:

430a431,435
>     if (ard->tail == NULL) {
>         *ev_info = NULL;
>         return;
>     }
>

[7/18/96 public]
Fixed in DCE1.2.2 (BL03).



CR Number                     : 13139
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : "diff" pthread is not destroyed
Reported Date                 : 10/3/95
Found in Baseline             : 1.1
Found Date                    : 10/3/95
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : trl_ops.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/3/95 public]
Mutex is not destroyed in dce_aud_close().

[10/4/95 public]
Fixed.  The diff file and the new versions of trl_ops.c are
also found in /afs/dce.osf.org/project/dce/ibm/audit

422a423,427
>
>     /* destroy the mutex */
>     pthread_mutex_destroy(&at->mutex);
>     pthread_mutex_destroy(&esl_mutex);
>

[12/5/95 public]

Fixed as proposed above.

[02/07/96 public]
According to the Application Development Reference version 1.1, 
"the results of this routine are unpredictable if the mutex object
specified in the mutex parameter does not currently exist", I think 
my previous proposed solution would be better if we destroy it ONLY 
it exists, i.e:

422a423,429
>
>     /* destroy the mutex */
>     if (at->mutex.mtx_id != 0)
>       pthread_mutex_destroy(&at->mutex);
>     if (esl_mutex.mtx_id != 0)
>       pthread_mutex_destroy(&esl_mutex);
>

[7/18/96 public]
Fixed in DCE1.2.2 (BL03).

[09/30/96 public]
Fixed again in 1.1 maintenance tree.

./security/audit/libaudit/trl_ops.c
Comparing revision 1.1.6.3 with revision 1.1.6.4.
*** 1.1.6.3     1996/09/30 14:00:05
--- 1.1.6.4     1996/09/30 14:14:04
***************
*** 9,18 ****
  /*
   * HISTORY
   * $Log:	c013139,v $
# Revision 1.7  96/09/30  18:57:37  root
# changed fields:  new/changed/deleted note(s) [mariko 09/30/96 public]
# 
   * Revision 1.1.6.3  1996/09/30  14:00:05  mariko
   *    OT 13311  Audit Trail needs to be opened in binary mode
   *    [1996/09/30  13:58:44  mariko]
!  *
   * Revision 1.1.6.2  1996/01/27  16:12:37  dlynch
   *    CR OT 13120 - changed auth info from pkt privacy to
   *    pkt integrity.
--- 9,22 ----
  /*
   * HISTORY
   * $Log:	c013139,v $
# Revision 1.7  96/09/30  18:57:37  root
# changed fields:  new/changed/deleted note(s) [mariko 09/30/96 public]
# 
+  * Revision 1.1.6.4  1996/09/30  14:14:04  mariko
+  *    OT 13139:  Destroy pthreads only when it exists
+  *    [1996/09/30  14:13:42  mariko]
+  *
   * Revision 1.1.6.3  1996/09/30  14:00:05  mariko
   *    OT 13311  Audit Trail needs to be opened in binary mode
   *    [1996/09/30  13:58:44  mariko]
!  * 
   * Revision 1.1.6.2  1996/01/27  16:12:37  dlynch
   *    CR OT 13120 - changed auth info from pkt privacy to
   *    pkt integrity.
***************
*** 114,119 ****
--- 118,126 ----
  
  boolean32 aud_g_cli_audit_on = TRUE;
  boolean32 aud_g_cli_filter_on = FALSE;
+ boolean32 at_mutex_created    = FALSE;                /* OT13139 */
+ boolean32 esl_mutex_created   = FALSE;                /* OT13139 */
+ 
  aud_esl_guides_p_t aud_g_cli_world_guides = NULL;
  aud_esl_guides_p_t aud_g_cli_world_overridable_guides = NULL;
  static aud_esl_entry_p_t cli_esl_princ[HASH_TABLE_SIZE];
***************
*** 311,316 ****
--- 318,324 ----
                *stp = aud_s_cannot_init_trail_mutex;
                return;
            }
+           at_mutex_created = TRUE;            /* OT 13139 */
        }
        (*at)->flags = flags;
      }
***************
*** 358,363 ****
--- 366,375 ----
        dce_printf(aud_s_client_esl_mutex);
        *stp = aud_s_client_esl_mutex;
      }
+     else
+     {
+       esl_mutex_created = TRUE;       /* OT 13139 */
+     }
      /*  init_update_module(); */
      register_update_interface(stp);
  }
***************
*** 434,442 ****
      if (at->auditd_binding != NULL)
        rpc_binding_free(&(at->auditd_binding), status);
  
!     /* destroy the mutex */
!     pthread_mutex_destroy(&at->mutex);
!     pthread_mutex_destroy(&esl_mutex);
  
      free(at);
      unregister_update_interface(status);
--- 446,460 ----
      if (at->auditd_binding != NULL)
        rpc_binding_free(&(at->auditd_binding), status);
  
!     /* OT 13139: destroy the mutexes if they were created */
!     if (at_mutex_created) {
!       pthread_mutex_destroy(&at->mutex);
!       at_mutex_created = FALSE;
!     }
!     if (esl_mutex_created) {
!       pthread_mutex_destroy(&esl_mutex);
!       esl_mutex_created = FALSE;
!     }
  
      free(at);
      unregister_update_interface(status);



CR Number                     : 13119
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 10442
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : auditd cntrl interface incompatible with DES export restrictions
Reported Date                 : 9/12/95
Found in Baseline             : 1.1
Found Date                    : 9/12/95
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1, 1.1maint
Affected File(s)              : security/audit/auditd/dmn_rpc_manager.c,..audit/libaudit/trl_ops.c,admin/dcecp/aud_util.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/12/95 public]

Full Description:

If you build the rpc runtime with NOENCRYPTION, which you
must do to export DCE, you cannot control auditd with dcecp.
This is because auditd demands packet privacy be used on it
control interface.

Repeat By:

Build DCE for export and try to do 'dcecp aud show'

Proposed Solution:

Depending on whether or not you want to allow domestic audit servers to
be controlled by non-des capable dcecp sessions, then you could modify
audit in one of two ways.

1. if you only want audit to be controllable by non-des capable dcecp
   sessions only in environments where des is not permitted, then you
   should modify the rpc_binding_inq_auth_.. calls of audit to be more
   lenient in non-des installations of DCE (conditional compilation based
   on USE_DES being undefined).

2. If you wish to allow audit to be controllable by non-des capable
   dcecp clients within cells where auditd is des capable, then you
   may want to modify the rpc_binding_inq_auth_.. calls such that
   either packet integrity or packet privacy is acceptable independent
   of the des capabilities of the DCE installation.

The proposed solution assumes that method 1 is desired. It is trivial to
change the solution to implement method 2 if that is suitable.

*** dmn_rpc_manager.c   Thu Sep 29 17:33:04 1994
--- /tmp/x      Tue Sep 12 17:53:21 1995
***************
*** 142,147 ****
--- 142,168 ----
  #define OUTPUT_RPC_COUNT
  #endif
  
+ #ifndef USE_DES
+    rpc_binding_inq_auth_client(h, &privs, NULL, &authn_level, \
+                                &authn_svc, &authz_svc, stp); \
+    if (GOOD_STATUS(stp)) { \
+       if (((authn_level != rpc_c_protect_level_pkt_privacy) && \
+            (authn_level != rpc_c_protect_level_pkt_integ)) || \
+            (authz_svc != rpc_c_authz_dce)) { \
+          dce_svc_printf(AUD_S_WRONG_PROTECTION_LEVEL_MSG); \
+          *stp = aud_s_wrong_protection_level; \
+          return; \
+       } \
+       if (audit) { \
+          dce_aud_start(event, h, aud_c_evt_all_info, \
+                        aud_c_esl_cond_unknown, &ard, stp); \
+          if (BAD_STATUS(stp)) return; \
+       } \
+    } else { \
+         dce_svc_printf(AUD_S_CANNOT_AUTHENTICATE_MSG); \
+         return; \
+    }
+ #else
  #define CHECK_AUDIT_SECURITY(event) \
     rpc_binding_inq_auth_client(h, &privs, NULL, &authn_level, \
                                 &authn_svc, &authz_svc, stp); \
***************
*** 161,166 ****
--- 182,188 ----
          dce_svc_printf(AUD_S_CANNOT_AUTHENTICATE_MSG); \
          return; \
     }
+ #endif
  
  #define CHECK_AUTHORIZATION(func) \
      func(h, &authz_ok, stp); \
***************
*** 1023,1030 ****
--- 1045,1058 ----
      rpc_binding_inq_auth_caller(h, &callers_identity, NULL, &authn_level,
                                &authn_svc, &authz_svc, stp);
      if (GOOD_STATUS(stp)) {
+ #ifndef USE_DES
+        if (((authn_level == rpc_c_protect_level_pkt_privacy) ||
+             (authn_level == rpc_c_protect_level_pkt_integ)) &
+             (authz_svc == rpc_c_authz_dce)) {
+ #else
        if ((authn_level == rpc_c_protect_level_pkt_privacy) &
            (authz_svc == rpc_c_authz_dce)) {
+ #endif
        } else {
            dce_svc_printf(AUD_S_WRONG_PROTECTION_LEVEL_MSG);
            *stp = aud_s_wrong_protection_level;

[9/20/95 public]

I adding this problem seen at fujitsu, and reported maintainance
ticket 21910.  I am not sure, though, as customer has not responded
to the question if he built without encryption.

Client is configuring a mixed environment DCE1.0.3 DCE1.1 cell, so
initially I thought that was the problem, but could not find any
issue, with it.

> 
> ----------------------------------------------------------------------------
>          Additional Server Configuration ( on C	)
> 
> 
>          1. Additional CDS Server(s)
>          2. DTS
>          3. GDA Server
>          4. Replica Security Server
>          5. Auditing
>          6. Password Management Server
>          7. Unconfigure Password Management Server
> 
> 
>         98. Return to previous menu
>         99. Exit
> 
> 
> 
>         selection:  5
> S:****** Configuring Audit...
> S:****** Creating default filters for security, dts, and audit.
> 1995-08-07-15:26:54.668+09:00I----- auditd ERROR aud general
> dmn_rpc_manager.c
>  527 0x00077be8
> Client has no permission to execute operation
> Error: Client has no permission to execute operation
> 1995-08-07-15:26:57.246+09:00I----- auditd ERROR aud general
> dmn_rpc_manager.c
>  527 0x00077be8
> .......
> Client has no permission to execute operation
> Bus Error - core dumped
>

[10/31/95 public]

Here is HP's fix that IBM needs to review:

These source files were affected:

./security/audit/auditd/dmn_rpc_manager.c
./security/audit/libaudit/trl_ops.c
./admin/dcecp/aud_util.c

./security/audit/auditd/dmn_rpc_manager.c

11a12,18
>  * Revision /main/HPDCE02/3  1995/08/18  19:53 UTC  kline_s
>  *    Merge fix for CHFts16115
>  *    Fix international release audit test problems in using rpc_c_authn_level_pkt_privacy
>  *    as the level of protection for the rpc_binding_set/_auth_info() and
>  *    rpc_binding_inq_auth_client() calls.  This uses DES encryption, which is not supported
>  *    in the international version.
>  *
144a152,156
> /*
>  * For international (ie. non-DES) releases, check for a less strict,
>  * non-encrypted protection level in rpc_binding_inq_auth_client():
>  */
>
149c161
<       if ((authn_level != rpc_c_protect_level_pkt_privacy) || \
---
>       if ((authn_level != rpc_c_protect_level_pkt_integ) || \
1026c1038
<       if ((authn_level == rpc_c_protect_level_pkt_privacy) &
---
>       if ((authn_level == rpc_c_protect_level_pkt_integ) &


./security/audit/libaudit/trl_ops.c
11a12,17
>  * Revision /main/HPDCE02/5  1995/08/18  19:53 UTC  kline_s
>  *    Merge fix for CHFts16115 - only use integrity
>  *    protection level instead of privacy protection level.
>  *    Required to avoid mix/match conflicts between clients
>  *    and servers due to DES export restrictions.
>  *
515c521
<                                 rpc_c_authn_level_pkt_privacy,
---
>                                 rpc_c_authn_level_pkt_integrity,


./admin/dcecp/aud_util.c
11a12,17
>  * Revision /main/HPDCE02/8  1995/08/18  19:53 UTC  kline_s
>  *    Merge fix for CHFts16115 - only use integrity
>  *    protection level instead of privacy protection level.
>  *    Required to avoid mix/match conflicts between clients
>  *    and servers due to DES export restrictions.
>  *
404c410
<                                   rpc_c_authn_level_pkt_privacy,
---
>                                   rpc_c_authn_level_pkt_integrity,

[11/01/95 public]
It seems to me that the proposed solution from HP is suitable and we 
would like to have it fix in the next merge.  Thanks.

[03/21/96 public]
Fix was included in DCE 1.2.1.  Closed with agreement of IBM.

[09/30/96 public]
The fix was made to the DCE 1,1 Maintenance tree as a part of OT13120.

[09/30/96 public]
Accidentally deleted 03/21/96 message.  Restored it.



CR Number                     : 13024
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : aud
Subcomponent Name             : auditd & libaudit
Short Description             : "diff" need sec_rgy_site_close() on error
Reported Date                 : 8/7/95
Found in Baseline             : 1.1wp
Found Date                    : 8/7/95
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : security/audit/auditd/{dmn_acl_mgr.c dmn_rpc_manager.c}, security/audit/libaudit/{evt_read.c evt_write.c}
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/7/95 public]

There are several places where sec_rgy_site_close() should be called upon
error condition detection, but before function return.

There exist a memory leak in evt_read.c where free() should be called upon
error condition detection, but before function return.

src/security/audit/auditd/dmn_acl_mgr.c,
***************
*** 160,165 ****
--- 160,166 ----
      uuid_t            hostuuid;
      uuid_t            groupuuid;
      sec_acl_permset_t   permset = (sec_acl_permset_t) 0;
+     error_status_t      tmp_st;

      /* Get some config info. */
      dce_cf_get_cell_name((char **)&cellname, st);
***************
*** 169,179 ****
      if (*st != error_status_ok)
        return;
      sec_id_parse_name(h, cellname, NULL,  &celluuid, NULL, NULL, st);
!     if (*st != error_status_ok)
        return;
      sec_id_parse_name(h, (unsigned_char_t *)auditd_identity, NULL,  NULL, host
prin, &hostuuid, st);
!     if (*st != error_status_ok)
        return;

      /*
       * Get the default audit server's group name.  Later on, if it has been
--- 170,184 ----
      if (*st != error_status_ok)
        return;
      sec_id_parse_name(h, cellname, NULL,  &celluuid, NULL, NULL, st);
!     if (*st != error_status_ok) {
!       sec_rgy_site_close(h, &tmp_st);
        return;
+     }
      sec_id_parse_name(h, (unsigned_char_t *)auditd_identity, NULL,  NULL, host
prin, &hostuuid, st);
!     if (*st != error_status_ok) {
!       sec_rgy_site_close(h, &tmp_st);
        return;
+     }

      /*
       * Get the default audit server's group name.  Later on, if it has been

src/security/audit/auditd/dmn_rpc_manager.c
***************
*** 214,219 ****
--- 214,220 ----
        sec_rgy_pgo_name_to_id(rgy_context, sec_rgy_domain_person,
                               subject_name, subject_uuid, stp);
        if (BAD_STATUS(stp)) {
+           sec_rgy_site_close( rgy_context , stp);
            *stp = aud_s_unknown_principal_rc;
            dce_svc_printf(AUD_S_UNKNOWN_PRINCIPAL_MSG, subject_name);
            return;
***************
*** 224,229 ****
--- 225,231 ----
        sec_id_parse_name(rgy_context, subject_name, cell_name, cell_uuid,
                          princ_name, subject_uuid, stp);
        if (BAD_STATUS(stp)) {
+           sec_rgy_site_close( rgy_context , stp);
            *stp = aud_s_unknown_foreign_principal_rc;
            dce_svc_printf(AUD_S_UNKNOWN_FOREIGN_PRINCIPAL_MSG, subject_name);
            return;
***************
*** 234,239 ****
--- 236,242 ----
        sec_rgy_pgo_name_to_id(rgy_context, sec_rgy_domain_group,
                               subject_name, subject_uuid, stp);
        if (BAD_STATUS(stp)) {
+           sec_rgy_site_close( rgy_context , stp);
            *stp = aud_s_unknown_group_rc;
            dce_svc_printf(AUD_S_UNKNOWN_GROUP_MSG, subject_name);
            return;
***************
*** 244,249 ****
--- 247,253 ----
        sec_id_parse_group(rgy_context, subject_name, cell_name, cell_uuid,
                           princ_name, subject_uuid, stp);
        if (BAD_STATUS(stp)) {
+           sec_rgy_site_close( rgy_context , stp);
            *stp = aud_s_unknown_foreign_group_rc;
            dce_svc_printf(AUD_S_UNKNOWN_FOREIGN_GROUP_MSG, subject_name);
            return;
***************
*** 255,260 ****
--- 259,265 ----
        sec_id_parse_name(rgy_context, subject_name, cell_name, subject_uuid,
                          princ_name, &princ_uuid, stp);
        if (BAD_STATUS(stp)) {
+           sec_rgy_site_close( rgy_context , stp);
            *stp = aud_s_unknown_cell_rc;
            dce_svc_printf(AUD_S_UNKNOWN_CELL_MSG, subject_name);
            return;
***************
*** 262,267 ****
--- 267,273 ----
        break;

      default:
+       sec_rgy_site_close( rgy_context , stp);
        *stp = aud_s_invalid_esl_type_rc;
        dce_svc_printf(AUD_S_INVALID_ESL_TYPE_MSG, esl_type);
        return;

src/security/audit/libaudit/evt_read.c
***************
*** 263,268 ****
--- 263,270 ----
                  sizeof(rec_start_pos), at->md_index_fp)
            != sizeof(rec_start_pos))
        {
+           if ( local_predicate != NULL ) free( orig_predicate );
+           if ( check_addr ) free( addr );
            *ard = NULL;
            *status = aud_s_ok;
            return;
***************
*** 271,276 ****
--- 273,280 ----
                if (fread((void *)&esize, sizeof(idl_byte), sizeof(esize),
                    at->md_index_fp) != sizeof(esize))
                {
+                   if ( local_predicate != NULL ) free( orig_predicate );
+                   if ( check_addr ) free( addr );
                    return;
                } else {
                    if (at->trail_cursor != rec_start_pos) {
***************
*** 293,298 ****
--- 297,304 ----
        dce_printf(aud_s_trail_file_corrupted, at->trail_file);
        *status = aud_s_trail_file_corrupted;
        free(ep);
+       if ( local_predicate != NULL ) free( orig_predicate );
+       if ( check_addr ) free( addr );
        return;
      }
      idl_es_decode_buffer(ep, esize, &h, status);
***************
*** 301,306 ****
--- 307,314 ----
        DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
            "dce_aud_next: idl_es_decode_buffer failed\n"));
  #endif
+       if ( local_predicate != NULL ) free( orig_predicate );
+       if ( check_addr ) free( addr );
        free(ep);
        return;
      }
***************
*** 307,313 ****
      *ard = (dce_aud_rec_t) malloc(sizeof(struct _dce_aud_rec_handle));
      if (*ard == NULL) {
          idl_es_handle_free(&h, status);
!         if (BAD_STATUS(status)) return;
        free(ep);
        dce_printf(aud_s_cannot_allocate_memory,
                sizeof(struct _dce_aud_rec_handle));
--- 315,327 ----
      *ard = (dce_aud_rec_t) malloc(sizeof(struct _dce_aud_rec_handle));
      if (*ard == NULL) {
          idl_es_handle_free(&h, status);
!         if (BAD_STATUS(status)) {
!           if ( local_predicate != NULL ) free( orig_predicate );
!           if ( check_addr ) free( addr );
!           return;
!       }
!       if ( local_predicate != NULL ) free( orig_predicate );
!       if ( check_addr ) free( addr );
        free(ep);
        dce_printf(aud_s_cannot_allocate_memory,
                sizeof(struct _dce_aud_rec_handle));
***************
*** 316,325 ****
      }
      (*ard)->as = NULL;
      audit_pickle_dencode_ev_info(h, &(*ard)->header, &(*ard)->tail, status);
!     if (BAD_STATUS(status)) return;

      idl_es_handle_free(&h, status);
!     if (BAD_STATUS(status)) return;

      free(ep);

--- 330,349 ----
      }
      (*ard)->as = NULL;
      audit_pickle_dencode_ev_info(h, &(*ard)->header, &(*ard)->tail, status);
!     if (BAD_STATUS(status)) {
!         if ( local_predicate != NULL ) free( orig_predicate );
!         if ( check_addr ) free( addr );
!         free(ep);
!         return;
!     }

      idl_es_handle_free(&h, status);
!     if (BAD_STATUS(status)) {
!         if ( local_predicate != NULL ) free( orig_predicate );
!         if ( check_addr ) free( addr );
!         free(ep);
!         return;
!     }

      free(ep);

***************
*** 366,371 ****
--- 390,398 ----
      DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
        "dce_aud_next: found a matching record\n"));
  #endif
+     if ( local_predicate != NULL ) free( orig_predicate );
+     if ( check_addr ) free( addr );
+
      (*ard)->tail_read_cursor = 0;
      *status = aud_s_ok;
      return;
***************
*** 579,584 ****
--- 606,612 ----
      sec_login_net_info_t net_info;
      boolean32       found = FALSE;
      own_id_t        *secondary_group_ptr, *temp_group_ptr;
+     unsigned32 tmp_status;

      if (ard == NULL) {
        *status = aud_s_invalid_record_descriptor;
***************
*** 617,626 ****
             if (!own_id_initialized)
             {
                sec_login_get_current_context(&login_context, status);
!               if (*status != error_status_ok) return;
                sec_login_inquire_net_info(login_context, &net_info, status);
!               if ((*status != error_status_ok)
!                  && (*status != sec_login_s_not_certified)) return;

                own_cell_uuid = net_info.pac.realm.uuid;

--- 645,662 ----
             if (!own_id_initialized)
             {
                sec_login_get_current_context(&login_context, status);
!               if (*status != error_status_ok) {
!                  sec_rgy_site_close( rgy_context, &tmp_status );
!                  free( strbuf );
!                  return;
!               }
                sec_login_inquire_net_info(login_context, &net_info, status);
!               if ((*status != error_status_ok)
!                  && (*status != sec_login_s_not_certified)) {
!                  sec_rgy_site_close( rgy_context, &tmp_status );
!                  free( strbuf );
!                  return;
!               }

                own_cell_uuid = net_info.pac.realm.uuid;

***************
*** 921,926 ****
--- 957,964 ----
      *buffer = (unsigned_char_t *) malloc(strlen(strbuf)+1);
      if (*buffer == NULL) {
        dce_printf(aud_s_cannot_allocate_memory, strlen(strbuf)+1);
+         sec_rgy_site_close(rgy_context, &tmp_status);
+         free(strbuf);
        *status = aud_s_cannot_allocate_memory;
        return;
      }

security/audit/libaudit/evt_write.c
***************
*** 417,422 ****
--- 417,423 ----
      uuid_t          princ_uuid, cell_uuid;
      sec_id_pac_t   *pac;
      unsigned32            lst;
+     unsigned32      tmp_status;


      *status = aud_s_ok;
***************
*** 432,437 ****
--- 433,439 ----
      sec_id_parse_name(rgy_context, client, cell_name, &cell_uuid, princ_name,
                      &princ_uuid, status);
      if (BAD_STATUS(status)) {
+       sec_rgy_site_close( rgy_context, &tmp_status );
        return;
      }
      pac = (sec_id_pac_t *) malloc(sizeof(sec_id_pac_t));
***************
*** 441,447 ****
      pac->num_groups = 0;

      dce_aud_start_with_pac(event, pac, address, options, outcome, ard, status)
;
!     if (BAD_STATUS(status)) return;
      if (*ard != NULL)
      {
         (*ard)->header.authz_st = rpc_c_authz_name;
--- 443,452 ----
      pac->num_groups = 0;

      dce_aud_start_with_pac(event, pac, address, options, outcome, ard, status)
;
!     if (BAD_STATUS(status)) {
!       sec_rgy_site_close( rgy_context, &tmp_status );
!       return;
!     }
      if (*ard != NULL)
      {
         (*ard)->header.authz_st = rpc_c_authz_name;
***************
*** 457,462 ****
--- 462,468 ----
        dce_aud_discard(*ard, &lst);
      }
   */
+     sec_rgy_site_close( rgy_context, &tmp_status );

      return;
  }

[10/4/95 public]
Fixed.  The diff files and the new versions of dmn_acl_mgr.c,
dmn_rpc_manager.c, evt_write.c, and evt_read.c are also
found in /afs/dce.osf.org/project/dce/ibm/audit subdir.

1) diff file for dmn_acl_mgr.c:

150a151
>     error_status_t      stp;
172c173,174
<     if (*st != error_status_ok)
---
>     if (*st != error_status_ok) {
>         sec_rgy_site_close(h, &stp);
173a176
>     }
175c178,179
<     if (*st != error_status_ok)
---
>     if (*st != error_status_ok) {
>         sec_rgy_site_close(h, &stp);
176a181
>     }

2) diff file for dmn_rpc_manger.c:

201a202
>     error_status_t  st;
216a218
>             sec_rgy_site_close(rgy_context, &st);
226a229
>             sec_rgy_site_close(rgy_context, &st);
236a240
>             sec_rgy_site_close(rgy_context, &st);
246a251
>             sec_rgy_site_close(rgy_context, &st);
257a263
>             sec_rgy_site_close(rgy_context, &st);
264a271
>         sec_rgy_site_close(rgy_context, &st);

3) diff file for evt_read.c:

265a266,269
>             if (local_predicate)
>                 free(orig_predicate);
>             if (check_addr)
>                 free(addr);
273a278,281
>                     if (local_predicate)
>                         free(orig_predicate);
>                     if (check_addr)
>                         free(addr);
295a304,307
>         if (local_predicate)
>             free(orig_predicate);
>         if (check_addr)
>             free(addr);
303a316,319
>         if (local_predicate)
>             free(orig_predicate);
>         if (check_addr)
>             free(addr);
310c326,336
<         if (BAD_STATUS(status)) return;
---
>         if (BAD_STATUS(status)) {
>             if (local_predicate)
>                 free(orig_predicate);
>             if (check_addr)
>                 free(addr);
>             return;
>         }
>         if (local_predicate)
>             free(orig_predicate);
>         if (check_addr)
>             free(addr);
319c345,352
<     if (BAD_STATUS(status)) return;
---
>     if (BAD_STATUS(status)) {
>         if (local_predicate)
>             free(orig_predicate);
>         if (check_addr)
>             free(addr);
>         free(ep);
>         return;
>     }
322c355,362
<     if (BAD_STATUS(status)) return;
---
>     if (BAD_STATUS(status)) {
>         if (local_predicate)
>             free(orig_predicate);
>         if (check_addr)
>             free(addr);
>         free(ep);
>         return;
>     }
368a409,412
>     if (local_predicate)
>         free(orig_predicate);
>     if (check_addr)
>         free(addr);
565a610
>     unsigned32      st;
620c665,669
<               if (*status != error_status_ok) return;
---
>               if (*status != error_status_ok) {
>                   sec_rgy_site_close(rgy_context, &st);
>                   free(strbuf);
>                   return;
>               }
623c672,676
<                  && (*status != sec_login_s_not_certified)) return;
---
>                  && (*status != sec_login_s_not_certified)) {
>                   sec_rgy_site_close(rgy_context, &st);
>                   free(strbuf);
>                   return;
>               }
923a977,978
>         sec_rgy_site_close(rgy_context, &st);
>         free(strbuf);

4) diff file for evt_write.c:

414a415
>     unsigned32     st;
434a436
>         sec_rgy_site_close(rgy_context, &st);
444c446,449
<     if (BAD_STATUS(status)) return;
---
>     if (BAD_STATUS(status)) {
>         sec_rgy_site_close(rgy_context, &st);
>         return;
>     }
459a465
>     sec_rgy_site_close(rgy_context, &st);
754c760,763
<             if (BAD_STATUS(status)) return;
---
>             if (BAD_STATUS(status)) {
>                 dce_aud_discard(ard, &st);
>                 return;
>             }

[10/6/95 public]

Following was submitted to the 1.1 maintenance code base. 

CAUTION: The above fix that 'trant' put out (which is also part of 1.2 fix in
         AFS cell) has unknowingly created few problems. Following code
         fixes that. To correct the bug replace 'unsigned32 *st' everywhere
         it was added in IBM fix, to 'unsigned32 st', i.e., make it a data
         store for status. And then replace 'st' in sec_* call by '&st'.

*** /project/dce/build/dce1.1-maint/src/security/audit/auditd/dmn_acl_mgr.c	Fri Aug 12 15:20:34 1994
--- security/audit/auditd/dmn_acl_mgr.c	Mon Aug 28 15:30:16 1995
***************
*** 160,165 ****
--- 160,166 ----
      uuid_t		hostuuid;
      uuid_t		groupuuid;
      sec_acl_permset_t   permset = (sec_acl_permset_t) 0;
+     error_status_t      tmp_st;
  
      /* Get some config info. */
      dce_cf_get_cell_name((char **)&cellname, st);
***************
*** 169,179 ****
      if (*st != error_status_ok)
  	return;
      sec_id_parse_name(h, cellname, NULL,  &celluuid, NULL, NULL, st);
!     if (*st != error_status_ok)
  	return;
      sec_id_parse_name(h, (unsigned_char_t *)auditd_identity, NULL,  NULL, hostprin, &hostuuid, st);
!     if (*st != error_status_ok)
  	return;
  
      /*
       * Get the default audit server's group name.  Later on, if it has been
--- 170,184 ----
      if (*st != error_status_ok)
  	return;
      sec_id_parse_name(h, cellname, NULL,  &celluuid, NULL, NULL, st);
!     if (*st != error_status_ok) {
!         sec_rgy_site_close(h, &tmp_st);
  	return;
+     }
      sec_id_parse_name(h, (unsigned_char_t *)auditd_identity, NULL,  NULL, hostprin, &hostuuid, st);
!     if (*st != error_status_ok) {
!         sec_rgy_site_close(h, &tmp_st);
  	return;
+     }
  
      /*
       * Get the default audit server's group name.  Later on, if it has been
 
*** /project/dce/build/dce1.1-maint/src/security/audit/auditd/dmn_rpc_manager.c	Thu Sep 29 17:33:04 1994
--- security/audit/auditd/dmn_rpc_manager.c	Fri Oct  6 19:41:04 1995
***************
*** 202,207 ****
--- 202,208 ----
      sec_rgy_handle_t rgy_context;
      sec_rgy_name_t  princ_name, cell_name;
      uuid_t          princ_uuid;
+     error_status_t  st;
  
      uuid_create_nil(cell_uuid, stp);
      uuid_create_nil(subject_uuid, stp);
***************
*** 214,219 ****
--- 215,221 ----
  	sec_rgy_pgo_name_to_id(rgy_context, sec_rgy_domain_person,
  			       subject_name, subject_uuid, stp);
  	if (BAD_STATUS(stp)) {
+             sec_rgy_site_close(rgy_context , &st);
  	    *stp = aud_s_unknown_principal_rc;
  	    dce_svc_printf(AUD_S_UNKNOWN_PRINCIPAL_MSG, subject_name);
  	    return;
***************
*** 224,229 ****
--- 226,232 ----
  	sec_id_parse_name(rgy_context, subject_name, cell_name, cell_uuid,
  			  princ_name, subject_uuid, stp);
  	if (BAD_STATUS(stp)) {
+             sec_rgy_site_close(rgy_context , &st);
  	    *stp = aud_s_unknown_foreign_principal_rc;
  	    dce_svc_printf(AUD_S_UNKNOWN_FOREIGN_PRINCIPAL_MSG, subject_name);
  	    return;
***************
*** 234,239 ****
--- 237,243 ----
  	sec_rgy_pgo_name_to_id(rgy_context, sec_rgy_domain_group,
  			       subject_name, subject_uuid, stp);
  	if (BAD_STATUS(stp)) {
+             sec_rgy_site_close(rgy_context , &st);
  	    *stp = aud_s_unknown_group_rc;
  	    dce_svc_printf(AUD_S_UNKNOWN_GROUP_MSG, subject_name);
  	    return;
***************
*** 244,249 ****
--- 248,254 ----
  	sec_id_parse_group(rgy_context, subject_name, cell_name, cell_uuid,
  			   princ_name, subject_uuid, stp);
  	if (BAD_STATUS(stp)) {
+             sec_rgy_site_close(rgy_context , &st);
  	    *stp = aud_s_unknown_foreign_group_rc;
  	    dce_svc_printf(AUD_S_UNKNOWN_FOREIGN_GROUP_MSG, subject_name);
  	    return;
***************
*** 255,260 ****
--- 260,266 ----
  	sec_id_parse_name(rgy_context, subject_name, cell_name, subject_uuid,
  			  princ_name, &princ_uuid, stp);
  	if (BAD_STATUS(stp)) {
+             sec_rgy_site_close(rgy_context , &st);
  	    *stp = aud_s_unknown_cell_rc;
  	    dce_svc_printf(AUD_S_UNKNOWN_CELL_MSG, subject_name);
  	    return;
***************
*** 262,267 ****
--- 268,274 ----
  	break;
  
      default:
+         sec_rgy_site_close(rgy_context , &st);
  	*stp = aud_s_invalid_esl_type_rc;
  	dce_svc_printf(AUD_S_INVALID_ESL_TYPE_MSG, esl_type);
  	return;
 
*** /project/dce/build/dce1.1-maint/src/security/audit/libaudit/evt_read.c	Thu Feb 16 16:57:13 1995
--- security/audit/libaudit/evt_read.c	Fri Oct  6 20:00:08 1995
***************
*** 267,272 ****
--- 267,276 ----
  		  sizeof(rec_start_pos), at->md_index_fp)
  	    != sizeof(rec_start_pos))
  	{
+             if (local_predicate)
+                 free(orig_predicate);
+             if (check_addr)
+                 free(addr);
  	    *ard = NULL;
  	    *status = aud_s_ok;
  	    return;
***************
*** 275,280 ****
--- 279,288 ----
  		if (fread((void *)&esize, sizeof(idl_byte), sizeof(esize), 
  		    at->md_index_fp) != sizeof(esize))
  		{
+                     if (local_predicate)
+                         free(orig_predicate);
+                     if (check_addr)
+                         free(addr);
  		    return;
  		} else {
  		    if (at->trail_cursor != rec_start_pos) {
***************
*** 297,302 ****
--- 305,314 ----
  	dce_printf(aud_s_trail_file_corrupted, at->trail_file);
  	*status = aud_s_trail_file_corrupted;
  	free(ep);
+         if (local_predicate)
+             free(orig_predicate);
+         if (check_addr)
+             free(addr);
  	return;
      }
      idl_es_decode_buffer(ep, esize, &h, status);
***************
*** 305,317 ****
  	DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
      	    "dce_aud_next: idl_es_decode_buffer failed\n"));
  #endif
  	free(ep);
  	return;
      }
      *ard = (dce_aud_rec_t) malloc(sizeof(struct _dce_aud_rec_handle));
      if (*ard == NULL) {
          idl_es_handle_free(&h, status);
!         if (BAD_STATUS(status)) return;
  	free(ep);
  	dce_printf(aud_s_cannot_allocate_memory, 
  		sizeof(struct _dce_aud_rec_handle));
--- 317,338 ----
  	DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
      	    "dce_aud_next: idl_es_decode_buffer failed\n"));
  #endif
+         if (local_predicate)
+             free(orig_predicate);
+         if (check_addr)
+             free(addr);
  	free(ep);
  	return;
      }
      *ard = (dce_aud_rec_t) malloc(sizeof(struct _dce_aud_rec_handle));
      if (*ard == NULL) {
          idl_es_handle_free(&h, status);
!         if (local_predicate)
!             free(orig_predicate);
!         if (check_addr)
!             free(addr);
!         if (BAD_STATUS(status))
!             return;
  	free(ep);
  	dce_printf(aud_s_cannot_allocate_memory, 
  		sizeof(struct _dce_aud_rec_handle));
***************
*** 320,329 ****
      }
      (*ard)->as = NULL;
      audit_pickle_dencode_ev_info(h, &(*ard)->header, &(*ard)->tail, status);
!     if (BAD_STATUS(status)) return;
  
      idl_es_handle_free(&h, status);
!     if (BAD_STATUS(status)) return;
  
      free(ep);
  
--- 341,364 ----
      }
      (*ard)->as = NULL;
      audit_pickle_dencode_ev_info(h, &(*ard)->header, &(*ard)->tail, status);
!     if (BAD_STATUS(status)) {
!         if (local_predicate)
!             free(orig_predicate);
!         if (check_addr)
!             free(addr);
!         free(ep);
!         return;
!     }
  
      idl_es_handle_free(&h, status);
!     if (BAD_STATUS(status)) {
!         if (local_predicate)
!             free(orig_predicate);
!         if (check_addr)
!             free(addr);
!         free(ep);
!         return;
!     }
  
      free(ep);
  
***************
*** 370,375 ****
--- 405,415 ----
      DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
  	"dce_aud_next: found a matching record\n"));
  #endif
+     if (local_predicate)
+         free(orig_predicate);
+     if (check_addr)
+         free(addr);
+ 
      (*ard)->tail_read_cursor = 0;
      *status = aud_s_ok;
      return;
***************
*** 583,588 ****
--- 623,629 ----
      sec_login_net_info_t net_info;
      boolean32       found = FALSE;
      own_id_t        *secondary_group_ptr, *temp_group_ptr;
+     unsigned32      tmp_status;
  
      if (ard == NULL) {
  	*status = aud_s_invalid_record_descriptor; 
***************
*** 621,630 ****
             if (!own_id_initialized)
             {
                sec_login_get_current_context(&login_context, status);
!               if (*status != error_status_ok) return;
                sec_login_inquire_net_info(login_context, &net_info, status);
                if ((*status != error_status_ok) 
!                  && (*status != sec_login_s_not_certified)) return;
  
                own_cell_uuid = net_info.pac.realm.uuid;
  
--- 662,679 ----
             if (!own_id_initialized)
             {
                sec_login_get_current_context(&login_context, status);
!               if (*status != error_status_ok) {
!                   sec_rgy_site_close( rgy_context, &tmp_status );
!                   free( strbuf );
!                   return;
!               }
                sec_login_inquire_net_info(login_context, &net_info, status);
                if ((*status != error_status_ok) 
!                  && (*status != sec_login_s_not_certified)) {
!                   sec_rgy_site_close( rgy_context, &tmp_status );
!                   free( strbuf );
!                   return;
!               }
  
                own_cell_uuid = net_info.pac.realm.uuid;
  
***************
*** 925,930 ****
--- 974,981 ----
      *buffer = (unsigned_char_t *) malloc(strlen(strbuf)+1);
      if (*buffer == NULL) {
  	dce_printf(aud_s_cannot_allocate_memory, strlen(strbuf)+1);
+         sec_rgy_site_close(rgy_context, &tmp_status);
+         free(strbuf);
  	*status = aud_s_cannot_allocate_memory;
  	return;
      }
 
*** /project/dce/build/dce1.1-maint/src/security/audit/libaudit/evt_write.c	Wed Oct  5 09:42:25 1994
--- security/audit/libaudit/evt_write.c	Fri Oct  6 20:02:43 1995
***************
*** 417,422 ****
--- 417,423 ----
      uuid_t          princ_uuid, cell_uuid;
      sec_id_pac_t   *pac;
      unsigned32	    lst;
+     unsigned32	    tmp_status;
  
  
      *status = aud_s_ok;
***************
*** 432,437 ****
--- 433,439 ----
      sec_id_parse_name(rgy_context, client, cell_name, &cell_uuid, princ_name,
  		      &princ_uuid, status);
      if (BAD_STATUS(status)) {
+         sec_rgy_site_close( rgy_context, &tmp_status );
  	return;
      }
      pac = (sec_id_pac_t *) malloc(sizeof(sec_id_pac_t));
***************
*** 441,447 ****
      pac->num_groups = 0;
  
      dce_aud_start_with_pac(event, pac, address, options, outcome, ard, status);
!     if (BAD_STATUS(status)) return;
      if (*ard != NULL)
      {
         (*ard)->header.authz_st = rpc_c_authz_name;
--- 443,452 ----
      pac->num_groups = 0;
  
      dce_aud_start_with_pac(event, pac, address, options, outcome, ard, status);
!     if (BAD_STATUS(status)) {
!         sec_rgy_site_close( rgy_context, &tmp_status );
!         return;
!     }
      if (*ard != NULL)
      {
         (*ard)->header.authz_st = rpc_c_authz_name;
***************
*** 457,462 ****
--- 462,468 ----
  	dce_aud_discard(*ard, &lst);
      }
   */
+     sec_rgy_site_close( rgy_context, &tmp_status );
  
      return;
  }
***************
*** 751,757 ****
  	} else {
  	    idl_es_encode_dyn_buffer(&ep, &esize, &h, status);
  	    audit_pickle_dencode_ev_info(h, &ard->header, &ard->tail, status);
!             if (BAD_STATUS(status)) return;
  #ifdef DCE_AUD_DEBUG
  	    DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
  		"pickle size = %ld\n", esize));
--- 757,766 ----
  	} else {
  	    idl_es_encode_dyn_buffer(&ep, &esize, &h, status);
  	    audit_pickle_dencode_ev_info(h, &ard->header, &ard->tail, status);
!             if (BAD_STATUS(status)) {
!                 dce_aud_discard(ard, &st);
!                 return;
!             }
  #ifdef DCE_AUD_DEBUG
  	    DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
  		"pickle size = %ld\n", esize));

[10/26/95 public]
Thanks to Parul for pointing out the error.  I corrected the files in 
/afs/dce.osf.org/project/dce/ibm/audit.

[7/18/96 public]
Fixed in DCE1.2.2 (BL03).



CR Number                     : 12853
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : filter change rpc waits while server
updates clients
Reported Date                 : 4/28/95
Found in Baseline             : 1.1
Found Date                    : 4/28/95
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : rpc
Sensitivity                   : public

[4/28/95 public]
From: John Rousseau <jrr@apollo.hp.com>
Subject: auditd problem
Date: Thu, 27 Apr 1995 15:47:45 -0400

The problem with dcecp hanging when creating (or listing)
audit filters is really with auditd.

Everytime an rpc is made that changes the list of filters,
the audit daemon goes through each directory in

/opt/dcelocal/var/audit/client/*

and looks up the bindings for a client that has communicated
with the auditd. The daemon then does an
rpc_mgmt_is_server_listening() for each of these clients. In
the DG case, this can take well in excess of 30 seconds
(somtimes much longer (like 2 minutues), which concerns
me). Only after tring to reach each client does the original
rpc return. I have seen this take in excess of 40 minutes.

I can see a workaround and two fixes:

The workaround:

(extreme)
/etc/dce.clean
rm -rf /opt/dcelocal/var/audit/client/*
/etc/rc.dce

By doing this, I changed the audfilter create response time
from 48 minutes to 2 seconds.

- or -

(If you have a lot of recent audit clients, this may only
help a little)
cd /opt/dcelocal/var/audit/client
find . -type d -mtime +2 -exec rm -rf {} \;


The fixes are:

Create a thread that will go around and update all of the
clients. After creating the thread, return the original rpc
to the caller. Now we (kinda) don't care how long the update
takes.

Secondly, institute a process where the old bindings are
removed. This is probably a two fold setup.  The daemon
should clean up the binding file when it detects that a
client is no longer listening on a binding handle. This will
catch most cases.

Also, I think that in the new update thread that if the
rpc_mgmt_is_server_listening() call fails with some sort of
hard failure, then the binding file should be nuked. This
will prevent anything from falling through the cracks
(client dies, is killed, or doesn't clean up correctly).

-John


From: tatsu_s@apollo.hp.com
Subject: Re: Proposed auditd changes
Reply-To: tatsu_s@apollo.hp.com
Date: Thu, 27 Apr 1995 19:14:34 -0400

Instead of spawning a thread from the server manager routine, I
recommend to start it at the server startup.

The client purge thread does something like:

  Sleep for awhile (waiting for the server startup).
  While (true) {
    Ping each client and remove it if fails ? times. <= !!!
    cond_timed_wait()
  }

aud_update_announce() simply calls cond_signal().

(Of course, you need to take care of the mutex, cond vars, etc. But,
there is plenty of examples in dced.)

Implementing reliable ping logic is really difficult. This case is
worse than dced because it involves the remote rpc whereas dced does
only local rpc.

---  Seiichi

[10/23/95 public]
I have talked to Shyh_Wei and here are his thoughts:

---------------------------------------------------

Date: 19 October 1995, 19:26:55 PDT
From: Shyh-Wei Luan                                  LUAN     at ALMADEN
To:   TRANT at AUSVM1
cc:   WEISZ at TOROLAB6, LUAN at ALMADEN
In-Reply-To: <trant@ausvm1.VNET>
             "OT 12853" (Oct 19,  2:25pm)
Subject: Re: OT 12853
References: <9510191936.AA37244@seaside.almaden.ibm.com>
X-Mailer: Z-Mail (3.2.0 06sep94)
Mime-Version: 1.0
Content-Type: text/plain; charset=us-ascii

I think some cleaning daemon process may be run to clean up the dangling
client binding directories.  The directories named with process ids that
do not exist on the system are the ones to be removed.  I don't
think removing binding directories upon rpc_mgmt_is_server_listening
timeouts is right, since the audit client may be stopped or slow in
responding.  Removing their binding directories/files would prevent them
from getting current/later updates.

Periodical or command-driven removal of binding directories/files for
non-existing processes hopefully will eliminate almost all the waiting.  For
the rest of the cases, I think auditd should generate an error
message, dcecp should return failure.  The failed update can be retried,
probably after human intervention (to look at the health of the
audit client process).

Shyh-Wei

[jrr public]
For completeness: a recent mail conversation

On Thu Nov 2, 1995, tmt@vnet.ibm.com wrote:

> Ref:  Your note of Wed, 1 Nov 1995 08:45:31 -0500 (attached)
> 
> John,
> 
> I reviewed it and would not change the algorithm.  I think your algorithm
> proposed the best way to solve the problem.  I only have one question:
> 
>    In aud_update_client routine, there is a lock at the beginning of
>    the routine and unlock it before calling aud__do_client_update,
>    then lock it again.  Should we have an unlock outside of for loop???

No. pthread_cond_timedwait will unlock the mutex while
sleeping and relock it upon waking.

> Would you please update the OT.  For dmn_updt_inform.c, I would like to
> add some error checkings and remove the update file if bad status returned
> from RPC calls. I have put dmn_updt_inform.12853 and dmn_updt_inform.diff.12853
> in /afs/dce.osf.org/project/dce/ibm/audit.

I don't think this is right. This is the problem is that you
can never be sure that the client you are trying to update
is dead and not just unconscious. If you remove the binding
then that client will never recieve updates of filter
changes and therefore you open a security hole.

If your security folks want to do this, that's fine, but I
didn't want to take the chance. A little more error
checking would be great.

> One more thing, for this problem, you will change rc.clean and rc.dce,
too???

Yes. We just added lines to remove the client binding files.

-John

[03/21/96 public]
Fixed for DCE 1.2.1.  Closed Now



CR Number                     : 12688
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : "diff" ev_info ACL contents not printed during trail dump
Reported Date                 : 10/20/94
Found in Baseline             : 1.1
Found Date                    : 10/20/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : evt_read.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/20/94 public]
ACL contents not printed when dumping the audit trail file.

[7/26/95 public]

This defect needs to be looked at closer.  It appears that an interface
would have to change to fix this problem.  Like 12688, I will engage
Robert Weisz to see why he thought this should be fixed.

[9/27/95 public]
The fix has been made.

[9/28/95 public]
Sorry, I did not include the diff.  The diff file and the new version
of evt_read.c are also found in /afs/dce.osf.org/project/dce/ibm/audit


570c570
<     int             id_count;
---
>     int             id_count, num_entries;
903a904,1045
>
>               uuid_to_string(&(tail->info_item[i].tagged_union.acl->default_realm.uuid),
>                                &sp, status);
>               if (sp != NULL) {
>                     sprintf(strbuf+strlen(strbuf), "default realm uuid: %s\n", sp);
>                   rpc_string_free(&sp, status);
>               }
>
>                 sp = tail->info_item[i].tagged_union.acl->default_realm.name;
>               if (sp != NULL) {
>                     sprintf(strbuf+strlen(strbuf), "default realm name: %s\n", sp);
>               }
>
>               uuid_to_string(&(tail->info_item[i].tagged_union.acl->sec_acl_manager_type),
>                              &sp, status);
>               if (sp != NULL) {
>                     sprintf(strbuf+strlen(strbuf), "acl manager type: %s\n", sp);
>                   rpc_string_free(&sp, status);
>               }
>
>                 num_entries = tail->info_item[i].tagged_union.acl->num_entries;
>                 sprintf(strbuf+strlen(strbuf), "number of entries: %d\n", num_entries);
>
>                 for (j = 0; j < num_entries; j++) {
>                    switch (tail->info_item[i].tagged_union.acl->sec_acl_entries[j].entry_info.entry_type)>                 {
>
>                        case sec_acl_e_type_user_obj:
>                           sprintf(strbuf+strlen(strbuf), "type user obj\n");
>                        break;
>
>                        case sec_acl_e_type_group_obj:
>                           sprintf(strbuf+strlen(strbuf), "type group obj\n");
>                        break;
>
>                        case sec_acl_e_type_other_obj:
>                           sprintf(strbuf+strlen(strbuf), "type other obj\n");
>                        break;
>
>                        case sec_acl_e_type_unauthenticated:
>                           sprintf(strbuf+strlen(strbuf), "type unauthenticated\n");
>                        break;
>
>                        case sec_acl_e_type_any_other:
>                           sprintf(strbuf+strlen(strbuf), "type any other\n");
>                        break;
>
>                        case sec_acl_e_type_user:
>                           sprintf(strbuf+strlen(strbuf), "type user\n");
>
>                           uuid_to_string(&(tail->info_item[i].tagged_union.acl->sec_acl_entries[j].entryinfo.tagged_union.id.uuid),
>                                          &sp, status);
>                           if (sp != NULL) {
>                              sprintf(strbuf+strlen(strbuf), "uuid: %s\n", sp);
>                            rpc_string_free(&sp, status);
>                         }
>
>                           sp = tail->info_item[i].tagged_union.acl->sec_acl_entries[j].entry_info.taggedunion.id.name;
>                           if (sp != NULL) {
>                              sprintf(strbuf+strlen(strbuf), "name: %s\n", sp);
>                         }
>                        break;
>
>                        case sec_acl_e_type_group:
>                           sprintf(strbuf+strlen(strbuf), "type group\n");
>                           uuid_to_string(&(tail->info_item[i].tagged_union.acl->sec_acl_entries[j].entryinfo.tagged_union.id.uuid),
>                                          &sp, status);
>                           if (sp != NULL) {
>                              sprintf(strbuf+strlen(strbuf), "uuid: %s\n", sp);
>                            rpc_string_free(&sp, status);
>                         }
>
>                           sp = tail->info_item[i].tagged_union.acl->sec_acl_entries[j].entry_info.taggedunion.id.name;
>                           if (sp != NULL) {
>                              sprintf(strbuf+strlen(strbuf), "name: %s\n", sp);
>                           }
>                        break;
>
>                        case sec_acl_e_type_foreign_other:
>                           sprintf(strbuf+strlen(strbuf), "type foreign other\n");
>                           uuid_to_string(&(tail->info_item[i].tagged_union.acl->sec_acl_entries[j].entryinfo.tagged_union.id.uuid),
>                                          &sp, status);
>                           if (sp != NULL) {
>                              sprintf(strbuf+strlen(strbuf), "uuid: %s\n", sp);
>                              rpc_string_free(&sp, status);
>                           }
>
>                           sp = tail->info_item[i].tagged_union.acl->sec_acl_entries[j].entry_info.taggedunion.id.name;
>                           if (sp != NULL) {
>                              sprintf(strbuf+strlen(strbuf), "name: %s\n", sp);
>                         }
>                        break;
>
>                        case sec_acl_e_type_foreign_user:
>                           sprintf(strbuf+strlen(strbuf), "type foreign user\n");
>                           uuid_to_string(&(tail->info_item[i].tagged_union.acl->sec_acl_entries[j].entryinfo.tagged_union.foreign_id.id.uuid),
>                                          &sp, status);
>                           if (sp != NULL) {
>                              sprintf(strbuf+strlen(strbuf), "uuid: %s\n", sp);
>                            rpc_string_free(&sp, status);
>                         }
>
>                           sp = tail->info_item[i].tagged_union.acl->sec_acl_entries[j].entry_info.taggedunion.foreign_id.id.name;
>                           if (sp != NULL) {
>                              sprintf(strbuf+strlen(strbuf), "name: %s\n", sp);
>                           }
>                        break;
>
>                        case sec_acl_e_type_foreign_group:
>                           sprintf(strbuf+strlen(strbuf), "type foreign group\n");
>                           uuid_to_string(&(tail->info_item[i].tagged_union.acl->sec_acl_entries[j].entryinfo.tagged_union.foreign_id.id.uuid),
>                                          &sp, status);
>                           if (sp != NULL) {
>                              sprintf(strbuf+strlen(strbuf), "uuid: %s\n", sp);
>                            rpc_string_free(&sp, status);
>                         }
>
>                           sp = tail->info_item[i].tagged_union.acl->sec_acl_entries[j].entry_info.taggedunion.foreign_id.id.name;
>                           if (sp != NULL) {
>                              sprintf(strbuf+strlen(strbuf), "name: %s\n", sp);
>                           }
>                           uuid_to_string(&(tail->info_item[i].tagged_union.acl->sec_acl_entries[j].entryinfo.tagged_union.foreign_id.realm.uuid),
>                                          &sp, status);
>                           if (sp != NULL) {
>                              sprintf(strbuf+strlen(strbuf), "realm uuid: %s\n", sp);
>                            rpc_string_free(&sp, status);
>                         }
>
>                           sp = tail->info_item[i].tagged_union.acl->sec_acl_entries[j].entry_info.taggedunion.foreign_id.realm.name;
>                           if (sp != NULL) {
>                              sprintf(strbuf+strlen(strbuf), "realm name: %s\n", sp);
>                           }
>                        break;
>
>                        case sec_acl_e_type_extended:
>                        default:
>                        break;
>                   }                       /* end of switch */
>                   sprintf(strbuf+strlen(strbuf), "permission bits: %lX\n",
>                           tail->info_item[i].tagged_union.acl->sec_acl_entries[j].perms);
>                 }                           /* end of for loop */
>

[7/18/96 public]
Fixed in DCE1.2.2 (BL03).



CR Number                     : 12562
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : doc bug: dce_aud_start_with_pac(3) does not match code
Reported Date                 : 10/7/94
Found in Baseline             : 1.1b20
Found Date                    : 10/7/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b20
Affected File(s)              : app_ref/man3sec/dce_aud_start_with_pac.3sec
Sensitivity                   : public

[10/7/94 public]


The dce_aud_start_with_pac(3) man page doesn't match the code.


                dce_aud_start_with_pac
                (
                                 unsigned32 event,
                                 sec_id_pac_t * pac,
                                 unsigned_char_t * address,
                                 unsigned32 options,
                                 unsigned32 outcome,
                                 dce_aud_rec_t * ard,
                                 unsigned32 * status
		) 


SYNOPSIS
     #include <dce/audit.h>

     void dce_aud_start_with_pac(
             unsigned32 event,
             sec_id_pac_t pac,
             unsigned_char_t *address,
             unsigned32 options,
             unsigned32 outcome,
             dce_aud_rec_t *ard,
             unsigned32 *status);
[10/17/94,public]
Corrected the man paga.

[10/27/94 public]
Closed bug.



CR Number                     : 12560
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : doc bug: dce_aud_next missing format parameter
Reported Date                 : 10/7/94
Found in Baseline             : 1.1b20
Found Date                    : 10/7/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b20
Affected File(s)              : app_ref/man3sec/dce_aud_next.3sec
Sensitivity                   : public

[10/7/94 public]


The dce_aud_next(3) man page is missing the "unsigned16 format" parameter.

dce_aud_next
                (
                                 dce_aud_trail_t at,
                                 char *predicate,
                                 unsigned16 format,
                                 dce_aud_rec_t * ard,
                                 unsigned32 * status
                )


dce_aud_next(3sec)  UNIX Programmer's Manual   dce_aud_next(3sec)



NAME
     dce_aud_next -  Reads the next audit record from a specified
     audit trail file into a buffer.

     Used by the trail analysis and examination tools.

SYNOPSIS
     #include <dce/audit.h>

     void dce_aud_next(
             dce_aud_trail_t at,
             char *predicate,
             dce_aud_rec_t *ard,
             unsigned32 *status);

[10/17/94 public]
Added the format parameter to the man page of this API.

[10/27/94 public]
Closed bug.



CR Number                     : 12558
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : doc bug: incorrect central path
Reported Date                 : 10/7/94
Found in Baseline             : 1.1b20
Found Date                    : 10/7/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b20
Affected File(s)              : admin_gd/security/security/15_audit_tasks.gpsml
Sensitivity                   : public

[10/7/94 public]

In the Audit Adminstrative Tasks pg, 43-9 it says
you can print out the central trail with:

dcecp> audtrail show central_trail

This is incorrect the actual path is:

dcecp> audtrail show /opt/dcelocal/var/audit/adm/central_trail

[10/17/94 public]
Changed the pathname of the central trail file to the correct one.

[10/27/94 public]
Closed bug.



CR Number                     : 12554
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : "diff" Add the name of the event in the event class files
Reported Date                 : 10/7/94
Found in Baseline             : 1.1b20
Found Date                    : 10/7/94
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : 
../src/security/audit/h/evtp.h
../src/security/audit/ec/*
../src/security/audit/libaudit/evt_read.c
../src/security/audit/libaudit/evt_classes.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/7/94 public]
The IBM team notes that adding the name of the event in the event class
files would allow that when printing the audit trail, we would be able to
print the actual name of the event, as opposed to just its numerical value.
This is easier than reading the numerical value and then doing a manual
cross referencing.

[11/9/95 public]
I have supported the enhancement and I would like it to be included in the
next merge.  All the diff files and their new versions are also found in
/afs/dce.osf.org/project/dce/ibm/audit.  Notice that, I only modified
two event class files to show the examples.  The event name and event  
descriptions followed the event number are optional fields.  They can be 
omitted.  The event name must be a single word whereas event description 
can be a phrase and enclosed by double quotes if they exist.  Their maximum
lengths are 80. The format is shown below:

eventnumber [eventname] ["this is the description of the event name"]

o The input_e_table() is used to insert the event class, event number,
  event name, and event text into the linked list, e_table.
o The print_e_table() is used to display the whole linked list in a fine format.
    Event Class      Event Number       Event Name      Event Description
    -----------      ------------       ----------      -----------------
    dce_sec_server    0x124/(292)       REPADMIN_Stop   "Direct the registry.."
                      0x125/(293)       REPADMIN_Maint  "Direct the registry.."
                      ...               ...             ...

o The free_e_table() is used to free the linked list.

1) diff file for evtp.h:

150,153c150,153
<       unsigned32      evt_number;
<       int             evt_class_cnt;  /* number of event classes */
<       unsigned32     *evt_classes;    /* array of event classes to which
<                                          this event belongs */
---
>       unsigned32         evt_number;          /* event number                    */
>       int                evt_class_cnt;       /* number of event classes         */
>       unsigned32        *evt_classes;         /* array of event classes to which */
>                                               /* this event belongs              */
166,167c166,167
<       unsigned32      evt_number;
<       struct _ec_evt_t *next;
---
>       unsigned32         evt_number;          /* linked list of event numbers in */
>       struct _ec_evt_t  *next;                /* ec table                        */
171,175c171,174
<       unsigned32      ec_number;
<       char            *ec_name;
<       ec_evt_t        *evts;          /* linked list of events in
<                                          this event class */
<       struct _ec_t    *next;
---
>       unsigned32         ec_number;           /* linked list of event class      */
>       char              *ec_name;             /* numbers, names, and event       */
>       ec_evt_t          *evts;                /* numbers within the same class   */
>       struct _ec_t      *next;
178a178,187
>
> typedef struct _e_t {
>       char              *ec_name;             /* linked list of event numbers,   */
>       unsigned32         e_number;            /* event names, and event          */
>       char              *e_name;              /* descriptions within a event     */
>       char              *e_text;              /* class                           */
>       struct _e_t       *next;
> } e_t;
>
> extern e_t *e_table;

2) diff file for dce_sec_server:

9c9
< 0x0124
---
> 0x0124 REPADMIN_Stop "Direct the registry server to stop servicing RPCs"
11c11
< 0x0125
---
> 0x0125 REPADMIN_Maint "Direct the registry server into or out of maintenance state"
13c13
< 0x0126
---
> 0x0126 REPADMIN_Mkey "Direct the registry to change its master key and re_encrypt account"
15c15
< 0x0127
---
> 0x0127 REPADMIN_Destroy "Direct the registry to destroy its master key"
17c17
< 0x0128
---
> 0x0128 REPADMIN_Init " Direct the registry to initialize its master key"
~

3) diff file for dce_audit_admin_modify:

8c8
< 0x305
---
> 0x305 sstrategy "Modify sstrategy for audit daemon"
10c10
< 0x306
---
> 0x306 state "Modify state for audit daemon"
12c12
< 0x307
---
> 0x307 rewind "Rewind the audit trail"
14c14
< 0x308
---
> 0x308 stop "Stop the audit daemon"

4) diff file evt_read.c:

100a101
> e_t            *e_table = NULL;
102d102
<
566c566
<     dce_aud_hdr_t   header;
---
>     dce_aud_hdr_t           header;
568,581c568,583
<     int             i,j;
<     client_id_t     id;
<     int             id_count;
<     unsigned_char_t *sp;
<     char            buf[100];
<     sec_rgy_handle_t rgy_context;
<     sec_rgy_name_t  subject_name;
<     boolean32       output_uuids = TRUE;
<     char            *strbuf;
<     int                   index;
<     sec_login_handle_t login_context;
<     sec_login_net_info_t net_info;
<     boolean32       found = FALSE;
<     own_id_t        *secondary_group_ptr, *temp_group_ptr;
---
>     int                     i,j;
>     client_id_t             id;
>     int                     id_count;
>     unsigned_char_t        *sp;
>     char                    buf[100];
>     char                    event_name[80];
>     sec_rgy_handle_t        rgy_context;
>     sec_rgy_name_t          subject_name;
>     boolean32               output_uuids = TRUE;
>     char                   *strbuf;
>     int                           index;
>     sec_login_handle_t      login_context;
>     sec_login_net_info_t    net_info;
>     boolean32               found = FALSE;
>     own_id_t               *secondary_group_ptr, *temp_group_ptr;
>     error_status_t          stp;
660a663,670
>     if (e_table == NULL)
>     {
>         input_e_table();
> #ifdef AUD_DEBUG
>         print_e_table();
> #endif /* AUD_DEBUG */
>     }
>
669a680,682
>     index = strlen(strbuf);
>     get_event_name_from_number(header.event, event_name);
>     sprintf(strbuf+strlen(strbuf), "Event Name: %s\n", event_name);

5) diff file for evt_classes.c:

60,62c60,62
< #define LINE_BUF_SIZE 2048    /* for both input and output lines */
< #define NUM_BUF_SIZE  32      /* for numbers */
< #define FILENAME_SIZE 512     /* for event class dir and files */
---
> #define LINE_BUF_SIZE 2048                    /* for both input and output lines  */
> #define NUM_BUF_SIZE  32                      /* for numbers                      */
> #define FILENAME_SIZE 512                     /* for event class dir and files    */
64c64
< enum ec_file_parse_mode { evt_table_input, ec_table_input };
---
> enum ec_file_parse_mode { evt_table_input, ec_table_input, e_table_input };
67,70c67,69
< evt_t         *evt_table;
< ec_t          *ec_table = NULL;
< unsigned32    aud_g_cli_num_of_ecs = 0;
< unsigned32    *aud_g_cli_evt_classes = NULL;
---
> evt_t                *evt_table;
> ec_t                 *ec_table = NULL;
> e_t                  *e_table  = NULL;
72,75c71,77
< static        int     lineno;         /* line number in current ec file */
< static        FILE    *file;          /* current ec file */
< static        char    *line;          /* buffer for reading a line */
< static        int     line_len;       /* current length of a line */
---
> unsigned32            aud_g_cli_num_of_ecs = 0;
> unsigned32             *aud_g_cli_evt_classes = NULL;
>
> static        int             lineno;                 /* line number in current ec file   */
> static        FILE           *file;                   /* current ec file                  */
> static        char           *line;                   /* buffer for reading a line        */
> static        int             line_len;               /* current length of a line         */
79c81,83
< static        char            fname[FILENAME_SIZE];
---
> static        char            fname[FILENAME_SIZE];   /* fully qualified path for class   */
> static        char            ecname[FILENAME_SIZE];  /* event class name = file name     */
> static        e_t            *e_table_ptr = NULL;     /* point of the e_table linked list */
83,84c87,88
<     Ecn,          /* Event Class Number */
<     Sep           /* Servers' Events Prefixes */
---
>     Ecn,                                              /* Event Class Number               */
>     Sep                                               /* Servers' Events Prefixes         */
93,94c97,98
<     char        *name;        /* Name of keyword */
<     int                 op;           /* Operation */
---
>     char        *name;                                /* Name of keyword                  */
>     int                 op;                           /* Operation                        */
110a115
>     return;
123a129
>     return;
141a148
>     return;
143a151,166
> void
> free_e_table()
> {
>     e_t * tmp;
>
>     while (e_table != NULL) {
>       tmp = e_table->next;
>         free(e_table->ec_name);
>         free(e_table->e_name);
>         free(e_table->e_text);
>         free(e_table);
>         e_table = tmp;
>     }
>     return;
> }
>
205a229
>     return;
207a232
> void
256a282
>     return;
258a285,322
> void
> add_evt_to_e_table
> (
>   unsigned32  evt_number,
>   char         *evt_name,
>   char         *evt_text
> )
> {
>     e_t *tmp = NULL;
>
>     tmp = (e_t *)malloc(sizeof(e_t));
>     if (tmp == NULL)
>     {
>         dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, sizeof(e_t));
>         return;
>     }
>
>     /* set the linked list fields */
>     tmp->ec_name = malloc(strlen(ecname));
>     strcpy(tmp->ec_name, ecname);
>     tmp->e_number = evt_number;
>     tmp->e_name = malloc(strlen(evt_name));
>     strcpy(tmp->e_name, evt_name);
>     tmp->e_text = malloc(strlen(evt_text));
>     strcpy(tmp->e_text, evt_text);
>     tmp->next = NULL;
>
>     /* add the new node at the end */
>     if (e_table_ptr != NULL)
>         e_table_ptr->next = tmp;
>     e_table_ptr = tmp;
>
>     /* set e_table to the header of the linked list */
>     if (e_table == NULL)
>         e_table = e_table_ptr;
>     return;
> }
>
297a362,399
> get_event_number_from_name
> (
>   char * evt_name,
>   unsigned32  evt_number
> )
> {
>     e_t * ep = e_table;
>
>     while (ep != NULL) {
>       if ( strcmp(ep->e_name, evt_name) == 0 ) {
>             evt_number = ep->e_number;
>           return(TRUE);
>       }
>       ep = ep->next;
>     }
>     return(FALSE);
> }
>
> boolean32
> get_event_name_from_number
> (
>   unsigned32 evt_number,
>   char * evt_name
> )
> {
>     e_t * ep = e_table;
>
>     while (ep != NULL) {
>       if ( ep->e_number == evt_number) {
>           strcpy(evt_name, ep->e_name);
>           return(TRUE);
>       }
>       ep = ep->next;
>     }
>     return(FALSE);
> }
>
> boolean32
415a518
>     return;
417a521,548
> void
> print_e_table()
> {
>     e_t * tmp = e_table;
>     char *pecname;
>
>     if (tmp == NULL) {
>         printf("The e_table is empty.  Use input_e_table() to initialize it\n");
>         return;
>     } /* endif */
>
>     printf("Event Class              Event Number   Event Name                Event Description\n");
>     printf("-----------              ------------   ----------                -----------------\n");
>     while (tmp != NULL) {
>        if (strcmp(tmp->ec_name, pecname) != 0) {
>            pecname = malloc(strlen(tmp->ec_name));
>            strcpy(pecname, tmp->ec_name);
>            printf("%25-s %#lx/(%ld)   %25-s %s\n", pecname,
>                   tmp->e_number, tmp->e_number, tmp->e_name, tmp->e_text);
>        }
>        else
>            printf("%25-s %#lx/(%ld)   %25-s %s\n"," ",
>                   tmp->e_number, tmp->e_number, tmp->e_name, tmp->e_text);
>        tmp = tmp->next;
>     }
>     return;
> }
>
452a584
>     return;
456c588
< DoEventNumber
---
> DoEvent
461,462c593,596
<     unsigned32 evt_number;
<     char *end;
---
>     unsigned32   evt_number;
>     char        *tmp          = NULL;
>     char         evt_name[20] = "";
>     char         evt_text[80] = "";
464,467c598,606
<     evt_number = strtoul(str, &end, 0);
<     if ( !isspace(*end) && *end != '\0' ) {
<       dce_svc_printf(AUD_S_INVALID_LINE_IN_CLASS_FILE_MSG, str, fname);
<       return;
---
>     /* locate the double quote if exists  */
>     /* and parse the str for event number */
>     /* event name, and event text         */
>     tmp = strchr(str, '\"');
>     if (tmp != NULL) {
>         sscanf(str, "%lx %s", &evt_number, evt_name);
>         strcpy(evt_text, tmp);
>     } else {
>         sscanf(str, "%lx %s %s", &evt_number, evt_name, evt_text);
470c609
<     if (parse_mode == evt_table_input) {
---
>     if (parse_mode == evt_table_input)
472c611
<     } else {  /* parse_mode == ec_table_input */
---
>     else if (parse_mode == ec_table_input)
474c613,615
<     }
---
>     else
>       add_evt_to_e_table(evt_number, evt_name, evt_text);
>     return;
503a645
>     return;
535a678
>     return;
722c865
<           DoEventNumber(line);
---
>           DoEvent(line);
724c867,868
<     }
---
>    }
>    return;
726a871
> void
765a911
>     return;
792a939,945
> void input_e_table ()
> {
>
>     parse_mode = e_table_input;
>     ParseFiles();
>     return;
> }

[11/27/95 public]
minor correction on the pre_processor statement.

[12/7/95 public]
I have been noticed that the event description may not comply with
the NLS rules.  My suggestion to this OT is that ONLY picking up if 
you really want to see the event name in the audit log and you don't
worry about NLS rules. The new algorithm supports the event name and
event description which complies with NLS will be addressed in OT
13222.  We will supply the enhancement after DCE1.2.1 came out.

[7/18/96 public]
Fixed in DCE1.2.2 (BL03).



CR Number                     : 12553
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : "diff" Audit event numbers should be printed in hex
Reported Date                 : 10/7/94
Found in Baseline             : 1.1b20
Found Date                    : 10/7/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 1.2.2, 1.1maint
Affected File(s)              : evt_read.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/7/94 public]
Shyh-Wei notes that the audit event numbers should be printed in hex when
displaying audit records to be consistent with the event class files and
man pages - easier to look them up.

[7/26/95 public]

I agree that this defect needs to be fixed.  I don't currently have
a target, I'm guessing sometime in September.  If this needs to be fixed
sooner please let me know.

[9/27/95 public]
The fix has been made.

[9/27/95 public]
Can this fix be put into OT? We need them to incorporate into 1.1-maint code.
A context diff wrt to 1.1 code would be good. Also, please provide all such
fixes in corresponding OTs. Thanks.

[9/28/95 public]
Sorry, I did not know that I should include the diff file here.  The diff
file and the new version of the evt_read.c are also found in
/afs/dce.osf.org/project/dce/ibm/audit


157c157
<           evt_id = atoi(local_predicate + strlen("EVENT:"));
---
>           evt_id = strtol(local_predicate + strlen("EVENT:"), NULL, 16);
669c669
<     sprintf(strbuf+strlen(strbuf), "Event Number: %ld\n", header.event);
---
>     sprintf(strbuf+strlen(strbuf), "Event Number: %lx\n", header.event);

[7/18/96 public]
Fixed in DCE1.2.2 (BL03).

[09/30/96 public]
Fixed in 1.1 maintenance tree.

./security/audit/libaudit/evt_read.c
Comparing revision 1.1.8.2 with revision 1.1.8.3.
*** 1.1.8.2     1995/10/07 00:24:16
--- 1.1.8.3     1996/09/30 15:04:11
***************
*** 9,18 ****
  /*
   * HISTORY
   * $Log:	c012553,v $
# Revision 1.10  96/09/30  18:49:24  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
   * Revision 1.1.8.2  1995/10/07  00:24:16  parul
   *    Fix OT 13024: need sec_rgy_site_close() on error
   *    [1995/10/07  00:23:40  parul]
!  *
   * Revision 1.1.8.1  1995/02/16  22:03:53  levy
   *    Submission of 1.1 unintegrated.
   *    [1995/02/16  20:42:38  levy]
--- 9,22 ----
  /*
   * HISTORY
   * $Log:	c012553,v $
# Revision 1.10  96/09/30  18:49:24  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
+  * Revision 1.1.8.3  1996/09/30  15:04:11  mariko
+  *    OT 12553: Print audit event numbers in hex
+  *    [1996/09/30  15:03:48  mariko]
+  *
   * Revision 1.1.8.2  1995/10/07  00:24:16  parul
   *    Fix OT 13024: need sec_rgy_site_close() on error
   *    [1995/10/07  00:23:40  parul]
!  * 
   * Revision 1.1.8.1  1995/02/16  22:03:53  levy
   *    Submission of 1.1 unintegrated.
   *    [1995/02/16  20:42:38  levy]
***************
*** 162,168 ****
            *commap = '\0';
        }
        if (strncmp(local_predicate, "EVENT:", strlen("EVENT:")) == 0) {
!           evt_id = atoi(local_predicate + strlen("EVENT:"));
            check_evt = TRUE;
        } else if (strncmp(local_predicate, "OUTCOME:", strlen("OUTCOME:")) == 0) {
            if (strcmp(local_predicate + strlen("OUTCOME:"), "SUCCESS") == 0) {
--- 166,173 ----
            *commap = '\0';
        }
        if (strncmp(local_predicate, "EVENT:", strlen("EVENT:")) == 0) {
!           /* OT 12553: print audit event numbers in hex */
!           evt_id = strtoul(local_predicate + strlen("EVENT:"), NULL, 16);
            check_evt = TRUE;
        } else if (strncmp(local_predicate, "OUTCOME:", strlen("OUTCOME:")) == 0) {
            if (strcmp(local_predicate + strlen("OUTCOME:"), "SUCCESS") == 0) {
***************
*** 723,729 ****
       */
  
      sprintf(strbuf, "\n--- Dumping an event record --- ");
!     sprintf(strbuf+strlen(strbuf), "Event Number: %ld\n", header.event);
      index = strlen(strbuf);
  
      if (!output_uuids)
--- 728,735 ----
       */
  
      sprintf(strbuf, "\n--- Dumping an event record --- ");
!     /* OT 12553: print audit event numbers in hex */
!     sprintf(strbuf+strlen(strbuf), "Event Number: %lx\n", header.event);
      index = strlen(strbuf);
  
      if (!output_uuids)



CR Number                     : 12551
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : Admin Guide
Short Description             : documentation on permissions for audit client is incorrect
Reported Date                 : 10/6/94
Found in Baseline             : 1.1b20
Found Date                    : 10/6/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : admin_gd/security/security/15_audit_tasks.gpsml
Sensitivity                   : public

[10/6/94 public]


In the DCE Audit Service Adminsitrative Tasks section
page 43-3 it says a DCE security group can be created which
consists of the servers on the host that are authorized
to generate audit records by doing the following steps,
however when I try these steps I am getting errors:

root@clam> acl_edit /.:/hosts/clam/audit-server
sec_acl_edit> m group:group/hosts/clam/audit-clients:l
ERROR: SEC_ACL_EDIT - invalid or unknown entry key (dce / sad)
sec_acl_edit> m group:group/hosts/clam/audit-admin:rwc
ERROR: SEC_ACL_EDIT - invalid or unknown entry key (dce / sad)
sec_acl_edit> 


sec_acl_edit> l

# SEC_ACL for /.:/hosts/clam/audit-server:
# Default cell = /.../clam_cell.qadce.osf.org
unauthenticated:-r--
user:hosts/clam/self:crwl
group:subsys/dce/audit-admin:crwl
any_other:-r--

[10/6/94 public]

This is a doc bug, page 43-3 is incorrect

The initial ACL should be listed as follows:

# SEC_ACL for /.:/hosts/clam/audit-server:
# Default cell = /.../clam_cell.qadce.osf.org
unauthenticated:-r--
user:hosts/clam/self:crwl
group:subsys/dce/audit-admin:crwl
any_other:-r--


Then before giving permissions to audit-clients
"audit-clients" needs to be created by rgy_edit:

Then the user can type:

sec_acl_edit> m group:audit-clients:l

Then to grant permissions to administrators the correct command is:

sec_acl_edit> m group:subsys/dce/audit-admin:rwc

[10/06/94 public]
Assigned to myself.

[10/07/94 public]

There is a second problem with the documentation: it uses acl_edit rather
than dcecp.  This appears to be the only use that I can find (in a brief
scan of the audit chapters of the admin guide) where dcecp is not used.
Therefore, this CR should also cover converting the (corrected) information
to use dcecp.

[10/20/94 public]
Fixed and verified by Jerry Kazin.  These changes were made
by Rico Cruz at IBM.

[10/27/94 public]
Closed bug.



CR Number                     : 12547
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : printf's in libaudit code
Reported Date                 : 10/6/94
Found in Baseline             : 1.1b20
Found Date                    : 10/6/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1, 1.1maint
Affected File(s)              : libaudit et al.
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/6/94 public]
There are still dce_printf's in libaudit.

These should be removed and replaced with status codes returned with
each function.

[ninja]:.../security/audit/libaudit> grep dce_printf *.c
esl_file_read.c:        dce_printf(aud_s_uuid_hash_failed);
esl_file_read.c:        dce_printf(aud_s_wrong_esl_file_version, fname);
esl_file_read.c:        dce_printf(aud_s_cannot_allocate_memory, size);
esl_file_read.c:        dce_printf(aud_s_cannot_read_file, fname);
esl_file_read.c:        dce_printf(aud_s_wrong_esl_updt_file_version, fname);
esl_file_read.c:        dce_printf(aud_s_cannot_allocate_memory, size);
esl_in_core.c:  dce_printf(aud_s_uuid_hash_failed);
esl_in_core.c:          dce_printf(aud_s_cannot_allocate_memory, 
esl_in_core.c:          dce_printf(aud_s_cannot_allocate_memory, 
esl_in_core.c:  dce_printf(aud_s_action_bit_set, guides_ptr->audit_action);
esl_in_core.c:  dce_printf(aud_s_condition_bit_set, guides_ptr->audit_condition);
esl_in_core.c:  dce_printf(aud_s_evt_classes);
esl_in_core.c:  dce_printf(aud_s_no_filter);
esl_sync.c:         dce_printf(aud_s_stat_esl_file, ESL_FILE_NAME(esl_type));
esl_sync.c:         dce_printf(aud_s_stat_esl_update_file, 
esl_sync.c:     dce_printf(aud_s_cannot_mkdir, dname);
esl_sync.c:     dce_printf(aud_s_cant_open_client_binding_file, fname);
evt_classes.c:              dce_printf(aud_s_cannot_allocate_memory, i * sizeof(unsigned32));
evt_classes.c:    dce_printf(aud_s_unknown_event_class, ec_name);
evt_classes.c:      dce_printf(aud_s_cannot_allocate_memory, i*sizeof(char *));
evt_read.c:     dce_printf(aud_s_trail_file_corrupted, at->trail_file);
evt_read.c:     dce_printf(aud_s_cannot_allocate_memory, 
evt_read.c:     dce_printf(aud_s_invalid_record_descriptor);
evt_read.c:     dce_printf(aud_s_invalid_record_descriptor);
evt_read.c:        dce_printf(aud_s_invalid_record_descriptor);
evt_read.c:     dce_printf(aud_s_cannot_allocate_memory, EVENT_BUF_SIZE);
evt_read.c:     dce_printf(aud_s_cannot_allocate_memory, strlen(strbuf)+1);
evt_utils.c:          dce_printf(aud_s_trl_file_size_limit, backup_trail, backup_trail_index);
evt_utils.c:        dce_printf(aud_s_trl_write_failure);
trl_ops.c:      dce_printf(aud_s_cannot_allocate_memory, 
trl_ops.c:                dce_printf(aud_s_invalid_audit_trail_size_limit);
trl_ops.c:              dce_printf(aud_s_cannot_init_trail_mutex);
trl_ops.c:      dce_printf(aud_s_client_esl_mutex);

[7/26/95 public]

To fix this defect will require some design change.  Some of hte functions
that have dce_printfs in them are void, and doing a return would be 
useless.  I can see fixing some of these, but some I cannot.  What is
the problem -- is it that the dce_printf's are in the code or that
some of the functions do not return() anything?

[(aka rousseau) 8/4/95 public]

These messages should be changed to use dce_svc_printf(). This will solve
two problems. First, dcecp users will not have these messages splatted to
stdout when they occur. Secondly, these messages can then be controlled via
svc routings allowing individual sites to tailor the amount of output into
log files.

HP has already made this fix and it will be sent to OSF during our next
drop.

[9/28/95 public]
The fixes have been made.  All the diff files are also found in
/afs/dce.osf.org/project/dce/ibm/audit

1) The diff file for aud.sams:

1005c1005
< attributes    "svc_c_error"
---
> attributes    "svc_c_sev_error"
1014c1014
< attributes    "svc_c_error"
---
> attributes    "svc_c_sev_error"
1032c1032
< attributes    "svc_c_error"
---
> attributes    "svc_c_sev_error"
1068a1069,1070
> sub-component   aud_s_general
> attributes      "aud_c_sev_error"
1085c1087
< start
---
> start           undocumented
1095c1097
< start
---
> start           undocumented
1106c1108
< start
---
> start           undocumented
1344a1347,1390
> end
>
> start
> code            aud_s_stat_esl_update_file_rc
> sub-component   aud_s_esl
> attributes      "svc_c_sev_error"
> text            "Cannot stat esl update file"
> explanation     "The UNIX \*Lstat\*O command returned an error when the Audit daemon tried to get size information
> about an esl file."
> action          "Make sure the file exists.  The file name is of the form \*L/opt/dcelocal/var/audit/esl*\*O."
> end
>
> start
> code            aud_s_cannot_allocate_memory_rc
> text            "Cannot allocate memory"
> explanation     "The \*Lmalloc()\*O call failed."
> action          "Report to your system administrator for resolution."
> end
>
> start
> code            aud_s_stat_esl_file_rc
> sub-component   aud_s_esl
> attributes      "svc_c_sev_error"
> text            "Cannot stat esl file"
> explanation     "The \*Lfstat()\*O call on the an esl file failed."
> action          "Check the \*Lfstat()\*O error code and act accordingly."
> end
>
> start
> code            aud_s_cannot_mkdir_rc
> sub-component   aud_s_esl
> attributes      "svc_c_sev_error"
> text            "Cannot make a directory"
> explanation     "An attemp to create a directory failed."
> action          "Make sure that the Audit client has the appropriate permissions to create the directory."
> end
>
> start
> code            aud_s_trail_file_corrupted_rc
> sub-component   aud_s_evt
> attributes      "svc_c_sev_error"
> text            "Audit trail file being read is corrupted."
> explanation     "The \*Lfread()\*O call on the trail file failed."
> action          "Contact your system administrator."

2) The diff file for esl_file_read.c:

140c140
<       dce_printf(aud_s_uuid_hash_failed);
---
>       dce_svc_printf(AUD_S_UUID_HASH_FAILED_MSG);
250c250
<       dce_printf(aud_s_wrong_esl_file_version, fname);
---
>       dce_svc_printf(AUD_S_WRONG_ESL_FILE_VERSION_MSG, fname);
256c256
<       dce_printf(aud_s_cannot_allocate_memory, size);
---
>       dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, size);
265c265
<       dce_printf(aud_s_cannot_read_file, fname);
---
>       dce_svc_printf(AUD_S_CANNOT_READ_FILE_MSG, fname);
435c435
<       dce_printf(aud_s_wrong_esl_updt_file_version, fname);
---
>       dce_svc_printf(AUD_S_WRONG_ESL_UPDT_FILE_VERSION_MSG, fname);
441c441
<       dce_printf(aud_s_cannot_allocate_memory, size);
---
>       dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, size);
~

3) The diff file for esl_in_core.c:

650c650
<       dce_printf(aud_s_uuid_hash_failed);
---
>       dce_svc_printf(AUD_S_UUID_HASH_FAILED_MSG);
766,767c766,767
<               *stp = aud_s_cannot_allocate_memory;
<               dce_printf(aud_s_cannot_allocate_memory,
---
>               *stp = aud_s_cannot_allocate_memory_rc;
>               dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG,
796,797c796,797
<               *stp = aud_s_cannot_allocate_memory;
<               dce_printf(aud_s_cannot_allocate_memory,
---
>               *stp = aud_s_cannot_allocate_memory_rc;
>               dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG,
826a827,829
>
> #ifdef DCE_AUD_DEBUG
>
831,833c834,836
<       dce_printf(aud_s_action_bit_set, guides_ptr->audit_action);
<       dce_printf(aud_s_condition_bit_set, guides_ptr->audit_condition);
<       dce_printf(aud_s_evt_classes);
---
>       DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1, "Audit Actions: %lx", guides_ptr->audit_action));
>       DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1, "Audit Conditions: %lx", guides_ptr->audit_condition));
>       DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1, "Audit Classes:"));
835c838
<           printf("\n");
---
>           DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1, "\n"));
839c842
<           printf("%ld ", ec_ptr->evt_class);
---
>           DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1, "%lx", ec_ptr->evt_class));
842c845
<       printf("\n");
---
>       DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1, "\n"));
844a848,850
>
> #endif /* DCE_AUD_DEBUG */
>
872c878
<       dce_printf(aud_s_no_filter);
---
>       dce_svc_printf(AUD_S_NO_FILTER_MSG);
~

4) The diff file esl_syn.c:

124,125c124,125
<           dce_printf(aud_s_stat_esl_file, ESL_FILE_NAME(esl_type));
<           *stp = aud_s_stat_esl_file;
---
>           dce_svc_printf(AUD_S_STAT_ESL_FILE_MSG, ESL_FILE_NAME(esl_type));
>           *stp = aud_s_stat_esl_file_rc;
157c157
<           dce_printf(aud_s_stat_esl_update_file,
---
>           dce_svc_printf(AUD_S_STAT_ESL_UPDATE_FILE_MSG,
159c159
<           *stp = aud_s_stat_esl_update_file;
---
>           *stp = aud_s_stat_esl_update_file_rc;
249,250c249,250
<       *status = aud_s_cannot_mkdir;
<       dce_printf(aud_s_cannot_mkdir, dname);
---
>       *status = aud_s_cannot_mkdir_rc;
>       dce_svc_printf(AUD_S_CANNOT_MKDIR_MSG, dname);
269c269,270
<       dce_printf(aud_s_cant_open_client_binding_file, fname);
---
>       dce_svc_printf(AUD_S_CANT_OPEN_CLIENT_BINDING_FILE_MSG, fname);
>         *status = aud_s_cant_open_client_binding_file_rc;
~

5) The diff file for evt_classes.c:

319c319
<                   dce_printf(aud_s_cannot_allocate_memory, i * sizeof(unsigned32));
---
>                   dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, i * sizeof(unsigned32));
334c334
<     dce_printf(aud_s_unknown_event_class, ec_name);
---
>     dce_svc_printf(AUD_S_UNKNOWN_EVENT_CLASS_MSG, ec_name);
356c356
<           dce_printf(aud_s_cannot_allocate_memory, i*sizeof(char *));
---
>           dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, i*sizeof(char *));
~

6) The diff file for evt_read.c:

293,294c293,294
<       dce_printf(aud_s_trail_file_corrupted, at->trail_file);
<       *status = aud_s_trail_file_corrupted;
---
>       dce_svc_printf(AUD_S_TRAIL_FILE_CORRUPTED_MSG, at->trail_file);
>       *status = aud_s_trail_file_corrupted_rc;
312c312
<       dce_printf(aud_s_cannot_allocate_memory,
---
>       dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG,
314c314
<       *status = aud_s_cannot_allocate_memory;
---
>       *status = aud_s_cannot_allocate_memory_rc;
385a386
>         dce_svc_printf(AUD_S_INVALID_RECORD_DESCRIPTOR_MSG);
425c426
<       dce_printf(aud_s_invalid_record_descriptor);
---
>       dce_svc_printf(AUD_S_INVALID_RECORD_DESCRIPTOR_MSG);
539c540
<       dce_printf(aud_s_invalid_record_descriptor);
---
>       dce_svc_printf(AUD_S_INVALID_RECORD_DESCRIPTOR_MSG);
585c586
<         dce_printf(aud_s_invalid_record_descriptor);
---
>         dce_svc_printf(AUD_S_INVALID_RECORD_DESCRIPTOR_MSG);
591c592
<       dce_printf(aud_s_cannot_allocate_memory, EVENT_BUF_SIZE);
---
>       dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, EVENT_BUF_SIZE);
593c594
<       *status = aud_s_cannot_allocate_memory;
---
>       *status = aud_s_cannot_allocate_memory_rc;
923,924c924,925
<       dce_printf(aud_s_cannot_allocate_memory, strlen(strbuf)+1);
<       *status = aud_s_cannot_allocate_memory;
---
>       dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, strlen(strbuf)+1);
>       *status = aud_s_cannot_allocate_memory_rc;
~

7) The diff file for evt_utils.c:

537c537
<           dce_printf(aud_s_trl_file_size_limit, backup_trail, backup_trail_index);
---
>           dce_svc_printf(AUD_S_TRL_FILE_SIZE_LIMIT_MSG, backup_trail, backup_trail_index);
542c542
<         dce_printf(aud_s_trl_write_failure);
---
>         dce_svc_printf(AUD_S_TRL_WRITE_FAILURE_MSG);
~

8) The diff file for trl_ops.c:

251c251
<       dce_printf(aud_s_cannot_allocate_memory,
---
>       dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG,
253c253
<       *stp = aud_s_cannot_allocate_memory;
---
>       *stp = aud_s_cannot_allocate_memory_rc;
286c286
<                 dce_printf(aud_s_invalid_audit_trail_size_limit);
---
>                 dce_svc_printf(AUD_S_INVALID_AUDIT_TRAIL_SIZE_LIMIT_MSG);
297c297
<               dce_printf(aud_s_cannot_init_trail_mutex);
---
>               dce_svc_printf(AUD_S_CANNOT_INIT_TRAIL_MUTEX_MSG);
345c345
<       dce_printf(aud_s_client_esl_mutex);
---
>       dce_svc_printf(AUD_S_CLIENT_ESL_MUTEX_MSG);
~

[12/13/95 public]

Corrections made in DCE 1.2.1
Closed

[09/30/96 public]
Fixed in 1.1 maintenance tree.

./security/audit/libaudit/esl_file_read.c
Comparing revision 1.1.10.1 with revision 1.1.10.2.
*** 1.1.10.1    1996/09/30 14:50:35
--- 1.1.10.2    1996/09/30 17:22:49
***************
*** 9,18 ****
  /*
   * HISTORY
   * $Log:	c012547,v $
# Revision 1.7  96/09/30  18:33:34  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
   * Revision 1.1.10.1  1996/09/30  14:50:35  mariko
   *    OT 13179:  hash_uuid_failed msg enhance
   *    [1996/09/30  14:49:42  mariko]
!  *
   * Revision 1.1.2.8  1994/04/10  19:57:52  weisz
   *    CR 10320: used memcpy in aud_esl_input_file and aud_esl_input_update_file
   *              instead of cast *(unsigned32 *)data_p to avoid alignment problem
--- 9,22 ----
  /*
   * HISTORY
   * $Log:	c012547,v $
# Revision 1.7  96/09/30  18:33:34  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
+  * Revision 1.1.10.2  1996/09/30  17:22:49  mariko
+  *    OT 12547: changed dce_printf() to dce_svc_printf()
+  *    [1996/09/30  17:21:11  mariko]
+  *
   * Revision 1.1.10.1  1996/09/30  14:50:35  mariko
   *    OT 13179:  hash_uuid_failed msg enhance
   *    [1996/09/30  14:49:42  mariko]
!  * 
   * Revision 1.1.2.8  1994/04/10  19:57:52  weisz
   *    CR 10320: used memcpy in aud_esl_input_file and aud_esl_input_update_file
   *              instead of cast *(unsigned32 *)data_p to avoid alignment problem
***************
*** 264,276 ****
      read(fd, (char *) &num_entries, sizeof(num_entries));
      read(fd, (char *) &file_version, sizeof(file_version));
      if (file_version != CURRENT_FILE_VERSION) {
!       dce_printf(aud_s_wrong_esl_file_version, fname);
        close(fd);
        return(0);
      }
      data_p = (char *) malloc(size);
      if (data_p == NULL) {
!       dce_printf(aud_s_cannot_allocate_memory, size);
        close(fd);
        return(0);
      }
--- 268,282 ----
      read(fd, (char *) &num_entries, sizeof(num_entries));
      read(fd, (char *) &file_version, sizeof(file_version));
      if (file_version != CURRENT_FILE_VERSION) {
!       /* OT 12547: use dce_svc_printf */
!       dce_svc_printf(AUD_S_WRONG_ESL_FILE_VERSION_MSG, fname);
        close(fd);
        return(0);
      }
      data_p = (char *) malloc(size);
      if (data_p == NULL) {
!       /* OT 12547: use dce_svc_printf */
!       dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, size);
        close(fd);
        return(0);
      }
***************
*** 279,285 ****
      close(fd);
  
      if (size_read != size) {
!       dce_printf(aud_s_cannot_read_file, fname);
        close(fd);
        return(0);
      } {
--- 285,292 ----
      close(fd);
  
      if (size_read != size) {
!       /* OT 12547: use dce_svc_printf */
!       dce_svc_printf(AUD_S_CANNOT_READ_FILE_MSG, fname);
        close(fd);
        return(0);
      } {
***************
*** 449,461 ****
      read(fd, (char *) &num_entries, sizeof(num_entries));
      read(fd, (char *) &file_version, sizeof(file_version));
      if (file_version != CURRENT_FILE_VERSION) {
!       dce_printf(aud_s_wrong_esl_updt_file_version, fname);
        close(fd);
        return(0);
      }
      data_p = (char *) malloc(size);
      if (data_p == NULL) {
!       dce_printf(aud_s_cannot_allocate_memory, size);
        close(fd);
        return(0);
      }
--- 456,470 ----
      read(fd, (char *) &num_entries, sizeof(num_entries));
      read(fd, (char *) &file_version, sizeof(file_version));
      if (file_version != CURRENT_FILE_VERSION) {
!       /* OT 12547: use dce_svc_printf */
!       dce_svc_printf(AUD_S_WRONG_ESL_UPDT_FILE_VERSION_MSG, fname);
        close(fd);
        return(0);
      }
      data_p = (char *) malloc(size);
      if (data_p == NULL) {
!       /* OT 12547: use dce_svc_printf */
!       dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, size);
        close(fd);
        return(0);
      }


./security/audit/libaudit/esl_in_core.c
Comparing revision 1.1.8.1 with revision 1.1.8.2.
*** 1.1.8.1     1996/09/30 14:50:33
--- 1.1.8.2     1996/09/30 17:22:50
***************
*** 9,18 ****
  /*
   * HISTORY
   * $Log:	c012547,v $
# Revision 1.7  96/09/30  18:33:34  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
   * Revision 1.1.8.1  1996/09/30  14:50:33  mariko
   *    OT 13179:  hash_uuid_failed msg enhance
   *    [1996/09/30  14:49:10  mariko]
!  *
   * Revision 1.1.2.4  1994/03/11  22:48:37  luan
   *    CR 9775 9776: Changed debug messages to use dce_svc_printf() or DCE_SVC_DEBUG.
   *    [1994/03/11  22:20:32  luan]
--- 9,22 ----
  /*
   * HISTORY
   * $Log:	c012547,v $
# Revision 1.7  96/09/30  18:33:34  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
+  * Revision 1.1.8.2  1996/09/30  17:22:50  mariko
+  *    OT 12547: changed dce_printf() to dce_svc_printf()
+  *    [1996/09/30  17:21:23  mariko]
+  *
   * Revision 1.1.8.1  1996/09/30  14:50:33  mariko
   *    OT 13179:  hash_uuid_failed msg enhance
   *    [1996/09/30  14:49:10  mariko]
!  * 
   * Revision 1.1.2.4  1994/03/11  22:48:37  luan
   *    CR 9775 9776: Changed debug messages to use dce_svc_printf() or DCE_SVC_DEBUG.
   *    [1994/03/11  22:20:32  luan]
***************
*** 783,789 ****
                malloc(sizeof(aud_esl_foreign_entry_t));
            if (entry_ptr == NULL) {
                *stp = aud_s_cannot_allocate_memory;
!               dce_printf(aud_s_cannot_allocate_memory, 
                                sizeof(aud_esl_foreign_entry_t));
                return;
            };
--- 787,794 ----
                malloc(sizeof(aud_esl_foreign_entry_t));
            if (entry_ptr == NULL) {
                *stp = aud_s_cannot_allocate_memory;
!               /* OT 12547: use dce_svc_printf */
!               dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, 
                                sizeof(aud_esl_foreign_entry_t));
                return;
            };
***************
*** 813,819 ****
                malloc(sizeof(aud_esl_entry_t));
            if (entry_ptr == NULL) {
                *stp = aud_s_cannot_allocate_memory;
!               dce_printf(aud_s_cannot_allocate_memory, 
                                sizeof(aud_esl_entry_t));
            };
  
--- 818,825 ----
                malloc(sizeof(aud_esl_entry_t));
            if (entry_ptr == NULL) {
                *stp = aud_s_cannot_allocate_memory;
!               /* OT 12547: use dce_svc_printf */
!               dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, 
                                sizeof(aud_esl_entry_t));
            };
  
***************
*** 847,855 ****
      aud_esl_evt_classes_p_t ec_ptr;
  
      while (guides_ptr != NULL) {
!       dce_printf(aud_s_action_bit_set, guides_ptr->audit_action);
!       dce_printf(aud_s_condition_bit_set, guides_ptr->audit_condition);
!       dce_printf(aud_s_evt_classes);
        if ((ec_ptr = guides_ptr->ec_list) == NULL) {
            printf("\n"); 
            return;
--- 853,862 ----
      aud_esl_evt_classes_p_t ec_ptr;
  
      while (guides_ptr != NULL) {
!       /* OT 12547: use dce_svc_printf */
!       dce_svc_printf(AUD_S_ACTION_BIT_SET_MSG, guides_ptr->audit_action);
!       dce_svc_printf(AUD_S_CONDITION_BIT_SET_MSG, guides_ptr->audit_condition);
!       dce_svc_printf(AUD_S_EVT_CLASSES_MSG);
        if ((ec_ptr = guides_ptr->ec_list) == NULL) {
            printf("\n"); 
            return;
***************
*** 888,894 ****
        }
        aud_esl_list_guides(guides_ptr);
      } else {
!       dce_printf(aud_s_no_filter);
      }
  }
  
--- 895,902 ----
        }
        aud_esl_list_guides(guides_ptr);
      } else {
!       /* OT 12547: use dce_svc_printf */
!       dce_svc_printf(AUD_S_NO_FILTER_MSG);
      }
  }
  

./security/audit/libaudit/esl_sync.c
Comparing revision 1.1.9.1 with revision 1.1.9.2.
*** 1.1.9.1     1995/02/16 22:03:48
--- 1.1.9.2     1996/09/30 17:22:52
***************
*** 9,18 ****
  /*
   * HISTORY
   * $Log:	c012547,v $
# Revision 1.7  96/09/30  18:33:34  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
   * Revision 1.1.9.1  1995/02/16  22:03:48  levy
   *    Submission of 1.1 unintegrated.
   *    [1995/02/16  20:42:35  levy]
!  *
   * Revision 1.1.7.1  1994/10/14  17:05:25  blazin
   *    Use correct number of args in call to aud_esl_clean_table.
   *    [1994/10/14  17:04:41  blazin]
--- 9,22 ----
  /*
   * HISTORY
   * $Log:	c012547,v $
# Revision 1.7  96/09/30  18:33:34  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
+  * Revision 1.1.9.2  1996/09/30  17:22:52  mariko
+  *    OT 12547: changed dce_printf() to dce_svc_printf()
+  *    [1996/09/30  17:21:34  mariko]
+  *
   * Revision 1.1.9.1  1995/02/16  22:03:48  levy
   *    Submission of 1.1 unintegrated.
   *    [1995/02/16  20:42:35  levy]
!  * 
   * Revision 1.1.7.1  1994/10/14  17:05:25  blazin
   *    Use correct number of args in call to aud_esl_clean_table.
   *    [1994/10/14  17:04:41  blazin]
***************
*** 125,131 ****
        /* Also don't forget that we have locked "esl_mutex". */
      } else {
          if (fstat(fd, &stat_buf) < 0) {
!           dce_printf(aud_s_stat_esl_file, ESL_FILE_NAME(esl_type));
            *stp = aud_s_stat_esl_file;
            pthread_mutex_unlock(&esl_mutex);
            return;
--- 129,136 ----
        /* Also don't forget that we have locked "esl_mutex". */
      } else {
          if (fstat(fd, &stat_buf) < 0) {
!           /* OT 12547: use dce_svc_printf */
!           dce_svc_printf(AUD_S_STAT_ESL_FILE_MSG, ESL_FILE_NAME(esl_type));
            *stp = aud_s_stat_esl_file;
            pthread_mutex_unlock(&esl_mutex);
            return;
***************
*** 158,164 ****
        /* Also don't forget that we have locked "esl_mutex". */
      } else {
          if (fstat(fd, &stat_buf) < 0) {
!           dce_printf(aud_s_stat_esl_update_file, 
                ESL_UPDATE_FILE_NAME(esl_type));
            *stp = aud_s_stat_esl_update_file;
            pthread_mutex_unlock(&esl_mutex);
--- 163,170 ----
        /* Also don't forget that we have locked "esl_mutex". */
      } else {
          if (fstat(fd, &stat_buf) < 0) {
!           /* OT 12547: use dce_svc_printf */
!           dce_svc_printf(AUD_S_STAT_ESL_UPDATE_FILE_MSG, 
                ESL_UPDATE_FILE_NAME(esl_type));
            *stp = aud_s_stat_esl_update_file;
            pthread_mutex_unlock(&esl_mutex);
***************
*** 251,257 ****
  
      if (mkdir(dname, 0700) == -1) {
        *status = aud_s_cannot_mkdir;
!       dce_printf(aud_s_cannot_mkdir, dname);
        return;
      }
      
--- 257,264 ----
  
      if (mkdir(dname, 0700) == -1) {
        *status = aud_s_cannot_mkdir;
!       /* OT 12547: use dce_svc_printf */
!       dce_svc_printf(AUD_S_CANNOT_MKDIR_MSG, dname);
        return;
      }
      
***************
*** 270,276 ****
          }
          close(fd);
      } else {
!       dce_printf(aud_s_cant_open_client_binding_file, fname);
      }
  
      rpc_server_register_if(update_v1_0_s_ifspec, 
--- 277,284 ----
          }
          close(fd);
      } else {
!       /* OT 12547: use dce_svc_printf */
!       dce_svc_printf(AUD_S_CANT_OPEN_CLIENT_BINDING_FILE_MSG, fname);
      }
  
      rpc_server_register_if(update_v1_0_s_ifspec, 



./security/audit/libaudit/evt_classes.c
Comparing revision 1.1.2.5 with revision 1.1.8.1.
*** 1.1.2.5     1994/04/28 13:50:33
--- 1.1.8.1     1996/09/30 17:22:53
***************
*** 9,18 ****
  /*
   * HISTORY
   * $Log:	c012547,v $
# Revision 1.7  96/09/30  18:33:34  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
   * Revision 1.1.2.5  1994/04/28  13:50:33  weisz
   *    CR 10469: initialize aud_g_cli_num_of_ecs to 0, in input_evt_table
   *    [1994/04/28  13:47:03  weisz]
!  *
   * Revision 1.1.2.4  1994/03/11  22:48:40  luan
   *    CR 10115: Added functions for maintaining an event class table.
   *    CR 9775 9776: Changed debug messages to use dce_svc_printf() or DCE_SVC_DEBUG.
--- 9,22 ----
  /*
   * HISTORY
   * $Log:	c012547,v $
# Revision 1.7  96/09/30  18:33:34  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
+  * Revision 1.1.8.1  1996/09/30  17:22:53  mariko
+  *    OT 12547: changed dce_printf() to dce_svc_printf()
+  *    [1996/09/30  17:21:46  mariko]
+  *
   * Revision 1.1.2.5  1994/04/28  13:50:33  weisz
   *    CR 10469: initialize aud_g_cli_num_of_ecs to 0, in input_evt_table
   *    [1994/04/28  13:47:03  weisz]
!  * 
   * Revision 1.1.2.4  1994/03/11  22:48:40  luan
   *    CR 10115: Added functions for maintaining an event class table.
   *    CR 9775 9776: Changed debug messages to use dce_svc_printf() or DCE_SVC_DEBUG.
***************
*** 316,322 ****
            if (i != 0) {
                *evts = (unsigned32 *) malloc (i * sizeof(unsigned32));
                if (evts == NULL) {
!                   dce_printf(aud_s_cannot_allocate_memory, i * sizeof(unsigned32));
                    return(FALSE);
                }
                evt_p = ec_p->evts;
--- 320,327 ----
            if (i != 0) {
                *evts = (unsigned32 *) malloc (i * sizeof(unsigned32));
                if (evts == NULL) {
!                   /* OT 12547:  use dce_svc_printf */
!                   dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, i * sizeof(unsigned32));
                    return(FALSE);
                }
                evt_p = ec_p->evts;
***************
*** 331,337 ****
        }
        ec_p = ec_p->next;
      }
!     dce_printf(aud_s_unknown_event_class, ec_name);
      return(FALSE);
  }
  
--- 336,343 ----
        }
        ec_p = ec_p->next;
      }
!     /* OT 12547:  use dce_svc_printf */
!     dce_svc_printf(AUD_S_UNKNOWN_EVENT_CLASS_MSG, ec_name);
      return(FALSE);
  }
  
***************
*** 353,359 ****
      if (i != 0) {
        *ec_names = (char **) malloc ( i * sizeof(char *));
        if (*ec_names == NULL) {
!           dce_printf(aud_s_cannot_allocate_memory, i*sizeof(char *));
            return(FALSE);
        }
        ec_p = ec_table;
--- 359,366 ----
      if (i != 0) {
        *ec_names = (char **) malloc ( i * sizeof(char *));
        if (*ec_names == NULL) {
!           /* OT 12547:  use dce_svc_printf */
!           dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, i*sizeof(char *));
            return(FALSE);
        }
        ec_p = ec_table;


./security/audit/libaudit/evt_read.c
Comparing revision 1.1.8.5 with revision 1.1.8.6.
*** 1.1.8.5     1996/09/30 16:32:24
--- 1.1.8.6     1996/09/30 17:22:55
***************
*** 9,18 ****
  /*
   * HISTORY
   * $Log:	c012547,v $
# Revision 1.7  96/09/30  18:33:34  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
   * Revision 1.1.8.5  1996/09/30  16:32:24  mariko
   *    OT 13312: Fixed several coding and logic errors
   *    [1996/09/30  16:32:02  mariko]
!  *
   * Revision 1.1.8.4  1996/09/30  15:21:36  mariko
   *    OT 13481:  dce_aud_get_ev_info must return when it reaches the limit
   *    [1996/09/30  15:21:12  mariko]
--- 9,22 ----
  /*
   * HISTORY
   * $Log:	c012547,v $
# Revision 1.7  96/09/30  18:33:34  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
+  * Revision 1.1.8.6  1996/09/30  17:22:55  mariko
+  *    OT 12547: changed dce_printf() to dce_svc_printf()
+  *    [1996/09/30  17:21:58  mariko]
+  *
   * Revision 1.1.8.5  1996/09/30  16:32:24  mariko
   *    OT 13312: Fixed several coding and logic errors
   *    [1996/09/30  16:32:02  mariko]
!  * 
   * Revision 1.1.8.4  1996/09/30  15:21:36  mariko
   *    OT 13481:  dce_aud_get_ev_info must return when it reaches the limit
   *    [1996/09/30  15:21:12  mariko]
***************
*** 340,346 ****
  #endif
      ep = (idl_byte *) malloc(esize);
      if (fread(ep, sizeof(idl_byte), esize, at->trail_fp) != esize) {
!       dce_printf(aud_s_trail_file_corrupted, at->trail_file);
        *status = aud_s_trail_file_corrupted;
        free(ep);
          if (local_predicate)
--- 344,351 ----
  #endif
      ep = (idl_byte *) malloc(esize);
      if (fread(ep, sizeof(idl_byte), esize, at->trail_fp) != esize) {
!       /* OT 12547: use dce_svc_printf */
!       dce_svc_printf(AUD_S_TRAIL_FILE_CORRUPTED_MSG, at->trail_file);
        *status = aud_s_trail_file_corrupted;
        free(ep);
          if (local_predicate)
***************
*** 372,378 ****
          if (BAD_STATUS(status))
              return;
        free(ep);
!       dce_printf(aud_s_cannot_allocate_memory, 
                sizeof(struct _dce_aud_rec_handle));
        *status = aud_s_cannot_allocate_memory;
        return;
--- 377,384 ----
          if (BAD_STATUS(status))
              return;
        free(ep);
!       /* OT 12547: use dce_svc_printf */
!       dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, 
                sizeof(struct _dce_aud_rec_handle));
        *status = aud_s_cannot_allocate_memory;
        return;
***************
*** 502,508 ****
  
      if (ard == NULL) {
        *status = aud_s_invalid_record_descriptor;
!       dce_printf(aud_s_invalid_record_descriptor);
        return;
      }
  
--- 508,515 ----
  
      if (ard == NULL) {
        *status = aud_s_invalid_record_descriptor;
!       /* OT 12547: use dce_svc_printf */
!       dce_svc_printf(AUD_S_INVALID_RECORD_DESCRIPTOR_MSG);
        return;
      }
  
***************
*** 617,623 ****
  
      if (ard == NULL) {
        *status = aud_s_invalid_record_descriptor;
!       dce_printf(aud_s_invalid_record_descriptor);
        return;
      }
  
--- 624,631 ----
  
      if (ard == NULL) {
        *status = aud_s_invalid_record_descriptor;
!       /* OT 12547: use dce_svc_printf */
!       dce_svc_printf(AUD_S_INVALID_RECORD_DESCRIPTOR_MSG);
        return;
      }
  
***************
*** 664,676 ****
  
      if (ard == NULL) {
        *status = aud_s_invalid_record_descriptor; 
!         dce_printf(aud_s_invalid_record_descriptor);
        return;
      }
  
      strbuf = (char *) malloc(EVENT_BUF_SIZE);
      if (strbuf == NULL) {
!       dce_printf(aud_s_cannot_allocate_memory, EVENT_BUF_SIZE);
        *buffer = NULL;
        *status = aud_s_cannot_allocate_memory;
        return;
--- 672,686 ----
  
      if (ard == NULL) {
        *status = aud_s_invalid_record_descriptor; 
!       /* OT 12547: use dce_svc_printf */
!         dce_svc_printf(AUD_S_INVALID_RECORD_DESCRIPTOR_MSG);
        return;
      }
  
      strbuf = (char *) malloc(EVENT_BUF_SIZE);
      if (strbuf == NULL) {
!       /* OT 12547: use dce_svc_printf */
!       dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, EVENT_BUF_SIZE);
        *buffer = NULL;
        *status = aud_s_cannot_allocate_memory;
        return;
***************
*** 1011,1017 ****
      sprintf(strbuf+index, "--- End of an event record --- \n\n\n");
      *buffer = (unsigned_char_t *) malloc(strlen(strbuf)+1);
      if (*buffer == NULL) {
!       dce_printf(aud_s_cannot_allocate_memory, strlen(strbuf)+1);
          sec_rgy_site_close(rgy_context, &tmp_status);
          free(strbuf);
        *status = aud_s_cannot_allocate_memory;
--- 1021,1028 ----
      sprintf(strbuf+index, "--- End of an event record --- \n\n\n");
      *buffer = (unsigned_char_t *) malloc(strlen(strbuf)+1);
      if (*buffer == NULL) {
!       /* OT 12547: use dce_svc_printf */
!       dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, strlen(strbuf)+1);
          sec_rgy_site_close(rgy_context, &tmp_status);
          free(strbuf);
        *status = aud_s_cannot_allocate_memory;


./security/audit/libaudit/evt_utils.c
Comparing revision 1.1.9.1 with revision 1.1.9.2.
*** 1.1.9.1     1996/09/30 15:12:45
--- 1.1.9.2     1996/09/30 17:22:56
***************
*** 9,18 ****
  /*
   * HISTORY
   * $Log:	c012547,v $
# Revision 1.7  96/09/30  18:33:34  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
   * Revision 1.1.9.1  1996/09/30  15:12:45  mariko
   *    OT 13502: Need to sync the file cursor if the trail is rewound in another process
   *    [1996/09/30  15:12:27  mariko]
!  *
   * Revision 1.1.2.9  1994/09/27  00:27:17  weisz
   *    CR 10703: in case of wrap, fopen flags should be wb+
   *    [1994/09/27  00:26:41  weisz]
--- 9,22 ----
  /*
   * HISTORY
   * $Log:	c012547,v $
# Revision 1.7  96/09/30  18:33:34  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
+  * Revision 1.1.9.2  1996/09/30  17:22:56  mariko
+  *    OT 12547: changed dce_printf() to dce_svc_printf()
+  *    [1996/09/30  17:22:10  mariko]
+  *
   * Revision 1.1.9.1  1996/09/30  15:12:45  mariko
   *    OT 13502: Need to sync the file cursor if the trail is rewound in another process
   *    [1996/09/30  15:12:27  mariko]
!  * 
   * Revision 1.1.2.9  1994/09/27  00:27:17  weisz
   *    CR 10703: in case of wrap, fopen flags should be wb+
   *    [1994/09/27  00:26:41  weisz]
***************
*** 539,550 ****
            at->md_index_fp = md_index_fp;
            at->md_index_fd = fileno(md_index_fp);
  
!           dce_printf(aud_s_trl_file_size_limit, backup_trail, backup_trail_index);
        }
     }
  
     if (fwrite(ep, sizeof(idl_byte), esize, at->trail_fp) != esize) {
!         dce_printf(aud_s_trl_write_failure);
          *status = aud_s_trl_write_failure;
          pthread_mutex_unlock(&at->mutex);
          return;
--- 543,556 ----
            at->md_index_fp = md_index_fp;
            at->md_index_fd = fileno(md_index_fp);
  
!         /* OT 12547: use dce_svc_printf */
!           dce_svc_printf(AUD_S_TRL_FILE_SIZE_LIMIT_MSG, backup_trail, backup_trail_index);
        }
     }
  
     if (fwrite(ep, sizeof(idl_byte), esize, at->trail_fp) != esize) {
!       /* OT 12547: use dce_svc_printf */
!         dce_svc_printf(AUD_S_TRL_WRITE_FAILURE_MSG);
          *status = aud_s_trl_write_failure;
          pthread_mutex_unlock(&at->mutex);
          return;


./security/audit/libaudit/trl_ops.c
Comparing revision 1.1.6.5 with revision 1.1.6.6.
*** 1.1.6.5     1996/09/30 15:29:16
--- 1.1.6.6     1996/09/30 17:22:57
***************
*** 9,18 ****
  /*
   * HISTORY
   * $Log:	c012547,v $
# Revision 1.7  96/09/30  18:33:34  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
   * Revision 1.1.6.5  1996/09/30  15:29:16  mariko
   *    OT 13180: Tighten permissions on audit trail and associated index files
   *    [1996/09/30  15:28:53  mariko]
!  *
   * Revision 1.1.6.4  1996/09/30  14:14:04  mariko
   *    OT 13139:  Destroy pthreads only when it exists
   *    [1996/09/30  14:13:42  mariko]
--- 9,22 ----
  /*
   * HISTORY
   * $Log:	c012547,v $
# Revision 1.7  96/09/30  18:33:34  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
+  * Revision 1.1.6.6  1996/09/30  17:22:57  mariko
+  *    OT 12547: changed dce_printf() to dce_svc_printf()
+  *    [1996/09/30  17:22:21  mariko]
+  *
   * Revision 1.1.6.5  1996/09/30  15:29:16  mariko
   *    OT 13180: Tighten permissions on audit trail and associated index files
   *    [1996/09/30  15:28:53  mariko]
!  * 
   * Revision 1.1.6.4  1996/09/30  14:14:04  mariko
   *    OT 13139:  Destroy pthreads only when it exists
   *    [1996/09/30  14:13:42  mariko]
***************
*** 277,283 ****
      *at = (struct _dce_aud_trail_handle *)
        malloc(sizeof(struct _dce_aud_trail_handle));
      if (*at == NULL) {
!       dce_printf(aud_s_cannot_allocate_memory, 
                        sizeof(struct _dce_aud_trail_handle));
        *stp = aud_s_cannot_allocate_memory;
      } else {
--- 281,288 ----
      *at = (struct _dce_aud_trail_handle *)
        malloc(sizeof(struct _dce_aud_trail_handle));
      if (*at == NULL) {
!       /* OT 12547: use dce_svc_printf */
!       dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, 
                        sizeof(struct _dce_aud_trail_handle));
        *stp = aud_s_cannot_allocate_memory;
      } else {
***************
*** 312,318 ****
  
                 if ((size_limit_value == 0) || (size_limit_value == ULONG_MAX))
                 {
!                 dce_printf(aud_s_invalid_audit_trail_size_limit);
                  *stp = aud_s_invalid_audit_trail_size_limit;
                  return;
                 }
--- 317,324 ----
  
                 if ((size_limit_value == 0) || (size_limit_value == ULONG_MAX))
                 {
!                 /* OT 12547: use dce_svc_printf */
!                 dce_svc_printf(AUD_S_INVALID_AUDIT_TRAIL_SIZE_LIMIT_MSG);
                  *stp = aud_s_invalid_audit_trail_size_limit;
                  return;
                 }
***************
*** 323,329 ****
  
            if (pthread_mutex_init(&(*at)->mutex, 
                                pthread_mutexattr_default)<0){
!               dce_printf(aud_s_cannot_init_trail_mutex);
                *stp = aud_s_cannot_init_trail_mutex;
                return;
            }
--- 329,336 ----
  
            if (pthread_mutex_init(&(*at)->mutex, 
                                pthread_mutexattr_default)<0){
!               /* OT 12547: use dce_svc_printf */
!               dce_svc_printf(AUD_S_CANNOT_INIT_TRAIL_MUTEX_MSG);
                *stp = aud_s_cannot_init_trail_mutex;
                return;
            }
***************
*** 372,378 ****
  
      if (pthread_mutex_init(&esl_mutex, pthread_mutexattr_default) 
                < 0) {
!       dce_printf(aud_s_client_esl_mutex);
        *stp = aud_s_client_esl_mutex;
      }
      else
--- 379,386 ----
  
      if (pthread_mutex_init(&esl_mutex, pthread_mutexattr_default) 
                < 0) {
!       /* OT 12547: use dce_svc_printf */
!       dce_svc_printf(AUD_S_CLIENT_ESL_MUTEX_MSG);
        *stp = aud_s_client_esl_mutex;
      }
      else


./security/audit/libaudit/aud.sams
Comparing revision 1.1.7.4 with revision 1.1.7.5.
*** 1.1.7.4     1996/09/30 16:32:23
--- 1.1.7.5     1996/09/30 17:22:48
***************
*** 6,16 ****
  # 
  # HISTORY
  # $Log:	c012547,v $
# Revision 1.7  96/09/30  18:33:34  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
  # Revision 1.1.7.4  1996/09/30  16:32:23  mariko
  #     OT 13312: coding errors in evt_read.c  Added "sub-compnent" and "attributes"
  #               to 'aud_s_cannot_allocate_memory' to avoid compilation error.
  #     [1996/09/30  16:30:59  mariko]
! #
  # Revision 1.1.7.3  1996/09/30  14:50:37  mariko
  #     OT 13179:  hash_uuid_failed msg enhance
  #     [1996/09/30  14:50:00  mariko]
--- 6,20 ----
  # 
  # HISTORY
  # $Log:	c012547,v $
# Revision 1.7  96/09/30  18:33:34  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [mariko 09/30/96 public]
# 
+ # Revision 1.1.7.5  1996/09/30  17:22:48  mariko
+ #     OT 12547: changed several svc_c_error to svc_c_sev_error
+ #     [1996/09/30  17:20:31  mariko]
+ #
  # Revision 1.1.7.4  1996/09/30  16:32:23  mariko
  #     OT 13312: coding errors in evt_read.c  Added "sub-compnent" and "attributes"
  #               to 'aud_s_cannot_allocate_memory' to avoid compilation error.
  #     [1996/09/30  16:30:59  mariko]
! # 
  # Revision 1.1.7.3  1996/09/30  14:50:37  mariko
  #     OT 13179:  hash_uuid_failed msg enhance
  #     [1996/09/30  14:50:00  mariko]
***************
*** 1032,1038 ****
  start
  code          aud_s_trl_full
  sub-component         aud_s_evt
! attributes    "svc_c_error"
  text          "The trail file is full"
  explanation   "The storage size limit for the audit trail file has been reached."
  action                "Empty the trail file and issue the \*Laud enable\*O command to restart the logging of audit records."
--- 1036,1042 ----
  start
  code          aud_s_trl_full
  sub-component         aud_s_evt
! attributes    "svc_c_sev_error"
  text          "The trail file is full"
  explanation   "The storage size limit for the audit trail file has been reached."
  action                "Empty the trail file and issue the \*Laud enable\*O command to restart the logging of audit records."
***************
*** 1041,1047 ****
  start
  code          aud_s_dmn_disabled
  sub-component aud_s_general
! attributes    "svc_c_error"
  text          "The daemon is disabled for logging"
  explanation   "An attempt was made to log an audit record but the Audit daemon has been disabled by the administrator."
  action                "Reenable the Audit daemon by issueing the \*Laud enable\*O command."  
--- 1045,1051 ----
  start
  code          aud_s_dmn_disabled
  sub-component aud_s_general
! attributes    "svc_c_sev_error"
  text          "The daemon is disabled for logging"
  explanation   "An attempt was made to log an audit record but the Audit daemon has been disabled by the administrator."
  action                "Reenable the Audit daemon by issueing the \*Laud enable\*O command."



CR Number                     : 12519
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : "diff" memory leak in dce_aud_free_header
Reported Date                 : 10/5/94
Found in Baseline             : 1.1b20
Found Date                    : 10/5/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : evt_utils.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/5/94 public]
Shyh-Wei Luan [<luan@almaden.ibm.com>]:

> I took another look at the code, and found that the way dce_aud_free_header()
> works now does NOT cause a memory leak if the caller is dce_aud_discard().
> That is, this was not a partial cause of dcecp's core dump on the large trail.
>
> The header structure is a part of the _dce_aud_rec_handle structure, which is
> freed by dce_aud_discard().
>
> struct _dce_aud_rec_handle {
>     dce_aud_hdr_t   header;
>     aud_log_ev_info_list_t *tail;
>     unsigned32      tail_read_cursor;
>     unsigned32      options;
>     aud_esl_act_t *as;  /* action specifiers */
> };
>
> Calling free() with the address of "header" in dce_aud_free_header() would
> actually free the WHOLE _dce_aud_rec_handle structure, which is freed again
> in dce_aud_discard() - a problem!
>
> Solution with a minimum change:
>
> dce_aud_free_header() should still free the header structure's memory (as
> I suggested yesterday), because it is paired with dce_aud_get_header() function.
>
> dce_aud_discard(), instead of calling dce_aud_free_header(), should directly
> free the structures within the header.  The header structure itself would be
> freed when the descriptor (struct _dce_aud_rec_handle) is freed.

[7/26/95 public]

IBM will look into this.  I'm not sure if this exists anymore due to the
description.  I would suspect that sometime in September we can get
to this.

[9/27/95 public]
The fix has been made.

[9/28/95 public]
Sorry, I did not know that I should include the diff file here. The diff file
and the new version of the evt_utils.c are also found in
/afs/dce.osf.org/project/dce/ibm/audit


346a347,349
>     dce_aud_hdr_t  *header;
>     int             id_index;
>
357a361,364
>
>     /* free all header components */
>
>     header = (dce_aud_hdr_t *)ard;
359c366,376
<     dce_aud_free_header(&ard->header, status);
---
>     if (header ->addr != NULL) {
>         free(header->addr);
>     }
>
>     for (id_index = header->num_client_ids - 1; id_index >= 0; id_index--) {
>          if (header->client_id[id_index].num_groups != 0) {
>              free(header->client_id[id_index].groups);
>          }
>     }
>
>     free(header->client_id);
~

[11/1/95 public]

The change made above is incorrect in doing "header = (dce_aud_hdr_t *)ard;".
It would work but not right. Change it to "header = ard->header;". Also, it
failed to free header in dce_aud_free_header routine. I'm proposing the 
following instead. This has little bit of cleanup also. Let me know if
you don't like the changes:

*** ./libaudit/evt_utils.c.save Wed Nov  1 15:03:47 1995
--- ./libaudit/evt_utils.c      Wed Nov  1 16:39:39 1995
***************
*** 297,303 ****
      free(tail);
  }

! void dce_aud_free_header
                  (
                                 dce_aud_hdr_t * header,
                                 error_status_t * status
--- 297,303 ----
      free(tail);
  }

! void dce_aud_free_header_internal
                  (
                                 dce_aud_hdr_t * header,
                                 error_status_t * status
***************
*** 304,327 ****
  ) {
      int               id_index;

!     if (header == NULL) {
!       return;
!     }

!     if (header->addr != NULL) {
!       free(header->addr);
      }

!     for (id_index = header->num_client_ids - 1; id_index >= 0; id_index--) {
!       if (header->client_id[id_index].num_groups != 0) {
!           free(header->client_id[id_index].groups);
!       }
      }
-     free(header->client_id);
-     *status = aud_s_ok;
-     return;
  }

  void     dce_aud_free_ev_info
                  (
                                 dce_aud_ev_info_t * info_item,
--- 304,337 ----
  ) {
      int               id_index;

!     if (header) {
!         if (header->addr != NULL) {
!           free(header->addr);
!         }

!         for (id_index = header->num_client_ids - 1; id_index >= 0; id_index--) {
!           if (header->client_id[id_index].num_groups != 0) {
!               free(header->client_id[id_index].groups);
!           }
!         }
!         free(header->client_id);
!         *status = aud_s_ok;
      }
+ }

! void dce_aud_free_header
!                 (
!                                dce_aud_hdr_t * header,
!                                error_status_t * status
! ) {
!
!     if (header) {
!         dce_aud_free_header_internal(header, status);
!         free(header);
      }
  }

+
  void     dce_aud_free_ev_info
                  (
                                 dce_aud_ev_info_t * info_item,
***************
*** 373,379 ****
        aud__log_free_ev_info_list(ard->tail);
      }

!     dce_aud_free_header(&ard->header, status);
      free(ard);
      return;
  }
--- 383,389 ----
        aud__log_free_ev_info_list(ard->tail);
      }

!     dce_aud_free_header_internal(&ard->header, status);
      free(ard);
      return;
  }

[7/18/96 public]
Fixed DCE1.2.2 (BL03).



CR Number                     : 12427
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : aud_s_dmn_disabled_in_selfaudit undeclared. Causes build to fail.
Reported Date                 : 9/30/94
Found in Baseline             : 1.1b20
Found Date                    : 9/30/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b21
Affected File(s)              : aud.sams
Sensitivity                   : public

[9/30/94 public]

Symbol 'aud_s_dmn_disabled_in_selfaudit' in file:
dce1.1/src/security/audit/auditd/dmn_rpc_manager.c is not defined.
libdce built and the test/install look ok. The auditd did not build 
on the HP. 

From the 486 build log. 

/project/dce/build/dce1.1-snap/src/security/audit/auditd/dmn_rpc_manager.c: In function `audit_control_show_filter':
/project/dce/build/dce1.1-snap/src/security/audit/auditd/dmn_rpc_manager.c:348: `aud_s_dmn_disabled_in_selfaudit' undeclared (first use this function)
/project/dce/build/dce1.1-snap/src/security/audit/auditd/dmn_rpc_manager.c:348: (Each undeclared identifier is reported only once
/project/dce/build/dce1.1-snap/src/security/audit/auditd/dmn_rpc_manager.c:348: for each function it appears in.)
/project/dce/build/dce1.1-snap/src/security/audit/auditd/dmn_rpc_manager.c: In function `audit_control_list_filter':
/project/dce/build/dce1.1-snap/src/security/audit/auditd/dmn_rpc_manager.c:445: `aud_s_dmn_disabled_in_selfaudit' undeclared (first use this function)
/project/dce/build/dce1.1-snap/src/security/audit/auditd/dmn_rpc_manager.c: In function `audit_control_add_filter':
/project/dce/build/dce1.1-snap/src/security/audit/auditd/dmn_rpc_manager.c:530: `aud_s_dmn_disabled_in_selfaudit' undeclared (first use this function)
/project/dce/build/dce1.1-snap/src/security/audit/auditd/dmn_rpc_manager.c: In function `audit_control_remove_filter':
/project/dce/build/dce1.1-snap/src/security/audit/auditd/dmn_rpc_manager.c:642: `aud_s_dmn_disabled_in_selfaudit' undeclared (first use this function)
/project/dce/build/dce1.1-snap/src/security/audit/auditd/dmn_rpc_manager.c: In function `audit_control_delete_filter':
/project/dce/build/dce1.1-snap/src/security/audit/auditd/dmn_rpc_manager.c:732: `aud_s_dmn_disabled_in_selfaudit' undeclared (first use this function)
/project/dce/build/dce1.1-snap/src/security/audit/auditd/dmn_rpc_manager.c: In function `audit_control_modify_sstrategy':
/project/dce/build/dce1.1-snap/src/security/audit/auditd/dmn_rpc_manager.c:806: `aud_s_dmn_disabled_in_selfaudit' undeclared (first use this function)
/project/dce/build/dce1.1-snap/src/security/audit/auditd/dmn_rpc_manager.c: In function `audit_control_show_sstrategy':
/project/dce/build/dce1.1-snap/src/security/audit/auditd/dmn_rpc_manager.c:838: `aud_s_dmn_disabled_in_selfaudit' undeclared (first use this function)
/project/dce/build/dce1.1-snap/src/security/audit/auditd/dmn_rpc_manager.c: In function `audit_control_show_state':
/project/dce/build/dce1.1-snap/src/security/audit/auditd/dmn_rpc_manager.c:933: `aud_s_dmn_disabled_in_selfaudit' undeclared (first use this function)
*** Error code 1

[9/30/94 public]
All of these boil down to the addition and use of the CHECK_SELFAUDIT_STATE
macro.  That macro mentions aud_s_dmn_disabled_in_selfaudit but the
libaudit/aud.sams file does not.  There is a aud_s_dmn_disabled in the
aud.sams file but the file has not been updated since 9/22 and the
dmn_rpc_manager file was submitted yesterday.  I'm not sure if the status
code is wrong in CHECK_SELFAUDIT_STATE or if the aud.sams file was not
submitted.  

Please fix this immediately, we wanted a good build thursday night to run
the weekend system tests.

[9/30/94 public]
Forgot to submit aud.sams yesterday, as part of 12304.  Just did it now.



CR Number                     : 12406
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 9834
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : fvts
Short Description             : api_log_to_daemon tests need updateing
Reported Date                 : 9/29/94
Found in Baseline             : 1.1b19
Found Date                    : 9/29/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b21
Affected File(s)              : api_log_to_daemon/aud_testd_rpc_manager.c
Sensitivity                   : public

[9/29/94 public]
Due to the changes made for CR 9834, the api_log_to_daemon test needs
updating.

[09/29/94 public]
fixed.



CR Number                     : 12391
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 12174
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : fvts
Short Description             : fvts must be updated to match exit codes from dcecp
Reported Date                 : 9/28/94
Found in Baseline             : 1.1b19
Found Date                    : 9/27/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b20
Affected File(s)              : cp_filter
Sensitivity                   : public

[9/28/94 public]
Some of the audit fvts such as cp_filter04 now fail because the exit
codes from dcecp hav been updated.  The audit fvts need revision.

[10/14/94 public]
This was fixed back in build 20.  Have marked this closed.



CR Number                     : 12304
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : aud disable returns error
Reported Date                 : 9/22/94
Found in Baseline             : 1.1b18
Found Date                    : 9/22/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b21
Affected File(s)              : dmn_rpc_manager.c dmn_main.c aud.sams
Sensitivity                   : public

[9/22/94 public]
"aud disable" should not return this error:

dcecp> aud disable
Error: The daemon disabled for logging

...the daemon should hide the problem that it was not able to log
this event to the central trail.


Also, all subsequent dcecp audit operations succeed, but return the
same message, "The daemon disabled for logging" (should be "The daemon
is disabled for logging."). All these internal attempts to log events
should be hidden from the client.

[09/22/94 public]
Is the problem that the daemon is returning info to dcecp
which dcecp is printing or is this a message that comes directly
from the daemon.

Also, I do not understand why we should hide from a client the
fact that the daemon is disabled.  This is valuable information
that a client can use, especially if this is a client that relies
on auditting being active.

[9/22/94 public]
The message is being returned as a status code from the RPC. Robert
and I have already discussed this over the phone, and we both understand
what the issues are. The CR is just a place holder for the changes.

I am not suggesting that the info about the client being disabled be
hidden. What I am asking for is that the audit daemons inability to
log it's own events (I started auditd with -a) be hidden from the
control interface. I know that the daemon is disabled, I disabled it.
I don't care if the daemon can't log the disable event to it's own log
becuase I disabled it.

[02/26/94 public]
Downgraded because this is not a P0 nor does it cause a test to fail.

[02/26/94 public]
Changed priority back to P1 as this failure does indeed cause the dcecp
audit tests to fail.

[09/30/94 public]
Fixed.
Ensured checking is done at the rpc interfaces for the auditd
disabled state, and ensure logging during self audit is done
according to the state.



CR Number                     : 12300
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaud
Short Description             : libaud needs to be made public
Reported Date                 : 9/22/94
Found in Baseline             : 1.1b18
Found Date                    : 9/22/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b20
Affected File(s)              : dce_config, .../libaudit/Makefile
Sensitivity                   : public

[9/22/94 public]
For 1.1, libaud will not be folded into libdce.  Therefore, we must
insure that it is properly and completely exported for use by
developers.  We also need to make sure this is properly documented.

The work that needs to be done is as follows:

	1. Alter libaudit Makefile to install libaudit
	2. Test in sandbox.  Only one platform is necessary.

[09/26/94 public]
Upgrade to P0.  This is missing functionality that MUST be available
for GA else the public APIs will not be accessable to the public.

[9/28/94 public]
Fixed. libaudit.a is now copied into the install area by the install pass
of the build and then installed in /opt/dcelocal/usr/lib by dce_config.

[09/29/94 public]
Verified fix and closed CR.



CR Number                     : 12290
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 10703
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : admin_gd
Short Description             : update documentation for audit trail full (CR 10703)
Reported Date                 : 9/21/94
Found in Baseline             : 1.1
Found Date                    : 9/21/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b20
Affected File(s)              : admin_gd/security/security/15_audit_tasks.gpsml
Sensitivity                   : public

[9/21/94 public]
CR 10703 has changed a few things in audit trail handling, which need
to be documented.

[10/18/94 public]
Changed the section on controlling the audit trail size to reflect the
changes made.

[10/27/94 public]
Closed bug.



CR Number                     : 12273
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : "diff" APIs do not consistently check for validity of input args
Reported Date                 : 9/20/94
Found in Baseline             : 1.1b18
Found Date                    : 9/20/94
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : trl_ops.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/20/94 public]
While reviewing the audit api reference pages, I discoverd that the
status outputs do not always follow the code.  More importantly,
the function, dce_aud_close does not validate its input parameter,
at.  At least the value null should be checked for.  This is done
in some of the other audit apis.  It is also worth check the other
apis to verify that the input args are being verified whereever possible.

[7/26/95 public]

IBM will look into this. Audit is not the only code in DCE that does
not check its input parameters.  I know that in dce/utils this happens
as well, and probably lots of other places too.  

I think Jerry is describing two problems here, one with the man pages.
Is there a seperate man page defect?

[07/27/95 public]
Perhaps this can be turned into the manpage defect.  Checking for NULLs
is something DCE *does not do.*  Jerry Kazin was new to the project,
and missed all that fun discussion back when.

[9/26/95 public]
The fix has been made.

[9/28/95 public]
Sorry, I did not include the diff file.  The diff file and the new version
of trl_ops.c are also found in /afs/dce.osf.org/project/dce/ibm/audit


394a395,399
>     if (at == NULL) {
>        *status = aud_s_invalid_trail_descriptor;
>         return;
>     }
>

[10/01/95 public]
Do not do this.  This is a bad thing -- it will only mask errors (e.g.,
malloc failures) that the higher-level code should have caught and
responded to earlier.  Far better to let a core dump happen and get the
real cause of the error fixed.

[7/18/96 public]
Fixed in DCE1.2.2 (BL03).



CR Number                     : 12248
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : functional test
Short Description             : Running audit FVTs leaves incorrect audit-server acl entry for user.
Reported Date                 : 9/19/94
Found in Baseline             : 1.1b18
Found Date                    : 9/19/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b19
Affected File(s)              : test/security/audit/ts/api_log_to_daemon/aud_testd.c
Sensitivity                   : public

[9/19/94 public]

When you run the audit FVTs, the user entry in the default acl for the
audit-server has "r" permission incorrectly removed.

[9/19/94 public]
Oops! I should have written "l" not "r".  That is, running the tests
removes logging permission.

[09/21/94 public]
fixed.



CR Number                     : 12223
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : inconsistent permissions check at auditd rpc interfaces, also return if no permissions
Reported Date                 : 9/16/94
Found in Baseline             : 1.1
Found Date                    : 9/16/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b19
Affected File(s)              : auditd/dmn_rpc_manager.c, dce_config
Sensitivity                   : public

[9/16/94 public]
Some of the auditd rpc interfaces are not checked for proper
authorization (dce) and for proper protection level (packet privacy)
while others are.  Make the check consistent and if protection is not
adequate, do not perform operation.

[9/20/94]
As part of the consistency issue: all auditd interfaces that were
performing permissions checking, were also generating audit records
when auditd is put in self auditing mode.  Since  permissions
checking to the rpc interfaces which were not covered yet,
code points were added as well, and these audit events were put into two
new event classes, which need to be installed.

[09/29/94 public]
Verified the fix.



CR Number                     : 12167
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : HYP: Regression test failures in api_filter and ec_filter test suites
Reported Date                 : 9/13/94
Found in Baseline             : 1.1b17
Found Date                    : 9/13/94
Severity                      : B
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b21
Affected File(s)              : see list below
Sensitivity                   : public

[9/13/94 public]

When running the audit FVTs on my 486 on BL-17, I am getting inconsistent
results with the api_log_to_daemon tests and with the api_filter tests.

The first time I run these tests after starting DCE I get this kind of
failure:

  After 1st start of DCE:

	520|4 1 27847 1 3|ERROR: api_log_to_daemon01 failed

  After restart of DCE:

	520|4 1 24667 1 6|ERROR: api_log_to_daemon04 failed

Subsequent runs of the audit FVTs either PASS completely or yield the
following failures:

	20|6 1 26228 1 4|ERROR: api_filter02 failed
	520|6 1 26228 1 5|ERROR: api_filter03 failed
	520|6 1 26228 1 10|ERROR: api_filter08 failed

When I see these failures, a core file is also dropped into /tmp.  Looking
at this core file I see:

> In Local core dump file,
> #0  0x405273 in op4_csr (h=0xa403fea4, st=0x4f2010) at aud_testf_cstub.c:533
> aud_testf_cstub.c:533: No such file or directory.
> (gdb) where
> #0  0x405273 in op4_csr (h=0xa403fea4, st=0x4f2010) at aud_testf_cstub.c:533
> #1  0x404ce2 in op2_csr (Cannot access memory at address 0x4392bb.
>

The tests appears to be crashing in the cstub routing. Line 533 is

	CATCH(rpc_x_ss_pipe_comm_error)

so we may be experiencing some kind of comm error.  

Robert Weisz points out that the sequence jumping from op2_csr to op4_csr
is not making any sense.  He doesn't know what to make out of it.

[10/03/94]
The test results are now consistent but we still have test failures on
tests that previously passed.  Specifically, the following tests fail:

520|6 1 5582 1 4|ERROR: api_filter02 failed
520|6 1 5582 1 5|ERROR: api_filter03 failed
520|6 1 5582 1 7|ERROR: api_filter05 failed
520|7 1 5686 1 3|ERROR: ecfile_filter01 failed

The short description, area, and priority have been updated.

[10/3/94 public]
On hypercritical list.

[10/04/94 public]
This problem is caused by the fact that both security and audit are
using same event numbers.  I am changing the audit event numbers to
use a different range and will submit today.
 In the future, OSF will have to administer the allocation of those
ranges of numbers.

[10/05/94 public]
Submitted, please rerun.

These are the files affected:

    audit/ec/dce_audit_admin_modify
    audit/ec/dce_audit_admin_query
    audit/ec/dce_audit_filter_modify
    audit/ec/dce_audit_filter_query
    audit/auditd/dmn_aud_evtsp.h

    test/security/audit/ts/api_filter/aud_testf_rpc_manager.c
    test/security/audit/ts/ecfile_filter/aud_testec_rpc_manager.c



CR Number                     : 12029
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : formatting problems in dce_aud_print
Reported Date                 : 9/2/94
Found in Baseline             : 1.1
Found Date                    : 9/2/94
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b17
Affected File(s)              : evt_read.c
Sensitivity                   : public

[9/2/94 public]
Some specific event info items, are not formatted properly when
the audit trail is read.

[09/07/94 public]
Fixed.



CR Number                     : 11884
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : audit causes secd to loop
Reported Date                 : 8/25/94
Found in Baseline             : 1.1
Found Date                    : 8/25/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b17
Affected File(s)              : audit.h evt_read.c evt_write.c and tests
Sensitivity                   : public

[8/25/94 public]
Audit library trying to translate a name to a uuid by calling a
security API, causes a loop in secd since the security API contains
an audit codepoint which calls the audit library in turn.
A new audit API, dce_aud_start_with_uuid will be created, and used
by secd in order to avoid this problem.

[8/31/94 public]
Done.  Added dce_aud_start_with_uuid API.



CR Number                     : 11764
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : "diff" dce_aud_print returns in with error when context is not certified
Reported Date                 : 8/18/94
Found in Baseline             : 1.1b14
Found Date                    : 8/18/94
Severity                      : D
Priority                      : 4
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : evt_read.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/18/94 public]
dce_aud_print() is returning the warning sec_login_s_not_certified as
an error from sec_login_inquire_net_info(). The current fix to this
problem is to ignore this specific return from inquire_net_info().
There may be some future changes needed to tighten up security.
Upon receiving any non-successful status from any of the sec calls,
this routine may want to just print out uuid strings instead of 
possibly spoofed registry info.

[8/18/94 public]
Submitted change to ignore the sec_login_s_not_certified. I'll
leave this open at a very low priority just in case somebody
wantes to revisit the issue.

[9/26/95 public]
The fix has been made.

[9/28/95 public]
Sorry, I didi not include the diff file.  The diff file and the new version
of evt_read.c are also found in /afs/dce.osf.org/project/dce/ibm/audit


22,623c622,629
<               if ((*status != error_status_ok)
<                  && (*status != sec_login_s_not_certified)) return;
---
>
>               if (*status != error_status_ok)
>               {
>                  if (*status == sec_login_s_not_certified)
>                     output_uuids = TRUE;
>                  else
>                     return;
>               }



CR Number                     : 11742
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 11443
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : app_ref
Short Description             : add new outcome to dce_aud_start/dce_aud_commit
Reported Date                 : 8/17/94
Found in Baseline             : 1.1b11
Found Date                    : 8/17/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b18
Affected File(s)              : app_ref/man3sec/dce_aud_commit.3sec dce_aud_start.3sec
Sensitivity                   : public

[8/17/94 public]
A new outcome, PENDING, has been added as allowable input to 
dce_aud_start and dce_aud_commit, in addition to existing 
SUCCESS, DENIAL and FAILURE.

[08/18/94 public]
Assigned to writer Willie Williams (Audit Subsys doc owner).

[08/30/94 public]
Per Hal Lichtin's request, reassigned to Rico Cruz at IBM.

[09/12/94]
Added the new PENDING outcome to the documentation.

[10/27/94 public]
Closed bug.



CR Number                     : 11686
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 11431
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : Need to remove -i option and
add text for audit-admin group
Reported Date                 : 8/15/94
Found in Baseline             : 1.1b12
Found Date                    : 8/15/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : command_ref/man8sec/auditd.8sec
Sensitivity                   : public

[8/15/94 public]

auditd now runs as machine principle. (See 11431 for details as to why this
was done.)  When this was done, the "-i" identity option was removed.  This
needs to be reflected in the admin guide and in the ref pages.

Also, the audit-admin group was added to allow for easier management of the
auditd.  This needs to be reflected in the admin guide.

[08/16/94 public]
Reassigned to myself, since I am working on the rest of
the audit ref pages.

[09/15/94 public]
The -i option has been removed from the auditd.8sec reference
page in the Command Ref, and a mention of auditd running as
machine principal has been added.

I opened a new CR, #12210, to cover the documenting of the
new group audit-admin, since this enhancement may affect 
more than one Admin Guide Intro chapters and thus deserves 
its own CR.

[09/22/94 public]
Closed bug.



CR Number                     : 11642
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : unregister interfaces from endpoint mapper on shutdown
Reported Date                 : 8/10/94
Found in Baseline             : 1.1
Found Date                    : 8/10/94
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b15
Affected File(s)              : dmn_main.c
Sensitivity                   : public

[8/10/94 public]
Add rpc_ep_unregister for all previously registered interfaces
with the endpoint mapper.

[8/15/94 public]
Fixed.



CR Number                     : 11603
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : dce_aud_put_ev_info
Short Description             : Should check for NULL data before string copying
Reported Date                 : 8/8/94
Found in Baseline             : 1.1b14
Found Date                    : 8/8/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b15
Affected File(s)              : evt_write.c
Sensitivity                   : public

[8/8/94 public]

In evt_write.c:dce_aud_put_ev_info() there are at least 2 places where a
valid NULL pointer will cause a core dump of the calling process (secd)  
They are:

    case aud_c_evt_info_byte_string:
	{
	    idl_byte       *cp = (idl_byte *)
	    malloc(strlen((char *)info.data.byte_string) + 1);
	    strcpy((char *) cp, (char *) info.data.byte_string);
	    evip->tagged_union.byte_string = cp;
	}
	break;

    case aud_c_evt_info_char_string:
	{
	    idl_char       *cp = (idl_char *)
	    malloc(strlen((char *) info.data.char_string) + 1);
	    strcpy((char *) cp, (char *) info.data.char_string);
	    evip->tagged_union.char_string = cp;
	}
	break;

where the info.data.byte_string or info.data.char_string fields can be
NULL.  This happens when running the SEC ERA FVT's with the as-yet-to
be checked in auditing code in place.

[08/10/94 public]
Fixed.
When the user invokes the dce_aud_put_ev_info API in order to store some
event specific information, and then the pointer to that data is a NULL 
pointer, the audit library is not going to cause a crash anymore, it is
just going to ignore the request and return.



CR Number                     : 11444
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 11810
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : Can't get filters to work with auditd
Reported Date                 : 7/26/94
Found in Baseline             : 1.1
Found Date                    : 7/26/94
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b20
Affected File(s)              : admin_gd/security/security/15_audit_tasks.gpsml
Sensitivity                   : public

[7/26/94 public]

This was formerly part of 11429 -

Having auditd already running (and no env var set), I first added a couple 
of auditing related filters for principal cell_admin:

# auditcp
auditcp> audfilter add
Enter
0 for principal
1 for foreign principal
2 for group
3 for foreign group
4 for cell
5 for cell overridable
6 for world
7 for world overridable
0
Enter Subject Name (press enter if no more subject): cell_admin
Enter Audit Condition (press entrer if no more condition): all
Enter Audit Condition (press entrer if no more condition):
Enter Audit Action (press entrer if no more action): log
Enter Audit Action (press entrer if no more action):
Enter Event Class (press enter if no more event classes): dce_audit_filter_query
Enter Event Class (press enter if no more event classes): dce_audit_filter_modify
Enter Event Class (press enter if no more event classes):
More Guides? (n)/y
auditcp> q

Tailing the /tmp/messages svc file we see:

1994-07-23-21:27:23.166-04:00I----- auditd ERROR aud esl 0x40139268 unable to inform 
process /opt/dcelocal/var/audit/client/16091/update_binding_file about esl update
1994-07-23-21:27:58.166-04:00I----- auditd ERROR aud esl 0x40139268 unable to inform 
process /opt/dcelocal/var/audit/client/19800/update_binding_file about esl update
1994-07-23-21:28:33.167-04:00I----- auditd ERROR aud esl 0x40139268 unable to inform 
process /opt/dcelocal/var/audit/client/19851/update_binding_file about esl update

This doesn't look too good, but let's try killing auditd, set the DCEAUDITFILTER
env var on and restarting auditd.  Here's what I got when I did a rc.dce on the 
restart:

1994-07-23-21:31:51.834-04:00I----- auditd NOTICE_VERBOSE aud general 0x7aff2d60 s
et daemon locale: /:C;:C;:C;:C;:C;:C;:C;/
1994-07-23-21:31:51.846-04:00I----- auditd NOTICE aud general 0x7aff2d60 the audit
 daemon started
1994-07-23-21:31:51.982-04:00I----- auditd NOTICE_VERBOSE aud general 0x7aff2d60 d
aemon registered interfaces with RPC runtime
1994-07-23-21:31:55.287-04:00I----- auditd FATAL aud general 0x7aff2d60 cannot reg
ister daemon's ACL manager interface bindings

More not too goods as auditd died.  I tried a couple of different things, but the 
only way I could get auditd up and running was to go through dce_config, using
the configure option to bring up auditd.  Taking a look through the svc trace
below and again above, it appears that there is a defect in auditd being able to 
ascertain its authent identity when not using dce_config/config.  (Note that the 
config will query for the cell admin principal name and password, whereas rc.dce
does not.)  This (as indicated above) results in a failure when trying to
register auditd ACL manager bindings. 

1994-07-23-21:47:26.307-04:00I----- auditd NOTICE_VERBOSE aud general 0x7aff2d60 s
et daemon locale: /:C;:C;:C;:C;:C;:C;:C;/
1994-07-23-21:47:26.318-04:00I----- auditd NOTICE aud general 0x7aff2d60 the audit
 daemon started
1994-07-23-21:47:26.420-04:00I----- auditd NOTICE_VERBOSE aud general 0x7aff2d60 d
aemon registered interfaces with RPC runtime
1994-07-23-21:47:31.425-04:00I----- auditd NOTICE_VERBOSE aud general 0x7aff2d60 d
aemon registered its authentication identity hosts/engobe/self with RPC runtime
1994-07-23-21:47:31.597-04:00I----- auditd NOTICE_VERBOSE aud general 0x4013b9a8 d
aemon is ready to listen to its interfaces

auditd now seems to be happy... let's try dumping out the filters that
I set earlier:

# auditcp
auditcp> audfilter show
Enter
0 for principal
1 for foreign principal
2 for group
3 for foreign group
4 for cell
5 for cell overridable
6 for world
7 for world overridable
0
Enter Subject Name (press enter if no more subject): cell_admin
Audit Actions:
log
Audit Conditions:
success failure denial  (all)
Event Classes:
dce_audit_filter_query dce_audit_filter_modify
auditcp>
Everything looks good.  Now let's try doing something that will result
in an auditable event - (audfilter remove of principal cell_admin):

# date
Sat Jul 23 22:50:32 EDT 1994
# auditcp
auditcp> audfilter remove
Enter
0 for principal
1 for foreign principal
2 for group
3 for foreign group
4 for cell
5 for cell overridable
6 for world
7 for world overridable
0
Enter Subject Name (press enter if no more subject): cell_admin
Enter Audit Condition (press entrer if no more condition): all
Enter Audit Condition (press entrer if no more condition):
Enter Audit Action (press entrer if no more action): log
Enter Audit Action (press entrer if no more action):
Enter Event Class (press enter if no more event classes): dce_audit_filter_query
Enter Event Class (press enter if no more event classes):
More Guides? (n)/y
auditcp>
#
The svc file says:

1994-07-23-22:51:44.170-04:00I----- auditd ERROR aud esl 0x4012f1c8 unable to info
rm process /opt/dcelocal/var/audit/client/16091/update_binding_file about esl update
1994-07-23-22:52:19.171-04:00I----- auditd ERROR aud esl 0x4012f1c8 unable to info
rm process /opt/dcelocal/var/audit/client/19800/update_binding_file about esl update
1994-07-23-22:52:54.171-04:00I----- auditd ERROR aud esl 0x4012f1c8 unable to info
rm process /opt/dcelocal/var/audit/client/19851/update_binding_file about esl update
1994-07-23-22:52:54.187-04:00I----- auditd WARNING aud esl 0x40128b68 cannot open
esl file /opt/dcelocal/var/audit/esl-princ

This looks bad.  It can't even open the principal's esl file!  However, auditcp 
doesn't indicate any sort of error - one would assume that this command had
succeeded!!!!

Meanwhile, the central trail isn't even logging auditable events:

/net/engobe/opt/dcelocal/var/audit/adm --> ls -l
total 2
-rw-r--r--   1 root     sys          224 Jul 23 21:35 acl
-rw-rw-rw-   1 root     sys            0 Jul 23 20:55 central_trail
-rw-rw-rw-   1 root     sys            0 Jul 23 20:55 central_trail.md_index

Busted!

[7/27/94 public]
In the first sentence you indicate that "(and no env var set)", i.e. 
DCEAUDITFILTERON is not set either.
What were you trying to achieve, when adding/removing filters, while
DCEAUDITFILTERON was not set?   If you intend to use filters, this 
environment variable has to be set.
(it might be an interesting test scenario for negative testing, but 
that's about it.)

[7/27/94 public]
Actualy I got confused, there are here 3 different scenarios.
The first one, about the auditd reporting error:
"unable to inform process /opt/dcelocal/var/audit/client/16091/update_binding_f
ile about esl update".
An administrative action, whenever a audit client crashes, is to remove
the "16091/update_binding_file"  directory/file combination.
These files, are used by the audit daemon, to find out its clients, and notify
them about any filter changes.  Whenever audit clients are coming down
gracefully, they clean up these files, among other things, but not in case
of crashes, obviously.
The number 16091 is the pid of the audit client process, so you can know
that if a directory is there with a number not matching any live process pid,
it should be removed.    
The second scenario, with the "cannot register daemon's ACL manager interface
bindings", there is a CR open already, CR 11243.
The third one, it was not specified whether DCEAUDITFILTERON was set or not.
Will look into it.

[7/27/94 public]
About the third scenario: the "cannot open esl file ...../esl-princ" is just
a warning, not an error, and without getting into internals, it could be
quite ok.  Try performing the auditcp audfilter show operation before giving up.
It might very well work...
About not seeing the audit trail grow, the reason is that the operating system
is buffering the data, before writing it to the physical device.
If you would take auditd down, using auditcp, not kill, the buffer would be 
flushed to disk on termination of the process.  Or, if producing enough 
audit records, the buffer would get flushed automaticaly every so often.
(size of buffer is system dependent).

[7/28/94 public]

I've been able to get auditd started with the DCEAUDITFILTERON environment
variable set.  I've been able to add and view filters for auditd events, BUT
I still don't see any data being logged to the central trail file for auditd.
Without seeing data there, I can't tell if filters are even working.  I even
shut the auditd down to see if that would force the event records to be flushed
to disk.  Still nothing.  

How do I tell if filters are working? My acceptance procedure dictated that I
would set a filter and verify that the audit trail contained the appropriate
data based on the filter. 

I still think there's a problem here, but I don't konw if it's that I'm not
doing everything I'm supposed to be doing (doc issue) or that auditd doesn't
work as I expected it to...

[7/28/94 public]

There are a few things to check here.  Did you start auditd with the "-a" option
(for self auditing)?  Did you make sure that DCEAUDITOFF is unset?  Did you create
the right filter to capture the event/subject/outcome for which you like
to see audit record(s)?  (The scenario you described at the beginning of this
OT should do it if you were using cell_admin to remove the filter.)  

If you wish to see if auditd is appending audit records to its central
trail, try the "-D" option when starting auditd. You will see the 
length and address of the pickled audit record that is being appended.  These
are generated by two printf's (probably among a few others that I was not able
to clean up before I left the project).  These really should be removed or 
replaced by svc statements now.

[8/4/94 public]
Changed priority to 1.  This still needs to be fixed but it's isn't holding
anyone else up.

[8/29/94 public]
This is a doc bug if anything.  I'm going to dup it into 11810 - which is
logged against sec, but really applies to auditd and dtsd as well.

[9/12/94 public]
The following information is from Rico Cruz at IBM.  I am therefore
reopening this CR.
"11444 and 11810 are really two different CRs and not dupes.
11444 is a "give-us-an-example-of-how-to-use-the-auditcp" CR.
11810 is a CR on a default filter that they are planning to ship
and therefore should be documented in the pubs.
I will address each separately (Robert Weisz "owns" 11444)."

[10/18/94 public]
Added a new section in the Admin Guide on enabling audit filtering. 
This include info on the removal of the update binding file, the
DCEAUDITFILTERON env variable, and how the OS buffers the audit trail file.

[10/27/94 public]
Closed bug.



CR Number                     : 11443
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : unable to log events with unknown
outcome
Reported Date                 : 7/26/94
Found in Baseline             : 1.1
Found Date                    : 7/26/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b15
Affected File(s)              : evt_write.c evt_read.c audit_control.idl trl_ops.c evtp.h aud.sams api_log testsuite
Sensitivity                   : public

[7/26/94 public]

  From our reading of the Spec, we thought that we'd be
  able to log events with "Unknown" outcomes.  This is displayed
  in an audtrail show as outcome = success failure denial whenever
  we try to record an outcome of "unknown"

The folks who are developing an application using audit, they've added
the following input on this.

> With regard to outcome "unknown"
> From an application perspective the event outcome unknown is important.
> There are times an application will want to record "I'm about to
> try to do x".
> 
> This does not mean "x" was successul. 
> 
> After "x" has completed, the application will then write "completed x (or
> success) in the audit file.
> 
> The RFCs from OSF appeared to specify that the audit facility can
> be used by application programs.
> 
> If this is the case, the capability to log "unknown" should be provided,
> as it meets a need for the application developer.
> 
> HP has taken advantage of this capability for an application it is 
> currently developing.

[8/18/94 public]
Fixed.  Added "pending" as a new outcome, since "unknown" has a different
meaning/role than the one desired by HP.



CR Number                     : 11431
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : auditd sometimes fail to start
Reported Date                 : 7/25/94
Found in Baseline             : 1.1
Found Date                    : 7/25/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b16
Affected File(s)              : dce_config, dmn_main.c,
dmn_acl_mgr.c, aud.sams, auditd_startup
Sensitivity                   : public

[7/25/94 public]

auditd often fails to start after having been stopped with auditcp.
This happens even after performing the recommended "cleanup" operations
(cdscp del obj and removal of the /opt/dcelocal/var/audit/adm/acl), and
attempting to restart the daemon.

Output from svc messages file is as follows:

# auditd
# cat /tmp/messages
1994-07-25-20:49:30.017-04:00I----- auditd NOTICE_VERBOSE aud general 0x7aff2d60 set daemon locale: /:C;:C;:C;:C;:C;:C;:C;/
1994-07-25-20:49:30.036-04:00I----- auditd NOTICE aud general 0x7aff2d60 the audit daemon started
1994-07-25-20:49:30.556-04:00I----- auditd NOTICE_VERBOSE aud general 0x7aff2d60 daemon registered interfaces with RPC runtime
1994-07-25-20:49:31.708-04:00I----- auditd FATAL aud general 0x7aff2d60 cannot register daemon's svc manager bindings with RPCD
# 

Reconfiguring the cell makes the problem go away, but is a bit extreme.

If there are additional administrative tasks that should be performed,
these need to be documented.

[7/25/94 public]
This problem has been plaguing me for a while. It lived as CR 11119 for
a while until it became a dumping ground for the world's problems.

I thought that this was a CDS problem. I still think it is, but I can't
prove it.

Try deleting /.:/hosts/HOSTNAME/audit-server (or aud-acl) depending on
how recent an auditd you are running. You can even use a nifty-keen
administration tool called dcecp. Don't bother with that old crusty
cdscp. This has been a paid advertisement from... :-)

dcecp> obj del /.:/hosts/HOSTNAME/audit-server

Can you supply more information regarding when the problem firt occured?
Was it during a startup of all the daemons on your machine (running rc.dce)?

My guess is that the cds advertiser is starting up and accepting connections
while it is still in a funny state. There is then a race condition of things
registering themselves in the namespace (like auditd which is started next
in rc.dce). Once auditd encounters this problem and dies, it leaves its
entry in a broken state (sometimes without expected ACL entries and such).
Deleting it and restarting auditd by hand seems to help. Please let me know
(or update this CR) if deleting the namespace entry does or does not help.

[7/26/94 public]

I am performing the obj del of the cds namespace that you mention, and also
removing the acl file from /opt/dcelocal/var/audit/adm/acl.  This does not
solve the problem.  The only time that I can get auditd to start consistently
is from a "fresh" dce_config of a cell.  Other than that, it's a game of
chance.  We're still using the aud-acl version of auditd, and I'm using cdscp
not dcecp.  Either starting auditd by hand or by using rc.dce (after it has
been up and running from the config) can produce the above problem.  I see 
the same problem when I kill auditd with a "kill -9" or when I use the admin
program and do an "aud stop" (yes, I'm still using auditcp - :^( - but that's
a whole other story!).  This has been happening to me ever since I started
to use audit, but up until now felt that I might be doing something wrong 
that would explain what was going wrong and dce_config'ing a new cell wasn't
that big of a deal, but this is clearly unacceptable for a customer to use.
I was secretly hoping that by entering this CR someone would tell me some 
administrative task that I'm not performing that would solve my problem. If
there is anything that I should be trying or that would provide more info
to help solve the problem, let me know.

[7/28/94 public]
Try this when you get the failure: unsetenv KRB5CCNAME and see if you succeed 
restarting auditd manualy.
I have never encountered this problem in my environment, so I cannot debug.
Make sure you start auditd as root, and that when you do a klist command,
you see the local host machine id.  If you don't see it, unset the environment
variable KRB5CCNAME.

[7/28/94 public]

Interestingly enough, I found that the opposite of what you suggest is
what I needed to do.  From testing I found that I could re-start auditd
100% of the time if I used dce_config to start ("configure") it.  The
only thing that dce_config did differently was that it forced me to dce_login
as cell_admin .... So, I tried that without dce_config. 

So, whether I use a kill -9 or the control program to stop auditd and even
if I don't do any of the prescribed clean-up - as long as I dce_login as
cell_admin before restarting auditd, it starts every time.

The question - should I have to be cell_admin in order to start this daemon?

[7/29/94 public]
The short answer: no you don't have to be cell_admin to start auditd.
As to the scenario you described:
Did you also delete svc-acl from namespace when you delete aud-acl?   
(These names are now consolidated to "audit-server".)

As to the power of being cell_admin to start auditd:
(if not deleting svc-acl entry from cds was the cause of the problem)

I think it was because cds' acl.  Auditd, running as cell_admin
was able to write to svc-acl entry when it already existed.
However, if auditd, running as cell_admin,
created the entry and did not unexport it before leaving, a later instance
of auditd, running as hosts/x/self, would not have the permission to write
to the name entry.

[7/29/94 public]
I have been running both the audit system tests and the audit functional
tests on my 486 and have not seen this problem.  I am currently using
bl-12 for both dce and for the tests.

I use dce_config to start and stop dce for the functional tests. The
system tests start and stop auditd on their own.

I have found that you do not need to be dce-logged in.  I just run as
root.

[7/29/94 public]
If you don't do dce_login and you are root, then you are using 
hosts/x/self credentials.  Did you have a chance to see what the acl of
the aud-acl/svc-acl entries look like?  Did hosts/x/self have
"rw" permissions if you did acl_edit -e /.:/hosts/x/aud-acl or
acl_edit -e /.:/hosts/x/svc-acl commands and list the acls?

In any case, I believe dce_config should add the folloiwng line(s) when 
doing config_audit, so that auditd running as /hosts/x/self, would be able 
to write to these name space entries.

        acl_edit -e /.:/hosts/$HOSTNAME/aud-acl \
        -m user:hosts/$HOSTNAME/self:rwt

        acl_edit -e /.:/hosts/$HOSTNAME/svc-acl \
        -m user:hosts/$HOSTNAME/self:rwt

or  (after name consolidation)

        acl_edit -e /.:/hosts/$HOSTNAME/audit-server \
        -m user:hosts/$HOSTNAME/self:rwt

[8/4/94 public]
I now understand why this doesn't happen all the time. If you start auditd
through dce_config for the first time, the acl that gets created is just what
the initial object acl on the parent direcotry is. This is because the 
dce_config user is running as cell_admin at this point, and cds does not
need to modify the acl. Therefore the hosts/HOSTNAME/self entry is not
created in the namespace acl.

If you start auditd just as root (like just modifying /etc/rc.dce and
restarting), cds adds an entry into the namespace acl for you. Note
the passage from the holy tome "OSF DCE Administration Guide -- Core
Components" page 7-5:

	"The creator of a name is automatically granted all permisions that
	are appropriate for the type of name that is created. For example, a
	principal that is creating an object entry is granted read, write,
	delete, test and control permissions to the object entry..."

This is why this scenario works, and the scenario where you config auditd from
dce_config and then try to restart auditd fails. Thanks Howard!

[08/15/94 public]

Fixed the problem by modifying the auditd startup code to always execute as
machine principle.  When doing this I deleted support for the "-i" identity
option which in-turn required that auditd stops spawning a thread to manage
its key.

Also, because auditd now always runs as machine principle, and at the
request	of the "powers that be", I added support for an audit-admin group.
This	will allow the cell-admin to manage auditds on various hosts
without	having to become the machine prinicple on those hosts.

[8/17/94 public]
Updated also the test suite auditd_startup, removing tests for
the -i option.



CR Number                     : 11425
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : switch to use new ACL library
Reported Date                 : 7/25/94
Found in Baseline             : 1.1b11
Found Date                    : 7/25/94
Severity                      : B
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b13
Affected File(s)              : dmn_acl_mgr.c dmn_main.c aud.sams
and defuncted a few
Sensitivity                   : public

[7/25/94 public]
DCE 1.1 offers an ACL mgr library.  Remove current ACL mgr implementation
from auditd and replace with calls to the new library.

[7/27/94 public]
done.



CR Number                     : 11372
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : need a way to have multiple related processes share an audit trail file (central trail is too big)
Reported Date                 : 7/20/94
Found in Baseline             : 1.1
Found Date                    : 7/20/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b13
Affected File(s)              : audit_pickle.acf audit_pickle.idl
evtp.h evt_read.c evt_write.c dmn_rpc_manager.c
Sensitivity                   : public

[7/20/94 public]

This problem was first seen while using auditcp, so I didn't enter
a defect.  Writing an independent c program that uses the libaudit
management API and does the same sequence of events as auditcp results
in an identical crash and core dump.

The program is reading through the audit trail and hits a point where
this message is displayed:

Exception: wrong version of IDL Encoding Services (dce / rpc)

(When looking for when this message is returned, it was found that this
happens only when the marshalling code thinks it has exhausted the buffer
and it shouldn't have).

and the program dumps core.  Here is the traceback for the core file.

>trace
 0 kill@libc_r + 0x00000008 (hp-ux export stub)
 1 cma__abort_process@libdce + 0x0000004c (0x6, 0x4, 0x14, 0x7b0331d8)
 2 __iob@libdce + 0x458f4074 (0x7aff49f8, 0x4, 0x14, 0x7b0331d8)
 3 rpc_ss_raise_impl_exception@li + 0x00000e90 (0x16c9a112, 0, 0x400bbac4, 0x1)
 4 rpc_ss_report_error_2@libdce + 0x000000ec (0, 0x4009bf08, 0x16c9a112, 0x7b034418)
 5 audit_pickle_dencode_ev_info + 0x00000218 (0x400a23f8, 0x400a25e8, 0x400a2620, 0x7b034250)
 6 dce_aud_next + 0x00000a38 (0x4009deb8, 0, 0x7aff0000, 0x7b03424c)
 7 main + 0x000000d0 (0, 0, 0, 0)

Additional info from xdb that may be of use:

>lr $a
$arg0     = 0x7b01f8a0
$arg1     = 0x7b034f09
$arg2     = 0
$arg3     = 0xb

> lr $r
$r0       = 0
$r1       = 0x54f10000
$r2       = 0x8082ce1b
$r3       = 0x7b01f8a0
$r4       = 0x1
$r5       = 0x112
$r6       = 0x4f
$r7       = 0x7b034f08
$r8       = 0x4f
$r9       = 0x4
$r10      = 0
$r11      = 0
$r12      = 0x4000bee0
$r13      = 0
$r14      = 0x10000080
$r15      = 0x10000000
$r16      = 0
$r17      = 0x14
$r18      = 0
$r19      = 0x7afff97c
$r20      = 0x4b0
$r21      = 0x7afe58f8
$r22      = 0
$r23      = 0xb
$r24      = 0
$r25      = 0x7b034f09
$r26      = 0x7b01f8a0
$r27      = 0x40004b80
$r28      = 0x3e
$r29      = 0x4529000
$r30      = 0x7b034758
$r31      = 0x8082ce63
$ret0     = 0x3e
$ret1     = 0x4529000

>p *($pc-16)\20i
0x8082ce08  OR  0,0,0
0x8082ce0c  BREAK       0,0
0x8082ce10  BL  _fp_status+0040,2
0x8082ce14  OR  0,0,0
0x8082ce18  LDW -24(0,30),2
0x8082ce1c  LDSID       (0,2),1
0x8082ce20  MTSP        1,0
0x8082ce24  BE,N        0(0,2)
0x8082ce28  BL  _fp_status+0028,2
0x8082ce2c  OR  0,0,0
0x8082ce30  LDW -24(0,30),2
0x8082ce34  LDSID       (0,2),1
0x8082ce38  MTSP        1,0
0x8082ce3c  BE,N        0(0,2)
0x8082ce40  BL  _fp_status+0008,1
0x8082ce44  ADDIL       0xfff79000,1
0x8082ce48  LDO 812(1),1
0x8082ce4c  BV,N        0(1)
0x8082ce50  STW 19,-28(0,30)
0x8082ce54  LDIL        0xc0000000,1


I haven't tried this with dcecp, but if it uses the management API,
it will suffer the same fate.

[7/20/94 public]
It seems that this is happening inside the rpc client stub, when
doing pickling.

[07/21/94 public]
dced and SVC learned this the hard way :-)   if you call IDL encoding
functions in a non-server stub you must first call rpc_ss_enable_client_malloc.

[7/21/94 public]
I think this is a different problem.  (I had the coredumps from using free() and
they disappeared once I replaced the free with rpc_sm_client_free(). )
Here rpc_ss_report_error_2 sends out 16c9a112 => rpc_s_ss_wrong_es_version and then
core dumps somewhat later.
Mary also sent me earlier another trace where in similar circumstances the error
code from rpc_ss_report_error_2 was 16c9a110 => rpc_s_ss_bad_buffer, which when 
looking in idl/lib/pickling.c is reported when a buffer is not 8 byte aligned.
If the errors (?) are caught, why the coredumps?

[7/21/94 public]
I will answer my own question, the coredumps happen since audit code doesn't
catch the exception raised by the encoding service.  
Reassign to audit component.

[7/26/94 public]

I have downgraded this defect to a C2 and changed the description to 
match what the remaining problem is.  We have been able to stop the
original problem (IDL exception and bad data) from happening by having 
each process write to it's own audit trail file.  We believe that having
multiple processes writing to a single file caused the above errors by 
corrupting the audit trail file.

However, we see a need to have a way for related daemons to store their 
audit information in a common file, that isn't the central trail file.  
The central trail potentially has too many processes writing to one place 
- the signal to noise ratio would be unacceptable.  Having each process 
write to it's own individual file quickly becomes an administrative nightmare
to keep track of all of the files.

[7/28/94 public]
The original secd coredump was caused by audit code not catching an
exception raised by rpc encoding services.  This has been fixed by
adding status parameter to the audit_pickle_dencode_ev_info function
and adding [comm_status] to the acf file.
I am marking this CR as fixed, since the requirment for writing to
a local trail file by multiple processes was not a design goal for 1.1.
Please open a separate enhancement request for this functionality.



CR Number                     : 11364
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : servers should register in ep map before ns
Reported Date                 : 7/20/94
Found in Baseline             : 1.1b13
Found Date                    : 7/20/94
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b13
Affected File(s)              : security/audit/auditd/dmn_main.c
Sensitivity                   : public

[7/20/94 public]
Servers should register themselves with the endpoint mapper before they 
register themselves with the namespace. This avoides the (very) small 
window of where clients can look up a server in the namespace, but can't 
cantact it because the endpoint mapper doesn't know about the server yet.

[8/3/94 public]
Submitted last week.



CR Number                     : 11359
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : functional test
Short Description             : CR 11298 changed exported i/f name
Reported Date                 : 7/19/94
Found in Baseline             : 1.1
Found Date                    : 7/19/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b13
Affected File(s)              : restorelogperm setaclnologperm auditd_acl
Sensitivity                   : public

[7/19/94 public]
Tests have to follow suite with the exported name changes done with CR 11298.

[7/21/94 public]
fixed.



CR Number                     : 11347
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : "diff" need to use dce_bindings_to_file (was need all protseqs)
Reported Date                 : 7/18/94
Found in Baseline             : 1.1b12
Found Date                    : 7/18/94
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : dmn_main.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/18/94 public]
auditd should use both CN and DG. It currently uses just DG.

[7/26/94 public]
auditd currently writes it's single string binding to the daemon_binding
file. Now that it will have multiple string bindings, it should write
a count of bindings in the file before the list of bindings.

[7/28/94 public]
Submitted. Uses all_protseqs, but writes output file in old format.
Should eventually be changed to use new dce_bindings_to_file() call.
Downgraded to D3.

[8/17/94 public]
The last comment is incorrect (I knew what I meant :-). The output file 
is written by calling fputs, not using the new dce_bindings_to_file() 
call. The format of the file is correct, and will not change. Changing 
auditd to use the new call is purely for aesthetics, hence the D3.

[8/18/94 public]
Made an enhancement.

[9/26/95 public]
The fix has been made.  In addition, I added a close statement to close
the daemon_identity file to close it after the writing is done.

[9/28/95 public]
Sorry, I did not know I should include the diff file here.  The diff file and
the new version of the file are also found in
/afs/dce.osf.org/project/dce/ibm/audit

235,236c235
<     char                    *count_string;
<     unsigned_char_p_t       string_binding;
---
>     FILE                   *F;
243a243
>         close(fd);
257,264c257,266
<         for (i = 0; i < bindings->count; i++) {
<             rpc_binding_to_string_binding(bindings->binding_h[i],
<                                           &string_binding, st);
<             if (GOOD_STATUS(st) && (char *) string_binding != 0) {
<                 write(fd, (char *) string_binding,
<                       strlen((char *) string_binding));
<                 write(fd, "\n", 1);
<             } else {
---
>         /* write all bindings to daemon_binding file */
>
>         if ((F = fdopen(fd, "w")) == NULL) {
>             dce_svc_printf(AUD_S_DMN_BINDING_FILE_MSG, DAEMON_BINDING_FILE);
>             close(fd);
>             return;
>         }
>         dce_bindings_to_file(F, bindings, st);
>         if (BAD_STATUS(st)) {
>
266,267c268,269
<               DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
<                       "cannot get daemon string binding"));
---
>                   DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
>                         "cannot write daemon string binding to a file"));
269d270
<             }
271c272
<         close(fd);
"dmn_main.diff.11347" 39 lines, 1258 characters

[11/1/95 public]

In process of merging the fixes, I noticed the following two problems:

1. The fix above is missing close(fd) after doing fclose(F)
2. The declaration "void              **thread_status;" in main is incorrect;
   it should be "pthread_addr_t      thread_status;"

[11/01/95]
Noop, according to manpage for fdopen(), fclose is only close statement you 
need to close the file for {open and fdopen}.  For the second problem, it's 
been there since the first development (???) and I think you mentioned in 13177.

[11/195 public]
You are right, sorry about repeat and incorrect statement.

[7/18/96 public]
Fixed in DCE1.2.2 (BL03).



CR Number                     : 11305
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : acl manager support
Short Description             : Modify Audit ACL
manager helpstring to "Audit server".
Reported Date                 : 7/14/94
Found in Baseline             : 1.1b11
Found Date                    : 7/14/94
Severity                      : E
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b13
Affected File(s)              : security/audit/auditd/dmn_acl_manager.c
Sensitivity                   : public

[7/14/94 public]

BACKGROUND:
 A polymorphic object, as in DCE 1.1, can be a principal name and a 
 principal directory and therefore have 2 ACL managers. 

 In "dcecp", the ACL manager name can be obtained by invoking the
 "acl show -managers" command.  The other "acl" commands can
 accept a -type option to specify the manager name.  Previously, 
 this ACL manager name was really only informational and not visible
 to the end user, but now it is.

 Below, I have compiled a list of the ACL manager names and their 
 "helpstrings" that will be displayed to the user.

CDS ACL Managers:
    GDA managment ACL manager:
        dcecp> acl show /.:/hosts/<hostname>/cds-gda -managers
        {GDA              Change ACL for gda management}

    CDS Server Management ACL manager:
        dcecp> acl show /.:/hosts/<hostname>/cds-server -managers
        {CDS Server       Change ACL for server management}

    CDS Directory entry ACL manager:
        dcecp> acl show /.:/cell-profile -managers -entry
        {Directory entry  Change ACL for CDS directory entry}

    CDS Directory ACL manager:
        dcecp> acl show /.:/hosts -managers
        {Directory        Change ACL for CDS directory}

    CDS Clearinghouse ACL manager:
        dcecp> acl show /.:/<hostname>_ch -managers
        {Clearinghouse    Change ACL for CDS clearinghouse}

    CDS Clerk management ACL manager:
        dcecp> acl show /.:/hosts/<hostname>/cds-clerk -managers
        {CDS Clerk        Change ACL for clerk management}


Security ACL Managers:
    Security Directory ACL manager:
	dcecp> acl show /.:/sec/principal -managers
	dcecp> acl show /.:/sec/group -managers
	dcecp> acl show /.:/sec/org -managers
        {Sec Directory    Manage directory object acls.}

    Security Principal ACL manager:
        dcecp> acl show /.:/sec/principal/<name> -managers
        {Sec Principal    Manage principal object acls.}

        A polymorphic object will look like this:
	dcecp> acl show /.:/sec/principal/<princ-dir-name> -managers
	{Sec Principal    Manage principal object acls.}
	{Sec Directory    Manage directory object acls.}

    Security Group ACL manager:
        dcecp> acl show /.:/sec/group/<name> -managers
        {Sec Group        Manage group object acls.}

        A polymorphic object will look like this:
	dcecp> acl show /.:/sec/group/<group-dir-name> -managers
	{Sec Group        Manage group object acls.}
	{Sec Directory    Manage directory object acls.}

    Security Organization ACL manager:
        dcecp> acl show /.:/sec/org/<name> -managers
        {Sec Org          Manage org object acls.}

        A polymorphic object will look like this:
	dcecp> acl show /.:/sec/org/<org-dir-name> -managers
	{Sec Org          Manage org object acls.}
	{Sec Directory    Manage directory object acls.}

    Security Replica List ACL manager:
        dcecp> acl show /.:/sec/replist -managers
        {Sec Replist      Manage the replist object acl.}

    Security Policy ACL manager:
        dcecp> acl show /.:/sec/policy -managers
        {Sec Policy       Manage the policy object acl.}

    Security Extended Attribute Schema ACL manager:
        dcecp> acl show /.:/sec/xattrschema/<name> -managers
        {Sec Attr_schema  Manage the attr_schema object acl.}


DTS ACL manager:
    dcecp> acl show /.:/hosts/<hostname>/dts-entity -managers
    {dtsd             DTSD DCE Time Service daemon}


Auditing ACL manager:
    dcecp> acl show /.:/hosts/<hostname>/aud-acl -managers
    {audit            Audit daemon ACL manager}


DCED ACL managers:

    Generic ACL managers for DCED:
	dcecp> acl sh /.:/hosts/<hostname>/self -m
	dcecp> acl sh /.:/hosts/<hostname>/config -m
        {dced-mgmt        DCED manager}

        dcecp> acl show /.:/hosts/<hostname>/config/srvrconf -managers
        dcecp> acl show /.:/hosts/<hostname>/config/srvrexec -managers
	dcecp> acl show /.:/hosts/<hostname>/config/hostdata -managers
        dcecp> acl show /.:/hosts/<hostname>/config/keytab -managers
        dcecp> acl sh /.:/hosts/<hostname>/config/attr_schema -managers
        dcecp> acl show /.:/hosts/<hostname>/config/secval -managers
        {dced-managers    DCED manager Pseudo-object}

    Server configuration ACL manager:
        dcecp> acl show /.:/hosts/<hostname>/config/srvrconf/<name> -managers
        {srvrconf         Server Configuration}

    Server execution ACL manager:
        dcecp> acl show /.:/hosts/<hostname>/config/srvrexec/<name> -managers
        {srvrexec         Server Execution}
    
    Hostdata configuration ACL managers:
        dcecp> acl show /.:/hosts/<hostname>/config/hostdata/<name> -managers
        {hostdata         Host Data}

    Keytab configuration ACL manager:
        dcecp> acl show /.:/hosts/<hostname>/config/keytab/<name> -managers
        {rkeytab          Key Management}

    Extended Attribute Schema configuration ACL manager:
        dcecp> acl sh /.:/hosts/<hostname>/config/xattrschema/<name> -managers
        {attr_schema      Attribute Schema}

    Secval configuration ACL manager:
        dcecp> acl show /.:/hosts/<hostname>/config/secval/<name> -managers
        {secval           Security Validation}


DFS ACL manager:
    dcecp> acl show /.:/fs/<name> -managers
    {DFS              DFS ACL manager}


Misc:
    dcecp> acl show <application-specific ACL object>  -managers
    {general          General ACL Manager}
    Note that there is nothing DCE ships that uses this ACL manager.
    This is part of the ACL manager library for application
    developers.

____________________________________________________________
NEW GUIDELINES FOR ACL MANAGER NAMES:

We would like to enforce guidelines for all DCE ACL
managers.  These are not architectural and dcecp will accept 
any valid ACL manager names, but we would like DCE-named ACL 
managers to be named consistently and in an easily
usable manner.  Since dcecp is what will make these names
visible to a user, we are using dcecp attribute naming
conventions:

ACL manager names for all of DCE must be:
1) lowercase
2) no underscores
3) no spaces
4) 16 bytes (sizeof "sec_acl_printstring_len").
5) Choose names similiar to object command names supported in
   dcecp wherever possible.
   For example, the ACL manager name "principal" refers to
   the object that contains registry information about principals;
   /.:/sec/principal.
   Note that dcecp will allow abbreviations. For example, a user
   can specify "org" for the ACL manager name "organization".
6) Names must be unique within a component's ACL manager but not
   within DCE. 
   For example, "xattrschema" can be used for a DCED Extended
   Attribute Configuration Schema ACL object and for a Security 
   Extended Registry Attribute Schema ACL object.
7) The helpstring for an ACL manager must specify the component
   that owns or manages the objects in questions, since this 
   information cannot always be derived from the ACL manager name.
____________________________________________________________
PROPOSAL:

Below are the current DCE ACL manager names/helpstrings and their 
proposed names/helpstrings following the above guidelines.

  Old names        New names/helpstrings
--------------    ---------------------------
GDA               {gda           Global Directory Agent server}
CDS Server        {cdsserver     Cell Directory Service server}
Directory entry   {entry         CDS namespace entry ACLs}
Directory         {directory     CDS directory ACLs}
Clearinghouse     {clearinghouse CDS clearinghouse ACLs}
CDS Clerk         {cdsclerk      Cell Directory Service clerk}
Sec Principal     {principal     Registry principal object ACLs}
Sec Directory     {secdirectory  Registry directory object ACLs}
Sec Group         {group         Registry group object ACLs}
Sec Org           {organization  Registry organization object ACLs}
Sec Replist       {replist       Registry replica list object ACL}
Sec Policy        {policy        Registry policy object ACL}
Sec Attr_schema   {xattrschema   Registry extended attribute schema object ACLs}
dtsd              {dts           Distributed Time Service server or clerk}
audit             {audit         Audit server}
dced-mgmt         {dced          DCED server}
dced-managers     {container     DCED container ACLs}
srvrconf          {srvrconf      DCED server configuration object ACLs}
srvrexec          {srvrexec      DCED server execution object ACLs}
hostdata          {hostdata      DCED host data object ACLs}
rkeytab           {keytab        DCED key management object ACLs}
attr_schema       {xattrschema   DCED extended attribute schema object ACLs} 
secval            {secval        DCED security validation service}
DFS               {dfs           Distributed File Service server}
general           {generic       Generic ACL server}

[8/3/94 public]
Submitted a while ago.



CR Number                     : 11298
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : merge exported if's and add control
Reported Date                 : 7/14/94
Found in Baseline             : 1.1b11
Found Date                    : 7/14/94
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b12
Affected File(s)              : security/audit/auditd/dmn_main.c
Sensitivity                   : public

[7/14/94 public]
Currently auditd exports it's svc interface to /.:/hosts/hostname/aud-svc
and it's acl interface to /.:/hosts/hostname/aud-acl. It currently does
not export it's management (control) interface.

All three interfaces should be exported to one namespace entry.

[7/14/94 public]
In order for dcecp to access remote audit daemons, auditd must
export it's control interface to the namespace.

Talking to Dick Mackey, the correct name should be
/.:/hosts/hostname/audit-server

The merging of the interfaces into one namespace entry is an enhancement,
but the exporting of the control interface is a defect. I figured that
they could both be done at once.

[7/14/94 public]
Submitted.



CR Number                     : 11175
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : "diff" audit trail read in oldest to newest order :-(
Reported Date                 : 7/5/94
Found in Baseline             : 1.1
Found Date                    : 7/5/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : evt_read.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/5/94 public]

While attempting to find out what was going on just before my
RIOS crashed, I found this sec_audit_trail file with a timestamp
from 3 minutes prior to the crash - psyched! However, I am still
waiting for auditcp to get to events on the same day as the
crash, never mind the hour ... Would be really nice if it went
most recent to least - I believe most system administrators
would appreciate this as well ... what d'ya say?

[7/6/94 public]
I say that sounds like a good idea.  I've reassigned this to dcecp because
auditcp has been moved to nosupport.  dce_aud_next lets you specify some
predicates which may allow more flexibility than a simple sequential step
through the trail file.  (I.e., TIME>whenever).  However, I'm willing to
believe that this enhancement might need to be bounced back to auditing
with a request for a dce_aud_prev function.

[7/8/94 public]
This is an audit problem. A new call needs to be created, or the arg list
to dce_aud_next() must be changed to handle reverse ordering.

[10/12/95 public]
The enhancement is made.  dce_aud_prev() is added in audit.h and evt_read.c.
The format and the number of arguments for dce_aud_prev() are exactly the
same as dce_aud_next().  However, dce_aud_prev() returns the previous record 
whereas dce_aud_next() returns the next record.
In addition, I also added some checkings, cleanup the unused variables, and
fix memory leak.  The diff files and the new versions of audit.h and evt_read.c
are also found in /afs/dce.osf.org/project/dce/ibm/audit

1) diff file for audit.h:

184a185,195
>
> extern void
> dce_aud_prev(
>            dce_aud_trail_t,
>            char *,
>            unsigned16,
>            dce_aud_rec_t *,
>            unsigned32 *
> );
>
>

2) the diff file for evt_read.c:

101a102,109
> typedef struct  _index_file {
>                 unsigned32    sn;   /* the starting position of the record in the index file */
>                 unsigned32    ln;   /* the length of the record in the index file            */
>         struct _index_file   *next; /* next starting position in the index trail file        */
>
> } index_file;
> index_file      *ifile = NULL;
113c121
<     int             i, j;
---
>     int             i;
116,118d123
<     aud_esl_act_t actions;
<     aud_log_ev_info_list_t *tail_list;
<     aud_log_ev_info_list_t *retrieved_ev_info;
120d124
<     unsigned_char_t *alarm_message;
146a151,155
>         if (local_predicate == NULL) {
>             dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, strlen(predicate)+1);
>             *status = aud_s_cannot_allocate_memory_rc;
>             return;
>         }
201a211,217
>             if (addr == NULL) {
>                 dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, strlen(local_predicate) - strlen("ADDR:") + 1);
>                 *status = aud_s_cannot_allocate_memory_rc;
>                 if (local_predicate)
>                     free(orig_predicate);
>                 return;
>             }
273a290,291
>                     *ard = NULL;
>                     *status = aud_s_ok;
291a310,318
>     if (ep == NULL) {
>         dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, esize);
>         *status = aud_s_cannot_allocate_memory_rc;
>         if (local_predicate)
>             free(orig_predicate);
>         if (check_addr)
>             free(addr);
>         return;
>     }
373a401,426
> void
>                 dce_aud_prev
>                 (
>                                dce_aud_trail_t at,
>                                char *predicate,
>                                unsigned16 format,
>                                dce_aud_rec_t * ard,
>                                unsigned32 * status
> ) {
>     idl_es_handle_t h;
>     int             i;
>     idl_byte       *ep;
>     idl_ulong_int   esize;
>     dce_aud_hdr_t  *header;
>     char           *commap;
>     unsigned32      authz_status;
>     unsigned32      evt_id, evt_outcome;
>     unsigned32      rec_start_pos;
>     utc_t           before_time, after_time;
>     uuid_t          server_uuid, client_uuid, cell_uuid, group_uuid;
>     boolean32       check_evt, check_outcome, check_authz_status, check_time_before, check_time_after, check_server, check_client, check_cell, check_group, check_addr;
>     unsigned_char_t *addr;
>     enum utc_cmptype time_relation;
>     char            *local_predicate = NULL;
>     char            *orig_predicate;
>     index_file      *tfile = NULL;
374a428,778
>     if (at == NULL) {
>       dce_svc_printf(AUD_S_INVALID_TRAIL_DESCRIPTOR_MSG);
>       *status = aud_s_invalid_trail_descriptor;
>       return;
>     }
>     *status = aud_s_ok;
>     *ard = NULL;
>
>     check_evt = check_outcome = check_authz_status = check_time_before
>       = check_time_after = check_server = check_client = check_cell
>       = check_group = check_addr = FALSE;
>
>     if (predicate != NULL && strlen(predicate) != 0) {
>         local_predicate = malloc(strlen(predicate) + 1);
>         if (local_predicate == NULL) {
>             dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, strlen(predicate)+1);
>             *status = aud_s_cannot_allocate_memory_rc;
>             return;
>         }
>         strcpy(local_predicate, predicate);
>         orig_predicate = local_predicate;
>     }
>
>     while (local_predicate != NULL && strlen(local_predicate) != 0) {
>       commap = (char *) strchr(local_predicate, ',');
>       if (commap != NULL) {
>           *commap = '\0';
>       }
>       if (strncmp(local_predicate, "EVENT:", strlen("EVENT:")) == 0) {
>           evt_id = strtol(local_predicate + strlen("EVENT:"), NULL, 16);
>           check_evt = TRUE;
>       } else if (strncmp(local_predicate, "OUTCOME:", strlen("OUTCOME:")) == 0) {
>           if (strcmp(local_predicate + strlen("OUTCOME:"), "SUCCESS") == 0) {
>               evt_outcome = aud_c_esl_cond_success;
>               check_outcome = TRUE;
>           } else if (strcmp(local_predicate + strlen("OUTCOME:"), "FAILURE") == 0) {
>               evt_outcome = aud_c_esl_cond_failure;
>               check_outcome = TRUE;
>           } else if (strcmp(local_predicate + strlen("OUTCOME:"), "DENIAL") == 0) {
>               evt_outcome = aud_c_esl_cond_denial;
>               check_outcome = TRUE;
>           } else if (strcmp(local_predicate + strlen("OUTCOME:"), "PENDING") == 0) {
>               evt_outcome = aud_c_esl_cond_pending;
>               check_outcome = TRUE;
>           }
>       } else if (strncmp(local_predicate, "STATUS:", strlen("STATUS:")) == 0) {
>           if (strcmp(local_predicate + strlen("STATUS:"), "DCE") == 0) {
>               authz_status = rpc_c_authz_dce;
>               check_authz_status = TRUE;
>           } else if (strcmp(local_predicate + strlen("STATUS:"), "NAME") == 0) {
>               authz_status = rpc_c_authz_name;
>               check_authz_status = TRUE;
>           }
>       } else if (strncmp(local_predicate, "TIME:>", strlen("TIME:>")) == 0) {
>           utc_mkasctime(&after_time, local_predicate + strlen("TIME:>"));
>           check_time_after = TRUE;
>       } else if (strncmp(local_predicate, "TIME:<", strlen("TIME:<")) == 0) {
>           utc_mkasctime(&before_time, local_predicate + strlen("TIME:<"));
>           check_time_before = TRUE;
>       } else if (strncmp(local_predicate, "SERVER:", strlen("SERVER:")) == 0) {
>           uuid_from_string((unsigned_char_t *)local_predicate + strlen("SERVER:"), &server_uuid, sttus);
>           check_server = TRUE;
>       } else if (strncmp(local_predicate, "CLIENT:", strlen("CLIENT:")) == 0) {
>           uuid_from_string((unsigned_char_t *)local_predicate + strlen("CLIENT:"), &client_uuid, sttus);
>           check_client = TRUE;
>       } else if (strncmp(local_predicate, "CELL:", strlen("CELL:")) == 0) {
>           uuid_from_string((unsigned_char_t *)local_predicate + strlen("CELL:"), &cell_uuid, status;
                                                                                                     >    check_cell = TRUE;
>       } else if (strncmp(local_predicate, "GROUP:", strlen("GROUP:")) == 0) {
>           uuid_from_string((unsigned_char_t *)local_predicate + strlen("GROUP:"), &group_uuid, stats);
>           check_group = TRUE;
>       } else if (strncmp(local_predicate, "ADDR:", strlen("ADDR:")) == 0) {
>           addr = (unsigned_char_t *) malloc(strlen(local_predicate) -
>                                             strlen("ADDR:") + 1);
>             if (addr == NULL) {
>                 dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, strlen(local_predicate) - strlen("DDR:") + 1);
>                 *status = aud_s_cannot_allocate_memory_rc;
>                 if (local_predicate)
>                     free(orig_predicate);
>                 return;
>             }
>           strcpy((char *)addr, local_predicate + strlen("ADDR"));
>           check_addr = TRUE;
>       }
>       if (commap != NULL) {
>           local_predicate = commap + 1;
>       } else {
>             free(orig_predicate);
>           local_predicate = NULL;
>       }
>     }
>
> #ifdef DCE_AUD_DEBUG
>     if (check_evt) {
>       DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
>           "dce_aud_prev: Check event\n"));
>     }
>     if (check_outcome) {
>       DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
>           "dce_aud_prev: Check outcome\n"));
>     }
>     if (check_authz_status) {
>       DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
>           "dce_aud_prev: Check authz_status\n"));
>     }
>     if (check_time_before) {
>       DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
>           "dce_aud_prev: Check time_before\n"));
>     }
>     if (check_time_after) {
>       DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
>           "dce_aud_prev: Check time after\n"));
>     }
>     if (check_server) {
>       DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
>           "dce_aud_prev: Check server\n"));
>     }
>     if (check_client) {
>       DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
>           "dce_aud_prev: Check client\n"));
>     }
>     if (check_cell) {
>       DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
>           "dce_aud_prev: Check cell\n"));
>     }
>     if (check_group) {
>       DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
>           "dce_aud_prev: Check group\n"));
>     }
>     if (check_addr) {
>       DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
>           "dce_aud_prev: Check addr\n"));
>     }
> #endif /* DCE_AUD_DEBUG */
>
> prev_record:
>     if (*ard != NULL) {
>       dce_aud_discard(*ard, status);
>     };
>
>     /* Since the md_index file contains (s1, l1),(s2, l2),...,(sn, ln) where si is   */
>     /* the starting point of the event record and li is the length of the event      */
>     /* record, we must reverse the index and store them in a linked list to retrieve */
>     /* them in LIFO order, i.e (sn, ln),(sn-1, ln-1),...,(s2, l2),(s1, l1).          */
>
>     if (!ifile) {
>         at->trail_cursor = 0;
>         at->index_cursor = 0;
>         /* The trail might have been wrapped around. */
>         while (1) {
>           fread((void *)&rec_start_pos, sizeof(idl_byte), sizeof(rec_start_pos), at->md_index_fp);
>           /* terminate the loop if eof or error on reading */
>           if (ferror(at->md_index_fp) || feof(at->md_index_fp)) {
>               break;
>           if (rec_start_pos >= at->index_cursor) {
>                 fread((void *)&esize, sizeof(idl_byte), sizeof(esize), at->md_index_fp);
>               if (at->index_cursor != rec_start_pos) {
>                   fseek(at->index_fp, rec_start_pos, SEEK_SET);
>               }
>               at->index_cursor = rec_start_pos + esize;
>
>                 tfile = (index_file *) malloc(sizeof(index_file));
>                 if (tfile == NULL) {
>                     dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, sizeof(index_file));
>                     *status = aud_s_cannot_allocate_memory_rc;
>                     if (local_predicate)
>                         free(orig_predicate);
>                     if (check_addr)
>                         free(addr);
>                     return;
>                 }
>                 /* add into the linked list */
>                 tfile->sn = rec_start_pos;
>                 tfile->ln = esize;
>                 tfile->next = ifile;
>                 ifile = tfile;
>
>             } else {
>               fseek(at->md_index_fp, sizeof(esize), SEEK_CUR);
>           }
>         }
>         free(tfile);
>     }
>
>     /* check to make sure the linked list is not empty */
>     if (ifile == NULL) {
>         if (local_predicate)
>             free(orig_predicate);
>         if (check_addr)
>             free(addr);
>       *ard = NULL;
>       *status = aud_s_ok;
>         return;
>     }
>
>     /* set the starting pointer to the starting point of  */
>     /* the previous last written audit record             */
>     at->trail_cursor = ifile->sn;
>     esize            = ifile->ln;
>     ifile            = ifile->next;
>     fseek(at->trail_fp, at->trail_cursor, SEEK_SET);
>
> #ifdef DCE_AUD_DEBUG
>       DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
>           "dce_aud_prev: sn is %ld bytes\n", at->index_cursor));
>       DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
>           "dce_aud_prev: ln is %ld bytes\n", esize));
> #endif
>     ep = (idl_byte *) malloc(esize);
>     if (ep == NULL) {
>         dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, esize);
>         *status = aud_s_cannot_allocate_memory_rc;
>         if (local_predicate)
>             free(orig_predicate);
>         if (check_addr)
>             free(addr);
>         if (ifile)
>             free(ifile);
>         return;
>     }
>     if (fread(ep, sizeof(idl_byte), esize, at->trail_fp) != esize) {
>       dce_printf(aud_s_trail_file_corrupted, at->trail_file);
>       *status = aud_s_trail_file_corrupted;
>       free(ep);
>         if (local_predicate)
>             free(orig_predicate);
>         if (check_addr)
>             free(addr);
>         if (ifile)
>             free(ifile);
>       return;
>     }
>     idl_es_decode_buffer(ep, esize, &h, status);
>     if (BAD_STATUS(status)) {
> #ifdef DCE_AUD_DEBUG
>       DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
>           "dce_aud_prev: idl_es_decode_buffer failed\n"));
> #endif
>         if (local_predicate)
>             free(orig_predicate);
>         if (check_addr)
>             free(addr);
>         if (ifile)
>             free(ifile);
>       free(ep);
>       return;
>     }
>     *ard = (dce_aud_rec_t) malloc(sizeof(struct _dce_aud_rec_handle));
>     if (*ard == NULL) {
>         idl_es_handle_free(&h, status);
>         if (BAD_STATUS(status)) {
>             if (local_predicate)
>                 free(orig_predicate);
>             if (check_addr)
>                 free(addr);
>             if (ifile)
>                 free(ifile);
>             return;
>         }
>         if (local_predicate)
>             free(orig_predicate);
>         if (check_addr)
>             free(addr);
>         if (ifile)
>             free(ifile);
>       free(ep);
>       dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG,
>               sizeof(struct _dce_aud_rec_handle));
>       *status = aud_s_cannot_allocate_memory_rc;
>       return;
>     }
>     (*ard)->as = NULL;
>     audit_pickle_dencode_ev_info(h, &(*ard)->header, &(*ard)->tail, status);
>     if (BAD_STATUS(status)) {
>         if (local_predicate)
>             free(orig_predicate);
>         if (check_addr)
>             free(addr);
>         if (ifile)
>             free(ifile);
>         free(ep);
>         return;
>     }
>
>     idl_es_handle_free(&h, status);
>     if (BAD_STATUS(status)) {
>         if (local_predicate)
>             free(orig_predicate);
>         if (check_addr)
>             free(addr);
>         if (ifile)
>             free(ifile);
>         free(ep);
>         return;
>     }
>
>     free(ep);
>
>     header = &((*ard)->header);
>     if (format != 0 && format != header->format) {
>       goto prev_record;
>     }
>     if ((check_evt && evt_id != header->event) ||
>       (check_evt && evt_id != header->event) ||
>       (check_outcome && evt_outcome != header->outcome) ||
>       (check_authz_status && authz_status != header->authz_st) ||
>       (check_server && uuid_equal(&server_uuid, &header->server, status)) ||
>       (check_client &&
>           uuid_equal(&client_uuid, &header->client_id[0].client, status)) ||
>       (check_cell &&
>           uuid_equal(&cell_uuid, &header->client_id[0].cell, status)) ||
>       (check_addr && strcmp((char *)addr, (char *)header->addr) == 0)) {
>       goto prev_record;
>     }
>     if (check_time_before) {
>       utc_cmpintervaltime(&time_relation, &header->time, &before_time);
>       if (time_relation == utc_greaterThan) {
>           goto prev_record;
>       }
>     }
>     if (check_time_after) {
>       utc_cmpintervaltime(&time_relation, &header->time, &after_time);
>       if (time_relation == utc_lessThan) {
>           goto prev_record;
>       }
>     }
>     if (check_group) {
>       for (i = 0; i < header->client_id[0].num_groups; i++) {
>           if (uuid_equal(&header->client_id[0].groups[i],
>                               &group_uuid, status)) {
>               break;
>           }
>       }
>       if (i == header->client_id[0].num_groups) {
>           goto prev_record;
>       }
>     }
> #ifdef DCE_AUD_DEBUG
>     DCE_SVC_DEBUG((aud_svc_handle, aud_s_msgs, svc_c_debug1,
>       "dce_aud_prev: found a matching record\n"));
> #endif
>     if (local_predicate)
>         free(orig_predicate);
>     if (check_addr)
>         free(addr);
>     (*ard)->tail_read_cursor = 0;
>     *status = aud_s_ok;
>     return;
> }
>
388a793,797
>     if (*header == NULL) {
>         dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, sizeof(dce_aud_hdr_t));
>         *status = aud_s_cannot_allocate_memory_rc;
>         return;
>     }
392a802,806
>     if ((*header)->client_id == NULL) {
>         dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, sizeof(client_id_t) *id_cnt);
>         *status = aud_s_cannot_allocate_memory_rc;
>         return;
>     }
398a813,817
>         if ((*header)->client_id[id_cnt].groups == NULL) {
>             dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, sizeof(uuid_t)*group_cnt);
>             *status = aud_s_cannot_allocate_memory_rc;
>             return;
>         }
406a826,830
>         if ((*header)->addr == NULL) {
>             dce_svc_printf(AUD_S_CANNOT_ALLOCATE_MEMORY_MSG, strlen((char *)ard->header.addr) + 1);
>             *status = aud_s_cannot_allocate_memory_rc;
>             return;
>         }


In addition, I also removed some unused variables and added some status checkings
for malloc() in dce_aud_next.

[10/30/95 public]
I just added the doc and the testcase for dce_aud_prev() in /afs/dce.osf.org/project/ibm/dce/audit
subdir.  The doc should be added to audit doc source.

[03/07/96 public]
Removed the old testcase and used TET instead.

[3/15/96 public]
The dce_aud_prev.3sec manpage has been added to the Application Reference.
As this is not a "doc" defect, and I'm not sure of what-all else might
be involved, I'm leaving the CR open.

[7/18/96 public]
Fixed in DCE1.2.2 (BL03).



CR Number                     : 11167
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : dce_aud_open returns w/o error when DCEAUDITOFF is set
Reported Date                 : 7/1/94
Found in Baseline             : 1.1
Found Date                    : 7/1/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b12
Affected File(s)              : trl_ops.c dmn_main.c
Sensitivity                   : public

[7/1/94 public]

In an attempt to workaround the problem in CR 11166 we attempted
to environment variables to turn auditing off so that I could dump
the audit trail to a file for inspection.  Using the environment
variables caused an immediate core dump with the following trace:

>trace
 0 audtrail_show + 0x000000fc (0x7b033bdc, 0x10004, 0x7aff2d60, 0x7aff2d60)
 1 _p_mutex_lock@libc_r + 0x00000078 (0x7b033b5c, 0x10004, 0x7aff2d60, 0x7aff2d60)
 2 ___stdio_unsup_1@libc_r + 0x00000410 (0x7b027cdc, 0x10004, 0x7aff2d60, 0x7aff2d60)
 3 _p_mutex_unlock@libc_r + 0x00000088 (0x7b027cf0, 0x7b033248, 0x7b009aa8, 0x7b027ce4)
 4 _gets@libc_r + 0x000001b0 (0x3, 0x7b033704, 0, 0xffff9d90)
 5 main + 0x000004ec (0x1, 0x7b03317c, 0, 0)
>

[7/6/94 public]
Reassigned to dcecp

[7/7/94 public]
When using dcecp with DCEAUDITOFF=1, I receive the following message:

dcecp> audt sh /opt/dcelocal/var/audit/adm/central_trail
1994-07-07-23:33:38.925-04:00I----- PID#10731 ERROR aud evt 0xa44cdbc4
an invalid audit trail descriptor is used
Error: an invalid audit trail descriptor is used

This is most likley an audit bug, but I'll try to track this down a 
little better tomorrow.

[7/8/94 public]
Well, dcecp doesn't coredump, so I'm dropping the priority. What is 
happening in dcecp is that when I call dce_aud_open() with DCEAUDITOFF
set, it just returns without error (and a NULL trail handle, which 
causes the subsequent error). See libaudit/trl_ops.c:165 .

I need to understand what it means to have DCEAUDITOFF set. At least
dce_aud_open should do is return an error status. More likely, the
routine should allow the open to happen if aud_c_trl_open_read is
specified, and just deny writes.

[7/12/94 public]
DCEAUDITOFF is meant to turn auditing off (i.e. no audit records will be
generated, nor written to any trail file.)  Should have no effect on reading
of trail files.  The return on line 168 of trl_ops.c looks bogus,
I will test and submit as soon as I find out.

[7/15/94 public]
Fixed.



CR Number                     : 11166
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : audtrail show of local audit file dumps core when writing to a file
Reported Date                 : 7/1/94
Found in Baseline             : 1.1
Found Date                    : 7/1/94
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b13
Affected File(s)              : evt_read.c trl_ops.c evtp.h
Sensitivity                   : public

[7/1/94 public]

auditcp dumps core in the following scenario:

1. auditcp> audtrail show
Enter trail file name: /opt/dcelocal/var/security/sec_audit_trail
Enter trail dump file name (enter for screen dump): /tmp/audit_out

The audit trail that I was trying to dump was large (and growing by
the minute - theory is that this is because auditd - which is required
to view the audit_trail info - is using security - which is logging
records to the sec_audit_trail .... 

This dump appears to be in an infinite loop on Event 298 (Ie. the 
dump continues until it either dumps core, you can't stand to wait
any longer or your disk fills up between the local audit trail file
growth and the size of the output file if you've selected this option).

For example, the sec_audit_trail file was about 3 meg when I requested
that auditcp dump the file - at the end (when it dumped core), the
sec_audit_trail file was about 12 meg!  This is on a system that was doing
nothing other than running auditd and auditcp to view the sec_audit_trail that
was generated during cell configure.  The event that seemed to be
being logged over and over is 298.  (ie. This is the full record

--- Dumping an event record --- Event Number: 298
Unknown client and cell uuids
Number of groups: 0
Event Outcome: success
Authorization Status: Authorized with a pac
Local Time: 1994-07-01-12:55:05.730-04:00I1.519
1 event specific info items
char string
--- End of an event record ---
)

This record is repeated over and over.  When it dumped core, the
last record contained in the output file looked like this:

--- Dumping an event record --- Event Number: 0
Event Outcome:
Authorization Status: Local Time: {^C1D{^C1L{^C2
--- End of an event record ---

The following was displayed in the window that auditcp was executing
in:
# /opt/dcelocal/bin/auditcp
auditcp> audtrail show
Enter trail file name: /net/little/opt/dcelocal/var/security/sec_audit_trail
Enter trail dump file name (enter for screen dump):/net/nerikomi/tmp/audit_out
Exception: wrong version of IDL Encoding Services (dce / rpc)
Abort(coredump)

I didn't get the core dump because the file was accidently deleted.
I will continue to watch for this and add the dump when I get it.

Note that Event 298 is part of the latest security code points being added.
This defect was found during testing of these code points.

[7/6/94 public]
Redirected to dcecp.

[7/6/94 public]
Mary, can you give me some setup information to reproduce this? I want
to see if dcecp has the same problem. I assume that you were running
secd -audit locally? What filters had you created? Anything else to help
me create the problem?

[7/7/94 public]
Since we're not even sure if this happens with dcecp it can't be
priority 0.  Downgraded to a 1, we'll try to reproduce.

[7/7/94 public]
After talking to HP, it is most likely that dcecp will see the same problem.
What is happening is that the late auditcp and dcecp both call dce_aud_print()
to print (format) and audit trail record. dce_aud_print() makes a call to 
sec_id_gen_name() which generates an audit event, which gets tossed into
the never ending queue of events to be displayed. My guess on what needs
to happen is either a snapshot of the audit trail file must be taken at
the beginning of the show procedure, and only that snapshot will be
shown, or there must be some way of temporarily turning off auditing 
while calls that generate audit events are being made.
I'm pointing this to IBM to fix.

[7/26/94 public]
Fixed.  Cached local id to break the loop.



CR Number                     : 11124
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : ecfile_filter
Short Description             : OS-dependent test in testsuite
Reported Date                 : 6/29/94
Found in Baseline             : 1.1
Found Date                    : 6/29/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b11
Affected File(s)              : ts/cp_auditd/cp_auditd
test/security/audit/ts/ecfile_filter/stopauditd
Sensitivity                   : public

[6/29/94 public]
This segment of code:

  nr_of_dcecp=$( ps -e | grep -c dcecp )
  while ((nr_of_dcecp!=0))
  do
    sleep 5
    nr_of_dcecp=$( ps -e | grep -c dcecp )
  done 

Causes and infinite loop on OSF1.  That is because 'ps -e' produces
slightly different results than it does on HP/UX or RIOS -- it shows the
arguments to the command whereas on other platforms it only shows the
command.  Therefore, the grep counts the 'grep -c dcecp' process in
addition to the 'dcecp' processes and thus the test never reaches 0.

The same is true for the 'auditcp' version of the code.

This script should have OS-dependent 'ps' flags.  An example, below, is
taken from the auditd_startup script:

        if [ "`uname`" = "OSF1" ]
        then
                PS_FLAGS="-e -o ucomm"
        else
                PS_FLAGS="-e"
        fi

[6/29/94 public]
fixed. both in ecfile_filter as well as in cp_auditd.



CR Number                     : 11123
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : all
Short Description             : remove hardcoded '-g' from
CFLAGS
Reported Date                 : 6/29/94
Found in Baseline             : 1.1
Found Date                    : 6/29/94
Severity                      : E
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b19
Affected File(s)              : auditd/Makefile,
libaudit/Makefile
Sensitivity                   : public

[6/29/94 public]

Prior to the 1.1 completion the hardcoded -g should be removed from the
CFLAGS lines.

[9/6/94 public]

Reassigned per minutes from managers meeting.

[09/26/94 public]
fixed.

[09/29/94 public]
Verified the fix.



CR Number                     : 11121
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : aud
Subcomponent Name             : fvt
Short Description             : cp_auditd07 fails
Reported Date                 : 6/28/94
Found in Baseline             : 1.1
Found Date                    : 6/28/94
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b11
Affected File(s)              : unknown
Sensitivity                   : public

[6/28/94 public]
test fails on HP.  No other information is available at the moment (nothing
is written to stdout or stderr to indicate the nature of the problem.)
I'll track this down tomorrow.

Can you reproduce on your HP?

[7/11/94 public]
This is believed to be fixed be some earlier submissions.  Waiting for
verification.

[9/12/94 public]
Runs of FVTs against BL17 now pass.



CR Number                     : 11115
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : cp_filter
Short Description             : Need to create filter before
removing it.
Reported Date                 : 6/28/94
Found in Baseline             : 1.1
Found Date                    : 6/28/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : ts/cp_filter/cp_filter
Sensitivity                   : public

[6/28/94 public]
The cp_filter testsuite has the following problem:

  START: cp_filter04 started
  audfilter modify {principal aud_test_princ2} -remove {dce_audit_filter_modifydenial log}
  
  OK: audfilter remove - successful
  {principal aud_test_princ1}
  {group aud_test_group1}
  {cell krbtgt/hither}
  world
  
  OK: audfilter catalog - successful
  Error: No filter found.

The filter needs to be created before it is removed.

[6/29/94 public]
Fixed.  Filter for aud_test_princ2 added as prerequisite to removing it.
The error: No filter found, on the other hand, is expected part of the
test, since trying to show the filter after removing it, to prove that
it was removed indeed



CR Number                     : 11109
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditcp
Short Description             : Move auditcp to nosupport
Reported Date                 : 6/28/94
Found in Baseline             : 1.1
Found Date                    : 6/28/94
Severity                      : E
Priority                      : 4
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b12
Affected File(s)              : src/security/audit/auditcp/*
src/security/audit/Makefile
Sensitivity                   : public

[6/28/94 public]
Move auditcp source code to nosupport.

[7/6/94 public]
Done.   Moved src/security/audit/auditcp to
src/nosupport/security/audit/auditcp.



CR Number                     : 11024
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : functional test
Short Description             : use dcecp as audit control program
Reported Date                 : 6/21/94
Found in Baseline             : 1.1
Found Date                    : 6/21/94
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b11
Affected File(s)              : most test suites
Sensitivity                   : public

[6/21/94 public]
Use dcecp as audit control program.

[6/24/94 public]
done.



CR Number                     : 11010
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : cp_filter
Short Description             : auditcp filter catalog coredumps
Reported Date                 : 6/20/94
Found in Baseline             : 1.1
Found Date                    : 6/20/94
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b11
Affected File(s)              : src/test/security/audit/ts/cp_filter/cp_filter
Sensitivity                   : public

[6/20/94 public]

In attempting to run the audit tests, I noted that the "START: cp_filter03" 
test was hanging "forever".  I attempted to run the command found in this
test manually. After an extended period of time without response from auditcp,
it dumped core due to "segmentation violation".  The core dump appear below:

>trace
 0 audfilter_catalog + 0x000003a8 (0x7aff2b40, 0x4000ec08, 0x7afe3728, 0x2e205573)
 1 cma__dispatch@libdce + 0x000003c0 (0x7aff2ac0, 0x1, 0x40, 0x7afe6430)
 2 _fp_status + 0x00000040 (Address not found (UE302)

[6/20/94 public]
Testcase cp_filter03 has a hardcoded cell name in it ... and I'm guessing
you didn't name your cell 'torolab.ibm.com' ?

IBM will submit the fix as soon as the tree is open.

[6/22/94 public]
fixed.



CR Number                     : 10995
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : Misc errors in test log
Reported Date                 : 6/17/94
Found in Baseline             : 1.1
Found Date                    : 6/17/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b11
Affected File(s)              : esl_sync.c
Sensitivity                   : public

[6/17/94 public]
I found a number of what seem to be errors in the api_filter test log (that
which is sent to stdout and stderr.)

  calling dce_aud_open 
  cannot make /opt/dcelocal/var/audit/client/12651/ directory
  
  dce_aud_open returns bad status= 10323064

[6/24/94 public]
fixed.

[6/27/94 public]
Fix was to use rmdir() and remove() instead of unlink() in
unregister_update_interface.



CR Number                     : 10994
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486,hppa
S/W Ref Platform              : osf1,hpux
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : aud_testd core dumps
Reported Date                 : 6/17/94
Found in Baseline             : 1.1
Found Date                    : 6/17/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b11
Affected File(s)              : trl_ops.c
Sensitivity                   : public

[6/17/94 public]
aud_testd core dumps during api_log_to_daemon.  Various attempts to
reproduce the problem show the program dumping core in differing test
cases. This occurs on 486 and HPUX.

  Start run_new_test
  servername= hosts/gemini/self
  Start aud_testd_case2
  dce_aud_open returns in_trail ptr = 4aadc8
  dce_aud_start returns in_ard ptr = 4ab248
  
  dce_aud_print (in) event:
   
  --- Dumping an event record --- Event Number: 998
  Client: /.../hither/hosts/gemini/self
  Number of groups: 2
  Group 0: /.../hither/none
  Group 1: /.../hither/none
  Event Outcome: success 
  Authorization Status: Authorized with a pac
  Local Time: 1994-06-17-09:48:02.721-04:00I-----
  Client Address: ncacn_ip_tcp:130.105.5.83[3880]
  1 event specific info items
  long int 10
  --- End of an event record --- 
  
  
  
  dce_aud_open returns in_trail ptr = 4aadc8
  api_log_to_daemon1[6]: 12252 Memory fault(coredump)
  16#8b
  
  
  ERROR: api_log_to_daemon01 failed
  
  ERROR: api_log_to_daemon02 failed
  
  PASS: api_log_to_daemon03 passed
  
  ERROR: api_log_to_daemon04 failed
  
  PASS: api_log_to_daemon05 passed
    
I reran aud_testd in a debugger and got the resulting backtrace.  Note that
the debugger session dumped core in aud_testd_case4:

  test log access result is False 
  sec_acl_perm_log = 128
  1994-06-17-09:56:53.178-04:00I----- auditd ERROR aud general 0x00533328
  a client's audit log access denied
  aud_testd_case4 succeeded
  
  Program received signal 11, Segmentation fault
  0xa40036d4 in free ()
  (gdb) bt
  #0  0xa40036d4 in free ()
  #1  0xa40036c8 in free ()
  #2  0x40b838 in dce_aud_close (at=0x4aae48, status=0x532b6c)
      at /project/dce/build/dce1.1-snap/src/security/audit/libaudit/trl_ops.c:340
  #3  0x403e24 in aud_testd_case4 (h=0x4aa340, stp=0x532b6c)
      at /project/dce/build/dce1.1-snap/src/test/security/audit/ts/api_log_to_daemon/aud_testd_rpc_manager.c:369
  #4  0x4017a5 in op3_ssr (h=0x4aa340, IDL_call_h=0x4b50f0, IDL_elt_p=0x532e4c, IDL_drep_p=0x4b0f50, 
      IDL_transfer_syntax_p=0x4b52ec, IDL_mgr_epv=0x412224, IDL_status_p=0x532e28) at aud_testd_sstub.c:459
  #5  0xa41fc498 in rpc__cn_call_executor (4935920, 0)
  #6  0xa41d3c88 in rpc_call_did_mgr_execute (4919856)
  #7  0xa41ac39b in cma__thread_base ()
  #8  0xa41b178d in cma__create_thread ()
  #9  0xa41d3ad8 in rpc_call_did_mgr_execute ()
  #10 0x525e28 in attr ()
  Cannot access memory at address 0x2.

[6/21/94 public]
fixed.
dce_aud_close was freeing trail_file, after checking that it was not NULL, but in some 
cases trail_file is not initialized at all, therefore the check didn't help.
Check for location instead.



CR Number                     : 10990
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : functional test
Short Description             : api_filter03 fails
Reported Date                 : 6/17/94
Found in Baseline             : 1.1
Found Date                    : 6/17/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b11
Affected File(s)              : cp_filter, addfilter.cell delfilter.cell
Sensitivity                   : public

[6/17/94 public]
api_filter03 fails on 486.  No further information available in journal or
log.

[6/17/94 public]
Also failed on RIOS earlier this week.

[6/17/94 public]
Reproduced again on AT386 and HP.  The probable cause is a series of
'command execution failures':

  Enter Subject Name (press enter if no more subject): Enter Audit Condition (press entrer if no more condition): Enter Aud
  it Condition (press entrer if no more condition): Enter Audit Action (press entrer if no more action): Enter Audit Action
   (press entrer if no more action): Enter Event Class (press enter if no more event classes): Enter Event Class (press ent
  er if no more event classes): More Guides? (n)/y command excution failed
  
  dce_aud_start
  TestCase2 succeeded
  deleting filter group1 took: 15212
  adding filter cell took: 12896
  Start run_new_test
  aud_client_server pw_princ1= princ1, pw_princ2= princ2
  
   princ2prec->key.tagged_union.plain = princ2, plain= princ2
  servername= hosts/gemini/self
  
  inside the TRY-CATCH: principal= 2Start aud_testf_case3
  
  client is aud_test_princ2
  
  calling dce_aud_open 
  cannot make /opt/dcelocal/var/audit/client/12651/ directory
  
  dce_aud_open returns bad status= 10323064
  Enter
  0 for principal
  1 for foreign principal
  2 for group
  3 for foreign group
  4 for cell
  5 for cell overridable
  6 for world
  7 for world overridable
  Enter Subject Name (press enter if no more subject): command excution failed
  Enter
  0 for principal
  1 for foreign principal
  2 for group
  3 for foreign group
  4 for cell
  5 for cell overridable
  6 for world
  7 for world overridable
  Enter Audit Condition (press entrer if no more condition): Enter Audit Condition (press entrer if no more condition): Ent
  er Audit Action (press entrer if no more action): Enter Audit Action (press entrer if no more action): Enter Event Class 
  (press enter if no more event classes): Enter Event Class (press enter if no more event classes): More Guides? (n)/y 
  dce_aud_start
  TestCase3 succeeded
  deleting filter cell took: 13143
  adding filter world took: 16365

[weisz 6/22/94 public] 
fixed.
removed hardcoded cell name assignement.



CR Number                     : 10988
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa,i486
S/W Ref Platform              : hpux,osf1
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : api_log_to_daemon failures
Reported Date                 : 6/17/94
Found in Baseline             : 1.1
Found Date                    : 6/17/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b11
Affected File(s)              : test suite
Sensitivity                   : public

[6/17/94 public]
api_log_to_daemon01 fails on HP and 486:
api_log_to_daemon02 fails on 486
api_log_to_daemon04 fails on 486

No further information available from journal or log

[6/20/94 public]
Fix submitted.



CR Number                     : 10987
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : aud
Subcomponent Name             : api_log
Short Description             : api_log01 failed
Reported Date                 : 6/17/94
Found in Baseline             : 1.1
Found Date                    : 6/17/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b11
Affected File(s)              : 
test/security/audit/ts/api_log/api_log
Sensitivity                   : public

[6/17/94 public]
No more information is available in either the journal or the log from the
test.

[6/17/94 public]
This failed because 'aud_test not found.'  Actually, it means that none of
the results of this test have any meaning.

Solution is to provide a path for 'aud_test' in the testsuite.

[6/20/94 public]
Fix submitted.



CR Number                     : 10986
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : fvt
Short Description             : need comprehensive p/f result
Reported Date                 : 6/17/94
Found in Baseline             : 1.1
Found Date                    : 6/17/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b16
Affected File(s)              : api_log, api_log_to_daemon, api_filter, ecfile_filter
Sensitivity                   : public

[6/17/94 public]
Each test suite should log a Pass/Fail result for the overall result
of the suite.  I.e.  if all test cases pass then the suite passes,
otherwise the suite fails.  Also,  the result should be logged with a
unique message such as:

	Suite result <testsuite>:  {PASS/FAIL/NORESULT]

This would make extracting the basic test results from the journal file
much easier.

[8/22/94 public]
Replaced hardcoded tet_results of PASS, with actual results of the suite.



CR Number                     : 10985
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa,i486
S/W Ref Platform              : hpux,osf1
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : Auditd logs fatal message on
benign shutdown
Reported Date                 : 6/17/94
Found in Baseline             : 1.1
Found Date                    : 6/17/94
Severity                      : E
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b16
Affected File(s)              : libaudit/aud.sams
Sensitivity                   : public

[6/17/94 public]
Auditd logs to following message upon receiving 'aud stop':

1994-06-17-08:22:17.177-04:00I----- auditd FATAL aud general 0xa44aead0
auditd non-distinguished thread received fault

[8/22/94 public]
Changed svc msgs from fatal to notice_verbose and notice, and remove
the exit_bad action.



CR Number                     : 10896
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : aud
Subcomponent Name             : cp_filter
Short Description             : cp_filter fails to detect
error condition in test 5
Reported Date                 : 6/8/94
Found in Baseline             : 1.1
Found Date                    : 6/8/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1beta
Fixed In Baseline             : 1.1
Affected File(s)              : test/security/audit/ts/cp_filter/cp_filter
Sensitivity                   : public

[6/8/94 public]
cp_filter05 shows PASS despite a critical error.

START: cp_filter05 started
Enter
0 for principal
1 for foreign principal
2 for group
3 for foreign group
4 for cell
5 for cell overridable
6 for world
7 for world overridable
Enter Subject Name (press enter if no more subject): Enter Audit Condition (press entrer if no more condition): Enter Audit Condi
tion (press entrer if no more condition): Enter Audit Action (press entrer if no more action): Enter Audit Action (press entrer i
f no more action): Enter Event Class (press enter if no more event classes): Enter Event Class (press enter if no more event clas
ses): More Guides? (n)/y command excution failed

ERROR: could not add filter 1

OK: auditcp audfilter catalog - successful
Enter
0 for principal
1 for foreign principal
2 for group
3 for foreign group
4 for cell
5 for cell overridable
6 for world
7 for world overridable
Enter Subject Name (press enter if no more subject): no filter

return from auditcp audfilter show for aud_test_princ2 = 0

PASS: cp_filter05 passed

[6/9/94 public]
fixed

[6/9/94 public]
Fix verified via FVT.



CR Number                     : 10889
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : aud
Subcomponent Name             : auditd_startup
Short Description             : method for determining
preconditions is not correct
Reported Date                 : 6/8/94
Found in Baseline             : 1.1
Found Date                    : 6/8/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1beta
Fixed In Baseline             : 1.1b10
Affected File(s)              : 
test/security/audit/ts/auditd_startup/auditd_startup
Sensitivity                   : public

[6/8/94 public]
The auditd_startup testsuite uses the following code to determine whether
auditd is already running (and, therefore, the test precondition is not
met):

  total_auditd=$( ps -e | grep -c auditd )
  auditd_startup=$( ps -e | grep -c auditd_startup )
  (nr_of_auditds = total_auditd - auditd_startup)) 
    
This works as long as TCC is invoked with 'all' testsuites.  However, if
you invoke the 'auditd_startup' test suite independently than the
precondition test fails.  This is because the grep for 'total_auditd' finds
four auditds:

	- the 'grep auditd' process
	- the 'tcc auditd_startup' process
	- two TET process with the name of the testsuite in the path

so, total-auditd = 4, auditd_startup = 1, and the testsuite incorrectly
believes auditd is already running.  Also, it also fails if you happen to
be logging TET output to a file named after the test suite (e.g., 'tcc
auditd_startup | tee log.auditd_startup').

A workaround is to change the syntax of the 'grep -c' commands to:

	grep -c "auditd "
	grep -c "auditd_startup "

[6/8/94 public]
Fix submitted.

[6/8/94 public]
Nope, that wasn't the right fix.  Currently embedding OS-dependent ps
switches in test.

[6/10/94 public]
Fixed, once again.



CR Number                     : 10829
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : Memory leaks in dce_aud_start
causes secd to grow and dumping core when running out of memory.
Reported Date                 : 6/1/94
Found in Baseline             : 1.1
Found Date                    : 6/1/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1beta
Fixed In Baseline             : 1.1
Affected File(s)              : evt_write.c evt_utils.c trl_ops.c esl_sync.c dmn_rpc_manager.c
Sensitivity                   : public

[6/1/94 public]
During the testing of the new sec drop in my sandbox, we found the secd
grow from 10.2 M to 24 M during the secd functional testing and ultimately
dumping core when running out of memory. This bug needs to be fixed for
Beta.

[6/9/94 public]
Plugged most leaks in the library.

[6/9/94 public]
Closed.  See long description in ot10924 for proof.  There may still be
leaks, but they're a heck of a lot smaller.  New leaks found will be opened
under a new defect.



CR Number                     : 10810
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : meaningful sec_acl_printstring
Reported Date                 : 5/31/94
Found in Baseline             : 1.1
Found Date                    : 5/31/94
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b10
Affected File(s)              : dmn_acl_mgr.c
Sensitivity                   : public

[5/31/94 public]
Need to change the "crw" strings, see below:
-------------------------------------------
 From: rps@apollo.hp.com
 Date: Thu, 26 May 94 13:56:43 EDT
 Subject: sec acl mgr printstrings
 To: Robert Weisz (416)448-3131 <weisz@torolab6.vnet.ibm.com>
 Reply-To: Robert_Stanzel@ch.hp.com

 Hi, I've re-appended the whole list so you can compare & contrast...

 The manager info sec_acl_printstring_t's two text fields should be:

        printstring     A token naming the manager
        helpstring      A phrase describing the manager

 The current acl editor acl_edit doesn't use them now, but dcecp or
 other programs could.


 For auditd, I'd suggest something like
        "audit" "Audit daemon manager"
 though I haven't read the code to see what space it manages...

 Thanks, Rob


 **** Forwarded Message Follows ****

 These are the <name, help [where convenient]> strings in the current DCE.

     {   "crw",  "crw" },       /* auditd -- needs fixing -rps */

     "DFS",                     "DFS ACL manager",
     "acl_test_server",         "Sample ACL manager.",
     "Sec Policy"
     "Sec Principal"
     "Sec Group"
     "Sec Org"
     "Sec Directory"
     "Sec Replist"
     "Sec Attr_Schema"
     {"dced-managers"},          {"DCED manager Pseudo-object"}
     {"hostdata"},               {"Host Data"}
     {"rkeytab"},                {"Key Management"}
     {"srvrconf"},               {"Server Configuration"}
     {"srvrexec"},               {"Server Execution"}
     {"secval"},                 {"Security Validation"}
     {"attr_schema"},            {"Attribute Schema"}
     {"dced-mgmt"},              {"DCED manager"}
     "general",          "General ACL Manager"
     "CDS Clerk"	"Change ACL for clerk management"
     "CDS Server"	"Change ACL for server management"
     "Directory"	"Change ACL for CDS directory"
     "Directory entry"	"Change ACL for CDS directory entry"
     "Clearinghouse"	"Change ACL for CDS clearinghouse"
     "GDA"              "Change ACL for gda management"
     "dtsd",		"DTSD DCE Time Service daemon"
     "acl_test",                "ACL Test Manager"


 **** End of Forwarded Message ****

[7/11/94 public]
Added to above list (Howard has pointed out that some cds/dts were missing)
in case it's used as a guide for others that will need tweaking (cds&sec)

[7/11/94 public]
Submitted the fix quite a while ago (May 31), forgot to update the CR to fix.



CR Number                     : 10803
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : functional tests
Short Description             : minor cleanup
Reported Date                 : 5/30/94
Found in Baseline             : 1.1
Found Date                    : 5/30/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : cp_filter auditd_acl
Sensitivity                   : public

[5/30/94 public]

Suite cp_filter needs to remove the audit filters it creates, after
the suite ends.  Also auditd should start without "-a" option, since
default acl does not allow auditd to log audit records.
Suite auditd_acl should check for "crw" permissions in the acl, and 
not for "crwl" since default acl does not allow logging.

[5/30/94 public]
fixed

[6/9/94 public]
closed.



CR Number                     : 10801
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : malloc and free problems
Reported Date                 : 5/27/94
Found in Baseline             : 1.1b9
Found Date                    : 5/27/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : libaudit/trl_ops.c
Sensitivity                   : public

[5/27/94 public]
There are two memory problems in trl_ops.c:

libaudit/trl_ops.c: 197
            (*at)->trail_file = (char *) malloc(strlen(description));
            strcpy((*at)->trail_file, description);

shouldn't the malloc be (strlen(description) +1)  ??



libaudit/trl_ops.c: 322
    free(at);

Shouldn't it be freeing at->trail_file first and then freeing at?

[5/29/94 public]
fixed.



CR Number                     : 10764
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : aud
Subcomponent Name             : ecfile_filter
Short Description             : aud_testec dumps core
Reported Date                 : 5/25/94
Found in Baseline             : 1.1
Found Date                    : 5/25/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b11
Affected File(s)              : aud_testec.c startauditd stopauditd
Sensitivity                   : public

[5/25/94 public]
aud_testec dumps core during ecfile_filter01

With binaries from 5/24:

  START: ecfile_filter1 started
  
  Enter
  0 for principal
  1 for foreign principal
  2 for group
  3 for foreign group
  4 for cell
  5 for cell overridable
  6 for world
  7 for world overridable
  Enter Audit Condition (press entrer if no more condition): Enter Audit Condition (press entrer if no more condition): Enter Audit Action (press entrer if no more action): Enter Audit Action (press entrer if no more action): Enter Event Class (press enter if no more event classes): Enter Event Class (press enter if no more event classes): More Guides? (n)/y ecfile_filter1[7]: 2337 Memory fault(coredump)
  16#8b
  
  
  ERROR: ecfile_filter01 failed

Not much information from the core, unfortunately:

[6/9/94 public]
Reproduced with binaries from 6/7/94.

[6/10/94 public]
This occurs both when executed with all test suites, and individually.
Here's information from SVC:

1994-06-10-07:25:26.370-04:00I----- auditd NOTICE_VERBOSE aud general 0xa44adad0 set daemon locale: (null)
1994-06-10-07:25:26.690-04:00I----- auditd NOTICE aud general 0xa44adad0 the audit daemon started
1994-06-10-07:25:27.240-04:00I----- auditd NOTICE_VERBOSE aud general 0xa44adad0 daemon registered interfaces with RPC runtime
1994-06-10-07:25:29.969-04:00I----- auditd NOTICE_VERBOSE aud general 0xa44adad0 daemon registered its authentication identity hosts/gemini/self with RPC runtime
1994-06-10-07:25:30.009-04:00I----- auditd NOTICE_VERBOSE aud general 0x004d5918 daemon is ready to listen to its interfaces
1994-06-10-07:25:38.549-04:00I----- auditcp DEBUG1 aud msgs 0xa44adad0 input_evt_table: File /opt/dcelocal/etc/audit/ec/dce_audit_filter_modify opened

1994-06-10-07:25:38.709-04:00I----- auditcp DEBUG1 aud msgs 0xa44adad0 DoKeyWord: Find keyword ECN with residual string 0

1994-06-10-07:25:38.709-04:00I----- auditcp DEBUG1 aud msgs 0xa44adad0 DoKeyWord: Find keyword SEP with residual string  0x100 

1994-06-10-07:25:38.719-04:00I----- auditcp DEBUG1 aud msgs 0xa44adad0 input_evt_table: File /opt/dcelocal/etc/audit/ec/dce_audit_filter_modify define event class number 0

1994-06-10-07:25:38.719-04:00I----- auditcp DEBUG1 aud msgs 0xa44adad0 input_evt_table: File /opt/dcelocal/etc/audit/ec/dce_audit_filter_query opened

1994-06-10-07:25:38.719-04:00I----- auditcp DEBUG1 aud msgs 0xa44adad0 DoKeyWord: Find keyword ECN with residual string 1

1994-06-10-07:25:38.719-04:00I----- auditcp DEBUG1 aud msgs 0xa44adad0 DoKeyWord: Find keyword SEP with residual string  0x100 

1994-06-10-07:25:38.719-04:00I----- auditcp DEBUG1 aud msgs 0xa44adad0 input_evt_table: File /opt/dcelocal/etc/audit/ec/dce_audit_filter_query define event class number 1

1994-06-10-07:25:38.729-04:00I----- auditcp DEBUG1 aud msgs 0xa44adad0 input_evt_table: File /opt/dcelocal/etc/audit/ec/dce_dts_mgt_modify opened

1994-06-10-07:25:38.779-04:00I----- auditcp DEBUG1 aud msgs 0xa44adad0 DoKeyWord: Find keyword ECN with residual string 2

1994-06-10-07:25:38.779-04:00I----- auditcp DEBUG1 aud msgs 0xa44adad0 DoKeyWord: Find keyword SEP with residual string  0x200 

1994-06-10-07:25:38.779-04:00I----- auditcp DEBUG1 aud msgs 0xa44adad0 input_evt_table: File /opt/dcelocal/etc/audit/ec/dce_dts_mgt_modify define event class number 2

1994-06-10-07:25:38.779-04:00I----- auditcp DEBUG1 aud msgs 0xa44adad0 input_evt_table: File /opt/dcelocal/etc/audit/ec/dce_dts_mgt_query opened

1994-06-10-07:25:38.789-04:00I----- auditcp DEBUG1 aud msgs 0xa44adad0 DoKeyWord: Find keyword ECN with residual string 3

1994-06-10-07:25:38.789-04:00I----- auditcp DEBUG1 aud msgs 0xa44adad0 DoKeyWord: Find keyword SEP with residual string  0x200 

1994-06-10-07:25:38.789-04:00I----- auditcp DEBUG1 aud msgs 0xa44adad0 input_evt_table: File /opt/dcelocal/etc/audit/ec/dce_dts_mgt_query define event class number 3

1994-06-10-07:25:38.799-04:00I----- auditcp DEBUG1 aud msgs 0xa44adad0 input_evt_table: File /opt/dcelocal/etc/audit/ec/dce_dts_synch opened

1994-06-10-07:25:38.799-04:00I----- auditcp DEBUG1 aud msgs 0xa44adad0 DoKeyWord: Find keyword ECN with residual string 4

1994-06-10-07:25:38.799-04:00I----- auditcp DEBUG1 aud msgs 0xa44adad0 DoKeyWord: Find keyword SEP with residual string  0x200 

1994-06-10-07:25:38.799-04:00I----- auditcp DEBUG1 aud msgs 0xa44adad0 input_evt_table: File /opt/dcelocal/etc/audit/ec/dce_dts_synch define event class number 4

1994-06-10-07:25:38.809-04:00I----- auditcp DEBUG1 aud msgs 0xa44adad0 input_evt_table: File /opt/dcelocal/etc/audit/ec/dce_dts_time_provider opened

1994-06-10-07:25:38.809-04:00I----- auditcp DEBUG1 aud msgs 0xa44adad0 DoKeyWord: Find keyword ECN with residual string 5

1994-06-10-07:25:38.809-04:00I----- auditcp DEBUG1 aud msgs 0xa44adad0 DoKeyWord: Find keyword SEP with residual string  0x200 

1994-06-10-07:25:38.809-04:00I----- auditcp DEBUG1 aud msgs 0xa44adad0 input_evt_table: File /opt/dcelocal/etc/audit/ec/dce_dts_time_provider define event class number 5

1994-06-10-07:25:39.779-04:00I----- auditd DEBUG9 aud general 0x0053d428 audit daemon serving RPC number 1
1994-06-10-07:25:39.789-04:00I----- auditd ERROR aud general 0x0053d428 client has no permission to execute operation

-----------

For some reason aud_testec is dropping core files that don't provide a
stack trace so I had to run it out of gdb.

sec_login_setup_identity() is returning 'sec_rgy_object_not_found'
(probably because of the of our old friend, the security bug(s)) aud_testec
is dying in the subsequent call to sec_login_validate_identity() is
dumping.

The return code from sec_login_setup_identity() needs to be handled.

Program received signal 11, Segmentation fault
0xa432654d in sec_login_validate_cert_auth (-1073743944)
(gdb) bt
#0  0xa432654d in sec_login_validate_cert_auth (-1073743944)
#1  0xa4326758 in sec_login_validate_identity (0, -1073743944, -1073744516, -1073744520, -1073744500)
#2  0x4008fc in aud_client_server (aud_test_case_n=0x400e40 <main+736>)
    at ../../../../../../../src/test/security/audit/ts/ecfile_filter/aud_testec.c:221
#3  0x40029d in tp1 () at ../../../../../../../src/test/security/audit/ts/ecfile_filter/aud_testec.c:111
#4  0x400bb4 in main () at ../../../../../../../src/test/security/audit/ts/ecfile_filter/aud_testec.c:278

[6/10/94 public]
fixed.

[6/17/94 public]
Reproduced today with binary from 6/13.
 
Program received signal 11, Segmentation fault
0xa432706d in sec_login_validate_cert_auth (-1073743916)
(gdb) bt
#0  0xa432706d in sec_login_validate_cert_auth (-1073743916)
#1  0xa4327481 in sec_login_validate_identity ()

[6/29/94 public]
fixed again...



CR Number                     : 10754
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : aud
Subcomponent Name             : api_log_to_daemon
Short Description             : api_log_to_daemon01 fails
Reported Date                 : 5/24/94
Found in Baseline             : 1.1
Found Date                    : 5/24/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1beta
Fixed In Baseline             : 1.1
Affected File(s)              : dmn_main.c
Sensitivity                   : public

[5/24/94 public]
Test fails. Here's the journal:

  0|1.10 15:10:50 19940524|User: zeliff (0) TCC Start, Command Line: /dcetest/dcelocal/test/tet/bin/tcc -e functional/security/audit api_log_to_daemon 
  20|/dcetest/dcelocal/test/tet/functional/security/audit/tetexec.cfg 1|Config Start
  30||TET_VERSION=1.10
  30||TET_OUTPUT_CAPTURE=False
  30||TET_RESCODES_FILE=tet_code
  30||TET_EXEC_IN_PLACE=False
  30||TET_NSIG=31
  30||TET_SIG_IGN=26,34
  40||Config End
  70||"Starting AUDIT api_log_to_daemon Test Suite"
  10|0 /ts/api_log_to_daemon/api_log_to_daemon 15:10:50|TC Start, scenario ref 32-1
  15|0 1.9 1|TCM Start
  520|0 0 26574 1 1|START DCE audit functional test: /u2/dcetest/test/tet/tet_tmp_dir/26569a/api_log_to_daemon/api_log_to_daemon; DATE: Tue May 24 15:10:58 EDT 1994
  400|0 1 1 15:10:58|IC Start
  200|0 1 15:10:58|TP Start
  520|0 1 26574 1 2|START: api_log_to_daemon1 started
  520|0 1 26574 1 3|ERROR: api_log_to_daemon01 failed
  520|0 1 26574 1 4|PASS: api_log_to_daemon02 passed
  520|0 1 26574 1 5|PASS: api_log_to_daemon03 passed
  520|0 1 26574 1 6|PASS: api_log_to_daemon04 passed
  520|0 1 26574 1 7|PASS: api_log_to_daemon05 passed
  220|0 1 0 15:11:49|PASS
  410|0 1 1 15:11:49|IC End
  520|0 0 26574 1 1|END DCE audit functional test: /u2/dcetest/test/tet/tet_tmp_dir/26569a/api_log_to_daemon/api_log_to_daemon; DATE: Tue May 24 15:11:49 EDT 1994
  80|0 0 15:11:51|TC End
  70||"Completed AUDIT api_log_to_daemon Test Suite"
  900|15:11:51|TCC End

Here's the stdout:
  --- Dumping an event record --- Event Number: 999
  Client: /.../gemini/hosts/gemini/self
  Event Outcome: success 
  Authorization Status: Authorized with a pac
  Local Time: 1994-05-24-15:11:13.431-04:00I-----
  --- End of an event record --- 
  
  
  
  
  dce_aud_commit returns bad status= 16c9a016
  16#1

[5/29/94 public]
fixed.
dmn_main.c needs to unexport acl and svc interfaces, upon exit.
somes exits happen within a dce_svc_printf (with exit_bad), so
they have to be taken care of as well.



CR Number                     : 10751
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : aud
Subcomponent Name             : 
Short Description             : aud_test dumps core during api_log
Reported Date                 : 5/24/94
Found in Baseline             : 1.1
Found Date                    : 5/24/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1beta
Fixed In Baseline             : 1.1b10
Affected File(s)              : test/security/audit/ts/api_log/aud_test_rpc_manager.c
Sensitivity                   : public

[5/24/94 public]
During the api_log test the aud_test program dumps core.  These binaries
were built on 5/15.

Here's an extract from stdout:
  --- Dumping an event record --- Event Number: 990
  Client: /.../gemini/hosts/gemini/self
  Event Outcome: success 
  Authorization Status: Authorized with a pac
  Local Time: 1994-05-24-14:33:26.796-04:00I-----
  Client Address: ncacn_ip_tcp:130.105.5.83[1662]
  --- End of an event record --- 
  
  
  
  audit record header.addr:
   ncacn_ip_tcp:130.105.5.83[1662]
  
  audit record header.client_id[0].num_groups:
   0
  api_log1[6]: 25359 Memory fault(coredump)
  16#8b
    
Here's the journal from the test:
  0|1.10 14:33:13 19940524|User: zeliff (0) TCC Start, Command Line: /dcetest/dcelocal/test/tet/bin/tcc -e functional/security/audit api_log 
  20|/dcetest/dcelocal/test/tet/functional/security/audit/tetexec.cfg 1|Config Start
  30||TET_VERSION=1.10
  30||TET_OUTPUT_CAPTURE=False
  30||TET_RESCODES_FILE=tet_code
  30||TET_EXEC_IN_PLACE=False
  30||TET_NSIG=31
  30||TET_SIG_IGN=26,34
  40||Config End
  70||"Starting AUDIT api_log Test Suite"
  10|0 /ts/api_log/api_log 14:33:14|TC Start, scenario ref 28-1
  15|0 1.9 1|TCM Start
  520|0 0 26133 1 1|START DCE audit functional test: /u2/dcetest/test/tet/tet_tmp_dir/26128a/api_log/api_log; DATE: Tue May 24 14:33:21 EDT 1994
  400|0 1 1 14:33:21|IC Start
  200|0 1 14:33:21|TP Start
  520|0 1 26133 1 2|START: api_log1 started
  520|0 1 26133 1 3|ERROR: api_log01 failed
  520|0 1 26133 1 4|ERROR: api_log02 failed
  520|0 1 26133 1 5|PASS: api_log03 passed
  520|0 1 26133 1 6|ERROR: api_log04 failed
  520|0 1 26133 1 7|PASS: api_log05 passed
  520|0 1 26133 1 8|PASS: api_log06 passed
  520|0 1 26133 1 9|PASS: api_log07 passed
  520|0 1 26133 1 10|ERROR: api_log08 failed
  520|0 1 26133 1 11|PASS: api_log09 passed
  520|0 1 26133 1 12|PASS: api_log10 passed
  520|0 1 26133 1 13|PASS: api_log11 passed
  520|0 1 26133 1 14|PASS: api_log12 passed
  520|0 1 26133 1 15|PASS: api_log13 passed
  520|0 1 26133 1 16|PASS: api_log14 passed
  220|0 1 0 14:33:54|PASS
  410|0 1 1 14:33:54|IC End
  520|0 0 26133 1 1|END DCE audit functional test: /u2/dcetest/test/tet/tet_tmp_dir/26128a/api_log/api_log; DATE: Tue May 24 14:33:54 EDT 1994
  80|0 0 14:33:55|TC End
  70||"Completed AUDIT api_log Test Suite"
  900|14:33:55|TCC End

Here's the stack trace from the core file:
  (gdb) bt
  #0  0x40976f in aud_test_case10 (h=0x4a05a8, stp=0x481b7c)
      at /project/dce/build/dce1.1-snap/src/test/security/audit/ts/api_log/aud_test_rpc_manager.c:884
  #1  0x402af5 in op9_ssr (h=0x4a05a8, IDL_call_h=0x4b3cc8, IDL_elt_p=0x481e54, IDL_drep_p=0x4afd28, 
      IDL_transfer_syntax_p=0x4b3ec4, IDL_mgr_epv=0x418360, IDL_status_p=0x481e30) at aud_test_sstub.c:1167
  #2  0xa41f385c in attr ()
  #3  0xa41d144f in attr ()
  #4  0xa41ac38b in attr ()
  #5  0xa41b177d in attr ()
  #6  0xa41d12f4 in attr ()
  #7  0x4cce18 in attr ()
  Cannot access memory at address 0x2.

[5/25/94 public]
Reproduced again with binaries from 5/24 nightly build.  Bl9.5

[6/10/94 public]
Reproduced with binaries from 6/8.

More debugging information.

Here's the console output from testcase 10:

  Start aud_test_case10
  calling dce_aud_start with flag aud_c_evt_address_info
  dce_aud_print (in) event: 
  --- Dumping an event record --- Event Number: 990
  Client: /.../hither/cell_admin
  Event Outcome: success 
  Authorization Status: Authorized with a pac
  Local Time: 1994-06-10-10:24:25.451-04:00I-----
  Client Address: ncacn_ip_tcp:130.105.5.83[3743]
  --- End of an event record --- 
  
  
  dce_aud_print (out) event: 
  --- Dumping an event record --- Event Number: 990
  Client: /.../hither/cell_admin
  Event Outcome: success 
  Authorization Status: Authorized with a pac
  Local Time: 1994-06-10-10:24:25.451-04:00I-----
  Client Address: ncacn_ip_tcp:130.105.5.83[3743]
  --- End of an event record --- 
  
  
  
  audit record header.addr:
   ncacn_ip_tcp:130.105.5.83[3743]
  
  audit record header.client_id[0].num_groups:
   0
  api_log1[6]: 20635 Memory fault(coredump)
  16#8b

The journal doesn't provide any useful information.  However, it is
interesting to note that it thinks api_log10 passed, despite the coredump.

[6/14/94 public]

Test that the defect is unlocked



CR Number                     : 10735
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : ./security/audit/libaudit/evt_write.c
Short Description             : LOGIN_GetInfo audit event causes secd to crash
Reported Date                 : 5/23/94
Found in Baseline             : 1.1
Found Date                    : 5/23/94
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : evt_write.c
Sensitivity                   : public

[5/23/94 public]

The addition of the LOGIN_GetInfo auditable event (in rs_login_get_info)
causes secd to periodically crash.  

The problem appears to be in ./src/security/audit/libaudit/evt_write.c  
(within dce_aud_start()):

>    if (authz_svc == rpc_c_authz_dce) {
>	dce_aud_start_with_pac(event, (sec_id_pac_t *) v1_privs, addr, options,
>			       outcome, ard, stp);
>    } else if (authz_svc == rpc_c_authz_name) {
>	dce_aud_start_with_name(event, (unsigned_char_t *) v1_privs, addr,
                                                           ^^^^^^^^
>				options, outcome, ard, stp);

"v1_privs" is delegation specific information and can not be passed around
as an unsigned char *.  Subsequent calls to dce_aud_start_with_name() and
then to sec_id_parse_name() are causing secd to crash.

Apparent fix is to change "v1_privs" to "callers_identity" as 2nd param in 
dce_aud_start_with_name() call.

Traceback info:

>t
 0 strlen@libc + 0x00000008 (hp-ux export stub)
 1 sec__id_parse_name@libdce + 0x00000128 (0x4036baf8, 0, 0xad000800, 0x401813b0)
 2 sec_id_parse_name@libdce + 0x00000068 (0x4036baf8, 0xad000800, 0x401813b0, 0x401817c4)
 3 dce_aud_start_with_name (event = 275, client = 0xad000800, address =   00000000, options = 0, out
come = 4294967295, ard = 0x401806f4, status = 0x40180710)    [/afs/ch/project/dce/build/dce1.1/src/s
ecurity/audit/libaudit/evt_write.c: 299]
 4 dce_aud_start (event = 275, binding = 0x403d1da8, options = 0, outcome = 4294967295, ard = 0x4018
06f4, stp = 0x40180710)    [/afs/ch/project/dce/build/dce1.1/src/security/audit/libaudit/evt_write.c
: 139]
 5 rs_login_get_info + 0x0000006c (0x403d1da8, 0x4017e850, 0x4017f454, 0x4017f470)
 6 op0_ssr + 0x00000264 (0x403d1da8, 0x403d2850, 0x4017e4cc, 0x4017e4b0)
 7 rpc__dg_execute_call@libdce + 0x000015b4 (0x403d2850, 0, 0, 0)
 8 cthread_call_executor@libdce + 0x00000270 (0x400edd58, 0x7af501f8, 0x40042460, 0x9)

[5/23/94 public]

The correct quick fix is call sec_cred_get_client_princ_name() to retrieve
the client's principal name from callers_identity.  Unlike the pre1.1
rpc_authz_handle_t returned by rpc_binding_inq_auth_client(), an
rpc_authz_cred_handle_t returned by the new rpc_binding_inq_auth_caller()
is truly opaque, and cannot (and should not) be cast to anything
meaningful.

In the case where the authorization service is rpc_c_authz_name,
the audit code is calling sec_id_parse_name() to convert the 
client's name to a PAC.  Is that really necessary?  Shouldn't
the caller's identity be logged in a format appropriate to
the authorization service in use: in this case, a DCE principal
name?

[5/29/94 public]
fixed.
Storing the UUID keeps the trail more consistent, easier to search.
It's not "really necessary" one way or the other.



CR Number                     : 10710
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : sams
Short Description             : Sams file needs cleanup
Reported Date                 : 5/20/94
Found in Baseline             : 1.1
Found Date                    : 5/20/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b17
Affected File(s)              : aud.sams
Sensitivity                   : public

[5/20/94 public]

There are a number of editorial and content changes that need to be made to
the Audit sams file.  A complete hard-copy review has been sent to Robert
Weisz for consideration.

[09/02/94 public]
Done.



CR Number                     : 10703
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : Can't aud rewind non-central trail
Reported Date                 : 5/19/94
Found in Baseline             : 1.1
Found Date                    : 5/19/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b20
Affected File(s)              : dmn_rpc_manager.c dmn_main.c evt_utils.c 
evt_write.c trl_ops.c aud.sams audit.h evtp.h and functional tests
Sensitivity                   : public

[5/19/94 public]


> > I wanted to rewind the audit daemon trail file
> > which contains the audit record for the
> > security code points.
> > The trail file is located in /opt/dcelocal/var/security/sec_audit_trail.
> >
> >
> > I thought "aud rewind" might work.
> > However it had no effect of the sec_audit_trail.
> > Is this a bug?
> >

It's not.
It was not intended to be used on anything else but the central trail.
(aud rewind does not prompt for a trail file name, for a reason.)
The trail full situation for non-central_trail files can be addressed
by the user of the audit API, by checking the return code from
dce_aud_commit and handling above dce_aud_commit, i.e. in the user's code.

Although I think that a better approach would be to handle this inside
dce_aud_commit, so as not to unduly burden the application using audit.
I would say, open a CR for an enhancement request.

(Using auditcp aud rewind is not a solution since this RPC interface
is implemented in the audit daemon, not in the library and adding
it to the library opens a security problem, i.e. anybody would be
able to rewind the file, unless we add another ACL to protect this
interface, which adds more admin complexity.)

[7/6/94 public]
auditcp has been defuncted, so this becomes an enhancement to libaudit.

[8/24/94 public]

HP believes that this really should be a defect and not an enhancement.
Security is forced to use local audit trails by the architectural dep-
endencies between audit and security.  The security daemon (without the
use of filters) during a functional test cycle generates about 3 meg of
data an hour.  This quickly fills the disk.  If you need/want to keep
this data around, you must currently stop secd - backup the log file and
then restart secd.  In a production environment this is not acceptable.

[09/29/94 public]
fixed.



CR Number                     : 10596
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : functional test
Short Description             : api_log_to_daemon assumes log ACL
Reported Date                 : 5/10/94
Found in Baseline             : 1.1
Found Date                    : 5/10/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : aud_testd.c aud_testd_rpc_manager.c
Sensitivity                   : public

[5/10/94 public]

api_log_to_daemon test suite wrongly assumes default ACL allows logging
to auditd. (default is crw , not crwl).



CR Number                     : 10529
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : code lagging design spec
Reported Date                 : 5/4/94
Found in Baseline             : 1.1
Found Date                    : 5/4/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : aud_test_rpc_manager.c
Sensitivity                   : public

[5/4/94 public]

Action flags "log" and "alarm" have been made independent of each other
in the design.  I.e. alarm does not automaticaly log as well.  This choice
is left for the user of the API.  The code has to reflect this as well.

Testcase api_log07 fails because of this.

[5/06/94 public]
This was a testcase problem.  Fixed testcase api_log07.
The log was produced by default, since audit is turned on, and filtering
is not enabled, hence everything is logged.

[5/12/94 public]
Closed.



CR Number                     : 10516
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : bad messages from auditd
Reported Date                 : 5/3/94
Found in Baseline             : 1.1b8
Found Date                    : 5/3/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b15
Affected File(s)              : dmn_rpc_manager.c dmn_updt_inform.c aud.sams evt_write.c trl_ops.c
Sensitivity                   : public

[5/3/94 public]
Status codes returned from an API should not contain a %s. There is no way
for the client to know what %s should be (or that there should be a %s at
all).

[8/9/94 public]
Fixed.



CR Number                     : 10501
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : dce_aud_open should initialize at=NULL
Reported Date                 : 5/2/94
Found in Baseline             : 1.1
Found Date                    : 5/2/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : trl_ops.c
Sensitivity                   : public

[5/2/94 public]

dce_aud_open does not initialize at (audit trail descriptor) to NULL.

[5/3/94 public]
fixed

[5/4/94 public]
Closed.



CR Number                     : 10469
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : segmentation violation on HP
Reported Date                 : 4/27/94
Found in Baseline             : 1.1
Found Date                    : 4/27/94
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : evt_classes.c
Sensitivity                   : public

[4/27/94 public]

In function input_evt_table, when initializing aud_g_cli_evt_classes to NULL,
aud_g_cli_num_of_ecs needs to be initialized as well to 0, otherwise 
a segmentation violation happens in add_evt_to_evt_table.

[5/02/94 public]
fixed

[5/4/94 public]
Closed.



CR Number                     : 10419
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : aud
Subcomponent Name             : api_log
Short Description             : syntax error
Reported Date                 : 4/21/94
Found in Baseline             : 1.1
Found Date                    : 4/21/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b8
Affected File(s)              : see below
Sensitivity                   : public

[4/21/94 public]

There are compilation errors in function "aud_client_server" which
occurs in 3 modules of the functional tests for audit:
 
[ /test/security/audit/ts/api_log at 03:36 (AM) Thursday ]

In file included from
 /project/dce/build/dce1.1-snap/src/test/security/audit/ts/api_log/aud_test.c:
 18:
 /u1/devobj/sb/nb_486/export/at386/usr/include/dce/dce_cf.h:49: parse error
 before `*'
/project/dce/build/dce1.1-snap/src/test/security/audit/ts/api_log/aud_test.c:
 In function `aud_client_server':
....
*** Error code 1

[ /test/security/audit/ts/api_log_to_daemon at 03:37 (AM) Thursday ]

/u1/devobj/sb/nb_486/export/at386/usr/include/dce/dce_cf.h:49: parse error
 before `*'
/project/dce/build/dce1.1-snap/src/test/security/audit/ts/api_log_to_daemon/\
 aud_testd.c: In function `aud_client_server':
....

[ /test/security/audit/ts/ecfile_filter at 03:38 (AM) Thursday ]

In file included from
 /project/dce/build/dce1.1-snap/src/test/security/audit/ts/ecfile_filter/aud_testec.c:18:
/u1/devobj/sb/nb_486/export/at386/usr/include/dce/dce_cf.h:49: parse error
 before `*'
....

[4/21/94 public]
The files modified are:

src/test/security/audit/ts/
	api_log/Makefile
	api_log/aud_test.c
	api_log_to_daemon/Makefile
	api_log_to_daemon/aud_testd.c
	ecfile_filter/Makefile
	ecfile_filter/aud_testec.c

There were two problems:
- the macro FILE was not found, but is used by dce_cf.h
	- this problem was fixed by explicitly including stdio.h in the
	offending program
- TRY/CATCH macros were not found
	- INCFLAGS line contained a poor path, thus the wrong pthread.h
	file was being included.

[5/4/94 public]
Closed.



CR Number                     : 10416
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit auditd
Short Description             : wrong place for unregister_update_interface
Reported Date                 : 4/20/94
Found in Baseline             : 1.1
Found Date                    : 4/20/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : dmn_rpc_manager.c trl_ops.c
Sensitivity                   : public

[4/20/94 public]
unregister_update_interface is not a public API, hence is should
be invoked inside dce_aud_close, and also removed from 
audit_control_stop in dmn_rpc_manager.c.



CR Number                     : 10402
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : more functional tests
Reported Date                 : 4/19/94
Found in Baseline             : 1.1
Found Date                    : 4/19/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : all new
Sensitivity                   : public

[4/19/94 public]
Second batch of functional tests for audit.



CR Number                     : 10386
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : Turn audit FVT on in build
Reported Date                 : 4/18/94
Found in Baseline             : 1.1
Found Date                    : 4/18/94
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b8
Affected File(s)              : src/test/security/Makefile
Sensitivity                   : public

[4/18/94 public]
Add 'audit' to SUBDIRS of src/test/seucrity/Makefile.

[4/18/94 public]
Fix submitted.

[4/19/94 public]
Closed



CR Number                     : 10385
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : functional
Short Description             : Cleanup stuff in makefile
Reported Date                 : 4/18/94
Found in Baseline             : 1.1
Found Date                    : 4/18/94
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b8
Affected File(s)              : see below
Sensitivity                   : public

[4/18/94 public]
Clean up various minor things in the functional test makefiles:

src/test/security/audit/Makefile:
src/test/security/audit/ts/Makefile:
src/test/security/audit/ts/auditd_acl/Makefile
src/test/security/audit/ts/auditd_startup/Makefile
src/test/security/audit/ts/cp_auditd/Makefile
src/test/security/audit/ts/cp_filter/Makefile

[4/18/94 public]
Fix submitted.

[4/19/94 public]
Closed.



CR Number                     : 10370
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : Running passwd_import
functional test 6 secd core dumps.
Reported Date                 : 4/15/94
Found in Baseline             : 1.1
Found Date                    : 4/15/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1beta
Fixed In Baseline             : 1.1
Affected File(s)              : evt_write.c evt_read.c
Sensitivity                   : public

[4/15/94 public]

Using nightly build available on 4/14 AM (which is bl-7), during execution
of passwd_import functional test secd core dumps on HP/UX. The same tests
passes on 486 using same build. The last time these tests passed on HP-UX
was on 3/24. Here is some info from xdb:


r0  00000000 00000000 800b290b 00000000 r4  00000002 40383c2c 00000000
00002000
r8  40385c2c 40385c28 00000000 00000000 r12 00000000 00000000 00000000
00000000
r16 00000000 00000000 00000000 7b007948 r20 177dc000 800b27b8 7afe84c8
40384894
r24 11000400 00000001 00000000 40025f08 r28 177db009 40383c28 402332a0
7b01278c
    pc = 000024b5.800b2908     priv = 3     psw = jthlnxbCvmrQPDI     sar =
26
        0x800b28d8   free    +0108   LDWS    0(0,5),26
        0x800b28dc   free    +010c   DEPI    0,31,2,26
        0x800b28e0   free    +0110   ADD     5,26,8
        0x800b28e4   free    +0114   LDWS    0(0,8),1
        0x800b28e8   free    +0118   BB,<,N  1,31,free+0168
        0x800b28ec   free    +011c   LDW     -1412(0,19),31
        0x800b28f0   free    +0120   LDO     -4(8),9
        0x800b28f4   free    +0124   LDW     0(0,31),23
        0x800b28f8   free    +0128   COMCLR,<>       23,8,0
        0x800b28fc   free    +012c   STW     5,0(0,31)
        0x800b2900   free    +0130   BL      _open+0274,2
        0x800b2904   free    +0134   LDWS    0(0,9),26
 >      0x800b2908   free    +0138   LDW     -32(0,30),19
        0x800b290c   free    +013c   LDWS    0(0,9),25
        0x800b2910   free    +0140   OR      5,0,31
        0x800b2914   free    +0144   DEPI    -1,31,1,31
        0x800b2918   free    +0148   AND     4,25,20
        0x800b291c   free    +014c   OR      31,20,31
        0x800b2920   free    +0150   STWS    31,0(0,9)
        0x800b2924   free    +0154   LDWS    0(0,8),25
        0x800b2928   free    +0158   DEPI    0,31,2,25
        0x800b292c   free    +015c   ADD     7,25,8
        0x800b2930   free    +0160   OR      0,8,9
        0x800b2934   free    +0164   STWS    9,0(0,5)
        0x800b2938   free    +0168   COMIBT,=,N      0,6,free+0194
 File: unknown    Procedure: free + 0x00000138    Line: unknown
  

Copyright Hewlett-Packard Co. 1985,1987-1992. All Rights Reserved.
<<<< XDB Version A.09.01 HP-UX >>>>
Do you want to save a backup copy of the core file? n
Core file from:  secd
Child died due to: segmentation violation
WARNING: /usr/lib/end.o was not linked with this program (UE836)
         Shared-library debugging cannot be made available (UE837)
Procedures:     87
Files: 13
>t
 0 free + 0x00000138 (0x1a, 0, 0x40230fff, 0x4022d000)
 1 _xflsbuf + 0x00000008 (Address not found (UE302)

[04/19/94 public]

We also reproduced this problem only on HP-UX when we were trying to run
the system test smoketests on BL-7.  I was able to run secd on AIX with
no problem.

[04/19/94 ]

I saw the same thing on SVR4.  Here is the backtrace.
#0  0x80cad70 in __nr_free ()
#1  0x80ca11b in free ()
#2  0x80c234c in dce_aud_commit (at=0x8329a38, ard=0x8398054, options=2, f
rmat=0,
    outcome=1, status=0x82c881c)
    at ../../../../../src/security/audit/libaudit/evt_write.c:593
#3  0x808269d in rs_acct_add (h=0x8327c7c, login__name=0x82c9dad, key_parts
0x82c9da8,
    user_part=0x82c9a88, admin_part=0x82c9a30, key=0x82c9a18, new_keytype=
ec_passwd_des,
    new_key_version=0x82c9a10, cache_info=0x82c99f4, status=0x82c99f0)
    at ../../../../../src/security/server/rs/rs_acct.c:262
#4  0x807083d in op0_ssr (h=0x8327c7c, IDL_call_h=0x82ecab0, IDL_elt_p=0x8
caca4,
    IDL_drep_p=0x824efb8, IDL_transfer_syntax_p=0x82eccac, IDL_mgr_epv=0x8
daec4,
    IDL_status_p=0x82cac80) at rs_acct_sstub.c:1613
#5  0x8019bc66 in rpc__cn_call_executor  ()
#6  0x8018542a in cthread_call_executor ()
#7  0x801074ba in cma__thread_base (tcb=0x81186a0)
    at ../../../src/threads/cma_thread.c:1327
(gdb)


See the following line:
    at ../../../../../src/security/audit/libaudit/evt_write.c:593
593                 free(ep);

(note this only happens when the input parm options is set to 2).

[4/19/94 public]

This problem appears to be in libaudit. Assigning this CR to audit
component.

[4/21/94 public]

This seems to be same problem as CR 9975, but missed when 9975 was fixed.
The free(ep) statement should be removed from dce_aud_commit, file evt_write.c
(I will test as soon as I get baseline 7 installed...)

[05/10/94 public]
Robert, I talked to Rich about this defect and we decided that this one
should be closed and you should open another one with your concern about
a possible memory leak.



CR Number                     : 10353
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : dce_aud_open - check input flags
Reported Date                 : 4/14/94
Found in Baseline             : 1.1
Found Date                    : 4/14/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : trl_ops.c, aud.sams
Sensitivity                   : public

[4/14/94 public]
Only flags allowed for opening a trail file are read, or write, 
and just one of them must be present.

[5/05/94 public]
fixed

[6/9/94 public]
Closed.



CR Number                     : 10336
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : typo on unexport acl interface
Reported Date                 : 4/12/94
Found in Baseline             : 1.1
Found Date                    : 4/12/94
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : dmn_main.c
Sensitivity                   : public

[4/12/94 public]
Typo on second call to rpc_ns_binding_unexport: should be rdaclif
instead of serviceability.  Also add the two unexport calls to the
other exit possibilities of the CATCH, CATCH_ALL.

[4/13/94 public]
fixed

[5/4/94 public]
Closed.



CR Number                     : 10327
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : submit functional tests
Reported Date                 : 4/11/94
Found in Baseline             : 1.1
Found Date                    : 4/11/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b8
Affected File(s)              : all new tests
Sensitivity                   : public

[4/11/94 public]
Submission of first batch of functional tests for audit.

[5/4/94 public]
Closed.



CR Number                     : 10322
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd, libaudit
Short Description             : add unregister update i/f function
Reported Date                 : 4/10/94
Found in Baseline             : 1.1
Found Date                    : 4/10/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : esl_sync.c dmn_rpc_manager.c
Sensitivity                   : public

[4/10/94 public]
Audit daemon needs to unregister its update interface on termination.

[4/12/94 public]
Fix. Created function unregister_update_interface in file esl_sync.c
Added its invocation in audit_control_stop, file dmn_rpc_manager.c.



CR Number                     : 10320
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : Bus error + core dumped on HP hardware
Reported Date                 : 4/10/94
Found in Baseline             : 1.1
Found Date                    : 4/10/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : esl_file_read.c
Sensitivity                   : public

[4/10/94 public]
When auditd tries to read the esl update file (function 
aud_esl_input_update_file) it gets a Bus error and a a core dump.
This happens when running on HP hardware, runs ok on RS/6000.

[4/12/94 public]
Used memcpy instead of a cast in esl_file_read.c.

[4/20/94 public]
Closed.



CR Number                     : 10318
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : aud
Subcomponent Name             : 
Short Description             : audit_control.acf is not exported
Reported Date                 : 4/8/94
Found in Baseline             : 1/1
Found Date                    : 4/8/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b7
Affected File(s)              : security/audit/idl/Makefile
Sensitivity                   : public

[4/8/94 public]
The new audit_control.acf file needs to be exported to the export tree so
that dcecp can pick it up with the audit_control.idl file.
I will make the submit if there are no problems with this.

[4/12/94 public]
New Makfile has been submitted.

[4/20/94 public]
Closed.



CR Number                     : 10314
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : aud
Subcomponent Name             : 
Short Description             : NULL pointer used in dce_aud_close
Reported Date                 : 4/7/94
Found in Baseline             : 1.1
Found Date                    : 4/7/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : dce_aud_clo
Sensitivity                   : public

[4/7/94 public]

When auditd is started without the -a option, when invoking auditcp aud stop,
function audit_control_stop calls dce_aud_close once for audit_trail and once
for central_trail, but in this case audit_trail is NULL.  dce_aud_close does
not check for NULL pointer and tries to use it.

[4/20/94 public]
Closed.



CR Number                     : 10178
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : aud
Subcomponent Name             : 
Short Description             : options and outcome missing from dce_aud_commit documentation
Reported Date                 : 3/18/94
Found in Baseline             : 1.1
Found Date                    : 3/18/94
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b18
Affected File(s)              : dce_aud_commit.3sec
Sensitivity                   : public

[3/18/94 public]

On the man pages I have for aud, under dce_aud_commit(3aud)
it says for the following parameters (options and outcome):

options ...option values described below...

outcome ...The following event-outcome values are defined:


However, the valid values of options and outcome
are missing from this particular man pages.

[09/12/94]
This has been fixed. The values of the options and outcome are in the doc.

[10/25/94 public]
Closed bug.



CR Number                     : 10155
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : Change syntax of CFLAGS assignment
Reported Date                 : 3/16/94
Found in Baseline             : 1.1
Found Date                    : 3/16/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b11
Affected File(s)              : audit/auditd/Makefile,
audit/auditcp/Makefile, audit/libaudit/Makefile
Sensitivity                   : public

[3/16/94 public]
Change the CFLAGS assignment from 
	CFLAGS = <whatever>
to
	CFLAGS += <whatever>

This allows more CFLAGS to be added from the 'build' command line.  E.g.,
build CFLAGS="-DDCE_DEBUG"

[6/29/94 public]
Fix submitted.



CR Number                     : 10152
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : constant debugging messages
Reported Date                 : 3/16/94
Found in Baseline             : 1.1
Found Date                    : 3/16/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b13
Affected File(s)              : security/audit/auditd/dmn_acl_mgr.c
Sensitivity                   : public

[3/16/94 public]
The acl_test_log_access() function has to following unwrapped code:

    if (*result == FALSE) {
        printf("test log access result is False \n");
        printf("sec_acl_perm_log = %ld\n", sec_acl_perm_log);
    }

This should be executed conditionally based upon 'debug_mode', or built-in
conditionally based upon DCE_AUD_DEBUG.

[7/19/94 public]
fixed.



CR Number                     : 10147
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : aud
Subcomponent Name             : auditcp
Short Description             : aud disable/modify don't work
Reported Date                 : 3/16/94
Found in Baseline             : 1.1
Found Date                    : 3/16/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : dmn_rpc_manager.c cp_daemon.c auditcpp.h aud.sams
Sensitivity                   : public

[3/16/94 public]
The 'aud disable' command seemingly doesn't work:

  auditcp> aud show
  Attribute Types: state (0), stostrategy (1)
  Enter a number: 0 
  Logging service is enabled 
  auditcp> aud disable
  auditcp> aud show
  Attribute Types: state (0), stostrategy (1)
  Enter a number: 0
  Logging service is enabled 
  auditcp> 

Tests run on binaries of nightly build of 3/15.

[3/16/94 public]
More information:  'aud modify' doesn't seem to work:

  auditcp> aud show
  Attribute Types: state (0), stostrategy (1)
  Enter a number: 0
  Logging service is enabled 
  auditcp> aud modify
  Attribute Types: state (0), stostrategy (1)
  Enter a number: 0
  Enter state attribute value: enabled (0), disabled (1)1
  auditcp> aud show
  Attribute Types: state (0), stostrategy (1)
  Enter a number: 0
  Logging service is enabled 
  auditcp> aud modify
  Attribute Types: state (0), stostrategy (1)
  Enter a number: 1
  stostrategy attribute value: stop (512), wrap (256)256
  auditcp> aud show
  Attribute Types: state (0), stostrategy (1)
  Enter a number: 1
  stostrategy: Stop logging when trail is full
  auditcp>

[3/24/94 public]
In lieu of opening another CR, I'll modify this one...

The above failures are most likely caused becuase the user you are running
as does not have access to perform the operation. cell_admin DOES NOT,
by default, have access to the audit daemon's ACL.

The CR should be that the daemon should report an error back to the calling
RPC that the operation failed due to a lack of rights. It currently just
returns back to the caller.

[5/11/94 public]
Fixed. ACL permission test results are being passed back to the caller.



CR Number                     : 10142
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : ec
Short Description             : Add event class files for DTS
and AUD
Reported Date                 : 3/15/94
Found in Baseline             : 1.1
Found Date                    : 3/15/94
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b5
Affected File(s)              : see below
Sensitivity                   : public

[3/15/94 public]
Add the default event class files for DTS and AUD. 

Files are:

security/audit/ec/
	Makefile
	dce_audit_filter_modify
	dce_audit_filter_query
	dce_dts_mgt_modify
	dce_dts_mgt_query
	dce_dts_synch
	dce_dts_time_provider

[3/15/94 public]
Files submitted.

[3/16/94 public]
Closed.



CR Number                     : 10115
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : Add an "audevents show" command
Reported Date                 : 3/9/94
Found in Baseline             : 1.1
Found Date                    : 3/9/94
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : cp_main.c cp_events.c evt_classes.c
Sensitivity                   : public

[3/9/94 public]
On Sun Jan 30, 1994, Howard Melman wrote:

> Should we have an "audevents show" which returns the contents of
> the event class?  This would be the event class number (a 32 bit integer),
> and the list of event numbers (also a 32 bit integer).
> Would it need to show the prefix as well?

Shyh-Wei now has the new command "audevents show" in auditcp using
the following new functions (will now send a request to submit):

void input_ec_table()  /* initializes the event class table from event class
                          files */
void free_ec_talbe()  /* frees memory of the event class table */

/*
 * Gets a list of the events in the specified event class
 */
boolean32 get_ec_events
(
  char * ec_name,
  unsigned32 * ec_number,
  int  * evt_cnt,
  unsigned32 ** evts
)

/*
 * Gets a list of the event classes that are defined.
 */
boolean32 get_ec_names
(
  int  * ec_cnt,                /* output the number of evt classes defined */
  char *** ec_names             /* output a pointer to an array of name ptrs */
)

/*
 * Frees the memory allocated by get_ec_names.
 */
void free_ec_names
(
  int  ec_cnt,                /* number of evt classes names to be freed */
  char ** ec_names            /* an array of name ptrs */
)

[3/11/94 public]
Enhancement submitted.

[3/15/94 public]
Closed.



CR Number                     : 10076
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : aud
Subcomponent Name             : 
Short Description             : dce_aud_star_with_name - parameters other and cell do not exist in the code
Reported Date                 : 3/7/94
Found in Baseline             : 1.0
Found Date                    : 3/7/94
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : dce_aud_start_with_name.3sec
Sensitivity                   : public

[3/7/94 public]


First there is a documentation error, that we will fix, the parameters
other and cell do not exist in the code!
What you need is self, which can be any principal name that exists in
the cell (currently I am using cell_admin), and for addr you can put
NULL.

[3/15/94 public]

[10/18/94 public]
Deleted the "other" and "self" parameters.  Added the "client" parameter in
the man page of this API.
Assigned to IBM doc writer.

[10/25/94 public]
Closed bug.



CR Number                     : 10064
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : redundant return in dce_aud_open
Reported Date                 : 3/4/94
Found in Baseline             : 1.1
Found Date                    : 3/4/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : trl_ops.c
Sensitivity                   : public

[3/4/94 public]
In function dce_aud_open, after the check for DCEAUDFILTERON, there should be no return.
The return causes an  exception in pthread_mutex_lock, since it prevents pthread_mutex_init from 
being executed.

[3/11/94 public]
Removed the bogus return call.  Fix submitted.

[3/14/94 public]
Closed.



CR Number                     : 10048
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : Don't install libaudit
Reported Date                 : 3/1/94
Found in Baseline             : 1.1
Found Date                    : 3/1/94
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b5
Affected File(s)              : security/audit/libaudit/Makefile
Sensitivity                   : public

[3/1/94 public]
Don't install libaudit.  (Or, put another way, stick the API into libdce)

[3/15/94 public]
Fix submitted.  Removed libaudit from ILIST.

[3/16/94 public]
Closed.



CR Number                     : 10038
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : Include delegation chain in audit record header
Reported Date                 : 2/28/94
Found in Baseline             : 1.1
Found Date                    : 2/28/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : audit_log.idl evt_read.c evt_write.c evt_utils.c
Sensitivity                   : public

[2/28/94 public]
Delegation chain informamtion should be included in the audit header so
that DCE 1.1 programs that use the delegation mechanism can be freed the
the burden of appending this information in audit records.

To include delegation chain information in the audit header, the audit record
header data structure needs to be modified, and the new set of sec_cred API
functions should be used replacing the rpc_binding_inq_auth_info() call.

[3/2/94 public]
Allows variable number of client ids in the header.  Provids an API option to
include/print delegation information (dce_aud_start_*(), dce_aud_print()).
Replaces rpc_binding_inq_auth_info*() calls with sec_cred_*() calls to get
initiator and delegates credentials.  Function sec_cred_get_v1_pac is
then used to obtain v1 pacs from these cedentials.  

New audit record header structure (the initiator's id is always the first
element of the client_id array):

      typedef struct {
          uuid_t           client;
          uuid_t           cell;       /* client cell */
          unsigned16       num_groups; /* no. of client groups */
          [size_is(num_groups), ptr]
          uuid_t           *groups;   /* client groups */
      } client_id_t;
  
  
      typedef struct {
          unsigned16       format;     /* event tail data format*/
          uuid_t           server;     /* uuid of server (audit client) */
          unsigned32       event;      /* event number */
          unsigned16       outcome;    /* event outcome (failed?) */
          unsigned16       authz_st;   /* authorization status */
          unsigned16       num_client_ids; /* number of client id's */
          [size_is(num_client_ids), ptr]
          client_id_t      *client_id;
          utc_t            time;       /* record commit time */
          [string, ptr] 
          char             *addr;      /* client address */
      } dce_aud_hdr_t;

[3/14/94 public]
Closed.



CR Number                     : 10035
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : rdaclif.idl should not be in sec/audit/idl
Reported Date                 : 2/28/94
Found in Baseline             : 1.1
Found Date                    : 2/28/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : auditd/Makefile
Sensitivity                   : public

[2/28/94 public]
Defunct security/audit/idl/rdaclif.idl.  Audit should use
./security/idl/rdaclif.idl

[3/2/94 public]
Fix submitted.

Use rdaclifv0.idl in auditd/Makefile with VPATH reference to
../../idl (security/idl).  Defunct audit/idl/rdaclif.idl.

[3/14/94 public]
Closed.



CR Number                     : 9991
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : ard's should be initialized to NULL
Reported Date                 : 2/22/94
Found in Baseline             : 1.1
Found Date                    : 2/22/94
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : rpc_dmn_manager.c
Sensitivity                   : public

[2/22/94 public]
The ard's (dce_aud_rec_t type) should be initialized to NULL.  Without
this initialization, auditd would run away if it is started without the
"-d" option (i.e., when auditd is not self auditing).

[2/22/94 public]
It should read "... auditd would run away if it is started without the
"-a" option ..." in the above.

[2/23/94 public]
Fix submitted.

[3/14/94 public]
Closed.



CR Number                     : 9976
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditcp
Short Description             : auditcp should have 'help'
Reported Date                 : 2/18/94
Found in Baseline             : 1.1
Found Date                    : 2/18/94
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : cp_main.c
Sensitivity                   : public

[2/18/94 public]
auditcp should have a help command.  It doesn't have to be elaborate;
simply a list of valid auditcp commands.

[3/11/94 public]
Enhancement submitted.

[3/15/94 public]
Closed.



CR Number                     : 9975
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : aud
Subcomponent Name             : 
Short Description             : extra free calls cause segmentationfaults on HP
Reported Date                 : 2/18/94
Found in Baseline             : 1.1
Found Date                    : 2/18/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : libaudit/evt_utils.c auditd/dmn_rpc_manager.c
Sensitivity                   : public

[2/18/94 public]

There are two places where free() calls cause problem on HP/UX.

1. auditd/dmn_rpc_manager.c:

audit_log_append() frees the buffer that is also freed by idl_es_handle_free()
(idl_es_handle_free() is a idl pickling service routine and it needs to document
this behavior).

    free(ep);
    idl_es_handle_free(&es_h, stp);

2. libaudit/evt_utils.c:

aud__log_free_ev_info_list calls free() with an address not obtained from
malloc().  This causes a segmentation fault on HP/UX.  The following
lines shoulbe be removed.

    if (tail->info_item != NULL) {
        free(tail->info_item);
    }

The fix is to remove the free() calls.

[2/18/94 public]
Fix submitted.

[3/14/94 public]
Closed.



CR Number                     : 9974
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : "diff" Merge libaudit into libdce
Reported Date                 : 2/18/94
Found in Baseline             : 1.1
Found Date                    : 2/18/94
Severity                      : D
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : 
../src/libdce/RIOS/machdep.mk
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/18/94 public]
Libaudit needs to be incorporated into libdce at some point.

[6/16/94 public]
Important points to consider:  Rich Salz opened a bunch of defects against
various components with the following notice:

All IDL files that are part of libdce should be compiled with ACF files
that have the [fault_status,comm_status] attributes.  Without this, a
failing RPC could cause client code to core dump when there is a perfectly
good error_status_t parameter available.  When adding the ACF files, it is
important to make sure that no API changes.  As most routines probably
already have an "error_status_t *st" parameter this will probably not be
an issue; routines that don't will have to be handled on a case-by-case,
probably by adding a new routine that DOES have the status param and
changing our existing code to call that routin

[6/16/94 public]
The fault_status,comm_status, were taken care of in CR 9928.

[8/22/94 public]
Dropping priority.  This isn't getting done in this release.

[11/13/95 public]
According to the previous notes,  I think the only thing that was left 
is changing the ../src/libdce/<machine>/machdep.mk. I have checked with
Rich Salz and he told me that the only machine that we support in DCE1.2  
is AIX.  Therefore, I only change the following file:

  ../src/libdce/RIOS/machdep.mk

Here is the diff:

130c130
<       ${libdua_sec.a:P}
---
>       ${libdua_sec.a:P} ${libaudit.a:P}

[7/18/96 public]
Fixed in DCE1.2.2 (BL03).
~



CR Number                     : 9928
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : IDL files
Short Description             : Need fault_status comm_status
Reported Date                 : 2/10/94
Found in Baseline             : 1.1
Found Date                    : 2/10/94
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : audit_control.acf audit_log.acf audit_update.acf
Sensitivity                   : public

[2/10/94 public]
All IDL files that are part of libdce should be compiled with ACF files
that have the [fault_status,comm_status] attributes.  Without this, a
failing RPC could cause client code to core dump when there is a perfectly
good error_status_t parameter available.  When adding the ACF files, it is
important to make sure that no API changes.  As most routines probably
already have an "error_status_t *st" parameter this will probably not be
an issue; routines that don't will have to be handled on a case-by-case,
probably by adding a new routine that DOES have the status param and
changing our existing code to call that routine.

[4/20/94 public]
Closed.



CR Number                     : 9866
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : unitialized variable causing
core dumps
Reported Date                 : 2/1/94
Found in Baseline             : 1.1
Found Date                    : 2/1/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : 
security/audit/auditd/dmn_acl_mgr.c
Sensitivity                   : public

[2/1/94 public]
Here's the problem:

Shyh-Wei Luan writes:
I think I found the problem.  In dmn_acl_mgr.c and acl__create_default()
the hostpric variable is not initialized before it is referenced.  Idon't
know why this problem did not occur before.  (Does not make sense to me.
John Rousseau brought up auditd too! )

Anyway, the line 

  sec_id_parse_name(h, (unsigned_char_t *)auditd_identity, NULL, NULL,
NULL, &hostuuid, st);

should be  

  sec_id_parse_name(h, (unsigned_char_t *)auditd_identity, NULL, NULL,
host_princ, &hostuuid, st);

and host_princ should be declared as 

  sec_rgy_name_t host_princ; 

instead of 

  unsigned char       *hostprin;

Shyh-Wei has a fix for this but it cannot be submitted until the 1.1 tree
is open.

[2/8/94 public]

Fix submitted.

[2/18/94 public]
Closed.



CR Number                     : 9860
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : libaudit checks for
debug_mode, but debug_mode is defined in auditd
Reported Date                 : 1/31/94
Found in Baseline             : 1.1
Found Date                    : 1/31/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : auditcpp.h evtp.h esl_file_read.c evt_classes.c evt_filter.c evt_read.c evt_utils.c evt_write.c trp_ops.c
Sensitivity                   : public

[1/31/94 public]
The symbol "debug_mode" is checked in multiple places in libaudit, but the
definition of the symbol is in auditd (dmn_main.c). This makes any program 
that links with libaudit have unresolved references to "debug_mode".
Debugging output should be done with the debugging macros as specified in
RFC34.

[2/22/94 public]
Changed to use DCE_DEBUG.   Fix submitted.

[3/14/94 public]
closed



CR Number                     : 9845
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : ESL_UPDATE_FILE_NAME returns
bad path
Reported Date                 : 1/28/94
Found in Baseline             : 1.1
Found Date                    : 1/28/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : libaudit/esl_file_read.c
Sensitivity                   : public

[1/28/94 public]
On startup auditd goes into aud_esl_input_update_file (libaudit,
esl_file_read.c) and eventually calls the macro ESL_UPDATE_FILE_NAME.  This
macro returns the following path:

(gdb) p fname
$11 = 0x4931e8 "/opt/dcelocalesl-update-princ"

[2/18/94 public]

Fix submitted.  Inserted needed prefix "/var/audit/" in the strings
of the aud_g_esl_update_fname[] array.

-- diff showing the change

12,14d11
<  * Revision 1.1.5.1  1994/02/11  03:25:40  luan
<  * *** Initial Branch Revision ***
<  *
54,61c51,58
<         "esl-update-princ",
<         "esl-update-foreign-princ",
<         "esl-update-group",
<         "esl-update-foreign-group",
<         "esl-update-cell",
<         "esl-update-cell-overridable",
<         "esl-update-world",
<         "esl-update-world-overridable"
---     
>         "/var/audit/esl-update-princ",
>         "/var/audit/esl-update-foreign-princ",
>         "/var/audit/esl-update-group",
>         "/var/audit/esl-update-foreign-group",
>         "/var/audit/esl-update-cell",
>         "/var/audit/esl-update-cell-overridable",
>         "/var/audit/esl-update-world",
>         "/var/audit/esl-update-world-overridable"

[3/14/94 public]
closed



CR Number                     : 9834
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : dce_aud_start_with_name
Reported Date                 : 1/27/94
Found in Baseline             : 1.1
Found Date                    : 1/27/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b19
Affected File(s)              : dmn_rpc_manager.c evt_read.c evt_write.c
Sensitivity                   : public

[1/27/94 public]

dce_aud_start_with_name() shoud have a "server" parameter for the
caller (i.e., self) principal's identity.

[09/22/94 public]
Besides the above, the field "server" in the audit record header should
be filled by all dce_aud_start* calls.

[09/26/94 public]
Fixed.  The fix was to fill the server field at the audit daemon side, so
dce_aud_start* did not need to change, including dce_aud_start_with_name
did not need to change prototype.  The documentation CR related to this
will remove the "self" (for server) parameter.



CR Number                     : 9810
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : audit record format version number
Reported Date                 : 1/24/94
Found in Baseline             : 1.1
Found Date                    : 1/24/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : evt_write.c
Sensitivity                   : public

[1/24/94 public]

Audit record format version number (used in dce_aud_commit() call) should
reserve "0" (zero) as don't care.  This enhancement would allow audit
analysis tools to ignore version numbers when extracting audit records from
audit trails.  Severity B because security and time are being instrumented.
They should use a non-zero format version number if event-specific information
may change in future dce releases.  Version number "1" is suggested, to be
on the safe side.  I will add this description to DCE audit documents.

[2/21/94 public]

Fix submitted on 1/25/94.

[3/14/94 public]
Closed.



CR Number                     : 9799
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : aud
Subcomponent Name             : 
Short Description             : audfilter catalog lists empty filters
Reported Date                 : 1/22/94
Found in Baseline             : 1.1
Found Date                    : 1/22/94
Severity                      : E
Priority                      : 4
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : auditcp/cp_utils.c
Sensitivity                   : public

[1/22/94 public]

The list of filters displayed by auditcp when "audfilter catalog" command
is invoked should not include filters that have been deleted.

Added checks for empty filters in aud_cp_list_entries() to skip them.
Fix submitted.

[2/18/94 public]
Closed.



CR Number                     : 9796
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : audit_control
Short Description             : linked-list of guides in mgr routine
Reported Date                 : 1/21/94
Found in Baseline             : 1.1
Found Date                    : 1/21/94
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : dmn_rpc_manager.c esl_file_read.c
esl_in_core.c evt_filter.c cp_daemon.c cp_utils.c
Sensitivity                   : public

[1/21/94 public]
This could become an enh or doc issue.  Severity B since there isn't really
a work around.

The audit_control_{add,remove,show}_filter() routines take an
aud_filter_guides_p_t argument which is a linked-list of guides.  However
the manager routines only look at the first element and not the entire
linked list.

dcecp would like the manager routine to look at the linked-list so
operations on multiple guides could be atomic.  Currently we have to make
separate RPC's.  Atomicity is not a requirement but is desireable.  Hence
this CR could be an enh.

If this API is public, then either the manager routines should be fixed or
this should be changed to a doc issue.  The fact that you can only enter
one guide needs to be in the API documenation.

[1/23/94 public]
This API is not public (it is not documented in Application Development
Reference), but the names of the rpc interface operations would be
misnomers given the current behavior.  So I changed it to allow
multiple-guide operations, i.e., filter operations..

Fix submitted.

[2/18/94 public]
Closed.



CR Number                     : 9780
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : svcacl.h shouldn't be in audit
Reported Date                 : 1/19/94
Found in Baseline             : 1.1
Found Date                    : 1/19/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : auditd/svcacl.h
Sensitivity                   : public

[1/19/94 public]

svcacl.h has no business in the auditd source tree.  Audit should be using
the copy exported by dce/util/svc to the export tree.

This file is to be defuncted.

[1/20/94 pblic]

Fixed.

[2/18/94 public]
Closed.



CR Number                     : 9779
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : Duplicate ODE Log information
Reported Date                 : 1/19/94
Found in Baseline             : 1.1
Found Date                    : 1/19/94
Severity                      : E
Priority                      : 4
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b4
Affected File(s)              : auditd/dmn_acl_store.h
Sensitivity                   : public

[1/19/94 public]
The file has duplicate ODE copyright markers and history logs.

[2/18/94 public]
Fixed.

[3/14/94 public]
Closed.



CR Number                     : 9777
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : make use #include<dce/..> consistent
Reported Date                 : 1/19/94
Found in Baseline             : 1.1
Found Date                    : 1/19/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : auditd/Makefile dmn_esl_file_write.c dmn_main.c dmn_rpc_manager.c dmn_updt_inform.c auditcpp.h evtp.h
Sensitivity                   : public

[1/19/94 public]
There is inconsistent usage of the #include instruction.  Some files
include headers via #include<dce/audit.h> whereas others simply #include
<audit.h>

(audit.h is merely used as an example.)

If a header file is exported then it should be included via <dce/header.h>.

These are the headers which are current exported:

auditd: dceaudmsg.h, dceaudmac.h
h:	audit.h

Here are some of the problems:
auditd:
	dmn_esl_file_write.c:#include <dceaudmac.h>
	dmn_esl_file_write.c:#include <dceaudmsg.h>
	dmn_main.c:#include <audit.h>
	dmn_main.c:#include <dceaudmac.h>
	dmn_main.c:#include <dceaudmsg.h>
	dmn_rpc_manager.c:#include <audit.h>
	dmn_rpc_manager.c:#include <dceaudmac.h>
	dmn_rpc_manager.c:#include <dceaudmsg.h>
	dmn_updt_inform.c:#include <dceaudmac.h>
	dmn_updt_inform.c:#include <dceaudmsg.h>
h:
	auditcpp.h:#include <audit.h>

[2/18/94 public]

Fix submitted.

[3/14/94 public]
Closed.



CR Number                     : 9776
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : Need DCE_AUD_DEBUG
Reported Date                 : 1/19/94
Found in Baseline             : 1.1
Found Date                    : 1/19/94
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : h/audit.h
Sensitivity                   : public

[1/19/94 public]
Code cleanup.

There needs to be a component-specific debug flag DCE_AUD_DEBUG.  See
Coding Style Guide section 2.6.6.

[2/22/94 public]
Defined DCE_AUD_DEBUG in audit.h.  Fix submitted.

[3/14/94 public]
Closed.



CR Number                     : 9775
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : libaudit
Short Description             : Remove or change PRE_BETA_DEBUG
Reported Date                 : 1/19/94
Found in Baseline             : 1.1
Found Date                    : 1/19/94
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : libaudit/esl_in_core.c,
libaudit/esl_sync.c, libaudit/esl_classes.c
Sensitivity                   : public

[1/19/94 public]
Code cleanup.

The conditional compilation variable PRE_BETA_DEBUG should either be
removed or changed to DCE_DEBUG.

[2/22/94 public]
Changed to DCE_DEBUG.  Fix submitted.

[3/14/94 public]
Closed.



CR Number                     : 9774
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : Don't use bcopy()
Reported Date                 : 1/19/94
Found in Baseline             : 1.1
Found Date                    : 1/19/94
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : auditd/dmn_esl_file_write.c
Sensitivity                   : public

[1/19/94 public]
Code cleanup item.

bcopy() is a BSD function.  Pick another option -- memmove(), perhaps.  See
section 2.4 of the coding style guide.

[3/11/94 public]
Changed to use memcpy().

[3/14/94 public]
Closed.



CR Number                     : 9773
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : header files should check for
prior inclusion
Reported Date                 : 1/19/94
Found in Baseline             : 1.1
Found Date                    : 1/19/94
Severity                      : D
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : see below
Sensitivity                   : public

[1/19/94 public]
This change is required to bring audit into conformance with the DCE coding
style guide:  section 2.8.

Header files should check for prior inclusion.  For example, dmn_acl_mgr.h
should be wrapped in:

#ifndef _DMN_ACL_MGR_H
#define _DMN_ACL_MGR_H
  <actual text of header file goes here>
#endif /* _DMN_ACL_MGR_H */


header files affected are:

auditd:
	dmn_acl_mgr.h
	dmn_aud_evtsp.h
	svcacl.h	<-- this only actually has it, but the #define
			doesn't match the name of the file
	
h:
	eslp.h		<-- this only actually has it, but the #define
			doesn't match the name of the file

[3/3/94 public]
Fix submitted.

Files affacted are (actually):
eslp.h auditcpp.h esl_filep.h evtp.h dmn_acl_store.h dmn_aud_evtsp.h

[3/14/94 public]
Closed.



CR Number                     : 9746
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 9745
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : Consolidate filesystem path
references to one location
Reported Date                 : 1/14/94
Found in Baseline             : 1.1
Found Date                    : 1/14/94
Severity                      : E
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : see below
Sensitivity                   : public

[1/14/94 public]
There are a variety of hard-coded paths throughout the audit code.
references to these should be changed to #defines which should be moved to
a common header file.

./auditcp/cp_main.c
        ("/opt/dcelocal/var/audit/daemon_bindings", "r")) != NULL) {

./auditd/dmn_main.c
#define AUDITD_BINDING      "/opt/dcelocal/var/audit/daemon_bindings"
#define AUDITD_IDENTITY     "/opt/dcelocal/var/audit/daemon_identity"
char * my_acl_file = "/opt/dcelocal/etc/audit/acl";

./h/pathsp.h
#define EC_DIR "/opt/dcelocal/etc/audit/ec/"
#define UPDATE_BINDINGS_DIR "/opt/dcelocal/etc/audit/update_notify/"
#define AUDITD_IDENTITY "/opt/dcelocal/var/audit/daemon_identity"

./libaudit/esl_file_read.c
        "/opt/dcelocal/var/audit/esl-update-princ",
        "/opt/dcelocal/var/audit/esl-update-foreign-princ",
        "/opt/dcelocal/var/audit/esl-update-group",
        "/opt/dcelocal/var/audit/esl-update-foreign-group",
        "/opt/dcelocal/var/audit/esl-update-cell",
        "/opt/dcelocal/var/audit/esl-update-cell-overridable",
        "/opt/dcelocal/var/audit/esl-update-world",
        "/opt/dcelocal/var/audit/esl-update-world-overridable"
        "/opt/dcelocal/var/audit/esl-princ",
        "/opt/dcelocal/var/audit/esl-foreign-princ",
        "/opt/dcelocal/var/audit/esl-group",
        "/opt/dcelocal/var/audit/esl-foreign-group",
        "/opt/dcelocal/var/audit/esl-cell",
        "/opt/dcelocal/var/audit/esl-cell-overridable",
        "/opt/dcelocal/var/audit/esl-world",
        "/opt/dcelocal/var/audit/esl-world-overridable"

./libaudit/trl_ops.c
         ("/opt/dcelocal/var/audit/daemon_bindings", "r")) != NULL) {

[1/14/94 public]
See RFC34.2, section 2.3 (i) for related information.

[1/24/94 public]
Fix submitted.

[2/18/94 public]
Closed.



CR Number                     : 9745
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : AUDITD_IDENTITY defined in two files
Reported Date                 : 1/14/94
Found in Baseline             : 1.1
Found Date                    : 1/14/94
Severity                      : E
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : 
security/audit/auditd/dmn_main.c, security/h/pathsp.h
Sensitivity                   : public

[1/14/94 public]
The definition AUDITD_IDENTITY is defined in two different files.  This
should be consolidated into one common header.

auditd/dmn_main.c:
#define AUDITD_IDENTITY "/opt/dcelocal/var/audit/daemon_identity"

h/pathsp.h:
#define AUDITD_IDENTITY "/opt/dcelocal/var/audit/daemon_identity"

and is referenced as a hard-coded path in auditcp/cp_main.c:
      ("/opt/dcelocal/var/audit/daemon_bindings", "r")) != NULL) {

and in libaudit/trl_ops.c:
      ("/opt/dcelocal/var/audit/daemon_bindings", "r")) != NULL) {

[1/14/94 public]
See RFC34.2, section 2.3(i) for related information.

[1/24/94 public]
Fix submitted.

[2/18/94 public]
Closed.



CR Number                     : 9744
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : headers installed to wrong location
Reported Date                 : 1/14/94
Found in Baseline             : 1.1
Found Date                    : 1/14/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b2
Affected File(s)              : 
security/audit/auditd/Makefile, security/audit/h/Makefile, security/audit/idl/Makefile
Sensitivity                   : public

[1/14/94 public]
The following header files are installed in <INSTALL>/usr/include/dce:

audit.h
audit_control.h
audit_control.idl
audit_log.h
dceaudmsg.h

Path should be '/share/include/dce'

[1/14/94 public]
Fix submitted.

[2/18/94 public]
Closed.



CR Number                     : 9736
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : aud
Subcomponent Name             : 
Short Description             : auditd terminates when client
calls audit_control_show_state
Reported Date                 : 1/13/94
Found in Baseline             : 1.1
Found Date                    : 1/13/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : auditd/dmn_main.c
Sensitivity                   : public

[1/13/94 public]
Any client control program (including auditcp) that calls
audit_control_show_state causes auditd to terminate. It is unclear at this
point where auditd is failing.

[1/24/94 public]
It was the thread stack problem. The thread stack size was set to 1280(!).
It is changed to 64K.

Fix submitted.

[2/18/94 public]
Closed.



CR Number                     : 9735
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : aud
Subcomponent Name             : auditd/Makefile
Short Description             : brackets need to be changed to
double quotes on the last ifdef line.
Reported Date                 : 1/13/94
Found in Baseline             : 1.1
Found Date                    : 1/13/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b2
Affected File(s)              : 
./security/audit/auditd/Makefile, security/audit/auditcp/Makefile
Sensitivity                   : public

[1/13/94 public]

The brackets need to be changed to quotes on the include line:
an ODE2.3 make-ism.

.if exists(${TARGET_MACHINE}/machdep.mk)
.include <${TARGET_MACHINE}/machdep.mk>
.endif

[1/13/94 public]
Fixed.

[1/14/94 public]
Verified in nightly build of 1/13.



CR Number                     : 9733
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : arguement mismatch for dce_svc_routings
Reported Date                 : 1/13/94
Found in Baseline             : 1.1
Found Date                    : 1/13/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b2
Affected File(s)              : security/audit/auditd/dmn_svc.c
Sensitivity                   : public

[1/13/94 public]
Rich Salz added a new parameter (debug_values) to dce_svc_routing on 1/10.
Need to change function to match this.

[1/13/94 public]
Correction to above comment:  function is dce_svc_routings, not
dce_svc_routing

[1/14/94 public]
Verified in nightly build of 1/13.



CR Number                     : 9732
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : Incorrect insertion of 'audit'
into build order
Reported Date                 : 1/13/94
Found in Baseline             : 1.1
Found Date                    : 1/13/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b2
Affected File(s)              : src/security/Makefile
Sensitivity                   : public

[1/13/94 public]
I incorrectly inserted 'audit' as the first security directory built.  This
was dumb because audit has dependencies on headers and IDLfiles from other
parts of DCE.  Specifically:

	- threads
	- dce
	- security/idl
	- time/common
	- rpc/sys_idl

Since security comes after all of these the fix is confined to
src/security/Makefile.

[1/14/94 public]
Verified in nightly build of 1/13.



CR Number                     : 9726
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : 
Short Description             : Integrate audit into
mainstream build
Reported Date                 : 1/12/94
Found in Baseline             : 1.1b1
Found Date                    : 1/12/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b2
Affected File(s)              : src/Makefile,
src/security/Makefile, src/security/audit/Makefile
Sensitivity                   : public

[1/12/94 public]
Audit needs to be added to the mainstream DCE build process.  This involves
adding it to the appropriate *SUBDIRS lines in the above mentioned
makefile.

[1/12/94 public]
Fix submitted.

[1/13/94 public]
Yup, it's building, all right.



CR Number                     : 9716
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : aud
Subcomponent Name             : auditd
Short Description             : dceaud.cat not built
Reported Date                 : 1/11/94
Found in Baseline             : 1.1b1
Found Date                    : 1/11/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b2
Affected File(s)              : src/security/audit/auditd/Makefile
Sensitivity                   : public

[1/11/94 public]
dceaud.cat is not automatically built.

[1/11/94 public]
Added SAMS* targets and removed previous hardcoded build rules.

*** old version
--- new version
***************
*** 28,33 ****
--- 31,42 ----
  audit_update.idl_IDLFLAGS =  -keep c_source -cepv 
  IDLFLAGS =  -keep c_source 
  
+ # SAMS stuff
+ SAMSFILES = aud.sams
+ SAMIDL_INCLUDES = dceaudmsg.h dceaudmac.h
+ SAMS_TARGETS = dceaudmsg.h dceaudmsg.c dceaudsvc.c dceaudmac.h \
+ 	dceaud.cat
+ 
  IDLFILES = audit_update.idl audit_log.idl audit_control.idl rdaclif.idl
  INCLUDES = dceaudmsg.h 
  EXPDIR = /usr/include/dce/
***************
*** 70,86 ****
  dmn_updt_inform.o: audit_update.idl
  
  ${SVC}: dceaudmsg.h dceaudmac.h dceaudsvc.c dceaudmsg.c
- 
- dceaudmsg.h: aud.sams
- 	${SAMS} -oh ${.ALLSRC}
- dceaudmsg.c: aud.sams
- 	${SAMS} -ot ${.ALLSRC}
- dceaudsvc.c: aud.sams
- 	${SAMS} -os ${.ALLSRC}
- dceaudmac.h: aud.sams
- 	${SAMS} -ou ${.ALLSRC}
- dceaud.msg dceaud.cat: aud.sams
- 	${SAMS} -ocm ${.ALLSRC}
  
  LIBS = -laudit -ldce
  
--- 79,84 ----

[1/14/94 public]
Verified in nightly build of 1/13.



