CR Number                     : 13532
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : sinix
Component Name                : thr
Subcomponent Name             : 
Short Description             : SVR4 keyboard polling problems
Reported Date                 : 5/20/96
Found in Baseline             : 1.1
Found Date                    : 10/4/95
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : threads/SVR4/cma_thread_io.c
Diff supplied by              : user
Diff release                  : 1.1
Sensitivity                   : public

[6/20/96 public]

A customer reported the following:

Full Description:

       In cma__io_available routine fd = 0 is not handled.
       A simple polling in a test program does not work and
       causes a threads crash.
This is a test program that shows the problem:

#include <signal.h>                                                             
#include <poll.h>                                                               
#include <dce/cts_test.h>                                                       

void do_exit();                                                                 
main( argc,  argv, environ)                                                     
int argc; char *argv[]; char **environ;                                         
{                                                                               
     unsigned char c;                                                           
     struct pollfd fds;                                                         
     signal(SIGINT, do_exit);                                                   
     signal(SIGQUIT, do_exit);                                                  
     fds.events = POLLIN;                                                       
     fds.fd = 0;                                                                
     cts_test ("PRVI_WRP_001", "Test Keyboard polling capability-please enter a char and then press return"); 
     poll(&fds,1, -1);                                                          
     if((fds.revents & POLLIN) != POLLIN)                                       
            printf("POLLIN not set\n");                                         
     else                                                                       
     {                          
            read(0, &c, 1);                                                     
            printf(" (character is '%c')\n", c);                                
     }                                                                          
     cts_result ();                                                             
}                                                                               
void do_exit()                                                                  
{                                                                               
   printf("exiting...\n");                                                      
}                                                                               
                                                                                
  
Repeat By:


Proposed Solution:

        After long debugging I found the solution:
        Module: cma__thread_io.c
        routine: cma__io_available
        (line 983 of module, 183 of the subroutine)
                        *  See if any files that the thread is polling          
                        *  are ready.                                           
                        */                                                      
                        i = select_tcb->select.poll_info.nfds;                  
                        poll_e_p = select_tcb->select.poll_info.poll_e_p;       
                        nfound = 0;                                             
                                                                                
                        while ( ( i > 0 ) && ( nfound < result ) )              
                                {                                               
                                cma_t_integer   tmp_fd = poll_e_p->fd;          
                                                                                
                                /*if ( tmp_fd > 0 ) */                          
/*------> This is the correction*/ if ( tmp_fd >= 0 ) /* tk */                     
                                        {                                       
                                        /*



CR Number                     : 13391
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : Redefined libarary and system functions
Short Description             : CMA redefines system and library calls incorrectly
Reported Date                 : 3/15/96
Found in Baseline             : 1.2.1
Found Date                    : 3/15/96
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[3/15/96 public]

Several header files in threads, e.g., threads/HP800/cma_ux.h redefines
the system and library call by using just the name of the call. This
results into string substitution all over the sources where that file
is included.

Example:
	typedef struct xyz {
		int system;
	} xyz_t;

	xyz_t *xyzp;

	int  a = xyzp->system;

        The above line changes to "int  a = xyzp->cma_system" when I have
        included pthread.h. This will fail to compile if pthread is included
	after the header defining this structure is included.

Proposed Solution:
	Change all redefinition to function call syntax, e.g.:
		#define system cma_system 

        changed to
        	#define system(x) cma_system(x)

	This will not however cover the function pointers' substitutions.



CR Number                     : 13223
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8148
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : thr
Subcomponent Name             : 
Short Description             : fcntl(...,F_SETFL,...) fails
Reported Date                 : 12/7/95
Found in Baseline             : 1.1
Found Date                    : 12/7/95
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[12/7/95 public]

During code cleanup ;) in cma_fcntl (HP800/cma_thdio_3.c) 

            if (cma__g_file[fd]->non_blocking) {
#ifdef __hpux
                tmp_arg |= O_NONBLOCK;
#else
# ifdef O_NDELAY
                tmp_arg |= O_NDELAY;
# endif
# ifdef _CMA_FNDELAY_
                tmp_arg |= FNDELAY;
# endif
# ifdef O_NONBLOCK
                tmp_arg |= O_NONBLOCK;
# endif
# ifdef _CMA_FNBLOCK_
                tmp_arg |= FNBLOCK;
# endif
#endif                                  /* __hpux */
                }

became

            if (cma__g_file[fd]->non_blocking) {
                tmp_arg |= O_NONBLOCK;
# ifdef O_NDELAY
                tmp_arg |= O_NDELAY;
# endif
# ifdef _CMA_FNDELAY_
                tmp_arg |= FNDELAY;
# endif
# ifdef O_NONBLOCK
                tmp_arg |= O_NONBLOCK;
# endif
# ifdef _CMA_FNBLOCK_
                tmp_arg |= FNBLOCK;
# endif
                }

so that O_NDELAY and O_NONBLOCK are always set in case of a fcntl F_SETFL
which will always fail as HPUX doesn't allow both flags to be set. The fix
is simply to transcribe the 1.0.3 code more carefully as:

            if (cma__g_file[fd]->non_blocking) {
                tmp_arg |= O_NONBLOCK;
               }

By the way, this problem appears to be fixed in an HP-DCE beta I got in
late August.  It would be really nice if serious problems, even platform
specific ones, were reported in OT especially when the platform in question
is a reference platform for the release in which the problem occurs. Now
you can make it a C3.

[12/8/95 public]

Well, it doesn't necessarily mean HP fixed it in its product. Consider the
possibility of HP not using this part of OSF code and never seeing it. :-)
It was OSF owned CMA and testing dce1.1 reference platforms and apparently
there was no test for fcntl(...,F_SETFL,...). Of course, dce1.2.1 is
another story, but HP-UX is not an official referenece platform, anymore.
:^) Just a personal opinion.

[2/9/96 public]
Lowered as requested.



CR Number                     : 13028
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : cma__ts_func does not initialize cma.
Reported Date                 : 8/7/95
Found in Baseline             : 1.1
Found Date                    : 8/7/95
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : AT386|HP800|RIOS|SVR4/cma_thread_io.h
Sensitivity                   : public

[8/7/95 public]

The cma__ts_func macro that wraps a number of IO functions does not
initialize threads. If any of those calls happen to be the first cma
calls in your program you're in trouble.


#define cma__ts_func(func,fd,arglist,type,post_process)	{ \
    cma_t_integer   __res__; \
    cma_t_boolean   __done__ = cma_c_false; \
    if ((fd < 0) || (fd >= cma__g_mx_file)) return (cma__set_errno (EBADF),
-1); \
    if (!cma__is_open(fd)) return (cma__set_errno (EBADF), -1); \
    cma__fd_reserve (fd); \
    if (!cma__is_open(fd)) return (cma__set_errno (EBADF), -1); \
    if (cma__issue_io_call(fd)) {\
	if ((!cma__g_file[fd]->set_non_blocking) && \
		(cma__g_file[fd]->non_blocking == cma_c_true)) \
	    cma__set_nonblocking(fd); \
...

A possible fix is to add cma__int_init() as the first statement in the
cma__ts_func macro.

[01/24/96]

Here are complete diffs:

> ./threads/AT386/cma_thread_io.h
> Comparing revision 1.1.5.1 with revision 1.1.5.2.
> *** 1.1.5.1     1995/10/02 18:14:48
> --- 1.1.5.2     1995/11/09 21:06:14
> ***************
> *** 468,473 ****
> --- 468,474 ----
>       cma_t_integer   __res__; \
>       cma_t_boolean   __done__ = cma_c_false; \
>       if ((fd < 0) || (fd >= cma__g_mx_file)) return (cma__set_errno (EBADF), -1); \
> +     cma__int_init(); \
>       if (!cma__is_open(fd)) return (cma__set_errno (EBADF), -1); \
>       cma__fd_reserve (fd); \
>       if (!cma__is_open(fd)) return (cma__set_errno (EBADF), -1); \

> ./threads/HP800/cma_thread_io.h
> Comparing revision 1.1.3.1 with revision 1.1.4.1.
> *** 1.1.3.1     1995/10/02 18:14:57
> --- 1.1.4.1     1995/11/09 21:06:52
> ***************
> *** 443,448 ****
> --- 444,450 ----
>       cma_t_integer   __res__; \
>       cma_t_boolean   __done__ = cma_c_false; \
>       if ((fd < 0) || (fd >= cma__g_mx_file)) return (cma__set_errno (EBADF), -1); \
> +     cma__int_init(); \
>       if (!cma__is_open(fd)) return (cma__set_errno (EBADF), -1); \
>       cma__fd_reserve (fd); \
>       if (!cma__is_open(fd)) return (cma__set_errno (EBADF), -1); \

> ./threads/RIOS/cma_thread_io.h
> Comparing revision 1.1.3.1 with revision 1.1.4.1.
> *** 1.1.3.1     1995/09/28 17:02:26
> --- 1.1.4.1     1995/11/09 21:06:54
> ***************
> *** 441,446 ****
> --- 442,448 ----
>       cma_t_integer   __res__; \
>       cma_t_boolean   __done__ = cma_c_false; \
>       if ((fd < 0) || (fd >= cma__g_mx_file)) return (cma__set_errno (EBADF), -1); \
> +     cma__int_init(); \
>       if (!cma__is_open(fd)) return (cma__set_errno (EBADF), -1); \
>       cma__fd_reserve (fd); \
>       if (!cma__is_open(fd)) return (cma__set_errno (EBADF), -1); \

> ./threads/SVR4/cma_thread_io.h
> Comparing revision 1.1.3.1 with revision 1.1.4.1.
> *** 1.1.3.1     1995/10/02 18:15:06
> --- 1.1.4.1     1995/11/09 21:06:55
> ***************
> *** 392,397 ****
> --- 393,399 ----
>       cma_t_boolean   __done__ = cma_c_false;                                  \
>       if ((fd < 0) || (fd >= cma__g_mx_file))                                  \
>                 return (cma__set_errno (EBADF), -1);                           \
> +     cma__int_init(); \
>       if (!cma__is_open(fd)) return (cma__set_errno (EBADF), -1);       \
>       cma__fd_reserve (fd);                                                    \
>       if (!cma__is_open(fd)) return (cma__set_errno (EBADF), -1);       \



CR Number                     : 13014
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : sigaction fails with SIGTTIN & SIGTTOU
Reported Date                 : 8/3/95
Found in Baseline             : 1.1
Found Date                    : 8/3/95
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : cma_signal.c
Sensitivity                   : public

[8/3/95 public]

sigaction() fails with SIGTTIN & SIGTTOU (synchronous signals generated
when a background process attempts to read or write from its control
terminal). In cma__init_signal (cma_signal.c) those signals are incorrectly
added to cma___g_sigact_block_mask, the signal set for disallowed signals
for sigaction. Here is the suggested (but untested) fix:

*** /project/dce/build/dce1.1/src/threads/HP800/cma_signal.c    Thu Jun  9
09:34:39 1994
--- cma_signal.c        Thu Aug  3 12:35:30 1995
***************
*** 859,864 ****
--- 859,868 ----
        cma__bugcheck ("init_signal:17");
      if (sigaddset (&cma___g_sig_wait_mask, SIGPIPE) == -1)
        cma__bugcheck ("init_signal:18");
+     if (sigaddset (&cma___g_sig_wait_mask, SIGTTIN) == -1)
+       cma__bugcheck ("init_signal:35");
+     if (sigaddset (&cma___g_sig_wait_mask, SIGTTOU) == -1)
+       cma__bugcheck ("init_signal:36");
      if (sigaddset (&cma___g_sig_wait_mask, _SIGRESERVE) == -1)
        cma__bugcheck ("init_signal:21");
  
***************
*** 895,904 ****
        cma__bugcheck ("init_signal:33");
      if (sigaddset (&cma___g_sigact_block_mask, SIGCHLD) == -1)
        cma__bugcheck ("init_signal:34");
-     if (sigaddset (&cma___g_sigact_block_mask, SIGTTIN) == -1)
-       cma__bugcheck ("init_signal:35");
-     if (sigaddset (&cma___g_sigact_block_mask, SIGTTOU) == -1)
-       cma__bugcheck ("init_signal:36");
      if (sigaddset (&cma___g_sigact_block_mask, SIGIO) == -1)
        cma__bugcheck ("init_signal:37");
      if (sigaddset (&cma___g_sigact_block_mask, SIGVTALRM) == -1) 
--- 899,904 ----



CR Number                     : 12928
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : thr
Subcomponent Name             : cma_select
Short Description             : cma_select() does not support message queues
Reported Date                 : 6/22/95
Found in Baseline             : 1.1
Found Date                    : 6/22/95
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[6/22/95 public]

Customer reported:

Offering and Version:   all
Component (Module):     src/threads/cma_thdio_4.c:cma_select()
Client Hardware:        RS/6000
Client Software:        AIX

    The AIX version of select() supports message queues (I believe this
    was a AIX enhancement).  From looking at the code, cma_select() does
    not.  I have two questions: 1) Does cma_select() indeed not
    support message queues?  2) If it does not will it ever?



CR Number                     : 12896
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : cma_signal.c
Short Description             : On SVR4 system exception causes core dumps
Reported Date                 : 6/1/95
Found in Baseline             : 1.1
Found Date                    : 6/1/95
Severity                      : B
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : threads/SVR4/cma_signal.c
Sensitivity                   : public

[6/1/95 public]

From customer:

This defect affects only SVR4 ports.

There is a #define _CMA_SYNC_KILL_ in file cma_signal.c. This causes
exceptions to cause directly a core dump and CATCH/TRY not to work.

This is an example Program:

#include <dce/pthread_exc.h>

main()
{
int i;
	TRY
	{
		i = 5/0;	
	}
	
	CATCH (exc_fltdiv_e)
	{
    	printf("Main : caught exception exc_fltdiv_e\n");
	}
	CATCH_ALL
	{
    	printf("Main : Unexpected exception\n");
	}
	ENDTRY
}



CR Number                     : 12887
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : app_gd
Short Description             : per-process thread limit implications
Reported Date                 : 5/25/95
Found in Baseline             : 1.1
Found Date                    : 5/25/95
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[5/25/95 public]
 There is a kernel-defined limit of 64 threads per process, by default.
 This can be modified by the customer via a rebuild of the kernel.
 This is an issue for any piece of multithreaded code running on
HI-OSF/M-1,
 not just DCE programs, but since it may arise in the context of DCE 
 we thought it worthy of mention.
 
 When this limit is hit, a variety of symptoms may ensue, depending very 
 much upon exactly when the program hits this limit.  From our tests,
 it would seem that the cdsclerk is prone to hitting this limit, but
 this probably reflects upon the nature of our tests more than anything
else. 
 (Although certain daemons may be implemented in a manner which, by luck,
 precludes this limit from being hit.) The DCE daemons themselves assume
 the ability to create threads at-will.
 
 When the cdsclerk does hit this limit, it might core dump in which case
name
 service access is resumed with a newly spawned clerk.  
 If it does not core dump, then a period of
 inactivity results in resumption of normal functionality as what were
 active threads gradually become available for reuse.
 
Related-file::Added 950413 by mhadcock:: Fix in Apps. Prog. Gd.
 The following note has been added to the pthreads 
 chapter in Apps. Prog. Gd, under "Creating
 Threads:"
 
   Note: The total number of processes plus threads allowed per 
   user ID is 64 by default. The value of DEFAULT_CHILD_MAX is set 
   in the /sys/conf/param.c file.
 
Related-file::Added 950421 by lconrad:: DCE 1.0 Release Notes
 
        Added the following text to the DCE 1.0 release notes:
 
        Threads Limitation:
  
                The default and maximum number of processes plus
                threads allowed per user ID is 64.  To change this
                value, set the parameter DEFAULT_CHILD_MAX in the
                /sys/conf/param.c file.
Related-file:::: Resolution 
 DESCRIPTION OF BUG FIX:
  Added description of limitation to DCE 1.0 Release Notes
 
 REGRESSION TEST SCENARIO:
  
  
 RCSDIFFS (either inserted manually or via Fci):
  See attachment 3.

[5/17/96 public]

This CR has escaped notice for some time because of some
unusual field values. Its previous "fixby" value was 1.1;
I am temporarily assigning it to myself so I can figure
out whether it's still valid before I do anything else with
it. For what it's worth, there is no mention of a
DEFAULT_CHILD_MAX "parameter" in the current Application
Guide or Release Notes, nor in the old Porting Guide.



CR Number                     : 12751
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : thr
Subcomponent Name             : 
Short Description             : check servers unable to detect late starting rios rservr
Reported Date                 : 11/18/94
Found in Baseline             : 1.1
Found Date                    : 11/18/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : ./test/systest/threads/dcethrpc
Sensitivity                   : public

[11/18/94 public]

Full Description:

the function check_servers does a preliminary check to see if a remote
server is running, and if it finds that it is not, then it enters a delay loop
where it tests for the server either until the server comes up, or the
delay time expires. In te case where the preliminary check does not find
the server active, I have found that in the case of a remote rs6000
machine, the test performed in the loop is not detecting a running server,
and thus always runs to timeout, and consequent error. The problem is that
the name of the process being looked for "thd_server" is truncated in the
output of the "ps -eal" command, and thus the "grep thd_server" never finds it.

$RSH_COMM $HOST "ps -ael | grep thd_server" | grep thd_server 1>/dev/null
2>&1

Note that the flags to the preliminary test are different, and don't result
in truncation.

${RSH_COMM} ${HOST} "ps -ef | grep thd_server" | grep thd_server | grep -v
grep 1>/dev/null 2>&1

Proposed Solution:

remove the -l from the ps flags used by the test in the delay loop.

$RSH_COMM $HOST "ps -ae | grep thd_server" | grep thd_server 1>/dev/null
2>&1



CR Number                     : 12656
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : thr
Subcomponent Name             : pthread_once
Short Description             : filewnr coredumps in threads
Reported Date                 : 10/18/94
Found in Baseline             : 1.1b21
Found Date                    : 10/18/94
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/18/94 public]

After running for many hours, the simple filewnr program used by the
dfs system tests coredumped with:

 0 kill@libc + 0x00000008 (hp-ux export stub)
 1 cma__abort_process@libdce + 0x000000a4 (0x6, 0, 0, 0x7b010ea8)
 2 cma__bugcheck@libdce + 0x0000048c (0x7af84b78, 0x7af84b48, 0x1, 0x46)
 3 cma__open_general@libdce + 0x00001964 (0x1, 0, 0x8, 0x4000a0d8)
 4 cma__init_thread_io@libdce + 0x00000358 (0x80, 0x7af77890, 0x4000a158, 0x2)
 5 cma__init_static@libdce + 0x00000550 (0, 0, 0, 0)
 6 pthread_once@libdce + 0x000000b4 (0x7afbac88, 0x7af63e5a, 0x7b012764, 0x7b01276c)
 7 sec_login_pvt_get_default_cont + 0x00000074 (0x7b03336c, 0x7b00d168, 0x7b00d164, 0x7b00d160)
 8 sec_login_get_current_context@ + 0x00000034 (0x7b033368, 0x7b03336c, 0x7b0331e8, 0x13)
 9 report_whoiam + 0x0000001c (0x40002520, 0x3, 0x400027c8, 0)

It is very possible that the ticket expired but I don't understand why the
coredump - do you? The test had experienced many "connection timed out" errors
by the time this occurred but I don't know of why there would be any correlation.

Also - the test had been running as the dce principal root, NOT the 
machine self principal, so I do not believe this is related to CR 12627.

[10/18/94 public]
The ticket expiring should have nothing to do with the above coredump.
sec_login_get_current_context() and sec_login_pvt_get_default_context() are
basically going to get the credential filename from the KRB5CCNAME environment
variable, then try to read the data from that file.  They do not perform
authenticated RPCs, so expirations should not cause change in behavior.
In fact, at the point where the above died, it's trying to do it's
pthread_once routine that sets up the storage for the default context.
NOTE:  That initialization routine never got called.  The process died in
CMA while trying to set up CMA initialization for a pthread_once call.
I really want to reassign this to threads, but it's too late in the game to
play pingpong with CRs anymore, so I just added JD to the CC list, to see if
he has any ideas on what might cause this (system resources?)...

[10/21/94 public]
Tag, you're it.
I checked the code for the above routines.  sec_login_get_current_context()
does *nothing* but call sec_login_pvt_get_default_context() and it does
nothing before calling pthread_once().  The core dump shows that the process
died in CMA threads initialization code below pthread_once() so the entire
problem listed here is really in threads, not security.  I've reassigned this
to Threads (sorry John, you're the only person I knew to assign it to over
there) and switched the CC list from thr to sec.

[10/21/94 public]
I missed this when you added me to the list. Sorry I could have sommented on
this then and saved you some checking. The reason for the core dump is a 
bugcheck failure. This is the cma equivalent of an assertion failure. In fact
I was planing to convert all of the bugcheck calls to assertions but the
servicability assertion mechanism uses threads. Now for the current problem,
the bugcheck routine should have written out a cma_dump.log file in the
same directory as the core file. That file would contain a one line description
of which check failed. If we see this again please check for the file. Gail
says she may not get a chance run the the failure scenario until mid next week. 
But the only bugcheck failures in cma__open_general are:

 1. The file descriptor was larger than the maximum allowed.
 2. An fstat on the file descriptor failed and the errno was not one of
       EBADF
       EIO
       ETIMEDOUT
       EOPNOTSUPP
       EINVAL
       ENOENT 
    those expected. 
 3. The fstat succeeded but the st_mode&S_IFMT field returned was not one of:
       S_IFCHR
       S_IFBLK
       S_IFDIR
       S_IFREG
       S_IFLNK
       0
       S_IFSOCK 
       S_IFIFO



CR Number                     : 12644
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : threads message changes go in unintegrated
Reported Date                 : 10/17/94
Found in Baseline             : 1.1
Found Date                    : 10/17/94
Severity                      : C
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/17/94 public]
Threads isn't using servicability routing but the need to use a special
cma version of dce_error_inq_text that has been supplied by the servicability
folk. The changes needed to do this need to go in. The risk is low and Susan
has already approved the UHYP status. We always new this needed to go in I 
just overlooked the fact that an ot had not been created.

[10/27/94 public]
The include of dce.h by cma.h caused a small number of problems in other
files so these changes were yanked. These are the diff with the 1.1 code
on the tape to reinsert the code.

+++++++++++++++++++ Makefile ++++++++++++++++++++
9,17d8
< # Revision 1.2.33.3  94/10/21  13:43:01  jd
< # 	build cma_send_error.o.
< # 
< # Revision 1.2.33.2  1994/10/20  21:26:40  jd
< # 	messages
< #
< # Revision 1.2.32.2  94/09/08  9:02:38  jd
< # 	Removed generation and export of dcethdmac.h and dcethdsvc.h
< # 
21c12
< # 
---
> #
114,115d104
< 
< #
135c124
< 	dcethdmsg.o		cma_send_error.o \
---
> 	dcethdmsg.o	\
163,165c152,154
< SAMSFILES       = thd.sams
< SAMIDL_INCLUDES = dcethdmsg.h
< SAMS_TARGETS    = ${SAMIDL_INCLUDES} dcethd.cat  dcethdmsg.c
---
> SAMSFILES		= thd.sams
> SAMSFILES_INCLUDES	= dcethdmsg.h
> SAMS_TARGETS		= dcethdmsg.c
167d155
< 
192,193c180
< 		cma_kernel.h 	cma_defer.h		\
<                 cma_kernel.h    cma_defer.h             dcethdmsg.h     \
---
> 		cma_kernel.h 	cma_defer.h		dcethdmsg.h \
+++++++++++++++++++ cma_init.c ++++++++++++++++++++
14,22d13
<  * Revision 1.1.12.2  94/10/20  17:26:29  jd
<  * 	messages
<  * 
<  * Revision 1.1.11.3  94/09/08  9:01:53  jd
<  * 	Removed include of dcethdmac.h and dcethdsvc.h
<  * 
<  * Revision 1.1.11.2  1994/09/06  21:19:51  jd
<  * 	servicability
<  *
26c17
<  * 
---
>  *
249d239
< 
295,296d284
< #include <dce/dce_msg.h>
< #include <dce/dcethdmsg.h>
298d285
< 
472,473d458
< extern void cma__init_dce_errors(void);
< 
675d659
<     cma__init_dce_errors();
+++++++++++++++++++ exc_handling.c ++++++++++++++++++++
11,19d10
<  * Revision 1.1.8.2  94/10/20  17:26:45  jd
<  * 	messages
<  * 
<  * Revision 1.1.7.3  94/09/08  9:01:58  jd
<  * 	Removed include of dcethdmac.h and dcethdsvc.h
<  * 
<  * Revision 1.1.7.2  1994/09/06  21:20:23  jd
<  * 	servicability
<  *
23c14
<  * 
---
>  *
250,251c241
< 
< 
---
> 
262a253
> # include <cma_message.h>
283,286d273
< #include <dce/dce.h>
< #include <dce/dce_error.h>
< #include <dce/dcethdmsg.h>
< #include <cma_send_error.h>
288d274
< 
951c937,943
< exc_report (EXCEPTION	*exc) 
---
> exc_report
> #ifdef _EXC_PROTO_
> 	(EXCEPTION	*exc) 
> #else
> 	(exc)
> 	EXCEPTION	*exc;
> #endif
952a945,946
> #if _EXC_OS_ == _EXC__VMS
>     unsigned int	msgvec[6], *mvp, old;
953a948,987
> 
>     if (exc->status.ext.sentinel != exc_newexc_c)
> 	old = 1;
>     else
> 	old = 0;
> 
>     /*
>      * If it's an old-format exception structure, or a new one that doesn't
>      * have any argument list, then fake a message vector.
>      */
>     if (old || exc->status.ext.args == (unsigned int *)0) {
> 
> 	if (exc->kind == exc_kind_status_c) {
> 	    msgvec[0] = 1;
> 	    msgvec[1] = exc->status.status;
> 	    msgvec[2] = 0;
> 	    msgvec[3] = 0;
> 	    msgvec[4] = 0;
> 	    msgvec[5] = 0;
> 	    mvp = &msgvec[0];
> 	    }
> 	else {
> 	    msgvec[0] = 3;
> 	    msgvec[1] = exc_s_exception;
> 	    msgvec[2] = 1;
> 	    msgvec[3] = (int)exc->address.address;
> 	    mvp = &msgvec[0];
> 	    }
> 
> 	}
>     else
> 	mvp = exc->status.ext.args;
>     
>     sys$putmsg (mvp, 0, 0, 0);
>     }
> #else
> #if (_CMA_UNIX_TYPE != _CMA__SVR4 )
>     (void)fflush (stdout);		/* Flush output stream, first */
> #endif
> 
954a989,996
> # if _EXC_VENDOR_ == _EXC__APOLLO
>         status_$t st;
>         static char *msg = "Exception: ";
>         st.all = exc->status.status;
>         error_$print_name(st, msg, strlen(msg));
> # else
> 	unsigned char	buffer[256], *stuff;
> 	int		status, arg = 0, len;
955a998,1001
> 
> 	cma__int_sprintf ((char *)buffer, "Exception: ");
> 	stuff = &buffer[0] + cma__strlen ((char *)buffer);
> 
962,967c1008,1031
<             cma_send_errno(exc->status.status);
<         }
<         else {
<             cma_send_error(exc->status.status);
<         }
<     }
---
> 
> 	    if (exc->status.status < sys_nerr) {
> 		cma__int_sprintf (
> 			(char *)stuff,
> 			"%s",
> 			sys_errlist[exc->status.status]);
> 		status = 0;
> 		}
> 	    else {
> 		cma__error_inq_text (exc_s_unkstatus, stuff, &status);
> 		arg = exc->status.status;
> 		}
> 
> 	    }
> 	else {
> 	    cma__error_inq_text (exc->status.status, stuff, &status);
> 	    }
> 
> 	len = cma__strlen ((char *)buffer);
> 	buffer[len] = '\n';
> 	buffer[len+1] = (char)0;
> 	cma__int_fprintf (stderr, (char *)buffer, arg, 0);
> # endif
> 	}
969c1033,1051
<       cma_send_exception((unsigned long)exc->address.address);
---
> 	unsigned char	buffer[256], *stuff;
> 	int		status, len;
> 
> 
> 	cma__int_sprintf ((char *)buffer, "Exception: ");
> 	stuff = &buffer[0] + cma__strlen ((char *)buffer);
> 	cma__error_inq_text (exc_s_exception, stuff, &status);
> 
> 	len = cma__strlen ((char *)buffer);
> 	buffer[len] = '\n';
> 	buffer[len+1] = (char)0;
> 	cma__int_fprintf (
> 		stderr,
> 		(char *)buffer,
> 		exc->address.address,
> 		0);
> 
> 	}
> 
971,972c1053,1101
< }
<         
---
> #endif
> 
> #if _EXC_OS_ == _EXC__VMS
> /*
>  *  FUNCTIONAL DESCRIPTION:
>  *
>  *	This function is used on VMS systems to copy a condition signal
>  *	vector (or message vector) from one place to another. It copies
>  *	arguments that may be stack addresses as 0, and pre-pends the
>  *	exc_s_exccop condition if it's not already there.
>  *
>  *  FORMAL PARAMETERS:
>  *
>  *	sigvec		Address of signal vector
>  *	ctxvec		Address of output vector
>  *	ctxlen		Size (in ints) of output vector
>  *
>  *  IMPLICIT INPUTS:
>  *
>  *	none
>  *
>  *  IMPLICIT OUTPUTS:
>  *
>  *	none
>  *
>  *  FUNCTION VALUE:
>  *
>  *	none
>  *
>  *  SIDE EFFECTS:
>  *
>  *	none
>  */
> static void
> exc___copy_args
> #ifdef _EXC_PROTO_
> 	(unsigned int	*sigarg,
> 	unsigned int	*ctxarg,
> 	exc_int_t	ctxlen)
> #else
> 	(sigarg, ctxarg, ctxlen)
> 	unsigned int	*sigarg;
> 	unsigned int	*ctxarg;
> 	exc_int_t	ctxlen;
> #endif
>     {
>     exc_int_t		count, facility, lost;
>     unsigned int	condition;
>     exc_int_t		in, out, size, lasthdw;
974,975d1102
<         
< 	    
976a1104,1293
>     if (sigarg[0] >= ctxlen)
> 	count = ctxlen - 1;
>     else
> 	count = sigarg[0] - 2;
> 
>     lost = 0;				/* So far, no data lost */
>     lasthdw = 0;			/* So far, no hardware exceptions */
>     size = ctxlen - 3;			/* Actual size minus count, pc, ps */
>     in = 1;
>     facility = sigarg[1] & STS$M_FAC_NO;	/* Get unshifted facility */
> 
>     /*
>      * If the signal vector already starts with a DECthreads facility
>      * message, copy it as is (this includes foreign messages that have
>      * already been prefixed by "exception copied" or "exception copied with
>      * lost data" codes). Otherwise, add the prefix.
>      */
>     if (facility == (exc_facility_c & STS$M_FAC_NO))
> 	out = 1;
>     else {
> 	out = 3;
> 	ctxarg[1] = exc_s_exccop;
> 	ctxarg[2] = 0;
> 	count += 2;			/* We added two fields */
> 	size -= 2;
> 	}
> 
>     ctxarg[0] = count;
> 
>     while (out <= count) {
> 	exc_int_t	argcnt, argzero;
> 
> 
> 	condition = sigarg[in];
> 	facility = FACID (condition);
> 	
> 	if (facility == 0) {
> 	    exc_int_t	i, msgid;
> 
> 
> 	    switch (condition) {
> 		case SS$_FLTOVF_F : {
> 		    condition = SS$_FLTOVF;
> 		    break;
> 		    }
> 		case SS$_FLTDIV_F : {
> 		    condition = SS$_FLTDIV;
> 		    break;
> 		    }
> 		case SS$_FLTUND_F : {
> 		    condition = SS$_FLTUND;
> 		    break;
> 		    }
> 		default : {
> 		    break;
> 		    }
> 
> 		}
> 
> 	    msgid = MSGID (condition);
> 	    argcnt = 0;
> 	    argzero = 0;
> 	    lasthdw = 0;
> 
> 	    for (i = 0; i < exc___c_hwexcs; i++) {
> 
> 		if (msgid == exc___g_sysargs[i].msgid) {
>     		    argcnt = exc___g_sysargs[i].argcnt;
> 		    lasthdw = 1;	/* It's a hardware exception! */
> 		    break;
> 		    }
> 
> 		}
> 		    
> 	    }
> 	else if (facility == 1) {
> 	    argcnt = 1;
> 	    argzero = 0;
> 	    lasthdw = 0;
> 	    }
> 	else if (facility == (exc_facility_c >> 16)) {
> 	    argcnt = sigarg[in+1] + 1;	/* Copy count and any args */
> 	    argzero = 0;		/* Assume our stuff is copyable! */
> 	    lasthdw = 0;
> 	    }
> 	else {
> 	    argcnt = 1;			/* Copy count */
> 	    argzero = sigarg[in+1];
> 	    lost = 1;			/* Set the "lost" flag */
> 	    lasthdw = 0;
> 	    }
> 
> 	/*
> 	 * If there's enough room, copy the condition into the output vector.
> 	 * If there's not enough room for the whole thing, don't copy any of
> 	 * it, since $putmsg might freak out.
> 	 */
> 	if (size >= argcnt + argzero + 1) {
> 	    size -= (argcnt + argzero + 1);
> 	    ctxarg[out++] = condition;	/* Copy it */
> 	    in++;
> 
> 	    /*
> 	     * If we need to copy arguments, do so
> 	     */
> 	    while (argcnt > 0) {
> 		ctxarg[out++] = sigarg[in++];
> 		argcnt--;
> 		}
> 
> 	    /*
> 	     * We need to zero any user condition arguments: that's a shame,
> 	     * but they might be stack addresses that would do something
> 	     * weird when we try to print the message later.
> 	     */
> 	    while (argzero > 0) {
> 		ctxarg[out++] = 0;
> 		in++;
> 		argzero--;
> 		}
> 
> 	    }
> 	else {
> 	    lost = 1;
> 	    break;
> 	    }
> 	
> 	}
> 
>     /*
>      * If the last condition was a hardware type, and we already copied the
>      * PC and PS to the two slots we reserved for them (which would take us
>      * beyond the expected count, since we'd dropped the PC/PSL), then add
>      * them to the count. Otherwise, copy two zeros, so something will be
>      * there just in case a user condition code does something odd.
>      */
>     if (lasthdw && out > (count + 1))
> 	ctxarg[0] += 2;			/* Admit to the extra stuff in count */
>     else {
> 	ctxarg[out++] = 0;
> 	ctxarg[out++] = 0;
> 	}
> 
>     /*
>      * If we lost any information, then change the primary condition code
>      * from exc_s_exccop to exc_s_exccoplos so the user will know.
>      */
>     if (lost && ctxarg[1] == exc_s_exccop)
> 	ctxarg[1] = exc_s_exccoplos;
> 
>     }
> #endif
> /*  DEC/CMS REPLACEMENT HISTORY, Element EXC_HANDLING.C */
> /*  *36   20-APR-1992 07:29:06 BUTENHOF "Remove exception interest" */
> /*  *35   17-APR-1992 11:12:16 BUTENHOF "Improve TRY/CATCH performance" */
> /*  *34   31-MAR-1992 15:12:18 BUTENHOF "Fix VMS exception interest" */
> /*  *33   31-MAR-1992 13:31:33 BUTENHOF "Implement exception 'interest' model" */
> /*  *32   10-FEB-1992 08:51:01 BUTENHOF "Drop depth modifications on VMS" */
> /*  *31    7-FEB-1992 10:31:09 BUTENHOF "Clean up VAX VMS resignal" */
> /*  *30    6-FEB-1992 10:24:50 CURTIN "Added individual ifndef's for Alpha hardware exc's" */
> /*  *29   22-JAN-1992 17:40:10 CURTIN "added a few casts" */
> /*  *28    9-JAN-1992 10:27:38 BUTENHOF "Move ""Exception:"" text from message catalog" */
> /*  *27   23-DEC-1991 14:06:04 CURTIN " remove include of starlet.h on vax" */
> /*  *26   20-DEC-1991 07:30:01 BUTENHOF "Alpha exception work" */
> /*  *25   18-DEC-1991 06:45:44 BUTENHOF "Remove exc_reraise function" */
> /*  *24   16-DEC-1991 12:55:26 BUTENHOF "Update previous exception changes" */
> /*  *23   13-DEC-1991 09:54:05 BUTENHOF "Clear message args on putmsg" */
> /*  *22   27-NOV-1991 11:03:46 BUTENHOF "Fix for DEC C" */
> /*  *21   26-NOV-1991 11:19:12 BUTENHOF "More Alpha changes" */
> /*  *20   25-NOV-1991 14:00:15 BUTENHOF "Make cma_message.h conditional" */
> /*  *19   22-NOV-1991 11:57:45 BUTENHOF "Integrate dce message formatting" */
> /*  *18   18-NOV-1991 10:24:29 BUTENHOF "Fix test for ""resignal""" */
> /*  *17    6-NOV-1991 09:06:55 BUTENHOF "Fix config macro use" */
> /*  *16   31-OCT-1991 12:40:27 BUTENHOF "Unwind to called frame if depth != 0" */
> /*  *15   24-SEP-1991 16:30:13 BUTENHOF "Merge CMA5 reverse IBM/HP/Apollo drops" */
> /*  *14   21-AUG-1991 16:46:33 CURTIN "Removed VMS include of stdio.h" */
> /*  *13    6-AUG-1991 17:03:47 CURTIN "fix nested TRYs" */
> /*  *12   31-JUL-1991 18:40:13 BUTENHOF "Improve VMS condition integration" */
> /*  *11   26-JUL-1991 15:56:57 CURTIN "Use internal routines instead of setjmp/longjmp" */
> /*  *10    2-JUL-1991 16:47:29 BUTENHOF "Make exc_report flush stdout" */
> /*  *9    13-JUN-1991 18:03:10 CURTIN "Converted to use Unix messages on Unix platforms" */
> /*  *8    10-JUN-1991 18:25:36 SCALES "Add sccs headers for Ultrix" */
> /*  *7     2-MAY-1991 14:00:08 BUTENHOF "Utilize _longjmp where appropriate" */
> /*  *6    15-APR-1991 15:54:40 CURTIN "clean up previous addition" */
> /*  *5     8-APR-1991 20:32:26 CURTIN "changed cma__abort to cma__process_abort" */
> /*  *4     1-APR-1991 18:10:08 BUTENHOF "QAR 93, exception text" */
> /*  *3    24-JAN-1991 00:35:30 BUTENHOF "Fix exception name references" */
> /*  *2    28-DEC-1990 00:04:49 BUTENHOF "Change exception names" */
> /*  *1    12-DEC-1990 21:56:12 BUTENHOF "Exception support" */
> /*  DEC/CMS REPLACEMENT HISTORY, Element EXC_HANDLING.C */
+++++++++++++++++++ cma.h ++++++++++++++++++++
14,19d13
<  * Revision 1.1.11.3  94/10/21  13:43:15  jd
<  * 	noop
<  * 
<  * Revision 1.1.11.2  1994/10/20  21:26:45  jd
<  * 	messages
<  *
23c17
<  * 
---
>  *
131d124
< 
148,150d140
< #include <dce/dce.h>
< #include <dce/dce_msg.h>
< #include <dce/dcethdmsg.h>
+++++++++++++++++++ cma_send_error.c ++++++++++++++++++++
+++++++++++++++++++ exc_handling.h ++++++++++++++++++++
14,19d13
<  * Revision 1.2.23.2  94/10/20  17:26:49  jd
<  * 	messages
<  * 
<  * Revision 1.2.22.2  94/09/06  17:10:33  jd
<  * 	servicability
<  * 
174,175d167
< 
< 
672d663
< #ifdef DONT_DEFINE
682a674,707
> #if _EXC_OS_ == _EXC__VMS
> /*
>  * A few of these codes are somewhat imaginary, since VMS doesn't support
>  * condition codes that very closely approximate the sense of some UNIX
>  * signals.  SIGTRAP, SIGIOT, and SIGEMT have no clear parallels, and the
>  * values chosen are fairly arbitrary.  For two others, we chose what seemed
>  * close equivalents: SIGPIPE becomes "no mailbox", and SIGXFSZ becomes "disk
>  * quota exceeded".
>  */
> # define exc_s_illaddr		12	/* ss$_accvio */
> # define exc_s_exquota		28	/* ss$_exquota */
> # define exc_s_insfmem		292	/* ss$_insfmem */
> # define exc_s_nopriv		36	/* ss$_nopriv */
> # define exc_s_normal		1	/* ss$_normal */
> # define exc_s_illinstr		1084	/* ss$_opcdec */
> # define exc_s_resaddr		1100	/* ss$_radrmod */
> # define exc_s_privinst		1084	/* ss$_opcdec */
> # define exc_s_resoper		1108	/* ss$_roprand */
> # define exc_s_SIGTRAP		1044	/* ss$_break */
> # define exc_s_SIGIOT		44	/* ss$_abort */
> # define exc_s_SIGEMT		1068	/* ss$_compat */
> # define exc_s_aritherr		1164	/* ss$_fltovf */
> # define exc_s_SIGSYS		20	/* ss$_badparam */
> # define exc_s_SIGPIPE		628	/* ss$_nombx */
> # define exc_s_excpu		8364	/* ss$_excputim */
> # define exc_s_exfilsiz		1004	/* ss$_exdiskquota */
> # define exc_s_intovf		1148	/* ss$_intovf */
> # define exc_s_intdiv		1156	/* ss$_intdiv */
> # define exc_s_fltovf		1164	/* ss$_fltovf */
> # define exc_s_fltdiv		1172	/* ss$_fltdiv */
> # define exc_s_fltund		1180	/* ss$_fltund */
> # define exc_s_decovf		1188	/* ss$_decovf */
> # define exc_s_subrng		1196	/* ss$_subrng */
> #else
725a751
> #endif
760d785
< #endif /* DONT_DEFINE */

New files

cma_send_error.c


/*
 * @OSF_COPYRIGHT@
 * 
 */
/*
 * HISTORY
 * $Log:	c012644,v $
# Revision 1.3  96/06/25  10:27:59  root
# changed fields: Status  
# 
# Revision 1.2  94/10/27  15:15:15  root
# changed fields: Short Description  Priority  Status  Fix By Baseline   new/changed/deleted note(s) [jd 10/27/94 public]
# 
 * Revision 1.1.2.2  94/10/20  17:26:33  jd
 * 	messages
 * 
 * Revision 1.1.1.3  94/09/08  9:01:56  jd
 * 	Removed include of dcethdmac.h and dcethdsvc.h
 * 
 * Revision 1.1.1.2  1994/09/07  21:14:10  jd
 * 	servicability
 *
 * Revision 1.1.1.2  94/09/06  17:09:57  jd
 * 	servicability
 * 
 * $EndLog$
 */


#include <dce/cma.h>
#include <dce/rpc.h>
#include <dce/dce_error.h>
#include <dce/dcethdmsg.h>
#include <stdio.h>
#include <cma_signal.h>
#include <cma_send_error.h>

#define ERROR_STRING_EXTRA 256 /* Room for line number, filename etc... */
unsigned char cma_dce_fatal_string[dce_c_error_string_len+ERROR_STRING_EXTRA];
unsigned char cma_dce_error_string[dce_c_error_string_len+ERROR_STRING_EXTRA];
unsigned char cma_dce_empty_string[dce_c_error_string_len+ERROR_STRING_EXTRA];
unsigned char cma_dce_error_buffer[dce_c_error_string_len+ERROR_STRING_EXTRA];

char cma_error_output_buffer[dce_c_error_string_len + ERROR_STRING_EXTRA];

void
cma__init_dce_errors(void)
{
  int st;
  int emptylen;

  dce_cma_error_inq_text(
            thd_empty_error_string,cma_dce_empty_string,&st);
  emptylen = strlen((char *)cma_dce_empty_string);
  dce_cma_error_inq_text(
            thd_fatal_error_string,cma_dce_fatal_string,&st);
  cma_dce_fatal_string
        [strlen((char *)cma_dce_fatal_string) - emptylen] = '\0';
  sprintf((char *)cma_dce_fatal_string,"%s %d",cma_dce_fatal_string,getpid());
  dce_cma_error_inq_text(
            thd_error_string,cma_dce_error_string,&st);
  cma_dce_error_string
        [strlen((char *)cma_dce_error_string) - emptylen] = '\0';
  sprintf((char *)cma_dce_error_string,"%s %d",cma_dce_error_string,getpid());
}

void
cma_send_fatal(unsigned long status)
{
  int st;
 
  printf("%s\n",cma_dce_fatal_string); 
  dce_cma_error_inq_text(status,cma_dce_error_buffer,&st);
  if(st == 0)
    {
      printf("%s\n",cma_dce_error_buffer);
    }
  else
    {
      printf("Unknown status %d\n",status);
    }
  fflush(stdout);
  cma__abort_process (SIGIOT);        /* Abort with core dump */
}

void
cma_send_error(unsigned long status)
{
  int st;

  printf("%s\n",cma_dce_error_string); 
  dce_cma_error_inq_text(status,cma_dce_error_buffer,&st);
  if(st == 0)
    {
      printf("%s\n",cma_dce_error_buffer);
    }
  else
    {
      printf("Unknown status %d",status);
    }
  fflush(stdout);
}

void
cma_send_exception(unsigned long address)
{
  int st;

  printf("%s\n",cma_dce_fatal_string);
  dce_cma_error_inq_text(exc_s_exception,cma_dce_error_buffer,&st);
  if(st == 0)
    {
      printf("%s\n",cma_dce_error_buffer);
    }
  else
    {
      printf("An address exception has occurred\n");
    }

  fflush(stdout);
}

void
cma_send_errno(unsigned long errno)
{
  int st;
  dce_cma_error_inq_text(thd_s_errno_raised,cma_dce_error_buffer,&st);
  sprintf(cma_error_output_buffer,"%s %d\n", cma_dce_error_buffer,errno);
  printf("%s\n",cma_error_output_buffer);
  fflush(stdout);
}


cma_send_error.h


/*
 * @OSF_COPYRIGHT@
 * 
 */
/*
 * HISTORY
 * $Log:	c012644,v $
# Revision 1.3  96/06/25  10:27:59  root
# changed fields: Status  
# 
# Revision 1.2  94/10/27  15:15:15  root
# changed fields: Short Description  Priority  Status  Fix By Baseline   new/changed/deleted note(s) [jd 10/27/94 public]
# 
 * Revision 1.1.2.2  94/10/20  17:26:37  jd
 * 	messages
 * 
 * Revision 1.1.1.2  94/09/06  17:10:05  jd
 * 	servicability
 * 
 * 
 * $EndLog$
 */

extern void cma__init_dce_errors(void);
extern void cma_send_fatal(unsigned long);
extern void cma_send_error(unsigned long);
extern void cma_send_errno(unsigned long);
extern void cma_send_exception(unsigned long);



CR Number                     : 12201
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : Problematic handling of SIGXFSZ by exception code
Reported Date                 : 9/15/94
Found in Baseline             : 1.0.3
Found Date                    : 9/15/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/15/94 public]

        CMA maps the signal SIGXFSZ to an exception and prints out a
        report on stderr. However if stderr also points to the file
        on which a write caused the SIGXFSZ signal ( file size limit
        exceeded ) it can loop endlessly by regenerating the same
        signal - because exceptions are implemented using longjmp(3C)
        SIGXFSZ is no longer blocked at the time the exception report
        is written on to stderr.

Proposed Solution:
        Change src/threads/exc_handling.c:exc_raise() to not
        write an exception report before aborting if the
        exception has the status exc_s_exfilsiz.
        src/threads/exc_handling.c diff that implements this
        is below.

*** /dce/dce1/sni103/src/threads/exc_handling.c Mon Mar 28 10:58:58 1994
--- ./exc_handling.c    Fri Sep  9 16:01:52 1994
***************
*** 566,572 ****
--- 566,587 ----
      ctx = (exc_context_t *)exc___ctx_stack_top;

      if (ctx == (exc_context_t *)0) {
+ #ifdef _FTX
+       /* If the current exception is generated by SIGXFSZ and
+        * we dont have an exception handler we dont want to
+        * generate an exception report here. If we do, we may
+        * generate SIGXFSZ ad inf.
+        */
+       {
+        cma_t_integer excst = -1;
+
+        exc_get_status(exc,(&excst));
+        if ( excst == -1 || excst != exc_s_exfilsiz )
+         exc_report (exc);
+       }
+ #else
        exc_report (exc);
+ #endif
        cma__abort_process (SIGIOT);
          }

 Another possible solution to the problem would be to block SIGXFSZ
 before generating an exception report and aborting. This would be
 better, as an exception report is written to stderr in the normal
 case, as before.



CR Number                     : 12058
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 11626
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : AT386/cma_stdio.c
Short Description             : krb5_read_password uses
unwrapped stdio call (fgets)
Reported Date                 : 9/6/94
Found in Baseline             : 1.1b16
Found Date                    : 9/6/94
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : read_pwd.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/6/94 public]

krb5_read_password uses fgets to read the password.  fgets is not
wrapped in the reference implementations.
The solution is to subsitute it with a read loop that reads one
character at a time up until it gets a newline.

Priority has been set to 1, since this dcecp si relying on this
function. See CR 11626.

[9/19/94 public]

You can't substitute a "read()" loop for an "fgets()" since
read operates on a file descriptor index, while fgets operates on a FILE
type, which does some extra buffering.  Mixing the two would result in
the read() call ignoring characters in the FILE buffer, and the next
*get*() call picking up the previously ignored characters.

The HP reference implementation of fgets is wrapped: it ends up calling
the HP C library, which is re-entrant.

The AT386 reference implementation is (according to the defect report) not
wrapped.  It needs to be wrapped in such a way that fgets results in a
thread-safe call that can mix with other wrapped calls.  This may require
a platform-specific implementation of fgets that calls read while maintaining
the consistency of the FILE structure.

Transferring this to thr: we should not be creating standard thread-safe
functions in components, since that is the job of the threads component.

[9/19/94 public]

I checked the HP executable of dcecp.  Let it sit in the password
read.  Once in sleep state, killed with QUIT.
Took stack from the core.  Here it is.

 0 _read@libc + 0x00000008 (hp-ux export stub)
 1 __filbuf@libc + 0x00000108 (0, 0, 0xa, 0x7b033190)
 2 fgets@libc + 0x00000084 (0x7aff87e0, 0x40040f30, 0, 0)
 3 TMEM@libdce + 0x000f81bc (0x7b033fd4, 0x200, 0x40002368, 0x40002664)
 4 TMEM@libdce + 0x004ed1bc (0x40004668, 0, 0x7b033fd4, 0x7b0341f0)
 5 dcp_login (clientData =   00000000, interp = 0x400be678, argc = 2, argv
= 0x7
b033f60)    [/project/dce/build/dce1.1-snap/src/admin/dcecp/commands.c:
3036]
 6 Tcl_Eval + 0x000009f0 (0x400be678, 0x7b0331e0, 0x7b033d98, 0x1)
 7 Tcl_RecordAndEval + 0x0000026c (0x400be678, 0x7b0331e0, 0, 0x1)
 8 main (argc = 1, argv = 0x7b0331a8)
[in/dcecp/main.c: 487]

What this seem to say is that the HP version is stuck in the read system
call.  This would indicate that the HP version of dcecp is not wrapped at
all.  If it were wrapped, shouldn't it block on the cma select ?

[9/20/94 public]
The fgets call on the AT386 is wrapped, the wrapper is in AT386/cma_stdio.h.
Fgets dives into the c-library for the actual read. The wrapper takes the
global lock to prevent another thread from getting into the library and 
mucking with the the file descriptor data structures in in the case where the 
first thread gets preempted before is gets to the read. 
What I believe is happening on the pc is that a wrapped read is doen on the
file descriptor first. This sets the file descriptor to non-blocking. The
fgets call comes along after that and of course finds the file descriptor
non=blocking so it doesn;t block. If this is true why isn't the hp behaving
in the same way. 

I'd like to spend a bit of time on this but it won't be by 10/6. Tha being
the case anything we do to it will be in the unintegrated tree. I'm going
to lower the priority to reflect this.

What I believe is happening on the 386 is that a wrapped read is called setting
the file descriptor to non-blocking. Fgets is then called. Even though the 
fgets results in a an unwrapped read in the c library it is non-blocking
because the read wrapper set the file descriptor to non-blocking. What puzzles
me is why is the hp behaving differently.



CR Number                     : 11626
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : 
Short Description             : Threads sets stdin to nonblocking and doesn't reset it (was "Interactive read of the password failed")
Reported Date                 : 8/9/94
Found in Baseline             : 1.1b12
Found Date                    : 8/9/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/9/94 public]
With last night's (8/8) build, on a 486:
    dcecp> login cell_admin
    Enter Password: 
    Error: Interactive read of the password failed
    dcecp> 

It does not wait at the "Enter Password", but immediately gives the error.
Works fine on HP.  I tried 2 different 486s, just to be sure it wasn't
the machine itself.

[8/9/94 public]
Could this be related to the editread changes Tom put in the other day?

[8/9/94 public]
It definitely looks suspect. krb5_read_password() hasn't changed in a very
long time. dcp_login() hasn't either. I'll go talk to Tom.

[8/9/94 public]
Very suspect. Removing the include from editline.c and rebuilding
libdceutils.a fixes the problem.

[8/18/94 public]
It's a threads issue (I won't say bug yet). CMA sets stdin to non-blocking
now that we are using the wrapped read() call in editline. This messes
up krb5_read_password() when it tries to read from stdin later. I tried
setting stdin back to blocking before krb5_read_password(), and it fixed the
486 and broke the HP. Reassigning to threads so the "right" thing can
happen.

[08/23/94 public]
There is a work-around.  Compile editline without pthread.h.  Change the
call to read() so that it calls threadsafe_read, which looks something
like this.  The second if test might be system-specific.
	size_t
	threadsafe_read(int fd, char *buffer, size_t size)
	{
	    size_t r;

	    for ( ; ; ) {
		r = read(fd, buffer, size);
		if (r > 0)
		    break;
		if (r == (size_t)-1 && errno == EAGAIN))
		    pthread_yield();
	    }
	    return r;
	}
Also change sysunix.c so that it has these lines:
	new.c_cc[VMIN] = 0;
	new.c_cc[VTIME] = 3;

[9/1/94 public]

Well, the change I'm about to submit for CR 10278 adds a new
dependency on pthread.h in editline.c.

[9/6/94 public]

dcecp uses the kerberos utility function krb5_read_password.  This
in turn, uses fgets, which is not wrapped. If any wrapped read
has been made on STDIN, the file descriptor will be set in non-blocking
mode (as it should) and the unaware fgets will return immediately.

The inclusion of pthread.h in editline.c probably caused dcecp to
switch from unwrapped to wrapped reads on STDIN, causing the above
issue.

I don't know why the problem does not show on the hp.
In any case due to the inclusion of pthread.h in read_pwd.c file
(via krb5.h), one assumes krb5_read_password should work in wrapped
mode and avoid unwrapped stdio calls.  I am going to open an OT
against krb5_read_password.

Finally notice that using fcntl within dcecp will fetch the wrapped
fcntl which will not set the file descriptor to blocking even if you
try to. It will only set the appropriate cma user flags for the file
descriptor, which are going to be relevant for wrapped calls only.

[9/6/94 public]

Filed CR 12058 against krb5_read_password.  I'll leave this open for
fix verification.

[9/20/94 public]
I'd still like to look at this but it's not as high a priority as other
things on my plate. It won't get done by 10/6. I will revisit it after the
10/6 main line freeze. Anything we do with it then will go into the 
unintegrated tree. Lowering the priority to reflect this.

[9/20/94 public]

I am going to summarize the history of the bug here, as well as spell out
the fact that the best option for the dcecp folks is probably to copy the
krb5_read_passwd in a file of their own, gut the fgets out and put in a
read loop.  Why this is not going to be done inside krb5_read_passwd is
part of how things unwrapped (so to speak).  Also if they put in the read
loop they do not need to call pthread_yield, since the read will in fact be
a cma_read.

This CR was filed because the passwd reading in dcecp would get bumped out
without reading anything. This started after Tom included <pthread.h> in
editline.c .  The effect was seen only on the 486, not on the HP.  Tom's
changes were due to the fact that within dtscp blocking reads in editline.c
where messing up the rpc runtime.

The main effect of including pthread.h would be to turn the reads in
editline.c into cma_read.  cma_read sets the file descriptor to
non-blocking, which is fine as long as it is accessed via cma calls
(wrapped calls).

But dcecp calls krb5_read_password which uses fgets.  Now the reference
implementation of cma stdio is primitive at best.  It does some locking but
calls the native libc stdio.  This in turn uses the system read.

The difference between what happens on the 486 and the HP is that on the
486 the system read finds the file descriptor in non-blocking mode and
returns before the user has input the passwd, whereas on HP the system
read, for not yet understood reasons blocks (but blocks the whole process,
not only the thread).

Although the discrepancy is a threads issue, neither behaviour is correct.
The real solution would be a real cma stdio library, with a cma_fgets
calling cma_read.  But this is not available, and in many places within
dce, work-arounds have been implemented, that avoid the use of stdio.

So I thought such a workaround could be put directly in the
krb5_read_password function.  And filed CR 12058.  I had some exchange with
the people at HP. They feel strongly against putting in such a workaround,
mostly because are wary of mixing reads with stdio, due to stdio buffering.
Although I think I have enough reasons to argue for the validity of the
read workaround, the HP folks decided that in fact did not want to put in a
workaround for a problem due to lack of real cma stdio.

Thus CR 12058 was turned from sec to threads.  Of course, a full cma stdio
is not going to be implemented any time soon.  So the only issue threads
can pick up is the different behaviour between the HP and the 486 platform
with respect to unwrapped reads.  Even fixing this so that the unwrapped
read behaves on the 486 as on the HP, the krb5 function as is (with the
fgets) may not be good for dcecp if its blocking can cause the same
problems blocking caused in dtscp.



CR Number                     : 11371
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : Makefile
Short Description             : install threads functional test and script to the install area
Reported Date                 : 7/20/94
Found in Baseline             : 1.1
Found Date                    : 7/20/94
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[7/20/94 public]

install runtest script and all the functional tests for threads.

Add the following two lines to Makefile:

	SCRIPT		= runtest
	ILIST		= ${PROGRAMS} ${SCRIPT}



CR Number                     : 11172
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : thr
Subcomponent Name             : 
Short Description             : assertion failure:  cma__queue_empty: Q corruption
Reported Date                 : 7/5/94
Found in Baseline             : 1.1
Found Date                    : 7/5/94
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/5/94 public]

Running DCE 1.1 available 6/28, including the 1.0.3a DFS that
it contains, the bosserver's log contained the following:

%Internal DCE Threads problem (version CMA BL10+), terminating execution.
% Reason: assertion failure:  cma__queue_empty: Q corruption
	at line 428 in /project/dce/build/dce1.1-snap/src/threads/cma_timer.c
% See 'cma_dump.log' for state information.
	**** Assertion failure. cma__queue_empty: Q corruption
     at line 428 in /project/dce/build/dce1.1-snap/src/threads/cma_timer.c
%Internal DCE Threads problem (version CMA BL10+), terminating execution.
% Reason: assertion failure:  cma__Queue_next: Q corruption
     at line 1743 in /project/dce/build/dce1.1-snap/src/threads/cma_debugger.c
% See 'cma_dump.log' for state information.
%Internal DCE Threads problem (version CMA BL10+), terminating execution.
% Reason: assertion failure:  cma__Queue_next: Q corruption
     at line 1743 in /project/dce/build/dce1.1-snap/src/threads/cma_debugger.c
% See 'cma_dump.log' for state information.
%Internal DCE Threads problem (version CMA BL10+), terminating execution.
% Reason: assertion failure:  cma__Queue_next: Q corruption
     at line 1743 in /project/dce/build/dce1.1-snap/src/threads/cma_debugger.c
% See 'cma_dump.log' for state information.
%Internal DCE Threads problem (version CMA BL10+), terminating execution.
% Reason: assertion failure:  cma__Queue_next: Q corruption
     at line 1743 in /project/dce/build/dce1.1-snap/src/threads/cma_debugger.c
% See 'cma_dump.log' for state information.
%Internal DCE Threads problem (version CMA BL10+), terminating execution.
     % Reason: assertion failure:  cma__Queue_next: Q corruption

Unfortunately the cma_dump.log referred to is empty. No tests were running
at the time.



CR Number                     : 11042
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : thr
Subcomponent Name             : cma_close
Short Description             : cma_close doesn't work correctly on HP
Reported Date                 : 6/22/94
Found in Baseline             : 1.1b10
Found Date                    : 6/22/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/22/94 public]

A process started by execv gets all open file descriptors from it's
parent. To close them our gdsdsa calls a function
"close_unused_files"  to avoid the inheritance from the calling program.
But cma_close doesn't close these files - we think because there
haven't been opened by cma_open.

Here is an example program which illustrates the behaviour:

-------

/* This program shows a bug in threads. The behaviour is different    */
/* in a threaded and a non threaded environment.                      */
/* Let "x" be any existing system file.                               */

/* If compiled and linked in a sandbox on HP800, NONTHREAD being not  */
/* set, the function close_files never closes any files physically.   */
/* After every "execv" the filedescriptor for "x" is incremented      */
/* therefore, after 60 execv the process specific limit of open files */
/* is exceeded.                                                       */

/* If compiled and linked on HP800 by a call                          */
/* "cc -o fdtest -DNONTHREAD fdtest.c",                               */
/* the function close_files closes the opened file after every "execv"*/
/* The filedescriptor for "x" is constant                             */

/* The gdsdsa closes all unused files in the beginning, to avoid the  */
/* inheritance from the calling program                               */

#ifndef NONTHREAD
#include <pthread.h>
#endif

#include <stdio.h>
#include <unistd.h>
#include <errno.h>

main(argc,argv)

int argc;
char *argv[];

{
  FILE *fp;

  close_files();
  if((fp = fopen("x","r")) != NULL)
  {
    printf("fileno: %d\n",fileno(fp));
  }
  printf("Press RETURN to proceed, DEL to break > ");
  getchar();
  execv(argv[0],argv);
  printf("execv failed, errno: %d\n",errno);
}

close_files()

{
  int fd;
  int fd_max;

  fd_max = sysconf(_SC_OPEN_MAX);
  for(fd = 3; fd < fd_max; fd++)
  {
    if(close(fd) == 0)
    {
      fprintf(stderr,"file closed, fd: %d\n",fd);
    }
  }
}

[6/22/94 public]
You are right cma_close in the  child process after the exec doesn't
know the file is open. cma_close calls cma__is_open to see if the file
is known to be open. If not it just returns. Since the bit that cma__is_open
looksis global data which is reset in the new address space it will of
course return false. Since none of the cma state is from the parent
is valid in the child you need to avoid the call to cma_close. I suggest

  for(fd = 3; fd < fd_max; fd++)
  {
#undef close
    close(fd)
#define close cma_close
  }

[Wed Jun 22 13:25:51 EDT 1994 public]

Make sure that you conditionalize this on a per-platform basis.  On SVR4,
CMA does know which files are open at process start-up time (including
inherited open file descriptors).  Therefore, you don't want to perform
this #undef for the SVR4 platforms and doing so may cause problems. 

Prehaps the CMA initialization code should do a better job of trying
to figure out which file descriptors are open at process start-up time
for other platforms?

[06/23/94 public]
I'm very proud of my SVR4 platform.
I totally agree: CMA should do a better job. Please see this as an
official change request: We would like to have a cma_close which
knows inherited open file descriptors.
Please give us a note if you will implement this or not.
(May be you can use SVR4 experiences ...)
Now we have the workaround that we don't include pthread.h into the file
which contains the function close_unused_files.
Will we have problems on SVR4?
This function is called only when the process is started - so, hopefully,
we will not have problems with the mix close - cma_close.
But this workaround is really not nice.

[Thu Jun 23 09:19:14 EDT 1994 public]

I don't think that it would really be feasible to use the SVR4 code
with learns about open file descriptors on other platforms because
it is based upon poll().  Code based upon select() would not be hard, 
just tedious.

If you are using SNI-SVR4, then you will not have a problem by removing
the include of pthread.h because the close() function is really the 
cma_close() function.  On other SVR4-based platforms (e.g. SCO) you 
might have a problem because you would miss out on calling cma_close()
for those file descriptors.

[6/23/94 public]
If removing pthread.h is acceptable I assume the exec'd process is 
intended to be single threaded so not calling cma_close should be ok.
I have some  exec wrappers recently supplied by HP that they use on 
their platform that do more than the previously supplied wrappers. If 
I get time in the 1.1 schedule I will look at these and see if they can
be made to work on the other platforms. I don't know if they cover
open file descriptors. I probably won't get to them for a couple
of weeks.



CR Number                     : 11004
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : thr
Subcomponent Name             : 
Short Description             : thread "heartbeat" is off in the child after fork().
Reported Date                 : 6/17/94
Found in Baseline             : 1.0.3
Found Date                    : 6/17/94
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/17/94 public]

The Problem
-----------

If a program which has initialized the threads layer (e.g. by calling a
wrapped library call such as printf()) calls fork() then the thread
"heartbeat" is off in the child. The OS fork() call disables the virtual
timer in the child (this may vary accross OS: it is specified in the OS/AES
and it seems to be the fork() behavior on AIX and HP/UX even though it is
not specified in the corresponding man pages) and the threads package does
not restore it.

Here is a little program "demonstrating" the behavior:

#include <pthread.h>
#include <stdio.h>
#include <sys/types.h>

typedef struct {
  int thread_id;
  int iterations;
} count_args_t;

void bar(int);
void count(pthread_addr_t);

void main(int argc, char *argv[])
{
  int iterations;

  sscanf(argv[1], "%d", &iterations);

  bar(iterations);

  if (fork() > 0)
    exit(0);
  else 
    bar(iterations);

  exit(0);
}

void bar(int iterations)
{
  pthread_t thread_1;
  pthread_t thread_2 ;
  count_args_t count_args_1;
  count_args_t count_args_2;
  pthread_addr_t thread_status;

  printf("in bar: pid = %d\n", getpid());

  count_args_1.thread_id = 1;
  count_args_1.iterations = iterations;
  pthread_create(&thread_1, 
                 pthread_attr_default, 
                 (pthread_startroutine_t) count,
                 (pthread_addr_t) &count_args_1);
  printf("in bar: pthread_create(thread_1)\n");

  count_args_2.thread_id = 2; 
  count_args_2.iterations = iterations;
  pthread_create(&thread_2,
                 pthread_attr_default, 
                 (pthread_startroutine_t) count,
                 (pthread_addr_t) &count_args_2);
  printf("in bar: pthread_create(thread_2)\n");

  pthread_join(thread_1, &thread_status);
  printf("in bar: pthread_join(thread_1)\n");
  pthread_join(thread_2, &thread_status);
  printf("in bar: pthread_join(thread_2)\n");
}

void count(pthread_addr_t x)
{
  count_args_t *count_args = (count_args_t *) x;
  int thread_id = count_args->thread_id;
  int iterations = count_args->iterations;
  int i;
  int k = iterations / 10;
  
  for (i = 0; i < iterations; i++) {
    if (i % k == 0) {
      printf("in count: thread id = %d, i = %d\n", thread_id, i);
    }
  }
}

along with the following sample run (1.0.3 on rios):

# ./foo1 1000000
in bar: pid = 7791
in bar: pthread_create(thread_1)
in bar: pthread_create(thread_2)
in count: thread id = 1, i = 0
in count: thread id = 1, i = 100000
in count: thread id = 2, i = 0
in count: thread id = 2, i = 100000
in count: thread id = 1, i = 200000
in count: thread id = 2, i = 200000
in count: thread id = 1, i = 300000
in count: thread id = 2, i = 300000
in count: thread id = 1, i = 400000
in count: thread id = 2, i = 400000
in count: thread id = 1, i = 500000
in count: thread id = 2, i = 500000
in count: thread id = 1, i = 600000
in count: thread id = 2, i = 600000
in count: thread id = 2, i = 700000
in count: thread id = 1, i = 700000
in count: thread id = 2, i = 800000
in count: thread id = 1, i = 800000
in count: thread id = 1, i = 900000
in count: thread id = 2, i = 900000
in bar: pthread_join(thread_1)
in bar: pthread_join(thread_2)
# in bar: pid = 27248
in bar: pthread_create(thread_1)
in bar: pthread_create(thread_2)
in count: thread id = 1, i = 0
in count: thread id = 1, i = 100000
in count: thread id = 1, i = 200000
in count: thread id = 1, i = 300000
in count: thread id = 1, i = 400000
in count: thread id = 1, i = 500000
in count: thread id = 1, i = 600000
in count: thread id = 1, i = 700000
in count: thread id = 1, i = 800000
in count: thread id = 1, i = 900000
in count: thread id = 2, i = 0
in count: thread id = 2, i = 100000
in count: thread id = 2, i = 200000
in count: thread id = 2, i = 300000
in count: thread id = 2, i = 400000
in count: thread id = 2, i = 500000
in count: thread id = 2, i = 600000
in count: thread id = 2, i = 700000
in count: thread id = 2, i = 800000
in count: thread id = 2, i = 900000
in bar: pthread_join(thread_1)
in bar: pthread_join(thread_2)

If the fork() section of the code (in main()) is replaced by the following:

  if (fork() > 0)
    exit(0);
  else {
    unix_timer.it_interval.tv_sec  = 0;
    unix_timer.it_interval.tv_usec = 100000; /* magic # from threads */
    unix_timer.it_value.tv_sec  = 0;
    unix_timer.it_value.tv_usec = 100000;
    setitimer(ITIMER_VIRTUAL, &unix_timer, &unix_oldtime);

    bar(iterations);
  }

then the program runs as follows (again 1.0.3 on rios):

# ./foo2 1000000
in bar: pid = 25729
in bar: pthread_create(thread_1)
in bar: pthread_create(thread_2)
in count: thread id = 1, i = 0
in count: thread id = 1, i = 100000
in count: thread id = 2, i = 0
in count: thread id = 2, i = 100000
in count: thread id = 1, i = 200000
in count: thread id = 2, i = 200000
in count: thread id = 1, i = 300000
in count: thread id = 2, i = 300000
in count: thread id = 1, i = 400000
in count: thread id = 2, i = 400000
in count: thread id = 1, i = 500000
in count: thread id = 2, i = 500000
in count: thread id = 1, i = 600000
in count: thread id = 2, i = 600000
in count: thread id = 1, i = 700000
in count: thread id = 1, i = 800000
in count: thread id = 2, i = 700000
in count: thread id = 2, i = 800000
in count: thread id = 1, i = 900000
in count: thread id = 2, i = 900000
in bar: pthread_join(thread_1)
in bar: pthread_join(thread_2)
# in bar: pid = 27266
in bar: pthread_create(thread_1)
in bar: pthread_create(thread_2)
in count: thread id = 1, i = 0
in count: thread id = 1, i = 100000
in count: thread id = 2, i = 0
in count: thread id = 2, i = 100000
in count: thread id = 1, i = 200000
in count: thread id = 2, i = 200000
in count: thread id = 1, i = 300000
in count: thread id = 2, i = 300000
in count: thread id = 1, i = 400000
in count: thread id = 2, i = 400000
in count: thread id = 1, i = 500000
in count: thread id = 2, i = 500000
in count: thread id = 1, i = 600000
in count: thread id = 2, i = 600000
in count: thread id = 1, i = 700000
in count: thread id = 2, i = 700000
in count: thread id = 2, i = 800000
in count: thread id = 1, i = 800000
in count: thread id = 1, i = 900000
in count: thread id = 2, i = 900000
in bar: pthread_join(thread_1)
in bar: pthread_join(thread_2)

So (1)
------

1) I understand that the POSIX semantic of fork() in a threaded environment
is that only the forking thread is "live" in the child. This, however, does
not specify whether the child can be threaded or not. If the child can be
threaded then the current threads implementation is defective; if it can not
then...

2) Many daemons in DCE are in error since they initialize threads before
forking and therefore the daemon (i.e. the child) runs without the thread
heartbeat! This does sound implausible since the DCE daemons do seem to
work (at least most of the time) but here is an experiment suggesting that
it is indeed the case (this is with cdsd but it works (!) for rpcd and
sec_clientd as well): 

	1.
	- attach a debugger to a running cdsd 
	- put a break point in cma__periodic() (the VTALRM signal handler)
	- continue
	- observe that cdsd never runs cma__periodic()

	2.
	- repeat 1. but having started cdsd with -d i.e. without forking.
	- observe that cdsd runs cma__periodic()

(still 1.0.3 on rios)

1.

# ps -ef | grep cdsd
    root 10021     1   0 10:40:26      -  0:33 /opt/dcelocal/bin/cdsd 
    root 25734 27896   0 16:59:18  pts/2  0:00 grep cdsd 
# dbx -a 10021
Waiting to attach to process 10021 ...
Successfully attached to cdsd.
warning: Directory containing cdsd could not be determined.
Apply 'use' command to initialize source path.

dbx version 3.1 for AIX.
Type 'help' for help.
reading symbolic information ...

attached in cma__io_available at 0xd02ee340
0xd02ee340 (cma__io_available+0x3c0) 80410014          l   r2,0x14(r1)
(dbx) ignore VTALRM
(dbx) stop in cma__periodic
[1] stop in cma__periodic
(dbx) c
-----
Here exercise cds and notice that the cdsd just keeps on going...
For fun you can also:

# kill -VTALRM 10021

and sure enough (back to dbx):
-----
[1] stopped in cma__periodic at 0xd02f6f34
0xd02f6f34 (cma__periodic)    7c0802a6       mflr   r0

2.

# /opt/dcelocal/bin/cdsd -d &
[2]     10143
# dbx -a 10143
Waiting to attach to process 10143 ...
Successfully attached to cdsd.
warning: Directory containing cdsd could not be determined.
Apply 'use' command to initialize source path.

dbx version 3.1 for AIX.
Type 'help' for help.
reading symbolic information ...

attached in cma__io_available at 0xd02ee340
0xd02ee340 (cma__io_available+0x3c0) 80410014          l   r2,0x14(r1)
(dbx) ignore VTALRM
(dbx) stop in cma__periodic
[1] stop in cma__periodic
(dbx) c 
[1] stopped in cma__periodic at 0xd02f6f34
0xd02f6f34 (cma__periodic)    7c0802a6       mflr   r0
(dbx) c
-----
Here cdsd stopped in cma__periodic already but if it did not try
exercising cds a little to get there. For example:

# cdscp show clear /.:/pierrot_ch

and (back to dbx):
-----
[1] stopped in cma__periodic at 0xd02f6f34
0xd02f6f34 (cma__periodic)    7c0802a6       mflr   r0

Again, this behavior is similar for all the daemons I tried: cdsd, rpcd and
sec_clientd. So:

3) Why do the daemons work? Threads yield on completion, on blocking I/O,
etc... i.e. not only through the threads pre-emptive scheduling. It is
possible that in an I/O bound process (e.g. a DCE daemon) this effectively
creates "cooperative" scheduling.

So (2)
------

Something needs to be fixed. Again, either the threads package is deficient
or the DCE daemons use the wrong programming model. 

By the way, in the process of tracking this down I also run these tests on
the HP/DCE product and the IBM/DCE product (both corresponding to OSF 1.0.2
I believe). HP folks may be interested to known that I observed the
behavior described in this report on their platform as well. On the other
hand, the IBM/DCE (product) fork() seems to restore the timer in the child
so may be we can get some help from IBM on this one :)

Finally, it is a little annoying that none of the tests point to this
problem.

[7/19/94 public]

I am raising the severity to A. Solving this problem may create problems in
other components (namely in all of the DCE daemons) so if it is not
addressed soon it is a safe bet that 1.1 will ship without a fix to this
defect.



CR Number                     : 10510
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : 
Short Description             : Compiler warning: ""macro
replacement within a string literal"
Reported Date                 : 5/3/94
Found in Baseline             : 1.0.3
Found Date                    : 5/3/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[5/3/94 public]

Customer reported that the following files give compilation warning when
using SVR4/FTX compiler:

                        src/threads/cma_mutex.h
                        src/threads/cma_queue.h
                        src/threads/cma_sched.h
                        src/threads/cma_thread_io.h

The warning msg is "macro replacement within a string literal".

To avoid a macro replacement string, try not to include any
word which is similar to the argument name.

For example:

* in cma_mutex.h
-----------------
# define cma__int_unlock(mutex) { \
    cma__t_int_tcb      *__utcb__; \
    __utcb__ = cma__get_self_tcb (); \
    if (((cma__t_int_mutex *)mutex)->mutex_kind == cma_c_mutex_fast) { \
        cma__assert_warn ( \
                (__utcb__ == ((cma__t_int_mutex *)mutex)->owner), \
                "attempt to release mutex owned by another thread"); \
        ((cma__t_int_mutex *)mutex)->owner = (cma__t_int_tcb *)cma_c_null_ptr; \
        } \
    cma__unset (((cma__t_int_mutex *)mutex)->unlock); \
    if (!cma__test_and_set (&((cma__t_int_mutex *)mutex)->event)) { \
        cma_t_status    res;\
        res = cma__int_mutex_unblock ((cma__t_int_mutex *)mutex); \
        if (res != cma_s_normal) cma__error (res); \
        } \
    }

Using the word "mutex" inside the string "attempt to release mutex owned by
another thread" will cause the warning error
    Warning: macro replacement within a string literal

Proposed Solution: Just change the argument name mutex to _mutex


* in cma_queue.h
----------------
#if ((_CMA_PLATFORM_ != _CMA__SINIX_MX300I) &&
               (_CMA_PLATFORM_ != _CMA__DCOSX_MI PS))
#define cma__queue_empty(head) (                 \
   cma__assert_fail (                            \
      (head)->blink->flink == (head),            \
      "cma__queue_empty: queue corruption -- head->blink->flink != head"), \
   cma__assert_fail (                            \
      (head)->flink->blink == (head),            \
      "cma__queue_empty: queue corruption -- head->flink->blink != head"), \
    (head)->flink == (head))
#else
.
.
#endif

Using the work "head" inside the string
   "cma__queue_empty: queue corruption -- head->blink->flink != head"

Proposed Solution: Change the argument name head to _head

----------------

#if ((_CMA_PLATFORM_ != _CMA__SINIX_MX300I) &&
               (_CMA_PLATFORM_ != _CMA__DCOSX_MI PS))
#define cma__queue_insert(element,q_ptr)    (        \
   cma__assert_fail (                               \
     (element)->flink == 0,                    \
     "cma__queue_insert: queue corruption -- element flink not zero"), \
   cma__assert_fail (                               \
     (element)->blink == 0,                   \
     "cma__queue_insert: queue corruption -- element blink not zero"), \
   cma__assert_fail (                               \
     (q_ptr)->blink->flink == (q_ptr),        \
     "cma__queue_insert: queue corruption -- q_ptr->blink->flink != q_ptr "), \
    cma__assert_fail (                                  \
     (q_ptr)->flink->blink == (q_ptr),         \
     "cma__queue_insert: queue corruption -- q_ptr->flink->blink != q_ptr "), \
    (element)->blink           = (q_ptr)->blink,      \
    (element)->flink           = (q_ptr),             \
    (q_ptr)->blink->flink      = (element),           \
    (q_ptr)->blink             = (element))
#else
  .
  .
#endif

Proposed Solution: Change the argument name "element" to "_element" and
"q_ptr" to _q_ptr"

-----------------------------------

Same things happen in macro cma__queue_insert_after, cma__queue_next,
cma__queue_previous, cma__queue_remove.

* in cma_sched.h
----------------

The macro cma__sched_parameterize has the same problem

* in cma_thread_io.h
---------------------
Macros cma__ts_open, cma__ts_open2 have the same problem



CR Number                     : 10437
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : test
Short Description             : crvb_exc_002 and prvb_exc_002
should be removed from src/test/threads/runtest.
Reported Date                 : 4/21/94
Found in Baseline             : 1.0.3
Found Date                    : 4/21/94
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/test/threads/runtest
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/21/94 public]

  Since crvb_exc_002 and prvb_exc_002 are not built in the 
 Makefile, they should be removed from the runtest script as
 well.



CR Number                     : 10435
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 10433
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : select masks delcared int
Reported Date                 : 4/21/94
Found in Baseline             : 1.0.3
Found Date                    : 4/21/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/21/94 public]

The following files all use an int instead of an fd_set.  Because an fd_set
can be larger than an int, this causes memory to be scribbled.

    cupb_nbi_001
    cuvb_nbi_002
    cuvb_nbi_003
    cuvi_nbi_004
    puvb_nbi_002
    puvb_nbi_003
    puvi_nbi_004

[4/25/94 public]

Diffs to fix this problem follow.

======================================================================
diff -r ../../../link/src/test/threads/cupb_nbi_001.c ./cupb_nbi_001.c
10a11,13
>  * Revision 1.1.3.2  94/04/25  11:26:58  weisman
>  * 	Changed select logic to use fd_sets instead of ints
>  * 
109a113
> #include <sys/select.h>
126c130,131
<     int		 fds, i;
---
>     fd_set fds;
>     int i;
133a139
>     FD_ZERO (&fds);
135c141
< 	fds = 2;
---
>         FD_SET (1, &fds);
149a156
>     FD_ZERO (&fds);
151c158
< 	fds = 2;
---
>         FD_SET (1, &fds);
diff -r ../../../link/src/test/threads/cuvb_nbi_002.c ./cuvb_nbi_002.c
10a11,16
>  * Revision 1.1.1.2  94/04/25  11:27:00  weisman
>  * 	Changed select logic to use fd_sets instead of ints
>  * 
>  * Revision 1.1  1994/03/07  20:16:05  rat
>  *        Base version
>  *
100a107
> #include <sys/select.h>
277,282c284,290
<     int  readfds = 0,
<          writefds = 0,
<          exceptfds = 0,
< 	 temp_r,
< 	 temp_w,
<          maxfds = 0,
---
>     fd_set  readfds,
>             writefds,      
>             exceptfds,
>             temp_r,
> 	    temp_w;
> 
>     int  maxfds = 0,
296a305,309
> 
>     FD_ZERO (&readfds);
>     FD_ZERO (&writefds);
>     FD_ZERO (&exceptfds);
> 
298,299c311,312
<         readfds |= 1<<t_socket[cnt];
<         writefds |= 1<<t_socket[cnt];
---
>         FD_SET (t_socket [cnt], &readfds);
>         FD_SET (t_socket [cnt], &writefds);
309,310c322,323
<         readfds |= 1<<cnt;
<         writefds |= 1<<cnt;
---
>         FD_SET (cnt, &readfds);
>         FD_SET (cnt, &writefds);
diff -r ../../../link/src/test/threads/cuvb_nbi_003.c ./cuvb_nbi_003.c
10a11,16
>  * Revision 1.1.1.2  94/04/25  11:27:02  weisman
>  * 	Changed select logic to use fd_sets instead of ints
>  * 
>  * Revision 1.1  1994/03/07  20:16:07  rat
>  *        Base version
>  *
97a104
> #include <sys/select.h>
273,278c280,286
<     int  readfds = 0,
<          writefds = 0,
<          exceptfds = 0,
< 	 temp_r,
< 	 temp_w,
<          maxfds = 0,
---
>    fd_set readfds,
>           writefds,
>           exceptfds,
> 	  temp_r,
> 	  temp_w;
> 
>     int  maxfds = 0,
292a301,305
> 
>     FD_ZERO (&readfds);
>     FD_ZERO (&writefds);
>     FD_ZERO (&exceptfds);
> 
294,295c307,308
<         readfds |= 1<<t_socket[cnt];
<         writefds |= 1<<t_socket[cnt];
---
>         FD_SET (t_socket [cnt], &readfds);
>         FD_SET (t_socket [cnt], &writefds);
304,305c317,318
<         readfds |= 1<<cnt;
<         writefds |= 1<<cnt;
---
>         FD_SET (cnt, &readfds);
>         FD_SET (cnt, &writefds);
diff -r ../../../link/src/test/threads/cuvi_nbi_004.c ./cuvi_nbi_004.c
14a15,17
>  * Revision 1.1.3.2  94/04/25  11:27:04  weisman
>  * 	Changed select logic to use fd_sets instead of ints
>  * 
113a117
> #include <sys/select.h>
235c239,240
<     int     r, w, e, rv;
---
>     fd_set  r, w, e;
>     int     rv;     
291c296,299
< 	    r = 1 << fd; w = 0; e = 0;
---
>             FD_ZERO (&r);
>             FD_ZERO (&w);
>             FD_ZERO (&e);
>             FD_SET (fd, &r);
307c315,318
< 	r = 1 << fd; w = 0; e = 0;
---
>         FD_ZERO (&r);
>         FD_ZERO (&w);
>         FD_ZERO (&e);
>         FD_SET (fd, &r);
diff -r ../../../link/src/test/threads/puvb_nbi_002.c ./puvb_nbi_002.c
10a11,16
>  * Revision 1.1.1.2  94/04/25  11:27:06  weisman
>  * 	Changed select logic to use fd_sets instead of ints
>  * 
>  * Revision 1.1  1994/03/07  20:17:14  rat
>  *        Base version
>  *
101a108
> #include <sys/select.h>
281,286c288,293
<     int  readfds = 0,
<          writefds = 0,
<          exceptfds = 0,
< 	 temp_r,
< 	 temp_w,
<          maxfds = 0,
---
>     fd_set  readfds,
>             writefds,
>             exceptfds,
> 	    temp_r,
> 	    temp_w;
>     int  maxfds = 0,
301a309,313
> 
>     FD_ZERO (&readfds);
>     FD_ZERO (&writefds);
>     FD_ZERO (&exceptfds);
> 
303,304c315,316
<         readfds |= 1<<t_socket[cnt];
<         writefds |= 1<<t_socket[cnt];
---
>         FD_SET (t_socket [cnt], &readfds);
>         FD_SET (t_socket [cnt], &writefds);
314,315c326,327
<         readfds |= 1<<cnt;
<         writefds |= 1<<cnt;
---
>         FD_SET (cnt, &readfds);
>         FD_SET (cnt, &writefds);
diff -r ../../../link/src/test/threads/puvb_nbi_003.c ./puvb_nbi_003.c
10a11,16
>  * Revision 1.1.1.2  94/04/25  11:27:08  weisman
>  * 	Changed select logic to use fd_sets instead of ints
>  * 
>  * Revision 1.1  1994/03/07  20:17:16  rat
>  *        Base version
>  *
103a110
> #include <sys/select.h>
278,283c285,290
<     int  readfds = 0,
<          writefds = 0,
<          exceptfds = 0,
< 	 temp_r,
< 	 temp_w,
<          maxfds = 0,
---
>     fd_set  readfds,
>             writefds,
>             exceptfds,
> 	    temp_r,
> 	    temp_w;
>     int  maxfds = 0,
298a306,310
> 
>     FD_ZERO (&readfds);
>     FD_ZERO (&writefds);
>     FD_ZERO (&exceptfds);
> 
300,301c312,313
<         readfds |= 1<<t_socket[cnt];
<         writefds |= 1<<t_socket[cnt];
---
>         FD_SET (t_socket [cnt], &readfds);
>         FD_SET (t_socket [cnt], &writefds);
310,311c322,323
<         readfds |= 1<<cnt;
<         writefds |= 1<<cnt;
---
>         FD_SET (cnt, &readfds);
>         FD_SET (cnt, &writefds);
diff -r ../../../link/src/test/threads/puvi_nbi_004.c ./puvi_nbi_004.c
10a11,16
>  * Revision 1.1.1.2  94/04/25  11:27:10  weisman
>  * 	Changed select logic to use fd_sets instead of ints
>  * 
>  * Revision 1.1  1994/03/07  20:17:19  rat
>  *        Base version
>  *
99a106
> #include <sys/select.h>
217c224,225
<     int     r, w, e, rv;
---
>     fd_set  r, w, e;
>     int     rv;
267c275,278
< 	    r = 1 << fd; w = 0; e = 0;
---
>             FD_ZERO (&r);
>             FD_ZERO (&w);
>             FD_ZERO (&e);
>             FD_SET (fd, &r);
269d279
<



CR Number                     : 10433
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 10435
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : fd_set wrongly declared int
Reported Date                 : 4/21/94
Found in Baseline             : 1.0.3
Found Date                    : 4/21/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cuvb_nbi_004.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/21/94 public]

The test cuvb_nbi_004.c wrongly declares an fd_set as a cma_t_integer.
This causes the too-small fd_set to be overwritten by select().

The diff below fixes this.

[There may be other similar cases in threads; I have not checked for these
yet.] 

======================================================================
***************
*** 195,201 ****
  	cma_t_integer	id;
  #endif	/* prototype */
      {
!     cma_t_integer	    rfds, nfound;
      static struct timeval   poll = {0, 0},
  			    timeout = {2, 500000};   /* 2.5 Seconds */
      cts_timebuf_t	    start;
--- 204,211 ----
  	cma_t_integer	id;
  #endif	/* prototype */
      {
!     fd_set                  rfds;
!     cma_t_integer	    nfound;
      static struct timeval   poll = {0, 0},
  			    timeout = {2, 500000};   /* 2.5 Seconds */
      cts_timebuf_t	    start;
***************
*** 213,219 ****
      /*
       * Test #1:  Polling select with no waiting data.
       */
!     rfds = 1 << p_fd[id];
      nfound = select (p_fd[id]+1, &rfds, 0, 0, &poll);
      if (nfound < 0) my_failure ("Error in select (poll/no data)");
      if (nfound > 0) cts_failed ("Polling select with no data, found data.");
--- 223,229 ----
      /*
       * Test #1:  Polling select with no waiting data.
       */
!     FD_SET (p_fd[id], &rfds);
      nfound = select (p_fd[id]+1, &rfds, 0, 0, &poll);
      if (nfound < 0) my_failure ("Error in select (poll/no data)");
      if (nfound > 0) cts_failed ("Polling select with no data, found data.");
***************
*** 221,227 ****
      /*
       * Test #2:  Timed select with no waiting data.
       */
!     rfds = 1 << p_fd[id];
      nfound = select (p_fd[id]+1, &rfds, 0, 0, &timeout);
      if (nfound < 0) my_failure ("Error in select (timeout/no data)");
      if (nfound > 0) cts_failed ("Timeout select with no data, found data.");
--- 231,237 ----
      /*
       * Test #2:  Timed select with no waiting data.
       */
!     FD_SET (p_fd[id], &rfds);
      nfound = select (p_fd[id]+1, &rfds, 0, 0, &timeout);
      if (nfound < 0) my_failure ("Error in select (timeout/no data)");
      if (nfound > 0) cts_failed ("Timeout select with no data, found data.");
***************
*** 246,253 ****
      /*
       * Test #3:  "Blocking" select with no waiting data.
       */
-     rfds = 1 << p_fd[id];
  
      nfound = select (p_fd[id]+1, &rfds, 0, 0, 0);
      cts_gettime(&end);
  
--- 256,264 ----
      /*
       * Test #3:  "Blocking" select with no waiting data.
       */
  
+     FD_SET (p_fd[id], &rfds);
+ 
      nfound = select (p_fd[id]+1, &rfds, 0, 0, 0);
      cts_gettime(&end);
  
***************
*** 269,275 ****
      /*
       * Test #4:  Polling select with waiting data.
       */
!     rfds = 1 << p_fd[id];
      nfound = select (p_fd[id]+1, &rfds, 0, 0, &poll);
      if (nfound < 0) my_failure ("Error in select (poll/data)");
      if (nfound == 0) cts_failed ("Polling select with data, found no data.");
--- 280,287 ----
      /*
       * Test #4:  Polling select with waiting data.
       */
! 
!     FD_SET (p_fd[id], &rfds);
      nfound = select (p_fd[id]+1, &rfds, 0, 0, &poll);
      if (nfound < 0) my_failure ("Error in select (poll/data)");
      if (nfound == 0) cts_failed ("Polling select with data, found no data.");
***************
*** 277,283 ****
      /*
       * Test #5:  Timed select with waiting data.
       */
!     rfds = 1 << p_fd[id];
      nfound = select (p_fd[id]+1, &rfds, 0, 0, &timeout);
      if (nfound < 0) my_failure ("Error in select (timeout/data)");
      if (nfound == 0) cts_failed ("Timeout select with data, found no data.");
--- 289,296 ----
      /*
       * Test #5:  Timed select with waiting data.
       */
! 
!     FD_SET (p_fd[id], &rfds);
      nfound = select (p_fd[id]+1, &rfds, 0, 0, &timeout);
      if (nfound < 0) my_failure ("Error in select (timeout/data)");
      if (nfound == 0) cts_failed ("Timeout select with data, found no data.");
***************
*** 285,291 ****
      /*
       * Test #6:  "Blocking" select with waiting data.
       */
!     rfds = 1 << p_fd[id];
      nfound = select (p_fd[id]+1, &rfds, 0, 0, 0);
      if (nfound < 0) my_failure ("Error in select (blocking/data)");
      if (nfound == 0) cts_failed ("Blocking select with data, found no data.");
--- 298,305 ----
      /*
       * Test #6:  "Blocking" select with waiting data.
       */
! 
!     FD_SET (p_fd[id], &rfds);
      nfound = select (p_fd[id]+1, &rfds, 0, 0, 0);
      if (nfound < 0) my_failure ("Error in select (blocking/data)");
      if (nfound == 0) cts_failed ("Blocking select with data, found no data.");

[4/21/94 public]

Minor addition to above -- each FD_SET should be preceeded by a:
	
   FD_ZERO (&rfds);



CR Number                     : 10369
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : kernel threads
Short Description             : cma__sem_timed_wait fails for
very long intervals
Reported Date                 : 4/15/94
Found in Baseline             : 1.0.3
Found Date                    : 4/15/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : .../src/threads/cma_semaphore,c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/15/94 public]

 If _CMA_THREAD_IS_VP_ is true, that is, in the case of kernel threads,
very long waits in cma__sem_timed_wait return immediately because the
calculation of the delta overflows and returns a negative value. The
problem appears when the timeout is approximately 23 days. The code in
question is the following:

#if _CMA_THREAD_IS_VP_
        cma__get_time (&current);
        cma__subtract_time (&delta, timeout, &current);
# if _CMA_OS_ == _CMA__VMS
        /*
         * FIX-ME:
         *
         * Need to implement this before supporting VMS kernel threads
         */
        this doesn't matter since vms doesn't have kernel threads!!!
# else
        delta_ms = ((delta.tv_sec * 1000) + ((delta.tv_usec + 999) /
1000));
# endif

        if (delta_ms <= 0)
            value = cma_c_false;        /* Instant timeout */
        else
            value = cma__block (&semaphore->queue, delta_ms);

#else

specifically, the conversion of delta.tv_sec to milliseconds in the
calculation of delta_ms. The customer included a suggested fix in his
service ticket.



CR Number                     : 10356
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : ptdexc_signal_cancel_np
Short Description             : unlike pthread_to_signal_np,
ptdexc_signal_cancel_np does not return a status
Reported Date                 : 4/14/94
Found in Baseline             : 1.0.3
Found Date                    : 4/14/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : .../src/threads/cma_ptd_exc.c,
					     .../src/threads/pthread_exc.h
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/14/94 public]

 pthread_signal_to_cancel_np returns a status value signifying success or
 failure. ptdexc_signal_to_cancel_np is declared as a void routine and
 does not return any value. This is particularly troublesome because
 pthread_signal_to_cancel_np is defined as ptdexc_signal_to_cancel_np
 when pthread_exc.h is included in a file in place of pthread.h.



CR Number                     : 10344
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : cma_init.c
Short Description             : debug code in cma_init.c doesn't maintain mutex table properly
Reported Date                 : 4/13/94
Found in Baseline             : 1.0.2
Found Date                    : 4/13/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cma_init.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
OB                            : 

[4/13/94 public]
 The cma___g_dbg_libcr_c counter is never decremented, only
 incremented.  That means if 1024 mutexes are created and then
 destroyed, the counter will overflow and trip an assert in
 cma___mutex_create. 
 
 The fix is easy enough; when a mutex_destroy is done, copy the last
 entry in the table into the newly-vacant slot and decrement the
 counter by 1.
 
Related-file::Added 931208 by wright::
/build/hiosfm/RCS/src/dce/src/threads/./c
ma_init.c,v 7.5
 /build/hiosfm/RCS/src/dce/src/threads/./cma_init.c,v 7.5
 wright 1993/12/08 19:10:29 +3 -3
 Reason:  OSDqa06763 mutex debug table can improperly overflow
 When removing table entry, put last entry into vacated spot.
 
     *** /tmp/ci.15985..cma_init.c.16012.1      Wed Dec  8 14:10:32 1993
     --- /tmp/cma_init.c.16012.2        Wed Dec  8 14:10:32 1993
     ***************
     *** 845,855 ****
           cma__int_lock (cma___g_dbg_libcr_m);
       
           for (i = 0; i < cma___g_dbg_libcr_c; i++) {
       
        if (cma___g_dbg_libcr_v[i] == *mutex) {
     !      cma___g_dbg_libcr_v[i] = (lib_mutex_t)0;
            done = cma_c_true;
            break;
            }
       
        }
     --- 845,855 ----
           cma__int_lock (cma___g_dbg_libcr_m);
       
           for (i = 0; i < cma___g_dbg_libcr_c; i++) {
       
        if (cma___g_dbg_libcr_v[i] == *mutex) {
     !      cma___g_dbg_libcr_v[i] = cma___g_dbg_libcr_v[--cma___g_dbg_libcr_c];
            done = cma_c_true;
            break;
            }
       
        }



CR Number                     : 10231
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : Uninitialized variables in crvb_sig_003.c
Reported Date                 : 3/26/94
Found in Baseline             : 1.0.3
Found Date                    : 3/26/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[3/26/94 public]

In test/threads/crvb_sig_003.c, in the functions pipe1_thread() and
pipe2_thread(), the local variables empty_mask and flags are uninitialized.
These values are passed into sigaction() and unexpected behavior can occur.



CR Number                     : 10156
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : aix
Component Name                : thr
Subcomponent Name             : cma
Short Description             : cma_sigaction fails on RIOS
Reported Date                 : 3/16/94
Found in Baseline             : 1.0.2a
Found Date                    : 3/16/94
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[3/16/94 public]
When I tried to use sigaction I got a compilation error on the RIOS.  The problem is related to the fact that cma_px.h contains:
#define sigaction cma_sigaction
But the structure used for arguments are also called sigaction and CMA
makes no attempt to declare "struct cma_sigaction".



Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'



CR Number                     : 10053
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : thr
Subcomponent Name             : 
Short Description             : CRVB_TIM_002 and CRVB_CVX_TIM_001 tests failed
Reported Date                 : 3/2/94
Found in Baseline             : 1.1
Found Date                    : 3/2/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[3/2/94 public]
This is the output from these tests:

START,  Test "CRVB_TIM_002":    Test accuracy of repeated concurrent delays
Thread 0: 0 under, 226004 over; min 0.000683, max 0.669859, avg 0.000737
Thread 1: 0 under, 179 over; min 1.000578, max 1.517567, avg 1.004374
FAILED, Test "CRVB_TIM_002":    Thread 1 had waits more than 20% too long
Thread 2: 0 under, 89 over; min 2.000563, max 2.016240, avg 2.001310
Thread 3: 0 under, 60 over; min 3.000576, max 3.057703, avg 3.002049
Thread 4: 0 under, 45 over; min 4.000651, max 4.069154, avg 4.002713
Thread 5: 0 under, 36 over; min 5.000595, max 5.068188, avg 5.003408
Thread 6: 0 under, 30 over; min 6.000636, max 6.080881, avg 6.003992
Thread 7: 0 under, 25 over; min 7.000605, max 7.005466, avg 7.001221
Thread 8: 0 under, 22 over; min 8.000607, max 8.004925, avg 8.001291
Thread 9: 0 under, 20 over; min 9.000591, max 9.016312, avg 9.001803
Thread 10: 0 under, 18 over; min 10.000634, max 10.009778, avg 10.002045
Thread 11: 0 under, 16 over; min 11.000589, max 11.001805, avg 11.001059
Thread 12: 0 under, 15 over; min 12.000701, max 12.016713, avg 12.002354
Thread 13: 0 under, 13 over; min 13.000583, max 13.001480, avg 13.001003
Thread 14: 0 under, 12 over; min 14.000581, max 14.001703, avg 14.001146
Thread 15: 0 under, 12 over; min 15.000637, max 15.020157, avg 15.002726
Thread 16: 0 under, 11 over; min 16.000683, max 16.001575, avg 16.001109
Thread 17: 0 under, 10 over; min 17.000648, max 17.001329, avg 17.000968
Thread 18: 0 under, 10 over; min 18.000614, max 18.020138, avg 18.003386
Thread 19: 0 under, 9 over; min 19.000607, max 19.001471, avg 19.000889


START,  Test "CRVB_CVX_TIM_001":        Test cma_cond_timed_wait with timeout an
d signals
COMMNT, Test "CRVB_CVX_TIM_001":        Part 1: signal after timeout interval
FAILED, Test "CRVB_CVX_TIM_001":        Expected 10 second interval: actual was 
9.959789 seconds
COMMNT, Test "CRVB_CVX_TIM_001":        Part 2: signal before timeout interval



CR Number                     : 10020
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : threads
Short Description             : atfork() returns exception instead of errno value on error.
Reported Date                 : 2/25/94
Found in Baseline             : 1.0.2
Found Date                    : 2/25/94
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cma_ux.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/25/94 public]
The atfork() function does not return a value but raises an exception
for insufficient memory, which is incorrect, as users may not be
using exceptions. Change the routine that allocates the fork structure
to hold the fork routines to return a value of -1 and an errno of
ENOMEM if insufficient memory exists, per the Threads AES section 2.2.3.

For instance, where the (exc_s_insfmem) exception is raised, return
the errno instead, to give:

 if((cma_t_address)entry == cma_c_null_ptr) {
    cma__set_errno (ENOMEM);
    status = -1;
    }
  .
  .
  .
 return status;
  .
  .
  .

DISCLAIMER: The above is an example. The fix may be accomplished
            differently than exampled and may involve more than shown.



CR Number                     : 9909
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : src/threads/cma_thdio_4.c
Short Description             : cma_poll() with a timeout of
less than 1000 milliseconds does not pend, burns cpu cycles
Reported Date                 : 2/8/94
Found in Baseline             : 1.0.3
Found Date                    : 2/8/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/threads/cma_thdio_4.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/8/94 public]

 The code for cma_poll() in src/threads/cma_thdio_4.c for an SVR4 system
calls __nr_poll() with an immediate timeout. If this poll fails, the code
checks for a user supplied timeout. If there is one, the routine blocks
the thread waiting for io activity or a timeout. The code used to set
the timeout is the following:

                cma__interval_to_time( timeout / 1000, &timeout_tmp );

                /*
                 * Add timeout (delta) to current (absolute) time to makean
                 * absolute timeout time.
                 */
                cma__get_time (&abs_time);
                cma__add_time (&abs_time, &abs_time, &timeout_tmp);

The process blocks by calling cma__int_timed_wait() within a while loop, 
using &abs_time to set the timeout value.

The problem is this: the variable "timeout" which appears within the call

                cma__interval_to_time( timeout / 1000, &timeout_tmp );

is an integer. If cma_poll() is called with a timeout of less than 1000, then
(timeout / 1000) equals 0, abs_time equals the system time, and the
cma__interval_to_time() does not block. Instead, this call is made
repeatedly in the while loop and the thread (process) takes up as much cpu
time as it can get.

The customer has observed this problem in practice, and has created a test
program which also demonstrates it (see the bug report).

The customer reported the problem for DCE1.0.2 but the same code exists in
DCE1.0.3



CR Number                     : 9825
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : Sequence numbers can roll over to 0
Reported Date                 : 1/26/94
Found in Baseline             : 1.0.2a
Found Date                    : 1/26/94
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[1/26/94 public]
We have had problems when the result of pthread_getunique_np() is
zero.  This routine returns zero when its 16-bit counter overflows.
CMA internally uses the counter value of zero as having a special
meaning (i.e. an invalid object, according to the comments in
cma_attr.c, as well as code that compares these sequence numbers in,
say, cma__validate_default_attr().
 
The simplest fix seems to be to fix the two places that increment this
16-bit counter (cma_sequence.c, routine cma__assign_sequence(), and
cma_mutex.c, routine cma__get_first_mutex()) so that they check
whether they just overflowed to zero, and to increment their counter
(to 1).  Expanding the counter to be a 32-bit number or larger is
probably also a good idea, but the check for zero should still be
there.  (How frequently can an application program create threads??)
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'



CR Number                     : 9788
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : installed .h includes non-installed .h
Reported Date                 : 1/20/94
Found in Baseline             : 1.1
Found Date                    : 1/20/94
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/20/94 public]
The file cma_defer.h is installed on a system and unconditionally includes
the file cma_cond_defs.h.  However cma_cond_defs.h is NOT installed on a
system.  How will this work for an application developer?  I think either
it doesn't or application developers shouldn't include this file (directly
or indirectly) so it shouldn't be in the install tree.

Also several cma headers that are installed in /usr/include/dce include
cma.h without a dce/ in front of it.  How will this work without forcing an
application developer to use -I/usr/include/dce?  Note that the handling of
finding includes is left open to the compiler by ANSI C.

absolut include/dce$ fgrep -e '#include' cma*.h | fgrep '<cma'
cma_assert.h:#include <cma.h>
cma_assert.h:#include <cma_defs.h>
cma_defer.h:#include <cma.h>
cma_defer.h:#include <cma_defs.h>
cma_defer.h:#include <cma_cond_defs.h>
cma_host.h:#include <cma.h>
cma_kernel.h:#include <cma_defs.h>
cma_kernel.h:#include <cma_defer.h>
cma_queue.h:#include <cma.h>



CR Number                     : 9787
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : remove extraneous DATAFILES
Reported Date                 : 1/20/94
Found in Baseline             : 1.1
Found Date                    : 1/20/94
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/20/94 public]
the src/threads/Makefiles has the following line:

  ILIST		= ${INCLUDES} ${OBJECTS} ${DATAFILES}

and yet $DATAFILES is not set anywhere, it should be removed.



CR Number                     : 9579
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : Meet code cleanup requirement.
Reported Date                 : 12/7/93
Found in Baseline             : 1.1
Found Date                    : 12/7/93
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/7/93 public]
This a place holder for the code clean up work.

[9/20/94 public]

Code cleanup is complete but there is a small amount of SVC work 
to submit. It will go into unintegrated.



CR Number                     : 9505
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : thr
Subcomponent Name             : 
Short Description             : code needlessly uses floating 
point internally
Reported Date                 : 11/17/93
Found in Baseline             : 1.0.3
Found Date                    : 11/17/93
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/17/93 public]
The cma code uses floating point to represent time intervals internally. 
cma_delay and cma_time_get_expiration take cma_t_interval, which is typed
to float, as an argument. Near as I can tell both of these come down to 
cma__interval_to_time which uses the float representation for a VAX call
only. For our platforms it casts the float to long to set values in a
timespec structure. Remove this floating code. There is no real need for 
it and it causes problems for very small client machines which may not
have floating point capabilities.



CR Number                     : 9477
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : mx300
S/W Ref Platform              : sinix
Component Name                : thr
Subcomponent Name             : 
Short Description             : CMA always issues a poll() before I/O
Reported Date                 : 11/11/93
Found in Baseline             : 1.0.3
Found Date                    : 11/11/93
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/11/93 public]

The way that the SVR4 port of CMA works is that before every I/O call, a
poll() is done,  because file descriptors should not always be put into 
non-blocking mode.

File descriptors on SVR4, and maybe other platforms, have a "file table"
structure in the kernel which contains information about them that is shared
by processes which have that file descriptor open (how processes come to share
this file descriptor is desribed below).  One of the pieces of information
that is maintained in the "file table" is the non-blocking state of the
file descriptor.  This means that *all* processes which share that file
descriptor have the same non-blocking state.

Why is this a problem?  The dce_login program is a good example of why it
would be a problem if CMA put all (possible) file descriptors into 
non-blocking mode.  When a user invokes dce_login, all of the file
descriptors that dce_login knows about will be put into non-blocking
mode, including stdin, stdout, and stderr.  dce_login eventually gets
around to exec()ing a shell for the user, but the file descriptors, which
the shell inherits, are all still in non-blocking mode.  Now the shell is
not expecting its stdin, stdout and stderr files to be non-blocking and
thus will have problems.

Well, one might say, well you should not try to put *all* file descriptors 
into non-blocking mode.  For example, I think that the other reference 
platforms only put sockets into non-blocking mode.  This is still a problem,
though not with a shell, because if the DCE program which does this invokes
a non-DCE program, which uses the sockets opened by the DCE process,
there will be problems unless the program invoked expects
to handle non-blocking sockets.  For the SVR4 platform, we have decided to
avoid this problem and not put any file descriptors into non-blocking mode.

The real answer, I think, is to have another state associated with a CMA
file descriptor, which tells CMA that this file descriptor is "shared"
with other process.  What shared really means is:  "could be shared", since
we can never be totally sure if a file descriptor is really shared or not.
There are only a few ways that a process on SVR4 can obtain a "shared" 
file descriptor is:

    1)  The first is when a process is exec()ed and it inherits file descriptors
        from its parent.  Any file descriptors open at this point are
        shared.
    2)  When a process invokes fork(), all file descriptors open at
        that point become shared.  This is because it is impossible
        to know what the child is going to do with its open file
        descriptors.
    3)  When a process uses ioctl(...,I_SENDFD,...) to send a file descriptor
        or when a process uses ioctl(...,I_RECVFD,...) to receive a
        file descriptor.  In either case, the fd is shared.

I don't think that there are any other ways in which a process can share
a file descriptor.  Given that this is the case, it is very easy to 
implement this so that CMA should be able to set file to non-blocking mode 
if they are not shared.



CR Number                     : 9402
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : thr
Subcomponent Name             : cma
Short Description             : cma fails to open stdout
Reported Date                 : 11/8/93
Found in Baseline             : 1.0.3
Found Date                    : 11/8/93
Severity                      : A
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Status               : open
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com

[11/8/93 public]
The access check ACL test (accheck) fails to complete because an
invocation of acl_edit fails due to what seems like cma's failure to
open stdout.  A core dump a file called cma_dump.log is generated.
Running the file command on the core dump shows
# ls -l
total 72
-rw-r--r--   1 andi     12          3450 Nov 08 12:59 cma_dump.log
-rw-r--r--   1 andi     12         30367 Nov 08 12:59 core
# file core
core:           data or International Language text
But Bruce tried "dbx"ing the core file for acl_edit and it showed a reasonable
stack:
# dbx /opt/dcelocal/bin/acl_edit
dbx version 3.1 for AIX.
Type 'help' for help.
reading symbolic information ...
[memory image in core]
abort process in cma__abort_process at 0xd03ec094
0xd03ec094 (cma__abort_process+0x4c) 80410014          l   r2,0x14(r1)
(dbx) where
cma__abort_process(0x6) at 0xd03ec094
cma__bugcheck(0xd064f75b, 0xd064f72b, 0x1, 0xd, 0xdeadbeef, 0xdeadbeef, 0xdeadbe
ef, 0xdeadbeef) at 0xd03c2984
cma__open_general(0x1) at 0xd03e9f6c
cma__init_thread_io(0x0) at 0xd03e6ec0
cma__init_static(0x1) at 0xd03c2554
cma_init(0x20002828) at 0xd03c22b8
main(0x5, 0x2ff7f024) at 0x100002b8
(dbx) 0xd064f75b/s
d064f75b: "cma__open_general: unexpected fstat error"
(dbx) 0xd064f72b/s
d064f72b: "(open_general) fstat on fd %d returned errno %d"
The relevant portion of code in cma__init_thread_io seems to be line 820 to 833
cma_io_thread.c in dce1.0.3bl8 build.
#if (_CMA_UNIX_TYPE ==  _CMA__SVR4)
....
....
#else 
    /*
     * "Open" the files (ie, within CMA) which are open by default:
     *		stdin, stdout, stderr.  
     *
     * Ignore errors resulting from these files having been closed already.
     */
    for (i = 0; i < 3; i++) {
	TRY
	    cma__open_general (i);
	CATCH (cma_e_badparam)
	    0;
	ENDTRY
	}
#endif /* (_CMA_UNIX_TYPE ==  _CMA__SVR4) */
I say stdout because the parameter to cma__open_general is 1.
I have copied the core and cma_dump.log file into
/afs/tr/public/rajesh/acltestcmabug.
The contents of the cma_dump.log file are also included below:
%Internal DCE Threads problem (version CMA BL10+), terminating execution.
% Reason: cma__open_general: unexpected fstat error
The current thread is 1 (address 0x2008f270)
DECthreads scheduling database is locked.
Current threads:
Thread default thread (2008f270) 1 : running
  Current vp is 0
  Join: mutex 200a12a8 (21), cv 200a12f8 (2)
  Sync. wait: mutex 200a1348 (22), cv 200a1398 (3)
  Start function 0 (0)
  Thread's last errno was 0
  Scheduling: priority 12, policy throughput
  Stack: 2ff7e490 (default stack) 
  Alerts: none pending, general delivery enabled, asynch delivery disabled
Thread null thread (200a9258) 2 : ready
  No current vp
  Join: mutex 200a9fc0 (23), cv 200aa010 (4)
  Sync. wait: mutex 200aa060 (24), cv 200aa0b0 (5)
  Start function 20071b34 (0)
  Thread's last errno was 0
  Scheduling: priority 0, policy idle
  Stack: 200cdd94 (base = 200ce000, guard = 200c2fff) [<-SP]
  Alerts: none pending, general delivery enabled, asynch delivery disabled
Mutexes:
Mutex default attr's mutex (200c0c18) 1, type fast, unlocked
Mutex attr sequence object (200a0c68) 2, type fast, unlocked
Mutex known attr list (200a0cb8) 3, type fast, unlocked
Mutex mutex sequence object (200a0d08) 4, type fast, unlocked
Mutex known mutex list (200a0d58) 5, type fast, unlocked
Mutex global lock (200a0da8) 6, type recursive, unlocked
Mutex global's internal lock (200a0df8) 7, type fast, unlocked
Mutex VM, small (200a0e48) 8, type fast, unlocked
Mutex VM, medium (200a0e98) 9, type fast, unlocked
Mutex VM, large (200a0ee8) 10, type fast, unlocked
Mutex VM, pool (200a0f38) 11, type fast, unlocked
Mutex per-thread context (200a0f88) 12, type fast, unlocked
Mutex cond sequence object (200a0fd8) 13, type fast, unlocked
Mutex known cond list (200a1028) 14, type fast, unlocked
Mutex mutex for delay (200a1078) 15, type fast, unlocked
Mutex atfork queue (200a1118) 16, type fast, unlocked
Mutex one time init (200a1168) 17, type fast, unlocked
Mutex stack mutex (200a11b8) 18, type fast, unlocked
Mutex stack sequence object (200a1208) 19, type fast, unlocked
Mutex thread sequence object (200a1258) 20, type fast, unlocked
Mutex for a TCB (200a12a8) 21, type fast, unlocked
Mutex for a TCB (200a1348) 22, type fast, unlocked
Mutex null thread (200a9fc0) 23, type fast, unlocked
Mutex for a TCB (200aa060) 24, type fast, unlocked
Mutex io database (200aaf08) 25, type fast, unlocked
Mutex dynamic io init (200aaf58) 26, type fast, unlocked
Mutex file mutex (200f3c70) 27, type fast, unlocked
Mutex file mutex (200f3d60) 28, type fast, locked by 1
Condition variables:
Condition variable cond for delay (200a10c8) 1
Condition variable for a TCB (200a12f8) 2
Condition variable for a TCB (200a1398) 3
Condition variable null thread (200aa010) 4
Condition variable for a TCB (200aa0b0) 5
Condition variable file read cv (200f3cc0) 6
Condition variable file write cv (200f3d10) 7
Condition variable file read cv (200f3db0) 8
Condition variable file write cv (200f3e00) 9
DCE Threads internal VM manager statistics:
 small (24 bytes): 1 allocated, 0 free
 medium (72 bytes): 40 allocated, 0 free
 large (3424 bytes): 3 allocated, 0 free
 2 things currently on general pool list
 2 zeroed allocations (88 bytes)
 3 syscalls for 466952 bytes (1 exact size), 0 attempts failed
 50 pool extractions; 47 split from larger packets
 2 pool returns; 0 merged with previous, 0 with next
 Lookaside scrounging: 0 small, 0 medium, 0 large
 0 sbrk alignments
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[11/10/93 public]
This won't get changed for 1.0.3. We'll look at it for 1.0.3a.

[3/3/94 public]

[3/3/94 public]
We're still trying to reproduce this.
Changed Resp. Engr's Company from `tarc' to `osf'



CR Number                     : 9396
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8396
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : cma_ux.c, cma_vp.c
Short Description             : fork reinitialization can fail in child
Reported Date                 : 11/8/93
Found in Baseline             : 1.0.3
Found Date                    : 11/8/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : threads/cma_ux.c, cma_vp.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/8/93 public]

One Line Description:
   OSDqa06239 fork reinitialization can fail in child

Full Description:

Related-file:::: Problem
 DESCRIPTION:  When a child thread is in cma_fork, its cleanup must be
 reordered.  In particular, mutex cleanup must be done before any other
 kind, because it's possible that the parent contained threads that
 were waiting on a mutex.  In the child, there are no other threads.
 Also, the child's vp state should be reinitialized early, because it's
 needed for any mach calls, including self-blocks, etc.
 
 REPRODUCIBLE:  Yes.
 
 
 TEST SOFTWARE DESCRIPTION:  Heavily modified cuvb_wrp_002.

Related-file::Added 930924 by wright:: /build/hiosfm/RCS/src/dce/src/threads/./cma_ux.c,v 7.3
 /build/hiosfm/RCS/src/dce/src/threads/./cma_ux.c,v 7.3
 wright 1993/09/24 20:31:11 +18 -5
 Reason:  OSDqa06239 fork reinitialization can fail in child
 Do mutex reinit much earlier, add vp reinit early.
 
     *** /tmp/ci.4842..cma_ux.c.4874.1	Fri Sep 24 16:31:14 1993
     --- /tmp/cma_ux.c.4874.2	Fri Sep 24 16:31:14 1993
     ***************
     *** 435,456 ****
       	/*
       	 * Reinitialize required data structures, and remove all other
       	 * threads from the known threads list in forked process.
       	 */
       #if (_CMA_OSIMPL_ == _CMA__OS_OSF) && _CMA_REENTRANT_CLIB_
     !     mach_init();
       #endif
       	/*
       	 * FIX-ME:
       	 *
       	 * This is inefficient. In each case, we need to clear state and
       	 * unlock the mutexes. The two are separated because the parent
       	 * post-fork processing also unlocks, but doesn't reinit. Still,
       	 * there's no need for two separate sets of calls: the reinit
       	 * functions should be implemented as a switch() with the clear case
     ! 	 * preceeding and falling through into the unlock case.
       	 */
       	cma__unset_kernel ();	
       	cma__int_unlock (cma__g_global_lock);
       
       #if (_CMA_OSIMPL_ == _CMA__OS_OSF) && _CMA_REENTRANT_CLIB_
       	/*
     --- 435,470 ----
       	/*
       	 * Reinitialize required data structures, and remove all other
       	 * threads from the known threads list in forked process.
       	 */
       #if (_CMA_OSIMPL_ == _CMA__OS_OSF) && _CMA_REENTRANT_CLIB_
     ! 	mach_init();
       #endif
       	/*
       	 * FIX-ME:
       	 *
       	 * This is inefficient. In each case, we need to clear state and
       	 * unlock the mutexes. The two are separated because the parent
       	 * post-fork processing also unlocks, but doesn't reinit. Still,
       	 * there's no need for two separate sets of calls: the reinit
       	 * functions should be implemented as a switch() with the clear case
     ! 	 * preceding and falling through into the unlock case.
       	 */
     +         /* The preceding comment (in the original OSF source) isn't
     + 	 * accurate for the kernel threads implementation, and even if it
     + 	 * were, WHO CARES?  The additional overhead is trivial in the
     + 	 * larger scheme of things.  You'd need to pass a second parameter
     + 	 * to determine whether this were the parent or the child, BTW.
     + 	 */
     + 
     +         /* We must reinit mutexes before doing any unlocks, because there
     + 	 * could be inherited waiters on the mutexes, and they don't exist
     + 	 * in the child, so don't try to wake them!
     + 	 */
     + 	cma__reinit_mutex (cma__c_reinit_postfork_clear);
     +         cma__reinit_self_vp ();
     + 
       	cma__unset_kernel ();	
       	cma__int_unlock (cma__g_global_lock);
       
       #if (_CMA_OSIMPL_ == _CMA__OS_OSF) && _CMA_REENTRANT_CLIB_
       	/*
     ***************
     *** 482,492 ****
       	cma__reinit_timer (cma__c_reinit_postfork_unlock);
       	cma__reinit_memory (cma__c_reinit_postfork_clear);
       	cma__reinit_memory (cma__c_reinit_postfork_unlock);
       	cma__reinit_signal (cma__c_reinit_postfork_clear);
       	cma__reinit_signal (cma__c_reinit_postfork_unlock);
     - 	cma__reinit_mutex (cma__c_reinit_postfork_clear);
       	cma__reinit_mutex (cma__c_reinit_postfork_unlock);
       	cma__reinit_attr (cma__c_reinit_postfork_clear);
       	cma__reinit_attr (cma__c_reinit_postfork_unlock);
       
       	/* don't rearrange the following unless you really know what
     --- 496,505 ----
 
Related-file::Added 930924 by ddts:: 
 /build/hiosfm/RCS/src/dce/src/threads/./cma_vp.c,v 7.6
 wright 1993/09/24 20:32:09 +140 -120
 Reason:  OSDqa06239 fork reinitialization can fail in child
 Rearrange vp reinit code, add self_reinit routine.
 
     *** /tmp/ci.4887..cma_vp.c.4925.1	Fri Sep 24 16:32:12 1993
     --- /tmp/cma_vp.c.4925.2	Fri Sep 24 16:32:12 1993
     ***************
     *** 155,266 ****
       
       /*
        * LOCAL MACROS
        */
       
     - /*
     -  * LOCAL FUNCTIONS
     -  */
       
       /*
        *  FUNCTIONAL DESCRIPTION:
        *
     !  *	initialize the VP layer
        *
        *  FORMAL PARAMETERS:
        *
     !  *	none
        *
        *  IMPLICIT INPUTS:
        *
     !  *	the current kernel thread
        *
        *  IMPLICIT OUTPUTS:
        *
     !  *	none
        *
        *  FUNCTION VALUE:
        *
     !  *	none
        *
        *  SIDE EFFECTS:
        *
     !  *	none
     !  * 
        */
     ! void
     ! cma__init_vp
       #ifdef _CMA_PROTO_
     ! 	(void)
       #else	/* no prototypes */
     ! 	()
       #endif	/* prototype */
           {
       #if _CMA_KTHREADS_ == _CMA__MACH
     !     kern_return_t	status;
     !     thread_t		virtual_processor;
     !     port_t		synch_port;
     !     cma__t_vstruct	*vp_struct;
     !     task_t		task;
       
     ! 
     !     task = task_self ();
     !     cma__trace ((
     ! 	    cma__c_trc_init | cma__c_trc_vp,
     ! 	    "(init_vp) running in task %d",
     ! 	    task));
       
     !     /*
     !      * Set up default VP
     !      */
     !     cma__queue_init (&cma___g_vp_queue);
     !     cma__queue_init (&cma___g_vp_cache);
     !     virtual_processor = thread_self ();
     !     status = port_allocate (task, &synch_port);
       
     !     cma__trace ((
       	    cma__c_trc_init | cma__c_trc_vp,
     ! 	    "(init_vp) running in vp %d, synch port is %d",
     ! 	    virtual_processor,
       	    synch_port));
       
     !     if (status != KERN_SUCCESS) {
     ! 	cma__trace ((
       		cma__c_trc_init | cma__c_trc_vp | cma__c_trc_bug,
     ! 		"(init_vp) error \"%s\" (%d) allocating def. VP synch port",
       		mach_error_string (status),
       		status));
     ! 	cma__bugcheck ("init_vp: port_allocate");
       	}
       
     !     status = port_disable (task, synch_port);
     !     if ((status != KERN_SUCCESS) && (status != KERN_NOT_IN_SET)) {
     ! 	cma__trace ((
       		cma__c_trc_init | cma__c_trc_vp | cma__c_trc_bug,
     ! 		"(init_vp) error \"%s\" (%d) disabling port %d",
       		mach_error_string (status),
       		status,
       		synch_port));
     ! 	cma__bugcheck ("init_vp: port_disable");
       	}
       
     !     if ((status = port_set_backlog (task, synch_port, 1)) != KERN_SUCCESS) {
     ! 	cma__trace ((
       		cma__c_trc_init | cma__c_trc_vp | cma__c_trc_bug,
     ! 		"(init_vp) error \"%s\" (%d) setting port %d backlog",
       		mach_error_string (status),
       		status,
       		synch_port));
     ! 	cma__bugcheck ("init_vp: port_set_backlog");
       	}
       
           vp_struct = cma__alloc_object (cma__t_vstruct);
     -     vp_struct->vp = virtual_processor;
     -     vp_struct->synch = synch_port;
     -     vp_struct->flags = cma__c_vp_running | cma__c_vp_default;
           cma__queue_insert (&vp_struct->queue, &cma___g_vp_queue);
           cma__queue_init(&vp_struct->stack);
       #endif
           }
       
       /*
        *  FUNCTIONAL DESCRIPTION:
     --- 155,309 ----
       
       /*
        * LOCAL MACROS
        */
       
       
       /*
        *  FUNCTIONAL DESCRIPTION:
        *
     !  *	cma___load_vp:  load a vp with mach values for current thread
     !  *      (the thread is assumed to be the inital thread of the process)
        *
        *  FORMAL PARAMETERS:
        *
     !  *	flag
        *
        *  IMPLICIT INPUTS:
        *
     !  *	None
        *
        *  IMPLICIT OUTPUTS:
        *
     !  *	None
        *
        *  FUNCTION VALUE:
        *
     !  *	None
        *
        *  SIDE EFFECTS:
        *
     !  *	None
        */
     ! static void
     ! cma___load_vp
       #ifdef _CMA_PROTO_
     ! 	(
     ! 	cma__t_int_tcb	*cur_tcb,
     ! 	cma__t_vpid	cur_vp)
       #else	/* no prototypes */
     ! 	(cur_tcb, cur_vp)
     ! 	cma__t_int_tcb	*cur_tcb;
     ! 	cma__t_vpid	cur_vp;
       #endif	/* prototype */
           {
       #if _CMA_KTHREADS_ == _CMA__MACH
     ! 	thread_t	self;
     ! 	kern_return_t	status;
     ! 	port_t		synch_port;
     ! 	task_t		task;
       
     ! 	/*
     ! 	 * Find out who we are, reload our vp
     ! 	 */
       
     ! 	task = task_self ();
     ! 	self = thread_self ();
     ! 	status = port_allocate (task, &synch_port);
       
     ! 	cma__trace ((
       	    cma__c_trc_init | cma__c_trc_vp,
     ! 	    "(load_vp) running in tcb %x, vpid %x, vp %d, synch is %d",
     ! 	    cur_tcb,
     ! 	    cur_vp,
     ! 	    self,
       	    synch_port));
       
     ! 	if (status != KERN_SUCCESS) {
     ! 	    cma__trace ((
       		cma__c_trc_init | cma__c_trc_vp | cma__c_trc_bug,
     ! 		"(load_vp) error \"%s\" (%d) allocating def. VP synch port",
       		mach_error_string (status),
       		status));
     ! 	    cma__bugcheck ("load_vp: port_allocate");
       	}
       
     ! 	status = port_disable (task, synch_port);
     ! 	if ((status != KERN_SUCCESS) && (status != KERN_NOT_IN_SET)) {
     ! 	    cma__trace ((
       		cma__c_trc_init | cma__c_trc_vp | cma__c_trc_bug,
     ! 		"(load_vp) error \"%s\" (%d) disabling port %d",
       		mach_error_string (status),
       		status,
       		synch_port));
     ! 	    cma__bugcheck ("load_vp: port_disable");
       	}
       
     ! 	if ((status = port_set_backlog (task, synch_port, 1)) != KERN_SUCCESS) {
     ! 	    cma__trace ((
       		cma__c_trc_init | cma__c_trc_vp | cma__c_trc_bug,
     ! 		"(load_vp) error \"%s\" (%d) setting port %d backlog",
       		mach_error_string (status),
       		status,
       		synch_port));
     ! 	    cma__bugcheck ("load_vp: port_set_backlog");
       	}
     + 	
     + 	cur_vp->vp = self;
     + 	cur_vp->synch = synch_port;
     + 	cur_vp->flags = cma__c_vp_running | cma__c_vp_default;
     + #endif
     +     }
     + /*
     +  * LOCAL FUNCTIONS
     +  */
     + 
     + /*
     +  *  FUNCTIONAL DESCRIPTION:
     +  *
     +  *	initialize the VP layer
     +  *
     +  *  FORMAL PARAMETERS:
     +  *
     +  *	none
     +  *
     +  *  IMPLICIT INPUTS:
     +  *
     +  *	the current kernel thread
     +  *
     +  *  IMPLICIT OUTPUTS:
     +  *
     +  *	none
     +  *
     +  *  FUNCTION VALUE:
     +  *
     +  *	none
     +  *
     +  *  SIDE EFFECTS:
     +  *
     +  *	none
     +  * 
     +  */
     + void
     + cma__init_vp
     + #ifdef _CMA_PROTO_
     + 	(void)
     + #else	/* no prototypes */
     + 	()
     + #endif	/* prototype */
     +     {
     + #if _CMA_KTHREADS_ == _CMA__MACH
     +     cma__t_vstruct	*vp_struct;
     + 
       
     +     cma__queue_init (&cma___g_vp_queue);
     +     cma__queue_init (&cma___g_vp_cache);
           vp_struct = cma__alloc_object (cma__t_vstruct);
           cma__queue_insert (&vp_struct->queue, &cma___g_vp_queue);
           cma__queue_init(&vp_struct->stack);
     + 
     +     cma___load_vp(NULL, vp_struct);
       #endif
           }
       
       /*
        *  FUNCTIONAL DESCRIPTION:
     ***************
     *** 290,300 ****
        *      this code was removed from the reinit_vp routine since it's
        *	needed twice
        *
        */
       #if _CMA_KTHREADS_ == _CMA__MACH
     ! static
       cma___del_vpid
       #ifdef _CMA_PROTO_
       	(
       	cma__t_queue	*qptr)
       #else	/* no prototypes */
     --- 333,343 ----
        *      this code was removed from the reinit_vp routine since it's
        *	needed twice
        *
        */
       #if _CMA_KTHREADS_ == _CMA__MACH
     ! static void
       cma___del_vpid
       #ifdef _CMA_PROTO_
       	(
       	cma__t_queue	*qptr)
       #else	/* no prototypes */
     ***************
     *** 337,346 ****
     --- 380,432 ----
       #endif
       
       /*
        *  FUNCTIONAL DESCRIPTION:
        *
     +  *	cma__reinit_self_vp:  post fork re-Initialize of vp data
     +  *
     +  *  FORMAL PARAMETERS:
     +  *
     +  *	None
     +  *
     +  *  IMPLICIT INPUTS:
     +  *
     +  *	None
     +  *
     +  *  IMPLICIT OUTPUTS:
     +  *
     +  *	None
     +  *
     +  *  FUNCTION VALUE:
     +  *
     +  *	None
     +  *
     +  *  SIDE EFFECTS:
     +  *
     +  *	vp of caller is reinitialized
     +  */
     + 
     + extern void
     + cma__reinit_self_vp
     + #ifdef _CMA_PROTO_
     + 	(void)
     + #else	/* no prototypes */
     + 	()
     + #endif	/* prototype */
     +     {
     + 	cma__t_int_tcb	*cur_tcb = cma__get_self_tcb();
     + 	cma__t_vpid	myvp = cur_tcb->sched.processor->vp_id;
     + 
     + 	
     + 	cma___load_vp(cur_tcb, myvp);
     +     }
     + 
     + 
     + 
     + /*
     +  *  FUNCTIONAL DESCRIPTION:
     +  *
        *	cma__reinit_vp:  Do pre/post fork re-Initialize 
        *
        *  FORMAL PARAMETERS:
        *
        *	flag
     ***************
     *** 382,472 ****
       	case cma__c_reinit_postfork_unlock : {
       	    cma__spinunlock (&cma___g_vp_lock);
       	    break;
       	    }
       	case cma__c_reinit_postfork_clear : {
     - 	    thread_t		self;
       	    cma__t_queue	*qptr;
       	    cma__t_int_tcb	*cur_tcb = cma__get_self_tcb();
       	    cma__t_vpid		myvp = cur_tcb->sched.processor->vp_id;
       
       	    /*
       	     * Remove all active VP structures, except for the VP that's
       	     * currently running.
       	     */
     - 	    self = thread_self ();
       	    qptr = cma__queue_next (&cma___g_vp_queue);
       
       	    while (qptr != &cma___g_vp_queue) {
       		cma__t_vpid	vptr = (cma__t_vpid)qptr;
       		cma__t_queue	*qnext = cma__queue_next (qptr);
       
     - 
       		if (vptr != myvp) {
       		    cma___del_vpid (qptr);
     - 		    /*
     - 		     * FIX-ME
     - 		     *
     - 		     * Need to determine whether ports are copied to a forked
     - 		     * task... if so, we need to port_deallocate() here, and
     - 		     * we don't need to allocate a new port for the current
     - 		     * VP (else clause).
     - 		     */
       		    }
     - 		else {
     - 		    kern_return_t	status;
     - 		    port_t		synch_port;
     - 		    task_t		task;
     - 		    thread_t		self;
     - 
     - 
     - 		    task = task_self ();
     - 		    self = thread_self ();
     - 		    status = port_allocate (task, &synch_port);
     - 
     - 		    cma__trace ((
     - 			    cma__c_trc_init | cma__c_trc_vp,
     - 			    "(reinit_vp) running in thread %x, vpid %x, vp %d, synch is %d",
     - 			    cur_tcb,
     - 			    myvp,
     - 			    self,
     - 			    synch_port));
     - 
     - 		    if (status != KERN_SUCCESS) {
     - 			cma__trace ((
     - 				cma__c_trc_init | cma__c_trc_vp | cma__c_trc_bug,
     - 				"(reinit_vp) error \"%s\" (%d) allocating def. VP synch port",
     - 				mach_error_string (status),
     - 				status));
     - 			cma__bugcheck ("reinit_vp: port_allocate");
     - 			}
     - 
     - 		    status = port_disable (task, synch_port);
     - 		    if ((status != KERN_SUCCESS) && (status != KERN_NOT_IN_SET)) {
     - 			cma__trace ((
     - 				cma__c_trc_init | cma__c_trc_vp | cma__c_trc_bug,
     - 				"(reinit_vp) error \"%s\" (%d) disabling port %d",
     - 				mach_error_string (status),
     - 				status,
     - 				synch_port));
     - 			cma__bugcheck ("reinit_vp: port_disable");
     - 			}
     - 
     - 		    if ((status = port_set_backlog (task, synch_port, 1)) != KERN_SUCCESS) {
     - 			cma__trace ((
     - 				cma__c_trc_init | cma__c_trc_vp | cma__c_trc_bug,
     - 				"(reinit_vp) error \"%s\" (%d) setting port %d backlog",
     - 				mach_error_string (status),
     - 				status,
     - 				synch_port));
     - 			cma__bugcheck ("reinit_vp: port_set_backlog");
     - 			}
     - 
     - 		    vptr->vp = self;
     - 		    vptr->synch = synch_port;
     - 		    vptr->flags = cma__c_vp_running | cma__c_vp_default;
     - 		    }
       
       		qptr = qnext;
       		}
       
       	    /*
     --- 468,494 ----
     ***************
     *** 476,488 ****
       
       	    while (qptr != &cma___g_vp_cache) {
       		cma__t_vpid	vptr = (cma__t_vpid)qptr;
       		cma__t_queue	*qnext = cma__queue_next (qptr);
       
     - 
       		cma___del_vpid (qptr);
     - 
       		qptr = qnext;
       		}
       
       	    cma__spinunlock (&cma___g_vp_lock);
       	    break;
     --- 498,508 ----



CR Number                     : 9393
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : 
Short Description             : cma_sigwait does not work correctly for kernel threads
Reported Date                 : 11/8/93
Found in Baseline             : 1.0.3
Found Date                    : 11/8/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/8/93 public]

problem description:

 Hitachi uses the information in the prorting and testing guide (Threads
 Preprocessor Variables) to build cma threads for execution in kernel
 on a multiprocessor. Whether or not this is recommended, or supported is
 in doubt, but at least we should capture the problems they are having.
 They report:

 The cma_sigwait function does not work properly in a kernel threads
 environment.  The cma__sig_deliver function assumes that it is
 sufficient to set a flag that will be seen by the next CMA kernel
 entry or exit.  This is not true for kernel threads.

 Reason:  suppose we have main thread t0 and child thread t1.  t1 does
 a cma_sigwait() and t0 is also sleeping.  The desired signal occurs.
 Thread t0 wakes up, the signal handler sets the flag and goes back to
 sleep.  Nobody goes through the kernel!

Proposed Solution:

 when the signal handler runs, it must attempt to enter the
 kernel.  If it can, it does the wakeup directly and returns.  If it
 can't, set the flag and again try to enter the kernel.  (Setting the
 flag alone is not sufficient -- there's a timing window that way.)

 As an additional Fun Thing, the locking in this code is not
 sufficient; there are windows, which requires rearranging some of the
 locking to close the windows.  This revolves around the sigprocmask
 calls, which must be globally locked (only one signal mask per
 process, not one per thread).  I got rid of the usage of the
 tcb->tswait_mutex, which isn't used with kernel threads anyway, and
 use the global sigwait mutex instead.

     *** /cma_signal.c
     --- /new/cma_signal.c
     ***************
     *** 747,766 ****
           static sigaction_t       sig_oact[NSIG];
       #endif

           cma__int_init ();

     - #if (_CMA_OSIMPL_ == _CMA__OS_OSF)
     -     /* OSF/1 signal semantics do not allow other than the main thread to
     -      * do a sigwait, since only thread 0 will receive asynchronous signals,
     -      * and it's not meaningful to sigwait() for synchronous signals.
     -      */
     -
     -     if (cma__get_self_tcb () != &cma__g_def_tcb)
     -      return (cma__set_errno (EINVAL), -1);
     - #endif
     -
           /*
            * For each signal, check to see if it is set in the user's mask.  If it is
            * also set in the "illegal values" mask, or if it is not set in the current
            * mask, then return an error.  Also, if there are no signals set in the
            * user's mask, return an error.
     --- 747,756 ----
     ***************
     *** 796,809 ****
           wblk.cv  = wblk.tcb->tswait_cv;

           /*
            * FIX-ME:  On VMS this should probably block ASTs
            */
           if (sigprocmask (SIG_BLOCK, &cma___g_sig_block_mask, &sig_mask) == -1)
        cma__bugcheck ("sigwait:2");

     -     cma__int_lock (cma___g_sigwait_mutex);
           cma__queue_insert ((cma__t_queue *)&wblk.queue, &cma___g_sigwait_queue);

           /*
            * Install the appropriate DECthreads signal handler for each signal that
            * the thread is waiting for, provided that we don't currently have a

     --- 786,800 ----
           wblk.cv  = wblk.tcb->tswait_cv;

           /*
            * FIX-ME:  On VMS this should probably block ASTs
            */
     +     cma__int_lock (cma___g_sigwait_mutex);
     +
           if (sigprocmask (SIG_BLOCK, &cma___g_sig_block_mask, &sig_mask) == -1)
        cma__bugcheck ("sigwait:2");

           cma__queue_insert ((cma__t_queue *)&wblk.queue,&cma___g_sigwait_queue);

           /*
            * Install the appropriate DECthreads signal handler for each signal that
            * the thread is waiting for, provided that we don't currently have a

     ***************
     *** 840,851 ****
             * signal handlers, etc.
             */
            cma___g_sigwaiters[i]++;
            }

     -     cma__int_unlock (cma___g_sigwait_mutex);
     -
           /*
            * Reenable the previously enabled signals, and then reenable the signals
            * that this thread is waiting for.
            *
            * FIX-ME:  On VMS this should probably unblock ASTs
     --- 831,840 ----
     ***************
     *** 854,882 ****
        cma__bugcheck ("sigwait:5");

           if (sigprocmask (SIG_UNBLOCK, set, (sigset_t *)cma_c_null_ptr) == -1)
        cma__bugcheck ("sigwait:6");

     -     cma__int_lock (wblk.tcb->tswait_mutex);
     -
           TRY {
        if (wblk.signal == -1)
            while (wblk.signal == -1)
     !          cma__int_wait (wblk.tcb->tswait_cv,wblk.tcb->tswait_mutex);
        else
            cma__attempt_delivery (wblk.tcb);
        }
           FINALLY {
     -  cma__int_unlock (wblk.tcb->tswait_mutex);
     -
        /*
         * FIX-ME:  On VMS this should probably block ASTs
         */
        if (sigprocmask (SIG_BLOCK, &cma___g_sig_block_mask, &sig_mask) == -1)
            cma__bugcheck ("sigwait:7");

     -  cma__int_lock (cma___g_sigwait_mutex);
       #if (_CMA_PLATFORM_ == _CMA__SINIX_MX300I)
        /*
        * FIX-ME:
        *       The compilers (/usr/ccs/bin/cc, /usr/ces/bin/cc) both have
        *       problems with taking the address of wblk.queue because it
     --- 843,866 ----
        cma__bugcheck ("sigwait:5");

           if (sigprocmask (SIG_UNBLOCK, set, (sigset_t *)cma_c_null_ptr) == -1)
        cma__bugcheck ("sigwait:6");

           TRY {
        if (wblk.signal == -1)
            while (wblk.signal == -1)
     !          cma__int_wait (wblk.tcb->tswait_cv, cma___g_sigwait_mutex);
        else
            cma__attempt_delivery (wblk.tcb);
        }
           FINALLY {
        /*
         * FIX-ME:  On VMS this should probably block ASTs
         */
        if (sigprocmask (SIG_BLOCK, &cma___g_sig_block_mask, &sig_mask) == -1)
            cma__bugcheck ("sigwait:7");

       #if (_CMA_PLATFORM_ == _CMA__SINIX_MX300I)
        /*
        * FIX-ME:
        *       The compilers (/usr/ccs/bin/cc, /usr/ces/bin/cc) both have
        *       problems with taking the address of wblk.queue because it
     ***************
     *** 912,931 ****
                        cma__bugcheck ("sigwait:9");
                    }
       #endif
                }

     -  cma__int_unlock (cma___g_sigwait_mutex);
     -
        /*
         * FIX-ME:  On VMS this should probably unblock ASTs
         */
        if (sigprocmask (SIG_SETMASK, &sig_mask, (sigset_t *)cma_c_null_ptr)
                == -1)
            cma__bugcheck ("sigwait:11");

        }
           ENDTRY

           return wblk.signal;
           }
       ^L
     --- 896,916 ----
                        cma__bugcheck ("sigwait:9");
                    }
       #endif
                }

        /*
         * FIX-ME:  On VMS this should probably unblock ASTs
         */
        if (sigprocmask (SIG_SETMASK, &sig_mask, (sigset_t *)cma_c_null_ptr)
                == -1)
            cma__bugcheck ("sigwait:11");

     +  cma__int_unlock (cma___g_sigwait_mutex);
     +
        }
     +
           ENDTRY

           return wblk.signal;
           }
       ^L
     ***************
     *** 1683,1693 ****
     --- 1668,1695 ----
        wblk = (cma___t_sigwait_block *)cma__queue_next (&wblk->queue);
        }

           if (wblk != (cma___t_sigwait_block*)&cma___g_sigwait_queue) {
        wblk->signal = sig;
     + #if !_CMA_THREAD_IS_VP_
               cma__int_signal_int (wblk->cv);
     + #else
     +  /* if we can enter the kernel, do so and wake someone up.  If we
     +   * can't enter the kernel, we just record this guy's presence;
     +   * whoever is in the kernel should do the wakeup -- UNLESS they
     +   * get out while we're doing this, so we check again after we
     +   * do the int_signal_int.
     +   */
     +  if (cma__tryenter_kernel()) {
     +             cma__int_signal_int (wblk->cv);      /* already locked */
     +      if (cma__tryenter_kernel())
     +                 cma__exit_kernel();              /* close a window */
     +         } else {
     +             cma__sem_iwake_one (&(wblk->cv->semaphore));
     +             cma__exit_kernel();
     +         }
     + #endif
        return cma_c_true;
        }
           else
        if (resend) {
       #if _CMA_OS_ == _CMA__VMS



CR Number                     : 9392
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : 
Short Description             : compilation problems in thread tests
Reported Date                 : 11/8/93
Found in Baseline             : 1.0.3
Found Date                    : 11/8/93
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 
Affected File(s)              : test/threads/crvb_thd_010.c,crvb_alt_003.c,prvb_can_003.c,prvb_thd_006.c,prrb_thd_001.c
Sensitivity                   : public

[11/8/93 public]

The following problems were reported to be preventing ANSI C compilation
of some of the thread tests. Proposed solutions are included.
_______________
crvb_thd_010.c
_______________
     *** /crvb_thd_010.c
     --- /new/crvb_thd_010.c
     ***************
     *** 145,156 ****
            */

           cma_thread_create (
                       &thread1,
                       &attr,
     !                 thread_routine,
     !                 cma_c_null_ptr);

           /*
            * Set flag to LOW and changed default threads priority to fifo/low.
            * This should allow the created thread to run and return LOW. Then
            * return default thread to fifo/high and change the flag value.
     --- 145,156 ----
            */

           cma_thread_create (
                       &thread1,
                       &attr,
     !                 (cma_t_start_routine)thread_routine,
     !                 (cma_t_address)cma_c_null_ptr);

           /*
            * Set flag to LOW and changed default threads priority to fifo/low.
            * This should allow the created thread to run and return LOW. Then
            * return default thread to fifo/high and change the flag value.
     ***************
     *** 166,180 ****
            * Join with the created thread expecting a result value of LOW.
            */

           cma_thread_join (&thread1, &exit, &result);

     !     if (result == HIGH)
             cts_failed ("Created thread allowed to run, despite lower priorit\n");
     !     else if (result == END)
             cts_failed ("Created thread did not run during priority change\n");
     !     else if (result != LOW)
             cts_failed ("Unknown failure, did not get expected return value\n");

           cts_result ();

           }
     --- 166,180 ----
            * Join with the created thread expecting a result value of LOW.
            */

           cma_thread_join (&thread1, &exit, &result);

     !     if ((cma_t_integer)result == HIGH)
             cts_failed ("Created thread allowed to run, despite lower priorit\n");
     !     else if ((cma_t_integer)result == END)
             cts_failed ("Created thread did not run during priority change\n";
     !     else if ((cma_t_integer)result != LOW)
             cts_failed ("Unknown failure, did not get expected return value\n");

           cts_result ();

           }
_______________
crvb_alt_003.c
________________
     *** /crvb_alt_003.c
     --- /new/crvb_alt_003.c
     ***************
     *** 291,301 ****
        _CMA_VOLATILE_ cts_timebuf_t    *t2;
       #endif   /* prototype */
           {
           cma_t_integer        sec, ms;

     !  return (cts_timediff(t1, t2));

           }
       /*  DEC/CMS REPLACEMENT HISTORY, Element CRVB_ALT_003.C */
       /*  *4    12-FEB-1991 01:30:45 BUTENHOF "Changes to alert control" */
       /*  *3     5-SEP-1990 09:39:41 BUTENHOF "Convert to new CMA interfaces" */
     --- 291,301 ----
        _CMA_VOLATILE_ cts_timebuf_t    *t2;
       #endif   /* prototype */
           {
           cma_t_integer        sec, ms;

     !  return ((cma_t_interval)cts_timediff((cts_timebuf_t *)t1,(cts_timebuf_t *)t2));

           }
       /*  DEC/CMS REPLACEMENT HISTORY, Element CRVB_ALT_003.C */
       /*  *4    12-FEB-1991 01:30:45 BUTENHOF "Changes to alert control" */
       /*  *3     5-SEP-1990 09:39:41 BUTENHOF "Convert to new CMA interfaces" */
______________
prvb_can_003.c
______________

     *** /prvb_can_003.c
     --- /new/prvb_can_003.c
     ***************
     *** 324,334 ****
        (t1, t2)
        _CMA_VOLATILE_ cts_timebuf_t    *t1;
        _CMA_VOLATILE_ cts_timebuf_t    *t2;
       #endif   /* prototype */
           {
     !  return (cts_timediff(t1, t2));
           }
       /*  DEC/CMS REPLACEMENT HISTORY, Element PRVB_CAN_003.C */
       /*  *4    17-JUN-1991 11:41:03 BUTENHOF "Fix compilation warnings" */
       /*  *3    12-FEB-1991 01:35:04 BUTENHOF "Changes to alert control" */
       /*  *2     7-SEP-1990 09:06:41 BUTENHOF "Remove CMA-isms from pthread tests" */
     --- 324,334 ----
        (t1, t2)
        _CMA_VOLATILE_ cts_timebuf_t    *t1;
        _CMA_VOLATILE_ cts_timebuf_t    *t2;
       #endif   /* prototype */
           {
     !  return (cts_timediff((cts_timebuf_t *)t1, (cts_timebuf_t *)t2));
           }
       /*  DEC/CMS REPLACEMENT HISTORY, Element PRVB_CAN_003.C */
       /*  *4    17-JUN-1991 11:41:03 BUTENHOF "Fix compilation warnings" */
       /*  *3    12-FEB-1991 01:35:04 BUTENHOF "Changes to alert control" */
       /*  *2     7-SEP-1990 09:06:41 BUTENHOF "Remove CMA-isms from pthread tests" */
______________
prvb_thd_006.c
______________

     *** /prvb_thd_006.c.9723
     --- /new/prvb_thd_006.c
     ***************

     ***************
     *** 167,176 ****
     --- 167,180 ----

       #if _CMA_UNIX_TYPE == _CMA__SVR4
       #define min_iterations   100000
       #endif

     + #ifndef min_iterations
     + #define min_iterations   100000
     + #endif
     +

       unsigned int     start = 0, quit[thread_count], maybe_done = 0;
       pthread_mutex_t  smutex, maybe_done_mutex, qmutex[thread_count];
       pthread_cond_t   start_cv, maybe_done_cv;

     ***************
     *** 278,295 ****
        }

           status = pthread_cond_init  (&start_cv,pthread_condattr_default);
           check(status,"pthread_cond_init");

           for (i = 0; i < thread_count; i++)
        status = pthread_create (
                &threads[i],
                attr,
     !          thread,
                (pthread_addr_t)i);
        check(status,"pthread_create");
     
           fprintf (stderr, "Starting...");
           status = pthread_mutex_lock (&smutex);
           check(status,"pthread_mutex_loc");
           start = 1;
           status = pthread_mutex_unlock (&smutex);
     --- 282,299 ----
        }

           status = pthread_cond_init  (&start_cv,pthread_condattr_default);
           check(status,"pthread_cond_init");

           for (i = 0; i < thread_count; i++) {
        status = pthread_create (
                &threads[i],
                attr,
     !          (pthread_startroutine_t)thread,
                (pthread_addr_t)i);
        check(status,"pthread_create");
     
        }
           fprintf (stderr, "Starting...");
           status = pthread_mutex_lock (&smutex);
           check(status,"pthread_mutex_loc");
           start = 1;
           status = pthread_mutex_unlock (&smutex);
______________
prrb_thd_001.c
______________

     *** /prrb_thd_001.c
     --- /new/prrb_thd_001.c
     ***************
     *** 58,68 ****
        pthread_t self;

        self = pthread_self();
        pthread_detach(&self);
        if (method)
     !          pthread_exit(1);
        else
                return (0);
       }

       pthread_mutex_t parent_mutex;
     --- 58,68 ----
        pthread_t self;

        self = pthread_self();
        pthread_detach(&self);
        if (method)
     !          pthread_exit((pthread_addr_t)1);
        else
                return (0);
       }

       pthread_mutex_t parent_mutex;
     ***************
     *** 75,85 ****
        pthread_t ct[MAXSIMCHILD];

        for (cnt = 0; cnt < ITERS; ++cnt) {
                for (ccnt = 0; ccnt < G_simchild; ++ccnt) {
                        if (pthread_create(&ct[ccnt],
     !                          pthread_attr_default, child, number & 1) == -1) {
                                cts_failed("parent %d failed on %dth ", number, cnt);
                                perror("child create");
                                return (1);
                        }
                }
     --- 75,86 ----
        pthread_t ct[MAXSIMCHILD];

        for (cnt = 0; cnt < ITERS; ++cnt) {
                for (ccnt = 0; ccnt < G_simchild; ++ccnt) {
                        if (pthread_create(&ct[ccnt],
     !                          pthread_attr_default, (pthread_startroutine_t)child,
     !                          (pthread_addr_t)(number & 1)) == -1) {
                                cts_failed("parent %d failed on %dth ", number, cnt);
                                perror("child create");
                                return (1);
                        }
                }
     ***************
     *** 117,127 ****
        if (2 < ac)
                G_simchild = atoi(av[1]);
        if (MAXSIMCHILD < G_simchild)
                G_simchild = MAXSIMCHILD;
        for (p = 1; p <= parents; ++p) {
     !          if (pthread_create(&pt, pthread_attr_default, parent, p) == -1) {
                        perror("can't create");
                        exit(1);
                }
                cts_comment("parent %d created", p);
        }
     --- 118,128 ----
        if (2 < ac)
                G_simchild = atoi(av[1]);
        if (MAXSIMCHILD < G_simchild)
                G_simchild = MAXSIMCHILD;
        for (p = 1; p <= parents; ++p) {
     !          if (pthread_create(&pt, pthread_attr_default, (pthread_startroutine_t)parent, (pthread_addr_t)p) == -1) {
                        perror("can't create");
                        exit(1);
                }
                cts_comment("parent %d created", p);
        }



CR Number                     : 9341
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : Namespace pollution caused by wrapper definition
Reported Date                 : 11/3/93
Found in Baseline             : 1.0.2a
Found Date                    : 11/3/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cmalib_crtlx.h
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[11/3/93 public]
The wrapper for free is defined as follows:
#define free cma_lib_free
This prevents me from defining a structure member named "free".
This is a surprising and unreasonable restriction.  It could be avoided
by using:
#define free(p) cma_lib_free(p)
Likewise for various other wrappers in the same file.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[11/3/93 public]
Changed H/W Ref Platform from `hppa' to `all' 
Changed S/W Ref Platform from `hpux' to `all' 
Changed Component Name from `dfs' to `thr'



CR Number                     : 9334
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : CMA does not handle EAGAIN
from select/poll
Reported Date                 : 11/3/93
Found in Baseline             : 1.0.3
Found Date                    : 11/3/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[11/3/93 public]

Licensee reported:

" select(3C) on AIX and poll(2) on SVR4 can return EAGAIN when
  system, under stress, runs out of memory resources. This happened
  on penguin ( FTX machine ) - I was able to verify from crash(1M)
  that some kernel memory allocation failed. From secd core dump
  below it seems to have died under these conditions.

# sdb /opt/dcelocal/bin/secd core
no source file
0x8101ca58   (_kill+0x8)                bc      12865 <81029360>  [_cerror]
*t
_kill()
cma__abort_process(abort_signal=6)      [cma_signal.c:885]
cma__bugcheck(text="cma__io_available: unexpected select error")  [cma_errors.c:299]
cma__io_available(function=cma__c_io_read,fd=0,timeout=0xefcc4)   [cma_thread_io.c:789]
cma___null_thread()     [cma_dispatch.c:2406]
cma__thread_base()      [cma_thread.c:1381]
*errno
Assuming :errno is int
:errno/0xb


Repeat By:

Proposed Solution:

        Two options exist.

        - One is to have the operation retried, in the hope that the
          condition is temporary.

        - The other is to leave it the way it is - because retrying
          may exacerbate the situation and the system could take longer
          to recover.

        I'd recommend the first option, as this condition will be
        noticed outside of CMA, which I think is a better place
        to handle the situation and perhaps gracefully shutdown.
"



CR Number                     : 9281
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : cma__int_cond_delete macro should not return
Reported Date                 : 10/28/93
Found in Baseline             : 1.0.3
Found Date                    : 10/28/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/threads/cma_condition.h
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/28/93 public]

The cma__int_cond_delete macro contains a return without a return value.
This macro is used by two functions and 1 proceedure. In the case of the
functions, pthread_cond_destroy and ptdexc_cond_destroy, execution of the
return statement in the macro, will cause an unspecified return value
to be seen by the caller.

Proposed solution:

The return statement should be eliminated from the macro. The following
modification will correct the problem and allow the existing uses of the
macro to remain unchanged.

     ***************
     *** 343,358 ****
        *       none
        */
       #define cma__int_cond_delete(_condition_) { \
           cma__t_int_cv       *_int_cv_; \
           (_int_cv_) = cma__validate_null_cv (_condition_); \
     !     if ((_int_cv_) == (cma__t_int_cv *)cma_c_null_ptr) \
     !         return; \
     !     if (cma__cv_waiting ((_condition_))) \
     !         cma__error (cma_s_in_use); \
     !     cma__free_cv (_int_cv_); \
     !     cma__clear_handle (_condition_); \
           }
       ^L
       /*
        *  FUNCTIONAL DESCRIPTION:
        *
     --- 343,358 ----
        *       none
        */
       #define cma__int_cond_delete(_condition_) { \
           cma__t_int_cv       *_int_cv_; \
           (_int_cv_) = cma__validate_null_cv (_condition_); \
     !     if ((_int_cv_) != (cma__t_int_cv *)cma_c_null_ptr) { \
     !  if (cma__cv_waiting ((_condition_))) \
     !          cma__error (cma_s_in_use); \
     !  cma__free_cv (_int_cv_); \
     !  cma__clear_handle (_condition_); \
     !  }       \
           }
       ^L
       /*
        *  FUNCTIONAL DESCRIPTION:
        *



CR Number                     : 9280
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : 
Short Description             : if _CMA_THREAD_IS_VP_ cma__int_make_thread does not int mem from cma__alloc_object
Reported Date                 : 10/28/93
Found in Baseline             : 1.0.3
Found Date                    : 10/28/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cma_thread.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/28/93 public]

if _CMA_THREAD_IS_VP_ cma__int_make_thread calls cma__alloc_object to
allocate a cma__t_vp structure. However, cma__int_make_thread neglects
to initialize the contents of the returned structure. This leads to some
very weird results when later code concludes that the garbage values in
the structures are queue pointers or vp_id's.

Proposed solution:

     * Create a runnable thread:  Initialize the stack and context, and
     * notify the scheduler
     */
#if _CMA_THREAD_IS_VP_
    /*
     * If we have kernel threads, and we're enforcing one-to-one mapping,
     * then create a new VP for the thread.
     */
    if ((cma_t_address)tcb->sched.processor == cma_c_null_ptr) {
	vp = cma__alloc_object (cma__t_vp);

	if ((cma_t_address)vp == cma_c_null_ptr)
	    return cma_c_false;

     +  vp->current_thread = NULL;
     +  vp->vp_id = 0;
     +  cma__queue_zero(&vp->interrupts);
     +
	tcb->sched.processor = vp;
	}
    else



CR Number                     : 9278
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : 
Short Description             : prvb_thd_006 hangs on kernel threads
Reported Date                 : 10/27/93
Found in Baseline             : 1.0.3
Found Date                    : 10/27/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cma_condition.h
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/27/93 public]

They are porting DCE threads to OSF1 kernel threads, and reported a
hang in prvb_thd_006. They traced the problem to the misordering
of the unlock and enter kernel calls in cma__wait (cma__timed_wait
also unlocks the mutex before entering the kernel). These calls are
apparently reversed in order to prevent a deadlock related to the
enter kerenel (the unlock call will default to a NOOP if called
after the enter_kernel. The result is that a window of opportunity
is opened in which a thread which has committed to wait on a condition
variable can be interrupted by another thread which signals the condition
variable. In an early implementation of threads, this last minute signal
would not be percieved by the waiter, it would proceed to wait in some
cases never to awaken again. To correct for this problem, the nopending
bit was added which is basically a last chance for the about to wait
thread to reconsider it's decision to wait. If this bit is cleared, it
means that a late arriving signal did arrive, and the thread should
not wait.

Given this background, this OT is being written to make two points.

1. OSF should take the time to make DCE threads work on OSF1
   kernel threads. Some of the threads code is partially set up
   to build for kernel threads based on compile time constants
   documented in the porting and testing guide. We should probably
   follow through on this ourselves. The porting and testing guide
   should give better guidance as to how to do this. In particular,
   we probably want to recommend that someone trying to run DCE
   on kernel threads, get at the kernel threads via the pthread
   interface, without any effort at porting DCE user space threads
   into the kernel. This is in constrast to the strategy implied
   by the compiler constants described in the porting and
   testing guide.

2. Although I haven't been able to prove it, the nopending bit
   functionality is not robust enough to correct for the race
   condition introduced by the misordering of the unlock and
   enter_kernel operations of cma__wait (I don't think it can
   deal with more than one waiter being interrupted in the
   race area; a rare but possible scenario). The threads package
   should be modified to eliminate this race condition and
   obviate the need for the nopending hack and it's consequences
   (including the infamous spurios wakeup).



CR Number                     : 8669
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : 
Short Description             : Too many select calls
Reported Date                 : 9/23/93
Found in Baseline             : 1.0.2a
Found Date                    : 6/09/93
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/23/93 public]

Adding an extra cma__io_available call in cma_dispatch.c by jd on 
April 07, 1993 has caused excessive select/sendmsg/recvmsg calls and 
thus degraded rpc performance as documented by hsiao on June 09, 1993. 

Note that John's fix was to prevent a DFS starvation problem and thus
we cannot just take that extra cma__io_available call away to fix this 
problem.



CR Number                     : 8667
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : threads/cma_thdio_4.c
Short Description             : cma_connect returns values
other than 0 or -1
Reported Date                 : 9/23/93
Found in Baseline             : 1.0.2
Found Date                    : 9/23/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/23/93 public]

The licensee reported:

        cma_connect will return values other than 0 or -1.  It will frequently
        return the value returned by select.


Checking the code indicates that when cma_select returns a positive number
(the number of descriptor ready) and the descriptor is for write,
cma_connect will simply return the return value of cma_select, a positive
number. connect semantics requires that return be either 0 or -1.

To show the problem, run the following test code (link with -ldce so that
cma stuff is used). You also need to have a small server code running on 
another host waiting to be connected (on the same port). Here is what returns 
on my sparc:

$ conn pierrot
connection completed: errno is 36, connect returned 1

(errno 36: EINPROGRESS /* Operation now in progress */)

(If you need the server code, please let me know).

#include <sys/types.h>
#include <sys/time.h>
#include <sys/signal.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <sys/errno.h>
#include <stdio.h>
#include <sys/filio.h>
#include <dce/cma.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#define DEFAULT_PORT        22979

#define bcopy(s,d,l)    memcpy(d,s,l)
#define bzero(a,l)  memset(a,0,l)

char *Progname;
int Verbose = 0;

extern int errno;

void
connect_test( host, port )
    char *host;
    int port;
{
    int sock;
    struct sockaddr_in servaddr;
    struct hostent *hostp;
    extern struct hostent *gethostbyname();
    int flag = 1;
    int connect_complete = 0;
    int serr = 0;

    if ( (sock = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP ) ) == -1) {
        fprintf( stderr, "errno %d: ", errno );
        perror("socket");
        fflush( stderr );
    } else if ( ioctl( sock, FIONBIO, &flag ) == -1 ) {
        fprintf( stderr, "errno %d: ", errno );
        perror("ioctl");
        fflush( stderr );
        close( sock );
    } else if ( !(hostp = gethostbyname( host )) ) {
        fprintf( stderr, "%s: TCP test: host %s unknown\n", Progname, host );
        fflush( stderr );
        close( sock );
    } else {
        bzero( &servaddr, sizeof( servaddr ) );
        servaddr.sin_family = AF_INET;
        bcopy( hostp->h_addr, &servaddr.sin_addr, hostp->h_length );
        servaddr.sin_port = port;
        while ( !connect_complete ) {
            if ( (serr = connect( sock, &servaddr, sizeof( servaddr ) ))
                == -1 ) {
                    switch ( errno ) {
                        case EINTR:
                            break;
                        default:
                            connect_complete = 1;
                            fprintf( stderr, "errno %d: ", errno );
                            perror( "connect" );
                            fflush( stderr );
                            break;
                }
            } else {
                connect_complete = 1;
            }
        }
        printf( "connection completed: errno is %d, connect returned %d\n",
            errno, serr );
        shutdown( sock );
        close( sock );
    }
    return;
}

usage()
{
    fprintf( stderr, "usage: %s hostname\n", Progname );
    exit( -1 );
}

main( argc, argv )
    int argc;
    char **argv;
{
    char *argp;
    int port = DEFAULT_PORT;
    int err = -1;

    Progname = *argv++;
    if ( --argc ) {
        connect_test( *argv, port );
    } else {
        fprintf( stderr, "%s: missing host name\n", Progname );
    }
    return( err );
}



CR Number                     : 8504
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : EINTR handling in CMA
Reported Date                 : 8/24/93
Found in Baseline             : 1.0.2
Found Date                    : 8/24/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/24/93 public]

CMA does not retry when sys calls return -1 with error code set to EINTR.
Instead, an error is returned to the user application.

This happens mostly to the cma jacket routine (for SVR4, it also happens to
fcntl and fstat which CMA uses directly. But the problem with fcntl and
fstat is SVR4 specific). 

The comments from cma__ts_open() in cma_thread_io.h:

     * FIX-ME: for the time being, if the I/O operation returns EINTR, we
     *      simply return it to the caller; eventually, we should catch this
     *      and "do the right thing" (if we can figure out what that is).

suggests that EINTR should be caught.

This OT is opened so that we don't forget this issue.



CR Number                     : 8495
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : flock/fcntl
Short Description             : Use of non-thread safe file
locking calls in the security code may be causing process deadlock.
Reported Date                 : 8/20/93
Found in Baseline             : 1.0.2
Found Date                    : 8/20/93
Severity                      : A
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/20/93 public]

The DME development group using dce1.0.2 code have run into process
deadlock under the following scenario. This is probably caused by the use
of non-thread safe file locking calls (flock or fcntl) in the security
code. The current threads package has a wrapper for fcntl call, but does 
not provide file locking operations. This particular call is in the 
fcc_maybe.c file. It may require to be wrapped with either a mutex or a 
global lock. Here is the info from the DME developer.
----------------------------------------------------------------------
I have a multithread client wherein many of the threads
are doing RPC's using the same sec_login_handle_t. (ie, calling
rpc_binding_set_auth_info() with ptrs to the same
sec_login_handle_t).  Is this OK?

I see strange behaviour in this process including a "hang" with
rpc_binding_set_auth_info().  The process is stuck in an flock(),
here is the stack of one of the stuck threads,  I don't know
how to view the stacks of the other CMA threads in gdb....

#0  0xa403fb18 in flock ()
#1  0xa43c154c in fcc_lock_file (8457480, 24, 0)
#2  0xa43c17ab in krb5_fcc_open_fileOB (10150528, 2)
#3  0xa43c3128 in krb5_fcc_store (10150528, 10156200)
#4  0xa43c9ce7 in krb5_get_credentials (16, 10150528, 10156200)
#5  0xa42fecf2 in sec_krb_get_cred (5346984, 10478640, 5, 2, 10304520,
7863104)
#6  0xa4228157 in rpc__krb_get_tkt (10304440)
#7  0xa42285f7 in rpc__krb_bnd_set_auth
    (10269176, 5, 5346984, 2, 10157736, 7863200, 7863612)
#8  0xa41cff49 in rpc_binding_set_auth_info
    (10157736, 10269176, 5, 1, 5346984, 2, 7863612)
#9  0x4093c7 in evs_i_erb_rpc_forward (p_forward_buf=0x9b28b8, 
    p_thread_data=0x4ed914, p_login_context=0x518f34, p_status=0x77fe10)
    at ../../../../../src/services/evs/evs_erb/erb_rpc.c:196
#10 0x403053 in evs_i_erb_emit_thrd_main (emit_thrd_id_arg=0xd)
    at ../../../../../src/services/evs/evs_erb/erb_emit_thrd.c:116
#11 0xa41c2063 in cma__thread_base ()
#12 0xa41cd685 in cma__create_thread ()
#13 0x402f48 in evs_i_erb_emit_thrd_main (Cannot access memory at address
0xd.

[10/7/93 public]
This should be fixed with thread-safe wrappers for flock and fcntl.
Changed component to threads, owner to John Dugas.

[jd 10/15/93 public] 
The original proposed solution to this was to make fcntl block only
the calling thread while waiting for the file lock but as it turns out
there are other problems. The lock obtained from fcntl is a process 
resource. That is two threads in the same process asking for a lock on
the same file will both succeed. The kernel checks the process id
against that of the owner and if its the same it returns success. Just
making the call a thread blocking rather than a process blocking call
will not solve this and in fact could exasperate the problem.
What's required is a full implementation of a thread safe the file locking 
capability in  cma on top of the existing fcntl functionality. We have
looked at the feasability of this and determined that it is doable but not
in the exiting time frame. We are therefore defering this and will
implement the full functionality in 1.1. The secuurity problem that triped
across this is being fixed with suitable mutexes to safeguard critical
file access.

[10/15/93 public]
Realistically this is an enhancement request for an np extension to
fcntl to make the lock a thread resource. It WILL be done in 1.1
as an enhancement.



CR Number                     : 8494
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : 
Short Description             : Caching of vp's and stacks does not work properly when Mach threads are used
Reported Date                 : 8/20/93
Found in Baseline             : 1.0.2
Found Date                    : 8/20/93
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : threads/cma_vp_defs.h,cma_stack.h,cma_vp.h,cma_tcb.h,cma_stack.c,cma_tcb.c,cma_thread.c,cma_dispatch.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/20/93 public]

Full Description:

 Disclaimer: I have accepted this as is from the submitter, use at
             your own risk.

Full Description:

 The DCE threads code tries to be clever about how it uses vp's and
 stacks.  Rather than reallocating these resources, it caches them when
 a thread exits.  This is a good idea in principle, but requires
 considerable care to ensure that a resource is not re-used until
 nobody else is using it.
 
 Problems:
 
 1)  Stacks may not be re-used until the last user has been restarted
 (on a different stack).  This is because the thread_suspend call is
 going to return status to the last stack it knew about, not the one
 it's now supposed to be using.  My solution was to record the stack in
 the vpid structure and, when the thread is re-used, it frees the stack
 it used the last time.
 
 2)  VP's may not be casually re-used.  In particular, just because the
 user level code has decided that it is done with the VP, that VP may
 still be running in the kernel (not suspended yet).  It's necessary to
 check the thread's status with the kernel to ensure that it has truly
 stopped. 

Proposed Solution:
 
src/threads/cma_vp_defs.h
 added stack field to cma__t_vpid struct.

src/threads/cma_stack.h
 added prototype for cma__stack_preserve function.

src/threads/cma_vp.h
 added prototype for cma__vp_cache_vpid.

src/threads/cma_tcb.h
 added second parameter (destroy) to cma__free_tcb prototype.

src/threads/cma_stack.c
 added cma__stack_preserve routine.

src/threads/cma_tcb.c
 added call to vp_cache_vpid in destroy_tcb, added second
 parameter to free_tcb, added asserts checking for bad queue
 values in get_tcb, null sched.processor and unconditional
 stack allocation in ini_tcb.  Also cleaned up a little in fork
 processing (use symbolic values, not hardcoded constants).
 
src/threads/cma_thread.c
 modify thread_detach logic to make sure the thing is
 dead.  changed cma_yield to avoid kernel entry/exit.  changed
 int_make_thread routine to check vp_set_start status, and do
 a cma__vp_yield if it works.  In thread startup, yield right
 away so the parent can release the kernel lock.  Also, on
 thread startup, do a free_stack_list of any previous stack.
 
src/threads/cma_dispatch.c
 Reason:  Caching of vp's and stacks does not work properly
 in cma__block on return from cma__dispatch, if the
 tcb is on a queue, take it off unconditionally, and don't
 forget to update the count of running vp's.  Removed a trace
 that could cause deadlock.  In dispell_zombies, ensure the
 vp is really there and really stopped, not just logically
 stopped from CMA's viewpoint.  In init_dispatch, be sure to
 initialize signal state only under the right conditions.  Add
 call to cma__stack_preserve in terminate_thread.  In the
 yield_processor routine, the assert is not valid for vp's.
 
src/threads/cma_vp.c
 added stack queuing for vp, added vp_cache_vpid routine,
 removed code putting vp on cached queue (now in vp_get_state).

     *** src/threads/cma_vp_defs.h.	Fri Jul 16 14:05:01 1993
     --- /tmp/cma_vp_defs.h	Fri Jul 16 14:05:01 1993
     ***************
     *** 170,179 ****
     --- 170,180 ----
       typedef struct CMA__T_VPID {
           cma__t_queue	queue;		/* Queue of VPs */
           thread_t		vp;		/* Actual Mach VP id */
           port_t		synch;		/* Synch port */
           cma_t_integer	flags;		/* What's it doing */
     +     cma__t_queue	stack;		/* Queue header for stack descr. */
           } cma__t_vstruct, *cma__t_vpid;
       #else
       typedef cma_t_address 	cma__t_vpid;
       #endif
       
 
     *** src/threads/cma_stack.h	Fri Jul 16 14:05:47 1993
     --- /tmp/cma_stack.h	Fri Jul 16 14:05:47 1993
     ***************
     *** 187,196 ****
     --- 187,199 ----
       
       extern void
       cma__init_stack _CMA_PROTOTYPE_ ((void));
       
       extern void
     + cma__stack_preserve _CMA_PROTOTYPE_ ((cma__t_int_tcb		*tcb));
     + 
     + extern void
       cma__reinit_stack _CMA_PROTOTYPE_ ((
       	cma_t_integer	flag));
       
       #if _CMA_PROTECT_MEMORY_
       extern void
 
     *** src/threads/cma_vp.h	Fri Jul 16 14:06:27 1993
     --- /tmp/cma_vp.h	Fri Jul 16 14:06:27 1993
     ***************
     *** 130,139 ****
     --- 130,143 ----
       cma__vp_get_state _CMA_PROTOTYPE_ ((
       	cma__t_vpid	vpid,
       	cma__t_vp_state	*state));
       
       extern void
     + cma__vp_cache_vpid _CMA_PROTOTYPE_ ((
     + 	cma__t_vpid	vpid));
     + 
     + extern void
       cma__vp_dump _CMA_PROTOTYPE_ ((void));
       
       extern cma__t_vp_status
       cma__vp_interrupt _CMA_PROTOTYPE_ ((
       	cma__t_vpid		vpid,
 
     *** src/threads/cma_tcb.h	Fri Jul 16 14:07:07 1993
     --- /tmp/cma_tcb.h	Fri Jul 16 14:07:07 1993
     ***************
     *** 160,170 ****
       cma__destroy_tcb _CMA_PROTOTYPE_ ((
       	cma__t_int_tcb	*old_tcb));	/* The TCB to be deleted */
       
       extern void
       cma__free_tcb _CMA_PROTOTYPE_ ((
     ! 	cma__t_int_tcb	*old_tcb));	/* The TCB to be freed */
       
       extern cma__t_int_tcb *
       cma__get_tcb _CMA_PROTOTYPE_ ((
       	cma__t_int_attr	*attrib));	/* Attributes object to use */
       
     --- 160,171 ----
       cma__destroy_tcb _CMA_PROTOTYPE_ ((
       	cma__t_int_tcb	*old_tcb));	/* The TCB to be deleted */
       
       extern void
       cma__free_tcb _CMA_PROTOTYPE_ ((
     ! 	cma__t_int_tcb	*old_tcb,	/* The TCB to be freed */
     ! 	cma_t_integer	destroy));	/* if nonzero, destroy tcb */
       
       extern cma__t_int_tcb *
       cma__get_tcb _CMA_PROTOTYPE_ ((
       	cma__t_int_attr	*attrib));	/* Attributes object to use */
       
 
     *** /src/threads/cma_stack.c	Fri Jul 16 14:08:48 1993
     --- /tmp/cma_stack.c	Fri Jul 16 14:08:49 1993
     ***************
     *** 1820,1829 ****
     --- 1820,1879 ----
           cma__queue_insert (&stack->header.queue, &tcb->stack);
           cma__int_unlock (tcb->mutex);
           stack->tcb = tcb;
           }
       
     + #if _CMA_THREAD_IS_VP_
     + /*  
     +  *  FUNCTIONAL DESCRIPTION:
     +  *
     +  *	Move a stack descriptor from a tcb to that tcb's vpid
     +  *
     +  *  FORMAL PARAMETERS:
     +  *
     +  *	tcb		tcb containing stack descriptor
     +  *
     +  *  IMPLICIT INPUTS:
     +  *
     +  *	none
     +  *
     +  *  IMPLICIT OUTPUTS:
     +  *
     +  *	none
     +  *
     +  *  FUNCTION VALUE:
     +  *
     +  *	none
     +  *
     +  *  SIDE EFFECTS:
     +  *
     +  *	none
     + 
     +  */
     + void
     + cma__stack_preserve
     + #ifdef _CMA_PROTO_
     + 	(
     + 	cma__t_int_tcb		*tcb)	/* tcb being modified */
     + #else	/* no prototypes */
     + 	(tcb)
     + 	cma__t_int_tcb		*tcb;	/* tcb being modified */
     + #endif	/* prototype */
     +     {
     +     cma__t_int_stack	*stack;		/* stack of tcb */
     + 
     + 
     +     cma__int_lock (tcb->mutex);
     +     stack = (cma__t_int_stack *)cma__queue_next(&tcb->stack);
     +     cma__queue_remove (&stack->header.queue);
     +     cma__queue_insert (&stack->header.queue, 
     + 		       &tcb->sched.processor->vp_id->stack);
     +     cma__int_unlock (tcb->mutex);
     +     stack->tcb = (cma__t_int_tcb *)cma_c_null_ptr;
     +     }
     + #endif
     + 
       /*
        *  FUNCTIONAL DESCRIPTION:
        *
        *	Free a set of chunks in a stack cluster
        *
 
     *** src/threads/cma_tcb.c	Fri Jul 16 14:10:47 1993
     --- /tmp/cma_tcb.c	Fri Jul 16 14:10:47 1993
     ***************
     *** 326,338 ****
       	    cma__int_mutex_locked (old_tcb->attributes->mutex),
       	    "cma__destroy_tcb called without attributes object locked.");
       
           cma__trace ((
       	    cma__c_trc_obj,
     ! 	    "(destroy_tcb) destroying TCB %08x (%d)",
       	    old_tcb,
     ! 	    old_tcb->header.sequence));
       
           /*
            * Since we don't want recursive mutexes and such for our internal synch.
            * objects, we always use the default attributes object for them. If we
            * don't have the correct mutex locked, release it and lock the default
     --- 326,341 ----
       	    cma__int_mutex_locked (old_tcb->attributes->mutex),
       	    "cma__destroy_tcb called without attributes object locked.");
       
           cma__trace ((
       	    cma__c_trc_obj,
     ! 	    "(destroy_tcb) destroying TCB %08x (%d) (vp_id %08x, vp %08x)",
       	    old_tcb,
     ! 	    old_tcb->header.sequence,
     ! 	    old_tcb->sched.processor ? old_tcb->sched.processor->vp_id : 0,
     ! 	    old_tcb->sched.processor ? old_tcb->sched.processor->vp_id ?
     ! 		 old_tcb->sched.processor->vp_id->vp : 0 : 0));
       
           /*
            * Since we don't want recursive mutexes and such for our internal synch.
            * objects, we always use the default attributes object for them. If we
            * don't have the correct mutex locked, release it and lock the default
     ***************
     *** 385,394 ****
     --- 388,403 ----
           if ((cma_t_address)old_tcb->select.rfds != cma_c_null_ptr)
       	cma__free_mem ((cma_t_address)old_tcb->select.rfds);
       
       #endif
       
     + 
     + #if _CMA_THREAD_IS_VP_
     +     if (old_tcb->sched.processor && old_tcb->sched.processor->vp_id)
     + 	    cma__vp_cache_vpid(old_tcb->sched.processor->vp_id);
     + #endif
     + 
           cma__free_mem ((cma_t_address)old_tcb);
           }
       
       /*
        *  FUNCTIONAL DESCRIPTION:
     ***************
     *** 417,430 ****
        */
       extern void
       cma__free_tcb
       #ifdef _CMA_PROTO_
       	(
     ! 	cma__t_int_tcb	*old_tcb)	/* The TCB to be freed */
       #else	/* no prototypes */
       	(old_tcb)
       	cma__t_int_tcb	*old_tcb;	/* The TCB to be freed */
       #endif	/* prototype */
           {
           cma__t_int_attr	*attrib;
       
       
     --- 426,441 ----
        */
       extern void
       cma__free_tcb
       #ifdef _CMA_PROTO_
       	(
     ! 	cma__t_int_tcb	*old_tcb,	/* The TCB to be freed */
     ! 	cma_t_integer	destroy)	/* if nonzero, destroy tcb */
       #else	/* no prototypes */
       	(old_tcb)
       	cma__t_int_tcb	*old_tcb;	/* The TCB to be freed */
     +         cma_t_integer	destroy;	/* if nonzero, destroy tcb */
       #endif	/* prototype */
           {
           cma__t_int_attr	*attrib;
       
       
     ***************
     *** 457,467 ****
       
           cma__int_lock (attrib->mutex);
           attrib->refcnt--;
       
           if ((old_tcb->header.revision == attrib->cache[cma__c_obj_tcb].revision)
     ! 	&& (! attrib->delete_pending)) {
       
       	if (attrib->cache[cma__c_obj_tcb].count
       		< cma__g_env[cma__c_env_maxthread].value) {
       	    attrib->cache[cma__c_obj_tcb].count += 1;
       	    cma__queue_insert (
     --- 468,478 ----
       
           cma__int_lock (attrib->mutex);
           attrib->refcnt--;
       
           if ((old_tcb->header.revision == attrib->cache[cma__c_obj_tcb].revision)
     ! 	&& (! attrib->delete_pending) && (destroy == 0)) {
       
       	if (attrib->cache[cma__c_obj_tcb].count
       		< cma__g_env[cma__c_env_maxthread].value) {
       	    attrib->cache[cma__c_obj_tcb].count += 1;
       	    cma__queue_insert (
     ***************
     *** 551,560 ****
     --- 562,572 ----
       	    cma__int_unlock (attrib->mutex);
       	    return (cma__t_int_tcb *)cma_c_null_ptr;
       	    }
       
       	cma__trace ((cma__c_trc_obj, "(get_tcb) allocated tcb %08x", new_tcb));
     + 
       	list_empty = cma_c_true;
       	}
           else {
       	new_tcb = (cma__t_int_tcb *)cma__queue_dequeue (
       		&attrib->cache[cma__c_obj_tcb].queue);
     ***************
     *** 562,580 ****
     --- 574,600 ----
       	cma__trace ((
       		cma__c_trc_obj | cma__c_trc_cache,
       		"(get_tcb) retrieved tcb %08x from cache (%d more)",
       		new_tcb,
       		attrib->cache[cma__c_obj_tcb].count));
     + 
       	list_empty = cma_c_false;
       	}
       
           attrib->refcnt++;
           cma__int_unlock (attrib->mutex);
       
           if (!cma___ini_tcb (new_tcb, cma__c_thkind_normal, attrib, list_empty))
       	return (cma__t_int_tcb *)cma_c_null_ptr;
       
     +     cma__assert_fail (
     + 	    (&new_tcb->header.queue)->flink == 0,
     + 	    "cma__get_tcb: queue corruption -- element flink not zero");
     +     cma__assert_fail (
     + 	    (&new_tcb->header.queue)->blink == 0,
     + 	    "cma__get_tcb: queue corruption -- element blink not zero");
     + 
           return new_tcb;
           }
       
       /*
        *  FUNCTIONAL DESCRIPTION:
     ***************
     *** 681,698 ****
       	cma__t_thkind	    kind;
       	cma__t_int_attr	    *attrib;
       	cma_t_boolean	    is_raw_storage;
       #endif	/* prototype */
           {
     !     cma_t_integer   i;
       
           if (is_raw_storage) {
     - 	cma__t_int_stack	*stack;
       	cma__t_context_list	init_list;	/* Pointer to initial list */
       	cma_t_natural		init_size;	/* Size of new list */
       	static cma__t_string	tcb_obj_name = "for a TCB";
     - 	cma_t_boolean		ok = cma_c_true;
       
       
       	/*
       	 * This is the initialization required if the TCB is raw
       	 * new storage (did not come from a cache).  We must create
     --- 701,718 ----
       	cma__t_thkind	    kind;
       	cma__t_int_attr	    *attrib;
       	cma_t_boolean	    is_raw_storage;
       #endif	/* prototype */
           {
     !     cma_t_integer   	i;
     !     cma_t_boolean	ok = cma_c_true;
     !     cma__t_int_stack	*stack;
       
           if (is_raw_storage) {
       	cma__t_context_list	init_list;	/* Pointer to initial list */
       	cma_t_natural		init_size;	/* Size of new list */
       	static cma__t_string	tcb_obj_name = "for a TCB";
       
       
       	/*
       	 * This is the initialization required if the TCB is raw
       	 * new storage (did not come from a cache).  We must create
     ***************
     *** 701,710 ****
     --- 721,731 ----
       	 */
       
       	tcb->header.type = cma__c_obj_tcb;
       	tcb->attributes = attrib;
       	cma__queue_init (&tcb->stack);
     + 	tcb->sched.processor = cma_c_null_ptr;
       
       	/*
       	 * If we can't allocate any of the subobjects in the TCB, destroy the
       	 * TCB and reraise the allocation exception. Except if we're trying
       	 * to set up the default thread TCB (far too early for any reasonable
     ***************
     *** 810,845 ****
       		    }
       
       		}
       #endif
       
     ! 	    if (ok && kind != cma__c_thkind_initial) {
     ! 		stack = cma__get_stack (attrib);
     ! 
     ! 		if ((cma_t_address)stack == cma_c_null_ptr)
     ! 		    ok = cma_c_false;
     ! 		else
     ! 		    cma__assign_stack (stack, tcb);
       
     ! 		}
       
     ! 	if (!ok) {			/* If an allocation failed, back off */
       
     ! 	    if (kind != cma__c_thkind_initial) {
     ! 		cma__t_int_mutex	*am;
       
       
     ! 		am = tcb->attributes->mutex;
     ! 		cma__int_lock (am);
     ! 		cma__destroy_tcb (tcb);
     ! 		cma__int_unlock (am);
     ! 		}
       
     ! 	    return cma_c_false;
       	    }
       
     ! 	}
       
           /*
            * Whether the TCB is old or new, we need to ensure certain field
            * initialization. The most important release is generating a unique
            * sequence number for the new TCB object.
     --- 831,870 ----
       		    }
       
       		}
       #endif
       
     ! 	} else {
     ! 	    cma__assert_fail (
     ! 		    cma__queue_empty(&tcb->stack),
     ! 		    "cma___ini_tcb -- stack exists");
     ! 	}
       
     !     /* whether or not it's raw storage, need to allocate a stack */
       
     !     if (ok && kind != cma__c_thkind_initial) {
     ! 	stack = cma__get_stack (attrib);
       
     ! 	if ((cma_t_address)stack == cma_c_null_ptr)
     ! 	    ok = cma_c_false;
     ! 	else
     ! 	    cma__assign_stack (stack, tcb);
     !     }
       
     +     if (!ok) {			/* If an allocation failed, back off */
       
     ! 	if (kind != cma__c_thkind_initial) {
     ! 	    cma__t_int_mutex	*am;
       
     ! 	    am = tcb->attributes->mutex;
     ! 	    cma__int_lock (am);
     ! 	    cma__destroy_tcb (tcb);
     ! 	    cma__int_unlock (am);
       	    }
       
     ! 	return cma_c_false;
     !     }
       
           /*
            * Whether the TCB is old or new, we need to ensure certain field
            * initialization. The most important release is generating a unique
            * sequence number for the new TCB object.
     ***************
     *** 1006,1025 ****
            * TCB to make sure nobody can be in the middle of modifying it (e.g., to
            * set pending alert)... since only the current thread will exist in the
            * child process, that could leave the TCB's mutex locked.
            */
       
     !     if (flag == 0) {				/* pre fork work */
               cma__int_lock (cma___g_tcb_seq.mutex);
       	cma__int_lock (cma__get_self_tcb()->mutex);
       	}
     !     else if (flag == 1) {	/* post fork work, out of kernel */
       	cma__int_unlock (cma__get_self_tcb()->mutex);
               cma__int_unlock (cma___g_tcb_seq.mutex);
       	}	
       
           }
       /*  DEC/CMS REPLACEMENT HISTORY, Element CMA_TCB.C */
       /*  *29    5-JUN-1992 13:34:59 BUTENHOF "Fix delete_pending attr handling" */
       /*  *28   18-MAY-1992 16:50:07 SCALES "Add additional queue element initializations" */
       /*  *27   15-MAY-1992 15:04:49 SCALES "Cleanse tcb links for known-threads queue" */
       /*  *26    3-APR-1992 18:34:06 SCALES "Rework async context switch for U*ix" */
     --- 1031,1054 ----
            * TCB to make sure nobody can be in the middle of modifying it (e.g., to
            * set pending alert)... since only the current thread will exist in the
            * child process, that could leave the TCB's mutex locked.
            */
       
     !     if (flag == cma__c_reinit_prefork_lock) {
               cma__int_lock (cma___g_tcb_seq.mutex);
       	cma__int_lock (cma__get_self_tcb()->mutex);
       	}
     !     else if (flag == cma__c_reinit_postfork_unlock) {
       	cma__int_unlock (cma__get_self_tcb()->mutex);
               cma__int_unlock (cma___g_tcb_seq.mutex);
       	}	
     +     else if (flag == cma__c_reinit_postfork_clear) {
     + 	cma__get_self_tcb()->kind = cma__c_thkind_initial;
     +     }
       
           }
     + 
       /*  DEC/CMS REPLACEMENT HISTORY, Element CMA_TCB.C */
       /*  *29    5-JUN-1992 13:34:59 BUTENHOF "Fix delete_pending attr handling" */
       /*  *28   18-MAY-1992 16:50:07 SCALES "Add additional queue element initializations" */
       /*  *27   15-MAY-1992 15:04:49 SCALES "Cleanse tcb links for known-threads queue" */
       /*  *26    3-APR-1992 18:34:06 SCALES "Rework async context switch for U*ix" */
 
     *** src/threads/cma_thread.c	Fri Jul 16 14:12:46 1993
     --- /tmp/cma_thread.c	Fri Jul 16 14:12:47 1993
     ***************
     *** 329,342 ****
       #else	/* no prototypes */
       	(thread)
       	cma_t_thread	*thread;	/* Handle of thread to detach*/
       #endif	/* prototype */
           {
     !     cma__t_int_tcb  *tcb;
     ! 	cma_t_boolean	do_free;
     ! 
     ! 	do_free = cma_c_false;
       
           /* 
            * Validate the handle, insure that it's a thread, and get the TCB address
            */
           tcb = cma__validate_null_tcb (thread);
     --- 329,340 ----
       #else	/* no prototypes */
       	(thread)
       	cma_t_thread	*thread;	/* Handle of thread to detach*/
       #endif	/* prototype */
           {
     !     cma__t_int_tcb	*tcb;
     !     cma_t_boolean	do_free = cma_c_false;
       
           /* 
            * Validate the handle, insure that it's a thread, and get the TCB address
            */
           tcb = cma__validate_null_tcb (thread);
     ***************
     *** 351,377 ****
            * then free the tcb now.  If the thread has not yet terminated, then mark
            * the tcb to-be-freed when the thread does terminate
            */
           cma__int_lock (tcb->mutex);		/* Lock for visibility */
       
     ! 	if (!tcb->detached) {
     ! 		tcb->detached = cma_c_true;	/* Mark it for freeing */
     ! 		if (tcb->terminated) {		/* If the thread has terminated...*/
     ! 			cma__assert_not_kernel ();	/* Shouldn't already be in kernel */
     ! 			cma__enter_kernel ();
     ! 			if (tcb->state == cma__c_state_terminated) {	/* ...and if really dead */
     ! 				do_free = cma_c_true;	/* ...then free the TCB (& stack) */
     ! 				cma__queue_remove (&tcb->threads);	/* Remove fr. known threads queue */
     ! 			}
     ! 			cma__exit_kernel ();
     ! 		}
     ! 	}
       
     ! 	cma__int_unlock (tcb->mutex);	/* Visibility */
       
     - 	if (do_free)
     - 		cma__free_tcb (tcb);	/* ...then free the TCB (& stack) */
       
           /*
            * This handle is no longer valid, clear it
            */
           cma__clear_handle (thread);
     --- 349,387 ----
            * then free the tcb now.  If the thread has not yet terminated, then mark
            * the tcb to-be-freed when the thread does terminate
            */
           cma__int_lock (tcb->mutex);		/* Lock for visibility */
       
     !     if (!tcb->detached) {
     ! 	    tcb->detached = cma_c_true;	/* Mark it for freeing */
     ! 	    if (tcb->terminated) {		/* If the thread has terminated...*/
     ! 		    cma__assert_not_kernel ();	/* Shouldn't already be in kernel */
     ! 		    cma__enter_kernel ();
     ! 		    if (tcb->state == cma__c_state_terminated) {	/* ...and if really dead */
     ! 			    do_free = cma_c_true;	/* ...then free the TCB (& stack) */
     ! 			    cma__queue_remove (&tcb->threads);	/* Remove fr. known threads queue */
     ! 		    }
     ! 		    cma__exit_kernel ();
     ! 	    }
     !     }
     ! 
     !     if (do_free) {
     ! #if _CMA_THREAD_IS_VP_
     ! 	    cma__t_vp		*vpstr = tcb->sched.processor;
     ! 	    cma__t_vp_state	state;
       
     ! 	    do {
     ! 		    cma__vp_get_state (vpstr->vp_id, &state);
     ! 	    } while (state.run_state != cma__c_vp_st_stop ||
     ! 		     state.mach_state != TH_STATE_STOPPED);
     ! #endif
     ! 	    vpstr->vp_id = (cma__t_vpid)cma_c_null_ptr;
     ! 	    cma__int_unlock (tcb->mutex);	/* Visibility */
     ! 	    cma__free_tcb (tcb, 0);	/* ...then free the TCB (& stack) */
     !     } else
     ! 	    cma__int_unlock (tcb->mutex);	/* Visibility */
       
       
           /*
            * This handle is no longer valid, clear it
            */
           cma__clear_handle (thread);
     ***************
     *** 526,542 ****
       		
           /* 
            * Get a TCB (and stack) for the new thread
            */
           cma__dispell_zombies ();		/* see if we can free a tcb/stack */
           new_tcb = cma__get_tcb (new_att);
       
           if ((cma_t_address)new_tcb == cma_c_null_ptr)
       	cma__error (exc_s_insfmem);
       
           if (!cma__int_make_thread (new_tcb, new_thread, start_routine, arg)) {
     ! 	cma__free_tcb (new_tcb);
       	cma__error (exc_s_insfmem);
       	}
       
           /*
            * Point user's handle at the new thread object
     --- 536,554 ----
       		
           /* 
            * Get a TCB (and stack) for the new thread
            */
           cma__dispell_zombies ();		/* see if we can free a tcb/stack */
     + 
           new_tcb = cma__get_tcb (new_att);
       
           if ((cma_t_address)new_tcb == cma_c_null_ptr)
       	cma__error (exc_s_insfmem);
       
           if (!cma__int_make_thread (new_tcb, new_thread, start_routine, arg)) {
     ! 	cma__queue_remove (&new_tcb->threads);  /* Remove fr. known threads queue */
     ! 	cma__free_tcb (new_tcb, 1);
       	cma__error (exc_s_insfmem);
       	}
       
           /*
            * Point user's handle at the new thread object
     ***************
     *** 769,778 ****
     --- 781,791 ----
       #endif	/* prototype */
           {
           cma__t_int_tcb  *tcb;
       
       
     + 
           /*
            * Validate the handle, insure that it's a thread, and get the TCB address
            */
           tcb = cma__validate_tcb (thread);
       
     ***************
     *** 1163,1175 ****
     --- 1176,1192 ----
       	(void)
       #else	/* no prototypes */
       	()
       #endif	/* prototype */
           {
     + #if !_CMA_THREAD_IS_VP_
           cma__enter_kernel ();
     + #endif
           cma__yield_processor ();
     + #if !_CMA_THREAD_IS_VP_
           cma__exit_kernel ();
     + #endif
           }
       
       /*
        *  FUNCTIONAL DESCRIPTION:
        *
     ***************
     *** 1271,1280 ****
     --- 1288,1298 ----
           {
           cma__t_int_stack	*new_stack;	/* New thread's stack */
           cma__t_vp		*vp;		/* VP structure for new VP */
           cma__t_vpid		vpid;		/* ID of VP (if nonmultiplexed mP) */
           cma__t_vp_state	state;		/* State array for new VP */
     +     cma__t_vp_status	start_status;	/* result of vp_set_start */
       
       
           /*
            * Get address of the new child thread's stack object
            */
     ***************
     *** 1316,1325 ****
     --- 1334,1360 ----
       	tcb->sched.processor = vp;
       	}
           else
       	vp = tcb->sched.processor;
       
     + {
     + 
     +     cma__t_int_tcb	*self;
     + 
     +     self = cma__get_self_tcb ();
     + 
     +     cma__trace ((
     + 	    cma__c_trc_obj,
     + 	    "(int_make_thread) self %08x (vp %08x vp_id %08x vp %08x) makes thread %08x, vp %08x, vp_id %08x",
     + 	    self,
     + 	    self->sched.processor,
     + 	    self->sched.processor->vp_id,
     + 	    self->sched.processor->vp_id->vp,
     + 	    tcb,
     + 	    vp, 
     + 	    vp->vp_id));
     + }
           cma__enter_kernel ();
       
           if ((cma_t_address)tcb->sched.processor->vp_id == cma_c_null_ptr) {
       
       	if (cma__vp_create (&vpid) != cma__c_vp_normal) {
     ***************
     *** 1336,1356 ****
       
           state.stack = (int)new_stack->stack_base;
           state.tcb = (int)tcb;
           state.start_routine = (int)start_routine;
           state.start_arg = (int)start_arg;
     !     cma__vp_set_start (vpid, &state);
     !     cma__queue_init (&vp->interrupts);
     !     vp->current_thread = tcb;
     !     cma__start_thread (tcb);
           cma__exit_kernel ();
           cma__trace ((
       	    cma__c_trc_obj | cma__c_trc_vp,
     ! 	    "(int_make_thread) thread %08x (%d); vp %d allocated",
       	    tcb,
       	    tcb->header.sequence,
     ! 	    vpid->vp));
       #else
           cma__create_thread (
       	    &tcb->static_ctx,		/* Address of base of child context */
       	    new_stack->stack_base,	/* Address of base of child stack */
       	    tcb);
     --- 1371,1421 ----
       
           state.stack = (int)new_stack->stack_base;
           state.tcb = (int)tcb;
           state.start_routine = (int)start_routine;
           state.start_arg = (int)start_arg;
     !     if ((start_status = cma__vp_set_start (vpid, &state)) == KERN_SUCCESS) {
     ! 	cma__queue_init (&vp->interrupts);
     ! 	vp->current_thread = tcb;
     ! 	cma__start_thread (tcb);
     !     }
           cma__exit_kernel ();
     + #if _CMA_THREAD_IS_VP_
     +     /* Now that the kernel is unlocked, if status is successful, do a
     +      * yield so the child can run.
     +      */
     +     if (start_status == KERN_SUCCESS)
     +         cma__vp_yield();
     + #endif
     + 
     +     if (start_status != KERN_SUCCESS) {
     +         cma__t_int_tcb	*self;
     +         self = cma__get_self_tcb ();
     + 
     +         cma__trace ((
     + 		cma__c_trc_obj | cma__c_trc_vp,
     + 		"(int_make_thread) vp_set_start (vp %d, flags 0x%x, port %d) failed \"%s\" (%d) (me vp %d, flags 0x%x, port %d)",
     + 		vpid->vp,
     + 		vpid->flags,
     + 		vpid->synch,
     + 	        mach_error_string (start_status),
     + 	        start_status,
     + 		self->sched.processor->vp_id->vp,
     + 		self->sched.processor->vp_id->flags,
     + 		self->sched.processor->vp_id->synch));
     + 	return cma_c_false;
     +     }
     + 
     + {
           cma__trace ((
       	    cma__c_trc_obj | cma__c_trc_vp,
     ! 	    "(int_make_thread) thread %08x (%d); vp %d (port %d) allocated",
       	    tcb,
       	    tcb->header.sequence,
     ! 	    vpid->vp,
     ! 	    vpid->synch));
     ! }
       #else
           cma__create_thread (
       	    &tcb->static_ctx,		/* Address of base of child context */
       	    new_stack->stack_base,	/* Address of base of child stack */
       	    tcb);
     ***************
     *** 1398,1414 ****
           cma_t_address	argument= tcb->start_arg;
           cma_t_address	value;
           cma_t_exit_status	status;
           char	output[128];
       
     ! 
           /*
            * A new thread is started with the kernel locked.  The first thing we
            * need to do is unlock the kernel to allow other business to proceed:
            */
     - #if !_CMA_THREAD_IS_VP_
           cma__exit_kernel ();
       #endif
       
           cma__trace ((
       	    cma__c_trc_obj,
       	    "(thread_base) beginning thread %08x (%d) at pc %08x (arg %08x), sp %08x",
     --- 1463,1486 ----
           cma_t_address	argument= tcb->start_arg;
           cma_t_address	value;
           cma_t_exit_status	status;
           char	output[128];
       
     ! #if !_CMA_THREAD_IS_VP_
           /*
            * A new thread is started with the kernel locked.  The first thing we
            * need to do is unlock the kernel to allow other business to proceed:
            */
           cma__exit_kernel ();
     + #else
     +     /* This thread's creator locked the kernel before starting the thread.
     +      * Trying to have this thread unlock the kernel is very messy due to
     +      * all the error paths in the creator, so let's just have this guy
     +      * take a timeslice so the creator gets to run again and unlock the
     +      * kernel.
     +      */
     +     cma__vp_yield();
       #endif
       
           cma__trace ((
       	    cma__c_trc_obj,
       	    "(thread_base) beginning thread %08x (%d) at pc %08x (arg %08x), sp %08x",
     ***************
     *** 1418,1427 ****
     --- 1490,1508 ----
       	    argument,
       	    cma__fetch_sp ()));
       
       #if _CMA_PER_THD_SYNC_SIGS_
           cma__sig_thread_init ();
     + #endif
     + 
     + #if _CMA_THREAD_IS_VP_
     +     /* If this is a recycled vp_id, it may have an old stack
     +      * recorded in it, so delete that stack
     +      */
     + 
     +     if (! cma__queue_empty (&tcb->sched.processor->vp_id->stack))
     + 	cma__free_stack_list (&tcb->sched.processor->vp_id->stack);
       #endif
       
           status = cma_c_term_normal;		/* Assume it'll be normal */
       
           TRY {
 
     *** src/threads/cma_dispatch.c	Fri Jul 16 14:15:13 1993
     --- /tmp/cma_dispatch.c	Fri Jul 16 14:15:13 1993
     ***************
     *** 540,549 ****
     --- 540,550 ----
        *  SIDE EFFECTS:
        *
        *	The first thread from the ready list will be taken and become
        *	the running thread.
        */
     + 
       extern cma_t_boolean
       cma__block
       #ifdef _CMA_PROTO_
       	(
       	cma__t_queue	*blocked_list,
     ***************
     *** 625,638 ****
            */
           status = cma__dispatch (cur_tcb, cma_c_true, milliseconds);
       
       #if _CMA_THREAD_IS_VP_
           /*
     !      * Remove entry only if it timed out.
            */
     !     if (!status)
       	(void)cma__queue_remove (&cur_tcb->header.queue);
       #endif
       
           return status;
           }
       
     --- 626,649 ----
            */
           status = cma__dispatch (cur_tcb, cma_c_true, milliseconds);
       
       #if _CMA_THREAD_IS_VP_
           /*
     !      * Remove entry if the tcb is still queued.  This code formerly removed
     !      * the entry only if the call timed out; this is wrong, at least in
     !      * a VP environment, because a thread on a semaphore queue could time
     !      * out while the queue is being notified, so the semaphore in question
     !      * is effectively overnotified -- a subsequent wait will not block, but
     !      * no dequeuing took place.
            */
     !     if (!status) {
     ! 	cma__count_vp_running ();
     !     }
     !

CR Number                     : 8480
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : 
Short Description             : pthread_signal_to_cancel_np will not work with Mach Threads
Reported Date                 : 8/18/93
Found in Baseline             : 1.0.2
Found Date                    : 8/18/93
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : src/threads/cma_pthread.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/18/93 public]

Full Description:

 On a Mach threads implementation, only thread 0 (the initial thread in
 the process) can receive asynchronous signals.  Therefore, the
 pthread_signal_to_cancel_np interface cannot work, since it relies on
 any thread being able to intercept any signal.

Proposed Solution:

 On a Mach threads implementation, disable  pthread_signal_to_cancel_np.

*** cma_pthread.c	Wed Feb  3 19:29:09 1993
--- /users/xxx/cma_pthread.c	Wed Aug 18 18:20:14 1993
***************
*** 3696,3703 ****
      {
      int	status = 0;
  
!     cma__int_lock (cma__g_global_lock);
  
      TRY {
  	(void) cma__validate_tcb (thread);
  
--- 3696,3707 ----
      {
      int	status = 0;
  
! #if _CMA_KTHREADS_ == _CMA__MACH
!     cma__set_errno (EINVAL);
!     status = -1;
  
+ #else
+     cma__int_lock (cma__g_global_lock);
      TRY {
  	(void) cma__validate_tcb (thread);
  
***************
*** 3731,3737 ****
  
      if (status == 0)
  	cma__int_unlock (cma__g_global_lock);
! 
      return status;
      }
  
--- 3735,3741 ----
  
      if (status == 0)
  	cma__int_unlock (cma__g_global_lock);
! #endif
      return status;
      }

[8/19/93 public]

For what it's worth, it *is* possible to build a functional version of 
pthread_signal_to_cancel_np using sigwait().  We (DEC) have done so on DEC 
OSF/1 which of course has mach threads.  It can be called by threads other
than the process' primary thread.

[8/31/93 public]

I heard back from the submitter, and they write

"The underlying problem was actually a flaw in the code implementing
 the cma_sigwait routine.  We have prepared a defect report on this and
 OSF should be receiving it in the next week or two."

Therefore, this enhancement request should be cancelled (when it is
assigned a responsible engineer).



CR Number                     : 8475
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : functional tests
Short Description             : return value from pthread_getprio() is not checked properly in prvb_thd_006.c
Reported Date                 : 8/18/93
Found in Baseline             : 1.0.3
Found Date                    : 8/18/93
Severity                      : E
Priority                      : 4
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/18/93 public]

A chance look at the file prvb_thd_006.c revealed an error at line 253:

    prio = pthread_getprio(pthread_self ());
    check (sched_pol, "pthread_getprio");

The first argument to the check macro should be prio, not sched_pol.

The rest of this file and the other tests should be checked for similar
"cut and paste" errors.



CR Number                     : 8473
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : 
Short Description             : thread_resume not applied to cached threads
Reported Date                 : 8/18/93
Found in Baseline             : 1.0.2
Found Date                    : 8/18/93
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : threads/cma_vp.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/18/93 public]

The code in cma__vp_resume, uses the thread_resume system call
only for vp's marked as "new"; it should also do this for vp's marked
"cached".

Proposed Solution:

*** cma_vp.c    Tue Dec 15 18:35:26 1992
--- /users/xxxxx/cma_vp.c    Wed Aug 18 17:16:27 1993
***************
*** 1035,1041 ****
      kern_return_t     status;


!     if (!(vpid->flags & cma__c_vp_new)) {
        msg_header_t    mhdr;


--- 1035,1041 ----
      kern_return_t     status;


!     if (!(vpid->flags & (cma__c_vp_new | cma__c_vp_cached))) {
        msg_header_t    mhdr;


***************
*** 1059,1065 ****

        }
      else {
!       vpid->flags &= ~cma__c_vp_new;
        vpid->flags |= cma__c_vp_running;

        if ((status = thread_resume (vpid->vp)) != KERN_SUCCESS) {
--- 1059,1065 ----

        }
      else {
!       vpid->flags &= ~(cma__c_vp_new | cma__c_vp_cached);
        vpid->flags |= cma__c_vp_running;

        if ((status = thread_resume (vpid->vp)) != KERN_SUCCESS) {



CR Number                     : 8455
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : 
Short Description             : _CMA_HARDWARE_ definition fails when compiling with gcc -ansi flag
Reported Date                 : 8/16/93
Found in Baseline             : 1.0.3
Found Date                    : 8/16/93
Severity                      : C
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/16/93 public]

The file dce/cma_config.h tests for the symbol i386 when checking
for the machine type. Instead, it should check for __i386__ 
since i386 is undefined when -ansi is passed to gcc on OSF/1.

The affected code:

# if !defined(SNI_SVR4)
#  ifdef i386
#   define       _CMA_HARDWARE_  _CMA__I386
#  endif
# endif
# ifndef _CMA_HARDWARE_
   !!!Error: _CMA_HARDWARE_ not set
# endif
#endif

The symptom (fatal compilation error):
In file included from /project/dce/build/dce1.0.2a/src/threads/cma.h:137, from ../../../src/threads/cma_stdio.c:214:
/usr/sandbox/rhw/sb/dce103i/export/at386/usr/include/dce/cma_config.h:402: parse error before `!'

This should be a DCE 1.1 code cleanup item.

[08/16/93 public]
This work is in the project plan for 1.1 as part of the code cleanup.



CR Number                     : 8421
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : clumsy architecture specific code
Reported Date                 : 8/6/93
Found in Baseline             : 1.0.2
Found Date                    : 8/6/93
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : threads/cma_vp.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/6/93 public]

Customer is porting DCE to kernel theads, which meant they needed to
modify cma_vp.c for their architecture. They found this difficult to
do, and suggested the following changes to make it such work simpler.
Also note that they modified the functions cma__vp_interrupt and 
cma__vp_resume to return a value of type consistent with their definition.
Before this last change these functions behaved as procedures.

*** ../../link/link/src/threads/cma_vp.c	Tue Dec 15 18:35:26 1992
--- cma_vp.c	Fri Aug  6 17:23:57 1993
***************
*** 127,132 ****
--- 127,140 ----
  # include <mach.h>
  # include <mach_error.h>
  # include <mach/machine/syscall_sw.h>
+ # if _CMA_HARDWARE_ == _CMA__MIPS
+ #  define NATIVE_THREAD_STATE        MIPS_THREAD_STATE
+ #  define NATIVE_THREAD_STATE_COUNT  MIPS_THREAD_STATE_COUNT
+ # endif
+ # if _CMA_HARDWARE_ == _CMA__ALPHA
+ #  define NATIVE_THREAD_STATE        ALPHA_THREAD_STATE
+ #  define NATIVE_THREAD_STATE_COUNT  ALPHA_THREAD_STATE_COUNT
+ # endif
  #endif
  
  /*
***************
*** 927,938 ****
  
      if ((status = thread_get_state (
  	    vpid->vp,
! # if _CMA_HARDWARE_ == _CMA__MIPS
! 	    MIPS_THREAD_STATE,
! # endif
! # if _CMA_HARDWARE_ == _CMA__ALPHA
! 	    ALPHA_THREAD_STATE,
! # endif
  	    (thread_state_t)&state_array,
  	    &state_count)) != KERN_SUCCESS) {
  	cma__trace ((
--- 935,941 ----
  
      if ((status = thread_get_state (
  	    vpid->vp,
! 	    NATIVE_THREAD_STATE,
  	    (thread_state_t)&state_array,
  	    &state_count)) != KERN_SUCCESS) {
  	cma__trace ((
***************
*** 956,974 ****
  
      if ((status = thread_set_state (
  	    vpid->vp,
! # if _CMA_HARDWARE_ == _CMA__MIPS
! 	    MIPS_THREAD_STATE,
! # endif
! # if _CMA_HARDWARE_ == _CMA__ALPHA
! 	    ALPHA_THREAD_STATE,
! # endif
  	    (thread_state_t)&state_array,
! # if _CMA_HARDWARE_ == _CMA__MIPS
! 	    MIPS_THREAD_STATE_COUNT)) != KERN_SUCCESS) {
! # endif
! # if _CMA_HARDWARE_ == _CMA__ALPHA
! 	    ALPHA_THREAD_STATE_COUNT)) != KERN_SUCCESS) {
! # endif
  	cma__trace ((
  		cma__c_trc_vp | cma__c_trc_bug,
  		"(vp_interrupt) error \"%s\" (%d) setting state on vp %d",
--- 959,967 ----
  
      if ((status = thread_set_state (
  	    vpid->vp,
! 	    NATIVE_THREAD_STATE,
  	    (thread_state_t)&state_array,
! 	    NATIVE_THREAD_STATE_COUNT)) != KERN_SUCCESS) {
  	cma__trace ((
  		cma__c_trc_vp | cma__c_trc_bug,
  		"(vp_interrupt) error \"%s\" (%d) setting state on vp %d",
***************
*** 991,996 ****
--- 984,990 ----
  	cma__bugcheck ("vp_interrupt: thread_resume");
  	}
  
+     return(cma_c_vp_normal);
  #else
      cma__bugcheck ("vp_interrupt: no VPs");
  #endif
***************
*** 1073,1078 ****
--- 1067,1073 ----
  	    }
  
  	}
+     return(cma_c_vp_normal);
  #else
      cma__bugcheck ("vp_resume: no VPs");
  #endif
***************
*** 1189,1202 ****
      struct alpha_thread_state	thd_state;
  # endif
      int				*stack_array;
- # if _CMA_HARDWARE_ == _CMA__MIPS
-     int				state_count =
MIPS_THREAD_STATE_COUNT;
- # endif
- # if _CMA_HARDWARE_ == _CMA__ALPHA
-     int				state_count =
ALPHA_THREAD_STATE_COUNT;
- # endif
  
- 
      stack_array = (int *)(state->stack - (2 * sizeof (int)));
      stack_array[0] = state->tcb;	/* a0 */
      stack_array[1] = 0;			/* Clear out a null a1 */
--- 1184,1190 ----
***************
*** 1205,1220 ****
      thd_state.pc = (int)cma__execute_thread;
      status = thread_set_state (
  	    vpid->vp,
! # if _CMA_HARDWARE_ == _CMA__MIPS
! 	    MIPS_THREAD_STATE,
  	    (thread_state_t)&thd_state,
! 	    MIPS_THREAD_STATE_COUNT);
! # endif
! # if _CMA_HARDWARE_ == _CMA__ALPHA
! 	    ALPHA_THREAD_STATE,
! 	    (thread_state_t)&thd_state,
! 	    ALPHA_THREAD_STATE_COUNT);
! # endif
  
      return status;
  #endif
--- 1193,1201 ----
      thd_state.pc = (int)cma__execute_thread;
      status = thread_set_state (
  	    vpid->vp,
! 	    NATIVE_THREAD_STATE,
  	    (thread_state_t)&thd_state,
! 	    NATIVE_THREAD_STATE_COUNT);
  
      return status;
  #endif



CR Number                     : 8419
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : 
Short Description             : port_disable status interpretation
Reported Date                 : 8/6/93
Found in Baseline             : 1.0.2
Found Date                    : 8/6/93
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : threads/cma_vp.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/6/93 public]

[8/6/93 public]

When using Mach kernel threads The function cma__init_vp in the file
threads/cma_vp.c calls port_disable

    if (status != KERN_SUCCESS) {
	cma__trace ((
		cma__c_trc_init | cma__c_trc_vp | cma__c_trc_bug,
		"(init_vp) error \"%s\" (%d) allocating def. VP synch port",
		mach_error_string (status),
		status));
	cma__bugcheck ("init_vp: port_allocate");
	}

port_disable is actually and obsoleted Mach call, which has been remapped to
a call to port_set_remove. port_set_remove is capable of returning
KERN_NOT_IN_SET which should be treated by cma__init_vp in the same manner
as KERN_SUCCESS. Therefore, the customer's recommendation is that we change
the three calls to port_diable which appear in cma__init_vp to the following
form:

    status = port_disable (task, synch_port);
    if ((status != KERN_SUCCESS) && (status != KERN_NOT_IN_SET)) {
	cma__trace ((
		cma__c_trc_init | cma__c_trc_vp | cma__c_trc_bug,
		"(init_vp) error \"%s\" (%d) disabling port %d",
		mach_error_string (status),
		status,
		synch_port));
	cma__bugcheck ("init_vp: port_disable");
	}



CR Number                     : 8371
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : thr
Subcomponent Name             : cma_stdio
Short Description             : cma does not provide wrapper for sscanf
Reported Date                 : 7/27/93
Found in Baseline             : 1.0.3
Found Date                    : 7/27/93
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[7/27/93 public]
On AIX the function sscanf appears to be non-reentrant.  However, the
CMA wrapper for sscanf is turned off by default.  This means that any
threaded application that uses sscanf is at risk for intermittent
failures.
In my case I found that test_anode failed intermittently in 1.0.3 which
uses the native pthread functions (instead of the LWP wrappers built out
of pthreads primitives).
I have a 176 line test program that only uses DFS's osi.h and
<pthread.h> which exhibits this problem.  I have not looked at the
source to sscanf to determine why it is written non-reentrantly.
I can provide further details upon request.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[8/18/93 public]

As currently implemented, CMA provides a stub for sscanf on those platforms
which have vsscanf (vsscanf is not required by POSIX). Since sscanf has a
variable length argument list, there is no way in ANSI C to write a macro 
which provides the requested wrapper. This is why this CR is being changed 
from a defect to an enhancement to provide a vsscanf function. Application 
writers are advised to avoid using sscanf() for the time being (on AIX).



CR Number                     : 8300
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 1694
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : add include of stdlib.h to cma.h
Reported Date                 : 7/16/93
Found in Baseline             : 1.0.2
Found Date                    : 7/16/93
Severity                      : E
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cma.h
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/16/93 public]

Customer is trying to build DCE using OSF1 kernel threads which means that
whereever they include cma.h it doesn't proceed to include cmalib_crtlx.h
and accordingly cmalib_crtlx.h doesn't have an opportunity to include
stdlib.h. The result being that functions like malloc are threated as
returning int instead of void *, and compiler warnings are produced 
whenever the returned value of malloc is not cast before being assigned
to other than an integer.

I suggest we make inclusion of stdlib.h an invariant consequence of
including cma.h, the result being that one can be certain that as a
result of including cma.h the function definitions of stdlib.h or their
mapped equivalents have been performed.

Doing as suggested is facilitated since stdlib.h has been written to
prevent its being multiply included.



CR Number                     : 8239
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : cma_recvmsg does not return valid access rights
Reported Date                 : 7/7/93
Found in Baseline             : 1.0.2a
Found Date                    : 7/7/93
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[7/7/93 public]
    [Opening this defect for Andy Hastings]
cma_recvmsg does not return valid access rights.
Scenario:  Process A passes a file descriptor to process B via sendmsg/recvmsg
           calls on a Unix-domain socket.
1.  Process B stores the appropriate values in msg_accrightslen and
    msg_accrights.  Process B makes the recvmsg call BEFORE data is
    available on the socket.  Process A then makes the appropriate sendmsg
    call.  Result:  the msg_accrightslen returned to process B is ZERO,
    and no file descriptors are returned.  Fix:  cma_recvmsg should save
    the initial value of msg_accrightslen, and restore the value before
    each recvmsg system call.
2.  Process B makes the recvmsg call AFTER data is available on the socket.
    Process B receives the file descriptor, but the CMA I/O database does
    not know about it, and all attempts to perform I/O on the descriptor
    fail with EBADF.  Fix:  cma_recvmsg should call cma__open_general on
    each file descriptor received via the recvmsg system call.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'



CR Number                     : 8158
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : 
Short Description             : Turn off compiler optimization
on HP/UX
Reported Date                 : 6/15/93
Found in Baseline             : 1.0.3
Found Date                    : 6/15/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : threads/exc_handling.h
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/15/93 public]
Currently the HP/UX port of DCE has compilation problems when compiler
optimization is turned on.  The version of the compiler being used is:

# what /lib/ccom
/lib/ccom:
        HP92453-01 A.09.19 HP C Compiler
         HP-UX SLLIC/OPTIMIZER  HP-UX.09.00.20 08/13/92
         Ucode Code Generator - HP-UX.09.00.23 8/13/92

Folks at HP suggest that an interim fix is to add the following code to
threads/exc_handling.h:

	#ifdef __hpux
	#pragma OPTIMIZE OFF
	#endif



CR Number                     : 8148
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : HPUX: cma_fcntl error when called with (setfl, O_NDELAY)
Short Description             : cma_fcntl fails when trying to set O_NDELAY
Reported Date                 : 6/11/93
Found in Baseline             : 1.0.3
Found Date                    : 6/11/93
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : cma_thdio_3.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/11/93 public]

NB: This bug is against the 1.0.3 hpux port.
============================================

In rpc/runtime/comsoc_bsd.c/rpc__socket_set_nbio(), there's a call:

   i = fcntl(sock, F_SETFL, O_NDELAY);

This goes into cma_fcntl which does:

	#ifdef __hpux
		tmp_arg |= O_NONBLOCK;

This causes the real fcntl to return EINVAL.  The hpux man page for fcntl
says: 

           [EINVAL]       cmd is F_SETFL and both O_NONBLOCK and O_NDELAY 
                          are specified. 
 
It's not yet clear if this is causing serious problems, but it should be
fixed.  During the port to OSF/1, there were similar issues with one of the
bits being set for the fd, but the other bit being tested later...

[9/23/93 public]

I have two major topics to discuss with respect to this bug: 1) a
question about how the DG RPC runtime can possibly work with this bug;
2) the proposed fix and its ramifications.

1) It is NOT obvious that the DG runtime currently works properly here
for the HP port. The call to fcntl is in rpc__socket_set_nbio, which 
I've copied below. After that, I copied the line where it's called, in
use_protseq(), in rpc/runtime/dgsoc.c. I assume the filer of this
report must have been running RPC in debug mode to see this error, as
the caller does not check the return value from
rpc__socket_set_nbio(). On HP/UX, this call to fcntl() will fail, and 
the flags will remain unchanged. Unless the caller calls fcntl with 
O_NONBLOCK or uses the FIOSNBIO ioctl() request, any subsequent 
recvfrom() attempts on the socket will block (from RPC's perspective) 
if there is no data present.

My question is, does the runtime care if this call fails? If so, the
observable effects should be added to this report and fixed by the DG 
RPC responsible engineer. If not, this bug should be cancelled.

PRIVATE rpc_socket_error_t rpc__socket_set_nbio(sock)

rpc_socket_t        sock;

{
#ifndef vms

    int i;

    i = fcntl(sock, F_SETFL, O_NDELAY);
    if (i == -1)
    {
        RPC_DBG_GPRINTF(("(rpc__socket_set_nbio) error=%d\n", errno));
        return (errno);
    }

    return (rpc_c_socket_ok);

#else
VMS code removed
#endif
}

from rpc/runtime/dgsoc.c:
    /*
     * Set the socket to do non-blocking IO, and to close itself
     * if the process execs.
     */
    rpc__socket_set_nbio(socket_desc);
    rpc__socket_set_close_on_exec(socket_desc);


2) a) We could "fix" this bug by having the threads component mask out
O_NDELAY when it is requested (for __hpux). But this would change the
behavior of the recv* and read system calls. Instead, it should/will
be documented that DCE threads use O_NONBLOCK internally, and that
using O_NDELAY may produce unexpected results on some (HPUX)
platforms.  DCE threads applications (such as DCE RPC) should use
O_NONBLOCK to get non-blocking behavior.

   b) Using O_NONBLOCK in rpc/rpc/runtime/comsoc_bsd.c instead of
O_NDELAY will raise questions about the expected recvfrom/recv/read
semantics in the RPC runtime.  When O_NDELAY is set, recvfrom()
returns zero when there is no data on the socket. If the call to fcntl
is made with O_NONBLOCK, as suggested, a read on a socket with no data
will return (-1). The RPC runtime macros can not handle this, because
they compare the return value to rpc_c_socket_ok, which is defined as
0 (zero). For this change to work, the macros in comsoc*.h will need
to be reviewed and fixed. This looks like a DCE 1.1 change.

  c) O_NDELAY appears in the DCE sources as follows (occurances in
threads are not included). A quick look at the files suggests that
rpc, directory/gds, security, and time may require attention.

#define O_NONBLOCK      O_NDELAY
./directory/gds/oss/prod/cmxxtiport.h
        if (fcntl(fd, F_SETFL, status|O_NDELAY) == D2_ERROR)
./directory/gds/util/d27rdchk.c
                    O_NDELAY|O_WRONLY|O_NOCTTY, 0777, 0, FP_SYS, &fd);
./file/osi/RIOS/osi_port_aix.c
#define O_NDELAY    0
./nosupport/glb/glbd/std.h
    *---* first try to open the file.  We specify O_NONBLOCK and O_NDELAY
to
   if ( (fd = open_file(fn, O_RDONLY | O_NONBLOCK | O_NDELAY, 0)) == -1 )
./nosupport/test/systest/1.0.2systest/file/filewnr.c
    i = fcntl(sock, F_SETFL, O_NDELAY);
./rpc/runtime/RIOS/comsoc_sys.c
    i = fcntl(sock, F_SETFL, O_NDELAY);
./rpc/runtime/SVR4/comsoc_sys.c
 * (see BSD UNIX fcntl(sock, F_SETFL, O_NDELAY))
./rpc/runtime/comsoc.h
    i = fcntl(sock, F_SETFL, O_NDELAY);
./rpc/runtime/comsoc_bsd.c
#  define set_socket_non_blocking(sock) fcntl(sock, F_SETFL, O_NDELAY)
./rpc/runtime/std_15.h
                *fd = open(LRGY_FILE, (O_RDWR | O_CREAT | O_NDELAY |
O_EXCL),
            *nfd = open(LRGY_NEW_FILE, (O_RDWR | O_CREAT | O_NDELAY |
O_EXCL), 0);
                            (O_RDWR | O_CREAT | O_NDELAY | O_EXCL),
            *nfd = open(LRGY_NEW_TGT_FILE, (O_RDWR | O_CREAT | O_NDELAY |
O_EXCL), 0);
./security/client/rca/sec_lrgy.c
    {"O_NDELAY",   O_NDELAY},
./test/file/itl/file/itl_file.c
    *---* first try to open the file.  We specify O_NONBLOCK and O_NDELAY
to
   if ( (fd = open_file(fn, O_RDONLY | O_NONBLOCK | O_NDELAY, 0)) == -1 )
./test/systest/file/filewnr.c
        if ((ttyfd = open("/dev/tty", O_RDONLY | O_NDELAY)) >= 0) {
./test/tet/src/dtet/dtetlib/notty.c
    if ((fd = open(devicename, O_RDWR  | O_NDELAY, 0)) < 0)
./time/service/dts_acts_provider.c

[9/23/93 public]

I forgot to mention that the use of O_NDELAY is not defined by POSIX; but 
O_NONBLOCK is the POSIX way of doing non-blocking I/O.

[9/24/93 public]

Under the right (and not that unlikely) circumstances, this bug could end up 
disabling a DCE application/service.

I expect that as part of the 1.1 code cleanup work, RPC and the other components
will be modified to use O_NONBLOCK (for POSIX conformance).  In the meantime,
it seems like the right thing to do is to fix the CMA library to handle
requests for NDELAY semantics correctly.

[10/15/93 public]
This is realy an enhancement request related to code cleanup and will be 
addresses then.



CR Number                     : 7740
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : thdio_3
Short Description             : possible deadlock/races in cma_dup2
Reported Date                 : 4/16/93
Found in Baseline             : 1.0.2
Found Date                    : 4/16/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
	threads/cma_thdio_3.c
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/16/93 public]

There are two possible races in cma_dup2 (observed while looking for other
cma__g_file locking problems):

1) if cma_dup2 is racing against cma_close on one or the other of the file
descriptors (and cma_close wins), then the entry in cma__g_file may get
stomped to NULL, resulting in a crash.

2) if cma_dup2(a, b) is racing against cma_dup2(b, a), we can deadlock due
to a lock ordering problem.

[10/14/93 public]

add this to the above list:

3) before we deadlock as in 2), above, we can get the assertion "attempt
   to relock a mutex" because both file descriptors refer to the same 
   cma file object and reserving 'a' also reserves 'b'. This happens when 
   both 'a' and 'b' are already open.

4) if another thread closes a fd, cma_dup2 can think it has it (newd) 
   reserved, since it doesn't call cma__is_open(newd) a second time after 
   calling cma__fd_reserve(newd).

[10/14/93 public]

5) if newd == oldd, cma_dup2 increments the reference count; it should just 
   return 0 instead.

[10/20/93 public]
Have fix to check if the file is still open after a possible wait for 
reserve mutex but do not have fix for two calls with opposing file
descriptors. Defered.



CR Number                     : 7470
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : cma__assert_warn
Short Description             : most, if not all, assertion warnings should be fatal.
Reported Date                 : 3/10/93
Found in Baseline             : 1.0.2
Found Date                    : 3/10/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[3/10/93 public]

Note that this is an enhancement request for 1.0.3

I have yet to see a CMA "warning" which didn't indicate a fatal error in
either (a) the program calling CMA or (b) CMA itself.  Rather than dying
immediately and either (a) trapping into a debugger or (b) creating a core
dump indicating the immediate point of the error, CMA emits a (tantalizing
but incomplete) warning message and *keeps on going*, destroying most
evidence of where the error actually occurred.

The easiest way to, umm, fix this is to tweak cma__assert_warn to be the
same as cma__assert_fail..

[3/10/93 public]
added dce-ot-sec to interest list.



CR Number                     : 7322
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : use of wrong error codes
Reported Date                 : 2/23/93
Found in Baseline             : 1.0.2
Found Date                    : 2/23/93
Severity                      : D
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/23/93 public]
Looking at CR 6451 I noticed something was wrong.  The component name being 
used in the error messages is `thd', and it should be `thr'.  The later is
the official abbreviation of the component name.

What does this mean?  It probably means that the current error codes for
the threads component are wrong (since we encode the component name in the
error code).  Taking a brief look at the code I saw that CMA has it's own
cma_error_inq_text which seems to do basically the same thing as
dce_error_inq_text in src/rpc/runtime/dce_error.c.  CMA should really just
use the dce routine (perhaps there is an issue here that it should be moved
from libnck.a to a libdceutils.a perhaps this is a 1.1 thing).

Below is the note from CR 6451 that I saw this in:

  Using nightly build available today (on amigo), and a dce_config altered to
  NOT start sec_clientd (known problem - see OT 6448), I cannot configure
  an initial cds server on pmax:
  
	  Add CDS registry entries
  Current site is: registry server at /.../dfs_cell 
  Domain changed to: principal
  Domain changed to: account
  Exception: Invalid memory address (dce / thd)
  config_basecds[3]: 953 Resources lost
	  Creating the cds.conf file...
	  Starting cdsadv ...
  Exception: Invalid memory address (dce / thd)
  cdsadv failed to start
	  Press <ENTER> to continue or CTRL-C to exit

[8/20/93]
Changing threads to use the DCE routine is planned for 1.1. For now, it
is sufficient to change the encoding of the 3-char component name 
abbreviation. This is done in exc_handling.h in the _EXC_DCE_PREFIX_
constant. The new value is 0x177e9000, where "thr" is encoded in the 
"77e9" part, and the "1" is used to differentiate dce codes from 
errno values. The "000" are placeholders which offset the values. 
The algorithm for creating the value is:
        ((((char1 - 'a') * 40 + (char2 - 'a')) * 40) + (char1 - 'a'))
or	(((('t'   - 'a') * 40 + ('h'   - 'a')) * 40) + ('r'   - 'a'))
	((((19         ) * 40 + (7          )) * 40) + (17         ))

nitro 942 % dc
19 40 * 7 + 40 * 17 + p
30697
q

produces the value in decimal. Converted to hex, it is 0x77e9, and
don't forget to add in the top "1". To test the value  0x77e9, compile
and run the following program (note that it is really in RAD-40, not 
RAD-50):

-- cut --
#include        <stdio.h>
#include        <stdlib.h>
#include        <string.h>

main( int argc, char *argv[] )

{
        int i;
        long code;
        unsigned char name[6];

        if (argc < 2)
        {
            fprintf(stderr, "usage: %s <hexidecimal_number>\n",
                argv[0] );
            exit(1);
        }

        for (i = 0; i < sizeof(name); i++)
                name[i] = '\0';

        i = 1;
        sscanf( argv[i], "%x", &code );
        printf( "decimal representation of code is %d.\n", code);

        /*
         * Convert component name from RAD-50 component code.  (Mapping is:
         * 0 => 'a', ..., 25 => 'z', 26 => '{', 27 => '0', ..., 36 => '9'.)
         */

        name[3] = 0;
        name[2] = code % 40;
        code /= 40;
        name[1] = code % 40;
        name[0] = code / 40;

        for (i = 0; i < 3; i++)
        {
            name[i] += (name[i] <= 26) ? 'a' : ('0' - 27);
        }

        printf("encoded name is \"%s\"\n", name);

}
-- cut --

nitro 945 % rad50_toascii 0x77e9 
decimal representation of code is 30697.
encoded name is "thr"

[9/7/93]
Because of unresolved backwards compatibility issues, this bug is being 
deferred to DCE 1.1.



CR Number                     : 7314
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : cma_mutex.c
Short Description             : thread_mutex_unlock() did not
return an ownership error when attempting to unlock a mutex owned by another thread
Reported Date                 : 2/22/93
Found in Baseline             : 1.0.1
Found Date                    : 2/22/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/22/93 public]

Full Description:

        The function does not complain if invoked with a mutex which is
currently locked by another thread. Seems like this could lead to very
hard to debug problems if this goes undected. The man page for the function
indicates the behavior is unpredictable. Seems like this should be an
error which is deteced.

	If one goes to build cma without defining NDEBUG, he at least get a
warning. But it is said that normally threads package is built with NDEBUG 
defined.

	Here is a short sample program.

#include <pthread.h>
#include <cma_errno.h>

static pthread_t        thread;

pthread_mutex_t     mutex;

static void
my_thread
#ifdef _CMA_PROTO_
        (int thd_id)
#else
        (thd_id)
        int     thd_id;
#endif
    {
    int                 status;

    status = pthread_mutex_lock (&mutex);

    }

int
main
#ifdef _CMA_PROTO_
        (int argc, char *argv[], char *envp[])
#else   /* no prototypes */
        (argc, argv, envp)
        int     argc;
        char    *argv[];
        char    *envp[];
#endif  /* prototype */
    {
    int i, status;

    status = pthread_mutex_init (&mutex, pthread_mutexattr_default);

    status = pthread_create (
        &thread,
        pthread_attr_default,
        (pthread_startroutine_t)my_thread,
        (pthread_addr_t)i);

    pthread_yield();

    status = 0;

    status = pthread_mutex_unlock (&mutex);

    if (!status)
    {
      printf("pthread_mutex_unlock() OK\n");
    }
    else
    {
      printf("status = %d, errno = %d\n", status, errno);
      printf("pthread_mutex_unlock() returned error\n");
    }

}



CR Number                     : 7130
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : cma_config
Short Description             : cma_config enumerations should not overlap.
Reported Date                 : 2/4/93
Found in Baseline             : 1.0.2
Found Date                    : 2/4/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : threads/cma_config.h
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/4/93 public]

There are about a half dozen different explicit enumerations in
cma_config.h which "overlap" in their range.

Since there's no type checking in the preprocessor it might make sense to
split these up into different ranges.. e.g., 100001..100004 for UNIX_TYPE,
200001..200004 for VENDOR, 300001..300004 for PLATFORM, etc.

This change should be limited in scope to this one module.



CR Number                     : 7110
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : cma_signal
Short Description             : should not put in default handler if !_CMA_PROTECT_MEMORYU_
Reported Date                 : 2/3/93
Found in Baseline             : 1.0.2
Found Date                    : 2/3/93
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/3/93 public]

There are two reasons for estabilishing the cma___sig_sync_kill handler:
 - to vector signals to the appropriate per-thread handler
 - to remap the stack guard pages prior to inducing a core dump.

The latter is a no-op on systems where _CMA_PROTECT_MEMORY_ is zero.
In most cases, the former is a no-op.

Post-mortem core dumps on RIOS and HPUX would be easier to diagnose if
cma___sig_sync_kill were not set up until *after* the application asked for
a signal handler.

(yes, I realize that there is an interaction with exception handlers here).



CR Number                     : 7067
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : 
Short Description             : use correct i386 macros
Reported Date                 : 1/29/93
Found in Baseline             : 1.0.1
Found Date                    : 1/29/93
Severity                      : D
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/29/93 public]
All DCE header files should include the definition:

    if defined(i386) || defined(__i386__)

instead of merely saying
    ifdef i386 
or
    if defined(i386)
etc

because the gcc compiler on OSF/1 1.1 has changed to adopt the new
standard in that all internally set macros names now has '__' as
its prefix and suffix.

This is needed for the DME project.

[1/29/93 public]
The fix should be to change the #ifdef to the right value, not just add
another value.  There is an easy work-around (severity A?) to this by using
CENV=-Di386 in the build environment if your compiler doesn't define it.

I'm curious as to which DCE files have this problem.  Also are these
conditionalized sections of code dependent on it being a 386 or on being
OSF/1?  There are no headers in the install tree that mention i386 and
there is only one header in the export tree that does and that's asn1.h.
Is this only a problem with headers?  Why not with .c files?

I've changed this to an enhancement since i386 is not a supported reference
platform.  Also I changed the severity to D since there is a very simple
work-around.  

Well, I also did a grep of the 1.0.2 backing tree and found 3 references to
i386 in only two files (decnet_types.h and asn1.h).  So I imagine that this
bug report is not intended toward our code.

[03/30/94 public]
I don't think we have a problem with this anymore.
Canceled.

[3/30/94 public]

Now at: /project/dce/build/dce1.1/export/hp800/usr/include/dce

absolut include/dce$ gegrep [^_]i386 *.h
cma_config.h:#  ifdef i386
exc_handling.h:#  if defined(i386)
absolut include/dce$ 

Yes, code cleanup should fix this.  I just don't see the need to cancel a
bug before all occurances have been fixed :-)

[03/30/94 public]
Well, if you are going to open it up, you have to take resonsibility
for getting it fixed.  Don't punt the problem on to my lap!

[3/30/94 public]
Sorry, tom, I did change it to "cma" I forgot to change resp. enginneer.
And it don't have to be me, there is no rule that if you open it you have
to be the one to fix it.  :-)

[3/30/94 public]
Its a threads bug that will be fixed by code cleanup. I've assigned it 
to myself.



CR Number                     : 6886
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8025
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : IO wrappers
Short Description             : close() of fd being waited for confuses CMA
Reported Date                 : 1/18/93
Found in Baseline             : 1.0.2
Found Date                    : 1/18/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[1/18/93 public]
The enclosed test program demonstrates a defect with CMA: if you close a
file descriptor which is being listened on by another thread, CMA gets
horribly confused, with a bunch of assertions and then a core dump.
(reader_proc) blocking
(close_proc) sleeping
(close_proc) pipes[0]
**** Assertion warning. cma__close_general:  Closing a file with threads waiting to read.
     at line 447 in /project/dce/build/dce1.0.2/src/threads/cma_thread_io.c
**** Assertion warning. cma__close_general:  Closing a file with threads waiting for exception.
     at line 453 in /project/dce/build/dce1.0.2/src/threads/cma_thread_io.c
**** Assertion warning. cma__close_general:  Closing a file with read mask bit set.
     at line 456 in /project/dce/build/dce1.0.2/src/threads/cma_thread_io.c
**** Assertion warning. cma__close_general:  Closing a file with except mask bit set.
     at line 462 in /project/dce/build/dce1.0.2/src/threads/cma_thread_io.c
(close_proc) sleeping again
%Internal DCE Threads problem (version CMA BL10+), terminating execution.
% Reason: cma__io_available: File was unexpectedly closed
% See 'cma_dump.log' for state information.
zsh: IOT instruction (core dumped)  ./test-close
The obvious "correct" behavior in this case is that the system call should
be retried with the FD closed; otherwise, this breaks any legacy program
which calls a DCE library and then does a
"for (i=3; i<getdtablesize(); i++) close(i); exec()"
#undef _CMA_NOWRAPPERS_
#include <pthread.h>
#include <unistd.h>     
pthread_t reader;
pthread_t closer;
int pipes[2];
void *reader_proc (void *arg)
{
    char buf[1024];
    int ret;
    
    do {
	printf("(reader_proc) blocking\n");
	ret = read (pipes[0], buf, 1024);
	printf("(reader_proc) returned %d\n", ret);
    } while (ret > 0);
    printf("(reader_proc) returns now.\n");
    return 0;
}
void *close_proc (void *arg)
{
    struct timeval tv;
    tv.tv_sec = 10;
    tv.tv_usec = 0;
    printf("(close_proc) sleeping\n");
    select (1, 0, 0, 0, &tv);
    printf("(close_proc) pipes[0]\n");
    close (pipes[0]);
    tv.tv_sec = 10;
    tv.tv_usec = 0;
    printf("(close_proc) sleeping again\n");
    select (1, 0, 0, 0, &tv);
    printf("(close_proc) pipes[0]\n");    
    close (pipes[1]);
    tv.tv_sec = 10;
    tv.tv_usec = 0;
    printf("(close_proc) sleeping a third time\n");    
    select (1, 0, 0, 0, &tv);
    printf("(close_proc) returning now\n");
    return 0;
}
main()
{
    pthread_addr_t status;
    
    pipe(pipes);
    
    pthread_create (&reader, pthread_attr_default, reader_proc, 0);
    pthread_create (&closer, pthread_attr_default, close_proc, 0);
    
    pthread_join(reader, &status);
    pthread_join(closer, &status);
}

[01/27/93 public]
So far I've gotten it down to the following code in cma__io_available.
Select has returned EBADF on the closed file descriptor. Need to check
with DEC to see if they have the FIX-ME in hand for this.....
                        if ((fstat (i, &buf) == -1) && (errno == EBADF)) {
                            cma__assert_warn (
                                i < cma__g_file_num,
                                "Big, bad, file descriptor.");
                            /*
                             * FIX-ME:
                             *
                             * What should happen here is we need to
"defer"
                             * a cma_close() on this file.
                             */
                            cma__bugcheck ("cma__io_available: File was
unexpectedly closed")
assigned to dec.

[5/25/93 public]
Filled in Interest List CC with `comer@transarc.com' 
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'

[10/19/93 public]
The fix for this involves an interaction between cma_close,
cma__close_general and cma__io_availacbe that I'm not comfortable 
with at this point in the schedule. Defered.



CR Number                     : 6854
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : 
Short Description             : Make handling of blocking file
descriptors more dynamic.
Reported Date                 : 1/15/93
Found in Baseline             : 1.0.2
Found Date                    : 1/15/93
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[1/15/93 public]
The method cma employs to check for pending io on blocked
descriptors needs to be made more flexible. It currently uses
a fd_set bit mask to to keep track of all possible open files
which works if the maximum number of open files is <= to the
fd_set width. On OSF/1 1.1.1 this is not the case. The maximum
number of open files is dynamic and defaults to 1024 while
the width of fd_set is, short of forcing the application to 
redefine FD_SETSIZE prior to includeing types.h, fixed at 256.
The work around for 1.0.2 is to have cma_init drop the maximum
number of open file descriptos to 256.



CR Number                     : 6394
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : 
Short Description             : TRY gets compile warnings on hpux
Reported Date                 : 12/9/92
Found in Baseline             : 1.0.2
Found Date                    : 12/9/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[12/9/92 public]

Each occurance of the TRY macro in the source gets two compile-time
warnings on HPUX (the compiler is very finicky about casting volatile data
to non-volatile data).  Since we're using HPUX systems for development of
new features, this causes us to tend to ignore compiler warning messages
(which is generally a Bad Thing).

The fix is somewhat convoluted, but can be appropriately #ifdef'ed so that
non-HP-UX compilers see exactly the same source (modulo whitespace changes)
after the preprocessor.

A context diff of the fix will be posted here shortly..



CR Number                     : 5624
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : thr
Subcomponent Name             : 
Short Description             : threads functional tests shouldn't build against libcma.a
Reported Date                 : 10/13/92
Found in Baseline             : 1.0.1
Found Date                    : 10/13/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[10/13/92 public]
Ram Balaraman rediscovered today that at least the threads functional
tests (and perhaps others) are linked against a static libcma.a on the
RIOS, rather than against the shared libdce.a.  This is because a few
symbols originally defined in .s files cannot be used successfully from
libdce.a.  If an application using these symbols is linked against
libdce.a, it will fail in mysterious ways (see OT defects 2631 and
2632).

Though we accepted linking against libcma.a as a workaround for 1.0.1,
it's not acceptable as a permanent fix, for two reasons:  1) disk space
(the statically-linked tests taken about 400KB apiece), and 2)
correctness (the functional tests really should be linked against the
same library as DCE itself uses).

So this defect is a reminder that "we" (probably actually someone at
IBM) need to resolve this for 1.0.2.

[10/19/92 public]

OT cleanup 1 : Severity = unchanged (B)  ;  Priority = unchanged(2)
               Assigned to myself.

N.B. I assigned the bug to myself for the time being. Either IBM or
     I will fix it.

[11/03/92 public]
Changed responsible engr to jd (John Dugas, osf)

[01/18/93 public]
I'm told the problem is that AIX uses an import mechanism for its shared
objects. An import/export file is required for some of the tests and the
threads person in Austin is checking on it.

[02/03/93 public]
The problem here is that at least three of the tests reference 
the symbol cma__transfer_thread_ctx. This is an internal function
that is contained in the assembler module and doesn't get exported
from the shared object libdce.so. The build of these test modules
run into undefined symbol as a result. The remaining test modules
build just fine with libdce. Other executables never reference 
the function directly. We might want to figure out how to link all
but these modules to libdce and link these to libcma or just leave
them the way they are. The makefile LIBS line does the right thing.
The tests themselves pass just fine linked agains libcma.a
I'm going file this as an enhancement to be revisited later.



CR Number                     : 5213
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : pthread_unlock_global_np
Short Description             : pthread_unlock_global_np(3thr)
returns an exception when called twice or called by a non-owner
Reported Date                 : 8/26/92
Found in Baseline             : 1.0.1
Found Date                    : 8/26/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/26/92 public]

        An exception is returned when extra pthread_unlock_global_np() is
	called, or called by a thread which is not the owner.

	Although the man page clearly says that the behavior under such
	cases is undefined, a warning or error return would be more
	proper.

	The following are two test cases:

---------------------cut here for test 1---------------------------
#include <pthread.h>
#include <cts_test.h>

main()
{

        cts_test("lock", "test");
        pthread_lock_global_np();
        pthread_unlock_global_np();

        pthread_unlock_global_np();

        cts_result();

}

----------------------cut here for test 2-------------------------------
#include <pthread.h>
#include <cts_test.h>

static void locker()
{
    /* lock the global mutex for trouble */
    pthread_lock_global_np();

    /* now back to the creating routine */
    pthread_yield();
}

static void not_owner()
{
    pthread_t thread;
    int status;

    status = pthread_create (
                &thread,
                pthread_attr_default,
                (pthread_startroutine_t)locker,
                (pthread_addr_t)0);
    check(status,"pthread_create");

    pthread_yield();            /* give it a chance to lock */

   /*
    * the man page says the result of unlocking the global mutex
    * when it is owned by another thread is undefined
    */
    pthread_unlock_global_np();
}

main ()
{
    struct timespec delay;
    int status;
    int join_status;
    pthread_addr_t      result;

    cts_test ("unlock_global_err","Test errors for pthread_global_unlock_np()");

    printf("not_owner();\n");
    not_owner();

    cts_result ();

}

[01/21/93 public]

The person who filed this defect originally (From HaL Computers) came back
to ask and ask if it has been fixed in 1.0.2. When he got to know that it
is still open, he expressed his concern and asked if the priority can be
raised.

[01/25/93 public]
I agree it would be nice to warn the programmer rather than
raise the exception in this and probably a number of other 
calls that are documented as undefined under various circumstances.
But I don't beleive there is time in the 1.0.2 schedule. If
I get come slack I'll look at it but I can't commit to it.



CR Number                     : 4977
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : threads/cma_message.c
Short Description             : Porting issue: define
nl_sprintf for other platforms
Reported Date                 : 8/10/92
Found in Baseline             : 1.0.1
Found Date                    : 8/10/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/10/92 public]

        nl_sprintf (and two others) get defined only when building on
        AIX or OSF/1. WHne building on other platform, you don't see the
        problem until you try to link with cma.a or dce.a, then you get
        unsolved symbol.

Proposed Solution:

        If we don't know what value is proper for other platforms, at least
        we can make compiler error by saying sth. like 

        #ifndef nl_sprintf
        print error, check your system
        #endif

        so that poeple get aware ofthis problem before too late.



CR Number                     : 4920
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8237
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : thr
Subcomponent Name             : signal handling
Short Description             : CMA loses SIGCHLD
Reported Date                 : 8/4/92
Found in Baseline             : 1.0.1
Found Date                    : 8/4/92
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[8/4/92 public]

  I found that there is a situation in which SIGCHLD gets lost i.e. sigwait()
does not receive SIGCHLD. The following program illustrates the situation.
This program used to work with dce.19e. I think there has been some
modification to CMA with respect to how SIGCHLD is handled but that should
not create this situation. You may verify that the problem is menifested
only with SIGCHLD by simply replacing SIGCHLD with SIGHUP. The program will
work as expected.

Note: The following program is assuming that while sigwaiting it will
first receive SIGCHLD and then SIGINT. This is not a valid assumption.
This assumption is not affecting the bug I'm trying to reproduce through
this program.

compile instruction: xlc_r -D_ALL_SOURCE -o sigchld_lost sigchld_lost.c
--------------------------------- sigchld_lost.c ---------------------
/*
 * sigchld_lost.c:
 *   This program finds out whether a sigwait() call loses the SIGCHLD
 * signal while waiting for other signals.
 *
 */

#include <pthread.h>
#include <stdio.h>
#include <errno.h>
#include <signal.h>

int doneFlag = 0;

char *msg = "\
\n    We expect to return form the next sigwait() waiting on SIGINT since\
\n    SIGINT signal should already be pending. If sigwait() does not return\
\n    it is probably an error. Press ^C to generate a new SIGINT signal and\
\n    the program will terminate normally.\n\n";

WaitThread()
{
    sigset_t waitUpon;
    int sig;

    (void) sigemptyset(&waitUpon);
    (void) sigaddset(&waitUpon, SIGCHLD);
    (void) sigaddset(&waitUpon, SIGINT);
    fprintf(stderr, "sigwait: waits on signals SIGCHLD(20), SIGINT(2)\n");
    if ((sig = sigwait(&waitUpon)) == -1) {
        fprintf(stderr, "sigwait: error (%d)\n", errno);
    } else {
        fprintf(stderr, "sigwait: returned because of signal %d\n", sig);
    }

    fprintf(stderr, msg);
    (void) sigemptyset(&waitUpon);
    (void) sigaddset(&waitUpon, SIGINT);
    fprintf(stderr, "sigwait: waits on signal SIGINT\n");
    if ((sig = sigwait(&waitUpon)) == -1) {
        fprintf(stderr, "sigwait: error (%d)\n", errno);
    } else {
        fprintf(stderr, "sigwait: returned because of signal %d\n", sig);
    }
    doneFlag = 1;
}

main(argc,argv,envp)
    int argc;
    char **argv;
    char **envp;
{
    pthread_t tid;
    sigset_t sigMask;

    (void) sigfillset(&sigMask);
    (void) sigdelset(&sigMask, SIGVTALRM);
    if (sigprocmask(SIG_SETMASK, &sigMask, NULL) == -1) {
        fprintf(stderr, "sigprocmask: error (%d)\n", errno);
        exit(1);
    }

    if (kill(getpid(), SIGCHLD) == -1) {
        fprintf(stderr, "kill: error (%d), signal SIGCHLD\n", errno);
    } else {
        fprintf(stderr, "kill: sent signal SIGCHLD\n");
    }
    if (kill(getpid(), SIGINT) == -1) {
        fprintf(stderr, "kill: error (%d), signal SIGINT\n", errno);
    } else {
        fprintf(stderr, "kill: sent signal SIGINT\n");
    }

    if (pthread_create(&tid, pthread_attr_default, WaitThread, NULL) == -1) {
        fprintf(stderr, "pthread_create: error (%d)\n", errno);
        exit(2);
    }

    while (doneFlag == 0)
        pthread_yield();

    exit(0);
}

[10/20/92 public]

OT cleanup 1 : Severity = unchanged(B) ;  Priority = unchanged(2)
               Assigned to keane.

[10/15/93 public]
This behavior is unfortunatly correct. See ot 8237 for a pretty complete
explaination of what the problem is. Basically the default action for
SIGCHILD on most implementations is to ignore it. POSIX states that 
such signals will not be received. This action can;t be changed with 
sigaction due to the fact that its an asyncronous signal and sigaction
is undefined for such signals according Draft 4 of the threads standard.
FOr these reasons sigwait will never see this signal. I'm not going to
completly cancel this but make it an enhancement request so we can look
at we might do to work around the problem, Its not a bug however.



CR Number                     : 4880
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : cma_timer.c
Short Description             : cma__check_timer_queue()
should return cma_c_false even when the queue is empty later on
Reported Date                 : 7/29/92
Found in Baseline             : 1.0.1
Found Date                    : 7/29/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/29/92 public]

No external symptoms other than the performance could be slightly better.

In cma_timer.c: cma__check_timer_queue() always returns cma_c_true, unless
        the queue is empty when the routine is entered.
        If the queue is not empty when the routine is entered and the
        queue becomes empty while in the routine,
        the value cma_c_true is still returned. This may return the wrong
        value to the null thread causing the wrong value to be passed
        to select.

In the normal case where a single timer is active (say one
pthread_delay_np),
when the timer expires, cma__check_timer_queue is called twice before
it returns false.

Repeat By:

Run once with one pthread_delay_np and trace the code to see
that cma__check_timer_queue will return true/false, when the timer expires
and is moved by cma___null_thread.

Proposed Solution:

Change cma__check_timer_queue() as follows:

Right after:
    if (!cma__queue_empty (&cma___g_timer_queue)) {

set ret_val to cma_c_true.

Later, right after:
        if (cma__queue_empty (&cma___g_timer_queue)) {
            cma__zero (&cma__g_next_tqe);

set ret_val to cma_c_false.

Delete:
        ret_val = cma_c_true;

right after the call to cma__subtract_time().



CR Number                     : 4877
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : thr
Subcomponent Name             : threads/cma_util.c
Short Description             : Casting a char * to an int before arithmetic does not work on some hardware.
Reported Date                 : 7/29/92
Found in Baseline             : 1.0.1
Found Date                    : 7/29/92
Severity                      : D
Priority                      : 3
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[7/29/92 public]

In cma_util.c:cma__strlen(), the line:
    return ((cma_t_integer)tmpstr - (cma_t_integer)s -1);
will return an incorrect value when the character pointers are not word
aligned. Since a Cray is not byte addressible, the compiler keeps the
byte within word in the high ordered bits of the char *. When casting
to an int, this results in large positive or negative numbers, ...

Repeat By:

Running the above (non-portable) code on a non-byte addressable machine.

Proposed Solution:

Change the above to:

    return (tmpstr - s - 1);



CR Number                     : 4495
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : 
Short Description             : Signature mismatch with same
function in OSF/1
Reported Date                 : 6/26/92
Found in Baseline             : 1.0.1b20
Found Date                    : 6/26/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/26/92 public]

pthread_signal_to_cancel_np()'s signature in DCE is different than
what is in OSF/1. That is the second argument of this api is of
type 'pthread_t *' in DCE instead of 'pthead_t' in OSF/1 pthread
implementation.

[06/29/92 public]
While we recognize the importance of harmonizing the interfaces
presented by the DCE and OSF/1 Pthreads implementations, this
is an enhancement that won't be performed for 1.0.1.  Defer it
till afterward.



CR Number                     : 4365
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : ./threads/cma_thread_io.c
Short Description             : The non_blocking field for socket type file should be set to false.
Reported Date                 : 6/19/92
Found in Baseline             : 1.0
Found Date                    : 6/19/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/19/92 public]
Full Description:

I am porting DCE thread package to Sun Sparc and am running the
thread test code. All the test cases with socket failed: infinitely waiting
for message to come: the process is blocked, no one else can run.

I traced the code and found the following problem: the non-blocking filed
of 
cma__g_file_obj for the socket file descriptor is set to true in
cma__open_general() when the socket is opened. Thus, when a recvmsg
(cma_recvmsg) is called to receive a message from another thread, the
cma__ts_func macro lets it execute the recvmsg sys call without doing io
wait, hence hanging the whole process. When I set that field in debug to
false, the test case runs fine.

This is not a Sun specific problem. I believe that it would cause failure
on
AIX and OSF/1 machines, unless the kernel thread is usedin OSF/1 case. Did
we
run all the thread test before shipping 1.0? I found OT 2317, which
described
a similar problem, but was taken as something else.

I further looked at the 1.0.1 code. A new field set_non_blocking is added,
but I am afraid that it does not fix this problem with my code inspection.
cma__set_non_blocking is called in cma__ts_func when non_blocking is true,
and the function is still carried out without setting io to wait. Can you
successfully run those socket related test case with 1.0.1 code?


Repeat By:

	Run any thread test case with socket (cuvb_nbi_002 for example).

Proposed Solution:

	The following patch is for 1.0 code:

*** cma_thread_io.c.orig	Fri Jun 19 17:44:17 1992
--- cma_thread_io.c	Fri Jun 19 17:48:52 1992
***************
*** 1094,1100 ****
  	     * According to the documentation, this means the file is a
socket.
  	     */
  	    case EOPNOTSUPP: {
! 		cma__g_file_obj[fo].non_blocking = cma_c_true;
  		cma__trace ((
  			cma__c_trc_io,
  			"(open_general) fd %d is a socket (EOPNOTSUPP)",
--- 1094,1101 ----
  	     * According to the documentation, this means the file is a
socket.
  	     */
  	    case EOPNOTSUPP: {
! 		/* socket's non-blocking field should be set to false */
! 		cma__g_file_obj[fo].non_blocking = cma_c_false;
  		cma__trace ((
  			cma__c_trc_io,
  			"(open_general) fd %d is a socket (EOPNOTSUPP)",
***************
*** 1136,1141 ****
--- 1137,1144 ----
  	    case S_IFCHR:
  	    case S_IFBLK:
  	    case S_IFREG:
+             case 0:             /* Yet another SOCKET possibility... */
+             case S_IFSOCK:
  	    case S_IFLNK: {
  		cma__g_file_obj[fo].non_blocking = cma_c_false;
  		break;
***************
*** 1145,1154 ****
  	     * For the following types of files, setting non-blocking mode
is
  	     * just the right thing to do, so do it.
  	     */
- 	    case 0:		/* Yet another SOCKET possibility... */
- #if _CMA_VENDOR_ != _CMA__APOLLO
- 	    case S_IFSOCK:
- #endif
  	    case S_IFIFO: {
  		cma__g_file_obj[fo].non_blocking = cma_c_true;
  		break;
--- 1148,1153 ----


wwang 6/26

When a socket is opened as UNIX socket, its file statuys is S_IFIFO. I
think its non_blocking filed should also be set to false, instead of true.

wwang 6/26

I looked at 1.0.1 code again and realized that 1.0.1 actually fixed this 
problem by adding a new function cma__set_nonblocking. When a file is
opened, its new set_non_blocking field is always set to false. And later if
its non_blocking filed is true, it calls cma__set_nonblocking to call
fcntl to explicitly set the file to be non blocking.

Since by default, all files are opened as blocking, I think it may make
more sense to just set the non_blocking field to always false. This will
make all cases working.

[06/29/92 public]
Just for the record:  I don't believe the analysis above is quite
correct (for either the 1.0 or the 1.0.1 code).  In the 1.0 code,
setting the non_blocking field of the file object to true does *not*
indicate an assumption that the file is already set up for non-blocking
I/O.  Rather, it indicates that an fcntl() call is to be done, later in
cma__open_general(), that will force the file to be set non-blocking.
My guess (and that's all it is) is that this fcntl call (F_SETFL) isn't
working under SunOS, such that the file remains blocking even after the
call.

Setting non_blocking to false, which is one way around this problem,
disables a significant performance optimization, since it forces CMA
always to enter cma__io_wait() for any I/O on the file, rather than
trying the I/O once, then falling into cma__io_wait() if the operation
would block.  Thus it is desirable to continue setting files to be
non-blocking (and setting a flag to indicate this) wherever possible.

The 1.0.1 code changed in this area due to a problem (reported as
defect 2540) caused by always setting files to be non-blocking as soon
as they're opened.  The intent of the changes is to delay this setup
until the first time a file is used.

So:  there is a portability problem here, at least in the 1.0
source base.  Until we know what it is, we can't know if it's
fixed in 1.0.1.  But it's not the problem detailed above...

And, yes, all functional tests were run (and are still being run)
with both the 1.0 and 1.0.1 testcase sources, including those
that failed here.

[07/01/92 public]
Don is right. It is indeed a portability problem. To set the status to be 
non-blocking using fcntl() on Sun, one can only use FNDELAY, not O_NDELAY,
nor O_NONBLOCK.

Realizing this, 1.0.1 still has the same portability problem.

[09/10/92 public]
I think the bottom line here is that the setup of cma___c_non_blocking_flag
in cma_thread_io.c should be modified to force each port of CMA to
choose its own flag from among the (obviously inconsistent) set of
possibilities.  The current code rather optimistically defaults to
using the POSIX O_NONBLOCK flag.  This becomes an enhancement request.



CR Number                     : 4326
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : thr
Subcomponent Name             : 
Short Description             : no atfork support on ref. platforms
Reported Date                 : 6/18/92
Found in Baseline             : 1.0.1b18
Found Date                    : 6/18/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[6/18/92 public]
Discovered during system test (see OT 4147, dcecdnam RPC client hangs
during fork() call). We suspect lack of atfork() support within RPC
is causing the hang. In any event, this should be fixed for other/future
unsuspecting (forking) dce rpc applications.

[06/23/92 public]
In general, forking is not supported in DCE programs.  I made this as C2
enhancement, and made it a general DCE issue (not RPC/Nat Mishkin) since
we do not know what other areas within DCE need to be made fork-safe.



CR Number                     : 2995
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : thr
Subcomponent Name             : cma
Short Description             : Assert error in cma_errors.c
Reported Date                 : 4/22/92
Found in Baseline             : 1.0.1b11
Found Date                    : 4/22/92
Severity                      : B
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[4/22/92 public]
The following assert message appeared while running the DFS scout
program.  The program had been running for about 1.5 hours.

**** Assertion failure. About to enter kernel when already in kernel.
     at line 258 in ../../../src/threads/cma_errors.c

Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[05/15/92 public]
Brian's still investigating this one.  The problem is that cma_error(),
which is itself an error output routine, asserts that it is not
called from within the CMA kernel.  Somehow, it was.  As a result,
cma_error() itself blew up, obscuring whatever failure had caused
cma_error() to be called in the first place.

An exhaustive check by Brian of the callers of cma_error() did
not reveal any case in which the routine could be called from
within the CMA kernel.

[05/22/92 public]
Our belief is that a) the underlying problem that caused cma__error()
to be called wrong (and hence to fail its assertion check) is a rare
occurrence, and (therefore) b) that this bug is not really a priority
1, since it's not impeding anyone's development.

We do, of course, want to understand the cma__error() failure, but
completing the checking required to find the erroneous call to
cma__error() will require more time than we have this week to put into
it.

[10/20/92 public]

OT cleanup 1 : Severity = unchanged(B)  ;  New priority = 1
                                           Old priority = 2

N.B. I raised the priority to 1 because this bug needs to be resolved.
     since this has the potential for violating the 1.0.2 exit criteria
     i.e. 1.0.2 cannot ship with any code defects open for more 180 days 
     old.

[10/20/92 public]
This defect is a dup of 5389.  I'm not marking it that way, though,
so as to avoid losing age information.  See the description of 5389
for more details.

[12/29/92 public]
Just reporting that this has been seen again. I was running a simple
DFS glue test on a rios configured as a sec, cds and FL server using
dce1.0.2b9. Unfortunately, since we do not have a thread-knowledgeable
debugger on the rios, path information can not be obtained.

[01/27/93 public]
From the above discussions we know that there are paths through
the threads code where cma_error gets called with the kernel lock
in hand. Attempts have been made to find these occurrences through
code examination and failed. The problem arises so infrequently that
we don't have enough data on hand to isolate it. As soon as 1.0.2
os shipped I'd like to add an identifying argument to the cma_error
function, it might be through a macro controlled by NDEBUG, so we
can at least identify the offending calls. The last time it happened
however was late December and the time before that was October.
We aren't likely to get a handle on this before ship and it doesn't
seem to happen often enough to have serious impact. I'm defering
this to after the 1.0.2 ship.

[9/8/93 public]

This bug exposes the larger issue that cma__error() can not indicate
the caller's _FILE_ and _LINE_ since it is a function call. This is an
enhancement which is begging to be done.

To do the enhancement, cma__error() will be changed to a macro which
prints out _LINE_ and _FILE_ of the caller. To keep the number of 
printf's from increasing, a substitute for cma__assert_fail will be 
written for cma__error() which has one less printf.

So far as this bug and its dup, CR5389, are concerned, it has not been
seen recently, but when it occurs, it can hardly go unnoticed, since
cma__error() causes an exception to be raised. We suspect that the bug
may no longer exist, since it has not been reported recently.

So, unless there are any objections, cma__error() will be changed to
be a macro. Instead of providing useless _LINE_ and _FILE_ information
about the line and file name of the cma__error() function, it will
give the line and file name of the caller. This will serve the purpose
of gathering more data about this and future/other bugs which cause
termination in the same manner. Since this bug has not been seen in a
while, it will be considered fixed when the enhancement is complete. If 
or when it is seen again, there will be better data about the calling 
code and it can be re-opened or re-submitted.

[10/13/93 public]
The bug that was causing cma__error to be called with kernel lock in hand 
hasn;t been seen in quite a while. What we want to do is fix up cma__error
with some code to tell us where it is called from so that if we do hit the
problem again we can get more information. cma__error is going to be 
reworked as part of the servicability requirements during 1.1 and that is
the time to do what we want to do with it. We;ll make this ot into an 
enhancement request for this work.



CR Number                     : 2954
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : cma_open() does not support FIFO files
Reported Date                 : 4/21/92
Found in Baseline             : 1.0.1
Found Date                    : 4/21/92
Severity                      : E
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/21/92 public]
The cma_open() call does not currently support POSIX named pipes (FIFO files).
This is obvious from looking at the code.  The cma__ts_open() macro simply
calls open directly with a lock held.  If the open() call blocks, and the
application expects to open the other end of the pipe in a separate thread,
then the program will hang indefinitely.  Ideally, cma_open() should not
block, but should allow other threads to continue execution.

[05/15/92 public]
This bug is still open, and will remain so throughout 1.0.1.
The priority says it all...

[10/20/92 public]

OT cleanup 1 : Severity = unchanged(E) ; New priority = 1
                                         Old priority = 3

N.B. Raised the priority to 1 because this bug has the potential
     for violating the 1.0.2 exit criteria i.e. 1.0.2 cannot ship
     with any bug older than 180 days old. Raising the priority DOES
     not mean that the defect has to be *fixed*. It DOES mean that a
     decision MUST be made quickly regarding what to do with the bug.
     Some of the possibilities are:

     a. cancel the bug
     b. is such a lower priority that it is not going to be fixed, 
        but it could be documented as a limitation. 
     c. the bug will be fixed.
     d. convert this to an enhancement.
     
     I will revisit this and update this CR as to what my recommendations
     are for dealing with this defect (I can't do it this instant because 
     I am in the middle of OT cleanup which is the highest priority item 
     I have to do).

[10/30/92 public]

I believe this defect should be reclassified as an enhancement.  I will do so in a few
days if I hear no dissent.

[11/05/92 public]
Made this an enhancement request, unassigned.



CR Number                     : 2789
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : thr
Subcomponent Name             : 
Short Description             : threads.mk defines CFLAGS for specific .o files
Reported Date                 : 4/15/92
Found in Baseline             : 1.0.1
Found Date                    : 4/15/92
Severity                      : B
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/15/92 public]
threads.mk defines <MACHINE>_libcma_OFILES.  This definition should be moved 
into machine dependent machdep.mk files in the libcma directory.
VAX_libcma_OFILES       ?= cma_vmprot.o
MIPS_libcma_OFILES      ?= cma_vmprot.o
MACH_libcma_OFILES      ?= cma_vmprot.o
PMAX_libcma_OFILES      ?= cma_vmprot.o
RIOS_libcma_OFILES      ?= getasyncinfo.o
HP300_libcma_OFILES     ?= cma_host.o
HP800_libcma_OFILES     ?= cma_host.o
APOLLO68K_libcma_OFILES ?= cma_host.o
threads.mk also defines <MACHINE>_INCLUDES which should be moved into 
machdep.mk files for the directory that it is used in.
MIPS_INCLUDES   ?= cma_host.h
RIOS_INCLUDES   ?= cma_host.h
PMAX_INCLUDES   ?= cma_host.h
HP800_INCLUDES  ?= cma_host.h
HP300_INCLUDES  ?= cma_host.h
APOLLO68K_INCLUDES ?= cma_host.h

[4/15/92 public]
Changed time to threads.  Problem is realy in threads.mk

[4/15/92 public]

Assigned to threads/Brian Keane/DEC, and changed mckeen@osf.org to mckeen
so he will get mail.

[04/24/92 public]
Since nothing is really "broken" by the current state of affairs, this
looks much more like an enhancement request than a defect report.  I
think it should be deferred till after 1.0.1.



CR Number                     : 2697
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : 
Short Description             : pthread_create should have EINVAL as a return value.
Reported Date                 : 4/13/92
Found in Baseline             : 1.0
Found Date                    : 4/13/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[4/13/92 public]
The return value EINVAL is not either in the code of the documentation
for the function call pthread_create. For many test cases, the return
value in pthread_create is EAGAIN, indicating that the system has a
problem, when, in fact, the user may have inserted an invalid value in
a parameter. The code, as well as the documentation, should allow a
return value of EINVAL to give the user more correct feedback.

[04/17/92 public]
The use of EINVAL, though not required by the standard for
pthread_create(), does seem like a useful extension, given the use
of this error return by other entry points.

However, I think providing it is an enhancement, not a bug fix, and
hence want to defer doing so till after 1.0.1.



CR Number                     : 2669
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : app_ref
Short Description             : Threads man pages make no statement about possible exceptions.
Reported Date                 : 4/9/92
Found in Baseline             : 1.0
Found Date                    : 4/9/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Sensitivity                   : public

[4/9/92 public]

	When using the exception returning interface, the user has no way
	to determine what exceptions may be returned. Each man page should
	state the likely exceptions for the function just as it states the
	return values for the error return interface.
	Add possible exception return values to man pages?

[1/22/93 public]
The change request is really an enhancement, not an actual bug. As a
result, I changed the status to "enhancement". No changes were made
in the documentation.

[06/10/93 public]
Changed "Responsible Engineer" to "osf".  Writer TBD.

[07/06/93 public]
Assigned this CR to writer Doug Weir.

weir 10/26/94 public]
Deferred to 1.2.

[6/30/95 public]

Assigned to HP for DCE 1.2.



CR Number                     : 2136
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : thr
Subcomponent Name             : app_gd
Short Description             : discussion of mixed environments needed
Reported Date                 : 2/21/92
Found in Baseline             : 1.0.1b1
Found Date                    : 2/21/92
Severity                      : C
Priority                      : 2
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[2/21/92 public]
A discussion is needed of the problems of mixed use of DCE and non-DCE
threads environments. For example, what happens if an application
wants to use Sun LWP and DCE together?

[03/20/92 public]
Assign to DEC documentation group.  (NB: there is *no* code
component to this defect.  Davie Robinson has been assigned
as code engineer only so that short-format OT reports will
show his name as owning this defect.)

[1/14/93 public]

Please defer this enhancement to the next major release.

[06/10/93 public]
Changed "Responsible Engineer" to "osf".  Writer TBD.

[07/06/93 public]
Assigned this CR to writer Doug Weir.

[10/26/94 public]
Deferred to 1.2.

[6/30/95 public]

Assigned to HP for DCE 1.2.

[7/5/95 public]

Updated interest list.



CR Number                     : 1670
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : thr
Subcomponent Name             : 
Short Description             : pthread_exit cannot be called from main()
Reported Date                 : 06/20/91
Found in Baseline             : .38
Found Date                    : 
Severity                      : D
Priority                      : 1
Status                        : open
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 
Affected File(s)              : 
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[01/29/92 public]

Orbit reference number 2086
reference     
product       dce_osf
phaseFound    development

History:
lastUpdate    91/11/05 15:38:19
endDate                                
assignDate    91/10/30 14:57:44   





    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    91/06/20 10:48:54    create          hirsch (Phil Hirsch)
    91/07/11 16:24:52    return          wkh (Ward K. Harold)
    91/07/12 08:53:22    note            ebrown (Erik Brown)
    91/10/30 14:57:44    reopen          hirsch (Phil Hirsch)
    91/10/31 07:23:10    note            hirsch (Phil Hirsch)
    91/10/31 09:24:40    modify          adm (DCE Family Administrator)
    91/11/05 15:38:19    modify          drb (Defect Review Board)

[06/20/91 public]
The below test shows that CMA raises an exception when the initial thread
(the main() routine) exits.  However, I can't find any provision for
this in the pthread spec (P1003.4a/D4).  The text for pthread_exit()
says

        "The process will exit when the last running thread calls
         pthread_exit()."

which seems to imply that main() should behave like any other thread.

When this test is run, the following error appears when main() calls
pthread_exit:

      %CMA exception, Current thread has been requested to exit.
      IOT trap (core dumped)

========================== start of test program ============================
/*
 * Copyright (C) 1990 Transarc Corporation
 * All Rights Reserved
 */
/*
 * main_test.c -- test early exit of the main routine
 */

#include <stdio.h>
#include <pthread.h>

/*
 * testThread() -- testing thread.  This simply prints a message and exits.
 */
testThread(y)
  int y;
{
    pthread_yield();
    fprintf(stderr, "testThread: arg %d\n", y);
    pthread_yield();
    pthread_exit(y);
}

/*
 * main() -- start maxThreads threads and exits.  We should be able to
 *     start all the threads and exit before any of the test threads are
 *     scheduled, but the testThread's call pthread_yield() just to make
 *     sure that main() will exit first.
 */
main(argc,argv)
  int argc;
  char **argv;
{
    int i;
    int maxThreads = 5;
    pthread_t th;
    int err;

    fprintf(stderr,"Starting %d threads\n",maxThreads);


    for (i=0; i<maxThreads; i++) {
        err = pthread_create(&th, pthread_attr_default, testThread, i);
        if (err != 0) {
            fprintf(stderr,"main: pthread_create failed\n");
            exit(1);
        }
        pthread_detach(&th);
    }

    /*
     * Cause the main() thread to exit.  The other threads should
     * continue execution.
     */
    fprintf(stderr,"main: exiting\n");
    pthread_exit(0);
    /* task execution should continue */
}

================= end of test program ===============================

[07/11/91 public]
The pthread spec does imply that you should be able to pthread_exit() *any*
thread but clearly the thread executing main() is special because it's
continuation is different than pthread_create() generated threads. So exiting
the main() thread will result in a return to the Crtl start() routine which
will exit killing the process. Webb Scales seemed to think this was documented
somewhere.

[07/12/91 public]
Ward Harold claims that exiting the main() thread will result in a
return to the start() routine.  This is true only if the code falls
off the end of main(), which certainly must be a limitation for DCE
threads.  However, if the main() thread calls pthread_exit(), the
threading package should be able to do one of the following to allow
the process to continue execution.

    1) Block on a condition variable that is never signalled.
       Alternately, this could be signalled when all other threads
       have exited.

    2) Remove this (main) thread from the run queue, possibly
       re-using the data structures for a subsequent thread
       creation request.  In theory, this would allow other
       threads to continue execution.

Also, we have not found any reference in our latest documents, or in
the pthread extensions document from DEC.  It could be we just missed it.

[10/30/91 public]

Erik Brown (eeb@transarc.com) comments:

I would like the DRB to review this defect and consider marking it as deferred,
rather than returned, so that it is fixed in a future release.

[10/31/91 public]
We'd like to change the severity of this defect from 2 to 3; I think that
someone in Austin has to do this for us, tho.

[10/31/91 public]
Severity changed at Phil Hirsch's request

[11/05/91 public]
This defect has been marked 'deferred' (do not fix in 1.0) by the DRBoard.  Reason:
Consider for future implementations.

[03/19/92 public]
Defer this again.  Implementation of requested functionality is
quite involved, and conformance to a mere draft of the Pthreads
spec is insufficient motivation to do it for 1.0.1.

[10/20/92 public]

OT cleanup 1 : New Severity = D ; New priority = 1
               Old severity = C ; Old priority = 2

N.B. Downgraded both the severity and priority of this defect.
     (C seems inappropriate for this). 

     Raised the priority to 1 because this defect will violate
     1.0.2 exit criteria i.e. 1.0.2 cannot ship with any code defect 
     older than 180 days old. Hence the priority is being raised to 
     to ensure that this defect is going to be addressed quickly.
     Some of the possibilities are:

     a. cancel the bug
     b. is such a lower priority that it is not going to be fixed,
        but it could be documented as a limitation.
     c. the bug will be fixed.
     d. convert this to an enhancement.

     I will revisit and update this report as to what my recommendations
     are for dealing with this defect (I can't do it this instant because
     I am in the middle of OT cleanup which is the highest priority item
     I have to do). But I am leaning towards either b or d.

[jd 11/05/92 public] 
Made this an enhancement request for 1.1. Responsible Eng. unassigned.



