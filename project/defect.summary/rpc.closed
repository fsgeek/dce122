CR Number                     : 13630
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_ref
Short Description             : misc errors in codeset conversion documentation
Reported Date                 : 9/25/96
Found in Baseline             : 1.2.1
Found Date                    : 9/25/96
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.2
Fixed In Baseline             : 1.2.2
Affected File(s)              : app_ref/man3rpc/cs_byte*
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public

[9/25/96 public]

This is to record work that Bob is doing in eight codeset conversion
and sizing routines' reference pages in the Application Reference.

[12/14/96 public]

Closed. All the manpages were updated by Bob Binstock and reviewed.



CR Number                     : 13362
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : idlcxx
Short Description             : ENDGAME: fix for IBM C++ suffix
Reported Date                 : 2/23/96
Found in Baseline             : 1.2.1
Found Date                    : 2/23/96
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : src/test/rpc/idlcxx/ ...
idlcxx.mk
account/Makefile        handle/Makefile         native/Makefile         static/Makefile
account2/Makefile       local_object/Makefile   refcnt/Makefile         stubexc/Makefile
accountc/Makefile       lookup/Makefile         refmon/Makefile
bind/Makefile           matrix/Makefile         retry/Makefile
card/Makefile           matrixc/Makefile        stack/Makefile
Sensitivity                   : public

[2/23/96 public]
fix for IBM C++ suffix



CR Number                     : 13361
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : ENDGAME:Added "-DIDL_PROTOTYPES"
Reported Date                 : 2/23/96
Found in Baseline             : 1.2.1
Found Date                    : 2/23/96
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : src/test/functional/rpc/runtime/i18n_api/ts/cs_eval/{cs_byte/Makefile, wchar/Makefile}
Sensitivity                   : public

[2/23/96 public]
Added "-DIDL_PROTOTYPES"

[2/23/96 public]
Fixed.



CR Number                     : 13357
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : ENDGAME: Class usage adjustments for IBM C++
Reported Date                 : 2/23/96
Found in Baseline             : 1.2.1
Found Date                    : 2/23/96
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : src/test/rpc/idlcxx/card/{String.hxx, Makefile, player.h, test_string.h}
                                             src/test/rpc/idlcxx/native/{String.hxx, Makefile, test_com.h, test_string.h}
Sensitivity                   : public

[2/23/96 public]
ENDGAME: Class usage adjustments for IBM C++



CR Number                     : 13356
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : ENDGAME: duplicate common files
Reported Date                 : 2/23/96
Found in Baseline             : 1.2.1
Found Date                    : 2/23/96
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : src/test/rpc/idlcxx/{String.hxx, server.hxx, svrlib.cxx, test_com.h}
Sensitivity                   : public

[2/23/96 public]
duplicate common files



CR Number                     : 13348
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : ENDGAME: codeset_registry_9.txt is HP specific.
Reported Date                 : 2/21/96
Found in Baseline             : 1.2.1
Found Date                    : 2/21/96
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : src/rpc/csrc/csr/Makefile
Sensitivity                   : public

[2/21/96 public]

ENDGAME: codeset_registry_9.txt is HP specific.

[2/22/96 public]
Added machine specific directories for holding codeset_registry.txt files.
Moved codeset_registry.txt to those subdirs. Fixed Makefile. Each vendor
should port their platform specific codeset_registry.txt.

Diffs:

Moved ./rpc/csrc/csr/code_set_registry.txt to
      ./rpc/csrc/csr/HP800/code_set_registry.txt
Added ./rpc/csrc/csr/RIOS/code_set_registry.txt

DIFF: OLD,NEW : ./rpc/csrc/Makefile===========================
*** ./rpc/csrc/Makefile.orig	Thu Feb 22 09:25:17 1996
--- /project/dce/build/dce1.2/src/./rpc/csrc/Makefile	Thu Feb 22 10:40:28 1996
***************
*** 7,65 ****
  # 
  # HISTORY
  # $Log:	c013348,v $
# Revision 1.2  96/02/22  12:09:00  root
# changed fields: Status  Fixed In Baseline   new/changed/deleted note(s) [domian 2/21/96 public] [psn 2/22/96 public] [domian 2/21/96 public]
# 
  # Revision 1.1.4.1  1995/12/08  00:11:07  root
  # 	Submit OSF/DCE 1.2.1
! #
  # 	HP revision /main/HPDCE02/7  1995/07/27  21:56 UTC  kline_s
  # 	Merge fix for libdld.sl 10.0 dependency.
! #
  # 	HP revision /main/HPDCE02/kline_s_mothra_10/5  1995/07/27  18:48 UTC  kline_s
  # 	Fix 10.0-specific dependency for libdld.sl.
! #
  # 	HP revision /main/HPDCE02/6  1995/07/14  19:51 UTC  rmm
  # 	merge back ux_release changes
! #
  # 	HP revision /main/HPDCE02/rmm_wc_work/1  1995/06/29  22:37 UTC  rmm
  # 	Change 1000 cond to work for Walnut Creek
! #
  # 	HP revision /main/HPDCE02/5  1995/03/30  23:32 UTC  kline_s
  # 	Add SUBDIRS tables and methods.
! #
  # 	HP revision /main/HPDCE02/kline_s_mothra_10/4  1995/03/29  19:10 UTC  kline_s
  # 	Add SUBDIRS tables and methods.
! #
  # 	HP revision /main/HPDCE02/4  1995/02/16  22:26 UTC  kline_s
  # 	I18N RPC changes required for 10.0
! #
  # 	HP revision /main/HPDCE02/kline_s_mothra_10/3  1995/02/10  21:15 UTC  kline_s
  # 	Merge changes from mainline into branch.
! #
  # 	HP revision /main/HPDCE02/kline_s_mothra_10/3  1995/02/10  21:14 UTC  kline_s
! #
  # 	HP revision /main/HPDCE02/kline_s_mothra_10/2  1995/02/10  21:05 UTC  kline_s
  # 	Use special OS naming for 9.0 code_set_registry.txt file (instead
  # 	of for the 10.0 version.
! #
  # 	HP revision /main/HPDCE02/kline_s_mothra_10/1  1995/02/09  22:53 UTC  kline_s
  # 	Allow for 10.x/9.x OS differentiations of code_set_registry.txt files
  # 	Defer actual creation of code_set_registry.db until install/customize
  # 	phase.  Needed to avoid cross OS version build problems in using csrc.
! #
  # 	HP revision /main/HPDCE02/3  1995/01/30  22:52 UTC  sommerfeld
  # 	Remove duplicate build rules for message catalog files.
  # 	Don't assume `.' is in $PATH.
  # 	[1995/01/27  04:14 UTC  sommerfeld  /main/HPDCE02/sommerfeld_mothmk_2/1]
! #
  # 	HP revision /main/HPDCE02/2  1994/12/23  00:26 UTC  kline_s
  # 	Enable RPC I18N functionality
! #
  # 	HP revision /main/HPDCE02/kline_s_mothra_latest/1  1994/12/22  21:39 UTC  kline_s
  # 	Enable I18N RPC features for Mothra.
! #
  # 	HP revision /main/HPDCE02/1  1994/07/12  15:26 UTC  mothra
  # 	Fix yacc and lex
  # 	[1995/12/07  23:53:49  root]
! #
  # Revision 1.1.2.3  1994/06/10  20:53:27  devsrc
  # 	cr10871 - fix copyright
  # 	[1994/06/10  14:59:36  devsrc]
--- 7,69 ----
  # 
  # HISTORY
  # $Log:	c013348,v $
# Revision 1.2  96/02/22  12:09:00  root
# changed fields: Status  Fixed In Baseline   new/changed/deleted note(s) [domian 2/21/96 public] [psn 2/22/96 public] [domian 2/21/96 public]
# 
+ # Revision 1.1.4.2  1996/02/22  16:40:27  root
+ # 	ENDGAME Submission
+ # 	[1996/02/22  16:10:51  root]
+ #
  # Revision 1.1.4.1  1995/12/08  00:11:07  root
  # 	Submit OSF/DCE 1.2.1
! # 
  # 	HP revision /main/HPDCE02/7  1995/07/27  21:56 UTC  kline_s
  # 	Merge fix for libdld.sl 10.0 dependency.
! # 
  # 	HP revision /main/HPDCE02/kline_s_mothra_10/5  1995/07/27  18:48 UTC  kline_s
  # 	Fix 10.0-specific dependency for libdld.sl.
! # 
  # 	HP revision /main/HPDCE02/6  1995/07/14  19:51 UTC  rmm
  # 	merge back ux_release changes
! # 
  # 	HP revision /main/HPDCE02/rmm_wc_work/1  1995/06/29  22:37 UTC  rmm
  # 	Change 1000 cond to work for Walnut Creek
! # 
  # 	HP revision /main/HPDCE02/5  1995/03/30  23:32 UTC  kline_s
  # 	Add SUBDIRS tables and methods.
! # 
  # 	HP revision /main/HPDCE02/kline_s_mothra_10/4  1995/03/29  19:10 UTC  kline_s
  # 	Add SUBDIRS tables and methods.
! # 
  # 	HP revision /main/HPDCE02/4  1995/02/16  22:26 UTC  kline_s
  # 	I18N RPC changes required for 10.0
! # 
  # 	HP revision /main/HPDCE02/kline_s_mothra_10/3  1995/02/10  21:15 UTC  kline_s
  # 	Merge changes from mainline into branch.
! # 
  # 	HP revision /main/HPDCE02/kline_s_mothra_10/3  1995/02/10  21:14 UTC  kline_s
! # 
  # 	HP revision /main/HPDCE02/kline_s_mothra_10/2  1995/02/10  21:05 UTC  kline_s
  # 	Use special OS naming for 9.0 code_set_registry.txt file (instead
  # 	of for the 10.0 version.
! # 
  # 	HP revision /main/HPDCE02/kline_s_mothra_10/1  1995/02/09  22:53 UTC  kline_s
  # 	Allow for 10.x/9.x OS differentiations of code_set_registry.txt files
  # 	Defer actual creation of code_set_registry.db until install/customize
  # 	phase.  Needed to avoid cross OS version build problems in using csrc.
! # 
  # 	HP revision /main/HPDCE02/3  1995/01/30  22:52 UTC  sommerfeld
  # 	Remove duplicate build rules for message catalog files.
  # 	Don't assume `.' is in $PATH.
  # 	[1995/01/27  04:14 UTC  sommerfeld  /main/HPDCE02/sommerfeld_mothmk_2/1]
! # 
  # 	HP revision /main/HPDCE02/2  1994/12/23  00:26 UTC  kline_s
  # 	Enable RPC I18N functionality
! # 
  # 	HP revision /main/HPDCE02/kline_s_mothra_latest/1  1994/12/22  21:39 UTC  kline_s
  # 	Enable I18N RPC features for Mothra.
! # 
  # 	HP revision /main/HPDCE02/1  1994/07/12  15:26 UTC  mothra
  # 	Fix yacc and lex
  # 	[1995/12/07  23:53:49  root]
! # 
  # Revision 1.1.2.3  1994/06/10  20:53:27  devsrc
  # 	cr10871 - fix copyright
  # 	[1994/06/10  14:59:36  devsrc]
***************
*** 74,89 ****
  # 
  # $EndLog$
  
  PROGRAMS = csrc
  
! .if ${ux_release} >= 1000
! OTHERS = ./csr/code_set_registry.txt
! .else
! OTHERS = ./csr/code_set_registry_9.txt
  .endif
  
  # iconv converter tables/methods are not built for 9.0.x versions
! .if ${ux_release} >= 1000
  EXPLIB_SUBDIRS = methods
  SUBDIRS = methods tables
  .endif
--- 78,94 ----
  # 
  # $EndLog$
  
+ VPATH    =./csr/${TARGET_MACHINE}
+ 
  PROGRAMS = csrc
+ OTHERS   = code_set_registry.txt
  
! .if ${TARGET_MACHINE} == "HP800" && ${ux_release} < 1000
! OTHERS   = code_set_registry_9.txt
  .endif
  
  # iconv converter tables/methods are not built for 9.0.x versions
! .if ${TARGET_MACHINE} == "HP800" && ${ux_release} >= 1000
  EXPLIB_SUBDIRS = methods
  SUBDIRS = methods tables
  .endif
***************
*** 92,101 ****
  IDIR = /bin/
  dcecsr.cat_IDIR	= /nls/msg/en_US.ASCII/
  
! .if ${ux_release} >= 1000
! ./csr/code_set_registry.txt_IDIR=/nls/
! .else
! ./csr/code_set_registry_9.txt_IDIR=/nls/
  .endif
  #
  #
--- 97,105 ----
  IDIR = /bin/
  dcecsr.cat_IDIR	= /nls/msg/en_US.ASCII/
  
! code_set_registry.txt_IDIR=/nls/
! .if ${TARGET_MACHINE} == "HP800" && ${ux_release} < 1000
! code_set_registry_9.txt_IDIR=/nls/
  .endif
  #
  #
***************
*** 102,108 ****
  # Add /usr/lib to possible paths so that libdld.sl will be
  # resolved at runtime.
  
! .if ${ux_release} >= 1000
  csrc_LDFLAGS	= -Wl,-a,default,+b,/usr/lib
  .endif
  
--- 106,112 ----
  # Add /usr/lib to possible paths so that libdld.sl will be
  # resolved at runtime.
  
! .if ${TARGET_MACHINE} == "HP800" && ${ux_release} >= 1000
  csrc_LDFLAGS	= -Wl,-a,default,+b,/usr/lib
  .endif



CR Number                     : 13343
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : ENDGAME:remove reference to dce_langinfo.o
Reported Date                 : 2/21/96
Found in Baseline             : 1.2.1
Found Date                    : 2/21/96
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : src/rpc/runtime/Makefile
Sensitivity                   : public

[2/21/96 public]

ENDGAME:remove reference to dce_langinfo.o

[2/22/96 public]
Fixed & Tested.

Diffs are:

DIFF: OLD,NEW : ./rpc/runtime/Makefile===========================
*** ./rpc/runtime/Makefile.orig	Thu Feb 22 09:25:17 1996
--- /project/dce/build/dce1.2/src/./rpc/runtime/Makefile	Thu Feb 22 10:35:20 1996
***************
*** 10,46 ****
  #
  # HISTORY
  # $Log:	c013343,v $
# Revision 1.2  96/02/22  11:53:39  root
# changed fields: Status  Fixed In Baseline   new/changed/deleted note(s) [domian 2/21/96 public] [psn 2/22/96 public] [domian 2/21/96 public]
# 
  # Revision 1.2.21.1  1995/12/08  00:16:22  root
  # 	Submit OSF/DCE 1.2.1
! #
  # 	HP revision /main/HPDCE02/gaz_dce_instr/jrr_1.2_mothra/1  1995/11/16  21:29 UTC  jrr
  # 	Remove some Mothra specific stuff.
! #
  # 	HP revision /main/HPDCE02/gaz_dce_instr/2  1995/07/20  18:31 UTC  gaz
  # 	Remove define of 'USE_GETTIMEOFDAY' to header files
! #
  # 	HP revision /main/HPDCE02/gaz_dce_instr/1  1995/07/15  20:17 UTC  gaz
  # 	cause server stubs to be compiled with instrumentation
! #
  # 	HP revision /main/HPDCE02/5  1995/01/16  19:14 UTC  markar
  # 	Merging Local RPC mods
! #
  # 	HP revision /main/HPDCE02/markar_local_rpc/1  1995/01/05  16:03 UTC  markar
  # 	Implementing Local RPC bypass mechanism
! #
  # 	HP revision /main/HPDCE02/4  1994/12/23  00:25 UTC  kline_s
  # 	Enable RPC I18N functionality
! #
  # 	HP revision /main/HPDCE02/kline_s_mothra_latest/1  1994/12/22  21:38 UTC  kline_s
  # 	Add dce_langinfo() to object list.
! #
  # 	HP revision /main/HPDCE02/3  1994/09/21  15:11 UTC  tatsu_s
  # 	Fixed DES_HIDDEN build.
! #
  # 	HP revision /main/HPDCE02/2  1994/09/21  14:50 UTC  tatsu_s
  # 	Merged mothra up to dce1_1_b18.
  # 	[1995/12/07  23:57:00  root]
! #
  # Revision 1.2.18.10  1994/09/07  15:48:34  marty
  # 	CR # 11497 - Remove '-v' option from IDLFLAGS defineittion.
  # 	[1994/09/06  21:39:31  marty]
--- 10,50 ----
  #
  # HISTORY
  # $Log:	c013343,v $
# Revision 1.2  96/02/22  11:53:39  root
# changed fields: Status  Fixed In Baseline   new/changed/deleted note(s) [domian 2/21/96 public] [psn 2/22/96 public] [domian 2/21/96 public]
# 
+ # Revision 1.2.21.2  1996/02/22  16:35:19  root
+ # 	ENDGAME Submission
+ # 	[1996/02/22  16:10:54  root]
+ #
  # Revision 1.2.21.1  1995/12/08  00:16:22  root
  # 	Submit OSF/DCE 1.2.1
! # 
  # 	HP revision /main/HPDCE02/gaz_dce_instr/jrr_1.2_mothra/1  1995/11/16  21:29 UTC  jrr
  # 	Remove some Mothra specific stuff.
! # 
  # 	HP revision /main/HPDCE02/gaz_dce_instr/2  1995/07/20  18:31 UTC  gaz
  # 	Remove define of 'USE_GETTIMEOFDAY' to header files
! # 
  # 	HP revision /main/HPDCE02/gaz_dce_instr/1  1995/07/15  20:17 UTC  gaz
  # 	cause server stubs to be compiled with instrumentation
! # 
  # 	HP revision /main/HPDCE02/5  1995/01/16  19:14 UTC  markar
  # 	Merging Local RPC mods
! # 
  # 	HP revision /main/HPDCE02/markar_local_rpc/1  1995/01/05  16:03 UTC  markar
  # 	Implementing Local RPC bypass mechanism
! # 
  # 	HP revision /main/HPDCE02/4  1994/12/23  00:25 UTC  kline_s
  # 	Enable RPC I18N functionality
! # 
  # 	HP revision /main/HPDCE02/kline_s_mothra_latest/1  1994/12/22  21:38 UTC  kline_s
  # 	Add dce_langinfo() to object list.
! # 
  # 	HP revision /main/HPDCE02/3  1994/09/21  15:11 UTC  tatsu_s
  # 	Fixed DES_HIDDEN build.
! # 
  # 	HP revision /main/HPDCE02/2  1994/09/21  14:50 UTC  tatsu_s
  # 	Merged mothra up to dce1_1_b18.
  # 	[1995/12/07  23:57:00  root]
! # 
  # Revision 1.2.18.10  1994/09/07  15:48:34  marty
  # 	CR # 11497 - Remove '-v' option from IDLFLAGS defineittion.
  # 	[1994/09/06  21:39:31  marty]
***************
*** 320,329 ****
  #
  # Implementation of the rpc_cs_... routines.
  #
  .if ${TARGET_MACHINE} == "SVR4"
  OBJS_CS         = cs_s_reg.o cs_s_eval.o
  .else
! OBJS_CS		= cs_s_eval.o cs_s_stub.o cs_s_reg.o dce_langinfo.o
  .endif
  
  #
--- 324,337 ----
  #
  # Implementation of the rpc_cs_... routines.
  #
+ .if ${TARGET_MACHINE} == "HP800" && ${ux_release} < 1000
+ LANGINFO	= dce_langinfo.o
+ .endif
+ 
  .if ${TARGET_MACHINE} == "SVR4"
  OBJS_CS         = cs_s_reg.o cs_s_eval.o
  .else
! OBJS_CS		= cs_s_eval.o cs_s_stub.o cs_s_reg.o ${LANGINFO}
  .endif
  
  #



CR Number                     : 13127
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : upkibml.c
Short Description             : OSDqa12240 unpacking of IBM
Reported Date                 : 9/18/95
Found in Baseline             : 1.1
Found Date                    : 9/18/95
Severity                      : B
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.1maint
Affected File(s)              : rpc
Sensitivity                   : public

[9/18/95 public]

NOTE: This is a re-submit of OT#13214 which was deleted.

The unpacking code for IBM big endian floating point long numbers doesn't
work correctly for little endian architectures.  The bytes are being
shuffled within each word, but the words aren't being swapped.  This
problem was uncovered during IFEST testing between little endian
architectures and IBM big endian architectures.

REPRODUCIBLE:
Yes, between Hitachi DCE/Base-M R1.1 and Gradients SysV-DCE for MP-RAS.

TEST SOFTWARE DESCRIPTION:
dcerpper, rpc perf tests.

DESCRIPTION OF HARDWARE WHERE BUG OCCURRED:
MP-RAS.

DESCRIPTION OF WHERE TEST SUCCESSFULLY RAN:
Related-file::Added 950810 by warnick::
/build/hiosfm/RCS/dce1.1/src/rpc/idl/lib
/./upkibml.c,v 8.2
 /build/hiosfm/RCS/dce1.1/src/rpc/idl/lib/./upkibml.c,v 8.2
 warnick 1995/08/10 19:52:40 +9 -2
 Reason: OSDqa12240 unpacking of IBM big endian floats doesn't work for
little endian

Fix for OSDqa12240.
     *** /tmp/ci.26560..upkibml.c.26601.1       Thu Aug 10 15:52:42 1995
     --- /tmp/upkibml.c.26601.2 Thu Aug 10 15:52:42 1995
     ***************
     *** 132,141 ****
     --- 132,148 ----
        r[2] |= ((r[1] >> 8) & 0x0000FF00L);
        r[1]  = ((r[0] << 24) | (r[0] >> 24));
        r[1] |= ((r[0] << 8) & 0x00FF0000L);
        r[1] |= ((r[0] >> 8) & 0x0000FF00L);
     + #ifdef hitm
     +  /* swap words to little endian format */
     +
     +  r[0]=r[1];
     +  r[1]=r[2];
     +  r[2]=r[0];
     + #endif
       #endif
        /* Initialize FLAGS and perhaps set NEGATIVE bit */
        r[U_R_FLAGS] = (r[1] >> 31);

Related-file:::: Resolution

DESCRIPTION OF BUG FIX:
Added word swapping when unpacking IBM big endian floating point longs for
little endian architectures.

REGRESSION TEST SCENARIO:
Run dcerpper tests between Hitachi DCE R1.1 and DCE1.1 on little endian
architectures.

[11/17/95 public]
Submitted the fix (two submissions, the second one fixes a compiler error
introduced in the first one) to 1.1maint tree.

[12/22/95 public]
Fix included in DCE 1.2.1
Closed



CR Number                     : 13124
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : upkibml.c
Short Description             : OSDqa12240 unpacking of IBM
big endian floats doesn't work for little endian
Reported Date                 : 9/15/95
Found in Baseline             : 1.1
Found Date                    : 9/15/95
Severity                      : B
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : rpc/idl/lib/upkibml.c
Sensitivity                   : public

[09/15/95 public]

 The unpacking code for IBM big endian floating point long numbers
 doesn't work correctly for little endian architectures.  The bytes
 are being shuffled within each word, but the words aren't being swapped.
 This problem was uncovered during IFEST testing between little endian
 architectures and IBM big endian architectures.

 REPRODUCIBLE:
 Yes, between Hitachi DCE/Base-M R1.1  and Gradients SysV-DCE for MP-RAS.
 TEST SOFTWARE DESCRIPTION:
 dcerpper, rpc perf tests.

 DESCRIPTION OF HARDWARE WHERE BUG OCCURRED:
 MP-RAS.

 DESCRIPTION OF WHERE TEST SUCCESSFULLY RAN:
Related-file::Added 950810 by warnick::
/build/hiosfm/RCS/dce1.1/src/rpc/idl/lib
/./upkibml.c,v 8.2
 /build/hiosfm/RCS/dce1.1/src/rpc/idl/lib/./upkibml.c,v 8.2
 warnick 1995/08/10 19:52:40 +9 -2
 Reason: OSDqa12240 unpacking of IBM big endian floats doesn't work for
little endian

 Fix for OSDqa12240.
     *** /tmp/ci.26560..upkibml.c.26601.1       Thu Aug 10 15:52:42 1995
     --- /tmp/upkibml.c.26601.2 Thu Aug 10 15:52:42 1995
     ***************
     *** 132,141 ****
     --- 132,148 ----
        r[2] |= ((r[1] >> 8) & 0x0000FF00L);
        r[1]  = ((r[0] << 24) | (r[0] >> 24));
        r[1] |= ((r[0] << 8) & 0x00FF0000L);
        r[1] |= ((r[0] >> 8) & 0x0000FF00L);
     + #ifdef hitm
     +  /* swap words to little endian format */
     +
     +  r[0]=r[1];
     +  r[1]=r[2];
     +  r[2]=r[0];
     + #endif
       #endif
        /* Initialize FLAGS and perhaps set NEGATIVE bit */
        r[U_R_FLAGS] = (r[1] >> 31);

 Related-file:::: Resolution

 DESCRIPTION OF BUG FIX:
 Added word swapping when unpacking IBM big endian floating point longs
 for little endian architectures.

 REGRESSION TEST SCENARIO:
 Run dcerpper tests between Hitachi DCE R1.1 and DCE1.1 on
 little endian architectures.

[09/15/95 public]

Cleaned up the OT entry above to make it readable.

[02/8/96 public]
Already in 1.2.1.



CR Number                     : 13100
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : dcerpbnk
Short Description             : test dcerpbnk: bankd server won't start
Reported Date                 : 9/6/95
Found in Baseline             : 1.2
Found Date                    : 8/31/95
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : dced
Sensitivity                   : public

[9/6/95 public]
 
When the dcerpbnk test is run the bankd server does not start, so 
the test aborts.  I tried to start the bankd server by hand 
as well, without success.  The server does not exit with an error code, 
it just doesn't stay running.

[2/09/96 public]

A later iteration of this test on 1.2.1 bits showed that this problem 
was resolved by the new dced code (merge in of numerous fixes from HP).



CR Number                     : 13099
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : dfs client side
Short Description             : dfs client side inoperative
Reported Date                 : 9/6/95
Found in Baseline             : 1.2
Found Date                    : 8/28/95
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : rpc
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : 

[9/6/95 public]
Installed dfs on single node cell.  It does not appear to 
come up and operate.  This appears to be a problem on the 
client side of dfs, since later an HP dfs client was configed 
to this cell, which functioned.  
I tried ls /:/  and get "The file /:/ does not exist."  An ls -l / "
finally returns after a few minutes with:
"dfs: communication failure with server 15.22.48.170 in cell perrydo.
dfs: lost contact with the fx server 15.22.48.170 in cell perrydo"
Below is a lot of debug info. 
dfsexport looks good: dfsexport: /dev/hd1, ufs, 1, 0,,1
The BosConfig file format looks good:
restarttime 11 0 4 0 0
checkbintime 3 0 5 0 0
bnode simple flserver 1
parm /opt/dcelocal/bin/flserver
end
bnode simple bakserver 1
parm /opt/dcelocal/bin/bakserver
end
bnode simple ftserver 1
parm /opt/dcelocal/bin/ftserver
end
bnode simple repserver 1
parm /opt/dcelocal/bin/repserver
end
Looking in /opt/dcelocal/var/dfs/adm logs:
BakLog BosLog FlLog FtLog RepLog
cat BakLog:
Mon Aug 28 16:02:34 1995
: /opt/dcelocal/bin/bakserver: log initialized to /opt/dcelocal/var/dfs/adm/BakLog
Mon Aug 28 16:02:44 1995
: Ready to process requests at Mon Aug 28 16:02:44 1995
Mon Aug 28 16:02:50 1995
: dbread: ubik_Read pos 0, buff 540576420, len 4
Mon Aug 28 16:02:50 1995
: DFS:ubk: premature EOF (dfs / ubk)
CheckInit: No data base, code 668147727
Mon Aug 28 16:02:52 1995
: dbread: ubik_Read pos 0, buff 540576420, len 4
Mon Aug 28 16:02:52 1995
: DFS:ubk: premature EOF (dfs / ubk)
CheckInit: No data base, code 668147727
Mon Aug 28 16:02:52 1995
: Error discovered in header, rebuilding.
cat BosLog:
Mon Aug 28 16:01:13 1995: /opt/dcelocal/bin/bosserver: beginning logging
Mon Aug 28 16:01:14 1995: host not foundrepserver: no aggregates on this server
cat FlLog:
95-Aug-28 16:02:18 flserver: log initialized to /opt/dcelocal/var/dfs/adm/FlLog
95-Aug-28 16:02:18 flserver: using default group of /.../perrydo/fs
95-Aug-28 16:02:26 flserver: cell perrydo, trial ID 134240973,,1846272371, 1 servers.
95-Aug-28 16:02:26 flserver: ready to service requests.
95-Aug-28 16:02:55 flserver: Initializing the FLDB header.
95-Aug-28 16:02:56 flserver: FLDB header initialized; space for 64 sites, cell id 13424097
3,,1846272371.
95-Aug-28 16:02:56 flserver: created site 15.22.48.170(0xf1630aa), principal 'hosts/ibm_l4
', quota 0
95-Aug-28 16:03:13 flserver: filling in the principal names for the 1 DB servers.
95-Aug-28 16:03:13 flserver: site 0 (f1630aa) has principal 'hosts/ibm_l4'
cat FtLog:
1995-Aug-28 16:02:47 Log file initialized as /opt/dcelocal/var/dfs/adm/FtLog
1995-Aug-28 16:02:48 Ftserver starting
1995-Aug-28 16:04:44 Failed to get info for aggr 1, code = 572833795 (Aggregate is not att
ached (dfs / ftu))
cat RepLog:
95-Aug-28 16:02:47 repserver: log initialized to /opt/dcelocal/var/dfs/adm/RepLog
95-Aug-28 16:03:00 Replication server started.  Mainprocs=1; tokenprocs=4.
95-Aug-28 16:03:14 repserver: no aggregates on this server

[09/12/95 public]
The text for this OT was initially entered in the header part, not
in the variable-text part.  his caused all sorts of problems.  We
recreated it by editing the RCS file directly (ick...).  Updates may
have been lost, so please review.

[9/12/95 public]
These lines in your log files:
        1995-Aug-28 16:02:48 Ftserver starting
        1995-Aug-28 16:04:44 Failed to get info for aggr 1, code = 572833795 (\
Aggregate is not att
        ached (dfs / ftu))
...
        95-Aug-28 16:02:47 repserver: log initialized to /opt/dcelocal/var/dfs\
/adm/RepLog
        95-Aug-28 16:03:00 Replication server started.  Mainprocs=1; tokenproc\
s=4.
        95-Aug-28 16:03:14 repserver: no aggregates on this server
Seem to indicate that some aggregates did not get recovered and attached to 
the file server.  If the aggregate in question contained the root.dfs fileset
then that would explain part of the problem.
Alternatively if root.dfs was in fact online, then what we need to see 
is the output from running "dfstrace dump"  This will reveal the state of 
the "client side" or cache manager.
Changed Interest List CC from `conley_s@ch.hp.com, jrr@ch.hp.com, 
 white_r@ch.hp.com' to `conley_s@ch.hp.com, jrr@ch.hp.com, white_r@ch.hp.com, 
 berman@transarc.com' 
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `'

[9/13/95 public]
I have looked over the icl traces provided by HP.
These are annotated excerpts from Icl trace "dump2"
provided by HP for analysis of ot cr 13099.
Thanks to cfe for aid in the analysis.
.
	[ Client requests AFS_SetContext ]
time 296.973270, pid 19016: start AFS_SetContext conn 5d0608c srv level 0x20000 
time 297.101107, pid 13690: in AFS_SetContext, Flag b 
.
...	[ Server finishes AFS_SetContext ]
time 297.101786, pid 13690: fshs_CreateHost: returning 655257602 
time 297.103640, pid 19016: end AFS_SetContext code 655257602 
.
	[ Client requests AFS_SetContext ]
time 297.103699, pid 19016: start recheck AFS_SetContext: conn 5d0608c srv level  0x20000 
time 297.106935, pid 13690: in AFS_SetContext, Flag b 
.
...	[ Server finishes AFS_SetContext]
time 297.107205, pid 13690: fshs_CreateHost: returning 655257602 
time 297.109057, pid 19016: end recheck AFS_SetContext: code 655257602 
time 297.109144, pid 19016: cm_ConnAndReset: conn 0x5d0608c, server 0x5cf740c: reset 0 tokens 
.
	[ Client requests AFS_SetContext ]
time 297.109161, pid 19016: cm_ConnAndReset: conn 0x5d0608c, service 0x20000: calling AFS_SetContext 
time 297.111329, pid 13690: in AFS_SetContext, Flag f 
.
...	[ Server processing AFS_SetContext begins server-initiated client TKN RPC ]
time 297.111615, pid 13690: tokenint_InitTokenState host 5cbf11c 
time 297.111626, pid 13690: fshs_GetTSRCode: host 5cbf11c, returning 0xc 
time 297.116854, pid 19242: TKN_InitTokenState called 
time 297.116914, pid 19242: TKN_InitTokenState's server is 5cf740c 
.
	[ Client replies to server-initiated TKN RPC ]
time 297.116926, pid 19242: TKN_InitTokenState returning code 0 
time 297.118618, pid 13690: fshs_CreateHost: host 5cbf11c TKN_InitTokenState returned 0 
.
...	[ Server finishes AFS_SetContext ]
time 297.118681, pid 13690: fshs_CreateHost: returning 655257655 
time 297.120417, pid 19016: cm_ConnAndReset: conn 0x5d0608c: AFS_SetContext result is 655257655 
time 297.120477, pid 19016: RecoverTokenState, flags 0x0, tsrMode 2 
time 297.120595, pid 19016: cm_ConnByHost using conn 5d0608c, service 0x20000 
.
	[ Client begins AFS_LookupRoot ]
time 297.120620, pid 19016: begin AFS_LookupRoot 
time 297.122610, pid 13690: in AFS_LookupRoot Volume 0.1 
time 297.122778, pid 13690: fshs_GetPrincipal START 
.
...	[ Server finishes AFS_LookupRoot call successfully ]
time 297.134370, pid 13690: fshs_PutPrincipal 5cee090 ref 1 
time 297.134573, pid 13690: AFS_LookupRoot returning Vnode 2, Unique 1, code 0 
.
...	[ 121 seconds later Client error-exits AFS_LookupRoot ]
	[ Error is "DCE Communications Failure" ]
time 418.139752, pid 19016: end AFS_LookupRoot, code 382312470 
time 418.139788, pid 19016: cm_Analyze: conn 5d0608c, code 382312470, user 0 
time 418.140803, pid 19016: server 5cf740c just marked down 
time 418.141450, pid 19016: mark conn bad for pag -1 
time 418.141488, pid 19016: mark conn bad for pag -1 
time 418.141531, pid 19016: cm_ConnByMHosts server type 20000 
time 418.141544, pid 19016: cm_ConnByMHosts: found  0-th server down 
time 418.141558, pid 19016: cm_ConnByMHosts: all filesets bad 
time 418.141570, pid 19016: cm_Analyze: conn 0, code -1, user 0 
time 418.141641, pid 19016: checkerror returning code 78 
.
The same pattern of errors is found in "dump3".  These seem to indicate
a corrupted or broken Kernel RPC system which is experience "comm failure" 
due to timeout.  I am reassigning the this OT to HP because I believe the 
problem to be caused by the kernel rpc runtime.  There does not seem to be 
any DFS defect here.
Changed Responsible Engr. from `Vikram_Biyani@transarc.com' to 
 `conley_s@ch.hp.com' 
Changed Resp. Engr's Company from `tarc' to `hp'
[hp 9/13/95 public]
 
A little bit more information:  
 
When DFS is not configured their is no evidence of rpc comm problems in 
the cell.  Rpc system tests succeed.  With DFS configured the cell is 
inoperable.

[9/13/95 public]
Um, ``the cell is inoperable'' is a pretty broad brush; what do you mean?
DFS is inoperable (in the way seen above)?  Other DCE services fail?
 
Whether user-space RPC system tests succeed is only marginally
relevant to the above case, in which it's KRPC that's failing.  The
point of the trace output is that these DFS traces show no DFS
involvement at the point of failure.  What appears to have happened is
that a manager routine returned to the RPC runtime, but the RPC client
never saw any result.  Presumably the thing to be traced and
understood here is activity in the KRPC runtime, not DFS activity.
 
I believe that Steve B. also mentioned to me that the AIX platform
requires a special compiler to be used for ``reentrant'' code.  I've
added Carl Burnett to the CC: list in hopes that he can shed any
appropriate light on that matter.

[9/27/95 public]
Changed the "component" field to rpc as per request by mpt@osf.org
Changed Component Name from `dfs' to `rpc'

[9/28/95 public]

We thought it might help if we could narrow this problem down a bit, so 
I am inserting testing report from Russ White: 

I've run some quick tests on DFS manually and these are the results,
plus some interesting observations:

The following tests were run on HP-UX systems using DCE1.2 and HP-UX 9.0.
Server: dcecb3;  clients: java, dcecb3

On the DCE 1.2 - 09/12/95 build (with XIDL - without regy_sync add-ons)
1.      On the server, the /.: link was NOT set; on the client java it was.
2.      The /:/link was set correctly on both systems.
3.      Ran the same set of manual tests on DFS and it seems to be OK.
        I also changed access rights at the /.:/fs level and was
        able to make and delete directories.

On the DCE 1.2 - 09/22/95 build (with XIDL + regy_sync add_ons)
1.      The /.: and /: links on both server and client were set correctly.
2.      Ran manual tests creating, deleting directories and reading
        all of the items.  DFS appears to work OK on both dcecb3 and java
        as clients (dcecb3 as a server-only would be unable to perform
        these operations).

In addition, I ran a test on the IBM AIX (ibm_l3) system with the latest
DCE 1.2 bits, including XIDL and regy_sync bits (an AIX version of 09/22/95).
This test was a single node cell operating as both the server and client
(similar to dcecb3/hp nodes in the tests above).
1.      The /.: and /: links were set correctly.
2.      When the client was configured, and after waiting the requisite
        5 minutes for TKN to complete its scan, setting up, etc. I
        performed the following:
        ls /<mounted disk>  gave the expected jfs listing.
        ls /:/    went into an unending loop and did not return.
3.      After the ls /:/ action above, in another window I retried the
        ls /<mounted disk> command which also hung in a loop.
        Further windows using  ls /   or ls of any type resulted in
        hung windows.
My initial conclusion from this is that there may be something within the
IBM implementation of krpc and its interaction with AIX, or equivalent,
which is causing this problem.
(This is based on OT 13099 with Transarc's responses, and the fact that the
same code running on the HP-UX systems does not fail.  We are using the C
and C++ compilers which are purchased from IBM.  If there is a "special"
compiler, we are not aware of it.)

[10/03/95 public]

Find below request for further information from Liz Hughes at IBM on this OT.
The mail from Liz has the '>'.  The requested information is between.

-Deon

>Deon,
>>Hi, my name is Liz Hughes and I work on DFS at IBM.  We've
>been asked to help out with OT 13099.   We don't have this
>level of code running down here, so we'll need your help
>in providing us some trace information.  If you could
>recreate the last test scenario you documented in the OT
>and get some dfs traces, it will give us something to start with.
>
>On the AIX machine:
>
>1) turn on the dfs tracing for cm, fx, and fshost:
>   # dfstrace setset -set cm fx fshost -active
>   # dfstrace clear
>
>2) attempt to do the ls of /:

        command line result of ls /:/

        result of /:/

dfs: comm failure/set context: code 382312543
dfs: lost contact with the fx server 15.22.48.168 in cell ibm_l3_s920
ls: 0653-341 The file /:/ does not exist.

>
>3) in another window dump the dfstrace logs, only wait about 10 secs
>   otherwise the log will get too big
>   # dfstrace dump -file /tmp/dfsdump

	<<This file too large to enter here with cut and paste>>
	<<If anyone wants it send an email request to bell_d@ch.hp.com >>
	<<I can email it to you.			      >>
>
>4) Also, dump the icl trace for the dfsbind process
>   # kill -30 <pid_of_dfsbind>
>   (the trace is dumped to /opt/dcelocal/var/dfs/adm/icl.bind)
THE ICL.BIND file:

DFS Trace Dump -

   Date: Tue Oct  3 14:48:35 1995

Contents of log common:
time 290.194618, pid 0: current time: Tue Oct  3 14:46:58 1995
time 290.194618, pid 11: ubik_GetServerList returns (groupName=/.../ibm_l3_s920, groupSize=
0, errorcode=0)
time 290.242830, pid 11: dfsauth_client_ReleaseLock entered
time 290.242951, pid 11: dfsauth_client_ReleaseLock exiting, returning Error 0
time 290.243300, pid 11: dfsauth_client_InitAuthContext exiting, returning Error 0
time 290.252891, pid 11: dfsauth_client_InitAuthentication exiting, returning Error 0
time 291.324742, pid 12: ubik_GetServerList returns (groupName=/.../ibm_l3_s920/fs, groupSi
ze=1, errorcode=0)
time 291.324931, pid 12: dfsauth_client_InitAuthentication entered
time 291.324983, pid 12: dfsauth_client_InitAuthentication: serverLocationP: local, useNoAu
th? no, useLocalAuth? no
time 291.331980, pid 12: dfsauth_client_InitAuthContext entered
time 291.332061, pid 12: dfsauth_client_GrabLock entered
time 291.332152, pid 12: dfsauth_client_GrabLock exiting, returning Error 0
time 291.332211, pid 12: dfsauth_client_ReleaseLock entered
time 291.332273, pid 12: dfsauth_client_ReleaseLock exiting, returning Error 0
time 291.332329, pid 12: dfsauth_client_InitAuthContext exiting, returning Error 0
time 291.332386, pid 12: dfsauth_client_InitAuthentication exiting, returning Error 0

Contents of log ubikvote:

Contents of log bind:
time 490.517953, pid 0: current time: Tue Oct  3 14:33:14 1995
time 490.517953, pid 1: helper read: entry
time 499.843142, pid 1: helper read: exit code:53
time 499.843284, pid 1: helper read: entry
time 499.843688, pid 9: ProcessRequest: entry
time 499.843752, pid 9: do_auth_request: entry
time 499.844132, pid 9: do_auth_request: exit code:0
time 499.844218, pid 9: ProcessRequest: exit code:0
time 499.844268, pid 9: helper write: entry
time 499.844786, pid 9: helper write: exit code:47
time 755.603739, pid 1: helper read: exit code:23
time 755.603880, pid 1: helper read: entry
time 755.604288, pid 10: ProcessRequest: entry
time 755.620475, pid 10: sec_id_parse_name: entry name=/.../ibm_l3_92x
time 756.109928, pid 10: sec_id_parse_name: exit code:387063930
time 756.110027, pid 10: rpc_ns_entry_inq_resolution: entry
time 756.339985, pid 10: rpc_ns_entry_inq_resolution: exit code:282109010
time 756.341419, pid 10: ProcessRequest: exit code:2
time 756.341502, pid 10: helper write: entry
time 756.347229, pid 10: helper write: exit code:35
time 289.683709, pid 1: helper read: exit code:24
time 289.683851, pid 1: helper read: entry
lper read: entry
time 290.781650, pid 12: ProcessRequest: entry
time 290.782060, pid 12: sec_id_parse_name: entry name=/.../ibm_l3_s920/fs
time 290.847348, pid 12: sec_id_parse_name: exit code:0
time 290.847447, pid 12: rpc_ns_entry_inq_resolution: entry
time 290.904087, pid 12: rpc_ns_entry_inq_resolution: exit code:0
time 290.904220, pid 12: ubik_ClientInit: entry
time 291.622798, pid 12: ubik_ClientInit: exit code:0
time 291.623133, pid 12: rpc_binding_inq_object: entry conns:20153500
time 291.623214, pid 12: rpc_binding_inq_object: exit conns:20153500 code:0
time 291.634390, pid 12: rpcx_binding_to_sockaddr: entry conns:20153500
time 291.635110, pid 12: rpcx_binding_to_sockaddr: exit conns:20153500 code:0

time 294.525011, pid 5: ProcessRequest: exit code:0
time 294.525062, pid 5: helper write: entry
time 294.527594, pid 5: helper write: exit code:1404
time 295.609753, pid 1: helper read: exit code:121
time 295.609889, pid 1: helper read: entry
time 295.610530, pid 6: ProcessRequest: entry
time 295.610602, pid 6: do_auth_request: entry
time 295.613730, pid 6: do_auth_request: exit code:0
time 295.613830, pid 6: ProcessRequest: exit code:0
time 295.613881, pid 6: helper write: entry
time 295.616215, pid 6: helper write: exit code:1404
time 297.606127, pid 1: helper read: exit code:121
time 297.606265, pid 1: helper read: entry
time 297.606730, pid 7: ProcessRequest: entry
time 297.606795, pid 7: do_auth_request: entry
time 297.609926, pid 7: do_auth_request: exit code:0
time 297.610169, pid 7: ProcessRequest: exit code:0
time 297.610252, pid 7: helper write: entry
time 297.612572, pid 7: helper write: exit code:1404
time 299.606171, pid 1: helper read: exit code:121
time 303.605567, pid 1: helper read: entry
time 303.606020, pid 6: ProcessRequest: entry
time 303.606088, pid 6: do_auth_request: entry
time 303.609003, pid 6: do_auth_request: exit code:0
time 303.609104, pid 6: ProcessRequest: exit code:0
time 303.609156, pid 6: helper write: entry
time 303.609764, pid 6: helper write: exit code:1404
time 305.606101, pid 1: helper read: exit code:121
time 305.606240, pid 1: helper read: entry
time 305.606668, pid 7: ProcessRequest: entry
time 305.606733, pid 7: do_auth_request: entry
time 305.609639, pid 7: do_auth_request: exit code:0
time 305.609740, pid 7: ProcessRequest: exit code:0
time 305.609791, pid 7: helper write: entry
time 305.610530, pid 7: helper write: exit code:1404
time 307.605368, pid 1: helper read: exit code:121
time 307.605504, pid 1: helper read: entry
time 307.605933, pid 8: ProcessRequest: entry
time 307.605997, pid 8: do_auth_request: entry
time 307.608900, pid 8: do_auth_request: exit code:0
time 307.609000, pid 8: ProcessRequest: exit code:0
time 307.609050, pid 8: helper write: entry
time 307.609645, pid 8: helper write: exit code:1404
time 309.605388, pid 1: helper read: exit code:121
time 309.605526, pid 1: helper read: entry
time 309.605954, pid 5: ProcessRequest: entry
time 309.606019, pid 5: do_auth_request: entry
time 309.608920, pid 5: do_auth_request: exit code:0
time 309.609019, pid 5: ProcessRequest: exit code:0
time 309.609069, pid 5: helper write: entry
time 309.609661, pid 5: helper write: exit code:1404
time 311.605377, pid 1: helper read: exit code:121
time 311.605515, pid 1: helper read: entry
time 311.605944, pid 6: ProcessRequest: entry
time 311.606008, pid 6: do_auth_request: entry
time 311.608921, pid 6: do_auth_request: exit code:0
time 311.609022, pid 6: ProcessRequest: exit code:0
time 311.609074, pid 6: helper write: entry
time 311.609667, pid 6: helper write: exit code:1404
time 313.605376, pid 1: helper read: exit code:121
time 313.605516, pid 1: helper read: entry
time 313.605942, pid 7: ProcessRequest: entry
time 313.606007, pid 7: do_auth_request: entry
time 313.608914, pid 7: do_auth_request: exit code:0
time 313.609015, pid 7: ProcessRequest: exit code:0
time 313.609066, pid 7: helper write: entry
time 313.609655, pid 7: helper write: exit code:1404
time 315.606741, pid 1: helper read: exit code:121
time 315.606877, pid 1: helper read: entry
time 315.607303, pid 8: ProcessRequest: entry
time 315.607368, pid 8: do_auth_request: entry
time 315.610447, pid 8: do_auth_request: exit code:0
time 315.610545, pid 8: ProcessRequest: exit code:0
time 315.610596, pid 8: helper write: entry
time 315.611188, pid 8: helper write: exit code:1404
time 317.605437, pid 1: helper read: exit code:121
time 317.605575, pid 1: helper read: entry
time 317.606003, pid 5: ProcessRequest: entry
time 317.606068, pid 5: do_auth_request: entry
time 317.608978, pid 5: do_auth_request: exit code:0
time 317.609077, pid 5: ProcessRequest: exit code:0
time 317.609127, pid 5: helper write: entry
time 317.609720, pid 5: helper write: exit code:1404
time 319.605379, pid 1: helper read: exit code:121
time 319.605517, pid 1: helper read: entry
time 319.605948, pid 6: ProcessRequest: entry
time 319.606014, pid 6: do_auth_request: entry
time 319.608919, pid 6: do_auth_request: exit code:0
time 319.609019, pid 6: ProcessRequest: exit code:0
time 319.609071, pid 6: helper write: entry
time 319.609667, pid 6: helper write: exit code:1404
time 321.605408, pid 1: helper read: exit code:121
time 321.605547, pid 1: helper read: entry
time 321.605974, pid 7: ProcessRequest: entry
time 321.606039, pid 7: do_auth_request: entry
time 321.608951, pid 7: do_auth_request: exit code:0
time 321.609051, pid 7: ProcessRequest: exit code:0
time 321.609102, pid 7: helper write: entry
time 321.609700, pid 7: helper write: exit code:1404
time 323.605516, pid 1: helper read: exit code:121
time 323.605652, pid 1: helper read: entry
time 323.606080, pid 8: ProcessRequest: entry
time 323.606144, pid 8: do_auth_request: entry
time 323.609047, pid 8: do_auth_request: exit code:0
time 323.609147, pid 8: ProcessRequest: exit code:0
time 323.609197, pid 8: helper write: entry
time 323.609791, pid 8: helper write: exit code:1404
time 325.606103, pid 1: helper read: exit code:121
time 333.605494, pid 1: helper read: entry
time 333.605921, pid 5: ProcessRequest: entry
time 333.605986, pid 5: do_auth_request: entry
time 333.608886, pid 5: do_auth_request: exit code:0
time 333.608985, pid 5: ProcessRequest: exit code:0
time 333.609035, pid 5: helper write: entry
time 333.609628, pid 5: helper write: exit code:1404
time 335.605485, pid 1: helper read: exit code:121
time 335.605623, pid 1: helper read: entry
time 335.606054, pid 6: ProcessRequest: entry
time 335.606119, pid 6: do_auth_request: entry
time 335.609024, pid 6: do_auth_request: exit code:0
time 335.609125, pid 6: ProcessRequest: exit code:0
time 335.609177, pid 6: helper write: entry
time 335.609770, pid 6: helper write: exit code:1404
time 337.605370, pid 1: helper read: exit code:121
time 337.605510, pid 1: helper read: entry
time 337.605938, pid 7: ProcessRequest: entry
time 337.606003, pid 7: do_auth_request: entry
time 337.608901, pid 7: do_auth_request: exit code:0
time 337.609001, pid 7: ProcessRequest: exit code:0
time 337.609052, pid 7: helper write: entry
time 337.609648, pid 7: helper write: exit code:1404
time 339.605324, pid 1: helper read: exit code:121
time 339.605459, pid 1: helper read: entry
time 339.605887, pid 8: ProcessRequest: entry
time 339.605951, pid 8: do_auth_request: entry
time 339.608851, pid 8: do_auth_request: exit code:0
time 339.608952, pid 8: ProcessRequest: exit code:0
time 339.609002, pid 8: helper write: entry
time 339.609595, pid 8: helper write: exit code:1404
time 341.605508, pid 1: helper read: exit code:121
time 341.605645, pid 1: helper read: entry
time 341.606072, pid 5: ProcessRequest: entry
time 341.606137, pid 5: do_auth_request: entry
time 341.609040, pid 5: do_auth_request: exit code:0
time 341.609139, pid 5: ProcessRequest: exit code:0
time 341.609189, pid 5: helper write: entry
time 341.609784, pid 5: helper write: exit code:1404
time 343.605327, pid 1: helper read: exit code:121
time 343.605463, pid 1: helper read: entry
time 343.605893, pid 6: ProcessRequest: entry
time 343.605957, pid 6: do_auth_request: entry
time 343.608859, pid 6: do_auth_request: exit code:0
time 343.608960, pid 6: ProcessRequest: exit code:0
time 343.609011, pid 6: helper write: entry
time 343.609604, pid 6: helper write: exit code:1404
time 345.605359, pid 1: helper read: exit code:121
time 345.605500, pid 1: helper read: entry
time 345.605929, pid 7: ProcessRequest: entry
time 345.605995, pid 7: do_auth_request: entry
time 345.608898, pid 7: do_auth_request: exit code:0
time 345.608999, pid 7: ProcessRequest: exit code:0
time 345.609050, pid 7: helper write: entry
time 345.609642, pid 7: helper write: exit code:1404
time 347.605494, pid 1: helper read: exit code:121
time 347.605630, pid 1: helper read: entry
time 347.606059, pid 8: ProcessRequest: entry
time 347.606123, pid 8: do_auth_request: entry
time 347.609021, pid 8: do_auth_request: exit code:0
time 347.609123, pid 8: ProcessRequest: exit code:0
time 347.609174, pid 8: helper write: entry
time 347.609765, pid 8: helper write: exit code:1404
time 349.605390, pid 1: helper read: exit code:121
time 349.605529, pid 1: helper read: entry
time 349.605956, pid 5: ProcessRequest: entry
time 349.606022, pid 5: do_auth_request: entry
time 349.608933, pid 5: do_auth_request: exit code:0
time 349.609032, pid 5: ProcessRequest: exit code:0
time 349.609082, pid 5: helper write: entry
time 349.609679, pid 5: helper write: exit code:1404
time 351.605344, pid 1: helper read: exit code:121
time 351.605481, pid 1: helper read: entry
time 351.605912, pid 6: ProcessRequest: entry
time 351.605977, pid 6: do_auth_request: entry
time 351.608883, pid 6: do_auth_request: exit code:0
time 351.608984, pid 6: ProcessRequest: exit code:0
time 351.609036, pid 6: helper write: entry
time 351.609630, pid 6: helper write: exit code:1404
time 353.605564, pid 1: helper read: exit code:121
time 353.605704, pid 1: helper read: entry
time 353.606132, pid 7: ProcessRequest: entry
time 353.606197, pid 7: do_auth_request: entry
time 353.609105, pid 7: do_auth_request: exit code:0
time 353.609206, pid 7: ProcessRequest: exit code:0
time 353.609257, pid 7: helper write: entry
time 353.609856, pid 7: helper write: exit code:1404
time 355.606032, pid 1: helper read: exit code:121
time 355.606168, pid 1: helper read: entry
time 355.606597, pid 8: ProcessRequest: entry
time 355.606662, pid 8: do_auth_request: entry
time 355.609557, pid 8: do_auth_request: exit code:0
time 355.609659, pid 8: ProcessRequest: exit code:0
time 355.609710, pid 8: helper write: entry
time 355.610438, pid 8: helper write: exit code:1404
time 357.605325, pid 1: helper read: exit code:121
time 357.605462, pid 1: helper read: entry
time 357.605890, pid 5: ProcessRequest: entry
time 357.605955, pid 5: do_auth_request: entry
time 357.608856, pid 5: do_auth_request: exit code:0
time 357.608955, pid 5: ProcessRequest: exit code:0
time 357.609006, pid 5: helper write: entry
time 357.609602, pid 5: helper write: exit code:1404
time 359.605477, pid 1: helper read: exit code:121
time 359.605615, pid 1: helper read: entry
time 359.606045, pid 6: ProcessRequest: entry
time 359.606110, pid 6: do_auth_request: entry
time 359.609013, pid 6: do_auth_request: exit code:0
time 359.609115, pid 6: ProcessRequest: exit code:0
time 359.609167, pid 6: helper write: entry
time 359.609763, pid 6: helper write: exit code:1404
time 361.605324, pid 1: helper read: exit code:121
time 361.605462, pid 1: helper read: entry
time 361.605889, pid 7: ProcessRequest: entry
time 361.605955, pid 7: do_auth_request: entry
time 361.608854, pid 7: do_auth_request: exit code:0
time 361.608955, pid 7: ProcessRequest: exit code:0
time 361.609006, pid 7: helper write: entry
time 361.609597, pid 7: helper write: exit code:1404
time 363.605357, pid 1: helper read: exit code:121
time 363.605493, pid 1: helper read: entry
time 363.605921, pid 8: ProcessRequest: entry
time 363.605985, pid 8: do_auth_request: entry
time 363.608882, pid 8: do_auth_request: exit code:0
time 363.608984, pid 8: ProcessRequest: exit code:0
time 363.609035, pid 8: helper write: entry
time 363.609626, pid 8: helper write: exit code:1404
time 365.605516, pid 1: helper read: exit code:121
time 365.605655, pid 1: helper read: entry
time 365.606083, pid 5: ProcessRequest: entry
time 365.606149, pid 5: do_auth_request: entry
time 365.609049, pid 5: do_auth_request: exit code:0
time 365.609148, pid 5: ProcessRequest: exit code:0
time 365.609198, pid 5: helper write: entry
time 365.609793, pid 5: helper write: exit code:1404
time 367.605352, pid 1: helper read: exit code:121
time 367.605490, pid 1: helper read: entry
time 367.606104, pid 6: ProcessRequest: entry
time 367.606187, pid 6: do_auth_request: entry
time 367.609271, pid 6: do_auth_request: exit code:0
time 367.609373, pid 6: ProcessRequest: exit code:0
time 367.609425, pid 6: helper write: entry
time 367.610021, pid 6: helper write: exit code:1404
time 369.605351, pid 1: helper read: exit code:121
time 369.605491, pid 1: helper read: entry
time 369.605918, pid 7: ProcessRequest: entry
time 369.605983, pid 7: do_auth_request: entry
time 369.608883, pid 7: do_auth_request: exit code:0
time 369.608984, pid 7: ProcessRequest: exit code:0
time 369.609035, pid 7: helper write: entry
time 369.609632, pid 7: helper write: exit code:1404
time 371.605518, pid 1: helper read: exit code:121
time 371.605654, pid 1: helper read: entry
time 371.606083, pid 8: ProcessRequest: entry
time 371.606147, pid 8: do_auth_request: entry
time 371.609050, pid 8: do_auth_request: exit code:0
time 371.609150, pid 8: ProcessRequest: exit code:0
time 371.609201, pid 8: helper write: entry
time 371.609794, pid 8: helper write: exit code:1404
time 373.605368, pid 1: helper read: exit code:121
time 373.605507, pid 1: helper read: entry
time 373.605934, pid 5: ProcessRequest: entry
time 373.605999, pid 5: do_auth_request: entry
time 373.608900, pid 5: do_auth_request: exit code:0
time 373.608999, pid 5: ProcessRequest: exit code:0
time 373.609049, pid 5: helper write: entry
time 373.609642, pid 5: helper write: exit code:1404
time 375.605353, pid 1: helper read: exit code:121
time 375.605490, pid 1: helper read: entry
time 375.605919, pid 6: ProcessRequest: entry
time 375.605984, pid 6: do_auth_request: entry
time 375.608894, pid 6: do_auth_request: exit code:0
time 375.608995, pid 6: ProcessRequest: exit code:0
time 375.609047, pid 6: helper write: entry
time 375.609639, pid 6: helper write: exit code:1404
time 377.605572, pid 1: helper read: exit code:121
time 377.605715, pid 1: helper read: entry
time 377.606155, pid 7: ProcessRequest: entry
time 377.606220, pid 7: do_auth_request: entry
time 377.609127, pid 7: do_auth_request: exit code:0
time 377.609228, pid 7: ProcessRequest: exit code:0
time 377.609279, pid 7: helper write: entry
time 377.609870, pid 7: helper write: exit code:1404
time 379.605346, pid 1: helper read: exit code:121
time 379.605481, pid 1: helper read: entry
time 379.605911, pid 8: ProcessRequest: entry
time 379.605976, pid 8: do_auth_request: entry
time 379.608872, pid 8: do_auth_request: exit code:0
time 379.608973, pid 8: ProcessRequest: exit code:0
time 379.609024, pid 8: helper write: entry
time 379.609614, pid 8: helper write: exit code:1404
time 381.605367, pid 1: helper read: exit code:121
time 381.605504, pid 1: helper read: entry
time 381.605933, pid 5: ProcessRequest: entry
time 381.605998, pid 5: do_auth_request: entry
time 381.608901, pid 5: do_auth_request: exit code:0
time 381.609000, pid 5: ProcessRequest: exit code:0
time 381.609050, pid 5: helper write: entry
time 381.609645, pid 5: helper write: exit code:1404
time 383.605547, pid 1: helper read: exit code:121
time 383.605685, pid 1: helper read: entry
time 383.606118, pid 6: ProcessRequest: entry
time 383.606183, pid 6: do_auth_request: entry
time 383.609085, pid 6: do_auth_request: exit code:0
time 383.609185, pid 6: ProcessRequest: exit code:0
time 383.609237, pid 6: helper write: entry
time 383.609831, pid 6: helper write: exit code:1404
time 385.606043, pid 1: helper read: exit code:121
time 385.606182, pid 1: helper read: entry
time 385.606612, pid 7: ProcessRequest: entry
time 385.606677, pid 7: do_auth_request: entry
time 385.609581, pid 7: do_auth_request: exit code:0
time 385.609681, pid 7: ProcessRequest: exit code:0
time 385.609732, pid 7: helper write: entry
time 385.610465, pid 7: helper write: exit code:1404
>
>5) Also, the output from the following commands would be helpful:
>   # dfsexport
>   # bos status -server <hostname>
>   # fts lsfldb
>   # fts lsaggr -server <hostname>
>   # fts lsheader -server <hostname>
>
df command:

DFS            9000000 9000000    0%       0     0% /...

mount command:

mount: 0506-309 /... has a gfstype 7 that is not known.

(root@ibm_l3) -->dfsexport
dfsexport: /dev/hd1, ufs, 1, 0,,1

(root@ibm_l3) -->bos status -server ibm_l3
bos: WARNING: short name for server used; no authentication information
 will be sent to the bosserver

Instance flserver, currently running normally.
Instance bakserver, currently running normally.
Instance ftserver, currently running normally.
Instance repserver, currently running normally.

(root@ibm_l3) -->fts lsfldb

root.dfs
        readWrite   ID 0,,1  valid
        readOnly    ID 0,,2  invalid
        backup      ID 0,,3  invalid
number of sites: 1
   server           flags     aggr   siteAge principal      owner
ibm_l3.ch.apollo.hp RW       /home   0:00:00 hosts/ibm_l3   <nil>
----------------------
Total FLDB entries that were successfully enumerated: 1 (0 failed; 0 wrong aggr
type)

fts lsaggr -server ibm_l3
There is 1 aggregate on the server ibm_l3 (ibm_l3.ch.apollo.hp.com):
                /home (/dev/hd1): id=1     (Non-LFS)

(root@ibm_l3) -->fts lsheader -server ibm_l3
Total filesets on server ibm_l3 aggregate /home (id 1): 1
/dev/hd1                 0,,1 RW    484 K alloc    484 K quota On-line
Total filesets on-line 1; total off-line 0; total busy 0

Total number of filesets on server ibm_l3: 1

>Send me the /tmp/dfsdump file and the icl.bind, and the command output.

        See above
>
>We'll start with this, we probably will need additional information
>once we look at these traces.
>
>I'm assuming the AIX machine DCE/DFS configuration still matches the
>last note you posted to the defect.  If it doesn't, please
>include DCE/DFS configuration information.

        Still the same

[10/04/95 public]

Insert of more information as investigation progresses by Liz Hughes: 
To: lhughes@austin.ibm.com
Cc: bell_d@apollo.hp.com
Subject: 2nd attempt dfsdump
Date: Wed, 04 Oct 95 09:08:09 -0400
From: bell_d@apollo.hp.com



On Tue, 3 Oct 1995 lhughes@austin.ibm.com wrote:

        (Some of this message is a repeat of earlier one).

>Thanks Deon,
>Unfortunately, the trace doesn't yield any magic answers.
>
>Would you mind doing this again?  Please turn off all the dfstracing
>except cm, fx, and fshost, the tpq activity really clutters up the log:
>  # dfstrace setset -inactive
>  # dfstrace setset -set cm fx fshost
>  # dfstrace clear

        terminal response of command line ls /:/ is different this time.
        This is the same node as before, been idle since I did the stuff
        last time.

        I also dumped the icl.  Do you want it?

DFS Trace Dump -

   Date: Wed Oct  4 08:57:23 1995

Found 2 logs.

Contents of log cmfx:
Log wrapped; data missing.
time 1010.097024, pid 25279: flushactivescaches starting 0 concurrent storebacks
time 15.108084, pid 25279: running write through dslots
time 15.108696, pid 25279: servertokenmgt running 2 subops
time 15.109586, pid 26307: in cm_FlushQueuedServerTokens for server 5942f0c
time 15.109729, pid 26050: in cm_FlushQueuedServerTokens for server 5942c0c
time 15.109939, pid 25279: running major renewlazyreps
time 15.109967, pid 25279: Renewlazyreps starts 0 subjobs
time 16.120881, pid 25279: flushactivescaches starting 0 concurrent storebacks
ther UUID 6f6931/82dc1071/80e43812/2000
3 for connp 60ad0cc
time 118.066011, pid 26564: start AFS_SetContext conn 60ad0cc srv level 0x20000
time 135.070941, pid 25279: running write through dslots
time 135.071552, pid 25279: servertokenmgt running 2 subops
time 135.072435, pid 26307: in cm_FlushQueuedServerTokens for server 5942f0c
time 135.072577, pid 26050: in cm_FlushQueuedServerTokens for server 5942c0c
time 135.072783, pid 25279: running major renewlazyreps
time 135.072811, pid 25279: Renewlazyreps starts 0 subjobs
time 136.083736, pid 25279: flushactivescaches starting 0 concurrent storebacks
time 151.790904, pid 20666: cm_lookup 60ae00c ibm_l3_s920
time 151.790960, pid 20666: Trybind on name = ibm_l3_s920
time 151.791025, pid 20666: cm_lookup 60ae130 fs
time 151.791041, pid 20666: Trybind on name = fs
time 153.542063, pid 20666: Trybind: read helper returns avpp  2ff97720, replyCode 0
time 153.542260, pid 20666: cm_NewCell ibm_l3_s920
time 153.542327, pid 20666: getvolbyname looking for volume root.dfs
time 153.542355, pid 20666: cm_ConnByMHosts server type 10000
time 153.542375, pid 20666: cm_ConnByHost server type 0x10000, serverp 5942c0c
time 153.542394, pid 20666: cm_ConnByHost: creating conn type 0x10000, conn 60ad08c
time 153.542418, pid 20666: cm_ConnByHost using conn 60ad08c, service 0x10000
time 153.542749, pid 20666: begin VL_GetVolByName
time 153.596216, pid 20666: end VL_GetVolByName, code 0
time 153.596251, pid 20666: cm_Analyze: conn 60ad08c, code 0, user 0
time 153.596322, pid 20666: Install vol entry for volume ID 1
time 153.596459, pid 20666: cm_ConnByMHosts server type 20000
time 153.596474, pid 20666: cm_ConnByMHosts: found  0-th server down
time 153.596486, pid 20666: cm_ConnByMHosts: all filesets bad
time 153.596495, pid 20666: cm_Analyze: conn 0, code -1, user 0
time 153.596545, pid 20666: checkerror returning code 78
time 166.087314, pid 20667: cm_lookup 60ae00c ibm_l3_s920
time 166.087369, pid 20667: Trybind on name = ibm_l3_s920
time 166.087434, pid 20667: cm_lookup 60ae130 fs
time 166.087450, pid 20667: Trybind on name = fs
time 166.094795, pid 25279: flushactivescaches starting 0 concurrent storebacks
time 166.932326, pid 20667: Trybind: read helper returns avpp  2ff97720, replyCode 0
time 166.932525, pid 20667: cm_NewCell ibm_l3_s920
time 166.932624, pid 20667: cm_ConnByMHosts server type 20000
time 166.932636, pid 20667: cm_ConnByMHosts: found  0-th server down
time 166.932648, pid 20667: cm_ConnByMHosts: all filesets bad
time 166.932660, pid 20667: cm_Analyze: conn 0, code -1, user 0
time 166.932708, pid 20667: checkerror returning code 78
time 171.743867, pid 20668: cm_lookup 60ae00c ibm_l3_s920
time 171.743924, pid 20668: Trybind on name = ibm_l3_s920
time 171.743989, pid 20668: cm_lookup 60ae130 fs
time 171.744006, pid 20668: Trybind on name = fs
time 172.618242, pid 20668: Trybind: read helper returns avpp  2ff97720, replyCode 0
time 172.618439, pid 20668: cm_NewCell ibm_l3_s920
time 172.618537, pid 20668: cm_ConnByMHosts server type 20000
time 172.618549, pid 20668: cm_ConnByMHosts: found  0-th server down
time 172.618562, pid 20668: cm_ConnByMHosts: all filesets bad
time 172.618574, pid 20668: cm_Analyze: conn 0, code -1, user 0
time 172.618621, pid 20668: checkerror returning code 78

Contents of log disk:

DFS Trace Dump - Completed

>
>Let the trace run longer this time.  Don't dump the trace until
>you see the error message from the ls command.  We'd like to see the
>return from the AFS_SetContext call which is missing in the current trace.
>
>Also, it looks like the ls command returned this time and did
>not go into an infinite loop, is that correct?

        Yes, it is.
>
>You have configured an HP machine into the cell as a DFS client
>and successfully did an ls /: from the HP dfs client, right?

        right.
>
>Have you tried configuring the AIX machine as a dfs client to
>an HP dfs server and if so, what happened.  If not, can you do that?

        Well, I have done an AIX node as a dfs client to another
        AIX node dfs server successfully.  The problem only manifests
        with the client on the SAME node as the server.

        I don't mind doing this for you AT ALL.  I would really like to
        be in the picture as to what you hope to learn from having it done.
        I hope you don't mind taking a few moments to explain it to me.
>
>Thanks,
>Liz Hughes
>AIX DFS development
>lhughes@austin.ibm.com
>(512) 838-3483

        Thanks to you too.

        Deon

---------

To: lhughes@austin.ibm.com
Cc: bell_d@apollo.hp.com, conley_s@apollo.hp.com, mwc@apollo.hp.com
Subject: dfs operable on AIX node!!!
Date: Wed, 04 Oct 95 12:54:27 -0400
From: bell_d@apollo.hp.com



        Liz:

        I installed and configured on a AIX 3.2.5 node that is new
        to us (borrowed from another department due to machine shortage).

        The good news is that the dfs server/client on the same node is
        operating fine.  The ls /:/ gives me back the appropriate ls
        of the dfs mounted /home directory.

        The question new remains; what is different between the two AIXs?
        We have thought that we had the correct decided upon version (3.2.5)
        with the appropriate patches.

        I think the best thing may be to send you some lslpp info on both
        the working system and the non-working system, and maybe you can
        make some sense of it(?)  

        Given this new information, if there is something new you would like,
        don't hesitate.

        - Deon
-------
I have sent both `lslpp -La` and lslpp -m information from both the 
successful and the unsuccessful systems to Liz for comparison purposes. 
Find below the output from lslpp -m.  (The lslpp -La is too long for cut 
and paste addition here.)

 Successful dfs client/server node:


 Description                                           State     Fix Id
 ----------------------------------------------------  ------    ------------

 X11mEn_US.msg 1.2.3.0
   3250 X11mEn_US X11-R5 Maintenance Level                  C    U491115

 X11rte.ext.obj 1.2.3.0
   3250 X11rte X11-R5 Maintenance Level                     C    U491119

 X11rte.obj 1.2.3.0
   3250 X11rte X11-R5 Maintenance Level                     C    U491119

 bos.data 3.2.0.0
   3250 bos.data Maintenance Level                          C    U491124

 bos.obj 3.2.0.0
   3250 bos Maintenance Level                               C    U491123
   3250 AIX Maintenance Level                               C    U493250

 bosadt.bosadt.data 3.2.0.0
   No Maintenance Level Applied.

 bosadt.bosadt.obj 3.2.0.0
   3250 bosadt Maintenance Level                            C    U491125

 bosadt.lib.obj 3.2.0.0
   3250 bosadt Maintenance Level                            C    U491125

 bosadt.prof.obj 3.2.0.0
   3250 bosadt Maintenance Level                            C    U491125

 bosadt.xde.obj 3.2.0.0
   3250 bosadt Maintenance Level                            C    U491125

 bosext1.csh.obj 3.2.0.0
   3250 bosext1 Maintenance Level                           C    U491126
 bosext1.ecs.obj 3.2.0.0
   3250 bosext1 Maintenance Level                           C    U491126

 bosext1.extcmds.data 3.2.0.0
   3250 bosext1.data Maintenance Level                      C    U491127

 bosext1.extcmds.obj 3.2.0.0
   3250 bosext1 Maintenance Level                           C    U491126

 bosext1.mh.obj 3.2.0.0
   3250 bosext1 Maintenance Level                           C    U491126

 bosext1.uucp.obj 3.2.0.0
   3250 bosext1 Maintenance Level                           C    U491126

 bosext1.vdidd.obj 3.2.0.0
   3250 bosext1 Maintenance Level                           C    U491126

 bosext2.acct.obj 3.2.0.0
   3250 bosext2 Maintenance Level                           C    U491128

 bosext2.ate.obj 3.2.0.0
   3250 bosext2 Maintenance Level                           C    U491128

 bosext2.dlc8023.obj 3.2.0.0
   3250 bosext2 Maintenance Level                           C    U491128

 bosext2.dlcether.obj 3.2.0.0
   3250 bosext2 Maintenance Level                           C    U491128

 bosext2.dlcfddi.obj 3.2.0.0
   3250 bosext2 Maintenance Level                           C    U491128

 bosext2.dlcqllc.obj 3.2.0.0
   3250 bosext2 Maintenance Level                           C    U491128

 bosext2.dlcsdlc.obj 3.2.0.0
   3250 bosext2 Maintenance Level                           C    U491128

 bosext2.dlctoken.obj 3.2.0.0
   3250 bosext2 Maintenance Level                           C    U491128

 bosext2.dosutil.obj 3.2.0.0
   3250 bosext2 Maintenance Level                           C    U491128

 bosext2.games.obj 3.2.0.0
   3250 bosext2 Maintenance Level                           C    U491128

 bosext2.lrn.data 3.2.0.0
   3250 bosext2.data Maintenance Level                      C    U491129

 bosext2.x25app.obj 3.2.0.0
   3250 bosext2 Maintenance Level                           C    U491128

 bosnet.ncs.obj 3.2.0.0
   3250 bosnet Maintenance Level                            C    U491130

 bosnet.nfs.obj 3.2.0.0
   3250 bosnet Maintenance Level                            C    U491130

 bosnet.snmpd.obj 3.2.0.0
   3250 bosnet Maintenance Level                            C    U491130

 bosnet.tcpip.obj 3.2.0.0
   3250 bosnet Maintenance Level                            C    U491130

 bsl.en_US.aix.loc 3.2.0.0
   3250 bsl Maintenance Level                               C    U491131

 bsl.en_US.pc.loc 3.2.0.0
   3250 bsl Maintenance Level                               C    U491131

 bsmEn_US.msg 3.2.0.0
   3250 bsmEn_US Maintenance Level                          C    U491133

 xlccmp.obj 1.3.0.0
   3250 xlccmp 1.3 Maintenance Level                        C    U491204


State Codes:
 A -- Applied.
 B -- Broken.
 C -- Committed.
 N -- Not Installed, but was previously installed/seen on some media.
 - -- Superseded, not Applied.
 ? -- Inconsistent State...Run lppchk -v.


 UNSUCCESSFUL dfs client/server node:

 Description                                           State     Fix Id
 ----------------------------------------------------  ------    ------------

 X11fnt.coreX.fnt 1.2.3.0
   3250 X11fnt X11-R5 Maintenance Level                     C    U491105

 X11fnt.ibm850.pc.fnt 1.2.3.0
   3250 X11fnt X11-R5 Maintenance Level                     C    U491105

 X11fnt.iso88591.aix.fnt 1.2.3.0
   3250 X11fnt X11-R5 Maintenance Level                     C    U491105

 X11fnt.oldX.fnt 1.2.3.0
   3250 X11fnt X11-R5 Maintenance Level                     C    U491105

 X11mEn_US.msg 1.2.3.0
   3250 X11mEn_US X11-R5 Maintenance Level                  C    U491115

 X11rte.ext.obj 1.2.3.0
   3250 X11rte X11-R5 Maintenance Level                     C    U491119

 X11rte.obj 1.2.3.0
   3250 X11rte X11-R5 Maintenance Level                     C    U491119

 bos.data 3.2.0.0
   3250 bos.data Maintenance Level                          C    U491124
   3250 AIX Maintenance Level                               C    U493250

 bosadt.bosadt.data 3.2.0.0
   No Maintenance Level Applied.

 bosadt.bosadt.obj 3.2.0.0
   3250 bosadt Maintenance Level                            C    U491125

 bosadt.lib.obj 3.2.0.0
   3250 bosadt Maintenance Level                            C    U491125

 bosadt.prof.obj 3.2.0.0
   3250 bosadt Maintenance Level                            C    U491125

 bosadt.xde.obj 3.2.0.0
   3250 bosadt Maintenance Level                            C    U491125

 bosext1.csh.obj 3.2.0.0
   3250 bosext1 Maintenance Level                           C    U491126

 bosext1.ecs.obj 3.2.0.0
   3250 bosext1 Maintenance Level                           C    U491126

 bosext1.extcmds.data 3.2.0.0
   3250 bosext1.data Maintenance Level                      C    U491127

 bosext1.extcmds.obj 3.2.0.0
   3250 bosext1 Maintenance Level                           C    U491126

 bosext1.mh.obj 3.2.0.0
   3250 bosext1 Maintenance Level                           C    U491126

 bosext1.uucp.obj 3.2.0.0
   3250 bosext1 Maintenance Level                           C    U491126

 bosext1.vdidd.obj 3.2.0.0
   3250 bosext1 Maintenance Level                           C    U491126

 bosext2.acct.obj 3.2.0.0
   3250 bosext2 Maintenance Level                           C    U491128

 bosext2.ate.obj 3.2.0.0
   3250 bosext2 Maintenance Level                           C    U491128

 bosext2.dlc8023.obj 3.2.0.0
   3250 bosext2 Maintenance Level                           C    U491128

 bosext2.dlcether.obj 3.2.0.0
   3250 bosext2 Maintenance Level                           C    U491128

 bosext2.dlcfddi.obj 3.2.0.0
   3250 bosext2 Maintenance Level                           C    U491128

 bosext2.dlcqllc.obj 3.2.0.0
   3250 bosext2 Maintenance Level                           C    U491128

 bosext2.dlcsdlc.obj 3.2.0.0
   3250 bosext2 Maintenance Level                           C    U491128

 bosext2.dlctoken.obj 3.2.0.0
   3250 bosext2 Maintenance Level                           C    U491128

 bosext2.dosutil.obj 3.2.0.0
   3250 bosext2 Maintenance Level                           C    U491128

 bosext2.games.obj 3.2.0.0
   3250 bosext2 Maintenance Level                           C    U491128

 bosext2.lrn.data 3.2.0.0
   3250 bosext2.data Maintenance Level                      C    U491129

 bosext2.x25app.obj 3.2.0.0
   3250 bosext2 Maintenance Level                           C    U491128

 bosnet.ncs.obj 3.2.0.0
   3250 bosnet Maintenance Level                            C    U491130

 bosnet.nfs.obj 3.2.0.0
   3250 bosnet Maintenance Level                            C    U491130

 bosnet.snmpd.obj 3.2.0.0
   3250 bosnet Maintenance Level                            C    U491130

 bosnet.tcpip.obj 3.2.0.0
   3250 bosnet Maintenance Level                            C    U491130

 bsl.en_US.aix.loc 3.2.0.0
   3250 bsl Maintenance Level                               C    U491131

 bsl.en_US.pc.loc 3.2.0.0
   3250 bsl Maintenance Level                               C    U491131

 bsmEn_US.msg 3.2.0.0
   3250 bsmEn_US Maintenance Level                          C    U491133

 nep.ddx 1.1.2.0
   No Maintenance Level Applied.

 nep.mcx 1.1.2.0
   No Maintenance Level Applied.

 nep.vdd 1.1.2.0
   No Maintenance Level Applied.

 xlccmp.obj 1.3.0.0
   3250 xlccmp 1.3 Maintenance Level                        C    U491204


State Codes:
 A -- Applied.
 B -- Broken.
 C -- Committed.
 N -- Not Installed, but was previously installed/seen on some media.
 - -- Superseded, not Applied.
 ? -- Inconsistent State...Run lppchk -v.

[10/05/95 public]

To: lhughes@austin.ibm.com
Cc: bell_d@apollo.hp.com, lmm@apollo.hp.com
/21/94   02:08:49 root
    U422592 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:08:49 root
    U422593 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:08:50 root
    U422594 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:08:50 root
    U422595 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:08:51 root
    U422596 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:08:52 root
    U422597 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:08:52 root
    U425841 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:08:53 root
    U491115 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:08:53 root


  X11rte.ext.obj
    U411705 01.02.0000.0000 COMPLETE   COMMIT     03/21/94   02:03:04 root

  X11rte.ext.obj
            01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:02:54 root
    U409194 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:02:59 root
    U422598 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:02:59 root
    U422599 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:03:00 root
    U422600 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:03:01 root
    U422601 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:03:02 root
    U422602 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:03:02 root
    U422603 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:02:55 root
    U422604 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:02:56 root
    U423364 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:02:57 root
    U424814 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:03:04 root
    U425319 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:03:05 root
    U425321 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:03:04 root
    U425829 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:03:06 root
    U491119 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:03:05 root

  X11rte.obj
    U411705 01.02.0000.0000 COMPLETE   COMMIT     03/21/94   02:02:55 root

  X11rte.obj
            01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:02:51 root
    U409194 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:02:54 root
    U422606 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:02:51 root
    U422607 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:02:53 root
    U422608 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:02:53 root
    U422609 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:02:58 root
    U424551 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:03:05 root
    U491119 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:03:08 root
    U491174 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:03:06 root
    U491177 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:03:07 root
    U491178 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:02:55 root

  bos.obj
            03.02.0000.0000 COMPLETE   COMMIT     12/31/69   18:00:00 root
    U407415 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:57 root
    U418278 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:44 root
    U418289 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:39 root
    U418295 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:40 root
    U418321 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:40 root
    U418324 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:41 root
    U418325 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:42 root
    U418326 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:43 root
    U418329 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:43 root
    U418330 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:44 root
    U418332 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:45 root
    U418337 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:46 root
    U418343 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:46 root
    U418344 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:47 root
    U422437 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   15:30:05 root
    U422441 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:45 root
    U422442 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:48 root
    U422443 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:49 root
    U422444 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:37 root
    U422445 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:49 root
    U422446 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:54 root
    U422447 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:51 root
    U422448 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:46 root
    U422449 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:52 root
    U422450 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:52 root
    U422451 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:39 root
    U422452 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:40 root
    U422453 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:53 root
    U422454 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:54 root
    U422455 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:55 root
    U422456 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:56 root
    U422457 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:27 root
    U422458 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:22 root
    U422459 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:28 root
    U422460 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:57 root
    U422461 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:58 root
    U422462 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:32 root
    U422463 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:59 root
    U422464 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:33 root
    U422465 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:00 root
    U422466 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:02 root
    U422467 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   15:30:05 root
    U422468 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:55 root
    U422469 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:58 root
    U422470 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:03 root
    U422471 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:55 root
    U422472 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:03 root
    U422473 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:04 root
    U422474 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:05 root
    U422475 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:06 root
    U422476 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:47 root
    U422477 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:07 root
    U422478 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:57 root
    U422479 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:07 root
    U422480 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:08 root
    U422481 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:09 root
    U422482 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:10 root
    U422483 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:34 root
    U422484 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:41 root
    U422485 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:42 root
    U422486 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:48 root
    U422487 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:09:35 root
    U422488 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:12 root
    U422489 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:43 root
    U422490 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:12 root
    U422491 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:48 root
    U422492 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:13 root
    U422493 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:14 root
    U422494 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:15 root
    U422495 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:16 root
    U422496 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:49 root
    U422497 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:16 root
    U423492 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:18 root
    U423515 03.02.0000.0000 COMPLETE   COMMIT     10/11/93   20:21:39 root
    U423535 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   18:32:08 root
    U423643 03.02.0000.0000 COMPLETE   COMMIT     10/11/93   20:21:40 root
    U423716 03.02.0000.0000 COMPLETE   COMMIT     11/18/93   09:53:41 root
    U423761 03.02.0000.0000 COMPLETE   COMMIT     10/11/93   20:21:39 root
    U423984 03.02.0000.0000 COMPLETE   COMMIT     11/03/93   11:43:38 root
    U424003 03.02.0000.0000 COMPLETE   COMMIT     11/18/93   09:46:00 root
    U424153 03.02.0000.0000 COMPLETE   COMMIT     11/03/93   11:43:40 root
    U424399 03.02.0000.0000 COMPLETE   COMMIT     11/03/93   11:43:17 root
    U424402 03.02.0000.0000 COMPLETE   COMMIT     11/03/93   11:43:19 root
    U424502 03.02.0000.0000 COMPLETE   COMMIT     11/03/93   11:43:36 root
    U424508 03.02.0000.0000 COMPLETE   COMMIT     11/18/93   09:53:40 root
    U424590 03.02.0000.0000 COMPLETE   COMMIT     11/18/93   09:53:37 root
    U424613 03.02.0000.0000 COMPLETE   COMMIT     11/18/93   09:53:42 root
    U424777 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:21 root
    U425688 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:28 root
    U425823 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:22 root
    U491123 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:11:00 root
    U491150 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   18:32:09 root
    U491160 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:37 root
    U491161 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:19 root
    U491162 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:52 root
    U491163 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:59 root
    U491164 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:59 root
    U491165 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:58 root
    U491167 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:34 root
    U491168 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:52 root
    U491169 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:53 root
    U491170 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:35 root
    U491171 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:11:00 root
    U491172 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:53 root
    U491173 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:53 root
    U491181 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:35 root
    U491186 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:36 root
    U491203 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:37 root
    U491255 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:22 root
    U491256 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:23 root
    U491257 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:30 root
    U491258 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:23 root
    U491259 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:23 root
    U491261 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:23 root
    U491262 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:24 root
    U491264 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:24 root
    U491265 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:24 root
    U491267 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:25 root
    U491268 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:25 root
    U491270 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:25 root
    U491271 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:25 root
    U491273 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:26 root
    U491274 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:26 root
    U491276 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:26 root
    U491277 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:27 root
    U491279 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:27 root
    U491280 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:27 root
    U491282 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:27 root
    U491283 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:28 root
    U493250 03.02.0000.0000 COMPLETE   COMMIT     10/11/93   20:21:41 root

  bosadt.bosadt.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:14 root
    U418356 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:28 root
    U418360 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:28 root
    U418363 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:29 root
    U418366 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:29 root
    U418367 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:30 root
    U422498 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:32 root
    U422499 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:34 root
    U422500 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:34 root
    U422501 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:35 root
    U422502 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:35 root
    U423365 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:42 root
    U423366 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:42 root
    U423371 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:44 root
    U423493 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:44 root
    U491125 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:06 root

  bosadt.lib.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:14 root
    U418298 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:27 root
    U418371 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:31 root
    U418372 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:31 root
    U418374 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:32 root
    U422503 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:36 root
    U422504 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:37 root
    U422505 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:40 root
    U422506 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:40 root
    U423369 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:43 root
    U423370 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:43 root
    U424505 03.02.0000.0000 COMPLETE   COMMIT     11/18/93   09:53:39 root
    U424808 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:30 root
    U491125 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:16 root
    U491179 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:06 root

  bosadt.prof.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:14 root
    U422507 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:41 root
    U491125 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:06 root

  bosadt.xde.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:59 root
    U422508 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:07 root
    U491125 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:16 root

  bosext1.csh.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:15 root
    U422509 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:47 root
    U491126 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:06 root

  bosext1.ecs.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:00 root
    U418375 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:08 root
    U491126 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:16 root

  bosext1.extcmds.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:15 root
    U418377 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:45 root
    U419138 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:46 root
    U422511 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:47 root
    U491126 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:06 root

  bosext1.mh.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:15 root
    U422512 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:45 root
    U491126 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:06 root

  bosext1.uucp.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:15 root
    U422513 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:48 root
    U491126 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:06 root

  bosext1.vdidd.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:15 root
    U419139 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:46 root
    U491126 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:06 root

  bosext2.acct.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:17 root
    U422514 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:48 root
    U491128 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:06 root

  bosext2.ate.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:17 root
    U422515 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:49 root
    U491128 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:06 root

  bosext2.dlc8023.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:17 root
    U422516 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:50 root
    U491128 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:06 root

  bosext2.dlcether.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:17 root
    U422517 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:51 root
    U491128 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:06 root

  bosext2.dlcfddi.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:00 root
    U422518 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:08 root
    U491128 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:16 root

  bosext2.dlcqllc.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:17 root
    U422519 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:52 root
    U491128 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:06 root

  bosext2.dlcsdlc.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:17 root
    U422520 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:53 root
    U491128 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:06 root

  bosext2.dlctoken.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:17 root
    U422521 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:54 root
    U491128 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:06 root

  bosext2.dosutil.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:17 root
    U422522 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:54 root
    U491128 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:06 root

  bosext2.games.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:17 root
    U422523 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:55 root
    U491128 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:06 root

  bosext2.x25app.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:17 root
    U422524 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:56 root
    U491128 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:06 root

  bosnet.ncs.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:01 root
    U422533 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:12 root
    U491130 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:16 root

  bosnet.nfs.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:01 root
    U422534 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:09 root
    U422535 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:10 root
    U422536 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:13 root
    U491130 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:16 root

  bosnet.snmpd.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:01 root
    U422537 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:11 root
    U424404 03.02.0000.0000 COMPLETE   COMMIT     11/03/93   11:43:40 root
    U491130 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:16 root
    U491183 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:16 root

  bosnet.tcpip.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:23 root
    U422538 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:56 root
    U422539 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:58 root
    U422540 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:58 root
/21/94   01:38:59 root
    U422577 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:39:02 root
    U491133 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:39:03 root

  xlccmp.obj
            01.03.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:24 root
    U491204 01.03.0000.0000 COMPLETE   COMMIT     10/07/93   18:32:09 root

Path: /etc/objrepos
  X11rte.ext.obj
            01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:02:55 root

  X11rte.obj
    U422609 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:03:03 root
    U424551 01.02.0003.0000 COMPLETE   COMMIT     03/21/94   02:03:07 root

  bos.obj
            03.02.0000.0000 COMPLETE   COMMIT     12/31/69   18:00:00 root
    U422444 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:39 root
    U422446 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:56 root
    U422451 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:50 root
    U422452 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:50 root
    U422457 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:20 root
    U422458 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:36 root
    U422459 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:20 root
    U422462 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:20 root
    U422464 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:21 root
    U422483 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:21 root
    U422484 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:51 root
    U422485 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:51 root
    U422487 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:21 root
    U422489 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:10:51 root
    U423535 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   18:32:09 root
    U423761 03.02.0000.0000 COMPLETE   COMMIT     10/11/93   20:21:40 root
    U424399 03.02.0000.0000 COMPLETE   COMMIT     11/03/93   11:43:41 root
    U424402 03.02.0000.0000 COMPLETE   COMMIT     11/03/93   11:43:42 root
    U424502 03.02.0000.0000 COMPLETE   COMMIT     11/03/93   11:43:42 root
    U424590 03.02.0000.0000 COMPLETE   COMMIT     11/18/93   09:53:43 root
    U424613 03.02.0000.0000 COMPLETE   COMMIT     11/18/93   09:53:44 root
    U424777 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:30 root
    U425688 03.02.0000.0000 COMPLETE   COMMIT     03/21/94   01:28:30 root

  bosext1.ecs.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:04 root

  bosext1.mh.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:24 root
    U422512 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:03 root

  bosext1.uucp.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:24 root

  bosext2.acct.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:25 root

  bosext2.dlc8023.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:25 root

  bosext2.dlcether.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:25 root

  bosext2.dlcfddi.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:04 root

  bosext2.dlcqllc.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:25 root

  bosext2.dlcsdlc.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:25 root

  bosext2.dlctoken.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:25 root

  bosnet.ncs.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:04 root

  bosnet.nfs.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:04 root
    U422534 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:14 root
    U422535 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:14 root

  bosnet.snmpd.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:04 root
    U422537 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:15 root
    U424404 03.02.0000.0000 COMPLETE   COMMIT     11/03/93   11:43:42 root

  bosnet.tcpip.obj
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:25 root
    U422538 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:03 root
  xlccmp.obj
            01.03.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:26 root

Path: /usr/share/lib/objrepos
  bos.data
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:05:30 root
    U422439 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:05:31 root
    U422440 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:05:31 root
    U491124 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:05:32 root

  bosadt.bosadt.data
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:26 root

  bosext1.extcmds.data
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:26 root
    U422510 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:04 root
    U491127 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:15 root

  bosext2.lrn.data
            03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:44:27 root
    U418385 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:05 root
    U491129 03.02.0000.0000 COMPLETE   COMMIT     10/07/93   08:45:15 root

THE BAD SYSTEM:

  Name
  --------------------
    Fix Id  Release         Status     Action     Date       Time     User Name
    ------- --------------- ---------- ---------- ---------- -------- ----------
Path: /usr/lib/objrepos
  X11fnt.coreX.fnt
            01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:20:32 root
    U423362 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:20:34 root
    U491105 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:20:35 root

  X11fnt.ibm850.pc.fnt
            01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:20:32 root
    U422588 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:20:34 root
    U491105 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:20:35 root

  X11fnt.iso88591.aix.fnt
            01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:20:32 root
    U491105 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:20:35 root

  X11fnt.oldX.fnt
            01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:20:32 root
    U491105 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:20:35 root

  X11mEn_US.msg
    U411707 01.02.0000.0000 COMPLETE   COMMIT     03/26/25   11:27:50 root

  X11mEn_US.msg
            01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:27:46 root
    U410794 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:27:47 root
    U422592 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:27:47 root
    U422593 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:27:48 root
    U422594 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:27:49 root
    U422596 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:27:49 root
    U422597 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:27:50 root
    U425841 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:27:51 root
    U428099 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:27:51 root
    U432312 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:27:52 root
    U491115 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:27:52 root

  X11rte.ext.obj
    U411705 01.02.0000.0000 COMPLETE   COMMIT     03/26/25   11:05:20 root

  X11rte.ext.obj
            01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:15 root
    U409194 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:16 root
    U422598 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:16 root
    U422599 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:17 root
    U422600 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:17 root
    U422601 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:18 root
    U422603 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:18 root
    U422604 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:19 root
    U423364 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:19 root
    U424814 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:20 root
    U425319 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:20 root
    U425321 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:21 root
    U428195 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:26 root
    U432315 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:28 root
    U491119 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:28 root

  X11rte.obj
    U411705 01.02.0000.0000 COMPLETE   COMMIT     03/26/25   11:05:15 root

  X11rte.obj
            01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:11 root
    U409194 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:12 root
    U422606 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:12 root
    U422607 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:13 root
    U422608 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:14 root
    U428372 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:22 root
    U433733 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:27 root
    U491119 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:29 root
    U491174 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:28 root
    U491177 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:21 root
    U491178 01.02.0003.0000 COMPLETE   COMMIT     03/26/25   11:05:16 root

  bos.obj
            03.02.0000.0000 COMPLETE   COMMIT     12/31/69   19:00:00 root
    U407415 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:10:57 root
    U418278 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:10:44 root
    U418289 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:09:39 root
    U418295 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:09:40 root
    U418321 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:09:40 root
    U418324 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:09:41 root
    U418325 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:09:42 root
    U418326 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:09:43 root
    U418329 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:09:43 root
    U418330 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:09:44 root
    U418332 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:09:45 root
    U418337 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:09:46 root
    U418343 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:09:46 root
    U418344 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:09:47 root
    U422437 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   16:30:05 root
    U422441 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:10:45 root
    U422442 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:09:48 root
    U422443 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:09:49 root
    U422444 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:10:37 root
    U422445 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:09:49 root
    U422446 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:10:54 root
    U422447 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:09:51 root
    U422448 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:10:46 root
    U422449 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:09:52 root
    U422450 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:09:52 root
    U422451 03.02.0000.0000 COMPLETE   COMMIT     10/06/93   17:10:39 root
    U422452 03.02.0000.0000 COMPLETE   COMMIT    [bell_d@ch.hp.com 10/16/95 public]

Liz Hughes from IBM and I have investigated this problem.  She took a 
build of the DCE that was just previous to the Xidl additions (done by 
Gerry Thomey) and installed them on a PowerPC at Austin.  DFS client/server 
on the same node worked. (That is, ls /:/ gave back a list of the dfs 
file system). 

We exchanged the dfs kernel extension files (dfscore.ext and dfscmfx.ext). 
I loaded her extensions onto the Power PC here at HP running DCE 1.2 with 
Xidl.  They worked.  She loaded my extensions onto her PowerPC at 
Austin running DCE 1.1 (DCE just before Xidl), and they broke the dfs. 

Conclusion:  dfs server/client on same node inoperable on AIX Power PC 
systems seems to have been introduced by the Xidl source changes and 
additions.  (This problem is on the Power PC only.  Unfortunately, our 
2 main test nodes are Power PCs.)  I have reassigned this OT to DEC.  

Thanks to Liz Hughes for all her patience and hard work.

[10/26/95 public]

Some suggestions for further investigation.

1) If you have a K-RPC test that works without XIDL but fails with XIDL
please forward that to us.

2) We did not intrinsically make any K-RPC changes for XIDL, but because
of a compilation problem when compiling all of rpc, I removed a function.
It wouldn't let me redeclare the 'abort' function in subr_krpc.c, so I 
changed this part to:
	#ifndef AIX32
	int
	abort( void )
	{
    		panic("NCK runtime abort");
	}
	#endif
I don't know if I've damaged something by doing this, I should think its
only hit by very special failures anyway, but someone more knowledgable
in this area should perhaps examine this.

3) The failing DFS test should be run with using the old libdce (without
XIDL) by using LD_LIBRARY_PATH to see if that makes the problem go away.
If it does clear up the problem, we know that the issue was with 
building libdce.

4) If libdce is at fault, replace just the idl portion of the new libdce 
and see if that clears up the problem.  If it does, then we're suspect,
otherwise its in another componenet.

5) Build the krpc component with the old idl compiler.  If that clears
up the problem, then the new idl is highly suspect and we can begin
diffing the generated stubs to see which one caused the problem.

[12/22/95 public]
Fixed in DCE 1.2.1
Closed



CR Number                     : 13040
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : dg
Short Description             : Handle 103 meaning of FACK winsz field
Reported Date                 : 8/16/95
Found in Baseline             : 1.1
Found Date                    : 8/11/95
Severity                      : B
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : dglsn.c
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : jaffe@transarc.com
Transarc Status               : open

[8/16/95 public]
The interpretation of the FACK window_size field changed between
DCE1.0.3 and DCE1.1.  This can cause interoperability problems.
The suggested fix is to modify the code in do_fack_body to check the
result of the conversion from Kb to packets for zero.  If the
window_size is larger than the send_frag_size then assume you are
talking to a 1.0.3 receiver and use a window size of three(3).
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `jaffe@transarc.com' 
Added field Transarc Status with value `open'

[12/19/95 public]
Fixed in DCE 1.2.1
Closed



CR Number                     : 13039
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : Runtime wants to know if using pipes
Reported Date                 : 8/15/95
Found in Baseline             : 1.1
Found Date                    : 8/15/95
Severity                      : E
Priority                      : 4
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : rpc/sys_idl/rpcbase.idl
					     rpc/idl/idl_compiler/clihamts.c
Sensitivity                   : public

[8/15/95 public]

A client stub should provide a hint to the rpc runtime that it's using
pipes. This can be implemented by the following changes in the header file
and the IDL compiler, that passes the hint as a part of the call_options in
rpc_call_start().

In rpc/sys_idl/rpcbase.idl, add the following after rpc_c_call_maybe:

const long  rpc_c_call_in_pipe              = 0x01000000;
const long  rpc_c_call_out_pipe             = 0x02000000;

In rpc/idl/idl_compiler/clihamts.c, CSPELL_call_start(), add the following
after spelling of "|rpc_c_call_idempotent":

    if (AST_HAS_IN_PIPES_SET(p_operation))
    {
        fprintf( fid, "|rpc_c_call_in_pipe" );
    }
    if (AST_HAS_OUT_PIPES_SET(p_operation))
    {
        fprintf( fid, "|rpc_c_call_out_pipe" );
    }

This is very valuable information for the rpc runtime, especially for the
DG protocol, doing timeout avoidance, optimization, etc. For instance, one
can use this hint to turn off the DG private socket for pipes so that
blocking in pipe's push/pull routines won't cause the timeout
(rpc_s_comm_failure).

It is desirable to also pass it to the server side runtime, however the
server stub don't call rpc_call_start(). (Making it a part of the PDU
header, thus the protocol change, seems to be overkill.)

[12/20/95 public]
Fixed in DCE 1.2.1
Closed



CR Number                     : 13037
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : uninitialized vars in receive_dispatch()
Reported Date                 : 8/15/95
Found in Baseline             : 1.1
Found Date                    : 8/15/95
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : rpc/runtime/cnrcvr.c
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : open

[8/15/95 public]
   In an application wherein wherein one DCE process calls another, and the
second calls the first back from within the manager function, the first
process occasionally crashes.  On inspection, the address space of the first
process appears to be corrupt.  
Delta: khale-db15632-uninitialized-var-causes-bus-error-in-rpc__cn_call_end
Change: rpc/runtime/cnrcvr.c from 12.1 to 12.3
*** rpc/runtime/cnrcvr.c
--- 12.3        1995/06/16 18:39:35
***************
*** 1,3 ****
--- 1,21 ----
+ /*-
+  * @TRANSARC_COPYRIGHT@
+  *
+  * $TALog: cnrcvr.c,v $
+  * Revision 12.3  1995/06/16  18:39:35  khale
+  * This delta fixes a problem caused by uninitialized vars in receive_dispatch(),
+  * which does no init the IOVLEN field in a crep to 0.
+  *
+  * Set the IOVLEN field to 0
+  * [from r12.1 by delta khale-db15632-uninitialized-var-causes-bus-error-in-rpc__cn_call_end, r1.1]
+  *
+  * $EndTALog$
+  */
+ 
+ #if !defined(_NOIDENT) && !defined(lint)
+ static char *TARCSId = "$Id: c013037,v 1.4 95/12/15 09:45:30 root Exp $";
+ #endif
+ 
  /*
   * @OSF_COPYRIGHT@
   * COPYRIGHT NOTICE
***************
*** 982,987 ****
--- 1000,1008 ----
  
                  {
                  int i;
+ 
+               RPC_CN_CREP_IOVLEN(call_r) = 0;
+ 
                  for( i=1; i<RPC_C_MAX_IOVEC_LEN; i++ ) {
                      call_r->buffered_output.iov.elt[i].buff_addr = NULL;
                      call_r->buffered_output.iov.elt[i].buff_dealloc = NULL;
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `open'

[8/15/95 public]
Please do not assign bugs to me on creation.  I don't even work on the RPC
component.  Leave the actual assignment of the bug to the component owner.
I've removed my name from the responsible engineer field above.

[8/16/95 public]

Just curious. Is the callback a maybe call?

[12/15/95 public]
Fixed in DCE 1.2.1
Closed



CR Number                     : 13032
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_gd
Short Description             : add xidl information
Reported Date                 : 8/9/95
Found in Baseline             : 1.1
Found Date                    : 8/9/95
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : idl refpage, appgd (intro + core)
Sensitivity                   : public

[8/9/95 public]
This bug covers the xidl (object-oriented idl extensions) being added by 
Digital to DCE 1.2.1. It will be closed after the material has been
submitted, reviewed, and approved.

[9/13/95 public]
corrected some addresses (burns, jshirley)

[9/15/95 public]
  Added new Chapter 15 - distrib_obj_usage.gpsml to the App Dev Gd Core 
  volume. 
  
  Replaced existing 17.14.3 "Enumerations" with revised section. 
  
  Added new section 17.4 "IDL Support for C++" to idl.gpsml
  
  Replaced existing 18.3.3 "The include Statement" with revised section
  
  Added new Section 18.4 ("The C++ Attributes cxx_new, cxx_static, and
  cxx_lookup ") to acf.gpsml

  The idl.8dce reference page will be updated after the command reference 
  R1.1 technical and editorial fixes have been made.

[9/19/95 public]
Added subcomponent field values (i.e., book names), fixed "Reported by"
field value.

[10/4/95 public]
Changed erroneous "app_ref" in subcomponent to "command_ref".

[3/28/96 public]
Closing the CR as this documentation is completed. The docs have been
reviewed and approved.



CR Number                     : 13026
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : dg
Short Description             : FACK advertizes huge max_tsdu it cannot honor
Reported Date                 : 8/7/95
Found in Baseline             : 1.1
Found Date                    : 8/7/95
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : dgcall.c
Sensitivity                   : public

[8/7/95 public]
The DCE1.1 kernel dg protocol changed the name of one of the fields in a
fack from max_path_tpdu to max_frag_size.  The 103 code basically ignores
this number.  In the kernel on Solaris the 1.1 code sends facks with
max_tsdu set to 49000+ bytes and the max_frag_size (was max_path_tpdu) to
8000.  However, the kernel *WILL* not read a packet out of the network
larger than 8192 bytes.  The IBM1.0.3 product can decide to send fragments
as large as 8400+ bytes.  These cannot be receives and the call (usual a
pipe argument) fails and the file exporter sees pipe exceptions.

The logic for determining all these numbers is very convoluted and I am not
up to figuring out what the right fix is.  However, it is abundantly clear
that neither of these number should ever be larger than
RPC_C_DG_MAX_PKT_SIZE.  So I propose the following change in
dgcall.c:rpc__dg_call_xmit_fack
    body.vers           = RPC_C_DG_FACKPKT_BODY_VERS;
    body.pad1           = 0;
-   body.max_tsdu       = xq->max_rcv_tsdu;
+   body.max_tsdu       = MIN(xq->max_rcv_tsdu,RPC_C_DG_MAX_PKT_SIZE);

I will leave the max_frag_size computation alone.

[8/7/95 public]

Simple question: how does IBM 1.0.3 product decide to send fragments larger
than 8000 bytes? It seems to me that IBM 1.0.3 product is breaking the wire
protocol. (Unfortunately, AES/DC RPC Volume Revision A is not concise about
the fragment size negotiation. But, I think that it doesn't mean anyone can
invent own.) Here is the excerpt from dce1.0.3 dg.h:

 * The following two values related to packet size can appear in a fack
 * body:
 *
 * max_tsdu:      The size of the largest transport protocol data unit
 *                (TPDU) that can be passed through the local transport
 *                service interface (i.e., transport API).  The fack
 *                sender can never process datagrams larger than this.
 *
 * max_path_tpdu: The size of the largest transport protocol data unit
 *                (TPDU) that can be sent to the fack receiver without
 *                being fragmented along the way.
 *
 * The sender of a fack puts its local idea of these two values into
 * the fack body purely as advisory information, to help the other side
 * determine what packet size to use.  The fack sender is saying "Don't
 * ever send me packets larger than 'max_tsdu'" and "I think you probably
 * don't want to send me packets larger than 'max_path_tpdu'".
 * 
 * The receiver of a fack compares the two values with the locally
 * determined values (in the receiver's call xmitq) and, if appropriate,
 * the xmitq's maximum packet size is increased.  (Currently, we play
 * it safe by taking the minimum the two values in the fack and the two
 * locally computed values.)

If IBM 1.0.3 follows the above, it shouldn't send a fragment larger than
8000 (max_path_tpdu).

RPC_C_DG_MAX_PKT_SIZE should not limit the fragment size. See comment in
dg.h.

Side note: OSF dce1.0.3 implementation ignores the fack body's
max_path_tpdu and uses the value returned from
rpc__naf_inq_max_pth_unfrg_tpdu() (which is 1464).

[8/7/95 public]
It seems clear from the comments you quote above that the max_path_tpdu
is advisory.  Further, as you note, the reference implementation ignores
this value.  It maybe that the ...inq_max_pth... thing returns 1464 in
the reference code but IBM103 product decides on 8400 somehow.  Since
max_tsdu is 49K this is clearly legal.

The comments about RPC_C_DG_MAX_PKT_SIZE suggest that this is the KERNEL
implementation limit.  I don't know what you mean when you say that this
"should not limit the fragment size", as clearly it does.  Filling this
into max_tsdu (which is the absolute upper bound) seems ideal.

[8/7/95 public]

If you ignore the advice and the call fails, who should be blamed? :-) The
reference implementation ignores max_path_tpdu (means it's broken), but
fortunately, it doesn't use a large fragment. Should we change the protocol
just because there are senders who ignore the advice? I hope, not.

RPC_C_DG_MAX_PKT_SIZE is not the *KERNEL* implementation limit. It just
means that internally we use it as a size of a packet buffer. At dce1.0.3
where there was no multi-buffer fragment, max_path_tpdu had to be less than
or equal to rpc_c_dg_max_pkt_size. At dce1.1 with the multi-buffer
fragment, max_frag_size has to be less than or equal to
RPC_C_DG_MAX_FRAG_SIZE. (See dg.h's #define. packet buffers are chained to
make a fragment buffer.) Note: The reference implementation does not use
the MBF in krpc, but HP uses it in krpc. max_tsdu tells how much data
recv/sendmsg() can read/write, but not the size of iov.

[8/7/95 public]
It seems to me there are only to important points of interest here.

1) There is a shortcomming in the 103a RPC reference implementation in
   that it ignores max_path_tpdu when determining the packet
   size for future transmissions.  I intend to generate a
   defect against our 103a based IBM product so we can send
   a patch to the field.  I suggust that OSF generate a patch
   as well.  I should also point out this is not a kernel only
   issue.  Even though it may be advisory, its probably worth using
   in the evaluation.  I noticed that this seems to be the case
   in the RPC 1.1 implementation where max_path_tpdu (renamed to max_frag_size)
   is considered now. The logic I am referring to
   is in do_fack_body() in both the 103 and 1.1 implementations.

2) It seems wrong that the 1.1 RPC code is sending 49000 for max_tsdu.
   It is not clear whether this is specific to Transarc's Solaris kernel 
   port of the RPC or if this is in common code.  Transarc, can
   you investigate this and find out.  Clearly this is the
   real bug in this defect since the receiver (fack xmitter) cannot
   handle a packet bigger than 8000 bytes, but is advertising otherwise.
   A quick look at our AIX and OS/2 ports leads me to believe this may
   be platform specific.  AIX and OS/2 will not advertise values for
   either max_tsdu or max_path_tpdu (max_frag_size) that are larger
   than the largest dg rpc packet that can be received.

[8/9/95 public]

I agree with the above point 1). Ignoring a fack body's max_path_tpdu is a
bug in the dce1.0.3 (and before) reference implementation, which shows up
when a receiver advertises max_path_tpdu != 1464 and a sender is capable of
handling large (variable sized) fragments.

I do not agree with the point 2) because it is suggesting to redefine
max_tsdu as max_frag_size. If they are same, why should we have two
numbers? Here is how a fack body's max_tsdu is defined, with hope that this
may be of some use in the future optimization (but, not useful for now,
just like max_path_tpdu was useless in the dce1.0.3 reference
implementation).

max_tsdu (TSDU: Transport Service Data Unit?) is the size of the largest
message which the local transport service can pass. Logically, it's the
largest size of a UDP/IP packet body for ncadg_ip_udp. Thus, the definition
of RPC_C_IP_UDP_MAX_TSDU in ipnaf.h. (It doesn't matter you are using BSD
socket, Streams, Winsock, etc.)

Unfortunately, the local transport service API (send/recvmsg() or
sosend/receive() in the case of the BSD socket) imposes an additinal limit.
For instance, on HP-UX the maximum message size for a UDP datagram socket
is 58254 bytes. (The default is 9216 bytes.) Thus, we define
RPC_C_SOCKET_MAX_RCV/SNDBUF and RPC_C_SOCKET_GUESSED_RCV/SNDBUF
appropriately in HP800/sysconf.h, effectively overriding ones defined in
comsoc_bsd.c. (In reality, HP-UX can't send/recv 58254 bytes UDP messages,
so we set MAX_RCV/SNDBUF to 56KB. ;)

A smaller of these two numbers is what we can send/receive over the local
transport service and sent in the fack body's max_tsdu. (It's 56KB on HP-UX
and we almost always advertise max_tsdu 56KB in a server's fack body
regardless of a fragment size. If Transarc's kernel transport service API
(t_ksnd/rcv()?) can't pass larger than 8192 bytes messages, then
rpc__socket_set_bufs() should limit that, just like comsoc_bsd.c. The
dce1.x.x reference platforms likely advertise 32KB.)

(Confusing, who designed it? :-)

[8/30/95 public]

dce1.0.3 licensees should fix do_fack_body() line#1874 in dglsn.c,

    our_min = MIN(call->xq.max_tsdu, call->xq.max_path_tpdu);

    call->xq.max_pkt_size = MIN(our_min, max_tsdu);

to
    our_min = MIN(call->xq.max_tsdu, call->xq.max_path_tpdu);
    our_min = MIN(our_min, max_path_tpdu);
    call->xq.max_pkt_size = MIN(our_min, max_tsdu);

Especially, those vendors who change the max_tsdu and the fragment size
(unless they have some fallback logic) must pick this fix.

dce1.1 licensees should fix rpc__dg_call_xmit_fack() line#220 in dgcall.c,

    body.max_tsdu       = xq->max_rcv_tsdu;

to

    body.max_tsdu       = MIN(xq->max_rcv_tsdu, xq->max_frag_size);

This allows dce1.1 interoperate with dce1.0.3 large fragment without the
above fix. Since the current reference implementation can not manage these
two sizes, there is no benefit of advertising different values. Also, this
will avoid the future incompatibility problem when the implementation might
support two different values. (I can think of one use of these two values
which is optimizing a receiver's memory usage. KRPC and/or small machines
could benefit from that.)

[12/15/95 public]
Fixed in DCE 1.2.1
Closed



CR Number                     : 13023
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12904
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : context
Short Description             : no context rundowns for multi-threaded clients
Reported Date                 : 8/5/95
Found in Baseline             : 1.1
Found Date                    : 8/5/95
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : rpc
Sensitivity                   : public

[8/5/95 public]

The following is from a message Neil Winton sent on the SIG-DCE
mailing list.  Sev and Prio just picked out of a hat.

If a multi-threaded client (with threads sharing the same context handle)
dies then no rundown occurs at all.

Looking at the PD DCE source (the source is the ULTIMATE reference --
thanks OSF, DEC and HP :-) there appears to be a deadlock in the
rpc_ss_rundown_client routine (in src/rpc/idl/lib/ctxeecli.c) which is
excerpted below.

When the routine is entered the rpc_ss_context_table_mutex is locked.
Before rundown is performed there is a check to see whether the
reference count on the handle is zero indicating that no other manager
routines are using it (at least I believe that's what is happening).
The routine waits on a condition variable for this value to become
zero. Unfortunately the wait is done as

            while (this_client->ref_count != 0)
            {
                this_client->rundown_pending = idl_true;
                RPC_SS_THREADS_CONDITION_WAIT(&this_client->cond_var,
                                              &rpc_ss_context_table_mutex);
                                        /* Mutex has been released */
                RPC_SS_THREADS_MUTEX_LOCK(&rpc_ss_context_table_mutex);
            }

Despite the fact that the comment says "Mutex has been release" on
exit from a condition wait the mutex will be *locked* (unless
RPC_SS_THREADS_CONDITION_WAIT somehow behaves differently from
pthread_cond_wait). The thread then tries to re-lock the mutex and
deadlocks itself. Not only that, but any other threads entering this
routine will also be deadlocked waiting for the mutex as well! Of
course, in the case where there is only a single thread using the
context the ref_count will be zero and the deadlock will never occur.

[8/7/95 public]

There are two bugs here.

The OT CR#10110 fix in dce1.1 is incomplete. It does not address the case
where multiple CN associations are in use when a client dies. Whether or
not concurrent calls are using the context handle doesn't matter. In this
case, rpc_ss_rundown_client() never get called and the mutex locking bug is
irrelevant.

The mutex locking bug can cause a deadlock with a DG context handle. Sigh.

[8/16/95 public]

Here is a fix. (A typo is fixed too.)

--- cnsasgsm.c@@/main/LATEST    Mon Aug  8 14:18:16 1994
+++ Standard Input      Wed Aug 16 13:46:15 1995
@@ -588,7 +588,7 @@
         {\
             status = 1;\
        }\
-               if (status == 1)\
+       else\
        {\
                status = 2;\
        }\
@@ -843,7 +843,7 @@
      * association count in the group and remove the association from
      * the group's association list.
      */
-    if ( sm_p->cur_state != RPC_C_SERVER_ASSOC_GRP_CALL_WAIT)
+    if (assoc_grp->grp_callcnt == 0)
         RPC_CN_LOCAL_ID_CLEAR (assoc->assoc_grp_id);
     
     /*

[12/20/95 public]
Fixed in DCE 1.2.1
Closed



CR Number                     : 12899
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : maybe RPC in DG causes assert with security
Reported Date                 : 6/1/95
Found in Baseline             : 1.1b18
Found Date                    : 11/10/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 1.2.1
Affected File(s)              : rpc/runtime/dgexec.c
Sensitivity                   : public

[6/2/95 public]

We are having a problem with release 1.1 with Maybe rpc's and
security. We are hitting the assert in
        rpc/runtime/dgexec.c:rpc__dg_execute_call():

        assert(force_way_auth == false);

This is occuring for a maybe RPC. The scte points to a key_info. The
maybe RPC is getting a new scall which gets the associated ccall's
key_info initialized from the scte in rpc__dg_scall_alloc. In other
words, the activity has a key_info. The rpc__dg_execute_call
routine calls  rpc__dg_call_receive_int() which is returning
rpc_s_dg_need_way_auth. The reason this is returned is because
key_info is set in the ccall and rpc__krb_dg_recv_ck() is called by
rpc__dg_call_receive_int. The recv_ck routine returns this error code
because rpc__krb_set_key() is returning rpc_s_key_id_not_found.
The key sequence number is 2 and there is one in the key_info which is 1.

The code in rpc__dg_execute_call is then setting force_way_auth to
true. There is no way for a maybe RPC to change it back to false.

I have read through a bunch of documentation including the AES and
other RPC docs and can't find a specification for maybe RPCs and
security.

Should the code in rpc__dg_execute_call() do the callback for
a maybe RPC? What is the specification of a maybe RPC relative to
security? Can a maybe RPC be encrypted, have checksums, ...? What if
the encryption/checksum/... fails, should the maybe not be executed?

The question then is:

        1.) Should we change rpc__dg_execute_call to do the call to
rpc__dg_sct_way_validate() for a maybe? I think the answer is no.
        2.) Should we change the code to clear force_way_auth for a
maybe RPC?

        3.) Should we just remove the assert and then drop the maybe
RPC if force_way_auth is set?


I have duplicated this problem with a test program that does the following:

client:
        sec_login* calls to set-up a login context (with 5 minutes expiration
                time in the registry)
        call some maybe and regular rpcs.
        sleep for about 5 minutes

        call some more maybe/regular rpcs.
        if a maybe rpc (in a TRY/CATCH) gets an exception, use the sec_login*
        calls to refresh the context and redo the maybe rpc.


server:
        handle the client rpcs.


In the client, I am calling set_auth_info with rpc_c_protect_level_pkt_privacy.

After the 5 minutes expires and we refresh the context and issue another maybe
rpc from the client. The server falls
over with: Assertion failed: force_way_auth == false in dgexec.c.


mostek@transarc.com
412-338-6773

[12/15/95 public]
Fixed in DCE 1.2.1
Closed



CR Number                     : 12897
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : dg
Short Description             : DG rpc xmit code loops if snd_frag_size shrinks
Reported Date                 : 6/1/95
Found in Baseline             : 1.1
Found Date                    : 5/12/95
Severity                      : A
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.2
Fixed In Baseline             : 1.2.1
Affected File(s)              : rpc/runtime/dglsn.c
					     rpc/runtime/dgccall.c
					     rpc/runtime/dgscall.c
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : 

[6/1/95 public]
Transarc Status         : fixed
Transarc Deltas         : nydick-15219-rpc-transmit-oversize-partial-frag-if-fragsize-shrunk, nydick-15343-rpc-remove-snd_frag_size-assert
Here are the diffs:
===================================================================
RCS file: rpc/runtime/RCS/dg.c,v
retrieving revision 12.4
retrieving revision 12.5
diff -cibwt -r12.4 -r12.5
*** 12.4        1994/12/20 15:14:07
--- 12.5        1995/05/15 20:27:06
***************
*** 2,7 ****
--- 2,13 ----
   * @TRANSARC_COPYRIGHT@
   *
   * $TALog: dg.c,v $
+  * Revision 12.5  1995/05/15  20:27:06  nydick
+  * rpc__dg_call_xmit_int would go into an infinite loop when the saved
+  * partial fragment ended up larger than the server's advertised maximum
+  * fragment size.
+  * [from r12.4 by delta nydick-15219-rpc-transmit-oversize-partial-frag-if-fragsize-shrunk, r1.1]
+  *
   * Revision 12.4  1994/12/20  15:14:07  aswini
   * [merge of changes from 12.1 to 12.3 into 12.2]
   *
***************
*** 16,22 ****
   */
  
  #if !defined(_NOIDENT) && !defined(lint)
! static char *TARCSId = "$Id: c012897,v 1.11 95/12/19 15:28:30 root Exp $";
  #endif
  
  /*
--- 22,28 ----
   */
  
  #if !defined(_NOIDENT) && !defined(lint)
! static char *TARCSId = "$Id: c012897,v 1.11 95/12/19 15:28:30 root Exp $";
  #endif
  
  /*
***************
*** 530,537 ****
--- 536,563 ----
           * Copy as much data into the partial packet as will fit.
           */
  
+         if ((body_size < xqe->body_len) ||
+             (xq->snd_frag_size < frag_length)) {
+             /*
+              * We assume the (xq->snd_frag_size < frag_len) case occurs when
+              * we receieve a FACK which lowers the snd_frag_size, and we
+              * already have more than the new snd_frag_size's worth of data
+              * in part_xqe.  Our solution is to send the one over-large
+              * fragment and obey the new fragment size for future fragments.
+              * The (body_size < xqe->body_len) case has never been observed,
+              * but is here for completeness.
+              */
+             room_left = 0;
+             RPC_DBG_PRINTF(rpc_e_dbg_general, 1, 
+                            ("(rpc__dg_call_xmit_int) sending overlarge "
+                             "fragment: body_size=%d xqe->body_len=%d "
+                             "xq->snd_frag_size=%d frag_length=%d\n",
+                             body_size, xqe->body_len,
+                             xq->snd_frag_size, frag_length));
+         } else {
              room_left = MIN(body_size - xqe->body_len,
                          xq->snd_frag_size - frag_length);
+         }
  
          if (elt_num < data->num_elt) {
              rpc_iovector_elt_t *iove = &data->elt[elt_num];
***************
*** 603,609 ****
           * Add newly-filled pkt to xmit queue.
           */
  
!         if (frag_length == xq->snd_frag_size)
          {
              rpc__dg_xmitq_append_pp(call, st);
              if (*st != rpc_s_ok)
--- 629,635 ----
           * Add newly-filled pkt to xmit queue.
           */
  
!         if (frag_length >= xq->snd_frag_size)
          {
              rpc__dg_xmitq_append_pp(call, st);
              if (*st != rpc_s_ok)
===================================================================
RCS file: rpc/runtime/RCS/dgxq.c,v
retrieving revision 12.2
retrieving revision 12.3
diff -cibwt -r12.2 -r12.3
*** 12.2        1994/12/05 18:40:12
--- 12.3        1995/05/24 13:58:57
***************
*** 2,7 ****
--- 2,16 ----
   * @TRANSARC_COPYRIGHT@
   *
   * $TALog: dgxq.c,v $
+  * Revision 12.3  1995/05/24  13:58:57  nydick
+  * The code was asserting that no fragment on the transmit queue was
+  * larger than the snd_frag_size.  This breaks, because a FACK might
+  * arrive which reduces snd_frag_size after a fragment is already on the
+  * xmit queue.
+  *
+  * Removed an assert.
+  * [from r12.2 by delta nydick-15343-rpc-remove-snd_frag_size-assert, r1.1]
+  *
   * Revision 12.2  1994/12/05  18:40:12  aswini
   * [merge of changes from 11.1 to 11.2 into 12.1]
   *
***************
*** 11,17 ****
   */
  
  #if !defined(_NOIDENT) && !defined(lint)
! static char *TARCSId = "$Id: c012897,v 1.11 95/12/19 15:28:30 root Exp $";
  #endif
  
  /*
--- 20,26 ----
   */
  
  #if !defined(_NOIDENT) && !defined(lint)
! static char *TARCSId = "$Id: c012897,v 1.11 95/12/19 15:28:30 root Exp $";
  #endif
  
  /*
***************
*** 844,851 ****
                         / blocksize) * blocksize;
          last_xqe->body_len += (frag_length - xqe->frag_len);
          xqe->frag_len = frag_length;
- 
-         assert(RPC_C_DG_RAW_PKT_HDR_SIZE + frag_length + auth_epv->overhead <= xq->snd_frag_size);
  
          if (last_xqe->body_len + auth_epv->overhead
              > RPC_C_DG_MAX_PKT_BODY_SIZE)
--- 853,858 ----

[6/1/95 public]
So, who is shrinking the snd_frag_size?
A sender starts with 1KB (for the historical reason) and increases it based
on a fack it receives. One change done in dce1.1 is keeping the
snd_frag_size across the calls over the same connection, instead of
starting over with a smaller fragment size for each call (performance
enhancement). I believe that we updated AES (really X/Open's DC spec.) to
clarify this.
Anyway, you should force the call to fail when the snd_frag_size gets
shrunk, instead of sending over-sized fragments. (It's not just one
over-sized fragment. There can be more depending on when a fack arrives.)
With your fix, a receiver truncates PDUs (if its buffer is really smaller)
and simply drops them, and the sender has to wait for the timeout.
For the various reasons, the fragment size can't be shrunk without
rebumping the DG protocol version.

[6/7/95 public]
Yikes, I've found one case where a server sends a smaller max_frag_size for
already negotiated connections. That is when a call is queued and/or a
packet reservation fails in rpc__dg_do_request(). I must say that it is a
rare condition which happens only if MBF is turned on in KRPC (it is turned
off on the reference platforms) or RPC_C_DG_PKT_MAX is set to low in the
user-space (it's virtually unlimited on the reference platforms). Note: We
don't expect the packet rationing in the user-space and even considered
taking it out from the user-space code for the performance improvement.
Here is the fix:
--- /afs/ch/project/dce/build/dce1.1/src/rpc/runtime/dglsn.c	Thu Aug 25 17:54:14 1994
+++ /tmp/dglsn.c	Wed Jun  7 09:42:00 1995
@@ -2412,7 +2412,45 @@
         do_selective_ack( rqe, call, window_incr, rexmit_cnt, curr_serial);
     }
 
+#ifndef	HPDCE_FIX_OT12897
     /*
+     * Before updating our snd_frag_size, make sure the fack sender
+     * is not trying to shrink the snd_frag_size.
+     */
+    if (call->xq.snd_frag_size > snd_frag_size)
+    {
+	if (RPC_DG_CALL_IS_CLIENT(call)
+	    && call->xq.window_size == 0
+	    && call->xq.head != NULL
+	    && call->xq.head->fragnum == 0)
+	{
+	    /*
+	     * If the client's first fragment (un-acked head of xq)
+	     * is dropped by the server because of queued call or
+	     * unreserved packet (window_size == 0), keep using the
+	     * current snd_frag_size.
+	     *
+	     * Note: The above condition is also met when the
+	     * server's rq is full and the fragment number wraps.
+	     * However, the server eventually opens up its window
+	     * (window_size != 0) and if it still insists on
+	     * shrinking the snd_frag_size, we will catch it.
+	     */
+	    RPC_DBG_PRINTF(rpc_e_dbg_recv, 6, (
+		"(do_fack_body) server dropped frag %lu and shrunk snd_frag_size\n",
+		rqe->hdrp->fragnum));
+	}
+	else
+	{
+	    RPC_DBG_GPRINTF(("Send frag size shrunk [%s]\n",
+			     rpc__dg_act_seq_string(rqe->hdrp)));
+	    rpc__dg_call_signal_failure(call, rpc_s_protocol_error);
+	}
+    }
+    else
+    {
+#endif	/* HPDCE_FIX_OT12897 */
+    /*
      * Before updating our snd_frag_size, make sure that we have enough
      * packets reserved.
      */
@@ -2443,6 +2481,9 @@
          * Else keep using the current snd_frag_size.
          */
     }
+#ifndef	HPDCE_FIX_OT12897
+    }
+#endif	/* HPDCE_FIX_OT12897 */
 
     RPC_DBG_PRINTF(rpc_e_dbg_recv, 6, (
         "(do_fack_body) <-- our snd_tsdu %lu, max fs %lu, snd fs %lu\n",

[7/12/95 public]
I hadn't converted my krpch kernel extension to the one running the fix
provided by tatsu_s and was running our own fix.  However, under heavy load
I was seeing unexpected pipe exceptions.  When I converted to using the
tatsu_s fix these problems disappeared.
This suggests that the problem of sending frag_size reductions is a real
one.  As I understand the fix we are now just rejecting such FACKs and the
code that decides to send such a FACK has not been "fixed" to stop doing
so.  Perhaps that should be looked into.
Also what is the 1.0.3/1.1 interoperability story?  I gather that the
frag_size management was one of the things that changed in 1.1.  Will 103
machines send frag_size reductions?  Will they handle such reductions
safely if a 1.1 machine sends them?

[7/12/95 public]
Your fix doesn't adjust an over-sized fragment size to an integral multiple
of 8 bytes. I guess, that's probably the reason why you got the unexpected
pipe exceptions.
Disclaimer: I only speak for the OSF DCE reference implementation. (or the
vendor products which have not changed the protocol logic. :-)
The pre-1.1 DG runtime used the fragment size, i.e., xq->max_path_tpdu,
1024 (rpc_c_dg_initial_max_pkt_size, for NCS 1.5 compatibility) or 1464
(rpc_c_ip_udp_max_pth_unfrg_tpdu) bytes. A receiver always advertised the
fragment size 1464 because it knew the sender's address when sedning a
fack. The receiver's fragment size never shrunk or re-adjusted. As a
sender, it always started with 1024, i.e., xq->max_pkt_size, and increased
to 1464 when the receiver told so. The sender's fragment size never shrunk,
but could be increased. The fack receiver never used the max_path_tpdu
field in the fack body to adjuest the fragment size. (Note: The
max_path_tpdu field is renamed to max_frag_size in 1.1.) Basically, there
was no fragment size negotiation implemented in the pre-1.1 DG runtime.
This is good because we can't fix receivers out there. Some DCE vendors may
have changed 1464 to something bigger, e.g., IBM DCE on AIX (at least in
user-space, 2 years ago when I tried it), but unless the logic got changed
too, they shouldn't shrink.
With the 1.1 DG runtime, a receiver advertizes a fragment size based on the
sender's address and/or the packet reservation. The fragment size gets
shrunk (to 1464) only if reusing the existing connection (which advertized
a bigger size in the previous use) and the packet reservation fails in the
server. However, when the packet reservation fails the server stops the
client by closing the window as commented in the above diff. If a pre-1.1
client receives such a fack, what happens? It doesn't care because it
ignores the field in the fack (and it doesn't use larger than 1464,
anyway). What if an IBM DCE client receives such a fack? I don't know. (I
even don't know how they negotiated the fragment size.)

[8/8/95 public]
I have trouble following the above logic and looking at the 1.1
reference implementation code doesn't help matters.
However, it appears that the wire protocol allows for the fragment size
to change both up and down.  Even though the reference implementation
may not use this capability, other vendors have and the reference
implementation must correctly handle these facks to inter-operate
correctly.
It may be *LEGAL* to reject or ignore requests by the receiver to change
the frag size.  However, since the receive is probably reducing the frag
size under duress, it would seems like an extremely good idea to help
him out by sending smaller fragments.
Given this argument I think fixing the 1.1 code to handle reductions in
the fragment size would be preferable to approach taken by the above
diffs.  I plan to make the Solaris product handle frag size reductions
and I understand that the IBM product also does this.
The problem we were having when we tried to do this before was that we
would get pipe exceptions at the receiver.  We eventually tracked this
down to a bug in dg.c:rpc__dg_call_transmit_int.  Here is the scenario:
 1. A call to xmit_int would finish leaving, an odd number of 4-byte
    words in the call's xq.
 2. A fack would arrive reducing the send_frag_size below the number of
    bytes already queued.
 3. The next call to xmit_int would find the packet already too large
    and call rpc__dg_xmitq_append_pp to send it.
 4. The lower levels would pad out to a multiple of 8 bytes before
    appending the auth_trailer.
 5. The receiver would find an extra word in the data stream (since in
    can't distinguish padding from data) and interpret it as the Z-value
    for the next array.
The fix that IBM adopted (apparently in the 1.0.3 time frame) was to
remember the snd_frag_size at the time the xqe is allocated.  The even
cheaper fix I made was to keep a local copy of the snd_frag_size within
the body of xmit_int and if frag_length is greater than snd_frag_size
round the local copy up to the next multiple of 8.
I can send the diffs if there is any interest.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `'

[8/8/95 public]

(Please don't reformat an entire message.)

I don't understand how you can possibly shrink the fragment size in the
middle of a call.

When a sender (client) receives a fack, it means that it has sent at least
one fragment which size is the current snd_frag_size. Assuming that the
current snd_frag_size is 4KB, there is at least one unacknowledged fragment
on xq (xq->head) which size is 4KB. Now, the fack tells that a receiver can
accept upto 2KB fragment size.  (snd_frag_size shrinks. Did the fack ack'ed
4KB fragment? or dropped?)  With your (and IBM?) fix, transmit_int() starts
fragmenting new fragments with 2KB, but what happens with already queued
unacknowledged 4KB fragments (there can be multiple of them) on xq?  The DG
runtime still re-transmits those 4KB fragments.

Here is one scenario:

  Send		frag0 4KB
  Send		frag1 4KB
  Recv		fack ack -1 ws 24 max_frag_size 2KB
  Resend	frag0 4KB
  Resend	frag1 4KB
  Send		frag2 2KB

Another scenario (worse because there is a hole):

  Send		frag0 4KB
  Send		frag1 4KB
  Recv		fack ack -1 ws 24 max_frag_size 2KB selack 1
  Resend	frag0 4KB
  Send		frag2 2KB

If you really like to shrink the fragment size in the middle of the call,
you must re-fragment already queued fragments. And if it's an authenticated
rpc, you have to go through (*auth_epv->encrypt/pre_send)() again. (You
need to decrypt it before re-encrypting.) In the above second scenario, you
can't re-fragment frag0 because frag1 is already ack'ed.

With the current wire protocol, the receiver is not given enough
information about when it's safe to reduce the fragment size. (It has no
idea how many fragments are already queued in the sender's xq.) The sender
can't re-fragment already sent/unack'ed fragments. (Unlike IP fragment
where a byte-offset is used, our fragment number is monotonic.) We thought
about it while doing dce1.1 work, but concluded that without rebumping the
major DG protocol version we can't do this.

To make your schema work, the receiver has to continue receiveing large
fragments even after it advertises a smaller fragment size (if it drops or
truncates frag0, a user data stream is not intact). How long? Then, why
should it try it in the first place?

(Isn't an unreliable datagram wonderful? There is no guarantee that facks
arrive in-order, e.g., fack w\ 2KB fs, fack w\ 4KB fs, fack w\ 2KB fs...
:-)

Am I missing something here? Is there any guarantee that there won't be any
unack'ed fragments when the fragment size shrinks?

[8/9/95 public]

I forgot to add one more point. I stated in the previous comment [tatsu_s
6/1/95 public] that

  One change done in dce1.1 is keeping the snd_frag_size across the calls
  over the same connection, instead of starting over with a smaller fragment
  size for each call (performance enhancement).

If a server resets a fragment size between calls (starts over with a small
fragment), then the snd_frag_size gets shrunk in the middle of a call
because a client already sent a large fragment (which size was negotiated
in a previous call). The dce1.1 reference implementation does not reset it.
But, how about others? Does IBM 1.0.3 product's server (capable of large
fragment) reset it? If so, we have a problem. Here is the code to reset the
snd_frag_size at the beginning of each calls (with slightly loss of
performance for back-to-back small in/out calls).

Change ccall_common_init() in dgccall.c, line# 476:

    else
    {
        ccall->c.high_seq = ccall->c.call_seq = ccall->ccte_ref.ccte->seq++;

        if ((options & rpc_c_call_brdcst) != 0)
        {
		:
		:
        }
    }

to

    else
    {
        ccall->c.high_seq = ccall->c.call_seq = ccall->ccte_ref.ccte->seq++;

        /*
         * Reset high_rcv_frag_size and snd_frag_size since we start from
         * the minimum fragment size.
         */
        ccall->c.rq.high_rcv_frag_size = RPC_C_DG_INITIAL_MAX_PKT_SIZE;
        ccall->c.xq.snd_frag_size = MIN(RPC_C_DG_MUST_RECV_FRAG_SIZE,
                                        ccall->c.xq.snd_frag_size);
    }

Change rpc__dg_scall_reinit() in dgscall.c, line# 866:

    }

    RPC_DBG_PRINTF(rpc_e_dbg_xmit, 6,

to

    }
    else
    {
        /*
         * Reset high_rcv_frag_size and snd_frag_size since we start from
         * the minimum fragment size.
         * 
         * Note: snd_frag_size could *already* be set larger because of the
         * previous use of this scall.
         */
        scall->c.rq.high_rcv_frag_size = RPC_C_DG_INITIAL_MAX_PKT_SIZE;
        scall->c.xq.snd_frag_size = MIN(RPC_C_DG_MUST_RECV_FRAG_SIZE,
                                        scall->c.xq.snd_frag_size);
    }

    RPC_DBG_PRINTF(rpc_e_dbg_xmit, 6,

Note: This change shrinks the fragment size between calls, not in the
middle of the call (which can't be done).

[8/16/95 public]

The important note about my last comment, resetting the fragment size
between calls. This change introduces the interoperability problem between
the current OSF dce 1.1 rpc runtime (including PD DCE RPC) and the runtime
having applied the above change. I have checked X/Open DCE RPC Spec.
whether or not we stated not-resetting the fragment size between calls, and
have found that we didn't. So, resetting the fragment size between calls is
legal and all OSF licensees should apply the above change. (Sigh.)

[12/19/95 public]
Fixed in DCE 1.2.1
Closed



CR Number                     : 12885
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 12931
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : Auth RPC causing server crash
Reported Date                 : 5/23/95
Found in Baseline             : 1.0.3
Found Date                    : 5/23/95
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1, 1.1maint
Affected File(s)              : rpc
Sensitivity                   : public

[5/23/95 public]
The following problems occur when making a CN authenticated RPC call using the
following IDL specification:

[,version(1)]
interface _sfsWireProc
{

const long WIRE_MAX_RECORD_BUFFER_SIZE = 1024;

/*
 * wire_record_t -- record buffer description
 */
typedef struct {
    [ptr,length_is(dataLength),
     size_is(bufferLength)] /* wire_pointer_t */ byte * buffer; /* XXX */
    unsigned long           bufferLength;
    unsigned long           dataLength;
} wire_record_t;

typedef struct {
    unsigned long numWrites ;
    [ptr , size_is (numWrites ) ] wire_record_t *writeRecordArrayP ;
} wire_batchInRequest_t ;

unsigned32 _svr_NTBatch(
    [in] handle_t h,
    [ptr,in] wire_batchInRequest_t *batchInP
);
}

1) with protect level = connect (ie 2), the server manager routine gets
invoked, but the data is not all transmitted.  When the server manager
routine returns, it SIGIOT's with an illegal state transition in the SERVER
CALL state machine.

2) with protect level = integrity (ie 5), the server SIGSEGV's in a memcpy
routine before invoking the server manager routine.

Here is what I have determined so far:

This is only a CN related problem.  Using DG, you can specify any protect
level, and any size of data, and everything works correctly.

The failure is related to the size of the data transmitted.  When you specify
an array of length 1->7 (see testcase client code below), everything works, no
matter what protection level you specify.  When you specify an array that is
greater than 7, the testcase will fail.

The testcase fails at different points, depending on the protect level used.
I think this is just because of different code paths taken in the server,
based on the protect level.

In the case where protect level = 5, I have discovered the following things:

The server SIGSEGVs in a memcpy, while unmarshalling the input argument,
when it tries to use a range_list to access the data in a varying array.
The range_list.upper value is garbage.  However,
if you look at the range_list's when they are built on the client side
(in the routine src/rpc/idl/lib/interpsh.c:rpc_ss_build_range_list(),
you'll see that the correct values are being used.  So somewhere after the
range_list is being built, the data is getting corrupted.

Probably other data is corrupted also, its just
that the range_list is the first thing that gets used, so it appthat the range_list is the first thing that gets used, so it appears as the
first indicator that things are wrong.

My suspicion is that the problem is in the client, somewhere around the
point where the buffer is actually transmitted.  There is a routine
rpc__cn_transmit_buffers() that has a code block that checks if authentication
is in use.  If it is, then the auth_trailer is added after the last iovector
element.  It could be that things get stomped on here.  What I don't
understand is that the problem happens with protect_level = connect, and in
that case, there is only authentication being applied to the bind, and not to
the subsequent packet transmissions of the RPC data, right?

What follows is the client/server testcase that demonstrates the problem
consistently.  Transarc has indicated that this testcase fails on Solaris
also, so it is not just an AIX related problem.

-----------Makefile------------

IDL = idl
IDL_FLAGS = -keep c_source
RM = rm -f
CFLAGS = -g -I.

# AIX
CC = cc_r
SYS_LIBS = -ldce -lpthreads

# Solaris
#SYS_LIBS = -ldce -lm -lnsl -lthread -lsocket

all:    client server

CLIENT_OBJS = client.o _wire_proc_cstub.o

client: $(CLIENT_OBJS)
        $(CC) -o client $(CLIENT_OBJS) $(SYS_LIBS)

SERVER_OBJS = server.o _wire_proc_sstub.o

server: $(SERVER_OBJS)
        $(CC) -o server $(SERVER_OBJS) $(SYS_LIBS)

clean:
        -$(RM) $(CLIENT_OBJS) $(SERVER_OBJS)
        -$(RM) _wire_proc.h _wire_proc_cstub.c _wire_proc_sstub.c

clobber:        clean
        -$(RM) client server

_wire_proc.h _wire_proc_cstub.c _wire_proc_sstub.c: _wire_proc.idl
        $(IDL) $(IDL_FLAGS) _wire_proc.idl

client.o:       _wire_proc.h
server.o:       _wire_proc.h

-----------README------------

The server segfaults because the received batchInOutP->wirePosResP is
a null pointer.  Comparison of the parameters sent by the client and
received by the server indicates that DCE is not transmitting
the parameters properly.

How to reproduce the problem after building the client and server:

1.  Create a server principal and put it in a keyfile; e.g.,
    % rgy_edit -update
    rgy_edit=> kta -p server-principal -f KeyFile

2.  Start the server specifying the server principal and keyfile; e.g.,
    % server server-principal KeyFile
    ncacn_ip_tcp:158.98.9.87[52235]
    ncadg_ip_udp:158.98.9.87[42741]
    listening...

3.  Choose one of the stream (ncacn_unix_stream or ncacn_ip_tcp)
    endpoints displayed by the server.  Invoke the client with the
    stream endpoint and a protection level of 2 or greater, and an
    indication of how many array elements you want transmitted; e.g.,

    % client 'ncacn_ip_tcp:158.98.9.87[52235]' 5 8

    This would specify a protect level of 5, and 8 array elements.

Note that the problem does not occur with datagram endpoints
(ncadg_ip_udp), or if the protection level is 1.

I've reproduced the problem on both Solaris 2.3 and AIX 3.2.5
with DCE 1.0.3.

-----------_wire_proc.idl------------

[,version(1)]
interface _sfsWireProc
{

const long WIRE_MAX_RECORD_BUFFER_SIZE = 1024;

/*
 * wire_record_t -- record buffer description
 */
typedef struct {
    [ptr,length_is(dataLength),
     size_is(bufferLength)] /* wire_pointer_t */ byte * buffer; /* XXX */
    unsigned long           bufferLength;
    unsigned long           dataLength;
} wire_record_t;

typedef struct {
    unsigned long numWrites ;
    [ptr , size_is (numWrites ) ] wire_record_t *writeRecordArrayP ;
} wire_batchInRequest_t ;

unsigned32 _svr_NTBatch(
    [in] handle_t h,
    [ptr,in] wire_batchInRequest_t *batchInP
);
}

-----------client.c------------

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <dce/exc_handling.h>
#include <dce/rpc.h>
#include "_wire_proc.h"

#define CKERR(why) if (st != error_status_ok) {\
        fprintf(stderr,"%s, err=%d\n",why,st); exit(1);}
#define UTIL_ALLOC(ptr, cast, size)                                     \
do {                                                                    \
   if (!((ptr) = (cast) malloc(size)) && (size)) {                      \
       fprintf(stderr, "malloc(%d) failed at line %d\n", (size), __LINE__);\
       exit(2);                                                         \
   }                                                                    \
   memset((ptr), 0, (size)); /* to make comparison easier */            \
} while (0)

/*
 * canonical usage message
 */
void usage(void)
{
    fprintf(stderr,"usage: client <string_binding> [<protectLevel>]\n");
    exit(1);
}

/*
 * get an RPC handle.
 */
handle_t get_handle(const char *name, unsigned32 protectLevel)
{
    handle_t hndl;
    error_status_t st;
    unsigned char *serverPrincipal;

    rpc_binding_from_string_binding((idl_char *)name, &hndl, &st);
    CKERR("rpc_binding_from_string_binding");

    if (protectLevel != rpc_c_protect_level_none) {
        rpc_mgmt_inq_server_princ_name(hndl, rpc_c_authn_default,
                                       &serverPrincipal, &st);

        CKERR("rpc_mgmt_inq_server_princ_name");

        rpc_binding_set_auth_info(hndl, serverPrincipal,
                                  protectLevel, rpc_c_authn_default,
                                  NULL, rpc_c_authz_dce, &st);
        CKERR("rpc_binding_set_auth_info");
    }

    return (hndl);
}

/*
 * make a call on the passed handle
 */
doit(handle_t h)
{
    static unsigned char bigbuf[15][32769];
    wire_batchInRequest_t batchIn;
    unsigned32 st;
    int i;

#define REC312LEN       283

    /* Zero the parameter */
    memset(&batchIn, 0, sizeof(batchIn));

    batchIn.numWrites = 15;
    UTIL_ALLOC(batchIn.writeRecordArrayP,
               wire_record_t *,
               (batchIn.numWrites * sizeof(wire_record_t)));

    for (i=0; i<batchIn.numWrites; i++)
    {
        batchIn.writeRecordArrayP[i].dataLength = REC312LEN;
        batchIn.writeRecordArrayP[i].bufferLength = REC312LEN;
        batchIn.writeRecordArrayP[i].buffer = bigbuf[i];
    }

    TRY
        st = (unsigned32) _svr_NTBatch(h, &batchIn);
        if (st)
        {
            fprintf(stderr,"_svr_NTBatch returns failure: %d\n",st);
        }
        else
        {
            fprintf(stderr,"_svr_NTBatch returns successfully\n");
        }
    CATCH_ALL
        fprintf(stderr, "_svr_NTBatch caught exception 0x%x\n", THIS_CATCH);
        exit(1);
    ENDTRY
}

main(int argc, char **argv)
{
    char *name = 0;
    handle_t h;
    unsigned32 protectLevel = rpc_c_protect_level_default;

    argc--; argv++;

    if (argc == 0) usage();
    name = *argv++;
    argc--;
    if (argc > 0) {
        protectLevel = atoi(*argv++);
        argc--;
    }
    if (argc > 0) usage;

    h = get_handle(name, protectLevel);

    doit(h);
    printf("call succeeded\n");

    exit(0);
}

-----------server.c------------

#define MAXCALLS 5
#define CKERR(why) if (st != error_status_ok) {\
        fprintf(stderr,"%s, err=%d\n",why,st); exit(1);}

#include <dce/pthread_exc.h>
#include <dce/rpc.h>
#include "_wire_proc.h"
#include <malloc.h>
#include <string.h>
#include <stdio.h>


/*
 * usage
 */
void usage(void)
{
    fprintf(stderr,"usage: server [principal keyfile]\n");
    exit(1);
}

/*
 * main line program
 */
main(int argc, char **argv)
{
    int i;
    error_status_t st;
    rpc_binding_vector_p_t bvec;
    unsigned_char_t *s;

    argc--; argv++;
    if (argc == 2) {
        rpc_server_register_auth_info((unsigned char *)argv[0],
                                       rpc_c_authn_dce_secret, NULL,
                                       (unsigned char *)argv[1], &st);
        CKERR("rpc_server_register_auth_info");
        argc -= 2;
    }
    if (argc>0) usage();

    rpc_server_use_all_protseqs(MAXCALLS,&st);
    CKERR("rpc_server_use_all_protseqs");

    rpc_server_register_if(_sfsWireProc_v1_0_s_ifspec, NULL, NULL, &st);
    CKERR("rpc_server_register_if");

    rpc_server_inq_bindings(&bvec, &st);
    CKERR("rpc_server_inq_bindings");

    for (i=0; i<bvec->count; i++) {
        rpc_binding_to_string_binding(bvec->binding_h[i],&s,&st);
        CKERR("rpc_binding_to_string_binding");
        printf("%s\n",s);
        rpc_string_free(&s,&st);
    }

    rpc_binding_vector_free(&bvec, &st);
    CKERR("rpc_binding_vector_free");

    TRY {
        printf("listening...\n"); fflush(stdout);
        rpc_server_listen(MAXCALLS, &st);
        CKERR("rpc_server_listen");
    } CATCH_ALL {
        fprintf(stderr,"Caught exception %x\n",THIS_CATCH);
        exit(1);
    } ENDTRY;

    exit(0);
}


/*
 * manager routines
 */

unsigned32 _svr_NTBatch(
    /* [in] */ handle_t h,
    /* [in] */ wire_batchInRequest_t *batchInP
                        )
{
    int i;
    char wBuf[WIRE_MAX_RECORD_BUFFER_SIZE/2];

    printf("_svr_NTBatch called\n");

    return 0;
}

[5/24/95]
Per Rich Salz's request, Grant Alvis provided the following explanation
as to why just using DG isn't okay.
.
These are production environments that are built on Encina and DCE.  It is
not acceptable to ask the customers to restrict their protocol support to
DG only.  IBM Encina Support has indicated that there are ~10 customers who
are experiencing this problem in their production environments.  We need
a timely resolution to this problem that is occurring over CN RPC.

[5/25/95 public]

Whoever working on this, please check the IDL library.

The sample program sends 4635 bytes of NDR encoded data:
  4+(4+4)+(4+15*(4+4+4))+14*(4+4+4+283+1)+(4+4+4+283)=4635

DG breaks it down to 6 fragments
  4+(4+4)+(4+15*(4+4+4))+2*(4+4+4+283+1)+(4+4+4+120)=920
  (163+1)+2*(4+4+4+283+1)+(4+4+4+152)=920
  (131+1)+2*(4+4+4+283+1)+(4+4+4+184)=920
  (99+1)+2*(4+4+4+283+1)+(4+4+4+216)=920
  (67+1)+2*(4+4+4+283+1)+(4+4+4+248)=920
  (35)+5=40 (5 bytes padding)

CN breaks it down to 3 fragments:
  4+(4+4)+(4+15*(4+4+4))+6*(4+4+4+283+1)+(4+4+4)=1984
  (283+1)+5*(4+4+4+283+1)+(4+4+4+283)=2059
  1+(4+4+4+283+1)+(4+4+4+283)=592

The protection level doesn't matter since the difference is only the auth
trailer length. With pkt_integrity, the entire fragments are:
  24+4+(4+4)+(4+15*(4+4+4))+6*(4+4+4+283+1)+(4+4+4)+(8+18)=2034
  24+(283+1)+5*(4+4+4+283+1)+(4+4+4+283)+(1+8+18)=2110
  24+1+(4+4+4+283+1)+(4+4+4+283)+(8+18)=642

(Note: The connect level has the auth trailer, too.)

As you can see, the third fragment is unaligned. This is caused by the
client stub sending 3*10 iovector elements (3 call_transmit() with 10
elements each):
  4+(4+4)+(4+15*(4+4+4))+(4+4+4)
  283
  1+(4+4+4) -|
  283       -|- repeat 14 times

The even number index elements have the rpc_c_iovector_elt_reused flag set:

  elt[0]: elt.flags->1 args.buff_len->2048 args.data_len->208
  elt[1]: elt.flags->0 args.buff_len->283 args.data_len->283
  elt[2]: elt.flags->1 args.buff_len->2048 args.data_len->13
  elt[3]: elt.flags->0 args.buff_len->283 args.data_len->283
  elt[4]: elt.flags->1 args.buff_len->2048 args.data_len->13
  elt[5]: elt.flags->0 args.buff_len->283 args.data_len->283
  elt[6]: elt.flags->1 args.buff_len->2048 args.data_len->13
  elt[7]: elt.flags->0 args.buff_len->283 args.data_len->283
  elt[8]: elt.flags->0 args.buff_len->2048 args.data_len->13
  elt[9]: elt.flags->0 args.buff_len->283 args.data_len->283
  elt[0]: elt.flags->1 args.buff_len->2048 args.data_len->13
  elt[1]: elt.flags->0 args.buff_len->283 args.data_len->283
  elt[2]: elt.flags->1 args.buff_len->2048 args.data_len->13
  elt[3]: elt.flags->0 args.buff_len->283 args.data_len->283
  elt[4]: elt.flags->1 args.buff_len->2048 args.data_len->13
  elt[5]: elt.flags->0 args.buff_len->283 args.data_len->283
  elt[6]: elt.flags->1 args.buff_len->2048 args.data_len->13
  elt[7]: elt.flags->0 args.buff_len->283 args.data_len->283
  elt[8]: elt.flags->1 args.buff_len->2048 args.data_len->13
  elt[9]: elt.flags->0 args.buff_len->283 args.data_len->283
  elt[0]: elt.flags->1 args.buff_len->2048 args.data_len->13
  elt[1]: elt.flags->0 args.buff_len->283 args.data_len->283
  elt[2]: elt.flags->1 args.buff_len->2048 args.data_len->13
  elt[3]: elt.flags->0 args.buff_len->283 args.data_len->283
  elt[4]: elt.flags->1 args.buff_len->2048 args.data_len->13
  elt[5]: elt.flags->0 args.buff_len->283 args.data_len->283
  elt[6]: elt.flags->1 args.buff_len->2048 args.data_len->13
  elt[7]: elt.flags->0 args.buff_len->283 args.data_len->283
  elt[8]: elt.flags->1 args.buff_len->2048 args.data_len->13
  elt[9]: elt.flags->0 args.buff_len->283 args.data_len->283

Why the IDL marshalling engine is producing the iovector element
with 283 bytes data, instead of 283+1 bytes?

Strangely enough, on HP-UX, the server sometimes sends back an
rpc_x_invalid_bound fault *before* receiveing the third fragment.

[5/26/95 public]

Oops, of course, an alignment padding is a part of the next data element.

NDR encoded data:
  4+(4+4)+(4+15*(4+4+4))+(4+4+4+283)+14*(1+4+4+4+283)=4635

CN fragments:
  4+(4+4)+(4+15*(4+4+4))+(4+4+4+283)+5*(1+4+4+4+283)+(1+4+4+4)=1984
  (283)+6*(1+4+4+4+283)=2059
  2*(1+4+4+4+283)=592

CN fragments (No auth):
  4+(4+4)+(4+15*(4+4+4))+(4+4+4+283)+6*(1+4+4+4+283)+(1+4+4+4)=2280
  (283)+6*(1+4+4+4+283)+(1+4+4+4)=2072
  (283)=283

With DG, the fragmented data size is always a multiple of 8 except for the
last fragment. I suppose that CN is not doing that (and probably this
problem can happen with an unauthenticated rpc, too).

[6/9/95]

We have repreduced a (not sure yet whether it's the problem) problem on
DEC Unix AXP.
We are seeing an rpc_s_connect_rejected, 0x16c9a042, error return from
rpc_mgmt_inq_server_princ_name(),  before rpc_binding_set_auth_info()
gets called.

[6/9/95]

This is not the focus of the problem.  The server princ name is just a piece
of the setup, before making the RPC call.

I have put some debug statements in the client, and printed out the correct
server principal name after the call to rpc_mgmt_inq_server_princ_name().
Everything works fine with my testcase here.

Could it have something to do with the testcase server's configuration?  You
have to create a keytab file for the server, and pass the server principal
name and keytab file as command line args when starting the server, ie:

server cell_admin /tmp/keytabfile

You must use rgy_edit to create the keytabfile, ie:

rgy_edit=> kta -p cell_admin -f /tmp/keytabfile 

Otherwise, the only time I get rpc_s_connect_rejected is when the string
binding is not that of the server process (ie the port number is incorrect,
or the ip address is incorrect).

[6/19/95]

We have recreated the problem and continue to try to isolate the cause.

[6/19/95 public]

Please add a tag marker when updating an OT.

As I commented earlier, it is caused by CN protocol violating the SPI rule,
i.e., returning an iovector_elt which data_len is not a multiple of 8
bytes. (Note: The last iovector_elt can be any length.)

[6/23/95 public]

Please look at OT 12931. It highlights similar problem.

[7/5/95 public]

I'm still working on this problem.  I've confirmed the problem, 
and that the server fails because of bad limits for the array
being read in.  I understand that it is an alignment problem,
although in the case of the array being 284 long, the test passes,
but total fragment lengths are still not 8-byte aligned.
I use 284 as an arbitrary divisible-by-4 number (that happens to
be next to 283).

I believe that are marshalling engine should ideally be lumping
the 283-byte long elements with their accompanying 13-byte long
elements for handoff to the transmit_req_action_rtn() routine.

This problem can be worked around by forcing a flag in the routine 
transmit_req_action_rtn().  I'm going to investigate the original
intent of some of the code that has been commented out (using
#if 0 conditionals).  For now, the code snippet below, found in
cncclsm.c:

------
                    if (iov_elt_p->flags & rpc_c_iovector_elt_reused)
                    {
                        rpc__cn_copy_buffer (call_rep, iov_elt_p, &status);
                        if (status != rpc_s_ok)
                        {
                            goto done;
                        }
                    }
------ can be changed to:

                    iov_elt_p->flags |= rpc_c_iovector_elt_reused;
                    if (iov_elt_p->flags & rpc_c_iovector_elt_reused)
                    {
                        rpc__cn_copy_buffer (call_rep, iov_elt_p, &status);
                        if (status != rpc_s_ok)
                        {
                            goto done;
                        }
                    }
------ or for that matter, just
                        rpc__cn_copy_buffer (call_rep, iov_elt_p, &status);
                        if (status != rpc_s_ok)
                        {
                            goto done;
                        }

This should fix the unalignment problem.
Brandon Chubb (bfc@setld.enet.dec.com)

[7/5/95 public]
A little more on this -- it looks like in the DG case the IO element
field 'flags' is explicitly set to rpc_c_iovector_elt_reused, then
never used.  In the CN case it appears that it was used but never set.
Perhaps the above behavior of observing it alternating between set and
unset was due to the nature of the test and how our IO elements were
alternating between the 13-byte element and the 283-byte element.
Regardless, it appears that this was some abandoned design idea, and
I'd be glad to hear any of the history behind it.  The intent seems
to be to force the flushing of data so the vectors can be immediately
reused.  There have been '#if 0' blocks in the code since 1.0.3.

[7/5/95 public]

DG ignores the rpc_c_iovector_elt_reused flag because it must always copyin
a marshalling buffer to a DG fragment buffer for fragmentation, re-xmit,
etc. CN uses the rpc_c_iovector_elt_reused flag as a hint for doing
copy-avoidance, i.e., if set then copyin, otherwise avoid copying. (Note:
The flag is set by a stub, i.e., the marshalling engine which allocates a
marshalling buffer.) I don't know the history behind '#if 0' because this
was done by DEC, but the copy-avoidance seems to be a reasonable
performance optimization. (Though RPC_C_CN_BCOPY_LIM seems to be too small.
For instance, the above testcase doesn't fill in the fragment.) Flushing of
buffers will cause an unfilled fragment sent. The above suggested
workaround essentially turns off the copy-avoidance.

Here is a patch against dce 1.0.3. (Ya, there are some dup'ed code
fragments. It would be nice to clean them up. :-) Since this bug has been
there from the beginning and we can't fix all of senders out there, reject
bad guys. ;^<

--- cncall.c@@/main/9	Tue Sep 14 14:31:15 1993
+++ cncall.c@@/main/KK_FIX/LATEST	Mon Jun 26 13:25:55 1995
@@ -8,6 +8,12 @@
 /*
  * HISTORY
  * $Log:	c012885,v $
# Revision 1.17  96/01/26  18:28:49  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [wwang 1/26/96 public]
# 
# Revision 1.16  95/12/15  09:39:05  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company   new/changed/deleted note(s) [white_r 12/15/95 public]
# 
# Revision 1.15  95/08/28  11:38:56  root
# changed fields:  new/changed/deleted note(s) [tatsu_s 8/28/95 public]
# 
# Revision 1.14  95/08/25  14:31:14  root
# changed fields:  new/changed/deleted note(s) [parul 8/25/95 public]
# 
# Revision 1.13  95/08/22  15:15:06  root
# changed fields:  new/changed/deleted note(s) [galvis 8/22/95 ]
# 
# Revision 1.12  95/07/05  17:15:52  root
# changed fields:  new/changed/deleted note(s) [tatsu_s 7/5/95 public]
# 
+ * Revision /main/KK_FIX/1  1995/06/26  17:25 UTC  tatsu_s
+ * 	Submitted the fix for OT12885.
+ * 
+ * Revision /main/tatsu_s.kk_fix_b6/1  1995/06/23  14:05 UTC  tatsu_s
+ * 	Fragment's user data length must be a multiple of 8-bytes.
+ * 
  * Revision 1.1.9.2  1993/09/14  18:31:15  ganni
  * 	OT 7944 - processing of fault packets is missing in
  * 	rpc__cn_call_transmit(). And also modify the client call SM
@@ -1125,6 +1131,23 @@
                  */
                 if (RPC_CN_PKT_PTYPE(header_p) == rpc_c_cn_pkt_response)
                 {
+#ifndef	HPDCE_FIX_OT12885
+                    /*
+		     * data_size must be an integral multiple of 8 bytes
+		     * except for the last fragment.
+		     */
+		    if (((RPC_CN_PKT_FLAGS(header_p) &
+			  rpc_c_cn_flags_last_frag) == 0) &&
+			(frag_buf->data_size & 0x07) != 0)
+		    {
+			/*
+			 * This is a protocol error, just return the whole
+			 * packet.
+			 */
+			call_rep->cn_call_status = rpc_s_protocol_error;
+		    }
+		    else
+#endif	/* HPDCE_FIX_OT12885 */
                     frag_buf->data_p = (pointer_t)
                                       (RPC_CN_PKT_RESP_STUB_DATA(header_p));
                 }
@@ -1410,11 +1433,46 @@
      */
     if (RPC_CN_PKT_PTYPE(header_p) == rpc_c_cn_pkt_response)
     {
+#ifndef	HPDCE_FIX_OT12885
+	/*
+	 * data_size must be an integral multiple of 8 bytes
+	 * except for the last fragment.
+	 */
+	if (((RPC_CN_PKT_FLAGS(header_p) &
+	      rpc_c_cn_flags_last_frag) == 0) &&
+	    (frag_buf->data_size & 0x07) != 0)
+	{
+	    /*
+	     * This is a protocol error, just return the whole
+	     * packet.
+	     */
+	    call_rep->cn_call_status = rpc_s_protocol_error;
+	}
+	else
+#endif	/* HPDCE_FIX_OT12885 */
         frag_buf->data_p = (pointer_t)
                       (RPC_CN_PKT_RESP_STUB_DATA(header_p));
     }
     else if (RPC_CN_PKT_PTYPE(header_p) == rpc_c_cn_pkt_request)
     {
+#ifndef	HPDCE_FIX_OT12885
+	/*
+	 * data_size must be an integral multiple of 8 bytes
+	 * except for the last fragment.
+	 */
+	if (((RPC_CN_PKT_FLAGS(header_p) &
+	      rpc_c_cn_flags_last_frag) == 0) &&
+	    (frag_buf->data_size & 0x07) != 0)
+	{
+	    /*
+	     * This is a protocol error, just return the whole
+	     * packet.
+	     */
+	    call_rep->cn_call_status = rpc_s_protocol_error;
+	}
+	else
+	{
+#endif	/* HPDCE_FIX_OT12885 */
         if (RPC_CN_PKT_OBJ_UUID_PRESENT (header_p))
         {
                 frag_buf->data_p = (pointer_t) 
@@ -1425,6 +1483,9 @@
             frag_buf->data_p = (pointer_t)
                 RPC_CN_PKT_RQST_STUB_DATA_NO_OBJ (header_p);
         }
+#ifndef	HPDCE_FIX_OT12885
+	}
+#endif	/* HPDCE_FIX_OT12885 */
     }
     else if (RPC_CN_PKT_PTYPE(header_p) == rpc_c_cn_pkt_fault)
     {
--- cncthd.c@@/main/3	Sat Jan 30 17:20:30 1993
+++ cncthd.c@@/main/KK_FIX/LATEST	Mon Jun 26 13:26:00 1995
@@ -8,6 +8,12 @@
 /*
  * HISTORY
  * $Log:	c012885,v $
# Revision 1.17  96/01/26  18:28:49  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [wwang 1/26/96 public]
# 
# Revision 1.16  95/12/15  09:39:05  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company   new/changed/deleted note(s) [white_r 12/15/95 public]
# 
# Revision 1.15  95/08/28  11:38:56  root
# changed fields:  new/changed/deleted note(s) [tatsu_s 8/28/95 public]
# 
# Revision 1.14  95/08/25  14:31:14  root
# changed fields:  new/changed/deleted note(s) [parul 8/25/95 public]
# 
# Revision 1.13  95/08/22  15:15:06  root
# changed fields:  new/changed/deleted note(s) [galvis 8/22/95 ]
# 
# Revision 1.12  95/07/05  17:15:52  root
# changed fields:  new/changed/deleted note(s) [tatsu_s 7/5/95 public]
# 
+ * Revision /main/KK_FIX/1  1995/06/26  17:26 UTC  tatsu_s
+ * 	Submitted the fix for OT12885.
+ * 
+ * Revision /main/tatsu_s.kk_fix_b6/1  1995/06/23  14:05 UTC  tatsu_s
+ * 	Added missing call_reject.
+ * 
  * Revision 1.1.3.4  1993/01/30  17:20:30  weisman
  * 	OT 7072: Incorrect operation number check, fixed as
  * 	detailed in OT.
@@ -195,6 +201,11 @@
         RPC_CALL_LOCK ((rpc_call_rep_t *) call_r);
         rpc__cthread_cancel_caf ((rpc_call_rep_t *) call_r);
         RPC_CALL_UNLOCK ((rpc_call_rep_t *) call_r);
+#ifndef	HPDCE_FIX_OT12885
+        RPC_CN_LOCK ();
+        rpc__cn_call_reject ((rpc_call_rep_p_t) call_r, status);
+        RPC_CN_UNLOCK ();
+#endif	/* HPDCE_FIX_OT12885 */
         goto CLEANUP;
     }
     
--- cnxfer.c@@/main/2	Fri Feb  5 16:07:27 1993
+++ cnxfer.c@@/main/KK_FIX/LATEST	Thu Jun 15 14:46:50 1995
@@ -8,6 +8,12 @@
 /*
  * HISTORY
  * $Log:	c012885,v $
# Revision 1.17  96/01/26  18:28:49  root
# changed fields: Fixed In Baseline   new/changed/deleted note(s) [wwang 1/26/96 public]
# 
# Revision 1.16  95/12/15  09:39:05  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.  Resp. Engrs Company   new/changed/deleted note(s) [white_r 12/15/95 public]
# 
# Revision 1.15  95/08/28  11:38:56  root
# changed fields:  new/changed/deleted note(s) [tatsu_s 8/28/95 public]
# 
# Revision 1.14  95/08/25  14:31:14  root
# changed fields:  new/changed/deleted note(s) [parul 8/25/95 public]
# 
# Revision 1.13  95/08/22  15:15:06  root
# changed fields:  new/changed/deleted note(s) [galvis 8/22/95 ]
# 
# Revision 1.12  95/07/05  17:15:52  root
# changed fields:  new/changed/deleted note(s) [tatsu_s 7/5/95 public]
# 
+ * Revision /main/KK_FIX/1  1995/06/15  18:46 UTC  tatsu_s
+ * 	Submitted the fix for OT12885.
+ * 
+ * Revision /main/tatsu_s.kk_fix_b5/1  1995/06/06  16:33 UTC  tatsu_s
+ * 	Fix OT12885: Fragment's user data length must be a multiple of 8-bytes.
+ * 
  * Revision 1.1.2.5  1993/02/05  16:07:27  raizen
  * 	26-jan-93    wh      Do not dealloc last element of call_rep->
  * 	                     buffered_output when authenticated RPC
@@ -131,13 +137,25 @@
     byte_p_t                src;
     byte_p_t                dst;
     rpc_cn_packet_p_t       header_p;
+#ifndef	HPDCE_FIX_OT12885
+    rpc_iovector_elt_p_t    iov_p;
+    unsigned32		    extra_data_size;
+#endif	/* HPDCE_FIX_OT12885 */
 
     src = iov_elt_p->data_addr;
     bytes_left_to_xfer = iov_elt_p->data_len;
     header_p = (rpc_cn_packet_p_t) RPC_CN_CREP_SEND_HDR (call_rep);
     *status = rpc_s_ok;
 
+#ifndef	HPDCE_FIX_OT12885
+    bytes_to_segment_size =
+	((call_rep->max_seg_size
+	  - RPC_CN_CREP_SIZEOF_HDR (call_rep)) & ~0x07)
+	- (RPC_CN_CREP_ACC_BYTCNT (call_rep)
+	   - RPC_CN_CREP_SIZEOF_HDR (call_rep));
+#else
     bytes_to_segment_size = 1;
+#endif	/* HPDCE_FIX_OT12885 */
 
     cur_iov_index = RPC_CN_CREP_CUR_IOV_INDX (call_rep);
     while (bytes_left_to_xfer > 0)
@@ -178,6 +196,14 @@
              */
             if (RPC_CN_CREP_IOVLEN (call_rep) >= rpc_c_max_iovec_len)
             {
+#ifndef	HPDCE_FIX_OT12885
+		extra_data_size =
+		    (RPC_CN_CREP_ACC_BYTCNT (call_rep)
+		     - RPC_CN_CREP_SIZEOF_HDR (call_rep)) & 0x07;
+
+		if (extra_data_size == 0)
+		{
+#endif	/* HPDCE_FIX_OT12885 */
                 /* 
                  * Transmit all the data buffered thus far.
                  */
@@ -196,6 +222,89 @@
                     return;
                 }
 
+#ifndef	HPDCE_FIX_OT12885
+		}
+		else
+		{
+		    iov_p = &(RPC_CN_CREP_IOV (call_rep)[cur_iov_index]);
+
+		    /*
+		     * Adjust the last iovector element
+		     * rounded down to the nearest 8-byte boundary.
+		     */
+		    iov_p->data_len -= extra_data_size;
+
+		    RPC_CN_CREP_ACC_BYTCNT (call_rep) -= extra_data_size;
+		    rpc__cn_transmit_buffers (call_rep, status);
+		    if (*status != rpc_s_ok)
+		    {
+			/*
+			 * Fix up the iovector in the call rep so
+			 * that we again have only the cached protocol
+			 * header (and no stub data).
+			 */
+			rpc__cn_dealloc_buffered_data (call_rep);
+			RPC_CN_FREE_ALL_EXCEPT_PROT_HDR (call_rep);
+			return;
+		    }
+
+		    memcpy (iov_p->data_addr, iov_p->data_addr+iov_p->data_len,
+			    extra_data_size);
+
+		    /*
+		     * Deallocate all the buffers except the 1st and last.
+		     * Then adjust iovector so that we have only
+		     * the header plus the current stub data.
+		     */
+		    if ((call_rep->sec != NULL
+			 && RPC_CN_CREP_IOVLEN (call_rep) > 3)
+			|| (call_rep->sec == NULL
+			    && RPC_CN_CREP_IOVLEN (call_rep) > 2))
+		    {
+			/*
+			 * rpc__cn_dealloc_buffered_data will always skip the
+			 * first iovector element (protocol header).
+			 * Decrementing iovlen will cause it to skip
+			 * the last element also.
+			 */
+			RPC_CN_CREP_IOVLEN (call_rep) --;
+			rpc__cn_dealloc_buffered_data (call_rep);
+
+			/*
+			 * Now we rebuild the iovector.  It will have only
+			 * 2 elements: the header, plus the iovector element
+			 * which we are processing.
+			 */
+			if (call_rep->sec != NULL)
+			{
+			    RPC_CN_CREP_IOVLEN (call_rep) = 3;
+			}
+			else
+			{
+			    RPC_CN_CREP_IOVLEN (call_rep) = 2;
+			}
+			RPC_CN_CREP_CUR_IOV_INDX (call_rep) = 1;
+			RPC_CN_CREP_IOV (call_rep)[1] = *iov_p;
+		    }
+
+		    /*
+		     * Now logically, the only data is the header
+		     * and the next iovector element
+		     */
+		    RPC_CN_CREP_ACC_BYTCNT (call_rep) =
+			RPC_CN_CREP_SIZEOF_HDR (call_rep);
+		    RPC_CN_CREP_IOV(call_rep)[0].data_len = 
+			RPC_CN_CREP_SIZEOF_HDR (call_rep);
+
+		    cur_iov_index = RPC_CN_CREP_CUR_IOV_INDX (call_rep);
+		    RPC_CN_CREP_FREE_BYTES (call_rep) = iov_p->data_len;
+		    RPC_CN_CREP_FREE_BYTE_PTR (call_rep) =
+			iov_p->data_addr + extra_data_size;
+		    RPC_CN_CREP_IOV (call_rep) [cur_iov_index].data_len =
+			extra_data_size;
+		    RPC_CN_CREP_ACC_BYTCNT (call_rep) += extra_data_size;
+		}
+#endif	/* HPDCE_FIX_OT12885 */
             }
             else
             {
@@ -215,8 +324,16 @@
          *   3) remaining bytes left before we reach max_seg_size.
          */
         xfer_size = RPC_CN_CREP_FREE_BYTES (call_rep);
+#ifndef	HPDCE_FIX_OT12885
+	bytes_to_segment_size =
+	    ((call_rep->max_seg_size
+	      - RPC_CN_CREP_SIZEOF_HDR (call_rep)) & ~0x07)
+	    - (RPC_CN_CREP_ACC_BYTCNT (call_rep)
+	       - RPC_CN_CREP_SIZEOF_HDR (call_rep));
+#else
         bytes_to_segment_size = call_rep->max_seg_size -
                                 RPC_CN_CREP_ACC_BYTCNT (call_rep);
+#endif	/* HPDCE_FIX_OT12885 */
         if (xfer_size > bytes_to_segment_size)
         {
             xfer_size = bytes_to_segment_size;
@@ -292,6 +409,9 @@
     byte_p_t                dst;
     rpc_iovector_elt_p_t    iov_p;
     rpc_cn_packet_p_t       header_p;
+#ifndef	HPDCE_FIX_OT12885
+    unsigned32		    extra_data_size;
+#endif	/* HPDCE_FIX_OT12885 */
 
     src = iov_elt_p->data_addr;
     bytes_left_to_xfer = iov_elt_p->data_len;
@@ -305,6 +425,14 @@
      */
     if (RPC_CN_CREP_IOVLEN (call_rep) >= rpc_c_max_iovec_len)
     {
+#ifndef	HPDCE_FIX_OT12885
+	extra_data_size =
+	    (RPC_CN_CREP_ACC_BYTCNT (call_rep)
+	     - RPC_CN_CREP_SIZEOF_HDR (call_rep)) & 0x07;
+
+	if (extra_data_size == 0)
+	{
+#endif	/* HPDCE_FIX_OT12885 */
         /* 
          * Transmit all the data buffered thus far.
          */
@@ -321,6 +449,90 @@
         {
             return;
         }
+#ifndef	HPDCE_FIX_OT12885
+	}
+	else
+	{
+	    cur_iov_index = RPC_CN_CREP_CUR_IOV_INDX (call_rep);
+	    iov_p = &(RPC_CN_CREP_IOV (call_rep)[cur_iov_index]);
+
+	    /*
+	     * Adjust the last iovector element
+	     * rounded down to the nearest 8-byte boundary.
+	     */
+	    iov_p->data_len -= extra_data_size;
+
+	    RPC_CN_CREP_ACC_BYTCNT (call_rep) -= extra_data_size;
+	    rpc__cn_transmit_buffers (call_rep, status);
+	    if (*status != rpc_s_ok)
+	    {
+		/*
+		 * Fix up the iovector in the call rep so
+		 * that we again have only the cached protocol
+		 * header (and no stub data).
+		 */
+		rpc__cn_dealloc_buffered_data (call_rep);
+		RPC_CN_FREE_ALL_EXCEPT_PROT_HDR (call_rep);
+		return;
+	    }
+
+	    memcpy (iov_p->data_addr, iov_p->data_addr+iov_p->data_len,
+		    extra_data_size);
+
+	    /*
+	     * Deallocate all the buffers except the 1st and last.
+	     * Then adjust iovector so that we have only
+	     * the header plus the current stub data.
+	     */
+	    if ((call_rep->sec != NULL
+		 && RPC_CN_CREP_IOVLEN (call_rep) > 3)
+		|| (call_rep->sec == NULL
+		    && RPC_CN_CREP_IOVLEN (call_rep) > 2))
+	    {
+		/*
+		 * rpc__cn_dealloc_buffered_data will always skip the
+		 * first iovector element (protocol header).
+		 * Decrementing iovlen will cause it to skip
+		 * the last element also.
+		 */
+		RPC_CN_CREP_IOVLEN (call_rep) --;
+		rpc__cn_dealloc_buffered_data (call_rep);
+
+		/*
+		 * Now we rebuild the iovector.  It will have only
+		 * 2 elements: the header, plus the iovector element
+		 * which we are processing.
+		 */
+		if (call_rep->sec != NULL)
+		{
+		    RPC_CN_CREP_IOVLEN (call_rep) = 3;
+		}
+		else
+		{
+		    RPC_CN_CREP_IOVLEN (call_rep) = 2;
+		}
+		RPC_CN_CREP_CUR_IOV_INDX (call_rep) = 1;
+		RPC_CN_CREP_IOV (call_rep)[1] = *iov_p;
+	    }
+
+	    /*
+	     * Now logically, the only data is the header
+	     * and the next iovector element
+	     */
+	    RPC_CN_CREP_ACC_BYTCNT (call_rep) =
+		RPC_CN_CREP_SIZEOF_HDR (call_rep);
+	    RPC_CN_CREP_IOV(call_rep)[0].data_len = 
+		RPC_CN_CREP_SIZEOF_HDR (call_rep);
+
+	    cur_iov_index = RPC_CN_CREP_CUR_IOV_INDX (call_rep);
+	    RPC_CN_CREP_FREE_BYTES (call_rep) = iov_p->data_len;
+	    RPC_CN_CREP_FREE_BYTE_PTR (call_rep) =
+		iov_p->data_addr + extra_data_size;
+	    RPC_CN_CREP_IOV (call_rep) [cur_iov_index].data_len =
+		extra_data_size;
+	    RPC_CN_CREP_ACC_BYTCNT (call_rep) += extra_data_size;
+	}
+#endif	/* HPDCE_FIX_OT12885 */
     }
 
     /*
@@ -348,8 +560,16 @@
      * element until the total remaining size (including
      * protocol header) is less than our segment size.
      */
+#ifndef	HPDCE_FIX_OT12885
+    bytes_to_segment_size =
+	((call_rep->max_seg_size
+	  - RPC_CN_CREP_SIZEOF_HDR (call_rep)) & ~0x07)
+	- (RPC_CN_CREP_ACC_BYTCNT (call_rep)
+	   - RPC_CN_CREP_SIZEOF_HDR (call_rep));
+#else
     bytes_to_segment_size = call_rep->max_seg_size -
                             RPC_CN_CREP_ACC_BYTCNT (call_rep);
+#endif	/* HPDCE_FIX_OT12885 */
 
     /* 
      * Only invoke rpc__cn_transmit_buffers() if iov_elt_p->data_len is 
@@ -376,9 +596,15 @@
             RPC_CN_FREE_ALL_EXCEPT_PROT_HDR (call_rep);
             return;
         }
+#ifndef	HPDCE_FIX_OT12885
+        iov_elt_p->data_len = bytes_left_to_xfer - bytes_to_segment_size;
+	bytes_left_to_xfer = iov_elt_p->data_len;
+#else
         iov_elt_p->data_len -= bytes_to_segment_size;
+#endif	/* HPDCE_FIX_OT12885 */
         iov_elt_p->data_addr += bytes_to_segment_size;
 
+#ifdef	HPDCE_FIX_OT12885
         /*
          * Before adjusting the iovector make life simple and remove
          * the auth trailer iovector.
@@ -387,13 +613,21 @@
         {
             RPC_CN_CREP_IOVLEN (call_rep)--;
         }
+#endif	/* HPDCE_FIX_OT12885 */
 
         /*
          * Deallocate all the buffers except the 1st and last.
          * Then adjust iovector so that we have only 2 elements:
          * the header plus the current stub data.
          */
+#ifndef	HPDCE_FIX_OT12885
+	if ((call_rep->sec != NULL
+	     && RPC_CN_CREP_IOVLEN (call_rep) > 3)
+	    || (call_rep->sec == NULL
+		&& RPC_CN_CREP_IOVLEN (call_rep) > 2))
+#else
         if (RPC_CN_CREP_IOVLEN (call_rep) > 2)
+#endif	/* HPDCE_FIX_OT12885 */
         {
             /*
              * rpc__cn_dealloc_buffered_data will always skip the
@@ -408,11 +642,23 @@
              * 2 elements: the header, plus the iovector element
              * which we are processing.
              */
+#ifndef	HPDCE_FIX_OT12885
+	    if (call_rep->sec != NULL)
+	    {
+		RPC_CN_CREP_IOVLEN (call_rep) = 3;
+	    }
+	    else
+	    {
+		RPC_CN_CREP_IOVLEN (call_rep) = 2;
+	    }
+#else
             RPC_CN_CREP_IOVLEN (call_rep) = 2;
+#endif	/* HPDCE_FIX_OT12885 */
             RPC_CN_CREP_CUR_IOV_INDX (call_rep) = 1;
             iov_p = &(RPC_CN_CREP_IOV (call_rep)[1]);
         }
 
+#ifdef	HPDCE_FIX_OT12885
         /*
          * Make sure to reserve an iovector element for the protocol
          * trailer if required.
@@ -421,6 +667,7 @@
         {
             RPC_CN_CREP_IOVLEN (call_rep)++;
         }
+#endif	/* HPDCE_FIX_OT12885 */
 
         /*
          * Now logically, the only data is the header.
@@ -433,9 +680,16 @@
         
         *iov_p = *iov_elt_p;
 
+#ifndef	HPDCE_FIX_OT12885
+	bytes_to_segment_size =
+	    ((call_rep->max_seg_size
+	      - RPC_CN_CREP_SIZEOF_HDR (call_rep)) & ~0x07)
+	    - (RPC_CN_CREP_ACC_BYTCNT (call_rep)
+	       - RPC_CN_CREP_SIZEOF_HDR (call_rep));
+#else
         bytes_to_segment_size = call_rep->max_seg_size -
                             RPC_CN_CREP_ACC_BYTCNT (call_rep);
-
+#endif	/* HPDCE_FIX_OT12885 */
     }
 
     /*

[8/22/95]

We have implemented the 2 fixes recommended above, and they seem to have
fixed things.  I have tested that the client generates correct marshalled
information, and also that the server has the ability to detect garbage
from a client, and will reject it, instead of choking on it.  Both are
working correctly.

[8/25/95 public]
I'm little confused. What I am hearing is that IBM has picked up both DEC and
HP's fixes. I thought HP's fix was making DEC's fix unnecessay. From what I 
read DEC's fix was disabling copy-avoidance of iovec elements and so was more 
like problem avoidance type of fix. Do I need both fixes or just the one from
HP? Comments?

[8/28/95 public]

DEC's change disables the copy-avoidance and as a side effect, fixes (work
around) the client side of the fragmentation bug. It shouldn't be needed if
you apply HP's fix.

[12/15/95 public]
Fixed in DCE 1.2.1
Closed

[1/26/96 public]
Fix submitted to 1.1maint. Fixed as proposed in OT + plus some error 
checking code from 1.2.1 code base.

Files modified:	rpc/runtime/cncall.c
		rpc/runtime/cnxthd.c
		rpc/runtime/cnxfer.c

How tested:	Code review, build, run the test case from the OT

Diff:		

*** /project/dce/build/dce1.1-maint/src/rpc/runtime/cncall.c	Thu Jul 14 17:31:01 1994
--- cncall.c	Wed Jan 17 13:31:31 1996
***************
*** 466,478 ****
              }
          }
      }
! 
      /*
       * At this point, we have a fully-bound binding.
       * We can now allocate a call_rep.
       */
      call_rep = (rpc_cn_call_rep_p_t) 
          rpc__list_element_alloc (&rpc_g_cn_call_lookaside_list, true);
  
      /*
       * Mark it as a client call rep.
--- 466,492 ----
              }
          }
      }
!     if (!binding_r->addr_has_endpoint)
!     {
! 	RPC_DCE_SVC_PRINTF ((
! 	    DCE_SVC(RPC__SVC_HANDLE, "%s%x"),
! 	    rpc_svc_general,
! 	    svc_c_sev_fatal | svc_c_action_abort,
!             rpc_m_call_failed,
!             "(rpc__cn_call_start)",
!             "binding has no endpoint."));
!     }
      /*
       * At this point, we have a fully-bound binding.
       * We can now allocate a call_rep.
       */
      call_rep = (rpc_cn_call_rep_p_t) 
          rpc__list_element_alloc (&rpc_g_cn_call_lookaside_list, true);
+     if (call_rep == NULL){
+ 	*st = rpc_s_no_memory;
+ 	RPC_CN_UNLOCK ();
+ 	return(NULL);
+     }
  
      /*
       * Mark it as a client call rep.
***************
*** 512,517 ****
--- 526,532 ----
      call_rep->last_frag_received = false;
      call_rep->call_executed = false;
  
+ 
      /*
       * Initialize some cancel state information. 
       */
***************
*** 645,650 ****
--- 660,672 ----
               * Allocate a small fragbuf to contain the authentication trailer.
               */
              RPC_CN_FRAGBUF_ALLOC (call_rep->prot_tlr, RPC_C_CN_SMALL_FRAG_SIZE, st);
+ 	    if (call_rep->prot_tlr == NULL){
+ 		/* set status and clean up using call_end */
+ 		RPC_CN_UNLOCK ();
+ 		*st = rpc_s_no_memory;
+ 		rpc__cn_call_end ((rpc_call_rep_p_t *) &call_rep, &temp_st);
+ 		return(NULL);
+ 	    }
              call_rep->prot_tlr->fragbuf_dealloc = NULL;
              auth_value_len = RPC_C_CN_SMALL_FRAG_SIZE;
              auth_tlr = (rpc_cn_auth_tlr_t *)call_rep->prot_tlr->data_p;
***************
*** 1175,1180 ****
--- 1197,1217 ----
                   */
                  if (RPC_CN_PKT_PTYPE(header_p) == RPC_C_CN_PKT_RESPONSE)
                  {
+                     /*
+ 		     * data_size must be an integral multiple of 8 bytes
+ 		     * except for the last fragment.
+ 		     */
+ 		    if (((RPC_CN_PKT_FLAGS(header_p) &
+ 			  RPC_C_CN_FLAGS_LAST_FRAG) == 0) &&
+ 			(frag_buf->data_size & 0x07) != 0)
+ 		    {
+ 			/*
+ 			 * This is a protocol error, just return the whole
+ 			 * packet.
+ 			 */
+ 			call_rep->cn_call_status = rpc_s_protocol_error;
+ 		    }
+ 		    else
                      frag_buf->data_p = (pointer_t)
                                        (RPC_CN_PKT_RESP_STUB_DATA(header_p));
                  }
***************
*** 1464,1474 ****
--- 1501,1542 ----
       */
      if (RPC_CN_PKT_PTYPE(header_p) == RPC_C_CN_PKT_RESPONSE)
      {
+ 	/*
+ 	 * data_size must be an integral multiple of 8 bytes
+ 	 * except for the last fragment.
+ 	 */
+ 	if (((RPC_CN_PKT_FLAGS(header_p) &
+ 	      RPC_C_CN_FLAGS_LAST_FRAG) == 0) &&
+ 	    (frag_buf->data_size & 0x07) != 0)
+ 	{
+ 	    /*
+ 	     * This is a protocol error, just return the whole
+ 	     * packet.
+ 	     */
+ 	    call_rep->cn_call_status = rpc_s_protocol_error;
+ 	}
+ 	else
          frag_buf->data_p = (pointer_t)
                        (RPC_CN_PKT_RESP_STUB_DATA(header_p));
      }
      else if (RPC_CN_PKT_PTYPE(header_p) == RPC_C_CN_PKT_REQUEST)
      {
+ 	/*
+ 	 * data_size must be an integral multiple of 8 bytes
+ 	 * except for the last fragment.
+ 	 */
+ 	if (((RPC_CN_PKT_FLAGS(header_p) &
+ 	      RPC_C_CN_FLAGS_LAST_FRAG) == 0) &&
+ 	    (frag_buf->data_size & 0x07) != 0)
+ 	{
+ 	    /*
+ 	     * This is a protocol error, just return the whole
+ 	     * packet.
+ 	     */
+ 	    call_rep->cn_call_status = rpc_s_protocol_error;
+ 	}
+ 	else
+ 	{
          if (RPC_CN_PKT_OBJ_UUID_PRESENT (header_p))
          {
                  frag_buf->data_p = (pointer_t) 
***************
*** 1479,1484 ****
--- 1547,1553 ----
              frag_buf->data_p = (pointer_t)
                  RPC_CN_PKT_RQST_STUB_DATA_NO_OBJ (header_p);
          }
+ 	}
      }
      else if (RPC_CN_PKT_PTYPE(header_p) == RPC_C_CN_PKT_FAULT)
      {
***************
*** 1942,1947 ****
--- 2011,2017 ----
              rpc__cn_smfragbuf_free (call_rep->prot_tlr);
          }
  
+ 
          /* 
           * Free the call_rep itself.
           */
***************
*** 1960,1965 ****
--- 2030,2036 ----
       */
      RPC_CN_UNLOCK ();
  
+ 
      RPC_LOG_CN_CALL_END_XIT;
  }
  
***************
*** 2602,2609 ****
--- 2673,2683 ----
      RPC_CN_DBG_RTN_PRINTF(rpc__cn_call_ccb_create);
  
      RPC_LIST_INIT (ccb->common.link);
+ 
      ccb->common.protocol_id = RPC_C_PROTOCOL_ID_NCACN;
      fragbuf_p = rpc__cn_fragbuf_alloc (false);
+     if (fragbuf_p == NULL)
+ 	RAISE(exc_insfmem_e);
      fragbuf_p->fragbuf_dealloc = NULL;
      ccb->prot_header = fragbuf_p;
      header_p = (rpc_cn_packet_p_t) RPC_CN_CREP_SEND_HDR (ccb);
***************
*** 3087,3092 ****
--- 3161,3173 ----
                         ("(rpc__cn_call_binding_serialize) binding_rep->%x cancel timeout\n", binding_r));
          *st = rpc_s_cancel_timeout;
      }
+     else if (!binding_r->addr_has_endpoint)
+     {
+ 	*st = rpc_s_endpoint_not_found;
+ 	RPC_DBG_PRINTF (rpc_e_dbg_general, RPC_C_CN_DBG_GENERAL,
+ 			("(rpc__cn_call_binding_serialize) binding_rep->%x couldn't be resolved\n",
+ 	                 binding_r));
+     }
  }
  
  
*** /project/dce/build/dce1.1-maint/src/rpc/runtime/cncthd.c	Tue Jun 21 17:53:38 1994
--- cncthd.c	Wed Jan 17 13:31:49 1996
***************
*** 174,182 ****
          RPC_CALL_LOCK ((rpc_call_rep_t *) call_r);
          rpc__cthread_cancel_caf ((rpc_call_rep_t *) call_r);
          RPC_CALL_UNLOCK ((rpc_call_rep_t *) call_r);
-         RPC_CN_LOCK ();
-         rpc__cn_call_reject ((rpc_call_rep_p_t) call_r, status);
-         RPC_CN_UNLOCK ();
          goto CLEANUP;
      }
      
--- 174,179 ----
*** /project/dce/build/dce1.1-maint/src/rpc/runtime/cnxfer.c	Fri Jan 21 17:34:54 1994
--- cnxfer.c	Wed Jan 17 13:32:27 1996
***************
*** 141,153 ****
      unsigned32              cur_iov_index;
      byte_p_t                src;
      rpc_cn_packet_p_t       header_p;
  
      src = iov_elt_p->data_addr;
      bytes_left_to_xfer = iov_elt_p->data_len;
      header_p = (rpc_cn_packet_p_t) RPC_CN_CREP_SEND_HDR (call_rep);
      *status = rpc_s_ok;
  
!     bytes_to_segment_size = 1;
  
      cur_iov_index = RPC_CN_CREP_CUR_IOV_INDX (call_rep);
      while (bytes_left_to_xfer > 0)
--- 141,159 ----
      unsigned32              cur_iov_index;
      byte_p_t                src;
      rpc_cn_packet_p_t       header_p;
+     rpc_iovector_elt_p_t    iov_p;
+     unsigned32		    extra_data_size;
  
      src = iov_elt_p->data_addr;
      bytes_left_to_xfer = iov_elt_p->data_len;
      header_p = (rpc_cn_packet_p_t) RPC_CN_CREP_SEND_HDR (call_rep);
      *status = rpc_s_ok;
  
!     bytes_to_segment_size =
! 	((call_rep->max_seg_size
! 	  - RPC_CN_CREP_SIZEOF_HDR (call_rep)) & ~0x07)
! 	- (RPC_CN_CREP_ACC_BYTCNT (call_rep)
! 	   - RPC_CN_CREP_SIZEOF_HDR (call_rep));
  
      cur_iov_index = RPC_CN_CREP_CUR_IOV_INDX (call_rep);
      while (bytes_left_to_xfer > 0)
***************
*** 188,193 ****
--- 194,205 ----
               */
              if (RPC_CN_CREP_IOVLEN (call_rep) >= RPC_C_MAX_IOVEC_LEN)
              {
+ 		extra_data_size =
+ 		    (RPC_CN_CREP_ACC_BYTCNT (call_rep)
+ 		     - RPC_CN_CREP_SIZEOF_HDR (call_rep)) & 0x07;
+ 
+ 		if (extra_data_size == 0)
+ 		{
                  /* 
                   * Transmit all the data buffered thus far.
                   */
***************
*** 206,211 ****
--- 218,304 ----
                      return;
                  }
  
+ 		}
+ 		else
+ 		{
+ 		    iov_p = &(RPC_CN_CREP_IOV (call_rep)[cur_iov_index]);
+ 
+ 		    /*
+ 		     * Adjust the last iovector element
+ 		     * rounded down to the nearest 8-byte boundary.
+ 		     */
+ 		    iov_p->data_len -= extra_data_size;
+ 
+ 		    RPC_CN_CREP_ACC_BYTCNT (call_rep) -= extra_data_size;
+ 		    rpc__cn_transmit_buffers (call_rep, status);
+ 		    if (*status != rpc_s_ok)
+ 		    {
+ 			/*
+ 			 * Fix up the iovector in the call rep so
+ 			 * that we again have only the cached protocol
+ 			 * header (and no stub data).
+ 			 */
+ 			rpc__cn_dealloc_buffered_data (call_rep);
+ 			RPC_CN_FREE_ALL_EXCEPT_PROT_HDR (call_rep);
+ 			return;
+ 		    }
+ 
+ 		    memcpy (iov_p->data_addr, iov_p->data_addr+iov_p->data_len,
+ 			    extra_data_size);
+ 
+ 		    /*
+ 		     * Deallocate all the buffers except the 1st and last.
+ 		     * Then adjust iovector so that we have only
+ 		     * the header plus the current stub data.
+ 		     */
+ 		    if ((call_rep->sec != NULL
+ 			 && RPC_CN_CREP_IOVLEN (call_rep) > 3)
+ 			|| (call_rep->sec == NULL
+ 			    && RPC_CN_CREP_IOVLEN (call_rep) > 2))
+ 		    {
+ 			/*
+ 			 * rpc__cn_dealloc_buffered_data will always skip the
+ 			 * first iovector element (protocol header).
+ 			 * Decrementing iovlen will cause it to skip
+ 			 * the last element also.
+ 			 */
+ 			RPC_CN_CREP_IOVLEN (call_rep) --;
+ 			rpc__cn_dealloc_buffered_data (call_rep);
+ 
+ 			/*
+ 			 * Now we rebuild the iovector.  It will have only
+ 			 * 2 elements: the header, plus the iovector element
+ 			 * which we are processing.
+ 			 */
+ 			if (call_rep->sec != NULL)
+ 			{
+ 			    RPC_CN_CREP_IOVLEN (call_rep) = 3;
+ 			}
+ 			else
+ 			{
+ 			    RPC_CN_CREP_IOVLEN (call_rep) = 2;
+ 			}
+ 			RPC_CN_CREP_CUR_IOV_INDX (call_rep) = 1;
+ 			RPC_CN_CREP_IOV (call_rep)[1] = *iov_p;
+ 		    }
+ 
+ 		    /*
+ 		     * Now logically, the only data is the header
+ 		     * and the next iovector element
+ 		     */
+ 		    RPC_CN_CREP_ACC_BYTCNT (call_rep) =
+ 			RPC_CN_CREP_SIZEOF_HDR (call_rep);
+ 		    RPC_CN_CREP_IOV(call_rep)[0].data_len = 
+ 			RPC_CN_CREP_SIZEOF_HDR (call_rep);
+ 
+ 		    cur_iov_index = RPC_CN_CREP_CUR_IOV_INDX (call_rep);
+ 		    RPC_CN_CREP_FREE_BYTES (call_rep) = iov_p->data_len;
+ 		    RPC_CN_CREP_FREE_BYTE_PTR (call_rep) =
+ 			iov_p->data_addr + extra_data_size;
+ 		    RPC_CN_CREP_IOV (call_rep) [cur_iov_index].data_len =
+ 			extra_data_size;
+ 		    RPC_CN_CREP_ACC_BYTCNT (call_rep) += extra_data_size;
+ 		}
              }
              else
              {
***************
*** 214,219 ****
--- 307,323 ----
                   * In this case, we can use a new iovector element.
                   */
                  rpc__cn_prep_next_iovector_elmt (call_rep, status);
+ 		if (*status != rpc_s_ok)
+ 		{
+ 		    /*
+ 		     * Fix up the iovector in the call rep so
+ 		     * that we again have only the cached protocol
+ 		     * header (and no stub data).
+ 		     */
+ 		    rpc__cn_dealloc_buffered_data (call_rep);
+ 		    RPC_CN_FREE_ALL_EXCEPT_PROT_HDR (call_rep);
+ 		    return;
+ 		}
                  cur_iov_index ++;
              }
          }
***************
*** 225,232 ****
           *   3) remaining bytes left before we reach max_seg_size.
           */
          xfer_size = RPC_CN_CREP_FREE_BYTES (call_rep);
!         bytes_to_segment_size = call_rep->max_seg_size -
!                                 RPC_CN_CREP_ACC_BYTCNT (call_rep);
          if (xfer_size > bytes_to_segment_size)
          {
              xfer_size = bytes_to_segment_size;
--- 329,339 ----
           *   3) remaining bytes left before we reach max_seg_size.
           */
          xfer_size = RPC_CN_CREP_FREE_BYTES (call_rep);
! 	bytes_to_segment_size =
! 	    ((call_rep->max_seg_size
! 	      - RPC_CN_CREP_SIZEOF_HDR (call_rep)) & ~0x07)
! 	    - (RPC_CN_CREP_ACC_BYTCNT (call_rep)
! 	       - RPC_CN_CREP_SIZEOF_HDR (call_rep));
          if (xfer_size > bytes_to_segment_size)
          {
              xfer_size = bytes_to_segment_size;
***************
*** 307,312 ****
--- 414,420 ----
      byte_p_t                src;
      rpc_iovector_elt_p_t    iov_p;
      rpc_cn_packet_p_t       header_p;
+     unsigned32		    extra_data_size;
  
      src = iov_elt_p->data_addr;
      bytes_left_to_xfer = iov_elt_p->data_len;
***************
*** 320,325 ****
--- 428,439 ----
       */
      if (RPC_CN_CREP_IOVLEN (call_rep) >= RPC_C_MAX_IOVEC_LEN)
      {
+ 	extra_data_size =
+ 	    (RPC_CN_CREP_ACC_BYTCNT (call_rep)
+ 	     - RPC_CN_CREP_SIZEOF_HDR (call_rep)) & 0x07;
+ 
+ 	if (extra_data_size == 0)
+ 	{
          /* 
           * Transmit all the data buffered thus far.
           */
***************
*** 336,341 ****
--- 450,537 ----
          {
              return;
          }
+ 	}
+ 	else
+ 	{
+ 	    cur_iov_index = RPC_CN_CREP_CUR_IOV_INDX (call_rep);
+ 	    iov_p = &(RPC_CN_CREP_IOV (call_rep)[cur_iov_index]);
+ 
+ 	    /*
+ 	     * Adjust the last iovector element
+ 	     * rounded down to the nearest 8-byte boundary.
+ 	     */
+ 	    iov_p->data_len -= extra_data_size;
+ 
+ 	    RPC_CN_CREP_ACC_BYTCNT (call_rep) -= extra_data_size;
+ 	    rpc__cn_transmit_buffers (call_rep, status);
+ 	    if (*status != rpc_s_ok)
+ 	    {
+ 		/*
+ 		 * Fix up the iovector in the call rep so
+ 		 * that we again have only the cached protocol
+ 		 * header (and no stub data).
+ 		 */
+ 		rpc__cn_dealloc_buffered_data (call_rep);
+ 		RPC_CN_FREE_ALL_EXCEPT_PROT_HDR (call_rep);
+ 		return;
+ 	    }
+ 
+ 	    memcpy (iov_p->data_addr, iov_p->data_addr+iov_p->data_len,
+ 		    extra_data_size);
+ 
+ 	    /*
+ 	     * Deallocate all the buffers except the 1st and last.
+ 	     * Then adjust iovector so that we have only
+ 	     * the header plus the current stub data.
+ 	     */
+ 	    if ((call_rep->sec != NULL
+ 		 && RPC_CN_CREP_IOVLEN (call_rep) > 3)
+ 		|| (call_rep->sec == NULL
+ 		    && RPC_CN_CREP_IOVLEN (call_rep) > 2))
+ 	    {
+ 		/*
+ 		 * rpc__cn_dealloc_buffered_data will always skip the
+ 		 * first iovector element (protocol header).
+ 		 * Decrementing iovlen will cause it to skip
+ 		 * the last element also.
+ 		 */
+ 		RPC_CN_CREP_IOVLEN (call_rep) --;
+ 		rpc__cn_dealloc_buffered_data (call_rep);
+ 
+ 		/*
+ 		 * Now we rebuild the iovector.  It will have only
+ 		 * 2 elements: the header, plus the iovector element
+ 		 * which we are processing.
+ 		 */
+ 		if (call_rep->sec != NULL)
+ 		{
+ 		    RPC_CN_CREP_IOVLEN (call_rep) = 3;
+ 		}
+ 		else
+ 		{
+ 		    RPC_CN_CREP_IOVLEN (call_rep) = 2;
+ 		}
+ 		RPC_CN_CREP_CUR_IOV_INDX (call_rep) = 1;
+ 		RPC_CN_CREP_IOV (call_rep)[1] = *iov_p;
+ 	    }
+ 
+ 	    /*
+ 	     * Now logically, the only data is the header
+ 	     * and the next iovector element
+ 	     */
+ 	    RPC_CN_CREP_ACC_BYTCNT (call_rep) =
+ 		RPC_CN_CREP_SIZEOF_HDR (call_rep);
+ 	    RPC_CN_CREP_IOV(call_rep)[0].data_len = 
+ 		RPC_CN_CREP_SIZEOF_HDR (call_rep);
+ 
+ 	    cur_iov_index = RPC_CN_CREP_CUR_IOV_INDX (call_rep);
+ 	    RPC_CN_CREP_FREE_BYTES (call_rep) = iov_p->data_len;
+ 	    RPC_CN_CREP_FREE_BYTE_PTR (call_rep) =
+ 		iov_p->data_addr + extra_data_size;
+ 	    RPC_CN_CREP_IOV (call_rep) [cur_iov_index].data_len =
+ 		extra_data_size;
+ 	    RPC_CN_CREP_ACC_BYTCNT (call_rep) += extra_data_size;
+ 	}
      }
  
      /*
***************
*** 363,370 ****
       * element until the total remaining size (including
       * protocol header) is less than our segment size.
       */
!     bytes_to_segment_size = call_rep->max_seg_size -
!                             RPC_CN_CREP_ACC_BYTCNT (call_rep);
  
      /* 
       * Only invoke rpc__cn_transmit_buffers() if iov_elt_p->data_len is 
--- 559,569 ----
       * element until the total remaining size (including
       * protocol header) is less than our segment size.
       */
!     bytes_to_segment_size =
! 	((call_rep->max_seg_size
! 	  - RPC_CN_CREP_SIZEOF_HDR (call_rep)) & ~0x07)
! 	- (RPC_CN_CREP_ACC_BYTCNT (call_rep)
! 	   - RPC_CN_CREP_SIZEOF_HDR (call_rep));
  
      /* 
       * Only invoke rpc__cn_transmit_buffers() if iov_elt_p->data_len is 
***************
*** 391,414 ****
              RPC_CN_FREE_ALL_EXCEPT_PROT_HDR (call_rep);
              return;
          }
!         iov_elt_p->data_len -= bytes_to_segment_size;
          iov_elt_p->data_addr += bytes_to_segment_size;
  
-         /*
-          * Before adjusting the iovector make life simple and remove
-          * the auth trailer iovector.
-          */
-         if (call_rep->sec != NULL)
-         {
-             RPC_CN_CREP_IOVLEN (call_rep)--;
-         }
  
          /*
           * Deallocate all the buffers except the 1st and last.
           * Then adjust iovector so that we have only 2 elements:
           * the header plus the current stub data.
           */
!         if (RPC_CN_CREP_IOVLEN (call_rep) > 2)
          {
              /*
               * rpc__cn_dealloc_buffered_data will always skip the
--- 590,609 ----
              RPC_CN_FREE_ALL_EXCEPT_PROT_HDR (call_rep);
              return;
          }
!         iov_elt_p->data_len = bytes_left_to_xfer - bytes_to_segment_size;
! 	bytes_left_to_xfer = iov_elt_p->data_len;
          iov_elt_p->data_addr += bytes_to_segment_size;
  
  
          /*
           * Deallocate all the buffers except the 1st and last.
           * Then adjust iovector so that we have only 2 elements:
           * the header plus the current stub data.
           */
! 	if ((call_rep->sec != NULL
! 	     && RPC_CN_CREP_IOVLEN (call_rep) > 3)
! 	    || (call_rep->sec == NULL
! 		&& RPC_CN_CREP_IOVLEN (call_rep) > 2))
          {
              /*
               * rpc__cn_dealloc_buffered_data will always skip the
***************
*** 423,441 ****
               * 2 elements: the header, plus the iovector element
               * which we are processing.
               */
!             RPC_CN_CREP_IOVLEN (call_rep) = 2;
              RPC_CN_CREP_CUR_IOV_INDX (call_rep) = 1;
              iov_p = &(RPC_CN_CREP_IOV (call_rep)[1]);
          }
  
-         /*
-          * Make sure to reserve an iovector element for the protocol
-          * trailer if required.
-          */
-         if (call_rep->sec != NULL)
-         {
-             RPC_CN_CREP_IOVLEN (call_rep)++;
-         }
  
          /*
           * Now logically, the only data is the header.
--- 618,635 ----
               * 2 elements: the header, plus the iovector element
               * which we are processing.
               */
! 	    if (call_rep->sec != NULL)
! 	    {
! 		RPC_CN_CREP_IOVLEN (call_rep) = 3;
! 	    }
! 	    else
! 	    {
! 		RPC_CN_CREP_IOVLEN (call_rep) = 2;
! 	    }
              RPC_CN_CREP_CUR_IOV_INDX (call_rep) = 1;
              iov_p = &(RPC_CN_CREP_IOV (call_rep)[1]);
          }
  
  
          /*
           * Now logically, the only data is the header.
***************
*** 448,456 ****
          
          *iov_p = *iov_elt_p;
  
!         bytes_to_segment_size = call_rep->max_seg_size -
!                             RPC_CN_CREP_ACC_BYTCNT (call_rep);
! 
      }
  
      /*
--- 642,652 ----
          
          *iov_p = *iov_elt_p;
  
! 	bytes_to_segment_size =
! 	    ((call_rep->max_seg_size
! 	      - RPC_CN_CREP_SIZEOF_HDR (call_rep)) & ~0x07)
! 	    - (RPC_CN_CREP_ACC_BYTCNT (call_rep)
! 	       - RPC_CN_CREP_SIZEOF_HDR (call_rep));
      }
  
      /*
***************
*** 795,800 ****
--- 991,1000 ----
       * Allocate a new [large] fragment buffer.
       */
      buf_p = rpc__cn_fragbuf_alloc (true);
+     if (buf_p == NULL){
+ 	*status = rpc_s_no_memory;
+ 	return;
+     }
      
      /*
       * Make the next iovector element point to it.

0HISTORY Tue May 23 12:47:12 1995 galvis	Created



CR Number                     : 12820
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime/rpclist.c
Short Description             : rpc code uses the return from rpc__list_element_alloc() without checking for NULL ptr first
Reported Date                 : 3/16/95
Found in Baseline             : 1.1
Found Date                    : 3/16/95
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 1.2.1
Affected File(s)              : rpc
Sensitivity                   : public

[3/16/95 public]

rpc/runtime/rpclist.c's rpc__list_element_alloc() function can return a NULL
pointer if the block field is false, or if the block field is true and after
number of times allocation always fails.

But calls to this function always assume that this fucntion will return a
non-NULL ptr. For example, runtime/nslookup.c's rpc__bindlkup_node_create()
function calls rpc__list_element_alloc() and uses the return immediately.

[12/15/95 public]
Fixed in DCE 1.2.1
Closed



CR Number                     : 12801
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : aes/rpc
Short Description             : 1.0.2/1.0.3 incompatibility
Reported Date                 : 2/23/95
Found in Baseline             : 1.1
Found Date                    : 2/23/95
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.2
Affected File(s)              : aes
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Herder               : andi
Transarc Status               : 

[2/23/95 public]
Date: Fri, 10 Feb 1995 13:08:39 -0500 (EST)
From: Daniel_Nydick@transarc.com
To: burati@apollo.hp.com
CC: David_Stephenson@transarc.com, Craig_Everhart@transarc.com
Subject: NDR question
Mike,
        I'm a member of Transarc's DCE maintenance group.  One of our
customers has run across an incompatibility between the 1.0.2 and
1.0.3 IDL compilers, and I need an informed opinion on the NDR wire
encoding.  Craig Everhart thought you might either be able to answer
my question, or redirect me to someone who can.
Here's the gist: the customer has defined a tagged union which covers
different sized data items, using an enumerated type as the
discriminator.  He's encapsulated this union in a structure.
----------------------
[
uuid(006e4cae-9d97-1f3b-8959-9e620c39aa77),
version(1.0)
]
interface foo
{
typedef enum {
    E_NULL, E_SHORT, E_LONG, E_FLOAT, E_DOUBLE, E_ARRAY, E_STRING
} EEE;
typedef struct SSS {
    union switch (EEE type) {
        case E_SHORT:  short int  short_t;
        case E_LONG:   long  int  long_t;
        case E_FLOAT:  float      float_t;
        case E_DOUBLE: double     double_t;
        case E_ARRAY:  [ptr] struct SSS *array_t;
        case E_STRING: [ptr,string] char *string_t;
        default: ;
    } data;
} SSS;
void glop([in]handle_t h, [ptr,in] SSS *arg, [out] long int *st);
}
------------------------
Here's the problem.  Imagine we call glop, passing an SSS of type
E_STRING.  The 1.0.2 stub transmits the following byte stream:
    00 00 00 01 00 06 XX XX 00 00 00 02 ....
where XX are fill bytes, 00 00 00 01 identifies the structure's node,
00 06 is the type field, 00 00 00 02 identifies the string's node, and
the .... is the encoding of the string.
The 1.0.3 stub sends:
    00 00 00 01 XX XX XX XX 00 06 XX XX 00 00 00 02 ....
ie: the 1.0.3 stub appears to be aligning the union to 8 bytes.  And
sure enough, in the marshalling table emitted by the 1.0.3 compiler,
there is an IDL_NDR_ALIGN_8 just before the IDL_DT_ENC_UNION
directive.  Presumably, the new idl compiler decided to align the
union to the largest possible member.  As a check, I changed the
IDL_NDR_ALIGN_8 to a IDL_NDR_ALIGN_2 (which acts as a noop in this
particular case), and the 1.0.3 stub started inter-operating with the
1.0.2 stub.
My reading of chapter 14 of the AES ("Transfer Syntax NDR") makes me
think we're only supposed to align primitive items.  I think the 1.0.2
compiler did the right thing, and the 1.0.3 compiler is broken.  But I
need an informed opinion.  Which encoding is right?  And the harder
question, if the 1.0.3 compiler is broken, what do we do about all the
broken compilers out there?
Thanks for any help you can give me!
        Dan
Dan Nydick
DCE Maintenance Team                    Transarc Corp.
(412)338-6962                           707 Grant Street
nydick@transarc.com                     Pittsburgh, PA 15219
Added field Transarc Herder with value `andi' 
Added field Transarc Status with value `'

[2/23/95 public]
Sorry, I don't have anything to do with RPC or IDL.  I just happened to
be sent the above mail on the topic from Transarc.  Unassigning this from
myself so someone in the RPC/IDL support area will reassign it.

[3/2/95 public]
People would expect the AES to specify what kind of alignment should happen
in this case. Unfortunately, the published 1.0.3 AES RPC only says something
for primitive types (Section 14.2.2).

I checked the latest AES source and found the following extra about
alignment (sorry, but I am not going to format it):

--- start to quote ---
.H 3 "Alignment of Constructed Types"
.iX "NDR constructed types" "alignment"
.P
The octet-stream representation of an NDR constructed type is a
sequence of representations of NDR primitive types. For most
constructed types, each primitive in the representation of the
constructed type is NDR-aligned according to the description in
Subsection 14.1.2.  However, for structures, NDR defines more than one
alignment.
.P
Alignment gaps can appear in the octet stream before and/or within
the sequence of primitives that represents a constructed type.
.H 4 "Alignment of Structures"
.iX "NDR constructed types" "structure alignment"
.P
NDR defines aligned and unaligned structures. The representations
of an aligned structure and an unaligned structure differ only in
the alignment required for the first primitive in the representation
of the structure.
.P
The first primitive in an aligned structure is represented in the NDR
octet stream at an alignment equal to the greatest of the alignments
that would apply to the members of the structure. That is, if the
largest element has size \*Vn\*O, then the first scalar is aligned at
an octet stream index that is a multiple of \*Vn\*O.  The first
primitive in an unaligned structure is represented in the NDR octet
stream at the alignment that would apply to the first member of the
structure.
.P
The same alignment rules apply to nested constructed types.  Thus if a
structure contains a substructure, the alignment of the first
primitive in the substructure likewise has the greatest alignment
value of all of the elements of the substructure.

--- end of quote ---

From the above description, it appears that 1.0.2 IDL treats union as an
unaliagned structure, while 1.0.3 IDL treats union as an aligned structure.
But the section for Union still does not say what a union should be treated.

Too bad that we broke compatibility, but really there is no right or wrong
between 1.0.2 idl and 1.0.3/1.1 idl. All we need is one consistent encoding
and one clear doc which says what things should happen.

What to do with this incompatibility? Upgrade to 1.0.3 or 1.1 idl. It does not
make sense tome that we chamge back to the 1.0.2 idl behavior. We will
make this an aes defect. The easiest fix is to add to aes that a union should
be treated as an aligned structure. And a note to document this incompatibility
between earlier (pre 1.0.3) idl and later idl.

[3/21/95 public]
Arthur Harvey informed me that the text I quoted above is actually not quite
right and was removed from the AES (I did not noticed the cS and cE macro
around them for suppression).

OSF is aware of this incompatibility problem and is working with the IDL
folks at DEC to find out what needs to be fixed in the AES regarding NDR
alignment rules. There is a bunch of information about alignment of 
structures which is missing from the NDR chapter. Last I heard, the plan is 
to specify the 1.0.3+ behavior.

[3/20/96 public]
Marked as an AES bug, and assigned to Art Harvey.

[4/4/96 public]
Reassigned (on Art's monition) to Susan Thompson.

[11/25/96 public]

Chapter 14 (NDR) of the CAE Specification has been updated at 1.1 with
NDR alignment rules as per X/Open Corrigenda U010.  No plans at this
time for updates to the AES.

[12/14/96 public]

Closed.



CR Number                     : 12609
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : dg
Short Description             : Wrapped fragnum may cause the segmentation fault
Reported Date                 : 10/12/94
Found in Baseline             : 1.1
Found Date                    : 10/12/94
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1maint, 1.2.1
Affected File(s)              : rpc/runtime/dgcall.c
                                             rpc/runtime/dglsn.c
Sensitivity                   : public

[10/12/94 public]

If the fragment number wraps and it's a part of the selective ACK, it may
cause the SIGSEGV in rpc__dg_call_xmit_fack()::dgcall.c . The offending
code is:

  shift = rqe_p->hdrp->fragnum - (unsigned16) rq->next_fragnum;

For instance, if rqe_p->hdrp->fragnum == 1 and rq->next_fragnum == 65530,
shift becomes (unsigned32)4294901767 instead of 7. The fix is simple:

  shift = (unsigned16)(rqe_p->hdrp->fragnum - rq->next_fragnum);

Also, do_selective_ack()::dglsn.c doesn't handle the wrapped fragment
number. The type of selack_fragnum should be changed to unsigned16.

[11/14/95 public]

N SUBMISSION REQUEST-----------------------
OT CR #:       12609 

OT Summary:      fragnum wraparound not handled correctly

Components:     rpc

Fix summary:   Add proper casts 

Files modified: dgcall.c dglsn.c

How tested:     Compile on hp800

Platforms:   all

Tested against: 1.1GA + unintegrated + Warranty Patch

How to verify:  Code review

Diff:           

*** dgcall.c    Mon Oct 30 23:45:18 1995
--- ../../../link/src/rpc/runtime/dgcall.c      Thu Aug 25 17:54:08 1994
***************
*** 423,429 ****
               *                *maskp &= 1 << shift;
               */
  
!             shift = (unsigned16)(rqe_p->hdrp->fragnum - rq->next_fragnum);
              *(maskp + (shift/32)) |= 1 << (shift%32);
              rqe_p = rqe_p->next;
          }
--- 423,429 ----
               *                *maskp &= 1 << shift;
               */
  
!             shift = rqe_p->hdrp->fragnum - (unsigned16) rq->next_fragnum;
              *(maskp + (shift/32)) |= 1 << (shift%32);
              rqe_p = rqe_p->next;
          }
*** dglsn.c     Mon Oct 30 23:48:47 1995
--- ../../../link/src/rpc/runtime/dglsn.c       Thu Aug 25 17:54:14 1994
***************
*** 2094,2102 ****
      rpc_dg_fackpkt_body_p_t bodyp = (rpc_dg_fackpkt_body_p_t) &rqe->pkt->body;      rpc_dg_xmitq_elt_p_t xq_curr, xq_prev, rexmitq_tail;
      rpc_dg_xmitq_p_t xq = &call->xq;
!     unsigned32 mask, i, j, *selack;
      unsigned16 selack_len, curr_serial = (unsigned16) serial_cnt;
-     unsigned16 selack_fragnum ;
  
      RPC_DG_CALL_LOCK_ASSERT(call);
  
--- 2094,2101 ----
      rpc_dg_fackpkt_body_p_t bodyp = (rpc_dg_fackpkt_body_p_t) &rqe->pkt->body;      rpc_dg_xmitq_elt_p_t xq_curr, xq_prev, rexmitq_tail;
      rpc_dg_xmitq_p_t xq = &call->xq;
!     unsigned32 mask, selack_fragnum, i, j, *selack;
      unsigned16 selack_len, curr_serial = (unsigned16) serial_cnt;
  
      RPC_DG_CALL_LOCK_ASSERT(call);
  

--------END SUBMISSION REQUEST-------------------

[12/19/95 public]
Included in DCE 1.2.1
Closed



CR Number                     : 12572
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : auth
Short Description             : rpc__krb_get_tkt() is not cancel safe
Reported Date                 : 10/10/94
Found in Baseline             : 1.1
Found Date                    : 10/10/94
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1, 1.1maint
Affected File(s)              : rpc/runtime/krbclt.c
Sensitivity                   : public

[10/10/94 public]

rpc__krb_get_tkt()::krbclt.c is not cancel-safe and can leave the mutex
(krb_info mutex) locked. This can be easily re-produced by running perf
test #15 (Static Cancel test) with the short server ticket lifetime to
force the ticket refresh for each RPC. Here is the scenario:

1) The first RPC gets cancelled in sec_krb_get_cred(). This leaves
   krb_info->cred_fetching set to true.

2) The second RPC does conditional-wait on krb_info->cond because
   krb_info->cred_fetching is set. And it gets cancelled there, which
   leaves krb_info->lock mutex locked.

3) The third RPC can't lock krb_info->lock in rpc__krb_dg_pre_call().
   (cma__bugcheck() if CMA is built with -UNDEBUG.)

[10/10/94 public]

Of course, the above scenario can happen in CN, too. Just replace
rpc__krb_dg_pre_call() with rpc__krb_cn_cred_refresh().

[12/19/95 public]
Fixed in DCE 1.2.1
Closed

[1/26/96 public]
Submitted to 1.1 maint.

	Test procedures:

		1. create an account for perf_server with maxtktlife as 1 sec.
		2. run the server as:
		   ./server -p 1,perf_server 5 all
		3. run the client as (Important: multiple passes!!!)
		   ./client -p 1,2,3,perf_server 15 STRING_BINDING 5 y/n
		4. You should see the CMA error at second pass

Diff:		

*** /project/dce/build/dce1.1-maint/src/rpc/runtime/krbclt.c	Mon Aug 15 15:04:54 1994
--- krbclt.c	Thu Jan 11 13:44:21 1996
***************
*** 114,120 ****
      while (krb_info->cred_fetching) {
          RPC_DBG_PRINTF(rpc_e_dbg_auth, 3, 
              ("(rpc__krb_get_tkt) waiting for someone else\n"));
!         RPC_KRB_INFO_COND_WAIT(krb_info);
      }
      if (krb_info->creds_valid) {
          RPC_DBG_PRINTF(rpc_e_dbg_auth, 3, 
--- 114,140 ----
      while (krb_info->cred_fetching) {
          RPC_DBG_PRINTF(rpc_e_dbg_auth, 3, 
              ("(rpc__krb_get_tkt) waiting for someone else\n"));
! 	TRY
! 	    RPC_KRB_INFO_COND_WAIT(krb_info);
!         CATCH(pthread_cancel_e)
! 	    st = rpc_s_call_cancelled;
!         CATCH_ALL
! 	    /* 
! 	     * Any other type of exception is something serious.
! 	     */
! 	    /*
! 	     * rpc_m_unexpected_exc
! 	     * "(%s) Unexpected exception was raised"
! 	     */
! 	    RPC_DCE_SVC_PRINTF ((
! 		DCE_SVC(RPC__SVC_HANDLE, "%s"),
! 	        rpc_svc_recv,
! 	        svc_c_sev_fatal | svc_c_action_abort,
! 		rpc_m_unexpected_exc,
! 		"rpc__krb_get_tkt" ));
!         ENDTRY
!         if (st != rpc_s_ok)
! 	    return st;
      }
      if (krb_info->creds_valid) {
          RPC_DBG_PRINTF(rpc_e_dbg_auth, 3, 
***************
*** 132,137 ****
--- 152,162 ----
           */
          RPC_DBG_PRINTF(rpc_e_dbg_auth, 3, 
              ("(rpc__krb_get_tkt) fetching credentials\n"));
+ 	/* 
+ 	 * We should probably disable general cancellability here because the
+ 	 * security runtime's state is unknown if it gets cancelled...
+ 	 */
+ 	TRY
          st = sec_krb_get_cred (krb_info->auth_info.u.auth_identity,
              krb_info->server,
              krb_info->auth_info.authn_level,
***************
*** 151,156 ****
--- 176,199 ----
                  ("(rpc__krb_get_tkt) fetch succeeded\n"));
              krb_info->creds_valid = 1;
          }
+         CATCH(pthread_cancel_e)
+ 	    RPC_KRB_INFO_LOCK (krb_info);
+ 	    st = rpc_s_call_cancelled;
+         CATCH_ALL
+ 	    /* 
+ 	     * Any other type of exception is something serious.
+ 	     */
+ 	    /*
+ 	     * rpc_m_unexpected_exc
+ 	     * "(%s) Unexpected exception was raised"
+ 	     */
+ 	    RPC_DCE_SVC_PRINTF ((
+ 		DCE_SVC(RPC__SVC_HANDLE, "%s"),
+ 	        rpc_svc_recv,
+ 	        svc_c_sev_fatal | svc_c_action_abort,
+ 		rpc_m_unexpected_exc,
+ 		"rpc__krb_get_tkt" ));
+         ENDTRY
          krb_info->cred_fetching = 0;
          RPC_KRB_INFO_COND_BROADCAST(krb_info);
      }
***************
*** 192,197 ****
--- 235,244 ----
  
      RPC_MEM_ALLOC (krb_info, rpc_krb_info_p_t, sizeof(*krb_info),
                     RPC_C_MEM_UTIL, RPC_C_MEM_WAITOK);
+     if (krb_info == NULL){
+ 	*stp = rpc_s_no_memory;
+ 	return;
+     }
  
      memset (krb_info, 0, sizeof(*krb_info));
      
***************
*** 239,244 ****
--- 286,295 ----
          }
  
      krb_info->auth_info.server_princ_name = rpc_stralloc(server_name);
+     if ((krb_info->auth_info.server_princ_name == NULL) && server_name != NULL){
+ 	st = rpc_s_no_memory;
+ 	goto poison;
+     }
      krb_info->auth_info.authn_level = level;
      krb_info->auth_info.authn_protocol = rpc_c_authn_dce_private;
      krb_info->auth_info.authz_protocol = authz_prot;



CR Number                     : 12540
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : dg
Short Description             : UHYP: wrapped fragnum => tkt_expired error
Reported Date                 : 10/6/94
Found in Baseline             : 1.1
Found Date                    : 10/6/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1, 1.1maint
Affected File(s)              : dg.c dgexec.c krbdgcom.c noauthdg.c dg.h dgrq.c krbdgp.h noauthdg.h
Diff supplied by              : 
Diff release                  : 
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : 

[10/6/94 public]
Jeff Prem diagnosed this one.
 
If you ship lots of bits through a pipe, the ``fragnum'' field can
wrap back to zero.  The code in rpc__krb_dg_recv_ck (in krbdgcom.c)
contains the following clause:
    /*
     * Check for authentication expiration.
     *
    if (krb_key->c.is_server &&
        level > rpc_c_authn_level_none &&
        hdrp->fragnum == 0 &&
        rpc__clock_unix_expired(krb_key->expiration+5*60))
    {
        RPC_DBG_GPRINTF(("(rpc__krb_dg_recv_ck) authentication expired\n"));
        st = rpc_s_auth_tkt_expired;
        goto out;
    }
 
Now, the service ticket was set up when the RPC started, and if the
fragnum wrapped, that was likely to have been some time ago.  Thus,
it's likely that after a wrap that ticket has expired, though it was
OK the first time the fragnum was zero.  This happens a lot when we
try to replicate a 700 megabyte fileset.  It happens even more when
the PTGT lifetime is set low for testing/stress purposes!
 
I don't know if the right thing to do is to re-issue an authentication
challenge or somehow to sense that this isn't really the first frag in
the RPC any more.  Maybe there's already a data structure to check,
but without a lot more research (or existing knowledge) that's a bit
hard to determine.

[10/6/94 public]
Changed Interest List CC from `jdp@transarc.com' to `jdp@transarc.com, 
 dce-ot-dfs'

[10/6/94 public]
Unfortunately, DG runtime doesn't keep track of wrapped fragnum. Re-issuing
an authentication challenge, WAY-auth, is probably the right thing (as long
as the encryption key doesn't change), but it requires many code changes.
So simpler fix is to make the above expiration check for the real first
fragment only. If anyone is interested, I have checked in my fix (which I
will test tomorrow if the build succeeds) into tatsu_s_fix12540 branch at
OSF.
  ./rpc/runtime/dg.h      1.1.599.2
  ./rpc/runtime/krbdgp.h  1.1.620.2
  ./rpc/runtime/noauthdg.h        1.1.515.2
  ./rpc/runtime/dg.c      1.1.918.2
  ./rpc/runtime/dgexec.c  1.1.103.2
  ./rpc/runtime/dgrq.c    1.1.615.2
  ./rpc/runtime/krbdgcom.c        1.1.819.2
  ./rpc/runtime/noauthdg.c        1.1.614.2

[10/7/94 public]
This has been identified as something that should be submitted to
the unintegrated tree for 1.1.

[10/7/94 public]
The fix doesn't break anything on HP-UX, but I don't have the test
environment to force the wrapped fragnum. Can Transarc test this?

[10/10/94 public]
As far as I know, we don't have the 1.1 code here yet, so while I'd be happy
to test the fix, I don't have the build environment to do so.  If this can
wait until we start building 1.1 code here, I'll try it out then; if not,
I can supply the test.  The test consists of only two source files and an IDL
file, so there isn't much complexity in building and running the test.
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `'

[10/12/94 public]
 
Is this still UHYP:A0? It seems to me that nobody is blocked by this and
nobody has the testing resource.

[10/12/94 public]
Jeff offered the test, which doesn't depend on DFS, so if one of you folks
who has access to an installed version of the current unintegrated build
wants to run Jeff's test, it might be more satisfying than just assuming
that the fix works.  To whom should Jeff Prem (jdp@transarc.com) send the
three files?
 
Not to say that we're not quite happy with the excellent work and the
turn-around time for this bug!!!

[10/13/94 public]
I have volunteered to run the test provided by Transarc on the HP fixes.
If all goes well, I will request HP to submit them to the unintergrated
tree next week.

[10/19/94 public]
Code is in the unintegrated tree.
Marked fixed in 1.1unintegrated.

[12/19/95 public]
Fixed in DCE 1.2.1
Closed

[09/19/96 public]
Marc Levy added this to the 1.1maint tree in 02/95.



CR Number                     : 12318
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc
Short Description             : cds/rpc 486 core smoketest fails
Reported Date                 : 9/23/94
Found in Baseline             : 1.1
Found Date                    : 9/23/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b19
Affected File(s)              : ./admin/dcecp/dts_util.c
./dce/AT386/dce.h
./dce/HP800/dce.h
./dce/PMAX/dce.h
./dce/RIOS/dce.h
./dce/SVR4/dce.h
./dce/utils/misc/dce64.h
./time/common/arith.c
./time/common/dtssmacros.h
./time/common/utc_arith.h
./time/common/utcapi.c
./time/libutc/user/utc_adjtime_user.c
./time/libutc/user/utc_gettime_user.c
./time/service/clock_adjust.c
./time/service/clock_adjust_ultrix.c
./time/service/dtss_service_main.c
./time/service/mgtrpc.c
./time/service/time_request.c
./time/service/timers.c
Sensitivity                   : public

[9/23/94 public]

The AT486 core smoketest failed, due, we believe to a problem in rpc
that affects cdsd.  Here is the relevant section of the smoketest log: 

:****** Starting cdsadv...
1994-09-23-15:13:07.434+00:00I----- cdsadv(775) FATAL cds adver dceassert.c
63 0
x0057a598
Assertion "0 <= utc_status" failed in
"/project/dce/build/dce1.1-snap/src/direct
ory/cds/adver/adver_cache.c"file> line <
174
S:****** Starting cdsd...
1994-09-23-15:13:43.921+00:00I----- cdsd(783) FATAL cds adver dceassert.c
63 0x0
05d4d78
Assertion "status >= 0" failed in
"/project/dce/build/dce1.1-snap/src/directory/
cds/library/unix_time.c"file> line <360
ERROR:   cdsd failed to start
+ cd /u1/RAT_tools
+ rm -rf /u1/RAT_tools/run_commands.log.previous
+ mv /u1/RAT_tools/run_commands.log /u1/RAT_tools/run_commands.log.previous
+ /u1/opt/dcelocal/bin/dce_login cell_admin -dce- -exec
/u1/RAT_tools/run_comman
ds
+ 1> /u1/RAT_tools/run_commands.log 2>& 1
+ cat /u1/RAT_tools/run_commands.log
Password must be changed!
cdscp show server
Connection request rejected (dce / rpc)
Communications failure (dce / rpc)
Communications failure (dce / rpc)
Communications failure (dce / rpc)
cdscp show dir /.:

                        SHOW
                   DIRECTORY   /.../sif_cell
                          AT   1994-09-23-15:14:42
Error on entity: /.../sif_cell
Error with socket
Function: dnsEnumAttr

cdscp list dir /.:
                        LIST
                   DIRECTORY   /.../sif_cell
                          AT   1994-09-23-15:14:42
cdscp show clearinghouse /.:/sif_ch

                        SHOW
               CLEARINGHOUSE   /.../sif_cell/sif_ch
                          AT   1994-09-23-15:14:42
Error on entity: /.../sif_cell/sif_ch
Error with socket
Function: dnsEnumAttr

invoking dcecp smoke test
Error with socket
dcecp returned value is:
DONE

[9/23/94 public]
Problem was submission from Janet at DEC that caused the UTC api
to croak on little-endian machines (486).
Backed out changes, and verified that 486 configs with new libdce
and dts functional test rantest_api runs on all three platforms.

[10/18/94 public]
Things are back to the way they were.
Closed.



CR Number                     : 12207
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl_compiler
Short Description             : silence an ANSI complaints
Reported Date                 : 9/15/94
Found in Baseline             : 1.1
Found Date                    : 9/15/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b18
Affected File(s)              : rpc/idl/idl_compiler/ifspemts.c
Sensitivity                   : public

[9/15/94 public]

IDL generates server stub files that have unsigned32 bit values
that often have the high-bit on, which can cause problems in strict
ANSI environments.  The fix is to explicitly declare the constants as
unsigned.  The following diff fixes the problem:
*** ifspemts.c	Wed Dec 15 13:33:11 1993
--- /tmp/x	Thu Sep 15 11:39:58 1994
***************
*** 174,180 ****
      fprintf( fid, "\nstatic rpc_syntax_id_t IDL_transfer_syntaxes[%d] = {\n{\n",
                                                                   1 );
          fprintf(fid,
! "{0x8a885d04, 0x1ceb, 0x11c9, 0x9f, 0xe8, {0x8, 0x0, 0x2b, 0x10, 0x48, 0x60}},");
          fprintf(fid, "\n2}");
      fprintf(fid, "};\n");
  
--- 174,180 ----
      fprintf( fid, "\nstatic rpc_syntax_id_t IDL_transfer_syntaxes[%d] = {\n{\n",
                                                                   1 );
          fprintf(fid,
! "{0x8a885d04u, 0x1ceb, 0x11c9, 0x9f, 0xe8, {0x8, 0x0, 0x2b, 0x10, 0x48, 0x60}},");
          fprintf(fid, "\n2}");
      fprintf(fid, "};\n");
  
***************
*** 184,192 ****
      fprintf(fid, "  %d, /* if version */\n", ifp->version);
      fprintf(fid, "  {");
  #ifdef _VMS
!     fprintf(fid, "0x%08.8x, ", ifp->uuid.time_low);
  #else
!     fprintf(fid, "0x%08.8lx, ", ifp->uuid.time_low);
  #endif
      fprintf(fid, "0x%04.4x, ", ifp->uuid.time_mid);
      fprintf(fid, "0x%04.4x, ", ifp->uuid.time_hi_and_version);
--- 184,192 ----
      fprintf(fid, "  %d, /* if version */\n", ifp->version);
      fprintf(fid, "  {");
  #ifdef _VMS
!     fprintf(fid, "0x%08.8xu, ", ifp->uuid.time_low);
  #else
!     fprintf(fid, "0x%08.8lxu, ", ifp->uuid.time_low);
  #endif
      fprintf(fid, "0x%04.4x, ", ifp->uuid.time_mid);
      fprintf(fid, "0x%04.4x, ", ifp->uuid.time_hi_and_version);

[9/16/94 public]
Made the fixes Rich details above.



CR Number                     : 12003
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : uuidgen
Short Description             : uuidgen prints hex status code instead of error text
Reported Date                 : 9/1/94
Found in Baseline             : 1.1
Found Date                    : 9/1/94
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b17
Affected File(s)              : uuidgen.c uid.sams
Sensitivity                   : public

[9/1/94 public]

The uuidgen program is very user unfriendly when an error occurs:
	surf>uuidgen -c -t sdf
	The uuid_from_string call failed with the error 0x16c9a08f

This should print out the error text.



CR Number                     : 12001
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : need semi-public interface to get_ep_binding
Reported Date                 : 9/1/94
Found in Baseline             : 1.1
Found Date                    : 9/1/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b17
Affected File(s)              : rpc/runtime/comep.c,rpc/sys_idl/rpc.idl
Sensitivity                   : public

[9/1/94 public]

The dced convenience routiens (dce_server_XXX) need to call get_ep_binding.
Best way to make this happen is to add a one-line function,
rpc_binding_to_epmap, that calls this INTERNAL function.

[09/14/94 public]
Done, built, being used in dced API and dcecp.  Can be closed.



CR Number                     : 11996
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 10052
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rtandidl testdriver.tsh
Short Description             : rtandild testdriver test fail
Reported Date                 : 9/1/94
Found in Baseline             : 1.1
Found Date                    : 9/1/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b17
Affected File(s)              : test/rpc/rtandidl/control/binding.tshrc
Sensitivity                   : public

[9/1/94 public]

Ran the rtandidl tests on HP and 486.
3 testdriver tests fail both tcp and udp:

comtest_bind_to_str_bind 333b91c50000.0d.00.00.87.84.00.00.00@ncacn_ip_tcp:16.20
.16.27[2001] 

Test Number:      6
Routine Tested:   comtest_bind_to_str_bind
Test Status:      %tst-fail: Test FAILED
Status Returned:  Successful completion (dce / svc)

comtest_bind_copy 333b91c50000.0d.00.00.87.84.00.00.00@ncacn_ip_tcp:16.20.16.27[
2001] 

Test Number:      9
Routine Tested:   comtest_bind_copy
Test Status:      %tst-fail: Test FAILED
Status Returned:  Successful completion (dce / svc)

comtest_bind_inq_object 333b91c50000.0d.00.00.87.84.00.00.00@ncacn_ip_tcp:16.20.
16.27[2001] 

Test Number:      11
Routine Tested:   comtest_bind_inq_object
Test Status:      %tst-fail: Test FAILED
Status Returned:  Successful completion (dce / svc)

[9/1/94 public]
The reason the tests are failing is because it is sending in an old-style
uuid and expect to get an old style uuid back out.

With the fix to OT 10052 (never contruct an old style uuid string),
these tests aren't correct.

[9/1/94 public]
Changed binding.tshrc to use new style uuid string.



CR Number                     : 11901
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : interp encoding minor vers num needs to be increased
Reported Date                 : 8/25/94
Found in Baseline             : 1.1
Found Date                    : 8/25/94
Severity                      : B
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b17
Affected File(s)              : idl_compiler/ddbe.h, 
                                             lib/interpsh.c
Sensitivity                   : public

[8/25/94 public]

Along with the code submission for OT 10103, the
interpreter encoding minor version number should
have been increased by one. This number is checked
by the runtime to ensure that the stubs were spelled
by a compatible compiler version.

The encoding minor number is defined in idl_compiler/ddbe.h
Currently the number is 1 and should be increased
to 2.  The runtime routine which checks this number
is rpc_ss_type_vec_vers_check in lib/interpsh.c.
The check should allow versions 3.0 through 3.2.

[8/25/94 public]
Talk about your last minute defects....
Are we sure this will do the right thing?

Did we modify the code enough to justify changing this version number?
What are the compatibility issues involved here?
Will a 1.0.3 idl generate stubs that will work on a 1.1 libdce?
Will a 1.1 idl generate subs that will work with a 1.0.3 libdce?

This will be post freeze, so we need to justify this change.

[8/25/94 public]

My apologies about the timing of this OT,
I just noticed that this was left out today.  

The increase in the minor version number will
allow 1.0.3 stubs to work with a 1.1 runtime
but not vice versa.  Thus, backward compatability
is maintained.  The change is necessary, however,
since a 1.0.3 runtime will not be able to interpret
a 1.1 stub which has a type vector spelled in 
big endian.  This is similar to the way a 1.0.2
runtime cannot handle a 1.0.3 stub.

[8/26/94 public]
I have the changes, I will put them in to the 1.1 base.


====== ./rpc/idl/idl_compiler/ddbe.h
9a10
>  * Bug 11901 - Increase encoding minor version number to 2.
67c68
< #define DDBE_VER_MINOR        1     /* Interpreter encoding minor version */
---
> #define DDBE_VER_MINOR        2     /* Interpreter encoding minor version */
 
 
====== ./rpc/idl/lib/interpsh.c
9a10
>  * Bug 11901 - Accept version 3.2 in rpc_ss_type_vec_vers_check.
1470c1471
<     if ((interp_major_version != 3) || (interp_minor_version > 1))
---
>     if ((interp_major_version != 3) || (interp_minor_version > 2))
1473c1474
<         printf("Expecting data structure version 3.0 or 3.1 - found %d.%d\n",
---
>         printf("Expecting data structure version 3.0, 3.1 or 3.2 - found %d.%d\n",

[8/26/94 public]
Submitted.



CR Number                     : 11770
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000,hppa
S/W Ref Platform              : aix,hpux
Component Name                : rpc
Subcomponent Name             : /rpc/idl/klib
Short Description             : missing include file 'rpcsvc.h
Reported Date                 : 8/19/94
Found in Baseline             : 1.1
Found Date                    : 8/19/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b15
Affected File(s)              : rpc/idl/klib/Makefile
Sensitivity                   : public

[8/19/94 public]

c89 -c        -DGENERIC -DAPPLETALK -DFDDI_VM -DHW_VISIBLE_TBL -D_KERNEL_BUILD -D_UNSUPPORTED -DWSIO_PHYSIO  -DEQUIVMEM -DNGRAF_WS -DSPARSE_PDIR -D_WSIO -DSNAKES_IO -DPA89 -DGETMOUNT -DLOCAL_DISC -DFSS  -DREGION -D_HPUX_SOURCE -DHFS -DAUDIT  -DACLS -DFSD_KI -DPSTAT -DPOSIX -DMP -DLWSYSCALL -DICA_ON -DRDB -DEQUIVMEM -DSYSCALLTRACE  -DBSDJOBCTL -DQUOTA -DFPC_BUG -DNSYNC -DTEAC_FLOPPY -DAUTOCHANGER -D_PA_RISC_1_1 -DTIMEX_BUG -DTIMEX -DHP_DFS -D_KERNEL -DKERNEL -DIDL_LIB_FLAG -DMIA -D__hppa -Dhp9000s800 -Dhp9000s700 -D__hp9000s800 -D__hp9000s700 -DHPUX -D__hpux -Dunix +DA1.0 -D_HPUX_SOURCE    -I. -I/u3/devobj/sb/nb_ux/src/rpc/idl/klib -I/project/dce/build/dce1.1-snap/src/rpc/idl/klib  -I../lib -I/u3/devobj/sb/nb_ux/src/rpc/idl/lib -I/project/dce/build/dce1.1-snap/src/rpc/idl/lib -I/project/dce/build/hp_kinc/hp800 -I/u3/devobj/sb/nb_ux/export/hp800/usr/include -I/project/dce/build/dce1.1-snap/export/hp800/usr/include    /project/dce/build/dce1.1-snap/src/rpc/idl/lib/ctxeecli.c
ctxeecli.c: 111: Unable to find include file 'rpcsvc.h'.
*** Error code 1

[8/19/94 public]
Added CFLAGS and INCFLAGS to the klib Makefile



CR Number                     : 11719
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : uuidgen
Short Description             : uuidgen's sams file needs newlines
Reported Date                 : 8/16/94
Found in Baseline             : 1.1b14
Found Date                    : 8/16/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b15
Affected File(s)              : rpc/idl/uuidgen/uid.sams
Sensitivity                   : public

[8/16/94 public]
uuidgen prints its help message as one long string.  The fix: put newlines
at the end of the appropriate text fields in uuidgen/uid.sams.
(dce_printf no longer adds a newline to messages.)

[8/16/94 public]
Added newlines.



CR Number                     : 11707
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : cn
Short Description             : CN RPC authentication
Reported Date                 : 8/15/94
Found in Baseline             : 1.0.3
Found Date                    : 8/15/94
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b17
Affected File(s)              : rpc/runtime/cnrcvr.c cncassm.c
cnp.h
Sensitivity                   : private

[8/15/94 public]
Please see problem description in :

/afs/dce.osf.org/project/dce/dec/b_burton

Thanks
Bob Burton

[8/15/94 public]
Just to make life easier for everyone here is the problem description:

There appears to be a security opening in the DCE RPC.
This problem exists in the CN code and it seems to exist
in DG also.  Here's the scenario:

A client begins an RPC, (which authentication being requested),
to a server over one of the CN transport protocols.
The association between client/server gets set up
normally with the client sending a BIND packet which contains
security credentials.  Then he server responds with a BIND_ACK
which also contains security credentials.  So far, everything
is normal.  A security context is entered for this assoc, (see
below).

{
          .
          .
          .
    rpc_cn_assoc_sec_context_t          security;   <====== SECURITY CONTEXT
    rpc_cn_fragbuf_p_t                  raw_packet_p;
} rpc_cn_assoc_t, *rpc_cn_assoc_p_t;

NOW:  We proceed with the rest of the RPC.  The client sends the server
a REQUEST packet which contains a authentication trailer.  Now suppose
the server, (this is the bug), sends back a RESPONSE packet which also
contains an authentication trailer but whose packet header field,
"auth_len",  for some unknown reason contains "0".  This packet header
field, "auth_len", being something other than zero is the only
indication which the client has to know that authentication is being
requested.  In function, "receive_dispatch()", cnrcvr.c, we have a
macro, "RPC_CN_PKT_AUTH_TLR_PRESENT()"
        /*
         * Determine whether the received PDU contains an
         * authentication trailer.  We don't care about byte
         * ordering in the following macro invocation because
         * the trailer length is compared with zero to determine
         * whether or not the trailer is present.
         */
        if (RPC_CN_PKT_AUTH_TLR_PRESENT (pktp))
        {
            .
            .
            .
         }

This simply tests the packet header field "auth_len".  If it is "0"
it concludes that there is no authentication in force for this RPC,
and accepts the packet; actually it accepts all of the remaining packets
in the current RPC.

At first a fix seems rather strait-forward, but further examination
reveals that, while many solutions are obvious, one which won't
introduce a performance degradation isn't so obvious.

It seems like just checking the "security" field in the "sturct
rpc_cn_assoc_t", would be easy, but this is a linked list of security
contexts and what's worse, it requires unpacking the security key from
out of the authentication trailer on the packet, but we don't know it's
length.  Even if you did, you would have to run a rather cumbersome
check on EVERY packet which goes by.  The only other place, to check
to see if authentication is in force for this RPC is the 'call_rep',
which we do later in this same function - this looks for the moment like
the most viable solution.

[8/15/94 public]

I don't think this problem exists in DG. In DG, the authentication checking
(auth_trailer length checking and rpc__krb_dg_recv_ck()) is enforced if the
client call rep has the key_info.

In the CN client receiver thread, i.e., receive_dispatch(), and
mark_syntax_and_sec_action_rtn()::cncassm.c, we can probably use
assoc->call_rep->binding_rep->auth_info to check if the authenticated rpc
is requested or not. If the auth rpc is requested and
RPC_CN_PKT_AUTH_TLR_PRESENT() is false, then someone is playing with us.
(The CR9549 fix, just submitted, comes in handy because
binding_rep->auth_info tells us the real authn_level iff needed. But, I
think that we only need to know if auth_info is not NULL.)

Note: The association is allocated for the client call rep in
rpc__cn_assoc_request()::cnassoc.c. Thus, the client assoc->call_rep
shouldn't be NULL.

[8/16/94 public]

Just to make things clear, DG does not have this problem.

[8/16/94 public]
Since Prasad was kind enough to provide us with the 9549 fix, 
he has volunteered to fix this one.
Its not holding anyone up, so its a P1.

[8/24/94 public]
The following change in cnrcvr.c should fix the problem.
My question is: what should be the status set to? I am
setting this to rpc_s_invalid_checksum at present.

905a906,924
>         else
>         {
>             if ((assoc->assoc_flags & RPC_C_CN_ASSOC_CLIENT) &&
>                         (ptype == RPC_C_CN_PKT_RESPONSE) &&
>                         (assoc->call_rep->binding_rep->auth_info))
>             {
>                 RPC_DBG_PRINTF (rpc_e_dbg_general, RPC_C_CN_DBG_GENERAL,
>                         ("CN: Client assoc PDU type %d\n", ptype));
>                 RPC_DBG_PRINTF (rpc_e_dbg_general, RPC_C_CN_DBG_GENERAL,
>                         ("CN: auth_info %x\n", assoc->call_rep->binding_rep->auth_info));
>                 RPC_DBG_PRINTF (rpc_e_dbg_general, RPC_C_CN_DBG_GENERAL,
>                         ("CN: should not continue further with this PDU\n"));
>                 (*fragbuf_p->fragbuf_dealloc)(fragbuf_p);
>                 /* ??? think of the correct status */
>                 st = rpc_s_invalid_checksum;
>                 RPC_CN_ASSOC_WAKEUP (assoc);
>                 break;
>             }
>         }

[8/24/94 public]

Do what dg rpc does:

    if (level != krb_key->c.authn_level)  {
        st = rpc_s_authn_level_mismatch;
        goto out;
    }

[8/25/94 public]

fix submitted with the status set to rpc_s_authn_level_mismatch.

[8/25/94 public]

Why not fix the same hole in the BIND exchange
(mark_syntax_and_sec_action_rtn()::cncassm.c)?

[8/29/94 public]
same fix can be applied for bind - bind-ack exchange.

Is the fix necessary for alert_context exchange?

If necessary, then the above fix will not be sufficient - 
eg.
if an authenticated association is just trying to modify
the presentation context, the auth-len will be zero
in auth_conext_resp. (assoc->call_rep->binding_rep->auth_info
will not be NULL).

[8/30/94 public]

Prasad is right about the alter_context/_resp exchange. It's unfortunate
that the assoc state doesn't keep the sec_context requested in the
alter_context PDU. To fix it, we'll need to have a flag in the
rpc_cn_assoc_t to indicate that the security context negotiation has been
requested (probably set in send_pdu()::cncassm.c) and check that flag (and
reset) in mark_syntax_and_sec_action_rtn().

Do we need to fix the alter_context/_resp exchange? I think so. The client
credential refresh also causes the alter_context/_resp exchange and if we
don't fix it we won't know whether the server is doing the right thing or
not.

By the way, we should use
RPC_CN_AUTH_REQUIRED(assoc->call_rep->binding_rep->auth_info) instead of
just checking the NULL pointer.

[8/30/94 public]

Actually I have been testing since yesterday, with identical changes 
as you detailed - by using an additional flag in assoc structure - 
I can bring up the cell etc.; But few of the authentications tests
in rtandidl fail - Still to identify the problem.

[8/25/94 public]

fix submitted for bind/bind-ack exchange and alter_context_req/resp
exchange.



CR Number                     : 11627
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : idl functional tests core dump
Reported Date                 : 8/9/94
Found in Baseline             : 1.1b14
Found Date                    : 8/9/94
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b15
Affected File(s)              : ndrmi2.c
Sensitivity                   : public

[8/9/94 public]

The idl functional tests core dump, starting with the 'arrayp' test.
The backtrace is as follows:

#0  0xa4267695 in rpc_ss_mem_item_free (handle=0xbffff820, 
    data_addr=0x4052c0 "")
    at /project/dce/build/dce1.1-baseline/bl-14/src/rpc/idl/lib/allocate.c:336
#1  0xa4294c65 in rpc_ss_ndr_m_dfc_arr_ptees (defn_index=363, 
    array_addr=0x4bd03c, struct_addr=0x0, struct_offset_vec_ptr=0x0, flags=0, 
    IDL_msp=0xbffff70c)
    at /project/dce/build/dce1.1-baseline/bl-14/src/rpc/idl/lib/ndrmi2.c:878
#2  0xa4297148 in rpc_ss_ndr_marsh_union_ptees (defn_vec_ptr=0x40529c "", 
    switch_value=1, body_addr=0x4bd03c, IDL_msp=0xbffff70c)
    at /project/dce/build/dce1.1-baseline/bl-14/src/rpc/idl/lib/ndrmi3.c:409
#3  0xa429745a in rpc_ss_ndr_m_enc_union_or_ptees (union_addr=0x4bd038, 
    defn_index=316, pointees=1 '\001', IDL_msp=0xbffff70c)
    at /project/dce/build/dce1.1-baseline/bl-14/src/rpc/idl/lib/ndrmi3.c:484
#4  0xa42941b1 in rpc_ss_ndr_m_struct_pointees (struct_type=15 '\017', 
    defn_index=300, struct_addr=0x4bd034, IDL_msp=0xbffff70c)
    at /project/dce/build/dce1.1-baseline/bl-14/src/rpc/idl/lib/ndrmi2.c:614
#5  0xa42948fb in rpc_ss_ndr_m_f_or_c_arr_ptees (array_addr=0x4bd034, 
    dimensionality=1, bounds_list=0x4b6cc0, defn_vec_ptr=0x405280 "\001", 
    IDL_msp=0xbffff70c)
    at /project/dce/build/dce1.1-baseline/bl-14/src/rpc/idl/lib/ndrmi2.c:777
#6  0xa4294c1c in rpc_ss_ndr_m_dfc_arr_ptees (defn_index=275, 
    array_addr=0x4bd000, struct_addr=0x0, struct_offset_vec_ptr=0x0, flags=16, 
    IDL_msp=0xbffff70c)
    at /project/dce/build/dce1.1-baseline/bl-14/src/rpc/idl/lib/ndrmi2.c:872
#7  0xa4290766 in rpc_ss_ndr_marsh_interp (IDL_parameter_count=1, 
    IDL_type_index=184, IDL_param_vector=0xbffff5fc, IDL_msp=0xbffff70c)
    at /project/dce/build/dce1.1-baseline/bl-14/src/rpc/idl/lib/ndrmi.c:1966


The code is:

In ndrmi2.c (rpc_ss_ndr_m_dfc_arr_ptees())
878   rpc_ss_mem_item_free(&IDL_msp->IDL_mem_handle, (byte_p_t)bounds_list);

data_addr == &IDL_msp->IDL_mem_handle

In allocate.c (rpc_ss_mem_item_free())
325     {
326         header *this = *(header **)((char *)data_addr - GAP);
...

336         if (this->next) this->next->prev = this->prev;

(gdb) p this
$1 = (struct header *) 0x16b

I will test bl-13 to see if the recent change Rico made to allocate.c
affects this.  There was only this and a typdef change (that I made).

[8/9/94 public]
Ran with bl-13 and the same thing happens:

root@tsunami % ./run_tests 1 arrayp
Running arrayp test
./run_tests: 25887 Memory fault - core dumped
./run_tests: 25880 Hangup
Successes 0; Failures 1; Not run 0

>trace
 0 rpc_ss_mem_item_free@libdce + 0x00000008 (hp-ux export stub)
 1 $RECOVER_END + 0x1d1ff150 (0x13c, 0x2708180b, 0x1, 0x12c)
 2 _fp_status + 0x00000008 (Address not found (UE302)

Now I'm really stumped.
Memory corruption by some other part of rpc?

[8/10/94 public]
Caused by missing braces in the code given to OSF by HP:

====== rpc/idl/lib/ndrmi2.c
*** /project/dce/build/dce1.1/src/rpc/idl/lib/ndrmi2.c	Wed Jul 13 14:56:19 1994
--- rpc/idl/lib/ndrmi2.c	Wed Aug 10 10:51:38 1994
***************
*** 7,12 ****
--- 7,13 ----
   */
  /*
   * HISTORY
+  * Bug 11627 - Fix missing braces in rpc_ss_ndr_m_dfc_arr_ptees.
   * $Log:	c011627,v $
# Revision 1.4  94/09/22  15:59:11  root
# changed fields: Status  
# 
# Revision 1.3  94/08/10  13:34:20  root
# changed fields: Status  Fixed In Baseline  Affected File(s)   new/changed/deleted note(s) [tom 8/10/94 public]
# 
   * Revision 1.1.6.3  1994/07/13  18:56:18  tom
   * 	Merged with changes from 1.1.6.2
***************
*** 872,879 ****
--- 873,882 ----
      rpc_ss_ndr_m_f_or_c_arr_ptees( array_addr, dimensionality, bounds_list,
                                    defn_vec_ptr, IDL_msp );
      if (IDL_msp->IDL_type_vec[TVEC_INT_REP_OFFSET] == NDR_LOCAL_INT_REP)
+     {
  	if (IDL_M_FLAGS_TEST(flags,IDL_M_CONF_ARRAY))
  	  rpc_ss_mem_item_free(&IDL_msp->IDL_mem_handle, (byte_p_t)bounds_list);
+     }
      else 
  	rpc_ss_mem_item_free(&IDL_msp->IDL_mem_handle, (byte_p_t)bounds_list);
  }
***************
*** 1065,1073 ****
--- 1068,1078 ----
      rpc_ss_mem_item_free(&IDL_msp->IDL_mem_handle, (byte_p_t)range_list);
      rpc_ss_mem_item_free(&IDL_msp->IDL_mem_handle, (byte_p_t)Z_values);
      if (IDL_msp->IDL_type_vec[TVEC_INT_REP_OFFSET] == NDR_LOCAL_INT_REP)
+     {
  	if (IDL_M_FLAGS_TEST(flags,IDL_M_CONF_ARRAY))
  	    rpc_ss_mem_item_free(&IDL_msp->IDL_mem_handle, 
  				 (byte_p_t)bounds_list);
+     }
      else 
  	rpc_ss_mem_item_free(&IDL_msp->IDL_mem_handle, (byte_p_t)bounds_list);



CR Number                     : 11604
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : dg
Short Description             : Inadequate DG stale BH detection
Reported Date                 : 8/8/94
Found in Baseline             : 1.1b14
Found Date                    : 8/8/94
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b15
Affected File(s)              : dglsn.c
Sensitivity                   : public

[8/8/94 public]

(This proposal was already circulated on dce-tech.)

Currently, when there are no compatible servers registered in the EP map
(and the call is not being directed at the rpcd/dced itself), the DG call
request is simply dropped.  The client then retransmits several times
(each of which is dropped by the rpcd), before faulting the call with a
comm failure.  This exchange takes 30 seconds by default.

The right way to fix this requires a protocol change, and will probably
be done for 1.2.  In the meantime, we can make life a little more pleasant 
for existing clients:

There already exists a nca_s_comm_failure reject status, which gets mapped
by DG clients into the rpc_s_comm_failure status code.

Since a client that uses a stale handle is going to see a comm failure
(eventually), we can just make the dced provide this information (immediately)
by sending back a nca_s_comm_failure reject.

The behavior on the client will be identical, the call will be faulted with
a comm failure.  The only difference is that the client won't actually have
to sit through the timeout.



CR Number                     : 11578
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 8443
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : svc
Short Description             : dce_error_inq_text(3dce) man page in App Rff should not mention NLSPATH
Reported Date                 : 8/5/94
Found in Baseline             : 1.1
Found Date                    : 8/5/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : dce_error_inq_text(3dce)
Sensitivity                   : public

[8/5/94 public]

The dce_error_inq_text(3rpc) man page should not claim that you must set
the NLSPATH environment variable.

With serviceability, all component who return application level status
codes should have their messages built in to libdce.

You should mention that if the user sets their LANG variable and
has the correct message catalog files installed, they may get translated
messages.  In other words, the text string returned can be dependant 
on the current locale.

Also, this page should mention the dce_error_string_t typedef, which
you can use to declare a character array suitable for the <error_text>
argument.  See <dce/dce_error.h> for the declaration of this.

[08/05/94 public]
I believe that the original SVC draft manpages that I wrote contained
a rewrite of the dce_error_inq_text manpage.  Willie has them.

[08/09/94 public]
Assigned this bug to Willie Williams.

[8/15/94 public]

Added CR8443 as a related CR.

[09/30/94 public]
Reassigned to myself.

[10/06/94 public]
Fixed and verified by Tom Jordahl.  The routine dce_error_inq_text
is now part of man3dce.  All changes recommended in this CR
have been made to the reference page.

[10/27/94 public]
Closed bug.



CR Number                     : 11531
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : debug messages have time and thread info which isnt needed
Reported Date                 : 8/2/94
Found in Baseline             : 1.1b13
Found Date                    : 8/2/94
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : rpcsvc.c
Sensitivity                   : public

[8/2/94 public]

The rpc debug output looks like this:
1994-08-02-17:12:13.301-04:00I----- dced DEBUG1 rpc general ? 0 0x005e7f18 "[time: 004953] [thread: 005e7f18.00000015] CN: Global mutex locked
"

To clean this up:
	- Don't need double quotes
	- Don't need thread id
	- Don't need rpc timestamp

Since svc gives us the thread-id and timestamp already, remove them.

[8/2/94 public]
Removed code from rpcsvc.c.



CR Number                     : 11450
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : svc
Short Description             : dced core dumps with dbg svc routing
Reported Date                 : 7/26/94
Found in Baseline             : 1.1b12
Found Date                    : 7/26/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : cnclsm.h, cnasgsm.h, cnassm.h
Sensitivity                   : public

[7/26/94 public]

This is exhibited by running systest svccfg006 on the HP
(passes on i486 osf/1) with nightly from 7/22.

When specifying the following as the default routing file:

  rpc:*.2:FILE:/dcetest/dcelocal/status/svc_logs/DBGFIL/rpc
  sec:*.2:FILE:/dcetest/dcelocal/status/svc_logs/DBGFIL/sec
  cds:*.2:FILE:/dcetest/dcelocal/status/svc_logs/DBGFIL/cds
  aud:*.2:FILE:/dcetest/dcelocal/status/svc_logs/DBGFIL/aud
  gds:*.2:FILE:/dcetest/dcelocal/status/svc_logs/DBGFIL/gda
  dts:*.2:FILE:/dcetest/dcelocal/status/svc_logs/DBGFIL/dtsd

dced dies on startup with /etc/rc.dce:

  yosemite / K# /etc/rc.dce
          /opt/dcelocal/bin/dced
  dced (pid 1775) exited with status 0213

trace info:

>t
 0 _doprnt@libc + 0x00000344 (0x4000f528, 0x40049b64, 0x7af3b21c, 0x8146c387)
 1 vsprintf@libc + 0x00000040 (0x400194c8, 0x40049b64, 0x234d003, 0)
 2 cma_vsprintf@libdce + 0x000001a8 (0x401335bc, 0x7af69d30, 0x40049abc, 0x4)
 3 rpc__svc_fmt_dbg_msg@libdce + 0x000001bc (0x7af69d30, 0, 0x67206f66, 0x6c642f64)
 4 rpc__cn_call_start@libdce + 0x00000d74 (0x400bef60, 0x2, 0x7af78098, 0x2)
 5 rpc_call_start@libdce + 0x0000025c (0x400bef60, 0x2, 0x7af78098, 0x2)
 6 op2_csr@libdce + 0x00000194 (0x400bef60, 0x400494ac, 0, 0)
 7 rpc_mgmt_is_server_listening@l + 0x000000e0 (0x400bef60, 0x400494ac, 0, 0)
 8 check_listener (arg = 0x4000e290)    [/project/dce/build/dce1.1-snap/src/admin/dced/server/main.c: 528]
 9 cma__thread_base@libdce + 0x0000021c (0x400194c8, 0, 0, 0)
10 cma__thread_start1@libdce + 0x0000004c (0x400194c8, 0, 0, 0)
11 cma__thread_start0@libdce + 0x00000008 (0x400194c8, 0, 0, 0)
12 _doprnt@libc + 0x00000344 (0, 0, 0, 0)


The svc rpc debug log that gets generated has the following for the
last minute:


1994-07-26-14:43:21.095-04:00I1.165 dced DEBUG1 rpc rpc_svc_atfork ? 0 0x7affba68 "[time: 000001] [thread: 7affba68.00000001] (_pre_fork) entering, pid 1774, pre 0, post_p 0, post_c 0
"
1994-07-26-14:43:21.109-04:00I1.165 dced DEBUG1 rpc rpc_svc_atfork ? 0 0x7affba68 "[time: 000001] [thread: 7affba68.00000001] (_pre_fork) returning, pid 1774, pre 1, post_p 0, post_c 0
"
1994-07-26-14:43:21.138-04:00I1.165 dced DEBUG1 rpc rpc_svc_atfork ? 0 0x7affba68 "[time: 000001] [thread: 7affba68.00000001] (_post_fork_child) entering, pid 1774, pre 1, post_p 0, post_c 0
"
1994-07-26-14:43:21.154-04:00I1.165 dced DEBUG1 rpc rpc_svc_atfork ? 0 0x7affba68 "[time: 000001] [thread: 7affba68.00000001] (_post_fork_child) returning, pid 1774, pre 1, post_p 0, post_c 1
"
1994-07-26-14:43:21.284-04:00I1.165 dced DEBUG1 rpc rpc_svc_general ? 0 0x7affba68 "[time: 000002] [thread: 7affba68.00000001] (rpc__cn_network_use_protseq) Creating 1 sockets
"
1994-07-26-14:43:21.287-04:00I1.165 dced DEBUG1 rpc rpc_svc_general ? 0 0x7affba68 "[time: 000002] [thread: 7affba68.00000001] (rpc__cn_network_use_protseq) Created socket #1
"
1994-07-26-14:43:21.291-04:00I1.165 dced DEBUG1 rpc rpc_svc_general ? 0 0x7affba68 "[time: 000002] [thread: 7affba68.00000001] (rpc__cn_network_init_desc) desc->a desired_sndbuf 4096, desired_rcvbuf 4096
"
1994-07-26-14:43:21.295-04:00I1.165 dced DEBUG1 rpc rpc_svc_general ? 0 0x7affba68 "[time: 000002] [thread: 7affba68.00000001] (rpc__cn_network_init_desc) desc->a actual sndbuf 4096, actual rcvbuf 4096
"
1994-07-26-14:43:21.302-04:00I1.165 dced DEBUG1 rpc rpc_svc_general ? 0 0x7affba68 "[time: 000002] [thread: 7affba68.00000001] (rpc__socket_set_nbio) error=22
"
1994-07-26-14:43:21.356-04:00I1.165 dced DEBUG2 rpc rpc_svc_general ? 0 0x7affba68 "[time: 000002] [thread: 7affba68.00000001] (rpc_server_listen) cthreads started
"
1994-07-26-14:43:21.370-04:00I1.165 dced DEBUG2 rpc rpc_svc_general ? 0 0x40021068 "[time: 000003] [thread: 40021068.0000000a] (lthread) Unwound
"
1994-07-26-14:43:21.377-04:00I1.165 dced DEBUG1 rpc rpc_svc_atfork ? 0 0x7affba68 "[time: 000001] [thread: 7affba68.00000001] (_post_fork_parent) entering, pid 1774, pre 1, post_p 0, post_c 0
"
1994-07-26-14:43:21.382-04:00I1.165 dced DEBUG1 rpc rpc_svc_atfork ? 0 0x7affba68 "[time: 000001] [thread: 7affba68.00000001] (_post_fork_parent) returning, pid 1774, pre 1, post_p 1, post_c 0
"
1994-07-26-14:43:40.835-04:00I1.185 sec_clientd DEBUG1 rpc rpc_svc_general ? 0 0x7affba68 "[time: 000001] [thread: 7affba68.00000001] (rpc__cn_network_use_protseq) Creating 1 sockets
"
1994-07-26-14:43:40.845-04:00I1.185 sec_clientd DEBUG1 rpc rpc_svc_general ? 0 0x7affba68 "[time: 000001] [thread: 7affba68.00000001] (rpc__cn_network_use_protseq) Created socket #1
"
1994-07-26-14:43:40.850-04:00I1.185 sec_clientd DEBUG1 rpc rpc_svc_general ? 0 0x7affba68 "[time: 000001] [thread: 7affba68.00000001] (rpc__cn_network_init_desc) desc->3 desired_sndbuf 4096, desired_rcvbuf 4096
"
1994-07-26-14:43:40.853-04:00I1.185 sec_clientd DEBUG1 rpc rpc_svc_general ? 0 0x7affba68 "[time: 000001] [thread: 7affba68.00000001] (rpc__cn_network_init_desc) desc->3 actual sndbuf 4096, actual rcvbuf 4096
"
1994-07-26-14:43:40.859-04:00I1.185 sec_clientd DEBUG1 rpc rpc_svc_general ? 0 0x7affba68 "[time: 000001] [thread: 7affba68.00000001] (rpc__socket_set_nbio) error=22
"
1994-07-26-14:43:41.165-04:00I1.185 sec_clientd DEBUG2 rpc rpc_svc_dg_state ? 0 0x7affba68 "[time: 000001] [thread: 7affba68.00000001] (RPC_DG_CALL_SET_STATE) call=400a2040, old state=0, new state=1
"
1994-07-26-14:43:41.189-04:00I1.185 sec_clientd DEBUG2 rpc rpc_svc_dg_state ? 0 0x7affba68 "[time: 000001] [thread: 7affba68.00000001] (RPC_DG_CALL_SET_STATE) &ccall->c=400a2040, old state=1, new state=2
"
1994-07-26-14:43:44.784-04:00I1.189 sec_clientd DEBUG2 rpc rpc_svc_general ? 0 0x4000ee48 "[time: 000021] [thread: 4000ee48.00000003] (recv_state_timer) Re-pinging (rq->next_fragnum=0) [7fc61240-a8a9-1d1d-a94e-08000925a586, 0.0]
"
1994-07-26-14:43:48.801-04:00I1.193 sec_clientd DEBUG2 rpc rpc_svc_general ? 0 0x4000ee48 "[time: 000041] [thread: 4000ee48.00000003] (recv_state_timer) Re-pinging (rq->next_fragnum=0) [7fc61240-a8a9-1d1d-a94e-08000925a586, 0.0]
"
1994-07-26-14:43:56.783-04:00I1.201 sec_clientd DEBUG2 rpc rpc_svc_general ? 0 0x4000ee48 "[time: 000081] [thread: 4000ee48.00000003] (recv_state_timer) Re-pinging (rq->next_fragnum=0) [7fc61240-a8a9-1d1d-a94e-08000925a586, 0.0]
"
1994-07-26-14:44:04.783-04:00I1.209 sec_clientd DEBUG2 rpc rpc_svc_general ? 0 0x4000ee48 "[time: 000121] [thread: 4000ee48.00000003] (recv_state_timer) Re-pinging (rq->next_fragnum=0) [7fc61240-a8a9-1d1d-a94e-08000925a586, 0.0]
"
1994-07-26-14:44:12.783-04:00I1.217 sec_clientd DEBUG1 rpc rpc_svc_general ? 0 0x4000ee48 "[time: 000161] [thread: 4000ee48.00000003] (recv_state_timer) Ping timeout [7fc61240-a8a9-1d1d-a94e-08000925a586, 0.0]
"
1994-07-26-14:44:12.786-04:00I1.217 sec_clientd DEBUG1 rpc rpc_svc_general ? 0 0x4000ee48 "[time: 000161] [thread: 4000ee48.00000003] (rpc__dg_call_signal_failure) CCALL st = 0x16c9a016 (orig st = 0x0) [7fc61240-a8a9-1d1d-a94e-08000925a586, 0.0]
"
1994-07-26-14:44:12.791-04:00I1.217 sec_clientd DEBUG2 rpc rpc_svc_dg_state ? 0 0x7affba68 "[time: 000161] [thread: 7affba68.00000001] (RPC_DG_CALL_SET_STATE) &ccall->c=400a2040, old state=2, new state=5
"
1994-07-26-14:44:12.797-04:00I1.217 sec_clientd DEBUG1 rpc rpc_svc_general ? 0 0x7affba68 "[time: 000161] [thread: 7affba68.00000001] (rpc__dg_call_end) Sending orphan quit
"
1994-07-26-14:44:15.783-04:00I1.220 sec_clientd DEBUG1 rpc rpc_svc_general ? 0 0x4000ee48 "[time: 000176] [thread: 4000ee48.00000003] rpc__dg_ccall_timer) Orphan timeout
"
1994-07-26-14:44:15.786-04:00I1.220 sec_clientd DEBUG1 rpc rpc_svc_general ? 0 0x4000ee48 "[time: 000176] [thread: 4000ee48.00000003] (rpc__dg_call_signal_failure) CCALL st = 0x16c9a016 (orig st = 0x16c9a016) [7fc61240-a8a9-1d1d-a94e-08000925a586, 0.0]
"
1994-07-26-14:44:15.789-04:00I1.220 sec_clientd DEBUG2 rpc rpc_svc_dg_state ? 0 0x7affba68 "[time: 000176] [thread: 7affba68.00000001] (RPC_DG_CALL_SET_STATE) &(ccall)->c=400a2040, old state=5, new state=4
"

[7/26/94 public]
One more thing, here was the config:
        pomerol         (OSF/1)         sec/cds server
        yosemite        (HP)            sec replica
        fiji            (OSF/1)         client
test was run on 'yosemite'

[07/26/94 public]
Will it's dumping core in RPC, most likely a mismatch SVC call.
Assigned to RPC.

[7/27/94 public]

This is not related to the core dump, but don't set "rpc:*.2:...". Never
use the wildcard for rpc debugging! You must know the meaning of
sub-comp.level for setting it.

[7/28/94 public]
The problem is with the CN performance modifications.
In cnclsm.h, the macro RPC_CN_CALL_SM_TRC evaluates the following
expression:
	rpc_g_cn_call_server_states[(crep)->call_state.cur_state]

But now the state values start at 100, so they can be kept in
the same variables as events.

The fix is to subtract 100 from the current state:
	rpc_g_cn_call_server_states[(crep)->call_state.cur_state-100]

I will also check the other trace macros for this problem.

[7/28/94 public]
Also found the same problem with the group and assoc server/client
event and state debug tables.

Used the #define RPC_C_CN_STATEBASE instead of the constant 100.



CR Number                     : 11440
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : cn
Short Description             : RPC/CN sets TCP window size
Reported Date                 : 7/26/94
Found in Baseline             : 1.1
Found Date                    : 7/26/94
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b15
Affected File(s)              : ./rpc/runtime/cnnet.c
./rpc/runtime/cnnet.h
./rpc/runtime/comsoc_bsd.c
./test/rpc/runtime/perf/client.c
./test/rpc/runtime/perf/server.c
Sensitivity                   : public

[7/26/94 public]
RPC/CN sets the TCP window size.  There are many environments, particularly
long-haul networks using satellite uplinks, where this is not acceptable.
One site reports needing a 24-28k window to effectively use their network.
From some email:
    Today, across a satellite link we can get:
	    185k bits/sec   -- FTP
	    ~50k            -- UPD and DCE rpc
	    ~30k            -- TCP and DCE rpc
    ... We cannot send out our
    application with such poor performance in relation to FTP.

The claim was made that fixing this will not be easy since apparently the
4k window size is hardwired in as a constant.  (i.e., RPC depends on it
being compile-time not run-time).  I can't comment on the validity of that
claim.

Assigned A1 because this must get looked at soon.

[7/26/94 public]

The problems are in rpc__cn_network_init_desc() and
rpc__cn_network_req_connect()::cnnet.c . These functions call
rpc__socket_set_bufs() to set SO_SNDBUF and SO_RCVBUF to 4KB. One of our
customers complained about this (he found the 4KB window size when watching
the network analyzer), because on HP-UX the default value for
SO_SNDBUF/SO_RCVBUF is 8KB and CN RPC is slower than the database
application using TCP/IP. So at least, rpc__socket_set_bufs() should not
cut down SO_SNDBUF/SO_RCVBUF if they are already larger than what requested
(and rpc_g_cn_large_frag_size should be set to
MIN(RPC_C_CN_LARGE_FRAG_SIZE,what set_bufs returns)). I don't know if it
should be configurable by the application (require a new API or env. var
:-).


[7/26/public]

Dick,

        After our  talk I went over some cn codes and did some
        experiments last night and this morning. Big thruput gains
        were as expected(30%). Below is a brief description of how
        cn's send/recv buffer sizes are determined in the runtime: 

        The cn runtime does have the setsockopt and getsockopt
        calls in place to set and get send/recv buffer sizes --- 
        rpc__socket_set_bufs fuction in comsoc_bsd.c. So, the
        problem is how to set these two parameters dynamically
        before calling setsockopt. 

        Right now the two parameters are determined by

        /* cn.h */
        #define rpc_c_cn_large_frag_size        4096 

        and rpc_c_socket_max_sndbuf(32K) and rpc_c_socket_max_rcvbuf
        (32K) in rpc__socket_set_bufs of comsoc_bsd.c. See also the 
        enclosed code pieces.

        It seems to me that the change should be straightforward.
        One way is to change rpc_c_cn_large_frag_size from a
        #define to a global variable and there are thousands
        ways to set it dynamically.

        I'll dig into cn more.

Jean

+++++++++++++++++++++++++++++++++++++++++++++
/* comsoc_bsd.c */

...

#ifndef rpc_c_socket_max_rcvbuf
#  define rpc_c_socket_max_rcvbuf (32 * 1024)
#endif

#ifndef rpc_c_socket_max_sndbuf
#  define rpc_c_socket_max_sndbuf (32 * 1024)
#endif

...

rpc__socket_set_bufs(){

...

    txsize = MIN(txsize, rpc_c_socket_max_sndbuf);

    e = setsockopt(sock, SOL_SOCKET, SO_SNDBUF, &txsize, sizeof(txsize));

...
}


/* cnnet.c */

...

rpc__cn_network_init_desc(){

...

    /*
     * Setup the socket's send and receive buffering to be the max
     * fragment size.
     */
    serr = rpc__socket_set_bufs (*desc,
                                 rpc_c_cn_large_frag_size,
                                 rpc_c_cn_large_frag_size,
                                 &rpc_g_cn_large_frag_size,
                                 &rpc_g_cn_large_frag_size);

...

}

rpc__cn_network_req_connect(){

...

        /*
         * Setup the socket's send and receive buffering to be the max
         * fragment size.
         */
        serr = rpc__socket_set_bufs (assoc->cn_ctlblk.cn_sock,
                                     rpc_c_cn_large_frag_size,
                                     rpc_c_cn_large_frag_size,
                                     &rpc_g_cn_large_frag_size,
                                     &rpc_g_cn_large_frag_size);
...

}

[7/26/94 public]

It is wrong to change RPC_C_CN_LARGE_FRAG_SIZE from the constant to the
variable. The variable rpc_g_cn_large_frag_size already exists. The CN
fragment size is a buffering size negotiated by the sender and the receiver
and its lower bound is RPC_C_ASSOC_MUST_RECV_FRAG_SIZE (1432).

The CN fragment size should not be tied to the TCP/IP window size. The
problem is that the current CN implementation treats them together.


[7/27 public]

I agree that we should separate CN fragment size from TCP window size.
So, I propose the following two simple changes in rpc__socket_set_bufs
before the two setsockopt calls: 

<	txsize = MIN(txsize, RPC_C_SOCKET_MAX_SNDBUF);
---------------
>	txsize = RPC_C_SOCKET_MAX_SNDBUF ;

<	rxsize = MIN(rxsize, RPC_C_SOCKET_MAX_RCVBUF);
---------------
>	rxsize = RPC_C_SOCKET_MAX_RCVBUF ;

The default values for RPC_C_SOCKET_MAX_SNDBUF and RPC_C_SOCKET_MAX_RCVBUF are
32K. But, each platform can set its own values, for example, HP800 uses 56K. 

With these two changes the 64 KB input argument perf test increased its thruput from 
704 KB/sec to 1008 KB/sec between two HP's in the OSF LAN.

[7/27/94 public]

Please don't do that. rpc__socket_set_bufs() is also used by DG and
SO_SNDBUF/SO_RCVBUF have a different meaning for UDP. Also the proposed
change will jeopardize rpc_g_cn_large_frag_size.

I believe that something following would be better.

In rpc__socket_set_bufs():

  txsize = MIN(txsize, RPC_C_SOCKET_MAX_SNDBUF);
  getsockopt(sock,SOL_SOCKET,SO_SNDBUF,&ntxsize,(int *)&sizelen);
  if (ntxsize < txsize)
  {
    /* Do what we do now */
    setsockopt(sock,SOL_SOCKET,SO_SNDBUF,&txsize,sizoef(txsize);
    getsockopt(sock,SOL_SOCKET,SO_SNDBUF,&ntxsize,(int *)&sizelen);
  }
  /* Do same for SO_RCVBUF */

In rpc__cn_network_init_desc() and rpc__cn_network_req_connect():

  rpc__socket_set_bufs(*desc, Window_Size, Window_Size,
                       &ssize,&rsize);
  /*
   * Should we just set rpc_g_cn_large_frag_size = RPC_C_CN_LARGE_FRAG_SIZE?
   */
  rpc_g_cn_large_frag_size = MIN(RPC_C_CN_LARGE_FRAG_SIZE,ssize);

The remaining question is how we define the Window_Size, constant or
variable?

[07/28/94 public]
The Window_Size should be variable.  It should be per-protseq.

Here is what I would like to see happen.  Add "socket_read_buffer" and
"socket_write_buffer" fields to rpc_g_protseq_id.  Add the following
two routines:
	void rpc__inq_sock_buffsize(
	    char *rpc_prots,
	    signed32 *rsize,
	    signed32 *wsize,
	    error_status_t *st);
	void rpc__set_sock_buffsize(
	    char *rpc_prots,
	    signed32 rsize,
	    signed32 wsize,
	    error_status_t *st);
A value of "0" means -- don't change the system defaults.  These are internal
and undocumented but vendors could expose them for special-cases.  This is
not a great solution but it helps an important class of customers without
really breaking source compatibility.

[8/1/94 public]

Arrggh.  This really should be per-connection (binding), not per-protseq.
Just because a process needs to use 1 WAN connection, doesn't mean it wants
all of its other calls (over that protseq) to use an increased amount of 
kernel buffering.  (Compare this to rpc_mgmt_set_com_timeout().).

This won't be the last "quality of service" attribute that apps want to
attach to binding handles, so it would be nice to have a more generic,
extensible way to allow for this. (as you know :-)

[08/01/94 public]
I agree this is far from perfect, but I have realized (rationalized?) that
perfect protocol independence is not always achievable and at least this
works for severs, too.  It also lets you do per-binding things albeit 
in a not-wonderful way:
	inq_buffers
	set_to_new_value
	import/resolve
	restore_old_value

[8/8/94 public]
I too think that this should be per binding attribute.
Adding these fields to the binding handle would be easy, as would
setting and reading them.

However, the binding handle is not readily available at the level
that rpc__socket_set_bufs() is called.  I am investigating
passing it down (via rpc_addr?  binding handle pointer?) and would
appreciate any thoughts from the HP DG people on how this could be done.

The more I look at per protocol, the less I like it....
But it may be the expediant thing to do.

[8/8/94 public]
Per connection doesn't seem doable right now, and wouldn't work
for servers well at all.

I have coded up the following changes:

 - In comsoc_bsd.c, if the new size is passed in as 0, we don't
   adjust the buffer size, we return the OS default.  

   Otherwise, we set to specified size (but no bigger than 
   RPC_C_SOCKET_MAX_SNDBUF/RECVBUF).


 - In cnnet.c, rpc__cn_network_init_desc() and rpc__cn_network_req_connect()
   now do the following:

        serr = rpc__socket_set_bufs (*desc,
                         /* In */    rpc_g_cn_socket_read_buffer,
                         /* In */    rpc_g_cn_socket_write_buffer,
                         /* Out */   &ssize,
                         /* Out */   &rsize);

        /* 
         * This check might not really be needed. 
         */
	if (rsize < RPC_C_ASSOC_MUST_RECV_FRAG_SIZE)
	{
            /*
             * rpc_m_recvbuf_toosmall
  .....

   NOTE: We do not set the variable rpc_g_cn_large_frag_size in these
         routines.  This uncouples the socket buffers from the internal
	 CN rpc buffers.


 - In cnnet.[ch], the following variables and APIs are declared:

 static unsigned32     rpc_g_cn_socket_read_buffer=0;
 static unsigned32     rpc_g_cn_socket_write_buffer=0;


 PRIVATE void
 rpc__cn_inq_sock_buffsize(
       unsigned32      *rsize,
       unsigned32      *ssize,
       error_status_t  *st)
 {
     *rsize = rpc_g_cn_socket_read_buffer;
     *ssize = rpc_g_cn_socket_write_buffer;
     *st = rpc_s_ok;
 }

 PRIVATE void
 rpc__cn_set_sock_buffsize(
       unsigned32      rsize,
       unsigned32      ssize,
       error_status_t  *st)
 {
     rpc_g_cn_socket_read_buffer = rsize;
     rpc_g_cn_socket_write_buffer = ssize;
     *st = rpc_s_ok;
 }

This gives an (undocumented) API for anyone who wants to muck around
with the CN TCP buffer size.  For the application site mentioned above,
they shuold be able to set their buffers to 24-28K in both the server
and client sides.

[8/12/94 public]
Code has been submitted.
Added a -B option to perf server and client to allow test tweaking
of the TCP socket size.
Marked 'Fix'.



CR Number                     : 11413
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : rpc_ss_allocate can leave
mutex locked
Reported Date                 : 7/25/94
Found in Baseline             : 1.1
Found Date                    : 7/25/94
Severity                      : D
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b12
Affected File(s)              : stubbase.h allocate.c nidlalfr.c
Sensitivity                   : public

[7/25/94 public]

The function rpc_ss_allocate which can be called from stub code or from
application code calls malloc to allocate memory.  If malloc returns NULL
indicating no memory is available, rpc_ss_allocate raises a rpc_x_no_memory
exception but erroneously leaves a mutex locked.  Another thread of
execution calling rpc_ss_allocate would hang waiting for the mutex.

[7/28/94 public]

Fixed by adding new function rpc_sm_mem_allocate to allocate.c. Function 
called from rpc_ss_allocate returns status instead of raising exception
and esception is then raised after mutex unlocked. It was implmented this
way rather than as a TRY CATCH block for performance reasons.



CR Number                     : 11400
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : dfs.glue fails with rpc timeout
Reported Date                 : 7/22/94
Found in Baseline             : 1.1
Found Date                    : 7/22/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b17
Affected File(s)              : rpc/krpc ones
Sensitivity                   : public

[7/22/94 public]

This defect is opened bacause of a rpc problem related to defect 11070.
A fix to the dfs rpoblem has been tested but the assert occured
because of mishandling of the RPC exception during a pipe operation.

To reproduce this problem run the dfs.glue system test. After a
few hours a timeout will occur with the new changes that were
made to the px_read function in px_subr.c, or the system will panic
with the old px_read code. The new code was given to Ron Arbo
on 7/22.

[7/27/94 public]
Assigned to HP.  Mark, can you get someone to take a look-see?
Defect 11070 has a traceback in it.

[8/11/94 public]

Mark - Ron and I have tried many times to get more
information on the rpc exception with no luck. I asked at the
conference call that Sam at IBM contact Ron or myself with the
name of the engineer who can work with you on this. Please be
prepared to help this engineer gather the information you'll need.
I asked that this engineer be familiar with debugging the IBM
kernel extensions so that should get you past what's blocking
us here at OSF. Please also watch CR 11070, the bug whose "fix"
spawned this CR.

[8/17/94 public]
Since neither OSF nor HP can make progress on this without significant
help from IBM - AND since this is only showing up on the IBM, assigning
to IBM.

[8/18/94 public]
Carl Burnett spoke with Ron Arbo aobut this problem and he thought that
all was well.  So be ti.  We'll look at this again.  Carl is not available
to look at this until late friday (8/19) afternoon.

[8/24/94 public]
Heard that suddenly this was no longer reproducable - suggested that
the workaround for 11070 be pulled to see if the panic was also no
longer reproducable - any status on this? Thanks. Also, adding Sam
to interest list so he'll see updates.

[8/24/94 public]
I was running the dfs.glue test with what I thought was the changes in
px_subr.c to try to determine the rpc error that was occuring. However,
this caused a panic. I am trying to reproduce this problem again on
16. Stay tuned.

[8/29/94 public]
This from CR 11070 :

[8/26/94 public]
I have been using the new code on BL16 and a panic is still occuring.
We captured the exception, which is 804779204. We are in the process
of rebuilding the rpc kruntime in order to get a stack traceback.
At first I thought I might be running with the wrong code when a
panic occured. Has something changed that is causing this second
panic to occur. The traceback is the same as the one before.

[8/29/94 public]
Note from OT 11070:
The value 804779204 is incorrect, that was the address of the structure
for THIS_CATCH. "THIS_CATCH" is of type EXCEPTION which had the
following values at the specified address:

        EXCEPTION
                exc_kind
                        address         0x2130456
                        status          0x16c9a80
                match [value/address]   0x2ff7fc60

Since the value for match appeared to be an address in the stack, I
assume that 0x16c980 (23894656 in base 10) is the exception status.

[9/12/94 public]
I ran the dfs.glue test on the BL17 build this weekend. It ran for
10 hours until my ticket expired without any errors. I will also
update OT 11070 with this information.

[9/12/94 public]
Hmmm, ticket expired?  Is this test run as root/self or some other principal?
The root/self principal's context should be refreshed continuously by
sec_clientd/dced-secval and therefore should not expire.  If self identity
is expiring then may signal secval problem... let me know.

[9/12/94 public]
The test cannot be run as root/self principal. A dce_login must be
performed before running the test.

[9/12/94 public]
Yeah! dfs.glue has been running successfully for over 4 hours w/ bl-17.
Once it has solidly passed the 10 hour mark, I'll close this, pointing
to the HP submission we believe addressed this problem.

[9/13/94 public]
Closed - to quote tatsu_s "The runaway packet reservation
was fixed in the last MBF code drop."



CR Number                     : 11399
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc.sams
Short Description             : rm rpc_svc_ from sub-comp names
Reported Date                 : 7/22/94
Found in Baseline             : 1.1b12
Found Date                    : 7/22/94
Severity                      : E
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : src/rpc/sys_idl/rpc.sams
Sensitivity                   : public

[7/22/94 public]
The sub-component names defined in the sams file should not have rpc_svc_
as a prefix.  Having that string means the following happens:

  dcecp> log list /.:/hosts/frick/cds-clerk -comp rpc
  {rpc_svc_general 0  ""}
  {rpc_svc_mutex 0  ""}
  {rpc_svc_xmit 0  ""}
  {rpc_svc_recv 0  ""}
  {rpc_svc_dg_state 0  ""}
   ...

As opposed to:

  dcecp> log list /.:/hosts/frick/cds-clerk -comp cds
  {adver      0  ""}
  {clerk      0  ""}
  {gda        0  ""}
   ...

Only change the string displayed, not the names of the variables.
In general change:

    sub-component    rpc_svc_general       "rpc_svc_general"       rpc_svc_desc_general

to:

    sub-component    rpc_svc_general       "general"       rpc_svc_desc_general

[7/27/94 public]
If this change means that I can set up my *routing* file to have
only 'general', instead of 'rpc_svc_general', than this is a good thing.

[7/28/94 public]
Removed the offending characters.



CR Number                     : 11369
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_gd
Short Description             : rpc_s_no_more_entries needs to
be changed to rpc_s_no_more_bindings
Reported Date                 : 7/20/94
Found in Baseline             : 1.1
Found Date                    : 7/20/94
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : acf.gpsml
Sensitivity                   : public

[7/20/94 public]

The status code rpc_s_no_more_entries was obsoleted and it looks
like the status code rpc_s_no_more_bindings replaced it. Although
the reference pages have been corrected, the Application Development
Guide still contains some references to using rpc_s_no_more_entries.

I'm assigning this CR to myself. I'll fix the references as part
of my IDL work on the only chapter that seems to be affected
(dce_books/app_gd/rpc/acf.gpsml).

[9/6/94 public]

Fixed and verified (by me).

[09/22/94 public]
Closed bug.



CR Number                     : 11358
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : error messages printed in the non-debug mode
Reported Date                 : 7/19/94
Found in Baseline             : 1.1
Found Date                    : 7/19/94
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 1.1b15
Affected File(s)              : ./rpc/runtime/cnassoc.c ./rpc/runtime/cnrcvr.c ./rpc/runtime/cnsassm.c ./rpc/runtime/cnsclsm.c ./rpc/runtime/cominit.c ./rpc/runtime/commonp.h ./rpc/sys_idl/rpc.sams
Sensitivity                   : public

[7/19/94 public]


There are two places in cn code where in an error occurs, the code will
print to stderr an error message with hexidecimal error code. I think
such error messages should be printed in the debug mode, with better
message but just erro code.

In rpc/runtime/cnassoc.c, function rpc__cn_assoc_send_frag():

        RPC_CN_AUTH_PRE_SEND (&assoc->security,
                              sec,
                              iovp,
                              iovcnt,
                              &out_iov,
                              st);
        if (*st != rpc_s_ok)
        {
            if (assoc->assoc_flags & RPC_C_CN_ASSOC_SERVER)
            {
                /*
                 * rpc_m_call_failed_s
                 * "%s on server failed, status = %x"
                 */
                RPC_DCE_SVC_PRINTF ((
                    DCE_SVC(RPC__SVC_HANDLE, "%s%x"),
                    rpc_svc_auth,
                    svc_c_sev_error,
                    rpc_m_call_failed_s,
                    "RPC_CN_AUTH_PRE_SEND",
                    *st ));
            }
            return;

[in 1.0.3 code, it is:

        RPC_CN_AUTH_PRE_SEND (&assoc->security,
                              sec,
                              iovp,
                              iovcnt,
                              &out_iov,
                              st);
        if (*st != rpc_s_ok)
        {
            if (assoc->assoc_flags & rpc_c_cn_assoc_server)
            {
                fprintf (stderr, "(RPC_CN_AUTH_PRE_SEND) on server failed status = %x\n", *st);
            }
            return;
]

When error happends, it prints to stderr.

Another case in cnsassm.c, function rpc__cn_assoc_process_auth_tlr():

    if (verify_client_req_st != rpc_s_ok)
    {
        /*
         * "%s on server failed, status = %x"
         */
        RPC_DCE_SVC_PRINTF ((
            DCE_SVC(RPC__SVC_HANDLE, "%s%x"),
            rpc_svc_auth,
            svc_c_sev_error,
            rpc_m_call_failed_s,
            "RPC_CN_AUTH_VFY_CLIENT_REQ",
            verify_client_req_st ));

[in 1.0.3 code, it is:

                    if (verify_client_req_st != rpc_s_ok)
                    {
                        fprintf (stderr, "(RPC_CN_AUTH_VFY_CLIENT_REQ) on server failed status = %x\n", verify_client_req_st);
]

[7/19/94 public]
This message are printed to STDERR only if you haven't redirected them
with the SVC routing file (/opt/dcelocal/var/svc/routing).

They are errors and as such its useful and important to print
them to the user.  They are also 'shouldn't happen' errors.

RPC is using the correct mechanism here, and providing useful info.

Perhaps a case could be made to lookup the status code.

[7/19/94 public]
I agree that 1.1 code is already better that 1.0.3 code that if the user
sets the routing table, he may not see the really-debug message on his 
screen.

But what if someone just take DCE by default? He runs his rpc program and
out goes this message with a hexidecimal number.

If they are really "shouldn't happen" errors, why care to check for them?
To say the least, if we insist leaving this message here, we should print
the message returned from dce_error_inq_text(), not 0xabcdefg.

[07/19/94 public]
For DCE 1.1, printing the hex code is not a bad thing, since you can
easily look up numeric status codes in the problem determination guide.

Donning my pedantic hat (the red one, with the bells), library routines
should never output text but only return status codes.  I think this should
be turned into either a debug message or an assertion failure.

[7/22/94 public]
More places:

in cnassoc.c, function rpc__cn_assoc_sec_alloc():

    RPC_CN_AUTH_GET_PROT_INFO (info, &cn_info, st);
    if (*st != rpc_s_ok)
    {
        if (info->is_server)
        {
            /*
             * rpc_m_call_failed_s
             * "%s on server failed, status = %x"
             */
            RPC_DCE_SVC_PRINTF ((
                DCE_SVC(RPC__SVC_HANDLE, "%s%x"),
                rpc_svc_auth,
                svc_c_sev_error,
                rpc_m_call_failed_s,
                "RPC_CN_AUTH_GET_PROT_INFO",
                *st ));
        }
        return (NULL);


In cnrcvr.c, function receive_dispatch():

                        else
                        {
                            /*
                             * rpc_m_call_failed_s
                             * "%s on server failed, status = %x"
                             */
                            RPC_DCE_SVC_PRINTF ((
                                DCE_SVC(RPC__SVC_HANDLE, "%s%x"),
                                rpc_svc_recv,
                                svc_c_sev_error,
                                rpc_m_call_failed_s,
                                "RPC_CN_AUTH_RECV_CHECK",
                                auth_st ));


In cnsassm.c, function rpc__cn_assoc_process_auth_tlr():

    if (sec == NULL)
    {
        RPC_CN_AUTH_CREATE_INFO (
                   RPC_CN_AUTH_CVT_ID_WIRE_TO_API (req_auth_tlr->auth_type, st),
                   req_auth_tlr->auth_level,
                   &info,
                   st);
    }
    if (*st != rpc_s_ok)
    {
        /*
         * "%s failed, status = %x"
         */
        RPC_DCE_SVC_PRINTF ((
            DCE_SVC(RPC__SVC_HANDLE, "%s%x"),
            rpc_svc_auth,
            svc_c_sev_error,
            rpc_m_call_failed,
            "RPC_CN_AUTH_CREATE_INFO",
            *st ));
        goto DONE;


And in cnsclsm.c, function handle_first_frag_action_rtn():

            RPC_CN_AUTH_PRE_CALL (RPC_CN_ASSOC_SECURITY (call_rep->assoc),
                                  call_rep->sec,
                                  (pointer_t) auth_tlr->auth_value,
                                  &auth_value_len,
                                  &status);
            if (status != rpc_s_ok)
            {
                /*
                 * "%s on server failed, status = %x"
                 */
                RPC_DCE_SVC_PRINTF ((
                    DCE_SVC(RPC__SVC_HANDLE, "%s%x"),
                    rpc_svc_auth,
                    svc_c_sev_error,
                    rpc_m_call_failed_s,
                    "RPC_CN_AUTH_PRE_CALL",
                    status ));


By the way, the above problem in 1.0.3 happens in the following places:

cnassoc.c:1908:                fprintf (stderr, "(RPC_CN_AUTH_PRE_SEND) on server failed status = %x\n", *st);
cnassoc.c:3624:            fprintf (stderr, "(RPC_CN_AUTH_GET_PROT_INFO) on server failed status = %x\n", *st);
cnrcvr.c:805:                            fprintf (stderr, "(RPC_CN_AUTH_RECV_CHECK) on server failed status = %x\n", auth_st);
cnsassm.c:3268:                        fprintf (stderr, "(RPC_CN_AUTH_VFY_CLIENT_REQ) on server failed status = %x\n", verify_client_req_st);
cnsassm.c:3290:                fprintf (stderr, "(RPC_CN_AUTH_CREATE_INFO) failed status = %x\n", *st);
cnsclsm.c:1142:                fprintf (stderr, "(RPC_CN_AUTH_PRE_CALL) on server failed status = %x\n", status);

[8/5/94 public]
I still believe that htese are usefull errors that are important to see.  
I have submitted changes to translate the status core in to a text message.
anything further will have to be done in 1.2.



CR Number                     : 11315
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : llb.idl
Short Description             : don't know how to make llb.idl
Reported Date                 : 7/15/94
Found in Baseline             : 1.1
Found Date                    : 7/15/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : rpc/rpcd/Makefile, rpc/idl/Makefile
Sensitivity                   : public

[7/15/94 public]


HP build log
------------

[ /rpc/rpcd at 22:02 (PM) Thursday ]
makepath rpcd/. && cd rpcd &&  exec make MAKEFILE_PASS=BASIC     build_all
rpcd: created directory
make: don't know how to make llb.idl (continuing)


AT486 build log
---------------

/project/dce/build/dce1.1-snap/tools/at386/macho/gcc -B/project/dce/build/dce1.1-snap/tools/at386/macho/  -traditional -c    -D_SHARED_LIBRARIES   -D_BSD    
I. -I/u1/devobj/sb/nb_486/src/rpc/idl/nidl_to_idl -I/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl     -pic-lib   -L/u1/devobj/sb/nb_486/export/at386/usr/shlib -L/project/dce/build/dce1.1-snap/export/at386/usr/shlib -L/usr/shlib -L/u1/devobj/sb/nb_486/export/at386/usr/lib     -L/project/dce/build/dce1.1-snap/export/at386/usr/lib     -lm -lbsd   /project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/frontend.c
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/frontend.c:139: `SUFFIXES' undeclared, outside of functions
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/frontend.c:140: `ACF_SUFFIXES' undeclared, outside of functions
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/frontend.c: In function `NIDL_parse_args':
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/frontend.c:493: `DEFAULT_IDIR' undeclared (first use this function)
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/frontend.c:493: (Each undeclared identifier is reported only once
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/frontend.c:493: for each function it appears in.)
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/frontend.c:496: `CD_IDIR' undeclared (first use this function)
*** Error code 1



/project/dce/build/dce1.1-snap/tools/at386/macho/gcc -B/project/dce/build/dce1.1-snap/tools/at386/macho/  -traditional -c    -D_SHARED_LIBRARIES   -D_BSD    -I. -I/u1/devobj/sb/nb_486/src/rpc/idl/nidl_to_idl -I/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl     -pic-lib   -L/u1/devobj/sb/nb_486/export/at386/usr/shlib -L/project/dce/build/dce1.1-snap/export/at386/usr/shlib -L/usr/shlib -L/u1/devobj/sb/nb_486/export/at386/usr/lib     -L/project/dce/build/dce1.1-snap/export/at386/usr/lib     -lm -lbsd   lex_yy.c
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/nidl.l:241: syntax error before `short'
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/nidl.l:258: syntax error before `unsigned'
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/nidl.l:290: syntax error before `unsigned'
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/nidl.l:300: syntax error before `short'
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/nidl.l:321: syntax error before `short'
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/nidl.l:342: syntax error before `short'
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/nidl.l:375: syntax error before `short'
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/nidl.l:434: conflicting types for `yyunput'
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/nidl.l:126: previous declaration of `yyunput'
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/nidl.l: In function `commenteof':
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/nidl.l:227: `yylineno' undeclared (first use this function)
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/nidl.l:227: (Each undeclared identifier is reported only once
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/nidl.l:227: for each function it appears in.)
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/nidl.l: At top level:
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/nidl.l:231: parse error before `1'
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/nidl.l:234: conflicting types for `yyuninclude'
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/nidl.l:95: previous declaration of `yyuninclude'
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/nidl.l:235: parse error before `if'
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/nidl.l:240: `yylineno' used prior to declaration
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/nidl.l:241: parse error before `return'
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/nidl.l:494: conflicting types for `yyuninclude'
/project/dce/build/dce1.1-snap/src/rpc/idl/nidl_to_idl/nidl.l:234: previous declaration of `yyuninclude'
*** Error code 1
`build_all' not remade because of errors.
*** Error code 1
`build_all' not remade because of errors.
*** Error code 1

[7/15/94 public]
Remove nild_to_idl from rpc/idl/Makefile
Removed llbd support from rpc/rpcd/Makefile.



CR Number                     : 11294
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 11296
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : i18n
Short Description             : Change attr_type to a uuid_t*
Reported Date                 : 7/14/94
Found in Baseline             : 1.1b11
Found Date                    : 7/14/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : sys_idl/Makefile, nsattrid.h rpc.idl, rpcbase.idl  runtime/ns_s_attr.c, cs_s.h and relating functional tests
Sensitivity                   : public

[7/14/94 public]
For compatibility with the other DCE attribute stuff (that is, the
xattrschema stuff from ERA and used by DCED), the attr_type parameter
in the rpc_ns_mgmt_attr API calls should uuid_t *, not unsigned32.

The API should be changed and a new well-known uuid should be defined
for the codeset attribute.  (It might be tough to define a uuid in rpc.idl
so perhaps a NULL pointer can be used.)

For now, the RPC code can internally map the uuid into an integer.  In
1.2 or later we should revisit this issue in a more global scale.

[7/28/94 public]

  Added well-known uuid for codesets attribute.  Modified APIs as suggested.
Modified functional tests accordingly.



CR Number                     : 11292
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 9601, 10505
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_gd
Short Description             : ACF syntax descriptions need
to include attributes added since 1.0.2
Reported Date                 : 7/14/94
Found in Baseline             : 1.1
Found Date                    : 7/14/94
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : app_gd/rpc/acf.gpsml
Sensitivity                   : public

[7/14/94 public]

The Application Development Guide chapter on the Attribute
Configuration Language needs to be updated to show usage
syntax for the 1.0.3 ACF attributes (encode, decode, extern_exception,
cs_char, ...) and 1.1 ACF attributes (binding_callout).

The affected file is app_gd/rpc/acf.gpsml.

Assigning this CR to myself (since I'm the OSF writer
who's responsible for IDL documentation).

[8/15/94 public]

Fixed and verified (by M. Romagna and T. Jordahl).

[09/08/94 public]
Closed bug.



CR Number                     : 11260
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : CN
Short Description             : Add DEC CN performance enhancements
Reported Date                 : 7/12/94
Found in Baseline             : 1.1
Found Date                    : 7/12/94
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b13
Affected File(s)              : ./rpc/runtime/cnasgsm.h
./rpc/runtime/cnassm.h
./rpc/runtime/cnassoc.c
./rpc/runtime/cnassoc.h
./rpc/runtime/cncall.c
./rpc/runtime/cncasgsm.c
./rpc/runtime/cncassm.c
./rpc/runtime/cncclsm.c
./rpc/runtime/cnclsm.h
./rpc/runtime/cnp.h
./rpc/runtime/cnrcvr.c
./rpc/runtime/cnsasgsm.c
./rpc/runtime/cnsassm.c
./rpc/runtime/cnsclsm.c
./rpc/runtime/cnsm.c
./rpc/runtime/cnsm.h
Sensitivity                   : public

[7/12/94 public]

Ursula Sinkewicz at DEC has provided OSF with modifications
to the rpc CN runtime to boost performance.

The files will be submitted under this OT.

Here are some perf numbers from the HP and 486 platforms:

486 Summary

	Null call test:
		OLD: 5.156
		NEW: 4.783
				(7.5% better)

	Variable length input arg test:
		OLD: 9.6976
		NEW: 9.4188
				(3% better)

	Variable length output arg test:
		OLD: 10.1092
		NEW: 9.6844
				(4.3% better)

HP Summary
	Null call test:
		Avg OLD: 6.233
		Avg NEW: 6.251
				(~1% worse)
	Variable input args test:
		Avg OLD: 12.0156
		Avg NEW: 11.9519
				(~1% better)

	Variable output args test:
		Avg OLD: 12.39
		Avg NEW: 12.2192
				(~1% better)

RIOS Summary

	Null call test:
		OLD: 7.4824
		NEW: 7.1599
				(4.5% better)

	Variable length input arg test:
		OLD: 10.1989
		NEW: 10.0492
				(1.5% better)

	Variable length output arg test:
		OLD: 11.9185
		NEW: 12.0537
				(1% worse)

[public]
Submitted the DEC changes.



CR Number                     : 11176
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : krbcn
Short Description             : fill in missing code.
Reported Date                 : 7/5/94
Found in Baseline             : 1.1
Found Date                    : 7/5/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : 
	rpc/runtime/cn.h
	rpc/runtime/cnp.h
	rpc/runtime/cnsassm.c
	rpc/runtime/krbcn.c
	rpc/runtime/krbdgsrv.c
Sensitivity                   : public

[7/5/94 public]

due to an unfortunate misunderstanding, the changes I made to support big
pac's for real in RPC didn't include the code needed to get CN rpc to
support this for real.

This submission will close this oversight.

[7/6/94 public]

fix submitted.



CR Number                     : 11153
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rpc coredumps when given an incorrect ethernet address.
Reported Date                 : 6/30/94
Found in Baseline             : 1.1
Found Date                    : 6/30/94
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : rpc/runtime/dgcct.c
                                             rpc/runtime/dgclive.c
Sensitivity                   : public

[6/30/94 public]

ON OSF1 only:

It the ethernet address in the file /etc/ieee_802_addr is missing numbers,
then dced coredumps and the following messages are printed:

S:****** Starting dced...
WARNING: If "dced" was recently running, and was using the TCP protocol
sequence to listen for calls to the server, then a TCP shutdown period of
up to 4 minutes is required before restarting "dced" in order to avoid
"cannot bind socket" errors.
        Press <RETURN> to continue, CTRL-C to exit: 
S:****** Initializing dced...
1994-06-30-16:50:13.540-04:00I----- dced FATAL rpc rpc_svc_general
0xa44b1bc4
(rpc__dg_maintain_init) Can't create UUID
config_epmap[50]: 1420 Resources lost(coredump)
ERROR:   dced -i failed to start.
        Press <RETURN> to continue, CTRL-C to exit:

[06/30/94 public]
What's happening is that an RPC initialization function is trying to
create a UUID and treating failure as a fatal error.  It is doing
the dce_svc_printf() call with "svc_c_sev_fatal | svc_c_action_abort"
so it's the intended behavior.  Changed to RPC component who can cancel
if they wish.

[7/1/94 public]
Yes, it a bigtime fatal error if we can't create a uuid.
See OT 6224 where I added code to check the return value of uuid_create().
There really isn't anything else to do at this point but die.
Bug canceled.

[7/1/94 public]

I know I'm picky :-), but how about changing svc_c_action_abort to
svc_c_action_exit_bad in rpc__dg_maintain_init()::dgclive.c? The core file
is wasting a disk space.

[7/1/94 public]
If a submit request were sent in for this, I would inclined to approve it.
hint, hint.
Make sure you catch *all* the uuid_create failures in runtime.

[7/8/94 public]

There are only two places where the DG runtime aborts because of
uuid_create() failure, dgclive.c and dgcct.c . The CN runtime doesn't abort
immediately, but updates the association's status and posts the local error
event.

[7/15/94 public]

Submitted.



CR Number                     : 11148
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : FREE macro in cover_ool/util_macros.h use non ANSI C free.
Reported Date                 : 6/30/94
Found in Baseline             : 1.0.3
Found Date                    : 6/30/94
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : test/rpc/idl/cover_ool/util_macros.h, util_xmit.c
Sensitivity                   : public

[6/30/94 public]

The FREE macro defined in util_macros.h uses a free() returning int as
opposed to the ANSI C free() which has return type void.

[6/30/94 public]
Remove the FREE macro.
Closed.



CR Number                     : 11138
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 7713
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : command_ref
Short Description             : add doc on -c option on
uuidgen man page
Reported Date                 : 6/29/94
Found in Baseline             : 1.1
Found Date                    : 6/29/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : command_ref/man1rpc/uuidgen.1rpc
Sensitivity                   : public

[6/29/94 public]

The new -c option to uuidgen needs to be documented.

The uuidgen program currently provides three output formats:
 - the "default" just prints the string form of the uuid. 
 -s outputs the uuid as a C static initializer
 -i outputs the uuid as a "template" idl file.

The -c option allows you to supply a pre-existing uuid, which is output by
uuidgen in the output format you select; it makes most sense when used with
"-s" in the event that you're hard-coding a uuid into a program (it's more
efficient that using uuid_from_string() to convert the character string
form, and less error-prone than doing the conversion manually).

The -c must come last on the command line; any options after the -c are
ignored.

typical usage:

% uuidgen -s -c 1251ace6-93a1-11cd-95ad-0800097086e4
    = { /* 1251ace6-93a1-11cd-95ad-0800097086e4 */
        0x1251ace6,
        0x93a1,
        0x11cd,
        0x95,
        0xad,
        {0x08, 0x00, 0x09, 0x70, 0x86, 0xe4}
      };

[6/30/94 public]

Assigned this CR to John Shirley (OSF RPC writer)

[08/09/94 public]
Reassigned to myself.

[08/23/94 public]
Changed severity to "B".

[08/25/94 public]
Fixed.  Verified by Tom Jordahl.

[09/01/94 public]
Closed bug.



CR Number                     : 11132
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : portability change to ns_s_attr.c
Reported Date                 : 6/29/94
Found in Baseline             : 1.1
Found Date                    : 6/29/94
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : ns_s_attr.c
Sensitivity                   : public

[6/29/94 public]

The following line in ns_s_attr.c:

rpc__nscodesets_to_codesets(es_h, (long *)length, (idl_byte *)(*value));

should be changed to

rpc__nscodesets_to_codesets(es_h, (idl_long_int *)length, (idl_byte *)(*value));

The cast to (idl_long_int *) is more portable than (long *).

[7/28/94 public]
Fix submitted.



CR Number                     : 11082
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : Memory leak in libidl marshalling
Reported Date                 : 6/24/94
Found in Baseline             : 1.0.3
Found Date                    : 6/24/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : ndrmi2.c
Sensitivity                   : public

[6/24/94 public]

The code submitted for OT 10345 has introduced a small memory
leak in src/rpc/idl/lib/ndrmi2.c.  Two calls to
rpc_ss_pointee_desc_from_data have been added in the 
rpc_ss_ndr_marsh_pointee routine.  These calls allocate memory
which should be release by calling rpc_ss_rlse_data_pointee_desc.
This call should be added at the end of the routine.

[6/27/94 public]
Looking at the code, there already is a call to rpc_ss_rlse_data_pointee_desc()
at the bottom of rpc_ss_ndr_marsh_pointee():

   pointee_desc.dimensionality = 0;
    do {
        type_byte = *defn_vec_ptr;

.......

                RAISE(rpc_x_coding_error);
        }
    } while (type_byte != IDL_DT_EOL);
    rpc_ss_rlse_data_pointee_desc( &pointee_desc, IDL_msp );

}

Perhaps a merging error at HP?
Please re-open if I missed something here.

[6/27/94 public]

Reopened. 
Tom, the code you quoted above is from rpc_ss_ndr_m_struct_pointees.
The call is still missing in rpc_ss_ndr_marsh_pointee.

[6/27/94 public]
OK, right.  Fix submitted. :-)

[7/13/94 public]

Oops, I composed the following reply before realizing that the fix
has already ben submitted.  Here it is for the record...

lmm, did you actually confirm that there is a memory leak here, or are
you inferring that from reading the code?

From a quick look at the code, I believe it may just be an optimization
that rpc_ss_rlse_data_pointee_desc is not "called".  You'll find that
rpc_ss_rlse_data_pointee_desc is a macro which does this:

    if ((p_pointee_desc)->dimensionality > 0) \
    { \
        rpc_ss_mem_item_free(&IDL_msp->IDL_mem_handle, \
                                      (byte_p_t)((p_pointee_desc)->Z_values)); \
    }

I believe that in the code sites you mention,
(p_pointee_desc)->dimensionality
is always 0 since the pointee is a pointer which does not have
dimensionality.

I'll agree that such optimizations can be risky and I would not oppose
adding in the rpc_ss_rlse_data_pointee_desc calls, but I don't believe
from a quick code inspection that there is a real memory leak here.



CR Number                     : 11063
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 11062
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_gd
Short Description             : Document opaque context handles
Reported Date                 : 6/23/94
Found in Baseline             : 1.1
Found Date                    : 6/23/94
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : app_gd/rpc/idl.gpsml
Sensitivity                   : public

[6/23/94 public]

The idl compiler now has the following new functionality in it:


Start included text ------------------------

0 Opaque context handle support in DCE 1.1

The unextended IDL compiler allows context handles to be specified by
either of the following methods:
    o use the context_handle attribute on a parameter of type void *.
    o use the context_handle attribute on a type that is defined as void *.

The opaque context handle support allows this additional way to specify
a context handle:
    o use the context_handle attribute on a type that is defined as a
      pointer to a structure by tag name.

The context_handle attribute indicates that the data is a pointer-sized
object that serves as the handle, or method of accessing, some object.
A context handle is opaque to, and must never be written by, the caller
code.  To emphasize this, IDL previously required that context handles be
defined as type (void *).

To the called operation in an RPC server, however, the context handle is
not opaque.  Most often, it is the address of a structure in memory.
Since the IDL-emitted type for the context handle is (void *), the server
code must use casts extensively in its manipulation of the context handle.

The opaque context handle feature alleviates this problem.  A context
handle can be defined as a forward reference to structure type by tag.
Normally, IDL requires that the forward referenced type be subsequently
defined in the IDL file or something it imports.  With the opaque context
handle feature, the forward referenced type need not be defined.  The
IDL-emitted type for the context handle is, for example, (struct foo *).
This type is still opaque to the caller, because struct foo is never
fully defined.  Yet it provides type checking and alleviates the need for
casting in the server code, which can include the actual definition of
struct foo.

0.1 Rules for using opaque context handles

The rules for opaque context handles are the same as for the previously
existing, void *, context handles.

A structure type in a context handle type definition must be referenced by
tag name, not type name.  For example, the first of these declarations is
valid; the second is not.
    typedef [context_handle] struct struct_tag * valid_ch_t;    /* OK */
    typedef [context_handle] struct_type * invalid_ch_t;        /* Error */

A structure type in a context handle type definition may also be defined
in the IDL file, though this is not generally recommended because it
violates the opaqueness of the context handle type.  For example, this
definition could either precede or follow the definition of valid_ch_t.
    typedef struct struct_tag {long l;} struct_type;

0.2 Examples

    /* A "normal" context handle for reference */
    typedef [context_handle] void * void_ch_t;

    /* An "opaque" context handle */
    typedef [context_handle] struct opaque_struct * opaque_ch_t;

    /* Operations using both "normal" and "opaque" context handles */
    void ch_oper(
        [in] void_ch_t v1,
        [in,out] void_ch_t *v2,
        [out] void_ch_t *v3,
        [in] opaque_ch_t o1,
        [in,out] opaque_ch_t *o2,
        [out] opaque_ch_t *o3
    );

    void_ch_t void_ch_oper([in] handle_t h);

    opaque_ch_t opaque_ch_oper([in] handle_t h);


end included text -------------------------------

[7/19/94 public]

Added information about "opaque" context handles to
the discssion of "normal" context handles in the
section entitled "Context Handles" in the Interface
Definition Language chapter of the Application Development
Guide, RPC part. Will give a copy to Tom Jordahl for
technical review/verification.

[7/19/94 public]

Incorporated Tom's comments on my writeup and marked
this CR verified.

[08/30/94 public]
Closed bug.



CR Number                     : 11062
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 7320
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : Add opaque context handle support to idl
Reported Date                 : 6/23/94
Found in Baseline             : 1.1
Found Date                    : 6/23/94
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : ./rpc/idl/idl_compiler/astp_cpx.c
./rpc/idl/idl_compiler/checker.c
./rpc/idl/idl_compiler/clihamts.c
./rpc/idl/idl_compiler/irepgen.c
./rpc/idl/idl_compiler/nidlmsg.m
./rpc/idl/idl_compiler/propagat.c
./rpc/idl/idl_compiler/sstubmts.c
./test/rpc/idl/context2/context2.idl
./test/rpc/idl/context2/manager.c
Sensitivity                   : public

[6/23/94 public]

This is from Rico at DEC:

opaque context handle

 - Code changes to:
        src/rpc/idl/idl_compiler files: astp_cpx.c checker.c clihamts.c
                                        irepgen.c nidlmsg.msg propagat.c
                                        sstubmts.c

 - Changes to our runtime test context2
    This consists of three files:
        client_a.c context2.idl manager.c
    and the files that are common to our tests, which I've already sent.
    The changed files are context2.idl and manager.c.

 - Note: These changes should also satisfy CR 7320, "[local] opaque pointers
    should work".  It asked for the capability to do
        typedef struct private_struct *abstract_handle;
    in a [local] interface.  It will work if you do
        typedef [context_handle] struct private_struct *abstract_handle;



CR Number                     : 11044
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : i18n
Short Description             : some code set i14y evaluation failed on 486
Reported Date                 : 6/22/94
Found in Baseline             : 1.1b10
Found Date                    : 6/22/94
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b19
Affected File(s)              : cs_s_stub.c
Sensitivity                   : public

[6/22/94 public]

  Default logic for code set I14Y failed on 486 functional tests.
The error says "conversion between codesets not possible", when it
should be.

[9/15/94 public]
This is impoartant - raising to P1.

[9/23/94 public]

  The problem was fixed by copying the terminating null bytes into
a buffer.

[9/26/94 public]

  Nightly build worked.



CR Number                     : 11043
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : i18n
Short Description             : code set registry functional test
need to be machine dependent
Reported Date                 : 6/22/94
Found in Baseline             : 1.1b10
Found Date                    : 6/22/94
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : access_cs_rgy.c code_set_registry.txt
Sensitivity                   : public

[6/22/94 public]

  Since code set names differ platform by platform, functional test for
code set registry access needs to be separated to a machine dependent
directory.  The functional test failed on 486 (and probably RIOS, too)
due to the code set name mismatch problem.

[6/22/94 public]

  Fix was submitted.

  src/test/functional/rpc/runtime/i18n_api/ts/cs_rgy/HP800/access_cs_rgy.c
				"		    /RIOS/access_cs_rgy.c
				"		    /AT386/access_cs_rgy.c
				"		    /HP800/code_set_registry.txt

  HP code_set_registry.txt was modified to null-out Korean entry, so the
negative test for accessing code set registry could pass.

[6/23/94 public]

  Fix worked.  Done.



CR Number                     : 11041
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : i18n
Short Description             : wchar_t functional test failed
Reported Date                 : 6/22/94
Found in Baseline             : 1.1b9
Found Date                    : 6/22/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b20
Affected File(s)              : cs_s_stub.c plus functional tests.
Sensitivity                   : public

[6/22/94 public]

  Most of the wchar_t functional tests for RPC I18N API failed, probably
due to the following problem.  I've been noticing it for a while, but could
not get fixed due to the other higher priority tasks.

   Current implementation for wchar_t_to_netcs has the following signature:

       PUBLIC void wchar_t_to_netcs
       (
               rpc_binding_handle_t    h,
               unsigned32              tag,
               wchar_t                 *ldata,
               unsigned32              l_data_len,
               idl_byte                *wdata,
               unsigned32              *p_w_data_len,
               error_status_t          *status
       )

   'l_data_len' is the number of wchar_t elements in 'ldata'.  Since we will
 not send wchar_t type data over the network (wchar_t is a process code, which
 is not compatible with various operating systems), we have to convert
 wchar_t data type to multibyte data type.

   When this conversion takes place, the resulting multibyte length is
 different from 'l_data_len'.  In case of fixed length array and varying
 length array, 'p_w_data_len' is NULL.  IDL library assumes 'l_data_len'
 will be the length of network data. (And that's the specification of
 I-char support in IDL).  The length of multibyte string is usually larger
 than the length of wchar_t string.

   So when server receives multibyte string, it is usually shorter than
 the entire multibyte string.  Consequently, at the server side, when
 this multibyte string is converted to wchar_t string, 'invalid character
 error' occurs.

[9/15/94 public]
This is important - raising to P1.

[9/23/94 public]

  This problem was fixed partially with the fix CR 11044.  Currently, wchar_t
operations are working with fixed and varying array data types.  It still
has problems with conformant array data type.  I will still try to fix
it, but it probably goes into un-integrated tree, due to the main line tree
closing.

[9/27/94 public]

  Well, I found the fix before the tree is completely closed.  The fix is
mostly in functional tests.  size_is value should have been 
'(wcslen + 1) * sizeof(wchar_t)'.

[9/28/94 public]

  Nightly worked.  Done.



CR Number                     : 10981
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : cn
Short Description             : casting pointer to unsigned32
Reported Date                 : 6/16/94
Found in Baseline             : 1.1
Found Date                    : 6/16/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b11
Affected File(s)              : cnpkt.h
Sensitivity                   : public

[6/16/94 public]

The macro RPC_CN_PKT_AUTH_TLR defined in cnpkt.h is casting a pointer
to unsigned32.  It should be changed to unsigned_char_p_t.  The new
macro should be defined as follows:

#define RPC_CN_PKT_AUTH_TLR(pkt_p, pkt_len)\
    (rpc_cn_auth_tlr_t *) ((unsigned_char_p_t)(pkt_p) + pkt_len - RPC_CN_PKT_AUTH_TLR_LEN(pkt_p))

[6/20/94 public]
Made the suggested change.
Submitted.



CR Number                     : 10979
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl&runtime
Short Description             : handle_t and idl_es_handle_t badly opaque
Reported Date                 : 6/16/94
Found in Baseline             : 1.1
Found Date                    : 6/16/94
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : idl_es.h, idlbase.h, idlddefs.h runtime/com.h
Sensitivity                   : public

[6/16/94 public]
The RPC(and IDL) convention seems to be that opaque handles are
defined as struct {int dummy } *handle_t.  Ick ick ick.  They should
be "void *handle" or "struct you_dont_need_to_know *handle".

Here is the bug.  IDL encoding services generates idl_handle_t's.
The generated function, however, wants handle_t's.  Those types aren't
the same.  I get compiler warnings.

[6/16/94 public]
Well, we do have this in idlbase.h:
/*
 * The definition of the primitive "handle_t" IDL type.
 *
 * 1/10/94 CBrooks
 * previously, the definition of handle_t as a void * was dependent
 * on the _MSDOS macro being defined
 *
 */
#ifdef HANDLE_T_IS_VOID_PTR
typedef void *handle_t;
#else
typedef struct
{
    unsigned short data_offset;
} *handle_t;
#endif /* HANDLE_T_IS_VOID_PTR */

Any reason why we didn't turn this ifdef on Charlie?
I suppose we should just remove the ifdef and make this
and idl_es_handle_t both "typedef void *".

Do we know what (if any) affect this will have on apps?

[6/16/94 public]

The above code was originally #ifdef'ed as _MSDOS. At this point,
after talking with Rich, it is probably the case that all XXX_handle_t
could be changed to void *. 

My assumption is that this should have no effect on apps whatsover,
since any reference to the handle in the called function must, of
necessity, been converted to a pointer to the correct (hidden) type. 
Hence, casting of a "void *" to a "type *" will be a no-op (in C, not
C++).

Easiest strategy: we should make this change in idlbase.h, and idl_es.h, and 
do a scratch build. If everything works, we could submit this under 
the code cleanup guidelines for 1.1. 

More comprehensive and nicer strategy: typedef the handle values to 
be 
	typedef struct you_dont_need_to_know * xxx_handle_t 

and provide a DEBUG facility to make the internals of the structure
visible (a la X/Windows private header files). This would be a help in 
debugging the code, whilst making it private (opaque) for production purposes.

[6/17/94 public]
Did a complete scratch build (including stup_all) on both the HP and
the 486 with both handle_t and idl_es_handle_t defined as:
	typedef void *
and everything works.

So, when the tree opens up, I will submit.

[6/20/94 public]
Files submitted.

[6/21/94 public]
But Rich has convinced me that the right way to do it is to
define the handle's using via struct.

So I am going to go back and do it the right way.

[6/22/94 public]
Submitted definitions using strcuture tag so
this will be nice for opaqueness and debuggers.



CR Number                     : 10960
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : idl test mtsvary fails for DG
Reported Date                 : 6/15/94
Found in Baseline             : 1.1
Found Date                    : 6/15/94
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : rpc/runtime/dg.c rpc/runtime/dgccall.c
Sensitivity                   : public

[6/15/94 public]

While running the idl tests, the pipefault and threads tests failed
for tcpip and mtsvary failed for udp.

The following is the output in the results file for tcp:

****TEST pipefault START****
PASS 0
Pipe empty exception
Pipe order exception
Binding my_handle
Unbinding my_handle
***FAILURE***: Unexpected exception
***FAILURE***: unexpected CMA exception rpc_x_unknown_reject
Binding my_handle
Unbinding my_handle
Pipe discipline exception
Test Complete
Summary: 1 passes, 1 failures
****server pipefault output****
****TEST pipefault END****
Client return code for pipefault: 1
****TEST threads START****
Error in thread_main, thread #3
Error in thread_main, thread #0
Error in thread_main, thread #5
Error in thread_main, thread #2
Error in thread_main, thread #7
Error in thread_main, thread #8
Error in thread_main, thread #9
Thread 0 exited with non-NULL context!
Thread 2 exited with non-NULL context!
Thread 3 exited with non-NULL context!
Thread 5 exited with non-NULL context!
Thread 7 exited with non-NULL context!
Thread 8 exited with non-NULL context!
Thread 9 exited with non-NULL context!
PASS 0
***FAILURE***: unexpected CMA exception rpc_x_connection_closed
***FAILURE***: unexpected CMA exception rpc_x_connection_closed
***FAILURE***: unexpected CMA exception rpc_x_connection_closed
***FAILURE***: unexpected CMA exception rpc_x_connection_closed
***FAILURE***: unexpected CMA exception rpc_x_connection_closed
***FAILURE***: unexpected CMA exception rpc_x_connection_closed
***FAILURE***: unexpected CMA exception rpc_x_connection_closed
***FAILURE***: unexpected CMA exception rpc_x_connect_rejected
****server threads output****
****TEST threads END****
Client return code for threads: 0


The following is the output in the results file for udp:

****TEST mtsvary START****
PASS 0
op0(j=8) completed - 0 failures
op0(j=9) completed - 0 failures
op0(j=10) completed - 0 failures
op0(j=11) completed - 0 failures
op0(j=12) completed - 0 failures
op1 completed - 0 failures
op2 completed - 0 failures
Returned from op2 call with inside-out data limits
***FAILURE***: unexpected CMA exception rpc_x_invalid_bound
****server mtsvary output****
****TEST mtsvary END****
Client return code for mtsvary: 0

[6/15/94 public]
Ran the complete idl test suite for cn and dg on RIOS, 486, and HP.
This was on the nightly build of 6/14-15 (13-14 for RIOS).

The pipfault test is a known failure, see ot 10677 and 9550.
A fix is forthcomming on this.

The threads test passes on all three platforms.

The mtsvary test, however, fails with the DG protocol.
Since I have integrated some idl enhancements, I will
investigate, but HP should also look at this since the DG
runtime has changed.

[6/15/94 public]
Tracked this down to the following change from Rico @ DEC that
I integrated in to the idl library.

src/idl/lib/ndrui.c:

10a11,14
>  * Revision 1.1.6.3  1994/05/31  18:56:43  tom
>  * 	From DEC: unmarshalling security enhancement (OT 10807).
>  * 	[1994/05/31  18:55:47  tom]
>  *
14c18
<  *
---
>  * 
1184a1189,1199
>     if (Z_values != NULL)   /* NULL possible for transmit_as case */
>     {
>         for (i=0; i<dimensionality; i++)
>         {
>             if ((range_list[i].upper - range_list[i].lower) > Z_values[i])
>             {
>                 /* Bogus data stream with A,B values outside of Z bound value */
>                 RAISE(rpc_x_invalid_bound);
>             }
>         }
>     }

What is strange (but I must be missing something) is the test code
seems to explicitly catch this exception.

src/rpc/idl/mtsvary/client_aux.c:

    TRY
        f = -1;
        l = 10;
        opc1(h, v, b, hy, u, sm2, &f, &l, a);
        printf("**Failure**: first call to opc1 didn't get exception\n");
        failures++;
    CATCH(rpc_x_invalid_bound)
#ifndef _MSDOS
    CATCH_ALL
        printf("Unexpected exception in first call to opc1\n");
        print_exception(THIS_CATCH);
        failures++;
#endif
    ENDTRY

Rico, any help?

[6/16/94 public]
The problem is definitely in the idl library change.  The
CATCH caluse *is* catching the first invalid_bounds exception,
however the new code is raising *another* exception that
the program does not expect.

For some reason, the second exception either does not occur
when using the CN protocol, or it is supressed.
Do an DG type from HP (Mark, Seiichi) think that there
has been any changes to the DG code that would show this problem?

[6/16/94 public]

I'm not sure if this helps. But, could you try RPC_DEBUG=33.1 (no private
socket)? If this changes the behavior, then it's related to the private
socket.

[6/16/94 public]
Turning private socket off has no affect.
I knew it wasn't the private socket code exactly, but something
having to do with the exception handling state of the DG code
which may affect this.  I'm not sure that trying to figure out
why it fails on DG and passes on CN isn't a red herring, but
its the only idea I have right now.

[6/16/94 public]
Well, after most of the day chasing this, I have to throw it back 
to the DG runtime.  I built a libdce with the bl-9 runtime and
the latest IDL library and the mtsvary test passes.

Plenty of DG files have changed since then, including some cancelability
fixes Mark submitted, and additional MBF code.  Here are the list of defects
in the 'fix'state relating to DG rpc.

10852 rpc   fix    tatsu_s@ 06/02/94 A 1 dced functional tests (keytab_create, h
10808 rpc   fix    markar   05/31/94 B 2 recv_pkt_private does not cancel if rec
10444 rpc   fix    tatsu_s  04/22/94 C 2 WAY failure gets mapped to comm failure
10377 rpc   fix    markar   04/14/94 B 2 ftserver dumps core
10345 rpc   fix    rico     04/13/94 B 1 unmarshalling error in 103 interpreter 
 9614 rpc   fix    tatsu_s  12/14/93 C 2 WAY callback failure with pkt_privacy
 9551 rpc   fix    tatsu_s  11/23/93 B 2 DG fault PDU not decrypted in pkt_priva
 8643 rpc   fix    tatsu_s  09/21/93 B 2 CL rpc does not consist with encryption
 8053 rpc   fix    tatsu_s  05/25/93 C 3 Perf test security errors
 7465 rpc   fix    tatsu_s  03/10/93 C 3 assert in pkt_alloc()

[6/17/94 public]

The second exception is raised by the second opc1() call in the
unmarshaling code. (The first opc1() call raises the invalid bound
exception in the marshaling code before transmitting any data to the
server.) What's different between CN and DG? It's the fragment size. The
second opc1() call's IN/OUT data sizes are 2238/2242 bytes, which fit into
a single fragment in CN, but not in DG. Yup, it's a bug in MBF. The two
lines fix will be included in the next MBF code drop. What exactly wrong
was the server sending the fragment which size wasn't a multiple of 8
bytes.

[6/27/94 public]

The fix was submitted.

[6/27/94 public]
And I verified that indeed, the idl tests pass with the nightly of 6/26-27.
Closed.



CR Number                     : 10876
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Can't bind to /.:
Reported Date                 : 6/7/94
Found in Baseline             : 1.1
Found Date                    : 6/7/94
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1beta
Fixed In Baseline             : 1.1
Affected File(s)              : krbdgsrv.c
Sensitivity                   : public

[6/7/94 public]
When configuring a cell on an HP, I got:

S:****** Starting cdsadv...
S:****** Starting cdsd...
ERROR:   Error while setting ACLs on /.:
           Message from acl_edit:
           ERROR: communications failure (dce / rpc)
         Unable to bind to object /.:

Binaries were from nightly build of 6/6/94.

[6/7/94 public]
There were no changes to RPC for 2 months when this problem started ocurring.
CDS, on the other hand, has changed almost every source file.
Moving to CDS.

[6/7/94 public]
Looks like this is a dup of the dced authenticated rpc problem OT #10852.
I will verify when the fix for that defect comes in.

[6/7/94 public]

Don't jump on to it. cdsd *is* crushing in the rpc runtime (I have the
stack trace which I'm investigating because this bug prevents me to set up
the cell to workon OT 10852), but, it started after the security drop and
the symptom is different from OT 10852. (Although they both are related to
WAY auth.)

[6/7/94 public]
Still unclear if its cdsd which is stomping on DG's data,
or if there is a code problem in the MBF code.

We are going to back out the 3 files submitted to cds since Thursday (6/2)
to see if this helps.  Thursday nights build did work and it did have
the latest security drop in it (although we aren't ruling sec out 100%).

Here is more info:


Program received signal SIGFPE (8), Arithmetic exception
0x801b713a in rpc__dg_call_recvq_insert (call=0x86166c0, rqe=0x81a357c,
    wake_thread=0x8326b2f "") at ../../../../src/rpc/runtime/dgcall.c:1280
1280                unsigned32 max_queue_len =
1281                RPC_C_DG_MAX_RECVQ_LEN / MIN(call->n_resvs, call->max_resvs);


(gdb) p call->n_resvs
$1 = 0 '\000'

------ here is the backtrace -----
#0  0x801b713a in rpc__dg_call_recvq_insert (call=0x86166c0,
    rqe=0x81a357c, wake_thread=0x8326b2f "")
    at ../../../../src/rpc/runtime/dgcall.c:1280
#1  0x801bc432 in rpc__dg_do_response (sp=0x8195fb0, rqe=0x81a357c,
    ccall=0x86166c0) at ../../../../src/rpc/runtime/dgclsn.c:539
#2  0x801c25d1 in recv_dispatch (sp=0x8195fb0, rqe=0x81a357c)
    at ../../../../src/rpc/runtime/dglsn.c:3019
#3  0x801c2f19 in rpc__dg_network_select_dispatch (sock=8, sp_=0x8195fb0,
    is_active=1, st=0x83274d0) at ../../../../src/rpc/runtime/dglsn.c:3430
#4  0x801b6af8 in rpc__dg_call_wait (call=0x86166c0,
    event=rpc_e_dg_wait_on_network_event, st=0x83274d0)
    at ../../../../src/rpc/runtime/dgcall.c:948
#5  0x801b4e7e in rpc__dg_call_receive_int (call=0x86166c0,
    data=0x8327518, st=0x83274d0) at ../../../../src/rpc/runtime/dg.c:525
#6  0x801b56b8 in rpc__dg_call_transceive (call_=0x86166c0,
    xmit_data=0x83273ac, recv_data=0x8327518, ndr_format=0x83274dc,
    st=0x83274d0) at ../../../../src/rpc/runtime/dg.c:888
#7  0x8018c7ae in rpc_call_transceive (call_h=0x86166c0,
    in_call_args=0x83273ac, out_call_args=0x8327518,    at ../../../../src/rpc/runtime/comcall.c:326
#8  0x801cd31e in op3_csr (h=0x86160a4, actuid=0x8615cc4,
    boot_time=771003309, in_data=0x83278b4 ">Bm\022r8\035 ",
    in_len=16, out_max_len=1404, seq=0x8327c0c, cas_uuid=0x8327bf4,
    out_data=0x8616140 "", out_len=0x861613c, st=0x8327cb0)
    at conv_cstub.c:701
#9  0x801d3886 in rpc__krb_dg_who_are_you (key=0x8615fc8, h=0x86160a4,
    actuid=0x8615cc4, boot_time=771003309, seq=0x8327c0c,
    cas_uuid=0x8327bf4, stp=0x8327cb0)
    at ../../../../src/rpc/runtime/krbdgsrv.c:223

------- here is the value of call 

(gdb) p *call
$4 = {c = {link = {next = 0x0, last = 0x0}, m = {m = {field1 = 0x838bc60,
        field2 = 841, field3 = 3}}, protocol_id = 1, is_server = 0, u = {
      server = {cancel = {accepting = 0, queuing = 0, had_pending = 0,
          count = 0}, cthread = {is_queued = 0, executor = 0,
          optargs = 0x0, thread_h = {field1 = 0x0, field2 = 0,
            field3 = 0}, qelt = 0x0}}, client = {dummy = 0 '\000'}}},
  next = 0x0, state = rpc_e_dg_cs_recv, status = 0,
  state_timestamp = 207, cv = {c = {field1 = 0x838bcb0, field2 = 340,
      field3 = 2}, mp = 0x0, stats = {init = 0, delete = 0, wait = 0,
      signals = 0}}, xq = {head = 0x0, first_unsent = 0x0, tail = 0x0,
    rexmitq = 0x0, part_xqe = 0x0, hdr = {_rpc_vers = 4 '\004',
      _ptype = 0 '\000', flags = 32 ' ', flags2 = 0 '\000',
      drep = "\020\000", serial_hi = 0 '\000', object = {time_low = 0,
        time_mid = 0, time_hi_and_version = 0,
        clock_seq_hi_and_reserved = 0 '\000', clock_seq_low = 0 '\000',
        node = "\000\000\000\000\000"}, if_id = {time_low = 859447926,
        time_mid = 0, time_hi_and_version = 0,
        clock_seq_hi_and_reserved = 13 '\r', clock_seq_low = 0 '\000',
        node = "\000\200\234\000\000"}, actuid = {time_low = 195634560,
        time_mid = 33294, time_hi_and_version = 7453,
        clock_seq_hi_and_reserved = 146 '\222', clock_seq_low = 125 '}',
        node = "\000\000@)\207V"}, server_boot = 771003350, if_vers = 3,
      seq = 19, opnum = 3, ihint = 65535, ahint = 65535, len = 48,
      fragnum = 0, auth_proto = 0 '\000', serial_lo = 0 '\000'},
    awaiting_ack_timestamp = 207, timestamp = 207, rexmit_timeout = 10,
    base_flags = 32, base_flags2 = 0, next_fragnum = 1,
    next_serial_num = 1, last_fack_serial = 65535, window_size = 8,
    cwindow_size = 1, max_rcv_tsdu = 24576, max_snd_tsdu = 24576,
    max_frag_size = 8192, snd_frag_size = 1024, blast_size = 0 '\000',
    max_blast_size = 4 '\004', xq_timer = 8, xq_timer_throttle = 1,
    high_cwindow = 1 '\001', freqs_out = 1 '\001', push = 1,
    awaiting_ack = 0, first_fack_seen = 0}, rq = {head = 0x0,
    last_inorder = 0x0, high_rcv_frag_size = 1524, next_fragnum = 0,
    high_fragnum = 65535, high_serial_num = 0, head_fragnum = 65535,
    head_serial_num = 65535, window_size = 3, wake_thread_qsize = 6144,
    max_queue_len = 96, queue_len = 0 '\000', inorder_len = 0 '\000',
    recving_frags = 0, all_pkts_recvd = 0, is_way_validated = 0},
  sock_ref = 0x8195fb0, actid_hash = 46063, key_info = 0x0,
---Type <return> to continue, or q <return> to quit---
  auth_epv = 0x0, addr = 0x816d118, timer = {next = 0x803842e0,
    trigger = 212, frequency = 5,
    proc = 0x801baab8 <rpc__dg_ccall_timer>, parg = 0x86166c0},
  last_rcv_timestamp = 0, start_time = 207, high_seq = 19,
  pkt_chain = 0x0, com_timeout_knob = 5, thread_id = {field1 = 0x8118420,
    field2 = 16, field3 = 4}, refcnt = 3 '\003', n_resvs = 0 '\000',
  n_resvs_wait = 0 '\000', max_resvs = 6 '\006', blocked_in_receive = 0,
  priv_cond_signal = 0, stop_timer = 0, is_cbk = 0, is_in_pkt_chain = 0}
(gdb)

[6/7/94 public]
Thanks to Seiichi, the fix was to adjust the variable MAX_AUTH_MESSAGE_LEN
to be the correct size in krbdgsrv.c

Fix submitted (tested on HP and 486).



CR Number                     : 10872
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : idl/lib/sscmaset.c
Short Description             : Possible compiler warning
Reported Date                 : 6/6/94
Found in Baseline             : 1.0.3
Found Date                    : 6/6/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b13
Affected File(s)              : rpc/idl/lib/sscmaset.c
Sensitivity                   : public

[6/6/94 public]

Licensee reported that when using [their] ANSI C, they had to add the 
following type cast for the call of fread since fread's return type
is size_t:

<     if (fread ((char *)ndr_g_ascii_to_ebcdic, 1, 512, fid) < 512)
---
>     if ((int)fread ((char *)ndr_g_ascii_to_ebcdic, 1, 512, fid) < 512)
"

Apparently, their compiler is not that smart to tell that constant 512
is a positive number, that there is no danger in converting integer 512 to
unsigned integer 512.

On the other hand, there may be some/many such compilers around. We may want
to do sth to avoid compiler warning, like assign the fread return to a variable first.

[6/7/94 public]

Exactly what it the compiler complaining about? It seems to me that
this is an "unsigned relop signed" comparison, which should result in 
a conversion of the unsigned value to a signed value (differs from K&R
C). Certain compilers will warn about this as a conversion problem if 
warning levels are set high enough.

[6/7/94 public]
For ANSI C, the usual binary conversion is for the signed one to be converted
to be unsigned (maybe K&R C does the other way). So when a comparison invloves
one unsigned and one signed, the signed one will be automatically converted
to be unsigned first. In doing so, there is possibility that a negative 
signed will become a large unsigned. Strict ANSI C compiler should give
warning for this.

THe problem here is, the signed party is 512, a positive constant. There is
no danger to convert it into an unsigned. A smart compiler should not give
warning.

[06/07/94 public]
I bet the compiler is warning that the semantics of "signed relop unsigned"
changed from traditional to ANSI C.  Cleanest "fix" is to write (size_t)512.

[7/15/94 public]
Cast the 512 with size_t.
Closed.



CR Number                     : 10866
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : build broke in nightly build.
Reported Date                 : 6/6/94
Found in Baseline             : 1.1
Found Date                    : 6/6/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1beta
Fixed In Baseline             : 1.1
Affected File(s)              : rs_replist.acf
Sensitivity                   : public

[6/6/94 public]
Nightly build broke due to undefineds in krbdgsrvc. file.

[]

Related additional bug

/project/dce/build/dce1.1-snap/src/security/server/rrs/rrs_rep_remote.c
:123: too few arguments to function In function 'rrs_rep_replist_read'
*** Error code 1

[6/8/94 public]
Fix submitted by Michael Fairbrother.



CR Number                     : 10852
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486,hppa
S/W Ref Platform              : osf1,hpux
Component Name                : rpc
Subcomponent Name             : cl
Short Description             : dced functional tests
(keytab_create, hostdata_create, secval_start) fail with
rpc_s_who_are_you_failed error.
Reported Date                 : 6/2/94
Found in Baseline             : 1.1
Found Date                    : 6/2/94
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1beta
Fixed In Baseline             : 1.1
Affected File(s)              : rpc/runtime/dglsn.c
Sensitivity                   : public

[6/2/94 public]

With the latest nightly build - 
dced API functional tests fail with the errors:
rpc_s_who_are_you_failed or rpc_s_protocol_error
when using secval_start, keytab_create, or hostdata_create.

These tests used to pass before. 
With the same latest nightly build and with "ncacn_ip_tcp", these
tests pass.

[6/3/94 public]

Does it happen only on 486? Can you get any debug info from the *server*
side? (RPC_DEBUG=0.10 used to work, but the serviceability change requires
other magic, which I don't know.) The MBF code drop included a lot of
pkt_privacy related bug fixes and the DG auth-RPC code changes, which might
be the cause of this failure. Unfortunately, I don't have a 486 box to
build/test it.

[6/3/94 public]
Just a datapoint, I ran all the rtandidl and idl functional tests
using DG and all passed on the nightly build of 6/2/94.
This includes the 'auth' rtandidl tests.

[6/6/94 public]

With the following patch to rpcsvc.c, we can get the debug output:

--- ../../../link/src/rpc/runtime/rpcsvc.c	Thu May 19 17:15:05 1994
+++ rpcsvc.c	Fri Jun  3 18:05:48 1994
@@ -21,9 +21,9 @@
 #include <rpcsvc.h>
 #include <stdarg.h>
 
-/*
+
 dce_svc_handle_t rpc_g_svc_handle;
-*/
+
 DCE_SVC_DEFINE_HANDLE(rpc_g_svc_handle, rpc_g_svc_table, "rpc")
       
 
@@ -66,6 +66,8 @@
      * in rpc_g_dbg_switches[], or ...
      */
 
+    rpc_g_svc_handle = dce_svc_register(rpc_g_svc_table, "rpc", &status);
+
     /*
      * This silliness is a placeholder, so that we
      * remember to do things differently in the kernel

Could you send me the instruction on how to run the test, so that I can
reproduce it here at Chelmsford?

[6/7/94 public]
When the test failed, the test was creating authenticated binding
handle using protect_level_integrity.

I ran the tests successfully with protect_level_connect,
protect_level_call,
protect_level_pkt.

But failed with protect_level_default, protect_level_integrity,
protect_level_privacy.

Also note that the BIG security code drop was not in, when the
failures happened.

[6/7/94 public]

First of all, this bug has nothing to do with MBF. :^) It started to happen
when dced started to register the forward map function.

The call to rpc__if_lookup() in recv_dispatch()::dglsn.c is modifying the
pdu header (ihint field) which caused the rpc_s_auth_bad_integrity error in
rpc__krb_dg_recv_ck(). This bug has been there from the beginning, but
nobody makes the authenticated RPC to rpcd. (The fix is only 2 lines.)

[6/8/94 public]

The fix is submitted.

[6/21/94 public]

I think I can tell why this problem has never showed up before despite
being present. There are two tests that can produce a problem that I
feel is related to this one.

1) Functional test: run  the rpc perf test with packet privacy option 
   enabled when using DG protocol. This test fails for cases# 7
   (Unregistered interface test) and #8 (Forwarding test). With my
   analysis so far, I can see that when the client tries to respond
   to a WAY AUTH it gets 'unknown reject' error:

(rpc__dg_call_start) rcvbuf 32768, ws 16
(conv_stub_who_are_you_auth) Thinking about responding to WAYAUTH callback
(rpc__dg_call_transceive) unblocking serialized waiters...
(rpc__dg_do_reject) Got a live one [3947a3e0-8d0d-1d1d-bc42-0000c0ea4f78, 1.0]
(rpc__dg_call_signal_failure) CCALL st = 0x16c9a060 (orig st = 0x0) [3947a3e0-8d0d-1d1d-bc42-0000c0ea4f78, 1.0]
*** Unknown exception raised
Exception: unknown reject (dce / rpc)

2) System tests: run the rpc.cds.3 test with the protection level set to
   privacy. It always fails trying do its fourth call.

Does OSF or anybody else run these tests with specified options? If this is
pointing to a different problem then we should reopen this OT or create a
new one. 

Where can I find the fix that I can apply to SNI DCE 1.0.3 code?

[6/21/94 public]

The above comment is not true. Only rpcd and dced register the fwd_map
function. The perf and systest do not have it. Thus, this problem has/will
never showed/show up in them. Your problem with pkt_privacy is related to
one of the DG auth RPC fixes submitted as a part of the first MBF drop. I
have successfully run the perf test with all of the anthn levels. So the
fix is in dce1.1 tree. (Be cautious, there is a licensing issue to pick bug
fixes from dce1.1 for apply it to your product.)



CR Number                     : 10808
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : dg private socket
Short Description             : recv_pkt_private does not cancel if recv_from is not cancellable
Reported Date                 : 5/31/94
Found in Baseline             : 1.1
Found Date                    : 5/31/94
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : dglsn.c
Sensitivity                   : public

[5/31/94 public]

The function recv_pkt_private fails to cancel if recv_from is
not cancellable.  Code needs to be added for NON_CANCELLABLE_IO.

The following is a modified verson of the TRY - CATCH - CATCH_ALL - ENDTRY
code from recv_pkt_private to support NON_CANCELLABLE_IO:

    TRY
    {
        call->blocked_in_receive = 1;
        RPC_DG_CALL_UNLOCK(call);

        RPC_DBG_PRINTF(rpc_e_dbg_dg_sockets, 5, (
                "(recv_pkt_private) blocking in recv_pkt\n"));

#ifdef NON_CANCELLABLE_IO
         pthread_setasynccancel(CANCEL_ON);
         pthread_testcancel();
#endif

        recv_flag = recv_pkt(sp, rqe);

#ifdef NON_CANCELLABLE_IO
        pthread_setasynccancel(CANCEL_OFF);
#endif

        RPC_DG_CALL_LOCK(call);
        call->blocked_in_receive = 0;
   
        /*
         * There's a window, between when we returned from recvfrom and
         * when we got the call handle relocked.   If a cancel was posted,
         * by the runtime trying to simulate a cond_signal, we need to eat
         * it here.
         */
        if (call->priv_cond_signal == true)
        {
            RPC_DG_CALL_UNLOCK(call);
            pthread_testcancel();
        }
    }
    CATCH(pthread_cancel_e)
    {
#ifdef NON_CANCELLABLE_IO
        pthread_setasynccancel(CANCEL_OFF);
#endif

        RPC_DG_CALL_LOCK(call);

        call->blocked_in_receive = 0;

        RPC_DBG_PRINTF(rpc_e_dbg_dg_sockets, 3, (
                "(recv_pkt_private) caught a thread cancel\n"));

        /*
         * If this cancel wasn't thrown by the runtime itself, it must
         * have been a real cancel, thrown by some other thread.  Treat
         * it as a real cancel.
         */
        if (! call->priv_cond_signal)
            rpc__dg_call_local_cancel(call);

        /*
         * Reset the flag.
         */
        call->priv_cond_signal = false;
    }
    CATCH_ALL
    {
#ifdef NON_CANCELLABLE_IO
        pthread_setasynccancel(CANCEL_OFF);
#endif

        RPC_DG_CALL_LOCK(call);

        call->blocked_in_receive = 0;

        RPC_DBG_PRINTF(rpc_e_dbg_dg_sockets, 3, (
                "(recv_pkt_private) caught an unknown exception\n"));

        rpc__dg_call_signal_failure(call, (unsigned32) -1);
    } ENDTRY

[5/31/94 public]

I'll include this fix with my submission for CR 10377.

[6/6/1994 public]

Submitted.



CR Number                     : 10807
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : Idl needs unmarshalling security
Reported Date                 : 5/31/94
Found in Baseline             : 1.1
Found Date                    : 5/31/94
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : idl/lib/ndrui.c idl/lib/ndrui3.c
Sensitivity                   : public

[5/31/94 public]


One of the idl enhancements from DEC:

Rico writes----------------------------------------

There is no documentation as this is purely an "added robustness" feature
which does not affect the application developer.  I've appended a technical
analysis of the issue in case you want to include it in a defect report.

Regards,
Rico

              -< analysis of unmarshalling security issues in .0 >-
--------------------------------------------------------------------------------
The base note brings up two potential security issues for unmarshalling.
Below is my analysis of these two issues.

 1) Check that unmarshalling is happening within the receive buffer.

    The idea here is that, if the unmarshalling data stream were to have
    a "short" APDU, it could cause our code to walk outside the data stream.

    The unmarshalling macros in ndrui.h all do a check to make sure we're
    within the receive buffer.  Thus, if we can prove that all unmarshalling
    code either uses the macros or does an explicit check, then this issue
    is already accounted for.

    The only places where we expect to unmarshall without using the macros
    that include a buffer check are when we unmarshall by copying directly
    from the unmarshalling buffer into user memory.  The routine
    ndrui.c/rpc_ss_ndr_unmar_by_copying indeed calls
    rpc_ss_ndr_unmar_check_buffer before calling memcpy to do a copy.

    I also searched all the code for other occurences of memcpy.  I found
    none that related to unmarshalling by copying.

    Thus, I conclude issue 1 is already accounted for and no work is needed.

 2) Ensure that varying information lies within allocated bounds

    The idea here is that the unmarshalling stream can have varying or open
    arrays where the A,B values lie outside the bounds set by the Z values.
    Our code could therefore attempt to write outside the bounds of user data.

    To track this one I looked at all code sites calling
    rpc_ss_ndr_unmar_range_list.  There are seven:

        ndrui.c     rpc_ss_ndr_unmar_struct (2)
                    rpc_ss_ndr_unmar_varying_arr
                    rpc_ss_ndr_unmar_interp
        ndrui2.c    rpc_ss_ndr_unmar_pointee_desc (2)
        ndrui3.c    rpc_ss_ndr_unmar_xmit_as

    All of these code sites subsequently call rpc_ss_ndr_u_var_or_open_arr.

    Thus, there is a single code site where the additional check needs to
    be added.  This is the additional check.  It may first appear to be
    "off by one", but remember that range_list[i].lower contains the A
    value and range_list[i].upper contains the A+B value, so in effect,
    range_list[i].lower is the normallized lower bound and
    range_list[i].upper is the normallized upper bound PLUS ONE.

    if (Z_values != NULL)   /* NULL possible for transmit_as case */
    {
        for (i=0; i<dimensionality; i++)
        {
            if ((range_list[i].upper - range_list[i].lower) > Z_values[i])
            {
                /* Bogus data stream with A,B values outside of Z bound value */
                RAISE(rpc_x_invalid_bound);
            }
        }
    }

    The need for the (Z_values != NULL) test was discovered during testing.
    There is a code site (rpc_ss_ndr_unmar_xmit_as) that could call
    rpc_ss_ndr_u_var_or_open_arr without initializing the Z_values argument.
    It didn't matter to date, because for that case, the Z_values argument
    would never be accessed.  With the new code that is now possible, thus
    the caller site in ndrui3.c/rpc_ss_ndr_unmar_xmit_as needed this
    additional initialization:

    idl_ulong_int *Z_values = NULL;

end included text-------------------------------

[5/31/94 public]
Files submitted.
Closed.



CR Number                     : 10794
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : extern_exceptions should allow the list to be omitted
Reported Date                 : 5/26/94
Found in Baseline             : 1.1
Found Date                    : 5/26/94
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : acf.y
Sensitivity                   : public

[5/26/94 public]

A fix/enhancement from rico at DEC:

A) extern_exceptions enhancement

    This is really a fix more than an enhancement.  RFC 2.1 allows the
    list to be omitted from an extern_exceptions attribute.  We missed
    that when we implemented extern_exceptions for R1.0.3.

    The only file affected is acf.y.

    There is no documentation for this, unless someone recognized the
    deficiency in 1.0.3 and changed the doc for extern_exceptions.
    extern_exceptions with no list implies that all exceptions are
    external.

[5/27/94 public]
The code has been submitted.



CR Number                     : 10787
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl_compiler
Short Description             : rtn_vec needs more typedefs
Reported Date                 : 5/26/94
Found in Baseline             : 1.1b9
Found Date                    : 5/26/94
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : ddspell.c, idlddefs.h
Sensitivity                   : public

[5/26/94 public]
The IDL_rtn_vec is a table of function pointers.  Right now those functions
don't have declarations of their parameters causing strict ANSI compilers
to warn about missing prototypes.

Here's one way to fix it:

Add this line to idlddefs.h:
	typedef void (*IDL_rtn_func_t)  _DCE_PROTOTYPE_ ((rpc_void_p_t ));
Change the IDL_rtn_vec field in the IDL_ms_t to be like this:
	IDL_rtn_func_t *IDL_rtn_vec; /* The routine vector for this interface */
Then in ddspell.c, the DDBE_spell_rtn_vec function, change these three lines:
    fprintf(fid, "(void (*)())NULL,");
    fprintf(fid, "(void (*)())%s,\n", rtn_name);
    fprintf(fid, "(void (*)())NULL,");
to read like this:
    fprintf(fid, "(IDL_rtn_func_t)NULL,");
    fprintf(fid, "(IDL_rtn_func_t)%s,\n", rtn_name);
    fprintf(fid, "(IDL_rtn_func_t)NULL,");

I think there is a similar printf in sstubmts.c but I'm not sure.

To test this, I edited the generated code by hand to get the above
effect and it compiles cleanly and works.

[8/15/94 public]
Fixed this in July.
Closed.



CR Number                     : 10738
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : test/rpc/idl
Short Description             : Reference to AUX files should be deleted
Reported Date                 : 5/24/94
Found in Baseline             : 1.1
Found Date                    : 5/24/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : see below
Sensitivity                   : public

[5/24/94 public]

test/rpc/idl failed because it was trying to reference the AUX files.
The 'new' IDL no longer needs these files.

I have talked to Rich Salz and Charles Brooks as Tom Jordahl and Paul
Ellis are NOT here yet.  The 'correct' fix was to obsolete (delete)
those references.  

In order to get a good build, this is what I did:

    FILE = src/test/rpc/idl/maketest.mk
    changes =  took out these four lines:

        .if defined(NEED_AUX_FILES)
        CAUX        = ${IDLBASE}_caux.o
        SAUX        = ${IDLBASE}_saux.o
        .endif

I am rebuilding on all platforms now.

ps.  Charlie Brooks approved this fix.

[05/24/94 public]

However, after looking at the root of the problem, it appears
that all the Makefiles that include src/test/rpc/idl/maketest.mk 
will have to be changed as well as there is another variable that 
is being set to the AUX files.

I am still waiting for tom to get back to me.

[5/24/94 public]

Removed NEED_AUX_FILES from all makefiles which used it.
Removed support for NEED_AUX_FILES in maketest.mk.
Cleaned up some compiler warnings in common_server.c.

Affected files:
./test/rpc/idl/alias/Makefile
./test/rpc/idl/ao_arrays/Makefile
./test/rpc/idl/arraystr2/Makefile
./test/rpc/idl/common_server.c
./test/rpc/idl/comprefs_ool/Makefile
./test/rpc/idl/conftree/Makefile
./test/rpc/idl/cover1/Makefile
./test/rpc/idl/cover2/Makefile
./test/rpc/idl/cover_array_ool/Makefile
./test/rpc/idl/cover_ool/Makefile
./test/rpc/idl/cover_union/Makefile
./test/rpc/idl/maketest.mk
./test/rpc/idl/no_op/Makefile
./test/rpc/idl/nodethreads/Makefile
./test/rpc/idl/ool/Makefile
./test/rpc/idl/oolsmall/Makefile
./test/rpc/idl/oolthings/Makefile
./test/rpc/idl/pipe_of_array/Makefile
./test/rpc/idl/pipefault/Makefile
./test/rpc/idl/pipes/Makefile
./test/rpc/idl/pipetest/Makefile
./test/rpc/idl/pipetest2/Makefile
./test/rpc/idl/pipetest2_cancel/Makefile
./test/rpc/idl/pipetest2_ool/Makefile
./test/rpc/idl/repas1/Makefile
./test/rpc/idl/repas2/Makefile
./test/rpc/idl/represent_ool/Makefile
./test/rpc/idl/sp_union/Makefile
./test/rpc/idl/string_tree/Makefile
./test/rpc/idl/tree/Makefile
./test/rpc/idl/xmit/Makefile
./test/rpc/idl/xmitas/Makefile
./test/rpc/idl/xmitas_repas/Makefile
./test/rpc/idl/xmitas_repas_ool/Makefile

[05/24/94 public]

Tom has fixed this problem and have build successfully in his sandbox.
I am now closing this bug now.



CR Number                     : 10725
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : missing SAMS assignment setup,
so none of the SAMS files were created
Reported Date                 : 5/23/94
Found in Baseline             : 1.1
Found Date                    : 5/23/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : src/Makefile, src/rpc/Makefile
Sensitivity                   : public

[5/23/94 public]

The Makefile in rpc/runtime is broken.  It does not have the SAMSFILES
assignment but references the objects - dcerpcmsg.o dcerpcsvc.o ...

You need to do something like this:

THE ORIGINAL
============
OBJS_SVC     = rpcsvc.o  dcerpcmsg.o  dcerpcsvc.o
              (^^^^^^^ What is this??, I think it should have a dce prefix
               as such dcerpcsvc.o which you already have in the same line)

THE FIX
=======
OBJS_SVC     = dcerpcmsg.o  dcerpcsvc.o ... (other svc *.o files)
SAMSFILES    = rcp.sams
SAMIDL_INCLUDES = dcerpcmsg.h ... (others svc created *.h)
SAMS_TARGETS    = dcerpcmsg.c  ... (others svc created *.c) 

thanks
annie

[05/23/94 public]
This broke libdce on all platforms.

[5/23/94 public]

actually, they should have been built in ../sys_idl.

the fix (which I'm proposing to submit) would be to add "rpc" to
src/Makefile's SAMIDL_SUBDIRS, and "SAMIDL_SUBDIRS=sys_idl" to
src/rpc/Makefile.

[5/27/94 public]
I blieve that we have clean build and this problem is solved.
Closed.



CR Number                     : 10712
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000,hppa,i486
S/W Ref Platform              : osf1,aix,hpux
Component Name                : rpc
Subcomponent Name             : /libdce
Short Description             : cc: error 2151: Can't open "rpcsvc.o"
Reported Date                 : 5/20/94
Found in Baseline             : 1.1
Found Date                    : 5/20/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : /src/rpc/runtime/rpcsvc.c
				             ../sys_idl/dcerpcmsg.c
					     ../sys_idl/dcerpcsvc.c
Sensitivity                   : public

[5/20/94 public]


c89 -c    -D_SHARED_LIBRARIES  +z  -DNCK -DPROT_NCADG -DPROT_NCACN  -DAUTH_KRB -DNAF_IP -DDNS_CD\
S -DDNSPI_V3 -DDNS_V3API    -DDCE_RPC_SVC    -DDEBUG -D__hppa -Dhp9000s800 -Dhp9000s700 -D__hp90\
00s800 -D__hp9000s700 -DHPUX -D__hpux -Dunix +DA1.0 -D_HPUX_SOURCE    -I. -I/u3/devobj/sb/nb_ux/\
src/rpc/runtime -I/u3/devobj/sb/nb_ux/src/rpc/runtime -I/project/dce/build/dce1.1-snap/src/rpc/r\
untime  -IHP800 -I/u3/devobj/sb/nb_ux/src/rpc/runtime/HP800 -I/u3/devobj/sb/nb_ux/src/rpc/runtim\
e/HP800 -I/project/dce/build/dce1.1-snap/src/rpc/runtime/HP800 -I/u3/devobj/sb/nb_ux/export/hp80\
0/usr/include -I/u3/devobj/sb/nb_ux/export/hp800/usr/include -I/project/dce/build/dce1.1-snap/ex\
port/hp800/usr/include    /project/dce/build/dce1.1-snap/src/rpc/runtime/rpcsvc.c
cc: error 2151: Can't open "rpcsvc.o".
*** Error code 1
c89 -c    -D_SHARED_LIBRARIES  +z  -DNCK -DPROT_NCADG -DPROT_NCACN  -DAUTH_KRB -DNAF_IP -DDNS_CD\
S -DDNSPI_V3 -DDNS_V3API    -DDCE_RPC_SVC    -DDEBUG -D__hppa -Dhp9000s800 -Dhp9000s700 -D__hp90\
00s800 -D__hp9000s700 -DHPUX -D__hpux -Dunix +DA1.0 -D_HPUX_SOURCE    -I. -I/u3/devobj/sb/nb_ux/\
src/rpc/runtime -I/u3/devobj/sb/nb_ux/src/rpc/runtime -I/project/dce/build/dce1.1-snap/src/rpc/r\
untime  -IHP800 -I/u3/devobj/sb/nb_ux/src/rpc/runtime/HP800 -I/u3/devobj/sb/nb_ux/src/rpc/runtim\
e/HP800 -I/project/dce/build/dce1.1-snap/src/rpc/runtime/HP800 -I/u3/devobj/sb/nb_ux/export/hp80\
0/usr/include -I/u3/devobj/sb/nb_ux/export/hp800/usr/include -I/project/dce/build/dce1.1-snap/ex\
port/hp800/usr/include    ../sys_idl/dcerpcmsg.c
cc: error 2151: Can't open "dcerpcmsg.o".
*** Error code 1
c89 -c    -D_SHARED_LIBRARIES  +z  -DNCK -DPROT_NCADG -DPROT_NCACN  -DAUTH_KRB -DNAF_IP -DDNS_CD\
S -DDNSPI_V3 -DDNS_V3API    -DDCE_RPC_SVC    -DDEBUG -D__hppa -Dhp9000s800 -Dhp9000s700 -D__hp90\
00s800 -D__hp9000s700 -DHPUX -D__hpux -Dunix +DA1.0 -D_HPUX_SOURCE    -I. -I/u3/devobj/sb/nb_ux/\
src/rpc/runtime -I/u3/devobj/sb/nb_ux/src/rpc/runtime -I/project/dce/build/dce1.1-snap/src/rpc/r\
untime  -IHP800 -I/u3/devobj/sb/nb_ux/src/rpc/runtime/HP800 -I/u3/devobj/sb/nb_ux/src/rpc/runtim\
e/HP800 -I/project/dce/build/dce1.1-snap/src/rpc/runtime/HP800 -I/u3/devobj/sb/nb_ux/export/hp80\
0/usr/include -I/u3/devobj/sb/nb_ux/export/hp800/usr/include -I/project/dce/build/dce1.1-snap/ex\
port/hp800/usr/include    ../sys_idl/dcerpcsvc.c
cc: error 2151: Can't open "dcerpcsvc.o".
*** Error code 1

[5/27/94 public]
We have clena build, so this problem is solved.
Closed.



CR Number                     : 10679
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : rpccp
Short Description             : missing casts in rpccp.c
Reported Date                 : 5/17/94
Found in Baseline             : 1.1b8
Found Date                    : 5/17/94
Severity                      : E
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b10
Affected File(s)              : src/rpc/rpccp/rpccp.c
Sensitivity                   : public

[5/17/94 public]
Minor point, but we are doing code cleanup and shipping rpccp...

Compiling on the HP shows the following warnings.  All are in procedure
usage() and are that cmd_tokens[0] needs to be cast to a (char *) from
an (unsigned char *).

c89 -c        -D__hppa -Dhp9000s800 -Dhp9000s700 -D__hp9000s800 -D__hp9000s700 -DHPUX -D__hpux -Dunix +DA1.0 -D_HPUX_SOURCE  -DREMOTE_ENDPOINT_ACCESS  -I. -I/sandbox/melman/sb1/src/rpc/rpccp -I/project/dce/build/dce1.1/src/rpc/rpccp  -I../runtime -I/sandbox/melman/sb1/src/rpc/runtime -I/project/dce/build/dce1.1/src/rpc/runtime -I../runtime/HP800 -I/sandbox/melman/sb1/src/rpc/runtime/HP800 -I/project/dce/build/dce1.1/src/rpc/runtime/HP800 -I/sandbox/melman/sb1/export/hp800/usr/include -I/project/dce/build/dce1.1/export/hp800/usr/include    /project/dce/build/dce1.1/src/rpc/rpccp/rpccp.c
cc: "/project/dce/build/dce1.1/src/rpc/rpccp/rpccp.c", line 1223: warning 604: Pointers are not assignment-compatible.
cc: "/project/dce/build/dce1.1/src/rpc/rpccp/rpccp.c", line 1223: warning 563: Argument #1 is not the correct type.
cc: "/project/dce/build/dce1.1/src/rpc/rpccp/rpccp.c", line 1224: warning 604: Pointers are not assignment-compatible.
cc: "/project/dce/build/dce1.1/src/rpc/rpccp/rpccp.c", line 1224: warning 563: Argument #1 is not the correct type.
cc: "/project/dce/build/dce1.1/src/rpc/rpccp/rpccp.c", line 1225: warning 604: Pointers are not assignment-compatible.
cc: "/project/dce/build/dce1.1/src/rpc/rpccp/rpccp.c", line 1225: warning 563: Argument #1 is not the correct type.
cc: "/project/dce/build/dce1.1/src/rpc/rpccp/rpccp.c", line 1235: warning 604: Pointers are not assignment-compatible.
cc: "/project/dce/build/dce1.1/src/rpc/rpccp/rpccp.c", line 1235: warning 563: Argument #2 is not the correct type.

[05/17/94 public]
>Minor point, but we are doing code cleanup and shipping rpccp...
Well, sort of.  We're shipping it in nosupport for the official
release.  Is nosupport subject to cleanup req'ts?

[05/17/94 public]
Yeah, well, call me a purist.  It's a 4 line fix and I'll do it as soon
as the tree is open.

In general, nosupport is NOT subject to cleanup requirements.

[05/17/94 public]
Added "(char *)" in five places.  Submitted.



CR Number                     : 10640
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 9702
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : i18n
Short Description             : code set converter tables are missing
Reported Date                 : 5/13/94
Found in Baseline             : 1.1
Found Date                    : 5/13/94
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : rpc/csrc/ucs_tables
Sensitivity                   : public

[5/13/94 public]

  Responding to a request from SIG, OSF will ship some of the OSF/1
iconv converter tables for universal code set (UCS-2 Level 2).  There
are 37 tables which covers ISO 8859 families, Asian EUCs (Korean, Chinese,
Japanese) and SJIS.

  These tables are need to be integrated into 'iconv' or a local converter
module for each platform (except OSF/1) by each vendor.  Therefore, they
will not be a part of install tree.  They are just included in a source tree.

[6/6/94 public]

  All tables were submitted with README.  Didn't affect nightly build.

  % ls /project/dce/build/dce1.1/src/rpc/csrc/ucs_tables
  ISO8859-1_FSS-UTF_src  ISO8859-8_FSS-UTF_src  UCS-2_ISO8859-8_src
  ISO8859-2_FSS-UTF_src  ISO8859-8_UCS-2_src    UCS-2_ISO8859-9_src
  ISO8859-2_UCS-2_src    ISO8859-9_FSS-UTF_src  UCS-2_SJIS_src
  ISO8859-3_FSS-UTF_src  ISO8859-9_UCS-2_src    UCS-2_eucJP_src
  ISO8859-3_UCS-2_src    README                 UCS-2_eucKR_src
  ISO8859-4_FSS-UTF_src  SJIS_FSS-UTF_src       UCS-2_eucTW_src
  ISO8859-4_UCS-2_src    SJIS_UCS-2_src         eucJP_FSS-UTF_src
  ISO8859-5_FSS-UTF_src  UCS-2_ISO8859-2_src    eucJP_UCS-2_src
  ISO8859-5_UCS-2_src    UCS-2_ISO8859-3_src    eucKR_FSS-UTF_src
  ISO8859-6_FSS-UTF_src  UCS-2_ISO8859-4_src    eucKR_UCS-2_src
  ISO8859-6_UCS-2_src    UCS-2_ISO8859-5_src    eucTW_FSS-UTF_src
  ISO8859-7_FSS-UTF_src  UCS-2_ISO8859-6_src    eucTW_UCS-2_src
  ISO8859-7_UCS-2_src    UCS-2_ISO8859-7_src



CR Number                     : 10599
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : un-documented nsi error message
Reported Date                 : 5/10/94
Found in Baseline             : 1.0.3
Found Date                    : 5/10/94
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b13
Affected File(s)              : rpc/runtime/nsutil.c
Sensitivity                   : public

[5/10/94 public]

 abstract: rpc_ns_binding_import_next and/or rpc_ns_binding_lookup_next (?)   
           return undocumented value (rpc_s_socket_failure)
 description: An RPC API rpc_ns_binding_import_next returns an rpc error  
       rpc_s_socket_failure, which is not documented.  It is  
       an internal error code that is an artifact of the  
       implementation.  This artifact should be hidden or  
       at least a return code that is documented (  
       rpc_s_name_service_unavailable???) should be returned.
       This error code returned (282110316) is listed in  
       /usr/include/dce/dnsmessage.h as both DNS_SOCKET  
       and CDS_SOCKET.  It is more meaningful to return  
       rpc_s_name_service_unavailable instead of  
       rpc_s_socket_failure.

[05/10/94 public]
Your description of how this interface returns the error status
rpc_s_socket_failure is a little unclear.  

Under what conditions does this status get returned to the application?

The runtime only returns this status in two places (both in DG code):
% fgrep rpc_s_socket_failure *.c
dglsn.c:        *st = rpc_s_socket_failure;
dgxq.c:        rpc__dg_call_signal_failure(call, rpc_s_socket_failure);

Both are the result of the socket being disabled.  I don't think these
are the problems.  Perhaps the CDSPI interface is returning this?  
In this case, I would agree that if the CDS routines
can not reach the advertiser on its socket, they should return
a more desriptive error code.  If this is the case, this would be
a CDS defect.

I will add the CDS poeple to the CC list.  They might have some insight.

[5/11/94 public]
The error code that is returned is 282110316, which dce_err maps to 
Error with socket (dce / cds)

What we're suggesting is that rpc__ns_status_from_nserror should map this
to rpc_s_name_service_unavailable, which is a little more useful to the user.

We have seen this both when the cdsadv had died and when the cdsclerk is
under stress and can't accept incoming requests as fast as the clients are
sending them.  If the connection requests overflow the socket buffer the
cdslib routines get a socket error on the connect and return 282110316.

There's possibly also a documentation issue with the nsi routines in general,
since they will pass through any cdspi error codes they don't recognize.

[05/11/94 public]
Thanks for the further explaination.

This sounds like a fine idea to me, anyone else have an opinion?

[7/15/94 public]
Well the change is made, we now map DNS_SOCKET return value to
the rpc code rpc_s_name_service_unavailable.



CR Number                     : 10598
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl library
Short Description             : Add encoding services get/set attribute API.
Reported Date                 : 5/10/94
Found in Baseline             : 1.1
Found Date                    : 5/10/94
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b9
Affected File(s)              : see below
Sensitivity                   : public

[5/10/94 public]

The backing store library needs the ability to set a flag in the 
encoding services handle that will prevent the pickling library 
from checking the interface uuid on decode against the interface 
that encoded it.

Two new interfaces (defined in idl_es.h) are added:

#define IDL_ES_NO_ENCODING_CHECK        0x1

void idl_es_set_attrs(
    idl_es_handle_t,    /* [in] handle */
    unsigned32,         /* [in] flags */
    error_status_t *);  /* [out] status */

void idl_es_inq_attrs(
    idl_es_handle_t,    /* [in] handle */
    unsigned32 *,       /* [out] flags */
    error_status_t *);  /* [out] status */


And in idlddefs.h we add IDL_es_flags to idl_es_handle_t:

***************
*** 876,881 ****
--- 877,883 ----
                 During decoding this is a local copy of the pickle header */
      IDL_msp_t IDL_msp;              /* For encode/decode the marshalling state
                                          block is dynamically allocated */
+     idl_ulong_int IDL_es_flags;     /* attribute flags */
  /* Fields used for incremental buffering */
  
      idl_void_p_t IDL_state;  /* User state */

[05/10/94 public]
Submitted code changes and a new test:
./rpc/idl/lib/pickling.c
./rpc/sys_idl/idl_es.h
./rpc/sys_idl/idlddefs.h
./test/rpc/idl/es_attr/Makefile
./test/rpc/idl/es_attr/RUN_ARGS
./test/rpc/idl/es_attr/client.c
./test/rpc/idl/es_attr/es_attr_decode.acf
./test/rpc/idl/es_attr/es_attr_decode.idl
./test/rpc/idl/es_attr/es_attr_encode.acf
./test/rpc/idl/es_attr/es_attr_encode.idl
./test/rpc/idl/es_attr/server.c
./test/rpc/idl/run_tests.sh



CR Number                     : 10589
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime/dg
Short Description             : timer_loop() needs TRY..FINALLY..ENDTRY
Reported Date                 : 5/9/94
Found in Baseline             : 1.0.3
Found Date                    : 5/9/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : rpc/runtime/cominit.c
                                             rpc/runtime/comnet.c
                                             rpc/runtime/comnlsn.c
                                             rpc/runtime/dg.h
                                             rpc/runtime/dgclive.c
                                             rpc/runtime/dginit.c
                                             rpc/runtime/dglsn.c
                                             rpc/runtime/dgslive.c
                                             test/rpc/runtime/perf/client.c
                                             test/rpc/runtime/perf/perf.c
                                             test/rpc/runtime/perf/perf.idl
Sensitivity                   : public

[5/9/94 public]
The timer_loop routine in rpctimer.c needs to have a TRY..FINALLY around
the main loop so that when the timer thread is cancelled it can unlock
the timer mutex.  Otherwise there is a race condition during pre-fork
processing where an RPC can come in after you've cancelled the timer thread
while it held the timer lock and before you've cancelled the listener thread,
so the listener thread tries to handle the RPC and gets blocked trying to
acquire the timer lock.  Now the main thread hangs trying to cancel and join
with the listener thread and you now have a deadlocked process.

I've had this happen to me many time with cdsadv on a sufficiently fast box.

The additions are in the ifdefs below:

INTERNAL void timer_loop()
{
    RPC_TIMER_LOCK(0);
#if defined(AIXPROD) || defined(IBMOS2) /* CMVC 8721 */
    TRY
#endif

    while (!stop_timer)
    {
        rpc_clock_t next;
        struct timespec next_ts;
        rpc_clock_t max_step;

...

...

        rpc_timer_cur_trigger = rpc_g_clock_curr + next;
        rpc__clock_timespec (rpc_timer_cur_trigger, &next_ts);
        RPC_COND_TIMED_WAIT(rpc_g_timer_cond, rpc_g_timer_mutex, &next_ts);

    }

#if defined(AIXPROD) || defined(IBMOS2) /* CMVC 8721 */
    FINALLY
#endif

    RPC_TIMER_UNLOCK(0);

#if defined(AIXPROD) || defined(IBMOS2) /* CMVC 8721 */
    ENDTRY
#endif

}

[5/10/94 public]

I think you're right that there's a potential deadlock when starting new
calls after the timer thread has been stopped, but I don't think this is
the fix.

The timer thread never actually gets cancelled, so the TRY/FINALLY clause 
should be a no-op, although it will make things run a little slower.

Also, as soon as the timer_loop thread goes away, the fork-handler is
going to relock the mutex anyway (creating the same potential deadlock).

[5/10/94 public]

*sigh* that's the problem with intermittent errors - you don't get immediate
feedback when you're confused.  Okay, I'll change my story and claim that
the fundamental problem with the rpc__fork_handler is that it invokes the
subsystem fork handlers in the same order as they were originally started.
Specifically, since the timer thread was started before the listener thread,
it should be shut down after the listener thread is cancelled (that's the
thread that I had seen being cancelled).  That would fix this particular
deadlock, since the listener thread wouldn't be around to get blocked on
the mutex by the time the timer thread went away.  There may be other
issues that haven't popped up yet as well.

In general, it seems like rpc__fork_handler should vary the order it calls
the subsystem fork handlers based on the fork state - pre-fork should be
the opposite of post-fork, which should be the same order as initialization.

[5/17/94 public]

I originally thought of reversing the calling sequence in the post fork
handler, just like CMA's internal fork handler. But, I didn't think it was
really necessary. Anyway, this needs to be fixed. Also, we may have a
problem with the mutex unlocking in the child's post fork handler.

[7/15/94 public]

Submitted.

The execution orders of fork handlers were fixed so that pre-fork handlers
execute in the opposite of the initialization and post-fork handlers
execute in the same order as initialization. While in there I added missing
fork handler for the client's maintain liveness thread and fixed the fork
handler for the server's monitor thread. Also, I added more fork tests in
perf (but, couldn't reproduce IBM's failure condition).

The mutex unlocking in the child's post-fork handler is not a problem
because CMA's own post-fork hander does not destroy the mutexes.



CR Number                     : 10582
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : refdels client core dumps on SVR4 platform
Reported Date                 : 5/9/94
Found in Baseline             : 1.0.3
Found Date                    : 5/9/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : test/rpc/idl/refdels/client_aux.c
Sensitivity                   : public

[5/9/94 public]

The function build_node() in file refdels/client_aux.c does not returns the
p_node pointer when the 'depth == 1'. This causes some junk to be returned
and so core dump. Following #ifdef SNI_SVR4 indicate the fix:

if (depth == 1)
{
....
....
#ifdef SNI_SVR4
   return p_node;
#else
   return;
#endif
}

[05/10/94 public]
Abby said she had a fix for this.

[5/10/94 public]
Tom, the purpose of this bug report was to have OSF incorporate the fix
into their main-line source. This is not a SVR4 specific bug. Yes, Abby
would have this because I fixed it for her!! Thanks.

[05/10/94 public]
And she is going to submit this (and another fix) to the mailine source.
She (and you!) can do that, you know.. :-)

[5/27/94 public]
Abby, when are you going to submit this code?



CR Number                     : 10579
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : csrc
Short Description             : The dcecsr.cat is not
installed.
Reported Date                 : 5/9/94
Found in Baseline             : 1.1
Found Date                    : 5/9/94
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : rpc/csrc/Makefile
Sensitivity                   : public

[5/9/94 public]

The file dcecsr.cat in not installed during the DCE installation.
In the NB area, this file is installed in:

/project/dce/build/nb_<platform>/install/<platform>/opt/dce1.1/bin

not in:

/project/dce/build/nb_ux/install/hp800/opt/dce1.1/nls/msg/en_US.ASCII

That is the reason why dce_config does not install it in the appropiate 
directory.

[5/10/94 public]

  Added dcecsr.cat_IDIR to install dcecsr.cat to /nls/msg/en_US.ASCII/

[5/11/94 public]

  Nightly build showed dcecsr.cat is installed in

        /install/<machine>/opt/dce1.1/nls/msg/en_US.ASCII



CR Number                     : 10547
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 7730
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : "HEAP" ACF attribute does not
work for scalar types anymore
Reported Date                 : 5/5/94
Found in Baseline             : 1.0.3
Found Date                    : 5/5/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : app_gd/rpc/acf.gpsml
Sensitivity                   : public

[5/5/94 public]

Customer reported:

        The V1.0.3 IDL compiler generates server stub code that puts a
        parameter of a scalar type on the stack even if the "heap"
        attribute has been specified for it in an ACF file.  Is it
        supposed to work this way?  I've scanned the documentation and
        can't find any indication that the "heap" attribute is not
        supposed to work for scalars.  The V1.0.2 IDL compiler puts
        scalar types with the "heap" attribute in heap memory.

I tried 1.0.2 and 1.0.3 idls and saw the problem reported. If this is a
desired change, please properly document it (this is the reason I put OT
7730 "explain use of acf heap attribute" as related).

Repeat By:

        The following .idl and .acf files will demonstrate the problem
        for "long int *":

/*********************************************************************/

/*
 * Test IDL file
 */

[uuid (e073d860-6830-11c9-a60d-08002b0dea7a),
    version(1)
]

interface test
{

void ShowAttrCmd
        (
        [in]       long int            *aint
        );

} /** END of IDL file ***/

/*********************************************************************/

/*
 *      Test ACF file
 */

interface test
{
        ShowAttrCmd     (
                         [heap] aint
                         );
} /* End of ACF file */


[5/5 public]
This is the intended behavior, as the following code fragment illustrates:
                            if (ref_type_p->kind != AST_pipe_k
                                && !AST_CONTEXT_SET(param_p)
                                && !AST_CONTEXT_RD_SET(ref_type_p)
                                && !type_is_scalar(ref_type_p))
                                AST_SET_HEAP(param_p);

The [heap] attribute is ignored for pipes, context handles, and scalars.

This should be a documentation defect.


[5/5 public]

Care to explain why this change? I mean from the code above, it looks like
that this is an intended new behavior. There must be reason(s) behind this
change (since 1.0.2). I think the document people need to know this reason
too to explain why in the documentation.

[6/8/94 public]

Assigned this CR to myself - I'm the OSF writer who's
responsible for the IDL documentation.

[9/6/94 public]

Due to time and resource constraints, this CR cannot be
addressed in the DCE 1.1 timeframe. Marking this CR deferred
until DCE 1.2.

[9/6/94 public]

Howard Melman suggests that an easy way to address this CR
would be to add the following text in the places where the
heap attribute is described:

 "The [heap] attribute is ignored for pipes, context handles,
  and scalars".

I think this fix can be made in the DCE 1.1 timeframe, so
I'm reopening the CR.

[9/15/94 public]

Fixed and verified (by me).

[09/22/94 public]
Closed bug.



CR Number                     : 10534
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_gd, app_ref
Short Description             : remove NCS compatibility info
Reported Date                 : 5/4/94
Found in Baseline             : 1.1
Found Date                    : 5/4/94
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : command_ref/man1rpc/idl.1rpc,
	app_gd/rpc/9_idl.gpsml, app_gd/rpc/12_bnf_syntax.gpsml,
	app_gd/rpc/11_ncs_v1_issues.gpsml, command_ref/man1rpc/rpc_intro.1rpc,
	command_ref/man8dce/dce_config.8dce, command_ref/man1rpc/uuidgen.1rpc
Sensitivity                   : public

[5/4/94 public]

DCE 1.1 will no longer support compatibility to NCS, since
it is an entirely different product and since several versions
of DCE have now been released. NCS users should have converted
to DCE RPC by now.

As a result, all of the NCS compatibility documentation needs
to be removed from the Application Development Guide and Reference.
This impacts both RPC documentation (owned by J. Shirley) and
IDL documentation (owned by L. Zahn).

[5/5/94 public]
Removed IDL-related documentation for NCS compatiblity from
app_gd and app_ref.  Affected files are:

/command_ref/man1rpc/nidl_to_idl.1rpc - removed
/command_ref/man1rpc/rpc_intro.1rpc
/app_gd/rpc/9_idl.gpsml
/app_gd/rpc/11_ncs_v1_issues.gpsml - removed

Still need to check and remove cross-references.

[5/5/94 public]

This functionality MUST still be supported in the rpcd.  There
are still applications that depend on license servers that use
NCS and the rpcd and llbd both use port 135.  I wish all NCS
applications were moved up to DCE but this is not reality yet.

[5/5/94 public]

Note, that lldb will be ported to dced and shipped with dce 1.1.

The rest of the NCS 1.5 support has been removed in the rpc code 
cleanup.

[5/11/94 public]

(I think "lldb" should be "llbd" (Local Location Broker Daemon))

Removed references to IDL-related NCS compatibility features.
Checked for cross-references to defuncted NCS compatibility
chapter but didn't find any. As of now, all of the documentation
for IDL/RPC NCS compatibility features has been removed from
the app_ref and the app_gd. The revised documentation needs
technical review before this CR can be changed to "verified".

[8//30/94 public]
Verified.  Found new changes needed for dce_config.8dce and uuidgen.1rpc.

[10/27/94 public]
Closed bug.



CR Number                     : 10526
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_gd
Short Description             : Reorg. App. Gd. for RPC Sections
Reported Date                 : 5/4/94
Found in Baseline             : 1.0
Found Date                    : 5/4/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : See file list below
Sensitivity                   : public

[5/4/94 public]

The RPC chapters in the Application Development Guide need reorganizing and
consolidating.

[8/30/94 public]
Upgraded severity and priority fields.
Reorganization is complete except the old files still need to be removed
from source control.

[9/6/94 public]
Fixed and verified the new book build for the App. Dev. Guide Core.
The following files in the ../app_gd/rpc/ directory were defuncted:
	10_acf.gpsml@
	10a_encode.gpsml@
	10b_ichar_support.gpsml@
	1_intro.gpsml@
	2_components.gpsml@
	3_build_app.gpsml@
	4_remoteness.gpsml@
	5_dce_rpc_ops.gpsml@
	6_advanced_topics.gpsml@
	7_nsi_usage.gpsml@
	8_err_hndlng.gpsml@
	9_idl.gpsml@
	part3a.gpsml@
	part3b.gpsml@
	char_codeset_i14y.gpsml@

[9/14/94 public]

I also defuncted the file 12_bnf_syntax.gpsml back before
1.1 beta. I moved the IDL and ACF syntaxes to idl.gpsml
and acf.gpsml, respectively.

[09/22/94 public]
Closed bug.



CR Number                     : 10515
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 10514
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_ref
Short Description             : add new rpc_binding_inq_auth_caller routine 
to support delegation
Reported Date                 : 5/3/94
Found in Baseline             : 1.0.3
Found Date                    : 5/3/94
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : new file to be added: app_ref/man3rpc/
rpc_binding_inq_auth_caller.3sec
Sensitivity                   : public

[5/3/94 public]

Add new rpc_binding_inq_auth_caller.3rpc to support delegation.

[5/10/94 public]
Beta version of rpc_binding_inq_auth_caller.3rpc submitted to tree.

[5/11/94 public]
Changed Short Description to refer to ...inq_auth_caller instead 
of ...inq_auth_client.  Thanks Ward R. for catching this typo.

[10/14/94 public]
Verified by greg.

[10/25/94 public]
Closed bug.



CR Number                     : 10513
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_gd
Short Description             : Document idl extended string enhancement
Reported Date                 : 5/3/94
Found in Baseline             : 1.1
Found Date                    : 5/3/94
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : idl.gpsml
Sensitivity                   : public

[5/3/94 public]

DEC has provided OSF with the source changes to support the following
functionality which should be documented in the right places.

DEC provided this initial doc spec.

begin-text----------------------------------------------

0 Extended string support in DCE 1.1

The unextended IDL compiler implements strings as one-dimensional arrays
to which the [string] attribute is assigned.  The element type of the
array must resolve to one of the following:
    o Type char
    o Type byte
    o A structure all of whose members are of type byte or of a named
      type that resolves to byte
    o A named type that resolves to one of the previous three types
For simplicity these element types are referred to as "byte types" and
strings built from these types are referred to as "byte string types".

The extended string support adds these string element types:
    o Type unsigned short
    o Type unsigned long
    o A named type that resolves to unsigned short or unsigned long
For simplicity these element types are referred to as "integer types" and
strings built from these types are referred to as "integer string types".

The string extensions allow for multi-octet character sets whose
characters are represented by 16-bit or 32-bit quantities, rather than
as groups of bytes.  These extensions support the Unicode standard.

0.1 Rules for Using Integer String Types

The rules for integer string types are similar to those for byte string
types.  An array of integer type with the [string] attribute represents a
string of characters.  An array element of value 0 represents the string
terminator, similar to the NULL character in a string of byte type.  The
number of characters in the string array includes the 0 terminator, and
the entire terminated string is passed between stubs.

The restrictions that apply to byte string types also apply to integer
string types.

As with the byte string types, the [string] attribute may be applied to
a pointer to an integer type.  The [string] attribute converts the pointee
from a single integer to an array of integers, to which string semantics
apply.

0.2 Examples

/* A string type that holds 80 characters */
typedef [string] unsigned short string_t[81];

/* A structure containing a fixed string and a conformant string */
typedef unsigned long PRIVATE_CHAR_32;
typedef struct {
    [string] PRIVATE_CHAR_32 fixed[27];
    [string] PRIVATE_CHAR_32 conf[];
} two_strings;

/* A structure containing pointers to two strings */
typedef unsigned short PRIVATE_CHAR_16;
typedef struct {
    [string] PRIVATE_CHAR_16 *astring;
    [string] PRIVATE_CHAR_16 *bstring;
} stringptrs;


end-text-----------------------------------

[6/8/94 public]

Assigned this CR to myself (I'm the OSF writer responsible
for the 1.1 IDL enhancement documentation).

[7/18/94 public]

Added documentation and examples of integer-string types
to the byte-string types already described in the section
entitled "Strings" in the Interface Definition Language
chapter. T. Jordahl will verify.

[7/19/94 public]

Verified by T. Jordahl.

[09/08/94 public]
Closed bug.



CR Number                     : 10512
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl compiler
Short Description             : idl extended string enhancement
Reported Date                 : 5/3/94
Found in Baseline             : 1.1
Found Date                    : 5/3/94
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : see below
Sensitivity                   : public

[5/3/94 public]

DEC has provided OSF with the modifications to idl and libdce
to support extended string types (unsigned short and long).

The affected files are:
./rpc/idl/idl_compiler/checker.c
./rpc/idl/idl_compiler/nidlmsg.h
./rpc/idl/idl_compiler/nidlmsg.m
./rpc/idl/lib/ndrmi.c
./rpc/idl/lib/ndrui.c

./test/rpc/idl/run_tests.sh
./test/rpc/idl/strint/Makefile
./test/rpc/idl/strint/client_aux.c
./test/rpc/idl/strint/manager.c
./test/rpc/idl/strint/strint.idl
./test/rpc/idl/strint/util1.c

[05/03/94 public]
Code verified by the provided test.
Submitted.



CR Number                     : 10508
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : rpc/idl/idl_compiler
Short Description             : idl compiler broke in setup
Reported Date                 : 5/3/94
Found in Baseline             : 1.1
Found Date                    : 5/3/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : acf.y
Sensitivity                   : public

[5/3/94 public]

In the setup pass:

[ /rpc/idl/idl_compiler at 21:07 (PM) Monday ]

xlc -c -Dunix -D_ALL_SOURCE -DNO_SIOCGIFADDR -DMIA  -D_ALL_SOURCE -DAIX32 \
  -I. -I/u1/devobj/sb/nb_rios/src/rpc/idl/idl_compiler \
  -I/project/dce/build/dce1.1-snap/src/rpc/idl/idl_compiler acf_y_tab.c \
  "acf_y_tab.c", line 71.18: 1506-045 (S) Undeclared identifier \
  binding_callout_name.
*** Error code 1

[05/03/94 public]
Change a ';' to a ',' in declaration of binding_callout_name.



CR Number                     : 10504
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl compiler
Short Description             : Add binding callout functionality.
Reported Date                 : 5/2/94
Found in Baseline             : 1.1
Found Date                    : 5/2/94
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b9
Affected File(s)              : see below
Sensitivity                   : public

[5/2/94 public]

DEC has provided us with binding callout functionality for the
idl compiler.
The affected files are:
./rpc/idl/idl_compiler/acf.l
./rpc/idl/idl_compiler/acf.y
./rpc/idl/idl_compiler/ast.h
./rpc/idl/idl_compiler/astp_dmp.c
./rpc/idl/idl_compiler/clihamts.c
./rpc/idl/idl_compiler/hdgen.c
./rpc/idl/lib/Makefile
./rpc/idl/lib/bindcall.c
./rpc/sys_idl/stubbase.h
./test/rpc/idl/README
./test/rpc/idl/bindcall/Makefile
./test/rpc/idl/bindcall/RUN_ARGS
./test/rpc/idl/bindcall/bindcall.acf
./test/rpc/idl/bindcall/bindcall.idl
./test/rpc/idl/bindcall/client.c
./test/rpc/idl/bindcall/manager.c
./test/rpc/idl/bindcall/server.c
./test/rpc/idl/run_tests.sh

[5/2/94 public]
Verified with the provided test.
Submitted and closed.



CR Number                     : 10496
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : i18n
Short Description             : I-char marshalling and unmarshalling fail for varying array
Reported Date                 : 5/2/94
Found in Baseline             : 1.1
Found Date                    : 5/2/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : ndrui5.c ndrmi5.c
Sensitivity                   : public

[5/2/94 public]

  When I-char operation (automatic code set conversion) is used for
varying array, it fails within marshalling or unmarshalling routine
depends on where the code set conversion takes place.  In case of
unmarshalling, the problem is (probably) with the following piece of
code.

  In function 'rpc_ss_ndr_unmar_cs_array()' (ndrui5.c),

    if (convert_type != idl_cs_no_convert)
    {
        /* Call ..._from_netcs */
        (*(routine_ptr + IDL_RTN_FROM_NETCS_INDEX))(IDL_msp->IDL_h,
                *(IDL_msp->IDL_cs_tags_p->p_unmar_tag),
                wdata,
                w_data_len,
                l_storage_len,
                array_addr,
                ((array_type == IDL_DT_FIXED_ARRAY)
                    || (array_type == IDL_DT_CONF_ARRAY)) ? NULL : &l_data_len,
                &IDL_msp->IDL_status);
        if (IDL_msp->IDL_status != error_status_ok)
            RAISE(rpc_x_ss_pipe_comm_error);
    }


  When I-char varying array is unmarshalled, and convert_type ==
idl_cs_no_convert, 'l_data_len' is left as uninitialized.  This l_data_len is
passed to manager code as the length of (length_is) varying array, which
is a problem.  And what I observed was, when the I-char array was marshalled
after the manager call, the marshalling process dumped core, since within
'rpc_ss_ndr_marsh_by_looping()' call (ndrmi.c), 'element_count' was a huge
number (means it was a garbage. Proper value was not set), so it dereferenced
an invalid address.

  The fix for this problem will be the following:

     if (convert_type != idl_cs_no_convert)
     {
         /* Call ..._from_netcs */
         (*(routine_ptr + IDL_RTN_FROM_NETCS_INDEX))(IDL_msp->IDL_h,
                 *(IDL_msp->IDL_cs_tags_p->p_unmar_tag),
                 wdata,
                 w_data_len,
                 l_storage_len,
                 array_addr,
                 ((array_type == IDL_DT_FIXED_ARRAY)
                     || (array_type == IDL_DT_CONF_ARRAY)) ? NULL : &l_data_len,
                 &IDL_msp->IDL_status);
         if (IDL_msp->IDL_status != error_status_ok)
              RAISE(rpc_x_ss_pipe_comm_error);
     }
 !   else
 !   {
 !       l_data_len = w_data_len;
 !   }


  For I-char varying array marshalling, I tried the temporary patch to
'rpc_ss_ndr_marsh_cs_array()' (ndrmi5.c).

    idl_ulong_int cs_type_defn_index;
    idl_byte *cs_type_defn_ptr;
 !  idl_ulong_int *vary_length;

   ......

    /* Data limit information */
    if ((array_type == IDL_DT_VARYING_ARRAY)
        || (array_type == IDL_DT_OPEN_ARRAY))
    {
        array_defn_ptr++;       /* We know the lower data limit is fixed */
        IDL_GET_LONG_FROM_VECTOR(range_pair.lower, array_defn_ptr);
        array_defn_ptr++;       /* We know upper data limit is [length_is] */
        ln_type = *array_defn_ptr;  /* A */
        IDL_GET_LONG_FROM_VECTOR(ln_index, array_defn_ptr);
        ln_index--;     /* Shadow has one less elt than param or offset vec */
        range_pair.upper = rpc_ss_get_typed_integer(ln_type,
                            (rpc_void_p_t)&cs_shadow[ln_index].IDL_data,
                            IDL_msp);   /* B */
        range_pair.upper += range_pair.lower;   /* A + B */

 !      vary_length = (idl_ulong_int *)IDL_msp->IDL_param_vec[ln_index + 1];
 !      range_pair.upper = *vary_length;
    }

  This patch initialized the value of 'range_pair.upper', which looked
uninitialized with my test cases.  However, as Rico (@DEC) mentioned:

> The second fix does not appear to be correct to us.  The code is constructing
> a range pair which is based on the wire length of the data.  Your fix assigns
> a range_pair.upper that is based on the local length of the data.

  this is not the correct fix.

[6/13/94 public]

The fix is in the function rpc_ss_ndr_m_array_shadow. Previously, if 
the array was marked as idl_cs_no_convert, no length was calculated,
but was retrieved in rpc_ss_ndr_marsh_cs_array. The fix is to set the 
wire data length to be the local data length, and insert that value into
the shadow vector. 

This change will be checked in after the current beta.

[5/27/94 public]
  Charile's fix for marshalling worked.  Done.



CR Number                     : 10487
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : Avoiding TCP/IP shutdown period
Reported Date                 : 4/29/94
Found in Baseline             : 1.0.3
Found Date                    : 4/29/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b13
Affected File(s)              : rpc/runtime/comsoc_bsd.c
Sensitivity                   : public

[4/29/94 public]

As warned by dce_config, rpcd may not be restarted within 4 minutes of the
last termination (at least on HP-UX :-). This can be easily reproduced in
the following scenario.

1) rpcd has the open CN association when it gets killed.
For instance:

$ rpccp
rpccp> show mapping ncacn_ip_tcp:localhost
rpccp>

Immediately following "show mapping" command (within 30 seconds before the
association gets reclaimed), kill rpcd.

2) Restart rpcd, bind() fails because one unique TCP/IP association
(5-tuple) using the port 135 is in the shutdown phase.

This problem can happen to any servers using the well-known endpoint.
However, it can be avoided by setting SO_REUSEADDR socket option and
retrying bind().

Here is the suggested fix in rpc__socket_bind()::comsoc_bsd.c .

PRIVATE rpc_socket_error_t rpc__socket_bind
#ifdef _DCE_PROTO_
(
    rpc_socket_t        sock,
    rpc_addr_p_t        addr
)
#else
(sock, addr)
rpc_socket_t        sock;
rpc_addr_p_t        addr;
#endif
{
    rpc_socket_error_t  serr;
    unsigned32 status;
    rpc_addr_p_t temp_addr = NULL;
    boolean has_endpoint = false;
    int setsock_val = 1;

    RPC_LOG_SOCKET_BIND_NTR;

    /*
     * Check if the address has a well-known endpoint.
     */
    if (addr->rpc_protseq_id == RPC_C_PROTSEQ_ID_NCACN_IP_TCP)
    {
        unsigned_char_t *endpoint;

        rpc__naf_addr_inq_endpoint (addr, &endpoint, &status);

        if (status == rpc_s_ok && endpoint != NULL)
        {
            if (endpoint[0] != '\0')    /* test for null string */
                has_endpoint = true;

            rpc_string_free (&endpoint, &status);
        }
        status = rpc_s_ok;
    }

    /* 
     * If there is no port restriction in this address family, then do a 
     * simple bind. 
     */
    
    if (! RPC_PROTSEQ_TEST_PORT_RESTRICTION (addr -> rpc_protseq_id))
    {
        serr = 
            (bind(sock, (struct sockaddr *)&addr->sa, addr->len) == -1) ? 
                errno : RPC_C_SOCKET_OK;
#if defined(SOL_SOCKET) && defined(SO_REUSEADDR)
        if (serr == RPC_C_SOCKET_EADDRINUSE && has_endpoint)
        {
            if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,
                           &setsock_val, sizeof(setsock_val)) != -1)
            {
                serr = (bind(sock, &addr->sa, addr->len) == -1)
                    ? errno : RPC_C_SOCKET_OK;
            }
        }
#endif
    }                                   /* no port restriction */

    else                          
    {
        /* 
         * Port restriction is in place.  If the address has a well-known 
         * endpoint, then do a simple bind.
         */
        
        if (has_endpoint)
        {
            serr = (bind(sock, (struct sockaddr *)&addr->sa, addr->len) == -1)?
                errno : RPC_C_SOCKET_OK;
#if defined(SOL_SOCKET) && defined(SO_REUSEADDR)
            if (serr == RPC_C_SOCKET_EADDRINUSE)
            {
                if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,
                               &setsock_val, sizeof(setsock_val)) != -1)
                {
                    serr = (bind(sock, &addr->sa, addr->len) == -1)
                        ? errno : RPC_C_SOCKET_OK;
                }
            }
#endif
        }                               /* well-known endpoint */

        else
        {
		:
		:

[4/29/94 public]

It would be even better for rpcd to catch SIGHUP and SIGKILL and do a
rpc_mgmt_stop_server_listening.  That would allow rpcd to finish the calls
it had outstanding and close out the open connections before exiting.  You'd
also want to make sure that part of rpc_mgmt_stop_server_listening's job
was to shut down any remaining associations.

This should be done for all the daemons, so there is a clean way to get them
to exit.

[04/29/94 public]
dced does the hup/kill catching, and I believe the server style guide book
being written for 1.1 talks about this, too.

[4/29/94 public]

Also note the limitations to server shutdown processing described in OT 9957.
I'm not sure that CN will actually close its connections as a result of calling
rpc_mgmt_stop_server_listening (the RPC protocols are never notified that the
server is going down).

[4/29/94 public]

Well, we do sigwait() on SIGHUP (ignored), SIGINT, SIGQUIT and SIGTERM in
HP DCE product version of rpcd and call rpc_mgmt_stop_server_listening().
But, this problem still happens. Mark is right about
rpc_mgmt_stop_server_listening() not closing sockets. (I don't know if
closing sockets helps or not, though. May need to play with SO_LINGER?)
Currently CN does not provide the function for shuting down all
associations. (rpc__cn_assoc_reclaim() will not shutdown the association
with the client context.)

Beside, we can't force everybody to use the sigwait()'ing thread. :-)

[7/19/94 public]
Applied Seiichi's fix to use SO_REUSEADDR in binds with a fixed
endpoint.  dced does everything it can to shutdown correctly.



CR Number                     : 10458
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8157
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : cnassoc.c
Short Description             : Client process abends when
'cn' call is cancelled whilst transmitting data.
Reported Date                 : 4/26/94
Found in Baseline             : 1.0.3
Found Date                    : 4/26/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b13
Affected File(s)              : cnassoc.c
Sensitivity                   : public

[4/26/94 public]

    The client was calling the following remote procedure using connection
    orientated RPC.

        [idempotent] void
        doop_echo_array_to_int(
            [in]    handle_t                  handle,
            [in, size_is(in_array_size)] long in_array[],
            [in]    long                      in_array_size,
            [out]   long                      *echo_out,
            [out]   error_status_t            *comm_status_p);

    The client call was cancelled (by another thread in the client) whilst
    the client was still sending data to the server (the in_array_size
    was set at 100000 to test this). This caused the client process to
    abend, printing out the following message.

(rpc__cn_call_sm_protocol_error) Illegal state transition detected in CN
client
call state machine
(rpc__cn_call_sm_protocol_error) Current state: 2
(rpc__cn_call_sm_protocol_error) Current event: 4
(rpc__cn_call_sm_protocol_error) Call rep: 20510e28
(rpc) *** FATAL ERROR "(rpc__cn_call_sm_protocol_error)" at cnsclsm.c\2218
***
IOT/Abort trap(coredump)

     This is the associated stack trace:

raise(0x0) at 0xd000693c
abort(0x0) at 0xd000684c
rpc__die(0xd06e21ee, 0xd06e1b04, 0x8aa) at 0xd05ca0cc
rpc__cn_call_sm_protocol_error(0x205118c8, 0x0) at 0xd06e19c4
rpc__cn_sm_eval_event(0x4, 0x0, 0x205118c8, 0x205118fc) at 0xd06da7e4
rpc__cn_call_forward_cancel(0x205118c8, 0x2ff7f2bc) at 0xd05e3738
rpc__cn_call_local_cancel(0x205118c8, 0x2ff7ecb8, 0x2ff7f2bc) at 0xd05e3320
rpc__cn_assoc_send_frag(0x20511c58, 0x2051193c, 0x0, 0x2ff7f2bc) at
0xd06cb280
rpc__cn_transmit_buffers(0x205118c8, 0x2ff7f2bc) at 0xd06e2df0
rpc__cn_add_new_iovector_elmt(0x205118c8, 0x2ff7f504, 0x2ff7f2bc) at
0xd06e2798
transmit_req_action_rtn(0x205118c8, 0x2ff7f4e8) at 0xd06c791c
send_last_frag_action_rtn(0x205118c8, 0x2ff7f4e8) at 0xd06c7a50
rpc__cn_sm_eval_event(0x9, 0x2ff7f4e8, 0x205118c8, 0x205118fc) at
0xd06da7e4
rpc__cn_call_transceive(0x205118c8, 0x2ff7f4e8, 0x2ff7f94c, 0x2ff7f618,
0x2ff7f60c) at 0xd05e0d24
rpc_call_transceive(0x205118c8, 0x2ff7f4e8, 0x2ff7f94c, 0x2ff7f618,
0x2ff7f60c)
at 0xd05deec0
doop_echo_array_to_int(0x20140f58, 0x20140fb8, 0xf4240, 0x2ff7f9c8,
0x2ff7f9cc)
at 0x100036a8
do_echo(0x20140f58, 0x2ff7fa48) at 0x10001640
main(0x0, 0x2ff7fcdc) at 0x1000112c

    This problem occurs because the client calls
rpc__cn_call_local_cancel()
    from rpc__cn_assoc_send_frag(). The client is sending multiple packets
    of data for the first marshalled parameter. When the cancel occurs
    the client call state is still rpc_c_client_call_stub_wait (ie. current
    state is 2). Because the first packet has already been sent the event
    rpc_c_call_local_alert is evaluated (in rpc__cn_call_forward_cancel()).
    This is an illegal transition for the current state.

    The real problem is in rpc__cn_assoc_send_frag(). The packet to be sent
    to the server is referenced by the call_rep structure. When a cancel
    occurs the "cancel handling" routine rpc__cn_call_local_cancel()
    is called. Even if we allow the 'local_alert' event to be valid for
    the 'stub_wait' state, the action routine forward_alert_action_rtn()
    will over-write the packet referenced by the call_rep structure
    with a 'remote_alert' packet. This is a more general problem.
    Regardless of the current state the client is in, calling
    rpc__cn_call_local_cancel() is a mistake because it can cause the
    data to be over-written.

Repeat By:

    See description.

Proposed Solution:


    Replace the call to rpc__cn_call_local_cancel() in
    rpc__cn_assoc_send_frag() to just increment the count of cancels.

    Code patch for rpc__cn_assoc_send_frag()

        CATCH (pthread_cancel_e)
        RPC_LOG_CATCH_POST;
        {

#ifdef NON_CANCELLABLE_IO
            pthread_setasynccancel(CANCEL_OFF);
#endif
            /*
             * A sendmsg has just completed. Re-aquire the global mutex
             * and notify our receiver thread that we are done if it is
             * waiting.
             */
            RPC_CN_LOCK ();
            assoc->cn_ctlblk.in_sendmsg = false;
#ifdef BUGFIX
            /*
             * The test for cancel is before any data has been sent.
             * Set count of bytes of data sent to zero.
             */
            cc = 0;
            /*
             * Do NOT forward the cancel to the server just record
             * that it was detected.
             * Note: this is a copy of rpc__cn_call_local_cancel()
             * with the call to rpc__cn_call_forward_cancel() removed.
             */
            if (RPC_CALL_IS_CLIENT (((rpc_call_rep_t *) assoc->call_rep)))
            {
                /*
                 * Record the cancel that was just detected.
                 */
                assoc->call_rep->u.client.cancel.local_count++;
                rpc__cn_call_start_cancel_timer (assoc->call_rep, st);
                if (*st == rpc_s_ok)
                {
                    retry_op = true;
                }
                else
                {
                    retry_op = false;
                }
            }
            else
            {
                retry_op = false;
                *st = rpc_s_call_cancelled;
            }
#else

            rpc__cn_call_local_cancel (assoc->call_rep,
                                       &retry_op,
                                       st);
#endif
            RPC_DBG_PRINTF (rpc_e_dbg_cancel, rpc_c_cn_dbg_cancel,
                            ("(rpc__cn_assoc_send_frag) call_rep->%x
assoc->%x d
esc->%x cancel caught\n",
                             assoc->call_rep,
                             assoc,
                             assoc->cn_ctlblk.cn_sock));

        }

[7/19/94 public]
Applied the suggested fix, ran functional tests which unfortunatly
will only prove that I didn't break something we test for.

If we have an inhouse test (syseng?) that will verify this fix
we should run it.



CR Number                     : 10454
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : client w/encryption should handle server w/o
Reported Date                 : 4/25/94
Found in Baseline             : 1.0.3a
Found Date                    : 4/25/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : rpc
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : 

[4/25/94 public]
This is a combination of bugs in RPC and in DFS.  When a client that supports 
encryption makes an encrypted RPC (e.g. for bos addkey) to a server that
doesn't support encryption, there will be a problem.  It should be handled
as follows:
- server should transmit error code rpc_s_unsupported_protect_level to client
  (requires fixes to RPC, which is at present changing this to a more generic
  error code);
- client application (bos) should handle this error code by resetting itself
  to NOT use encryption and retrying the RPC.
I cannot easily submit this to 1.1 and so am sending "under separate cover"
the diffs for Transarc's sources to markar@apollo.hp.com.
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `'

[7/18/94 public]
Since our fix for DFS (bos) fix had been made for 1.0.3, we need the 1.0.3
RPC runtime portion fix.  If the 1.0.3 runtime fix is not scheduled
we would like OSF to give use the fix (diffs files) and merge the fix
into our 1.0.3 RPC runtime.  Could we get the fix as early as possible
if we need do it in our 1.0.3.

[7/18/94 public]
Unfortunately, this fix has *not* made it in to 1.1 yet.
I have added your userid to the CC list, so you will be notified
of any change in the status of this defect.  We expect this defect
to be fixed for the 1.1 release (right Mark?).

If you need a fix to 1.0.3 from 1.1 source you will have to contact
OSF Support.  They might be able to provide you with this type of fix
(a 1.1 fix applied to a 1.0.3 source base).

[7/19/94 public]

I'll try to have this done early next week.

[7/27/94 public]

I've checked in a fix for this in the following files:

    rpc/runtime/dgexec.c        1.1.102.2
    rpc/runtime/dgclsn.c        1.1.710.2
    file/userInt/bos/bos_main.c 1.1.132.2

The RPC part has been tested, and is ready to submit.

For the DFS change, I've simply merged in the changes that
Bruce sent me.  It hasn't been built or tested, and I'd like
to get someone closer to DFS to verify that everything is
working correctly.  Any volunteers?

[10/12/94 public]

Since dce1.1 mainline has changed, the above fix in dgexec.c is not
up-to-date. Also, while we are there, we should handle
rpc_s_invalid_checksum and rpc_s_invalid_crc status, which have
corresponding NCA reject status, too.

[12/19/95 public]
Fixed in DCE 1.2.1
Closed



CR Number                     : 10444
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : dg
Short Description             : WAY failure gets mapped to comm failure
Reported Date                 : 4/22/94
Found in Baseline             : 1.0.3
Found Date                    : 4/22/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : rpc/runtime/dgexec.c
Sensitivity                   : public

[4/22/94 public]

When WAY fails, the server sends back the nca_s_comm_failure reject status,
instead of the nca_s_who_are_you_failed status.

[5/27/94 public]

The fix has been submitted as a part of MBF code drop.



CR Number                     : 10427
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Cleanup needed for csrc sams file
Reported Date                 : 4/21/94
Found in Baseline             : 1.1
Found Date                    : 4/21/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : csr.sams
Sensitivity                   : public

[4/21/94 public]

Some minor cleanup neds to be done to the csrc sams file.  A review
comments have been given to Mariko Romagna.

[5/6/94 public]
Modifed csrc sams file based on Kathy's review.  Kathy checked the
modification for me.  Submitted to 1.1 tree with other csrc changes.

[5/10/94 public]
Nightly build was fine.  Closed.



CR Number                     : 10413
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Kerberos resp not validated
Reported Date                 : 4/20/94
Found in Baseline             : 1.0.3
Found Date                    : 4/20/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b19
Affected File(s)              : 
	./rpc/runtime/krbcn.c
	./rpc/runtime/krbcn.h
	./security/idl/sec_authn.idl
	./security/utils/seca_cn.c
Sensitivity                   : public

[4/20/94 public]

The connection-oriented RPC code currently does not check that an
authentication response message, sent in reply to a Kerberos authenticator,
was generated in reply to the particular authenticator that was used (rather
than an earlier authenticator for the same server).  This means that it would
be possible for an attacker to record a response message, and replay it in a
later authentication exchange, spoofing a client into thinking it had
authenticated to the correct server.

The way an authenticator is supposed to be matched to a response is that
response messages contain a copy of the microsecod-resolution timestamp from
the original authenticator, and client-side code is supposed to verify that the
timestamp in the response message is the same as that in the original
authenticator.  The current CO RPC code does not retain the timestamp that
was put in the authenticator, and it does not check it in the response.

The fix would be for sec_krb_cn_build_message (the routine in
security/utils/sec_authn.c that constructs the authenticator) to take two
additional parameters (a sec_krb_timestamp * and an unsigned32 *) to return
the authenticator timestamp & microsecond components, and to have RPC runtime
save these (change to rpc_krb_cn_info_t).  sec_krb_cn_decode_rep_message 
(the routine that decodes a response message) should take a sec_krb_timestamp 
and unsigned32, and compare these values with the timestamp in the reply 
message.  This is purely an RPC client-side change; the RPC server-side code 
already copies the timestamp from the authenticator into the response message.

[05/04/94 public]
Assigned to Bill Sommerfeld since I believe he is working on the sec_authn
code for 1.1 security.  I know he is modifying sec_krb_cn_build_message
for EPAC's.

[9/21/94 public]

Fixed more or less as suggested above.



CR Number                     : 10411
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : pipes
Short Description             : unsigned /signed type mismatch
in rpc_ss_initialize_callee_pipe()
Reported Date                 : 4/20/94
Found in Baseline             : 1.0.3
Found Date                    : 4/20/94
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b15
Affected File(s)              : ../src/rpc/idl/lib/pipesupp.c
					     ../src/rpc/sys_idl/stubbase.h
Sensitivity                   : public

[4/20/94 public]

 The first three parameters in the rpc_ss_initialize_callee_pipe() call are

	pipe_index,
	next_in_pipe, and
	next_out_pipe.

  They are declared type "unsigned long", both in the procedure and in the
prototype in stubbase.h. These parameters are used to initialize the 

	pipe_number,
	next_in_pipe, and
	next_out_pipe

fields of the rpc_ss_ee_pipe_state_t structure (defined in stubbase.h).
These fields are declared type "long" in the structure declaration. The result
is a type mismatch in rpc_ss_initialize_callee_pipe(). Since these fields
can take negative values, the error is in rpc_ss_initialize_callee_pipe(),
not in the structure declaration.

 If MIA is defined, the same mismatch will occur in the routine 
rpc_ss_mts_init_callee_pipe().

[8/12/94 public]
Removed 'unsigned' from argument decl.



CR Number                     : 10410
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : i18n
Short Description             : Stub returns 'comm failure' when code set conversion failed.
Reported Date                 : 4/20/94
Found in Baseline             : 1.1
Found Date                    : 4/18/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b17
Affected File(s)              : ./rpc/idl/lib/ndrui5.c
./rpc/idl/lib/sscmaset.c
./rpc/sys_idl/ncastat.idl
./rpc/sys_idl/rpc.sams
./rpc/sys_idl/rpcexc.h
Sensitivity                   : public

[4/20/94 public]

  When I18N code set conversion failed in a server stub, 'remote communication
failure' is returned to the client.  This is due to the following I-char 
unmarshalling code in IDL library.

        /* Call ..._from_netcs */
        (*(routine_ptr + IDL_RTN_FROM_NETCS_INDEX))(IDL_msp->IDL_h,
                *(IDL_msp->IDL_cs_tags_p->p_unmar_tag),
                wdata,
                w_data_len,
                l_storage_len,
                array_addr,
                ((array_type == IDL_DT_FIXED_ARRAY)
                    || (array_type == IDL_DT_CONF_ARRAY)) ? NULL : &l_data_len,
                &IDL_msp->IDL_status);
        if (IDL_msp->IDL_status != error_status_ok)
            RAISE(rpc_x_ss_pipe_comm_error);

  This code set conversion routine is (potentially) user supplied routine, so
'remote communication failure' is not the right error.  It really confuzes the
application developer.  It needs to indicate a code set conversion failed, so
the developer can find out the problem easily.  I don't ask to return 
IDL_msp->IDL_status to the client, since we cannot predict the value of the
status code at this point (as Tony mentioned).  So even though it will be
a fixed error status (something like rpc_x_ss_codeset_conv_error), it should
be other than 'remote communication failure'.

[4/21/94 public]

Just a note to the above: You also have to define a new nca_s_ fault
value (and doc it in the AES) so that IDL can map a server side
rpc_x_ss_codeset_conv_error exception to a fault packet and remap it
to the exception on the client side.  And, you need a matching status
code for the new exception in case [fault_status] is specified in the
operation.

[8/23/94 public]
Changed code in ndrui5.c (shown above) to raise new exception:
rpc_x_ss_codeset_conv_error instead of rpc_x_ss_pipe_comm_error.

Added exception definition to idl/lib/sscmaset.c, declaration to rpcexc.h.

Added new status code, rpc_s_fault_codeset_conv_error, to rpc.sams.

Added new nca fault code to sys_idl/ncastat.idl: 
	nca_s_fault_codeset_conv_error = 0x1C000023



CR Number                     : 10404
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : RPC sams file needs cleanup
Reported Date                 : 4/20/94
Found in Baseline             : 1.1
Found Date                    : 4/20/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b16
Affected File(s)              : rpc.sams
Sensitivity                   : public

[4/20/94 public]
I have reviewed the rpc.sams file and noted corrections necessary on hard
copy.  This review has been returned to Will Hopkins per Carolyn Frisco's
direction.

[08/25/94 public]
Editorial and content changes made where appropriate
as per Kathy's markup.



CR Number                     : 10377
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : dg runtime
Short Description             : ftserver dumps core
Reported Date                 : 4/14/94
Found in Baseline             : 1.1
Found Date                    : 4/14/94
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : dglsn.c
Sensitivity                   : public

[4/14/94 public]
This is another placeholder until I can reproduce it reliably.  I will
cancel it if this problem doesn't happen again.
 
Cell Config: running dce1.1ab2
486 core server
HP flserver 
HP fserver
 
Cell activity:
Running dfs.repfs -- didn't get beyond switch_rep.
Specifically, scheduled replication of a fileset.
 
Bos status output:
root@largo> bos status /.:/hosts/largo -proc ftserver -long
Bosserver reports inappropriate access on server directories.
Instance ftserver, (type is simple) has core file, currently running
normally.
    Process last started at Wed Apr 13 16:38:13 1994 (22 proc starts)
    Last exit at Wed Apr 13 16:38:12 1994
    Last error exit at Wed Apr 13 16:38:12 1994, due to signal 6
    Parameter 1 is '/opt/dcelocal/bin/ftserver'
 
Stack Trace:
 
>t
 0 kill@libc + 0x00000008 (hp-ux export stub)
 1 cma__abort_process@libdce + 0x000000a4 (0x6, 0, 0, 0x7b022d28)
 2 cma__bugcheck@libdce + 0x0000048c (0x7af50d30, 0x32, 0, 0x2)
 3 cma__assert_message@libdce + 0x000001bc (0, 0x7af6530c, 0x7af65340,0x89d)
 4 ptdexc_mutex_unlock@libdce + 0x000000a4 (0x4056ed68, 0, 0, 0)
 5 recv_dispatch@libdce + 0x000003c0 (0x400b5908, 0x4054ac48, 0x1,0x4056eccc)
 6 rpc__dg_network_select_dispatc + 0x0000041c (0xa, 0x400b5908, 0x1, 0x4050052c)
 7 rpc__dg_call_wait@libdce + 0x00000194 (0x4056ed60, 0x1, 0x4050052c, 0)
 8 rpc__dg_call_transmit_int@libd + 0x000001d0 (0x4056ed60, 0x40500408,0x4050052c, 0)
 9 rpc__dg_call_transmit@libdce + 0x000001bc (0x4056ed60, 0x40500408, 0x4050052c, 0x80040e03)
10 rpc_call_transmit@libdce + 0x00000074 (0x4056ed60, 0x40500408,0x4050052c, 0x2000)
11 rpc_ss_xmit_iovec_if_necess@li + 0x000000a0 (0x40500301, 0x405003f8,0x40500aac, 0x2000000)
12 rpc_ss_ndr_marsh_by_pointing@l + 0x000001c0 (0x2000, 0x1, 0x405d8fd8, 0x405003f8)
13 rpc_ss_ndr_m_fix_or_conf_arr@l + 0x000001d8 (0x405d8fd8, 0x1,0x405009dc, 0x400042e8)
14 rpc_ss_ndr_marsh_pipe@libdce + 0x000001e4 (0x5d8, 0x404ffcdc,0x405003f8, 0x5)
15 rpc_ss_ndr_marsh_interp@libdce + 0x00002c2c (0x1, 0x324, 0x40500668, 0x405003f8)
16 FTSERVER_Restore + 0x00000160 (0x40565930, 0x7, 0, 0x404ffcdc)
17 vols_Forward + 0x000007cc (0x405643b8, 0x40563c48, 0x6, 0x404ff8f0)
18 SFTSERVER_Forward + 0x00000240 (0x40563c48, 0x6, 0x404ff8f0, 0x404ff91c)
19 op7_ssr + 0x0000019c (0x40563c48, 0x400b4778, 0x404ff54c, 0x404ff530)
20 rpc__dg_execute_call@libdce + 0x000015d0 (0x400b4778, 0, 0, 0)
21 cthread_call_executor@libdce + 0x00000270 (0x400adad8, 0x7af6c6cc, 0x40167930, 0x25)
22 cma__thread_base@libdce + 0x0000021c (0x40167930, 0, 0, 0)

[4/26/94 public]
The ftserver has not been dumping core reliably, but frequently when I run
dfs.repfs (when it's testing the read/write and the read-only residing on
the same machine).  All the core files have the same stack trace.  I
haven't reproduced this on a rios.
 
Here is the FtLog...
 
1994-Apr-26 15:44:32 Log file initialized as
/opt/dcelocal/var/dfs/adm/FtLog
1994-Apr-26 15:44:33 Ftserver starting
1994-Apr-26 15:51:44 Dumping 1:ft.test-1 (0,,57)
1994-Apr-26 15:51:57 Restoring fileset 0,,53/1
1994-Apr-26 15:51:57 Restoring 1:ft.test-1.clone (0,,53)
1994-Apr-26 15:52:10 vols_Restore: returning 0
1994-Apr-26 15:52:10 Restored fileset 0,,53/1: returned code 0
1994-Apr-26 15:54:58 Creating fileset ft.test-2 (0,,60) on aggr 1
1994-Apr-26 15:54:58 Failed to open 1:0,,60, code = 572833799 (Fileset does
not
exist (dfs / ftu))
1994-Apr-26 15:54:58 ftserver_CreateVolume: created ft.test-2 as 0,,60 on
aggr 1
1994-Apr-26 15:55:25 Dumping 1:ft.test-2 (0,,60)
1994-Apr-26 15:55:35 Restoring fileset 0,,61/1
1994-Apr-26 15:55:35 Restoring 1:ft.test-2.readonly (0,,61)
1994-Apr-26 15:55:36 vols_Restore: returning 0
1994-Apr-26 15:55:36 Restored fileset 0,,61/1: returned code 0
1994-Apr-26 16:00:15 Dumping 1:ft.test-2 (0,,60)
1994-Apr-26 16:00:27 Restoring fileset 0,,53/1
1994-Apr-26 16:00:27 Restoring 1:ft.test-2.clone (0,,53)

[4/27/94 public]
You may want to check the per-thread stack size for ftserver on the
fatal platform.

[04/27/94 public]
John Dugas looked at this an recv_dispatch (in dglsn.c) is unlocking a mutex
that it doesn't own.

This code might be the cause:
        else
        {
            /*
             * The "normal" dispatch code will not expect this handle
             * to be locked.
             */
            RPC_DG_CALL_UNLOCK(&sp->ccall->c);
        }

or
       /*
         * When handling private sockets, the caller expects that the call
         * handle will be locked when we return.
         */
        if (sp->is_private)
            RPC_DG_CALL_LOCK(&sp->ccall->c);


Since the only other unlocks correspond to the global rpc mutex.

This may be related to the private sockets modification.
Assigning to Mark K. at HP.

[4/29/94 public]

Indeed it is.

For handling timeouts, the private socket code relies on cancels to rouse 
a thread out of the call to recvfrom.

The ftserver manager routines disable general cancelability, and then go
on to make chained RPCs (i.e., the manager becomes a client and ends up
using a private socket).

The private socket code is failing because general cancelability has been
disabled.  (In case it isn't clear, this is a bug in RPC.)

I've checked in a work-around, look in dglsn.c, rev. 1.1.912.2.

Basically, we need to enable general cancelability around the blocking 
recvfrom call, and make sure that any cancels we catch get disposed of in 
the way the application is expecting (they're either eaten, forwarded, or 
re-posted).  

(The only part missing from the work-around I've checked in is the case 
where the application disables cancelability, and then cancels the thread.
Handling this is a little tricky, and I don't think it's needed by the 
ftserver.)

[5/25/94 public]

I merged the changes in dglsn.c rev 1.1.912.2 into 1.1a, submitted and
tested using dfs.repfs both RIOS <-> HP, HP <-> RIOS. The ftserver
did not dump core. Additional testing will be done since ftserver
core dumps were not completely reliable prior to this partial fix but
it looks good so far ... Also, the repserver DID dump core (apparently
due to receiving a signal 6). This problem was also seen prior to this
partial fix with the dfs.repfs but less frequently and apparently not a
symptom of this CR - logging separately.

Please update this CR when the complete fix is done - thanks.

[6/6/94 public]

I've submitted the complete fix for this one.

In the case where the app has disabled cancellability, and then cancels the
thread, we hold onto the cancel until the call is done and then repost it
(locally).



CR Number                     : 10359
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : idl -no_header option is broken.
Reported Date                 : 4/14/94
Found in Baseline             : 1.1b6
Found Date                    : 4/14/94
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b15
Affected File(s)              : ./rpc/idl/idl_compiler/command.c
Sensitivity                   : public

[4/14/94 public]

The -no_header option to idl is broken.

If you invoke idl with the options
	-no_header -server none foo.idl
the generated foo_cstub.c file contains

#include <>

.. which is just plain wrong.

						- Bill

[8/17/94 public]
Fixed command.c to set the include file name even though
we aren't generating the actual include file.

We want this instead of removing the include all together,
since the -no_header option is for build systems which
want to create each part from an idl file seperately.



CR Number                     : 10352
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : DG
Short Description             : DG runtime needs to support delayed forwarding for dced
Reported Date                 : 4/14/94
Found in Baseline             : 1.1
Found Date                    : 4/14/94
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b8
Affected File(s)              : ./rpc/rpcd/rpcd.c
./rpc/runtime/comfwd.h
./rpc/runtime/dgfwd.c
./rpc/runtime/dgfwd.h
./rpc/runtime/dginit.c
./rpc/runtime/dglsn.c
Sensitivity                   : public

[4/14/94 public]

Defect to cover this work (as described by Rich Salz):

When it starts up, rpcd (or dced) calls rpc__server_register_fwd_map to
set up a forward map lookup (FML) function.  When an incoming request
comes in to rpcd, if the request should not be handled by rpcd, the DCE
runtime calls the FML to determine which server should actually get the
request.  For 1.1 we will expand the semantics of the FML so that it
can tell the runtime "I don't know yet."  If the runtime gets this value,
then dced guarantees that at some point it will call a NEW function and
tell it what to do with the packet.  In order for this to work, there must
be some state between the FML and the new RPC function.  This state
should be the "activity uuid" which is a field in the RPC DG packet header.

Right now, the FML gets called with the following parameters:
        /* [in] */    uuid_p_t           /*obj_uuid*/,
        /* [in] */    rpc_if_id_p_t      /*if_id*/,
        /* [in] */    rpc_syntax_id_p_t  /*data_rep*/,
        /* [in] */    rpc_protocol_id_t  /*rpc_protocol*/,
        /* [in] */    unsigned32         /*rpc_protocol_vers_major*/,
        /* [in] */    unsigned32         /*rpc_protocol_vers_minor*/,
        /* [in] */    rpc_addr_p_t       /*addr*/,
    /* NEW PARAMTER HERE; SEE BELOW */
        /* [out] */   rpc_addr_p_t      * /*fwd_addr*/,
        /* [out] */   rpc_fwd_action_t  * /*fwd_action*/,
        /* [out] */   unsigned32	* /*status*/,
The rpc_fwd_action_t is an enum that can have the following values
	rpc_e_fwd_drop,
	rpc_e_fwd_reject,
	rpc_e_fwd_forward

We need to add a new parameter to the FML.  Since the FML is never
documented and since only rpcd has ever set up an FML, and since dced
and libdce will be installed together, I propose that we change the
calling sequence.  The alternative is to provide a new internal API
that registers a new-style FML.  I don't think this is worth it.

So we change the fpw_cwd_map_fn_t to add this new parameter just before
the first [out] parameter:
	/* [in] */    uuid_p_t            /*actuuid*/,
It should be easy to change the FML call in dgfwd.c to just add
	hdrp->actuid
as a new parameter just before &fwd_addr.  (Right, Mark?)

We also add a new value to rpc_fwd_action_t:
	rpc_e_fwd_delayed

If the FML returns this new value then the runtime will "hold on to"
the request.  In addition, dced guarantees that at some point
it will call the following new function provided by the RPC runtime:
	rpc__server_fwd_resolve_delayed(
	    /* [in] */   uuid_p_t            /*actuuid*/,
	    /* [in] */   rpc_addr_p_t        /*fwd_addr*/,
	    /* [in] */   rpc_fwd_action_t  * /*fwd_action*/,
	    /* [out] */  unsigned32	   * /*status*/,

Once rpc__server_fwd_resolve_delayed the RPC runtime will stop holding on
to the request and forward it just as if the original FML returned the
values passed in here.

[04/15/94 public]
Code tested and submitted.



CR Number                     : 10351
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 8238
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : admin_gd
Short Description             : add description of endpoint restriction method
Reported Date                 : 4/14/94
Found in Baseline             : 1.0.3
Found Date                    : 4/14/94
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : admin_gd/rpc/rpc/appl_admin.gpsml
Sensitivity                   : public

[4/14/94 public]

Use of the RPC_RESTRICTED_PORTS feature should be explained somewhere
in the Administration Guide. The information is currently in Chapter
3 of the Porting Guide, in a section called ``RPC Endpoint Restriction''.
The section as it is there could probably just be copied or moved from
the Porting Guide chapter to the appropriate place in the Admin Guide,
wherever that is.

[4/18/94 public]

Assigned this CR to John Shirley (OSF RPC writer).



CR Number                     : 10346
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : Limitations with New Protseqs
Reported Date                 : 4/13/94
Found in Baseline             : 1.0.3
Found Date                    : 4/13/94
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : comtwrref.c
Sensitivity                   : public

[4/13/94 public]

The following is a memo on interoperability and backwards compatibility
problems that occur when RPC is expanded to include support for new
protocol sequences.  It contains a lot of background info, because the
memo was originally intended for a broader audience.  The meat of the
problem is that there needs to be a way for the RPC runtime to be able
to cope with protocol towers that it does not understand.  Currently,
it returns the errors indicating that the tower is not an RPC tower, and
that is it.  The RPC runtime needs to be enhanced so that protocol towers
that are unknown can be quietly ignored, if desired.

                 Effects of Adding Support For New Protocol
                 ==========================================
                     Sequences on DCE Interoperatbility
                     ==================================

                            Author:  Grant Alvis

The OSF DCE product offering supports communication between client
and server processes over a variety of protocol sequences. The modular
design of the RPC runtime library facilitates the addition of new protocol
sequences. By adding information to a core set of RPC data structures, and
then adding a few files with routines that provide runtime support for the
particulars of the new protocol sequence, you can extend the supported
protocol sequences beyond those of the base OSF DCE product offering.

This document discusses the issues surrounding the addition of new proto-
col sequences to DCE RPC. The major concern is the ability to support
backwards compatibility with previous versions of DCE RPC, which have
no knowledge of the new protocol sequences that have been implemented.
This concern is not just for one vendors ability to interoperate with its own
previous DCE versions, but also for interoperability between DCE offer-
ings from different vendors, where one vendor has implemented a new
RPC protocol sequence, and another vendor has no knowledge of it.


                           Background Information
                           ----------------------

Protocol Tower Storage Format in CDS and RPC
--------------------------------------------

RPC binding handles are stored in the CDS namespace and RPC endpoint
map as protocol towers. These towers exist in their canonical form, and are
encoded as simple octetstrings. When a DCE application makes a request
to the namespace or endpoint map for bindings, all protocol towers that
match the Interface ID/Object UUID criteria specified by the DCE applica-
tion are returned. Neither the CDS server daemon nor the RPC endpoint
map does any processing of the protocol towers before returning them to a
calling DCE application. The protocol towers are simply passed back to the
calling DCE applications RPC runtime library as an encoded octetstring.

RPC Runtime Protocol Tower Verification
---------------------------------------

It is the responsibility of the calling DCE applications RPC runtime library
to examine each protocol tower returned to ensure that two criteria hold for
each protocol tower: 1) the tower represents a known protocol sequence,
and 2) the protocol sequence the tower represents is supported. If these two
criteria hold, then the protocol tower can be converted into a binding han-
dle, and returned by the RPC runtime to the application code.

The RPC runtime contains a static table, called rpc_tower_prot_ids[], that
lists the syntaxes of all known protocol towers. Each table entry contains
information about the ordering of the component floors in each protocol
tower, as well as the syntax of each floor. The table entries also contain the
protocol sequence id that the tower represents. Determining the protocol
sequence id is done by breaking the protocol tower down into its compo-
nent floors, and comparing each floor against the entries in rpc_tower_pro-
t_ids[]. When each floor of a tower completely matches an
rpc_tower_prot_id[] table entry, then the protocol sequence for that tower
is known.

Once the protocol sequence of the tower has been determined, the RPC
runtime must then determine whether or not the protocol sequence is cur-
rently being supported by the process. This is done by comparing the proto-
col sequence id (gotten from making a match against an
rpc_tower_prot_id[] table entry) against another table, called rpc_g_prot-
seq_id[], which represents all protocol sequences that the RPC runtime
knows about. If the protocol sequence id matches one of the entries in the
rpc_g_protseq_id[] table, then a further test is done to ensure that the "sup-
ported" flag for the rpc_g_protseq_id[] table entry is set to "TRUE", indi-
cating that the process is currently allowing the use of that protocol
sequence.

When both of these criteria have been met, then the RPC runtime knows it
has a protocol tower that is valid to use, so it can then proceed to convert
the protocol tower into an RPC binding handle structure.

Adding RPC Runtime Support for a New Protocol Sequence
------------------------------------------------------

The addition of a new protocol sequence to the RPC runtime library
involves a variety of modifications to the RPC code, but central to all of
these changes is the need to expand the two tables discussed above: The
table indicating all known protocol towers, and the table containing all
known protocol sequences (See the table rpc_tower_prot_ids[] in file comt-
wrref.c, and the table rpc_g_protseq_id[] in comp.c for detailed informa-
tion).

                Compatibility Problems When Adding Support
                ------------------------------------------
                        for New Protocol Sequences
                        --------------------------

With the addition of new protocol sequences, however, it becomes a prob-
lem to provide backwards compatibility with previous revisions of DCE, or
compatibility with DCE offerings from different companies. New protocol
sequences mean new internal RPC table entries in the RPC runtime library
of the new release, which previous/other releases know nothing about.
Problems surface in all cases where a protocol tower representing a new
protocol sequence is given to an RPC runtime library that doesn't recog-
nize it. There are a variety of scenarios where this can happen. Some exam-
ples are given below.

Consider the case where a DCE server machine is an older DCE version,
and a DCE client machine is newer, and has additional support for new
protocol sequences. If a DCE server application on the client machine
exports bindings to the namespace, there will be towers stored in CDS that
the DCE server machine has no knowledge of. This in and of itself is not a
problem. However, if an administrator/user on the DCE server machine
issues an rpccp show mapping call or cdscp show entry call, the protocol
towers for the server application on the DCE client machine will be
returned. The RPC runtime library will be called upon to interpret the
unknown protocol tower, and will fail.

Another example is the case where a DCE client machine is an older DCE
version, and is being configured into a DCE cell where the DCE server
machine is a newer version. The DCE server machine will contain protocol
towers in the namespace that the client machine does not know about.
When dce_login attempts to bind to a security server, all binding handles
for the security server will be returned to the RPC runtime library of the
dce_login program. Since the protocol tower for the new protocol sequence
is not understood by the RPC runtime library, an error will be encountered.

In addition to the problem of backwards compatibility of one companies
DCE product releases, consider the case where a DCE cell consists of a
DCE client machine and DCE server machine from different vendors. If
one vendor (or both) have added support for new protocol sequences, the
same problems as described above will happen, since unrecognizeable pro-
tocol towers will be in use.

                       Solutions to the Problem
                       ------------------------

There are different approaches that will work as solution to the above men-
tioned problems. These approaches are each different and have advantages
and tradeoffs. Each is discussed below.

Solution #1: Add Additional Error Checking to the RPC Runtime Library
---------------------------------------------------------------------

Currently, the RPC runtime library inspects a protocol tower and attempts
to map it to a protocol sequence. If the protocol tower is unrecognizeable,
the RPC runtime raises the error "Not an RPC Tower". This gets propa-
gated back up the stack, and eventually the application code gets this error.
The RPC runtime code could be changed to simply ignore unrecognized
protocol towers. This will work in the case where a new DCE offering sup-
ports a new protocol tower and the RPC runtime of an older DCE offering
is returned this new protocol tower, and can't deal with it. However, this is
not a good solution in the case where there really is a problem with an RPC
protocol tower. If something goes wrong with the encoding/decoding of a
protocol tower, it is nice to have an error raised, rather than simply throw-
ing out the protocol tower and silently moving on.  The use of an environ-
ment variable could be used to add some flexibility in controlling how the
RPC runtime handles unknown protocol towers.  By default the RPC runt-
ime could quietly throw out the unrecognized protocol tower.  But if an
application needs/wants to know whenever a protocol tower is not sup-
ported, the environment variable could be set to indicate this.  Then when
an unrecognized protocol tower is encountered, an error would be raised.

Solutions #2: Dynamically Create RPC Internal Tables From an Editable
---------------------------------------------------------------------
System File
-----------

Currently, the RPC runtime has statically defined tables that contain all
known protocol sequences and all known protocol tower syntaxes. There-
fore they can not be modified by a DCE administator. By moving these
tables to exist in system files, then a DCE administator could edit these files
(ie with a utility program) and add/delete new protocol sequence and proto-
col tower knowledge to the DCE product as necessary. Then this file could
be read by the RPC runtime library, and the tables could be loaded dynami-
cally. This would NOT mean dynamic runtime support for new proto-
col sequences. It would, however, allow the RPC runtime to discern
between towers that are valid, but unsupported, versus towers that are com-
pletely unrecognizable.

There is the disadvantage of having to read in a system file and load some
internal RPC tables each time a DCE application process starts (assuming
of course that it makes use of the RPC runtime library). For small utility
programs (ie rpccp) there may be a noticeable overhead in loading the sys-
tem file each time it starts up, but for a long running applciation, the time
necessary to complete this startup task will become negligible in the grand
scheme of things.

Solution #3: Add a Parameter Containing Supported Protocol Sequences To
-----------------------------------------------------------------------
Routines That Make Requests For Protocol Towers
-----------------------------------------------

Another solution would be to allow the calling DCE application to indicate
what protocol sequences it supports. When a request is made to the RPC
endpoint map or CDS namespace for towers, the calling DCE application
could pass in a parameter (ie a bitstring, or something like that) that indi-
cates the protocol sequences that it supports. The endpoint map and
namespace information would then be filtered before it is returned to the
calling DCE application. That way, there would never be a case where an
unrecognized protocol tower being returned, since the calling DCE appli-
cation would control what is returned.

This solution is probably not feasible, since it involves a functional param-
eter change to an interface between two processes. Older versions of DCE
would not be able to communicate to newer versions, since the call param-
eters would have changed.



There is definitely a need for enhancing the RPC runtime library in some
fashion, in order to overcome the current limitations that will exist when
new protocol sequences are added to the RPC runtime library. The solu-
tions proposed here are more than likely not all-inclusive. All comments
and suggestions are welcome.

[04/15/94 public]
The RPC runtime should ignore protocols not supported on the local machine.
I believe we all expect(ed) your "Solutions #1" to work.  Can you
provide details where it doesn't so that we really can call this an RPC
defect?

[4/15/94 public]

The problem is in comtwrref.c::rpc__tower_ref_is_compatible(), which
does:

    /*
     * Obtain the protocol sequence from this tower.
     */
    rpc__tower_ref_inq_protseq_id (tower_ref, &tower_protseq_id, status);
    if (*status != rpc_s_ok)
    {
        return (false);
    }

When the protseq isn't recognized, rpc__tower_ref_inq_protseq_id returns 
a status of rpc_s_not_rpc_tower.

rpc__tower_ref_is_compatible should then set the status to rpc_s_ok, before
returning 'false'.

[05/04/94 public]
Looks to me like Marks solution is the right thing.

[6/30/94 public]
Applied the above fix.



CR Number                     : 10345
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : idl runtime
Short Description             : unmarshalling error in 103 interpreter 
B
Reported Date                 : 4/13/94
Found in Baseline             : 1.0.3
Found Date                    : 4/13/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : rpc/sys_idl/idlddef.h rpc/idl/lib/ndrmi.c rpc/idl/lib/ndrmi2.c rpc/idl/lib/ndrui.c rpc/idl/lib/ndrui.h rpc/idl/lib/ndrui2.c rpc/idl/lib/ndrui3.c
Sensitivity                   : public

[4/13/94 public]

Client unmarshalling error in DCE 103 IDL runtime interpreter.
The application works with old stubs.

- On AIX 1.0.3 based DCE: client is killed.
- On OS/2 1.0.3 based DCE: Client prints interger devide by zero exception.
  failed instruction is in the routine rpc_ss_expand_array() of
  src/rpc/idl/lib/ernodtbl.c. The value of variable "currently_mapped"
  becomes invalid and causes the interger devide by zero exception.

- On AIX 1.0.2 based DCE: the application works
*- On OS/2 1.0.3 based DCE with DCE 1.0.2 IDL: the application works

================
The idl file:

[uuid(003f6a42-b4bb-1d88-b004-08005a4d0ce1),version(1.0)]
interface try
{
  typedef [ptr, string] char *string_t;
  typedef struct {
    unsigned long count;
    [ptr, size_is(count)] unsigned long *ids;
    [ptr, size_is(count)] string_t *names;
    [ptr, size_is(count)] string_t *types;
  } idList_t;
  typedef [ptr] idList_t * idListP_t;

  unsigned long try_get1(
    [in] handle_t h,
    [out, ref] idList_t *idP
  );
  unsigned long try_get2(
    [in] handle_t h,
    [out] idListP_t *idPP
  );
}

Server program tryServer.c:

#include <stdio.h>
#include <stdlib.h>
#include "try.h"
#define StatusCheck(status, what)  if (status) { printf what; printf("
failure.  status 0x%x\n", status); exit(3); }

char *array[] = {"zero", "one", "two", "three", "four", "five",
       "six", "seven", "eight", "nine"};

unsigned long try_get1_mgr(h, identitiesP)
   /* [in] */ handle_t h;
   /* [out] */ idList_t *identitiesP;
{
   int i;
   identitiesP->count = 7;
   identitiesP->ids = (unsigned long *)rpc_ss_allocate(7*sizeof(unsigned long));
   identitiesP->names = (string_t *)rpc_ss_allocate(7 * sizeof(string_t));
   identitiesP->types = (string_t *)rpc_ss_allocate(7 * sizeof(string_t));

   for (i=0; i<7; i++) {
     identitiesP->ids[i] = i + 100000;
     identitiesP->names[i] = NULL;
     identitiesP->types[i] = array[i];
   }

   printf("from try_get1 \n");
   for (i = 0; i < identitiesP->count; i++)
     printf("%d (%s): %s\n", identitiesP->ids[i],
      (identitiesP->names[i] ? (char *)identitiesP->names[i] : ""),
      (identitiesP->types[i] ? (char *)identitiesP->types[i] : ""));

   printf("\n");
   return 0;
}

idList_t id;

unsigned long try_get2_mgr(h, idPP)
   /* [in] */ handle_t h;
   /* [out] */ idListP_t *idPP;
{
   int i;
   id.count = 7;

   id.ids = (unsigned long *)rpc_ss_allocate(7*sizeof(unsigned long));
   id.names = (string_t *)rpc_ss_allocate(7 * sizeof(string_t));
   id.types = (string_t *)rpc_ss_allocate(7 * sizeof(string_t));

   for (i=0; i<7; i++) {
     id.ids[i] = i + 100000;
     id.names[i] = NULL;
     id.types[i] = array[i];
   }

   printf("from try_get2 \n");
   for (i = 0; i < id.count; i++) {
     printf("%d (%s): %s\n", id.ids[i],
       (id.names[i] ? (char *)id.names[i] : ""),
       (id.types[i] ? (char *)id.types[i] : ""));
   }
   printf("\n");
   *idPP = &id;
   return 0;
}

int main(argc, argv)
   int argc; char **argv;
{
   static try_v1_0_epv_t try_epv = {try_get1_mgr, try_get2_mgr};
   unsigned long status;
   unsigned_char_t *networkAddr = NULL;
   unsigned_char_t *endpoint = NULL;
   unsigned_char_t *protseq = NULL;

   rpc_string_binding_parse(argv[1], NULL, &protseq,
       &networkAddr, &endpoint, NULL, &status);

   StatusCheck((status != rpc_s_ok), ("binding parsing"));
   rpc_server_use_protseq_ep(protseq, rpc_c_protseq_max_reqs_default,
         endpoint, &status);
   StatusCheck((status != rpc_s_ok), ("register server"));

   rpc_server_register_if(try_v1_0_s_ifspec, NULL,
       (rpc_mgr_epv_t)&try_epv, &status);
   StatusCheck((status != rpc_s_ok), ("register interface"));

   fprintf(stderr, "server listening...\n");
   rpc_server_listen(0, &status);
   StatusCheck(status, ("server listen"));
}

Client program tryClient.c:

#include <stdio.h>
#include <stdlib.h>
#include "try.h"
#define StatusCheck(status, what)  if (status) { printf what; printf("
  failure.  status 0x%x\n", status); exit(3); }

void Get1(binding)
   handle_t binding;
{
   unsigned long status;
   idList_t id;
   int i;

   status = try_get1(binding, &id);
   StatusCheck(status, ("get1"));

   for (i = 0; i < id.count; i++) {
     printf("%d (%s): %s\n", id.ids[i],
       (id.names[i] ? (char *)id.names[i] : ""),
       (id.types[i] ? (char *)id.types[i] : ""));
   }
}

void Get2(binding)
   handle_t binding;
{
   unsigned long status;
   idList_t *idP;
   int i;

   status = try_get2(binding, &idP);
   StatusCheck(status, ("get2"));

   for (i = 0; i < idP->count; i++) {
     printf("%d (%s): %s\n", idP->ids[i],
       (idP->names[i] ? (char *)idP->names[i] : ""),
       (idP->types[i] ? (char *)idP->types[i] : ""));
   }
}

int main(argc, argv)
   int argc;
   char **argv;
{
   handle_t binding;
   unsigned long status;

   rpc_binding_from_string_binding(argv[1], &binding, &status);
   StatusCheck((status != rpc_s_ok), ("binding import"));

   if (!strcmp(argv[2], "get1")) {
      Get1(binding);
   } else if (!strcmp(argv[2], "get2")) {
      Get2(binding);
   } else {
      fprintf(stderr, "illegel command: %s\n", argv[2]);
   }
}
============
This server's address is an well known end point.  The server start
 command example is

 tryServer "ncadg_ip_udp:muse[1234]"

 and the client commands can be

 tryClient "ncadg_ip_udp:muse[1234]" get1

 and

 tryClient "ncadg_ip_udp:muse[1234]" get2

 I build both the client and the server on an aix machine and an os2
 machine.  The result of testing is as follows:

 client on aix  server on aix  pass
 client on aix  server on os2  pass
 client on os2  server on aix  client reaches server (you can see
  the server prints out the data) and then hangs in cstub code
 client on os2  server on os2  server works as above but
  If I use the "get2" command, the client prints
   Exception: Integer divide by zero (dce / thd)
  If I use the "get1" command, the client prints
   get1 failure. status 0x5  (rpc call return code wrong)

 If I remove two fields "ids" and "names" from the following structure, the
 client works fine with servers on both os2 and aix.

     typedef struct {
       unsigned long count;
       [ptr, size_is(count)] unsigned long *ids;
       [ptr, size_is(count)] string_t *names;
       [ptr, size_is(count)] string_t *types;
     } idList_t;

[5/11/94 public]

The fixes have been submitted.  Here is a summary of the bug(s):
     There are several places where full [ptr] pointers are marshalled or
     unmarshalled and must be checked for NULL or aliasing.  These checks
     were being done by the caller of two common routines rather than in
     the called routine, and the checks were absent or partially absent at
     some of the call sites.  The fix is to properly modularize the code
     such that the checks are coded once in the common routine and so that
     all call sites remove any specific checking and call the common routine.



CR Number                     : 10341
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : during install of
multi-machine cell, rpcd fails
Reported Date                 : 4/13/94
Found in Baseline             : 1.1
Found Date                    : 4/13/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : combind.c
Sensitivity                   : public

[4/13/94 public]


The build of April 12, 194 compiled clean. 
The single cell smoketest was clean.

The multi-machine smoketest fails with the following message:


S:****** Starting rpcd...

>>> rpc runtime error: i18n tags structure is not valid (dce / rpc)

/.../sif_cell dce_config failed to find sec server uuid
ERROR:   Unable to get object uuid of security server.  Check that rpcd and

         secd are running on "sif" (130.105.5.25) and retry the
configuration.

[4/13/94 public]

  Added initialiation for i18n flag within rpc_binding_reset and
rpc__binding_alloc.  Added i18n flag copy within rpc_binding_copy.
Added #ifdef _KERNEL around i18n cleanup for rpc__binding_free.

[4/15/94 public]

  Nightly build and smoke tests verified the fix worked.



CR Number                     : 10334
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime/dg
Short Description             : Multi-buffer fragments work
Reported Date                 : 4/12/94
Found in Baseline             : 1.1
Found Date                    : 4/12/94
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b17
Affected File(s)              : 
	rpc/kruntime/BSD44_TEMPLATE/comsoc_sys.c
	rpc/kruntime/BSD44_TEMPLATE/comsoc_sys.h
	rpc/kruntime/BSD44_TEMPLATE/ipnaf_sys.c
	rpc/kruntime/HP800/comsoc_sys.c
	rpc/kruntime/HP800/comsoc_sys.h
	rpc/kruntime/HP800/ipnaf_sys.c
	rpc/kruntime/OSF1_TEMPLATE/comsoc_sys.c
	rpc/kruntime/OSF1_TEMPLATE/comsoc_sys.h
	rpc/kruntime/OSF1_TEMPLATE/ipnaf_sys.c
	rpc/kruntime/RIOS/comsoc_sys.c
	rpc/kruntime/RIOS/comsoc_sys.h
	rpc/kruntime/RIOS/ipnaf_sys.c
	rpc/runtime/HP800/ipnaf_sys.c
	rpc/runtime/HP800/sysconf.h
	rpc/runtime/RIOS/ipnaf_sys.c
	rpc/runtime/RIOS/sysconf.h
	rpc/runtime/com.h
	rpc/runtime/comnaf.c
	rpc/runtime/comnaf.h
	rpc/runtime/dg.c
	rpc/runtime/dg.h
	rpc/runtime/dgcall.c
	rpc/runtime/dgcall.h
	rpc/runtime/dgccall.c
	rpc/runtime/dgclsn.c
	rpc/runtime/dgexec.c
	rpc/runtime/dghnd.c
	rpc/runtime/dglsn.c
	rpc/runtime/dgpkt.c
	rpc/runtime/dgpkt.h
	rpc/runtime/dgrq.c
	rpc/runtime/dgrq.h
	rpc/runtime/dgscall.c
	rpc/runtime/dgsct.c
	rpc/runtime/dgslsn.c
	rpc/runtime/dgsoc.c
	rpc/runtime/dgsoc.h
	rpc/runtime/dgxq.c
	rpc/runtime/dgxq.h
	rpc/runtime/ipnaf.c
	rpc/runtime/ipnaf.h
	rpc/runtime/ipnaf_bsd.c
	rpc/runtime/krbdgcom.c
	rpc/runtime/rpcdbg.h
Sensitivity                   : public

[4/12/94 public]

This is a place holder for the second part of rfc20.0 work, multi-buffer
fragments.

[5/27/94 public]

The MBF code was submitted without the null call performance recovery,
which will be done later.

[8/26/94 public]

The last drop was submitted.



CR Number                     : 10310
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : Serviceability work
Reported Date                 : 4/6/94
Found in Baseline             : 1.1
Found Date                    : 4/6/94
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b15
Affected File(s)              : ./src/rpc/runtime/rpcsvc.h,./src/rpc/sys_idl/rpc.sams,./src/rpc/idl/lib/Makefile,./src/rpc/idl/lib/ctxeecli.c,./src/rpc/idl/klib/Makefile
Sensitivity                   : public

[4/6/94 public]

OT defect to cover work involved with
implementation of serviceability for
RPC.

[8/19/94 public]

Completed serviceability coding for RPC.



CR Number                     : 10263
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 12263
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_ref
Short Description             : Make tower API public
Reported Date                 : 3/31/94
Found in Baseline             : 1.0.3
Found Date                    : 3/31/94
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : See comments "09/19/94" below
Sensitivity                   : public

[3/31/94 public]

The only architecturally safe way to pass around references to 
DCE servers is by way of protocol towers;  string bindings are not
*guaranteed* to work when passed across the wire.

Since the tower API is currently private to the runtime, there is no
way for applications to do this type of thing safely.

Of immediate concern are the trigger binding fields included in the
schema entries managed through the security ERA APIs.  These bindings 
may be stored in three formats:

    - server entry name (for use with rpc_ns_binding_import calls)
    - string binding (for use with rpc_binding_from_string_binding)
    - protocol towers (for use with rpc_tower_to_binding).

This, of course, presupposes that whoever is updating these fields
can generate the towers they're interested in.

[03/31/94 public]
We've talked about this within the OSF DCE group and we agree
that this should be done.  The biggest impediment is assessing the
doc impact.

[04/01/94 public]
Added Dick, Art, and Hal to the interest list.

Is this a doc or a code issue?  I think it's a doc issue.  Where you thinking
of making code changes Mark?  If not, then let's turn this into a doc
bug and specify the routines that need to be made public:
	rpc_tower_to_binding
	rpc_tower_vector_from_binding
	rpc_tower_vector_free
And document in the app dev guide that a tower is the network rep of a
binding.  Servers that need to support referrals (e.g., those
mentioned in ERA attributes or those doing master/slave replication for
rdaclif) will need these routines to hack on opaque data types.  Nobody
else will.  Right?

[4/8/94 public]

The problem with exposing the routines as they now stand is that there
is a mismatch between what the tower data structure is, and what we're
making public.  That is, towers may contain i/f and transfer syntax info,
but the current calls only allow access to the binding information.

I would hate to think that someday we'll decide to make the whole tower
public, and need to add yet more calls to the API:

    rpc_tower_to_binding_etc(tower, &binding, &if, &xfer_syntax);
    rpc_tower_from_binding_etc(&tower, binding, if, xfer_syntax);they 

Perhaps the right thing to do is to make the _etc routines public (suitably
named), and leave the current tower routines private.  (The _etc
routines would then provide the same functionality if called with the 
i/f and xfer-syntax args set to NULL.)  Make sense?

[4/14/94 public]

Not really. 

As Joe Pato points out, the tower structure may someday change, so we can't
guarantee that we won't end up adding more routines later.  Since the current
routines meet the needs of all parties that have requested access to towers,
let's make those public, and worry about the future later.

Turned into a doc bug, see Rich's mail above for the routines that need to
be documented.

[7/11/94 public]

Assigned this CR to Peter Neilson (OSF writer).

[08/27/94 public]
From rsalz Sat Aug 27 11:14:02 1994
To: dce-tech
Subject: Making parts of the tower API public

OT CR 10263 discusses how we need to document part of the RPC tower
interface.  Briefly, the ERA and RDACL interfaces have the concept of
a "referral" where a read-only slave can direct a client to the read-write
master.

We're not going to tell people a great deal about how to do this, but it's
wrong to if we don't at least document the routines they'll need to call. :-)

I think most people will be confused by what follows -- you can probalby
just skip this.  A few people will understand and be even able to see if
I get it all right.  RPC guru's, you listening? :-)  One of you will
have to understand this well enough to document it.  Please comment.

The basic concept is that if a server wants to tell a client "go speak
to THAT server", the IDL interface must have some kind of referral operation
and related datatype.  The referal type can be any kind of array of towers,
more or less.  The sec_acl_tower_set_t typedef in rdaclbase.idl is a
good one to use.  It is basically an array of pointers to towers.
You also need the server-stub ifspec in order to build the tower.

Here is a psuedo-code for a server that wants to create a set of referral
towers.  Start with a few variables:
	rpc_tower_vector_t *twr_vec;
	rpc_binding_vector_t *bindings;
	rpc_id_handle_t SERVER_v1_0_s_ifspec; /* declared in the IDL-generated
	server-stub header file. */

	rpc_server_inq_bindings(bindings)
	/* Loop over the bindings returned. */
	for (i = 0 i < bindings->count; i++) {
	    /* Get an unresolved binding (endpoint) to this host and
	     * turn it into a tower vector.  One endpoint can become
	     * multiple towers. */
	    rpc_binding_copy(bindings->binding_h[i], &temp);
	    rpc_binding_reset(temp)
	    rpc_tower_vector_from_binding(SERVER_v1_0_s_ifspec, temp, &twr_vec);
	    rpc_binding_free(temp);
	    for (j = 0; j < twr_vec->count; j++) {
		/* Append twr_vec->tower[j] to a tower list; how to do this
		 * will depend on what the referral operation wants as its
		 * output. */
	    }

This routine should be called once during server init time, if only because
we never free the tower vector and have a slight memory leak.  (We could
free the tower vector if the "Append..." section copied the tower but for
brevity here I didn't sketch that out.  At any rate, rpc_tower_vector_free
does just what you think it does, if we were to revise the code so that
we could use it.)

Code that does this is in security/server/rs/rs.c, the
rpc_tower_vector_from_binding function.  It's a little tough to figure
out what's happening without bouncing around a bit.

A client who needs to process a referral and get a binding handle does
something like this:
	for ( /* loop over all towers we got back. */ ) {
	    rpc_tower_to_binding(list[i]->tower_octet_string, &binding)
	    /* Take the first tower that is compatible -- i.e., it's a
	     * network protcol we support. */
	    if (st == error_status_ok) break;
	}
	if (st != error_status_ok) fatal_error("Can't get there from here.")

Code that does this is in security/client/acl/daclbind.c, the
sec__acl_rebind_update function.  It's more straight-forward.

Here are the datatypes we need to document
	rpc_tower_vector_t (in rpcbase.idl)
	Mention a typical referral type (rdacl's sec_acl_tower_set_t)

Here are the routines we need to document (prototypes in rpcpvt.idl)
	rpc_tower_to_binding
	rpc_tower_vector_from_binding
	rpc_tower_vector_free

Comments?
	/r$

[8/29/94 public]

Should we just force rpc_tower_vector_from_binding to return 
towers with parially bound endpoints?

The intent of the caller is create a reference that can be used 
"later", in the same way that a reference put into the name space
is used "later".  For the same reason, you'd expect this new 
reference to be parially bound.

Allowing rpc_tower_vector_from_binding to create fully-bound towers
just makes using the function harder (i.e., copy and reset), and
makes it easier for developers to do the wrong thing.

[08/29/94 public]
Mark, I'm assuming sinc you didn't call me a dunderhead that I got
the details right. :-)  I think it's too late to change towervec_from_binding
to return partially-bound towers, and I'm not convinced it is the right
thing.  If I know the master is up I'm okay, and this can save me the
hassle of having to do set_object in my binding handle, right?

How about a towervec_from_binding_vec that does most of the above
code?

[09/19/94 public]
Created man pages -
  ./dce_books/app_ref/man3rpc/rpc_tower_to_binding.3rpc
  ./dce_books/app_ref/man3rpc/rpc_tower_vector_free.3rpc
  ./dce_books/app_ref/man3rpc/rpc_tower_vector_from_binding.3rpc
These have been verified by rsalz.

An explanation of the use of tower needs to be added to the Applications
Guide.  This work is deferred to 1.2.

[09/20/94 public]
Just to avoid confusion, I'm marking this one open (don't know affected
files, e.g., else I'd mark as fixed) and opening a new one to talk about
the app dev guide work.

[09/20/94]
Marked as verified.

[10/25/94 public]
Closed bug.



CR Number                     : 10233
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : combind.c has unterminated comment
Reported Date                 : 3/28/94
Found in Baseline             : 1.1
Found Date                    : 3/28/94
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : combind.c
Sensitivity                   : public

[3/28/94 public]

There is an unterminated comment around line 153 in combind.c:
surf>bdiff -b -c combind.c
./rpc/runtime/combind.c
Comparing the file in your sandbox with revision 1.1.58.3.
*** 1.1.58.3    1994/03/21 19:26:11
--- /u0/rcs_trees/dce/rcs/#odexm005930/combind.c        1994/03/28 19:33:04
***************
*** 7,12 ****
--- 7,13 ----
   */
  /*
   * HISTORY
+  * Fix typo: make sure comment is terminated in rpc__binding_free.
   * $Log:	c010233,v $
# Revision 1.3  94/03/29  12:02:01  nata
# added the Created HISTORY line
# 
# Revision 1.2  94/03/28  14:29:30  notuser
# changed fields: Status  Fixed In Baseline  How was this defect found?   new/changed/deleted note(s) [tom 03/28/94 public]
# 
# Revision 1.1  94/03/28  14:27:39  notuser
# new CR
# 
   * Revision 1.1.58.3  1994/03/21  19:26:11  tom
   *    Place rpc__binding_set_prot_version under ifndef _KERNEL.
***************
*** 152,162 ****
  
      /*
       * see if we have a protocol version
!      *
      if (binding_rep->protocol_version != NULL)
      {
          rpc__binding_prot_version_free(&(binding_rep->protocol_version));
      }
      /*
       * if we have any authentication info, free it up now.
       */
--- 153,164 ----
  
      /*
       * see if we have a protocol version
!      */
      if (binding_rep->protocol_version != NULL)
      {
          rpc__binding_prot_version_free(&(binding_rep->protocol_version));
      }
+ 
      /*
       * if we have any authentication info, free it up now.
       */

[03/28/94 public]
Fixed.



CR Number                     : 10205
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : botched key_info update
Reported Date                 : 3/22/94
Found in Baseline             : 1.1
Found Date                    : 3/22/94
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1maint, 1.2.1
Affected File(s)              : src/rpc/runtime/krbdgsrv.c
Sensitivity                   : public

[3/22/94 public]

After making an AUTH-WAY call, the server is failing to update the 
key_info correctly if the key number returned is not exactly 1 greater
than the current key.

The check:

        if (krb_key->current_key == ((ksno-1) & 0xff))

should be changed to:

        (((signed8) ((krb_key->current_key) - (ksno))) < 0)

which is the standard trick for dealing with wrap-around.

[12/05/95 public]

Fixed as suggested. The fix would allow key version to be incremented
by upto 127 ( modulo 2**8 )

[12/19/95 public]
Fixed in DCE 1.2.1
Closed



CR Number                     : 10173
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa,rs6000
S/W Ref Platform              : hpux,aix
Component Name                : rpc
Subcomponent Name             : rpc/kruntime
Short Description             : combind.c compilation errors
Reported Date                 : 3/18/94
Found in Baseline             : 1.1
Found Date                    : 3/18/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : kruntime/rpcmem_krpc.h
Sensitivity                   : public

[3/18/94 public]

[ /rpc/kruntime ]

cc: "/project/dce/build/dce1.1-snap/src/rpc/runtime/combind.c", line 2725: \
  error 1588: "RPC_C_MEM_PROTOCOL_VERSION" undefined.
cc: "/project/dce/build/dce1.1-snap/src/rpc/runtime/combind.c", line 2725: \
  warning 563: Argument #2 is not the correct type.
cc: "/project/dce/build/dce1.1-snap/src/rpc/runtime/combind.c", line 2768: \
  error 1588: "RPC_C_MEM_PROTOCOL_VERSION" undefined.
cc: "/project/dce/build/dce1.1-snap/src/rpc/runtime/combind.c", line 2768: \
  warning 563: Argument #2 is not the correct type.
*** Error code 1
....
`build_all' not remade because of errors.
*** Error code 1

[ /rpc/kdes ]

....
*** Error code 1

[03/18/94 public]
Added the define RPC_C_MEM_PROTOCOL_VERSION to rpcmem_krpc.h.

[03/25/94 public]
Passed nightly build.
Closed.



CR Number                     : 10170
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpcd
Short Description             : old files rpcdtest.c rpcdtest2.c
Reported Date                 : 3/17/94
Found in Baseline             : 1.1
Found Date                    : 3/17/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b7
Affected File(s)              : rpc/rpcd/{rpcdtest.c,rpcdtest2.c}
Sensitivity                   : public

[3/17/94 public]
The files rpcdtest.c and rpcdtest2.c in src/rpc/rpcd should be defuncted.
From looking at the first version of the makefile (RCS vers 1.1!!!)
we have never compiled them.  They don't really compile now, the tests
they do are broken anyway.

[04/08/94 public]
Defuncted the files, moved directly to closed.



CR Number                     : 10143
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : 
Short Description             : private client socket mods
Reported Date                 : 3/15/94
Found in Baseline             : 1.0.3
Found Date                    : 3/15/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : 
        dg.c              dgcall.c           dgccall.c
        dglossy.c         dgpkt.c            dgsoc.c
        rpcdbg.h          dg.h               dgcall.h
        dgclsn.c          dglsn.c            dgpkt.h
        dgsoc.h
Sensitivity                   : public

[3/15/94 public]

Opened as a place holder for new 1.1 work.

[3/18/94 public]

Submitted changes.



CR Number                     : 10110
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : connection oriented rpc
Short Description             : Context not rundown when
client dies during call using 'cn' RPC.
Reported Date                 : 3/9/94
Found in Baseline             : 1.0.3
Found Date                    : 3/9/94
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : cnsasgsm.c cnassoc.c
Sensitivity                   : public

[3/9/94 public]

        If a client process dies while the server is handling a call from
        that client then any contexts that client had with the server are
        never rundown. This is only a problem for connection orientated RPC.

        Detailed description of problem:

        Rundown of contexts occurs when the event rpc_c_assoc_grp_no_calls_ind
        is handled by a group in the call_wait state. This calls the
	routine rundown_handles_action_rtn() in cnsasgsm.c

        When a client process dies the routine rpc__cn_assoc_grp_rem_assoc()
        is called to remove the association (which was active between the
        server and client) from the association group.

        Example stack trace:

             rpc__cn_assoc_grp_rem_assoc
             rem_assoc_from_grp_action_rtn
             rem_mark_cancel_action_rtn
             rpc__cn_sm_eval_event
             rpc__cn_assoc_post_error
             receive_dispatch
             rpc__cn_network_receiver


        If the server is currently handling a call from the client
        (ie. assoc_grp->grp_callcnt != 0) the event
        rpc_c_assoc_grp_no_calls_ind is not handled, so any contexts are
        not rundown yet. HOWEVER, the event rpc_c_assoc_grp_rem_assoc is 
	handled which invokes decr_assoc_count_action_rtn() which clears 
	the group pointer (assoc->assoc_grp_id) in the association.

        In rpc__cn_call_executor() every call is completed by
        rpc__cn_call_end(). This calls rpc__cn_assoc_pop_call().
        When the call from the client (which died) completes the event
        rpc_c_assoc_grp_no_calls_ind is still not processed. This is
        because the association has been removed from the group
        (assoc_grp == NULL). Hence any contexts this client had with the
        server are never rundown.

[8/3/94 public]
	The solution is not clear the group id from the assoc
	in decr_assoc_count_action_rtn(), when the group is in the call
	wait state. A group reaches call wait state, when only 
	one association has an active references. 

	By not clearing the group id from the assoc
	rpc__cn_assoc_pop_call() will have the chance to invoke
	rundown_handles_action_rtn(). In rundown_handles_action_rtn()
	clear the group id from the assoc.

	Files affected:
	cnsasgsm.c
		decr_assoc_count_action_routine()
		rundown_handles_action_rtn()
	cnassoc.c
		rpc__cn_assoc_grp_rem_assoc()
		rpc__cn_assoc_pop_call()

[8/8/94 public]
	fix is submitted as explained above.



CR Number                     : 10103
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : idl compiler always generates stubs in favor of little-endian architecture.
Reported Date                 : 3/8/94
Found in Baseline             : 1.0.3
Found Date                    : 1/12/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b12
Affected File(s)              : ./rpc/idl/idl_compiler/ddspell.c
./rpc/idl/lib/interpsh.c
./rpc/idl/lib/ndrmi.c
./rpc/idl/lib/ndrmi2.c
./rpc/idl/lib/ndrmi3.c
./rpc/idl/lib/ndrmi5.c
./rpc/idl/lib/ndrui.c
./rpc/idl/lib/ndrui2.c
./rpc/idl/lib/ndrui3.c
./rpc/idl/lib/ndrui5.c
./rpc/sys_idl/idlddefs.h
Sensitivity                   : public

[3/8/94 public]

The new IDL compiler generates stubs that will favor little-endian
architecture. The generated stubs have IDL_type_vec containing many
numbers that are hard-coded (in a way) to be little-endian
representation. Also the supporting macros in idlddefs.h also hard-
codes the way it accesses this table. The table IDL_type_vec has
a field to specify the encoding of the numbers but by hard-coding
all other code that accesses the data in this table is a bigger
problem. 

Ideally, IDL compiler should allow a command line option to specify
what endian user would prefer to have in stubs. If this option is
not specified it could detect the endian of the host on which it is
running and generate code.

This problem causes unfair performance penalties for a big
endian architecture machines using new IDL as compared to the
little endian architecture machines.

[03/09/94 public]
We know about this (and other companies with a big-endian architecture
do too -- HP, IBM), and we plan on fixing this in the 1.1 release.

I'm not sure if there already is an outstanding bug on this.

[04/11/94 public]

I've changed the priority to 1 because we'd really like
to have this fixed as soon as possible.  

We have implemented a fix to libidl and its support macros
in idlddefs.h which allows the marshalling of type vector
information spelled in either endian type. We also have a
compiler fix which allows us to spell the type vector in 
big rather than little endian.  With a small amount of work
this could be made into a command line option. 

If work is not currently being done on this item, we would 
be willing to have the changes reviewed and submitted to the
OSF source base.

[7/13/94 public]
Submitted changes provided by HP to the following files:
			./rpc/idl/idl_compiler/ddspell.c
                        ./rpc/idl/lib/interpsh.c
                        ./rpc/idl/lib/ndrmi.c
                        ./rpc/idl/lib/ndrmi2.c
                        ./rpc/idl/lib/ndrmi3.c
                        ./rpc/idl/lib/ndrmi5.c
                        ./rpc/idl/lib/ndrui.c
                        ./rpc/idl/lib/ndrui2.c
                        ./rpc/idl/lib/ndrui3.c
                        ./rpc/idl/lib/ndrui5.c
                        ./rpc/sys_idl/idlddefs.h

Testing shows little to no effect on little-endian performance
and somehwere around a 6-10% improvement on big-endian machines.



CR Number                     : 10079
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : cleanup
Short Description             : MIN/MAX conflict with param.h
Reported Date                 : 3/7/94
Found in Baseline             : 1.1
Found Date                    : 3/7/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : dce/HP800/dce.h
Sensitivity                   : public

[3/7/94 public]
It seems that every time I compile an IDL stub I get warnings like the
following (compile line folded for legibility):
    c89 -c    -D_SHARED_LIBRARIES  +z   -D__hppa -Dhp9000s800 -Dhp9000s700
	-D__hp9000s800 -D__hp9000s700 -DHPUX -D__hpux -Dunix +DA1.0
	-D_HPUX_SOURCE    -I. -I/users/rsalz/sb/d/src/admin/dced/idl
	-I/users/rsalz/sb/d/src/admin/dced/idl
	-I/project/dce/build/dce1.1/src/admin/dced/idl
	-I/users/rsalz/sb/d/export/hp800/usr/include
	-I/users/rsalz/sb/d/export/hp800/usr/include
	-I/project/dce/build/dce1.1/export/hp800/usr/include    secval_sstub.c
    param.h: 391: warning- Redefinition of macro MIN.
    param.h: 392: warning- Redefinition of macro MAX.

Those warnings should not appear.

I believe that this is related to the order in which headers are
#include'd, coming out of the code-cleanup work, which is why I am
assigning this to RPC and not utils.  I started to trace down the header
dependencies and got a headache. :-)

[03/07/94 public]
I already talked with Charlie about this, and its a bug in the HP/UX
header files (param.h).  The HP versions do not protect themselves
with an #ifndef bracket.

The DCE header (dce.h) *does* do this, but unfortunately it gets 
included first.

Not much we can do about this (Fix HP/UX?), and I don't think re-arranging
all the includes in rpc to work around it is a great solution.  99%
of the code-cleaned DCE headers files expect dce.h to be included before
they are, and then they in turn include system headers, lots of which
include param.h.

I'm sure he can add further explaination when he gets back from vacation.

[3/7/94 public]

There are other HP-UX system header files which are not protected against
the multiple definitions of macros and we have no control over these files.
But then, it's probably true for user defined headers included after dce.h.

By the way, you can use "-Wp,-H" (undocumented, unsupported) c89 option to
find which headers are included by which.

[03/07/94 public]
{Sorry, I was cut-off in mid-edit.}

Tom's wording was a little off.  It is not a problem with multiple inclusion
but rather that there is just "#define MIN ..." which is not wrapped
inside an "#ifndef MIN" kind of thing.

You could make the case that putting MIN/MAX in param.h is not right,
but it follows Unix historic practice.  We *could* fix the problem.  I am
unsympathetic to "it's too hard" arguments -- if we're going to do code
cleanup then let's make the builds silent, d--n it. 

I think we should remove MIN/MAX from dce.h, perhaps putting them into
a separate file.

[3/8/94 public]

Rich is correct: the problem arises from because of the #define MIN in 
<sys/param.h>. The file itself is guarded appropriately. 

Solution? I would advocate either 1) removing MIN/MAX from dce.h, or 
2) renaming them to be DCEMIN and DCEMAX, since one could argue that we 
wish to utilize those macros that are defined in the DCE "namespace". 

Finally, as regards the ordering of include files: it is my strong belief
that each file should include the files that it needs, *and no others*.
This violates the guideline of "A header file shouldn't include another
header file", but to my mind, the resulting code is much more concise. Of
course, you then need some kind of browsing mechanism to determine what 
depends on what, but, hey, that's what CASE is all about, right? ;-)

[3/8/94 public]
Quick and dirty, have src/dce/HP800/dce.h #include <sys/param.h> instead of
defining MIN and MAX.  sys/param.h is prototected by duplicate inclusion.
It does mean this file is included in virtually every DCE file.  Is it
already; what else includes sys/param.h?

[03/08/94 public]
Oooh, include sys/param.h is very very icky -- who knows what gunk vendors
have put into that file.  I think Charlie's idea -- rename the macros to
have DCE_ prefixes -- is the best idea.  Submit it and see what breaks.

[melman 3/8/94 public] 
Hmmm, I was really trying to avoid things like DCE_TRUE and I think DCE_MIN
is in the same category.  How about putting them in a new dce_macros.h
file, doing a grep to see what files need them, and having those files
include dce_macros.h.  Or could grep for #define MIN|MAX\( and replacing
those with #include <dce_macros.h>

[03/23/94 public]
Added an include of sys/param.h to the HP version of dce.h.



CR Number                     : 10077
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rtandidl testcase
Short Description             : errors in do_rpc_test
Reported Date                 : 3/7/94
Found in Baseline             : 1.1
Found Date                    : 3/7/94
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : 
			src/test/rpc/rtandidl/control/do_rpc_test.sh
Sensitivity                   : public

[3/7/94 public]
There are two errors in the shell script do_rpc_test:

1) The following line causes the Xserver process to be killed on an
	AIX machine:

ps -ef | grep server | grep -v grep | awk '{ print \$2 }' | xargs kill -9


	This line along with the following:
ps -ef | grep sofserv  | grep -v grep | awk '{ print \$2 }' | xargs kill -9
ps -ef | grep mgmt_ser | grep -v grep | awk '{ print \$2 }' | xargs kill -9

can be combined and modified into the following:

      ps -eo comm,pid | awk '/server|sofserv|mgmt_ser/ {print $2}' | xargs kill


2) If the test is interrupted, it does not cleanup.


I have added a cleanup function that will perform the following:

	- kill server processes
	- dce_login as cell_admin and remove name space entries


Therefore the cleanup function is:
cleanup()
{
        echo "Stopping servers"
        ps -eo comm,pid | awk '/server|sofserv|mgmt_ser/ {print $2}'|xargs kill

        echo "Removing ns entries"
        dce_login cell_admin -dce- <<-DCE_LOGIN_EOF
                # Remove cds entries
                cdscp >/dev/null 2>&1 <<-CDSCP_EOF
                        del obj /.:/NSTEST_DIR/profile_test
                        del obj /.:/NSTEST_DIR/profile_test_export1_8_dup
                        del obj /.:/NSTEST_DIR/profile_test_export_1_1
                        del obj /.:/NSTEST_DIR/profile_test_export1_1
                        del dir /.:/NSTEST_DIR
                        q
                CDSCP_EOF
        DCE_LOGIN_EOF
}

trap "cleanup; exit 1" 1 2 3 15



CR Number                     : 10059
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : missing files in install tree
Reported Date                 : 3/3/94
Found in Baseline             : 1.1
Found Date                    : 3/3/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : 
	src/test/rpc/idl/context/Makefile
	src/test/rpc/idl/cover1/Makefile
	src/test/rpc/idl/pipefault/Makefile
	src/test/rpc/idl/pipetest/Makefile
	src/test/rpc/idl/no_op/Makefile
	src/test/rpc/idl/pipes/Makefile
Sensitivity                   : public

[3/3/94 public]
When I was running the rpc idl tests the following tests failed because
the corresponding .h file was not put into the install tree:

context
cover1
no_op
pipefault
pipes
pipetest

The solution is to modify the Makefile for each directory to put the
.h file into the install tree.

[4/6/94 public]
Verified that tests run OK.
Closed.



CR Number                     : 10057
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : idl compiler
Short Description             : Compilation errors
Reported Date                 : 3/2/94
Found in Baseline             : 1.0.3
Found Date                    : 3/2/94
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : 
			.../src/rpc/idl/idl_compiler/comstmts.c
			.../src/rpc/idl/idl_compiler/acf.y
Sensitivity                   : public

[3/2/94 public]

 There are two files in the .../src/rpc/idl/idl_compiler directory which 
do not compile properly if the symbol PROTO is not defined.

 The first is comstmts.c. The error is in the declarations for the routine 
CSPELL_return_status(). The declaration

   char *IDL_msp_name

is not terminated with a semicolon.

 The second is acf.y. The error is in the parameter list for the routine
process_rep_as_type(). The last parameter is "ref_name". It should be
"ref_type_name" in order to agree with the declarations, the parameter list
when PROTO is defined, and the body of the routine.

[05/04/94 public]
Fixing these today.

[05/04/94 public]
Code submitted.



CR Number                     : 10054
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : perf test failures
Reported Date                 : 3/2/94
Found in Baseline             : 1.1
Found Date                    : 3/2/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b7
Affected File(s)              : perf_tcp.sh perf_udp.sh run_client.sh
Sensitivity                   : public

[3/2/94 public]
The following errors were extracted out of the log files from the perf tests:


perf_tcp.sh errors only:

client 12a
*** "Unknown remote fault" exception raised
Callback (UNSUPPORTED!) test [12]
client 12b
*** "Unknown remote fault" exception raised
Callback (UNSUPPORTED!) test [12]


perf_tcp.sh and perf_udp.sh errors:

client 15c
        Correct cancel exception operation
    *** unexpected cancel timeout raised (1st call)!
    *** unexpected cancel timeout exception raised!
    *** unexpected cancel timeout exception raised!
    *** cancel exception NOT raised!
    *** and lost cancel (not pending)!
client 15d
        Correct cancel exception operation
    *** unexpected cancel timeout raised (1st call)!
    *** unexpected exception raised!
    *** cancel not pending
        Correct cancel exception operation
    *** unexpected cancel timeout raised (1st call)!


run_client.sh ncadg_ip_udp

Variable length output arg test [2]
    passes: 3; calls/pass: 3; verification: on; idempotent: yes; bytes/call: 100000
        pass   1; ms/call: 474.177; kbytes/sec: 210
        pass   2; ms/call: 386.972; kbytes/sec: 259
        pass   3; ms/call: 374.101; kbytes/sec: 267
*** Call succeeded (shouldn't have); bound to "ncadg_ip_udp:129.35.67.203[1994]", result="rain.austin.ibm.com"
Broadcast test [3]
  Broadcast call that should succeed...
    bound to "ncadg_ip_udp:129.35.67.203[2001]", result="rain.austin.ibm.com"
  Broadcast call that should get communications failure (exception case)...
    call failed as expected
  Broadcast call that should get communications failure (unknown i/f case)...
Maybe test [4]


run_client.sh ncacn_ip_tcp

Variable length output arg test [2]
    passes: 3; calls/pass: 3; verification: on; idempotent: yes; bytes/call: 100000
        pass   1; ms/call: 224.987; kbytes/sec: 446
        pass   2; ms/call: 220.146; kbytes/sec: 454
        pass   3; ms/call: 224.112; kbytes/sec: 446
*** "Communications failure" exception raised
Broadcast test [3]
  Broadcast call that should succeed...
Maybe test [4]

[3/3/94 public]

Test #12: Callback test

It says "UNSUPPORTED!" and it is unsupported. (Although DG protocol
implementation has it and Microsoft RPC claims that it supports callbacks,
AES does not define it.)

Test #15: Static Cancel test

Since the server manager routines have a cancellation point, i.e.,
printf(), this test doesn't work as expected. (And there are other timing
related issues...)

Test #3: Broadcast test

Of course, it's supported in DG only. You shouldn't run it with CN.
In case of DG failure, it was caused by one of these:

a) You started the perf server with -b option. (Or there was another server
with -b option already running. Maybe from the previous test run?)

b) You had run the test #8: Forwarding test, which failed and didn't
unregister perfb interface from the server, before running the test #3. (Or
there was another server already running in this state from the previous
test run.)

There is another failure mode which wasn't the cause of your failure.

c) There is a server running in the above mentioned states, i.e.,
supporting perfb interface, on the local network. After all, it is a
broadcast.

Well, these failures, except test #15, are caused by the operator error.
So, it leaves us only test #15 to be fixed (or dropped :-).

[04/06/94 public]

I modified the scripts so they will not run the DG only tests if you
are testing CN.  In addition, I removed test 12 from the tcp script
since it is unsupported and will fail.

I could not reproduce the broadcast failures on HP or 486.  I think
this was operator error.

For test #15 - The static cancel test, I increased the cancel timeout value
from 1 second to 5.  I don't believe the printf's in the server code
are cancel points as Seiichi states above.  The failure in the test
was because the timeout timer was expiring before the rpc call had
finished its sleeping ( the old values were 1 second sleep and 1 
second timeout).

IBM - Please re-run these test on the RIOS and update the TestSummary file.
Thanks.

[4/13/94 public]

Yes, printf()s in the server manager code are cancellation points. However,
the current CMA implementation will not raise the exception unless the IO
gets blocked, i.e., if the first write() attempt succeeds it will never
check the pending alert (see cma__ts_func()::cma_thread_io.h.). Luckily,
your printf()s never get blocked. Try it on the slow IO output device. I
don't know what Pthread draft 4 says about this behavior, though.



CR Number                     : 10052
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : rpccp
Short Description             : UUID string syntax wrong
Reported Date                 : 3/2/94
Found in Baseline             : 1.1b3
Found Date                    : 3/2/94
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b15
Affected File(s)              : uuid.c
Sensitivity                   : public

[3/2/94 public]
I have 1.1b3 running on my machine (lobster), and I can do the following
rpccp:

rpccp> add entry /.:/bar

>>> entry added

rpccp> export /.:/bar -i 11111111-2222-3333-4444-555555555555 \
>-b ncadg_ip_udp:12.34.56.78[90]

>>> binding information exported

rpccp> show entry /.:/bar

>>> no matching objects found

binding information:

  <interface id>   111111112222.44.44.55.55.55.55.55.55,0.0
  <string binding> ncadg_ip_udp:12.34.56.78[90]

rpccp>

The problem is that the last UUID displayed here is shown in old string
format.  It should be in new string format ("8-4-4-4-12" format).
*ALL* UUID's in DCE should be output in new string format (regardless
of the version number of the UUID itself).  Furthermore, it's not clear
to me that the old string displayed above is even correct (compare it to
the UUID that was exported).

[05/04/94 public]
Since rpccp is depricated for 1.1, this will not get fixed.
dcecp team should make sure this doesn't happen in dcecp.
Canceled.

[5/4/94 public]
I think this is a perceived bug in uuid_to_string().  There are those
factions that think that it should always use the new string format of
UUID's inspite of what the version imbedded in the UUID is.

[8/16/94 public]
uuid_to_string() now will always return uuids formatted in the DCE
manner, even old ones.



CR Number                     : 10047
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime/i18n
Short Description             : Possible memory corruptions
Reported Date                 : 3/1/94
Found in Baseline             : 1.1
Found Date                    : 3/1/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : rpc/runtime/ns_s_attr.c
Sensitivity                   : public

[3/1/94 public]

Although the num argumemt in rpc__nscodesets_to_codesets() is defined as

[in,out] in rpc/sys_idl/codesets.idl, i.e.,:

void rpc__nscodesets_to_codesets (
	[in] handle_t			h,
	[in,out] long			*num,
	[out, size_is(*num)] long	codesets[]
);

neither length in rpc_ns_mgmt_read_attr_next() or temp_size in
rpc_ns_mgmt_read_codesets() is initialized.

rpc_ns_mgmt_read_attr_next() and rpc_ns_mgmt_set_attribute() pass the
conformant array size in *bytes* to rpc__nscodesets_to_codesets() and
rpc__codesets_to_nscodesets() respectively where the conformant array size
is expected in the number of longs.

[3/2/94 public]

The inconsistency was the result of several minor implementation changes
during the whole I18N runtime development.  

The IDL encoding services interfaces were modified for passing the bytes
instead of long integer.

	void rpc__codesets_to_nscodesets (
		[in] handle_t                   h,
		[in] long                       num,
		[in, size_is(num)] byte         codesets[]
	);

	void rpc__nscodesets_to_codesets (
		[in] handle_t                   h,
		[in, out] long                  *num,
		[out, size_is(*num)] byte       codesets[]
	);

The initialization of 'length' in rpc_ns_mgmt_read_attr_next() was added
at the beginning of the call.

Since rpc_ns_mgmt_read_codesets() will call rpc_ns_mgmt_read_attr_next(),
the initialization of 'temp_size' is not necessary.

[4/14/94 public]

  The modification was submitted along with other rpc i18n changes.  Build
and smoke test were fine.  closed.



CR Number                     : 9987
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa,rs6000
S/W Ref Platform              : hpux,aix
Component Name                : rpc
Subcomponent Name             : rpc/idl/klib
Short Description             : library "libkidl" broken
Reported Date                 : 2/22/94
Found in Baseline             : 1.1
Found Date                    : 2/22/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : rpc/idl/lib/sscmaset.c
Sensitivity                   : public

[2/22/94 public]

An error in the following module caused library libkidl not to build,
breaking rpc/kdes and rpc/runtime:

[ /rpc/idl/klib ]

cc: "/project/dce/build/dce1.1-snap/src/rpc/idl/lib/sscmaset.c", line 718: \
error 1588: "rpc_x_stub_protocol_error_id" undefined.
*** Error code 1

[2/23/94 public]

Fixed in nightly build of 2/22/94, by adding an appropriate #define for 
rpc_x_stub_protocol_error_id in src/rpc/kruntime/exc_handling_ids_krpc.h.

There should be internal documentation somewhere pointing to this file
when new exceptions are added to the IDL compiler.



CR Number                     : 9981
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : RPC functions missing volatile qualifier
Reported Date                 : 2/18/94
Found in Baseline             : 1.1
Found Date                    : 2/18/94
Severity                      : A
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : stubbase.h
Sensitivity                   : public

[2/18/94 public]

Client stub code generated by the IDL compiler passes volatile-qualified
variables to the following two RPC functions: rpc_ss_init_node_table() and
rpc_ss_mts_client_estab_alloc(). The arguments for these functions do not
have the volatile-qualifier, which generates a warning from the 
AT386 and HP-UX compilers: the error message from the AT386 compiler
appears below:

dced_convert_cstub.c:585: warning: passing arg 1 of `rpc_ss_init_node_table' 
        discards `volatile' from pointer target type

dced_convert_cstub.c:586: warning: passing arg 1 of
 `rpc_ss_mts_client_estab_alloc'  discards `volatile' from pointer 
         target type

Section 6.5.3 of the ANSI standard state the following: 

"If an attempt is made to refer to an object defined with a volatile
qualified type through use of an lvalue with non-volatile qualified type,
the behavior is undefined"

[04/12/94 public]
The declarations and definitions of the two functions should be
changed to have the volatile qualifier.  Those functions are only used
by IDL-generated code, and IDL is doing the right thing so fix the source.
Before the cleanup there were no errors (the bug was latent) but now
there are so this is arguably a regression.  Raised priority and assigned
it to the RPC code-cleanup engineer.

[8/15/94 public]
Rico @ DEC fixed this a few weeks ago.
Closed.



CR Number                     : 9969
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : 1.0.2 idl sources not defuncted
Reported Date                 : 2/16/94
Found in Baseline             : 1.1
Found Date                    : 2/16/94
Severity                      : D
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b15
Affected File(s)              : see below
Sensitivity                   : public

[2/16/94 public]

There are two conflicting definition and declarations of the functions
BE_gen_sstub(). One is in 

  sstubgen.h/sstubgen.c. sstubgen.h is included by backend.c 

The other declaration/definition is in 
    sstubmts.h/sstubmts.c. mtsbacke.c includes includes sstubmts.h.

sstubmts.o is specified as a target in the Makefile; sstubgen is not. 

Should sstubgen.[hc] be removed from the source tree?

[2/17/94 public]

I've been wondering why OSF doesn't get rid of 1.0.2 IDL sources from
idl_compiler directory.

[05/04/94 public]
Charlie, can you please defunct the 1.0.2 IDL sources from our tree.

[8/17/94 public]
Removed all the old 1.0.2 idl sources from the idl_compiler directory.
Files removed:

./rpc/idl/idl_compiler/backend.c
./rpc/idl/idl_compiler/blocks.c
./rpc/idl/idl_compiler/blocks.h
./rpc/idl/idl_compiler/bounds.c
./rpc/idl/idl_compiler/bounds.h
./rpc/idl/idl_compiler/clihandl.c
./rpc/idl/idl_compiler/commstat.c
./rpc/idl/idl_compiler/cstubgen.c
./rpc/idl/idl_compiler/decorate.c
./rpc/idl/idl_compiler/decorate.h
./rpc/idl/idl_compiler/dflags.c
./rpc/idl/idl_compiler/dflags.h
./rpc/idl/idl_compiler/dutils.c
./rpc/idl/idl_compiler/flatten.c
./rpc/idl/idl_compiler/flatten.h
./rpc/idl/idl_compiler/forhdgen.h
./rpc/idl/idl_compiler/genpipes.c
./rpc/idl/idl_compiler/ifspec.c
./rpc/idl/idl_compiler/inpipes.c
./rpc/idl/idl_compiler/inpipes.h
./rpc/idl/idl_compiler/irepdmp.c
./rpc/idl/idl_compiler/localvar.c
./rpc/idl/idl_compiler/localvar.h
./rpc/idl/idl_compiler/marshall.c
./rpc/idl/idl_compiler/mmarsh.c
./rpc/idl/idl_compiler/mmarsh.h
./rpc/idl/idl_compiler/munmarsh.c
./rpc/idl/idl_compiler/munmarsh.h
./rpc/idl/idl_compiler/mutils.c
./rpc/idl/idl_compiler/mutils.h
./rpc/idl/idl_compiler/nodesupp.c
./rpc/idl/idl_compiler/nodesupp.h
./rpc/idl/idl_compiler/nodmarsh.c
./rpc/idl/idl_compiler/nodmarsh.h
./rpc/idl/idl_compiler/nodunmar.c
./rpc/idl/idl_compiler/nodunmar.h
./rpc/idl/idl_compiler/oolrtns.c
./rpc/idl/idl_compiler/oolrtns.h
./rpc/idl/idl_compiler/outpipes.c
./rpc/idl/idl_compiler/outpipes.h
./rpc/idl/idl_compiler/sstubgen.c
./rpc/idl/idl_compiler/sstubgen.h



CR Number                     : 9967
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rtandidl test (pattrc-8) fails.
Reported Date                 : 2/16/94
Found in Baseline             : 1.1
Found Date                    : 2/16/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b7
Affected File(s)              : test/rpc/rtandidl/moretests/pattrc.c
Sensitivity                   : public

[2/16/94 public]

rtandidl test fails when testing with bl-3 code.

test description:
pattrc in all_idl.tsh

The out put from the log file:

Routine Tested:   pattrc
Tested For:       8. test a context_handle and rpc_ss_destroy_client_context

Failure Message:  caught a status exception: 16c9a060
Subtotal: 7 passed, 1 failed

[04/07/94 public]
This was caused by a race condition in the test:
	- called op2 (which shutdown the server)
	- called is_listening
	- if it was, it re-called op2
	  by the time the second call to op2 executed, the server wsa gone.

Changed the code to only loop on is_listening, until the server is gone.

Fixed and Verified.



CR Number                     : 9966
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rtandidl test (pattrc-2) fails.
Reported Date                 : 2/16/94
Found in Baseline             : 1.1
Found Date                    : 2/16/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b7
Affected File(s)              : test/rpc/rtandidl/moretests/pattrm.c
Sensitivity                   : public

[2/16/94 public]

rtandidl test fails when testing with bl-3 code.

test description:
pattrc in all_idl.tsh

The out put from the log file:

Routine Tested:   pattrc
Tested For:       2. test a comm_stat parameter attribute as an out

Test Status:      Test FAILED
Subtotal: 7 passed, 1 failed

[4/7/94 public]
This was caused by an uninitialezed exception in the server.
It was returning stack garbage, which happened to be the no_memory
exception that the previous test used.

Fixed and Verified.



CR Number                     : 9965
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa,i486
S/W Ref Platform              : hpux,osf1
Component Name                : rpc
Subcomponent Name             : 
Short Description             : idl functional test(bug_3) fails.
Reported Date                 : 2/16/94
Found in Baseline             : 1.1
Found Date                    : 2/16/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : ndrtypes.h
Sensitivity                   : public

[2/16/94 public]
bug_3 (idl) functional test fails when testing with bl-3 code.

/tmp/results file after running the test:

****TEST bug_3 START****
PASS 0
bug_3_true != 0xff
ndr_true != 0xff
idl_true != 0xff
Summary: 1 passes, 3 failures
****server bug_3 output****
****TEST bug_3 END****
Client return code for bug_3: 1

[04/06/94 public]
The problem was the ndr_true was defined in terms of TRUE
instead of lowercase true.

I changed ndrtypes.h, a machine dependant file, to #define ndr_true true.
Reran the tests on all platforms (RIOS, AT386, HP).



CR Number                     : 9955
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : IDL compiler allows empty enum
Reported Date                 : 2/15/94
Found in Baseline             : 1.1
Found Date                    : 2/15/94
Severity                      : D
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : nidl.y
Sensitivity                   : public

[2/15/94 public]
The IDL compiler accepts an empty enum declaration, but either generates
bogus C code or crashes as a consequence.



CR Number                     : 9933
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : IDL files
Short Description             : Need fault_status comm_status
Reported Date                 : 2/10/94
Found in Baseline             : 1.1
Found Date                    : 2/10/94
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b13
Affected File(s)              : ep.acf, mgmt.acf, runtime/comep.c, runtime/mgmt.c
Sensitivity                   : public

[2/10/94 public]
All IDL files that are part of libdce should be compiled with ACF files
that have the [fault_status,comm_status] attributes.  Without this, a
failing RPC could cause client code to core dump when there is a perfectly
good error_status_t parameter available.  When adding the ACF files, it is
important to make sure that no API changes.  As most routines probably
already have an "error_status_t *st" parameter this will probably not be
an issue; routines that don't will have to be handled on a case-by-case,
probably by adding a new routine that DOES have the status param and
changing our existing code to call that routine.

[05/04/94 public]
This sounds like a pretty wide-sweeping change.
Any hint (Rich?) on how it can be done efficiently?

[05/04/94 public]
It is.
I'm clueless.
:-)

[6/30/94 public]
Upon invetigation I believe the only changes needed for this defect
are to add fault_status to ep.acf and mgmt.acf (which already exist
and have the attribute comm_status).

These are the only API's which are used by public routines that make
RPC's and thus might return an exception to an unexpecting client.

I am do a test build now and expect to submit soon.

[6/30/94 public]
Submitted.

[6/30/94 public]

Just out of the curiosity, what is the expected behavior when the thread
making rpc_ep_register() (or else) gets cancelled by the other thread?

Without [fault_status] (current behavior), if the cancel gets forwarded to
the server and the server detects it, the call gets cancelled and the
client thread gets cancelled. If the server doesn't see the cancel, the
cancel is pending and the client thread will get cancelled later. In both
cases, the cancel gets delivered to the client thread.

With [fault_status], if the cancel gets forwarded to the server and the
server detects it, it is eaten up by the client stub and the client thread
will never see it (it gets mapped to rpc_s_call_cancelled status). If the
server doesn't see the cancel, the cancel is pending and the client thread
will get cancelled later. So in the fisrt case the cancell gets lost, which
is probably the case for ep and mgmt ifs.

[7/1/94 public]

Good point.  If the app cancels the thread, then it's going to expect to
be able to catch that cancel.  The client agent code needs to check to see
if the fault it catches is a cancel, and then re-raise it if it is.

[7/5/94 public]

OK, so here is the code in rpc/idl/lib/sscmaset.c (rpc_ss_report_error_2):
    if (fault_code != error_status_ok)
    {
        if ( p_fault_status == NULL )
        {
            if (fault_code == nca_s_fault_user_defined)
            {
                RPC_SS_THREADS_RESTORE_ASYNC( *p_async_cancel_state );
                RAISE( *(user_exception_pointers[user_fault_id]) );
            }
            rpc_ss_raise_arch_exception( fault_code, *p_async_cancel_state );
        }
        else
        {
            *p_fault_status = rpc_ss_map_fault_code( fault_code );
            return;
        }
    }

And with the fault_status acf file, the stub calls this with 
p_fault_status != NULL, so cancels get mapped to rpc_s_call_cancelled
by rpc_ss_map_fault_code().

Do we believe that changing this code to something like the following
will be the right thing?

    if (fault_code != error_status_ok)
    {
NEW>>   if ( p_fault_status == NULL || fault_code == nca_s_fault_cancel)
        {
            if (fault_code == nca_s_fault_user_defined)
            {
                RPC_SS_THREADS_RESTORE_ASYNC( *p_async_cancel_state );
                RAISE( *(user_exception_pointers[user_fault_id]) );
            }
            rpc_ss_raise_arch_exception( fault_code, *p_async_cancel_state );
        }
        else
        {
            *p_fault_status = rpc_ss_map_fault_code( fault_code );
            return;
        }
    }

I am a little uncertain about this, as it may introduce other complications,
but it doesn't seem to be too bad.

The other alternative is to back out the fault_status change 
and defer this to 1.2.

[7/5/94 public]

No, this would prevent *all* applications from being able to receive 
notification of cancels through the fault_status paramater.

The change needs to be made in the client agent code, where the remote 
call is actually made.

For example, in comep.c::ep_register():

        (*ept_v3_0_c_epv.ept_insert)
              (ep_binding, 1L, ept_entry, replace, status);
        if (*status == rpc_s_call_cancelled)
              pthread_cancel(pthread_self());

[7/15/94 public]
I added the check for call_cancelled to each place the affected
interfaces were actually called and re-raised any cancels. (see above)
Files were runtime/{mgmt,comep}.c



CR Number                     : 9925
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : rpc/sys_idl/rpc.idl
Short Description             : librs.a failed to compile
Reported Date                 : 2/10/94
Found in Baseline             : 1.1
Found Date                    : 2/10/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : rpc.idl, cs_s_eval.c nslookup.c
Sensitivity                   : public

[2/10/94 public]

The compilations of "security/server/rs/rpriv.c" and 
"security/krb5/kdb/dispathc.c" broke with many errors involving many
include files.  A few of the errors:

[ /security/server/rs at 22:04 (PM) Wednesday ]

/project/dce/build/dce1.1-snap/src/security/server/rs/rpriv.c
In file included from ./rpriv.h:7, from \
/project/dce/build/dce1.1-snap/src/security/server/rs/rpriv.c:102:
/u1/devobj/sb/nb_486/export/at386/usr/include/dce/rpc.h:798: parse error \
  before `free_func'
/u1/devobj/sb/nb_486/export/at386/usr/include/dce/rpc.h:802: \
  `rpc_ns_import_ctx_add_eval' declared as function returning a function
/u1/devobj/sb/nb_486/export/at386/usr/include/dce/rpc.h:803: variable or \
  field `error_status_t' declared void
/project/dce/build/dce1.1-snap/src/security/h/priv_krb_util.h:110: parse \
  error before `error_status_t'
/project/dce/build/dce1.1-snap/src/security/h/priv_krb_util.h:125: parse \
  error before `error_status_t'
/project/dce/build/dce1.1-snap/src/security/h/priv_krb_util.h:132: parse \
  error before `error_status_t'

This caused the compilation of librs.a to fail, in turn causing the build
of secd, sec_clientd and sec_salvage_db to fail, thus making core smoketest
fail, and precluding a DFS smoketest (AT486 is the core server for the
3-machine DFS cell for smoketest.

[2/10/94 public]
There's been no security submissions in this area since mine went in a week
ago.  The above starts breaking in rpc.h, not security, so I'd suspect the
RPC I18N submission, and have reassigned this to 'RPC'.

[2/10/94 public]

A security IDL file was submitted the day before yeaterday.  I'm
reassigning this OT back to security and to developer John Bowe.

[2/10/94 public]

The problem is with the rpc I18N submission. The prototype free_func is
already used in encode.h file under kerberos. Mariko will re-name it to
something like cs_free_func in rpc.idl and submit the fix.

[2/10/94 public]

The name "free_func" was re-named to "cs_free_func".  The fix was tested on 
486.  Both libdce.so and librs.a were built.  The fix was submitted to 1.1
tree.  Waiting to see the result from nightly build.

[2/15/94 public]

  The nightly build on Saturday showed the problem was fixed.



CR Number                     : 9912
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000,i486
S/W Ref Platform              : osf1, aix
Component Name                : rpc
Subcomponent Name             : ./rpc/runtime
Short Description             : undefined symbols caused
libdce not to build
Reported Date                 : 2/9/94
Found in Baseline             : 1.1
Found Date                    : 2/9/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : libdce/AT386/machdep.mk libdce/RIOS/machdep.mk rpc/rpc.mk rpc/runtime/Makefile rpc/runtime/cs_s.h runtime/AT386/cs_s_conv.c runtime/RIOS/cs_s_conv.c
Sensitivity                   : public

[2/9/94 public]

On the 486/OSF/1  build:
[ /libdce at 20:27 (PM) Tuesday ]
makepath libdce/. && cd libdce &&  exec make MAKEFILE_PASS=THIRD

libdce_1.o: Undefined symbol "_iconv_close" referenced
libdce_1.o: Undefined symbol "_iconv_open" referenced
libdce_1.o: Undefined symbol "_stub_conversion" referenced
libdce_1.o: Undefined symbol "_iconv" referenced

On the RIOS build:
[ /libdce at 01:28 (AM) Wednesday ]
makepath libdce/. && cd libdce &&  exec make MAKEFILE_PASS=THIRD
.stub_conversion
*** Error code 8
`build_all' not remade because of errors.
*** Error code 1

[2/10/94 public]

  The problem was I didn't do the entire tree build before my submission.
I did the scratch build from 'rpc' directory on both AT386 and RIOS, but
I didn't realize there were so many machine dependent files for libdce,
and all platforms links libdce differently.

  The fix was submitted yesterday, and the build log showed libdce were
built on all three platforms.  But there is still minor security build
problem on 486, so I will wait to see the clean build.

[2/15/94 public]

  The nightly build on Saturday showed the problem was fixed.

  The problem was I didn't do the entire tree build before my submission.



CR Number                     : 9908
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_gd, app_ref
Short Description             : need to remove note saying
that Version 1.0 of DCE RPC supports datagram auth RPC only
Reported Date                 : 2/8/94
Found in Baseline             : 1.0.3
Found Date                    : 2/8/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : app_gd/rpc/basic_tasks.gpsml
Sensitivity                   : public

[2/8/94 public]

In various places in the Application Development Guide, and
on the rpc intro man page, there appears the following note:

"Note that DCE RPC Version 1.0 supports authenticated RPC
for the connectionless (datagram) protocol only."

This is no longer true so the note needs to be removed.

The affected files are:

/app_ref/man3rpc/intro.3rpc

/app_gd/rpc/1_intro.gpsml
/app_gd/rpc/2_components.gpsml
/app_gd/rpc/5_dce_rpc_ops.gpsml

[4/11/94 public]

Made this fix in app_ref/man3rpc/intro.3rpc since
I was already in there making enhancements.

[08/09/94 public]
Reassigned to myself.

[08/23/94 public]
Changed priority to "2" and severity to "C".

[9/6/94 public]
Due to reorganization of the RPC chapters of the Application development
Guide, only one of its files needed fixing, the new
app_gd/rpc/basic_tasks.gpsml.

[10/20/94 public]
Closed bug.



CR Number                     : 9887
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : bad ifdefs in idlbase.h
Reported Date                 : 2/3/94
Found in Baseline             : 1.0.3
Found Date                    : 2/3/94
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : idlbase.h
Sensitivity                   : public

[2/3/94 public]

 There are MIPS define conflicts in the header file idlbase.h. The file 
contains two sections of the form

#if ... defined(MIPSEL) || defined(__MIPSEL) ...
        	.
        	.
		.
#define  ndr_boolean       unsigned char
#define  ndr_false         false
        	.
        	.
		.
#endif

The symbols defined within both sections are identical, and will therefore
conflict with one another.

[02/03/94 public]
Charlie Brooks has corrected this (and other ifdef's) in his code cleanup
submission.



CR Number                     : 9876
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : sinix
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : test/rpc/idl:data files are not installed
Reported Date                 : 2/2/94
Found in Baseline             : 1.0.3
Found Date                    : 2/2/94
Severity                      : B
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b12
Affected File(s)              : src/test/rpc/idl/{context,cover1,no_op,pipefault,pipes,pipetest}/Makefile
Sensitivity                   : public

[2/2/94 public]

The Makefiles under src/test/rpc/idl/{context,cover1,no_op,pipefault,
pipes,pipetest} do not install datafiles context.h, cover1.h, no_op.h,
pipefault.h, pipes.h, and pipetest.h respectively. This causes these
tests to fail when installed through dcetest_config.

Add correct .h file in each of these Makefiles. E.g., for context
test do the following:

DATAFILES=RUN_ARGS context.h
   instead of just
DATAFILES=RUN_ARGS

[8/29/94 public]
Bob W. from IBM submitted these fixes in March 1994.
Closed.



CR Number                     : 9858
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : src/test/rpc/idl
Short Description             : pointer initialization error
Reported Date                 : 1/29/94
Found in Baseline             : 1.1
Found Date                    : 1/29/94
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : arraypt/manager.c,bug_3/manager.c,
multiref/managter.c,stringptr/manager.c,stringts/manager.c
Sensitivity                   : public

[1/29/94 public]

Numerous error messages of the form:

7764:"/project/dce/build/dce1.1-snap/src/test/rpc/idl/arrayptr/manager.c", \
  line 430.44: 1506-196 (S) The number 1 initializer is in error: \
  Initialization between types pointer and pointer is not allowed.
....
Error code 1

are issued for each "manager.c" file in the following test directories:

	src/test/rpc/idl/arraypt
			 bug_3
			 multiref
			 stringptr
			 stringts

[1/31/94 public]

This is more properly a code cleanup bug. The problem arises because the 
local definitions of the functions have a different signature than
the members of the given structure. 

Fix: include dce/dce.h in the offending files, and change to use
_DCE_PROTO_ instead of the (obsolet) NIDL_PROTOTYPES.

I am testing this fix now on both the HP800 and the RIOS, and will check
it in when the tree opens.

[2/1/94 public]

Files were submitted for the nightly build for 1 February 1994



CR Number                     : 9855
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : kruntime
Short Description             : code clean up breaks krpc
Reported Date                 : 1/28/94
Found in Baseline             : 1.1
Found Date                    : 1/28/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : See Below
Sensitivity                   : public

[1/28/94 public]
Surprise, Surprise.  When loading the KRPC kernel extension,  the 
following symbols are unresolved:

microtime
memmove
krpc_helper_machinit

The symbol microtime previously resolved to a macro.  The macro
was changed to caps in 1.1, but the invocation was never changed.

Many bcopys were changed to memmoves; memmove is not defined in
the kernel.

krpc_helper_machinit has analogous problem to microtime.

[1/31/94 public]

I've alread made the appropriate changes in the HP800 code, and checked for
analagous errors on the RIOS to fix this bug.  I'm in the process of
rebuilding the code now so we can smoketest the kernel library, and waiting
for my turn in the queue to submit the code.

[2/2/94 public]

Files submitted to the build fixed the above problems. A libknck was sanity
checked on the HP by Mike Schmitz (thanks, Mike) and passed (able to config
a cell, run several commands that use kernel RPC).

Files affected: 

rpc/kruntime/HP800/comsoc_sys.c
rpc/kruntime/HP800/ipnaf_sys.c
rpc/kruntime/HP800/pthread_sys.c
rpc/kruntime/HP800/sysconf.h
rpc/kruntime/HP800/uuidsys.c

rpc/kruntime/RIOS/comsoc_sys.c
rpc/kruntime/RIOS/krpc_helper_mach.h
rpc/kruntime/RIOS/sysconf.h

rpc/kruntime/krpc_helper.c
rpc/kruntime/rpcmem_krpc.h
rpc/kruntime/subr_krpc.c



CR Number                     : 9819
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 10091
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : systest / dcerpper
Short Description             : systest dcerpper fails with floating point errors
Reported Date                 : 1/25/94
Found in Baseline             : 1.1
Found Date                    : 1/25/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : perf/client.c
Sensitivity                   : public

[01/25/94 public]

The system test dcerpper has failed often with the following errors:

*** Floating error #1 (0 != 0 -- (0 / 16956) * (0.015625 / 7))
*** Floating error #2 (++ != ++ -- (16956 / 0) * (7 / 0.015625))

*** Floating error #1 (0 != 0 -- (0 / -25576) * (6.34236e-05 / 3.79625e+08))
*** Floating error #2 (--- != --- -- (-25576 / 0) * (3.79625e+08 / 6.34236e-05))

*** Floating error #1 (0 != 0 -- (0 / 17929) * (5.67408e-05 / 196))
*** Floating error #2 (++ != ++ -- (17929 / 0) * (196 / 5.67408e-05))

*** Floating error #1 (++ != ++ -- (28545 / 0) * (4.72367e-05 / 2.01235e+06))
*** Floating error #2 (0 != 0 -- (0 / 28545) * (2.01235e+06 / 4.72367e-05))

etc.

[1/25/94 public]

As you can see from the above errors, they are caused by the inadequate
comparison of floating numbers in
approx_eq()::test/rpc/runtime/perf/client.c . These numbers all end up with
zero or infinite because of zero returned from rand(). They are indeed
equal within a reasonable error, i.e., 0 == 0, inf == inf.

[03/08/94 public]
Defect 10091 might be a duplicate of this one, only the symptoms might be
different on the AIX platform which dumps core.

[04/04/94 public]
Fix test up so rand() can't return 0, by adding 1 to the result of rand().
Submitted.

[04/27/94 public]
This defect is closed, but 10091 is still open.



CR Number                     : 9805
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : acl_edit, acl_server, DFS utils
Short Description             : /bin/ld: Unsatisfied symbols: uuid_nil (data)
Reported Date                 : 1/24/94
Found in Baseline             : 1.1
Found Date                    : 1/24/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : svr_example
Sensitivity                   : public

[1/24/94 public]

"security/clinet/admin/acl_edit", "security/client/admin/sec_admin",
"security/client/dce_login", and "/security/h" are all affectd by the
error:

[ /security/client/admin/acl_edit/svr_example at 22:22 (PM) Saturday ]

c89      -z -Wl,-Bimmediate,-Bnonfatal,-a,default,+b,/lib:/usr/lib \ 
  -L/u3/devobj/sb/nb_ux/export/hp800/usr/shlib \
  -L/project/dce/build/dce1.1-snap/export/hp800/usr/shlib -L \
  /usr/shlib -L/u3/devobj/sb/nb_ux/export/hp800/usr/lib \
  -L/project/dce/build/dce1.1-snap/export/hp800/usr/lib \
  -o acl_server.X dacl_manager.o   dacl_server.o    rdaclif_sstub.o \
  -L../../../../utils -lsecutil -ldce
/bin/ld: Unsatisfied symbols:
   uuid_nil (data)
*** Error code 1
`build_all' not remade because of errors.
*** Error code 1

[1/24/94 public]
Nope, this isn't mine.  I only own security/audit.  Removing 'luan' and
'zeliff' from the interest and assignee list.

[1/24/94 public]

The problem seems to affect "file/bosserver" and "file/update" on the HP:

[ /file/bosserver at 02:48 (AM) Sunday ]

xlc           -L/u1/devobj/sb/nb_rios/export/rios/usr/lib \
  -L/project/dce/build/dce1.1-snap/export/rios/usr/lib \
  -o bosserver.X bossvr_main.o bossvr_ncs_procs.o bbos_bnode.o \
  bbos_ncs_interface_sstub.o  bossvr_thread_childWatch.o \
  bossvr_thread_reBossvrWatch.o bossvr_thread_bnodeTimeout.o \
  bossvr_bnode_ezops.o bossvr_bnode_cronops.o  bossvr_afsFiles.o \
  bossvr_sleep.o bossvr_debug.o  -lbos -lcmd -lcmdAux -lafsutil -lncompat \
  -ldacl -ldauth -ldacllfs -ldacl -ldauth -ldacllfs  -lncompat -losi \
  -lcommondata -lcom_err -ldce -lafssys  -lbsd
0706-317 ERROR: Unresolved or undefined symbols detected:
                 Symbols in error (followed by references) are
                 dumped to the load map.
                 The -bloadmap:<filename> option will create a load map.
uuid_nil
*** Error code 8
`build_all' not remade because of errors.

[1/24/94 public]

It also affects "file/bosserver" and "file/updat" on the RIOS as well.

[1/24/94 public]
Ron, this has nothing to do with audit.

[1/24/94 public]
Cool, a yoyo CR...  I agree it probably has nothing to do with audit,
but don't you find it strange that both security and DFS started having
problems with an unresolved uuid_nil at the same time?  Seems like the
RPC code cleanup submission on Friday broke this too.  Nothing has been
submitted for security or DFS that would break both of these at the same
time over the weekend.  I'm reassigning this to RPC.

[1/24/94 public]
We just tracked this problem down. The code clean-up submission of RPC does
not have GLOBAL declaration for uuid_nil in uuid.c file. Charlie Brroks will 
submit a fix for this CR.

[1/24/94 public]

Fixed in rpc/runtime/uuid.c in submission for 1-24-94.



CR Number                     : 9803
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa,rs6000
S/W Ref Platform              : hpux,aix
Component Name                : rpc
Subcomponent Name             : rpc/kruntime
Short Description             : inconsistent declarations in subr_krpc.c, etc.
Reported Date                 : 1/24/94
Found in Baseline             : 1.1
Found Date                    : 1/24/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : kruntime/subr_krpc.c,
					     runtime/dgutl.c,krpc_helper.c
Sensitivity                   : public

[1/24/94 public]

On the HP the break causes errors in kruntime and kdes:

[ /rpc/kruntime ]

cc: "/project/dce/build/dce1.1-snap/src/rpc/kruntime/subr_krpc.c", line 939:
  error 1584: Inconsistent type declaration: "memset".
cc: "/project/dce/build/dce1.1-snap/src/rpc/kruntime/subr_krpc.c", line 939:
  error 1711: Inconsistent parameter list declaration for "memset".
*** Error code 1

On the RIOS ithe bug affects not only "kruntime/subr_rpc.c" but also
"runtime/dgutl.c,krpc_helper.c":

[ /rpc/runtime ]

"/project/dce/build/dce1.1-snap/src/rpc/runtime/dgutl.c", line 179.41:
1506-081 (S) Discarding \
previously defined typedef identifier: rpc_dg_pkt_hdr_p_t
"/project/dce/build/dce1.1-snap/src/rpc/runtime/dgutl.c", line 179.66:
1506-046 (S) Syntax erro\
r.
"/project/dce/build/dce1.1-snap/src/rpc/runtime/dgutl.c", line 179.85:
1506-081 (S) Discarding \
previously defined typedef identifier: rpc_dg_pkt_hdr_p_t
"/project/dce/build/dce1.1-snap/src/rpc/runtime/dgutl.c", line 189.5:
1506-046 (S) Syntax error\
.
"/project/dce/build/dce1.1-snap/src/rpc/runtime/dgutl.c", line 179.11:
1506-081 (S) Discarding \
previously defined typedef identifier: rpc_dg_pkt_hdr_p_t
"/project/dce/build/dce1.1-snap/src/rpc/runtime/dgutl.c", line 195.1:
1506-046 (S) Syntax error\
.
"/project/dce/build/dce1.1-snap/src/rpc/runtime/dgutl.c", line 214.9:
1506-045 (S) Undeclared i\
dentifier rpc_g_dg_pkt_log.
*** Error code 1

[1/24/94 public]
Changing status of this CR to fixed. Code submissions will fix this in 
the nightly build of 1-24-94



CR Number                     : 9797
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc/runtime
Short Description             : undeclared identifier
rpc_c_socket_ok and other errors
Reported Date                 : 1/22/94
Found in Baseline             : 1.1
Found Date                    : 1/22/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : rpc/runtime/cominit.c
Sensitivity                   : public

[1/22/94 public]
The following are the first feww errors that showed up. There are too many
to list. Refer to the nightly build logs dated 01-21-94 for more examples.

/rpc/runtime/cominit.c", line 733.33: 1506-045 (S) Undeclared identifier 
rpc_c_socket_ok.

/rpc/runtime/comnaf.c", line 974.42: 1506-016 (E) Operands must
be pointers to compatible types.

/rpc/runtime/comnaf.c", line 977.23: 1506-045 (S) Undeclared identifier 
rpc_c_socket_ok.

/rpc/runtime/comnet.c", line 2366.23: 1506-045 (S) Undeclared id
entifier rpc_c_socket_ok.

/rpc/runtime/cnassoc.c", line 2050.355: 1506-022 (S) msg_accrights not a member of the struct or union msg.

/rpc/runtime/cnassoc.c", line 2154.13: 1506-056 (S) Break statement cannot 
be placed outside a while, do, for, or switch statement.

/rpc/runtime/cnnet.c", line 303.21: 1506-045 (S) Undeclared identifier 
RPC_C_LISTEN_BACKLOG.

/rpc/runtime/cnnet.c", line 449.31: 1506-045 (S) Undeclared identifier 
rpc_c_socket_ok.

/rpc/runtime/cnnet.c", line 452.17: 1506-056 (S) Break statement
 cannot be placed outside a while, do, for, or switch statement.

[ rrizzo 1/24/94 public ]

This OT duplicates OT 9803 which was filed against a more recent build
so I'm closing this one.



CR Number                     : 9794
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime/com
Short Description             : Pre-fork handler causes the forked child process coredump
Reported Date                 : 1/21/94
Found in Baseline             : 1.0.3
Found Date                    : 1/21/94
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : rpc/runtime/comfork_cma.c
Sensitivity                   : public

[1/21/94 public]

If the RPC application's forked child process (no exec) forks again before
the RPC runtime is reinitialized, the RPC runtime's pre-fork handler causes
the coredump because of pthread_mutex_lock() tried on the cleared (by the
previous child-post-fork handler) mutex. Since there is no way to
unregister the fork handler in the child process, the fix is do nothing in
the fork handler if rpc_g_initialized == false.

[7/15/94 public]

Submitted.



CR Number                     : 9778
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : cln
Short Description             : Code Cleanup task
Reported Date                 : 1/19/94
Found in Baseline             : 1.1
Found Date                    : 1/19/94
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : most of rpc
Sensitivity                   : public

[1/19/94 public]

This CR is a place holder for the code cleanup effort for the RPC
component. 

Following the existing (1/19/94) directory hierarchy, we 
can (arbitrarily) divided this effort into the following subtasks.

idl
kdes
kruntime
rpccp/rpcd
runtime
sys_idl 

We plan to check in the code cleanup changes to sys_idl, runtime, kruntime,
kdes, and rpccp within a few days. The rpcd directory has been cleaned
sufficiently to compile, as has the idl directory. No further work will 
occur on the rpcd directory, since it is scheduled to be replaced by the 
dced in 1.1. The rpccp directory, however, has been cleaned. The idl
directory has been cleaned sufficiently to compile with the new, cleaned
header files, etc. 

To the extent possible, code in platform specific directories (AT386,
HP800, RIOS, and SVR4) has been cleaned as well.

[6/20/94 public]
I believe that all of the Code cleanup work that will be done on RPC
has been completed.

The IDL compiler will probably not have code cleanup changes made to it.



CR Number                     : 9752
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : rpc/runtime
Short Description             : krbcn.c failed to compile
Reported Date                 : 1/17/94
Found in Baseline             : 1.1
Found Date                    : 1/17/94
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : rpc/runtime/krbcn.c
Sensitivity                   : public

[1/17/94 public]

The remaining many RIOS errors were caused by "rpc/runtime/krbcn.c"
failing to build, causing in turn the builds of libraries "libnck.a"
and "libkdes.a" to fail; since "libnck.a" is required for the build
of "libdce.a", the libdce library failed to build, resulting in the
many errors.

Here is an excerpt from the build.log:

xlc -c       -DNCK -DPROT_NCADG -DPROT_NCACN  -DAUTH_KRB -DNAF_IP -DDNS_CDS \
 -DDNSPI_V3 -DDNS_V3API    -Dunix -D_ALL_SOURCE -DNO_SIOCGIFADDR -D_BSD=44 \
 -D_NONSTD_TYPES -DDEBUG -D_ALL_SOURCE -DAIX32   -I. \
 -I/u1/devobj/sb/nb_rios/src/rpc/runtime \
 -I/project/dce/build/dce1.1-snap/src/rpc/runtime  -IRIOS \
 -I/u1/devobj/sb/nb_rios/src/rpc/runtime/RIOS \
 -I/project/dce/build/dce1.1-snap/src/rpc/runtime/RIOS \
 -I/u1/devobj/sb/nb_rios/export/rios/usr/include \
 -I/project/dce/build/dce1.1-snap/export/rios/usr/include \
 /project/dce/build/dce1.1-snap/src/rpc/runtime/krbcn.c
"/project/dce/build/dce1.1-snap/src/rpc/runtime/krbcn.c", line 1121.20: \
 1506-068 (S) Operation between types pointer to void and long unsigned \
 is not allowed.
*** Error code 1

[01/17/94 public]
Can't do arithmatic on viod pointers.
Change:
	    *last_auth_pos += REQ_length;

to
	    *last_auth_pos = (char *)last_auth_pos + REQ_length;



CR Number                     : 9741
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rtandidl
Short Description             : mgmt_stop_server_listening test fails with CN RPC
Reported Date                 : 1/14/94
Found in Baseline             : 1.1
Found Date                    : 1/14/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b2
Affected File(s)              : mgmt_stop_server_listening.c
Sensitivity                   : public

[1/14/94 public]

While running the RPC functional test 'rtandidl', there is a failure
in the test 'mgmt_stop_server_listening'.

The test calls:
	#1. rpc_mgmt_is_server_listening()
	#2. rpc_mgmt_stop_server_listening()
	#3. rpc_mgmt_is_server_listening()

and compares the status code returned by #3 against rpc_s_comm_failure.

CN rpc returns rpc_s_connection_closed.

This test should check the return code (as opposed to the status code)
to see if the server has stopped listening.

[01/14/94 public]
Commented out the code which compares against rpc_s_comm_error.



CR Number                     : 9702
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 9701
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : i18n
Short Description             : code set registry compiler
Reported Date                 : 1/7/94
Found in Baseline             : 1.1
Found Date                    : 1/7/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : csrcgram.y csrclex.l csrc.c csrc.h
Sensitivity                   : public

[1/7/94 public]
 RPC runtime I18N support requires the common way to recognize
code sets for code set compatibility evaluation.  So OSF decided to
create a code set registry.  'csrc' (code set registry compiler) will
produce a binary code set registry file from ASCII input.

[3/23/94 public]
  We decided csrc belongs to 'rpc' component.  The initial version of
the code was submitted to the tree already, but I am expecting to modify
the code when I finished functional tests, so I will keep this open.

[5/6/94 public]
  All of the necessary changes including csrc sams clean-up are done.
Submitted to 1.1 tree.

[5/11/94 public]

  Nightly build showed there was no problem with the previous submission.



CR Number                     : 9701
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : i18n
Short Description             : RPC runtime needs i18n enhancements
Reported Date                 : 1/7/94
Found in Baseline             : 1.1
Found Date                    : 1/7/94
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b13
Affected File(s)              : nslookup.c nsp.c nsutil.c rpcmem.h com.h cs_s_eval.c cs_s_reg.c cs_s_stub.c ns_s_attr.c nsp.h rpc.idl codesets.idl codesets.acf codesets_stub.h rpc.msg cs_s.h combind.c
Sensitivity                   : public

[1/7/94 public]
  One of 1.1 release items is I18N enhancements for RPC runtime.
DEC completed IDL compiler modification for 1.0.3 release, and this
is the other half of the work.

[7/20/94 public]
I believe the RPC i18n enhancements are functionally complete.

[8/1/94 public]
  One more thing to be done with this OT.  rpc_binding_copy() needs to
take care of code set information when the source binding handle contains
one.

[8/2/94 public]
  rpc_binding_copy() was modified to take care of code set i14y.  The fix
and new functional tests were submitted.



CR Number                     : 9695
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : Function ptrs returning ptrs broken
Reported Date                 : 1/6/94
Found in Baseline             : 1.0.3
Found Date                    : 1/6/94
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b23
Affected File(s)              : astp_com.c
Sensitivity                   : public

[1/6/94 public]
For the following parameter specified in an IDL file (function pointer
to an allocate routine that returns a void*).

    [in]  void *(*allocate)(unsigned32 size),

IDL generates the following in the header file, which is incorrect
(in two places, but the declaration of allocate as a void fcn instead of
void* is the real problem, not the fact that it thinks size is an out).

#ifdef IDL_PROTOTYPES
    /* [in] */ void (*allocate)(
#ifdef IDL_PROTOTYPES
    /* [out] */ unsigned32 size
#endif
),

[3/9/94 public]
What's the status on this bug?  Some attribute support routines are
being held up by this bug.

[3/10/94 public]

I'm about to head off on vacation for a week+ - I'll look into this
when I get back.

[4/13/95 public]

For people who don't have 1.1 here is the fix that can be applied to 1.03
idl compiler code as extracted from 1.1:

*** astp_com.c.old      Thu Apr 13 15:17:41 1995
--- astp_com.c  Thu Apr 13 15:20:06 1995
***************
*** 1525,1531 ****
                  ASTP_validate_forward_ref(current_type);
                  return_type = AST_type_node(dop->op_kind);
                  return_type->type_structure.function =
!                         AST_function_node(type_node_ptr,
                                             declarator_ptr->name,
                                             dop->op_info.routine_params);
                  break;
--- 1525,1531 ----
                  ASTP_validate_forward_ref(current_type);
                  return_type = AST_type_node(dop->op_kind);
                  return_type->type_structure.function =
!                         AST_function_node(current_type,
                                             declarator_ptr->name,
                                             dop->op_info.routine_params);
                  break;

The test.idl file:

[local] interface test
{
 void func([in] void  *(a)(int x));
}

Creates test.h with operation signature:


#ifndef nbase_v0_0_included
#include <dce/nbase.h>
#endif
extern void func(
#ifdef IDL_PROTOTYPES
    /* [in] */ idl_void_p_t a(  <---- void * is not lost
#ifdef IDL_PROTOTYPES
    /* [out] */ idl_long_int x
#endif
)
#endif
);



CR Number                     : 9689
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : stubbase.h
rpc_ss_ee_ctx_to_wire function prototype incorrect
Reported Date                 : 1/6/94
Found in Baseline             : 1.0.3
Found Date                    : 1/6/94
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : ./rpc/idl/lib/ctxeecli.c ./rpc/idl/lib/ctxeectx.c ./rpc/idl/lib/ctxeertl.h
Sensitivity                   : public

[1/6/94 public]
The rpc_ss_ee_ctx_to_wire function prototype in stubbase.h is incomplete.
In particular, the ctx_rundown parameter, which is a function pointer,
should itself have a function prototype.

[1/6/94 public]

I think that this probably belongs to the code cleanup effort. Since I'm
responsible for code cleanup for the RPC component, I've taken the liberty
of assigning myself as the responsible engineer.

My initial thought is to create a typedef for a ctx_rundown function, 
and set the parameter to have that type: e.g.

typedef void (*ctx_rundown_fn_p_t) _DCE_PROTOTYPE((void));

void rpc_ss_ee_ctx_to_wire  _DCE_PROTOTYPE_ ((
    rpc_ss_context_t        ,   /* [in] opaque pointer */
    ndr_context_handle      *,  /* [out] ndr_context_handle */
    handle_t                ,                /* binding handle */
    ctx_rundown_fn_p_t,  /* Pointer to context rundown routine */
    ndr_boolean             ,           /* TRUE for [in, out]parameters */
    volatile error_status_t *
));

[01/07/94 public]
Defining a ctx_rundown_fn_p_t is a good idea, but I think your typedef
is wrong and should be
    typedef void (*ctx_rundown_fn_p_t)(rpc_ss_context_t);

This is a bigger issue then just changing stubbagse.h == you will also
have to change idl/lib/{ctxeectx.c,ctxeertl.h} and possibly others --
anywhere there is a "context rundown routine" to use the new typedef.
I also note that while OSF own RPC runtime code-cleanup, this may be
thought of as IDL compiler support, and therefore not an OSF responsibility.

[1/7/94 public]

It had been my original intent to assign this CR to myself, but being a
rookie at using the OT system, I goofed and missed doing it.  We have
actually already fixed this in our local code stream (although not in the
more elegant way of defining a type, as suggested above).  Feel free to
reassign this to me if you'd like, and let me know if the simpler form of
the fix (not defining a new type) suffices.

[1/7/94 public]

Rich, your definition of the typedef is in fact correct. All in all, I
would cast my vote for including the typedef in stubbase.h. I'm assuming
that the simpler form of the fix is simply to define the function argument as 

    void (*ctx_rundown)(rpc_ss_context_t);

I don't believe that the use of a typedef combined with a full declaration
would cause any conflict (since typedefs are really only aliases for
existing types in C/C++, not new types). However, I think that the use of 
the typedef in a public header file can be useful for programmer
documentation purposes, as well as providing stricter checking of return
types and function arguments. So I would advocate using the typedef. 

So ... to sum up: I would like to enter the correct typedef into stubbase.h 
as part of code cleanup. And I will re-assign the bug to you.

[7/19/94 public]
So looking at the current 1.1 stubbase.h, I see that there is a
typedef for ctx_rundown_fn_p_t, and the prototype for rpc_ss_ee_ctx_to_wire()
uses this typedef.  Do Rico or Charlie believe there is more work
to be done here?  If so, please specify what that might be.
Otherwise I will close this defect.

[7/20/94 public]
The functions that Rich mentioned (idl/lib/{ctxeectx.c,ctxeertl.h}) as
well as other IDL code, needs to be checked as per his instructions. 
Since the code compiles and works, I would say that this isn't high
priority, but would be nice for completeness.

[7/28/94 public]
Used the ctx_rundown_fn_p_t typedef to fix up:
	rpc_ss_rundown_list_elt - typedef
	callee_context_entry_t - typedef
	rpc_ss_create_callee_context() - declaration
	rpc_ss_ee_ctx_to_wire() - declaration
Code submitted.



CR Number                     : 9646
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : a type with [transmit_as]
should not inherit all attributes from its base type
Reported Date                 : 12/23/93
Found in Baseline             : 1.0.3
Found Date                    : 12/23/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : astp_com.c
Sensitivity                   : public

[12/23/93 public]
Consider the following IDL declarations

typedef [ref]long *t683;
typedef [transmit_as(long)]t683 t683b;

In the above declarations, a type (t683) that is used as a presented type
is given a transmissible type attribute (in this case, [ref]).  The IDL
compiler should either ignore the attribute when processing t683b, or at
most issue a warning that the [ref] attribute on t683 is not meaningful.

What is currently does is propagate the [ref] attribute from t683 to t683b,
causing an IDL compiler error message that a [transmit_as] type can not
have additional type attributes.

IDL should not propagate the following attributes from a base presented
type (t683) to the type with [transmit_as] (t683b):
string, v1_string, unique, ref, ignore, v1_array, context_handle, ptr



CR Number                     : 9614
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime/dg
Short Description             : WAY callback failure with pkt_privacy
Reported Date                 : 12/14/93
Found in Baseline             : 1.0.3
Found Date                    : 12/14/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : rpc/runtime/dgexec.c
Sensitivity                   : public

[12/14/93 public]

While using pkt_privacy over DG protocol, after rpc_binding_reset(), WAY
callback fails with "vf mismatch: pkt x.x vs vf y.y" if there is a PDU body
in a request.

This can be easily reprduced by using perf #1 test, e.g.:

  client -v2 -p 1,2,6,server -r 1 1 ncadg_ip_udp:host 2 1 n n 100

This is caused by the request PDU body decrypted twice in runtime. Here is
the scenario.

Client:                         Server:
------------------------------------------------------------------------
Make RPC call with pkt_privacy.
(New ccall created.)
                                Receive a new request.
                                (New sscall created. No recv_ck called.)
                                Make WAY-AUTH callback.
Respond to WAY-AUTH callback.
                                (recv_ck called. PDU body decrypted.)
                                Send the response.
Receive the response.
Call rpc_binding_reset().
Make RPC call with pkt_privacy.
(Cached ccall used.)
                                Receive the next request.
                                (Cached sscall used.
                                 recv_ck called. PDU body decrypted.)
                                Make WAY callback.
                                (because of missing server boottime.)
Respond to WAY callback.
				(recv_ck called. PDU body decrypted again.
				 recv_ck fails.)

[5/27/94 public]

The fix has been submitted as a part of MBF code drop.



CR Number                     : 9601
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : app_gd, app_ref
Short Description             : Doc enhancements for IDL V1.1
Reported Date                 : 12/8/93
Found in Baseline             : 1.0.2
Found Date                    : 12/8/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : app_gd/rpc/acf.gpsml
                                             app_gd/rpc/idl.gpsml
                                             app_gd/rpc/topics.gpsml
                                             app_ref/man3rpc/rpc_intro.3rpc
Sensitivity                   : public

[12/8/93 public]
The Application Development Guide and the Application Development Reference have been updated to reflect IDL compiler enhancements for Version 1.1. The following existing chapters have been affected: 8_err_hndlng.gpsml, 9_idl.gpsml, 10_acf.gpsml, 12_bnf_syntax.gpsml, idl.1rpc (ref), rpc_status_codes.7rpc (ref), intro.3rpc (ref). Two new chapters have been created that are currently labelled: 10a_encode.gpsml and 10b_ichar_support.gpsml. The new chapters describe the IDL Encoding Services and Support for International Characters respectively. These chapters might have to be renumbered so that they conform to the current numbering scheme in the Application Development Guide.

[3/24/94 public]

Assigned this CR to Ron Johnson (DEC DCE 1.1 writer).

[09/22/94 public]
Closed bug.  Note that the up-to-date list of files changed
per this CR appear in the Affected Files field above.



CR Number                     : 9577
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : The number of concurrent calls over a single rpc binding is limited
Reported Date                 : 12/6/93
Found in Baseline             : 1.0.2
Found Date                    : 12/6/93
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : rpc/runtime/com.h
Sensitivity                   : public

[12/6/93 public]

This is reopening of CR5163, which was originally reported by Transarc and
was cannelled.

The number of concurrent calls over a single DG rpc binding is limited by
the "calls_in_progress" field in the rpc_binding_rep_t structure, whose
type is "signed8". RPC_BINDING_CALL_{START,END}::com.h macros are used to
increment/decrement this field and have the following assertion:

   assert((binding_rep_p_t)->calls_in_progress > 0);

Therefore, if the number of concurrent calls exceed 127, RPC runtime
coredumps (if built with -DDEBUG) or serialization of calls may fail
quietly (if built with -UDEBUG), which leads to a potential rpc binding
corruption. In the case of CN protocol, this field is only used to
serialize the call to rpc_ep_resolve_binding(). Thus, it rarely happens.
(But it can still happen!)

CR5163 was cancelled because 128 was considered to be high enough. It turns
out that it is not. Transarc's Encina PPC Gateway can exceed this number.
This limitation imposed by the *implementation* is not documented and there
is no real reason why it needs to be limited. There is a great chance that
we will see an RPC client having more than 127 threads on a large system.

The fix is easy. We just need to change "signed8" to "signed32", which will
be high enough for now. (Or make it unsigned32 and change the assertion to
calls_in_progress != 0 . :-) This change is local to the client RPC
runtime.) The assertions causing coredumps need to be examined as a part of
DCE 1.1 serviceability/code cleanup work.

[12/6/93 public]

Make it signed32; it will be easier to detect if the counter goes negative
due to a software bug that way..

[7/15/94 public]

Submitted.



CR Number                     : 9553
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : IDL compiler crashes given an
incomplete non-encapsulated union type
Reported Date                 : 11/24/93
Found in Baseline             : 1.0.3
Found Date                    : 11/24/93
Severity                      : D
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : astp_com.c
Sensitivity                   : public

[11/24/93 public]
The IDL compiler crashes given this declaration:
	typedef [switch_type(short)] union t806 t805unused2;
if 'union t806' has not been previously declared.



CR Number                     : 9551
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : dg
Short Description             : DG fault PDU not decrypted in pkt_privacy
Reported Date                 : 11/23/93
Found in Baseline             : 1.0.3
Found Date                    : 11/23/93
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : rpc/runtime/dg.c
Sensitivity                   : public

[11/23/93 public]

Like CR8643, DG fault PDU's body is not decrypted in the client side when
the protection level pkt_privacy is used.

[5/27/94 public]

The fix been submitted as a part of MBF code drop.



CR Number                     : 9550
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 9962,10677
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : cn
Short Description             : CN authenticated RPC does not return the correct fault status
Reported Date                 : 11/23/93
Found in Baseline             : 1.0.3
Found Date                    : 11/23/93
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : cnsclsm.c
Sensitivity                   : public

[11/23/93 public]

The second part of CR8068 fixes broke the CN fault PDU.
abort_resp_action_rtn()::cnsclsm.c sets call_rep->cn_call_status to
rpc_s_call_orphaned if there is more than one iovector elements, which is
always true for the authenticated RPC. Thus, CN fault PDU's status field
becomes non-zero and the exception raised in the server manager routine
won't be passed back to the client.

By running perf #9 test with CN authenticated RPC, you will see "*** WRONG
exception raised" error. Here is the client's trace:

[time: 000010] [thread: 7aff3008.00000001] CN: call_rep->400aaa90 fault packet received st = 16c9a05e

0x16c9a05e is rpc_s_call_orphaned.

[2/10/94 public]

Here is what we have in our product code to fix this.

In abort_resp_send_fault_action_rtn()::cnsclsm.c :

{
    unsigned32              status;
#ifndef HPDCE_FIX_OT9550
    rpc_cn_call_rep_p_t     call_rep;
    unsigned32              saved_status;
#endif /* HPDCE_FIX_OT9550 */

    RPC_CN_DBG_RTN_PRINTF(SERVER abort_resp_send_fault_action_rtn);

#ifndef HPDCE_FIX_OT9550
    /*
     * Ugly fix!
     */
    call_rep = (rpc_cn_call_rep_p_t) spc_struct;
    saved_status = call_rep->cn_call_status;
#endif /* HPDCE_FIX_OT9550 */

    /*
     * Abort the send; we don't care about its returned
     * status.
     */
    status = abort_resp_action_rtn (spc_struct, event_param);

#ifndef HPDCE_FIX_OT9550
    /*
     * Ugly fix!
     * abort_resp_action_rtn() will set cn_call_status to
     * rpc_s_call_orphaned by thinking that the call was orphaned, which
     * is not true in this case.
     */
    if (saved_status != call_rep->cn_call_status)
    {
        call_rep->cn_call_status = saved_status;
    }
#endif /* HPDCE_FIX_OT9550 */

    /*
     * Send the fault.
     */
    status = send_call_fault_action_rtn (spc_struct, event_param);

    return (status);
}

[02/16/94 public]
SNI filed another way to fix this in CR 9962 (which has been dup'd):

From ot 9962:----------------------------------------------

When application would use authenticated CN RPC and the call faults in the
server manager routine, the CN runtime incorrectly returns the fault code
rpc_s_call_orphaned (0x16c9a05e). It looses the correct falult status that
was returned to it from the IDL library code.

To reproduce the error you can run the test/rpc/runtime/perf test. Run the
server and client as show below (the principal 'perf' has to be created and
its a/c and key should be created with password -dce-):

./server -p1,perf 1 ncacn_ip_tcp
./client -p1,2,5,perf 9 'ncacn_ip_tcp:140.231.30.192[2001]'

The test fails with the message that it got wrong exception. It was expecting
IntZeroDivide (0x1c000001) fault.

The action routine abort_resp_action_rtn() (file rpc/runtime/cnsclsm.c) that is
called from abort_resp_send_fault_action_rtn() should count in the iovec for 
the authentication trailer as shown below in #ifdef SNI_SVR4. This fix is a
generic fix and the #ifdef should be taken off:

     /*
      * If there are buffered iovector elements, deallocate them.
      *
      * Note that the comparison below is not strictly correct.
      * Even if there is only a single iovector element, there
      * may be copied stub data after the header.  It's ok to
      * ignore them because the only way in which the first
      * iovector element would be reused is if we use it to send
      * a fault.  That operation would adjust the pointers
      * anyway to point to only the fault data.
      */
+#ifdef SNI_SVR4
+    if (call_rep->sec == NULL && RPC_CN_CREP_IOVLEN (call_rep) > 1 ||
+        RPC_CN_CREP_IOVLEN (call_rep) > 2)
+#else
     if (RPC_CN_CREP_IOVLEN (call_rep) > 1)
+#endif /* SNI_SVR4 */
     {
         rpc__cn_dealloc_buffered_data (call_rep);
 
         /*
          * This will keep the call_end_action_rtn from attempting to
          * send the remaining iov which at this point is only an auth_tlr
          * if this was an authenticated call.  We are calling this an
          * orphaned call which technically, it is, ie the connection is
          * gone and along with it the association.
          */
         call_rep->cn_call_status = rpc_s_call_orphaned ;

end-of-included-text----------------------------------------

[6/13/94 public]
The SNI fix does not take care of this problem, however the HP
fix fixes the perf test failure and the idl/pipfault test failure
(See OT #10677).

I will submit the HP fix soon.

[6/20/94 public]
Submitted a modified form of the above HP fix.
Commented out the call to abort_resp_action_rtn() since everything
it does is also done elsewhere in this send_fault case.

There are good discussions about this in OT #9962, and 10677.
I don't believe that the sni fix is correct, since we are trying
to prevent the transmission of the auth data by setting the
call status to orphaned, and changing the if condition will
prevent that fix (for 8068) from working.



CR Number                     : 9549
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : auth
Short Description             : rpc_binding_set_auth_info() is not AES/DC RPC compliant
Reported Date                 : 11/23/93
Found in Baseline             : 1.0.3
Found Date                    : 11/23/93
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b15
Affected File(s)              : rpc/runtime/krbclt.c
Sensitivity                   : public

[11/23/93 public]

rpc_binding_set_auth_info() is broken because it is not upgrading
protect_level.

Here is what AES/DC RPC Volume says:

P. 3-23, rpc_binding_inq_auth_client()

Description

The rpc_binding_inq_auth_client() routine returns authentication,
authorization, and privilege information referenced by the client
                                         ~~~~~~~~~~~~~~~~~~~~~~~~
binding handle, binding. ...
~~~~~~~~~~~~~~~~~~~~~~~

P. 3-25, rpc_binding_inq_auth_info()

Description

The rpc_binding_inq_auth_info() routine returns authentication,
authorization, and protection level information referenced by the
server binding handle, binding. Client applications use this
routine to discover whether the protection level they have
                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
requested is supported by the RPC runtime implementation.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
... The value of protect_level returned by
rpc_binding_inq_auth_info() may be higher than the level
                                   ~~~~~~~~~~~~~~~~~~~~~
requested in the previous call to rpc_binding_set_auth_info(). ...
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

P. 3-33, rpc_binding_set_auth_info()

Description

... Note that the value of protect_level actually set for binding
depends on the protection levels supported by the implementation.
The value set may be higher than the level requested. When an
application requests a protection level that is not supported,
the RPC runtime attempts to upgrade the protection level to the
next highest supported level. When it succeeds, the binding will
be given a higher protection level than the one requested. ...
Applications can call the routine rpc_binding_inq_auth_info() to
discover the protection level actually set. ...



With the current CN implematation, the upgrade happens in
rpc__krb_cn_pre_send()/rpc__krb_cn_recv_check() and nobody else knows about
it. Thus, both rpc_binding_inq_auth_client() and
rpc_binding_inq_auth_info() lie. In the DG side, the client sends the right
protection level on the wire, thus rpc_binding_inq_auth_client() is ok, but
rpc_binding_inq_auth_info() is not.

[8/12/94]
modify rpc__krb_bnd_set_auth() [krbclt.c] to setup the
correct protect level.

The following code will be introduced to set the level.


  switch(binding_rep->protocol_id)
        {
        case RPC_C_PROTOCOL_ID_NCACN:
                if (level == rpc_c_authn_level_call)
                    level = rpc_c_authn_level_pkt;
                break;

        case RPC_C_PROTOCOL_ID_NCADG:
                if ((level >= rpc_c_protect_level_connect) &&
                    (level <= rpc_c_protect_level_call))
                    level = rpc_c_protect_level_pkt;
                break;

        default:
                break;
	}

[8/15/94]
fixed as explained above.



CR Number                     : 9533
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_ref
Short Description             : rpc_binding_set_auth_info.3rpc has bad prototype for server_princ_name arg
Reported Date                 : 11/22/93
Found in Baseline             : 1.0.3
Found Date                    : 11/22/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : app_ref/man3rpc/rpc_binding_set_auth_info.3rpc
Sensitivity                   : public

[11/22/93 public]

rpc_binding_set_auth_info.3rpc has bad prototype for the server_princ_name
arg.  It says 2 start.  Should be just one.  (There's a comment in there
that asks if this is correct.)

[2/1/94 public]

Made this easy change to the man page and marked
the CR verified. (Note: the current RPC AES shows the
correct synopsis).

[2/15/94]

Forgot to mark it verified and add "fixed in" field.

[09/19/94 public]
Closed bug.



CR Number                     : 9515
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc/runtime/comsoc_bsd.c
Short Description             : compiler complains about
incompatible operands
Reported Date                 : 11/18/93
Found in Baseline             : 1.0.3
Found Date                    : 11/18/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : comsoc_bsd.c
Sensitivity                   : public

[11/18/93 public]

 There are a few system calls for which our strict ANSI compiler
 complains.  As coded, the comsoc_bsd.c calls do not conform to the
 prototypes supplied with osf1.2

The specific places are:

rpc__socket_bind(): three calls to bind(). The second parameter of bind()
expects a type of (struct sockaddr *).

rpc__socket_inq_endpoint(): call to getsockname(). The second parameter of
getsockname() expects a type of (struct sockaddr *).

rpc__socket_set_broadcast(): call to setsockopt(). The 4th parameter
expects a type of (void *).

rpc__socket_set_bufs(): Two calls to setsockopt() and two calls to
getsockopt(). The 4th parameter of the two calls expects a type of (void
*), and the 5th parameter of the two calls expects a type of (int *).

rpc__socket_getpeername(): call to getpeername(). The 2nd parameter exepcts
a type of (struct sockaddr *).

rpc__socket_get_if_id(): call to getsockopt(). The 4th parameter expects a
type of (void *).

rpc__socket_set_keepalive(): call to setsockopt(). The 4th parameter
expects a type of (void *).

[05/04/94 public]
Most of these were fixed in code cleanup.

Our strict ANSI compiler (gcc -ansi -Wall -pedantic) doesn't complain
about setsockopt 4th argument not being cast to void *.

Closed.



CR Number                     : 9508
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc/runtime/dgsct.c
Short Description             : a functions requires explicit
return values
Reported Date                 : 11/18/93
Found in Baseline             : 1.0.3
Found Date                    : 11/18/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : dgsct.c
Sensitivity                   : public

[11/18/93 public]

 In the rpc__dg_sct_make_way_binding() function, a return statement
 is coded without explicitly supplying a value.

The licensee reported against 1.0.2 code, 1.0.3 has the same problem.

Suggested fix: return NULL.

[05/04/94 public]
Fixing this today.

[05/04/94 public]
Submitted



CR Number                     : 9507
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc/runtime.cnassoc.c
Short Description             : return value not explicit
Reported Date                 : 11/18/93
Found in Baseline             : 1.0.3
Found Date                    : 11/18/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : cnassoc.c
Sensitivity                   : public

[11/18/93 public]

 In the rpc__cn_assoc_grp_lkup_by_id() routine, there is a return
 statement (in the debug clause) that does not return an explicit value.

The licensee reported against 1.0.2 code, but the same problem exists in
1.0.3 code. This needs to be cleared up.

Suggested fix:

     + #if defined(hitm)
     +         RPC_CN_LOCAL_ID_CLEAR (ret_grp_id);
     +         return (ret_grp_id);
     + #else
               return;
     + #endif

[05/04/94 public]
So minor a nit, I'm going to fix it today.
Note: We usually don't fix DEBUG code.

[05/04/94 public]
Submitted.



CR Number                     : 9497
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : UUID_VERIFY_INIT which can issue return without return value is called form some functions
Reported Date                 : 11/16/93
Found in Baseline             : 1.0.3
Found Date                    : 11/16/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : src/rpc/runtime/uuid.c
Sensitivity                   : public

[11/16/93 public]

The macro UUID_VERIFY_INIT, which is instantiated within functions and 
procedures includes a return statement which does not include a return
value. When instantiated form a procedure, this is exactly correct. On
the otherhand when instantiated within a function, it is possible for
UUID_VERIFY_INIT to cause the function to return without an explicitly
specified or type appropraite to the functions return type.

One possible solution:

Create a second version of the macro to be used by the functions,
which returns a value. For example:

 + #define UUID_VERIFY_INIT_FUNCTION(fail_value)   \
 +     if (! uuid_init_done)                       \
 +     {                                           \
 +         init (status);                          \
 +         if (*status != uuid_s_ok)               \
 +         {                                       \
 +             return(fail_value);                 \
 +         }                                       \
 +     }
 + #endif

replace the instantiations of UUID_VERIFY_INIT in

	uuid_equal:	UUID_VERIFY_INIT_FUNCTION(false);
	uuid_is_nil:	UUID_VERIFY_INIT_FUNCTION(false);
	uuid_compare:	UUID_VERIFY_INIT_FUNCTION(-1);
	uuid_hash:	UUID_VERIFY_INIT_FUNCTION(0);

[05/04/94 public]
This was fixed in code-cleanup.
Closed.



CR Number                     : 9496
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rpc__naf_is_connect_closed should return a boolean
Reported Date                 : 11/16/93
Found in Baseline             : 1.0.3
Found Date                    : 11/16/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : src/rpc/runtime/comnaf.c
Sensitivity                   : public

[11/16/93 public]

Description:

In rpc/runtime/comnaf.c, the function rpc__naf_is_connect_closed()
is defined to return a boolean. However, there is a failure case
in which the function executes a return without specifying a value.

Proposed Solution:

{   
    rpc_naf_id_t            naf_id;

    /*
     * dispatch to the appropriate NAF service
     */
    rpc__naf_desc_inq_naf_id (desc, &naf_id, status);
!   if (*status != rpc_s_ok) return FALSE;
    return ((*rpc_g_naf_id[naf_id].epv->naf_is_connect_closed)
            (desc, status));
}

[05/04/94 public]
This was fixed in code cleanup.
It return TRUE because if it has an invalid descriptor
the connection must be closed! :-)
Defect Closed.



CR Number                     : 9485
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 7240
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_gd
Short Description             : change L&S to e.g. LandS
Reported Date                 : 11/12/93
Found in Baseline             : 1.0.3
Found Date                    : 11/12/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : /app_gd/rpc/figures/6_nsi_usage_08.ps
Sensitivity                   : public

[11/12/93 public]

The file 6_nsi_usage_08.ps needs to have the same changes
made to it as those made to the file 6_nsi_usage_07.ps; i.e.,
change "L&S" to "LandS" in 4 places. See CR7240 for more
details.

[11/12/93 public]
Demoted to priority 2 "next appropriate shceduled opportunity"
i.e., 1.1.

[3/24/94 public]

Reassigned this CR to Ron Johnson (DEC's DCE 1.1 writer) from
Diana Goldfarb.

[08/16/94 public]
Changed status from "closed" to "verified".  This CR fix has been
made by the writer assigned, but the OSF doc "bugmeister"
(that's me!) still has to review the changes in the build
output before the CR can be officially declared "closed".

[09/29/94 public]
Closed bug.



CR Number                     : 9481
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : test
Short Description             : move idl_frontend tests to
nosupport
Reported Date                 : 11/12/93
Found in Baseline             : 1.0.3
Found Date                    : 11/12/93
Severity                      : E
Priority                      : 4
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : test/rpc/idl_frontend/*
Sensitivity                   : public

[11/12/93 public]
The new IDL provided as part of 1.0.3 makes the idl_frontend tests
obsolete.  They are, therefore, moved to the nosupport directory.

[11/12/93 public]
Re-assigned to Tom.  This task belongs to the component owner, not the
Rats.

[11/12/93 public]
Eh?  These are RCS files which need to be copied to the no support tree,
then defuncted from the test source tree.

This is a job only a RAT can do.  Of course we *could* go the long
way around and bcreate, bco, copy, bci -defunct, bsubmit, but this
isn't going to happen.....

Talk to Damon about "b-move", and when I have that available, I'll
do it myself.

Reassigning this to Marcy, who should work with Prasad on what needs to be
done.

[04/01/94 public]
I believe Annie has moved these files.

I am assinging this defect to her so she can closed it.


[ annie ]
See cr10161



CR Number                     : 9480
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : Application Dev Ref
Short Description             : rpc_s_rpcd_comm_failure not documented in rpc_ep_resolve_binding() man page.
Reported Date                 : 11/12/93
Found in Baseline             : 1.0.2
Found Date                    : 11/12/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : app_ref/man3rpc/rpc_ep_resolve_binding.3rpc
Sensitivity                   : public

[11/12/93 public]

rpc_ep_resolve_binding() can return the status rpc_s_rpcd_comm_failure.
This is not documented in the man page.

[11/12/93 public]

Assigned this CR to Steve Lewontin.

[3/24/94 public]

Reassigned this CR to John Shirley from Steve Lewontin.

[08/09/94 public]
Reassigned to myself.

[08/23/94 public]
Changed priority to "2".

[08/25/94 public]
Fixed.  Verified by Tom Jordahl.

[09/22/94 public]
Closed bug.



CR Number                     : 9415
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : IDL compiler crashes on
pointer to type synonym
Reported Date                 : 11/9/93
Found in Baseline             : 1.0.3
Found Date                    : 11/9/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : propagat.c
Sensitivity                   : public

[11/9/93 public]
The bug happens when a type is defined as a synonym for a structure
type by tag name AND is pointed-at.



CR Number                     : 9405
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : nsi
Short Description             : incorrect return status check in rpc__bindlkup_obj_uuid_any()
Reported Date                 : 11/8/93
Found in Baseline             : 1.0.3
Found Date                    : 11/8/93
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b13
Affected File(s)              : runtime/nslookup.c
Sensitivity                   : public

[11/8/93 public]

Inspection of the code in nslookup.c revealed an incorrect check for the 
return value from uuid_create_nil. The pointer "status" should be 
dereferenced before the check. It is believed that this does not cause a 
more serious problem because of the coincidence uuid_s_ok == rpc_s_ok == 0.

/project/dce/build/dce1.0.3/src/rpc/runtime/nslookup.c" [Read only] line 2635

        case rpc_s_no_more_members:
            uuid_create_nil (&(lookup_context->obj_for_binding), status);

            if (status != uuid_s_ok)
            {
                goto CLEANUP;
            }

            *status = rpc_s_ok;

            break;

[7/28/94 public]
	actually, there is no need to check the status 
	after the uuid_create_nil(). Break out of 'switch' 
	after uuid_create_nil().
	Also did some cleanup of the file.



CR Number                     : 9391
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : infinite loop when stub tries
to unmarshall data that has not been sent
Reported Date                 : 11/8/93
Found in Baseline             : 1.0.3
Found Date                    : 11/8/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : ndrui.h sscmaset.c rpcexc.h
Sensitivity                   : public

[11/8/93 public]

This condition can only occur if the client and server are using stubs that
have been generated from inconsistent IDL files. However, in this case, if
the receiver is expecting more data than the server sent, it will sit in an
infinite loop looking for the rest of the data. The required fix is an
additional check on the results of rpc_call_receive.



CR Number                     : 9356
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : [fault_status] not meaningful
with IDL Encoding Services
Reported Date                 : 11/4/93
Found in Baseline             : 1.0.3
Found Date                    : 11/4/93
Severity                      : E
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : checker.c, nidlmsg.m, nidlmsg.h
Sensitivity                   : public

[11/4/93 public]
Use of IDL Encoding Services can never result in a [fault_status] error
code being generated. The IDL compiler should warn the user that

[fault_status] is inappropriate on a pickling operation.



CR Number                     : 9355
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : [comm_status] on operation
with [encode,decode] is flagged as error
Reported Date                 : 11/4/93
Found in Baseline             : 1.0.3
Found Date                    : 11/4/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : checker.c
Sensitivity                   : public

[11/4/93 public]
If [comm_status] is specified for an operation on which [encode,decode]
has been specified, the IDL compiler incorrectly reports an error that
all parameters should be [i,out].



CR Number                     : 9330
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime/common
Short Description             : Potential misuse of the pointer
Reported Date                 : 11/3/93
Found in Baseline             : 1.0.3
Found Date                    : 11/3/93
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b17
Affected File(s)              : rpc/runtime/comif.c
Sensitivity                   : public

[11/3/93 public]

In unregister_if_entry()::comif.c line# ~908:

            /*
             * remove this entry from the list for this interface
             */
            RPC_LIST_REMOVE (if_entry->type_info_list, type_info);

            /*
             * save this entry and get the next one on the list
             */
            current_type_info = type_info;
            
            RPC_LIST_NEXT (type_info, type_info, rpc_if_type_info_p_t);

RPC_LIST_NEXT() works because RPC_LIST_REMOVE() does not destroy
type_info->next pointer. However, this is a bad coding practice.
Instead, RPC_LIST_FIRST() should be used:

            RPC_LIST_FIRST
                (if_entry->type_info_list, type_info, rpc_if_type_info_p_t);

[8/25/94 public]

Submitted.



CR Number                     : 9328
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime/cn
Short Description             : rpc__cn_assoc_sec_free() uses the security context after it gets free'ed.
Reported Date                 : 11/3/93
Found in Baseline             : 1.0.3
Found Date                    : 11/3/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b13
Affected File(s)              : rpc/runtime/cnassoc.c
Sensitivity                   : public

[11/3/93 public]

In rpc__cn_assoc_sec_free()::cnassoc.c, *sec is used after it gets free'ed:

    /*
     * Free the security context element.
     */
    rpc__list_element_free (&rpc_g_cn_sec_lookaside_list,
                            (pointer_t) (*sec));

    /*
     * Remove the reference to the auth information structure.
     */
    RPC_CN_AUTH_RELEASE_REFERENCE ((rpc_auth_info_p_t *) &(*sec)->sec_info);

The above calling order should be reversed.

fixed as suggested.



CR Number                     : 9325
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : RPC functional test need cleanup
Reported Date                 : 11/2/93
Found in Baseline             : 1.0.3
Found Date                    : 11/2/93
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : ./test/rpc/rtandidl/Makefile
./test/rpc/rtandidl/README
./test/rpc/rtandidl/control/Makefile
./test/rpc/rtandidl/control/do_rpc_test.sh
./test/rpc/runtime/perf/Makefile
./test/rpc/runtime/v2test_lib/Makefile
Sensitivity                   : public

[11/2/93 public]

The RPC functional tests need a little cleanup:
	- Install README files
	- Install shell scripts which run the tests

[11/02/93 public]
Fixed up the above.
Closed.



CR Number                     : 9310
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_ref
Short Description             : rpc_binding_inq_auth_client should say that 'privs' arg may be NULL
Reported Date                 : 11/1/93
Found in Baseline             : 1.0.3
Found Date                    : 11/1/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : app_ref/man3rpc/rpc_binding_inq_auth_client.3rpc
Sensitivity                   : public

[11/1/93 public]
It is OK for the "rpc_authz_handle_t *privs" arg to NULL in
rpc_binding_inq_auth_client() (3rpc).  The refpage should say this.
(It correctly says this about the other args that can ne NULL.)

[11/3/93 public]

Assigned bug to S. Lewontin but changed "fixby" from
1.0.3 to 1.1 per doc group policy to defer bugs
filed after 1.0.3 soft freeze date.

[3/24/94 public]

Reassigned CR to John Shirley from Steve Lewontin.

[08/09/94 public]
Reassigned to myself.

[08/23/94 public]
Changed priority to "2" and severity to "C".

[08/25/94 public]
Made the requested change.  Verified by John Bowe.

[09/22/94 public]
Closed bug.



CR Number                     : 9272
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Manager is the one who rejects invalid security from client, not runtime
Reported Date                 : 10/27/93
Found in Baseline             : 1.0.3
Found Date                    : 10/27/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : app_gd/security/1_overv.gpsml app_gd/rpc/rpc_and_dce.gpsml app_ref/man3rpc/rpc_binding_set_auth_info.3rpc
Sensitivity                   : public

[10/27/93 public]

This is a bug (I guess) in the RPC docs.
Please contact the parties who are listed in the mail conversation below.

------------------------------------------------------

From davel@osf.org Mon Oct 25 15:08:43 1993
To: hathaway, tom
Subject: This needs to be a P1 doc bug
Date: Mon, 25 Oct 93 15:08:24 EDT
From: "David M. Lounsbury  +1 617 621 8791   davel@osf.org" <davel@osf.org>
Status: RO


------- Forwarded Message

>From dmackey Mon Oct 25 13:17:02 1993
Received: by pmin2.osf.org (5.65/4.7) id AA03587; Mon, 25 Oct 93 13:17:00 -0400
Date: Mon, 25 Oct 93 13:17:00 -0400
From: dmackey
Message-Id: <9310251717.AA03587@pmin2.osf.org>
To: davel
Subject: [walt: RPC auth followup (fwd)]

Date: Mon, 25 Oct 93 11:53:49 -0400
From: walt
To: dmackey, rsalz, jec
Subject: RPC auth followup (fwd)

>From walt Mon Oct 25 10:21:49 1993
Date: Mon, 25 Oct 93 10:20:39 -0400
From: walt
To: pato, burati
Subject: RPC authn question

If a server does an
rpc_server_register_auth_info(...,rpc_c_authn_dce_secret,...),
and a client does NOT do any rpc_binding_set_auth_info() (say, the
client might not even have done a dce_login), then what happens when the
client does an RPC to the server?  Does the request get rejected in the
runtime, or does the server manager wake up?

All existing documentation (App Dev Gd, App Dev Ref, RPC AES, Ed
courses, very ancient rememberances from DCE pre-1.0 days, etc.) says
the former happens, but some code experimentation (as well as some
logical argumentation) says the latter happens, so what is the design
intent?  And why?

- - Walt


>From burati@apollo.hp.com Mon Oct 25 11:36:13 1993
From: burati@apollo.hp.com
Date: Mon, 25 Oct 93 11:25:08 EDT
Subject: Re: RPC authn question
To: walt@osf.org
Cc: pato@apollo.hp.com, sommerfeld@apollo.hp.com
In-Reply-To: walt@osf.org, Mon, 25 Oct 93 10:25:42 -0400

> If a server does an
> rpc_server_register_auth_info(...,rpc_c_authn_dce_secret,...),
> and a client does NOT do any rpc_binding_set_auth_info() (say, the
> client might not even have done a dce_login), then what happens when the
> client does an RPC to the server?  Does the request get rejected in the
> runtime, or does the server manager wake up?

The manager wakes up, and it is up to it, to decide what to do based
on what the client did.  If it was rejected in the runtime, then an
unauthenticated call would never get to authenticated servers (ie: secd
and cdsd) and there would be no need for the "unauthenticated" ACL
entry type (that's not the reason itself, but it does show one argument
for the design).
 
..Mike
- -------


>From pato@apollo.hp.com Mon Oct 25 11:51:28 1993
Date: Mon, 25 Oct 93 11:35:26 -0400
X-Sender: pato@pop-e5.ch.apollo.hp.com
Mime-Version: 1.0
Content-Type: text/plain; charset="us-ascii"
To: burati@apollo.hp.com, walt@osf.org
From: pato@apollo.hp.com (Joseph N. Pato)
Subject: Re: RPC authn question
Cc: sommerfeld@apollo.hp.com

Mike is right.  In the original design, we had allowed the server to assert
a "minimum" security level, and the runtime would not invoke the manager
functions unless the security attributes exceeded the minimum.  This was
dropped eventually due to complaints from the RPC folks (primarily steve
miller of DEC I believe.  Their argument was that you could accomplish this
in the manager functions, so why add it to the basic suite of RPC stuff.)

- - joe

At 11:25 10/25/93 -0400, burati@apollo.hp.com wrote:
>> If a server does an
>> rpc_server_register_auth_info(...,rpc_c_authn_dce_secret,...),
>> and a client does NOT do any rpc_binding_set_auth_info() (say, the
>> client might not even have done a dce_login), then what happens when the
>> client does an RPC to the server?  Does the request get rejected in the
>> runtime, or does the server manager wake up?
>
>The manager wakes up, and it is up to it, to decide what to do based
>on what the client did.  If it was rejected in the runtime, then an
>unauthenticated call would never get to authenticated servers (ie: secd
>and cdsd) and there would be no need for the "unauthenticated" ACL
>entry type (that's not the reason itself, but it does show one argument
>for the design).
> 
>..Mike
>-------




>From walt Mon Oct 25 11:53:11 1993
Date: Mon, 25 Oct 93 11:36:11 -0400
From: walt
To: burati@apollo.hp.com
Cc: pato@apollo.hp.com, sommerfeld@apollo.hp.com
In-Reply-To: burati@apollo.hp.com's message of Mon, 25 Oct 93 11:25:08 EDT
Subject: RPC authn question

> The manager wakes up, and it is up to it, to decide what to do based
> on what the client did.

Like I said, all this make eminently good sense when one thinks about
it, it's just too bad that "nobody" knows it (in the sense of all
documentation being written incorrectly and not reviewed well enough)
...

BTW, I assume there are *some* circumstances where the RPC gets rejected
by the runtime, such as when the server registers DES and the client
sends RSA ...

- - Walt





------- End of Forwarded Message

[11/12/93 Public]

writer is already assigned to the bug, but I formally assigned it to ensure
it is tracked properly.

[11/12/93 Public]

The solution for this problem will be to provide a
clarifying note for the 1.0.3 release notes, and then really deal
with this in the 1.1 docs., as part of a deep housecleaning of the
security documentation.  The clarifying note text is as follows:
-------------------------- cut here -----------------------------
The \*LDCE Application Development Guide\*O and \*LDCE Application
Development Reference\*O may be misleading about
what happens when an unauthenticated client calls a server that has
specified authentication.  In such a case, the RPC runtime will not
perform any authentication, and \*Ethe call will reach the application
manager code\*O.  It is up to the manager to decide how to deal with
the unauthenticated call.  
.P
Typically, servers and clients establish authentication as follows:
.ML
.LI
The server specifies an authentication service for a principal
identity under which it runs by calling
\*Lrpc_server_register_auth_info(\|)\*O.  The authentication service
is specified by the \*Vauthn_svc\*O parameter of this call.
Currently, servers may specify either DCE secret key authentication
(by supplying either \*Lrpc_c_authn_dce_secret\*O or
\*Lrpc_c_authn_default\*O) or no authentication (by supplying
\*Lrpc_c_authn_none\*O).  The specified authentication service will be
used \*Eif it is also requested by the client\*O.  
.LI
The client sets authentication for a binding handle by calling
\*Lrpc_binding_set_auth_info(\|)\*O.  The choices are also currently
either DCE secret key or no authentication.  Client calls made on the 
binding handle attempt to use the specified authentication service.
.LI
The server manager code calls \*Lrpc_binding_inq_auth_client(\|)\*O to
extract any auth information from the client binding for the call.
.LE
.P
Whether the call actually wakes up in the server manager code or is
rejected by the runtime depends on following conditions:
.ML
.LI
If the client specified no authentication, then none is attempted by
the RPC runtime.  The call wakes up in the manager code whether the
server specified authentication or not.  This permits both
authenticated and unauthenticated clients to call authenticated
servers.  When the manager receives an unauthenticated call, it needs
to make a decision about how to proceed.
.LI
If the client specified DCE secret key authentication and the server
specified no authentication, then the runtime will fail the call, and
it will never reach the manager routine.
.LI
If both client and server specified DCE secret key authentication,
then authentication will be carried out by the RPC runtime
transparently.  Whether the call reaches the server manager code or is
rejected by the runtime depends on whether the authentication
succeeded.
.LE
.P
Although the RPC runtime is responsible any authentication that is
carried out, the fact that the runtime will always permit
unauthenticated clients to reach the manager code means that a manager
access function typically does need to make an authentication check.
When the manager access routine calls 
\*Lrpc_binding_inq_auth_client(\|)\*O it needs to check for a
\*Vstatus\*O of \*Lrpc_s_binding_has_no_auth\*O.  In this case, the
client has specified no authentication and the manager access function
needs to make an access decision based on this fact. Note that in such
a case, no meaningful authentication or authorization information is
returned from \*Lrpc_binding_inq_auth_client(\|)\*O.

[3/24/94 public]

Reassigned this CR to John Shirley (OSF RPC writer) from
Steve Lewontin.

[11/12/93 public]

This item is in the Release Notes, in the State of the DCE Documentation section,
under Application Guide, near the end of Chapter 1.

[08/09/94 public]
Reassigned to myself.

[08/23/94 public]
Changed priority to "1" and severity to "B".

[09/15/94 public]
Fixed and verified by Walt Tuvell.

Added a clear pointer to doc for RPC routines that directly
relate to security issues in the file
app_gd/security/1_overv.gpsml

Added the Release Notes overview of the way that servers and
clients establish authentication to the file
app_gd/rpc/rpc_and_dce.gpsml

Added the Release Notes description of conditions affecting
the outcome of the client/server interaction to the file
app_ref/man3rpc/rpc_binding_set_auth_info.3rpc

A "deep housecleaning" of the security documentation is not
possible at this point.  But, this 1.0.3 Release Notes information
has been incorporated into the DCE doc set, and the necessary
pointers have been added.

[10/20/94 public]
Closed bug.



CR Number                     : 9242
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : DG min. com_timeout doesn't work correctly
Reported Date                 : 10/22/93
Found in Baseline             : 1.0.2
Found Date                    : 10/22/93
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.2.1
Affected File(s)              : rpc
Sensitivity                   : public

[10/22/93 public]

With the DG protocol, setting the com_timeout to its minimum 
value (== 1 second timeout) causes long-running calls to always
timeout.  The problem is that the client doesn't ping the server
until 2 seconds have passed, so the server can never respond in
time to avoid the timeout.

[12/19/95 public]
Fixed in DCE 1.2.1
Closed



CR Number                     : 9240
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : CN rpc
Short Description             : timer thread exception
Reported Date                 : 10/22/93
Found in Baseline             : 1.0.2
Found Date                    : 10/22/93
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : runtime/cnassoc.c
Sensitivity                   : public

[10/22/93 public]
The stack for the timer thread is as follows :

timer_loop
rpc__cn_assoc_timer_reclaim
rpc__cn_assoc_reclaim
rpc__cn_assoc_acb_dealloc
rpc__list_element_free
rpc__cn_assoc_acb_free
pthread_cancel

the timer thread is posting a cancel to receiver thread, but we see is that
the cn_rcvr_thread_id is NULL !!!!!!! WHY?

The assoc data structure is as follows :

assoc_flags 0
assoc_status 0
assoc_local_status 0
assoc_ref_count 0
assoc_acb_ref_count 0
assoc_grp_id 00000000
assoc_msg_waiters 0
assoc_msg_cond e0894200 3b000200 00000000
assoc_max_xmit_frag 0
assoc_max_recv_frag 0
assoc_pres_context_id 0
ndr_format            01000000
call_rep              00000000


The cn_ctlblk for this assoc is as follows :

cn_state 0 => connection is closed
cn_rcvr_waiters 0
cn_rcvr_thread_id 00000000 00000000
cn_listening_endpoint 00000000
cn_sock 233 or 0xe9
rpc_addr 00000000
exit_rcvr 1
in_sendmsg 0
waiting_for_sendmsg_complete 0
cn_rcvr_cond d0854200 3a000200 00000000 00000000

I looked at rpc_g_cn_assoc_grp_tbl,

grp_count is 20 or 0x14
grp_active_count is 5

Please CORRECT my analysis for the above scenario :

The receiver thread received a cancel, while receiving packets. It deallocated
the fragbufs and then rereaised the exception, so we longjump to a previous
setjmp() which is in rpc__cn_network_receiver(). Here, the cancel exception
handler closes the socket, sets assoc->cn_state to closed and calls
rpc__cn_assoc_acb_dealloc() without sending an event through the association
state machine. rpc__cn_assoc_acb_dealloc() finally calls
rpc_list_element_free(). In this case, the lookaside list is full, so we call
rpc__cn_assoc_acb_free(). Since we are running in the receiver thread, it will
delete the "cn_rcvr_cond" and assoc->assoc_msg_cond varaibles and set
exit_rcvr field to true. I am assuming that receiver thread did delete
cn_rcvr_cond and assoc_msg_cond and then detached cn_rcvr_thread_id causing
zero to be assigned to it. On returning back to rpc__cn_network_receiver(), we
test for pending cancels and after catching all the exceptions come out of
rpc__cn_network_receiver().

So, this assoc is put back on the heap and does not have a receiver thread
assigned to it.

When the timer thread starts reclaiming associations, the same assoc IS STILL
in the rpc_g_cn_assoc_grp_tbl. The assoc_flags are zero and assoc_ref_count is
zero. Therefore, we increase the acb_ref_count. Now after setting the
assoc_flags to rpc_c_cn_assoc_scanned, we are calling
rpc__cn_assoc_acb_dealloc(). I know that William Sullivan talked to Wei-Hu
sometime in July, trying to find out if we can simply decrement the
assoc_acb_ref_count instead of calling rpc__cn_assoc_acb_dealloc(). The
answer, I think was that there is a specific reason for calling
rpc__cn_assoc_acb_dealloc(), which I am not aware of. In
rpc__cn_assoc_acb_dealloc(), the RPC_LIST_INIT and RPC_LIST_FIRST will still
work, fragbuf will be set to NULL and fragbufs won't be deallocated.

Thus, the timer thread will end up in rpc__cn_assoc_acb_free() where it posts
a cencel to cn_rcvr_thread_id, but cn_rcvr_thread_id is NULL, hence process
terminates with a thread exception!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


I put in a check that if cn_rcvr_thread_id is NULL, then timer thread should
not post a cancel to it, the modified code is as follows :

In rpc__cn_assoc_acb_free :

    else
    {
        /*
         * The receiver thread is now running with the CN global mutex
         * locked. We don't want to blow away anything in the association
         * or connection control block until we're sure the receiver
         * thread has terminated. To ensure this send the receiver thread a
         * cancel and then wait until it exits by using the
         * pthread_join() function. This function will not return
         * until the receiver thread has terminated.
         */
        ccb->exit_rcvr = true;
        if ((pthread_t)(ccb->cn_rcvr_thread_id).field1 != NULL)
        {
        pthread_cancel (ccb->cn_rcvr_thread_id);

        /*
         * Since this is a cancellable operation we'll turn cancels
         * off here. There's nothing we can do with them at this point.
         * The CN mutex must be unlocked also while we do the join.
         * This is because the receiver thread may need to lock the CN
         * mutex in order to exit. For instance, the receiver thread
         * may be blocked on the condition variable waiting for a new
         * connection. The process of unblocking from this condition
         * variable by definition acquires the CN mutex.
         */
        prev_cancel_state = pthread_setcancel (CANCEL_OFF);
        RPC_CN_UNLOCK ();
        pthread_join (ccb->cn_rcvr_thread_id,
                      &pthread_exit_status);
        RPC_CN_LOCK ();
        pthread_setcancel (prev_cancel_state);
        }

        /*
         * Now that the receiver thread has terminated we can delete the
         * receiver thread and association receive queue condition variable.
         */
        RPC_COND_DELETE (ccb->cn_rcvr_cond, rpc_g_global_mutex);
        RPC_COND_DELETE (assoc->assoc_msg_cond, rpc_g_global_mutex);
    }


Now I am getting an exception in an executor thread, which is doing
            RPC_COND_WAIT (assoc->assoc_msg_cond,
                           rpc_g_global_mutex);
in rpc__cn_assoc_receive_frag() because assoc->assoc_msg_cond varaible has
been deleted.
We are running with RPC code at ib2 level.

Please let me know what you think


Thanks
Sandhya Kapoor

[10/22/93 public]
Are you running source code with the fix for 9090 in it?
This was submitted 10/18/93.

What is "ib2 level"?

[10/22/93 public]
Ok, so Prasad tells me you aren't running with the 9090 fix, but 
that doesn't help this case at all (although it will help, so you should
pick it up).

Anyway,  Prasad and I think your analysis seems correct and what is missing
is when the receiver threads gets the cancel, it should send an event
through the server association state machine.  Just as you noted.

So, you should try replacing the rpc__cn_assoc_acb_dealloc(assoc) in
rpc__cn_network_receiver() with a call to  rpc__cn_assoc_dealloc().

old:
                /*
                 * Deallocate the association control block.
                 */
                 rpc__cn_assoc_acb_dealloc (assoc);
--
new:
                /*
                 * Deallocate the association control block.
                 */
                 {
                     unsigned32 status;
                     rpc__cn_assoc_dealloc(assoc, assoc->call_rep, &status);
                 }


We will build and try this fix, but without your dramatic test, I don't
think we will see any problems.

[10/22/93 public]

I am sooooo pleased to see this OT. :-) I've been tracking the memory
corruption problem caused by the same scenario for past 3 months and have
concluded the same analysis without the proof. (Though I still don't know
who is cancelling the receiver thread.) Sandhya's stack dump does prove
that there is a chance that the assoc is left on the assoc grp list when
it's deallocated.

Tom's suggested fix will not work because posting the DeallocateReq event
to the server association state machine will not remove the assoc from the
assoc_grp. I'm including the diffs (against the current dce1.0.3 cnrcvr.c)
of what I've been testing. I added the exception handler surrounding
receive_packet() in receive_dispatch() (and the exception type checking).
When the exception is RERAISE'd from receive_packet(), it sets st =
rpc_s_connection_closed. This will cause rpc__cn_assoc_post_error() be
called and it will take any necessary cleanup action. (Posting the
NoConnInd event is safe in any association state.)

--- /afs/ch/project/dce/build/dce1.0.3/src/rpc/runtime/cnrcvr.c	Mon Oct 18 15:26:30 1993
+++ cnrcvr.c	Fri Oct 22 12:53:27 1993
@@ -8,6 +8,12 @@
 /*
  * HISTORY
+ * Revision 1.1.9.2  1993/10/22  16:47:00  tatsu_s
+ * 	Installed the exception handler in receive_dispatch().
+ *
+ * 	If rpc__cn_network_receiver() catches the exception other than
+ * 	pthread_cancel_e, report it.
+ *
  * Revision 1.1.6.2  1993/10/18  19:26:29  tom
  * 	Bug 9090 - In rpc__cn_network_receiver, dont use
  * 	assoc (in while condition) after you have dealloc'd it.
@@ -362,8 +368,20 @@
             {
                 receive_dispatch (assoc);
             }
-            FINALLY
+            CATCH(pthread_cancel_e)
+            {    
+                RPC_DBG_PRINTF (rpc_e_dbg_general, rpc_c_cn_dbg_general,
+("CN: call_rep->%x assoc->%x desc->%x receiver canceled, caught in rpc__cn_network_receiver()\n",
+                                 assoc->call_rep, 
+                                 assoc,
+                                 assoc->cn_ctlblk.cn_sock));
+            }
+            CATCH_ALL
             {
+            DIE("(rpc__cn_network_receiver) Unexpected exception is raised\n");
+            }
+            ENDTRY
+
                 RPC_DBG_PRINTF (rpc_e_dbg_general, rpc_c_cn_dbg_general,
                                 ("CN: assoc->%x call_rep->none No longer receiving...Close socket\n",
                                  assoc));
@@ -383,7 +401,7 @@
                      * The socket close failed.
                      */
                     RPC_DBG_PRINTF (rpc_e_dbg_general, rpc_c_cn_dbg_errors,
-                                    ("(rpc__cn_network_receiver) assoc->%x desc->%x rpc__socket_close failed, error = %d\n", 
+("(rpc__cn_network_receiver) assoc->%x desc->%x rpc__socket_close failed, error = %d\n", 
                                      assoc,
                                      assoc->cn_ctlblk.cn_sock,
                                      RPC_SOCKET_ETOI(serr)));
@@ -432,8 +450,6 @@
                     DIE("(rpc__cn_network_receiver) Unexpected exception
is raised\n");
                 }
                 ENDTRY
-             } /* end FINALLY */
-            ENDTRY
         }
         CATCH_ALL
         {
@@ -532,7 +548,24 @@
         /*
          * Receive a packet from the network.
          */
+        TRY
+        {
         receive_packet (assoc, &fragbuf_p, &ovf_fragbuf_p, &st);
+        }
+        CATCH(pthread_cancel_e)
+        {    
+            RPC_DBG_PRINTF (rpc_e_dbg_general, rpc_c_cn_dbg_general,
+("CN: call_rep->%x assoc->%x desc->%x receiver canceled, caught in receive_dispatch()\n",
+                             assoc->call_rep, 
+                             assoc,
+                             assoc->cn_ctlblk.cn_sock));
+            st = rpc_s_connection_closed;
+        }
+        CATCH_ALL
+        {
+            DIE("(receive_dispatch) Unexpected exception is raised\n");
+        }
+        ENDTRY
         if (st != rpc_s_ok)
         {
             break;
@@ -1240,6 +1273,11 @@
 #ifdef NON_CANCELLABLE_IO
 	    pthread_setasynccancel(CANCEL_OFF);
 #endif            
+            RPC_DBG_PRINTF (rpc_e_dbg_general, rpc_c_cn_dbg_general,
+("CN: call_rep->%x assoc->%x desc->%x receiver canceled, caught in receive_packet()\n",
+                             assoc->call_rep, 
+                             assoc,
+                             assoc->cn_ctlblk.cn_sock));
             /*
              * Re-acquire the CN global mutex and free any fragment
              * buffers we have outstanding.
@@ -1251,6 +1289,10 @@
             }
             RERAISE;
         }
+        CATCH_ALL
+        {
+            DIE("(receive_packet) Unexpected exception is raised\n");
+        }
         ENDTRY
 
         /*

Also note that when the assoc is deallocated to the lookaside list or to
the malloc heap without first removing it from the assoc grp list, there is
the pointer left in the assoc grp list pointing to that assoc and it causes
a really nasty behavior, e.g., double-free'ing, etc. (Interestingly,
rpc__list_element_free() is not double-free safe!)

[10/22/93 public]
Thanks for your help.  
The other issue is that the cn_rcvr_thread_id is NULL, still the timer thread
is posting a cancel to it in rpc__cn_assoc_acb_free(). If an assoc has been
returned to the heap, then shouldn't it be removed from
rpc_g_cn_assoc_grp_tbl.assoc_grp_vector[i].grp_assoc_list, so that the timer
thread does not try to reclaim this association?

[10/22/93 public]
Once again, thanks to Seiichi for helping on this.  We thought our
idea would work, but we didn't even bother to test it after he sent
his note.. :-)

Anyway, if I follow his reasoning correctly, the association *will* be 
removed from the group.  Since the error status is connection closed, 
a "NoConnInd" event will be generated to the association state machine, 
which then takes as its actions RemoveAssocFromAssocGroup, MarkAssoc, 
and AbortAssoc.  (See the CN "Steve Miller Spec" state tables, page 64.)

I have made Seiichi's changes and checked them in to the 'tom_rpc'
branch in the OSF source tree (bco -read -r tom_rpc cnrcvr.c).  
If we are all agreed that this is the right fix to try, 
could you test with the fix?  I am running a cell with the changes, 
but I have nothing which can duplicate IBM or HP's stress tests.

[10/22/93 public]

That's right. The assoc will be removed from the group. We have been
running this code in our not-yet-released next HP DCE product since the
beginning of September. It hasn't broken anything, but it hasn't proved
that it is a right fix either. I've seen the RPC runtime crash only twice
(or three times) in the past 3 months caused (at least I believe :-) by
this defect. That's why I didn't open CR and why I was excited when I saw
Sandhya's report. And again, I still don't know how the receiver thread is
cancelled in the first place. Anyway, this fix seems to be harmless for the
normal RPC CN processing.

[10/25/93 public]
I have implemented this fix, but the lookaside list is being corrupted. 
I have seen this failure before while running dramatic testcase.

[10/25/93 public]

Too bad... Was the lookaside corrupted in the same way you originally
described? Or caused by double-freeing (because the lookaside wasn't full,
the same assoc was added to the lookaside twice)?

[10/25/93 public]
Yikes, this is bad.  

Can you give us more detail on the failure?  
Is it exactly the same as before, i.e. Did it the fix help at all?

Can I assume you are working on this problem
full time?  Since we can't reproduce this here, all we can do is
review the code.  We are trying to verify that every time we
free the association, it get removed from the group list.  Perhaps
we need to run with a trace on the free's and group list removes
to pinpoint where they are not happening at the same time.

[10/25/93 public]
Under advice from management, I am lowering this to an A1 and
assigning it to IBM.  We are hamstrung by the fact that IBM
is the only one who can reproduce this (at will), although HP
sees this problem every once-in-a-while.

We have a few days to fix this for 1.0.3, but OSF will hard freeze
with this bug unfixed and defer it to 1.1.

On a totally unrelated note, are you running your tests on the current
1.0.3 RPC source base?  I do not specifically suspect any
1.0.3 fix, but we *have* made fixes to the association code.

It may be helpfull to run against the weekly build that was made
available Friday, Oct 22, 1993.

I will submit Seiichi's 'fix' to our source base.  I believe it can't
hurt and should in fact help association alloc/dealloc.

[10/26/93 public]
I ran with debug statements added to rpclist.c in rpc__List_element_free(). We
found that the timer thread is trying to reclaim an association that is
already on  rpc_g_cn_assoc_lookaside_list. So, the question is why this assoc
is in rpc_g_cn_assoc_grp_tbl? I would have given you the answer, but
unfortunately today and tomorrow, I have to work on another issue. I will
debug further on Thursday morning.

[10/26/93 public]

The assoc is on both the grp_assoc_list and the lookaside list. Think about
this scenario:

1) The assoc is deallocated (by rpc__cn_assoc_acb_dealloc()) without first
removed from the grp_assoc_list. This is what you said in your original
analysis. The lookaside list was NOT full, so it's on the lookaside list
now. But, the grp_assoc_list's pointer chains are still pointing to this
assoc, which is now on the lookaside list.

2) The timer thread starts reclaiming the assocs on the grp_assoc_list and
ends up following links on the lookaside list.

Your original analysis deals with the case where the lookaside list was
full when rpc__cn_assoc_acb_dealloc() was called. But there is the case
where the lookaside list was not full.

I did the same debugging, double-free'ing check in
rpc__List_element_free(), moons ago, and found IT HAPPENS. But I still
don't know how it happens. Frustrating... The receiver thread jumping out
without calling rpc__cn_assoc_post_error() is one candidate for the cause
of this.

[10/28/93 public]
A fix for this has been submitted to the OSF code base (see below).
Defect 9258 was opened by HP, and tatsu_s tracked down a serious
problem with the group table expansion.

We would like for IBM to please apply this fix and re-run their tests
to verify that this fix indeed solves the problem.

NOTE: Both fixes suggested by HP are now in the OSF code.  We believe
the first fix will also help prevent associtations from being
dealloc'd and not removed from the group table.

Relevant comments from 9258 follow; tatsu_s writes:

Yes, yes, yes, finally I've found it! It was caused by
rpc__cn_assoc_grp_create().

When rpc_g_cn_assoc_grp_tbl.assoc_grp_vector is expanded (and relocated),
the active assoc_grp's first assoc on the grp_assoc_list (the one pointed
by rpc_g_cn_assoc_grp_tbl.assoc_grp_vector[x].grp_assoc_list.next) is still
holding the pointer to the old (free'ed) grp_assoc_list, e.g.,
new_assoc_grp[x].grp_assoc_list.next->last ==
old_assoc_grp[x].grp_assoc_list . Thus, when this assoc is removed from the
grp_assoc_list by using RPC_LIST_REMOVE()::rpclist.h macro, it updates
old_assoc_grp[x].grp_assoc_list.next pointer. It never update the now
relocated rpc_g_cn_assoc_grp_tbl.assoc_grp_vector[x].grp_assoc_list.next .
(Also the second assoc on the list still points to the
old_assoc_grp[x].grp_assoc_list after the removal. See RPC_LIST_REMOVE().)
If what IBM is seeing in CR9240 happens after the call to
rpc__cn_assoc_grp_create(), this must be it.

The fix in rpc__cn_assoc_grp_create() should be trivial. I'll think about
it after I get sleep.

Here is my suggested fix.

In rpc__cn_assoc_grp_create()::cnassoc.c, between memcpy() and
RPC_MEM_FREE() add:

        for (i = 0; i < old_count; i++)
        {
            /*
             * Relocate the "last" pointer in the head of the grp_assoc_list.
             * We don't check group's state because they must be all active.
             * Otherwise, this function never get called. (grp_assoc_list.next
             * shouldn't be NULL.)
             */
            if (new_assoc_grp[i].grp_assoc_list.next != NULL)
            {
                ((rpc_list_p_t)(new_assoc_grp[i].grp_assoc_list.next))->last =
                    (pointer_t)&new_assoc_grp[i].grp_assoc_list;
            }
        }        

We will test this fix.

[11/08/93 public]
Has IBM run with this fix and verified that it does indeed solve the problem
with their dramatic test?

This would be good to know.

[11/08/93 public]
Yes, we ran dramtic test with the fix and it does indeed solve the problem.
Thanks Sandhya

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 9220
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : porting guide
Short Description             : idl_frontend tests are moving to nosupport
Reported Date                 : 10/21/93
Found in Baseline             : 1.0.3
Found Date                    : 10/21/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : port_gd/3_rpc.gpsml
Sensitivity                   : public

[10/21/93 public]
The test/rpc/idl_frontend tests are moving to the nosupport tree.
This means we should either not document them, or note that these
tests are no longer supported by OSF.

Prasad will be moving the tests to the nosupport directory.

[10/22/93 public]

Assigned this CR to Doug Weir.

[11/2/93 public]

Removed the section from the Porting Guide, added a paragraph explaining the
non-support of the tests to the Release Notes, made a separate file from the
section, to be formatted and put into project/test_docs.nosupport, and men-
tioned this directory in the proper spots in Chapter 1 and Appendix A of the
Release Notes.

[11/12/93 public]

This is fixed and verified and reviewed several times.

[11/12/93 public]

Verified changes in latest doc build and closed this CR.



CR Number                     : 9190
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : Memory leaks in IDL Encoding Services
Reported Date                 : 10/19/93
Found in Baseline             : 1.0.3
Found Date                    : 10/19/93
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/idl/lib/pickling.c
Sensitivity                   : public

[10/19/93 public]
This is the problem we were asked about by the people at IBM Toronto who
are doing the DCE audit work. There is a bug in the way IDL Encoding
Services manages memory. This results in substantial memory leaks.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 9128
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : ./test/rpc/rtandidl/moretests/pattrm.c
Short Description             : 
./test/rpc/rtandidl/moretests/pattrm.c: In function `pattrtest_op2':
./test/rpc/rtandidl/moretests/pattrm.c:107:argument `st_in' doesn't match
					   prototype
Reported Date                 : 10/15/93
Found in Baseline             : 1.0.3
Found Date                    : 10/15/93
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : test/rpc/rtandidl/moretests/pattr.idl
Sensitivity                   : public

[10/15/93 public]

src/test/rpc/rtandidl/moretests/pattrm.c:In function `pattrtest_op2':
src/test/rpc/rtandidl/moretests/pattrm.c:107:argument `st_in' doesn't match
prototype 


test_install:
/test/rpc/rtandidl/moretests/tstsrvr: installing as
/u1/devobj/sb/nb_486/src/../install/at386/dcetest/dce1.0/test/rpc/rtandidl
/moretests/tstsrvr 
make: don't know how to make server (continuing)

[10/15/93 public]
Fixed the pattr.idl file to have to correct prototype.

[11/12/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 9112
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : config/dce_config
Short Description             : doesn't stop llbd before starting rpcd
Reported Date                 : 10/13/93
Found in Baseline             : 1.0.3
Found Date                    : 10/13/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rc.dce
Sensitivity                   : public

[10/13/93 public]
I configured a single node cell that happened to be running llbd at the
time.  dce_config kindly and silently killed llbd and started rpcd for me.
Later, I stopped DCE, rebooted, and restarted DCE using dce_config.  rpcd
didn't start, with no complaint,  and the rest of DCE failed to start, as
well.  The problem turned out to be that llbd was again running, having
just reboot the node.  dce_config should take care of this, just as it did
during configuration.

[10/13/93 public]
Actually, I don't think it should.  llbd is an HP-UX only problem,
and you need to know better than to start it (via OS rc scripts) if
you are going to run DCE.

I don't really want to clutter up rc.dce with more machine dependant 'fixes'.

[10/14/93 public]
I considered that llbd might not be dce_config's problem, when I discovered
that dce_config already does this during configuration in config_rpcd.
Besides, isn't NCS, including llbd, glbd, available on many platforms?
Regardless of whether it's correct to have dce_config consider llbd, we
need to be consistent.  Either do it for both configuration and restart, or
for neither.  If the latter, there should be mention made in release notes
of this.  Again, NCS runs on lots of different platforms.

[10/14/93 public]
I'm feeling in a generous mood, so I added the fix (in rc.dce):
> if [ "$UNAME" = "HP-UX" ]; then
>       daemon_slayer llbd
> fi

Closed.



CR Number                     : 9090
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : cn
Short Description             : network_receiver thread uses assoc after freeing it
Reported Date                 : 10/12/93
Found in Baseline             : 1.0.2a
Found Date                    : 10/12/93
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : cnassoc.c cnrcvr.c
Sensitivity                   : public
Transarc Deltas               : 
Transarc Status               : open

[10/12/93 public]
The rpc__cn_network_receiver thread calls rpc__cn_assoc_acb_dealloc in
the FINALLY clause after calling receive_dispatch.  This may result in
freeing the assoc if the look-aside list for it is already full.  It
then uses this freed assoc later to decide to quit the while-loop. 
However, if a second thread calls malloc after the free but before the
check in the "while (!assoc->cn_ctlblk.exit_rcvr)", then this memory
freed is allocated to someone else.  The second thread may write
something into the newly malloc'ed area, and the
rpc__cn_network_receiver thread will try to call condwait, thereby
scribbling into nowhere. 
Added field Transarc Deltas with value `' 
Added field Transarc Status with value `open'

[10/13/93 public]
The analysis seems correct.  The assoc is deallocated and then it
will be checked at the top of the while.
A simple solution would be to set a boolean when we dealloc ("done")
and check it before we check the assoc struct.

[10/13/93 public]
Well, implementing a simple solution is not simple. :-)
rpc__cn_assoc_acb_deaclloc() does not tell you if it really deallocated the
assoc. The deallocation of the assoc happens only when
assoc->assoc_acb_ref_cpunt == 0 in rpc__cn_assoc_acb_dealloc() which is
called at the end of rpc__cn_assoc_dealloc(). In a typical scenario,
someone else has a reference to the ACB and it won't be deallocated.
However, I'm seeing rpc__cn_assoc_acb_free() called from the receiver
thread in rpcd and it's causing rpcd coredump. (We are seeing rpcd crash in
DFS testing at HP and I'm tracking it.)

[10/14/93 public]
My previous comment was wrong. In a normal case, the receiver thread has
the last reference to the ACB and rpc__cn_assoc_acb_dealloc() called from
the receiver thread will deallocate the assoc. (And if the lookaside list
is full, rpc__cn_assoc_acb_free() will be executed.)

[10/14/93 public]
I've tried several different ways to fix this, and I've been only
partially successful.
My original take on this was to set a flag when we have done the
dealloc, which would prevent us from referencing the assoc structure:
PRIVATE void rpc__cn_network_receiver (assoc)
{
    boolean             done=false;
...
    /*
     * Loop until a cancel is sent to this thread.
     */
    while (!done && !assoc->cn_ctlblk.exit_rcvr)
    {
...
                /*
                 * Deallocate the association control block.
                 */
                if (assoc->assoc_acb_ref_count == 1)
                {
                        done = true;
                }
                rpc__cn_assoc_acb_dealloc (assoc);
...
    }
This fails.  sec_clientd will hang before it establishes the machine ID.
I have been unable to track exactly why.
The partial success I have had was from Seiichi's idea of decrementing
the ref_count and letting the reclaim routine clean up the assoc:
    while (!assoc->cn_ctlblk.exit_rcvr)
    {
...
                /* 
		 * Can't call rpc__cn_assoc_acb_dealloc (assoc); 
		 * Cause we need the assoc to get out of the while.
		 */
                RPC_CN_ASSOC_ACB_DEC_REF (assoc);
...
    }
This 'works', but I am wary about leaving the assoc 'hanging' and the
receiver thread still running.  It will take the server 10 seconds (max)
to cleanup everything, and 300 seconds for the client.  This seems large.
Any opionions?  Help?  Does anyone know of 'bad things' which could happen
if we leave the receiver thread hanging about?

[10/14/93 public]
I've found the problem of doing RPC_CN_ASSOC_ACB_DEC_REF(). In the normal
path, when receive_dispatch() returns the assoc is already removed from the
assoc_grp. Thus the timer thread won't reclaim it. (The resource leak.
Nobody knows about this assoc.) Our rpcd coredump problem was caused by the
timer thread reclaiming the already free'ed (by the receiver thread) assoc.
I don't understand why Tom's original solution didn't work. It looked fine.

[10/15/93 public]
Thanks to Seiichi, we have a fix that seems to work for this defect.
I don't fully trust the fix however, not to have some unforseen consequence
so I'm a little gun-shy about putting it in to 1.0.3 at this late date.
I need to know from Transarc more details on how they found this problem,
how ofter it occurs, and if they would be willing to test the fix.
The fix from Seiichi:
Clearly doing RPC_CN_ASSOC_ACB_DEC_REF() is a bad idea. It orphans the assoc.
    /*
     * Loop until a cancel is sent to this thread.
     */
    while (!done && !assoc->cn_ctlblk.exit_rcvr)
    {
	........
                assoc->cn_ctlblk.cn_state = rpc_c_cn_closed;
                /*
                 * Remove any pending cancel on this assoc. Otherwise, it's
                 * possible that the receiver thread will see this cancel after
                 * the next call begins.
                 */
                TRY
                {
                    pthread_testcancel();
                }
                CATCH_ALL
                {
                    RPC_DBG_PRINTF (rpc_e_dbg_general, rpc_c_cn_dbg_general,
                        ("CN: assoc->%x rcvr cancel found at acb_dealloc\n",
                        assoc));
                }
                ENDTRY
                
                /*
                 * Deallocate the association control block.
                 */
                rpc__cn_assoc_acb_dealloc (assoc);
                /*
                 * Check if rpc__cn_assoc_acb_free() posted the cancel.
                 */
                TRY
                {
                    pthread_testcancel();
                }
                CATCH(pthread_cancel_e)
                {    
                    RPC_DBG_PRINTF (rpc_e_dbg_general, rpc_c_cn_dbg_general,
                        ("CN: assoc->%x rcvr free'ed by acb_dealloc\n",
                        assoc));
                    done = true;
                }
                CATCH_ALL
                {
                    DIE("(rpc__cn_network_receiver) Unexpected exception is raised\n");
                }
                ENDTRY
             } /* end FINALLY */
            ENDTRY
In rpc__cn_assoc_acb_free():
    /*
     * Determine whether we are now running in the receiver thread.
     */
    current_thread_id = pthread_self();
    if (pthread_equal (current_thread_id,
                       assoc->cn_ctlblk.cn_rcvr_thread_id))
    {
        RPC_COND_DELETE (ccb->cn_rcvr_cond, rpc_g_global_mutex);
        RPC_COND_DELETE (assoc->assoc_msg_cond, rpc_g_global_mutex);
        pthread_cancel (ccb->cn_rcvr_thread_id);
    }
    else

[10/18/93 public]
I put this suggestion in, and ran the tests that produced the problem. 
They dont fail with this problem anymore.  Looks like it is a correct
solution.  I reorganized the rpc__cn_assoc_acb_free code a little, so
that it looks like:
PRIVATE void rpc__cn_assoc_acb_free (assoc)
rpc_cn_assoc_p_t        assoc;
{
    rpc_cn_ctlblk_t     *ccb;
    pthread_t           current_thread_id;
    pthread_addr_t      pthread_exit_status;
    int                 prev_cancel_state;
    RPC_LOG_CN_ASSOC_ACB_FR_NTR;
    RPC_CN_DBG_RTN_PRINTF(rpc__cn_assoc_acb_free);
    
    /*
     * Get a pointer to the connection control block contained in
     * the association control block.
     */
    ccb = &assoc->cn_ctlblk;
    /*
     * The receiver thread is now running with the CN global mutex
     * locked. We don't want to blow away anything in the association
     * or connection control block until we're sure the receiver
     * thread has terminated. To ensure this send the receiver thread a
     * cancel and then wait until it exits by using the
     * pthread_join() function. This function will not return
     * until the receiver thread has terminated.
     */
    ccb->exit_rcvr = true;
    pthread_cancel (ccb->cn_rcvr_thread_id);
    /*
     * Determine whether we are now running in the receiver thread.
     */
    current_thread_id = pthread_self();
    if (! pthread_equal (current_thread_id,
			 assoc->cn_ctlblk.cn_rcvr_thread_id))
    {
	/*
	 * We are not in the receiver thread, therefore wait for
	 * it to finish.
	 */
        /*
         * Since this is a cancellable operation we'll turn cancels
         * off here. There's nothing we can do with them at this point.
         * The CN mutex must be unlocked also while we do the join.
         * This is because the receiver thread may need to lock the CN
         * mutex in order to exit. For instance, the receiver thread
         * may be blocked on the condition variable waiting for a new
         * connection. The process of unblocking from this condition
         * variable by definition acquires the CN mutex. 
         */
        prev_cancel_state = pthread_setcancel (CANCEL_OFF);
        RPC_CN_UNLOCK ();
        pthread_join (ccb->cn_rcvr_thread_id,
                      &pthread_exit_status);
        RPC_CN_LOCK ();
        pthread_setcancel (prev_cancel_state);
    }
    /*
     * Now that the receiver thread has terminated we can delete the
     * receiver thread and association receive queue condition variable.
     */
    RPC_COND_DELETE (ccb->cn_rcvr_cond, rpc_g_global_mutex);
    RPC_COND_DELETE (assoc->assoc_msg_cond, rpc_g_global_mutex);
    pthread_detach (&ccb->cn_rcvr_thread_id);
    RPC_LOG_CN_ASSOC_ACB_FR_XIT;
}

[10/18/93 public]
I didn't reorganize the module, but I submitted the fixed I detailed above.

Don't want to make too much of a mess in a point release.
Thanks for testing this for me.

[10/22/93 public]

FYI: Tom's original fix didn't work because even if
assoc->assoc_acb_ref_count == 1, it doesn't mean that
rpc__cn_assoc_acb_free() will be called. rpc__cn_assoc_acb_free() will be
called only when the lookaside list is full. If the receiver thread exits
while the assoc is on the lookaside list, the next call grabbing it will
wait forever... Only rpc__cn_assoc_acb_free() can tell the receiver thread
to exit or not. Also the alternative way of fixing this is use of the
thread-specific data obtained from pthread_getspecific().

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 9087
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa,i486
S/W Ref Platform              : hpux,osf1
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : faultstat test core dumps
Reported Date                 : 10/12/93
Found in Baseline             : 1.0.3
Found Date                    : 10/12/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : test/rpc/idl/faultstat/manager.c,
					     client_aux.c
Sensitivity                   : public

[10/12/93 public]

While running the idl tests (using run_tests script), 
faultstat test core dumps.

From Log file:

Running faultstat test
run_tests: 9619 Floating exception - core dumped
run_tests: 9624 Killed

[10/12/93 public]
for 486/osf1 -
The non-portable tests (tests which use the bogus handle) are eliminated
by modfying the client_aux.c

for 486/osf1 and hp/ux-
Appropriate DIV_BY_ZERO is accessed in  manager.c

[11/12/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 9083
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : seg fault in rpc_ss_destroy_support_ptrs
Reported Date                 : 10/11/93
Found in Baseline             : 1.0.3
Found Date                    : 10/11/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/idl/lib/eenodtbl.c
Sensitivity                   : public

[10/11/93 public]
This problem manifested itself as a failure of rpcd. Under certain error
conditions, rpc_ss_destroy_support_ptrs gets called when the support
pointers data structure has not been created. The seg fault results from
trying to dereference the NULL value returned from per thread context in
this case.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 9082
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : Wrong default [pointer_default]
Reported Date                 : 10/11/93
Found in Baseline             : 1.0.3
Found Date                    : 10/11/93
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : astp_com.c
Sensitivity                   : public

[10/11/93 public]
When the IDL compiler finds that a [pointer_default] clause should be
present, but is not, for consistency with the 1.0.2 IDL compiler it should
treat the pointers that would be affected by the [pointer_default] clause
as [ptr].

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 9078
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : pointer to structure
containing conformant array of [cs_char] gives error
Reported Date                 : 10/8/93
Found in Baseline             : 1.0.3
Found Date                    : 10/8/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/idl/lib/ndrui2.c
Sensitivity                   : public

[10/8/93 public]
IDL unmarshalling code functions incorrectly for a pointer to a structure
containing a conformant array of [cs_char]s

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8903
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8238
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : krpc
Short Description             : krpc support for port restriction
Reported Date                 : 10/4/93
Found in Baseline             : 1.0.3
Found Date                    : 10/4/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : krpc_helper.c, krpc_helper.h, RIOS/comsoc_sys.c, HP800/comsoc_sys.c, main_helper.c
Sensitivity                   : public

[10/4/93 public]

This ot is to add the krpc support for the ports restrction
functionality implemented in ot 8238.  This will require changes
in krpc_helper.c, comsoc_sys.c and dfsbind/main_helper.c.

[10/05/93 public]

Fix submitted.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8901
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : Anonymous non-encapsulated
union will not compile
Reported Date                 : 10/4/93
Found in Baseline             : 1.0.3
Found Date                    : 10/4/93
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : astp_com.c
Sensitivity                   : public

[10/4/93 public]
The IDL compiler issues an error on an anonymous non-encapsulated union.
This construct is valid IDL and the compiler should accept it.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8900
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : Warn that anonymous enum is
not portable
Reported Date                 : 10/4/93
Found in Baseline             : 1.0.3
Found Date                    : 10/4/93
Severity                      : E
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : checker.c,nidlmsg.h,nidlmsg.m
Sensitivity                   : public

[10/4/93 public]
The IDL compiler will accept the use of an anonymous enumeration type.
However, the C code it generates may not compile correctly.
The user should be warned in this case.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8899
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : Improve error reporting of
missing reauired type
Reported Date                 : 10/4/93
Found in Baseline             : 1.0.3
Found Date                    : 10/4/93
Severity                      : E
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : acf.y,nidlmsg.h,nidlmsg.m
Sensitivity                   : public

[10/4/93 public]
Improve the handling of the case where a typedef required by the IDL
compiler is missing from nbase.idl

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8898
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : Warn user if IDL compiler
encounters CPP directive
Reported Date                 : 10/4/93
Found in Baseline             : 1.0.3
Found Date                    : 10/4/93
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : acf.l,nidl.l,nidlmsg.h,nidlmsg.m
Sensitivity                   : public

[10/4/93 public]
If the user does not ask for C preprocessing when compiling an IDL file,
he should be warned if the IDL compiler encounters a CPP directive.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8897
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : IDL compiler can fail silently
with an internal error
Reported Date                 : 10/4/93
Found in Baseline             : 1.0.3
Found Date                    : 10/4/93
Severity                      : E
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : driver.c,frontend.c
Sensitivity                   : public

[10/4/93 public]
Make sure that if an IDL compilation terminates abnormally the user sees a
message saying the comilation failed.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8896
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : improve #include file processing
Reported Date                 : 10/4/93
Found in Baseline             : 1.0.3
Found Date                    : 10/4/93
Severity                      : E
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : hdgen.c
Sensitivity                   : public

[10/4/93 public]
A simple change to the way #include's are spelt into generated IDL header
files will substantially reduce the number of lines of text that have to
be processed by the C compiler when source that includes IDL generated
headers is compiled.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8874
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : Internal design change to
support languages other than C
Reported Date                 : 9/29/93
Found in Baseline             : 1.0.3
Found Date                    : 9/29/93
Severity                      : E
Priority                      : 4
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : acf.y,ast.h,astp.h,astp_sim.c,hdgen.c,sysdep.h
Sensitivity                   : public

[9/29/93 public]
There is a low level design error in IDL which would lead to a #include
being incorrectly spelt into a header file when stubs to support a language
other than C were being generated.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8873
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rtandidl
Short Description             : rtandidl cmd_line test fails
Reported Date                 : 9/29/93
Found in Baseline             : 1.0.3
Found Date                    : 9/29/93
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : cmd_line.sh
Sensitivity                   : public

[9/29/93 public]
The rtandidl test for idl command line functionality fails
because the new 1.0.3 idl no longer generates _aux files by
default.

The files need to be removed from the expected files list in
the cmd_line.sh script.

[09/29/93 public]
Submitted and verified.
Closed.



CR Number                     : 8680
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : [transmit_as] conformant
stucture not allowed on array base type
Reported Date                 : 9/24/93
Found in Baseline             : 1.0.3
Found Date                    : 9/24/93
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : checker.c,ndrui3.c
Sensitivity                   : public

[9/24/93 public]
It is permitted for the base type of an array to have the transmit_as
attribute with the transmitted type being conformant provided the presented
type is not conformant. The IDL compiler incorrectly flags this construct
as an error.
Also, the IDL runtime supportis missing code to support the case where the
transmitted type is a conformant [v1_struct].

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8674
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl compiler
Short Description             : idl compiler generates wrong
code for int type
Reported Date                 : 9/23/93
Found in Baseline             : 1.0.3
Found Date                    : 9/23/93
Severity                      : C
Priority                      : 4
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : nidl.y
Sensitivity                   : public

[9/23/93 public]

A customer reports:

     idl compiler generates wrong code for int type

     -------------bla.idl-----------------
     [uuid(af4b6b41-4f82-11cc-9f63-080014815915)]
     interface test
     {
     error_status_t nothing(
                             [in] int p1,
                             [in] long int p3,
                             [in] unsigned int p6,
                             [in] unsigned long int p8);
     }
     ----------------------------------------

     % idl -keep c_source bla.idl
     Operation nothing has no binding handle parameter; [auto_handle] assumed
     idl: File bla.idl, line 8:                      [in] int p1,
     Warning: A size specifier is required; long assumed
     idl: File bla.idl, line 10:                     [in] unsigned int p6,
     Warning: A size specifier is required; long assumed

     
     --------------bla.h------------------
     .........
     #include <dce/nbase.h>
     extern error_status_t nothing(
     #ifdef IDL_PROTOTYPES
         /* [in] */ idl_ulong_int p1,    <-------must be idl_long_int
         /* [in] */ idl_long_int p3,
        /* [in] */ idl_long_int p6,     <-------must be idl_ulong_int
         /* [in] */ idl_ulong_int p8
     #endif

This was first noticed on the SVR4 platform, but Tom Jordahl has verified
that the bug exists on the 486 and hp platforms as well.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8672
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 8539,8451
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : admin_ref
Short Description             : rpccp remove mapping manpage in error
Reported Date                 : 9/23/93
Found in Baseline             : 1.0.2
Found Date                    : 9/23/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : admin_ref/man8rpc/rpccp_remove_mapping.8rpc
Sensitivity                   : public

[9/23/93 public]
Maybe this isn't a bug at all, but I thought it should be pointed out.
As a result of a change being made to the RPC code in 1.0.3, rpccp will
no longer accept remote requests to remove endpoints. The new code changes
the behavior of both the "add mapping" and "remove mapping" subcommands,
but it seems that "add mapping" already correctly refers only to local
endpoints. The "remove mapping" manpage however says that you can operate
on local or remote endpoints, which will no longer be the case.

There is a slight complicating factor in all this, however-- the remote
endpoint functionality can be enabled by building the RPC component with
a preprocessor variable defined (this is now documented in the Porting
Guide; see CRs 8539 and 8451 for more information). Thus, the behavior
of "add mapping" and "remove mapping" will depend on how the implementor
chose to build the component, although the default is that the remote
endpoint functionality is disabled.

[9/24/93 public]
Howard Melman commented as follows:

  This absolutely is a bug, a required doc change as part of
  functionality change.  We should document the default
  behavior we ship, which in this case is the removal of the
  remote case.  You can build DCE with DFS, but by default DFS
  is built and we document DFS :-)

[10/1/93 public]

Assigned this bug to myself.

[10/12/93 public]

Removed all reference to remote endpoint functionality.
Asked Tom Jordahl to verify.

[10/13/93 public]

Doc verified by T. Jordahl. Closed this bug.



CR Number                     : 8643
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : rpc/dg
Short Description             : CL rpc does not consist with encryption/decryption while handling reject packet.
Reported Date                 : 9/21/93
Found in Baseline             : 1.0.2
Found Date                    : 9/21/93
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : rpc/runtime/dgxq.c
Sensitivity                   : public

[9/21/93 public]

While using rpc_c_authn_level_pkt_privacy level of authentication, if the call
is generating an error on the server side (eg. unregister an interface that
doesn't exist), the server will form a xqe with only the error status in the
body, encrypted the body (in dgxq.c) and send it back to client. On the client
side, it receives the packet, identifies the packet type (rpc_c_dg_pt_reject in
this case), and dispatches to rpc__dg_do_reject (it is rejected by the server).
In rpc__dg_do_reject (dgclsn.c), it unmarshalled the NCA status from the reject 
packet body, mapped the NCA error to RPC error, and signal the failure of the
call to the client.

During above process, the problem happens in the encryption/decryption of the 
packet body. On the server side, the body of the reject packet (the error
status in this case) was encrypted (because the data privacy level protection). 
On the client side, however, the packet body was not decrypted (I guess it 
already assumed the reject packet will only contain error status in the body) 
before unmarshalling the error status. As a result, the rpc_c_unknown_reject 
error was signaled to the application client and the real error status reported
by the server was lost.

I think there are two ways to fix this problem: 

  - Fix the server side (dgxq.c) : Check on the call status, if it is rejected 
    call, skip the encryption (of the xqe->body) part, and send the error 
    status back to client. The client side will not need any change.
  
  - Fix the client side (in dgclsn.c) : Add the decryption process in the
    rpc__dg_do_reject before it unmarshalls the reject status from the body
    of the received packet. The server side will not need any change.

My recommandation will be fixing the server side since there is really no need 
to encrypt the error status before sent back to client.

[11/22/93 public]

AES/DC RPC Volume Chapter 13 is not clear about whether DG reject PDU body
should be encrypted or not. In general, a PDU body is encrypted when the
pkt_privacy is requested. Thus, in CN, request, response and fault PDU
bodies are encrypted. (AES/DC RPC 13.2.6.2.6 explicitly states this.) In
DG, any PDUs having body data are encrypted. However in the case of the
reject PDU, you may not be able to encrypt/decrypt its body if the reject
happened because of the authentication failure. After the authentication
succeeds, it may be a good idea to encrypt/decrypt rpc_s_unknown_if reject
status. CN does not have this problem because the reject status is a part
of PDU headers. Should the reject status be protected or not?

[12/8/93 public]

We think that the reject status should not be encrypted because it's hard
to implement and CN protocol doesn't do that. Fixing the server runtime
requires only 4 lines of codes added.

[5/27/94 public]

The fix has been submitted as a part of MBF code drop.



CR Number                     : 8638
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : cn rpc does not isolate des/non-des properly
Reported Date                 : 9/20/93
Found in Baseline             : 1.0.2
Found Date                    : 9/20/93
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : krbcn.c
Sensitivity                   : public

[9/20/93 public]
In the current rpc runtime, the flag "NOENCRYPTION" is used to separate the
des/non-des version of rpc runtime (due to export regulation). In CL code, all
the separation work out ok. However, in CO runtime (ie. in krbcn.c), all the
rpc_c_authn_level_pkt_privacy protection level code were not surrounded by the
"NOENCRYPTION". This means if I installed a non-des version of DCE, I cannot
run the data privacy level support on CL, but I still able to run data privacy
protection on CO (violating regualtion ???). I tested one simple case where 
client was running on a des version of DCE and server was running on non-des
version of DCE. Guess what ? They talk to each other using the level 6 
authentication (ie. data privacy support).

Here are what I think need to be changed in krbcn.c:

  Using #ifndef NOENCRYPTION to surround "case rpc_c_authn_level_pkt_privacy:"
   at about line 1816, 1843, 2198, and 2312.

[9/23/93 public]
all the rpc_c_authn_level_pkt_privacy code is enclosed
under #ifndef NOENCRYPTION.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8614
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa,rs6000
S/W Ref Platform              : hpux,aix
Component Name                : rpc
Subcomponent Name             : rpc/runtime
Short Description             : rpc__dg_conv_fork_handler() bug?
Reported Date                 : 9/16/93
Found in Baseline             : 1.0.3
Found Date                    : 9/16/93
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : dg.h, dginit.c, dglsn.c?
 (see list of
	changed rpc/runtime files below).  The bug breaks the
	build &/or installation in the directories libdce,
	file/libafs, diskless/swap/kernel, directory/cds/control.
Sensitivity                   : public

[9/16/93 public]

cdscp and possibly part of libdce didn't build as a result of this
bug.

A number of rpc/runtime files changed yesterday, including dg.h where
the routine rpc__dg_conv_fork_handler, a wrapper for the routine
rpc_fork_stage_id_t is defined, and dglsn.c, which uses it.


From the HPUX build:

[ /directory/cds/control at 20:37 (PM) Wednesday ]

c89 -E -I/u3/devobj/sb/nb_ux/export/hp800/usr/include
-I/project/dce/build/dce1.0.3-snap/export/hp800/usr/i\
nclude -Dunix -DDNS_CMA -DDNS_CDS -DDNS_V3API -DDCE_SEC -DDEBUG `genpath
-I. -I../stubs -I../includes` cds.\
c >cds.i
rm cds.c
/u3/devobj/sb/nb_ux/tools/hp800/bin/prs cds.i

Finished pass 1 with 0 errors.  Starting pass 2.

Finished pass 2

mv cds.bin cdscp.bpt
cp
/project/dce/build/dce1.0.3-snap/src/directory/cds/control/parser_aid_2.cdt \
parser_aid.cdt
chmod 644 parser_aid.cdt
/u3/devobj/sb/nb_ux/tools/hp800/bin/prs parser_aid.cdt

Finished pass 1 with 0 errors.  Starting pass 2.

Finished pass 2.

The size of the converted data file is 133 bytes.

mv parser_aid.bin parser_aid.bpt
c89 -z -Wl,-Bimmediate,-Bnonfatal,-a,default,+b,/lib:/usr/lib \
-L../cache -L/u3/devobj/sb/nb_ux/src/directory/cds/cache \
-L/project/dce/build/dce1.0.3-snap/src/directory/cds/cache \
-L/u3/devobj/sb/nb_ux/export/hp800/usr/shlib \
-L/project/dce/build/dce1.0.3-snap/export/hp800/usr/shlib \
-L/usr/shlib -L/u3/devobj/sb/nb_ux/export/hp800/usr/lib \
-L/project/dce/build/dce1.0.3-snap/export/hp800/usr/lib   -o parser_aid.X \
parser_aid_2.o hash.o parsing_support.o load_msg_file.o  load_parse_file.o \
emit_one_line.o op_list.o fopen2.o  find_base_name.o find_base_name_unix.o \
msgfnd.o msgrea.o prscmd.o prsrea.o -Wl,-a,archive -ldce -ldbm -lM 

/bin/ld: Unsatisfied symbols:
   rpc__dg_conv_fork_handler (code)
*** Error code 1


From the RIOS build:

[ /libdce at 00:55 (AM) Thursday ]

cd /u1/devobj/sb/nb_rios/obj/rios/directory/gds/ros/sh
if [ -f /u1/devobj/sb/nb_rios/src/directory/gds/ros/sh/build.made ]; then
rm -rf `head -1 /u1/devobj/sb/nb_rios/src/directory/gds/ros/sh/build.made | \
awk -F":" '{print $1}'`;  fi 
sed -e '1s;^#!;&;' -e t -e 's;^\(#.*\)\@SOURCEWARNING\@;\1THIS IS NOT A \
SOURCE FILE - DO NOT EDIT;' -e t \
/project/dce/build/dce1.0.3-snap/src/libdce/RIOS/makesyms.sh > makesyms.X
chmod +x makesyms.X
mv -f makesyms.X makesyms
rm -f *.o libdce.syms
for x in ..//threads/libcma.a ..//rpc/runtime/libnck.a \
..//rpc/idl/lib/libidl.a ..//directory/cds/library/libcds.a \
..//directory/gds/ASN1/lib_r/libasn1_r.a ..//security/utils/libsec.a \
..//directory/gds/ros/Seplog/libslog.a \
..//time/libutc/kernel/libutc-kernel.a ..//directory/gds/dua/libdua.a \
..//directory/xds/libXDS.a ..//directory/xom/libXOM.a \ 
..//config/libdce_conf.a ..//directory/gds/ros/sh/libshth.a; \
do  ./makesyms $x >> libdce.syms;  ar -xv $x;  done;
x - cma_alert.o
x - cma_assert.o
....

for y in krb5_cksumarray;  do  echo $y >> libdce.syms;  done;
ld -o shr.o *.o -bloadmap:shr.o.map -bM:sre -bE:libdce.syms \
-bI:/lib/syscalls.exp \
-bI:/project/dce/build/dce1.0.3-snap/src/libdce/RIOS/syms.imp \
-L/u1/devobj/sb/nb_rios/export/rios/usr/lib \
-L/project/dce/build/dce1.0.3-snap/export/rios/usr/lib -T512 -H512 -lbsd -lc \
-lm -lcurses -lkrb5 -lslog -lgda_util -lafssys -ldac l2acl 2> shr.o.error
.rpc__dg_conv_fork_handler
*** Error code 8 (continuing)
`build_all' not remade because of errors

[9/16/93 public]

My atfork handler support (OT8103) broke the KRPC build. Here is the fix
which has been submitted.

--- dginit.c	Thu Sep 16 15:36:14 1993
+++ dginit.c.new	Thu Sep 16 15:34:41 1993
@@ -12,6 +12,8 @@
  */
 /*
  * HISTORY
+ * 	Bug 8103 - Put the atfork handler under '#ifdef ATFORK_SUPPORTED'
for
+ * 	kruntime.
  * $Log:	c008614,v $
# Revision 1.5  94/03/15  15:59:48  nata
# added the Created HISTORY line
# 
# Revision 1.4  93/09/22  17:42:27  notuser
# changed fields: Status   new/changed/deleted note(s) [tom 09/22/93 public]
# 
# Revision 1.3  93/09/17  12:28:09  notuser
# changed fields: Status  Fixed In Baseline   new/changed/deleted note(s) [tatsu_s 9/17/93 public]
# 
# Revision 1.2  93/09/16  15:43:44  notuser
# changed fields: Responsible Engr.  Resp. Engr's Company   new/changed/deleted note(s) [tatsu_s 9/16/93 public]
# 
  * Revision 1.1.5.2  1993/09/14  16:50:45  tatsu_s
  * 	Bug 8103 - Added the call to rpc__dg_conv_init() in
@@ -129,8 +131,11 @@
     *mgmt_epv    = &dg_mgmt_epv;
     *binding_epv = &dg_binding_epv;
     *network_epv = &dg_network_epv; 
+#ifdef ATFORK_SUPPORTED
     *fork_handler= rpc__ncadg_fork_handler;
-
+#else
+    *fork_handler= NULL;
+#endif
     /*
      * Establish a server boot time.
      */
@@ -165,6 +170,7 @@
     *st = rpc_s_ok;
 }  
 
+#ifdef ATFORK_SUPPORTED
 /*
 **++
 **
@@ -236,4 +242,4 @@
             break;
     }
 }
-                       
+#endif

Pleae make sure that all files I submitted are in your src tree. There
seems to be a delay between my submittion and the actual submittion.

[9/17/93 public]

The fix was submitted yesterday under CR 8103.

[09/22/93 public]
Verified by nightly builds.
Closed.



CR Number                     : 8605
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : test/rpc/runtime/knctest,uncstest,
					     kv2test
Short Description             : secdefines.h & user.h
Reported Date                 : 9/14/93
Found in Baseline             : 1.0.3
Found Date                    : 9/14/93
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : various - see detailed description
Sensitivity                   : public

[9/14/93 public]

[ /test/rpc/runtime/kncstest at 02:05 (AM) Tuesday ]

In file included from 
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/param.h:379,
from /project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/user.h:286, 
from /project/dce/build/dce1.0.3-snap/src/test/rpc/runtime/ncstest/client.c:64:
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:40:\
 sec_base.h: No such file or directory
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:41:\
 sec_priv.h: No such file or directory
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:42:\
 sec_mac_ob.h: No such file or directory
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:43:\
 sec_acl_posix.h: No such file or directory
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:44:\
 sec_acl_sware.h: No such file or directory
In file included from
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/user.h:287,
from /project/dce/build/dce1.0.3-snap/src/test/rpc/runtime/ncstest/client.c:64:
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/time.h:65:\
 sys/unix_defs.h: No such file or directory
In file included from
/project/dce/build/dce1.0.3-snap/src/test/rpc/runtime/ncstest/client.c:64:
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/user.h:291:\
 sys/namei.h: No such file or directory
In file included from
/project/dce/build/dce1.0.3-snap/src/test/rpc/runtime/ncstest/client.c:64:
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/user.h:294:\
 sys/filedesc.h: No such file or directory
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/user.h:295:\
 sys/unix_defs.h: No such file or directory
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/user.h:297:\
 kern/event.h: No such file or directory
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/user.h:298:\
 kern/thread.h: No such file or directory
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/user.h:299:\
 machine/user.h: No such file or directory
*** Error code 1 (continuing)

[ /test/rpc/runtime/uncstest at 02:06 (AM) Tuesday ]

In file included from
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/ioctl.h:284,
from /project/dce/build/dce1.0.3-snap/src/test/rpc/runtime/v2test_lib/v2test.h:94, from\
/project/dce/build/dce1.0.3-snap/src/test/rpc/runtime/v2test_lib/v2server.c:54:
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:40:\
 sec_base.h: No such file or directory
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:41:\
 sec_priv.h: No such file or directory
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:42:\
 sec_mac_ob.h: No such file or directory
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:43:\
 sec_acl_posix.h: No such file or directory
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:44:\
 sec_acl_sware.h: No such file or directory
*** Error code 1 (continuing)

[ /test/rpc/runtime/kv2test at 02:06 (AM) Tuesday ]

In file included from
/project/dce/build/dce1.0.3-snap/src/test/rpc/runtime/v2test_lib/v2test.h:93,\
from /project/dce/build/dce1.0.3-snap/src/test/rpc/runtime/v2test_lib/v2server.c:54:\
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/time.h:65:\
 sys/unix_defs.h: No such file or directory
In file included from
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/ioctl.h:284,\
from /project/dce/build/dce1.0.3-snap/src/test/rpc/runtime/v2test_lib/v2test.h:94, from\
/project/dce/build/dce1.0.3-snap/src/test/rpc/runtime/v2test_lib/v2client.c:67:
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:40:\
 sec_base.h: No such file or directory
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:41:\
 sec_priv.h: No such file or directory
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:42:\
 sec_mac_ob.h: No such file or directory
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:43:\
 sec_acl_posix.h: No such file or directory
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:44:\
 sec_acl_sware.h: No such file or directory
*** Error code 1 (continuing)

In file included from
/project/dce/build/dce1.0.3-snap/src/test/rpc/runtime/v2test_lib/v2test.h:93,\
from /project/dce/build/dce1.0.3-snap/src/test/rpc/runtime/v2test_lib/v2client.c:67:
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/time.h:65:\
 sys/unix_defs.h: No such file or directory
In file included from
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/ioctl.h:284,\
from /project/dce/build/dce1.0.3-snap/src/test/rpc/runtime/v2test_lib/v2test.h:94, from\
/project/dce/build/dce1.0.3-snap/src/test/rpc/runtime/v2test_lib/crc.c:45:\
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:40:\
 sec_base.h: No such file or directory
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:41:\
 sec_priv.h: No such file or directory
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:42:\
 sec_mac_ob.h: No such file or directory
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:43:\
 sec_acl_posix.h: No such file or directory
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:44:\
 sec_acl_sware.h: No such file or directory
*** Error code 1 (continuing)
`build_all' not remade because of errors

In file included from
/project/dce/build/dce1.0.3-snap/src/test/rpc/runtime/v2test_lib/v2test.h:93,\
from /project/dce/build/dce1.0.3-snap/src/test/rpc/runtime/v2test_lib/crc.c:45:
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/time.h:65:\
 sys/unix_defs.h: No such file or directory
In file included from
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/ioctl.h:284,\
from /project/dce/build/dce1.0.3-snap/src/test/rpc/runtime/v2test_lib/v2test.h:94, from\
/project/dce/build/dce1.0.3-snap/src/test/rpc/runtime/v2test_lib/crc.c:45:\
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:40:\
 sec_base.h: No such file or directory
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:41:\
 sec_priv.h: No such file or directory
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:42:\
 sec_mac_ob.h: No such file or directory
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:43:\
 sec_acl_posix.h: No such file or directory
/project/osc/build/osc_sbox1.2/export/at386/usr/include/sys/secdefines.h:44:\
 sec_acl_sware.h: No such file or directory
*** Error code 1 (continuing)

[09/15/93 public]
This was caused by the osc_sbox1.2 having 1.1 header files in it
when it should have 1.2 header files in it.

Cris D. and I are rebuilding the export area for osc_sbox1.2.

[09/22/93 public]
The export area should now be correct for DFS.

[09/27/93 public]
DFS no longer turned on in nightly build, but verified by hand.
Closed.



CR Number                     : 8603
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : test/systest/rpc.sec.2,rpc.cds.3
Short Description             : assorted compile bugs involving
					     time variables
Reported Date                 : 9/14/93
Found in Baseline             : 1.0.3
Found Date                    : 9/14/93
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : err_track.h, chk_stat.c,
					     maintain_id.c, rep_timer.c,
					     rpc.cds.3_set_cal_uuid.c,
					     rpc.cds.3_smain.c
Sensitivity                   : public

[9/14/93 public]

[ /test/systest/rpc/rpc.sec.2 at 21:50 (PM) Monday ]

makepath rpc.sec.2/. && cd rpc.sec.2 &&  exec make MAKEFILE_PASS=BASIC
build_all
rpc.sec.2: created directory
c89 -c    -D_SHARED_LIBRARIES   -DIDL_PROTOTYPES -DRPCSEC2_SRV_REPORTING
-D__hppa -Dhp9000s800 -Dhp9000s700 -D__hp9000s800 -D__hp90\
00s700 -DHPUX -D__hpux -Dunix +DA1.0 -D_HPUX_SOURCE    -I.
-I/u3/devobj/sb/nb_ux/src/test/systest/rpc/rpc.sec.2 -I/project/dce/buil\
d/dce1.0.3-snap/src/test/systest/rpc/rpc.sec.2  -I../rpc.cds.3
-I/u3/devobj/sb/nb_ux/src/test/systest/rpc/rpc.cds.3 -I/project/dce/\
build/dce1.0.3-snap/src/test/systest/rpc/rpc.cds.3
-I/u3/devobj/sb/nb_ux/export/hp800/usr/include
-I/project/dce/build/dce1.0.3-sna\
p/export/hp800/usr/include
/project/dce/build/dce1.0.3-snap/src/test/systest/rpc/rpc.cds.3/chk_stat.c
cc:
"/project/dce/build/dce1.0.3-snap/src/test/systest/rpc/rpc.cds.3/err_track.h",
line 67: error 1000: Unexpected symbol: "time_t"\
.
cc:
"/project/dce/build/dce1.0.3-snap/src/test/systest/rpc/rpc.cds.3/chk_stat.c",
line 197: error 1000: Unexpected symbol: ")".
cc:
"/project/dce/build/dce1.0.3-snap/src/test/systest/rpc/rpc.cds.3/chk_stat.c",
line 214: error 1000: Unexpected symbol: ")".
cc:
"/project/dce/build/dce1.0.3-snap/src/test/systest/rpc/rpc.cds.3/chk_stat.c",
line 197: error 1588: "time_t" undefined.
cc:
"/project/dce/build/dce1.0.3-snap/src/test/systest/rpc/rpc.cds.3/chk_stat.c",
line 214: error 1533: Illegal function call.
*** Error code 1

c89 -c    -D_SHARED_LIBRARIES   -DIDL_PROTOTYPES -DRPCSEC2_SRV_REPORTING
-D__hppa -Dhp9000s800 -Dhp9000s700 -D__hp9000s800 -D__hp90\
00s700 -DHPUX -D__hpux -Dunix +DA1.0 -D_HPUX_SOURCE    -I.
-I/u3/devobj/sb/nb_ux/src/test/systest/rpc/rpc.sec.2 -I/project/dce/buil\
d/dce1.0.3-snap/src/test/systest/rpc/rpc.sec.2  -I../rpc.cds.3
-I/u3/devobj/sb/nb_ux/src/test/systest/rpc/rpc.cds.3 -I/project/dce/\
build/dce1.0.3-snap/src/test/systest/rpc/rpc.cds.3
-I/u3/devobj/sb/nb_ux/export/hp800/usr/include
-I/project/dce/build/dce1.0.3-sna\
p/export/hp800/usr/include
/project/dce/build/dce1.0.3-snap/src/test/systest/rpc/rpc.cds.3/maintain_id.c
e1.0.3-snap/src/test/systest/rpc/rpc.cds.3/err_track.h", line 67: error
1000: Unexpected symbol: "time_t"\
.cc:
"/project/dce/build/dce1.0.3-snap/src/test/systest/rpc/rpc.cds.3/chk_stat.c",
line 197: error 1000: Unexpected symbol: ")".
cc:
"/project/dce/build/dce1.0.3-snap/src/test/systest/rpc/rpc.cds.3/chk_stat.c",
line 214: error 1000: Unexpected symbol: ")".
cc:
"/project/dce/build/dce1.0.3-snap/src/test/systest/rpc/rpc.cds.3/chk_stat.c",
line 197: error 1588: "time_t" undefined.
cc:
"/project/dce/build/dce1.0.3-snap/src/test/systest/rpc/rpc.cds.3/chk_stat.c",
line 214: error 1533: Illegal function call.
*** Error code 1

c89 -c    -D_SHARED_LIBRARIES   -DIDL_PROTOTYPES -DRPCCDS3_SRV_REPORTING
-DRPCCDS3_AUTO_REFRESH -DRPCCDS3_DO_LOGIN -D__hppa -Dhp900\
0s800 -Dhp9000s700 -D__hp9000s800 -D__hp9000s700 -DHPUX -D__hpux -Dunix

[9/15/93 public]

Submitted the ported rpc.cds.3 file from HP.



CR Number                     : 8601
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : rpc/kruntime/OSF1_TEMPLATE
Short Description             : compile errors in krpch_conf.c
Reported Date                 : 9/14/93
Found in Baseline             : 1.0.3
Found Date                    : 9/14/93
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : krpch_conf.c
Sensitivity                   : public

[9/14/93 public]

[ /rpc/kruntime at 21:17 (PM) Monday ]

/project/dce/build/dce1.0.3-snap/tools/at386/macho/gcc \
-B/project/dce/build/dce1.0.3-snap/tools/at386/macho/  -c -DNCK -DKERNEL \
-D_KERNEL -DINET -DPROT_NCADG -DAUTH_KRB -DAUTH_KRB_DG  -DNAF_IP -D_BSD \
-DCOMPAT_43 -DMACH -D__OSF__ -DNIDL_PROTOTYPES -DIDL_PROTOTYPES -DAT386 \
-Wtrigraphs -Wcomment  -pic-none -nostdinc -pedantic -Wpointer-arith \
-I. -I/u1/devobj/sb/nb_486/src/rpc/kruntime \
-I/project/dce/build/dce1.0.3-snap/src/rpc/kruntime  -IAT386 \
-I/u1/devobj/sb/nb_486/src/rpc/kruntime/AT386 -I/project/dce/build \
/dce1.0.3-snap/src/rpc/kruntime/AT386 -IOSF1_TEMPLATE \
-I/u1/devobj/sb/nb_486/src/rpc/kruntime/OSF1_TEMPLATE \
-I/project/dce/build/dce1.0.3-snap/src/rpc/kruntime/OSF1_TEMPLATE \
-I../runtime -I/u1/devobj/sb/nb_486/src/rpc/runtime \
-I/project/dce/build/dce1.0.3-snap/src/rpc/runtime \
 -I/u1/devobj/sb/nb_486/export/at386/usr/include/kernel \
-I/project/osc/build/osc_sbox1.2/export/at386/usr/include/kernel \
-I/project/osc/build/osc_sbox1.2/export/at386/usr/include/kernel \
-I/u1/devobj/sb/nb_486/export/at386/usr/include -I/project/osc \
/build/osc_sbox1.2/export/at386/usr/include \
-I/project/osc/build/osc1.2/export/at386/usr/include \
-I/project/dce/build/dce1.0.3-snap /export/at386/usr/include \
-I/project/osc/build/osc_sbox1.2/export/at386/usr/include \
-I/project/osc/build/osc1.2/export/at386/usr/include \
/project/dce/build/dce1.0.3-snap/src/rpc/kruntime/OSF1_TEMPLATE/krpch_conf.c
/project/dce/build/dce1.0.3-snap/src/rpc/kruntime/OSF1_TEMPLATE/krpch_conf.c:28:
`nodev' undeclared, outside of functions
/project/dce/build/dce1.0.3-snap/src/rpc/kruntime/OSF1_TEMPLATE/ \
krpch_conf.c:28: parse error before `DEV_FUNNEL_NULL'
*** Error code 1 (continuing

[09/15/93 public]


fix submitted yesterday.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8600
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa, i486
S/W Ref Platform              : hpux, osf1
Component Name                : rpc
Subcomponent Name             : test/systest/rpc/rpc.sec.2, rpc.cds.3
Short Description             : no files rpc.*.?_srv, rpc.*.?_cli
Reported Date                 : 9/14/93
Found in Baseline             : 1.0.3
Found Date                    : 9/14/93
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : Makefile
Sensitivity                   : public

[9/14/93 public]

[ /test/systest/rpc/rpc.sec.2 at 22:06 (PM) Monday ]

makepath rpc.sec.2/. && cd rpc.sec.2 &&  exec make MAKEFILE_PASS=BASIC
install_all
make: don't know how to make rpc.sec.2_srv (continuing)
make: don't know how to make rpc.sec.2_cli (continuing)

[ /test/systest/rpc/rpc.cds.3 at 22:06 (PM) Monday ]

makepath rpc.cds.3/. && cd rpc.cds.3 &&  exec make MAKEFILE_PASS=BASIC
install_all
make: don't know how to make rpc.cds.3_srv (continuing)
make: don't know how to make rpc.cds.3_cli (continuing)

[9/15/93 public]

Submitted the ported rpc.cds.3 files from HP.



CR Number                     : 8587
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : app_ref
Short Description             : describe affect of null values
Reported Date                 : 9/13/93
Found in Baseline             : 1.0.2
Found Date                    : 9/13/93
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc_ns_profile_elt_remove.3rpc
Sensitivity                   : public

[9/13/93 public]
The rpc_ns_profile_elt_remove(3rpc) man page must describe the affect of
passing in a null value for the interface id (the default profile element
is removed) and what the affect is on other parameters (is member_name
ignored in this case?).

[9/24/93]

Assigned to Steve Lewontin.

[10/12/93]

Specifying NULL for the if_id removes the default profile element.
From the code, internally this results in a call to
rpc_ns_profile_elt_inq_begin() with inquiry_type set to
rpc_c_profile_default_elt.  Such a search ignores the member_name
argument.  Added text to reflect this.

[11/15/93 public]

Verified change in latest doc build and closed this CR.



CR Number                     : 8586
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : app_ref
Short Description             : formatting errors in rpc_ns_profile_elt_remove(3rpc)
Reported Date                 : 9/13/93
Found in Baseline             : 1.0.2
Found Date                    : 9/13/93
Severity                      : E
Priority                      : 4
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : app_ref/man3rpc/rpc_ns_profile_elt_remove.3rpc
Sensitivity                   : public

[9/13/93 public]
In the rpc_ns_profile_elt_remove(3rpc) man page, in the synopsis there is a
*L in the if_id parameter that should be removed.  Also in the Description
section the second paragraph has parens around entry_name that should not
be there.  Also the sentence could be improved to make it clear that any
entry that the member_name refers to is not deleted, only the reference to
it in the profile is removed.

[9/24/93 public]

Assigned this bug to myself, and fixed the formatting errors.
I rewrote the 2nd paragraph in the Description section, but
need to verify its technical accuracy with Howard before I call
the bug fixed.

[10/1/93 public]

Fixed and verified by H. Melman. Closed
this bug.



CR Number                     : 8574
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 8606
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_ref
Short Description             : status meaning useless
Reported Date                 : 9/8/93
Found in Baseline             : 1.0.2
Found Date                    : 9/8/93
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : dce/utils/misc/lib.sams
dce/utils/svc/svc.sams
dce/utils/dcecf/cfg.sams
rpc/idl/uuidgen/uid.sams
admin/dced/idl/dhd.sams
rpc/csrc/csr.sams
admin/dcecp/dcp.sams
directory/gds/sams/gds.sams
time/common/dts.sams
directory/cds/includes/cds.sams
rpc/sys_idl/rpc.sams
security/audit/libaudit/aud.sams
security/gssapi/gss_msgs.sms
Sensitivity                   : public

[9/8/93 public]
This is really a more general problem and all the man pages should be
checked for this, but here is one that bit me:

In rpc_ns_binding_export(3rpc), under the list of status code and their
values, it says that the meanings are given as well.  For
rpc_s_nothing_to_export, the "meaning" is "Nothing to export".  This does
not help me at all.  I would prefer it to say something like "no bindings
were entered to be exported" or "there was no entry name given", or
whatever the proper error is.

On this same page for rpc_s_no_ns_permission, the meaning is "No permission
for name service operation."  Well, the operation I assume is
rpc_ns_binding_export, at least as a user thats what I would expect.  I
want to know what permissions are required.  And if the operation is really
rpc_ns_binding_export then be more precise.  Say "Write permission to the
<entry_name> is required for the rpc_ns_binding_export operation.", or if
you must "for this operation".

If you want more, look at the same page for rpc_s_wrong_kind_of_binding.
The meaning doesn't add anything, and the first thing you should be asking
is "what is the right binding?  what other kinds of bindings are there?"

If you want even more, turn the pages and look at other man pages in this
section, they all follow the same pattern.

[9/24/93 public]

The existing man page rpc_status_codes(7rpc) in
the App Dev Ref provides more extensive explanations
of RPC status codes than are shown on the individual man pages.
Some explanations are better than others, but in general,
the explanations are significantly better than those
in the man pages.

However, the documentation strategy for the RPC status codes
(and the rest of the DCE APIs) will need to be revisited at DCE 1.1
in light of the DCE 1.1 serviceability project and the
planned DCE Error Messages manual. Since the strategy for
documenting status codes in man pages and the descriptions
given for each status code must be addressed at 1.1,
I am changing the "fix by" field from "1.0.3" to "1.1"
and assigning this bug to Bob Mathews (DCE 1.1 doc project
lead).

[9/24/93 public]

Added related CR 8606.

[4/18/94 public]

Reassigned this CR to Kathy Digan, who is
OSF's Problem Determination Guide writer and
error message documentation strategist.

[6/6/94 public]

Howard is correct that there is inadequate corrective action provided for
error messages and status codes.  The answer should be found in the new
Problem Determination Guide.  This new document will be a compilation of
all error messages and status codes and will contain detailed explanations
and recovery actions.  This should alliviate the problem Howard sites.

[09/22/94 public]
Closed bug.



CR Number                     : 8572
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpcd
Short Description             : rpcd should change directory into a well-known place and keep the logfile
Reported Date                 : 9/8/93
Found in Baseline             : 1.0.2
Found Date                    : 9/8/93
Severity                      : D
Priority                      : 4
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/rpcd/rpcd.c
Sensitivity                   : public

[9/8/93 public]

Although it is in RFC 34.2 (Coding Style Guide), it won't happen for rpcd
because it will be replaced by dced in DCE 1.1. But, it makes easier to
debug the RPC runtime and rpcd, if rpcd cd's into /opt/dcelocal/var/rpc and
keep the stderr output into the logfile. Here is the diffs:

--- ../../../link/src/rpc/rpcd/rpcd.c	Wed Aug 25 08:42:43 1993
+++ rpcd.c	Wed Sep  8 17:12:32 1993
@@ -191,6 +191,10 @@
 #   define rpcd_c_llb_database_name "rpcdllb.dat"
 #endif
 
+#ifndef rpcd_c_logfile_name
+#   define rpcd_c_logfile_name "rpcd.log"
+#endif
+
 
 /* 
  *  Optional list of protocol sequences which rpcd will use.
@@ -635,6 +639,34 @@
 
         setpgrp(0, getpid());
 #endif  /* SNI_SVR4_POSIX */
+        if (close(2) == 0)
+        {
+            char *fname;
+            char *p;
+
+            if ((fname = malloc(strlen(rpcd_c_database_name_prefix1) + 
+                           strlen(rpcd_c_database_name_prefix2) + 
+                           strlen(rpcd_c_logfile_name) + 1)) != NULL)
+            {
+                sprintf((char *) fname, "%s%s%s", rpcd_c_database_name_prefix1,
+                        rpcd_c_database_name_prefix2, rpcd_c_logfile_name);
+                fd = open(fname, O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
+
+                /*
+                 * We don't care if open() failed or fd != 2.
+                 */
+
+                if ((p = strrchr(fname, '/')) != NULL)
+                {
+                    *p = '\0';
+                    (void)chdir(fname);
+                    /*
+                     * Again, we don't care if chdir() failed.
+                     */
+                }
+                free(fname);
+            }
+        }
 #endif
     }

[9/28/93 public]

The fix was submitted to 1.0.3.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8569
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_gd
Short Description             : should warn against use of b'cast
Reported Date                 : 9/8/93
Found in Baseline             : 1.0.3
Found Date                    : 9/8/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : app_gd/rpc/fundamentals.gpsml app_gd/rpc/idl.gpsml
Sensitivity                   : public

[9/8/93 public]

The documentation does not say enough about the broadcast capabilities
of the RPC runtime.

In particular, it needs to say more about why broadcast is not such
a good idea.  

For example,

1. Not all systems and networks support broadcasting.

    - In particular, it is not supported by the RPC
      connection-oriented protocol

2. Broadcasts are limited to hosts on the local network.

3. Broadcasts make inefficient use of network bandwidth and
   processor cycles.

    - A client may receive responses from many servers,
      dropping all but the first.

    - Every host on the network must read in the packet.

    - When broadcasting on a partially-bound handle, all
      rpcd's on the local network must be scheduled to
      process the request packet.

4. The RPC runtime library does not support "at most once"
   semantics for broadcast operations; it applies idempotent
   semantics to all such operations.

[11/12/93 public]

Assigned this enhancement CR to Steve Lewontin and changed
"fixby" date from 1.0.3 to 1.1.

[3/29/94 public]

Reassigned this CR to John Shirley (OSF rpc writer)
from Steve Lewontin.

[04/21/94 public]
I think there is also a restriction on the size of the input argument.
Something like a single rpc pdu, but you'ld better check with the dg
rpc owner.

[4/22/94 public]

Right, the input arguments for broadcast calls are limited to 944 bytes.
There is no limit on the size of the return arguments.

[08/09/94 public]
Reassigned to myself.

[08/23/94 public]
Changed priority to "2".

[09/01/94 public]
Added the caveats about broadcasting to the following files:

app_gd/rpc/fundamentals.gpsml
app_gd/rpc/idl.gpsml

Also deleted a conflicting paragraph from fundamentals.gpsml 
that read as follows:

With the RPC communications protocols, a \*Lmaybe\*O or
\*Lbroadcast\*O call lacks guarantees; an \*Lidempotent\*O call
guarantees that the data for a remote procedure
call is received and processed in order zero
or more times; and an \*Lat-most-once\*O call guarantees that the call data
is received and processed in order zero or one time.

Verified by Tom Jordahl.

[10/20/94 public]
Closed bug.



CR Number                     : 8563
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 7750,7561
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : admin_ref
Short Description             : options wrong in unexport(8rpc)
Reported Date                 : 9/7/93
Found in Baseline             : 1.0.2
Found Date                    : 9/7/93
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : admin_ref/man8rpc/rpccp_unexport.8rpc
Sensitivity                   : public

[9/7/93 public]
The options in unexport(8rpc) mentions the -u switch and the command
doesn't take it.  The synopsis is correct.

[9/24/93 public]

CRs 7750, 7561, and this CR seem to illustrate the process
of discovery. CR7750 reported that the -u option was missing
from rpccp_unexport's synopsis but existed in the Options section.
Julie Buckler fixed and closed that bug. CR7561 reported that
the description of the -u option needed improvement. Julie
Buckler fixed and closed that bug for all the rpccp admin
commands that documented -u, including rpccp_unexport.
This CR reports that the -u option is actually not a
supported option for rpccp_unexport and that the synopsis
(which, in the 1.0.2 docs doesn't show it) is correct. 
I have removed -u from the synopsis and the text in the
source and have changed this bug to fixed. I will verify with 
Howard Melman that the code does not implement -u before
I close this bug.

[10/1/93 public]

Fixed and verified by H. Melman.
Closed this bug.

[10/1/93 public]

checked to make sure I filled in "fixed in" field
to "1.0.3."



CR Number                     : 8562
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : memory leak in get_ep_binding()
Reported Date                 : 9/7/93
Found in Baseline             : 1.0.2
Found Date                    : 9/7/93
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : runtime/comep.c
Sensitivity                   : public

[9/7/93 public]

Reported by tikku@sni-usa.com:

I have a small test program which I have enclosed in this mail.  It runs a
forever loop which creates an inquiry context to peruse through the local
endpoint map, Looks through the entire endpoint map, closes the inquiry
context. When I run this program it gains about 100K in size in about 600 
iterations.

I was wondering if you could compile and run this program with the latest 
software that you have and let me know if you are seeing a comparable gain
in size. Our RPC runtime library code is 1.0.2 based. If you don't see any
memory leaks then I am going to try and get us to update our source base
here.

We don't have anything later than May code base and hence the request.


thanks


sanjay
------
Sanjay Tikku			|Voice:		617-273-0480 ext 3470
Siemens-Nixdorf Inc.		|FAX:		617-221-0236
200 Wheeler Road		|Internet:	tikku@sni-usa.com
Burlington, MA 01803


***************cut here****************************
#include <stdio.h>
#include <dce/rpc.h>


main ()
{

   unsigned32 st, status;
   unsigned_char_p_t ann;
   rpc_ep_inq_handle_t inq_context;
   rpc_binding_handle_t binding_h;
   rpc_if_id_t ifid;
   int i;

   for (i=0; ; i++)
   {
	   printf ("Loop # %d\n",i);

	   /* Creating an inquiry context to view all elements endpoint map */
	   rpc_mgmt_ep_elt_inq_begin(NULL, rpc_c_ep_all_elts, NULL, 
					     NULL, NULL, &inq_context, &st);
	   if (st != rpc_s_ok)
	   {
		perror( "Unable to contact rpcd:");
		fflush (stdout);
		exit (1);
	   }

	   while (1)
	   {
		   rpc_mgmt_ep_elt_inq_next(inq_context, &ifid, &binding_h, 
					    NULL , &ann, &st);
	
		   rpc_string_free(&ann, &status);
		   rpc_binding_free(&binding_h, &status);
		   
		   if (st == rpc_s_no_more_elements)
				break;
	   }

	   rpc_mgmt_ep_elt_inq_done(&inq_context, &st);
   }
}

Verified by me on OSF/1:

  PID TTY      STAT        TIME       SL PAGEIN   VSZ  RSS %CPU %MEM COMMAND
15533 pts/1    R  +     0:28.56        0     42 7.36M 1.27 39.0  3.5 ./loop

15533 pts/1    R  +     0:43.19        0     44 7.43M 816K 21.7  2.2 ./loop

15533 pts/1    R  +     0:56.97        0     44 7.49M 852K 30.2  2.3 ./loop

15533 pts/1    R  +     1:45.13        0     44 7.73M 1.07 39.1  3.0 ./loop

After 4100 iterations.

Turns out the problem was a protseq_vector which wasn't getting free'd in

get_ep_binding() (in comep.c):
***************
*** 1369,1374 ****
--- 1370,1377 ----
               */
              *status = rpc_s_no_protseqs;
          }
+ 
+         rpc_protseq_vector_free(&protseq_vector, status);
      }
      else
      {

[09/07/93 public]
Code is submitted to the tree.
Closed.



CR Number                     : 8560
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : rpccp
Short Description             : rpccp show mapping core dumps when "-i" flag is missing
Reported Date                 : 9/7/93
Found in Baseline             : 1.0.2a
Found Date                    : 9/7/93
Severity                      : A
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpccp.c
Sensitivity                   : public

[9/7/93 public]

rpccp show mapping crashes on i486 (hppa is okay) when invoked 
without the "-i" flag (it doesn't make any difference what the 
value or format of the uuid is):

lobster 433 % uuidgen
004a4732-999c-1c8c-8068-0000c0eec744
lobster 434 % rpccp remove mapping 004a4732-999c-1c8c-8068-0000c0eec744

>>> command syntax error: interface required


usage: rpccp operation [options[args]] entry_name

operations:  quit (or exit)
             help
             show entry  -isu
             add entry  -s
             remove entry  -s
             show group  -mrsu
             remove group  -s
             add member  -ms
             remove member  -ms
             show profile  -adimrsuv
             remove profile  -s
             add element  -adimps
             remove element  -adims
             show server  -iosu
             export  -bios
             unexport  -iosv
             import  -einosuv
             show mapping  -iov
             remove mapping  -bio
             add mapping  -abioN

Segmentation fault (core dumped)

[09/07/93 public]
This bug looks like its been around for a while, but because we have
only been working on RISC machines, it didn't show up.

rpccp was using strcpy()'s into fixed length buffers.  When the source
string was longer than the target buffer, the stack got trashed.
It should be using strncpy().

In particular:

	strcpy (command_name, argv[1]);

where command name is a local variable.

Fixed and submitted.



CR Number                     : 8546
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_gd
Short Description             : rpccp description inadequate
Reported Date                 : 9/1/93
Found in Baseline             : 1.0.2
Found Date                    : 9/1/93
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : app_gd/rpc/2_components.gpsml
Sensitivity                   : public

[9/1/93 public]
Section 10.7 of the App Dev Guide describes rpccp in 1 paragraph and three
example input lines.  It should describe all the commands, or refer to
someplace that does (the man page, or a section in the admin_gd, see
another bug I opened on that).

It's probably sufficient to refer to a man page for developers.  They will
need to know how to view/modify NSI objects while testing their
applications.  This is how this documentation should be biased.

[9/15/93]

Assigned this bug to myself.

[10/13/93]

Fixed. Will ask H. Melman to verify.

[10/13/93]

Fixed and verified by H. Melman. Will
check output for formatting errors after
weekly build before closing this bug.

[11/11/93 public]

Verified change in latest doc build and closed this CR.



CR Number                     : 8545
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : admin_gd
Short Description             : description of rpccp needs improvement
Reported Date                 : 9/1/93
Found in Baseline             : 1.0.2
Found Date                    : 9/1/93
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : admin_gd/rpc/rpc/appl_admin.gpsml
Sensitivity                   : public

[9/1/93 public]
Looking at the Admin Guide-Core book I see that there is frightfully little
on rpccp there.  The entire RPC chapter is 8 pages, the first 5 of which is
rpcd. 

Section 1.3 discusses in brief the rpccp commands.  This section needs to
be improved.  First a discussion of the different types of NSI Namespace
objects (entries, groups, profiles), needs to be added or at least a
reference to the app_gd (chap 15 is quite good) should be included.  My
preference is a rewrite with a bent toward what a sys admin would need to
know.  

Then each command should be described and an example shown.  It should be
biased to what a sys admin would need to do, e.g., how to set up profiles
at your site and how to tell users to setup/modify their own personal
profiles.  Examples (WITH OUTPUT!) should be included.

[9/15/93 public]

The 1.0.2 version of DCE Administration Guide/Core Components,
Section 1.3 "RPC Control Program" does contain a (generic)
pointer to the chapter on NSI usage, as this CR suggests.

I consulted with Bob Mathews to determine how to resolve this
CR. Bob agrees that improving the rpccp administration documentation
is desirable, but he feels (and I concur) that the CR should be 
considered an enhancement. Because the OSF doc group has limited
time and resources, they cannot address this enhancement for 1.0.3.
As a result, I am changing the CR from "def" to "enh" and "fixby"
from "1.0.3" to "1.1". The doc group will revisit the rpccp
administration documentation and this enhancement request
as part of its DCE 1.1 revision to include the dcecp administration
information.

[11/5/93 public]

Steve Lewontin rightly pointed out that he should not be
assigned to this bug. I am reassigning this bug to Bob
Mathews until a new owner for the control program
administration documentation is found (Larry Kaplan
is the present owner, but only for a few more hours...)

[3/29/94 public]

Assigned this CR to Ward Rosenberry (OSF dcecp writer).

[8/31/94]
The RPC name service operations are now documented in the new Part III 
of the Administration Guide Core volume. Setting this CR to verified.

[9/23/94]
The original CR wanted a complete explanation of how to perform rpccp name
service operations. Although the 1.1 description replaces rpccp with dcecp,
the explanation of these operations is now complete.

[09/29/94 public]
Closed bug.



CR Number                     : 8541
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : wrong TSH function was used to test success
Reported Date                 : 8/31/93
Found in Baseline             : 1.0.3
Found Date                    : 8/31/93
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b18
Affected File(s)              : test/rpc/rtandidl/moretests/set_inq_auth_info.c,moretests/control/set_auth_info.tsh
Sensitivity                   : public

[8/31/93 public]

Full Description:

customer attempted to run the tests in set_auth_info.tsh on a version of
the rpc runtime (NOENCRYPTION) which doesn't allow allow packet privacy
as one of the supported protection levels. To their surprise all of the
tests passed. They looked into it, and found TestFunction() in
set_inq_auth_info.c to be using the wrong TSH function to test success
of some RPC API operations. The result being that TestFunction would exit
the test case with an rpc_s_ok status without having performed the
intended test. Furthermore, each test would be reported to have been
completed successfully.

More detail:

    * TSHMessage doesn't return a value, so when it's return
    * value is used as an expression in an if statement, the result
    * is likely to be (non zero) and thus true, idependent of the
    * real status of rpc_string_binding_compose(). This enables
    * the cleanup branch, which in most cases will cause the test
    * to return rpc_s_ok which interpretted by the test harness to
    * mean the test completed successfully even though the real
    * function under test was never run.
    *
    * Changing this TSHMessage to TSHStatus, should fix this problem
    *

Customer repaired this problem, along with some others (see details
below), and reran set_auth_info.tsh (on an RPC runtime which DID
allow for packet privacy) and got failures on the following
test cases:

	62, 63, 67, 68, 69, 99, 100, 111, 112, 123, 124,
	135, 136, 147, 148, 150, 151, 155, 156, 157, 159,
	160, 162, 163, 171, 172

The customer investigated the cause of these failures and concluded
that, in all cases, the failure could be attributed to an error in
set_auth_info.tsh expected status value for the failing test cases.

A synopsis of the test case particulars, the expected status
return, and the actual status return are listed at the end of
this mail. The corresponding corections should be made
to set_auth_info.tsh.

Other problems encountered/repaired:

	1) made change so that test arguments are clearly displayed

        2) fixed a null server principal name bug. If the test case
           called for the use of a NULL server principal name, an internal
           flag would be set in set_inq_auth_info, but never used.

           this was fixed by declaring a local variable into which a
           copy of the the server name passed as one of the test
           arguments was transferred.

           sec_rgy_name_t       tmp_server_name;

           This variable needs to contain a \'0' terminated character
           string even in the NULL server principal name case, since
           the RPC and security API's don't handle a null pointer very
           well.

           Use of a NULL pointer resulted in connection and communication
           failures. In the case of the null server name test cases, a
           0 length string is assigned to tmp_server_name.

Proposed Solution:

Changes to make to set_inq_auth_info.c

***
/project/dce/build/dce1.0.3/src/test/rpc/rtandidl/moretests/set_inq_auth_info.c
Wed Aug 25 09:33:30 1993
--- set_inq_auth_info.c	Tue Aug 31 11:10:21 1993
***************
*** 176,183 ****
        authn_svc = atol(argv[9]);
        authz_svc = atol(argv[10]);
  
!       TSHMessage(ctx, MOINFO, "7=%d 8=%d 9=%d\n",
!               atol(argv[7]), atol(argv[8]), atol(argv[9]));
  
        /* Adjust input values as necessary. */
  
--- 176,183 ----
        authn_svc = atol(argv[9]);
        authz_svc = atol(argv[10]);
  
!       TSHMessage(ctx, MOINFO, "7=%s 8=%d 9=%d 10=%d\n",
!               argv[7], atol(argv[8]), atol(argv[9]), atol(argv[10]));
  
        /* Adjust input values as necessary. */
  
***************
*** 317,323 ****
     	"rpc_binding_from_string_binding status: %d\n", tstatus);
  
     if (TSHStatus (ctx, SETUP,
!              "rpc_binding_from_string_binding failed", tstatus, rpc_s_ok)) {
        clean_up (ctx, client_name, server_name);
        return tstatus;
     }
--- 317,324 ----
     	"rpc_binding_from_string_binding status: %d\n", tstatus);
  
     if (TSHStatus (ctx, SETUP,
!              "rpc_binding_compose failed", tstatus, rpc_s_ok))
!    {
        clean_up (ctx, client_name, server_name);
        return tstatus;
     }
***************
*** 333,338 ****
--- 334,349 ----

     if (subcase != INQ_AUTH_INFO_WO_SETUP) {
  
+            sec_rgy_name_t	tmp_server_name;
+
+ 	   tmp_server_name[0] = '\0';
+ 	   if (servname_flag)
+ 		strcpy(tmp_server_name, server_name);
+ 
+ 	   TSHMessage(ctx,MOINFO,
+ 	      "tmp_server_name: %s, server_name: %s\n",
+ 		      tmp_server_name, server_name);
+ 
        /*
         * If this is the rpc_binding_set_auth_info test and the
         * rpc_s_invalid_binding pathological case, make an invalid handle.
Note
***************
*** 343,349 ****
        if ((subcase == SET_AUTH_INFO) && (estatus ==
rpc_s_invalid_binding))
     	binding = (rpc_binding_handle_t)NULL;
  
!       rpc_binding_set_auth_info (binding, server_name, authn_level,
        	authn_svc, auth_id, authz_svc, &tstatus);
  
        TSHMessage(ctx,MOTRACE,"rpc_binding_set_auth_info status: %d\n",
--- 354,360 ----
        if ((subcase == SET_AUTH_INFO) && (estatus == rpc_s_invalid_binding))
     	binding = (rpc_binding_handle_t)NULL;
  
!       rpc_binding_set_auth_info (binding, tmp_server_name, authn_level,
        	authn_svc, auth_id, authz_svc, &tstatus);
  
        TSHMessage(ctx,MOTRACE,"rpc_binding_set_auth_info status: %d\n",
***************
*** 359,369 ****
        	if (estatus == tstatus)
        		tstatus = rpc_s_ok;
        	else
!       		TSHMessage (ctx, MOFAILURE, "rpc_binding_set_auth_info failed\n");
        }
        else {
        	if (tstatus != rpc_s_ok)
!       		TSHMessage (ctx, SETUP, "rpc_binding_set_auth_info failed\n");
        }
  
     } /* End if (subcase != INQ_AUTH_INFO_WO_SETUP) */
--- 370,382 ----
        	if (estatus == tstatus)
        		tstatus = rpc_s_ok;
        	else
!       		TSHStatus (ctx, MOFAILURE, "rpc_binding_set_auth_info failed\n",
! 			estatus, tstatus);
        }
        else {
        	if (tstatus != rpc_s_ok)
!       		TSHStatus (ctx, SETUP, "rpc_binding_set_auth_info failed\n",
! 			estatus, tstatus);
        }
  
     } /* End if (subcase != INQ_AUTH_INFO_WO_SETUP) */


---------------------------

Corrections to be made to set_auth_info.tsh:

Failing Test Case Synopsis and Status Return Values. expect results are
those in set_auth_info.tsh

	62: protect level: packet privacy, authn svc: private,
	    authz svc: name, non-null server principal name

	test case expected result: rpc_s_authn_authz_mismatch
	test case actual result: rpc_s_ok

	-----------------------------------------------------
	63: protect level: packet privacy, authn svc: private,
	    authz svc: dce, non-null server principal name

	test case expected result: rpc_s_authn_authz_mismatch
	test case actual result: rpc_s_ok
	-----------------------------------------------------
	67: protect level: packet privacy, authn svc: none,
	    authz svc: none, non-null server principal none

	test case expected result: rpc_s_authn_authz_mismatch
	test case actual result: rpc_s_ok
	-----------------------------------------------------
	68: protect level: packet privacy, authn svc: none,
	    authz svc: name, non-null server principal name

	test case expected result: rpc_s_authn_authz_mismatch
	test case actual result: rpc_s_ok
	-----------------------------------------------------
	69: protect level: packet privacy, authn svc: none,
	    authz svc: dce, non-null server principal name

	test case expected result: rpc_s_authn_authz_mismatch
	test case actual result: rpc_s_ok
	-----------------------------------------------------
	99: protect level: default (integrity), authn svc: default (private),
	    authz svc: name, null server principal name

	test case expected result: rpc_s_ok
	test case actual result: sec_s_null_param_illegal
	-----------------------------------------------------
	100: protect level: default (integrity), authn svc: default (private),
	    authz svc: dce, null server principal name

	test case expected result: rpc_s_ok
	test case actual result: sec_s_null_param_illegal
	-----------------------------------------------------
	111: protect level: connect, authn svc: default (private),
	    authz svc: name, null server principal name

	test case expected result: rpc_s_ok
	test case actual result: sec_s_null_param_illegal
	-----------------------------------------------------
	112: protect level: connect, authn svc: default (private),
	    authz svc: dce, null server principal name

	test case expected result: rpc_s_ok
	test case actual result: sec_s_null_param_illegal
	-----------------------------------------------------
	123: protect level: call, authn svc: default (private),
	    authz svc: name, null server principal name

	test case expected result: rpc_s_ok
	test case actual result: sec_s_null_param_illegal
	-----------------------------------------------------
	124: protect level: call, authn svc: default (private),
	    authz svc: dce, null server principal name

	test case expected result: rpc_s_ok
	test case actual result: sec_s_null_param_illegal
	-----------------------------------------------------
	135: protect level: packet, authn svc: default (private),
	    authz svc: name, null server principal name

	test case expected result: rpc_s_ok
	test case actual result: sec_s_null_param_illegal
	-----------------------------------------------------
	136: protect level: packet, authn svc: default (private),
	    authz svc: dce, null server principal name

	test case expected result: rpc_s_ok
	test case actual result: sec_s_null_param_illegal
	-----------------------------------------------------
	147: protect level: integrity, authn svc: default (private),
	    authz svc: name, null server principal name

	test case expected result: rpc_s_ok
	test case actual result: sec_s_null_param_illegal
	-----------------------------------------------------
	148: protect level: integrity, authn svc: default (private),
	    authz svc: dce, null server principal name

	test case expected result: rpc_s_ok
	test case actual result: sec_s_null_param_illegal
	-----------------------------------------------------
	150: protect level: privacy, authn svc: private,
	    authz svc: name, null server principal name

	test case expected result: rpc_s_ok
	test case actual result: sec_s_null_param_illegal
	-----------------------------------------------------
	151: protect level: privacy, authn svc: private,
	    authz svc: dce, null server principal name

	test case expected result: rpc_s_ok
	test case actual result: sec_s_null_param_illegal
	-----------------------------------------------------
	155: protect level: privacy, authn svc: none,
	    authz svc: none, null server principal name

	test case expected result: rpc_s_unsupported_protect_level
	test case actual result: rpc_s_ok
	-----------------------------------------------------
	156: protect level: privacy, authn svc: none,
	    authz svc: name, null server principal name

	test case expected result: rpc_s_unsupported_protect_level
	test case actual result: rpc_s_ok
	-----------------------------------------------------
	157: protect level: privacy, authn svc: none,
	    authz svc: dce, null server principal name

	test case expected result: rpc_s_unsupported_protect_level
	test case actual result: rpc_s_ok
	-----------------------------------------------------
	159: protect level: privacy, authn svc: default (private),
	    authz svc: name, null server principal name

	test case expected result: rpc_s_ok
	test case actual result: sec_s_null_param_illegal
	-----------------------------------------------------
	160: protect level: privacy, authn svc: default (private),
	    authz svc: dce, null server principal name

	test case expected result: rpc_s_ok
	test case actual result: sec_s_null_param_illegal
	-----------------------------------------------------
	162: protect level: none, authn svc: private,
	    authz svc: name, null server principal name

	test case expected result: rpc_s_ok
	test case actual result: sec_s_null_param_illegal
	-----------------------------------------------------
	163: protect level: none, authn svc: private,
	    authz svc: dce, null server principal name

	test case expected result: rpc_s_ok
	test case actual result: sec_s_null_param_illegal
	-----------------------------------------------------
	171: protect level: none, authn svc: default (private),
	    authz svc: name, null server principal name

	test case expected result: rpc_s_ok
	test case actual result: sec_s_null_param_illegal
	-----------------------------------------------------
	172: protect level: none, authn svc: default (private),
	    authz svc: dce, null server principal name

	test case expected result: rpc_s_ok
	test case actual result: sec_s_null_param_illegal
 -------------------------------------------------------------------------

[9/22/93 public]

        The following is intended to clarify what was written in 2) above
        regarding tests performed via set_auth_info.tsh with null server
        principal names.

        set_auth_info.tsh contains 176 tests, the second 88 differ
        from the first 88 only in that they are expected to call
        rpc_binding_set_auth_info with a NULL pointer for server name.
        rpc_binding_set_auth_info chokes when passed a NULL pointer
        for server name so the set_inq_auth_info.c implementation
        of TestFunction ignores the $USE_SERVNAME/$NULL_SERVNAME passed
        down from set_auth_info.tsh. The result is that the same 88
        tests are performed twice, and the tests being performed in the
        second 88 are actually misrepresented in the report.

	The submitter of this defect, working under the assumption that
        their was something meaningful to test in the line of NULL
        server names, suggested modifications to the test code to
        use a zero length string when NULL_SERVER name was specified.
        They also suggested that rpc_binding_set_auth_info be 
        hardened to reject NULL server names. 

	I think the correct thing to do, is to remove the second 88
        tests form the set_auth_info.tsh (modulo changes being made for
        TET), and leave rpc_binding_set_auth_info alone.

	Note that the more significant problem reported in this defect,
        the use of TSHMessage(a procedure) as a function remains to be
        fixed.

[8/29/94 public]

rpc_binding_set_auth_info() has the unsupported "null server principal
name" feature. See test/rpc/runtime/perf/client.c for the sample usage.

[9/1/94 public]
Humm.. So I ran the tests with the server_name==NULL, but the
failure I am seeing is: Connection request rejected (dce / rpc)

Looking at the set_auth_info code we see that the NULL name feature
only works if rpc_c_authn_dce_secret is being used:

    if (authn_protocol == rpc_c_authn_dce_secret &&
        server_princ_name == NULL)
    {
        rpc_mgmt_inq_server_princ_name
            (binding_h,
             authn_protocol,
             &server_princ_name,
             st);

        if (*st != rpc_s_ok)
            return;

        need_to_free_server_name = true;
    }

I think we would be wise to remove these tests.
Comments?

[9/13/94 public]
Removed the NULL server tests, but fixed the test to actually pass
a NULL to rpc_binding_set_auth_info() is the command line arguments
call for it.

Fixed up expect results.

Fixed up test source to use correct TSH status function.



CR Number                     : 8539
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 8451
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rpcd endpoint map behavior needs to be documented for 1.0.3
Reported Date                 : 8/30/93
Found in Baseline             : 1.0.3
Found Date                    : 8/30/93
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : port_gd
Sensitivity                   : public

[8/30/93 public]

There will be a change to rpcd in 1.0.3 such that it will reject
requests from remote hosts to add/delete endpoints from the
endpoint map.  This is to minimize the security hole present
in previous version of DCE where any unauthenticated user
could (via a program or rpccp) add or delete endpoints.

See ot 8451 for other interesting details.

An ifdef (REMOTE_ENDPOINT_ACCESS) needs to be documented
in the release notes (or porting guide).  By default, it is not
defined, which gives the new behavior.  If turned on, the behavior
is the same as 1.0.2 and earlier.

This change affects the rpccp 'add mapping' and 'remove mapping' commands.

The ifdef is relevant for rpcd and rpccp.  If defined for rpcd,
it will reject remote requests to modify (but not read) the endpoint
map.  If defined for rpccp, the help message remove mapping will not 
show the [host-address] argument.

This documentation will probably not be needed for 1.1, as dced will replace
rpcd, and will add security/acl stuff on to the endpoint map.
This is 1.0.3 item only.

[08/31/93 public]
Since this is a 1.0.3 item, it gets to be P1.

[9/9/93 public]

Assigned bug to Doug Weir (1.0.3 Porting Guide writer).

[09/23/93 public]
Fixed, and verified by Tom Jordahl.

[11/12/93 public]

Verified changes in latest doc build and closed this CR.



CR Number                     : 8534
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : test/rpc/rtandidl/moretests
Short Description             : don't knwo how to make tstdriver
Reported Date                 : 8/30/93
Found in Baseline             : 1.0.3
Found Date                    : 8/30/93
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : comtest_client_xfr.c
Sensitivity                   : public

[8/30/93 public]

[ /test/rpc/rtandidl/moretests at 04:24 (AM) Monday ]

release   -o bin -g bin -m 755 -tostage \
/u1/devobj/sb/nb_rios/src/../install/ri\os/dcetest/dce1.0 \
-fromfile mgmt_stop_server_listening \
/rpc/rtandidl/moretests/\mgmt_stop_server_listening 
/rpc/rtandidl/moretests/mgmt_stop_server_listening: copying from \
mgmt_stop_serv\er_listening
/rpc/rtandidl/moretests/mgmt_stop_server_listening: owner bin, group bin, mode \0755
/rpc/rtandidl/moretests/mgmt_stop_server_listening: installing as \
/u1/devobj/sb\/nb_rios/src/../install/rios/dcetest/dce1.0/rpc/rtandidl/moretests/mgmt_stop_se\rver_listening
make: don't know how to make tstdriver (continuing)

[08/30/93 public]
This is a side affect of not being able to build comtest_client_xfr.o, which
prevented tstdriver from being built.

This is fixed as of today (built on 486 and RIOS).



CR Number                     : 8524
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : Makefiles
Short Description             : Functional test files installed in wrong place
Reported Date                 : 08/27/93
Found in Baseline             : 1.0.3
Found Date                    : 08/27/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : ./test/rpc/rtandidl/moretests/Makefile ./test/rpc/rtandidl/testsh/Makefile
Sensitivity                   : public

[08/27/93 public]

The following files are installed in "install/<mach>/dcetest/dce1.0"
instead of "install/<mach>/dcetest/dce1.0/test/...".  This is most
likely a problem with IDIR in the Makefiles:

rpc/rtandidl/moretests/mgmt_set_server_stack
rpc/rtandidl/moretests/if_reg_auth_info
rpc/rtandidl/moretests/sofserv
rpc/rtandidl/moretests/svr_reg_auth_info
rpc/rtandidl/moretests/rpc_server
rpc/rtandidl/moretests/binding_server_to_client
rpc/rtandidl/moretests/mgmt_inq_stats
rpc/rtandidl/moretests/mgmt_set_authz_fn
rpc/rtandidl/moretests/object_inq_type
rpc/rtandidl/moretests/enumc
rpc/rtandidl/moretests/scalc
rpc/rtandidl/moretests/ihc
rpc/rtandidl/moretests/mgmt_inq_dflt_authn_level
rpc/rtandidl/moretests/set_inq_auth_info
rpc/rtandidl/moretests/sofservclient
rpc/rtandidl/moretests/recc
rpc/rtandidl/moretests/strzc
rpc/rtandidl/moretests/specc
rpc/rtandidl/moretests/iattrc
rpc/rtandidl/moretests/pattrc
rpc/rtandidl/moretests/aryc
rpc/rtandidl/moretests/object_set_type
rpc/rtandidl/moretests/tattrc
rpc/rtandidl/moretests/rattrc
rpc/rtandidl/moretests/vrecc
rpc/rtandidl/moretests/pipec
rpc/rtandidl/moretests/outoflinec
rpc/rtandidl/moretests/repasc
rpc/rtandidl/moretests/stringc
rpc/rtandidl/moretests/uuid_from_string
rpc/rtandidl/moretests/uuid_compare
rpc/rtandidl/moretests/uuid_create
rpc/rtandidl/moretests/uuid_create_nil
rpc/rtandidl/moretests/uuid_equal
rpc/rtandidl/moretests/uuid_to_string
rpc/rtandidl/moretests/uuid_hash
rpc/rtandidl/moretests/uuid_is_nil
rpc/rtandidl/moretests/network_inq_protseqs_valid
rpc/rtandidl/moretests/string_binding_compose
rpc/rtandidl/moretests/string_binding_parse
rpc/rtandidl/moretests/binding_from_string
rpc/rtandidl/moretests/string_free
rpc/rtandidl/moretests/binding_copy
rpc/rtandidl/moretests/binding_free
rpc/rtandidl/moretests/mgmt_server
rpc/rtandidl/moretests/binding_inq_object
rpc/rtandidl/moretests/binding_reset
rpc/rtandidl/moretests/binding_set_object
rpc/rtandidl/moretests/binding_vector_free
rpc/rtandidl/moretests/error_inq_text
rpc/rtandidl/moretests/mgmt_inq_com_timeout
rpc/rtandidl/moretests/network_inq_protseqs
rpc/rtandidl/moretests/ns_mgmt_binding_unexport
rpc/rtandidl/moretests/group_mbr_add_remove
rpc/rtandidl/moretests/group_mbr_inquiry
rpc/rtandidl/moretests/ns_profile_elt_add
rpc/rtandidl/moretests/ns_profile_elt_inq
rpc/rtandidl/moretests/ns_profile_delete
rpc/rtandidl/moretests/ns_mgmt_entry_create
rpc/rtandidl/moretests/ns_mgmt_entry_delete
rpc/rtandidl/moretests/mgmt_set_com_timeout
rpc/rtandidl/moretests/ns_binding_import
rpc/rtandidl/moretests/ns_binding_export
rpc/rtandidl/moretests/ns_binding_lookup
rpc/rtandidl/moretests/ns_binding_select
rpc/rtandidl/moretests/ns_binding_unexport
rpc/rtandidl/moretests/ns_entry_object_inq
rpc/rtandidl/moretests/ns_entry_inq_if_ids
rpc/rtandidl/moretests/mgmt_ep_elt_inq
rpc/rtandidl/moretests/mgmt_inq_if_ids
rpc/rtandidl/moretests/tstsrvr
rpc/rtandidl/moretests/mgmt_stop_server_listening
rpc/rtandidl/moretests/tstdriver
rpc/rtandidl/moretests/server
rpc/rtandidl/moretests/ns_mgmt_exp_age
usr/include/dce/testsh

[9/24/93 public]
This was originally opened as a 'bld' defect and covered tests in CDS and
file, as well.  I've created two other defects to cover CDS and DFS and
have recaste this one as an RPC defect

[09/27/93 public]
Removed the IDIR variables from the Makefiles.
Verified by building and installing rtandidl.
Closed.



CR Number                     : 8520
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : test/rpc/idl/n_e_union
Short Description             : pointer initialization problem
Reported Date                 : 8/27/93
Found in Baseline             : 1.0.3
Found Date                    : 8/27/93
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : manager.c
Sensitivity                   : public

[8/27/93 public]

xlc -c       -Dunix -D_ALL_SOURCE -DNO_SIOCGIFADDR -D_ALL_SOURCE -DAIX32 \
-I. -I/u1/devobj/sb/nb_rios/src/test/rpc/idl/n_e_union \
 -I/u1/devobj/sb/nb_rios/src/test/rpc/idl/n_e_union \
-I.. -I/u1/devobj/sb/nb_rios/src/test/rpc/idl \
-I/u1/devobj/sb/nb_rios/src/test/rpc/idl \
-I/u1/devobj/sb/nb_rios/export/rios/usr/include \
../../../../../../src/test/rpc/idl/n_e_union/manager.c
"../../../../../../src/test/rpc/idl/n_e_union/manager.c", line 150.5: \
1506-196 (S) Initialization between types pointer and pointer is not allowed.
"../../../../../../src/test/rpc/idl/n_e_union/manager.c", line 153.5: \
1506-196 (S) Initialization between types pointer and pointer is not allowed.
"../../../../../../src/test/rpc/idl/n_e_union/manager.c", line 155.5: \
1506-196 (S) Initialization between types pointer and pointer is not allowed.
*** Error code 1 (continuing)
`build_all' not remade because of errors.

In manager.c:

/*globaldef*/ n_e_union_v0_0_epv_t n_e_union_v0_0_m_epv =
{
    s_param_by_value,                   line 150
    s_param_by_ref,
    s_in_struct,
    s_ptr_union_val_discrim,            line 153
    s_ptr_union_ref_discrim,
    s_union_unique_ref_discrim,         line 155
    s_in_multi,
    s_array_op
};

[11/12/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8519
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : test/rpc/idl/mtsaconf
Short Description             : incompatible pointer types, etc.
Reported Date                 : 8/27/93
Found in Baseline             : 1.0.3
Found Date                    : 8/27/93
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : client_aux.c, manager.c
Sensitivity                   : public

[8/27/93 public]

xlc -c       -Dunix -D_ALL_SOURCE -DNO_SIOCGIFADDR -D_ALL_SOURCE -DAIX32
-I. -I/u1/devobj/sb/nb_rios/src/test/rpc/idl/mtsaconf \
-I/u1/devobj/sb/nb_rios/src/test/rpc/idl/mtsaconf-I.. -I/u1/devobj/sb/nb_rios/src/test/rpc/idl -I/u1/devobj/sb/nb_rios/src/test/rpc/idl -I/u1/devobj/sb/nb_rios/export/rios/usr/include    ../../../../../../src/test/rpc/idl/mtsaconf/client_aux.c
"../../../../../../src/test/rpc/idl/mtsaconf/client_aux.c", line 112.44: \
1506-193 (E) Function call argument cannot be assigned to corresponding parameter.
"../../../../../../src/test/rpc/idl/mtsaconf/client_aux.c", line 145.25: \
1506-193 (E) Function call argument cannot be assigned to corresponding parameter.
"../../../../../../src/test/rpc/idl/mtsaconf/client_aux.c", line 206.12: \
1506-016 (E) Operands must be pointers to compatible types.
"../../../../../../src/test/rpc/idl/mtsaconf/client_aux.c", line 218.12: \
1506-016 (E) Operands must be pointers to compatible types.
"../../../../../../src/test/rpc/idl/mtsaconf/client_aux.c", line 248.12: \
1506-016 (E) Operands must be pointers to compatible types.
xlc          -L.. -L/u1/devobj/sb/nb_rios/src/test/rpc/idl \
-L/u1/devobj/sb/nb_rios/src/test/rpc/idl -L/u1/devobj/sb/nb_rios/export/rios/usr/lib       -o client.X client.o mtsaconf_cstub.o  client_aux.o  -lidltest -ld\
ce -lbsd
mv client.X client
sed -e "s/TESTCASE/mtsaconf/"
../../../../../../src/test/rpc/idl/server.tmpl > server.c
xlc -c       -Dunix -D_ALL_SOURCE -DNO_SIOCGIFADDR -D_ALL_SOURCE -DAIX32 \
-I. -I/u1/devobj/sb/nb_rios/src/test/rpc/idl/mtsaconf \
-I/u1/devobj/sb/nb_rios/src/test/rpc/idl/mtsaconf -I.. \
-I/u1/devobj/sb/nb_rios/src/test/rpc/idl \
-I/u1/devobj/sb/nb_rios/src/test/rpc/idl \
-I/u1/devobj/sb/nb_rios/export/rios/usr/include    server.c
xlc -c       -Dunix -D_ALL_SOURCE -DNO_SIOCGIFADDR -D_ALL_SOURCE -DAIX32
-I. -I/u1/devobj/sb/nb_rios/src/test/rpc/idl/mtsaconf \
-I/u1/devobj/sb/nb_rios/src/test/rpc/idl/mtsaconf \
-I.. -I/u1/devobj/sb/nb_rios/src/test/rpc/idl \
-I/u1/devobj/sb/nb_rios/src/test/rpc/idl \
-I/u1/devobj/sb/nb_rios/export/rios/usr/include \
../../../../../../src/test/rpc/idl/mtsaconf/manager.c
"../../../../../../src/test/rpc/idl/mtsaconf/manager.c", line 159.12: \
1506-016 (E) Operands must be pointers to compatible types.
"../../../../../../src/test/rpc/idl/mtsaconf/manager.c", line 194.16: \
1506-016 (E) Operands must be pointers to compatible types.
"../../../../../../src/test/rpc/idl/mtsaconf/manager.c", line 236.10: \
1506-196 (S) Initialization between types pointer and pointer is not allowed.
"../../../../../../src/test/rpc/idl/mtsaconf/manager.c", line 230.10: \
1506-196 (S) Initialization between types pointer and pointer is not allowed.
*** Error code 1 (continuing)
`build_all' not remade because of errors.

In manager.c:

    idl_short_float *flptr1, *flptr2;

    flptr1 = &(p_mc->a);        line 159

    idl_long_float *dbrowi, *dbcoli, *dbrowo, *dbcolo;

        dbrowi = &(p_mo->d);    line 194

/*globaldef*/ mtsaconf_v0_0_epv_t mtsaconf_v0_0_m_epv =
        {s_op0,                 line 230
         s_op1,
         s_op2,
         s_op3,
         s_op4,
         s_op5,
         s_op6};                line 236

[11/12/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8518
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : test/rpc/rtandidl/moretests
Short Description             : varrectest_op4 redeclared
Reported Date                 : 8/27/93
Found in Baseline             : 1.0.3
Found Date                    : 8/27/93
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : vrecm.c
Sensitivity                   : public

[8/27/93 public]

cc -c       -Dunix -D_ALL_SOURCE -DNO_SIOCGIFADDR  -D_ALL_SOURCE -DAIX32 \
-I. -I/u1/devobj/sb/nb_rios/src/test/rpc/rtandidl/moretests \
-I/u1/devobj/sb/nb_rios/src/test/rpc/rtandidl/moretests -I/u1/devobj/sb/nb_rios/export/rios/usr/include
../../../../../../src/test/rpc/rtandidl/moretests/vrecm.c \
"../../../../../../src/test/rpc/rtandidl/moretests/vrecm.c", line 262.6: \
1506-132 (S) Function varrectest_op4 cannot be redeclared.

[11/12/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8517
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : src/test/rpc/rtandidl/moretests
Short Description             : scalartest_op11 redeclared
Reported Date                 : 8/27/93
Found in Baseline             : 1.0.3
Found Date                    : 8/27/93
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : scalm.c
Sensitivity                   : public

[8/27/93 public]

c -c       -Dunix -D_ALL_SOURCE -DNO_SIOCGIFADDR  -D_ALL_SOURCE -DAIX32
-I. -I/u1/devobj/sb/nb_rios/src/t\
est/rpc/rtandidl/moretests
-I/u1/devobj/sb/nb_rios/src/test/rpc/rtandidl/moretests
-I/u1/devobj/sb/nb_rios/\
export/rios/usr/include
../../../../../../src/test/rpc/rtandidl/moretests/scalm.c
"../../../../../../src/test/rpc/rtandidl/moretests/scalm.c", line 308.6:
1506-132 (S) Function scalartest_op\
11 cannot be redeclared.

Line 308 in scalm.c is:

	void scalartest_op11

[11/12/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8516
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : test/rpc/rtandidl/moretests
Short Description             : unexpected argument in function call
Reported Date                 : 8/27/93
Found in Baseline             : 1.0.3
Found Date                    : 8/27/93
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : comtest_client_xfr.c
Sensitivity                   : public

[8/27/93 public]

c -c       -Dunix -D_ALL_SOURCE -DNO_SIOCGIFADDR  -D_ALL_SOURCE -DAIX32
-I. -I/u1/devobj/sb/nb_rios/src/t\
est/rpc/rtandidl/moretests
-I/u1/devobj/sb/nb_rios/src/test/rpc/rtandidl/moretests
-I/u1/devobj/sb/nb_rios/\
export/rios/usr/include
../../../../../../src/test/rpc/rtandidl/moretests/comtest_client_xfr.c
"../../../../../../src/test/rpc/rtandidl/moretests/comtest_client_xfr.c",
line 685.58: 1506-099 (S) Unexpect\
ed argument.
"../../../../../../src/test/rpc/rtandidl/moretests/comtest_client_xfr.c",
line 686.41: 1506-099 (S) Unexpect\
ed argument.
"../../../../../../src/test/rpc/rtandidl/moretests/comtest_client_xfr.c",
line 687.41: 1506-099 (S) Unexpect\
ed argument.
"../../../../../../src/test/rpc/rtandidl/moretests/comtest_client_xfr.c",
line 688.41: 1506-099 (S) Unexpect\
ed argument.
"../../../../../../src/test/rpc/rtandidl/moretests/comtest_client_xfr.c",
line 689.41: 1506-099 (S) Unexpect\
ed argument.

Lines 685-689 in comtest_client_xfr.c are:

                          ( (vararg_fn_t)(*object_ptr)) (binding_h,
                                        COMTST_client_more_tsts,
                                        (sstring_t *)COMTST_obj_buf,
                                        &omsg,
                                        status);

"../../../../../../src/test/rpc/rtandidl/moretests/comtest_client_xfr.c",
line 735.50: 1506-099 (S) Unexpect\
ed argument.
"../../../../../../src/test/rpc/rtandidl/moretests/comtest_client_xfr.c",
line 736.33: 1506-099 (S) Unexpect\
ed argument.
"../../../../../../src/test/rpc/rtandidl/moretests/comtest_client_xfr.c",
line 737.33: 1506-099 (S) Unexpect\
ed argument.
"../../../../../../src/test/rpc/rtandidl/moretests/comtest_client_xfr.c",
line 738.33: 1506-099 (S) Unexpect\
ed argument.
"../../../../../../src/test/rpc/rtandidl/moretests/comtest_client_xfr.c",
line 739.33: 1506-099 (S) Unexpect\
ed argument.

Lines 735-739 in comtest_client_xfr.c are:

                    ( (vararg_fn_t) (*sav_ptr)) (binding_h,
                                COMTST_client_nomore_tsts,
                                (sstring_t *)"Test Complete",
                                &omsg,
                                status);

[08/30/93 public]
Have to assign (*sav_ptr) to a temp pointer of the correct type to work
around a RIOS (but not gcc) compiler problem.

[11/12/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8513
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : pointers don't work in IDL
Encoding Services
Reported Date                 : 8/26/93
Found in Baseline             : 1.0.3
Found Date                    : 8/26/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : cstubmts.c
Sensitivity                   : public

[8/26/93 public]
Support for pointer-based data structures is missing from IDL Encoding
Services. A seg fault can be expected when a [ptr] pointer is pickled, or
when a [unique] pointer is unpickled.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8505
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rpc_ns_entry_inq_resolution should be documented
Reported Date                 : 8/24/93
Found in Baseline             : 1.0.3
Found Date                    : 8/24/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1doc
Affected File(s)              : app_ref/man3rpc/rpc_ns_entry_inq_resolution.3rpc
Sensitivity                   : public

[8/24/93 public]
The routine rpc_ns_entry_inq_resolution is being documented in the AES
and will be used by federated naming.  It is currently used by the
sec_acl_xxx routines.  It should be documented in the DCE 1.1
manpages.  Norbert has the AES text that can be used as the manpage
starting point.

[08/24/93 public]
Assigned to writer Steve Lewontin.

[3/24/94 public]

Reassigned to John Shirley (OSF RPC writer) from Steve Lewontin.

[08/09/94 public]
Reassigned to myself.

[08/23/94 public]
Changed priority to "1".

[09/01/94 public]
Created this new reference page, based on corresponding AES text.
Verified by Rich Salz.

[09/22/94 public]
Closed bug.



CR Number                     : 8484
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : Possible errors marshalling
large arrays of [cs_char]s
Reported Date                 : 8/19/93
Found in Baseline             : 1.0.3
Found Date                    : 8/19/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : idlddefs.h,ndrmi.c,ndrmi5.c
Sensitivity                   : public

[8/19/93 public]
If the number of characters in an array of [cs_char]s is greater than the
IDL internal constant IDL_POINT_THRESHOLD, incorrect data may be put onto
the wire as a pointer to an area of memory that has been released gets
passed to the RPC runtime.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8470
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : Marshalling error with [out,v1_array] and [in] pipe
Reported Date                 : 8/18/93
Found in Baseline             : 1.0.3
Found Date                    : 8/18/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : ndrmi.c
Sensitivity                   : public

[8/18/93 public]
The following fragment of IDL gets a marshalling error in the operation
    typedef pipe char pipe_of_chars;

    void ov1a_op([in] handle_t h,
                  [in] long s,
                  [in] pipe_of_chars in_pipe,
                  [out] pipe_of_chars out_pipe,
                  [out] long *p_l,
                  [out,v1_array,size_is(s),length_is(*p_l)]
                        unsigned short v1a[]);

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8463
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa,i486
S/W Ref Platform              : hpux,osf1
Component Name                : rpc
Subcomponent Name             : secd slave
Short Description             : secd slaves dumping core
Reported Date                 : 08/17/93
Found in Baseline             : 1.0.3
Found Date                    : 08/17/93
Severity                      : A
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/runtime/rpctimer.c
Sensitivity                   : public

[08/17/93 public]

Using the DCE 1.0.3 nightly build available on 08/13/93, the security slaves
in the following cell configuration have dumped core:

dce11 (hp)    - SEC Master, CDS Client, DTS Clerk
dce13 (hp)    - SEC Client, CDS Server, DTS Local Server
largo (hp)    - SEC Slave, CDS Replica, DTS Clerk
west (hp)     - SEC Client, CDS Client, DTS Local Server
tahiti (i486) - SEC Slave, CDS Replica, DTS Local Server, dts_ntp_provider
brandy (hp)   - SEC Client, CDS Client, DTS Clerk

I did not see this problem in the same cell running the build available
on 08/06/93.

*****

The core from the HP-UX machine largo was not readable and there was
no error message:

root@largo> gdb secd core.1
GDB is free software and you are welcome to distribute copies of it
 under certain conditions; type "show copying" to see the conditions.
There is absolutely no warranty for GDB; type "show warranty" for details.
GDB 4.6, Copyright 1992 Free Software Foundation, Inc...
(no debugging symbols found)...

"/u0/dcetest/results/current/core.1" is not a core dump: File format not recognized
(gdb) quit

*****

The error message on the OSF/1 slave was:

Assertion failed: rpc_timer_head == NULL, file ../../../../src/rpc/runtime/rpctimer.c, line 348

The OSF/1 core information is:

root@tahiti> gdb secd core.1
GDB is free software and you are welcome to distribute copies of it
 under certain conditions; type "show copying" to see the conditions.
There is absolutely no warranty for GDB; type "show warranty" for details.
GDB 4.5, Copyright 1992 Free Software Foundation, Inc.

OSF version 1.0 created Mon Dec  7 14:40:14 1992

..(no debugging symbols found)...
Core was generated by `secd'.
Program terminated with signal 6, IOT/Abort trap.
#0  0xa403fea4 in rwl_e_owner ()
(gdb) bt
#0  0xa403fea4 in rwl_e_owner ()
(gdb) info reg
eax            0x0      0
ecx            0x5      5
edx            0x1      1
ebx            0x6      6
esp            0xc60f6d40       -972067520
ebp            0x0      0
esi            0xa4008d34       -1543467724
edi            0xa4005830       -1543481296
eip            0xa403fea4       -1543242076
ps             0x286    646
cs             0x17     23
ss             0x1f     31
ds             0x57001f 5701663
es             0x1f     31
fs             0x410000 4259840
gs             0x0      0
(gdb) x/16i $pc-32
0xa403fe84 <rwl_e_owner+-1548062316>:   pushl  %eax
0xa403fe85 <rwl_e_owner+-1548062315>:   addb   $0x89,%al
0xa403fe87 <rwl_e_owner+-1548062313>:   decl   %eax
0xa403fe88 <rwl_e_owner+-1548062312>:   addb   %cl,0xf9830042(%ecx)
0xa403fe8e <rwl_e_owner+-1548062306>:   addb   %dh,0xffffff89(%ebx,%eax,1)
0xa403fe92 <rwl_e_owner+-1548062302>:   incl   %ecx
0xa403fe93 <rwl_e_owner+-1548062301>:   addb   $0x31,%al
0xa403fe95 <rwl_e_owner+-1548062299>:   rolb   $0x90,%bl
0xa403fe98 <rwl_e_owner+-1548062296>:   movl   $0x25,%eax
0xa403fe9d <rwl_e_owner+-1548062291>:   lcall  0x7,0x0
0xa403fea4 <rwl_e_owner+-1548062284>:
jae    0xa403feae <rwl_e_owner+-1548062274>
0xa403fea6 <rwl_e_owner+-1548062282>:   movl   0xa4046a28,%edx
0xa403feac <rwl_e_owner+-1548062276>:   jmp    *%edx
0xa403feae <rwl_e_owner+-1548062274>:   ret    
0xa403feaf <rwl_e_owner+-1548062273>:   nop    
0xa403feb0 <rwl_e_owner+-1548062272>:   movl   $0xdf,%eax

[8/21/93 public]

Talking with rpc developers, it appears that there was a submission related
to the timer code last week. The Assertion failure message may be related
to that submmission. Assigning to rpc component for now. Also, Paul has not
seen this problem since it was found last Tuesday. There has been no
security submission for the period 8/6 - 8/13. As he indicated above, build
of 8/6 worked ok with his testing and build of 8/13 did not. I have asked
him to reproduce this problem with his weekend testing.

[8/20/93 public]
The rpc timer queue was getting messed up due to pointer goof.
The 'prev' pointer was not getting reset to NULL because of 
a coding error in rpc__timer_clear().

Paul Ellis is having trouble reproducing this bug and will 
verify this fix over the weekend.

[09/23/93 public]

Closed, I haven't seen this problem in the last three builds.



CR Number                     : 8461
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Add error codes for
transactional RPC
Reported Date                 : 8/17/93
Found in Baseline             : 1.0.3
Found Date                    : 8/17/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc.msg,ncastat.idl
Sensitivity                   : public

[8/17/93 public]
Add error codes for transactiona RPC, as agreed between Dave Lounsbury
(OSF) and Larry Augustus (DEC)

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8451
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : rpcd
Short Description             : Remove ability to delete/add endpoints to rpcd from a remote machine
Reported Date                 : 8/13/93
Found in Baseline             : 1.0.3
Found Date                    : 8/13/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/rpcd/rpcdep.c
Sensitivity                   : public

[8/13/93 public]
The current implementation of rpc_mgmt_ep_unregister, rpc_ep_register,
and rpc_ep_register_no_replace cause a problem.  The problem being that
anyone can make a call to these API's that add/delete endpoints
from the RPCD endpoint map.  DCE provides an easy interface to these
API calls via 'rpccp add/remove mapping'.

For example, a user could delete the SECD or CDSD endpoints in the
rpcd endpoint map where those servers reside.

First let me state that we think that machines that house critical endpoint
data should be physically secure, so that no person can simply walk up
to the machine and start issuing rpccp commands.  Our fix deals with
securing the RPCD from remote adds and deletes of endpoints.

IBM-Austin has prototyped a fix for the RPCD that does not allow remote
addition or deletion of endpoints.  The fix is contained entirely in
RPCD, in the file rpcdep.c.  The fix works by checking the binding info
by calling the new function remote_handle() in the routines ept_insert,
ept_delete and ept_mgmt_delete.  The binding info is checked to see if
the call is a local call.  If the call is local, it is allowed.  If the
call is remote ept_s_cant_access is returned.

The first thing that came to my mind after looking at the fix is that
the fix was restricting remote administration of endpoint maps.  While
this is true in the rpccp sense, and administrator can still tn or rlogin
to the machine in question and do the necessary editing of the rpcd
endpoint map.  Also, it does not seem that adding/deleting of endpoints
in the rpcd endpoint map is a operation that will be done frequently.

Another solution we thought about was somehow integrating some sort of
security features in rpcd, using authenticated RPC's.  We decided that the
issues raised by trying integrate some sort of security could not be contained
in the 1.0.3 timeframe.
We have built this code on RIOS and it sniff tested OK.  We have not
run any formal tests on the changed code listed below.  All the code
below resides in rpcdep.c.  remote_handle is a new routine that
checks binding info to see if it's a local or remote call.  This code
starts around line 72 in rpcdep.c.

PRIVATE int remote_handle( handle_t h, error_status_t *st )
{

        error_status_t status,status1;
        rpc_binding_vector_p_t bv;
        handle_t binding;
        unsigned_char_p_t stb,our_netaddr,client_netaddr;
        int i;

/* Get client network address from binding handle (client_netaddr) */

        rpc_binding_server_from_client(h,&binding,&status);
        if ( status != rpc_s_ok ){
                *st = status;
                return(1);
        }
        rpc_binding_to_string_binding(binding,&stb,&status);
        if ( status != rpc_s_ok ){
                rpc_binding_free(&binding,&status1);
                *st = status;
                return(1);
        }
        rpc_string_binding_parse(stb,NULL,NULL,&client_netaddr,NULL,NULL,&status
);
        if ( status != rpc_s_ok ){
                rpc_binding_free(&binding,&status1);
                rpc_string_free(&stb,&status1);
                *st = status;
                return(1);
        }
/* Get server network address from binding handle (our_netaddr) */

        rpc_server_inq_bindings(&bv,&status);
        if ( status != rpc_s_ok ){
                rpc_binding_free(&binding,&status1);
                rpc_string_free(&stb,&status1);
                rpc_string_free(&client_netaddr,&status1);
                *st = status;
                return(1);
        }
        rpc_string_free(&stb,&status1);
        rpc_binding_free(&binding,&status1);

        for ( i=0; i < bv->count; i++ ) {
                rpc_binding_to_string_binding(bv->binding_h[i],&stb,&status);
                if ( status != rpc_s_ok ){
                        rpc_binding_vector_free(&bv,&status1);
                        *st = status;
                        return(1);
                }
                rpc_string_binding_parse(stb,NULL,NULL,&our_netaddr,NULL,NULL,&s
tatus);
                if ( status != rpc_s_ok ){
                        rpc_binding_vector_free(&bv,&status1);
                        rpc_string_free(&stb,&status1);
                        *st = status;
                        return(1);
                }

/* Compare client and server netaddrs, return appropriately */
               if(strcmp(client_netaddr,our_netaddr) == 0) {
                        rpc_binding_vector_free(&bv,&status1);
                        rpc_string_free(&stb,&status1);
                        rpc_string_free(&client_netaddr,&status1);
                        rpc_string_free(&our_netaddr,&status1);
                        return(0);
                }
                rpc_string_free(&stb,&status1);
                rpc_string_free(&our_netaddr,&status1);
        }
        rpc_binding_vector_free(&bv,&status1);
        rpc_string_free(&stb,&status1);
        rpc_string_free(&client_netaddr,&status1);
        rpc_string_free(&our_netaddr,&status1);
        return(1);

}



------------------------------

PRIVATE void ept_insert(h, num_ents, entries, replace, status)
handle_t            h;
unsigned32          num_ents;
ept_entry_t         entries[];
boolean32           replace;
error_status_t      *status;
{
    epdb_handle_t   epdb;
    ept_entry_t     *entp;
    int             i;
    error_status_t  tmp_st;

    epdb_handle_from_ohandle(h, &epdb, status);
   if (! STATUS_OK(status))
        return;

        if ( remote_handle(h,&tmp_st) ){
                *status = ept_s_cant_access;
                return;
        }

------------------------------

PRIVATE void ept_delete(h, num_ents, entries, status)
handle_t            h;
unsigned32          num_ents;
ept_entry_t         entries[];
error_status_t      *status;

{
    epdb_handle_t   epdb;
    ept_entry_t     *entp;
    int             i;
    error_status_t  tmp_st;

    epdb_handle_from_ohandle(h, &epdb, status);
    if (! STATUS_OK(status))
        return;

        if ( remote_handle(h,&tmp_st) ){
                *status = ept_s_cant_access;
                return;
        }

------------------------------

PRIVATE void ept_mgmt_delete(h, object_speced, object, tower, status)
handle_t            h;
boolean32           object_speced;
uuid_p_t            object;
twr_p_t             tower;
error_status_t      *status;
{
    epdb_handle_t epdb;
        error_status_t tmp_st;

    epdb_handle_from_ohandle(h, &epdb, status);
    if (! STATUS_OK(status))
        return;

        if ( remote_handle(h,&tmp_st) ){
                *status = ept_s_cant_access;
                return;
        }

[8/18/93 public]

Sounds like a good idea, at least for the short term. 

A couple of comments:  

We should only be looking up the local net addrs once, and cacheing the
results.

Since the documentation already specifies ept_s_cant_perform_op as a
potential return code, why don't we just use that?

[08/24/93 public]
I made this change with the two modification that Mark suggested:
	- It now remembers the local host addresses
	- The error code returned is ept_s_cant_perform_op.

The new remote_handle() code is below, reformatted to match the rest
of the module.

Mark, if you could code review this quickly before I submit it?

INTERNAL int remote_handle( handle_t h, error_status_t *st )
{

    error_status_t status,status1;
    rpc_binding_vector_p_t bv;
    handle_t binding;
    unsigned_char_p_t stb,our_netaddr,client_netaddr;
    int i;
    static unsigned_char_p_t *local_netaddr = NULL;
    static int addr_count = 0;

/* Get client network address from binding handle (client_netaddr) */

    rpc_binding_server_from_client(h,&binding,&status);
    if (! STATUS_OK(&status))
    {
        *st = status;
        return(1);
    }
    rpc_binding_to_string_binding(binding,&stb,&status);

    if (! STATUS_OK(&status))
    {
        rpc_binding_free(&binding,&status1);
        *st = status;
        return(1);
    }
    rpc_binding_free(&binding,&status1);

    rpc_string_binding_parse(stb,NULL,NULL,&client_netaddr,NULL,NULL,&status);
    if (! STATUS_OK(&status))
    {
        rpc_string_free(&stb,&status1);
        *st = status;
        return(1);
    }
    rpc_string_free(&stb,&status1);

    /*
     * Lookup all of the addresses which this node answers to.
     * Cache these in static storage so we only do this work once.
     */
    if (addr_count == 0)
    {
        rpc_server_inq_bindings(&bv,&status);
        if (! STATUS_OK(&status))
        {
            rpc_string_free(&client_netaddr,&status1);
            *st = status;
            return(1);
        }

        addr_count = bv->count;
        local_netaddr = (unsigned_char_p_t *) malloc( 
                        (size_t) (addr_count * sizeof(unsigned_char_p_t)));
        if (local_netaddr == NULL) 
        {
            rpc_string_free(&client_netaddr,&status1);
            rpc_binding_vector_free(&bv,&status1);
            *st = ept_s_no_memory;
            return(1);
        }

        for ( i=0; i < bv->count; i++ ) 
        {
            rpc_binding_to_string_binding(bv->binding_h[i],&stb,&status);
            if (! STATUS_OK(&status))
            {
                rpc_binding_vector_free(&bv,&status1);
                rpc_string_free(&client_netaddr,&status1);
                *st = status;
                return(1);
            }
            rpc_string_binding_parse(stb,NULL,NULL,
                                     &our_netaddr,NULL,NULL,&status);
            if (! STATUS_OK(&status))
            {
                rpc_binding_vector_free(&bv,&status1);
                rpc_string_free(&stb,&status1);
                rpc_string_free(&client_netaddr,&status1);
                *st = status;
                return(1);
            }

            local_netaddr[i] = our_netaddr;
            rpc_string_free(&stb,&status1);
        }
        rpc_binding_vector_free(&bv,&status1);
    }

    /*
     * Compare the addresses with the client address
     */
    *st = rpc_s_ok;
    for ( i=0; i < addr_count; i++ )
    {
        if(strcmp(client_netaddr,local_netaddr[i]) == 0)
        {
            rpc_string_free(&client_netaddr,&status1);
            return(0);
        }
    }
    rpc_string_free(&client_netaddr,&status1);
    return(1);

}

90c202,208
<                 
---
> 
>     if ( remote_handle(h,&tmp_st) )
>     {
>         *status = ept_s_cant_perform_op;
>         return;
>     }
> 
120a239,244
>     if ( remote_handle(h,&tmp_st) )
>     {
>         *status = ept_s_cant_perform_op;
>         return;
>     }
> 
240a365
>     error_status_t tmp_st;
244a370,375
> 
>     if ( remote_handle(h,&tmp_st) )
>     {
>         *status = ept_s_cant_perform_op;
>         return;
>     }

[08/31/93 public]
This code is submitted to 1.0.3.  I have created an ifdef: 
REMOTE_ENDPOINT_ACCESS to allow vendors to turn this behavior
off.  If defined, rpcd will behave in the pre 1.0.3 fashion:
it will allow remote hosts to modify the endpoint map.

The default is to not allow remote modifications.



CR Number                     : 8411
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : 
Short Description             : opening /dev/lan0 should be RDONLY
Reported Date                 : 8/4/93
Found in Baseline             : 1.0.3
Found Date                    : 8/4/93
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/runtime/uuid_hpux.c
Sensitivity                   : public

[8/4/93 public]
In uuid__get_os_address() there is:

    /* 
     * Get 802.3 address from card by opening the driver and interrogating
     * it.
     */
    if ((fd = open (LAN_DEV, O_RDWR)) == -1 &&
        (fd = open (LAN_DEV0, O_RDWR)) == -1 &&
        (fd = open (LAN_DEV1, O_RDWR)) == -1) 

These opens should be O_RDONLY not O_RDWR.  Creating uuid's failed on my HP
due to bad perms on /dev/lan0.  The error was just can't get 802 address.
Serviceability work in 1.1 should have for an HP port "check permissions on
/dev/lan*" as an action field for this error.  Code cleanup for 1.1 should
have reworking all these machine dependent versions of uuid__get_os_address
and friends to all be consistent (currently some are in
src/rpc/runtime/uuid_*, and some are in machine specific directories).

[8/4/93 public]

The write permission was required for the older versions of HP-UX. At HP-UX
9.0 (or 8.0?) and later, you only need the read permission to get the MAC
address. The standard HP-UX installation does not give you the
world-readable /dev/lan*. We have modified dce_config to set permissions.

Also src/rpc/runtime/*_hpux.c are not machine dependent files. They are OS
dependent files. :-) We'd better have machine AND OS specific
directories...

[8/4/93 public]
You will...

[8/26/93 public]

Along with this fix, we should be checking for a NIC at lan0-lan9.

[9/21/93 public]

Will check /dev/lan0 - /dev/lan9 to get the MAC address (but no more
/dev/lan). This is what HP's DCE product does now.

[9/28/93 public]

The fix was submitted to 1.0.3.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8379
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : 
Short Description             : HP and at386 dtsd can't talk to each other
Reported Date                 : 7/28/93
Found in Baseline             : 1.0.3
Found Date                    : 7/28/93
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : time/time.mk
Sensitivity                   : public

[7/28/93 public]
dtsd on an HP-UX machine can not talk to dtsd on a 486.

The utc_t goes in at one end and comes out at the other garbled.

At 1993-07-28-17:09:16.492+00:00I-----  the rpc returns:

        Timestamp is 21801-07-11-14:19:12.680I-----

I suspect an endian problem, since HP can talk to HP.

There is a bug in dtsd (#8373 already submitted) which causes dtsd to
core dump when the timestamp return from a server is garbled.

To reproduce:
	- build current (7/28/93) dtsd on HP and at386
	- Configure cell both machines in a cell, and configure
	  dtsd local servers on each.
	- execute dtscp set servers required 2
	- execute 'sync' on once machine.

The RPC call being executed is ServerRequestTime() in time_request.c
The server routine executed on the remote dtsd is RPC_ServerRequestTime().
(also in time_request.c).

[07/29/93 public]
Well, turns out the endian-ness of the HP platform was specified incorrectly.
The HP is a Big-Endian machine, not little which was specified in
the time.mk file.

Tested and submitted.

[07/30/93 public]
Verified from the nightly build.
Closed.



CR Number                     : 8376
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : ./rpc/runtime
Short Description             : 
./rpc/runtime/cnassoc.c: In function `rpc__cn_assoc_acb_dealloc has missing
structures
Reported Date                 : 7/28/93
Found in Baseline             : 1.0.3
Found Date                    : 7/28/93
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : cnassoc.c
Sensitivity                   : public

[7/28/93 public]

./src/rpc/runtime/cnassoc.c: In function`rpc__cn_assoc_acb_dealloc':
../../../../src/rpc/runtime/cnassoc.c:4220: structure has no member named
`cn_cntblk'
../../../../src/rpc/runtime/cnassoc.c:4221: structure has no member named
`cn_cntblk'
../../../../src/rpc/runtime/cnassoc.c:4223: structure has no member named
`cn_cntblk'


 ../../../src/rpc/runtime/cnassoc.c
../../../src/rpc/runtime/cnassoc.c:176: commonp.h: No such file or
directory
../../../src/rpc/runtime/cnassoc.c:177: com.h: No such file or directory
../../../src/rpc/runtime/cnassoc.c:178: comprot.h: No such file or
directory
../../../src/rpc/runtime/cnassoc.c:179: cnp.h: No such file or directory
../../../src/rpc/runtime/cnassoc.c:180: cnid.h: No such file or directory
../../../src/rpc/runtime/cnassoc.c:181: cnrcvr.h: No such file or directory
../../../src/rpc/runtime/cnassoc.c:182: cnnet.h: No such file or directory
../../../src/rpc/runtime/cnassoc.c:183: cnpkt.h: No such file or directory
../../../src/rpc/runtime/cnassoc.c:184: cnsm.h: No such file or directory
../../../src/rpc/runtime/cnassoc.c:185: cnassm.h: No such file or directory
../../../src/rpc/runtime/cnassoc.c:186: cnasgsm.h: No such file or
directory
../../../src/rpc/runtime/cnassoc.c:187: comauth.h: No such file or
directory
../../../src/rpc/runtime/cnassoc.c:188: cncall.h: No such file or directory
../../../src/rpc/runtime/cnassoc.c:189: cnassoc.h: No such file or
directory

[ /rpc/runtime at 20:42 (PM) Tuesday ]
makepath runtime/. && cd runtime &&  exec make MAKEFILE_PASS=THIRD
build_all
/project/dce/build/dce1.0.3i/tools/at386/macho/gcc
-B/project/dce/build/dce1.0.3i/tools/at386/macho/  -c    -D_SHARED
_LIBRARIES   -DNCK -DPROT_NCADG -DPROT_NCACN  -DAUTH_KRB -DNAF_IP -DDNS_CDS
-DDNSPI_V3 -DDNS_V3API    -D_BSD -DDEBUG
   -I. -I/u1/devobj/sb/nb_486/src/rpc/runtime
-I/project/dce/build/dce1.0.3i/src/rpc/runtime -I/project/dce/build/dce
1.0.2a/src/rpc/runtime  -IAT386
-I/u1/devobj/sb/nb_486/src/rpc/runtime/AT386
-I/project/dce/build/dce1.0.3i/src/rpc/r
untime/AT386 -I/project/dce/build/dce1.0.2a/src/rpc/runtime/AT386
-I/u1/devobj/sb/nb_486/export/at386/usr/include -I/
project/dce/build/dce1.0.3i/export/at386/usr/include
-I/project/dce/build/dce1.0.2a/export/at386/usr/include  -pic-li
b   -L/u1/devobj/sb/nb_486/export/at386/usr/shlib
-L/project/dce/build/dce1.0.3i/export/at386/usr/shlib   -L/projec
t/dce/build/dce1.0.2a/export/at386/usr/shlib -L/usr/shlib
-L/u1/devobj/sb/nb_486/export/at386/usr/lib     -L/project/
dce/build/dce1.0.3i/export/at386/usr/lib
-L/project/dce/build/dce1.0.2a/export/at386/usr/lib
../../../../src/rp
c/runtime/cnassoc.c
../../../../src/rpc/runtime/cnassoc.c: In function
`rpc__cn_assoc_acb_dealloc':
../../../../src/rpc/runtime/cnassoc.c:4220: structure has no member named
`cn_cntblk'
../../../../src/rpc/runtime/cnassoc.c:4221: structure has no member named
`cn_cntblk'
../../../../src/rpc/runtime/cnassoc.c:4223: structure has no member named
`cn_cntblk'

[7/28/93 public]
Sandbox problem; Checked in the correct file.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8369
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : rpc/runtime/ipnaf_bsd.c
Short Description             : missing casts in getsockname()
Reported Date                 : 7/27/93
Found in Baseline             : 1.0.2
Found Date                    : 7/27/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : ipnaf_*
Sensitivity                   : public

[7/27/93 public]
The calls to getsockname() in rpc__ip_desc_inq_addr() in runtime/ipnaf_bsd.c,
ipnaf_hpux.c, <machine>/ipnaf_sys.c needs casts in the second and third
parameter. It should read

	getsockname(..., (struct sockaddr *) ..., (int *) ...)

[09/29/93 public]
Added cast to all ipnaf* files.
Verified on all platforms.
Closed.



CR Number                     : 8367
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 8365
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : port_gd
Short Description             : enumerate_interfaces() does
not scale.
Reported Date                 : 7/27/93
Found in Baseline             : 1.0.2
Found Date                    : 7/27/93
Severity                      : E
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : port_gd/3_rpc.gpsml
Sensitivity                   : public

[7/27/93 public]

enumerate_interfaces in rpc/runtime/ipnaf_bsd.c (and also ipnaf_sys.c in
the machine dependent subdirectories of runtime and kruntime) allocates a
1024-byte buffer on the stack for the ifreq structures returned by an
ioctl(..., SIOCGIFCONF, ...). Each ifreq structure is at least 32 bytes
long, so there is space for at most 32 ifreqs.  Hitachi claims that that is
not enough for their purposes and proposes that the stack allocation be
replaced by a malloc with a #defined size.

Two objections to that are that the malloc idea does not work for kruntime
and that the #defined size does little to enhance the flexibility of the
software. But since the file is (supposed to be - see CR#8365) only a
template, perhaps the best thing to do is add a comment to the porting
guide, explaining the alternatives.

[07/29/93 public]
Assigned this CR to writer Doug Weir.

[09/21/93 public]
Made the specified changes.

[11/15/93 public]

Verified change in latest doc build and closed this CR.



CR Number                     : 8366
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rpc_string_free not call VERIFY_INI
Reported Date                 : 7/26/93
Found in Baseline             : 1.0.2
Found Date                    : 7/26/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : comutil.c
Sensitivity                   : public

[7/26/93 public]
rpc_string_free() does not really need to call RPC_VERIFY_INIT. The fact
that rpc_string_free() does so and initializes entire Runtime shows up
in a simple CDSCP command. The process simplt calls uuid_to_string and
then does rpc_string_free. This process does not need to initialize
Runtime code.

[07/28/93 public]
Be careful.  Note that rpc_string_free calls RPC_MEM_FREE (which might
call rpc__mem_free) which calls RPC_MEM_FREE_IL which calls RPC_MEM_LOCK.
While that is currently set up to be an empty macro.  Someone could change
that and not know to put back the RPC_VERIFY_INIT.  It should probably not
be removed but rather replaced by the same conditional compilation control
that is used in the RPC_MEM_LOCK choice.  Unfortunately the one that is
used is the semantic-free "#ifdef NOTDEF"
	/r$

[10/15/93 public]
I removed the VERIFY_INIT call.  I investigated the macro trial that Rich
warned about above and I don't see indications that there will be problems
now or in the future.  If RPC_MEM_LOCK is changed to require the rpc runtime
initialized, then it should call VERIFY_INIT itself.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8365
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : runtime/ipnaf_hpux.c
Short Description             : inconsistencies in dealing with machine dependent files.
Reported Date                 : 7/26/93
Found in Baseline             : 1.0.3
Found Date                    : 7/26/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : ipnaf_*
Sensitivity                   : public

[7/26/93 public]
The OSF/1 pmax build uses rpc/runtime/ipnaf_bsd.c.
The RIOS build uses rpc/runtime/RIOS/ipnaf_sys.c.
Now that HPUX is in, the file rpc/runtime/ipnaf_hpux.c
has sprouted.

In kernel RPC, RIOS uses rpc/kruntime/RIOS/ipnaf_sys.c
whereas OSF/1 uses rpc/kruntime/OSF1_TEMPLATE/ipnaf_sys.c.
HPUX uses rpc/kruntime/HP800/ipnaf_sys.c.

My understanding is that ipnaf_sys.c is a machine/OS dependent
file, so it should go in the appropriate machine-dependent
subdirectory.  ipnaf_bsd.c is a template and should not be used
in the builds. The kruntime machine-dependent subidrectory structure
needs some cleaning up as well, but that may be academic with the
going away of the pmax as a ref. platform.

[09/29/93 public]
Fixed up ipnaf files:
	./rpc/runtime/AT386/ipnaf_sys.c defunct
	./rpc/runtime/PMAX/ipnaf_sys.c  defunct
	./rpc/runtime/ipnaf_hpux.c      defunct
	./rpc/runtime/uuid_hpux.c       defunct

Added:
	./rpc/runtime/HP800/ipnaf_sys.c
	./rpc/runtime/HP800/uuidsys.c


Closed.



CR Number                     : 8363
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : rpcd/rpcd.c
Short Description             : redefinition of fork should be allowed
Reported Date                 : 7/26/93
Found in Baseline             : 1.0.2
Found Date                    : 7/26/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/rpcd/rpcd.c
Sensitivity                   : public

[7/26/93 public]

The licensee reported the following:

	 DESCRIPTION:

	 In rpc/rpcd/rpcd.c, there is cpp code to negate any redefinition of
	 fork which might be in effect.  Since we need to use cma_fork as
	 a wrapper, this is a problem.

The relevant portion of the file is as follows:

    /*
     * Don't allow the fork to be redefined to cma_fork, which doesn't exist
     * at CMA CD4.
     */
#ifdef fork
#undef fork
#endif

and his suggested change is to get rid of the whole thing (at least for his
case). It turns out that rpcd.c does not include the remapping header file
so these lines have no effect on the reference platforms. So, maybe they should
be deleted outright.

I asked why they had to use the wrapped fork but my correspondent did not
know (it is somebody else's province). I can go back for that information,
if necessary. Possibly relevant detail: Hitachi uses OSF/1 and kernel
threads, not CMA threads, for their DCE port.

[9/21/93 public]

Will take the above "#undef fork' out.

[9/28/93 public]

The fix was submitted to 1.0.3.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8356
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : string_buf[] defined twice.
Reported Date                 : 7/22/93
Found in Baseline             : 1.0.2
Found Date                    : 7/22/93
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : in test/rpc/rtandidl/moretests comtest_interface_y.c server_obj_tsts.h
Sensitivity                   : public

[7/22/93 public]

The variable string_buf is defined twice among the files that make up
tstsrvr. It appears both in comtest_interface_y.c (where it is not used)
and in server_obj_tsts.h (used in server_obj_tsts.c).  Why not get rid of
the definition in comtest_interface_y.c?

[10/15/93 public]
Removed the definition in comtest_interface_y.c.
Closed.



CR Number                     : 8355
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Return type of register_ifs conflicts with type of value actually returned.
Reported Date                 : 7/22/93
Found in Baseline             : 1.0.2
Found Date                    : 7/22/93
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : test/rpc/rtandidl/moretests/mgmt_ep_elt_inq.c
Sensitivity                   : public

[7/22/93 public]

In the file test/rpc/rtandidl/moretests/mgmt_ep_elt_inq.c the function
register_ifs() is declared without a return type and therefore its return
type is int while a couple of return statements in the body of the function
return pointers to unsigned32 resulting in type mismatch warnings. Since
the return value is never used by the caller a solution might be to
declare the return value of register_ifs() as void and not return anything
with the return statements.

[10/15/93 public]
Made register_ifs() a void function.
Closed.



CR Number                     : 8354
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 8300
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : A few files in test/rpc/rtandidl/moretests lack #include <stdlib.h>.
Reported Date                 : 7/22/93
Found in Baseline             : 1.0.2
Found Date                    : 7/22/93
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : binding_copy.c binding_from_string.c set_inq_auth_info.c string_binding_compose.c
Sensitivity                   : public

[7/22/93 public]

The files binding_copy.c, binding_from_string.c, set_inq_auth_info.c,
string_binding_compose.c all are missing the statement:

	#include <stdlib.h>

which is required since those files contain calls to functions declared in
<stdlib.h> (malloc() in binding_copy.c, binding_from_string.c and
string_binding_compose.c and getenv() in set_inq_auth_info.c). As a result
the compiler defaults the return type of these functions to int which
causes an ANSI-C compiler to issue type mismatch warnings in several
places. In most environments this problem is hidden by the indirect
inclusion of <stdlib.h> through a long chain of includes but the problem
arises when for example the DCE implementation uses kernel threads.

[10/14/93 public]
Added the includes.
Closed.



CR Number                     : 8342
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Compilation errors in v2test_lib
Reported Date                 : 7/22/93
Found in Baseline             : 1.0.3
Found Date                    : 7/22/93
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : ./test/rpc/runtime/v2test_lib/v2test.h
Sensitivity                   : public

[7/22/93 public]
Two compilation errors:
src/test/rpc/runtime/v2test_lib/v2client.c:
src/test/rpc/runtime/v2test_lib/v2server.c

src/test/rpc/runtime/v2test_lib/v2client.c:
cc: "../../../../../../src/test/rpc/runtime/v2test_lib/v2client.c", line
307: error 1588: "N" undefined.
cc: "../../../../../../src/test/rpc/runtime/v2test_lib/v2client.c", line
307: warning 563: Argument #2 is not the 
correct type.
cc: "../../../../../../src/test/rpc/runtime/v2test_lib/v2client.c", line
307: warning 608: Illegal integer-pointer
 combination in assignment.
cc: "../../../../../../src/test/rpc/runtime/v2test_lib/v2client.c", line
307: warning 563: Argument #3 is not the 
correct type.

src/test/rpc/runtime/v2test_lib/v2server.c:
cc: "../../../../../../src/test/rpc/runtime/v2test_lib/v2server.c", line
343: error 1588: "N" undefined.
cc: "../../../../../../src/test/rpc/runtime/v2test_lib/v2server.c", line
343: warning 563: Argument #2 is not the 
correct type.
cc: "../../../../../../src/test/rpc/runtime/v2test_lib/v2server.c", line
343: warning 608: Illegal integer-pointer
 combination in assignment.
cc: "../../../../../../src/test/rpc/runtime/v2test_lib/v2server.c", line
343: warning 563: Argument #3 is not the 
correct type.

[7/22/93 public]

This happens because you are building kernel RPC functional tests which is
not ported to HP-UX. If you do build in src/test/rpc/runtime/v2test_lib
directory (building the user space RPC functional tests), it will succeed.
The above errors are in src/test/rpc/runtime/uv2test and
src/test/rpc/runtime/kv2test (not in v2test_lib, please check 'cd' before
the errors).

[07/22/93 public]
Duplicate of 8340.

[07/23/93 public]
Didn't get fixed in nightly build of July22.
Refer to build log (for tests) for details.

[07/23/93 public]
Reopened this defect and assigned it to Dave.  I mistook it for a system
test defect.

[11/12/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8341
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Can't find header files in ncstest
Reported Date                 : 7/22/93
Found in Baseline             : 1.0.3
Found Date                    : 7/22/93
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : ./test/rpc/rpc.mk
					     ./test/rpc/runtime/ncstest/client.c
Sensitivity                   : public

[7/22/93 public]
In src/test/rpc/runtime/ncstest/client.c:
user.h: 17: Unable to find include file '../h/time.h'.
user.h: 18: Unable to find include file '../h/resource.h'.
user.h: 19: Unable to find include file '../h/privgrp.h'.
user.h: 20: Unable to find include file '../h/errno.h'.
user.h: 21: Unable to find include file '../h/signal.h'.
user.h: 22: Unable to find include file '../h/proc.h'.
user.h: 27: Unable to find include file '../h/vmmac.h'.

Here's the complete compilation invocation:
c89 
	-c    
	-D_SHARED_LIBRARIES  +z  
	-DKERNEL 
	-D_KERNEL  
	-D__hppa
	-Dhp9000s800 
	-Dhp9000s700 
	-D__hp9000s800 
	-D__hp9000s700 
	-DHPUX 
	-D__hpux 
	-Dunix +DA1.0 
	-D_HPUX_SOURCE    
	-I.
	-I/project/dce/build/nb_ux/src/test/rpc/runtime/kncstest
	-I/project/dce/build/dce1.0.3i/src/test/rpc/runtime/kncstest
	-I/project/dce/build/dce1.0.2a/src/test/rpc/runtime/kncstest  
	-I. 
	-I/project/dce/build/nb_ux/src/test/rpc/runtime/kncstest
	-I/project/dce/build/dce1.0.3i/src/test/rpc/runtime/kncstest
	-I/project/dce/build/dce1.0.2a/src/test/rpc/runtime/kncstest 
	-I../ncstest
	-I/project/dce/build/nb_ux/src/test/rpc/runtime/ncstest
	-I/project/dce/build/dce1.0.3i/src/test/rpc/runtime/ncstest
	-I/project/dce/build/dce1.0.2a/src/test/rpc/runtime/ncstest
	-I/project/dce/build/nb_ux/export/hp800/usr/include 
	-I/project/dce/build/dce1.0.3i/export/hp800/usr/include
	-I/project/dce/build/dce1.0.2a/export/hp800/usr/include
../../../../../../src/test/rpc/runtime/ncstest/client.c

[7/22/93 public]

On HP-UX, when _KERNEL is defined you need -I/etc/conf . I though that DFS
group is addressing this problem because they need kernel headers. As I
know, none of the kernel RPC functional tests is ported to HP-UX.

[07/22/93 public]
Duplicate of 8340.

[07/23/93 public]
Reopened and assigned to Dave.  I mistook this defect for a system test bug.

[8/12/93 public]
Fixed by changes in ./test/rpc/rpc.mk and
./test/rpc/runtime/ncstest/client.c

[11/12/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8313
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : rpccp.c
Short Description             : change order of header files
Reported Date                 : 7/19/93
Found in Baseline             : 1.0.2
Found Date                    : 7/19/93
Severity                      : E
Priority                      : 4
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpccp.c
Sensitivity                   : public

[7/19/93 public]

Due to an anomaly on one of our C Runtime libraries,
we had to ensure that the rpc and stubbase header files were
read in before any of the C header files.

The file inclusion looks like this:

#include <dce/rpc.h>
#include <dce/stubbase.h>

#include <stdio.h>
#include <signal.h>
#include <setjmp.h>
#include <errno.h>

#include <dce/pthread_exc.h>
#include <dce/exc_handling.h>

[10/18/93 public]
Since this wont hurt anything, I moved the headers around.
Probably should fix that os however, do you expect application
developers to do this?

[10/18/93 public]

Just a remainder: Including stubbase.h before stdio.h is a right thing to
do when using CMA. Because stubbase.h includes pthread_exc.h which includes
cma.h when using CMA, and cma_stdio.h which may be included by cma.h will
define some macros for CMA IO wrappers. These macros are supposed to be
used in stdio.h and others. (Also, if you include stubbase.h, you shouldn't
include pthread.h.) It's just a limitation of macros based wrappers...

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8309
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : Directionality of I-char tags
not checked
Reported Date                 : 7/19/93
Found in Baseline             : 1.0.3
Found Date                    : 7/19/93
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : chkichar.c,nidlmsg.h,nidlmsg.m
Sensitivity                   : public

[7/19/93 public]
When the IDL international character support is in use, the IDL compiler
should check that [cs_stag] or [cs_drtag] is applied to a parameter that
is [in] and [cs_rtag] is applied to a parameter that is [out].
Also the appropriate line from the ACF should appear with errors and
warnings relating to ACF source code.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8303
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : code cleanup issues
Reported Date                 : 7/16/93
Found in Baseline             : 1.0.2
Found Date                    : 7/16/93
Severity                      : E
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : test/rpc/runtime/ncstest/smplm.c,client.c,afsu.c test/rpc/runtime/v2test_lib/v2client.c,v2client.h
Sensitivity                   : public

[7/16/93 public]

1. test/rpc/runtime/ncstest/smplm.c

	remove superfluous ;'s after final brace of functions:

		ncstest_simple_op1
		ncstest_simple_op2
		ncstest_simple_op3

2. test/rpc/runtime/ncstest/client.c

	recasting required for argument of call to rpc_bincing_set_auth_info

3. test/rpc/runtime/ncstest/afsu.c
	
	the definition of ncstest_afs_foo in afsu.c should be changed to
        an external reference (globalref or extern), so as not to duplicate
        the definition put in afs_cstub.c by the idl compiler as the result
        of the transformation of afs.acf.

4. test/rpc/runtime/v2test_lib/v2client.c,v2client.h

	the definition of the global variable, timers appearing in inv2test.h
        causes this variable to be instantiated in each module which includes
        v2test.h. In the case of the server program, there are two modules
        which include v2test.h, and thus two instances of the variable which
        must be resolved by the linker.

5. test/rpc/runtime/perf/server.c

	two of the three calls to strtok appearing in this file have had
        their return values cast, and the third would require this to
        be done for the file to be ANSI compilable (without
        warning: assignment makes pointer from integer without a cast)

	No casting would be required (in any of the three cases) if string.h
        were simply included in server.c

[10/15/93 public]
Fixed 1-4, for the perf test, HP had added the third cast so I decided
not to change anything.



CR Number                     : 8289
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 7575
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : sys_idl
Short Description             : subbase.h has missing comment end marker
Reported Date                 : 7/16/93
Found in Baseline             : 1.0.3
Found Date                    : 7/16/93
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/sys_idl/subbase.h
Sensitivity                   : public

[7/16/93 public]
The header file stubbase.h is missing a '*/' to close a comment
which generates a warning every time this file is included.

And this file is included in a lot of things.

Fix is to close the comment.

[07/16/93 public]
Turns out this has been around a while (with another bug number, 7575).
Closed under this bug number, as I found out about the sup number too late.



CR Number                     : 8274
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : rpc/runtime/cn
Short Description             : CN call executor thread hang at call_receive
Reported Date                 : 7/14/93
Found in Baseline             : 1.0.2
Found Date                    : 7/14/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : cnassoc.c cnassoc.h cncall.c cnsclsm.c
Sensitivity                   : public

[7/14/93 public]

The client hanged at the static test cancel 3 (wating for a server
response) in perf.

$ client 15 ncacn_ip_tcp:15.22.48.70[2001] 2 y 1
Static Cancel test [15]
    passes: 2; idem: yes; slow secs: 1; cancel timeout secs: <default>
    Static Cancel Test 1 (server should NOT detect cancel):
    *** unexpected cancel exception raised!
    Static Cancel Test 2 (server SHOULD detect cancel):
        Correct cancel exception operation
    Static Cancel Test 3 (server SHOULD detect cancel on 2nd RPC):

The server was started with RPC_DEBUG turned on and with one call executor
thread. Here is the trace with my annotation indicated by =.

$ RPC_DEBUG=0.20,1-3.7,11.1,13.3,14.20,16.5 ./server -v1 1 ncacn_ip_tcp
(rpc__cn_assoc_grp_tbl_init)
(rpc__cn_assoc_grp_create)
(rpc__cn_assoc_grp_init)
(rpc__cn_assoc_grp_init)

= Some traces omitted.

= Here is the beginning of the static test cancel 2. Note assoc->400a7628 and
= call_rep->0 .

CN: call_rep->0 assoc->400a7628 desc->5 received 32 bytes
PACKET: type->REQUEST       flags->7 drep->00000000 frag_len->32 auth_len->0 call_id->2
PACKET: <0000> 0500 0007 0000 0000 0020 0000 0000 0002
PACKET: <0016> 0000 0000 0001 0010 0000 0000 0000 0001
(rpc__cn_assoc_push_call)
(rpc__cn_assoc_alloc)
STATE SERVER ASSOC: 400a7628 state->OPEN              event->ALLOC_REQ
(SERVER incr_active_action_rtn)
STATE SERVER ASSOC: 400a7628 new state->OPEN
STATE SERVER CALL:   2 state->INIT              event->INDICATION
(SERVER last_recv_frag_pred_rtn)
(SERVER handle_first_frag_action_rtn)
(SERVER handle_frag_action_rtn)
(rpc__cn_assoc_queue_frag)
(handle_first_frag_action_rtn) call_rep->400a7b68 alert pending bit set in header calling rpc__cthread_cancel()

= The client sent the alert (cancel) pending flag with its request.  So
= call_rep->u.server.cancel.count was increased by rpc__cthread_cancel().
= Note call_rep->400a7b68 .

STATE SERVER CALL:   2 new state->RESPONSE
(rpc__cn_assoc_syntax_lkup_by_id)
(cthread_call_executor) pool 400a75b8 cthread 400a75f0 executing call_rep 400a7b68
CN: call_rep->400a7b68 call executor running ... WAS NOT queued
(rpc__cn_call_receive)
CN: call_rep->400a7b68 call receive...
(rpc__cn_assoc_receive_frag)
PACKET: call receive args.flags->61 args.buff_len->4096 args.data_len->8
(rpc__cn_call_executor) call_rep->400a7b68 enabling posting of cancels and posting any queued cancels

= rpc__cthread_cancel_enable_post() was called to enable and post pending
= cancels.

(rpc__cn_assoc_grp_lkup_by_id)
+ perf_null_slow_idem: called from ncacn_ip_tcp:15.22.48.70[2158]
    ...'cancel' exception caught

= The server manager routine caught the exception and RERAISE'd it.  The
= server stub caught it and called rpc_ss_send_server_exception() which
= called rpc_call_transmit_fault().

(rpc__cn_call_transmit_fault)
CN: call_rep->400a7b68 call transmit fault
STATE SERVER CALL:   2 state->RESPONSE          event->FAULT
(SERVER response_fault_pred_rtn)
(SERVER abort_resp_send_fault_action_rtn)
(SERVER abort_resp_action_rtn)
(SERVER send_call_fault_action_rtn)
(send_call_fault_action_rtn) call_rep->400a7b68 setting alert count (0) in packet header
(rpc__cn_assoc_send_frag)
CN: call_rep->400a7b68 assoc->400a7628 desc->5 sent 36 bytes
PACKET: type->FAULT         flags->3 drep->00000000 frag_len->36 auth_len->0 call_id->2
PACKET: fragment->#0 addr->400a7de0
PACKET: <0000> 0500 0303 0000 0000 0024 0000 0000 0002
PACKET: <0016> 0000 0000 0001 0000 0000 0000 0000 0000
PACKET: fragment->#1 addr->400a9848
PACKET: <0032> 1c00 000d
STATE SERVER CALL:   2 new state->CALL_COMPLETED

= rpc__cn_call_transmit_fault() has finished. At this point the CN global
= mutex is unlocked.

(rpc__cn_call_end)

= rpc__cn_call_end() was called by rpc__cn_call_executor(). But, before
= rpc__cn_call_end() acquires the CN global mutex, the thread context switch
= happened and the receiver thread is now ready to read the new request
= (static test cancel 3). Note assoc->400a7628 and call_rep->400a7b68 . Since
= this RPC is from the same client, it is using the same association and
= call_rep is still pointing to the previous call which is about to finish.

CN: call_rep->400a7b68 assoc->400a7628 desc->5 received 32 bytes
PACKET: type->REQUEST       flags->7 drep->00000000 frag_len->32 auth_len->0 call_id->3
PACKET: <0000> 0500 0007 0000 0000 0020 0000 0000 0003
PACKET: <0016> 0000 0000 0001 0010 0000 0002 0000 0001
(rpc__cn_assoc_push_call)
(rpc__cn_assoc_alloc)
STATE SERVER ASSOC: 400a7628 state->OPEN              event->ALLOC_REQ
(SERVER incr_active_action_rtn)
STATE SERVER ASSOC: 400a7628 new state->OPEN
STATE SERVER CALL:   3 state->INIT              event->INDICATION
(SERVER last_recv_frag_pred_rtn)
(SERVER handle_first_frag_action_rtn)
(SERVER handle_frag_action_rtn)
(rpc__cn_assoc_queue_frag)

= The request was queued to assoc->msg_list .

(handle_first_frag_action_rtn) call_rep->400a7780 alert pending bit set in header calling rpc__cthread_cancel()

= The client sent the alert (cancel) pending flag with its request.  So
= call_rep->u.server.cancel.count was increased by rpc__cthread_cancel().
= Note the new call_rep->400a7780 .

STATE SERVER CALL:   3 new state->RESPONSE
(rpc__cn_assoc_syntax_lkup_by_id)
(cthread_pool_queue_call) pool 400a75b8 (now 1) call_rep 400a7780
CN: call_rep->400a7780 assoc->400a7628 desc->5 call queued

= Since there was only one call executor thread available in this server and
= it was still executing the previous request (blocked in
= rpc__cn_call_end()), the new call was queued by rpc__cthread_invoke_null().
= Now, the receiver thread unlocks the CN global mutex and calls
= pthread_yield() which wakes up the call executor thread executing
= rpc__cn_call_end().

CN: call_rep->400a7b68 call end
PACKET: call end
STATE SERVER CALL:   2 state->CALL_COMPLETED    event->END
STATE SERVER CALL:   2 new state->CALL_COMPLETED
(rpc__cn_assoc_pop_call)
(rpc__cn_assoc_dealloc)

= The problem is in rpc__cn_assoc_dealloc(). It's unconditionally flushes
= assoc->msg_list .

STATE SERVER ASSOC: 400a7628 state->OPEN              event->DEALLOC_REQ
(SERVER decr_active_action_rtn)
STATE SERVER ASSOC: 400a7628 new state->OPEN
(rpc__cn_assoc_acb_dealloc)

= The call executor thread starts the execution of the new request.

(cthread_call_dequeue) pool 400a75b8 (0 remain) call_rep 400a7780
(cthread_call_executor) pool 400a75b8 cthread 400a75f0 executing call_rep 400a7780
CN: call_rep->400a7780 call executor running ... WAS queued
(rpc__cn_call_receive)
CN: call_rep->400a7780 call receive...

= Since assoc->msg_list is empty, it waits forever. The server process is
= still alive as you can see that the timer thread is running. (Although this
= request has a pending cancel, the cancel is not enabled yet.)

(rpc__cn_assoc_receive_frag)
(rpc__cn_assoc_timer_reclaim)
(rpc__cn_assoc_reclaim)
(rpc__cn_assoc_timer_reclaim)
(rpc__cn_assoc_reclaim)
(rpc__cn_assoc_timer_reclaim)
(rpc__cn_assoc_reclaim)
(rpc__cn_assoc_timer_reclaim)
(rpc__cn_assoc_reclaim)
(rpc__cn_assoc_timer_reclaim)
(rpc__cn_assoc_reclaim)
(rpc__cn_assoc_timer_reclaim)
(rpc__cn_assoc_reclaim)

Here is the stack trace of the call executor thread.

STACK: 
$cmatcb = 0x40014be0
$sp = 0x400a99e0
$pc = 0x7abe9fc7
Blocked: $cmastate = 2
 0 cma__transfer_thread_ctx@libdce (cur_ctx = 0x40014c60, new_ctx = 0x4000af68)    [/afs/ch/project/dce/build/GAMERA/src/threads/HP800/cma_host.c: 117]
 1 cma__transfer_thread_ctx@libdc + 0x00000008 (hp-ux export stub)
 2 cma__dispatch@libdce (old_tcb = 0x40014be0, save_context = 1, milliseconds = 0)    [/afs/ch/project/dce/build/GAMERA/src/threads/cma_dispatch.c: 1134]
	status    = 0
	cur_tcb   =   00000000
 3 cma__dispatch@libdce + 0x00000008 (hp-ux export stub)
 4 cma__block@libdce (blocked_list = 0x40015bdc, milliseconds = 0)    [/afs/ch/project/dce/build/GAMERA/src/threads/cma_dispatch.c: 664]
	cur_tcb   = 0x40014be0
	status    = 1074436896
	ptr       = 0x00000001
	policy    = 0
	priority  = 0
	tcb       =   00000000
	sclass    = cma__c_class_rt
	spriority = 0
 5 cma__block@libdce + 0x00000008 (hp-ux export stub)
 6 ptdexc_cond_wait@libdce (cond = 0x400a7670, mutex = 0x7ab2f8a8)    [/afs/ch/project/dce/build/GAMERA/src/threads/cma_ptd_exc.c: 2599]
	_int_mu_  = 0x4000f400
	_int_cv_  = 0x40015bc0
	tcb       = 0x40014be0
	res       = 2062776880
	res       = 2062776884
 7 ptdexc_cond_wait@libdce + 0x00000008 (hp-ux export stub)
 8 rpc__cn_assoc_receive_frag@libdce (assoc = 0x400a7628, fragbuf = 0x400a9620, st = 0x400a959c)    [../../../../src/rpc/runtime/cnassoc.c: 1700]
	retry_op  = 1
	call_rep  = 0x400a7780
	exc_ctx   = 0x7af93e0b
	THIS_CATCH =   00000000
 9 rpc__cn_assoc_receive_frag@lib + 0x00000008 (hp-ux export stub)
10 rpc__cn_call_receive@libdce (call_r = 0x400a7780, call_args = 0x400a954c, st = 0x400a959c)    [/afs/ch/project/dce/build/GAMERA/src/rpc/runtime/cncall.c: 1270]
	call_rep  = 0x400a7780
	header_p  = 0x00000001
	frag_buf  = 0x20574153
	fault_code = 544306533
	valid_fragbuf = 0
11 rpc__cn_call_receive@libdce + 0x00000008 (hp-ux export stub)
12 rpc__cn_call_executor@libdce (arg = 0x400a7780, call_was_queued = 1)    [/afs/ch/project/dce/build/GAMERA/src/rpc/runtime/cncthd.c: 193]
	binding_r = 0x7aaca624
	call_r    = 0x400a7780
	iovector  = 0x706f6f6c
	type_uuid =   00000000
	manager_epv = 0x400a73e8
	transfer_syntax = 0x70203430
	server_stub_epv = 0x400011f0
	if_spec_rep = 0x40001180
	status    = 382312474
13 rpc__cn_call_executor@libdce + 0x00000008 (hp-ux export stub)
14 cthread_call_executor@libdce (cthread = 0x400a75f0)    [/afs/ch/project/dce/build/GAMERA/src/rpc/runtime/comcthd.c: 607]
	call_rep  = 0x400a7780
	pvt       = 0x400a779c
	p         = 0x400a75b8
	qelt      =   00000000
	skip_startup = 0
	run_queued_call = 1
15 cthread_call_executor@libdce + 0x00000008 (hp-ux export stub)
16 cma__thread_base@libdce (tcb = 0x40014be0)    [/afs/ch/project/dce/build/GAMERA/src/threads/cma_thread.c: 1422]
	routine   = 0x7aad0f52
	argument  = 0x400a75f0
	value     =   00000000
	status    = cma_c_term_normal
	output    = 0x400a90b0
	exc_ctx   = 0x7af93e0b
	THIS_CATCH =   00000000
	THIS_CATCH =   00000000
	exc_ctx   =   00000000
	THIS_CATCH =   00000000
17 cma__thread_base@libdce + 0x00000008 (hp-ux export stub)
18 cma__thread_start1@libdce (tcb = 0x40014be0)    [/afs/ch/project/dce/build/GAMERA/src/threads/HP800/cma_host.c: 93]
	ctx       = 0x40014c60
19 cma__thread_start1@libdce + 0x00000008 (hp-ux export stub)
20 cma__thread_start0@libdce + 0x00000008 (0x40014be0, 0, 0, 0)

This hang involves the timing of the thread context switching.  Thus, it is
not easily reproducible. I was unlucky (or lucky :-) to get it.

I think that the fix is to pass the call_rep to rpc__cn_assoc_dealloc() and
if (call_rep != assoc->call_rep) don't flush the message queue, just like
rpc__cn_assoc_pop_call(). (And maybe in handle_frag_action_rtn()/cnsclsm.c,
if it's a first frag the assoc->msg_list should be flushed?)

[08/18/93 public]
Seiichi found a memory leak in his initial solution to this bug.
He has provided me with a fix, and I'm going to test it out.

Unfortunately, I haven't been able to reproduce this problem using perf
on OSF/1 or HP-UX at all.

[08/18/93 public]
Found an easy way to reproduce this problem:
Insert a pthread_yield() before the global lock is taken in rpc__cn_end_call()
This will cause the perf test Seiichi mentions above to fail.

Applied his fix of passing the call_rep to rpc__cn_assoc_dealloc() and
checking that it matches the assoc before flushing the message queue:

         if (call_rep == assoc->call_rep
             || (assoc->call_rep == NULL && call_rep->assoc == NULL))

It works.

[08/18/93 public]
Submitted.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8272
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : IDL should not abort on ACF 
						include with file extension
Reported Date                 : 7/13/93
Found in Baseline             : 1.0.3
Found Date                    : 7/13/93
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/idl/idl_compiler/acf.y
Sensitivity                   : public

[7/13/93 public]
If the file name in an ACF "include" statement includes an extension,
the IDL compiler should issue a warning and continue, not abort the
compilation. A comment in the compiler indicates this is the intention,
but this is not what the current implemtnation does.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8270
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : rpc/idl/lib
Short Description             : 
src/rpc/idl/lib/sscmaset.c: Undeclared identifiers
Reported Date                 : 7/13/93
Found in Baseline             : 1.0.3
Found Date                    : 7/13/93
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : idl/lib/ndrui2.c
Sensitivity                   : public

[7/13/93 public]

[7/13/93 public]
Errors from dce103i build on RIOS:

[ /rpc/idl/klib at 23:19 (PM) Monday ]
makepath klib/. && cd klib &&  exec make MAKEFILE_PASS=THIRD

[ /rpc/idl/lib at 22:11 (PM) Monday ]

/rpc/idl/lib/sscmaset.c", line 448.42: 1506-045 (S) Undeclared identifier rpc_x_call_timeout_id.
/rpc/idl/lib/sscmaset.c", line 700.43: 1506-045 (S) Undeclared identifier rpc_x_ss_bad_buffer_id.
/rpc/idl/lib/sscmaset.c", line 702.46: 1506-045 (S) Undeclared identifier rpc_x_ss_bad_es_action_id.
/rpc/idl/lib/sscmaset.c", line 704.49: 1506-045 (S) Undeclared identifier rpc_x_ss_wrong_es_version_id.
/rpc/idl/lib/sscmaset.c", line 706.54: 1506-045 (S) Undeclared identifier rpc_x_ss_incompatible_codesets_id.
/rpc/idl/lib/sscmaset.c", line 708.54: 1506-045 (S) Undeclared identifier rpc_x_unknown_stub_rtl_if_vers_id.


 ../../../../../src/rpc/idl/lib/ndrui2.c
/rpc/idl/lib/ndrui2.c", line 453.54: 1506-045 (S) Undeclared identifier struct_cs_shadow.

[7/15/93 public]
The first part of this bug is duplicated with bug #8246 which has been fixed
and closed. 

The second part is fixed in ndrui2.c: rpc_ss_ndr_unmar_struct() by put its 
5th parameter struct_cs_shadow under "#ifndef _KERNEL", i.e.

#ifndef _KERNEL
                                                struct_cs_shadow, 
#else
                                                NULL, 
#endif

which is suggested by Tony Hinxman.  See r1.1.2.3 for the fix.

libkidl.a has been built successfully on RIOS (see 7-14-93 
nightly build log).



CR Number                     : 8265
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : 
Short Description             : memory leak introduced by OT 7464
Reported Date                 : 7/13/93
Found in Baseline             : 1.0.2
Found Date                    : 7/13/93
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/runtime/cnassoc.c
Sensitivity                   : public

[7/13/93 public]

The fix for OT 7464 causes a leak in the client.  The rpc_addr
copied in rpc__cn_assoc_open never gets freed.  Since an association is
frequently placed on the lookaside list for reuse, rpc__cn_assoc_acb_free is
not always called.  Thus, the rpc_addr copy needs to be checked and freed
in rpc__cn_assoc_acb_alloc instead of blindly initializing.
The differences looks like this:
 

Element CNASSOC.C(26P3) Line 4108
      1)    if (assoc->cn_ctlblk.rpc_addr != NULL)
      1)    {
      1)        rpc__naf_addr_free (&assoc->cn_ctlblk.rpc_addr, st);
      1)    }


Element CNASSOC.C(26P2) Line 4105
      2)    assoc->cn_ctlblk.rpc_addr = NULL;


This has been applied and tested in two of our code streams here at Digital.

	-Beth


    -Beth

[7/21/93 public]

The right place to fix this is in rpc__cn_assoc_acb_dealloc() before
calling rpc__list_element_free().

[7/21/93 public]

My original fix still stands.  The change that you added
will not change anything.  Furthermore, it's superflous.

The reasons why your change won't fix this leak is because the assocs
don't always get deallocated, but often times get reused which is what
I explained in my original text.  So on the reuse of an assoc,
rpc__cn_assoc_acb_alloc, needs to free the previously copied rpc_addr,
if non-null.

The reason why your fix is superflous is because rpc__cn_assoc_acb_dealloc()
calls rpc__cn_assoc_acb_free in rpc__list_element_free():

In cninit.c:

    /*
     * Initialize the association control block lookaside list.
     */
    rpc__list_desc_init (&rpc_g_cn_assoc_lookaside_list,
                         rpc_c_cn_assoc_lookaside_max,
                         sizeof(rpc_cn_assoc_t),
                         rpc_c_mem_cn_assoc,
                         (rpc_list_element_alloc_fn_t) rpc__cn_assoc_acb_create,
                         (rpc_list_element_alloc_fn_t) rpc__cn_assoc_acb_free,
                         &rpc_g_global_mutex,
                         &rpc_g_cn_lookaside_cond);

in rpclist.c (rpc__list_element_free():


        /*
         * If a free routine was specified when this lookaside list
         * was inited call it now.
         */
        if (list_desc->free_rtn != NULL)
        {
            (list_desc->free_rtn) (list_element);
        }

[7/21/93 public]

eek.  I understand what you are saying now.  It's been a while since we've 
fixed this fix.  Yes, you can place the fix where you suggested in the 
acb_dealloc routine. 
And it's where the original fix should have been.  I was incorrectly
thinking that the acb_dealloc routine didn't get called everytime.
But it's the rpc__cn_assoc_acb_free which doesn't get called everytime.
Either place would be fine.

[7/27/93 public]
rpc_addr is freed in rpc__cn_assoc_acb_dealloc(), which is the logical
choice.

[7/27/93 public]

The change made in rev 1.1.9.2 of rpc/runtime/cnassoc.c does not build on
HP-UX (and probably not on anything else for that matter).

The error I get is:

cc: "../../../../src/rpc/runtime/cnassoc.c", line 4220: error 1588: "cn_cntblk" undefined.

It looks like "cn_cntblk" was used instead of "cn_ctlblk".

[7/28/93 public]
sandbox problem. Fixed and checked in the correct file.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8257
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc/runtime/cn
Short Description             : Client context rundown function possibly canceled
Reported Date                 : 7/12/93
Found in Baseline             : 1.0.2
Found Date                    : 7/12/93
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : cnassoc.c
Sensitivity                   : public

[7/12/93 public]

When the client closes the TCP/IP connection, receive_packet() in cnrcvr.c
returns the rpc_s_connection_closed status. Then receive_dispatch() breaks
the for-loop and calls rpc__cn_assoc_post_error(). The first thing
rpc__cn_assoc_post_error() does is to cancel the receiver thread by calling
rpc__cn_network_close_connect(), then it evaluates the server association
state with the NoConnInd event. If there is a client context, the rundown
function will be executed which potentially be canceled by the pending
cancel posted by rpc__cn_network_close_connect(). (The user supplied
rundown function can have a cancellation point! Quick browsing execution
path within the state machines, I couldn't find any other cancellation
point, but you can't tell which system calls are cancellable. It's
implementation-defined in POSIX.)

I think that the fix is not to call rpc__cn_network_close_connect(), if st
== rpc_s_connection_closed .

[08/17/93 public]

The fix:
***************
*** 2696,2702 ****
           * First close the connection on the association. We will ignore
           * any error status from this routine. 
           */
!         rpc__cn_network_close_connect (assoc, &local_st);
  
          /*
           * Post a no connection indication event to the association
--- 2711,2719 ----
           * First close the connection on the association. We will ignore
           * any error status from this routine. 
           */
!       if (st != rpc_s_connection_closed) {
!             rpc__cn_network_close_connect (assoc, &local_st);
!       }
  
          /*
           * Post a no connection indication event to the association


Submitted.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8255
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc/common
Short Description             : Using RPC_DEBUG cancels threads unexpectedly
Reported Date                 : 7/12/93
Found in Baseline             : 1.0.2
Found Date                    : 7/12/93
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/runtime/rpcdbg.c, rpcdbg.h, cnpkt.h
Sensitivity                   : public

[7/12/93 public]

rpc__printf() in rpcdbg.c calls write(), which is a potential cancellation
point within CMA. If writing to the file descriptor 2 would block,
cma_write() calls cma__io_wait() which could be canceled. This makes
RPC_DEBUG almost useless, because the unexpected cancel causes an
unpredictable runtime state and data corruptions (especially in CN code).
As I understand it, whether system functions are cancelable or not is not
defined by POSIX. Therefore, the solution is to disable the general
cancelability while calling write(). Also rpc__print_source() should be
fixed to call rpc__printf() instead of fprintf().

Change line ~269 in rpcdbg.c:

    write (2, buff, strlen(buff));

to

    {
        int prev;
        prev = pthread_cancel (CANCEL_OFF);
        write (2, buff, strlen(buff));
        (void) pthread_cancel (prev);
    }

Line ~356:

        fprintf(stderr,"    [file: %s, line: %d]\n", file, line);

to

        EPRINTF("    [file: %s, line: %d]\n", file, line);

(If any other system calls used by rpc__printf() is also a cancellation
point, we'll still get an unexpected runtime behavior.)

fprintf() is called at a couple of places in CN code for printing error
messages, these may cause an unexpected thread cancellation.

[7/19/93 public]

There are typos in the above comment. pthread_cancel should be
pthread_setcancel for the obvious reason.

[8/26/93 public]

Also I've fixed RPC_CN_MEM_DUMP macro to call EPRINTF once per
line so that the timestamp and the thread-id can be printed with
the CN packet dump. (Not really part of OT8255)

New RPC_DEBUG options are added for upcoming atfork handler
support. (OT8103)

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8249
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : libidl
Short Description             : -DMIA confusion in sscmasrv.c
Reported Date                 : 7/8/93
Found in Baseline             : 1.0.3
Found Date                    : 7/8/93
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/idl/lib/sscmasrv.c
Sensitivity                   : public

[7/9/93]
Getting this right should be part of OSF's integration work.
I've reassigned this to the person responsible.

[7/8/93 public]

In rpc/idl/klib, sscmasrv.c won't build unless MIA is defined on the
compiler's command line (and that #define wasn't added to
rpc/idl/klib/Makefile).  It blows up looking for the undefined type
IDL_msp_t which is defined in an include file only included if MIA is
defined.

Either an explicit -DMIA shouldn't be required, or the files should build
both ways.

[7/13/93 public]

reassigned to pwang since he was doing the fix..

[7/15/93 public]
Fixed by updated the klib/Makefile to match with lib/Makefile which included
Defined -DMIA to CFLAGS and updated KERNEL_OFILES (and USER_OFILES). See 
r1.2.9.2 for the fix.  libkidl.a has been built successfully on RIOS (see 
7-14-93 nightly build log).



CR Number                     : 8248
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : idl code generation error with out_of_line attribute
Reported Date                 : 7/8/93
Found in Baseline             : 1.0.2
Found Date                    : 7/8/93
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : New IDL compiler
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[7/8/93 public]
I apologize for the screw up with OT 8247. Have no idea why the entire
text of the defect was never logged.
We noticed a problem with the marshalling code when using the "out_of_line"
attribute with certain datatypes. The symptom of the problem was a core
dump in the client stub in rpc__dg_call_transmit_int() trying to copy data 
into DG packets.
The following idl and acf files can be used to reproduce this bug.
------------------idl file----------------
>[
>uuid(4d37f2dd-ed96-0000-02c0-37cf1e000000),
>version(4.0)
>/* provider_version(1) */
>]
>
>interface foo
>{
>
>typedef struct hyper_t {
>	unsigned32 high;
>	unsigned32 low;
>} hyper_t;
>
>typedef struct recordLock {
>	signed16	      l_type;
>	signed16	      l_whence;
>	unsigned32   l_start_pos;
>	unsigned32   l_end_pos;
>	unsigned32   l_pid;
>	unsigned32   l_sysid;
>	unsigned32   l_fstype;
>	unsigned32   l_spare0;
>	unsigned32   l_spare1;
>} recordLock_t;
>
>typedef struct token {
>	hyper_t tokenID;
>	unsigned32 expirationTime;
>	hyper_t type;
>	unsigned32 beginRange;	
>	unsigned32 endRange;
>	unsigned32 beginRangeExt;	
>	unsigned32 endRangeExt;
>} token_t;
>
>typedef struct second_type {
>	hyper_t Cell;
>	hyper_t Volume;
>	unsigned32 Vnode;
>	unsigned32 Unique;
>} second_type_t;
>
>typedef struct first_type {
>    second_type_t second;
>    hyper_t  token;
>    hyper_t  type;
>    unsigned32  iflags;
>    unsigned32  oflags;
>    hyper_t  errorId;
>    token_t  a;
>    hyper_t  achoice;
>    token_t  b;
>    hyper_t  bchoice;
>    recordLock_t recordLock;
>} first_type_t;
>
>typedef struct aggr_type  {    
>	long len;
>	[length_is(len)] first_type_t val[32];
>} aggr_type_t;
>
>
>unsigned32 func
>(
>	[in]    handle_t	h,
>	[in, out] aggr_type_t 	*ptr
>);
>
>}
>
>
-----------------end of idl file-------------------
----------------acf file---------------------------
>interface foo
>{
>typedef [out_of_line] token_t;
>typedef [out_of_line] first_type_t;
>typedef [out_of_line] second_type_t;
>}
>
----------------end of acf file---------------------
We observed two problems with the client stub.
1.   The predicate sp_iovec is used in a strange way. The predicate
     NIDL_msp initializes itself as:
     NIDL_msp->p_iovec = (rpc_iovector_t*)&sp_iovec;
     However the fields of sp_iovec like buff_addr and data_addr
     are never initialized.
2.   A "for" loop in the same client stub contains the following
     line as its first statement:
     NIDL_msp->space_in_buff -= (op - NIDL_msp->op);
     Again, NIDL_msp->op was not initalized.
Approximately the stack trace appeared to be:
     rpc__dg_call_transmit_int()
     rpc_dg_call_transmit()
     rpc_call_transmit()
     rpc_ss_marsh_change_buff()
     and it appeared that rpc__dg_call_transmit_int() was accessing
     the fields of sp_iovec that were never initialized.
Pardon me for the ugly ">" characters at the beginning of some of the
lines. I learnt the hard way that OT will truncate my message if it
sees a "[" character at the beginning of a line
Changed Responsible Engr. from `hinxman' to `sanders' 
Changed Resp. Engr's Company from `dec' to `hp'

[7/9/93 public]
Filled in Interest List CC with `kazar@transarc.com, sanzi@transarc.com, 
 pakhtar@transarc.com'

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8247
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : error in code generation when using out_of_line attribute
Reported Date                 : 7/8/93
Found in Baseline             : 1.0.2
Found Date                    : 7/8/93
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : New IDL compiler
Sensitivity                   : public
As the new IDL compiler ignores [out_of_line], and in the absence of any
data below, I presume this CR refers to the old compiler.
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[7/8/93 public]
IDL seems to generate buggy code when using "out_of_line" attribute
for certain datatypes. The idl and acf files contained the following:
-----------idl file---------------------

[7/8/93 public]
Filled in Interest List CC with `sanzi@transarc.com, kazar@transarc.com, 
 pakhtar@transarc.com'

[7/9/93 public]

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8246
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : krpc
Short Description             : rpc/lib/kidl doesn't build
Reported Date                 : 7/8/93
Found in Baseline             : 1.0.3
Found Date                    : 7/8/93
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/kruntime/exc_handling_ids_krpc.h
Sensitivity                   : public
In each case, a spurious "_id" has been stropped on to the name of an
exception. This error is not present in the code that was supplied by
DEC to OSF, and must have been introduced during integration.

[7/8/93 public]

when building in rpc/idl/klib on HP-UX (and probably on RIOS, too), we get:

cc: "/project/dce/build/dce1.0.3i/src/rpc/idl/lib/sscmaset.c", line 448:
error 1588: "rpc_x_call_timeout_id" undefined.
cc: "/project/dce/build/dce1.0.3i/src/rpc/idl/lib/sscmaset.c", line 608:
error 1588: "rpc_x_no_ns_permission_id" undefined
.
cc: "/project/dce/build/dce1.0.3i/src/rpc/idl/lib/sscmaset.c", line 700:
error 1588: "rpc_x_ss_bad_buffer_id" undefined.
cc: "/project/dce/build/dce1.0.3i/src/rpc/idl/lib/sscmaset.c", line 702:
error 1588: "rpc_x_ss_bad_es_action_id" undefined
.
cc: "/project/dce/build/dce1.0.3i/src/rpc/idl/lib/sscmaset.c", line 704:
error 1588: "rpc_x_ss_wrong_es_version_id" undefi
ned.
cc: "/project/dce/build/dce1.0.3i/src/rpc/idl/lib/sscmaset.c", line 706:
error 1588: "rpc_x_ss_incompatible_codesets_id" u
ndefined.
cc: "/project/dce/build/dce1.0.3i/src/rpc/idl/lib/sscmaset.c", line 708:
error 1588: "rpc_x_unknown_stub_rtl_if_vers_id" u
ndefined.
*** Error code 1

This appears to be a cascade effect of the new IDL compiler.

We'll be looking for a fix shortly.

[7/8/93 public]

The fix is to add the new exception id's to
rpc/kruntime/exc_handling_ids_krpc.h

[7/8/93 public]

The tacked-on `_id' is not spurious; it's a feature of how the exception
package (specifically, EXCEPTION_INIT) works in the kernel; it's defined as

#define EXCEPTION_INIT(e)   (   \
        (e).match.value = e ## _id, \
        (e).kind = _exc_kind_status)

in rpc/kruntime/exc_handling.h

I now have a fixed version of exc_handling_ids_krpc.h which gets the above
module to build.

Defect reassigned to me 'cuz I have the fix..

[7/13/93 public]

reassigned to pwang since he was doing the fix.

[7/15/93 public]

Fixed by added the definitions to exc_handling_ids_krpc.h for the 
new error codes introduced by new idl. See r1.1.8.4 for the fix.
libkidl.a has been built successfully on RIOS (see 7-14-93 nightly 
build log).



CR Number                     : 8245
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc/runtime/ipnaf.c
Short Description             : TCP_NODELAY setting error in ipnaf.c
Reported Date                 : 7/8/93
Found in Baseline             : 1.0.2
Found Date                    : 7/8/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/runtime/ipnaf.c
Sensitivity                   : public

[7/8/93 public]

Licensee reported:

  when programming our own protocol extensions, I discovered an error in
the routine set_pkt_nodelay. The integer variable 'delay', which is
passed to the subsequent 'setsockopt' call, is not initialised, thus
a quasi-random value is passed to the call; in other words, the
TCP_NODELAY option is sometimes (statistically) turned on, sometimes
off.

  The problematic line is in the file 'ipnaf.c', line 1468 in the
version 1.0.1, or 1489 in 1.0.2. The 'setsockopt'-call concerned is
then on line 1477ff (1.0.1) or 1498ff (1.0.2).

  The declaration (line 1468 or 1489 resp.) should run

  int delay = 1;

  instead of just

  int delay;

[7/30/93 public]
initialized the variable delay to 1;

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8242
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : Add -no_header flag
Reported Date                 : 7/8/93
Found in Baseline             : 1.0.3
Found Date                    : 7/8/93
Severity                      : D
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/idl/idl_compiler/command.c
Sensitivity                   : public

[7/8/93 public]
There have been a number of requests to provide a method of suppressing
header file generation in an IDL compilation.
It is proposed to add a command line flag "-no_header" which will cause
header file generation to be suppressed.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8240
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : port_gd
Short Description             : -p switch incompletely documeneted
Reported Date                 : 7/7/93
Found in Baseline             : 1.0.2
Found Date                    : 7/7/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : port_gd/3_rpc.gpsml
Sensitivity                   : public

[7/7/93 public]

The porting and testing guide page 3-33 describes the -p flag 
of the runtime/perf/server as having two arguments. By looking at the 
implementation of the server it is appearent that there is an optional
third argument, the name of a keytab file which should alos be documented.

	[-p <authn proto>,<principal>[,<keytab file>]

Also, we should probably point out (maybe in section 3.4.2) that a
keytab file must be setup (probably with rgy_edit ktadd) for a server
principal before it will be possible to run the server program with
proto = private key authentication. If this setup is not done, the server
will print out the following message at startup.

***Error setting principal - Requested key is unavailble (dce/sec)

[07/08/93 public]
Assigned this CR to writer Doug Weir.

[09/21/93 public]
Made the two additions specified above.

[11/12/93 public]

Verified changes in latest doc build and closed this CR.



CR Number                     : 8238
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : DCE apps not usable between sites with n/w firewalls
Reported Date                 : 7/7/93
Found in Baseline             : 1.0.2
Found Date                    : 7/7/93
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b16
Affected File(s)              : kruntime/rpcmem_krpc.h
./rpc/runtime/RIOS/comsoc_sys.c
./rpc/runtime/SVR4/comsoc_sys.c
./rpc/runtime/com.h
./rpc/runtime/cominit.c
./rpc/runtime/cominit.h
./rpc/runtime/comnaf.c
./rpc/runtime/comnaf.h
./rpc/runtime/comp.c
./rpc/runtime/comsoc_bsd.c
./rpc/runtime/dgsoc.c
./rpc/runtime/ipnaf.c
./rpc/runtime/ipnaf.h
./rpc/runtime/rpcmem.h
./rpc/runtime/cnnet.c
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : open

[7/7/93 public]
There is a major operational problem with DCE Applications which
are spread across networks which use router filtering as a
security measure.  By filtering, I mean restricting in-comming
network packets to specific addresses on specific ports.
I believe this is a common practice in networks today.  To my
knowledge IBM, OSF, Transarc, HP and DEC implement this type
of security.
Since DCE dynamically determines port numbers for its services,
DCE applications (like DFS) cannot function between two sites
which implement router filtering.  This poses a serious usability
problem for these applications and in my opinion a major roadblock
in the success of DCE (and certainly DFS).
DCE must be fixed to operate in this environment.  It is wrong to
expect a customer to open up router filters to let all packets in.
I do not think IBM, OSF, Transarc, HP or DEC would be willing to
do this, so why should DCE/DFS customers.
I realize that DCE itself has security and should not require
security firewalls, but the fact remains that DCE must be
usable in environments were firewalls are used to protect
access to non DCE services.
One potential solution I have heard for this problem is to add
an API to the DCE RPC to allow a given set of port ranges to
be specified.  The RPC would then only grant port numbers over
that set of ranges and filters could be opened up over those ranges.
I have not done any detailed study, but I would guess that a range
of about 500 ports would be sufficient.
I believe this problem needs to be addressed ASAP as DCE based
applications will be shipping soon by several vendors.  It would
be best if an OSF endorsed solution were available for this
before the first customer complaint rolls in and the vendors
start solving it independently to address the customer's needs.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `open'

[7/7/93 public]

We recently had discussions on this issue, following are our conclusions:

- Any change in this area is an implementation facility and not an
AES-defined architectural facility.

- It is reasonable to provide an environment variable (or equivalent
interface for krpc) which is read at RPC startup.  Using this facility will
force RPC to request ports only in particular ranges.  Example:

  setenv RPC_RESTRICTED_PORTS="ncacn_ip_tcp:5000-5500,6250-6500"

- Well-known endpoints are not governed by this facility.

- Un*x OS provides no guarantee that other applications will not also try
to use ports in specified ranges.  

- Un*x implementations commonly #define	IPPORT_USERRESERVED 5000.  Any
process may ask for ports above this number, and such ports are not
normally not given out unless you ask for them.  These ports are
appropriate for use with RPC_RESTRICTED_PORTS.

[7/7/93 public]

IMHO, this is an enhancement, not a defect (it doesn't work with firewalls,
but that was never a design consideration in the architecture).

The environment variable stuff sounds fine, but I think you also want to
put the same stuff in dce_cf.db as well (not all os's provide a routine way
to set environment variables for all processes at login time).

This should *not* be left to vendors, as this will result in chaos as each
distinct implementation will do it differently.

[7/8/93 public]
While this isn't specifically a DCE security problem, it is security related,
so I've added dce-ot-sec to the InterestCC list (mainly because none of us
except Bill is on the dce-ot-rpc list) so we'll know what's happening with it.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.

[11/11/93 public]

Since the client CN runtime does not call rpc__socket_bind(), the port
restriction is not working in the client.
rpc__cn_network_req_connect()::cnnet.c calls rpc__socket_open(),
rpc__socket_set_*() and then rpc__socket_connect(). And the port is
automatically assigned by connect(2).

[11/12/93 public]

That's right; it was a nongoal to try to make the client socket bind to a
particular port.  

From discussions with network admin folks inside and outside of OSF, it
appears that "typical" firewall configurations permit any outgoing ports on
the client side of a call.  Most sites put the emphasis on protecting the
server side.

[11/12/93 public]

The question is what happens to incoming packets.  Are you saying that the
firewall router needs to be smart enough to know which incoming packets are 
on connections that were initiated inside the firewall?  Seems unlikely...

[11/12/93 public]

Actually not that strange.  Routers do make a distinction of which side a
conversation originates from.  Sites can/do allow clients to call anyhere,
but restrict *incoming* calls.

In any case for sites which don't make the distinction, this OT raises a
valid point.  It would be reasonable to go through the modified
rpc__socket_bind() for client sockets.

[11/12/93 public]

The DG code always calls rpc__socket_bind(). Thus, the port restriction *is
working* in the DG client, now. It's only the CN client ignoring the port
restriction. If it wasn't your goal to make a client bind to a particular
port, then the DG client needs to be fixed.

I think that it's fairly trivial to make
rpc__cn_network_req_connect()::cnnet.c call rpc__socket_bind() before
calling rpc__socket_connect().

[11/12/93 public]

It was something we thought about and decided wasn't super necessary, but I
certainly have no reservations about making CN act like DG and bind to a
particular port.

[11/15/93 public]
So, when Seiichi tests out the one line fix to allow the client to
behave in this manner, we can submit this code to 1.1.

Lowering to a C3, changing fixby to 1.1.

[11/22/93 public]

Here is what we are testing. It's more than one line due to the allocation
of the temporary rpc_addr structure. :-)

--- cnnet.c	Mon Nov 22 15:51:42 1993
+++ /afs/ch/project/dce/build/KK/src/rpc/runtime/cnnet.c	Sat Nov 20 09:36:14 1993
@@ -8,6 +8,17 @@
 /*
  * HISTORY
  * $Log:	c008238,v $
# Revision 1.19  94/09/22  16:03:15  root
# changed fields: Status  
# 
# Revision 1.18  94/08/22  16:30:04  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.   new/changed/deleted note(s) [tom 8/22/94 public]
# 
# Revision 1.17  94/03/16  13:09:41  pnh
# history editing for V3 conversion
# 
# Revision 1.16  94/03/15  16:25:09  nata
# added the Created HISTORY line
# 
# Revision 1.15  93/11/22  16:04:37  notuser
# changed fields:  new/changed/deleted note(s) [tatsu_s 11/22/93 public]
# 
+ * Revision 1.1.8.2  1993/11/18  16:45:39  tatsu_s
+ * 	Added the debugging output.
+ * 	[1993/11/16  19:16:57  tatsu_s]
+ *
+ * 	Fix OT8238.
+ * 	Call rpc__socket_bind() in rpc__cn_network_req_connect().
+ * 	[1993/11/15  20:39:00  tatsu_s]
+ *
+ * Revision 1.1.5.3  1993/09/15  15:28:38  root
+ * 	    Loading drop DCE1_0_3b03
+ * 
  * Revision 1.1.8.3  1993/08/26  19:15:55  tatsu_s
  * 	Bug 1709 - If rpc_addr_vec is empty, return rpc_s_no_addrs status
  * 	in rpc__cn_network_desc_inq_ep().
@@ -1060,6 +1071,11 @@
     rpc_socket_error_t  serr;
     volatile boolean32  retry_op;
     boolean32           connect_completed;
+#ifndef HPDCE_FIX_OT8238
+    rpc_naf_id_t        naf_id;
+    rpc_addr_p_t        temp_rpc_addr;
+    unsigned32          temp_status;
+#endif /* HPDCE_FIX_OT8238 */
 
     RPC_CN_DBG_RTN_PRINTF (rpc__cn_network_req_connect);
     CODING_ERROR(st);
@@ -1131,6 +1147,67 @@
          */
         rpc__socket_set_close_on_exec(assoc->cn_ctlblk.cn_sock);
 
+#ifndef HPDCE_FIX_OT8238
+        /*
+         * Allocate the temporarry rpc_addr to be passed to
+         * rpc__socket_bind().
+         */
+        naf_id = rpc_g_protseq_id[rpc_addr->rpc_protseq_id].naf_id;
+        rpc__naf_addr_alloc (rpc_addr->rpc_protseq_id,
+                             naf_id,
+                             (unsigned_char_p_t) NULL,  /* endpoint */
+                             (unsigned_char_p_t) NULL,  /* network address */
+                             (unsigned_char_p_t) NULL,  /* network option */
+                             &temp_rpc_addr,
+                             st);
+        if (*st != rpc_s_ok)
+        {
+            serr = rpc__socket_close (assoc->cn_ctlblk.cn_sock);
+            if (RPC_SOCKET_IS_ERR(serr))
+            {
+                /*
+                 * The socket close failed.
+                 */
+                RPC_DBG_PRINTF (rpc_e_dbg_general, rpc_c_cn_dbg_errors,
+                                ("(rpc__cn_network_req_connect) desc->%x rpc__socket_close failed, error = %d\n", 
+                                 assoc->cn_ctlblk.cn_sock, 
+                                 RPC_SOCKET_ETOI(serr)));
+            }
+            return;
+        }
+
+        /*
+         * Next, bind the socket to the RPC address.
+         */
+        serr = rpc__socket_bind (assoc->cn_ctlblk.cn_sock, temp_rpc_addr);
+        rpc__naf_addr_free(&temp_rpc_addr, &temp_status);
+        if (RPC_SOCKET_IS_ERR (serr))
+        {
+            RPC_DBG_PRINTF (rpc_e_dbg_general, rpc_c_cn_dbg_errors,
+                            ("(rpc__cn_network_req_connect) desc->%x rpc__socket_bind failed, error = %d\n",
+                             assoc->cn_ctlblk.cn_sock, 
+                             RPC_SOCKET_ETOI(serr)));
+            *st = rpc_s_cant_bind_sock;
+            
+            /*
+             * The bind request failed. Close the socket just created
+             * and free the association control block.
+             */
+            serr = rpc__socket_close (assoc->cn_ctlblk.cn_sock);
+            if (RPC_SOCKET_IS_ERR(serr))
+            {
+                /*
+                 * The socket close failed.
+                 */
+                RPC_DBG_PRINTF (rpc_e_dbg_general, rpc_c_cn_dbg_errors,
+                                ("(rpc__cn_network_req_connect) desc->%x rpc__socket_close failed, error = %d\n", 
+                                 assoc->cn_ctlblk.cn_sock, 
+                                 RPC_SOCKET_ETOI(serr)));
+            }
+            return;
+        }
+#endif /* HPDCE_FIX_OT8238 */
+
         /*
          * Indicate that the connection is being attempted.
          */

[8/22/94 public]
Plugged in HP's suggested fix.



CR Number                     : 8236
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 11358
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : There are fprintf's in the
code where errors are printed out directly w/o going through message catalog.
Reported Date                 : 7/6/93
Found in Baseline             : 1.0.2
Found Date                    : 7/6/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b15
Affected File(s)              : many
Sensitivity                   : public

[7/6/93 public]

	Customer reported:

 : 
 : Does anyone know what the RPC  Error Message below means?
 : 
 : 
 : Starting DCE daemons:
 : 	rpcd
 : 	secd
 : 	(RPC_CN_AUTH_VFY_CLIENT_REQ) on server failed status = 1412901f
 : 	sec_clientd
 : 	cdsadv
 : 	cdsd
 : 	gdad
 : 	dtsd


	We received this error message trying to restart a cell via "dce 
	start." Looking around the rpc code for the origin of this message,
	we found it in:

		rpc/runtime/cnsassm.c, line 3259, roughly.

		What's odd is that this error message is printed directly to 
	stderr, without any translation to a message string.  We found what we
	think is the correct message for this string in a kerberos message 
	catalogue, but should not have had to do this by hand. 

	This is a bug.  error messages printed from the runtime with error
	status should be translated via the catopen facility 
	( dce_error_inq_txt call in this case?! )
	and not dumped raw to the screen if at all possible. 

There are more than one place where fprintf is used to print out a error
status. This probably came from early debug purpose. But we need to clearn
up, especially if what being printed is important.

[7/26/93 public]
This problem will be fixed in 1.1; Will be addressed as part of 
Serviceability task.

[08/31/93 public]
Since its getting fixed in 1.1, defer it to 1.1

[03/23/94 public]
Reassigning this to Seiichi since I believe he is doing the 1.1 
seviceablility work for RPC.

[8/15/94 public]
These messages now use serviceability and dce_error_inq_text().
Closed.



CR Number                     : 8235
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc/runtime/dg
Short Description             : Callback from a server crashes the client.
Reported Date                 : 7/6/93
Found in Baseline             : 1.0.2
Found Date                    : 7/6/93
Severity                      : B
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/runtime/dgexec.c
Sensitivity                   : public

[7/6/93 public]

Callback causes the SIGSEGV in rpc__dg_execute_call() in the client. It
happens at line ~473 in dgexec.c:

    key_info = scall->scte->key_info; 

In the callback case, scall->scte is always NULL. Thus, it should be fixed
to:

    if (scall->c.is_cbk)
        key_info = NULL;
    else
        key_info = scall->scte->key_info;

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8221
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : relnotes
Short Description             : If you have /etc/ncs/llbd
daemon running on HP machine, dce_config will fail.
During the config of the security server, you get the message" rpcd/llbd
cannot bind socket".
Work around included below.
Reported Date                 : 7/1/93
Found in Baseline             : 1.0.3
Found Date                    : 7/1/93
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : relnotes/1_overview.gpsml
Sensitivity                   : public

[7/1/93 public]

On HP machine you'll get an error during the configuration of the security
server. You get the ambiguous error message "cannot bind socket (dce
/rpc)" for rpcd/llbd. 


Work around:
 make the following modifications to your system:

	/etc/nfsncsrc
		set START_LLBD=0
	kill /etc/ncs/llbd daemon

[7/1/93 public]

Change to doc bug, this information should go into the Porting Guide or the
Release Notes.

[07/06/93 public]
Assigned this CR to writer Doug Weir.

[11/7/93 public]
Added this information to the "State of DCE Configuration" and "State of
Security" sections, in Chapter 1 of the Release Notes and in Chapter 7 of
the Porting Guide.

[11/08/93 public]
dce_config will check for llbd running and kill it on HP-UX platforms.
/etc/rc.dce will also kill llbd before starting dce.

[11/12/93 public]

This is fixed and verified. I've had conversations with both Tom and Marcy
about it.

[11/12/93 public]

Verified changes in latest doc build and closed this bug.



CR Number                     : 8220
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : returning conformant arrays
Reported Date                 : 7/1/93
Found in Baseline             : 1.0.2
Found Date                    : 7/1/93
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : 9_idl.gpsml
Sensitivity                   : public

[7/1/93 public]
The AES has some discussion of pointers and arrays and their use in IDL.
In particular,
	void op ([in, out] long s, [in, out, size_is(s)] long **myarray);
is an array of pointers to longs, not a pointer to an array of longs.
This is a C "ambiguity" that has no effect in standard C, but does
need clarification when IDL is used.  This should be added to the AppDevGd.

[07/06/93 public]
Assigned this CR to writer Steve Lewontin.

[10/12/93 public]

Added text similar to that in the AES to the pointer section.

[11/11/93 public]

Verified changes in latest doc build and closed this CR.



CR Number                     : 8217
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : cell_profile should be cell-profile
Reported Date                 : 6/30/93
Found in Baseline             : 1.0.2
Found Date                    : 6/30/93
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : admin_ref/man8rpc/rpccp.8rpc,
admin_ref/man8rpc/rpccp_add_element.8rpc,
admin_ref/man8rpc/rpccp_show_profile.8rpc,
app_gd/rpc/6_advanced_topics.gpsml, app_gd/rpc/7_nsi_usage.gpsml
Sensitivity                   : public

[hal 6/30/93 public] 

It appears that in some cases our docs refer to cell-profile as
cell_profile.  I've appended the comment from original mail message
reporting this and the result of a find/grep for all such instances
(although I may have forgotten to make the grep case-insensitive).

The comment:
"I notice that some of the documentation (esp., the Prentice-Hall
rpccp manpage) uses the spelling "cell_profile" with an underscore, but
it's supposed to be "cell-profile" with a hyphen."

The search results:
for example, \*L/.:/cell_profile\*O.
./admin_ref/man8rpc/rpccp.8rpc
\*L/cell_profile\*O, in the local cell:
\*C> \*L/.:/cell_profile\*O
\*C> \*L-d   -m  /.:/cell_profile
./admin_ref/man8rpc/rpccp_add_element.8rpc
\*Lprofile /.:/cell_profile\*O in the local cell:
./admin_ref/man8rpc/rpccp_show_profile.8rpc
   /.../C=US/O=uw/OU=MadCity/cell_profile
   00000000-0000-0000-0000-000000000000,0.0   /.:/cell_profile   0
entry name for the default profile, \*L/.:/cell_profile\*O:
   00000000-0000-0000-0000-000000000000,0.0   /.:/cell_profile   0
\*L/.:/cell_profile\*O, which contains
/.:/LandS/cell_profile contents:
./app_gd/rpc/6_advanced_topics.gpsml
for example, \*L/.:/cell_profile\*O.
./app_gd/rpc/7_nsi_usage.gpsml

[08/12/93 public]
Fixed in the specified (5) files.  Verified by myself.

[08/19/93 public]
Closed bug.



CR Number                     : 8193
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : i486
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rpc_mgmt_inq_if_ids fails to return a NULL if_id_vector when a NULL binding is passed and there are no interfaces.
Reported Date                 : 6/23/93
Found in Baseline             : 1.0.2
Found Date                    : 6/23/93
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : comif.c
Sensitivity                   : public

[6/23/93 public]

A DCE VTS API test fails when calling rpc_mgmt_ing_if_ids() with a NULL
binding handle argument. The failure is because the RPC runtime does not
set the if_id_vector to NULL, as specified in the AES/DC, page 3-48, dated
February 20, 1993. The return status was correctly set to
rpc_s_no_interfaces, however. The test log for this failure:

10|189 /mgmt_obj/c_inq_if_ids 15:40:45|TC Start, scenario ref 54-20, ICs {6}
15|189 1.10 1|TCM Start
400|189 6 1 15:40:46|IC Start
200|189 6 15:40:46|TP Start
520|189 6 12683 1 1| rpc_mgmt_inq_if_ids_6, Assertion 06(A):
520|189 6 12683 1 2|When a NULL binding handle is supplied to
rpc_mgmt_inq_if_ids,
520|189 6 12683 1 3|and the application has no interfaces registered,
520|189 6 12683 1 4|then if_id_vector is set to NULL and status is set to
520|189 6 12683 1 5|rpc_s_no_interfaces.
220|189 6 1 15:40:47|FAIL
410|189 6 1 15:40:47|IC End
80|189 0 15:40:47|TC End

Note: this failed on the 486 DCE port but the problem should exist on all
ports.

[8/4/93 public]
if_if_vector is set to NULL in the case of no registered interfaces.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8181
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : port_gd
Short Description             : SERVERHOST variable needs to be documented
Reported Date                 : 6/20/93
Found in Baseline             : 1.0.2
Found Date                    : 6/20/93
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : port_gd/3_rpc.gpsml
Sensitivity                   : public

[6/20/93 public]

Full Description:

     There is no mention of the environment variable SERVERHOST in the Porting
     and Testing guide.  The version of the manuals which we currently have
     is Revision 1.0, Update 1.0.2

Proposed Solution:

     Mention in the Porting & Testing guide that the environment variable
     SERVERHOST must be set to the machine name of the machine that is to
     run the server daemon.

[09/21/93 public]
Made the specified addition.

[11/12/93 public]

Verified change in latest doc build and closed this CR.



CR Number                     : 8169
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : admin ref
Short Description             : rpccp show mapping should allow -v option
Reported Date                 : 6/17/93
Found in Baseline             : 1.0.2
Found Date                    : 6/17/93
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpccp_remove_mapping.8rpc
Sensitivity                   : public

[6/17/93 public]

rpccp show mapping should allow -v option -- see rpc.runtime.src
CMVC 2538 for reference

Problem with remove mapping using rpccp when -v upto option is given.

I used show mapping to list mappings on system, then I tried removing
the mapping with -v option.

  <object>         019EE420-682D-11C9-A607-08002B0DEA7A
  <interface id>   019EE420-682D-11C9-A607-08002B0DEA7A,1.0
  <string binding> ncadg_ip_udp:192.100.227.27[2547]
  <annotation>     Time Service

Was one of the item on list. I then remove using:

rpccp remove mapping -b ncadg_ip_udp:192.100.227.27[2547] \
-i 019EE420-682D-11C9-A607-08002B0DEA7A,2.0 -v upto


Tom Li

    <Note by kwalker (Ken Walker), 92/10/20 17:53:07, action: note>
For the record, none of the parameters for the -v option seem to work.  The
-v flag doesn't do a thing for me...

    <Note by phighley (Paul T. Highley), 92/11/25 10:41:55, action: note>
After looking at this defect, the rpccp/rpcd code and documentation I have
come to the following conclusions:

  1. The rpccp remove mapping documentation should remove it's reference to
     the '-v' option.

     Currently the documentation has the  '-v' option mentioned for remove
     mapping but in a contradictory way.  It states that if the '-v' option
     is used without the '-i' option it will be ignored ... but the remove
     mapping command REQUIRES the '-i' option.

     It would be possible to implement this functionality (currently there is
     nothing in rpccp to support the '-v' option for remote mapping) but I
     don't think it is what the designers had in mind.  They already restrict
     you from removing more than one interface at a time and if you want to
     remove more that one binding for a particular interface you must
     explicitly list them out.

  2. The rpccp show mapping code needs to allow the '-v' option.

     Currently the rpccp show mapping documentation says the '-v' option is
     valid but the code does not allow it.  There is code in show_mapping() to
     handle it but the command line syntax checking doesn't let the '-v'
     option through with the show mapping command.

  3. The rpcd handles the '-v upto' option incorrectly.

     The rpcd is handling '-v upto' in the opposite manner than the
     documentation states. If versions 1.0, 2.0, 2.1 and 3.0 for a 
     pariticular
	r
     interface are in the endpoint database and you do a show mapping for
     version 2.1 with the '-v upto' option you will receive mappings fo1.0.
     versions 2.1 and 3.0 instead of the correct versions 2.1, 2.0 and 1.0

I am going to use this defect to fix problem #2.  I have opened CMVC 
defect 3720 for problem #1 and defect 3721 for problem #3.

    <Note by page (Scott Page), 93/01/20 13:04:48, action: assign>
Defect is actually being worked by HP/DEC/OSF.  Some may be completed
in b11, others in b12.  Am assigning to galvis so the CMVC state can
be changed appropriately as the dce1.0.2 code merges are done.

Along with HP/DEC/OSF, IBM has submitted fixes for some of these problems.

    <Note by galvis (Grant Alvis), 93/03/05 16:47:03, action: verify>
OSF fix merged in b14 code drop

[06/17/93 public]
Assigned this CR to myself.

[06/17/93 public]

I think the only outstanding problem listed in this defect is the
-v option in the rpccp remove mapping manpage (it should be removed).  
rpccp has already been fixed.

[08/12/93 public]
Removed the -v option from the rpccp_remove_mapping.8rpc ref page.
Fixed and verified by Dave Weisman.

[08/19/93 public]
Closed bug.



CR Number                     : 8157
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : rpc/runtime/cn
Short Description             : Illegal state transition in CN
client assoc sm
Reported Date                 : 6/15/93
Found in Baseline             : 1.0.2
Found Date                    : 6/15/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b15
Affected File(s)              : rpc/runtime/cnassm.h
                                             rpc/runtime/cnassoc.c
                                             rpc/runtime/cncassm.c
                                             rpc/runtime/cnsassm.c
                                             rpc/sys_idl/rpc.sams
Sensitivity                   : public

[6/15/93 public]

We have seen the following rgy_edit crash in our system test.

(rpc__cn_assoc_sm_protocol_error) Illegal state transition detected in CN
client association state machine
(rpc__cn_assoc_sm_protocol_error) Current state: 4
(rpc__cn_assoc_sm_protocol_error) Current event: 5
(rpc__cn_assoc_sm_protocol_error) Assoc: 400a7df0
(rpc) *** FATAL ERROR "(rpc__cn_assoc_sm_protocol_error)" at cnassoc.c\2786 ***
ksh: 7846 Abort(coredump)

We lost the core dump file, but trying to reproduce it.

[6/18/93 public]

The crashed process was dce_login, not rgy_edit. The stack trace is not
helpful.

Copyright Hewlett-Packard Co. 1985,1987-1992. All Rights Reserved.
<<<< XDB Version A.09.01 HP-UX >>>>
Core file from:  dce_login
Child died due to: IOT instruction
Procedures:      0
Files: 0
(file unknown): _kill@libc_r +0x00000008: (line unknown)
>Stubs are visible.
 0 _kill@libc_r + 0x00000008 (hp-ux export stub)
 1 _raise@libc_r + 0x00000024 (0x22206174, 0x726f7229, 0x6c5f6572, 0x746f636f)
 2 _raise@libc_r + 0x00000008 (hp-ux export stub)
 3 _abort@libc_r + 0x0000011c (0x7afaeb98, 0x7afb14d4, 0x7afb1514, 0xae2)
 4 abort@libc_r + 0x00000008 (hp-ux export stub)
 5 rpc__die@libdce + 0x00000074 (0x7afb14a4, 0x400a7df0, 0x46000000, 0x2000000)
 6 rpc__die@libdce + 0x00000008 (hp-ux export stub)
 7 rpc__cn_assoc_sm_protocol_erro + 0x000000a8 (0, 0, 0x400cfee0, 0x80b91e0b)
 8 rpc__cn_assoc_sm_protocol_erro + 0x00000008 (hp-ux export stub)
 9 rpc__cn_sm_eval_event@libdce + 0x00000120 (0, 0, 0, 0)
10 rpc__cn_sm_eval_event@libdce + 0x00000008 (hp-ux export stub)
11 receive_dispatch@libdce + 0x00001470 (0x400cf6a0, 0, 0, 0)
12 rpc__cn_network_receiver@libdc + 0x000003b4 (0x400cf288, 0, 0, 0)
13 rpc__cn_network_receiver@libdc + 0x00000008 (hp-ux export stub)
14 cma__thread_base@libdce + 0x000000e4 (0, 0, 0, 0)
15 cma__thread_base@libdce + 0x00000008 (hp-ux export stub)
16 cma__thread_start1@libdce + 0x00000028 (0, 0, 0, 0)
17 cma__thread_start1@libdce + 0x00000008 (hp-ux export stub)
18 cma__thread_start0@libdce + 0x00000008 (0, 0, 0, 0)
19 _kill@libc_r + 0x00000008 (hp-ux export stub)
20 cma__thread_start0@libdce + 0x00000008 (0, 0, 0, 0)
21 _kill@libc_r + 0x00000008 (hp-ux export stub)
22 cma__thread_start0@libdce + 0x00000008 (0, 0, 0, 0)

[09/01/93 public]
Do we have anymore info on this?  Can this be reproduced?
If not, we might have to cancel it...

[09/01/93 public]

We have not seen this in the past two months (because of other CN fixes?).
Please cancel it.

[09/01/93 public]
Cool.  Canceled as unable to reproduce...

[9/1/93 public]

Wait a minute!  This bug is only 2 monthes old, and nobody has offered
an explanation as to its cause, or why it might now be fixed.  Given that 
it causes a process crash, I'm a little concerned about just dropping it.

[9/24/93 public]

Since we are unable to reproduce it (though we can't explain why either),
I'm lowering the priority.

[12/23/93 public]

Once in a while we hit this error. It must be a memory corruption. I can't
think of any other reason.

/opt/dcelocal/bin/passwd_export -x
(rpc__cn_assoc_sm_protocol_error) Illegal state transition detected in CN client association state machine
(rpc__cn_assoc_sm_protocol_error) Current state: 2
(rpc__cn_assoc_sm_protocol_error) Current event: 0
(rpc__cn_assoc_sm_protocol_error) Assoc: 400ae2a0
(rpc) *** FATAL ERROR "(rpc__cn_assoc_sm_protocol_error)" at cnassoc.c\2861 ***
sh: 13651 abort - core dumped

STACK: (Active stack) 
$cmatcb = 0x40009b98
$sp = 0x400ee1a0
$pc = 0x80387bcf
Ready: $cmastate = 1
 0 cma__transfer_regs@libdce + 0x0000000b (hp-ux export stub)
 1 cma__transfer_thread_ctx@libdc + 0x00000024 (0x40009c18, 0x400136f0, 0x7afe7930, 0)
 2 cma__transfer_thread_ctx@libdc + 0x00000008 (hp-ux export stub)
 3 cma__dispatch@libdce + 0x000003c0 (0x40009b98, 0x1, 0, 0)
 4 cma__dispatch@libdce + 0x00000008 (hp-ux export stub)
 5 cma__yield_processor_noselect@ + 0x00000058 (0, 0, 0x40016660, 0)
 6 cma__yield_processor_noselect@ + 0x00000008 (hp-ux export stub)
 7 cma___null_thread@libdce + 0x00000124 (0x40016130, 0, 0, 0)
 8 cma___null_thread@libdce + 0x00000008 (hp-ux export stub)
 9 cma__thread_base@libdce + 0x000000f4 (0x40009b98, 0, 0, 0)
10 cma__thread_base@libdce + 0x00000008 (hp-ux export stub)
11 cma__thread_start1@libdce + 0x00000038 (0x40009b98, 0, 0, 0)
12 cma__thread_start1@libdce + 0x00000008 (hp-ux export stub)
13 cma__thread_start0@libdce + 0x0000000c (0x40009b98, 0, 0, 0)

STACK: (Active stack) 
$cmatcb = 0x4000e800
$sp = 0x400ee1a0
$pc = 0x80387bcf
Blocked: $cmastate = 2
 0 cma__transfer_regs@libdce + 0x0000000b (hp-ux export stub)
 1 cma__transfer_thread_ctx@libdc + 0x00000024 (0x4000e880, 0x40009c18, 0, 0)
 2 cma__transfer_thread_ctx@libdc + 0x00000008 (hp-ux export stub)
 3 cma__dispatch@libdce + 0x000003c0 (0x4000e800, 0x1, 0, 0)
 4 cma__dispatch@libdce + 0x00000008 (hp-ux export stub)
 5 h_errno@libdce + 0x45366170 (0x4000e7cc, 0, 0, 0)
 6 cma__block@libdce + 0x00000008 (hp-ux export stub)
 7 cma__sem_timed_wait@libdce + 0x00000090 (0x4000e7cc, 0x4000e800, 0x4002f4e4, 0)
 8 cma__sem_timed_wait@libdce + 0x00000008 (hp-ux export stub)
 9 cma_cond_timed_wait@libdce + 0x000001c0 (0x7afe90b8, 0x7afe7988, 0x4002f4e4, 0x32)
10 cma_cond_timed_wait@libdce + 0x00000008 (hp-ux export stub)
11 ptdexc_cond_timedwait@libdce + 0x00000080 (0x7afe90b8, 0x7afe7988, 0x4002f4a4, 0)
12 ptdexc_cond_timedwait@libdce + 0x00000008 (hp-ux export stub)
13 timer_loop@libdce + 0x00000114 (0x4002f130, 0, 0, 0)
14 timer_loop@libdce + 0x00000008 (hp-ux export stub)
15 cma__thread_base@libdce + 0x000000f4 (0x4000e800, 0, 0, 0)
16 cma__thread_base@libdce + 0x00000008 (hp-ux export stub)
17 cma__thread_start1@libdce + 0x00000038 (0x4000e800, 0, 0, 0)
18 cma__thread_start1@libdce + 0x00000008 (hp-ux export stub)
19 cma__thread_start0@libdce + 0x0000000c (0x4000e800, 0, 0, 0)

STACK: (Active stack) 
$cmatcb = 0x400115d0
$sp = 0x400ee1a0
$pc = 0x80387bcf
Blocked: $cmastate = 2
 0 cma__transfer_regs@libdce + 0x0000000b (hp-ux export stub)
 1 cma__transfer_thread_ctx@libdc + 0x00000024 (0x40011650, 0x7aff51e8, 0, 0)
 2 cma__transfer_thread_ctx@libdc + 0x00000008 (hp-ux export stub)
 3 cma__dispatch@libdce + 0x000003c0 (0x400115d0, 0x1, 0, 0)
 4 cma__dispatch@libdce + 0x00000008 (hp-ux export stub)
 5 h_errno@libdce + 0x45366170 (0x4000f7fc, 0, 0, 0)
 6 cma__block@libdce + 0x00000008 (hp-ux export stub)
 7 cma__int_wait@libdce + 0x000001c8 (0x4000f7e0, 0x4000f790, 0, 0)
 8 cma__int_wait@libdce + 0x00000008 (hp-ux export stub)
 9 cma__io_wait@libdce + 0x00000174 (0, 0x3, 0, 0)
10 cma__io_wait@libdce + 0x00000008 (hp-ux export stub)
11 cma_read@libdce + 0x000005a8 (0x3, 0x400484c8, 0x10, 0)
12 cma_read@libdce + 0x00000008 (hp-ux export stub)
13 dns_reader@libdce + 0x00000198 (0x40048130, 0, 0, 0)
14 dns_reader@libdce + 0x00000008 (hp-ux export stub)
15 cma__thread_base@libdce + 0x000000f4 (0x400115d0, 0, 0, 0)
16 cma__thread_base@libdce + 0x00000008 (hp-ux export stub)
17 cma__thread_start1@libdce + 0x00000038 (0x400115d0, 0, 0, 0)
18 cma__thread_start1@libdce + 0x00000008 (hp-ux export stub)
19 cma__thread_start0@libdce + 0x0000000c (0x400115d0, 0, 0, 0)

STACK: (Active stack) 
$cmatcb = 0x40012640
$sp = 0x400ee1a0
$pc = 0x80387bcf
Blocked: $cmastate = 2
 0 cma__transfer_regs@libdce + 0x0000000b (hp-ux export stub)
 1 cma__transfer_thread_ctx@libdc + 0x00000024 (0x400126c0, 0x400136f0, 0, 0)
 2 cma__transfer_thread_ctx@libdc + 0x00000008 (hp-ux export stub)
 3 cma__dispatch@libdce + 0x000003c0 (0x40012640, 0x1, 0, 0)
 4 cma__dispatch@libdce + 0x00000008 (hp-ux export stub)
 5 h_errno@libdce + 0x45366170 (0x4001354c, 0, 0, 0)
 6 cma__block@libdce + 0x00000008 (hp-ux export stub)
 7 cma__int_wait@libdce + 0x000001c8 (0x40013530, 0x400134e0, 0, 0)
 8 cma__int_wait@libdce + 0x00000008 (hp-ux export stub)
 9 cma__io_wait@libdce + 0x00000174 (0, 0x4, 0, 0)
10 cma__io_wait@libdce + 0x00000008 (hp-ux export stub)
11 cma_recvmsg@libdce + 0x000005b4 (0x4, 0x400ba1c8, 0, 0)
12 cma_recvmsg@libdce + 0x00000008 (hp-ux export stub)
13 receive_packet@libdce + 0x000001b8 (0x400aed78, 0x400b9d38, 0x400b9d3c, 0x400b9d44)
14 receive_dispatch@libdce + 0x00000078 (0x400aed78, 0x7aff58f8, 0, 0)
15 rpc__cn_network_receiver@libdc + 0x00000370 (0x400aed78, 0, 0, 0)
16 rpc__cn_network_receiver@libdc + 0x00000008 (hp-ux export stub)
17 cma__thread_base@libdce + 0x000000f4 (0x40012640, 0, 0, 0)
18 cma__thread_base@libdce + 0x00000008 (hp-ux export stub)
19 cma__thread_start1@libdce + 0x00000038 (0x40012640, 0, 0, 0)
20 cma__thread_start1@libdce + 0x00000008 (hp-ux export stub)
21 cma__thread_start0@libdce + 0x0000000c (0x40012640, 0, 0, 0)

STACK: (Active stack) 
$cmatcb = 0x40013670
$sp = 0x400ee1a0
$pc = 0x80387bcf
Blocked: $cmastate = 2
 0 cma__transfer_regs@libdce + 0x0000000b (hp-ux export stub)
 1 cma__transfer_thread_ctx@libdc + 0x00000024 (0x400136f0, 0x40014c30, 0, 0)
 2 cma__transfer_thread_ctx@libdc + 0x00000008 (hp-ux export stub)
 3 cma__dispatch@libdce + 0x000003c0 (0x40013670, 0x1, 0, 0)
 4 cma__dispatch@libdce + 0x00000008 (hp-ux export stub)
 5 h_errno@libdce + 0x45366170 (0x4001457c, 0, 0x7fffffff, 0x7fffffff)
 6 cma__block@libdce + 0x00000008 (hp-ux export stub)
 7 cma__int_wait@libdce + 0x000001c8 (0x40014560, 0x40014510, 0xc9119fe8, 0)
 8 cma__int_wait@libdce + 0x00000008 (hp-ux export stub)
 9 cma__io_wait@libdce + 0x00000174 (0, 0x5, 0xab770800, 0x7e2211cb)
10 cma__io_wait@libdce + 0x00000008 (hp-ux export stub)
11 cma_recvmsg@libdce + 0x000005b4 (0x5, 0x400d41c8, 0, 0)
12 cma_recvmsg@libdce + 0x00000008 (hp-ux export stub)
13 receive_packet@libdce + 0x000001b8 (0x400ad8c0, 0x400d3d38, 0x400d3d3c, 0x400d3d44)
14 receive_dispatch@libdce + 0x00000078 (0x400ad8c0, 0x7aff58f8, 0, 0)
15 rpc__cn_network_receiver@libdc + 0x00000370 (0x400ad8c0, 0, 0, 0)
16 rpc__cn_network_receiver@libdc + 0x00000008 (hp-ux export stub)
17 cma__thread_base@libdce + 0x000000f4 (0x40013670, 0, 0, 0)
18 cma__thread_base@libdce + 0x00000008 (hp-ux export stub)
19 cma__thread_start1@libdce + 0x00000038 (0x40013670, 0, 0, 0)
20 cma__thread_start1@libdce + 0x00000008 (hp-ux export stub)
21 cma__thread_start0@libdce + 0x0000000c (0x40013670, 0, 0, 0)

STACK: (Active stack) 
$cmatcb = 0x40014bb0
$sp = 0x400ee1a0
$pc = 0x802bbe30
Running: $cmastate = 0
 0 _kill@libc_r + 0x00000008 (hp-ux export stub)
 1 _raise@libc_r + 0x00000024 (0x2a2a2a0a, 0x38363120, 0x2e635c32, 0x73736f63)
 2 _raise@libc_r + 0x00000008 (hp-ux export stub)
 3 abort@libc_r + 0x0000011c (0x7af897f0, 0x7af8e7b0, 0x7af8e7f0, 0xb2d)
 4 abort@libc_r + 0x00000008 (hp-ux export stub)
 5 rpc__die@libdce + 0x00000074 (0x7af8e7b0, 0x7af8e7d4, 0xb2d, 0x7ffe6000)
 6 rpc__die@libdce + 0x00000008 (hp-ux export stub)
 7 rpc__cn_assoc_sm_protocol_erro + 0x000000bc (0x400ae2a0, 0x400b6bf0, 0x400ee260, 0x8023f57b)
 8 rpc__cn_assoc_sm_protocol_erro + 0x00000008 (hp-ux export stub)
 9 rpc__cn_sm_eval_event@libdce + 0x00000138 (0, 0x400b6bf0, 0x400ae2a0, 0x400ae2a8)
10 rpc__cn_sm_eval_event@libdce + 0x00000008 (hp-ux export stub)
11 receive_dispatch@libdce + 0x0000146c (0x400ae2a0, 0x7aff58f8, 0, 0)
12 rpc__cn_network_receiver@libdc + 0x00000370 (0x400ae2a0, 0, 0, 0)
13 rpc__cn_network_receiver@libdc + 0x00000008 (hp-ux export stub)
14 cma__thread_base@libdce + 0x000000f4 (0x40014bb0, 0, 0, 0)
15 cma__thread_base@libdce + 0x00000008 (hp-ux export stub)
16 cma__thread_start1@libdce + 0x00000038 (0x40014bb0, 0, 0, 0)
17 cma__thread_start1@libdce + 0x00000008 (hp-ux export stub)
18 cma__thread_start0@libdce + 0x0000000c (0x40014bb0, 0, 0, 0)

STACK: (First stack) (Active stack) 
$cmatcb = 0x7aff5168
$sp = 0x400ee1a0
$pc = 0x80387bcf
Blocked: $cmastate = 2
 0 cma__transfer_regs@libdce + 0x0000000b (hp-ux export stub)
 1 cma__transfer_thread_ctx@libdc + 0x00000024 (0x7aff51e8, 0x400136f0, 0x2, 0x1)
 2 cma__transfer_thread_ctx@libdc + 0x00000008 (hp-ux export stub)
 3 cma__dispatch@libdce + 0x000003c0 (0x7aff5168, 0x1, 0, 0x10437ce)
 4 cma__dispatch@libdce + 0x00000008 (hp-ux export stub)
 5 h_errno@libdce + 0x45366170 (0x40014b7c, 0, 0x2, 0x45586732)
 6 cma__block@libdce + 0x00000008 (hp-ux export stub)
 7 ptdexc_cond_wait@libdce + 0x000001e0 (0x400ae2e8, 0x7aff58f8, 0, 0x400ae2d0)
 8 ptdexc_cond_wait@libdce + 0x00000008 (hp-ux export stub)
 9 rpc__cn_assoc_receive_frag@lib + 0x000000e4 (0x400ae2a0, 0x7b044068, 0x7b043a80, 0x400ae2a8)
10 rpc__cn_assoc_receive_frag@lib + 0x00000008 (hp-ux export stub)
11 rpc__cn_assoc_open@libdce + 0x00000758 (0x400ae2a0, 0x400ae220, 0x7afb2558, 0)
12 rpc__cn_assoc_request@libdce + 0x0000059c (0x400ae9f0, 0x400ae240, 0x7afb2558, 0x400aebec)
13 rpc__cn_assoc_request@libdce + 0x00000008 (hp-ux export stub)
14 allocate_assoc_action_rtn@libd + 0x00000094 (0x400ae9f0, 0x7afb2558, 0x7afb3f50, 0x7afb3738)
15 allocate_assoc_action_rtn@libd + 0x00000008 (hp-ux export stub)
16 rpc__cn_sm_eval_event@libdce + 0x00000138 (0x8, 0x7afb2558, 0x400ae9f0, 0x400aea24)
17 rpc__cn_sm_eval_event@libdce + 0x00000008 (hp-ux export stub)
18 rpc__cn_call_start@libdce + 0x000008e0 (0x400ae240, 0, 0x7afb2558, 0)
19 rpc__cn_call_start@libdce + 0x00000008 (hp-ux export stub)
20 rpc_call_start@libdce + 0x000001d8 (0x400ae240, 0, 0x7afb2558, 0)
21 rpc_call_start@libdce + 0x00000008 (hp-ux export stub)
22 op0_csr@libdce + 0x00000144 (0x400ae240, 0x7b033a44, 0x7b03527c, 0x7b035280)
23 op0_csr@libdce + 0x00000008 (hp-ux export stub)
24 override_get_login_info@libdce + 0x00000110 (0x7b033a44, 0x7b03527c, 0x7b035280, 0x7b042760)
25 override_get_login_info@libdce + 0x00000008 (hp-ux export stub)
26 make_files + 0x000001c4 (0xf4240, 0x1, 0, 0)
27 main + 0x000003ec (0x2, 0x7b033068, 0, 0)

[04/11/94 public]
The OSF selfhost cell has run in to this problem this past weekend on one
of their HP servers.  Running dce1_1ab1 (a dfs build based on dce1.1b3).
Rpcd is the program that core dumped.

Same state transition:

(rpc__cn_assoc_sm_protocol_error) Illegal state transition detected in CN client
 association state machine
(rpc__cn_assoc_sm_protocol_error) Current state: 2
(rpc__cn_assoc_sm_protocol_error) Current event: 0
(rpc__cn_assoc_sm_protocol_error) Assoc: 401c41f0
(rpc) *** FATAL ERROR "(rpc__cn_assoc_sm_protocol_error)" at cnassoc.c\2967 ***


This is a client in the init_wait_state (waiting for its BIND packet to be
accpeted or rejected).  The event 0 means the client is getting a BIND
packet back!  I think Seiichi is correct is guessing that it is a memory
corruption problem.

The problem is where/how to begin debugging this.....

[4/12/94 public]

Last week, our customer reported the exact same rpcd crash... We need to
make it reproducible. But how?

[6/21/94 public]

We are seeing the increased number of reports about the rpcd core dump with
the above state change (init_wait state, req event) from the fields. It
seems to happen in the heavily loaded (especial with *Encina*) or long
running cell. It is a show-stopper for DCE deployment. Thus, I'm raising
the priority and assigning it to the CN owner.

[7/5/94 public]

We finally got the RPC_DEBUG output from rpcd, but still can't determine
the cause of the failure. Here is the most interesting part of the output:

[time: 019072] [thread: 400129c8.00000004] STATE CLIENT CALL:   141 state->INIT              event->START            
[time: 019072] [thread: 400129c8.00000004] CN: call_rep->401f0118 assoc->401f05d0 desc->7 establishing connection & negotiating presentation syntax
[time: 019072] [thread: 400129c8.00000004] STATE CLIENT ASSOC: 401f05d0 state->CLOSED            event->REQ              
[019072] [thread: 400129c8.00000004] CN: call_rep->401f0118 assoc->401f05d0 desc->7 connection request initiated to 15.12.17.27[1910]
[time: 019072] [thread: 400129c8.00000004] (rpc__cn_network_req_connect) desc->7 desired_sndbuf 4096, desired_rcvbuf 4096
[time: 019072] [thread: 400129c8.00000004] (rpc__cn_network_req_connect) desc->7 actual sndbuf 4096, actual rcvbuf 4096
[time: 019072] [thread: 400129c8.00000004] CN: call_rep->401f0118 assoc->401f05d0 desc->7 connection established
[time: 019072] [thread: 400129c8.00000004] STATE INSERT EVENT [time: 019072] [thread: 400129c8.00000004] STATE CLIENT ASSOC: 401f05d0 state->CLOSED            event->CONN_ACK         
[time: 019072] [thread: 400129c8.00000004] CN: call_rep->401f0118 assoc->401f05d0 desc->7 negotiating for abstract syntax->afa8bd80-7d8a-11c9-bef4-08002b102989,1 context_id->1 call_id->142
[time: 019072] [thread: 400129c8.00000004] CN: call_rep->401f0118 assoc->401f05d0 desc->7 transfer_syntax[0]->8a885d04-1ceb-11c9-9fe8-08002b104860,2
[time: 019072] [thread: 400129c8.00000004] CN: call_rep->401f0118 assoc->401f05d0 desc->7 sent 72 bytes
[time: 019072] [thread: 400129c8.00000004] PACKET: type->BIND          flags->0 drep->00000000 frag_len->72 auth_len->0 call_id->142
[time: 019072] [thread: 400129c8.00000004] STATE CLIENT ASSOC: 401f05d0 new state->INIT_WAIT        
[time: 019072] [thread: 4017bae8.00000010] CN: assoc->401f05d0 call_rep->none Receiver awake ... Connection established
[time: 019072] [thread: 4017bae8.00000010] CN: call_rep->401f0118 assoc->401f05d0 desc->7 received 72 bytes
[time: 019072] [thread: 4017bae8.00000010] PACKET: type->BIND          flags->0 drep->00000000 frag_len->72 auth_len->0 call_id->142
[time: 019072] [thread: 4017bae8.00000010] STATE CLIENT ASSOC: 401f05d0 state->INIT_WAIT         event->REQ              
[time: 019072] [thread: 4017bae8.00000010] (rpc__cn_assoc_sm_protocol_error) Illegal state transition detected in CN client association state machine
[time: 019072] [thread: 4017bae8.00000010] (rpc__cn_assoc_sm_protocol_error) Current state: 2
[time: 019072] [thread: 4017bae8.00000010] (rpc__cn_assoc_sm_protocol_error) Current event: 0
[time: 019072] [thread: 4017bae8.00000010] (rpc__cn_assoc_sm_protocol_error) Assoc: 401f05d0
[time: 019072] [thread: 4017bae8.00000010] (rpc) *** FATAL ERROR "(rpc__cn_assoc_sm_protocol_error)" at cnassoc.c\2861 ***

rpcd was trying to ping the server to find out if it was alive or not. It
successfully established the TCP/IP connection, then sent the BIND pdu. The
server responded with the BIND pdu instead of the BIND_ACK or BIND_NACK
pdu. I believe that the client (rpcd) actually received the BIND pdu
because receive_packet()::cnrcvr.c reported the fragment length 72 bytes.
(Unless HP-UX networking code is broken, I don't think that bytes_rcved
returned from recvmsg() was accidentally set to 72.) We don't know if rpcd
was really talking to a rpc server or not. It could be talking to a random
TCP/IP process. For instance, by running the perf client against the echo
service, you'll get the same illegal state transition.

  $ client -d 0,1.5,11-12,13.3,14,23-24 0 ncacn_ip_tcp:host[7] 1 1 n n

or with dce1.1 serviceability

  $ export SVC_RPC_DBG=rpc:rpc_svc_general.1,rpc_svc_cancel.1,rpc_svc_orphan.1,rpc_svc_cn_state.3,rpc_svc_cn_pkt.1:STDERR:
  $ client 0 ncacn_ip_tcp:host[7] 1 1 n n

One possibility I can think of is that there was a stale endpoint, 1910, in
the EP map and the new TCP/IP process used that port explicitly (by
specifying it with bind()) and it behaved like the echo service.

[7/11/94 public]
Showed up with dced:

Martha Dassarma writes:

Cell Configuration: 

HPUX (dce1.1)   : dced, SEC server, DTS server
OSF1 (dce1.0.3) : rpcd, CDS server, DTS server

NB- July 6 (BL-11)

The cell was idle during the weekend; dced cored dump with the following
error:

1994-07-11-05:44:09.536-04:00I----- dced FATAL rpc rpc_svc_cn_state 0x40027928
Illegal state transition detected in CN client association state machine
[2, cur_event: 0, assoc: 401313a0]


[I had a core dump, unfortunatelly when I brought up the debugger, it
created another core which overwrote the one from dced]

[8/9/94 public]

Recreated this yet again running the sanity tests overnight on the following 
cell.  dced core dumped after about 9 hours.


HPUX : dced, cdsd, secd
OSF1 : dce client
OSF1 : dce client, ntp provider

The stack trace is as follows:

 0 _kill@libc + 0x00000008 (hp-ux export stub)
 1 _raise@libc + 0x00000024 (0x8, 0x404261a4, 0x12, 0x38343700)
 2 _abort@libc + 0x00000078 (0x400012b0, 0x404260f8, 0x1, 0x404260a4)
 3 dce_svc_printf_withfile@libdce + 0x000005a0 (0x7af61b90, 0x7af68450, 0xc08, 0x7af6848c)
 4 rpc__cn_assoc_sm_protocol_erro + 0x000000c0 (0x403ad218, 0x4041c008, 0x403ad220, 0x403b4764)
 5 rpc__cn_sm_eval_event@libdce + 0x000000e4 (0x64, 0x4041c008, 0x403ad218, 0x403ad220)
 6 receive_dispatch@libdce + 0x0000258c (0x403ad218, 0x7affc260, 0, 0)
 7 rpc__cn_network_receiver@libdc + 0x00000a98 (0x403ad218, 0x7af59088, 0x400302d0, 0x1e)
 8 cma__thread_base@libdce + 0x0000021c (0x400302d0, 0, 0, 0)
 9 cma__thread_start1@libdce + 0x0000004c (0x400302d0, 0, 0, 0)
10 cma__thread_start0@libdce + 0x00000008 (0x400302d0, 0, 0, 0)
.
.
.

[8/9/94 public]

This appears to be caused by a bug in the HP/UX networking code.

The rpcd/dced is trying to detect stale EP map entries by making 
RPC's to see if the registered servers are still alive.  Apparently, 
after some number of attempts to connect to ports that are no longer
in use, the connect's start succeeding, and any data sent on the 
connection ends up being echoed on the next read.  (!!) 

The CN protocol, upon seeing a BIND message echoed back at it, 
blows out the process. (!!)

I'll report the HP/UX bug to our networking group.  

We should also fix the CN code to be a little less sensitive to this
type of failure.  (After all, the protocol error seen here *appears*
to be the result of a faulty peer, what's the point in taking down
your own process?)

Seiichi is testing a CN fix to handle this condition.  Once tested,
we'll propose it for submission.

[8/9/94 public]
Much coolness!!

Prasad had just noticed that this bug was ocurring only on HP/UX.
The CN code always treats protocol errors as fatal.
I don't know if relaxing this is good.

What should we do in this case, just close the connection with comm_error?
Once again, great news!

[8/9/94 public]

We knew that it has been happening on HP-UX only. :-) (See, the platform is
hppa/hpux.)

The state machine change I'm testing is:

  Add the new action ignore_event_abort_action_rtn()::cncassm.c (the name
  is irreverent) which does

    print out the warning message "Illegal state transition...".
    call abort_assoc_action_rtn() which cancels the receiver thread.
    set assoc->assoc_status to rpc_s_protocol_error.
    call RPC_CN_ASSOC_WAKEUP().

  Change INIT_WAIT/REQ event to call ignore_event_abort_action_rtn() and the
  new state is CLOSED.

For now, I'm only doiny it for INIT_WAIT/REQ event. It's probably better
doing it for other illegal state transitions (selectively) caused by the
*network* events.

[8/12/94 public]

When I opened this CR, I reported the different state/event. However, there
were a lot of CN bug fixes in 1.0.3 and we havn't seen any state/event
other than INIT_WAIT/REQ in 1.0.3/1.1. I bet that ACTIVE/ACCEPT_CONF
(original illegal state change) was fixed somewhere else in 1.0.3.

We now know that INIT_WAIT/REQ (loopback) can happen on HP-UX because HP-UX
networking code allows symmetric open, just like BSD 4.4.

[8/12/94 public]

Submitted the above fix for INIT_WAIT/REQ event.



CR Number                     : 8152
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : admin ref docs
Short Description             : rpccp -v upto option descr. wrong
Reported Date                 : 6/14/93
Found in Baseline             : 1.0.2
Found Date                    : 6/14/93
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : 5
Sensitivity                   : public

[6/14/93 public]

rpccp -v upto option described incorrectly.

THIS DEFECT IS TO BE RETURNED TO OSF VIA OT BY IDD.

In (at least) these rpccp commands, there is a table describing the -v
flag.

  import
  show mapping
  show profile


The upto option is described incorrectly:

  upto The major and minor versions must be less than or equal to
       those specified.


This should be:

  upto The major version must be less than or equal to that specified.

       If the major versions are equal, the minor version must be less
       than or equal to that specifed.


--------------- Example program ----------------------------------

hostname=<your_favorite_rpcd_host>

rpccp add mapping \
-i 00583342-6353-1c1a-80b5-10005aa8b98d,1.1 \
-b ncacn_ip_tcp:${hostname}[8989] \
-o 002a8fdc-635b-1c1a-bac1-02608c2e98c4 \
-a 'bind_util, level 1'

rpccp add mapping \
-N \
-i 00583342-6353-1c1a-80b5-10005aa8b98d,1.9 \
-b ncacn_ip_tcp:${hostname}[8990] \
-o 002a8fdc-635b-1c1a-bac1-02608c2e98c4 \
-a 'bind_util, level 1'

rpccp add mapping \
-N \
-i 00583342-6353-1c1a-80b5-10005aa8b98d,2.1 \
-b ncacn_ip_tcp:${hostname}[8991] \
-o 002a8fdc-635b-1c1a-bac1-02608c2e98c4 \
-a 'bind_util, level 1'

rpccp show mapping -v upto \
-i 00583342-6353-1c1a-80b5-10005aa8b98d,2.1 \
-o 002a8fdc-635b-1c1a-bac1-02608c2e98c4 \

[06/15/93 public]
Assigned this CR to myself.

[06/17/93 public]
Fixed and verified by Dave Weisman.
Changed the upto description for -v in the following reference pages:

	rpccp_import.8rpc
	rpccp_remove_mapping.8rpc
	rpccp_show_mapping.8rpc
	rpccp_show_profile.8rpc
	rpccp_unexport.8rpc

[08/17/93 public]
Closed bug.



CR Number                     : 8143
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : 
Short Description             : The rpc-cds doc bugs
identified in the 1.0.2 Release Notes, Section 1.10.5.3, and all its
subsections (1.10.5.3.1 thru 1.10.5.3.3) should be fixed in the DCE Porting
Guide
Reported Date                 : 6/11/93
Found in Baseline             : 1.0.2
Found Date                    : 6/11/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.2a
Fixed In Baseline             : 1.0.2a
Affected File(s)              : port_gd/11_systest.gpsml
Sensitivity                   : public

[6/11/93 public]

[6/28/93 public]
The material referred to above is about the rpc.cds.3 system test. All
the items that don't involve unintegrated code have been moved into
Chapter 11 of the Porting Guide. The unintegrated code descriptions
should stay in the Release Notes for 1.0.2a, since the code itself
will still be unintegrated.

[08/19/93 public]
Closed bug.



CR Number                     : 8142
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : 
Short Description             : The rpc doc bugs and additions
identified in the DCE Release Notes, Section 1.10.5.2 and its subsections
(1.10.5.2.1 thru 1.10.5.2.6) should be fixed in the DCE Porting Guide
Reported Date                 : 6/11/93
Found in Baseline             : 1.0.2
Found Date                    : 6/11/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.2a
Fixed In Baseline             : 1.0.2a
Affected File(s)              : port_gd/11_systest.gpsml
Sensitivity                   : public

[6/11/93 public]

[6/28/93 public]
The material referred to above described the rpc.sec.2 system test.
All items that do not involve unintegrated code have now been moved
into Chapter 11 of the Porting Guide. The items that describe unin-
tegrated code have been left where they are in the Release Notes,
since all code that was unintegrated in 1.0.2 will remain so in 1.0.2a,
and references to the "unintegrated" tree should not occur in the
books.

[08/19/93 public]
Closed bug.



CR Number                     : 8126
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : admin_ref
Short Description             : The rpccp add mapping
reference page contained in the DCE Release Notes, Section 1.10.4.1, should
be added to the DCE Administration Reference.
Reported Date                 : 6/9/93
Found in Baseline             : 1.0.2
Found Date                    : 6/9/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.2a
Fixed In Baseline             : 1.0.2a
Affected File(s)              : admin_ref/man8rpc/rpccp_add_mapping.8rpc
Sensitivity                   : public

[6/9/93 public]

[6/11/93 public]
Added rpccp_add_mapping.8rpc to the admin_ref. Also converted source of
this file to SML.

[08/17/93 public]
Closed bug.



CR Number                     : 8111
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8073
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : CO rpc
Short Description             : input args freed incorrectly
Reported Date                 : 6/7/93
Found in Baseline             : 1.0.2
Found Date                    : 6/7/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/runtime/cncall.c
Sensitivity                   : public

[6/7/93 public]
In rpc__cn_call_transmit and rpc__cn_call_transceive, for the case where the
call is orphaned, we have to free the input args correctly. In the existing
code, the index of the for loop is not being used at all, so if the iovector
has "n" elements, then we free the same iov_elt_p
(initialized outside the loop) "n" times.

[7/28/93 public]

Will be fixed as a part of OT8073 fix.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8110
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc/runtime/cn
Short Description             : RPC_CN_DBG_RTN_PRINTF macro does not work with ANSI cpp.
Reported Date                 : 6/7/93
Found in Baseline             : 1.0.2
Found Date                    : 6/7/93
Severity                      : D
Priority                      : 4
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/runtime/cnp.h
Sensitivity                   : public

[6/7/93 public]

RPC_CN_DBG_RTN_PRINTF defined in cnp.h does not print out the routine name.
With ANSI cpp, it should be defined as:

#define RPC_CN_DBG_RTN_PRINTF(s) RPC_DBG_PRINTF(rpc_e_dbg_general, \
                                                rpc_c_cn_dbg_routine_trace,\
                                                ("(" #s ")\n"))

[08/16/93 public]
Seiichi is going to fix this.

[08/18/93 public]
Actually, I fixed it.  How this went this long without getting 
fixed I'll never know, cause I needed it!
Verified and closed.



CR Number                     : 8104
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8103
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc/runtime/cn
Short Description             : binding_cross_fork entry point is missing in cn_binding_epv.
Reported Date                 : 6/7/93
Found in Baseline             : 1.0.2
Found Date                    : 6/7/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : cninit.c, cnbind.c, cnbind.h
Sensitivity                   : public

[6/7/93 public]

cninit.c does not initialize cn_binding_epv.binding_cross_fork. Also, the
CN protocol does not provide any atfork handler (though I don't know if
an atfork handler is required for it).

[08/16/93 public]
Seiichi is going to fix this.

[8/18/93 public]

Just to be clear, there are two CN related fork problems.  The first one,
which is associated with this defect, is that the CN code is missing an
entry in it's binding EPV.  Seiichi will submit a fix for this problem.

The second problem, which is now associated with OT CR 8267, is that the
CN does not provide support for client processes that want to safely fork.
Seiichi is not fixing this problem.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8103
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8104
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc/runtime/dg
Short Description             : atfork handlers are not activated
Reported Date                 : 6/7/93
Found in Baseline             : 1.0.2
Found Date                    : 6/7/93
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/runtime/AT386/sysconf.h
                                             rpc/runtime/HP800/sysconf.h
                                             rpc/runtime/RIOS/sysconf.h
                                             rpc/runtime/Makefile
                                             rpc/runtime/com.h
                                             rpc/runtime/comfork_cma.c
                                             rpc/runtime/cominit.c
                                             rpc/runtime/comnet.c
                                             rpc/runtime/comnetp.h
                                             rpc/runtime/comnlsn.c
                                             rpc/runtime/dg.h
                                             rpc/runtime/dginit.c
                                             rpc/runtime/dglsn.c
                                             rpc/runtime/rpctimer.c
Sensitivity                   : public

[6/7/93 public]

Although CMA provides cma_atfork(), atfork handlers in rpc/runtime are not
activated when using CMA.

There are a couple of defects in existing atfork handlers. We have fixed
them which showed up with DFS (there is no functional test for RPC forking)
and have been using atfork handlers in the next release of HP DCE product.
This supports process forking from within RPC applications that use the DG
protocol with the following restrictions:

 For client-side applications, the DG protocol is fork safe. It is the
 responsibility of the application developer to ensure that all other
 application threads are capable of crossing forks safely.

 On the server side, the only supported behavior is for a call executor
 thread to fork() and exec(), with no use of RPC in the child of the fork()
 until after exec().

I'm filing the separate OT for the CN protocol.

[9/21/93 public]

Submitted to 1.0.3 and activated on all reference platforms.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8099
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rpc__cn_network_req_connect caller dies when communication partner dies
Reported Date                 : 6/7/93
Found in Baseline             : 1.0.2
Found Date                    : 6/7/93
Severity                      : A
Priority                      : 0
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/runtime/cnnet.c
Sensitivity                   : public
>                             : 

[6/7/93 public]

	Customer reported the following problem:

	two different machines of the same cell were configured
        with dts local servers. Both were configured with
        set servers required 2, and a dtscp synchronize command was
        performed on both machines. 

	Next, one of the the servers was brought down using dtscp.

		dtscp diable
                dtscp delete

	For some time after which, a sychronize command on the remaing
        server causes it to produce the following output and terminate.

        # (rpc__cn_network_req_connect) 
	desc->8 rpc__naf_set_pkt_keepalive failed, error = 32
        (rpc) *** FATAL ERROR "rpc__socket_set_keepalive() failed" at cnnet.c\1274 ***

	termination is caused by the segment of code, which can be
        found in the function rpc__cn_network_req_connect in the file
        rpc/runtime/cnnet.c. 

            /*
             * Set the keepalive socket option for this connection.
             */
            serr = rpc__socket_set_keepalive (assoc->cn_ctlblk.cn_sock);
            if (RPC_SOCKET_IS_ERR(serr))
            {
                /*
                 * The socket set keepalive option failed.
                 */
                EPRINTF ("(rpc__cn_network_req_connect) desc->%d \
                        rpc__naf_set_pkt_keepalive failed, error = %d\n",
                         assoc->cn_ctlblk.cn_sock, serr);
                DIE ("rpc__socket_set_keepalive() failed");
            }

	It appears, that the dts manipulation uncovered a fundamental
problem in the rpc runtime. Specifically, it seems to be the case that
when one half of an rpc cn communication dies/or is killed, there is
a window of opportunity during which the other side of the communication
will be killed if it tries to communicate with the dead side.

	My guess at what is happening is that rpc__socket_connect
may return rpc_c_socket_eisconn even though the process on the other
side is no longer around. If this is the case, rpc__cn_network_req_connect
will promote rpc_c_socket_eisconn to rpc_c_socket_ok even though the socket
is not suitable for data tranfer (no one is home on the other end). The
subsequent call to rpc__socket_set_keepalive which actually tries to send data,
learns that the pipe is broken and results in the DIE. The apparent
assumption that rpc__socket_connect will return an error other than
rpc_c_socket_eisconn whenever the socket is not suitable to intercahnge
data is suspect.

	Furthermore, note that a failure in the process at the other end
of the communication sometime after a successfull call to
rpc__socket_connect and sometime before the call to
rpc__socket_set_keepalive,  will also cause the process at this side
to DIE. 

	In general, it seems that we should reconsider the rational
behind the DIE statement in rpc__cn_network_req_connect.

[08/25/93 public]
I'll try to reproduce this, although I have never seen this happen
while working on DTS.

[08/25/93 public]
It looks like Hal has a weird implementation of TCP.  I was unable
to get the OSF/1 - HP-UX TCP to give me the error they got.

Tom Talpey suspects they have TCP running over streams, and it is very
agressive at returning errors even if they are misleading (or wrong), 
the traditional BSD implimentation doesn't return an error in this case.  
In fact the man page (and OSF/1 kernel code) says that setsockopt() 
doesn't return errno=32 (EPIPE).  This is reserved for write operations 
(which setsockopt() isn't).

That being said, it does appear that there *could* be a window between
the connect and keep-alive statements, and we should close it.
I have decided to not DIE() if the keep-alive fails, but to ignore
this error just as setting nodelay is ignored.  If the connection is
closed, the client will notice this in the usual manner.

I do not believe that the lines:
        if (serr == rpc_c_socket_eisconn)
        {
            serr = rpc_c_socket_ok;
        }
cover up any errors.  If the implementation returns is-connected when you
aren't, that isn't RPC's problem.

This fix should have little impact on anyone (but Hal Computer).

Diff:
--- 1277,1282 ----
***************
*** 1284,1293 ****
              {
                  /*
                   * The socket set keepalive option failed.
                   */
!                 EPRINTF ("(rpc__cn_network_req_connect) desc->%d rpc__naf_set_pkt_keepalive failed, error = %d\n",
!                          assoc->cn_ctlblk.cn_sock, serr);
!                 DIE ("rpc__socket_set_keepalive() failed");
              }
  
              /*
--- 1285,1297 ----
              {
                  /*
                   * The socket set keepalive option failed.
+                  * The connection on the other side may have gone away.
+                  * This is not a big deal because the client will
+                  * find this out in the normal manner.
                   */
!                 RPC_DBG_PRINTF (rpc_e_dbg_general, rpc_c_cn_dbg_errors,
!                                 ("(rpc__cn_network_req_connect) desc->%x rpc__naf_set_pkt_keepalive failed failed, error = %d\n",
!                                  assoc->cn_ctlblk.cn_sock, serr));
              }
  
              /*

I will submit this as soon as the 1.0.3 tree is opened.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8094
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : hppa
S/W Ref Platform              : hpux
Component Name                : rpc
Subcomponent Name             : 
Short Description             : HP-UX porting changes to RPC
Reported Date                 : 6/4/93
Found in Baseline             : 1.0.2
Found Date                    : 6/4/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/kruntime
Sensitivity                   : public

[6/4/93 public]

This defect covers HP-UX porting changes for RPC for accounting purposes.

[07/27/93 public]
Can this defect be closed now?



CR Number                     : 8090
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Compiler warnings.
Reported Date                 : 6/4/93
Found in Baseline             : 1.0.2
Found Date                    : 6/4/93
Severity                      : E
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/rpccp/rpccp.c rpc/rpcd/rpcdutil.c
Sensitivity                   : public

[6/4/93 public]

rpccp.c, function sigint_handler():

          if (signal (SIGINT, sigint_handler) == (void (*)()) (-1))
                         SHOULD BE REPLACED WITH
          if (signal (SIGINT, (void (*)())sigint_handler) == (void (*)()) (-1))


rpcd.c function main():

     rpc_network_is_protseq_valid ("ncadg_ip_udp", &status);
                    SHOULD BE REPLACED WITH
     rpc_network_is_protseq_valid ((unsigned_char_p_t)"ncadg_ip_udp", &status);


rpcdutil.c function tower_to_fields():

     if (tref->count < (rpc_c_num_rpc_floors + 1))
                    SHOULD BE REPLACED WITH
     if (tref->count < (unsigned16)(rpc_c_num_rpc_floors + 1))

	function tower_to_if_id():

     if (tref->count < rpc_c_num_rpc_floors)
		    SHOULD BE REPLACED WITH
     if (tref->count < (unsigned16)rpc_c_num_rpc_floors)

[06/04/93 public]
          if (signal (SIGINT, sigint_handler) == (void (*)()) (-1))
                         SHOULD BE REPLACED WITH
          if (signal (SIGINT, (void (*)())sigint_handler) == (void (*)()) (-1))
No no no.  There are two errors here.  sigint_handler should be written
to be "void sigint_handler(int s) { ... }".  Make the function right,
don't case it.

The second part is wrong in multiple ways.  At first you would think
the entire cast construct should be replaced by SIG_ERR.  However, since
signal returns the previous signal handler you can't get SIG_ERR, so
the entire if block should just be removed most likely.

[6/4/93 public]

In rpccp.c, the offending signal() is in an UNUSED function:

/*
 * sigint_handler - handle control-c's and such
 * Note: this is no longer used but is left for reference for later,
 * when there will be an ANSI compliant way of doing this.
 */

INTERNAL void
sigint_handler()
{
    if (signal (SIGINT, sigint_handler) == (void (*)()) (-1))
    {
        printf ("\n>>> can't reset SIGINT handler\n\n");
        perror(MYNAME);
        exit (-1);
    }

    printf ("\n>>> INTERRUPT -- Aborting operation\n\n");

    /* 
     * Shouldn't get this far:
     */
    exit (-1);

}

Aside from using the old (unreliable) signal mechanism which should be
replaced by sigaction(), this code is simply unneeded.

[10/14/93 public]
The two casts were alread in rpcd.c, added the casts to rpcdutil.c.
Removed the offending signal handler in rpccp.c.
Closed.



CR Number                     : 8073
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8111
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : Memory leak and multiple deallocations
Reported Date                 : 5/28/93
Found in Baseline             : 1.0.2
Found Date                    : 5/28/93
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/runtime/compat.c, rpc/idl/lib/sscmaset.c
Sensitivity                   : public

[5/28/93 public]

In rpc__cn_call_transmit(), if the call has been orphaned and the input
data iovec has more than one element, it deallocates the first element
multiple times. In cncall.c line ~724 :

        iov_elt_p = call_args->elt;
        for (i = 1; i <= call_args->num_elt; i++)
        {
            if (iov_elt_p->buff_dealloc != NULL)
            {
                (iov_elt_p->buff_dealloc) (iov_elt_p->buff_addr);
            }
        }

iov_elt_p should be increased.

Also after the deallocation, buff_dealloc should be nullified. There are a
number of places in CN where (*buff_dealloc)() is called, but not nullified
later. We identified all those places in DG and IDL (stub code generator
and libidl), and have fixed them in our product codes (but not in CN).

[5/28/93 public]

Would you annotate this CR with the changes in DG and IDL stub generation?

[5/28/93 public]

Here are diffs against dce1.0.2a as of today. The fix is active when
HPDCE_FIX_OT7465 is NOT defined. (dg.c has been fixed as a part of OT7769.)

*** ../../dce1.0.2a/src/rpc/idl/idl_compiler/inpipes.c	Sat Apr 10 17:19:49 1993
--- rpc/idl/idl_compiler/inpipes.c	Mon May 24 21:50:50 1993
***************
*** 121,130 ****
--- 129,145 ----
  #endif
  {
      fprintf(fid, 
+ #ifdef HPDCE_FIX_OT7465
  "if(%s->p_rcvd_data->buff_dealloc != NULL && %s->p_rcvd_data->data_len != 0)\n",
+ #else
+ "if(%s->p_rcvd_data->buff_dealloc != NULL && %s->p_rcvd_data->data_len != 0)\n{\n",
+ #endif /* HPDCE_FIX_OT7465 */
              pointer_name, pointer_name);
      fprintf(fid, "    (*(%s->p_rcvd_data->buff_dealloc))\n", pointer_name );
      fprintf(fid, "       (%s->p_rcvd_data->buff_addr);\n", pointer_name );
+ #ifndef HPDCE_FIX_OT7465
+     fprintf(fid, "    %s->p_rcvd_data->buff_dealloc = NULL_FREE_RTN;\n}\n", pointer_name );
+ #endif /* HPDCE_FIX_OT7465 */
  }
  
  /******************************************************************************/
*** ../../dce1.0.2a/src/rpc/idl/idl_compiler/munmarsh.c	Sat Apr 10 17:19:56 1993
--- rpc/idl/idl_compiler/munmarsh.c	Mon May 24 21:50:58 1993
***************
*** 293,301 ****
--- 297,313 ----
      BE_mn_t *mn;
  #endif
  {
+ #ifdef HPDCE_FIX_OT7465
      fprintf(fid,
  "if (%s->buff_dealloc && %s->data_len!=0)(*%s->buff_dealloc)(%s->buff_addr);\n",
                   mn->elt, mn->elt, mn->elt, mn->elt);
+ #else
+     fprintf(fid, "if (%s->buff_dealloc && %s->data_len!=0)\n{\n",
+             mn->elt, mn->elt);
+     fprintf(fid, "    (*%s->buff_dealloc)(%s->buff_addr);\n",
+             mn->elt, mn->elt);
+     fprintf(fid, "    %s->buff_dealloc = NULL_FREE_RTN;\n}\n", mn->elt);
+ #endif /* HPDCE_FIX_OT7465 */
  }
  
  /*
*** ../../dce1.0.2a/src/rpc/idl/lib/sscmaset.c	Sat Apr 10 17:20:44 1993
--- rpc/idl/lib/sscmaset.c	Mon May 24 21:51:46 1993
***************
*** 1334,1339 ****
--- 1342,1350 ----
              if (iovec_elt.buff_dealloc != NULL)
              {
                  (*iovec_elt.buff_dealloc)(iovec_elt.buff_addr);
+ #ifndef HPDCE_FIX_OT7465
+                 iovec_elt.buff_dealloc = NULL;
+ #endif /* HPDCE_FIX_OT7465 */
              }
              
              /*
***************
*** 1379,1385 ****
--- 1390,1403 ----
  #endif
  {
      if (elt->buff_dealloc && (elt->data_len != 0))
+ #ifndef HPDCE_FIX_OT7465
+     {
+ #endif /* HPDCE_FIX_OT7465 */
                                       (*elt->buff_dealloc)(elt->buff_addr);
+ #ifndef HPDCE_FIX_OT7465
+         elt->buff_dealloc = NULL;
+     }
+ #endif /* HPDCE_FIX_OT7465 */
      rpc_call_receive(call_h, elt, (unsigned32*)st);
      if (*st == error_status_ok)
          rpc_init_mp((*p_mp), elt->data_addr);
*** ../../dce1.0.2a/src/rpc/runtime/compat.c	Sat Apr 10 17:23:28 1993
--- rpc/runtime/compat.c	Mon May 24 21:54:19 1993
***************
*** 255,263 ****
--- 262,274 ----
                  iove_ins->data_len);
          iptr += iove_ins->data_len;             
          if (iove_ins->buff_dealloc != NULL)
+ #ifdef HPDCE_FIX_OT7465
          { 
              (*iove_ins->buff_dealloc)(iove_ins->buff_addr);
          }
+ #else
+             RPC_FREE_IOVE_BUFFER(iove_ins);
+ #endif /* HPDCE_FIX_OT7465 */
  
          /*
           * Copy all input data into the buffer to be sent to the

[7/2/93 public]

For CN codes, nullifying buff_dealloc pointer is not always a good idea.
There are cases where the buff_dealloc is a part of the deallocated memory.

[07/27/93 public]
This last note makes the bug and the fix unclear.  
perhaps you would be willing to fix this problem for us?

[7/28/93 public]

Ok, here is what I will/will not do list:

Will fix the iov_elt_p pointer in the for-loops in cncall.c,
which is also reported in OT 8111.

Will fix all (*buff_dealloc) problems in DG/compat runtime and
libidl.

Will not fix the (*buff_dealloc) problems in IDL since 1.0.3
IDL is different.

Will not fix the (*buff_dealloc) problems in CN runtime,
because of my previous comment and too many of them.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8071
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : admin ref
Short Description             : rpcd manpage refers to dce.rc
Reported Date                 : 5/28/93
Found in Baseline             : 1.0.2
Found Date                    : 5/28/93
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpcd.8rpc
Sensitivity                   : public

[5/28/93 public]

rpcd manpage refers to dce.rc instead of rc.dce

DCE Admin Reference
  DCE Remote Procedure Call
    rpcd


> Typically, the RPC daemon starts each time a host boots.  Usually, a
> /opt/dcelocal/etc/dce.rc file is created - with a link from
> /etc/dce.rc and with /etc/rc or /etc/rc.local invoking /etc/dce.rc.
> The /opt/dcelocal/etc/dce.rc file is responsible for deleting the
> database

It's rc.dce (not dce.rc) for both OSF and IBM.

[06/03/93 public]
Assigned this CR to myself.

[06/10/93 public]
Changed to "verified".  Made the requested change.  Also removed
incorrect information about links from the explanatory paragraph
after checking with Tom Jordahl.

[08/17/93 public]
Closed bug.



CR Number                     : 8070
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : doc
Short Description             : add RPC_SUPPORTED_PROTSEQS
Reported Date                 : 5/28/93
Found in Baseline             : 1.0.2
Found Date                    : 5/28/93
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : app_ref/man3rpc/intro.3rpc
Sensitivity                   : public

[5/28/93 public]

add description of RPC_SUPPORTED_PROTSEQS to rpc intro manpage (3rpc)

DCE Application Development Reference
  DCE Remote Procedure Call
    Overview
      DCE RPC Environment variables


> Environment Variables
>
>...
>
> RPC_DEBUG environment
>
> Appears for the sole purpose of telling you not to set it and not to use it.
>

  RPC_SUPPORTED_PROTSEQS environment

  Appears for the sole purpose of telling you not to set it and not to use it.

> Optionally, ...

[06/03/93 public]
Assigned this CR to myself.

[07/08/93 public]
Decided to cancel this CR after consulting with Dave Weisman.  
RPC_SUPPORTED_PROTSEQS is documented in the Porting Guide, and
this should be sufficient, since it is only for developer use.

[07/29/93 public]
I can not make a distinction between RPC_DEBUG appearing in the docs
with a warning and RPC_SUPPORTED_PROTSEQS being treated similarly.
Both environment variables are for development use, both are documented
in the porting guide, and either would result in a big suprise for a 
dce app developer, should he inadvertently use one in an app.  Please
clarify.

[07/30/93 public]
RPC_DEBUG should be moved into the porting guide.
For 1.1, actually, it goes away to be replaced by serviceability code.
Re-opened this defect.

[07/30/93 public]
Hmmm.  My point was that *both* RPC_DEBUG and RPC_SUPPORTED_PROTSEQS should
be in the rpc app dev ref. The typical app developer won't have the porting
guide, but would be singed if he inadvertently used either of these in
an app.

[08/02/93 public]
Yes, I understand your point, and I was trying to correct it:  Both
RPC_DEBUG and RPC_SUPPORTED_PROTSEQS are *not* intended to be available
in DCE production environments.  They are intended for test-use only,
and therefore should be in the P&T guide.

[08/03/93 public]
Reassigned this CR to Doug Weir, the owner of the Porting Guide.

[09/21/93]
Removed RPC_DEBUG from the intro.3rpc reference page. Information about
both variables is already in the Porting Guide.

[11/11/93 public]

Verified change in latest doc build and closed this CR.



CR Number                     : 8069
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : cn rpc:timer thread is in condition wait
Reported Date                 : 5/28/93
Found in Baseline             : 1.0.2a
Found Date                    : 5/28/93
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : /idl/idl_compiler/sstubmts.c
					     /sys_idl/stubbase.h
					     /idl/lib/ctxeecli.c
Sensitivity                   : public

[5/28/93 public]

The timer thread is reclaiming the last association from association group
and ends up calling rundown_handles_action_rtn which calls 
rpc_ss_rundown_client(libidl.a) because this routine was registered
as the grp_liveness_mntr routine. This way the timer thread ends up 
doing a condition wait while the reference count on the failed client
is not zero. The reference count on failed client is decremented
only by rpc_ss_ctx_client_ref_dec called by server stub.
rpc_ss_ctx_client_ref_dec can fail if the routine it calls
(rpc_binding_inq_client) returns bad status. Also,
rpc__ss_ctx_client_ref_count_dec may not be called if 
operations like rpc_call_transmit fail and control flow 
is "goto closedown".

It incorrect design to have the timer thread do a condition
wait where it could be hung indefinitely, while there is
other work to do. I saw this problem because the timer thread
has locked the cn global mutex and 6 other threads are blocked
on this mutex.

Should we have a separate thread monitor liveness of clients
like dg protocol?

I am adding the stack traces of the threads that are blocked.

(/bin/dbx) mutex wait
 mutex  type  lock  owner  mutex_name            num_wait  waiters
 $m89   fast   yes  $t3                                 7  $t84 $t7 $t94 $t45 $t76 $t82 
$t11 

(/bin/dbx) thread current 3
t(/bin/dbx) 
cma__dispatch(0x200f3918, 0x20613308, 0x200f3638) at 0xd01346e8
cma__block(0x200f3918, 0x20613308) at 0xd0134430
ptdexc_cond_wait(0x200f3918, 0x20613308) at 0xd0148cdc
rpc_ss_rundown_client(0x200f3918) at 0xd0d80360
rundown_handles_action_rtn(0x200f3918, 0x20613308) at 0xd0cb9204
rpc__cn_sm_eval_event(0x200f3918, 0x20613308, 0x200f3638, 0x20613028) at 0xd0cb07c8
rpc__cn_assoc_grp_rem_assoc(0x200f3918, 0x20613308) at 0xd0cb0148
rem_mark_abort_action_rtn(0x200f3918, 0x20613308) at 0xd0cb4b38
rpc__cn_sm_eval_event(0x200f3918, 0x20613308, 0x200f3638, 0x20613028) at 0xd0cb07c8
rpc__cn_assoc_reclaim(0x200f3918, 0x20613308) at 0xd0caf594
rpc__cn_assoc_timer_reclaim(0x200f3918) at 0xd0caf3ec
rpc__timer_callout() at 0xd0c68ba0
timer_loop() at 0xd0c6844c
cma__thread_base(0x200f3918) at 0xd013db60

(/bin/dbx) thread current 84
(/bin/dbx) t
cma__dispatch(0x20613308, 0x200a39e8, 0x20613028) at 0xd01346e8
cma__block(0x20613308, 0x200a39e8) at 0xd0134430
cma__int_mutex_block(0x20613308) at 0xd0123928
ptdexc_mutex_lock(0x20613308) at 0xd0148434
receive_packet(0x20613308, 0x200a39e8, 0x20613028, 0x200a3708) at 0xd0cb61d8
receive_dispatch(0x20613308) at 0xd0cb55b8
rpc__cn_network_receiver(0x20613308) at 0xd0cb53d8
cma__thread_base(0x20613308) at 0xd013db60

(/bin/dbx) thread current 7
(/bin/dbx) t
cma__dispatch(0x200afec0, 0x200a39e8, 0x200afbe0) at 0xd01346e8
cma__block(0x200afec0, 0x200a39e8) at 0xd0134430
cma__int_mutex_block(0x200afec0) at 0xd0123928
ptdexc_mutex_lock(0x200afec0) at 0xd0148434
rpc__cn_network_select_dispatch(0x200afec0, 0x200a39e8, 0x200afbe0, 0x200a3708) at 0xd0c
b3264
lthread_loop() at 0xd0ca53b0
lthread(0x200afec0) at 0xd0ca51ec
cma__thread_base(0x200afec0) at 0xd013db60
(/bin/dbx) thread current 94
(/bin/dbx) t
cma__dispatch(0x203248b0, 0x200a39e8, 0x203245d0) at 0xd01346e8
cma__block(0x203248b0, 0x200a39e8) at 0xd0134430
cma__int_mutex_block(0x203248b0) at 0xd0123928
ptdexc_mutex_lock(0x203248b0) at 0xd0148434
rpc__cn_binding_alloc(0x203248b0, 0x200a39e8) at 0xd0cb927c
rpc__binding_alloc(0x203248b0, 0x200a39e8, 0x203245d0, 0x200a3708, 0x0) at 0xd0ca3e00
rpc_binding_from_string_binding(0x203248b0, 0x200a39e8, 0x203245d0) at 0xd0ca2edc
get_ep_binding(0x203248b0, 0x200a39e8, 0x203245d0) at 0xd0c8e918
rpc_mgmt_ep_elt_inq_begin(0x203248b0, 0x200a39e8, 0x203245d0, 0x200a3708, 0x0, 0x0, 0x20
053e00) at 0xd0c8d730
checkandfix(0x2009cd2c, 0x2009dadc, 0x2009cc88, 0x2009da5c) at 0x10000b8c
epmwatcher() at 0x100010d8
cma__thread_base(0x203248b0) at 0xd013db60

(/bin/dbx) thread current 45
(/bin/dbx) t
cma__dispatch(0x2046d868, 0x200a39e8, 0x2046d588) at 0xd01346e8
cma__block(0x2046d868, 0x200a39e8) at 0xd0134430
cma__int_mutex_block(0x2046d868) at 0xd0123928
ptdexc_mutex_lock(0x2046d868) at 0xd0148434
receive_packet(0x2046d868, 0x200a39e8, 0x2046d588, 0x200a3708) at 0xd0cb6228
receive_dispatch(0x2046d868) at 0xd0cb55b8
rpc__cn_network_receiver(0x2046d868) at 0xd0cb53d8
cma__thread_base(0x2046d868) at 0xd013db60

(/bin/dbx) thread current 76
(/bin/dbx) t
cma__dispatch(0x20483908, 0x200a39e8, 0x20483628) at 0xd01346e8
cma__block(0x20483908, 0x200a39e8) at 0xd0134430
cma__int_mutex_block(0x20483908) at 0xd0123928
ptdexc_mutex_lock(0x20483908) at 0xd0148434
receive_packet(0x20483908, 0x200a39e8, 0x20483628, 0x200a3708) at 0xd0cb6228
receive_dispatch(0x20483908) at 0xd0cb55b8
rpc__cn_network_receiver(0x20483908) at 0xd0cb53d8
cma__thread_base(0x20483908) at 0xd013db60

(/bin/dbx) thread current 82
(/bin/dbx) t
cma__dispatch(0x206081b0, 0x200a39e8, 0x20607ed0) at 0xd01346e8
cma__block(0x206081b0, 0x200a39e8) at 0xd0134430
cma__int_mutex_block(0x206081b0) at 0xd0123928
ptdexc_mutex_lock(0x206081b0) at 0xd0148434
receive_packet(0x206081b0, 0x200a39e8, 0x20607ed0, 0x200a3708) at 0xd0cb6228
receive_dispatch(0x206081b0) at 0xd0cb55b8
rpc__cn_network_receiver(0x206081b0) at 0xd0cb53d8
cma__thread_base(0x206081b0) at 0xd013db60


(/bin/dbx) thread current 11
(/bin/dbx) t
cma__dispatch(0x200bba58, 0x200a39e8, 0x200bb778) at 0xd01346e8
cma__block(0x200bba58, 0x200a39e8) at 0xd0134430
cma__int_mutex_block(0x200bba58) at 0xd0123928
ptdexc_mutex_lock(0x200bba58) at 0xd0148434
rpc__dg_call_start(0x200bba58, 0x200a39e8, 0x200bb778, 0x200a3708, 0x0, 0x0) at 0xd0cba9
64
rpc_call_start(0x200bba58, 0x200a39e8, 0x200bb778, 0x200a3708, 0x0, 0x0, 0x2) at 0xd0c89
520
op0_csr(0x200bba58, 0x200a39e8, 0x200bb778, 0x200a3708, 0x0, 0x0, 0x2) at 0xd0d17790
sec_krb5rpc_sendto_kdc(0x200bba58, 0x200a39e8, 0x200bb778, 0x200a3708, 0x0, 0x0, 0x2) at
 0xd0d17564
krb5_sendto_kdc(0x200bba58, 0x200a39e8, 0x200bb778) at 0xd0d17060
krb5_do_as_request(0x200bba58, 0x200a39e8, 0x200bb778, 0x200a3708, 0x0, 0x0) at 0xd0d15f
18
sec_login_pvt_get_krb_tgt(0x200bba58, 0x200a39e8, 0x200bb778) at 0xd0c75268
sec_login_refresh_identity(0x200bba58, 0x200a39e8) at 0xd0cd4b18
ticket_refresh() at 0x10001d38
cma__thread_base(0x200bba58) at 0xd013db60

[6/7/93 public]

Following comments from Yi-Hsiu Wei at IBM:

In the server stub, the client context reference count should be decremented
only if it had been successfully incremented. A flag is added to ensure this
 condition.


*** 19e/sstubgen.c	Mon May 24 19:00:33 1993
--- sstubgen.c	Mon Jun  7 16:45:01 1993
***************
*** 1,4 ****
  #ifdef AIX_PROD
! static char sccsid[]="@(#)25    1.11  src/rpc/idl/idl_compiler/sstubgen.c, rpc.idl.src, aixdce12, 9319120  2/5/93  11:23:58";
  /*
   * COMPONENT_NAME:  rpc.idl.src 
--- 1,4 ----
  #ifdef AIX_PROD
! static char sccsid[]="@(#)25    1.11  src/rpc/idl/idl_compiler/sstubgen.c, rpc.idl.src, aixdce12, 9320120a  2/5/93  11:23:58";
  /*
   * COMPONENT_NAME:  rpc.idl.src 
***************
*** 349,352 ****
--- 349,360 ----
           "volatile RPC_SS_THREADS_CANCEL_STATE_T NIDL_general_cancel_state;\n");
  
+ #ifdef AIX_PROD /* CMVC 6328 */
+     if (AST_HAS_IN_CTX_SET(p_operation)
+         || AST_HAS_OUT_CTX_SET(p_operation))
+     {
+         fprintf(fid, "ndr_boolean using_ctx_client = ndr_false;\n");
+     }
+ #endif
+ 
      if (AST_HAS_IN_PTRS_SET(p_operation)
      || AST_HAS_OUT_PTRS_SET(p_operation)
***************
*** 493,496 ****
--- 501,508 ----
               "rpc_ss_ctx_client_ref_count_inc(h, (error_status_t *)&st);\n");
          CSPELL_test_status(fid);
+ 
+ #ifdef AIX_PROD /* CMVC 6328 */
+         fprintf(fid, "else using_ctx_client = ndr_true;\n");
+ #endif  
      }
  
***************
*** 508,520 ****
      if (AST_HAS_OUTS_SET(p_operation)) BE_marshall(fid, p_operation, BE_out);
  
- #ifdef AIX_PROD /* CMVC 1814 */
-     if (AST_HAS_IN_CTX_SET(p_operation)
-         || AST_HAS_OUT_CTX_SET(p_operation))
-     {
-         fprintf(fid,
-              "rpc_ss_ctx_client_ref_count_dec(h, (error_status_t *)&st);\n");
-         CSPELL_test_status(fid);
-     }
- #endif /* AIX_PROD */
      /*
       * Emit TYPE_free() calls for any [in] transmit_as types and
--- 520,523 ----
***************
*** 550,561 ****
      fprintf(fid, "ENDTRY\n");
  
- #ifndef AIX_PROD /* CMVC 1814 */
      if (AST_HAS_IN_CTX_SET(p_operation)
          || AST_HAS_OUT_CTX_SET(p_operation))
      {
          fprintf(fid,
               "rpc_ss_ctx_client_ref_count_dec(h, (error_status_t *)&st);\n");
      }
! #endif
      if (AST_HAS_IN_PTRS_SET(p_operation)
      || AST_HAS_OUT_PTRS_SET(p_operation)
--- 553,566 ----
      fprintf(fid, "ENDTRY\n");
  
      if (AST_HAS_IN_CTX_SET(p_operation)
          || AST_HAS_OUT_CTX_SET(p_operation))
      {
+ #ifdef AIX_PROD /* CMVC 6328 */
+         fprintf(fid, "if( using_ctx_client == ndr_true)\n");
+ #endif
          fprintf(fid,
               "rpc_ss_ctx_client_ref_count_dec(h, (error_status_t *)&st);\n");
      }
! 
      if (AST_HAS_IN_PTRS_SET(p_operation)
      || AST_HAS_OUT_PTRS_SET(p_operation)

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8068
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : kill client core dumps servers
Reported Date                 : 5/28/93
Found in Baseline             : 1.0.2b23
Found Date                    : 4/15/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : cnsclsm.c cncall.c
Sensitivity                   : public

[5/28/93 public]

This problem was discovered during pvt testing when it became necessary to
kill a large number of dramatic test clients in order to restart a different
configuration.  It was noted that various servers core dumped ( including   
the rpcd ) as a result.  We found that the stack traces often showed SIGSEGV
in malloc or free as though there had been a double free.  This corresponded
to a problem that we already had open here but not as an OT.  That problem 
was related to core dumps in servers when clients RPCs were cancelled.  The
stack traces vary and will not always indicate problems in malloc or free and
so we were not sure what the problem was.  In the last week I have been    
working on the problem and have found two separate corrections that must be 
made.

The first problem that I discovered was another one of those cases where a
part of the call_rep in the client call_start path was not initialized before
an error could occur.  The prot_tlr in the call_rep was not initialized
and if the call_rep came from the heap then any data could be in that 
location.  If this happened and the assoc_open failed from assoc_request,
then we will end up in call_end which will explicitly free this thing if it
is not NULL.  In the case of an uninitialized location we definitely create
some problems for the malloc tree. There are actually several places in 
assoc_request where it could fail.  In any event, if the prot_tlr happens to
be NULL when the call_rep is first pulled from the heap, then it will go back
on the free list that way and that call_rep will happen to always be ok.
In addition, systems that implicitly zero storage in malloc will not see this
problem.  This problem happened in a server that was making client calls and
was servicing client calls and so large amounts of memory were being reused.

The fix for this problem is in cncall.c at around line 443 in cn_call_start
as follows:

    /*
     * Mark it as a client call rep.
     */
    call_rep->common.is_server = false;
#if defined(AIX_PROD) || defined (IBMOS2)  /* CMVC 6177 */
    call_rep->prot_tlr = NULL;
#endif

You should also include the lines that follow this because they relate to
OT7356 for server calls ( I forgot to check client calls at the same time) 
#if defined(AIX_PROD) || defined (IBMOS2)  /* CMVC 5186 */
    /*
     * forgot to do this when we did it in cnrcvr.c for server calls
     */
    {
    int i;
    for( i=0; i<rpc_c_max_iovec_len; i++ ) {
    call_rep->buffered_output.iov.elt[i].buff_addr = NULL;
    call_rep->buffered_output.iov.elt[i].buff_dealloc = NULL;
    }
    }
#endif


The second problem was much more difficult to discover and produced all kinds
of core files that indicated some kind of memory corruption was occurring.
What it turned out to be was a write of a checksum by krb_cn_pre_send when
it called rpc__krb_cn_compute_md5_cksm.  The pointer it passes to write the
checksum is computed by using the auth_len field in the packet header.  What
was occurring that was causing the checksum to be written in  locations
that other threads were using was that the iov that was sent to pre_send
had only one element and it was an auth_tlr which doesn't have a valid packet
header because it is a trailer.  It so happens that the offset of the auth_len 
field in the packet header is some uninitialized data in an auth_tlr and hence
whatever came from the heap when the small fragbuf was allocated was used as
the length.  The source of this bug is in the call_executor thread when it
was doing a call_end from the stub and hence ended up in call_end_action_rtn.
The call was in the call_response state and was attempting to perform a   
rpc_resp event.  There is a disconnect predicate that is checked at this point
which if the connection is closed will fail the call and the stub will go to
call_end.  The disconnect predicate evalutating to true results in the 
abort_resp_action_rtn being called which calls dealloc_buffered_data and sets
the iovlen to 1.  This leaves the auth_tlr as the only element in the iov
and sets up the bad behavior. 

The fix that is made under this defect is to recognize that the call has been
damaged by the connection being closed and to set the call status to 
orphaned in the abort_resp_action_rtn ( in cnsclsm.c ).  There
is already code in the end_action_rtn that detects this status and refuses to
send the invalid packet.  

Here is that change ( at about line 1794 of cnsclsm.c in abort_resp_action_rtn)

    if (RPC_CN_CREP_IOVLEN (call_rep) > 1)
    {
    rpc__cn_dealloc_buffered_data (call_rep);

#if defined(AIX_PROD) || defined(IBMOS2)
    /*
     * This will keep the call_end_action_rtn from attempting to
     * send the remaining iov which at this point is only an auth_tlr
     * if this was an authenticated call.  We are calling this an
     * orphaned call which technically, it is, ie the connection is
     * gone and along with it the association.
     */
    call_rep->cn_call_status = rpc_s_call_orphaned ;
#endif

[6/18/93 public]

The above mentioned code in cncall.c (also in cnrcvr.c), which initializes
call_rep->buffered_output.iov.elt[i], should start from the index 1, e.g.,
i=1. Because when call_rep is allocated by rpc__list_element_alloc(), it
initializes call_rep->buffered_output.iov.elt[0] pointing to the protocol
header. Actually, the initialization is done only once when the call_rep
element is malloc'ed (by rpc__cn_call_ccb_create()) and the subsequent
reuse of the same element (via rpc__list_element_free() and
rpc__list_element_alloc()) won't re-initialize it.

RPC_CN_CREP_IOV macro should be used for the code consistency.

[ wrs public 6/23/93 ]
The above comment is accurate and when I saw it, I wondered why setting the
buff_addr to NULL in the first iov element didn't cause an immediate failure.
The reason is that the operation is a NOP because only the data_addr field
of the iov element is used for transmission purposes and the rest of the 
references to the protocol header are made through the prot_hdr field of the
call_rep itself ( which was not affected by the changes ).

[08/26/93 public]
In cncall.c, I initialized the call_rep iov's correctly (starting at element 1).
In cnsclsm.c, I set the call status to orphaned to prevent call_end_action_rtn
from trying to send the remaining iov's.

Code submitted to 1.0.3.

[10/6/93 public]
Initialized the call_rep iov's correctly (starting at element 1) 
in cnrcvr.c also.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8059
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 8058
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : sys_idl
Short Description             : nbase.acf is not installed in include area
Reported Date                 : 5/25/93
Found in Baseline             : 1.0.2
Found Date                    : 5/25/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : nbase.acf
Sensitivity                   : public
The new (1.0.3) IDL compiler ignores the [out_of_line] attribute.
Therefore nbase.acf is no longer needed

[5/25/93 public]

Page 2-9 of the application development reference lists the names of
the collection of files related to the idl command (see FILES).

Included in this list of files is nbase.acf which is not exported/installed
as part of the build/install/configure process. Therefore the build of the
rpc/sys_idl directory is not consistent with the documentation.

Furthermore, note that the nbase.acf file causes the marshalling of the
uuid_t type to be done out of line, with the corresponding space/time
tradeoff implications for dce core components and applications.

A related defect has also been opened against the documentation (see
Inter-dependent CRs).

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 8058
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 8059
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_ref
Short Description             : FILES section lists missing files
Reported Date                 : 5/25/93
Found in Baseline             : 1.0.2
Found Date                    : 5/25/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : idl.1rpc
Sensitivity                   : public

[5/25/93 public]

Page 2-9 of the application development reference lists the names of
the collection of files related to the idl command (see FILES).

included in this list of files is nbase.acf which is not exported/installed
as part of the build/install/configure process. Therefore the document is
not accurate with respect to the presence of this file.

In addition, it appears that the locations of the other files on the list 
are not quite correct. 

The absence of nbase.acf has an effect on DCE aplication stub size which
will be addressed in a companion defect opened against the code (see
Inter-dependent CRs).

[07/06/93 public]
Assigned this CR to writer Steve Lewontin.

[10/12/93]

I've updated the Files list to:

dceshared/bin/idl

dceshared/share/include

dceshared/share/include/dce/nbase.idl

dceshared/nls/msg/LANG/idl.cat

dceshared/share/include/dce/file.ext

[11/11/93 public]

Verified changes in latest doc build and closed this CR.



CR Number                     : 8053
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : perf tester
Short Description             : Perf test security errors
Reported Date                 : 5/25/93
Found in Baseline             : 1.0.2
Found Date                    : 5/25/93
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : rpc/runtime/krbdgcom.c
Sensitivity                   : public

[5/25/93 public]

(Defect opened on behalf of Spencer Ainsworth)

Problems with the perf testcases.

 The failure is test #13 for security combinations 1,1,1 and 1,2,1.
 On UDP the combinations 1,1,1 and 1,2,1 were failing with "incorrect exception"


I have tested both AIX/DCE 1.2 and OSF/DCE 1.0.2 released code. The results
turn out to be the same: 1,1,1 and 1,2,1 combinations failed on ncadg_ip_udp
but not ncacn_ip_tcp.

[12/8/93 public]

This happens when the cached scall is used, which was rejected in its
previous use, because its auth info is not validated yet.

[5/27/94 public]

The fix has been submitted as a part of MBF code drop.



CR Number                     : 8046
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : doc
Short Description             : fix for CMVC 5371 rpc.doc
Reported Date                 : 5/24/93
Found in Baseline             : 1.0.2b23
Found Date                    : 5/24/93
Severity                      : E
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : 1
Sensitivity                   : public

[5/24/93 public]

Add note about unsupported protseq error to rpcd manpage -- see
CMVC 5371 rpc.doc.

THIS DEFECT IS TO BE RETURNED TO OSF BY IDD, PLEASE ADD THE OT CR NUMBER TO
THIS DEFECT'S ABSTRACT WHEN THE OT CR IS OPENED (see CMVC 1381 for an example).

DCE Admin Reference
  DCE Remote Procedure Call
    rpcd

> ...
> The optional protseq argument lets you limit the protocol sequences that
> the RPC daemon listens on to only those protocol sequences that you
> specify.

  Note: If the persistent database file contains protocol sequences
        not included in the protseq argument, rpcd will fail to start.

> For backward ...

[06/15/93 public]
Assigned this CR to myself.

[06/17/93 public]
Added the requested note to the rpcd.8rpc DESCRIPTION section.
Verified by Dave Weisman.

[08/17/93 public]
Closed bug.



CR Number                     : 8041
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_gd
Short Description             : Section server.c Source Code, "signal" should be "exception."
Reported Date                 : 5/21/93
Found in Baseline             : 1.0.2
Found Date                    : 5/21/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : 1
Sensitivity                   : public

[5/21/93 public]

Full Description:

        Section 11.4.2 (in 1.0.1), is incorrect; the server behavior
        described relates to receiving an exception, not a signal. The
        paragraph begins:

        .P
        To begin listening for remote procedure call requests, the server
        calls \*Lrpc_server_listen(\|)\*O.  This call is placed within the
        \*LTRY\*O
        of a \*LTRY\*O, \*LCATCH_ALL\*O, \*LENDTRY\*O sequence so
        that if the server receives a signal while it is listening, it can
                                    ^^^^^^^^
        unregister its interface and its endpoint before it exits, as
	follows:
        .P

        The marked words should say "an exception" rather than "a signal."
        Also, after the example that follows the paragraph (ending as
	follows)

                 printf("Unregistering endpoint\\n");
                 rpc_ep_unregister(binop_v1_0_s_ifspec, bvec,
                     (uuid_vector_p_t) NULL, &st);

            } ENDTRY;
        }
        .oE

        it would be good to add the following:

        Server execution is often terminated using the ctrl-C
        (SIGINT on SVR4) signal. This signal is not trapped by
        the CATCH_ALL clause. Thus, server execution is terminated
        but obsolete end point mappings persist in the end point
        data base.

        To ensure that the server unregisters its interface and its
        endpoints on receipt of a terminating signal, the
        server must declare a handler as follows:


        void handler(signum)        /* SVR4 compliant */
        int signum;
        {
           if(signum == SIGINT)
             {
                rpc_ep_unergister(binop_v1_0_s_ifspec, bvec, NULL, &st);
                exit(0);
              }
         }
         ...    /* server code */

         signal(SIGINT, handler);    /* server must execute this statement*/
                                    /* before going into listen */

Repeat By:

Proposed Solution:

	See changes in Full Description

[5/27/93 public]
Assigned to myself.

[6/1/93 public]
Changed to "verified".  Made the changes described in this CR
to the Application Development Guide chapter rpc/3_build_app.gpsml.
Changed the sentence "Server execution is often terminated using the
ctrl-C (SIGINT on SVR4) signal." to "Server execution is often
terminated using the SIGINT signal, which is often generated by
entering <Ctrl-C>" at Howard Melman's request.

[08/17/93 public]
Closed bug.



CR Number                     : 8036
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : cn, ns
Short Description             : RPC crashes process after bad rpc__list_element_alloc.
Reported Date                 : 5/21/93
Found in Baseline             : 1.0.2
Found Date                    : 5/21/93
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpclist.c
Sensitivity                   : public

[5/21/93 public]

There are a number of places in CN and NS where rpc__list_element_alloc is
called without any error checking.  If the process cannot successfully
malloc, rpc__list_element_alloc returns a null pointer and a crash occurs.

Typical example (from cnassoc.c)

    sec_context = (rpc_cn_sec_context_t *) 
        rpc__list_element_alloc (&rpc_g_cn_sec_lookaside_list, true);

    sec_context->sec_valid = false;

All such calls to rpc__list_element_alloc need proper error handling.

[6/1/93 public]

Also, there a few places in CN where rpc__cn_fragbuf_alloc() is called
without any error checking, which include RPC_CN_FRAGBUF_ALLOC macro
defined in cnfbuf.h. Here is a list of files involved:
  cncall.c
  cncassm.c
  cnfbuf.c
  cnfbuf.h
  cnrcvr.c
  cnsassm.c
  cnsclsm.c
  cnxfer.c

In addition to these, rpc__list_element_free() does not check the null
pointer. (Well, it shouldn't happen, but the assertion like:
"assert((list_desc != NULL && list_element != NULL));" won't hurt.)

[6/1/93 public]

By further examining the code, we've found that the above *_alloc() never
return the NULL pointer because RPC_MEM_ALLOC() dies when it can't malloc.
rpc__die() will raise SIGABRT.

[6/2/93 public]

Hmmm, this gets more interesting.  I was originally tricked by the code in
rpc__list_element_alloc which does a sleep/retry loop after a NULL pointer
is returned from RPC_MEM_ALLOC [which of course can't happen.]  So somthing
slightly more subtle is going on:

rpc__list_element_alloc can still return NULL.  Near the bottom of the proc
is:

         /*
          * Catch any exceptions which may occur in the
          * list-specific alloc routine. Any exceptions
          * will be caught and the memory will be freed.
          */
         TRY
         {
             (*list_desc->alloc_rtn) (element);
         }
         CATCH_ALL
         {
             RPC_MEM_FREE (element, list_desc->element_type);
             element = NULL;
         }
         ENDTRY


We should decide if we want to spec rpc__list_element_alloc as having the
ability to return NULL [and fix all broken callers], or do a DIE() within
the CATCH_ALL to be culturally compatible with RPC_MEM_ALLOC.

BTW, this bug was originally seen by Paul Ellis when stress testing a cell
with ~20K entries in the registry, but a small ulimit on secd.  We'll try to
reproduce it and see who the offender is.

[6/4/93 public]

The specific failure is:

#0  0x732679e8 in rpc__cn_assoc_acb_alloc (wait=1, type=1, st=0x7fff7010)
    at /project/dce/build/dce1.0.2a/src/rpc/runtime/cnassoc.c:4038
#1  0x7325ff98 in rpc__cn_assoc_request (call_r=0x735f5568, binding_r=0x1, 
    if_r=0x1007a000, syntax=0x0, context_id=0x7fff6fe8, sec=0x7325ff98, st=0x0)
    at /project/dce/build/dce1.0.2a/src/rpc/runtime/cnassoc.c:740
#2  0x7327592c in allocate_assoc_action_rtn (spc_struct=0x735f5568 "", 
    event_param=0x1<Address 0x1 out of bounds>)
    at /project/dce/build/dce1.0.2a/src/rpc/runtime/cncclsm.c:741
#3  0x73286ac4 in rpc__cn_sm_eval_event (event_id=1935627624, 
    event_parameter=0x1<Address 0x1 out of bounds>, spc_struct=0x1007a000 "", 
    sm=0x0) at /project/dce/build/dce1.0.2a/src/rpc/runtime/cnsm.c:337
#4  0x7326ba98 in rpc__cn_call_start (binding_r=0x735f5568, call_options=1, 
    ifspec_r=0x1007a000, opnum=0, transfer_syntax=0x7fff6fe8, st=0x7325ff98)
    at /project/dce/build/dce1.0.2a/src/rpc/runtime/cncall.c:563
#5  0x732389e8 in rpc_call_start (binding_h=0x735f5568, flags=1, 
    ifspec_h=0x1007a000, opnum=0, call_handle=0x7fff6fe8, 
    xfer_syntax=0x7325ff98, status=0x0)
    at /project/dce/build/dce1.0.2a/src/rpc/runtime/comcall.c:157
#6  0x7325a408 in op3_csr (entry_handle_=0x0, h_=0x735f5568, 
    map_tower_=0x1007a000, max_towers_=2147446760, num_towers_=0x7325ff98, 
    object_=0x1, status_=0x0, towers_=0x0) at ep_cstub.c:1674
#7  0x7324a70c in ep_get_endpoint (if_r=0x735f5568, binding_r=0x1, 
    st=0x1007a000) at /project/dce/build/dce1.0.2a/src/rpc/runtime/comep.c:1900
#8  0x7324a0e0 in rpc_ep_resolve_binding (binding_h=0x735f5568, if_spec_h=0x1, 
    status=0x1007a000)
    at /project/dce/build/dce1.0.2a/src/rpc/runtime/comep.c:1590
#9  0x7326b42c in rpc__cn_call_start (binding_r=0x735f5568, call_options=1, 
    ifspec_r=0x1007a000, opnum=0, transfer_syntax=0x7fff6fe8, st=0x7325ff98)
    at /project/dce/build/dce1.0.2a/src/rpc/runtime/cncall.c:394
#10 0x732389e8 in rpc_call_start (binding_h=0x735f5568, flags=1, 
    ifspec_h=0x1007a000, opnum=0, call_handle=0x7fff6fe8, 
    xfer_syntax=0x7325ff98, status=0x0)
    at /project/dce/build/dce1.0.2a/src/rpc/runtime/comcall.c:157
#11 0x732bab74 in op4_csr (binding_handle_=0x735f5568, authn_proto_=1, 
    princ_name_size_=268935168, princ_name_=0x0, status_=0x7fff6fe8)
    at mgmt_cstub.c:787
#12 0x732b623c in rpc_mgmt_inq_server_princ_name (binding_h=0x735f5568, 
    authn_protocol=1, server_princ_name=0x1007a000, status=0x0)
    at /project/dce/build/dce1.0.2a/src/rpc/runtime/mgmt.c:1210
#13 0x7335e7e0 in rca_inq_cell_name ()
#14 0x7335caa0 in rca_setup_handle ()
#15 0x7335d58c in rca_rebind ()
#16 0x7335dc4c in rca_site_bind_pe_site ()
#17 0x7335c6dc in rca_nsi_binding_import ()
#18 0x7335fd48 in rca_site_bind ()
#19 0x733511d0 in sec_rgy_site_bind ()
#20 0x733512f8 in sec_rgy_site_bind_query ()
#21 0x73442a78 in sec_login_pvt_allocate_login_context ()
#22 0x73439608 in sec_login_setup_identity ()
#23 0x41b470 in rs_login_pvt_setup_context ()
#24 0x41c08c in rs_login_become_rgy ()
#25 0x407d14 in rs_setup_dce_rgy_identity ()
#26 0x400e54 in rgy_main ()
#27 0x4002a0 in main ()

We're die in rpc__cn_assoc_acb_alloc.  What's happening is that
rpc__list_element_alloc was called to allocate an assoc, but NULL was
returned.  This happened because inside element_alloc, we called the
list_desc->alloc_rtn() which is rpc__cn_assoc_acb_create.

acb_create calls pthread_create.  Pthread_create faults (presumably it
can't sbrk), and the fault is caught by element_alloc.  NULL is then
returned from element_alloc back to an unsuspecting acb_alloc.

[09/03/93 public]
It sounds to me like the right thing to do is DIE in rpc__list_element_alloc()
rather than fixing all the caller to do what?  Die also I would think...

And if RPC_MEM_ALLOC does it, I should think we would need to be consistant.

[09/07/93 public]
If alloc_rtn in rpc__list_element_alloc() raises an exception,
we DIE so we don't return null to callers that don't expect it.

Submitted

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 7990
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : cthread_call_executor is not cancel safe
Reported Date                 : 5/13/93
Found in Baseline             : 1.0.2
Found Date                    : 5/13/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b18
Affected File(s)              : sstubmts.c
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[5/13/93 public]
Often times I have noticed, executor threads die even with DG RPCs. A few
times I have been able to reproduce this by cancelling the client thread
that initiated the RPC. As a result of the cancellation, I guess a "quit"
message is sent to the server, causing the "lthread" to cancel the
appropriate executor thread. I have often times seen multiple cancellations
being generated as a result of the receipt of multiple "quit" messages at the
server. I do not understand the synchronization between the lthread generating
cancels and the executor thread, but a few times I have noticed the executor
thread being cancelled when it does a RPC_COND_WAIT in the idle state.
Since this particular RPC_COND_WAIT is not wrapped within the TRY, CATCH, 
ENDTRY clauses, an exception (read cancellation) causes the executor
thread to go away. The piece of code that is of interest appears to be:
INTERNAL void cthread_call_executor (cthread)
cthread_elt_p_t cthread;
{
    rpc_call_rep_t          *call_rep;
    rpc_cthread_pvt_info_p_t pvt;
    cthread_pool_elt_p_t    p = cthread->pool;
    cthread_queue_elt_p_t   qelt;
    boolean                 skip_startup = true;
    /*
     * Call executors execute with general cancelability disabled
     * until the stub dispatched to the manager.  This prevents the
     * call executor from having a pending cancel delivered to it before
     * the manager is called.
     */
    pthread_setcancel(CANCEL_OFF);
    RPC_MUTEX_LOCK (cthread_mutex);
    
    if (CTHREAD_POOL_IS_QUEUE_EMPTY(p))
    {
	skip_startup = false;
    }
    /*
     * Loop executing calls until we're told to exit.
     */
    while (true)
    {
        boolean run_queued_call = false;
	if (!skip_startup) 
	{
	    /*
	     * Update the pool's idle thread info.
	     */
	    CTHREAD_POOL_IDLE_THREAD(p, cthread);
	    /*
	     * Wait for a call assignment (or until we're told to exit).
	     */
	    while (cthread->thread_state == rpc_c_idle_cthread && ! p->stop)
	    {
		RPC_COND_WAIT (cthread->thread_cond, cthread_mutex);
	    }
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

[8/26/94 public]

The general cancelability is disabled in the call executor thread
(pthread_setcancel(CANCEL_OFF) in the above code fragment). Unless the
server stub returns without restoring the general cancelability state,
RPC_COND_WAIT() will never be cancelled. Are you really seeing the cancel?

[9/13/94 public]

See my comment in CR 12147. Probably, the general cancellability is enabled
in the call executor thread because of missing
RPC_SS_THREADS_RESTORE_GENERAL() in the CATCH_ALL block of the server stub.

[9/13/94 public]

Yup, the server stub is returning without restoring the general
cancellability state when the exception is raised in the server manager
routine. (If my memory is correct, there was the OT defect opened by IBM
against the 1.0.2 IDL compiler about this, which was closed or cancelled
when the 1.0.3 IDL compiler was submitted.) Here is the fix which seems to
be working:

--- ../../../../link/src/rpc/idl/idl_compiler/sstubmts.c        Thu Jun 23 14:25:25 1994
+++ sstubmts.c  Tue Sep 13 10:08:43 1994
@@ -336,6 +336,7 @@
 
     fprintf (fid, "\n/* manager call */\n");
     fprintf( fid, "IDL_manager_entered = ndr_true;\n" );
+    fprintf( fid, "RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);\n");
     fprintf( fid,
               "RPC_SS_THREADS_ENABLE_GENERAL(IDL_general_cancel_state);\n" );
 
@@ -467,6 +468,7 @@
     fprintf(fid, ");\n");
     fprintf( fid,
               "RPC_SS_THREADS_RESTORE_GENERAL(IDL_general_cancel_state);\n" );
+    fprintf( fid, "RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);\n");
 
     if ( rep_as_handle_param != BE_no_rep_as_handle_t_k )
     {
@@ -613,6 +615,8 @@
     fprintf(fid, "IDL_ms_t IDL_ms;\n");
     fprintf(fid, "volatile ndr_boolean IDL_manager_entered = ndr_false;\n");
     fprintf(fid,
+           "volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;\n");
+    fprintf(fid,
          "volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_general_cancel_state;\n");
     fprintf(fid, "idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];\n");
 
@@ -781,6 +785,12 @@
     fprintf(fid, "\nIDL_closedown: ;\n");
     fprintf(fid, "CATCH_ALL\n");
 
+    fprintf(fid, "if ( IDL_manager_entered )\n{\n");
+    fprintf(fid,
+              "RPC_SS_THREADS_RESTORE_GENERAL(IDL_general_cancel_state);\n");
+    fprintf(fid, "RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);\n");
+    fprintf(fid, "}\n");
+
     /*
      * For all exceptions other than report status, send the exception to the
      * client.  For the report status exception, just fall through and

[9/13/94 public]
We should fix this.

[9/14/94 public]
And we did.
Marked as fixed.

[9/22/94 public]
I agree with the basic fix to make sure that general cancellability is
restored for the exception case.  But why, at the same time, did you
add disabling/restoring of asynch cancellability.  My understanding is
that none of DCE supports asynch cancellability, so certainly the
RPC runtime is not calling into stubs with executor threads with
asynch cancellability enabled.  Also, it is documented that if a manager
routine enables asynch cancellability, it must restore asynch
cancellability before it returns into the server stub.

The stubs are already gross enough, I don't think we should make them
even grosser by adding this code, whose only purpose it to cover up
for misbehaved managers.  It is also a, perhaps slight, performance
issue to have the extra pair of calls per RPC.

Rico

[9/23/94 public]

You're right.  (I didn't notice that the fix was twiddling async-cancels.)
It's two more lock/unlock pairs to cover over a progrraming error.



CR Number                     : 7970
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc_mgmt_is_server_listening
Short Description             : OT 7243 broke rpc_mgmt_is_server_listening
Reported Date                 : 5/10/93
Found in Baseline             : 1.0.2
Found Date                    : 5/10/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 
Fixed In Baseline             : 1.0.3
Affected File(s)              : src/rpc/runtime/dglsn.c
Sensitivity                   : public

[5/10/93 public]
The fix to OT 7243 seems to have broken rpc_mgmt_is_server_listening when the
target binding doesn't have an endpoint and the endpoint is not in rpcd's map,
e.g. the client got a stale binding out of CDS.  The problem is the the new 
version of recv_dispatch in dglsn.c doesn't check anymore to see if the object
UUID is one that rpcd has registered.  In the old code this check would have
failed and the packet would have been passed to the forwarding function, there
to be dropped.

In the new code, the forwarding function is called right off, it fails to find
the interface and object in its map and returns false, and the interface is
then checked to see if rpcd supports it.  Unfortunately, since everybody
supports rpc_mgmt_is_server_listening, this check passes and the call is passed
on to rpcd who says "Yes, I'm listening."  This will happen for any interface
that is common to the runtime, e.g. rpc_mgmt_inq_server_stats.  

I assume that the original problem with rpc_mgmt_ep_unregister was that the
UUID to be unregistered is actually passed as the object UUID?  So in short,
the ept interface makes a non-standard usage of the object UUID?  If that is
the case, perhaps the solution is to use Mark's optimization of checking
explicitly for the ept interface (not forwarding in that case) and otherwise
preserve the prior behavior of first checking object and interface, and then
giving it to the forwarder as a last chance, but not trying to handle objects
whose types have not been registered locally.

[5/11/93 public]

I think we need to take a couple of steps backwards here.  This whole problem
seems to be a result of our underestimating the requirements for supporting 
forwarding servers that export the same i/f's as the server's they forward to.

There are two ways you might expect this to work.  First, the forwarder could be
a group leader, as well as a group member.  New requests would be handed to the
forward map function which could decide whether the request should be forwarded
or handled locally (load-balancing).  The forwarder would expect to be a full-
fledged server; in particular, it would expect that it could handle calls on
object UUIDs that it had *not* registered locally (the way all other servers
can).  This is the way the rpcd currently works (post OT 7243).

The second scenario is to have a forwarding server that is *only* a group leader/
representative/coordinator.  Under this scheme, the server might need to export 
one interface in common with the rest of the group (for code reuse or consistency), 
say, for example, a management interface.  In this case, the forwarder would probably 
need some way to differentiate itself from the other group members, since it is not 
just another member of the group.  This is the way that the rpcd used to work 
(pre OT 7243).  The problem with the pre-7243 scheme was that we made it work
by special casing the code around the forward map handoff routine.  Since the 
status of the forwarder (group member or coordinator) is decided at the application
level, the decision on how to treat shared interfaces belongs at that level as well.

Which bring us to the rpc_mgmt i/f.  *We* need to make this decision since we 
defined the i/f.   In our case, we would say that rpcd is a group coordinator rather 
than a group member, and that unless a mgmt call was specifically directed at the rpcd, 
it should be forwarded or dropped.  Rather than achieving this effect by adding a 
special case to the DG listener code, we could instead move it up to the "application" 
level by making the rpc_mgmt_*() routines do an ep_resolve on the handle, if necessary, 
before making the call.  Unless the client explicitly tries to do an rpc_mgmt call 
on a handle that is fully bound to the rpcd, the call will never get sent to an rpcd.

Note that this is essentially what happens in the  CN code already, which is why 
CN doesn't have this problem.

(Also, a side benefit of this modification is that clients will no longer see the
30 second timeout when the server doesn't exist but the rpcd is up.)

[5/12/93 public]
In the second scenario above, how does the forwarder differentiate itself from the
other group members?

It sounds like you're saying that in the case of rpcd it can't, so we have to make
sure that clients never try to forward common calls (e.g. mgmt interfaces).

It struck me this morning that this really is a behavioral change on the part of rpcd,
which affects interoperability with 1.0.1 clients (as well as clients based on the
future X/OPEN AES).

[5/13/93 public]

In general, differentiating between calls made to a group member or a group coordinator
belongs on the client side of the application.  This can be done with the cooperation of
the forwarder; for example, by using an object UUID registered by the forwarder.  Or it
can be done without cooperation from the forwarder; for example, by bypassing forwarding
and having the client send requests (over common i/f's) directly to the intended server.

In the rpc_mgmt case, the obvious choice is the second approach, both for backward 
compatibility, and because it performs better in the (common?) case of a client 
trying to determine the viability of some stale handle it just pulled out of the name
space.

I'm not sure if it's clear that this requires no change in application code.  The 
change is put into the client agent code (the rpc_mgmt* calls). If the application 
tries to do is_server_listening() on a partially bound handle, the agent routine 
needs to be smart enough to know that the client does not want this call handled 
by an rpcd.  (If the client *did* want to make the call to the rpcd, it would have 
specified a fully bound handle.)

Keep in mind that the CN protocol (appropriately) makes this assumption about 
*every* call.  If rpc__cn_call_start(), is called to start a call on a partially
bound handle, the CN code assumes the call is not being made to the rpcd, and
resolves the binding.  (If the call *is* being made to the rpcd, the handle must
be fully bound before making the call.)

As far as interoperability goes, this change only affects users of the rpc_mgmt i/f,
and means that DG clients will now see the same behavior that CN clients have seen all 
along (no more 30 sec. comm timeouts when making calls on stale name space entries).
(I don't know that the AES specifically mentions how failures look when making mgmt
calls over the DG protocol.)

[5/13/93 public]

The way it currently stands, DCE 1.0.1 clients using the rpc_mgmt i/f will get
incorrect results using unbound endpoints talking to 1.0.2 servers.

In the case of the rpc_mgmt i/f, doesn't the absence of a UUID differentiate
a call directed at the rpcd from a call that is to be forwarded?  The APIs
enforce that you either have a fully bound handle or you have a UUID so the
rpcd can figure out who you're talking to.

[5/17/93 public]

Yes, my point is that this logic belongs in the rpcd application code, not in the
rpc runtime (both the fix for 1.0.1 compatibility, and the grunge that knows what 
to do with mgmt calls based on the object UUID).

However, since HP is currently late in a release cycle, we will be using the quicker
(lower risk) fix for this problem, for the time being.  I simply  added the mgmt i/f 
checking into the forwarder handoff code in the rpc runtime.  If anyone wants a copy
of the fix, it's checked in as rev 1.1.6.2 of dglsn.c.

[5/26/93 public]
Will this fix be in 1.0.2a, since it's a backwards compatibility issue?

[8/20/93 public]

Since the difference between the quick fix and the overhaul is entirely
aesthetic, and since the rpcd will be overhauled for 1.1 anyway,  I propose
that I submit the quick fix to the mainline for 1.0.3, and leave the overhaul
as an enhancment.

(Everyone is building with the branch version anyway, right?)

[08/20/93 public]
We are seeing failures in dtsd (which uses rpc_is_server_listening )
due to this bug.  Did we ship 1.0.2 with this broken?  Boy I hope
not!  Anyway, please submit ASAP.  Thanks.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 7968
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : (rpc__cn_assoc_sm_protocol_error)
Reported Date                 : 5/10/93
Found in Baseline             : 1.02b23
Found Date                    : 5/10/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : cncassm.c
Sensitivity                   : public

[5/10/93 public]

While running our dramatic test we encountered thw following error message
and stack trace.

(rpc__cn_assoc_sm_protocol_error) Illegal state transition detected in CN client
 association state machine
(rpc__cn_assoc_sm_protocol_error) Current state: 3
(rpc__cn_assoc_sm_protocol_error) Current event: 8
(rpc__cn_assoc_sm_protocol_error) Assoc: 2102a288
(rpc) *** FATAL ERROR "(rpc__cn_assoc_sm_protocol_error)" at cnassoc.c\2791 ***
Dumping core after receiving signal SIGIOT

raise(0x0) at 0x2029093c
abort.abort(0x0) at 0x20011148
rpc__die(0x0, 0xdeadbeef, 0xdeadbeef) at 0x2004d204
rpc__cn_assoc_sm_protocol_error(0x0, 0xdeadbeef) at 0x200920bc
rpc__cn_sm_eval_event(0x0, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef) at 0x200943d8
receive_dispatch(0x0) at 0x20099c54
rpc__cn_network_receiver(0x0) at 0x2009906c
cma__thread_base(0x0) at 0x202666d8

Investiagtion of the problem revealed that actual problem here was that 
the presentation negotiation failed on the assoc with a status of 
rpc_s_cancel_timeout from a call to alter_context.  This 
happens around the sendmsg when we block and receive a cancel.  What happens
is that from there rpc_cn_call_local_cancel is called which will end up 
calling forward_alert which returns that value of the call_rep status as the
return value.  The cancel_timeout status is put in the call_rep by the timer
thread when it determines that the cancel timeout for this call has been 
exceeded and is hence an asynchronous event.  If the cancel timeout happens
before the thread can progress down to the forward alert call then when
that call is made the status returned will be rpc_s_cancel_timeout.
This percolates all the way back up as the return value from
alter_context which causes the presentation negotiation to fail and the 
receive_dispatch loop is exited without finishing the presentation negotiation
sequence.  The server however has possibly received his data and ultimately
sends back an alter_context_conf message which is received by the next call
that uses this association.   

The result of the alter_context_conf on an open but inactive association is
to cause a bugcheck which is not really the best thing to do since there is
no way to keep the previously described events from happening.  What I have
done is to modify the state machine so that the associotion is closed. 

Here is the change that I made to our product level code 

In cncassm.c at line 905 or there about 

#if defined(AIX_PROD) || defined(IBMOS2)    /* CMVC 5638 */
    /*
    * The packet is probably the result of a previous alter context
    * failing due to a cancel that didn't complete processing before
    * cancel timeout and so we can treat it as a local error instead of
    * simply killing the process.  Closing the association will cause the
    * server to exit his dangling sequence gracefully.
    */
    {
        rpc_c_sm_no_predicate,
        {
            {
                rpc_c_client_assoc_closed,
                rem_mark_abort
            },
            ILLEGAL_PREDICATE_RESULT,
            ILLEGAL_PREDICATE_RESULT
        }
    },
#else
    ILLEGAL_TRANSITION,
#endif

[9/13/93 public]
It is not necessary to close an OPEN association on receiving an alter_context
response. The SM can be modified to ignore the alter_context response
and stay in the same state.

[9/14/93 public]
Modifed the SM in cncassm.c to ignore the alter_context response
when an association is in OPEN state.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 7965
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : IDL won't build with OSF/1.1.1 lex
Reported Date                 : 5/10/93
Found in Baseline             : 1.0.2
Found Date                    : 5/10/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : none
Sensitivity                   : public

[5/10/93 public]
Currently, IDL doesn't build with the OSF/1.1.1 version of lex.  Our
workaround has been to include the source code for the OSF/1.0.4 version of
lex in the 'noship' directory of the DCE source tree and to build this lex
as part of the setup pass.  Now that 1.0.2core is out the door (no pun) we
should take the time to "port" idl to  the new lex.

Question: does the new idl resolve this problem?

[5/17/93 public]

After an evaluation of OSF/1 1.0.4 LEX and OSF/1 1.2 LEX (which is 
actually FLEX) it was determined that the DCE 1.0.3/1.1 projects
will continue to use the OSF/1 1.0.4 LEX. 

Although FLEX fixes a number of problems that IDL has with the existing
LEX, there are a number of problems using FLEX introduce. A few
issues are:

	1) The port will take two to three weeks and introduces a high degree
	   of risk.
	2) The new IDL parser will be vastly differenct from the 
	   other reference ports (it's not a matter of adding a few 
	   more #ifdefs) which will require support for two different
	   parser models.
	3) None of our major DCE licensees use FLEX.

[05/17/93 public]
I think this is a big mistake.  We should take the time, for 1.1, to
clean up any problems that show up in the IDL compiler lex input.  Outside
of generally making it more portable (a good thing), I find it embarassing
for us to say "build DCE on OSF/1 1.1, except for this one little exectuable"

I would like to see this re-opened, perhaps as a low-priority enhancement.

[5/17/93 public]

As part of the RPC code cleanup task... we will review IDL's use of LEX
internal state to make the code more portable to all LEX compilers.



CR Number                     : 7945
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : nsi
Short Description             : inconsistancy between nsi and dce_config
Reported Date                 : 5/6/93
Found in Baseline             : 1.0.1
Found Date                    : 5/6/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : ./rpc/runtime/ns.h
./rpc/runtime/ns_s_attr.c
./rpc/runtime/nsattr.c
./rpc/runtime/nsbndexp.c
./rpc/runtime/nsentry.c
./rpc/runtime/nsentry.h
./rpc/runtime/nsgroup.c
./rpc/runtime/nsinit.c
./rpc/runtime/nsmgmt.c
./rpc/runtime/nsp.c
./rpc/runtime/nsp.h
./rpc/runtime/nsprofile.c
./rpc/runtime/nsutil.c
Sensitivity                   : public

[5/6/93 public]

I got the following mail, which pointed out a bunch of issues.

Note specifically the comment about the difference in the way nsi creates
CDS objects vs. the way they're created in dce_config.

This may well be a dce_config bug, but I'd like someone more familiar with
NSI to look at it first.

					- Bill

To: dce-developers@ch.hp.com
Subject: When is a CDS entry a profile?
Organization: Hewlett-Packard, Networked Systems Architecture
Date: Wed, 05 May 93 08:23:22 -0700
From: John Dilley <jad@pimlico.nsa.hp.com>


Background:

	The NSI routines, when they create profiles (or groups), create
the CDS object with the CDS_Class attribute set to RPC_Entry, and the an
attribute RPC_Profile.  (The RPC_Profile attribute holds all the profile
elements, but when initially created is empty.)

	The DCE configuration scripts, however, seem to create profile
entries with the CDS_Class set to RPC_Profile and do not include an
attribute RPC_Profile.  When the NSI update this entry they will add
that attribute if needed.

	(The same argument applies to groups.)

Questions:

	What criteria should an application that browses/checks the CDS
use to determine if an entry is a profile?  Should it rely on the value
of the RPC_Entry attribute, or should it check the value of CDS_Class?

	Second, assume the application relies upon the presence of the
RPC_Profile (or RPC_Group or CDS_Towers) attribute, to be consistent
with the way NSI works (and therefore how client applications will see
the CDS).  How should the application treat an entry with more than one
of those attributes?  Which one should take precendence?  How does the
NSI treat these mutant entries when doing a search?

	Finally, if the CDS were to have these problems corrected, what
would the correction be in each of the cases?  Should HP fix the scripts
as delivered from OSF so that they are consistent with NSI behavior?  Or
should NSI behavior be changed?  Or should they remain inconsistent?

	Thank you for your advice and wisdom.  Regards,

                         --       jad       --

[08/25/93 public]
John, can you look at this and tell me if there is a problem here?

[04/05/94 public]
There has been mail exchanged on this:

----Howard Melman:
> Questions:
> 
>       What criteria should an application that browses/checks the CDS
> use to determine if an entry is a profile?  Should it rely on the value
> of the RPC_Entry attribute, or should it check the value of CDS_Class?

NSI objects in CDS are polymorphic.  A single CDS object can
be an RPC Entry, and RPC Group, and an RPC Profile.  The
only way to tell is to look and see what attributes are in
the object.

The CDS_Class attribute is a nice thing, but there are no
guarantees on it.  It is writable by something other than an
NSI call, so you don't want to depended on it.

>       Second, assume the application relies upon the presence of the
> RPC_Profile (or RPC_Group or CDS_Towers) attribute, to be consistent
> with the way NSI works (and therefore how client applications will see
> the CDS).  How should the application treat an entry with more than one
> of those attributes?  Which one should take precendence?  How does the
> NSI treat these mutant entries when doing a search?

Not sure: either report an error or treat the two together.
I.e., if you're doing a profile search, look in each
attribute for the highest priority element, then in each for
the next, etc.  Or whatever comparison is relevant to the
operation. 

>       Finally, if the CDS were to have these problems corrected, what
> would the correction be in each of the cases?  Should HP fix the scripts
> as delivered from OSF so that they are consistent with NSI behavior?  Or
> should NSI behavior be changed?  Or should they remain inconsistent?

Sounds like dce_config is broken.  Why is it setting these
attributes directly with cdscp and not using rpccp?


----Dick Mackey:
We should remove the ability to store multiple NSI entries (server,
group, profiile) in the same CDS entry.  We recommend against it but
don't enforce it.  The system is too complicated.

----Howard (in response to Dick):
You can't enforce this since CDS doesn't have a schema.
So how do you deal with this.

----Dick:
We simply change the API to only allow one attribute to be written to
an entry.  I don't know of anyone who does it and we recommend against
it.


John Dugas has agreed to look in to this.
At this point, it looks like it might be a dce_config error.

[7/19/94 public]
John and I talked about this.

First a pithy summary:
	When dce_config creates the profile entries in cds, it
	labels them with "CDS_Class RPC_Profile", groups with "RPC_Group",
	and entries with "RPC_Entry".

	When NSI creates entries, it labels them the a CDS_Class of
	RPC_Entry.  No matter what you are creating.

	Nothing and nobody seems to pay attention to these labels,
	because they are not correct or concise.

Now a solution:
	When calling rpc_ns_profile_elt_add() or rpc_ns_group_mbr_add()
	the NSI should slap the appropriate (RPC_Profile or RPC_Group)
	label on the entry, instead of using RPC_Entry for everything.

Code Details:
	rpc__nsentry_create() (in runtime/nsentry.c) should take an
	argument to determine what should be copied into class_attr_value.

	I believe that the following is incorrect and the #ifdef
	should be reversed (from rpc/runtime/nsp.h):

#ifndef DNSPI_V2

#define RPC_C_NS_DNA_TOWERS         ((unsigned_char_p_t) "1.3.22.1.3.30")
#define RPC_C_NS_CLASS_VERSION      ((unsigned_char_p_t) "1.3.22.1.1.1")
#define RPC_C_NS_OBJECT_UUIDS       ((unsigned_char_p_t) "1.3.22.1.1.2")
#define RPC_C_NS_GROUP              ((unsigned_char_p_t) "1.3.22.1.1.3")
#define RPC_C_NS_PROFILE            ((unsigned_char_p_t) "1.3.22.1.1.4")
#define RPC_C_NS_CODESETS           ((unsigned_char_p_t) "1.3.22.1.1.5")

#else

#define RPC_C_NS_DNA_TOWERS         ((unsigned_char_p_t) "DNA$Towers")
#define RPC_C_NS_CLASS_VERSION      ((unsigned_char_p_t) "RPC_ClassVersion")
#define RPC_C_NS_OBJECT_UUIDS       ((unsigned_char_p_t) "RPC_ObjectUuids")
#define RPC_C_NS_GROUP              ((unsigned_char_p_t) "RPC_Group")
#define RPC_C_NS_PROFILE            ((unsigned_char_p_t) "RPC_Profile")
#define RPC_C_NS_CODESETS           ((unsigned_char_p_t) "RPC_Codesets")

#endif

	Then rpc__nsentry_create() can take a string pointer which
	will indicate what class attribute to pass to dnsCreateObj().

[7/28/94 public]
Well, I was wrong about the NS attribute above, they are ISO
values and should remain as 6 numbers.

However, I have removed the DNSPI_V2 ifdef, and changed rpc__nsentry_create()
to take a pointer to the entry type.  I am testing now and plan to submit
soon.

[7/29/94 public]
Files submitted.



CR Number                     : 7944
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Illegal state transition in client call state machine
Reported Date                 : 5/6/93
Found in Baseline             : 1.0.2
Found Date                    : 5/6/93
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/runtime/cncall.c rpc/runtime/cncclsm.c
Sensitivity                   : public

[5/6/93 public]

(rpc__cn_call_sm_protocol_error) Illegal state transition detected in CN client 
call state machine
(rpc__cn_call_sm_protocol_error) Current state: 7
(rpc__cn_call_sm_protocol_error) Current event: 0
(rpc__cn_call_sm_protocol_error) Call rep: 20321678
(rpc) *** FATAL ERROR "(rpc__cn_call_sm_protocol_error)" at cnsclsm.c\2238 ***
Dumping core after receiving signal SIGIOT

and the stack trace from the core file is:
abort process in raise at 0xd097993c ($t217)
0xd097993c (raise+0x24) 80410014          l   r2,0x14(r1)
(/usr/local/bin/tdbx) t
raise(0x0) at 0xd00e693c
abort.abort(0x0) at 0xd01a1148
rpc__die(0x0, 0xdeadbeef, 0xdeadbeef) at 0xd074f1fc
rpc__cn_call_sm_protocol_error(0x0, 0xdeadbeef) at 0xd079d218
rpc__cn_sm_eval_event(0x0, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef) at 0xd0796468
rpc__cn_call_transmit(0x0, 0xdeadbeef, 0xdeadbeef) at 0xd0770b64
rpc_call_transmit(0x0, 0xdeadbeef, 0xdeadbeef) at 0xd076f50c
is_write(0x20142578, 0x20142208, 0x4, 0x20135018, 0x1001f07e, 0x2009b8e8, 0x0, 0
x2009b8f4) at 0x10012880
op_is_write(0x20142578, 0x20142208, 0x4, 0x20135018) at 0x1000fc7c
share_binding(0x20142208) at 0x1001cc20
cma__thread_base(0x0) at 0xd01f8750

(/usr/local/bin/tdbx) 0x20321678/50
20321678:  201ba688 20098af8 20344ec0 011c0003
20321688:  00000000 00000000 00000000 00000000
20321698:  20087af0 20321678 201fafe0 000d0004
203216a8:  00000000 2007a0f8 2007a420 2007b4d8
203216b8:  07000000 00000000 01010000 06000000 cur_state is 07,cur_event is 00
203216c8:  00000000 00000000 00000000 00000000 call_status is 00000000
203216d8:  20142578 20138328 203218d8 201bead8 assoc is 20138328 and 
protocol header is 203218d8 

203216e8:  00001000 00020000 00000000 00000000
203216f8:  00000000 00000100 203218f8 00000054 
20321708:  200877c0 00000000 00000000 00001000
20321718:  201bbb58 00000f00 00000000 00000000
20321728:  00000000 00001000 201beaf8 0000001a
20321738:  00000000 00000000

(/usr/local/bin/tdbx) 0x203218d8/20
203218d8:  00000000 00000000 00000100 00000000
203218e8:  203218f8 00000000 00000000 00000000
203218f8:  05000080 00000000 0ffa0012 00000689
20321908:  00000000 00010000 0042a9dc e3001be7
20321918:  870f0800 5a0d147e 4748494a 4b4c4d4e

data_p is 203218f8
(/usr/local/bin/tdbx) 0x203218f8/20
203218f8:  05000080 00000000 0ffa0012 00000689
20321908:  00000000 00010000 0042a9dc e3001be7
20321918:  870f0800 5a0d147e 4748494a 4b4c4d4e
20321928:  4f505152 43444546 4748494a 4b4c4d4e
20321938:  4f505152 53545556 5758595a 41424344

the call_rep for the client main thread has the request packet type in its
protocol header. The receiver thread got a fault packet from the server, so
it posted that event to the call state machine which changed the state of the
call to failed state. Now, the client main thread sent transmit_req (event 0)
to the call state machine. The state machine reported  Illegal transition on 
state 7 and event 0.

[5/6/93 public]
(/usr/local/bin/tdbx) 0x20138328/100
20138328:  20143548 2010fa48 2007a498 2007a780
20138338:  2007ac68 04090000 00000000 01010000 the state of assoc is 04 and 
event is 09
20138348:  02000000 203c3170 00000000 00000000
20138358:  00000000 00000000 00010001 00020000 its a client assoc and 
assoc_ref_count is 1, assoc_acb_ref_count is 2
20138368:  e3fe0002 00000000 200af5d  00ad0002
20138378:  00000000 00000000 00000000 00000000
20138388:  00000000 10001000 00000001 00000000
20138398:  00000000 201383fc 00000000 00000000
201383a8:  00000000 00000000 00000000 00000000
201383b8:  20321678 00020000 200af578 00ac0002 assoc has the call_rep:20321678
201383c8:  00000000 00000000 00000000 00000000
201383d8:  00000000 200af628 00070004 00000000
201383e8:  00000015 201427e8 00000000 203201b8
201383f8:  203201b8 2031b078 2031b078 00000000
20138408:  750cee26 0000001a 00000001 00000000
20138418:  20138b48 20138b48 00000000 00000000
20138428:  00000000 00000000 20137220 0000000c
20138438:  20138458 20138478 00000000 74696e2e
20138448:  69626d2e 636f6d6a 20137220 0000000c
20138458:  0002a970 00000004 20137228 00000008
20138468:  00000000 00000000 00000000 0000000c
20138478:  0002a970 00000004 20138498 00000001
20138488:  20138438 2be7e301 00000000 00000004
20138498:  c064e209 00000000 20137e90 000000a0
201384a8:  200b1ac8 009c0003 00000013 00000002

[5/19/93 public]

Here is an easy way to reproduce this bug by simulating an error in a server:

- Build the src/test/rpc/idl/pipetest client and server.

- Run the server from a debugger and put a break at rpc_call_receive.

- Start client.

- When the rpc_call_receive breakpoint hits, skip to the end of the
  function and set *status to a non-zero value.  Continue execution.

- The server stub will fault due to the non-zero status.

- The client will see the fault.

- The client will hit the state machine error on the next pipe transmit
  operation.

[5/24/93 public]

The problem is clearly visible in case of multiple calls to
rpc_call_transmit because "in_sendmsg" boolean is set to false after client
call thread has transmitted data and cn global lock is released. Now, the
receiver thread can run and on getting a fault packet sets the status of the
call to call_failed or call_failed,dne. The client call thread on sending a
transmit_request event through the client call state machine gets
ILLEGAL TRANSITION beacuse the state of the call is call_failed.

I modified the call_failed and call_failed,dne states for the events
transmit_req and last_transmit_req to not take any action(rpc_c_sm_no_action).
Then I modified rpc__cn_call_transmit to pick the fault packet queued by the
receiver thread and process it exactly as rpc__cn_call_transceive and
rpc__cn_call_receive.

cncclsm.c :

INTERNAL rpc_cn_sm_state_tbl_entry_t cfdne_state =
    {
#ifdef OT /* OT7944,CMVC5140 */
        { rpc_c_sm_no_predicate,            /* event 0 */
          { { rpc_c_client_call_cfdne,
              rpc_c_sm_no_action },
            ILLEGAL_PREDICATE_RESULT,
            ILLEGAL_PREDICATE_RESULT } },
#else
        ILLEGAL_TRANSITION,                 /* event 0 */
#endif
        ILLEGAL_TRANSITION,                 /* event 1 */
        ILLEGAL_TRANSITION,                 /* event 2 */
        ILLEGAL_TRANSITION,                 /* event 3 */
        { rpc_c_sm_no_predicate,            /* event 4 - local alert */
          { { rpc_c_client_call_cfdne,
              rpc_c_sm_no_action },
            ILLEGAL_PREDICATE_RESULT,
            ILLEGAL_PREDICATE_RESULT } },

        { rpc_c_sm_no_predicate,            /* event 5 - call_end */
          { { rpc_c_client_call_cfdne,
              rpc_c_sm_no_action },
            ILLEGAL_PREDICATE_RESULT,
            ILLEGAL_PREDICATE_RESULT } },
        ILLEGAL_TRANSITION,                 /* event 6 */
        ILLEGAL_TRANSITION,                 /* event 7 */
        ILLEGAL_TRANSITION,                 /* event 8 */
#ifdef OT /*OT7944,CMVC5140 */
        { rpc_c_sm_no_predicate,            /* event 9 */
          { { rpc_c_client_call_cfdne,
              rpc_c_sm_no_action },
            ILLEGAL_PREDICATE_RESULT,
            ILLEGAL_PREDICATE_RESULT } },
#else
        ILLEGAL_TRANSITION,                 /* event 9 */
#endif
        ILLEGAL_TRANSITION,                 /* event 10 */
        ILLEGAL_TRANSITION                  /* event 11 */
    };
    /* state 7 - call_failed */
INTERNAL rpc_cn_sm_state_tbl_entry_t call_failed_state =
    {
#ifdef OT /* OT7944,CMVC5140 */
        { rpc_c_sm_no_predicate,            /* event 0 - transmit_req*/
          { { rpc_c_client_call_call_failed,
              rpc_c_sm_no_action },
            ILLEGAL_PREDICATE_RESULT,
            ILLEGAL_PREDICATE_RESULT } },
#else
        ILLEGAL_TRANSITION,                 /* event 0 */
#endif
        ILLEGAL_TRANSITION,                 /* event 1 */
        ILLEGAL_TRANSITION,                 /* event 2 */
        ILLEGAL_TRANSITION,                 /* event 3 */
        { rpc_c_sm_no_predicate,            /* event 4 - local alert */
          { { rpc_c_client_call_call_failed,
              rpc_c_sm_no_action },
            ILLEGAL_PREDICATE_RESULT,
            ILLEGAL_PREDICATE_RESULT } },

        { rpc_c_sm_no_predicate,            /* event 5 - call_end */
          { { rpc_c_client_call_call_failed,
              rpc_c_sm_no_action },
            ILLEGAL_PREDICATE_RESULT,
            ILLEGAL_PREDICATE_RESULT } },
        ILLEGAL_TRANSITION,                 /* event 6 */
        ILLEGAL_TRANSITION,                 /* event 7 */
        ILLEGAL_TRANSITION,                 /* event 8 */
#ifdef OT /* OT7944,CMVC5140 */
        { rpc_c_sm_no_predicate,            /* event 9 */
          { { rpc_c_client_call_call_failed,
              rpc_c_sm_no_action },
            ILLEGAL_PREDICATE_RESULT,
            ILLEGAL_PREDICATE_RESULT } },
#else
        ILLEGAL_TRANSITION,                 /* event 9 */
#endif
        ILLEGAL_TRANSITION,                 /* event 10 */
        ILLEGAL_TRANSITION                  /* event 11 */
    };


cncall.c :

PRIVATE void rpc__cn_call_transmit (call_r, call_args, st)

rpc_call_rep_p_t        call_r;
rpc_iovector_p_t        call_args;
unsigned32              *st;
{
    rpc_cn_call_rep_t       *call_rep;
    rpc_iovector_elt_p_t    iov_elt_p;
    unsigned32              i;
    boolean                 valid_fragbuf;
    rpc_cn_fragbuf_p_t      frag_buf;
    rpc_cn_packet_p_t       header_p;
    unsigned32              fault_code;

    RPC_CN_DBG_RTN_PRINTF(rpc__cn_call_transmit);
    RPC_LOG_CN_CALL_TRANSMIT_NTR;
    CODING_ERROR (st);

    call_rep = (rpc_cn_call_rep_p_t) call_r;

    RPC_DBG_PRINTF (rpc_e_dbg_general, rpc_c_cn_dbg_general,
                    ("CN: call_rep->%x call transmit...\n",
                     call_rep));

    if (RPC_DBG (rpc_e_dbg_cn_pkt, rpc_c_cn_dbg_pkt))
    {
        RPC_DBG_PRINTF (rpc_e_dbg_cn_pkt, rpc_c_cn_dbg_pkt,
                        ("PACKET: call transmit args.num_elt->%d\n", call_args->
num_elt));
        for (i = 0; i < call_args->num_elt; i++)
        {
            RPC_DBG_PRINTF (rpc_e_dbg_cn_pkt, rpc_c_cn_dbg_pkt,
                            ("        elt[%d]: elt.flags->%x args.buff_len->%d a
rgs.data_len->%d\n",
                             i,
                             call_args->elt[i].flags,
                             call_args->elt[i].buff_len,
                             call_args->elt[i].data_len));
        }
    }
    /*
     * Acquire the CN global mutex to prevent other threads from
     * running.
     */
    RPC_CN_LOCK ();

    /*
     * The event call_send corresponds to transmit_req on
     * the client side and rpc_resp on the server side.
     *
     * If the call has been orphaned, return rpc_s_call_orphaned
     * and deallocate any input data.
     */
    if (call_rep->cn_call_status == rpc_s_call_orphaned)
    {
        RPC_DBG_PRINTF (rpc_e_dbg_general, rpc_c_cn_dbg_general,
                        ("CN: call_rep->%x call orphaned...\n",
                         call_rep));

        iov_elt_p = call_args->elt;
        for (i = 1; i <= call_args->num_elt; i++)
        {
#if defined (AIX_PROD) || defined (IBMOS2 ) /* CMVC 5186 */
                        /*
                         * It is not clear if it should be possible for buff_add
r to
                         * be NULL under all circumstances, but it happens at th
is
                         * time.  Hence , we are 'fixing' it here.
                         */
            if (iov_elt_p->buff_dealloc != NULL && iov_elt_p->buff_addr != NULL)
#else
            if (iov_elt_p->buff_dealloc != NULL)
#endif
            {
                (iov_elt_p->buff_dealloc) (iov_elt_p->buff_addr);
            }
        }
        *st = rpc_s_call_orphaned;
    }
    else
    {
        RPC_CN_CALL_EVAL_EVENT (rpc_c_call_send,
                                call_args,
                                call_rep,
                                *st);

#ifdef OT /* OT7944,CMVC5140 */
        if (((call_rep->call_state.cur_state == rpc_c_client_call_call_failed)
            || (call_rep->call_state.cur_state == rpc_c_client_call_cfdne))
            && ((call_rep->call_state.cur_event == rpc_c_call_send) ||
               (call_rep->call_state.cur_event == rpc_c_call_transmit_req) ||
               (call_rep->call_state.cur_event == rpc_c_call_last_transmit_req))
           )
        {
           valid_fragbuf = false;
           while (!valid_fragbuf)
           {
              rpc__cn_assoc_receive_frag(call_rep->assoc,
                                         &frag_buf,
                                         st);
              if (*st != rpc_s_ok)
              {
                 RPC_CN_UNLOCK ();
                 return;
              }
              if (frag_buf->data_p != NULL)
              {
                 valid_fragbuf = true;
              }
           }
           /*
            * Now adjust data_p to point to just the stub data.
            * Note that data_size has already been adjusted by
            * raise_fault_action_rtn
            */

            header_p = (rpc_cn_packet_p_t) RPC_CN_CREP_SEND_HDR (call_rep);
            if (RPC_CN_PKT_PTYPE(header_p) == rpc_c_cn_pkt_fault)
            {

               frag_buf->data_p = (pointer_t)
                                  (RPC_CN_PKT_FAULT_STUB_DATA(header_p));


            /* We had conservatively assumed that the call has executed
             * as soon as the call started. We can now update that
             * information.
             */

             if (RPC_CN_PKT_FLAGS (header_p) & rpc_c_cn_flags_did_not_execute)
             {
                call_rep->call_executed = false;
             }

             /*
              * This can be either a call_reject or a call_fault.
              */

              fault_code = RPC_CN_PKT_STATUS(header_p);

              RPC_DBG_PRINTF (rpc_e_dbg_general, rpc_c_cn_dbg_general,
                              ("CN: call_rep->%x fault packet received st=%x\n",
                                call_rep, fault_code));
              if (fault_code)
              {
                 /*
                  * Non-zero fault code implies a call_reject.
                  */

                 /*
                  * Deallocate the fragment buffer since we won't be returning
                  * it to the client stub.
                  */

                  (* frag_buf->fragbuf_dealloc) (frag_buf);

                  /*
                   * We translate the on-wire fault code into a local status
                   * and return it.
                   */


                   *st = rpc__cn_call_cvt_from_nca_st(fault_code);

                   /*
                    * Release the CN global mutex to allow other threads to run
                    */

                    RPC_CN_UNLOCK ();
                    return;
                 }
                 else
                 {
                    /*
                     * On a fault, we store the address of the fragment buffer
                     * in the call_rep for later retrieval via
                     * rpc__receive_fault.
                     */

                     call_rep->u.client.fault_data = frag_buf;
                     *st = rpc_s_call_faulted;

                     /*
                      * Release the CN global mutex to allow other threads to
                      * run.
                      */

                      RPC_CN_UNLOCK ();
                      return;
                  }
               }
            }
#endif
        /*
         * Check for any pending cancels just in case we're in a
         * long marshalling loop and not calling any cancellable
         * operations. Also, forward any cancels which may have been
         * queued already before we were ready to forward them.
         */
        if (RPC_CALL_IS_CLIENT (call_r))
        {

            RPC_CN_CHK_AND_FWD_CANCELS (call_rep, st);
        }
    }

    /*
     * Release the CN global mutex to allow other threads to
     * run.
     */
    RPC_CN_UNLOCK ();
    RPC_LOG_CN_CALL_TRANSMIT_XIT;
}

[08/17/93 public]
Prasad, We have been running dramatic testcase with the proposed fix for a
long time and we have not seen this problem again. I plan to submit this
fix soon.  Thanks Sandhya Kapoor

[08/17/93 public]
This fix should be tested on the OSF source base before submitting.

[8/18/93 public]
Verified this fix on the OSF source base (HP and 486).

[Sandhya Kapoor public]
Prasad, could you please update the backing tree with the changes.
Thanks, Sandhya

[9/14/93 public]
Modified the files (cncall.c and cncclsm.c ) with the proposed fix.
This fix has been applied to IBM's product level code and
also, verified on HP and 486 reference platforms.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 7817
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : krpc
Short Description             : TLB miss in sec_id_pac_util_free()
Reported Date                 : 4/28/93
Found in Baseline             : 1.0.2a
Found Date                    : 4/28/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.2a
Fixed In Baseline             : 1.0.2a
Affected File(s)              : src/rpc/kruntime/pac_util_krpc.c
Sensitivity                   : public

[4/28/93 public]
Gail encountered a kernel TLB miss with the following stack:

sec_id_pac_util_free
rpc__krb_dg_who_are_you
rpc__dg_sct_way_validate
rpc__dg_execute_cell
cthread_call_executor
base_routine

After mucking through the assembly, I believe this is occurring 
because the passed in PAC has a non-null numgroups field, with 
a null groups pointer.

It looks to me like this problem has already been fixed in the user 
space version of this code in

src/security/utils/sec_id_pac_util.c.

The obvious solution is to port this fix to the kernel space 
version in

src/rpc/kruntime/pac_util_krpc.c

Bill S. or Mark K., if you agree this is the correct fix, I'm 
volunteering to implement it.  However, I am curious why we aren't 
using the same source module for both user and kernel to avoid these 
kinds of problems in the first place.

[4/28/93 public]
I implemented the fix and Gail tried it out.  The kernel didn't panic,
but the user space version of this routine caused a core dump in
dfsbind (OT7938).  Since the kernel fix should probably be the same
as the fix for 7938 in user space, which is assigned to Sommerfeld,
I'm assigning this one to him as well.

[5/12/93 public]
The user space problem noted above is presumed to be fixed in CR7938
This fix is submitted since it is still required to fix the original
problem.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 7799
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : app_ref
Short Description             : rpc_mgmt_set_com_timeout needs some further description
Reported Date                 : 4/24/93
Found in Baseline             : 1.0.1b23
Found Date                    : 4/24/93
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.0.3
Affected File(s)              : 1
Sensitivity                   : public

[4/24/93 public]

I have been doing some experimentation with RPC timeout values.  I have been
setting the timeout value of the rpc_mgmt_set_com_timeout() routine, in a
client application, and then charting the time (in secs) that an RPC takes
to timeout, in the absense of a server.  I have done this for both DG and CN.

The client is a very simple application.  It creates a binding handle with
an endpoint (ie no cdsd/rpcd necessary).  The protseq, ip addr, and endpoint
are passed in on the command line.  A TRY/CATCH is put around the call, and
a timer is set up to count (in secs) how long the call takes to return.

I ran the client, setting the com timeout of the rpc_mgmt_set_com_timeout()
routine to all values, 0-10.  Here is the data I got, when I subsequently
attempted to make an RPC to a server that did not exist:

DATAGRAM
--------

timeout value       timeout (in secs)
      0                    5
      1                    5
      2                    9
      3                   13
      4                   20
      5                   35
      6                   65 (1m 5s)
      7                  125 (2m 5s)
      8                  245 (4m 5s)
      9                  485 (8m 5s)
     10                  doesn't timeout

CONNECTION-ORIENTED
-------------------

timeout value       timeout (in secs)
      0                   75
      1                   75
      2                   75
      3                   75
      4                   75
      5                   75
      6                   75
      7                   75
      8                   75
      9                   75
     10                  doesn't timeout

So it looks like the timeout value doesn't matter for connection-oriented
RPC, unless you choose 10 (attempt to connect forever).

Other notes of interest for CN RPC, where the client attempts to connect
to a server that isn't there:

* If the ip address in the binding handle is on the local net, and the host
  DOES exist, the RPC will always return immediately with the exception
  rpc_x_connect_rejected, no matter what the timeout value of
  rpc_mgmt_set_com_timeout() is set to.

* If the ip address is on the local net, but the host DOES NOT exist,
  the RPC will always return immediately with the exception
  rpc_x_connection_closed, no matter what the timeout value of
  rpc_mgmt_set_com_timeout() is set to.

* If the ip address is not on the local net, and the host DOES NOT exist,
  the RPC will always timeout after 75 seconds, no matter what the timeout
  value of rpc_mgmt_set_com_timeout() is set to, unless the value is set
  to 10 (attempt to connect forever).

Is this the designed behaviour?  I have seen nothing documented to indicate
that this is/isn't what I should expect to see.

[4/26/93 public]

Under what conditions did you see the results in the table above?   Are these 
the results from running the tests in the setup described under the third '*',
or from some other setup?

Yes, the results in the table above are from running the tests in the setup
described under the third '*'.  

The 75 second timeout only happened when you sent the RPC off into
"no mans land".

[4/28/93 public]

This is the expected behavior for CN RPC.  These values were originally
set up for DG since it does retransmissions, etc.  Also, note that the
man pages were pretty vague about how these values are interpreted.

CN RPC looks at the timeout value you enter as a binary value.  If you've
selected infinite timeout, then we'll try forever.  Otherwise, we will
try once and rely upon the underlying transport to perform any retries.
However, even in those cases where the user advises us to retry forever,
we won't if we get a "hard" error.

In terms of relative timings, 
CN RPC will timeout faster in those cases where the transport
can detect the situation faster.  (e.g., machine is up, but the server
is not.)

[4/28/93 public]

The manpage partially describes this situation:

	Depending on the protocol sequence for the specified binding
	handle, the <timeout> value acts only as advice to the RPC runtime.
	
I'll change this OT to a DOC enhancement; it should provide a bit more
detail as per Wei's comments above.

[06/03/93 public]
Assigned this CR to myself.

[06/17/93 public]
Fixed and verified by Dave Weisman.
Added a paragraph to the DESCRIPTION section of 
rpc_mgmt_set_com_timeout() describing the way that 
connection-oriented RPC handles time-out values.

[6/22/93 public]
Changed "Fix By Baseline" from 1.0.3 to 1.1.

[08/19/93 public]
Closed bug.



CR Number                     : 7798
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : large fragbuf not returned to lookaside list
Reported Date                 : 4/23/93
Found in Baseline             : 1.0.2b23
Found Date                    : 4/23/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : 1.0.3 idl
Sensitivity                   : public

[4/23/93 public]

This defect was detected by one of our support customers while they were
writing a simple rpc client/server application. In this application,
the client performs a rpc to the server passing as an argument an [out] pipe,
the server reads an arbitrary file, and returns the contents of the file
through the pipe to the client.

void
get_data(
	[out] foo_pipe_t *data
);

The client performs the rpc (get_data) 100 times, after which it was
determined (by instrumenting the code) that 100 cn_lg_fragbufs, each of
size 4134 bytes, were allocated, never freed, and never returned to the
appropriate lookaside list (e.g. lost). 

It appears that the last fragbuf that is allocated is not freed between
the receipt of the end of data and the startup of the next call to
get_data().

This behavior was demonstrated by the customer on their port of dce1.0.1,
and at OSF on dce1.0.2b23 RIOS/AIX, and also on a port of dce1.0.2b23 to
Ultrix. 

There is a test program available which makes it easy to reproduce this.

[08/23/93 public]
Could you provide me with the test program which reproduces this please?

[08/23/93 public]
Thanks to Ron, who provided me with the program to reproduce this.

The good news is, I believe the new idl fixed this problem, since
I saw absolutely no growth in the client (or server) of this program
after 3000 passes.

The numbers on OSF/1 (at386):
Start:
  PID TTY      STAT        TIME       SL PAGEIN   VSZ  RSS %CPU %MEM COMMAND
  673 pts/2    R  +     7:24.91        0      4 7.72M 1.46 28.2  4.0 ./server
  721 pts/4    S  +     0:11.97        0      3 7.23M 1.37 28.7  3.8 ./client -

End:
  PID TTY      STAT        TIME       SL PAGEIN   VSZ  RSS %CPU %MEM COMMAND
  673 pts/2    R  +    10:53.77        0      4 7.72M 1.46 35.1  4.0 ./server
  721 pts/4    R  +     9:16.60        0      3 7.23M 1.05 35.5  2.9 ./client -

I'm going to give it a shot on the HP, but unless I'm not running
this correctly, I will close this bug as fixedin 1.0.3 (by the new idl).

[08/23/93 public]
Ran the test program for 5000 iteration on a 1.0.3 HP system,
and it remained (via top) steady as a rock.

Closing this bug as fixed in 1.0.3 by the new idl.



CR Number                     : 7774
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpccp
Short Description             : help messages wrong in rpccp
Reported Date                 : 4/21/93
Found in Baseline             : 1.0.2
Found Date                    : 4/21/93
Severity                      : E
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpccp.c
Sensitivity                   : public

[4/21/93 public]
The help messages for the add/remove/show mapping commands are wrong.
Below is some email between Doug Weir and Mark Karuzis describing this:

   1. The Usage message for the subcommand reads as follows:
    
           rpccp> help add mapping
        
           usage: rpccp add mapping [<options>] <entry name>
        
           options:     a    <string>  annotation field
            	    b    <string>  string binding
    		    i    <if id>   interface identifier
    		    o    <uuid>    object identifier
    		    N              no replace
    
    
       --and I'm trying to figure out what the <entry name> argument is
       sup-posed to be. The "remove mapping" and "show mapping" have a
       "host-address" argument which allows you to access remote endpoint
       maps as well as the local one, but it appears that "add mapping"
       only accesses the local host. Is the usage message in error? Or does
       <entry name> mean something else?
    
I'm just going from the code here, but you're right that "add mapping" does
not allow the user to modify the endpoint map on remote machine.  The help
line is just a cobbled together default string, and say the wrong thing for
all of the endpoint-related commands.  It should not say <entry name> for
the "add mapping" command, and should say <host address> for the
show/remove commnads.

    2. For the other two subcommands, one -i option and at least one -b
       option are required. Is this true also of "add mapping"?

Yes.

    -- Mark Karuzis
       Open Systems Software Division
       Hewlett-Packard Company
       markar@apollo.hp.com

[09/01/93 public]
Changed to mapping commands to show (or not show) the host-address
option.  Also noted which options are required for each command.

For remove mapping, the usage will show the host-address option only
if REMOTE_ENDPOINT_ACCESS is defined.  See OT # 8451 for details
on this ifdef.

Closed.



CR Number                     : 7769
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpc runtime
Short Description             : rpc__dg_call_transmit_int() leaks memory
Reported Date                 : 4/21/93
Found in Baseline             : 1.0.1
Found Date                    : 4/21/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.2a
Fixed In Baseline             : 1.0.2a
Affected File(s)              : dg.c
Sensitivity                   : public
Transarc Deltas               : 
Transarc Herder               : 
Transarc Status               : open

[4/21/93 public]
Here is the information from our bug database which describes this problem
and provides a fix that has been tested.
name          5578
abstract      rpc__dg_call_transmit_int leaks memory
notes:
    <Note by carlb (Rodney Carlton Burnett), 93/04/19 07:17:32, action: open>
While running the connectathon tests continuously against DFS the
kernel is slowly leaking memory.  If the test is allowed to run
long enough, it will run the machine out of page space.  This
can be produced by running connectathon in a loop on a one
machine cell.
The DFS memory allocation statistics indicate the the memory is
not leaking in DFS but somewhere else, perhaps the kernel RPC.
    <Note by carlb (Rodney Carlton Burnett), 93/04/19 07:18:29, action: note>
Usaully the machine will run out of space within 24 hours depending on
the amount of available page space.
    <Note by carlb (Rodney Carlton Burnett), 93/04/21 09:48:39, action: assign>
The memory leak is due to a bug in rpc__dg_call_transmit_int (dg.c) in
the RPC runtime.  This occurs under the following scenario:
    if the space left in the packet exactly matches the amount of data
    left in the iovecs data buffer and it is the last iovec element,
    then end_of_data is set and the rpc__dg_call_transmit_int() exits.
    The bug is that when setting end_of_data in this case, a check needs
    to made to see if the iovec element has a dealloc function.  If so,
    the dealloc function should be called to free the iovec elements data
    buffer.  Without this check to data buffer which was allocated by
    the IDL stubs will never be freed, producing the leak.
    This is simalar the code path in the else condition of the above
    case where there is more space in the packet than data left in
    the iovec element.  The problem with the above case is the equals
    condition.  The fix is to check for a dealloc function and call it
    if it exists.  Below is the corrected code segment in
    rpc__dg_call_transmit_int():
.
.
.
            while (true) {
                unsigned32 data_left = iove->data_len - data_used;
                if (room_left <= data_left) {
.
.
.
.
                    /*
                     * If we copied the full data buffer, and it's the last one,
                     * set end of data flag.
                     */
#ifdef OT /* CMVC 5578 */
			if (data_used == iove->data_len && 
			(elt_num + 1 == data->num_elt)) {
			end_of_data = true;
			if (iove->buff_dealloc != NULL)
			    (*iove->buff_dealloc)(iove->buff_addr);
		    }
#else /* OT */
                    if (data_used == iove->data_len && (elt_num + 1 == data->num_elt))
                        end_of_data = true;
#endif /* OT */
                    break;
                }
                else {
.
.
.
This bug is common to both user and kernel RPC !!!
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `' 
Added field Transarc Status with value `open'

[4/21/93 public]
This looks like the right fix (although we should also clobber the iove pointers).
I'll submit the fix ASAP.

[4/21/93 public]
I spoke with Mark K. and we agreed the RPC_FREE_IOVE_BUFFER() should
be used to free the buffer.  This macro clobbers the pointers, and NULLs
the dealloc fcn pointer.  I made this change and tested that it works.
Here is the final version of the code segment I tested with:
#ifdef OT signals the changes.
.
.
.
            while (true) {
                unsigned32 data_left = iove->data_len - data_used;
                if (room_left <= data_left) {
                    memcpy(((char *)xqe->body)+xqe->body_len, &iove->data_addr[data_used], 
                          room_left);
                    data_used += room_left;
                    xqe->body_len = body_size;
                    room_left = 0;                      
                    /*
                     * If we copied the full data buffer, and it's the last one,
                     * set end of data flag.
                     */
#ifdef OT /* CMVC 5578, OT 7796 */
		    if (data_used == iove->data_len && 
			(elt_num + 1 == data->num_elt)) {
			end_of_data = true;
			if (iove->buff_dealloc != NULL)
			    RPC_FREE_IOVE_BUFFER(iove);
		    }
#else /* OT */
                    if (data_used == iove->data_len && (elt_num + 1 == data->num_elt))
                        end_of_data = true;
#endif /* OT */
                    break;
                }
                else {
                    memcpy(((char *)xqe->body)+xqe->body_len, &iove->data_addr[data_used], 
                          data_left);
                    room_left -= data_left;
                    xqe->body_len += data_left;
                    if (iove->buff_dealloc != NULL)
#ifdef OT /* CMVC 5578, OT 7796 */
			RPC_FREE_IOVE_BUFFER(iove);
#else /* OT */
                        (*iove->buff_dealloc)(iove->buff_addr);
#endif /* OT */
                    
                    /*
                     * We copied the full data buffer;  if it's the last one,
                     * set end of data flag.
                     */
.
.
.

[4/22/93 public]
Since this was found with DFS testing, I thought I would let the
OSF DFS crowd know about it.
Changed Interest List CC from `kazar@transarc.com,jaffe@transarc.com' to 
 `kazar@transarc.com,jaffe@transarc.com,delgado'

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 7764
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : doc
Short Description             : rpc_s_not_rpc_entry not documented
Reported Date                 : 4/20/93
Found in Baseline             : 1.0.2
Found Date                    : 4/20/93
Severity                      : D
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : app_ref/man7rpc/rpc_status_codes.7rpc
Sensitivity                   : public

[4/20/93 public]
The status code "rpc_s_not_rpc_entry" is not documented in the Appl Dev Ref.
The error message translated from this code is seen under a number of
circumstances.  For instance:

agony pts/0> rpccp show entry /.:/mine

>>> rpc runtime error: not RPC entry (dce / rpc)

agony pts/0> acl_edit /.:/mine
ERROR: not RPC entry (dce / rpc)
Unable to bind to object /.:/mine

There are comments in the rpc.msg file suggesting that this is (was?) an 
internal code, but it sure doesn't look that way now.

[8/13/93 public]

Changed responsible engineer to Hal because this is a doc bug.

[08/17/93 public]
Reassigned this CR to writer Steve Lewontin.

[10/07/93]
Reassigned the CR to writer Lisa Zahn.

[10/13/93 public]

Fixed. Will ask T. Jordahl to verify.

[10/13/93 public]

Fixed and verified by T. Jordahl. Closed
this bug.



CR Number                     : 7755
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : is_on_free_list gets stepped on
Reported Date                 : 4/19/93
Found in Baseline             : 1.0.2b23
Found Date                    : 4/15/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/runtime/dgpkt.h
                                             rpc/runtime/dgpkt.c
Sensitivity                   : public

[4/19/93 public]

The workaround for 7465 has problems if rpc_c_ip_udp_max_loc_unfrg_tpdu is
as large as the sizeof(rpc_dg_raw_pkt_t).  The problem being that the 
compiler has no idea that pkt->u.rqe.rqe.pkt may not be the equal to
pkt->u.rqe.rqe.pkt_real and hence it assumes pkt->is_on_free_list exactly
sizeof(rpc_dg_raw_pkt_t) bytes after pkt->u.pkt.  Thus, addresses generated
by the compiler will be inside of the actual raw packet buffer that is
being used by the transport layer if the pkt_real was not aligned on
an eight byte boundary.  The end result of this is horrendous
memory leaks in dg servers and clients.  It is immeadiately noticable in
pipe operations such as in the DFS flserver and ftserver.

This problem will not be noticable in the reference port code because the
transport layer never returns as many bytes from a recvfrom operation as
will fit in a raw packet.  However, we are opening this OT in hopes that
it will at least be commented upon.  What we plan to do is to change the
type of is_on_free_list to int and add a two word integer array after the
rqe element in the pkt_pool_elt definition.  This should give us the needed
padding that is added in the malloc call in pkt_alloc.

[4/20/93 public]

I'll fix this for 1.0.3.  Again, it only affects those who modify the constant
rpc_c_ip_udp_max_loc_unfrg_tpdu.

[9/21/93 public]

is_on_free_list will be removed. The dgpkt pool double-free problem has
been fixed in the CR 8073 submittion.

[9/28/93 public]

The fix was submitted to 1.0.3 along with the new debug code for the
double-free checking (RPC_DEBUG=20.20).

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 7750
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : admin_ref
Short Description             : unepxort synopsis missing -u
Reported Date                 : 4/19/93
Found in Baseline             : 1.0.2
Found Date                    : 4/19/93
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : 1
Sensitivity                   : public

[4/19/93 public]
The -u option is descibed in the Options section but not listed in the
synopsis section of the unexport(8rpc) man page.

[5/27/93 public]
Assigned to myself.

[5/38/92 public]
Changed to "verified".  Added [-u] to SYNOPSIS.

[08/17/93 public]
Closed bug.



CR Number                     : 7736
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : SIGSEGV in rpc__cn_assoc_push_call
Reported Date                 : 4/16/93
Found in Baseline             : 1.0.2b21
Found Date                    : 4/1/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : cnsassm.c
Sensitivity                   : public

[4/16/93 public]

Here is the stack trace for this problem
rpc__cn_assoc_push_call(0x20819498, 0x0) at 0xd06f9d6c
receive_dispatch(0x20819498) at 0xd0702218
rpc__cn_network_receiver(0x20819498) at 0xd0701cb8
cma__thread_base(0x20819498) at 0xd0181724

This problem is referenced in OT7618 and we have continued to work on this
other half of 7618 here.  The problem is that the timer thread will abort
an association and cause the group id to be cleared when the receiver thread
releases the lock.  There are two places this "window" can occur.  The first
is at the recvmsg in receive_packet and the second is at the bottom of the
receive_dispatch loop.  What happens is that there aren't cancel points
after the lock has been released but the timer thread has posted a cancel
to the receiver thread.  I suppose that the idea was that the recvmsg would
serve as a cancel point but it doesn't because if the lock is not held 
after returning from recvmsg, then there is a window right there and it must
be eliminated after reacquiring the lock.

The pathology of the second window is not really known to me because we only 
call push_call on the request packet of a call and I didn't think we could
stay in receive_dispatch across calls.  So if receive_dispatch is exited
I would think that any cancel gotten at the bottom of the loop would have
been detected in the pthread_testcancel in cn_receiver.  However, after 
closing the first window we still had the core dump in push_call and so I
added an aditional pthread_testcancel just prior to the receive_packet in
receive_dispatch.  Here are the two pieces which I inserted in cnrcvr.c

In receive_dispatc just prior to receive_packet I have

        /*
         * Close the window in which the timer thread may have run and
         * cancelled us  when we released the lock at the bottom of the loop.
         */
        TRY
            pthread_testcancel();
        CATCH (pthread_cancel_e)
            /*
             * If we still have a fragbufs, then deallocate them.
            */
            if (fragbuf_p)
            {
                (*fragbuf_p->fragbuf_dealloc)(fragbuf_p);
            }
            if (ovf_fragbuf_p)
            {
                (*ovf_fragbuf_p->fragbuf_dealloc)(ovf_fragbuf_p);
            }
            RERAISE;
        ENDTRY
        /*
         * Receive a packet from the network.
         */
        receive_packet (assoc, &fragbuf_p, &ovf_fragbuf_p, &st);

        if (st != rpc_s_ok)


In receive_packet just after reacquiring the lock after the recmsvg I have

        /*
         * Re-acquire the CN global mutex.
         */
        RPC_CN_LOCK ();
        /*
         * Close the window in which the timer thread may have run and
         * cancelled this thread.
         */

        TRY
        pthread_testcancel();
        CATCH ( pthread_cancel_e)
            /*
            * free any fragment  buffers we have outstanding.
            */
            if (fbp)
            {
                (*(fbp)->fragbuf_dealloc)(fbp);
            }
            RERAISE;
        ENDTRY

If anyone can determine why closing the second window ( ie in receive_dispatch)
please let me know.  For now we are installing these patches in our product
and will await resolution of this OT.



After talking with wei hu about this problem we have changed what we were 
doing to 'close the window'.  The window is actually closed by the check
on assoc_status that occurs below this but there is a problem in the 
abort_assoc_action_rtn in both the client and server association state 
machines.  Both of these routines call close_connect and pass the assoc_status
variable for return status, hence the association_aborted status that is set
by the mark_assoc_action_rtn is wiped out and so receive packet never
notices it.  We have modified both of the abort_assoc_action_rtn's to use
a local status in the call to close_connect.  This adresses the problem in
a direct and correct way and so we have implemented it in our product.

By the way, with respect to the second 'window', it was caused by a problem
that was introduced by a local change to our threads code.  Since the threads
fix was installed, we haven't seen any problems when this second TRY/CATCH
pair was removed.  So to reiterate, using the local status in the two
abort_assoc_action_rtns COMPLETELY solves this problem.

[5/4/93 public]

Can you please post the diff's showing the changes I asked you to make
to the code so that others can make the same changes? 
Thanks.

[5/4/93 public]

Here are the changes which I made -- Not diffed with b23 but from the 
product code so the ifdef makes it clear enough

In cncassm.c at line 2400 or thereabout ( in abort_assoc_action_rtn )

#ifdef OT /* OT7736 - CMVC 4654 */
    unsigned32 status;
#endif
 
and at line 2441 or therabout (in abort_assoc_action_rtn )

    /*
     * Close the connection on the association.
     */
#ifdef OT /* OT7736 - CMVC 4654 */
    rpc__cn_network_close_connect (assoc,&status);
#else

    rpc__cn_network_close_connect (assoc,
                                   &(assoc->assoc_status));
    RPC_CN_ASSOC_CHECK_ST (assoc, &(assoc->assoc_status));
#endif

In cnsassm.c starting at line 2382 or thereabout ( in abort_assoc_action_rtn )
do the exact same thing as above.

I believe that this is what wei hu suggested that I do.  If this is not 
correct, please let me know because it appears to be working OK.

[7/16/93 public]

The change that IBM has implemented is correct and is the one
suggested by Wei Hu.  We have also seen the identical problem here at
DEC and are wondering whether there are plans to close and submit these
changes soon.

[8/2/93 public]

1.in cncassm.c:

	There is no way abort_assoc_action_rtn() can overwrite the status
	that is set by mark_assoc_action_rtn(), because abort_assoc_action_rtn()
	is always invoked first and then mark_assoc_action_rtn().
	[see  mark_abort_action_rtn()/rem_mark_abort_action_rtn()].

	And also, mark_abort_action_rtn()/rem_mark_abort_action_rtn() 
	checks for the return status from abort_assoc_action_rtn() 
	in assoc->assoc_status.

	so I feel no changes are necessary in this file.

2. in cnsassm.c:

	The problem can be in cnsassm.c; 
	In this case mark_assoc_action_rtn() is invoked first and then,
	abort_assoc_action_rtn().  And also, the return status from any of 
	these functions is not verified by the caller.
	So in this case, the status set by mark_assoc_action_rtn() can be 
	overwrriten by abort_assoc_action_rtn().
	[see rem_mark_abort_action_rtn()/mark_abort_action_rtn()/
	rem_mark_abort_can_action_rtn()]

	The solution might be 
	1) modify the abort_assoc_action_rtn() as proposed by wei hu - 
	but this will not be consistent with the remaining code, 
	in regards with how the status is returned.

	Note: the return status from abort_assoc_action_rtn() 
        is not verified by the caller.

	
		(OR)

	2) to reverse the invocation order, ie.
	abort_assoc_action_rtn() first and mark_abort_action_rtn()
	next rather than to modify the abort_assoc_action_rtn() .
	But at the moment, I don't know the nature of the side effects if any.

	Any comments!

[9/21/93 public]
The status in assoc structure (set in mark_assoc_action_rtn())
is being overwritten in abort_assoc_action_rtn().
This is eliminated thru the changing the order of invocation
of functions mark_assoc_action_rtn() and abort_assoc_action_rtn() 
in rem_mark_abort_action_rtn(), mark_abort_action_rtn()
and rem_mark_abort_can_action_rtn functions.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 7725
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : test/rpc/idl
Short Description             : makefiles need updating
Reported Date                 : 4/15/93
Found in Baseline             : 1.0.2
Found Date                    : 4/15/93
Severity                      : D
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : test/rpc/idl/maketest.mk
Sensitivity                   : public
DEC does not own responsibility for the test suite. Please reassign this
to someone at OSF.

[4/15/93 public]
Makefiles in the RPC idl FVT test subdirectories: context, cover1, no_op,
pipefault, pipes, pipetest, and threads need updating to include the file
RUN_ARGS in the install variable ILIST. These tests appear to fail when
executed after a test installation because the RUN_ARGS file contains
the necessary runtime environment definitions. These do execute sucessfully
from the object tree.

[08/20/93 public]
Easy fix:
60c70
< ILIST         = ${PROGRAMS}
---
> ILIST         = ${PROGRAMS} ${DATAFILES}

Closed.



CR Number                     : 7713
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : uuidgen
Short Description             : uuidgen should allow for more conversions.
Reported Date                 : 4/13/93
Found in Baseline             : 1.0.2
Found Date                    : 4/13/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : rpc/idl/uuidgen/uuidgen.c
					     rpc/idl/uuidgen/uid.sams
Sensitivity                   : public

[4/13/93 public]

uuidgen should have an option to convert an existing uuid into an alternate
output format -- it would be useful to have something like the -t option
(which converts an "old format uuid" into a "new format uuid") only for the
"-s" output option (which outputs a C structure initialization).

This could be used, for instance, to make it easy to fix the code in CDS
which stores uuid's in the source code as character strings and does a
"uuid_from_string" at startup time.

[07/20/93 public]
Not going to happen in the near (or far) future.
OSF isn't too concerned with supporting "old" format uuids

Canceled.

[7/26/93 public]
This has *nothing* to do with old-format uuid's

I'll do this in my spare time..

[6/27/94 public]

Now that we've established that Bill has no spare time :-)

How about if we cancel this one again.

[6/27/94 public]
dcecp might already do this, but I'll check.  If not, this is a good
enhancement request.  Particularly:

 * convert old style uuids to new.
 * output in C structure format (run uuidgen -s to see)

[6/28/94 public]
Added -c option, which, in combination with -s or -i, outputs the uuid in
the chosen format.

[8/12/94 public]
I had changed to dcecp enhancement.  Bill fixed uuidgen.  Back to rpc...



CR Number                     : 7694
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : SIGSEGV rpc__cn_assoc_send_fragbuf
Reported Date                 : 4/13/93
Found in Baseline             : 1.0.2b21
Found Date                    : 4/5/93
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/runtime/cnsassm.c
Sensitivity                   : public

[4/13/93 public]

segmentation violation in ptrgl.$PTRGL [/usr/lib/libdce.a] at 0xd074cf50 ($t3)
0xd074cf50 ($PTRGL)    800b0000          l   r0,0x0(r11)
(/usr/local/bin/tdbx) t
ptrgl.$PTRGL() at 0xd074cf50
rpc__cn_assoc_send_fragbuf(0x0, 0xe, 0xdeadbeef, 0x16c9a036) at 0xd07916ec
reject_assoc_action_rtn(0x0, 0xe) at 0xd07977e8
rpc__cn_sm_eval_event(0x0, 0xe, 0xdeadbeef, 0x16c9a036) at 0xd0794100
rpc__cn_assoc_reclaim(0x0, 0xe) at 0xd0792e98
rpc__cn_assoc_timer_reclaim(0x0) at 0xd0792d34
rpc__timer_callout() at 0xd074ca48
timer_loop() at 0xd074c440
cma__thread_base(0x0) at 0xd0183724

rpc__cn_sm_eval_event calls reject_assoc_action_rtn with event_parm set to 
NULL. reject_assoc_action_rtn executes the following code :

    /*
     * The event parameter is a pointer to the fragbuf containing
     * the rpc_bind_nack PDU.
     */
    fragbuf = (rpc_cn_fragbuf_t *) event_param;


and calls rpc__cn_assoc_send_fragbuf(). When rpc__cn_assoc_send_fragbuf tries 
to deference fragbuf to get dealloc function, we get a core dump. 

The problem is related to passing in a NULL event_parm. I talked to Wei Hu. 
The fix is to either use the fragbuf in the assoc structure or allocate one.

[4/13/93 public]

Please try the following patch and let me know how it works.  The superficial
symptom is that somehow the BIND exchange got stuck for such a long time
that the timer thread tried to reclaim the association.  Without more data,
I can't tell why this is happening.

In the meantime, please apply this change below and tell me how the behavior
changes.  Note: I've not tried this out yet.

What I've done is to change the server association state machine to ignore
shutdown events until the negotiation has completed.

The following shows the context diff against the current 1.0.2 source:

$> diff -c cnsassm.c /project/dce/build/dce1.0.2/src/rpc/runtime
*** cnsassm.c   Tue Apr 13 13:25:33 1993
--- /project/dce/build/dce1.0.2/src/rpc/runtime/cnsassm.c       Fri Mar  5 14:23
***************
*** 606,619 ****
          rpc_c_sm_no_predicate,
          {
              {
!               /*
!                * Temporary fix.  Do not send a shutdown
!                * in this case.  We are going to remain in
!                * this state and wait for the server to
!                * complete the negotiation.
!                */
!               rpc_c_server_assoc_requested,
!               rpc_c_sm_no_action
              },
              ILLEGAL_PREDICATE_RESULT,
              ILLEGAL_PREDICATE_RESULT
--- 606,613 ----
          rpc_c_sm_no_predicate,
          {
              {
!                 rpc_c_server_assoc_closed,
!                 reject_assoc
              },
              ILLEGAL_PREDICATE_RESULT,
              ILLEGAL_PREDICATE_RESULT

[4/14/93 public]

The above fix is assuming that client association state machines will not
run into any kind of problem and close the association if a call does
not complete. I think the fix should take care of the fact that timer thread
must reclaim an asociation if assoc_request has not succeeded for a long
time.

[4/14/93 public]

Here, is the assoc data structure

(/tmp/dbx) 0x20149698/50
20149698:  20148dd8 20149868 2007a6b0 2007a910
201496a8:  2007a918 010b0000 00000000 01010000
201496b8:  0d000000 2058ab08 00000000 00000000
201496c8:  16c9a036 00000000 000a0000 00020000
201496d8:  dc550002 00000000 20a88630 094e0002
201496e8:  00000000 00000000 00000000 00000000
201496f8:  00000000 10001000 00000000 00000000
20149708:  00000000 00000000 00000000 00000000
20149718:  00000000 00000000 00000000 00000000
20149728:  00000000 00020000 209fde00 094d0002
20149738:  00000000 00000000 00000000 00000000
20149748:  00000000 2089f510 02ec0004 201365c8
20149758:  00000024 00000000
(/tmp/dbx)

I would suggest that in the server association state machine table, when
the current state is requested state and the event is shutdown_req then
we should set the next state to rpc_c_server_assoc_closed,
and the action to send_shutdown_req. Please let me know what you think.
Thanks   Sandhya Kapoor

[08/17/93 public]
Prasad, I made the change that Wei Hu had suggested and we have not come 
across this problem. One reason that the server did not send a bind ack/nak 
in a timely manner is the high level of stress that dramatic testcase's 
clients put on their servers. Let me know what you think. 
Thanks Sandhya Kapoor

[8/18/93 public]
Implemented Wei-hu's suggested fix. No action is necessary 
for a shut_down event in the assoc_requested state for server assoc SM.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 7682
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rpc_ns_binding_import/lookup_next always return binding with first object UUID.
Reported Date                 : 4/9/93
Found in Baseline             : 1.0.2b20
Found Date                    : 4/9/93
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc_ns_binding_import_next.3rpc, rpc_ns_binding_lookup_next.3rpc
Sensitivity                   : public

[4/9/93 public]
According to the DCE manuals (e.g. rpc_ns_binding_import_next(3rpc)) if the
obj_uuid argument of the rpc_ns_binding_import_begin() or
rpc_ns_binding_lookup_begin() operation contains a nil object uuid and, if
the server exported multiple object uuids, rpc_ns_binding_import_next() or
rpc_ns_binding_lookup_next() selects the returned object uuid in a
nondeterministic way. Yet, under these circumstances
rpc_ns_binding_import_next() only seems to return a binding with the first
object uuid of the server entry.

The following piece of code demonstrates the behavior:

===== foo_server.c =====
int main(...)
{

  ...

  uuid_t *object_uuids;
  struct {
    unsigned32 count;
    uuid_t *uuid[100];
  } l_object_uuid_vector;

  ...

  /*  Create the requested number of object uuids and gather them in vector */
  object_uuids = (uuid_t *) malloc(number_of_objects * sizeof(uuid_t));
  for (i = 0; i < number_of_objects; i++) {
    uuid_create(&object_uuids[i], &status);
    l_object_uuid_vector.uuid[i] = &object_uuids[i];
  }
  l_object_uuid_vector.count = i;

  ...

  /* Export bindings to name service */
  rpc_ns_binding_export(rpc_c_ns_syntax_default, cds_pathname, 
			fooif_v1_0_s_ifspec, binding_vector, 
			(uuid_vector_t *) &l_object_uuid_vector,
			&status);

  ...

}

===== foo_client.c =====
int main(int argc, char *argv[])
{
  error_status_t status;
  handle_t binding_h;
  rpc_ns_handle_t import_context;
  unsigned_char_p_t cds_pathname;
  unsigned_char_t *string_binding;

  cds_pathname = (unsigned_char_p_t) argv[1];
  rpc_ns_binding_import_begin(rpc_c_ns_syntax_default, cds_pathname,
			      fooif_v1_0_c_ifspec, NULL, &import_context,
			      &status);
  rpc_ns_binding_import_next(import_context, &binding_h, &status);
  rpc_binding_to_string_binding(binding_h, &string_binding, &status);
  printf("%s\n", string_binding);

  ...

}

The foo_server is run requesting (for example) that 10 object uuids
be created and entered in the server entry. A check with rpccp shows:

rpccp> show server /.:/subsys/foo_server

objects:

  0040f7c2-ab37-1bc5-9248-02608c2f8b6f
  0040fa74-ab37-1bc5-9248-02608c2f8b6f
  0040fc22-ab37-1bc5-9248-02608c2f8b6f
  0040fdbc-ab37-1bc5-9248-02608c2f8b6f
  0040ff60-ab37-1bc5-9248-02608c2f8b6f
  00410104-ab37-1bc5-9248-02608c2f8b6f
  0041753a-ab37-1bc5-9248-02608c2f8b6f
  004176f2-ab37-1bc5-9248-02608c2f8b6f
  00417896-ab37-1bc5-9248-02608c2f8b6f
  00417a30-ab37-1bc5-9248-02608c2f8b6f

binding information:

  <interface id>   0001aacc-7e87-1bc4-9f9d-02608c2f8b6f,1.0
  <string binding> ncadg_ip_udp:130.105.1.135[]
  <string binding> ncacn_ip_tcp:130.105.1.135[]

Yet, a 1000 invocations of the foo_client always returned a binding with
object 0040f7c2-ab37-1bc5-9248-02608c2f8b6f.

[4/12/93 public]

This is intended behavior.  (It was a topic of much discussion when
we were doing it.)  We don't want applications to depend upon
the order in which the object UUID is returned in this case.  However,
we also did not want to do the work to explicitly randomize it.
Hence, we just return the first one.

[4/12/93 public]

If this is intended behavior then I am changing this to a documentation
change request since rpc_ns_binding_import_next(3rpc) and 
rpc_ns_binding_lookup_next(3rpc) state:

	If the server exported multiple object UUIDs, the returned
	binding handle contains one of the object UUIDs. The import-next
	operation selects the returned object UUID in a nondeterministic
	way. So, a different object UUID can be returned for each 
	compatible binding handle from a single server entry.

(as a solution, everything from "The import-next" onward could be omitted
for example).

[5/7/93 public]

Since the above example is not entirely clear and the documentation is not
either, I was wondering about a couple of things.

1) Is intended behavior for the ns_binding_import_next() call supposed to 
   be: a) return the same obj_uuid for a specified binding, or b) is it
   supposed to allow you to loop through using the import_next call and
   return ALL obj_uuids of corresponding if_id and string_binding (one at
   a time of course).

2) If part (b) then, I would like to know how OSF is planning to correct
   the documentation for the two calls since we will have to update ours
   as well, and would like them to remain equivalent.

[07/06/93 public]
Reassigned to writer Steve Lewontin.

[10/12/93 public]

I've added text to both manpages saying:

1) That application should not make any assumptions about the object UUID
returned. 

2) Clarifying, in answer to the above questions, that while a series of
calls is guaranteed to return you all the exported towers, it returns each
tower only once from an entry.  It does not return the cross product of 
towers with object UUIDs.  Hence, you are not intended to get all the
object UUIDs and should not make any assumptions about what object UUIDs you
will get.

[11/11/93 public]

Verified changes in latest doc build and closed this CR.



CR Number                     : 7681
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : runtime CN client
Short Description             : CN RPC (client) runtime ignores Cancels.
Reported Date                 : 4/9/93
Found in Baseline             : 1.0.2
Found Date                    : 4/9/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/runtime/cncall.c
Sensitivity                   : public

[4/9/93 public]
        We found this problem on RIOS with RPC Validation software, when
        RPC runtime is behaving as CN client.

        CN client, after having sent a single fragment request PDU on behalf
        of the application, is in a transition from STUB_WAIT state to
        RESPONSE state. During this transition period it ignores any Cancel
        from the application.

        If the Cancel arrives when the CN client is in RESPONSE state,
        it sends a remote_alert PDU as expected.

[9/1/93 public]
Need to check for the pending cancels after a SENDMSG
in rpc__cn_call_transceive(). At present it just forwards
any queued cancels. Modified to check for pending cancels and then forward.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 7680
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : remove #ifdef _KERNEL from krbdgsrv.c
Reported Date                 : 4/9/93
Found in Baseline             : 1.0.2
Found Date                    : 4/9/93
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/runtime/krbdgsrv.c
Sensitivity                   : public

[4/9/93 public]

During the 1.0.2 endgame, some #ifdef _KERNEL changes were made to
krbdgsrv.c to reduce stack utilization; these changes should also just be
used as-is in user space (and have been tested in user space, but not
enough for OSF's criteria at this point).

this should *not* be fixed in time for 1.0.2 :-)

[9/30/93 public]

fixed in 1.0.3

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 7677
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : pipes
Short Description             : pipe description should be clearer
Reported Date                 : 4/8/93
Found in Baseline             : 1.0.2
Found Date                    : 4/8/93
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : 9_idl.gpsml
Sensitivity                   : public

[4/8/93 public]

All documentation on IDL pipes should make it clear that they exist to
allow for *application*-level optimization of bulk data transfer by
allowing the overlap of communication and processing; the actual data
communications occur at about the same speed as arrays; they only make a
difference for latency (how soon the application sees each "chunk" of data)
and (minimum) memory utilization, not throughput (at least directly;
reducing memory utilization can improve throughput by reducing VM paging).

The intent is that the pipe routines should actually *process* the data and
then get rid of it (i.e., summarize it; write it to a file; put it into a
`struct buf' and immediately wake up another thread to chew on it...),
rather than merely stuff it into an array.

[4/8/93 public]

note above revised slightly.

Comment from mail sent to dce-tech by vic voydock which cites the confusing
section of the document:

===============================================================================
Dick:

Then the DCE documentation should be clarified.  Pipes are defined in the
DCE Application Development Guide, section 17.14.4.  The last paragraph
before 17.14.4.1 states:

... The IDL implementation of pipes in the RPC stub and runtime allows the
apparent callbacks to occur without requiring actual remote callbacks. As
a result, pipes provide an efficient transfer mechanism for large amounts
of data.

Neither here, nor anywhere else that I can find in the DCE documentation,
does it state that pipes are only useful if the data is in "chunks" that
are not all in memory at the same time.

Also, as far as I remember, the various OSF presentations/tutorials did not
make this clear either.

Vic

-------

[07/06/93 public]
Assigned this CR to writer Steve Lewontin.

[10/12/93 public]

Added text to this effect to two places in the pipes section.  I'll go into
this in the 1.1 policy guide too.

[11/11/93 public]

Verified the changes in the latest doc build and
closed this CR.



CR Number                     : 7654
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : for loop in rpc__timer_clear doesn't set prev
Reported Date                 : 4/5/93
Found in Baseline             : 1.0.2
Found Date                    : 4/5/93
Severity                      : D
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : runtime/rpctimer.c
Sensitivity                   : public

[4/5/93 public]
The for loop in rpc__timer_clear neglects to set the prev pointer, even though 
it uses it to decide if it's looking at the first entry in the running list.
If there was ever more than one monitor in the running list and the second one
was supposed to be cleared, the first one would get removed from the list 
instead.  Fortunately, there doesn't currently seem to be a way for there to
be more than one monitor in the running list, but it's a bug anyway.

[08/03/93 public]
Easy fix, thanks Dave:

417c418
<     for (list_ptr = running_list; list_ptr; list_ptr = list_ptr->next)
---
>     for (list_ptr = running_list; list_ptr; prev = list_ptr, list_ptr = list_ptr->next)



CR Number                     : 7634
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : NULL assoc in assoc_receive_frag
Reported Date                 : 4/1/93
Found in Baseline             : 1.0.2b19
Found Date                    : 3/28/93
Severity                      : A
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : cnassoc.c
Sensitivity                   : public

[4/1/93 public]

Here is the stack trace that we are getting.  This happens when we have a
reasonably high stress level for several hours.  It is repeatable but takes
several hours to happen.

rpc__cn_assoc_receive_frag(0x304dfffc, 0x39c00088, 0x20385ac4) at 0xd07910ac
rpc__cn_call_receive(0x304dfffc, 0x39c00088, 0x20385ac4) at 0xd076ef44
rpc__cn_call_executor(0x304dfffc, 0x39c00088) at 0xd0799e68
cthread_call_executor(0x304dfffc) at 0xd0789220
cma__thread_base(0x304dfffc) at 0xd0181724

Here are the registers

  $r0: 0xd076ef48  $stkp: 0x20385788   $toc: 0x2008ccb8    $r3: 0x304dfffc  
  $r4: 0x39c00088    $r5: 0x20385ac4    $r6: 0x00000000    $r7: 0x304dfffc  
  $r8: 0x16c9a05e    $r9: 0x2009ad10   $r10: 0x00000080   $r11: 0x00000000  
 $r12: 0xd076eea8   $r13: 0x0000000b   $r14: 0x2ff7fb8c   $r15: 0x2ff7fbbc  
 $r16: 0xdeadbeef   $r17: 0xdeadbeef   $r18: 0x2009ac00   $r19: 0xdeadbeef  
 $r20: 0xdeadbeef   $r21: 0x2014d74c   $r22: 0x2054ff94   $r23: 0xd08f09c0  
 $r24: 0x00000000   $r25: 0x2014d748   $r26: 0x00000000   $r27: 0x00000000  
 $r28: 0x20385ac4   $r29: 0x20097b78   $r30: 0x20385a28   $r31: 0x20385ae0  
 $iar: 0xd07910ac   $msr: 0x0000d0b0    $cr: 0x48002044  $link: 0xd076ef48  
 $ctr: 0xd018bf08   $xer: 0x00000000    $mq: 0x00000000   $tid: 0x00000000  

The register 27 is the assoc that was passed in from the call rep in
call_receive. The call rep is as follows

2054ff78:  00000000 20097cb8 218c3250 1b8b0003
2054ff88:  00000000 ae69626d ce630000 2f647261
2054ff98:  20086c14 2054ff78 2031df20 001e0004
2054ffa8:  63360000 2007ab50 2007aca8 2007acc8
2054ffb8:  02010000 00000000 00000000 07000000
2054ffc8:  00000000 00000000 00000000 00000000
2054ffd8:  205441d8 00000000 2054dab8 206af4f8
2054ffe8:  00001000 00020000 00000000 00000000
2054fff8:  00000000 00000100 2054dad8 00000038
20550008:  00000000 00259558 00000000 10037e7a
20550018:  20259930 00000100 00000000 00000000
20550028:  00000000 00000000 2054b3e8 00000009

The status is at 5c offset from the start of this list which shows ok status
but it shows a NULL association.  One wonders how this call got started
with a NULL assoc.  This has to be the place where the first packet is 
being received in rpc__cn_call_executor because it is the only place that
call_receive is called in the routine.

[ wrs 4/7/93 public ]

Here is another of the bad call reps from the above core dump.  This one
occurred during product level testing with NO CANCELS in the client.      

2068d428:  208b7288 20136524 21979bb8 1edb0003
2068d438:  00000000 80000020 c0680000 00000030
2068d448:  20086c34 2068d428 20319fc0 001c0004
2068d458:  00000000 2007ab58 2007acb0 2007acd0
2068d468:  0201d790 00000000 0000009a 0702608c
2068d478:  00000000 00020000 001e9b38 00000000
2068d488:  208b9d08 00000000 2068cad8 00000000
2068d498:  00001000 00010010 00000000 200658f0
2068d4a8:  00000000 00000100 2068caf8 00000018
2068d4b8:  00000000 20098dd0 00000000 00696e2e

[ wrs 4/9/93 public ]

	I believe that I have found the source of the problem.  There are
two assocs pointing to the same call_rep.  The assoc that is causing the
trouble is in rpc__cn_assoc_acb_dealloc and is currently being deallocated.
The assoc being deallocated is a client assoc with assoc_status of 
connection closed.  The call_rep pointed to by this assoc has a different
assoc ( the other assoc in this picture ) in its call_rep->assoc field.
The call_rep and the other assoc represent a server call that is currently
in progress.  The way in which this can happen is that the client call 
starts up and hits a cancel point ( on a sendmsg )
in assoc_open while negotiating the 
transfer syntax.  The client call stub catches the cancel and transfers
control to the catch clause which calls call_end.  From there pop_call is
called, but at this time the assoc in the call rep is NULL and hence the
call_rep in the assoc is not NULLed but the call_rep is freed back to the
lookaside list.  Hence it can be picked up by the next server call that 
comes along.  This is apparently what is happening.  Finally, after the 
call_end is complete on the aborted call, the receiver thread for this assoc
notices that the connection is closed and exits receive_dispatch to the
FINALLY clause, closes the socket and deallocates the acb which is where the
assoc in the call_rep which no longer belongs to this receiver thread is
NULLed.  Because this can happen asynchronously to the other receiever and
executor threads, it produces a multitude of different core dumps.

	What I am testing as a solution is simply to verify in acb_dealloc
	if assoc->call_rep->assoc == assoc before doing   
	assoc->call_rep->assoc = NULL.  This seems to work, in that I have
put in a printf to verify that I am avoiding the erroneous NULLing of the 
assoc in the call_rep.  We will be testing this fix all morning here and
should be able to report success or otherwis before the end of the day so
that this can go in the 1.0.2 tree.

[4/12/93 public]

Assuming successful testing, William Sullivan will be submitting his fix to
the unintegrated tree for dce1.0.2.  This will also be mentioned in the
release notes.

[4/13/93 public ]
Here is what I did in acb_dealloc at line 4206 in our product version 
of cnassoc.c
~
        /*
         * Free the call rep on the assoc.
         */
        if (assoc->call_rep != NULL)
        {
#ifdef OT /* OT7634 - CMVC 5223 */
            /*
             * If this assoc is pointing to a call_rep that doesn't point
             * back to it then this assoc is probably a client assoc that
             * failed the presentation negotiation sequence and the call
             * rep already went back to the heap.  Hence this call_rep is
             * probably paired with another association at this time and
             * so it would be wrong to release the assoc from it.
             */
            if ( assoc->call_rep->assoc == assoc )
#endif
                assoc->call_rep->assoc = NULL;
            assoc->call_rep = NULL;
        }

[08/17/93 public]
Put in the suggested fix above.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 7627
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : rpccp
Short Description             : rpccp errors should go to stderr
Reported Date                 : 3/31/93
Found in Baseline             : 1.0.2b19
Found Date                    : 3/31/93
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpccp.c dce_config
Sensitivity                   : public

[3/31/93 public]

The rpccp command outputs errors to stdout.  Is there a reason that the
informational text and error text both go to stdout?  This causes problems
when using rpccp in shell scripts.

[08/20/93 public]
Changed most errors (but not help/usage and 'no match found' messages)
to print to stderr.

Fixed up dce_config to redirect stderr to temp files when looking
for errors.

Closed.



CR Number                     : 7617
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_ref
Short Description             : rpc_server_register_auth_info
(3rpc) gives incomplete data structure for rpc_auth_key_retrival_fn_t.
Reported Date                 : 3/31/93
Found in Baseline             : 1.0.1
Found Date                    : 3/31/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc_server_register_auth_info.3rpc
Sensitivity                   : public

[3/31/93 public]

[is still true in the current 1.0.2doc tree]

        The DCE 1.0.1 Prog. Ref. describes incorrect prototype for the
        rpc_auth_key_retrival_fn_t in the man pages for the interface
        rpc_server_register_auth_info(). Looking at the code tree based
        on Sept. 4, 92, I get the following:

typedef void (*rpc_auth_key_retrieval_fn_t)
(
    [in]        void                    *arg,
    [in]        unsigned_char_p_t       server_princ_name,
    [in]        unsigned32              key_type,
    [in]        unsigned32              key_ver,
    [out]       void                    **key,
    [out]       unsigned32              *st
);

as defined in rpcbase.idl file. The document is missing key_type argument.

[4/5/93 public]
This bug belongs to HP

[7/2/93 public]
Fixed and verified.  Reviewed by Bill Sommerfeld.

[06/08/93 public]
Changed "Fix By Baseline" field from 1.0.2 to 1.0.3.

[08/17/93 public]
Closed bug.



CR Number                     : 7587
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 8126
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : admin_ref
Short Description             : no man page for add mapping
Reported Date                 : 3/24/93
Found in Baseline             : 1.0.2b23
Found Date                    : 3/24/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.2a
Affected File(s)              : rpccp add mapping, rpccp
Sensitivity                   : public

[3/24/93 public]
There is no man page for the rpccp add mapping command, nor is it mentioned
in the rpccp.8rpc man page.  It's in the code.  This is from running rpccp:

    rpccp> help add mapping
    
    usage: rpccp add mapping [<options>] <entry name>
    
    options:     a    <string>  annotation field
		 b    <string>  string binding
		 i    <if id>   interface identifier
		 o    <uuid>    object identifier
		 N              no replace

If this doesn't make it into 1.0.2, then it should be mentioned in the
release notes, or wherever we mention known defects.

[5/24/93 public]

rpccp add mapping

Purpose

Adds to or replaces server address information in the local endpoint map.

Synopsis

rpccp add mapping

-i if-id -b string-binding [-b ... ] [ -o object-uuid  [-o ...]] 
   [ -a annotation ] [ -N ]

Options

-i  Declares an interface identifier (required). Only one interface can be 
added in a single operation. If more than one interface is specified, only 
the last identifier is used. The interface identifier has the following form:

interface-uuid,major-version.minor-version

The UUID is a hexadecimal string and the version numbers are decimal strings, 
for example:

-i EC1EEB60-5943-11C9-A309-08002B102989,1.1

Leading zeros in version numbers are ignored. Version numbers are optional, 
but if you omit a version number, the value 0 (zero) is used.

-b  Declares a string binding (required). You must also specify an interface 
identifier (using the -i option). Each command accepts up to 32 -b options.

The value has the form of an RPC string binding, without an object UUID. The 
binding information contains an RPC protocol sequence, a network address, and 
an endpoint as in the following example:


-b ncadg_ip_udp:63.0.2.17[5347]

Note that depending on your system, string binding delimiters such 
te that depending on your system, string binding delimiters such
as [ ] (brackets) may need to be preceded by an \ (escape symbol) or
placed within quotation marks (` ' or " "). Requirements vary from
system to system, and you must conform to the usage rules of a system.

The protocol sequence specified in each binding must be a protocol sequence
that the RPC daemon is listening on (and, implicitly, be a protocol sequence
supported by the RPC runtime on the local host).

-o  Defines an object UUID that further determines the endpoint map elements
that are added (optional). Each add mapping command accepts up to 32 -o options.

The UUID is a hexadecimal string, for example:

-o 3C6B8F60-5945-11C9-A236-08002B102989

-a  Defines an annotation string applied to each cross#product element added
to the local endpoint map. The string can contain up to 63 characters, plus
a null terminating character.

Note that the shell supports quotation marks around the annotation field of
profile elements, which allows you to include internal spaces in an annotation;
the control program does not. To specify or refer to annotations from within
the control program, limit each annotation to an unbroken alphanumeric string;
for example, CalendarGroup. To refer to annotations from the system prompt,
do not incorporate quotation marks into any annotation.

-N  Specifies not to replace a specified interface if the existing version
is greater than or equal to the interface to be added. Use this option when
multiple instances of a server run on the same host. If this option is not
used, and the mapping to be added has an identical (optional) object UUID,
identical interface UUID, identical major version number, and minor version
number equal to or greater than an existing endpoint map element, the
existing element is replaced. If the minor version number is less than the
matched existing element, the provided information is ignored and the
existing element remains unchanged.

Description

The add mapping command adds elements to, or replaces elements in, the local
endpoint map. Each map element corresponds to an interface identifier, binding
information, object UUID (optional), and annotation (optional). The interface
identifier consists of an interface UUID and an optional major and minor
version specifier. The binding information contains an RPC protocol
sequence, a network address, and an endpoint within brackets
(rpc-prot-seq:network-addr[endpoint]).

This command creates a cross#product from the if-id, string-binding,
and object-uuid arguments, and adds each element in the cross#product
as a separate registration in the local endpoint map. This command
requires one interface identifier (the -i option); at least one string
binding (the -b option); and, optionally, one or more object UUIDs
(the -o option). Each instance of the command accepts from 1 to 32 -b
options and from 0 to 32 -o options. If you supply NULL for object-uuid,
the corresponding elements in the cross#product contain a nil oject UUID.

See the rpccp command for more information on rpccp add mapping.

Example

The following command operates from the system prompt to add a map element
to the local endpoint map. The command adds the map element that contains the
specified interface identifier, server address (specified as a string binding),
and object UUIDs.


$ rpccp add mapping \
-i EC1EEB60-5943-11C9-A309-08002B102989,1.1 \
-b ncadg_ip_udp:63.0.2.17[5347] \
-o 005077D8-8022-1ACB-9375-10005A4F533A \
-o 001BC29A-8041-1ACB-B377-10005A4F533A \
-a 'Calendar version 1.1'
$

The previous command adds the following elements:

<object>            005077D8-8022-1ACB-9375-10005A4F533A
<interface ID>    EC1EEB60-5943-1169-A309-08002B102989,1.1
<string binding>  ncadg_ip_udp:63.0.2.17[5347]
<annotation>     Calendar version 1.1

<object>            001BC29A-8041-1ACB-B377-10005A4F533A
<interface ID>    EC1EEB60-5943-1169-A309-08002B102989,1.1
<string binding>  ncadg_ip_udp:63.0.2.17[5347]
<annotation>     Calendar version 1.1

Suggested Reading

Related Information

Commands: rpccp export
, rpccp remove mapping
, rpccp show mapping
, rpccp show server
.

Subroutines: rpc_ep_register
, rpc_ep_register_no_replace
.

[5/27/93 public]
Assigned to writer Larry Kaplan.

[6/25/93 public]
CR 8126 had suggested as did this CR that an add mapping page be added.
I had already added the add mapping page to the admin_ref.

However, this CR suggested further enhancements, so I added these to both
the add mapping reference page and the rpccp reference page.

[08/17/93 public]
Closed bug.



CR Number                     : 7564
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_ref
Short Description             : filling on in RELATED INFO section
Reported Date                 : 3/23/93
Found in Baseline             : 1.0.2
Found Date                    : 3/23/93
Severity                      : E
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.2
Fixed In Baseline             : 1.0.3
Affected File(s)              : 2
Sensitivity                   : public

[3/23/93 public]
I understand that filling is supposed to off in the RELATED INFORMATION
section of reference pages.  This is a good thing since filling often makes
these very difficult to read.  rpc_ns_mgmt_handle_set_exp_age.3rpc has
filling on this section as do almost all ref pages in 3rpc, and 3thr as
well.

[5/27/93 public]
Assigned to myself.

[5/28/93 public]
Changed to "verified".  This bug was apparently filed against the
1.0 printed doc, in which filling WAS a problem.  Fill mode seems to
have been routinely turned off during the last Prentice-Hall editorial
review (fall 1992) for all 3rpc and 3thr ref pages.  I found
two ref pages that still had this problem -- pthread_create.3thr and
rpc_sm_allocate.3rpc -- and fixed them.

[08/17/93 public]
Closed bug.



CR Number                     : 7561
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : admin_ref
Short Description             : -u in rpccp commands described badly
Reported Date                 : 3/22/93
Found in Baseline             : 1.0.2
Found Date                    : 3/22/93
Severity                      : E
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : 6
Sensitivity                   : public

[3/22/93 public]
The -u option of several rpccp commands (show server, show profile, show
entry, unexport; note that this is not an exhaustive list!) has problems
with the last sentence:

    1. It is different across the different man pages
    2. In some cases the word `of' I think should be `if' in order for the
       sentence to make sense, although even that doesn't help a lot.
    3. In some cases the word `option' is incorrectly in bold.

The unexport version seems to be the best.  

In general it "sounds like" rpccp is doing caching.  If so, please use the
word caching instead of `local copy'.

[5/27/93 public]
Assigned to myself.

[06/08/93 public]
Changed to "verified".  Rewrote the entire -u option description with
help from Dave Weisman.  The description is now standard for the six
relevant man8rpc reference pages, and refers to the CDS local cache
instead of simply the "local copy".  I updated the following files
in the man8rpc directory of the Admin Ref:

	rpccp_import.8rpc
	rpccp_show_entry.8rpc
	rpccp_show_group.8rpc
	rpccp_show_profile.8rpc
	rpccp_show_server.8rpc
	rpccp_unexport.8rpc

[06/08/93 public]
Changed "Fix By Baseline" field from 1.0.2 to 1.0.3.

[08/17/93 public]
Closed bug.



CR Number                     : 7551
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : krbp.h
Short Description             : krbp.h should not contain machine-specific ifdefs
Reported Date                 : 3/19/93
Found in Baseline             : 1.0.1
Found Date                    : 3/19/93
Severity                      : E
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/runtime/krbp.h
					     rpc/kruntime/RIOS/sysconf.h
Sensitivity                   : public

[3/19/93 public]

Some old mail which never got dealt with..

Date: Tue, 30 Jun 92 18:41:52 -0400
From: sommerfeld@apollo.hp.com
To: demail1!jwade
Subject: why is this in krbp.h?
Cc: mishkin@ch.hp.com

The changelog says you added this:

#if defined(_AIX) && defined(_KERNEL)
#include <sys/domain.h>
#include <sys/protosw.h>
#endif

I'd like to see this file free of machine-specific #ifdefs.  Is there
any particular reason why you aded this here?

Is there any reason why it couldn't be put in the sysconf.h for AIX?

					- Bill


From: mishkin@ch.hp.com (Nathaniel Mishkin)
Date: Wed, 1 Jul 92 09:03:20 EDT
Subject: Re: why is this in krbp.h? 
To: demail1!rebel.austin.ibm.com!jwade
Cc: sommerfeld@apollo.hp.com
In-Reply-To: demail1!rebel.austin.ibm.com!jwade, tue, 30 jun 92 19:18:36

    
    I guess I did not dig far enough to see that commonp.h includes sysconf.h.
    
    I can fix this if we can convince Dave W. that it is Priority 1.
    
I guess when I raised this issue a few conf calls ago, I was under the
mistaken impression that there was some subtle include file ordering
problem that precluded putting the #include's in sysconf.h (or I was
just too stupid to realize the right way to do it).

As you probably recall from the conf call, I really would like to not have
this sort of #ifdef in the non-platform-specific code--once the door is
open,
people feel free to follow.  I'd like to close the door.  So would you open
a defect and, if necessary, I'll push on Dave as well.

Thanks.

        -- Nat

From: jwade%demail1.UUCP@rebel.austin.ibm.com
To: @demail1.austin.ibm.com:apollo!mishkin (Nathaniel Mishkin)
Cc: @demail1:apollo!sommerfeld
Subject: Re: why is this in krbp.h? 
In-Reply-To: (Your message of Wed, 01 Jul 92 09:03:20 EDT.)
             <9207011248.AA17396@xuucp.ch.apollo.hp.com> 
Date: Wed, 01 Jul 92 09:02:41 -0600

....

I did not try to put them into sysconf.h.  I will try this morning and if
it works I will drop the changes this afternoon before I leave for
vacation.

Jim

[9/30/93 public]

Fixed in 1.0.3.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 7550
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : sys_idl
Short Description             : mgmt inquiry interfaces should be idempotent
Reported Date                 : 3/19/93
Found in Baseline             : 1.0.2
Found Date                    : 3/19/93
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : src/rpc/sys_idl/mgmt.idl
Sensitivity                   : public

[3/19/93 public]
The mgmt inquiry interfaces (rpc__mgmt_inq_if_ids, rpc__mgmt_inq_stats,
rpc__mgmt_is_server_listening, rpc__mgmt_inq_princ_name) should be
declared idempotent in src/rpc/sys_idl/mgmt.idl.  mgmt.idl seems to be one of
the few idl files in src/rpc/sys_idl that doesn't use idempotent queries.
Mark Karuzis thought this was probably just an oversight.

I got interested in this from the standpoint of being able to predict
the number of packets caused by successive rpc_mgmt_inq_stats calls
(delayed acks complicate things), but it also struck me that a
nonidempotent call requires more of a server's resources than an
idempotent one, in the usual case.  Management inquiries should be as
low-overhead as possible.

[9/27/93 public]

Although there's no reason why the mgmt i/f operations couldn't have used
idempotent semantics, it wouldn't be a good idea to change them at this 
point.

In particular, old servers will be expecting an 'ack' for mgmt calls.
If a new client does not send one, the server may end up retransmitting the
results (up to 5 times).

[9/27/93 public]

Actually, it doesn't quite work that way; the (dg) server code uses the
"idempotent" bit out of the packet header to decide which way to treat the
call, rather than looking at any per-interface config info..

[9/27/93 public]

Yes, Bill's right.  The current implementation treats idempotency as if it were
a 'level of service' requested by the client.  This being the case, I don't have
any other objections about making the proposed change.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 7525
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : Failure in /rpc/idl/nidl_to_idl/lex_yy.c on AIX
Reported Date                 : 3/17/93
Found in Baseline             : 1.0.2
Found Date                    : 3/17/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.2
Affected File(s)              : ./rpc/idl/nidl_to_idl/nidl.l
Sensitivity                   : public

[3/17/93 public]
We're building the "export"(international) archive now to sugar out
any issues before we go to code freeze.

The sources were snapped from the nightly build of March 10, which was
clean and smoked.

The "export" archive has the following files removed:

	security/krb5/lib/crypto/domestic
	rpc/kdes

The following coding changes are made:

Makeconf:
	Removed:	USE_DES=1 
	Added:		.undef USE_DES

rpc/runtime/krbclt.c:
	Added:		#define NOENCRYPTION
rpc/runtime/krbdgcom.c
	Added:		#define NOENCRYPTION

During the BASIC pass both Rich Zeliff and have seen this error:
 
  rpc/idl/nidl_to_idl/lex_yy.c ('lexed' from nidl.l)
"lex_yy.c", line 1337.6: 1506-132 (S) Function yyoutput cannot be
redeclared.
"lex_yy.c", line 1338.6: 1506-132 (S) Function yyunput cannot be
redeclared.
"lex_yy.c", line 1791.6: 1506-030 (S) Identifier yyoutput cannot be
redeclared.
"lex_yy.c", line 1795.6: 1506-030 (S) Identifier yyunput cannot be
redeclared.

[3/20/93 public]

Installed changes for updated IBM ncform from idl_compiler/nidl.l into
nidl_to_idl/nidl.l.

Marcy Wood is testing now.

[3/25/93 public]

Set to priority 2, this is not a ship/hold issue.

[7/27/93 public]

Tom Jordhal pinged me on whether this was fixed or not.

The file ./rpc/idl/nidl_to_idl/nidl.l was modified & submitted by Dave
Weisman on March 23 1993, therefore I am changing the status to closed.



CR Number                     : 7523
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : import.8rpc
Short Description             : synopsis and descrip of -e wrong
Reported Date                 : 3/17/93
Found in Baseline             : 1.0.2
Found Date                    : 3/17/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/rpccp.c
Sensitivity                   : public

[3/17/93 public]
The man page for the rpccp import command has:

NAME
     import  - Imports binding information and an object UUID
     from a server entry

SYNOPSIS
     rpccp import  starting-entry-name -i if-id [-v versions] [-
     e] [-n [ integer]]
     [-o object-uuid] [-s  syntax] [-u]

And in the OPTIONS:

     -e        Shows the name of the entry where the binding is
               found (optional).

(If this is what -e did then there really should be an example with -e in
it; but see below.)

Yet, if I run rpccp and do a help:

    rpccp> help import
    
    usage: rpccp import [<options>] <entry name>
    
    options:     e    <name>    binding entry name
		 i    <if id>   interface identifier
		 n    <count>   return count
		 o    <uuid>    object identifier
		 s    <syntax>  name syntax
		 u              update local name-service data
		 v    <option>  interface version option


In the doc -e takes no arg, but in the code it does.

[5/27/93 public]
Assigned to myself.

[06/03/93 public]
Changed this to a code bug, per Dave Weisman.  The documentation
(rpccp_import.8rpc) currently reflects the correct functionality
for the -e option -- that is, -e doesn't take an argument.  The
help message should be changed to match the doc.

[8/16/93 public]
Modified the description for rpccp import -e option.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 7519
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpccp man pages
Short Description             : /bin/sh prompt with setenv
Reported Date                 : 3/17/93
Found in Baseline             : 1.0.2
Found Date                    : 3/17/93
Severity                      : D
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.2
Fixed In Baseline             : 1.0.3
Affected File(s)              : 5
Sensitivity                   : public

[3/17/93 public]
Looking through the rpccp man pages I see several example that show what a
user would type from a command line.  The prompt in all cases is `$' which
is usually thought of as being for /bin/sh or /bin/ksh.  In some cases
environment variables need to be set and the csh setenv command is used
(see export, remove element, unexport, and rpccp man pages for examples,
there may be other instances).  

Either change the prompt to `%' the traditional C Shell prompt, or change
the setenv to the /bin/sh method:

    $ set foo=blah
    $ export foo

Note in ksh that the above can be combined to:

    $ export foo=blah

A good base may be to use the POSIX.2 shell version.  I don't KNOW what
this is, but I think it's the same as ksh.

Note also that in some cases (see export.8rpc) the nearby text explictly
says that in the Csh you can use the setenv command.  This should probably
be changed as well.

[03/17/93 public]
Actually the sh,ksh syntax is
	$ foo=blah
	$ export foo

[5/27/93 public]
Assigned to myself.

[06/03/93 public]
Changed to "verified".  Dave Weisman confirmed that the sh/ksh syntax
was the way to go.  I changed the csh examples to the sh/ksh
syntax cited above by rsalz in all affected man8rpc ref pages: 

	rpccp.8rpc
	rpccp_export.8rpc
	rpccp_remove_element.8rpc
	rpccp_show_profile.8rpc
	rpccp_unexport.8rpc

[08/17/93 public]
Closed bug.



CR Number                     : 7518
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpccp.8rpc
Short Description             : A footnote appears in a man page
Reported Date                 : 3/17/93
Found in Baseline             : 1.0.2
Found Date                    : 3/17/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.2
Fixed In Baseline             : 1.0.3
Affected File(s)              : 1
Sensitivity                   : public

[3/17/93 public]
In the rpccp man page there is a footnote in a table.  It gets oddly
formatted in the ascii version, and is easily changed to be a note after
the table.  From the ascii version:

     Function           At System Prompt   Inside Control Program
     ____________________________________________________________
     Strings within
     quotation marks

                        Supported1         Not required

     Wildcard substi-
     tution

                        Supported          Unsupported

     ____________________________________________________________

     1 Some UNIX systems require that you place an escape symbol
     (\) before string binding delimiters such as brackets ([ ])
     or that you place the delimiters within quotation marks (' '
     or '' '') at the system prompt.

(Go ahead, find the "1" in the table, I dare you! :-)

[5/27/93 public]
Assigned to myself.

[5/28/93 public]
Changed to "verified".  Turned the footnote into a standard
Note: immediately following the offending table.

[08/17/93 public]
Closed bug.



CR Number                     : 7517
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : rpccp.8rpc
Short Description             : Example wrong in Args and Options
Reported Date                 : 3/17/93
Found in Baseline             : 1.0.2
Found Date                    : 3/17/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.2
Fixed In Baseline             : 1.0.3
Affected File(s)              : 1
Sensitivity                   : public

[3/17/93 public]
An example in the Arguments and Options section seems wrong.  From the man
page: 

     Arguments and Options
     Except for the exit and quit commands, rpccp commands have
     one or more options.  Each option is identified by a -
     (dash) followed by a letter; for example, -s. Some options
     require arguments.

     Commands that access NSI operations also require the name of
     a name service entry as an argument.  The order of arguments
     and the entry-name option is arbitrary; for example, the
     following placements of arguments and options are
     equivalent:
     rpccp> add entry  /.:/LandS/anthro/mis_node_2  \
     > ec1eeb60-5943-11c9-a309-08002b102989,1.0

     rpccp> add entry ec1eeb60-5943-11c9-a309-08002b102989,1.0  \
     > /.:/LandS/anthro/mis_node_2

1. The example doesn't describe the text as it has two arguments and no
options.  This doesn't show how options and arguments can be given in any
order. 

2. The add entry command on its man page says it takes only one argument
and an option that specifies a syntax where we only support one right now.
Perhaps this was meant to be add element and the non-name part (the UUID
and version number) are supposed to be an option given with the -i switch.

[5/27/93 public]
Assigned to myself.

[06/03/93 public]
Changed to "verified".  Changed the "add entry" command in this
rpccp.8rpc ref page example to the "add element" command, using
the -i option to specify an interface identifier.  This solves
both of the problems listed in this CR.

[08/17/93 public]
Closed bug.



CR Number                     : 7504
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : SIGSEGV in rpc__cn_assoc_acb_dealloc
Reported Date                 : 3/15/93
Found in Baseline             : 1.02b17
Found Date                    : 3/5/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : cnassoc.c
Sensitivity                   : public

[3/15/93 public]

Here is a core dump stack trace
rpc__cn_assoc_acb_dealloc(0x0) at 0x20046f74
rpc__cn_assoc_reclaim(0x0, 0x20a84213) at 0x20046dc4
rpc__cn_assoc_timer_reclaim(0x0) at 0x20046c08
timer_callout() at 0x20000a30
cma__thread_base(0x0) at 0xd032b24c

This is a case of a server association reclamation that is made where the
acb has been reclaimed before the association has been removed from the
group list.  What this seems to be related to is over-decrementing of the
acb reference count.  The acb_dealloc is called in assoc_reclaim to 
decrement the reference count on the association that is currently being
scanned.  It appears that this code path assumed that the reference count
would always be at least one on any association that was scanned by
this routine and would not be decremented until the association had been
shutdown.  This is not actually the case because we are seeing the acb
reference count at 0 when assoc_reclaim is entered, the shutdown attempt
fails and we then deallocate the acb without removing it from the group
association list.  This produces any number of bad side effects - all of
which result in some type of core file being produced.

I am currently instrumenting the code to help me find the extra decrement.
I should also point out that this is happening in a server that also acts
as a client to another server, so substantial numbers of groups and 
associations of both client and server type are coexisting in this server.

[3/16/93 public]

Forget the over-decrementing hypothesis
Try this on for size ---

The timer_loop thread kicks off a rpc__cn_assoc_reclaim which grabs a 
reference to the rpc_g_cn_assoc_grp_tbl.assoc_grp_vector  in 
assoc_reclaim and begins cycling through the groups and associations.
It comes to an association that is worthy of a shutdown request and sends
a shutdown request to the client ( in the server association group ).
Guess what happens in rpc__cn_assoc_send_frag ?  It opens up the global
lock and lets some other thread run.  Now suppose that this thread happens
to be a new client thread that wants an association but no appropriate
group exits.  Well then this thread has to call grp_alloc which will call
grp_create if there aren't anymore groups in the current group table.
Well we know what happens in grp_create -- the old group list is copied to
a new larger list and is then freed to the heap.  The poor timer thread is
left pointing at a group list sitting in the free pool and subject to
being written all-over by it's new owner.

I think the fix for this should be pretty simple, just add a new reference
to the rpc_g_cn_assoc_grp_tbl.assoc_grp_vector at the bottom of the for
loop in assoc_reclaim.  I will be trying this fix out tonite and will
check back in tomorrow with the results.

[3/17/93 public]

This fix didn't work and what I have found is that I believe the problem is
systematic in that we have many references to RPC_CN_ASSOC_GRP which 
gets a reference to an element of the table directly from the 
assoc_grp_vector.  The only thing that works for me is to start the table
out with a large number of elements ( ie 100 ).  If I don't then even
with the "fix" , I still get references to associations that don't make
sense and cause core dumps.  I don't believe that this problem is within
my scope and so I am going to install the hack to initialize the table
with 100 elements and kick this back.

I believe that this problem can be recreated by writing a testcase in which
there is a substantial amount of call activity to different servers.

[3/17/93 public]

Here is what I have done for the time being in cnassoc.c at line 328
or thereabout (depending on whose file it is)

#define rpc_c_assoc_grp_alloc_size		100

[3/17/93 public]

Just a note of interest -- I was able to run my servers in a very heavy load
situation after making this change but my cell servers were still running
on the old library and the rpcd core dumped in assoc_listen.  It turned
out that his active group count was 0x18.  Maybe this bit of info can give
you some ideas on how to replicate this problem without having our test.

[3/19/93 public]

Wei submitted the workaround; the real data structure fixes will be done in
the 1.0.3 project.


I asked Ken (an engineer in my group) to do a code review of the references
to the assoc group structure.  We believe that, with one exception to be
described later, we are OK.  RPC_CN_ASSOC_GRP gets a pointer to
the assoc group by using the group ID.  The group ID contains a
field that is changed if we relocate the group table.  So, this
macro should correctly detect when the table has been relocated.

A problem was found in the timer / reclamation thread when it's calling
rpc__cn_assoc_reclaim.  This routine cycles through all the
association groups in the group table and walks the association list
on each looking for a candidate for reclaimation. When it finds one,
it will potentially send a shutdown request, which will release the
CN lock. This may allow another thread to reallocate the group table
and therefore make the references to the old table invalid.

One easy fix would be to return from rpc__cn_assoc_reclaim if an
association was shutdown. This would mean that it would possibly
take longer to shutdown associations since only one could be
shutdown on each pass. Another possible fix is to change
rpc__cn_assoc_reclaim to pick up the new base of the association
group table each time through the loop. This should also be fairly
easy. The reference to the assoc grp could be made through the
assoc_grp_vector (which always contains the current address of the
assoc group array).

Can you verify whether this is the problem by running the same tests
with the reclaimation timer turned off (just no-op out the call
to rpc__cn_assoc_reclaim) and changing the group table size back
to its original value?

[7/29/93 public]

Has anyone tryed the above suggested fixes?

I have implemented these fixes:

1) The reference to assoc_grp is now made through
   rpc_g_cn_assoc_grp_tbl.assoc_grp_vector[i] in
   rpc__cn_assoc_reclaim().

2) Added boolean32 loop as input argument to
   rpc__cn_assoc_reclaim(). If it's false (called from the timer
   thread) and the association was shutdown or aborted, return
   immediately.

3) Decreased rpc_c_assoc_grp_alloc_size to 10.

and is testing it. (So far, it seems to be working...)

I'm wondering if anyone has already fixed it because this bug
seems to be really trashing the memory.

[8/15/93 public]

If rpc__cn_assoc_reclaim() opens up the global mutex (by sending the
shutdown request), after that it should not use the next assoc retuned from
RPC_LIST_NEXT(). Because while the other threads are running
assoc_acb_ref_count may go down to 1 and rpc__cn_assoc_acb_decalloc() may
deallocate the assoc. Thus, the "next" pointer may be bogus or pointing to
an assoc on the lookaside_list.

[08/17/93 public]
Took the fix from tatsu_s (thanks!):

Added boolean32 loop as input argument to rpc__cn_assoc_reclaim().  
If it's false (called from the timer thread) and the association was 
shutdown or aborted, return immediately.

Also the reference to assoc_grp is now made through
rpc_g_cn_assoc_grp_tbl.assoc_grp_vector in rpc__cn_assoc_reclaim().

Decreased rpc_c_assoc_grp_alloc_size to 10.

Submitted.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 7489
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : perf test
Short Description             : forwarding test w/ dynamic endpoint fails
Reported Date                 : 3/12/93
Found in Baseline             : 1.0.2
Found Date                    : 3/12/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : src/test/rpc/runtime/perf/client.c
Sensitivity                   : public

[3/12/93 public]

Start up PERF server using notif (dynamic endpoints).

Have client perform test 8 (forwarding test) over TCP

The test will fail in the following way:

Forwarding test [8]
  binding resolved to: ncacn_ip_tcp:16.20.16.94[1414]
  result of forwarded call = "voran.lkg.dec.com"
  large forwarded call completd OK
  request for interface ids through partial binding completed OK (nil type obje
  request for interface ids through partial binding completed OK (non-nil type 
  warning: can't do broadcast
*** Unknown exception raised
%CMA-F-EXCCOPLOS, exception raised; some information lost
-DCERPC-E-CONNECTREJECTED, connection request rejected (dce / rpc)

What's happening is that at the end of the test, the client attempts
to contact the server (over the PERF if) to tell it to unregister the PERFB
interface (via perf_unregister_b).  The call is being made over a partially
bound handle.  In resolving the handle, the runtime pulls the well
known endpoint out of the perf if spec:

CN: call_rep->2763c8 assoc->2d0bc8 desc->0 connection request intiated to
16.20.16.94[2001]

In this case, though, the perf server was started up with a dynamic
endpoint and the connect request to the well known endpoint gets
rejected by the remote server machine.

There are at least a couple of ways to fix this:

- Could save the binding specified on the command line by the user and
the one used to make the initial call to the server.  Use this binding
to call perf_unregister_b.

- Conditionally perform an explicit rpc_ep_resolve_binding to fully
resolve the binding.

[3/17/93 public]
I have nothing to do with perf test.  Assign Markar as responsible engineer.

[9/17/93 public]

The string binding specified on the command line is still available when
perf_unregister_b() is called. So we just need to do:

    rh = binding_from_string_binding(NULL, argv[2]);

before calling perf_unregister_b().

[9/28/93 public]

The fix was submitted to 1.0.3.

[11/12/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 7471
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : sinix
Component Name                : rpc
Subcomponent Name             : src/rpc/runtime/SVR4/comsoc_sys.h
Short Description             : RPC_SOCKET_RECVMSG does not
initialize msg_accrightslen
Reported Date                 : 3/10/93
Found in Baseline             : 1.0.2b16
Found Date                    : 3/10/93
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : src/rpc/runtime/SVR4/comsoc_sys.h
Sensitivity                   : public

[3/10/93 public]

Full Description:

        RPC_SOCKET_RECVMSG does not initialize msg_accrightslen to zero.

Repeat By:

        Look at the code.

Proposed Solution:

        Add the following in #define RPC_SOCKET_RECVMSG:

        msg.msg_accrightslen = 0; \

        after the line,

        msg.msg_accrights = NULL; \


This defect has been sent to SNI for fixing.

[8/10/93 public]

This was fixed during the latest SVR4 merge.

[08/16/93 public]
As far as I can tell this change has been in our code for a while.
Closed.



CR Number                     : 7465
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : assert in pkt_alloc()
Reported Date                 : 3/10/93
Found in Baseline             : 1.0.2
Found Date                    : 3/10/93
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : rpc/runtime/dg.c
Sensitivity                   : public

[3/10/93 public]

While running a product level test on AIX platform, secd core dumped. The rpc
protocol being used is ncadg_ip_udp. I am including the stack traces and
general information about the threads, which tells us whether general
cancellability is enabled for a thread.

 thread  state  substate   held  priority  yield  preempt  function
>$t1     susp   cond         no  12(thru)  6      0        cma__dispatch
      general:
         thread kind  = initial
         thread errno = 109
         start pc     = 0x0
         detached     = no
      alert:
         alert pending             = no
         general alert delivery    = enabled
         asyn alert delivery       = disabled
      tcb (thread control block):
         address      = 0x200b3840         size         = 4044
      stack storage:
         sp           = 0x2ff7a198         on default stack

cma_dispatch.cma__dispatch(0x200b3b20, 0x2010e950, 0x200b3840) at 0xd050c700
cma_dispatch.cma__block(0x200b3b20, 0x2010e950) at 0xd050c448
cma_condition.cma__int_wait(0x200b3b20, 0x2010e950) at 0xd050c0c0
cma_thread.cma_thread_join(0x200b3b20, 0x2010e950, 0x200b3840) at 0xd0514610
cma_pthread.pthread_join(0x20111120, 0x90004, 0x2ff7ab1c) at 0xd051aa7c
rs_task_join(0x200b3b20, 0x2010e950, 0x200b3840) at 0x100316fc
rgy_main(0x200b3b20, 0x2010e950) at 0x10000dd4
main(0x200b3b20, 0x2010e950) at 0x100003dc


 thread  state  substate   held  priority  yield  preempt  function
>$t3     susp   cond         no  12(thru)  0      0        cma__dispatch
      general:
         thread kind  = normal
         thread errno = 0
         start pc     = 0x200db298
         detached     = no
      alert:
         alert pending             = no
         general alert delivery    = enabled
         asyn alert delivery       = disabled
      tcb (thread control block):
         address      = 0x20152548         size         = 4044
      stack storage:
         top          = 0x20129000         bytes free   = 42745
         guard        = 0x2012afff         bytes used   = 2312
         sp           = 0x201356f8         reserved     = 12288
         base         = 0x20136000         stack size   = 65536

cma_dispatch.cma__dispatch(0x20152828, 0x201161a0, 0x20152548) at 0xd050c700
cma_dispatch.cma__block(0x20152828, 0x201161a0) at 0xd050c448
cma_semaphore.cma__sem_timed_wait(0x20152828, 0x201161a0, 0x20152548) at 0xd0516
724
cma_condition.cma_cond_timed_wait(0x20152828, 0x201161a0, 0x20152548) at 0xd050b
160
cma_ptd_exc.ptdexc_cond_timedwait(0x20152828, 0x201161a0, 0x20152548) at 0xd0520
454
rpctimer.timer_loop() at 0xd030947c
cma_thread.cma__thread_base(0x20152828) at 0xd0515250


 thread  state  substate   held  priority  yield  preempt  function
>$t4     susp   cond         no  12(thru)  0      0        cma__dispatch
      general:
         thread kind  = normal
         thread errno = 0
         start pc     = 0x200f4670
         detached     = no
      alert:
         alert pending             = no
         general alert delivery    = enabled
         asyn alert delivery       = disabled
      tcb (thread control block):
         address      = 0x20105850         size         = 4044
      stack storage:
         top          = 0x20136000         bytes free   = 42025
         guard        = 0x20137fff         bytes used   = 3032
         sp           = 0x20142428         reserved     = 12288
         base         = 0x20143000         stack size   = 65536

cma_dispatch.cma__dispatch(0x20105b30, 0x200b3b20, 0x20105850) at 0xd050c700
cma_dispatch.cma__block(0x20105b30, 0x200b3b20) at 0xd050c448
cma_condition.cma__int_wait(0x20105b30, 0x200b3b20) at 0xd050c0c0
cma_signal.cma_sigwait(0x20105b30) at 0xd05059ec
sigwait.sigwait(0x20105b30) at 0xd02dc820
sig_handle() at 0x100002e8
cma_thread.cma__thread_base(0x20105b30) at 0xd0515250
 thread  state  substate   held  priority  yield  preempt  function


>$t5     susp   cond         no  12(thru)  0      0        cma__dispatch
      general:
         thread kind  = normal
         thread errno = 11
         start pc     = 0x200f4b74
         detached     = no
      alert:
         alert pending             = no
         general alert delivery    = enabled
         asyn alert delivery       = disabled
      tcb (thread control block):
         address      = 0x20107fb0         size         = 4044
      stack storage:
         top          = 0x201af000         bytes free   = 73273
         guard        = 0x201b0fff         bytes used   = 4552
         sp           = 0x201c2e38         reserved     = 12288
         base         = 0x201c4000         stack size   = 98304

cma_dispatch.cma__dispatch(0x20108290, 0x20101978, 0x20107fb0) at 0xd050c700
cma_dispatch.cma__block(0x20108290, 0x20101978) at 0xd050c448
cma_semaphore.cma__sem_timed_wait(0x20108290, 0x20101978, 0x20107fb0) at 0xd0516
724
cma_condition.cma_cond_timed_wait(0x20108290, 0x20101978, 0x20107fb0) at 0xd050b
160
cma_pthread.pthread_cond_timedwait(0x20108290, 0x20101978, 0x20107fb0) at 0xd051
d200
prop_driver_sleep(0x20108290, 0x20101978, 0x20107fb0, 0x20101698, 0x0, 0x0) at 0
x10075a74
prop_driver(0x20108290) at 0x10075618
cma_thread.cma__thread_base(0x20108290) at 0xd0515250


 thread  state  substate   held  priority  yield  preempt  function
>$t6     susp   cond         no  12(thru)  0      0        cma__dispatch
      general:
         thread kind  = normal
         thread errno = 11
         start pc     = 0x200f4b74
         detached     = no
      alert:
         alert pending             = no
         general alert delivery    = enabled
         asyn alert delivery       = disabled
      tcb (thread control block):
         address      = 0x2010a170         size         = 4044
      stack storage:
         top          = 0x201c4000         bytes free   = 73273
         guard        = 0x201c5fff         bytes used   = 4552
         sp           = 0x201d7e38         reserved     = 12288
         base         = 0x201d9000         stack size   = 98304

cma_dispatch.cma__dispatch(0x2010a450, 0x20101978, 0x2010a170) at 0xd050c700
cma_dispatch.cma__block(0x2010a450, 0x20101978) at 0xd050c448
cma_semaphore.cma__sem_timed_wait(0x2010a450, 0x20101978, 0x2010a170) at 0xd0516
724
cma_condition.cma_cond_timed_wait(0x2010a450, 0x20101978, 0x2010a170) at 0xd050b
160
cma_pthread.pthread_cond_timedwait(0x2010a450, 0x20101978, 0x2010a170) at 0xd051
d200
prop_driver_sleep(0x2010a450, 0x20101978, 0x2010a170, 0x20101698, 0x0, 0x0) at 0
x10075a74
prop_driver(0x2010a450) at 0x10075618
cma_thread.cma__thread_base(0x2010a450) at 0xd0515250


 thread  state  substate   held  priority  yield  preempt  function
>$t7     susp   cond         no  12(thru)  0      0        cma__dispatch
      general:
         thread kind  = normal
         thread errno = 11
         start pc     = 0x200f4b74
         detached     = no
      alert:
         alert pending             = no
         general alert delivery    = enabled
         asyn alert delivery       = disabled
      tcb (thread control block):
         address      = 0x2010c330         size         = 4044
      stack storage:
         top          = 0x201e2000         bytes free   = 73273
         guard        = 0x201e3fff         bytes used   = 4552
         sp           = 0x201f5e38         reserved     = 12288
         base         = 0x201f7000         stack size   = 98304

cma_dispatch.cma__dispatch(0x2010c610, 0x20101978, 0x2010c330) at 0xd050c700
cma_dispatch.cma__block(0x2010c610, 0x20101978) at 0xd050c448
cma_semaphore.cma__sem_timed_wait(0x2010c610, 0x20101978, 0x2010c330) at 0xd0516
724
cma_condition.cma_cond_timed_wait(0x2010c610, 0x20101978, 0x2010c330) at 0xd050b
160
cma_pthread.pthread_cond_timedwait(0x2010c610, 0x20101978, 0x2010c330) at 0xd051
d200
prop_driver_sleep(0x2010c610, 0x20101978, 0x2010c330, 0x20101698, 0x0, 0x0) at 0
x10075a74
prop_driver(0x2010c610) at 0x10075618
cma_thread.cma__thread_base(0x2010c610) at 0xd0515250


 thread  state  substate   held  priority  yield  preempt  function
>$t8     run                 no  12(thru)  5511   0        raise
      general:
         thread kind  = normal
         thread errno = 0
         start pc     = 0x200db61c
         detached     = no
      alert:
         alert pending             = no
         general alert delivery    = enabled
         asyn alert delivery       = disabled
      tcb (thread control block):
         address      = 0x2010e670         size         = 4044
      stack storage:
         top          = 0x201f7000         bytes free   = 74873
         guard        = 0x201f8fff         bytes used   = 2952
         sp           = 0x2020b478         reserved     = 12288
         base         = 0x2020c000         stack size   = 98304

raise.raise(0x0) at 0xd053e93c
abort.abort(0x0) at 0xd02d1640
assert._assert(0x0, 0xdeadbeef, 0xdeadbeef) at 0xd02ee1a8
dgpkt.rpc__dg_pkt_alloc_rqe() at 0xd0360d58
dglsn.rpc__dg_network_select_dispatch(0x0, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef) a
t 0xd036a310
comnlsn.lthread_loop() at 0xd0345668
comnlsn.lthread(0x0) at 0xd03454a4
cma_thread.cma__thread_base(0x0) at 0xd0515250



 thread  state  substate   held  priority  yield  preempt  function
>$t9     susp   cond         no  12(thru)  0      0        cma__dispatch
      general:
         thread kind  = normal
         thread errno = 0
         start pc     = 0x200f56cc
         detached     = no
      alert:
         alert pending             = no
         general alert delivery    = enabled
         asyn alert delivery       = disabled
      tcb (thread control block):
         address      = 0x20111120         size         = 4044
      stack storage:
         top          = 0x20225000         bytes free   = 75081
         guard        = 0x20226fff         bytes used   = 2744
         sp           = 0x20239548         reserved     = 12288
         base         = 0x2023a000         stack size   = 98304

cma_dispatch.cma__dispatch(0x20111400, 0x20113ad0, 0x20111120) at 0xd050c700
cma_dispatch.cma__block(0x20111400, 0x20113ad0) at 0xd050c448
cma_ptd_exc.ptdexc_cond_wait(0x20111400, 0x20113ad0) at 0xd052032c
comnet.rpc_server_listen(0x20111400, 0x20113ad0) at 0xd0339044
start_listeners(0x20111400) at 0x100014ac
cma_thread.cma__thread_base(0x20111400) at 0xd0515250



 thread  state  substate   held  priority  yield  preempt  function
>$t10    susp   cond         no  12(thru)  0      0        cma__dispatch
      general:
         thread kind  = normal
         thread errno = 11
         start pc     = 0x200f563c
         detached     = yes
      alert:
         alert pending             = no
         general alert delivery    = disabled
         asyn alert delivery       = disabled
      tcb (thread control block):
         address      = 0x201137f0         size         = 4044
      stack storage:
         top          = 0x2023a000         bytes free   = 70233
         guard        = 0x2023bfff         bytes used   = 7592
         sp           = 0x2024d258         reserved     = 12288
         base         = 0x2024f000         stack size   = 98304

cma_dispatch.cma__dispatch(0x20113ad0, 0x20101978, 0x201137f0) at 0xd050c700
cma_dispatch.cma__block(0x20113ad0, 0x20101978) at 0xd050c448
cma_condition.cma__int_wait(0x20113ad0, 0x20101978) at 0xd050c0c0
cma_thread_io.cma__io_wait(0x20113ad0, 0x20101978) at 0xd050fd38
cma_thdio_4.cma_recvfrom(0x20113ad0, 0x20101978, 0x201137f0, 0x20101698, 0x0, 0x
0) at 0xd0526478
recvfrom.recvfrom(0x20113ad0, 0x20101978, 0x201137f0, 0x20101698, 0x0, 0x0) at 0
xd02dc46c
listen_and_process(0x20113ad0) at 0x101117a8
kdc_run(0x20113ad0, 0x20101978) at 0x1010e980
start_kerberos_task(0x20113ad0) at 0x100023bc
cma_thread.cma__thread_base(0x20113ad0) at 0xd0515250


 thread  state  substate   held  priority  yield  preempt  function
>$t11    susp   cond         no  12(thru)  0      0        cma__dispatch
      general:
         thread kind  = normal
         thread errno = 12
         start pc     = 0x200db634
         detached     = yes
      alert:
         alert pending             = no
         general alert delivery    = disabled
         asyn alert delivery       = disabled
      tcb (thread control block):
         address      = 0x20115ec0         size         = 4044
      stack storage:
         top          = 0x20258000         bytes free   = 73081
         guard        = 0x20259fff         bytes used   = 4744
         sp           = 0x2026bd78         reserved     = 12288
         base         = 0x2026d000         stack size   = 98304

cma_dispatch.cma__dispatch(0x201161a0, 0x2010e950, 0x20115ec0) at 0xd050c700
cma_dispatch.cma__block(0x201161a0, 0x2010e950) at 0xd050c448
cma_ptd_exc.ptdexc_cond_wait(0x201161a0, 0x2010e950) at 0xd052032c
dgcall.rpc__dg_call_wait(0x201161a0, 0x2010e950) at 0xd035df0c
dg.rpc__dg_call_receive_int(0x201161a0, 0x2010e950, 0x20115ec0) at 0xd03629d4
dg.rpc__dg_call_transceive(0x201161a0, 0x2010e950, 0x20115ec0, 0x2010e670, 0x0)
at 0xd0362f08
comcall.rpc_call_transceive(0x201161a0, 0x2010e950, 0x20115ec0, 0x2010e670, 0x0)
 at 0xd0329c44
ep_cstub.op0_csr(0x201161a0, 0x2010e950, 0x20115ec0, 0x2010e670, 0x0) at 0xd0364
bb8
dgsct.rpc__dg_sct_way_validate(0x201161a0, 0x2010e950, 0x20115ec0) at 0xd0363e74
dgexec.rpc__dg_execute_call(0x201161a0, 0x2010e950) at 0xd0361ea4
comcthd.cthread_call_executor(0x201161a0) at 0xd0345aa8
cma_thread.cma__thread_base(0x201161a0) at 0xd0515250


 thread  state  substate   held  priority  yield  preempt  function
>$t12    susp   cond         no  12(thru)  0      0        cma__dispatch
      general:
         thread kind  = normal
         thread errno = 9
         start pc     = 0x200db634
         detached     = yes
      alert:
         alert pending             = no
         general alert delivery    = disabled
         asyn alert delivery       = disabled
      tcb (thread control block):
         address      = 0x20118080         size         = 4044
      stack storage:
         top          = 0x2026d000         bytes free   = 75673
         guard        = 0x2026efff         bytes used   = 2152
         sp           = 0x20281798         reserved     = 12288
         base         = 0x20282000         stack size   = 98304

cma_dispatch.cma__dispatch(0x20118360, 0x2010e950, 0x20118080) at 0xd050c700
cma_dispatch.cma__block(0x20118360, 0x2010e950) at 0xd050c448
cma_ptd_exc.ptdexc_cond_wait(0x20118360, 0x2010e950) at 0xd052032c
comcthd.cthread_call_executor(0x20118360) at 0xd0345a38
cma_thread.cma__thread_base(0x20118360) at 0xd0515250


 thread  state  substate   held  priority  yield  preempt  function
>$t13    susp   cond         no  12(thru)  0      0        cma__dispatch
      general:
         thread kind  = normal
         thread errno = 0
         start pc     = 0x200db634
         detached     = yes
      alert:
         alert pending             = no
         general alert delivery    = disabled
         asyn alert delivery       = disabled
      tcb (thread control block):
         address      = 0x2011a240         size         = 4044
      stack storage:
         top          = 0x202ab000         bytes free   = 75673
         guard        = 0x202acfff         bytes used   = 2152
         sp           = 0x202bf798         reserved     = 12288
         base         = 0x202c0000         stack size   = 98304

cma_dispatch.cma__dispatch(0x2011a520, 0x2028af48, 0x2011a240) at 0xd050c700
cma_dispatch.cma__block(0x2011a520, 0x2028af48) at 0xd050c448
cma_ptd_exc.ptdexc_cond_wait(0x2011a520, 0x2028af48) at 0xd052032c
comcthd.cthread_call_executor(0x2011a520) at 0xd0345a38
cma_thread.cma__thread_base(0x2011a520) at 0xd0515250


 thread  state  substate   held  priority  yield  preempt  function
>$t14    susp   cond         no  12(thru)  0      0        cma__dispatch
      general:
         thread kind  = normal
         thread errno = 0
         start pc     = 0x200db634
         detached     = yes
      alert:
         alert pending             = no
         general alert delivery    = disabled
         asyn alert delivery       = disabled
      tcb (thread control block):
         address      = 0x2028ac68         size         = 4044
      stack storage:
         top          = 0x202c0000         bytes free   = 75673
         guard        = 0x202c1fff         bytes used   = 2152
         sp           = 0x202d4798         reserved     = 12288
         base         = 0x202d5000         stack size   = 98304

cma_dispatch.cma__dispatch(0x2028af48, 0x2028cef8, 0x2028ac68) at 0xd050c700
cma_dispatch.cma__block(0x2028af48, 0x2028cef8) at 0xd050c448
cma_ptd_exc.ptdexc_cond_wait(0x2028af48, 0x2028cef8) at 0xd052032c
comcthd.cthread_call_executor(0x2028af48) at 0xd0345a38
cma_thread.cma__thread_base(0x2028af48) at 0xd0515250


 thread  state  substate   held  priority  yield  preempt  function
>$t15    susp   cond         no  12(thru)  0      0        cma__dispatch
      general:
         thread kind  = normal
         thread errno = 9
         start pc     = 0x200db634
         detached     = yes
      alert:
         alert pending             = no
         general alert delivery    = disabled
         asyn alert delivery       = disabled
      tcb (thread control block):
         address      = 0x2028cc18         size         = 4044
      stack storage:
         top          = 0x202de000         bytes free   = 75673
         guard        = 0x202dffff         bytes used   = 2152
         sp           = 0x202f2798         reserved     = 12288
         base         = 0x202f3000         stack size   = 98304

cma_dispatch.cma__dispatch(0x2028cef8, 0x2010e950, 0x2028cc18) at 0xd050c700
cma_dispatch.cma__block(0x2028cef8, 0x2010e950) at 0xd050c448
cma_ptd_exc.ptdexc_cond_wait(0x2028cef8, 0x2010e950) at 0xd052032c
comcthd.cthread_call_executor(0x2028cef8) at 0xd0345a38
cma_thread.cma__thread_base(0x2028cef8) at 0xd0515250


 thread  state  substate   held  priority  yield  preempt  function
>$t16    susp   cond         no  12(thru)  0      0        cma__dispatch
      general:
         thread kind  = normal
         thread errno = 0
         start pc     = 0x200dbf34
         detached     = no
      alert:
         alert pending             = no
         general alert delivery    = enabled
         asyn alert delivery       = disabled
      tcb (thread control block):
         address      = 0x2028f2c8         size         = 4044
      stack storage:
         top          = 0x202f3000         bytes free   = 42921
         guard        = 0x202f4fff         bytes used   = 2136
         sp           = 0x202ff7a8         reserved     = 12288
         base         = 0x20300000         stack size   = 65536

cma_dispatch.cma__dispatch(0x2028f5a8, 0x20101978, 0x2028f2c8) at 0xd050c700
cma_dispatch.cma__block(0x2028f5a8, 0x20101978) at 0xd050c448
cma_ptd_exc.ptdexc_cond_wait(0x2028f5a8, 0x20101978) at 0xd052032c
dglsn.convq_loop() at 0xd0367df0
cma_thread.cma__thread_base(0x2028f5a8) at 0xd0515250


 thread  state  substate   held  priority  yield  preempt  function
>$t18    susp   cond         no  12(thru)  0      0        cma__dispatch
      general:
         thread kind  = normal
         thread errno = 11
         start pc     = 0x200f5078
         detached     = no
      alert:
         alert pending             = no
         general alert delivery    = enabled
         asyn alert delivery       = disabled
      tcb (thread control block):
         address      = 0x20293898         size         = 4044
      stack storage:
         top          = 0x20326000         bytes free   = 71177
         guard        = 0x20327fff         bytes used   = 6648
         sp           = 0x20339608         reserved     = 12288
         base         = 0x2033b000         stack size   = 98304

cma_dispatch.cma__dispatch(0x20293b78, 0x20101978, 0x20293898) at 0xd050c700
cma_dispatch.cma__block(0x20293b78, 0x20101978) at 0xd050c448
cma_semaphore.cma__sem_timed_wait(0x20293b78, 0x20101978, 0x20293898) at 0xd0516
724
cma_condition.cma_cond_timed_wait(0x20293b78, 0x20101978, 0x20293898) at 0xd050b
160
cma_pthread.pthread_cond_timedwait(0x20293b78, 0x20101978, 0x20293898) at 0xd051
d200
rs_ns_register_sleep(0x20293b78) at 0x1007f1d4
rs_ns_server_master_change_monitor(0x20293b78, 0x20101978) at 0x1007ed88
rs_ns_server_register(0x20293b78) at 0x1007ebdc
cma_thread.cma__thread_base(0x20293b78) at 0xd0515250


 thread  state  substate   held  priority  yield  preempt  function
>$t19    susp   delay        no  12(thru)  0      0        cma__dispatch
      general:
         thread kind  = normal
         thread errno = 2
         start pc     = 0x200f509c
         detached     = yes
      alert:
         alert pending             = no
         general alert delivery    = enabled
         asyn alert delivery       = disabled
      tcb (thread control block):
         address      = 0x20295a58         size         = 4044
      stack storage:
         top          = 0x20344000         bytes free   = 73417
         guard        = 0x20345fff         bytes used   = 4408
         sp           = 0x20357ec8         reserved     = 12288
         base         = 0x20359000         stack size   = 98304

cma_dispatch.cma__dispatch(0x20295d38, 0x20101978, 0x20295a58) at 0xd050c700
cma_dispatch.cma__block(0x20295d38, 0x20101978) at 0xd050c448
cma_semaphore.cma__sem_timed_wait(0x20295d38, 0x20101978, 0x20295a58) at 0xd0516
724
cma_condition.cma__int_timed_wait(0x20295d38, 0x20101978, 0x20295a58) at 0xd050b
ee0
cma_pthread.pthread_delay_np(0x20295d38) at 0xd051da80
rs_task_sleep(0x20295d38) at 0x100317f8
rsdb_checkpt_task(0x20295d38) at 0x10025e54
cma_thread.cma__thread_base(0x20295d38) at 0xd0515250


 thread  state  substate   held  priority  yield  preempt  function
>$t20    susp   cond         no  12(thru)  0      0        cma__dispatch
      general:
         thread kind  = normal
         thread errno = 11
         start pc     = 0x200dc534
         detached     = no
      alert:
         alert pending             = no
         general alert delivery    = disabled
         asyn alert delivery       = disabled
      tcb (thread control block):
         address      = 0x20299b10         size         = 4044
      stack storage:
         top          = 0x20359000         bytes free   = 40409
         guard        = 0x2035afff         bytes used   = 4648
         sp           = 0x20364dd8         reserved     = 12288
         base         = 0x20366000         stack size   = 65536

cma_dispatch.cma__dispatch(0x20299df0, 0x20293b78, 0x20299b10) at 0xd050c700
cma_dispatch.cma__block(0x20299df0, 0x20293b78) at 0xd050c448
cma_condition.cma__int_wait(0x20299df0, 0x20293b78) at 0xd050c0c0
cma_thread_io.cma__io_wait(0x20299df0, 0x20293b78) at 0xd050fd38
cma_thdio_2.cma_read(0x20299df0, 0x20293b78, 0x20299b10) at 0xd0523f28
read.read(0x20299df0, 0x20293b78, 0x20299b10) at 0xd02c2540
dnsread.dns_reader() at 0xd03e1a5c
cma_thread.cma__thread_base(0x20299df0) at 0xd0515250

Thread 8 was in pkt_alloc routine, when the free_list hanging off
rpc_dg_g_pkt_pool was found to be NULL and free_count was 0x6b instead of
zero. The code path that listener thread (thread 8) executed could not have
corrupted the free list. So it is possible that another thread
(maybe thread 11) could be cancelled at one or more place(s), causing the
free_list to be messed up.

[markar 3/11/93 public] 

We'll try to reproduce this.  We've seen this problem before, and the last time
it was caused by freeing a single packet twice.  This puts the packet on the 
free list in two places.  Since the list is maintained by pointers internal
to the packets, when the first instance of the packet is removed from the list,
any changes to its pointers are also seen in the second instance which is still
on the free list.   This is noticed some time later when a completely 
unrelated thread tries to allocate a packet, and the allocate routine sees
that the free list has been corrupted.  (For this reason, it's not useful to
get a stack trace at the time the assert is triggered.)

I've created a private copy of dgpkt.c, with some code in the pkt_free routine
to scan the free_list before allowing a packet to be freed.  The runtime we're
building here will spit out a stack trace if it catches someone trying to 
free a packet twice.

[3/24/93 public]
I tried to recreate the problem using rev 1.1.6.2 of dgpkt.c. I could not 
recreate the problem. Could you please give me the workaround. Thanks

[3/25/93 public]

Pick up dgpkt.h rev. 1.1.6.2
    and dgpkt.c rev. 1.1.6.1

[3/31/93 public]

dgpkt.h rev. 1.1.6.2 defines a boolean is_on_free_list which is not used
in dgpkt.c rev. 1.1.6.1. So,the workaround is not clear to me.

[4/1/93 public]

This files have been submitted, take them off the mainline.

[4/1/93 public]
We will get the files off the mainline. Thanks

[11/9/93 public]

Thinking that we had cleaned up all of the possible causes for this
assertion failure, we had removed the work-around that would allow
the runtime to recover from double-frees of packet buffers.

Turns out we were wrong; secd crashed with this failure last weekend during
some scalability testing.

For the time being, I've rolled the code back to the version that contained
the work-around.  

Also, I put in a fix for the problem IBM described in 7755.

[11/10/93 public]

I believe that this is caused by rpc_ss_ndr_unmar_check_buffer() macro
defined in rpc/idl/lib/ndrui.h (the new file for 1.0.3 IDL).
IDL_msp->IDL_elt_p->buff_dealloc is not nullified in the user space
runtime. (It is nullified for KRPC.) However, as the comment for
rpc_ss_ndr_unmar_check_buffer() says, the real problem is
rpc__dg_call_receive_int() not initializing *data argument. We will be
verifying the fix in our scalability testing, but because of the randomness
of testing it may take a while.

[11/22/93 public]

Here is what we are testing.

--- ../../../../dce1.0.3/src/rpc/runtime/dg.c	Sat Aug 21 17:15:52 1993
+++ dg.c	Sat Nov 20 09:36:52 1993
@@ -8,6 +8,14 @@
 /*
  * HISTORY
  * $Log:	c007465,v $
# Revision 1.15  94/06/21  17:21:29  root
# changed fields: Status  
# 
# Revision 1.14  94/05/27  11:40:22  root
# changed fields: Status  Fixed In Baseline  Affected File(s)  Responsible Engr.   new/changed/deleted note(s) [tatsu_s 5/27/94 public]
# 
# Revision 1.13  94/03/15  17:07:36  nata
# added the Created HISTORY line
# 
# Revision 1.12  93/11/24  10:46:15  pellis
# changed fields: Found in Baseline  
# 
# Revision 1.11  93/11/22  16:41:22  notuser
# changed fields: Fix By Baseline   new/changed/deleted note(s) [tatsu_s 11/22/93 public]
# 
+ * Revision 1.1.8.2  1993/11/11  15:08:31  tatsu_s
+ * 	Fix OT7465.
+ * 	Initialize *data argument in rpc__dg_call_receive_int().
+ * 	[1993/11/10  16:27:11  tatsu_s]
+ *
+ * Revision 1.1.6.3  1993/09/15  15:30:17  root
+ * 	    Loading drop DCE1_0_3b03
+ * 
  * Revision 1.1.8.2  1993/04/26  17:30:28  markar
  * 	     OT CR 7769 fix: plugged memory leak in transmit_int
  * 	[1993/04/22  17:56:01  markar]
@@ -397,6 +405,14 @@
 
     RPC_DG_CALL_LOCK_ASSERT(call);
 
+#ifndef HPDCE_FIX_OT7465
+    data->data_len = 0;
+    data->data_addr = NULL;
+    data->buff_dealloc = NULL;
+    data->buff_len = 0;
+    data->buff_addr = NULL;
+#endif /* HPDCE_FIX_OT7465 */
+
     /*
      * Check for call failure conditions...
      */
@@ -418,9 +434,11 @@
      * EOD in non-call-failure conditions.
      */
     if (rq->all_pkts_recvd && rq->head == NULL) {
+#ifdef HPDCE_FIX_OT7465
         data->data_len = 0;
         data->buff_dealloc = NULL;
         data->buff_addr = NULL;
+#endif /* HPDCE_FIX_OT7465 */
         return;
     }

We also fixed rpc_ss_ndr_unmar_check_buffer() macro defined in
rpc/idl/lib/ndrui.h. We have not verified this fix yet.

[5/27/94 public]

The fix in rpc__dg_call_receive_int()::dg.c has been submitted as a part of
MBF code drop.



CR Number                     : 7439
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : rpcd
Short Description             : rpcd -D and -d flags should be rem
Reported Date                 : 3/5/93
Found in Baseline             : 1.0.2b17
Found Date                    : 3/5/93
Severity                      : D
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpcd/rpcd.c
Sensitivity                   : public

[3/5/93 public]

rpcd -D and -d flags should be removed from the help menu and the 
argument processing.

1) They won't work if runtime is built sans -DDEBUG.
2) They (esp. -d) are redundant.  RPC_DEBUG environment variable can be
used.


> rpcd -xxx
rpcd: illegal option -- x
usage: rpcd [-vDuf] [-d<debug switches>] [<protseq> ...]
  -v: Print rpcd version and exit
  -D: Turns on default RPC runtime debug output
  -u: Print this message and exit
  -f: Run in foreground (default is to fork and parent exit)
  -d: Turns on specified RPC runtime debug output
  If any <protseq>s are specified, the rpcd listens only on those;
  otherwise all protseqs are listened on.

[8/16/93 public]
The help message is fixed by moving the -D and -d option under
DEBUG code.

[8/16/93 public]
The -D (at least) option writes other debug info other than just the output
from the RPC_DEBUG switches.  So, I suspect the -D option should stay in
the common menu and its output be dependent on whether runtime is
built -DDEBUG or not.  Sorry about not pointing this out earlier, I thought
a fellow team member had.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 7435
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : test/idl
Short Description             : cleanup old NCS1.5 compat files
Reported Date                 : 3/5/93
Found in Baseline             : 1.0.2
Found Date                    : 3/5/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b13
Affected File(s)              : see below
Sensitivity                   : public

[3/5/93 public]

 
There is 1.5 compatibility support left in the Makefile, README, and code
and tests which were never ported.

For instance I found the following in the Makefile ane README

************************************************************************
Makefile:

# The following testcases were not compiled, because they depend on the
# 1.5 compatibility library.
COMPATIBILITY   = arrayv1_151 binopwk_151 orecord_151 sparse_151 string0_151

************************************************************************
README:

NOTE: Not all tests work or are used.  Some are NIDL V1.5.1 tests that
have not yet been ported to DCE IDL.  See the Makefile to see which tests
compile and execute successfully.


Building the testcases
=============================

Makefiles are provided for building most of the testcases.  There is also
a top-level Makefile that will build all the testcases.

************************************************************************

Could you please remove any 1.5 support in the Makefile, README, and remove
any tests which don't work or were never ported?

Thanks,

Bob H.

[3/5/93 public]

Mea culpa, should have been an enhancement.

[5/13/94 public]
Since Charlie is going to defunct the 1.5 compat stuff, I'll let him
handle this one.

[7/14/94 public]
Change these files not to talk aobut NCS 1.5:
./Makeconf
./rpc/runtime/Makefile
./rpc/sys_idl/Makefile
./test/rpc/idl/Makefile
./test/rpc/idl/README

Defuncted the following files:

./rpc/runtime/ask_15.c
./rpc/runtime/compat.c
./rpc/runtime/compat.h
./rpc/runtime/error_15.c
./rpc/runtime/error_15.h
./rpc/runtime/fault_15.h
./rpc/runtime/glb_15.c
./rpc/runtime/glb_15.h
./rpc/runtime/glb_cs_15.c
./rpc/runtime/glb_p_15.h
./rpc/runtime/idl_b_15.h
./rpc/runtime/lb_15.c
./rpc/runtime/lb_15.h
./rpc/runtime/lb_p_15.h
./rpc/runtime/llb_15.c
./rpc/runtime/llb_15.h
./rpc/runtime/llb_cs_15.c
./rpc/runtime/llb_p_15.h
./rpc/runtime/nbase_15.h
./rpc/runtime/ncast_15.h
./rpc/runtime/pbase_15.h
./rpc/runtime/ppfm_15.h
./rpc/runtime/rpc_15.c
./rpc/runtime/rpc_15.h
./rpc/runtime/rrpc.c
./rpc/runtime/rrpc_15.h
./rpc/runtime/rrpc_cs_15.c
./rpc/runtime/rrpc_csw_15.c
./rpc/runtime/sock_15.c
./rpc/runtime/sock_15.h
./rpc/runtime/sockd_15.c
./rpc/runtime/socki_15.c
./rpc/runtime/sockp_15.h
./rpc/runtime/std_15.h
./rpc/runtime/u_pfm_15.c
./rpc/runtime/uuid_15.c
./rpc/runtime/uuid_15.h
./rpc/sys_idl/glb.idl
./rpc/sys_idl/llb.idl
./rpc/sys_idl/rrpc.idl
./rpc/sys_idl/sockbase.idl
./test/rpc/idl/arrayv1_151/arrayv1.h
./test/rpc/idl/arrayv1_151/arrayv1.idl
./test/rpc/idl/arrayv1_151/client.c
./test/rpc/idl/arrayv1_151/client_aux.c
./test/rpc/idl/arrayv1_151/manager.c
./test/rpc/idl/binopwk_151/binopwk.idl
./test/rpc/idl/binopwk_151/client.c
./test/rpc/idl/binopwk_151/client_aux.c
./test/rpc/idl/binopwk_151/manager.c
./test/rpc/idl/orecord_151/client.c
./test/rpc/idl/orecord_151/client_aux.c
./test/rpc/idl/orecord_151/manager.c
./test/rpc/idl/orecord_151/orecord.idl
./test/rpc/idl/sparse_151/client.c
./test/rpc/idl/sparse_151/client_aux.c
./test/rpc/idl/sparse_151/convert.c
./test/rpc/idl/sparse_151/manager.c
./test/rpc/idl/sparse_151/sparse.idl
./test/rpc/idl/string0_151/client.c
./test/rpc/idl/string0_151/client_aux.c
./test/rpc/idl/string0_151/manager.c
./test/rpc/idl/string0_151/string0.idl

[07/15/94 public]
Just a clarification:  the files needed so that the DCE 1.1 endpoint
mapper (i.e., dced) can be built to handle NCS LLB requests have been
moved into the admin/dced tree.



CR Number                     : 7433
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : test/rpc/idl/repas2/manager.c
Short Description             : Pointer used after being freed.
Reported Date                 : 3/5/93
Found in Baseline             : 1.0.1
Found Date                    : 3/5/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : test/rpc/idl/repas2/util_cvt.c
Sensitivity                   : public
DEC has no responsibility to maintain these tests. Please reaasign this CR
to someone within OSF.

[3/5/93 public]

{note, the test code has not been changed since 1.0.1. So it is also a
1.0.2 problem}

Full Description:
        In test/rpc/idl/repas2/manager.c:_xmitas_sum_in_out(...)
        variable 'list' and reused by the following code.

          /* Free the in rep */
        trans_t_free_local(list);
        list->next = NULL;

         ....
            /* Recreate list with a new set of elements */
        l = list;
        for (i = 0; i < num_elems; i++)
        {
         l->value = i * 38;
                ...


        Where trans_t_free_local calls free_list_recursively
        which frees 'list' -
             if (l->next) free_list_recursively(l->next);
             free(l);

	So after calling trans_t_free_local, list is freed and should not
	be referenced again. but
        The list that is freed is getting used in
                manager.c:_xmitas_sum_in_out

Proposed Solution:
        trans_t_free_local(list->next) in _xmitas_sum_in_out()
        instead of trans_t_free_local(list)

[10/1/93 public]

Back in June, as a part of HP-UX reference platform submittion,
trans_t_free_local() was changed to not-free the first element of the list.
Thus, the above proposed solution is not necessary.

[11/12/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 7426
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : test/rpc/idl
Short Description             : Alignment problems in idl tests
Reported Date                 : 3/4/93
Found in Baseline             : 1.0.1
Found Date                    : 3/4/93
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : 
				test/rpc/idl/pipetest2/manager.c
				test/rpc/idl/pipetest2/client_aux.c
				test/rpc/idl/pipetest2_ool/manager.c
				test/rpc/idl/pipetest2_ool/client_aux.c
				test/rpc/idl/pipetest2_cancel/manager.c
				test/rpc/idl/pipetest2_cancel/client_aux.c
Sensitivity                   : public

[3/4/93 public]

(note, these test files have not been changed since 1.0.1, so it is also 
a problem for current 1.0.2 code)

------------------start: defect report from licensee----------------------
Full Description:
        Alignment problems from promotion of byte * to double/float/
        pt2_struct * in
      ( . = test/rpc/idl )
        ./pipetest2/manager.c
        ./pipetest2/client_aux.c
        ./pipetest2_cancel/manager.c
        ./pipetest2_cancel/client_aux.c
        ./pipetest2_ool/manager.c
        ./pipetest2_ool/client_aux.c

        mostly while declaring buffers ( manager_buffer/client_buffer
         ). byte pointers are being used by pipe callbacks as float
        and struct pointers - could leads to alignment problems.

Proposed Solution:

        Declare buffers and align it to double/float/pt2_struct
        eg:
           float client_buffer[howmany(CLIENT_BUFFER_SIZE,sizeof float)];
-------------------end of defect report from licensee---------------------

[03/04/93 public]
My experience with Sparc tells me that this is definitely an
alignment error which will cause core dump. Some systems, like Sparc, have
very strict requirement about alignment.

Also the proposed solution is not good enough for sparc, for the same
reason. On sparc, float * and double * are not the same, let alone the
struct. So to make the code portable, declaring a static array of any type
is not goign to work. Guess w ehave to dynamically allocate the memory.

[06/14/93 public]
DEC does not own responsibility for these tests.
Please assign this CR to someone in OSF.

[10/14/93 public]
Allocate the buffers dynamically both in client_aux.c and manager.c.
Introduced the alloc routines for pipes as needed in the tests.

[11/12/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 7338
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : App Dev Guide
Short Description             : Additional explanation for comm_status and fault_status.
Reported Date                 : 2/23/93
Found in Baseline             : 1.0.1
Found Date                    : 2/23/93
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.0.3
Affected File(s)              : 1
Sensitivity                   : public

[2/23/93 public]

======================================================================

The App Dev Guide discussion about the ACF comm_status and
fault_status in section 18.3.7 needs to have sample C code in the
example. 

We should add this after the ACF and IDL examples on page 18-10: 

server.c
--------

/* 
 * The three server procedures below illustrate the different 
 * models of comm_status and fault_status appearing in the idl 
 * and acf declarations above.  
 * 
 * RPC automatically passes back DCE error codes through 
 * comm_status and fault_status.  These examples differ in their 
 * handling of the non-error case.   
 */
    
error_status_t add (double a, 
                    double b, 
                    double * c)
{
    ...
    *c = answer;

    /* 
     * comm_status and fault_status are operation attributes. If 
     * no error occurs, the client will see the value that the 
     * server returns.    
     * 
     * We return error_status_ok here for the normal successful 
     * case. 
     */
    
    return error_status_ok;
}

double subtract (double a, 
                 double b, 
                 error_status_t * s)
{
    /* 
     * "s" appears in both the idl definition and the acf 
     * specification.  
     * 
     * In the successful case, the client is returned the 
     * value that the server puts in *s.  Therefore, assume
     * success here. 
     */
    
    *s = error_status_ok;

    ...
    return answer;
}

double multiply (double a, 
                 double b, 
                 error_status_t * c_sts, 
	         error_status_t * f_sts)
{
    /* 
     * c_sts and f_sts appear in the acf, but do not appear in 
     * the idl definition.  In this case, c_sts and f_sts are 
     * placed at the end of the parameter list generated by the idl 
     * compiler.  To conform to the prototype generated by idl, 
     * your server code must also declare these parameters.  
     *
     * In the successful case, c_sts and f_sts are automatically 
     * returned to the client as error_status_ok.  Even though 
     * c_sts and f_sts are parameters to the function, the server 
     * code must not modify these parameters or store through 
     * them. 
     */
    
    ...
    return answer;
}

[5/27/93 public]
Assigned to myself.

[06/03/93 public]
Changed to "verified".  Added the sample code in this CR to
the specified section of the App Guide file rpc/10_acf.gpsml.

[08/19/93 public]
Closed bug.



CR Number                     : 7334
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 8041
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : app_gd
Short Description             : statement about TRY block
catching SIGINT signal is not true.
Reported Date                 : 2/23/93
Found in Baseline             : 1.0.1
Found Date                    : 2/23/93
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : /app_gd/rpc/3_build_app.gpsml
Sensitivity                   : public

[2/23/93 public]

At the end of Chapter 11 "Building an Application", it says (for binop
example) the server can be terminated at any time by a quit signal, which
on many systems can be generated by Ctrl-C.  At the end of section 11.4.2,
it states that TRY-CATCH_ALL-ENDTRYT block will actually catch the signals.

This is not true.  At least starting from 1.0.1, CMA threads package does
nothing for asynchronized signals (SIGINT, SIGHUP, etc). It is up to the
sigwait to do it. By default, cma does not catch those signals, nor does it
convert them into exceptions to raise.

cdsclerk is an example to show how to catch async signals to do the
clean-up. It spawns a signal_catcher() thread to especially sigwait on
those async signals. Whne it gets one, it calls the clean-up routine.

Note, the current 1.0.2 doc still states the same thing, although I am not
sure whether it is still chapter 11.

[06/08/93 public]
Changed "Fix By Baseline" field from 1.0.2 to 1.0.3.

[07/06/93 public]
Reassigned this CR to writer Steve Lewontin.

[10/12/93 public]

Removed the TRY block from the sample code and removed the related text.
Having a thread do a sigwait() would be the correct approach here, but
this is beyond the scope of this example which mainly illustrates how to
build a DCE application.  This is more appropriate as an enhancement for
the 1.1 threads documentation.  I have written such a sample handler thread
for use in the 1.1 documentation and will file an enhancement OT.

Also removed the text added to deal with OT 8041.  This proposed a
probably non-portable use of signal() to install a signal handler.  Although 
POSIX is still not settled on this issue, it looks like sigwait() is the
correct way to go.

[10/12/93 public]
There's another problem here in that <ctrl-c> generates an interrupt
signal, not a quit signal.

[11/11/93 public]

Verified change in latest doc build and closed this CR.



CR Number                     : 7320
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 11062
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : [local] opaque pointers should work
Reported Date                 : 2/22/93
Found in Baseline             : 1.0.2
Found Date                    : 2/22/93
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : ./rpc/idl/idl_compiler/astp_cpx.c
./rpc/idl/idl_compiler/checker.c
./rpc/idl/idl_compiler/clihamts.c
./rpc/idl/idl_compiler/irepgen.c
./rpc/idl/idl_compiler/nidlmsg.m
./rpc/idl/idl_compiler/propagat.c
./rpc/idl/idl_compiler/sstubmts.c
Sensitivity                   : public

[2/22/93 public]

It would make our life in security a lot more type-safe if there could be
found some way for the following to work:

    [local] interface {
	typedef struct private_struct *abstract_handle;
    }

Currently, idl requires that it know about all such structs in advance;
however, C does not require this (Yes, I know, IDL is not C, but it
strongly resembles C).

Otherwise, we may need to manually convert our API-level interfaces from
.idl files to .h files to avoid some nasty type aliasing problems.

[07/20/93 public]
After discussion, it is decided that OSF will not make this
enhancement.  However, if Tony Hixnman at DEC is interested in
making this change to idl, we would have no objection.

Tony, could you please comment on this one way or another?
If you say thumbs down, I will cancel.
Thanks.

[07/21/93 public]
No, we (DEC) are not interested in making this change.

[11/09/93 public]
"Move to reconsider."  Perhaps we can do this for 1.1.  I propose something
like this:
	[opaque] struct foo *foo_p;
The opaque attribute, valid only in a [local] interface, means that the
pointer will never be dereferenced.

[02/18/94 public]
Folks at DEC have pointed out that you can probably get the same effect by
using an ACF and [represent_as].

[06/07/94 public]
Well, I needed to do this so here is what I came up with.
In the idl file, x.idl, do this:
	/* [opaque] */
	typedef [ptr] void *hack_XXX_t;
And then write your operations using hack_XXX_t.

Create a header file, call it something like xif.h, that has this:
	/* Declare XXX_t as an opaque handle to my private data. */
	typedef struct XXX_private_data_t *XXX_t;
	#define hack_XXX_t XXX_t
	#include <x.h>
Make sure all code includes xif.h, not x.h

[6/7/94 public]
Rico @ Dec has given me an enhancement to idl that should address this defect.
We are ironing out some small casting-type problems,
so this should be submitted soon (after beta).  
The enhacement is to support opaque context handles.

Here is what Rico says:
 5) Note: These changes should also satisfy CR 7320, "[local] opaque pointers
    should work".  It asked for the capability to do
        typedef struct private_struct *abstract_handle;
    in a [local] interface.  It will work if you do
        typedef [context_handle] struct private_struct *abstract_handle;

[7/23/94 public]
This code has been submitted.



CR Number                     : 7295
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : idl lib
Short Description             : Unmarshalling of Cray big endian format double-precision floating-point
numbers fails on an AIX RS6000 (IEEE big endian ascii native format).
Reported Date                 : 2/19/93
Found in Baseline             : 1.0.2
Found Date                    : 2/19/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : ndrfloat.c
Sensitivity                   : public

[2/19/93 public]

Unmarshalling of Cray big endian format double-precision floating-point
numbers fails on an AIX RS6000 (IEEE big endian ascii native format).

When it is server unmarshalling, the DCE RPC runtime fails, returning 
fault code 0x1c00000f. 

When it is client unmarshalling, the DCE RPC runtime raises the exception
exc_e_fltovf, and the RPC fails.

The data values correspond to 1.1, 4.0, and 0.0. The correct
octet stream order is shown below.

The Cray data, starting with octet #0, is:

0x40 0x1 0x8c 0xcc 0xcc 0xcc 0xcc 0xcd 
0x40 0x3 0x80 0x0 0x0 0x0 0x0 0x0 
0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0

[3/5/93 public]

I am annotating this OT with email from Jerry Harrow.

======================================================================

This is the "ndrfloat.c" Jerry mailed me. I tested it on an rs6000
and it fixed Cray double unmarshalling (server only) but I did NOT
build libdce.so on a pmax so I don't know whether or or it broke
anything on a little endian machine. It did NOT fix IBM double
unmarshalling on a big endian IEEE machine (presumably this bug
exists on an OS/2 machine as well). This fix did NOT appear to fix
client unmarshalling of Cray doubles so CR 7295 can not be closed
(the description may need to be updated).

Subject: RE: double unmarshaling problems

So the problems we have to fix are:

	1) Unmarshalling IBM double on Big Endian IEEE
	2) Unmarshalling CRAY double on Big Endian IEEE

Everything else works, right?

After looking at the code change histories again, there was a change to
UPKIEET.C for OT 5569 that probably caused this.  If we are
that lucky, the following version of ndrfloat.c should
fix everything.  Could you do a test run and let me know
the results.  Thanks.

- - - -Jer


/* ndrfloat.c to test */
/* 19-Feb-93 harrow Fix for OT 7294 & 7295 (Cray & IBM unmarshalling on a Big-endian)
/* 17-Dec-92 harrow Fix IBM->IEEE on OS/2 (OT 5569) */
/* 05-Jun-92 harrow Fix for CRAY->little endian IEEE, big endian VAX, & little endian IBM */
/* 06-May-92 harrow Incorporate floating point conversion fixes for IBM, CRAY, & IEEE */
/*
**  @OSF_COPYRIGHT@
**
**  Copyright (c) 1989, 1990, 1991 by
**      Hewlett-Packard Company, Palo Alto, Ca. &
**      Digital Equipment Corporation, Maynard, Mass.
**
**  NAME:
**
**      ndrfloat.c
**
**  FACILITY:
**
**      IDL Stub Runtime Support
**
**  ABSTRACT:
**
**  NDR floating point conversion routines.
**
**  Currently implemented:
**
**        To  || IEEE | VAX  | Cray | IBM
**      ==============+======+======+======
**   F   IEEE || Yes  | Yes  | Yes  | Yes
**      ------||------+------+------+------
**   r   VAX  || Yes  | Yes  | Yes  | Yes
**      ------||------+------+------+------
**   o   Cray || Yes  | Yes  | Yes  | Yes
**      ------||------+------+------+------
**   m   IBM  || Yes  | Yes  | Yes  | Yes
**
**
**  VERSION: DCE 1.0
**
*/

/*
 * VAX Floating point
 * ------------------
 *
 * VAX has four floating types: F, D, G, and H:
 *
 *     F is 32 bits with a 1-bit sign, an 8-bit exponent field (excess
 *     128), and a 23-bit mantissa representing a fraction in the range
 *     0.5 (inclusive) to 1.0 (exclusive).  (The redundant leading "1"
 *     bit is omitted.)
 *
 *     D is 64 bits with a 1 bit sign, an 8-bit exponent, and a 56-bit
 *     mantissa.
 *
 *     G is 64 bits with a 1 bit sign, an 11-bit exponent (excess 1024),
 *     and a 52-bit mantissa.
 *
 *     H is 128 bits. ...
 *
 *
 * IEEE Floating point
 * -------------------
 *
 * IEEE has two floating types: single and double:
 *
 *     Single is 32 bits with a 1-bit sign, an 8-bit exponent field
 *     (excess 127 = 16#7F), and a 23-bit mantissa representing a fraction
 *     in the range 1.0 (inclusive) to 2.0 (exclusive).  (The redundant,
 *     leading "1" bit is omitted.)
 *
 *                              -38         +38
 *                  range   = 10     ..   10
 *
 *                  MaxReal = 3.402823E+38
 *
 *     Double is 64 bits with a 1-bit sign, an 11-bit exponent field
 *     (excess 1023 = 16#3FF) and a 52-bit mantissa.
 *
 *                                -308        +308
 *                  range     = 10     ..   10
 *
 *                  MaxReal = 1.797693134862316E+308
 *
 * Note that (unlike all other allowed NDR floating point representations)
 * IEEE floating point numbers are generated on machines made by different
 * manufacturers (and with different architectures).  In particular, some
 * of those machines are little-endian (e.g. 80x86) and some are big-endian
 * (e.g. M680x0).  NDR defines that to interpret bytes in a stream tagged
 * as using IEEE floating point numbers, the integer representation tag
 * is used to determine the order of the bytes of the IEEE floating point
 * number.  This means that the bytes are in reverse order if sent from
 * machine that uses little-endian integers as compared to one that uses
 * big-endian integers.
 *
 *
 * CRAY Floating Point
 * -------------------
 *
 *     Cray-1, and X-MP's have one hardware floating-point type:  single.
 *     (95-bit double-precision routines are available in software.)
 *
 *     Single is 64 bits with a 1-bit sign, a 15-bit exponent field
 *     (biased by 16384 = 16#4000), and a 48-bit mantissa representing
 *     a fraction in the range of 0.0 (inclusive) to 1.0 (exclusive).
 *
 *                              -2466       +2466
 *                  range   = 10     ..   10
 *
 *                  MaxReal = 1.2650140831707E+2466  !! not correct !!
 *
 *     A zero value or an underflow result is not biased and is represented
 *     as 64 bits of zero.
 *
 *     An overflow result is represented by an exponent >= 24576 (=16#6000).
 *
 * Conversions
 * -----------
 *
 * NDR defines two floating types: single and double.  NDR defines a set
 * of possible representations of these types:  IEEE, VAX, Cray, IBM.  The
 * correspondences between the NDR types and the representations is shown
 * below:
 *
 *       NDR          IEEE     VAX      CRAY     IBM
 *                 +--------+--------+--------+--------+
 *      Single     | single |   F    | single |        |
 *                 +--------+--------+--------+--------+
 *      Double     | double |   G    | single |        |
 *                 +--------+--------+--------+--------+
 *
 * Note that the original VAX architecture defined only F and D, not G or H.
 * Most VAX compilers seem by default to interpret "double precision float"
 * as meaning D format; however, some compilers have an option telling
 * them to interpret it as G.  G seems to be the more "modern" and "popular"
 * flavor of double so that is why NDR uses it; also G corresponds better to
 * IEEE double.
 *
 * NOTE WELL:  The conversion routines as they currently exist are sure to
 * have bugs in the boundary cases.  Note also that the routines that
 * convert to VAX format are likely to work only on a VAX.
 *
 * The following diagrams show how the various representations appear in
 * an NDR byte stream:

    VAX F Floating
    ==============

        |<---- 8 bits ---->|   byte offset      field size

        +--+---------------+
        |X2|   FRAC1       |        0              1, 7
        +--+---------------+
        |SN|     X1        |        1              1, 7
        +--+---------------+
        |     FRAC3        |        2              8
        +------------------+
        |     FRAC2        |        3              8
        +------------------+

        In terms of the VAX architecture handbook:

                X1    = 8:14
                X2    = 7:7
                SN    = 15:15
                FRAC1 = 0:6
                FRAC2 = 24:31
                FRAC3 = 16:23

        FRACn are the segments of the mantissa.  In increasing order of
        significance they are:  FRAC3, FRAC2, FRAC1.  Xn are the segments
        of the exponent.  In increasing order of significance they are:  X2,
        X1.  SN is the sign bit.


    VAX D Floating (for illustration only)
    ==============

        |<---- 8 bits ---->|   byte offset      field size

        +--+---------------+
        |X2|   FRAC1       |        0              1, 7
        +--+---------------+
        |SN|     X1        |        1              1, 7
        +--+---------------+
        |     FRAC3        |        2              8
        +------------------+
        |     FRAC2        |        3              8
        +------------------+
        |     FRAC5        |        4              8
        +------------------+
        |     FRAC4        |        5              8
        +------------------+
        |     FRAC7        |        6              8
        +------------------+
        |     FRAC6        |        7              8
        +------------------+


    VAX G Floating
    ==============

        |<---- 8 bits ---->|    byte offset     field size

        +--------+---------+
        |   X2   | FRAC1   |        0              4, 4
        +--+-----+---------+
        |SN|     X1        |        1              1, 7
        +--+---------------+
        |     FRAC3        |        2              8
        +------------------+
        |     FRAC2        |        3              8
        +------------------+
        |     FRAC5        |        4              8
        +------------------+
        |     FRAC4        |        5              8
        +------------------+
        |     FRAC7        |        6              8
        +------------------+
        |     FRAC6        |        7              8
        +------------------+



    IEEE single
    ===========

            big-endian                         little-endian

        |<---- 8 bits ---->|                |<---- 8 bits ---->|

        +--+---------------+                +------------------+
        |SN|    X1         |    0           |       F3         |    0
        +--+---------------+                +------------------+
        |X2|      F1       |    1           |       F2         |    1
        +--+---------------+                +--+---------------+
        |       F2         |    2           |X2|      F1       |    2
        +------------------+                +--+---------------+
        |       F3         |    3           |SN|    X1         |    3
        +------------------+                +--+---------------+

    IEEE double
    ===========

            big-endian                         little-endian

        |<---- 8 bits ---->|                |<---- 8 bits ---->|

        +--+---------------+                +------------------+
        |SN|    X1         |    0           |       F7         |    0
        +--+-----+---------+                +------------------+
        |   X2   |   F1    |    1           |       F6         |    1
        +--------+---------+                +------------------+
        |       F2         |    2           |       F5         |    2
        +------------------+                +------------------+
        |       F3         |    3           |       F4         |    3
        +------------------+                +------------------+
        |       F4         |    4           |       F3         |    4
        +------------------+                +------------------+
        |       F5         |    5           |       F2         |    5
        +------------------+                +--+---------------+
        |       F6         |    6           |SN|    X1         |    6
        +------------------+                +--+-----+---------+
        |       F7         |    7           |   X2   |   F1    |    7
        +------------------+                +--------+---------+


    Cray single
    ===========


        |<---- 8 bits ---->|

        +--+---------------+
        |SN|    X1         |    0
        +--+-----+---------+
        |       X2         |    1
        +--------+---------+
        |       F1         |    2
        +------------------+
        |       F2         |    3
        +------------------+
        |       F3         |    4
        +------------------+
        |       F4         |    5
        +------------------+
        |       F5         |    6
        +------------------+
        |       F6         |    7
        +------------------+

 */

#include <cvt.h>
#include <cvt_pvt.h>

/* The ordering of the following 3 includes should NOT be changed! */
#include <dce/rpc.h>
#include <dce/stubbase.h>
#include <lsysdep.h>

#ifndef _KERNEL
#   ifdef __STDC__
#       include <stdlib.h>
#   endif
#endif

#define INTERNAL static
#define PUBLIC

#define IEEE_FLOAT (NDR_LOCAL_FLOAT_REP == ndr_c_float_ieee)
#define VAX_FLOAT  (NDR_LOCAL_FLOAT_REP == ndr_c_float_vax)
#define CRAY_FLOAT (NDR_LOCAL_FLOAT_REP == ndr_c_float_cray)
#define IBM_FLOAT  (NDR_LOCAL_FLOAT_REP == ndr_c_float_ibm)

#define SWAB_64(dst, src) ( \
    (dst)[0] = (src)[7], \
    (dst)[1] = (src)[6], \
    (dst)[2] = (src)[5], \
    (dst)[3] = (src)[4], \
    (dst)[4] = (src)[3], \
    (dst)[5] = (src)[2], \
    (dst)[6] = (src)[1], \
    (dst)[7] = (src)[0]  \
)

#define IBM_SWAB_64(dst, src) ( \
    (dst)[0] = (src)[4], \
    (dst)[1] = (src)[5], \
    (dst)[2] = (src)[6], \
    (dst)[3] = (src)[7], \
    (dst)[4] = (src)[0], \
    (dst)[5] = (src)[1], \
    (dst)[6] = (src)[2], \
    (dst)[7] = (src)[3]  \
)

#ifndef cray

#define SWAB_32(dst, src) ( \
    (dst)[0] = (src)[3], \
    (dst)[1] = (src)[2], \
    (dst)[2] = (src)[1], \
    (dst)[3] = (src)[0]  \
)

#define VAXF_BL_SWAP(dst, src) ( \
    (dst)[0] = (src)[1], \
    (dst)[1] = (src)[0], \
    (dst)[2] = (src)[3], \
    (dst)[3] = (src)[2]  \
)

#define VAXF_BL_SWAP1(dst) ( \
    temp = (dst)[0], \
    (dst)[0] = (dst)[1], \
    (dst)[1] = temp, \
    temp = (dst)[2], \
    (dst)[2] = (dst)[3], \
    (dst)[3] = temp \
)

#else

#define SWAB_32(dst, src) ( \
    (dst)[4] = (src)[7], \
    (dst)[5] = (src)[6], \
    (dst)[6] = (src)[5], \
    (dst)[7] = (src)[4]  \
)

#define VAXF_BL_SWAP(dst, src) ( \
    (dst)[4] = (src)[5], \
    (dst)[5] = (src)[4], \
    (dst)[6] = (src)[7], \
    (dst)[7] = (src)[6]  \
)

#endif

#define VAXG_BL_SWAP(dst, src) ( \
    (dst)[0] = (src)[1], \
    (dst)[1] = (src)[0], \
    (dst)[2] = (src)[3], \
    (dst)[3] = (src)[2], \
    (dst)[4] = (src)[5], \
    (dst)[5] = (src)[4], \
    (dst)[6] = (src)[7], \
    (dst)[7] = (src)[6]  \
)

#define VAXG_BL_SWAP1(dst) ( \
    temp = (dst)[0], \
    (dst)[0] = (dst)[1], \
    (dst)[1] = temp, \
    temp = (dst)[2], \
    (dst)[2] = (dst)[3], \
    (dst)[3] = temp, \
    temp = (dst)[4], \
    (dst)[4] = (dst)[5], \
    (dst)[5] = temp, \
    temp = (dst)[6], \
    (dst)[6] = (dst)[7], \
    (dst)[7] = temp \
)

#define COPY_64(dst, src) ( \
    *(long_float_p_t) (dst) = *(long_float_p_t) (src) \
)

#ifndef cray
#define COPY_32(dst, src) ( \
    *(short_float_p_t) (dst) = *(short_float_p_t) (src) \
)
#endif

/*
**  Floating point conversion routines:  --> IEEE
*/

/*
**
**  Routine:
**
**      cvt_vax_f_to_ieee_single
**
**  Functional Description:
**
**      This routine converts a VAX F_Float floating point number
**      into an IEEE single precision floating point number.
**
**  Formal Parameters:
**
**      input_value     A VAX F_Float floating point number.
**
**      options         An integer bit mask.  Set bits in the mask represent
**                      selected routine options.  Applicable options are:
**
**                           CVT_C_BIG_ENDIAN       - default is little endian
**                           CVT_C_TRUNCATE         - truncate
**                           CVT_C_ROUND_TO_POS     - round to +infinity
**                           CVT_C_ROUND_TO_NEG     - round to -infinity
**                           CVT_C_ROUND_TO_NEAREST - round to nearest
**                           CVT_C_VAX_ROUNDING     - VAX rounding
**
**                      NOTE: If no rounding mode is selected the following
**                      default rounding mode is assumed:
**
**                              CVT_C_ROUND_TO_NEAREST.
**
**                      NOTE2: This routine can not underflow.  The underflow
**                      option may be selected but will be effectively ignored
**                      (not signaled).
**
**      output_value    The IEEE single precision representation of the VAX
**                      F_Float number.
**
**  Side Effects/Signaled Errors:
**
**      exc_e_aritherr            an invalid input value was specified
**      exc_e_fltovf_t          floating point overflow
**      exc_e_fltund_t          floating point underflow
**
*/

#if IEEE_FLOAT || defined(DEBUG)
INTERNAL void cvt_vax_f_to_ieee_single
#ifdef IDL_PROTOTYPES
(
    CVT_VAX_F input_value,
    CVT_SIGNED_INT options,
    CVT_IEEE_SINGLE output_value
)
#else
( input_value, options, output_value )
    CVT_VAX_F input_value;
    CVT_SIGNED_INT options;
    CVT_IEEE_SINGLE output_value;
#endif

{
    int i, round_bit_position;
    UNPACKED_REAL r;

    switch ( options & ~(CVT_C_BIG_ENDIAN | CVT_C_ERR_UNDERFLOW) ) {
        case 0                      : options |= CVT_C_ROUND_TO_NEAREST;
        case CVT_C_ROUND_TO_NEAREST :
        case CVT_C_TRUNCATE         :
        case CVT_C_ROUND_TO_POS     :
        case CVT_C_ROUND_TO_NEG     :
        case CVT_C_VAX_ROUNDING     : break;
        default : RAISE(exc_e_aritherr);
    }

#include <upkvaxf.c>

#include <pkieees.c>

}
#endif

/*
**
**  Routine:
**
**      cvt_vax_g_to_ieee_double
**
**  Functional Description:
**
**      This routine converts a VAX G_Float floating point number
**      into an IEEE double precision floating point number.
**
**  Formal Parameters:
**
**      input_value     A VAX G_Float floating point number.
**
**      options         An integer bit mask.  Set bits in the mask represent
**                      selected routine options.  Applicable options are:
**
**                           CVT_C_BIG_ENDIAN       - default is little endian
**                           CVT_C_ERR_UNDERFLOW    - Raise underflows
**                           CVT_C_TRUNCATE         - truncate
**                           CVT_C_ROUND_TO_POS     - round to +infinity
**                           CVT_C_ROUND_TO_NEG     - round to -infinity
**                           CVT_C_ROUND_TO_NEAREST - round to nearest
**                           CVT_C_VAX_ROUNDING     - VAX rounding
**
**                      NOTE: If no rounding mode is selected the following
**                      default rounding mode is assumed:
**
**                              CVT_C_ROUND_TO_NEAREST.
**
**      output_value    The IEEE double precision representation of the VAX
**                      G_Float number.
**
**  Side Effects/Signaled Errors:
**
**      exc_e_aritherr            an invalid input value was specified
**      exc_e_fltovf_t          floating point overflow
**      exc_e_fltund_t          floating point underflow
**
*/

#if IEEE_FLOAT || defined(DEBUG)
INTERNAL void cvt_vax_g_to_ieee_double
#ifdef IDL_PROTOTYPES
(
    CVT_VAX_G input_value,
    CVT_SIGNED_INT options,
    CVT_IEEE_DOUBLE output_value
)
#else
( input_value, options, output_value )
    CVT_VAX_G input_value;
    CVT_SIGNED_INT options;
    CVT_IEEE_DOUBLE output_value;
#endif

{
    int i, round_bit_position;
    UNPACKED_REAL r;

    switch ( options & ~(CVT_C_BIG_ENDIAN | CVT_C_ERR_UNDERFLOW) ) {
        case 0                      : options |= CVT_C_ROUND_TO_NEAREST;
        case CVT_C_ROUND_TO_NEAREST :
        case CVT_C_TRUNCATE         :
        case CVT_C_ROUND_TO_POS     :
        case CVT_C_ROUND_TO_NEG     :
        case CVT_C_VAX_ROUNDING     : break;
        default : RAISE(exc_e_aritherr);
    }

#include <upkvaxg.c>

#include <pkieeet.c>

}
#endif

/*
**
**  Routine:
**
**      cvt_cray_to_ieee_single
**
**  Functional Description:
**
**      This routine converts a CRAY single precision floating point number
**      into an IEEE single precision floating point number.
**
**  Formal Parameters:
**
**      input_value     A CRAY single precision floating point number.
**
**      options         An integer bit mask.  Set bits in the mask represent
**                      selected routine options.  Applicable options are:
**
**                           CVT_C_BIG_ENDIAN       - default is little endian
**                           CVT_C_ERR_UNDERFLOW    - Raise underflows
**                           CVT_C_TRUNCATE         - truncate
**                           CVT_C_ROUND_TO_POS     - round to +infinity
**                           CVT_C_ROUND_TO_NEG     - round to -infinity
**                           CVT_C_ROUND_TO_NEAREST - round to nearest
**                           CVT_C_VAX_ROUNDING     - VAX rounding
**
**                      NOTE: If no rounding mode is selected the following
**                      default rounding mode is assumed:
**
**                              CVT_C_ROUND_TO_NEAREST.
**
**      output_value    The IEEE single precision representation of the CRAY
**                      number.
**
**  Side Effects/Signaled Errors:
**
**      exc_e_aritherr            an invalid input value was specified
**      exc_e_fltovf_t          floating point overflow
**      exc_e_fltund_t          floating point underflow
**
*/

#if IEEE_FLOAT || defined(DEBUG)
INTERNAL void cvt_cray_to_ieee_single
#ifdef IDL_PROTOTYPES
(
    CVT_CRAY input_value,
    CVT_SIGNED_INT options,
    CVT_IEEE_SINGLE output_value
)
#else
( input_value, options, output_value )
    CVT_CRAY input_value;
    CVT_SIGNED_INT options;
    CVT_IEEE_SINGLE output_value;
#endif

{
    int i, round_bit_position;
    UNPACKED_REAL r;

    switch ( options & ~(CVT_C_BIG_ENDIAN | CVT_C_ERR_UNDERFLOW) ) {
        case 0                      : options |= CVT_C_ROUND_TO_NEAREST;
        case CVT_C_ROUND_TO_NEAREST :
        case CVT_C_TRUNCATE         :
        case CVT_C_ROUND_TO_POS     :
        case CVT_C_ROUND_TO_NEG     :
        case CVT_C_VAX_ROUNDING     : break;
        default : RAISE(exc_e_aritherr);
    }

#include <upkcray.c>

#include <pkieees.c>

}


/*
 * Note 32 bit NDR floats for a cray are represented as IEEE 32 bit values.
 */

/*
 * This routine is not "internal" because cray stubbase.h macros need to invoke
 * it directly.
 */
int ndr_cray64_to_ieee32
#ifdef IDL_PROTOTYPES
(
    unsigned32 *cray_flt,   /* 64 bit entities */
    unsigned32 *ieee_flt
)
#else
(cray_flt, ieee_flt)
    unsigned32 *cray_flt;   /* 64 bit entities */
    unsigned32 *ieee_flt;
#endif

{
    /*
     * Cray does not have a 32 bit floating point format so ndr_short_floats
     * must be represented in 64 bits on Cray.  The Cray floating point value
     * is converted to IEEE single for sending over the wire.  Since the Cray
     * word size is 64 bits, make sure we use the least significant 4 bytes of
     * the 8 byte word to represent the IEEE single.  Convert the IEEE single
     * in Cray's native big-endian format.
     */
    cvt_cray_to_ieee_single((CVT_BYTE *)cray_flt, CVT_C_BIG_ENDIAN,
                            (CVT_BYTE *)(&(((char *)ieee_flt)[4])));
}
#endif

/*
**
**  Routine:
**
**      cvt_cray_to_ieee_double
**
**  Functional Description:
**
**      This routine converts a CRAY single precision floating point number
**      into an IEEE double precision floating point number.
**
**  Formal Parameters:
**
**      input_value     A CRAY single precision floating point number.
**
**      options         An integer bit mask.  Set bits in the mask represent
**                      selected routine options.  Applicable options are:
**
**                           CVT_C_BIG_ENDIAN       - default is little endian
**                           CVT_C_ERR_UNDERFLOW    - Raise underflows
**                           CVT_C_TRUNCATE         - truncate
**                           CVT_C_ROUND_TO_POS     - round to +infinity
**                           CVT_C_ROUND_TO_NEG     - round to -infinity
**                           CVT_C_ROUND_TO_NEAREST - round to nearest
**                           CVT_C_VAX_ROUNDING     - VAX rounding
**
**                      NOTE: If no rounding mode is selected the following
**                      default rounding mode is assumed:
**
**                              CVT_C_ROUND_TO_NEAREST.
**
**      output_value    The IEEE double precision representation of the CRAY
**                      number.
**
**  Side Effects/Signaled Errors:
**
**      exc_e_aritherr            an invalid input value was specified
**      exc_e_fltovf_t          floating point overflow
**      exc_e_fltund_t          floating point underflow
**
*/

#if IEEE_FLOAT || defined(DEBUG)
INTERNAL void cvt_cray_to_ieee_double
#ifdef IDL_PROTOTYPES
(
    CVT_CRAY input_value,
    CVT_SIGNED_INT options,
    CVT_IEEE_DOUBLE output_value
)
#else
( input_value, options, output_value )
    CVT_CRAY input_value;
    CVT_SIGNED_INT options;
    CVT_IEEE_DOUBLE output_value;
#endif

{
    int i, round_bit_position;
    UNPACKED_REAL r;

    switch ( options & ~(CVT_C_BIG_ENDIAN | CVT_C_ERR_UNDERFLOW) ) {
        case 0                      : options |= CVT_C_ROUND_TO_NEAREST;
        case CVT_C_ROUND_TO_NEAREST :
        case CVT_C_TRUNCATE         :
        case CVT_C_ROUND_TO_POS     :
        case CVT_C_ROUND_TO_NEG     :
        case CVT_C_VAX_ROUNDING     : break;
        default : RAISE(exc_e_aritherr);
    }

#include <upkcray.c>

#include <pkieeet.c>

}
#endif

/*
**
**  Routine:
**
**      cvt_ibm_short_to_ieee_single
**
**  Functional Description:
**
**      This routine converts an IBM single precision floating point number
**      into an IEEE single precision floating point number.
**
**  Formal Parameters:
**
**      input_value     An IBM single precision floating point number.
**
**      options         An integer bit mask.  Set bits in the mask represent
**                      selected routine options.  Applicable options are:
**
**                           CVT_C_BIG_ENDIAN       - default is little endian
**                           CVT_C_ERR_UNDERFLOW    - Raise underflows
**                           CVT_C_TRUNCATE         - truncate
**                           CVT_C_ROUND_TO_POS     - round to +infinity
**                           CVT_C_ROUND_TO_NEG     - round to -infinity
**                           CVT_C_ROUND_TO_NEAREST - round to nearest
**                           CVT_C_VAX_ROUNDING     - VAX rounding
**
**                      NOTE: If no rounding mode is selected the following
**                      default rounding mode is assumed:
**
**                              CVT_C_ROUND_TO_NEAREST.
**
**      output_value    The IEEE single precision representation of the IBM
**                      number.
**
**  Side Effects/Signaled Errors:
**
**      exc_e_aritherr            an invalid input value was specified
**      exc_e_fltovf_t          floating point overflow
**      exc_e_fltund_t          floating point underflow
**
*/

#if IEEE_FLOAT || defined(DEBUG)
INTERNAL void cvt_ibm_short_to_ieee_single
#ifdef IDL_PROTOTYPES
(
    CVT_IBM_SHORT input_value,
    CVT_SIGNED_INT options,
    CVT_IEEE_SINGLE output_value
)
#else
( input_value, options, output_value )
    CVT_IBM_SHORT input_value;
    CVT_SIGNED_INT options;
    CVT_IEEE_SINGLE output_value;
#endif

{
    int i, round_bit_position;
    UNPACKED_REAL r;

    switch ( options & ~(CVT_C_BIG_ENDIAN | CVT_C_ERR_UNDERFLOW) ) {
        case 0                      : options |= CVT_C_ROUND_TO_NEAREST;
        case CVT_C_ROUND_TO_NEAREST :
        case CVT_C_TRUNCATE         :
        case CVT_C_ROUND_TO_POS     :
        case CVT_C_ROUND_TO_NEG     :
        case CVT_C_VAX_ROUNDING     : break;
        default : RAISE(exc_e_aritherr);
    }

#include <upkibms.c>

#include <pkieees.c>

}
#endif

/*
**
**  Routine:
**
**      cvt_ibm_long_to_ieee_double
**
**  Functional Description:
**
**      This routine converts an IBM double precision floating point number
**      into an IEEE double precision floating point number.
**
**  Formal Parameters:
**
**      input_value     An IBM double precision floating point number.
**
**      options         An integer bit mask.  Set bits in the mask represent
**                      selected routine options.  Applicable options are:
**
**                           CVT_C_BIG_ENDIAN       - default is little endian
**                           CVT_C_TRUNCATE         - truncate
**                           CVT_C_ROUND_TO_POS     - round to +infinity
**                           CVT_C_ROUND_TO_NEG     - round to -infinity
**                           CVT_C_ROUND_TO_NEAREST - round to nearest
**                           CVT_C_VAX_ROUNDING     - VAX rounding
**
**                      NOTE: If no rounding mode is selected the following
**                      default rounding mode is assumed:
**
**                              CVT_C_ROUND_TO_NEAREST.
**
**                      NOTE2: This routine can not underflow.  The underflow
**                      option may be selected but will be effectively ignored
**                      (not signaled).
**
**      output_value    The IEEE double precision representation of the IBM
**                      number.
**
**  Side Effects/Signaled Errors:
**
**      exc_e_aritherr            an invalid input value was specified
**      exc_e_fltovf_t          floating point overflow
**      exc_e_fltund_t          floating point underflow
**
*/

#if IEEE_FLOAT || defined(DEBUG)
INTERNAL void cvt_ibm_long_to_ieee_double
#ifdef IDL_PROTOTYPES
(
    CVT_IBM_LONG input_value,
    CVT_SIGNED_INT options,
    CVT_IEEE_DOUBLE output_value
)
#else
( input_value, options, output_value )
    CVT_IBM_LONG input_value;
    CVT_SIGNED_INT options;
    CVT_IEEE_DOUBLE output_value;
#endif

{
    int i, round_bit_position;
    UNPACKED_REAL r;

    switch ( options & ~(CVT_C_BIG_ENDIAN | CVT_C_ERR_UNDERFLOW) ) {
        case 0                      : options |= CVT_C_ROUND_TO_NEAREST;
        case CVT_C_ROUND_TO_NEAREST :
        case CVT_C_TRUNCATE         :
        case CVT_C_ROUND_TO_POS     :
        case CVT_C_ROUND_TO_NEG     :
        case CVT_C_VAX_ROUNDING     : break;
        default : RAISE(exc_e_aritherr);
    }

#include <upkibml.c>

#include <pkieeet.c>

}
#endif

/*
**  Floating point conversion routines:  --> VAX
*/

/*
**
**  Routine:
**
**      cvt_ieee_single_to_vax_f
**
**  Functional Description:
**
**      This routine converts an IEEE single precision floating point number
**      into a VAX F_Float floating point number.
**
**  Formal Parameters:
**
**      input_value     An IEEE single precision floating point number.
**
**      options         An integer bit mask.  Set bits in the mask represent
**                      selected routine options.  Applicable options are:
**
**                           CVT_C_BIG_ENDIAN       - default is little endian
**                           CVT_C_ERR_UNDERFLOW    - Raise underflows
**
**                      NOTE: This routine does not require rounding and
**                      underflow is not possible.  Both options may be selected
**                      but will be effectively ignored (not signaled).
**
**      output_value    The VAX F_Float representation of the IEEE number.
**
**  Side Effects/Signaled Errors:
**
**      exc_e_aritherr            an invalid input value was specified,
**                              or the result is +infinity or -infinity
**      exc_e_fltovf_t          floating point overflow
**      exc_e_fltund_t          floating point underflow
**
*/

#if VAX_FLOAT || defined(DEBUG)
INTERNAL void cvt_ieee_single_to_vax_f
#ifdef IDL_PROTOTYPES
(
    CVT_IEEE_SINGLE input_value,
    CVT_SIGNED_INT options,
    CVT_VAX_F output_value
)
#else
( input_value, options, output_value )
    CVT_IEEE_SINGLE input_value;
    CVT_SIGNED_INT options;
    CVT_VAX_F output_value;
#endif

{
    int i, round_bit_position;
    UNPACKED_REAL r;

    switch ( options & ~(CVT_C_BIG_ENDIAN | CVT_C_ERR_UNDERFLOW) ) {
        case 0                      : options |= CVT_C_VAX_ROUNDING;
        case CVT_C_ROUND_TO_NEAREST :
        case CVT_C_TRUNCATE         :
        case CVT_C_ROUND_TO_POS     :
        case CVT_C_ROUND_TO_NEG     :
        case CVT_C_VAX_ROUNDING     : break;
        default : RAISE(exc_e_aritherr);
    }

#include <upkieees.c>

#include <pkvaxf.c>

}
#endif

/*
**
**  Routine:
**
**      cvt_ieee_double_to_vax_g
**
**  Functional Description:
**
**      This routine converts an IEEE double precision floating point number
**      into a VAX G_Float floating point number.
**
**  Formal Parameters:
**
**      input_value     An IEEE double precision floating point number.
**
**      options         An integer bit mask.  Set bits in the mask represent
**                      selected routine options.  Applicable options are:
**
**                           CVT_C_BIG_ENDIAN       - default is little endian
**                           CVT_C_ERR_UNDERFLOW    - Raise underflows
**
**                      NOTE: This routine does not require rounding.  A
**                      rounding option may be selected but will be effectively
**                      ignored (not signaled).
**
**      output_value    The VAX G_Float representation of the IEEE number.
**
**  Side Effects/Signaled Errors:
**
**      exc_e_aritherr            an invalid input value was specified,
**                      [tom 10/20/93 public]
This isn't going to make 1.0.3, defering to 1.1.

[10/26/93 public]
This failure has also been observed on hppa (the VTS port to hppa is 
being completed at this time).

This may not deserve as high a priority as CR 7294, however, because it is 
Cray's strategy to use IEEE float format in its DCE implementation, at
least until this bug is fixed (at least that's my understanding of it).

[01/24/94 public]
Assigned to Rico @ DEC.  

Please fix ASAP.  Aged defect.

[03/23/94 public]
Visual inspection shows the fix is in. Should run the VTS against it in
DCE 1.1 timeframe.

bdiff -r 1.1.6.2 ndrfloat.c 
===================================================================
RCS file: ./rpc/idl/lib/ndrfloat.c,v
retrieving revision 1.1.6.2
diff -r1.1.6.2 /u0/rcs_trees/dce/rcs/#odexm028845/ndrfloat.c
10a11,20
>  * Revision 1.1.9.2  1994/02/16  20:29:38  rico
>  *    Really enter previous fix for unmarshalling of CRAY big-endian format
>  *    double-precision floating-point numbers on AIX RS6000 and HPUX.
>  *    [1994/02/16  20:29:01  rico]
>  *
>  * Revision 1.1.9.1  1994/02/11  13:52:34  rico
>  *    Fix for unmarshalling of IBM big-endian format double-precision
>  *    floating-point numbers on AIX RS6000 and HPUX.
>  *    [1994/02/09  20:37:39  rico]
>  * 
14c24
<  *
---
>  * 
2403a2414,2415
> #if !(defined(_IBMR2) && defined(_AIX)) && \
>     !(defined(__hppa) && defined(__hpux))
2409a2422
> #endif



CR Number                     : 7294
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : idl lib
Short Description             : Unmarshalling of IBM big endian format double-precision floating-point
numbers fails on an AIX RS6000 (IEEE big endian ascii native format).
Reported Date                 : 2/19/93
Found in Baseline             : 1.0.2
Found Date                    : 2/19/93
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : upkibml.c
Sensitivity                   : public

[2/19/93 public]

Unmarshalling of IBM big endian format double-precision floating-point
numbers fails on an AIX RS6000 (IEEE big endian ascii native format).

When it is server unmarshalling, the DCE RPC runtime fails, returning 
fault code 0x1c00000f. 

When it is client unmarshalling, the DCE RPC runtime raises the exception
exc_e_aritherr, and the RPC fails.

The data values correspond to 1.1, 4.0, and 0.0. The correct
octet stream order is shown below.

The IBM data, starting with octet #0, is:

0x99 0x99 0x99 0x9a 0x41 0x11 0x99 0x99  
0x0 0x0 0x0 0x0 0x41 0x40 0x0 0x0 
0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 

Note:
When the test is modified to reverse the 32-bit word order in the 
octet stream, the unmarshaling works, returning the expected values. 
That is to say, instead of sending the octets in the correct order 
- 1-2-3-4-5-6-7-8 - they are sent in this order - 5-6-7-8-1-2-3-4.

[10/20/93 public]
This isn't going to make 1.0.3, defered to 1.1.

[10/26/93 public]
This failure has also been observed on hppa (the VTS port to hppa is being
completed at this time).

[01/24/94 public]
Assigned to Rico @ DEC.  

Have you guys been able to fix this yet?
I would like to get this and 7295 fixed *early* in 1.1 since it
was a P1 back in 1.0.3.

[03/23/94 public]
Visual inspection shows the fix is there. Should run the VTS against it in
DCE 1.1 timeframe as well.

nitro 67 % bdiff -r 1.1.6.2 upkibml.c
===================================================================
RCS file: ./rpc/idl/lib/upkibml.c,v
retrieving revision 1.1.6.2
diff -r1.1.6.2 /u0/rcs_trees/dce/rcs/#odexm028856/upkibml.c
10a11,20
>  * Revision 1.1.8.2  1994/02/16  20:31:45  rico
>  *    Really enter previous fix for unmarshalling of IBM big-endian format
>  *    double-precision floating-point numbers on AIX RS6000 and HPUX.
>  *    [1994/02/16  20:31:19  rico]
>  *
>  * Revision 1.1.8.1  1994/02/11  13:54:30  rico
>  *    Fix for unmarshalling of IBM big-endian format double-precision
>  *    floating-point numbers on AIX RS6000 and HPUX.
>  *    [1994/02/09  20:40:12  rico]
>  * 
14c24
<  *
---
>  * 
92a103,111
> #if (defined(_IBMR2) && defined(_AIX)) || \
>     (defined(__hppa) && defined(__hpux))
>         {
>         idl_ulong_int tmp;
>         tmp = r[1];
>         r[1] = r[2];
>         r[2] = tmp;
>         }
> #endif
nitro 68 %



CR Number                     : 7267
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : test
Short Description             : 
rpc_server_use_all_protseqs_if() does not detect invalid protocols
Reported Date                 : 2/17/93
Found in Baseline             : 1.0.2b15
Found Date                    : 2/17/93
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/runtime/comif.c
Sensitivity                   : public

[2/17/93 public]


When an invalid ifspec (contains an invalid endpoint vector element protocol
that is greater than 31 characters) is passed to the routine
rpc_server_use_all_protseqs_if(), it incorrectly returns rpc_s_ok
instead of an error code which would indicate that the protocol is invalid.

The actual call is:

        rpc_if_rep_p_t  loc_if_rep_pt;
        unsigned32      max_calls = 10;

        static rpc_endpoint_vector_elt_t BAD_name_of_endpoint[1] =
        {
           (unsigned_char_p_t)"THIS_NAME_IS_GREATER_THAN_32_CHARACTERS_LONG",
           (unsigned_char_p_t)"2002",
        };

        loc_if_rep_pt = (rpc_if_rep_p_t) comtest_ifspec;
        loc_if_rep_pt->endpoint_vector.endpoint_vector_elt =
                                               BAD_name_of_endpoint;
        loc_if_rep_pt->endpoint_vector.count = 1;

        rpc_server_use_all_protseqs_if(max_calls,comtest_ifspec,&status);

The cause of the appears to be in the rpc_server_use_all_protseqs_if() code
listed below:

    /*
     * For each valid protocol sequence, see if the ifspec has an endpoint
     * for it.  If it does, try to create a socket based on it.
     */
    for (i = 0; i < psvp->count; i++)
    {
        pseq_id = rpc__network_pseq_id_from_pseq (psvp->protseq[i], status);

        if (*status != rpc_s_ok)
        {
            break;
        }

        rpc__if_inq_endpoint ((rpc_if_rep_p_t) ifspec_h, pseq_id, 
            &endpoint, status);                                   

        if (*status == rpc_s_endpoint_not_found)                  
        {                                                         
            *status = rpc_s_ok;                                   
            continue;                                             
        }                                                         
        if (*status != rpc_s_ok)
        {
            break;
        }

rpc_server_use_protseq_ep (psvp->protseq[i], max_calls, endpoint, status);

        rpc_string_free (&endpoint, &my_status);

        if (*status != rpc_s_ok)
        {
            break;

        }
    }

    /*
     * Something's got to be done here to see if there were any
     * errors registering the valid protocol sequences.  If there
     * were any errors, we should de-register the ones registered,
     * free the vector and return an error.
     */

    /*
     * Now free the protocol sequence vector.
     */
    rpc_protseq_vector_free (&psvp, &my_status);

The routine rpc__if_inq_endpoint() will return rpc_s_endpoint_not_found status
when ifspec_h containing an invalid endpoint protocol is passed to it, but the
if condition following that function call intercepts the status and modifies it
to rpc_s_ok thus, eliminating any trace of the invalid protocol.  The if
condition then transfers control back to the for loop to handle the next valid
protocol vector item.  Continuing this proccess until the for loop ends, status
will be rpc_s_ok, which is not the intention.  To fix that, the if condition
should stop overwriting the status, and error checking is needed after the for
loop.  The code would be:

    /*
     * For each valid protocol sequence, see if the ifspec has an endpoint
     * for it.  If it does, try to create a socket based on it.
     */
    for (i = 0; i < psvp->count; i++)
    {
        pseq_id = rpc__network_pseq_id_from_pseq (psvp->protseq[i], status);

        if (*status != rpc_s_ok)
        {
            break;
        }

        rpc__if_inq_endpoint ((rpc_if_rep_p_t) ifspec_h, pseq_id,
            &endpoint, status);

        if (*status == rpc_s_endpoint_not_found)
        {
            continue;                            /* no more overwriting */
        }
        if (*status != rpc_s_ok)
        {
            break;
        }

        rpc_server_use_protseq_ep (psvp->protseq[i], max_calls, endpoint, status
);

        rpc_string_free (&endpoint, &my_status);

        if (*status != rpc_s_ok)
        {
            break;
        }
    }


    /*
     * check if the ifspec had an endpoint to any of the valid protocol sequence
s
     */

    if (*status == rpc_s_endpoint_not_found)
    {
       *status = rpc_s_invalid_rpc_protseq;    /* for example */
    }

The rpc_s_invalid_rpc_protseq status return code is used for the sake of the
argument.

[9/17/93 public]

The real problem is in rpc__if_inq_endpoint()/comif.c, which does not check
the returned status from rpc__network_pseq_if_from_pseq().
rpc__if_inq_endpoint() should return the failed status to the caller.

[9/28/93 public]

The fix was submitted to 1.0.3.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 7257
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : test
Short Description             : ep_unregister test fails to return rpc_s_invalid_binding
Reported Date                 : 2/17/93
Found in Baseline             : 1.0.2b15
Found Date                    : 2/17/93
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/runtime/comep.c
Sensitivity                   : public

[2/17/93 public]

The function rpc_ep_unregister in comep.c does not return the error code
rpc_s_invalid_binding.  Similar code in the function ep_register checks
the endpoint and returns the rpc_s_invalid_binding if the check is false.

code in rpc_ep_unregister:

 for (i = 0; i < binding_vec->count; i++)
    {
        if (binding_vec->binding_h[i] != NULL)
            break;
    }

similar code in ep_register:

 curr_hand = binding_vec->count;
    for (i = 0; i < binding_vec->count; i++)
    {
        if (binding_vec->binding_h[i] != NULL)
        {
            if (((rpc_binding_rep_p_t) binding_vec->binding_h[i])
                ->addr_has_endpoint == false)
            {
                *status = rpc_s_invalid_binding;
                return;
            }

            curr_hand = i;
        }

    }

[9/20/93 public]

None of the documents explicitly states that fully bound binding vectors
must be passed, or states that partially bound binding vectors are illegal.
(Though AES says that call rpc_server_inq_bindings() before unregistering
them.) But on the other hand unregistering the endpoints without specifying
them doesn't make sense (unless someone tells me that a partially bound
binding is a wildcard). I'll take the above suggested fix.

[9/28/93 public]

The fix was submitted to 1.0.3.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 7255
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : test
Short Description             : rpc_ns_group_mbr_inq_begin returns incorrect status.
Reported Date                 : 2/17/93
Found in Baseline             : 1.0.2b15
Found Date                    : 2/17/93
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.2
Affected File(s)              : runtime/nsp.h
Sensitivity                   : public

[2/17/93 public]

When an invalid member name syntax is passed to rpc_ns_group_mbr_inq_begin(),
it returns rpc_s_ok instead of the expected rpc_s_invalid_name_syntax, and when 
an unsupported member name syntax is passed, it returns rpc_s_ok instead of the 
expected rpc_s_unsupported_name_syntax.  The reason for that is the routine 
rpc_ns_group_mbr_inq_begin() does no error checking on the member name syntax, 
which is wrong.  

In the code below, extracted from rpc_ns_group_mbr_inq_begin() :

    /*
     * Resolve the member name syntax
     */

    new_member_name_syntax = member_name_syntax;
    RPC_RESOLVE_SYNTAX (new_member_name_syntax, status);
    if (*status != rpc_s_ok)
    {
        rpc__nsentry_free (&nsgroup_name, &internal_status);
        return;
    }

    /*
     * Create the inquire context and set the
     * member name syntax field within.
     */
    inq = rpc__inqcntx_create
            (nsgroup_name, rpc_e_group_member, status);

    inq->member_name_syntax = new_member_name_syntax;

the above line copies the member name syntax whether it is valid or not; to fix
the problem the routine rpc__ns_check_name_syntax() should be called with the
member name syntax to check for its validity and the code should look like this:

    /*
     * Resolve the member name syntax
     */

    new_member_name_syntax = member_name_syntax;
    RPC_RESOLVE_SYNTAX (new_member_name_syntax, status);
    if (*status != rpc_s_ok)
    {
        rpc__nsentry_free (&nsgroup_name, &internal_status);
        return;
    }

    /*
     * The code below, does the necessary checking on the
     * member name syntax
     */

    if (!(rpc__ns_check_name_syntax (new_member_name_syntax, status)))
    {
        rpc__nsentry_free (&nsgroup_name, &internal_status);
        return;
    }


    /*
     * Create the inquire context and set the
     * member name syntax field within.
     */
    inq = rpc__inqcntx_create
            (nsgroup_name, rpc_e_group_member, status);
    inq->member_name_syntax = new_member_name_syntax;

[08/04/93 public]
Taking a look at this one.
Suggested fix sounds reasonable

[08/04/93 public]
Upon investigation it turns out this was fixed in the RPC_RESOLVE_SYNTAX()
macro a while ago.  From src/runtime/nsp.h:

 * Revision 1.1.4.2  1992/11/05  16:37:56  grace
 * 28-sep-92    gh      Add rpc__ns_check_name_syntax() for checking name
 *                      syntax in both RPC_RESOLVE_SYNTAX and
 *                      RPC_RESOLVE_NAME_AND_SYNTAX macros.
 *      [1992/11/05  15:26:53  grace]

So the change suggested above for nsgroup.c is not needed.

Closing this bug.



CR Number                     : 7252
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : test
Short Description             : rpc_server_unregister_if() returns incorrect status
Reported Date                 : 2/17/93
Found in Baseline             : 1.0.2b15
Found Date                    : 2/17/93
Severity                      : C
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : comif.c
Sensitivity                   : public

[2/17/93 public]

rpc_server_unregister_if() returns the incorrect status 0 instead of the
expected rpc_s_unknown_if when an invalid rpc_if_handle_t is passed.  The 
cause of the error lies in the runtime routine rpc__server_unregister_if_int() 
found in "comif.c"; in which a variable is initialized at the top as follows:

    *rtn_ifspec_h = NULL;

the routine should check whether this variable changed or not before it exits,
if it did not change, the desired rpc_s_unknown_if error code should be
returned.  The code that does the checking:

    if (rtn_ifspec_h == NULL)               /*<<<<<< WRONG */
    {
       RPC_MUTEX_UNLOCK (if_mutex);
       *status = rpc_s_unknown_if;
       return;
    }

is incorrect, and should be replaced with the following:

    if (*rtn_ifspec_h == NULL)              /*<<<<<< RIGHT, added '*' */
    {
       RPC_MUTEX_UNLOCK (if_mutex);
       *status = rpc_s_unknown_if;
       return;
    }

[04/01/94 public]
Somewhere along the line, this defect got fixed.
Closed.



CR Number                     : 7240
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : doc
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : app_gd
Short Description             : change L&S to e.g. LandS
Reported Date                 : 2/17/93
Found in Baseline             : 1.0.1
Found Date                    : 2/17/93
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/figures/6_nsi_usage_07.ps
Sensitivity                   : public

[2/17/93 public]
This comment is from Norbert Leser at OSF.  In Figure 7 of the
chapter on Name Service Interface Usage, he requests that the 3
instances of "L&S" be changed to, for example, "LandS".  I think
this is because the & is not a legal name character.  I would
go in and change it myself but it's a postscript file so I can't.
The corresponding DEC figure file is pictures/rpc-model-service-sharing.ps.

[06/10/93 public]
Changed "Fix By Baseline" field from 1.0.2 to 1.0.3.

[11/05/93]
Changed L&S to LandS in figure 6_nsi_usage_07.ps.

[07/29/93 public]
Reassigned this CR to Diana Goldfarb, after converting it from a
code bug to a doc bug.

[11/12/93 public]

Verified change to this figure in the latest doc build
and closed this bug. Unfortunately, the figure that
follows this one (6_nsi_usage_08.ps) needs the same
changes. I will file a new CR for this defect.



CR Number                     : 7224
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : 
Short Description             : No semantic checking for a named type of void in a param type
Reported Date                 : 2/15/93
Found in Baseline             : 1.0.2b15
Found Date                    : 2/15/93
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/idl/idl_compiler/checker.c
Sensitivity                   : public

[2/15/93 public]

Full Description:

        When a typedef void * named type is used with the parameter
        attributes in and ptr, the back end of the IDL compiler
        outputs an internal error from line 122 of
        rpc/idl/idl_compiler/nodesupp.c.

Repeat By:

        Run the IDL compiler with the following IDL file (replace first two
exclaimation marks with open and close bracket characters).

!
uuid(e14c2d82-54e8-11ca-952f-10005aa8abef),
version(1.0)
!
interface test
{
typedef void *void_t ;
void problem
(
    [in] handle_t     h,
    [in,ptr] void_t  *s
);
}

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 7174
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : test
Short Description             : rpc_ep_unregister doesn't return ept_s_cant_access error
Reported Date                 : 2/9/93
Found in Baseline             : 1.0.2b14
Found Date                    : 2/9/93
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/rpcd/rpcdepdb.c
                                             rpc/runtime/comep.c
                                             test/rpc/rtandidl/moretests/mgmt_ep_elt_inq.c
Sensitivity                   : public

[2/9/93 public]

A test case in ep_unregister.tsh tries to receive the error ept_s_cant_access
by successfully registering an endpoint, then successfully unregistering it,
and trying to unregister the endpoint again.  The second successive call
to rpc_ep_unregister returns rpc_s_ok instead of an error.  As the code is
now, one can continually unregister the same endpoint and receive the rpc_s_ok
return code.

[9/16/93 public]

I can't find the ep_unregister.tsh in the rtandidl test. This must be IBM's
test case. However, I did verify that rpc_ep_unregister() succeeds with the
previously unregistered endpoint. The problem actually lives in RPCD.
epdb_delete()/rpcdepdb.c returns the rpc_s_ok status when there is no
matching entry or it's already marked as deleted.

[9/16/93 public]

Returning the ept_s_invalid_entry status, instead of ept_s_cant_access,
seems to be more appropriate because it doesn't exist in the database.

[9/17/93 public]

I don't think either of these is appropriate.  From rpc.msg:

   ept_s_cant_access               cannot access endpoint database
   #_explanation:
   #_ The endpoint mapper cannot open the existing database file which holds
   #_ the endpoint map.

   ept_s_invalid_entry             invalid endpoint entry
   #_explanation:
   #_ An entry supplied to the endpoint mapper as input contains invalid data;
   #_ for example, an invalid tower.

I think the one we want to use is: 

   ept_s_not_registered            not registered in endpoint map
   #_explanation:
   #_ An entry supplied as input to a remote call to the endpoint mapper
   #_ (for example, for deletion) does not exist in the endpoint map.

I don't know why the word "remote" is in there, but it needs to be
removed.

[9/28/93 public]

Fixing this defect broke the rtandidl's mgmt_ep_elt_inq.tsh. The cleanup
phase of the test unregisters the endpoints which aren't registered and
gets the error status. I have the fix for the test, but it led me to
believe that we might break the existing servers.

Without the fix, rpcd (almost) always returns the rpc_s_ok status to
rpc_ep_unregister(). So the server can simply call
rpc_server_inq_bindings() followed by rpc_ep_unregister() even if all or
some of endpoints are not registered. That's not true any more with the
fix. The server will see the error status returned from rpc_ep_unregister()
if one (or some) of the endpoints is not registered by the server, the
other instance of the server replaces the endpoint, or someone removes it
by calling rpc_mgmt_ep_unregister() (rpccp remove mapping).

Still, I believe that this fix is the right thing to do. Here are our
arguments to implement this:

1) The server expecting the current behavior is simply broken. It should
not unregister endpoints which it didn't register.

2) The server should remember which endpoints it registered and use that
list to unregister endpoints. (Or use rpc_mgmt_ep_elt_inq_*(), though there
is a window where the endpoint map may change.)

3) If the server receives the ept_s_not_registered status, either it should
simply ignore it (hey it's not there, I'm done.), or be nervous about it.
(If the endpoint was registered by the server and someone replaced/removed
it, then the server has not been able to serve the clients.)

4) There could be an application which benefits from this returned status,
e.g., I, the server, registered the endpoint but couldn't unregister it
because of the ept_s_not_registered, let's register it again to replace the
other. (Well, this can be done by rpc_mgmt_*().)

Along with the fix in rpcd, rpc_ep_unregister() needs to be fixed so that
it will continue the iteration when it sees the ept_s_not_registered error
and will remove everything else, then reports the error status.

[9/30/93 public]

Submitted.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 7164
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : test
Short Description             : rpc_ep_register does not check for a NULL if_spec.
Reported Date                 : 2/8/93
Found in Baseline             : 1.0.2b12
Found Date                    : 2/8/93
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/runtime/comep.c
                                             rpc/runtime/comtwr.c
Sensitivity                   : public

[2/8/93 public]

The failed test occurs from a test case in ep_unregister.tsh passing a null
if_spec.  In the runtime code comep.c, the function rpc_ep_register calls
ep_register, which in turn calls rpc__tower_ref_vec_from_binding in
comtwrref.c.  The function rpc__tower_ref_vec_from_binding has the
following for loop:

    /*
     * Create the towers for the remaining transfer syntaxes
     * in the interface specification.
     */
    if_syntax_id++;
    for (i=1; i < if_spec->syntax_vector.count;
         i++, if_syntax_id++, (*tower_vector)->count++)
    {

It uses if_spec without checking whether it is null.

[9/15/93 public]

This problem exists not only in rpc_ep_register() but also in
rpc_ep_unregister() and rpc_tower_vector_from_binding(). We can return the
rpc_s_no_interfaces status if ifspec == NULL (just like
rpc_mgmt_ep_unregister()). But none of the documentation (man page & AES)
is clear about if the NULL ifspec can be registered into the endpoint map.
(If it's allowed, the DG forwarding will break.) Unless I hear an
objection, I'll fix these routines to return the rpc_s_no_interfaces
status.

[9/28/93 public]

The fix was submitted to 1.0.3.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 6849
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : remove all references to
rpc_if_register_auth_info from the code, in rpc.h and rpc.idl
Reported Date                 : 1/14/93
Found in Baseline             : 1.0.2
Found Date                    : 1/14/93
Severity                      : E
Priority                      : 4
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : rpc.idl
Sensitivity                   : public

[1/14/93 public]

This is a follow up on  CR 5731. There, it is said that references
to rpc_ss_register_auth_info and  rpc_if_register_auth_info were 
removed from the documentation because they are not supported. 
However, rpc.h and rpc.idl still contain entries for 
rpc_if_register_auth_info. They should be deleted.

This is just for completeness and clean up. Believe it or not, some
people get confused by continuing to see the entry in the code.

[5/18/94 public]
Removed the definition from rpc.idl
Submitted.



CR Number                     : 6744
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : runtime/RIOS/ipnaf_sys.c
Short Description             : point2point interface 1st causes problem
Reported Date                 : 1/6/93
Found in Baseline             : 1.0.1b6
Found Date                    : 1/6/93
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.2
Fixed In Baseline             : 1.0.2
Affected File(s)              : rpc/runtime/RIOS/ipnaf_sys.c
Sensitivity                   : public

[1/6/93 public]
PROBLEM:

Sec_clientd won't configure if the first adapter in an RS/6000 is a point to
point interface.  The error message displayed is as follows:

      sec_clientd 11/09/92 14:54:53 - Unable to register override interface
      ... communications failure (dce / rpc)

ANALYSIS:

When a server starts it typically makes a call to one of the rpc_server_use_
protseq() routines followed by a call to rpc_server_inq_bindings().  These two
calls together effectively return a cross product of (1) what protocol
sequences you supplied to rpc_server_use_protseq() and (2) what network
interfaces your machine supports.  This cross product is the list of bindings
that your server will accept RPCs on.  If a machine has two network cards, a
token ring and a 370 channel adapter, and wants to use the ncadg_ip_udp
protocol sequence the following bindings would be produced by making the above
two RPC API calls:

        ncadg_ip_udp:<tr0 netaddr>[]
        ncadg_ip_udp:<ca0 netaddr>[]

The next step for a server is to register it's interface(s) with the runtime
and the rpcd.  The API for registering endpoints is rpc_ep_register().  This
routine is supplied a vector of bindings that the server is going to listen
on.  This is where the problem we are seeing occurs.  rpc_ep_register() uses
one of the bindings it is supplied with to communicate with the local rpcd.  If
it picks one that it can't communicate with the rpcd over it fails.  Since the
370 channel adapter is a point-to-point type device it can't be used to
communicate with the local rpcd.  The documentation states that
rpc_ep_register() uses "one" of the bindings supplied but from looking at the
code one can see that it uses the first binding in the list, if this happens to
be the channel adapter you're out of luck.  This explains why moving the
channel adapter to the end of the list allows DCE to configure.

SOLUTION:

One solution would be to remove point to point adapters from the list.
Even though DCE is not supported over SL/IP or the 370 channel adapter (yet),
I can foresee a customer wanting to connect two cells on two different LANs
via a SL/IP or channel adapter interface.

I suggest simply placing all point to point interfaces at the end of the list
of bindings.  This can easily be done in enumerate_interfaces() which frees the
user from having to configure their interfaces in the "right order".

The performance hit is negligable, one pointer-to-pointer swap per point to
point adapter in the machine.

Here is the context diff of rpc/runtime/RIOS/ipnaf_sys.c

< CURRENT
> PROPOSED

199a200,202
> #ifdef AIX_PROD /* CMVC 3687 */
>     int                     nptp=0,stop,cnt;
> #endif
355a359,371
> #ifdef AIX_PROD /* CMVC 3687 */
>       /*
>       ** Put point-to-point interfaces at the end of the list.
>       */
>
>       if (if_flags & IFF_POINTOPOINT) {
>         (*rpc_addr_vec)->addrs[n_ifs-1-nptp++] = (rpc_addr_p_t) ip_addr;
>       } else {
>         (*rpc_addr_vec)->addrs[(*rpc_addr_vec)->len++] = (rpc_addr_p_t) ip_add
r;
>       }
> #else
356a373
> #endif
357a375,393
> #ifdef AIX_PROD /* CMVC 3687 */
>     /*
>     ** Shuffle point to point entries from end of list into empty slots in
>     ** middle, if there are any.
>     */
>
>     cnt = (*rpc_addr_vec)->len;
>     if ((n_ifs - (cnt + nptp)) < nptp)
>       stop = n_ifs - (cnt + nptp);
>     else
>       stop = nptp;
>     stop += cnt;
>
>     for (i = cnt, nptp = n_ifs - 1; i < stop; i++) {
>       (*rpc_addr_vec)->addrs[i] = (*rpc_addr_vec)->addrs[nptp];
>       (*rpc_addr_vec)->addrs[nptp--] = NULL;
>     }
> #endif

[08/03/93 public]
Looks like this code made it in to the source tree in time for 1.0.2:
 * HISTORY
 * Revision 1.1.4.4  1993/02/03  16:11:04  paul
 *      Modified enumerate_interfaces() to add point to point entries to end of
 *      interface list.
 *      [1993/02/03  16:10:16  paul]

Bug closed.



CR Number                     : 6706
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : IDL compiler
Short Description             : idl can't find ACF if multiple '.''s in IDL file name
Reported Date                 : 12/30/92
Found in Baseline             : 1.0.2b5
Found Date                    : 11/07/92
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : frontend.c
Sensitivity                   : public

[12/30/92 public]
If you name an idl file with multiple '.''s in the name (a' la rpc.sec.2.idl)
then the IDL compiler will not find a corresponding .acf even if one
exists.  This should not be so.  (In case anyone was wondering, this is why
the .idl and .acf file for the src/test/systest/rpc/rpc.sec.2 system test
are named rpc_sec_2.idl and .acf).  

[ Disclaimer: this may be a dup.  I have been holding this defect with the
  intent of checking to see if it was already entered, but the schedule being
  what it is, I have no time.
]

[01/04/93 public]
Fixed component:  was threads, should have been (and now is :-) ) rpc.

[09/30/93 public]
This was fixed in the 1.0.3 IDL compiler as it was delivered to OSF.
It's just been pointed out to me that the CR was left open.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 6701
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 6698
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : memory leaks
Reported Date                 : 12/30/92
Found in Baseline             : 1.0.1
Found Date                    : 12/30/92
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : New IDL compiler
Sensitivity                   : public
The new IDL compiler uses a different scheme for managing its marshalling
buffers.
Transarc Deltas               : 
Transarc Herder               : mason@transarc.com
Transarc Status               : open

[12/30/92 public]

I noticed this problem while trying to debug a problem with
the "define cached server" command that was failing with 
an "invalid bound" error (refer to CR #6698).

The function rpc_ss_marsh_change_buff() calls malloc() to allocate
some memory, and it depends upon rpc_call_transmit() to free it.
However, there are situations whereby, an exception can be raised
between the allocation and the call to rpc_call_transmit(), resulting
in the memory not being freed at all.

Specifically, the op2_ssr() in cds_server_sstub.c() calls
cds_FullName_tOme() which is defined in cds_types_saux.c.
cds_Full_Name_tOme() calls rpc_ss_marsh_change_buff(). The parameters
passed to the rpc_ss_marsh_change_buff() are derived from out
parameters that the server manager functions initialize.
In this case, the server manager function (cds_SolicitServer_s)
did not initialize its out parameters. The result was that 
rpc_ss_marsh_change_buff() allocated a huge chunk of memory. 
Eventually cds_FullName_tOme() raised the rpc_x_invalid_bound exception, 
and the memory allocated by rpc_ss_marsh_change_buff() was never freed.
Added field Transarc Deltas with value `' 
Added field Transarc Herder with value `mason@transarc.com' 
Added field Transarc Status with value `open'

Whilst the memory that is leaking is allocated by libidl, the underlying
problem is that the code generated by the back end of the compiler needs
to retain more information about what storage is allocated.
For this reason I am re-assigning this defect.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 6333
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : mgmt_stop_server_listening
 and binding_server_to_client test
Short Description             : Return code of rpc_mgmt_is_server_listening changed in soruce code.  Need to update the test to reflec the change.
Reported Date                 : 12/4/92
Found in Baseline             : 1.0.2
Found Date                    : 12/4/92
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.2
Affected File(s)              : 
	./test/rpc/rtandidl/moretests/binding_server_to_client.c
	./test/rpc/rtandidl/moretests/mgmt_stop_server_listening.c
Sensitivity                   : public

[12/4/92 public]
Need to update the expected return status of rpc_mgmt_is_server_listening
to reflect the change in the rpc code.

[08/03/93 public]
Looks like Sue already fixed this in 1.0.2.
Closed.



CR Number                     : 6224
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : dg runtime
Short Description             : Failure to check for uuid_create() failures
Reported Date                 : 11/30/92
Found in Baseline             : 1.0.1
Found Date                    : 11/30/92
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : dgcct.c,dgclive.c
Sensitivity                   : public

[11/30/92 public]

It appears that when a system is mis-configured in such a way as to make
uuid_create() fail (e.g., wrong mode for /dev/lan0 on HP-UX), the error
return status of uuid_create() is not always being detected.  (I'm pretty
sure the error condition _is_ being indicated.)  As a result, a bogus (and
likely to be duplicate UUID) is used and strange symptoms result, with the
real cause being obscured.  The RPC code should be vetted for proper
checking for uuid_create() failures.

[1/7/93 public]
Promoted to enhancement.

[5/19/94 public]
Found two places in DG code where uuid_create's return value wasn't
checked and added the following code:
      uuid_create(&rpc_g_dg_my_cas_uuid, &st); 
+     if (st != rpc_s_ok)
+     {
+         DIE(("(rpc__dg_maintain_init) Can't create uuid"));
+     }



CR Number                     : 5458
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : idl_compiler
Short Description             : idl test arrayptr fails if the
host system does not support PACKED_SCALER_ARRAYS.
Reported Date                 : 9/24/92
Found in Baseline             : 1.0.1
Found Date                    : 9/24/92
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : New IDL compiler
Sensitivity                   : public

[9/24/92 public]

This is an Interoperability problem.


Full Description:

We have found a problem with the IDL compiler code for non-UNIX
systems.  The idl test in directory rpc/idl/arrayptr fails if the host
system does not support PACKED_SCALAR_ARRAYS. The case is a non-NULL
pointer to an array of shorts.
	
The problem is in the routine IDL_anon_0_mc in the client 'C; stub
generated by the IDL compiler. It uses the wrong variable for the size
of the array. It uses the last argument passed in (IDL_B_0) for the
size if PACKED_SCALAR_ARRAYS are defined. However, if this is not
supported then IDL_count_0 is used. IDL_count_0 is only set if
NIDL_varying  true. In these test case it is false.
	
	
	if (NIDL_varying)
	{
	rpc_marshall_ulong_int(mp, IDL_A_0);
	rpc_advance_mop(mp, op, 4);
	rpc_marshall_ulong_int(mp, IDL_B_0);
	rpc_advance_mop(mp, op, 4);
	IDL_count_0 = IDL_B_0;
	if (IDL_count_0 > IDL_size_0) RAISE(rpc_x_invalid_bound);
	}
	
	#ifdef PACKED_SCALAR_ARRAYS
	memcpy((char *)mp, (char *)&(*p_node)[IDL_A_0], IDL_B_0*2);
	rpc_advance_mop(mp, op, IDL_B_0*2);
	#else
	IDL_element_0 = &(*p_node)[IDL_A_0];
	for (IDL_index_0 = IDL_count_0; IDL_index_0; IDL_index_0--)
	{
	rpc_marshall_short_int(mp, (*IDL_element_0));
	rpc_advance_mop(mp, op, 2);
	IDL_element_0++;
	}
	#endif

[11/12/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 4954
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : Stub won't compile for out-of-line applied to array of [ref] pointers
Reported Date                 : 8/7/92
Found in Baseline             : 1.0.1
Found Date                    : 8/7/92
Severity                      : B
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : New IDL compiler
Sensitivity                   : public

[8/7/92 public]

Problem may be reproduced with the test ./test/rpc/idl/arrayswith by
making the following modifications:  

	1) Change pointer_default(ptr) to pointer_default(ref) in the idl file.

	2) Add the following ACF file.

	arrayswith.acf:
		[out_of_line] interface arrayswith{}

Errors are as follows:

build
relative path: ./test/rpc/idl/arrayswith.
cd ../../../../../obj/pmax/test/rpc/idl/arrayswith
exec make MAKEFILE_PASS=FIRST  _SUBMAKE_=_IS_SUBMAKE_  build_all
exec make MAKEFILE_PASS=FIRSTA  _SUBMAKE_=_IS_SUBMAKE_  build_all
exec make MAKEFILE_PASS=FIRSTB  _SUBMAKE_=_IS_SUBMAKE_  build_all
exec make MAKEFILE_PASS=THIRD  _SUBMAKE_=_IS_SUBMAKE_  build_all
exec make MAKEFILE_PASS=BASIC  _SUBMAKE_=_IS_SUBMAKE_  build_all
/project/dce/build/dce1.0.1/tools/pmax/bin/idl ../../../../../../src/test/rpc/idl/arrayswith/arrayswit
h.idl -cpp_cmd "cpp"     -no_cpp -keep both -no_mepv -v -cc_opt "-D_BSD "  -I. -I/sbox/idl/harrow/dce1
01/src/test/rpc/idl/arrayswith -I/project/dce/build/groupsb/src/test/rpc/idl/arrayswith -I/project/dce
/build/dce1.0.1/src/test/rpc/idl/arrayswith -I.. -I/sbox/idl/harrow/dce101/src/test/rpc/idl -I/project
/dce/build/groupsb/src/test/rpc/idl -I/project/dce/build/dce1.0.1/src/test/rpc/idl -I/sbox/idl/harrow/
dce101/export/pmax/usr/include -I/project/dce/build/groupsb/export/pmax/usr/include -I/usr/include -cc
_cmd "/usr/bin/cc -c"
Importing IDL file /project/dce/build/groupsb/export/pmax/usr/include/dce/nbase.idl
Processing attribute configuration file /sbox/idl/harrow/dce101/src/test/rpc/idl/arrayswith/arrayswith
.acf
/project/dce/build/dce1.0.1/tools/pmax/bin/idl: File ../../../../../../src/test/rpc/idl/arrayswith/arr
ayswith.idl, line 41:     );
Warning: The attributes [max_is,length_is] or [size_is,last_is] used together
/project/dce/build/dce1.0.1/tools/pmax/bin/idl: File ../../../../../../src/test/rpc/idl/arrayswith/arr
ayswith.idl, line 74:         [size_is(s_d),first_is(f_d),last_is(l_d)]double *y_d[];
Warning: The attributes [max_is,length_is] or [size_is,last_is] used together
Creating include file arrayswith.h
Creating stub module arrayswith_cstub.c
Creating stub module arrayswith_sstub.c
Creating stub module arrayswith_caux.c
Creating stub module arrayswith_saux.c
Compiling stub module /usr/bin/cc -c -D_BSD   -I. -I. -I/sbox/idl/harrow/dce101/src/test/rpc/idl/array
swith -I/project/dce/build/groupsb/src/test/rpc/idl/arrayswith -I/project/dce/build/dce1.0.1/src/test/
rpc/idl/arrayswith -I.. -I/sbox/idl/harrow/dce101/src/test/rpc/idl -I/project/dce/build/groupsb/src/te
st/rpc/idl -I/project/dce/build/dce1.0.1/src/test/rpc/idl -I/sbox/idl/harrow/dce101/export/pmax/usr/in
clude -I/project/dce/build/groupsb/export/pmax/usr/include -I/usr/include -I/usr/include  arrayswith_c
stub.c
Compiling stub module /usr/bin/cc -c -D_BSD   -I. -I. -I/sbox/idl/harrow/dce101/src/test/rpc/idl/array
swith -I/project/dce/build/groupsb/src/test/rpc/idl/arrayswith -I/project/dce/build/dce1.0.1/src/test/
rpc/idl/arrayswith -I.. -I/sbox/idl/harrow/dce101/src/test/rpc/idl -I/project/dce/build/groupsb/src/te
st/rpc/idl -I/project/dce/build/dce1.0.1/src/test/rpc/idl -I/sbox/idl/harrow/dce101/export/pmax/usr/in
clude -I/project/dce/build/groupsb/export/pmax/usr/include -I/usr/include -I/usr/include  arrayswith_s
stub.c
cfe: Error: arrayswith_sstub.c, line 1287: Syntax Error
   for ( = 0; ; --)
 --------^
cfe: Error: arrayswith_sstub.c, line 1287: Syntax Error
   for ( = 0; ; --)
 -----------------^
*** Error code 3

[3/1/93 public]

I've been tearing my hair out over this one.  The problem comes down to the flattened parameter 
list for the operation in question.  The code in flatten.c correctly sets up the list as three 
array headers followed by three ref_pass array parameters.  This list, left by itself will generate
correct code.  However, when out-of-line is turned on, additional processing is done on the 
flattened parameter list that incorrectly munges the list.  I've tried three different fixes for this, but
the fixes always break another test.

I'm afraid this problem doesn't have an easy fix.  The list munging code works fine for arrays of ref
pointers by themselves, and for out of line code by itself, but clearly the two cases were not intended
to work together.  I think fixing this problem will require a design level change, and I don't think 
we should be doing that at this stage.

Furthermore, I think this is a fairly obscure case (a pointer to a struct of arrays of pointers with
ool turned on).  Everything works fine when marshalling code is generated inline.  Any chance we
can defer this one?

[3/9/93 public]
Brad asked me to defer this one.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 4897
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : ool outpipe of base type
string causes _caux.c undeclared variable NIDL_varying
Reported Date                 : 7/30/92
Found in Baseline             : 1.0.1b25
Found Date                    : 7/30/92
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : New IDL compiler
Sensitivity                   : public

[7/30/92 public]

ool outpipe of base type string causes _caux.c undeclared variable
NIDL_varying

Compiling stub module xlc_r -c -Dunix -D_ALL_SOURCE   -I. -I.
-I/home/page/beach
/misc_tests/src/test/rpc/idl/ptest_nishino
-I/project/dce/build/dce.30e/src/test
/rpc/idl/ptest_nishino -I.. -I/home/page/beach/misc_tests/src/test/rpc/idl
-I/pr
oject/dce/build/dce.30e/src/test/rpc/idl
-I/home/page/beach/misc_tests/export/ri
os/usr/include -I/project/dce/build/dce.30e/export/rios/usr/include
-I/usr/inclu
de  xxx_ptest_caux.c
"xxx_ptest_caux.c", line 162.5: 1506-045 (S) Undeclared identifier
NIDL_varying.



----------------------------- xxx_ptest.idl ---------------------------
/*
 *      xxx_ptest.idl
 */

 [uuid(007AE09A-0CD1-1A42-9FEB-10005AA81C45),version(1.0),
endpoint("ncadg_ip_udp:[35002]")]

interface xxx_ptest
{
        typedef [string] char   ElementType[32];
        typedef pipe ElementType        statpipe_t;
        typedef [handle] long my_handle;

        void    xxx_ptest_do(
                [in] handle_t                   h,
                [out] statpipe_t                statpipe,
                [out] error_status_t            *status
        );
}

----------------------------- xxx_ptest.acf ---------------------------
/*
 *      xxx_ptest.acf
 */

 [implicit_handle( my_handle i_h )] interface xxx_ptest
{
        xxx_ptest_do([comm_status, fault_status] status);
        typedef [out_of_line] statpipe_t;
}

[page 1/7/93 public]  

We (IBM) have a fix for this - I'll get the diff into this OT today or
tomorrow.

[1/8/93 public]

Fix from IBM

IDL Fix Report
==============

defect  : 2249
abstract: ool outpipe of base type string causes _caux.c undeclared
variable 
          NIDL_varying
problem due to:
   An out-of-line unmarshalling routine for pipe is generated by 
   CSPELL_unmarshall_out_pipe in outpipes.c with a prototype different from

   the ool unmarshalling routines for other data types, due to the fact
that
   a pipe cannot have arbitrarily constructed element type.

   CSPELL_unmarshall_out_pipe invokes a general array unmarshalling routine
   generator at some point where it encounters array elements. However
there 
   is no information passed to indicate that a special case (pipe) is being

   dealed with.
   The array routine generator therefore as usual generates NIDL_varying
check
   statements, which is not supposed to exist in this special case. 

solution:
   BE_M_OOL_RTN flag is set in CSPELL_unmarshall_ou_pipe in outpipes.c
   to indicate that a pipe ool routine is under construction. This flag is 
   passed to and used by BE_spell_array_unmarshall in munmarsh.c to inhibit

   the generation of NIDL_varing check.
   Other three accompanying flags BE_M_PIPE, BE_M_CALLER,
BE_M_BUFFER_EXISTS 
   are used to help screen all cases, to prevent the situation that
BE_M_OOL_RTN
   used for other unawared purpose which now may errornously inhibit the 
   generation of NIDL_varying check.

Test:
   Comparison made on the caux files for the paticular example that has the
   problem.
   This IDL is no tested against IDL backend suite due to environmental
problem 
   we have.


Diffs (two files)

*** munmarsh.c  Fri Jan  8 11:23:26 1993
--- .munmarsh.c Fri Jan  8 11:20:16 1993
***************
*** 504,513 ****
       * conditional since the routine can also be called to unmarshall a
       * non-varying instance of the array type.
       */
! /* if generating ool pipe routine, do not spell 'NIDL_varying' check */
!     if ((flags & BE_M_NODE) && !(BE_PI_Flags(param) & BE_FIELD) &&
!         !((flags & BE_M_OOL_RTN) && (flags & BE_M_PIPE) &&
!           (flags & BE_M_CALLER) && (flags & BE_M_BUFF_EXISTS)))
          fprintf(fid, "if (NIDL_varying)\n{\n");
  
      /*
--- 504,510 ----
       * conditional since the routine can also be called to unmarshall a
       * non-varying instance of the array type.
       */
!     if ((flags & BE_M_NODE) && !(BE_PI_Flags(param) & BE_FIELD))
          fprintf(fid, "if (NIDL_varying)\n{\n");
  
      /*
***************
*** 594,603 ****
                            BE_get_name(BE_Array_Info(param)->count_var));
      }
  
! /* if generating ool pipe routine, do not spell 'NIDL_varying' check */
!     if ((flags & BE_M_NODE) && !(BE_PI_Flags(param) & BE_FIELD) &&
!         !((flags & BE_M_OOL_RTN) && (flags & BE_M_PIPE) &&
!           (flags & BE_M_CALLER) && (flags & BE_M_BUFF_EXISTS)))
      {
          /* Initialize the local A,B,count vars for the fixed array case.
*/
          fprintf(fid, "}\nelse\n{\n");
--- 591,597 ----
                            BE_get_name(BE_Array_Info(param)->count_var));
      }
  
!     if ((flags & BE_M_NODE) && !(BE_PI_Flags(param) & BE_FIELD))
      {
          /* Initialize the local A,B,count vars for the fixed array case.
*/
          fprintf(fid, "}\nelse\n{\n");
***************
*** 1073,1081 ****
      elt_flags = BE_M_ENOUGH_ROOM | BE_M_ADVANCE_MP |
          (flags &
              (BE_M_MAINTAIN_OP | BE_M_CONVERT | BE_M_DEFER | BE_M_NODE |
!              /* also copy BE_M_OOL_RTN */
!              BE_M_PIPE | BE_M_BUFF_EXISTS | BE_M_CALLER | BE_M_CALLEE
!              | BE_M_OOL_RTN));
      /*
       * Unmarshall an array element
       */
--- 1067,1073 ----
      elt_flags = BE_M_ENOUGH_ROOM | BE_M_ADVANCE_MP |
          (flags &
              (BE_M_MAINTAIN_OP | BE_M_CONVERT | BE_M_DEFER | BE_M_NODE |
!              BE_M_PIPE | BE_M_BUFF_EXISTS | BE_M_CALLER | BE_M_CALLEE));
      /*
       * Unmarshall an array element
       */
***************
*** 1120,1128 ****
              elt_flags = BE_M_CHECK_BUFFER | BE_M_ADVANCE_MP |
BE_M_BUFF_BOOL |
                  (flags &
                      (BE_M_MAINTAIN_OP | BE_M_CONVERT | BE_M_DEFER |
BE_M_NODE 
|
!                      /* also copy BE_M_OOL_RTN */
!                      BE_M_PIPE | BE_M_BUFF_EXISTS | BE_M_CALLER |
BE_M_CALLEE
!                      | BE_M_OOL_RTN));
  
              for (elt = BE_Array_Info(param)->flat_elt; elt; elt =
elt->next)
              {
--- 1112,1118 ----
              elt_flags = BE_M_CHECK_BUFFER | BE_M_ADVANCE_MP |
BE_M_BUFF_BOOL |
                  (flags &
                      (BE_M_MAINTAIN_OP | BE_M_CONVERT | BE_M_DEFER |
BE_M_NODE 
|
!                      BE_M_PIPE | BE_M_BUFF_EXISTS | BE_M_CALLER |
BE_M_CALLEE)
);
  
              for (elt = BE_Array_Info(param)->flat_elt; elt; elt =
elt->next)
              {

********************************************************************************
********************************************************************************
********************************************************************************


*** outpipes.c  Fri Jan  8 11:24:27 1993
--- .outpipes.c Fri Jan  8 11:20:17 1993
***************
*** 331,342 ****
  
          /* Unmarshall with matching dreps */
          BE_unmarshall_param(fid, flattened_type,
!         /*
!          * not to generate NIDL_varying check when do_ool is TRUE,
!          * use BE_M_OOL_RTN to carry this information to the later stages
!          */
!             ( do_ool  ? (BE_M_NODE | BE_M_BUFF_EXISTS | BE_M_OOL_RTN) : 0
) |
!             BE_M_CALLER |
              BE_M_CHECK_BUFFER | BE_M_ALIGN_MP | BE_M_PIPE,
              &pipe_marshalling_names, p_routine_mode);
          fprintf(fid, "}\nelse\n");
--- 320,326 ----
  
          /* Unmarshall with matching dreps */
          BE_unmarshall_param(fid, flattened_type,
!             ( do_ool  ? (BE_M_NODE | BE_M_BUFF_EXISTS) : 0 ) |
BE_M_CALLER |
              BE_M_CHECK_BUFFER | BE_M_ALIGN_MP | BE_M_PIPE,
              &pipe_marshalling_names, p_routine_mode);
          fprintf(fid, "}\nelse\n");
***************
*** 345,356 ****
      /* Unmarshall with differing dreps */
      fprintf(fid, "{\n");
      BE_unmarshall_param(fid, flattened_type,
!     /*
!      * not to generate NIDL_varying check when do_ool is TRUE,
!      * use BE_M_OOL_RTN to carry this information to the later stages
!      */
!         ( do_ool  ? (BE_M_NODE | BE_M_BUFF_EXISTS | BE_M_OOL_RTN) : 0 ) |
!         BE_M_CALLER |
          BE_M_CHECK_BUFFER | BE_M_CONVERT | BE_M_ALIGN_MP | BE_M_PIPE,
          &pipe_marshalling_names, p_routine_mode);
      fprintf(fid, "}\n");
--- 329,335 ----
      /* Unmarshall with differing dreps */
      fprintf(fid, "{\n");
      BE_unmarshall_param(fid, flattened_type,
!         ( do_ool  ? (BE_M_NODE | BE_M_BUFF_EXISTS) : 0 ) | BE_M_CALLER |
          BE_M_CHECK_BUFFER | BE_M_CONVERT | BE_M_ALIGN_MP | BE_M_PIPE,
          &pipe_marshalling_names, p_routine_mode);
      fprintf(fid, "}\n");

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 4464
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : src/rpc/idl/idl_compiler
Short Description             : function prototypes missing in
cstubgen.c sstubgen.c clihandl.c
Reported Date                 : 6/25/92
Found in Baseline             : 1.0.1b19
Found Date                    : 6/25/92
Severity                      : E
Priority                      : 4
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.0.3
Affected File(s)              : New IDL compiler
Sensitivity                   : public

[6/25/92 public]

I am entering this in OT to be considered when working on enhancements. -Martha DasSarma

Full Description:

During compilation of the IDL source code for AS/400, warnings were
generated due to missing function prototype declarations.  This
implies non-ANSI code (portability problem) in these files.  Due to
the strict ANSI compliance on AS/400, these warnings would potentially
cause problems when running the IDL compiler.

     files:                  missing function prototypes
     ========                ===========================
     cstubgen.c                BE_spell_end_unmarshall()
     sstubgen.c                BE_spell_end_unmarshall()
     clihandl.c              BE_spell_end_unmarshall()
(a simple fix: add  #include < mumarsh.h>)

       idlparse.c            yywhere()
       acf_lex_yy.c          acf_yyback(), acf_yylook(), acf_yywrap()
       acf_y_tab.c           yylex()
(a simple fix: declare the function protypes in the corresponding
 yacc files)

The problems in cstubgen.c,sstubgen.c,clihandl.c need fixing.
The others appear to be a problem with IBM's version of lex.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 4463
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : src/rpc/idl/idl_compiler
Short Description             : function prototypes are not
defined properly in error.h and checker.c
Reported Date                 : 6/25/92
Found in Baseline             : 1.0.1b19
Found Date                    : 6/25/92
Severity                      : E
Priority                      : 4
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.0.3
Affected File(s)              : New IDL compiler
Sensitivity                   : public

[6/25/92 public]

I am entering this in OT to be considered as an enhancement. - Martha DasSarma

Full Description:

The following function prototypes are not defined properly (ANSI
standard).

 File:               Functions              Scope
 =====               =========              =====
 erros.h             error()                global
                     warning()              global
                     log_source_error()     global
                     log_source_warning()   global
                     log_error()            global
                     log_warning()          global

 checker.h           CHECKER_error()        static
                     CHECKER_warning()      static
                     CHECKER_acf_error()    static
                     CHECKER_acf_warning()  static

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 3931
Defect or Enhancement?        : def
CR in Code, Doc, or Test?     : test
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : test
Short Description             : move "standard definitions" from test/rpc/rpc.mk to test/test.mk
Reported Date                 : 5/30/92
Found in Baseline             : 1.0.1b17
Found Date                    : 5/30/92
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : test/test.mk
Sensitivity                   : public

[5/30/92 public]
(Orbit 1225)

test/test.mk needs standard definitions to convert machine specific flags
to flags (e.g. RIOS_CFLAGS to CFLAGS) so they show up on the cc line.
Since they are already in test/rpc/rpc.mk, move them from there.

Also standard target-specific definitions.

[6/30/92 public]
Reassigned to RPC New World Leader.

[07/02/92 public]
Lowered priority to C2 -- everything builds this is not a P1 bug --
and removed the Responsible Engineer.

[12/29/92 public]

Changed to a 1.1 code cleanup.

[08/03/93 public]
Everything seems to work as is.  
What the bug is here is unclear.
Canceled.

[08/03/93 public]
These lines appear in test/rpc/rpc.mk
 
  #
  # Defaults for standard definitions.  These may be overriden in some RPC
  # test makefiles.
  #
 
  CFLAGS  ?= ${${TARGET_MACHINE}_CFLAGS}
  YFLAGS  ?= ${${TARGET_MACHINE}_YFLAGS}
  LIBS    ?= ${LIBS_DCE} ${${TARGET_MACHINE}_LIBS}

and allow the use of machine specific flags in the test/rpc component. If 
they were moved to test/test.mk, all test components could use machine
specific flags, without respecifying the assignments.  For example, in
test/directory/cds/Makefile, these lines appear

  RIOS_LIBS= -lm -lbsd
  LIBS     = -ldce ${${TARGET_MACHINE}_LIBS}

These sort of assignments appear in the component specific .mks (e.g., 
src/rpc/rpc.mk) in the source tree, but there is no .mk analogous to
test/test.mk in that branch.

So, I think there is a cleanup issue for 1.1.  Consistency between
makefiles would be an asset to porters.

[08/03/93 public]
Ok, I'll fix it.

[08/03/93 public]
Added the following to test.mk:
CFLAGS          ?= ${${TARGET_MACHINE}_CFLAGS}
LDFLAGS         ?= ${${TARGET_MACHINE}_LDFLAGS}
YFLAGS          ?= ${${TARGET_MACHINE}_YFLAGS}
LIBS            ?= ${LIBS_DCE} ${${TARGET_MACHINE}_LIBS}

removed the following from test/rpc/rpc.mk:
CFLAGS  ?= ${${TARGET_MACHINE}_CFLAGS}
YFLAGS  ?= ${${TARGET_MACHINE}_YFLAGS}
LIBS    ?= ${LIBS_DCE} ${${TARGET_MACHINE}_LIBS}

closed.



CR Number                     : 3926
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 10004
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : 
Short Description             : make uuid__get_os_address a public function and export its prototype
Reported Date                 : 5/29/92
Found in Baseline             : 1.0.1b16
Found Date                    : 5/29/92
Severity                      : D
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1b14
Affected File(s)              : runtime/uuid*
Sensitivity                   : public

[5/29/92 public]
Make uuid__get_os_address() a public API call and move its prototype
(currently in uuidp.h) to a file that is exported. This will allow
cds to replace its own code by calling this function.

[6/23/94 public]
As part of the new utils library (see OT 10004) the routine dce_get_802_addr
was added.  We now call this in uuid.c instead of uuid__get_os_address.

Also, cleaned up uuidsys.c to be in the runtime directory,
with platforms (such as SVR4) who need to can copy it with mods into
the machine specific directory.



CR Number                     : 3190
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : 
Short Description             : The way to resolve RAD-50 component code is codepage dependant; a porting issue.
Reported Date                 : 4/30/92
Found in Baseline             : 1.0
Found Date                    : 4/30/92
Severity                      : C
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : dce_error.c
Sensitivity                   : public

[4/30/92 public]

Full Description:

        In dce_error_inq_text routine, the component code portion
        of the error status is decoded using a mathematical formula.
        After the component code is decomposed into three numbers,
        these numbers are individually added to 'a' to come up
        with three characters that represent the component.  A second
        part of the calculation deals with characters that are
        outside of the 'a'-'z' range.  The characters are then
        concatenated with "dce" in the front and ".cat" in the
        back to come up with a catalog name like "dcerpc.cat".
        In cases where the component code contains non-alphabetical
        characters, the code added '21' hopping to come out with
        characters like '/', '0'-'9'...etc which is how ASCII
        code page encoded the characters.

        The method of adding offsets to characters has made the
        code non-portable to EBCDIC systems.  The wrong
        assumption that the code has made is that the code page
        contains characters that are contiguous and that they
        are offset the same way.  E.g. the 10th character "j"
        is not encoded as  character "a" offset by 10 when
        one examines the byte value.  An even more incorrect
        assumption is that the codepage is ASCII.

Repeat By:

        This is a coding practice / portability problem only.

Proposed Solution:

        It is more preferable to bypass the calculation of component
        names and simply use some lookup method to locate a
        component.  E.g. define "dce_rpc" as  0X6C9A and if component
        code is "dce_rpc" (which is 0x6C9A) then use "dcerpc.cat"
        as the catalog name.  Alternately, one may define an
        array of character arrays containing the components and
        then use the index of the array as a means to point to
        the characters "rpc".

[06/23/92 public]
We don't support anything other than ASCII, so I made this an unhancement.

[07/25/93 public]
Fixed in 1.1; will be closed when 1.1 tree opens.
Done as part of 1.1 SVC code.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 2457
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : pmax
S/W Ref Platform              : osf1
Component Name                : rpc
Subcomponent Name             : idl
Short Description             : RPCs w/ full ptr params prohibitively slow
Reported Date                 : 3/30/92
Found in Baseline             : 1.0.1
Found Date                    : 3/30/92
Severity                      : C
Priority                      : 1
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.0.3
Affected File(s)              : New IDL compiler
Sensitivity                   : public

[01/01/93 public]
[unique] pointers are implemented in the new IDL compiler



CR Number                     : 2306
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : all
S/W Ref Platform              : all
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rpc should handle large security credentials (PACs)
Reported Date                 : 3/16/92
Found in Baseline             : 1.0
Found Date                    : 3/16/92
Severity                      : B
Priority                      : 3
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.1
Affected File(s)              : many
Sensitivity                   : public

[3/16/92 public]

        Enter the name of your cell: ppppppppppppppppppppppppppppppppppppppppppppppppppppppp
pppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp
ppppppppppppp
                creating /krb5/krb.conf file...
                adding kerberos entry to /etc/services ...
                ensure rpcd is running...
        The Cell Administrator's principal name is: cell_admin
Enter keyseed for initial database master key: 
                start secd...
SECD Incomplete NSI registration; task sleeping for 60 seconds
                start sec_clientd...
Current site is: registry server at /.../ppppppppppppppppppppppppppppppppppppppppppppppppppp
pppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp
ppppppppppppppppp 
Domain changed to: group
?(rgy_edit) Unable to add group "acct-admin" - unknown reject (dce / rpc)
?(rgy_edit) Unable to add group "subsys/dce/sec-admin" - Registry server unavailable (Regist
ry Edit Kernel) (dce / sad)

NOTE: The security server does not communicate with rgy_edit. dce_login works fine
      even though a view on the server fails. The server stub code rs_pgo_sstub.c
      is not entered (function op4_ssr()) when an add is done in rgy_edit.

[3/19/92 public]

reassigned burati as the responsible engineer as suggested by Carolyn Francisco
(frisco@apollo.hp.com)

[3/26/92 public]

Changed severity to "B" - this is a feature failure that limits the length
of cell/principal names.

The problem here is that the authentication call back in the RPC runtime
does not run a full (multi-packet) RPC call.  It is limited to a single
packet (so about 1K of data).  The CO protocol is limited to about the 
same amount of data since the authentication information is transmitted
during connection setup.

Roughly speaking the callback needs about 200 bytes for non-authentication
data (header info and other arguments).  This leaves about 800 bytes for
the authentication info.

Rough (back of the envelope) calculations show that authentication info
requires the following amount of space:

	244 + 2(CR + CP) + SR + SP + 20(NGR) bytes

where CR is the size of encoding the Client realm, CP the client principal
SR the server realm SP the server principal and NGR is the number of
concurrent groups that the client belongs to.

The size for a principal is roughly:

	4(num_components+1) + strlen(princname)

and the size for a realm is roughly:

	4 + strlen(realm)

For a realm of length 160 (and a client with one component and 4 bytes long
e.g., root) trying to talk to the registry server (target principal
"dce-rgy" this would require at least 775 bytes in the callback packet.
Root actually requires at least 815 bytes since it is a member of two
concurrent groups (775 assumed no concurrent groups).

Fixing this problem will require a change to the RPC callback protocol
and should be deferred until DCE 1.1

[9/1/92 public]

Deferred again (read the previous comment).

[08/03/93 public]
This is a major work item for 1.1 in CN rpc, and a smaller 'bug fix'
for DG.

Changing this to a 1.1 enhancement simply for tracking.

[03/18/94 public]
The CN protocol has been changed to send multi-part BIND and ALTER_CONTEXT
packets.  The CN protocol version has been bumped to 5.1.

This defect is 'fixed' as far as CN RPC is concerned, so I am re-assigning
this to Mark at HP to close when the DG half of this work is done.

[3/18/94 public]

The DG work has already been submitted.



CR Number                     : 1709
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 6901
Project Name                  : dce
H/W Ref Platform              : other
S/W Ref Platform              : other
Component Name                : rpc
Subcomponent Name             : 
Short Description             : rpcd dumps core on a machine with no network interfaces
Reported Date                 : 11/18/91
Found in Baseline             : .69e
Found Date                    : 
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.0.3
Fixed In Baseline             : 1.0.3
Affected File(s)              : rpc/runtime/comnet.c, rpc/runtime/cnnet.c
Sensitivity                   : public

[01/29/92 public]

Orbit reference number 3705
reference     
product       dce_osf
phaseFound    development

History:
lastUpdate    91/12/04 17:50:52
endDate                                
assignDate    91/12/04 17:50:52   





    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    91/11/18 14:14:55    create          leban (Dick Leban)
    91/11/19 15:50:33    modify          drb (Defect Review Board)
    91/12/04 17:14:37    return          wkh (Ward K. Harold)
    91/12/04 17:16:12    note            wkh (Ward K. Harold)
    91/12/04 17:50:52    reopen          leban (Dick Leban)

[11/18/91 public]
ifconfig all outside network interfaces down (i left lo0 alone).  "rpcd -D".
here's a log of what it prints.

(rpcd) initializing database
(rpcd) endpoint database object id: 008A0FCA-1E53-1928-BD03-10005A4F4AE0
Exception: Illegal instruction
IOT/Abort trap(coredump)

[12/04/91 public]
We've noticed this phenomenon too.  You can't just change things to make
the loopback interface be picked up too.  The problem is that unless you
do more tricky stuff, the sequence:

    rpc_server_use_all_protseq();
    rpc_server_inq_bindings();
    rpc_ns_binding_export();

(which many servers will do) will result in towers with the loopback
address getting stashed in the CDS.  This would be a Very Bad Thing.
We decided to live with the problem for now.  Basically, you must
configure one real network interface before doing any RPC stuff.
That doesn't seem too unreasonable.

[12/04/91 public]
The previous comment came from Nat Mishkin, in response to a query
about this defect from me.

[12/04/91 public]
this defect was marked must fix.  please get it deferred or notaproblemed
before returning it:)

[03/18/92 public]
marked defer for 1.0.1

[10/19/92 public]
Changed priority = 1 for all active bugs > 6 months old.

[1/14/93 public]

It was decided that this defect should be documented as a limitation, and reclassified
as an enhancement.  I'm not sure how to turn this into a doc bug, and an enhancment
request at the same time, so I'm hoping Dave will help me out.

[1/19/93 public]

Changed to enhancement and added doc bug 6901.

[07/20/93 public]
Not really worth protecting someone from running DCE on a machine with
a network...  Due to resrouce limitations, this isn't going to happen.

Canceled.

[07/30/93 public]

I'm re-opening this bug because causing coredump is not good. Instead, it
should report the error. I believe that the fix is:

In rpc__cn_network_desc_inq_ep()/cnnet.c and
rpc__network_inq_local_addr()/comnet.c, if the returned rpc addr vector's
len == 0 from rpc__naf_desc_inq_addr(), return the status rpc_s_no_addrs
(just like in rpc__cn_network_use_protseq()'s #ifdef AUTOSTART part).

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



CR Number                     : 1236
Defect or Enhancement?        : enh
CR in Code, Doc, or Test?     : code
Inter-dependent CRs           : 
Project Name                  : dce
H/W Ref Platform              : rs6000
S/W Ref Platform              : aix
Component Name                : rpc
Subcomponent Name             : runtime
Short Description             : back-to-back maybe rpcs fail
Reported Date                 : 07/18/91
Found in Baseline             : .38
Found Date                    : 
Severity                      : B
Priority                      : 2
Status                        : closed
Duplicate Of                  : 
Fix By Baseline               : 1.1
Fixed In Baseline             : 1.0.3
Affected File(s)              : dg.h       dgexec.c   
                                             dglsn.c    dgscall.c  
                                             dgsct.c    dgsct.h    
                                             dgslsn.c
Sensitivity                   : public

[01/29/92 public]

Orbit reference number 2341
reference     
product       dce_osf
phaseFound    development

History:
lastUpdate    91/10/30 13:55:54
endDate                                
assignDate    91/10/30 13:55:54   





    addDate              action          userLogin (userName)
    -------------------- --------------- ----------------------------------
    91/07/18 08:13:36    create          ebrown (Erik Brown)
    91/07/18 11:07:11    note            mishkin (Nat Mishkin)
    91/07/18 14:01:59    note            ebrown (Erik Brown)
    91/07/19 13:47:44    note            ebrown (Erik Brown)
    91/07/23 12:36:35    note            bushnell (S. Bushnell)
    91/07/23 12:36:55    assign          bushnell (S. Bushnell)
    91/07/23 12:37:01    return          bushnell (S. Bushnell)
    91/07/24 10:37:24    modify          kwalker (Ken Walker)
    91/07/24 10:57:04    note            kwalker (Ken Walker)
    91/10/21 16:46:37    note            bushnell (S. Bushnell)
    91/10/23 13:26:24    note            ebrown (Erik Brown)
    91/10/23 13:33:17    note            bushnell (S. Bushnell)
    91/10/23 14:50:11    note            ebrown (Erik Brown)
    91/10/23 15:11:51    note            bushnell (S. Bushnell)
    91/10/30 13:55:54    reopen          ebrown (Erik Brown)

[07/18/91 public]
The NCS implementation exhibits problems with back-to-back
"maybe" RPCs.  When one client (thread) makes a "maybe" RPC, and
then makes another while the first is still being executed in
the server:

    1) The server thread executing the first call is the target
       of a "pthread_cancel".  This may make sense for full RPCs,
       in that the client must wait for the first to complete
       before it can legally make the second, but it should not
       apply to "maybe" RPCs.  A "maybe" RPC returns to the
       client as soon as the message is queued.

    2) The runtime does not invoke the manager function for the
       second "maybe" RPC.

A third "maybe" RPC *does not* cause a pthread_cancel, and the
manager function *is* invoked.  Only even-numbered calls exhibit
the problem.

Below is a test program that displays this behavior.  This was
converted from a simple add client and server, so the names do not
exactly reflect the functionality.  The server pauses for 10 seconds
in the manager function.  The client pauses for 5 seconds between
calls.  Changing the client interval to less than 5 seconds (so that
more than 1 additional client call comes in while an earlier call is
in progress) does not change the behavior.

/*
 * add.idl
 */
 [uuid(333A2276-0000-0000-0D00-00809C000011), version(1)]

interface add
{
	[maybe] void add_doit(	[in] handle_t handle,
			[in] long int n
			);
}

<< The entire test would not fit in a single message, so will send
   the remainder of the test in a subsequent note once I receive
   the orbit number. >>

[07/18/91 public]
I think we're going to want to treat this simply as a restriction on
the way "maybe" calls work.  If someone doesn't like this behavior, it
seems like they could just not use "maybe" calls.

[07/18/91 public]
/*
 * Copyright (C) 1991 Transarc Corporation
 * All Rights Reserved
 */
/*
 * add.c -- client side of NCS 2.0 add test
 */

#include <pthread.h>
#include "add.h"
#include <stdio.h>

char nilString[] = "";

main(argc,argv)
  int argc;
  char **argv;
{
    int				a,b,c;
    rpc_binding_handle_t	handle;
    error_status_t		st;
    char			*binder;
    int				i;

    cma_init();
    if (argc < 2) {
	fprintf(stderr,"Usage: %s binding-string [a] [b]\n", *argv);
	exit(1);
    }

    binder = argv[1];
    rpc_binding_from_string_binding(binder, &handle, &st);
    if (st != error_status_ok) {
	fprintf(stderr,"Cannot bind from string %s, status 0x%x.\n",
		binder, st);
	exit(1);
    }

    printf("Handle bound to %s\n", binder);
    /* rpc_string_free(&binder, &st); */
    if (st != error_status_ok) {
	fprintf(stderr,"Cannot free string binding, status 0x%x.\n", st);
	exit(1);
    }

    for (i = 0; i < 100; i++) {
        static struct timespec t = { 5, 0 };
	printf("client: Call %d\n", i); fflush(stdout);
        add_doit(handle, i);
	printf("client: Completed %d\n",i); fflush(stdout);
	pthread_delay_np(&t);
    }

    exit(0);
}

/*
 * Copyright (C) 1991 Transarc Corporation
 * All Rights Reserved
 */
/*
 * add_serv.c -- server side of add test
 */

#include <pthread.h>
#include "add.h"
#include <stdio.h>

add_v1_0_epv_t add_v1_0_manager_epv = { add_doit };
/* globaldef add_v0_0_epv_t string0_v0_0_m_epv = {add_doit}; */

globalref uuid_t uuid_nil;

void add_doit(handle, n)
  handle_t handle;
  int n;
{
    static struct timespec t = { 10, 0 };

    printf("server: Call number %d\n", n); fflush(stdout);
    pthread_delay_np(&t);
    printf("server: Returning from %d\n", n); fflush(stdout);
}

main(argc, argv)
  int argc;
  char **argv;
{
    rpc_binding_vector_p_t  	bvec;
    error_status_t          	st;
    int				valid;
    char                	*binder;
    int                     	i;

    cma_init();

    if (argc != 2) {
        fprintf(stderr, "Usage: %s family\n", *argv);
        exit(1);
    }

    valid = rpc_network_is_protseq_valid(argv[1], &st);
    if (st != error_status_ok) {
        fprintf(stderr, "Cannot check protocol sequence, status 0x%x\n",st);
        exit(1);
    }
    if (!valid) {
        printf("Protocol sequence %s is not valid\n", argv[1]);
        exit(1);
    }

    rpc_server_use_protseq(argv[1], 5, &st);
    if (st != error_status_ok) {
        fprintf(stderr,
		"Cannot use given protocol sequence, status 0x%x\n",st);
        exit(1);
    }

    rpc_server_register_if(add_v1_0_s_ifspec, &uuid_nil,
			   (rpc_mgr_epv_t)&add_v1_0_manager_epv, &st);
    if (st != error_status_ok) {
        printf("Cannot register interface, status %s\n", st);
        exit(1);
    }

    rpc_server_inq_bindings(&bvec, &st);
    if (st != error_status_ok) {
        printf("Cannot inquire bindings, status 0x%x\n", st);
        exit(1);
    }

    printf("Bindings:\n");
    for (i = 0; i < bvec->count; i++) {
        rpc_binding_to_string_binding(bvec->binding_h[i], &binder, &st);
        if (st != error_status_ok) {
            printf("Cannot get string binding, status 0x%x\n", st);
            exit(1);
        }
        printf("%s\n", (char *)binder);
    }

    rpc_string_free(&binder, &st);
    if (st != error_status_ok) {
        fprintf(stderr, "Cannot free string binding, status 0x%x\n", st);
        exit(1);
    }

    printf("Listening...\n");

    rpc_server_listen(5, &st);

    if (st != error_status_ok)
        fprintf(stderr, "Error on exit: status 0x%x\n", st);
    printf("Server exiting.\n");
    exit(0);
}

[07/19/91 public]
Comment from a developer here:

I can abide by their decision to call it an "implementation limitation"
that will eventually be removed.  I object strenuously to the notion
that it is a valid "interface restriction".  I think programmers should
reasonably expect a "maybe" RPC to have the properties of
a datagram -- loss is possible, especially under times of heavy load,
but not *likely*.

[07/23/91 public]
According to a note from Richard Curtis, this will be a documented restriction.  When the originator reviews the RPC publications, it should be ensured the wording in the pubs regarding this is to his satisfaction

[07/24/91 public]
This defect has been marked 'defer' (do not fix in 1.0) by the Defect Review Board.

[10/21/91 public]
Please close this defect.  Documentation was updated long ago

[10/23/91 public]
I do not see why this defect should be closed.  According to the
defect text, this has been deferred until after 1.0.  I think this is
a defect, but can abide by the decision to fix this at a later date.
I understand that this restriction has been documented for 1.0, but I
believe the defect should remain open and deferred so that it is
eventually fixed in a more satisfactory manner.

[10/23/91 public]
It's fine to leave it open - what we need to know is:
Are you content with the new wording in the pubs?

[10/23/91 public]
I was told that the pubs have been updated, but have not been told
where the text of these updates would be located.  If you could direct
me to the appropriate file, I will read the text.  Actually, I would
prefer it if I could simply receive a copy of the changed text.  You
can fax me at 412-338-4404 (Attn: Erik Brown) with the changes, which
might be easiest, or you can mail me at eeb@transarc.com.  If there
are further problems, call me at 412-338-4426.

BTW, we do not have updated pups here.  I'm not sure we have anything
newer than the OSF Snapshot 4 Docs, as this is sufficient for most of
our needs, and the source code answers any more detailed questions.

[10/23/91 public]
I have no idea who owns the pubs.  I suggest you contact your
local TransArc pubs representative (Julie Kownacki or Phil
Hirsch can probably tell you who the right person is, otherwise
Melanie Harper here at IBM (our pub contact) (512) 838-7986 can
probably direct you.)  All pubs are in the dillo cell, so I'm
sure someone there already has a copy.  Since Nat Mishkin is
the one that was going to put this info in the pubs, he may
be able to tell you exactly which document the information
went into.  Sorry I can't be of more help.  Pub closure dates
arrive in 1+ weeks, and then no more changes will be made.

[10/30/91 public]
This is being re-opened as a deferred defect to be fixed in a later release.

[02/06/92]
Without going into the merits of whether or not the code should be changed,
it should be noted that we have no plans to fix this for 1.0.1.

[03/18/92 public]
So be it.   Marked defer for 1.0.1, assigned to Mishkin.

[Kapoor 08/16/93 public]
This problem exists with dce1.0.2. I would appreciate, if HP could let us
know how they plan to fix it. Thanks

[10/4/93 public]

I've extended the server side connection table (SCT) so that each entry
now contains a list of maybe-calls currently associated with the
connection (in addition to the 1 non-maybe-call the entry currently
contains).

A newly received maybe-call will still cancel a currently running 
non-maybe call (with a lower sequence number), but not vice versa.

[11/10/93 public]
Code has passed functional and most of system test.
Closed.



