...\" OSF-RFC 51.3
...\"
...\" FORMATTING INSTRUCTIONS for this RFC:
...\"       nroff -Tlpr rfc51.3.roff > rfc51.3.txt
...\"       troff -Tps rfc51.3.roff | <ps-post-processor> > rfc51.3.ps
...\" (Where "troff" means "device-independent troff", or "ditroff".)
...\"
...\" If troff is not supported for a given RFC, insert the following:
...\" .if t \{\
...\" .tm *** Troff not supported for this RFC.
...\" .ex \}
...\"
...\" =========================================================================
...\" This template first sets a bunch of *roff options (authors/readers
...\" don't usually have to know about these).
...\" Then it defines some strings and macros, many of which deal with
...\" things that differ between nroff & troff (some of these may not be
...\" perfect, but they're better than nothing -- to do a really good
...\" job would require a real semantic markup language.
...\" Convention: "Begin/End" for strings, "Start/Finish" for macros.
...\" Strings:
...\"       \*(f!        - Footnote string (replaces \*F).
...\"       \*(hB, \*(hE - Page header/footer font (internal use).
...\"       \*(kB, \*(kE - Doc header font (internal use).
...\"       \*(qB, \*(qE - Quotations.
...\"       \*(iB, \*(iE - Italics/emphasis in primary font.
...\"       \*(bB, \*(bE - Bold font.
...\"       \*(lB, \*(lE - Literal font.
...\"       \*(jB, \*(jE - Italics/emphasis in literal font.
...\"       \*(nH        - Default note header string.
...\" Macros:
...\"       .aH      - Appendix header macro (uses number register \na).
...\"       .aL      - Automatic list macro (replaces .AL; uses num reg \ng).
...\"       .tS, .tF - Title start/finish (internal use).
...\"       .cS, .cF - Displays (no-fill) without indentation.
...\"       .dS, .dF - Displays (no-fill) with indentation.
...\"       .iS, .iF - Indented (fill) text.
...\"       .nS, .nF - Note.
...\" -------------------------------------------------------------------------
...\" First, set up some number registers here (instead of on command line),
...\" and include the "mm" macro package here (instead of on command line).
...\" -------------------------------------------------------------------------
.if n .nr L 66 \" Nroff page length = 66 lines.
.if t .nr L 11i \" Troff page length = 11 inches.
.if n .nr W 72 \" Nroff page width = 72 columns.
.if t .nr W 6.5i \" Troff page width = 6.5 inches.
.if n .nr O 3 \" Nroff page offset = 3 columns.
.if t .nr O 0.75i \" Troff page offset = 0.75 inches.
.nr N 2 \" No header on page 1.
.so /usr/lib/tmac/tmac.m \" Points to "mm" package, in /usr/lib/macros.
...\" -------------------------------------------------------------------------
...\" Next, twiddle the "mm" package to suit our preferred style.
...\" -------------------------------------------------------------------------
...\" Point size and font types.
...\" -------------------------------------------------------------------------
.if n .fp 1 R \" "Regular" font ONLY -- don't use any others in nroff.
.if t \{ .S 10 12 \" Point size = 10, vertical spacing = 12.
...\" Note: Some systems give different names to these fonts.
.fp 1 R \" Times roman.
.fp 2 I \" Times italic.
.fp 3 B \" Times bold.
.fp 4 BI \" Times bold italic.
.fp 5 CW \" Courier.
.fp 6 CI \" Courier oblique.
.fp 7 CB \" Courier bold.
.fp 8 CX \" Courier bold oblique.
.fp 9 H \" Helvetica.
.fp 10 HI \" Helvetica oblique.
.fp 11 HB \" Helvetica bold.
.fp 12 HX \" Helvetica bold oblique.
.fp 13 S \} \" Special symbol font -- normally only called automatically.
...\" -------------------------------------------------------------------------
...\" Headings; page header and footers; titles.
...\" -------------------------------------------------------------------------
.nr Ej 0 \" No eject for first-level headings.
.nr Hs 7 \" Heading space level = blank line after heading (all levels).
.nr Hb 7 \" Heading break level = break after heading (all levels).
.nr Hi 1 \" Post-heading indent = paragraph indent.
.nr Hc 0 \" Heading centering = none.
.if n .ds HF 1 1 1 1 1 1 1 \" Heading fonts = regular (no underlining).
.if t .ds HF 11 11 11 11 11 11 11 \" Heading fonts = Helvetica bold.
.if t .ds HP 0 0 0 0 0 0 0 \" Heading point sizes (= default).
.HM 1 1 1 1 1 1 1 \" Heading mark = arabic (all levels).
.nr Hu 1 \" Unnumbered heading level = 1 (see aH macro, below).
.de HX \" Beginning-of-heading processing.
.in 0 \" Left justify headings.
.ie     \\$2=0 .ds }0\" Null string heading mark for HU.
.el .ie \\$1=1 .ds }0 \\n(H1.\ \&\" Heading marks = dotted sections + 1 space.
.el .ie \\$1=2 .ds }0 \\n(H1.\\n(H2.\ \&
.el .ie \\$1=3 .ds }0 \\n(H1.\\n(H2.\\n(H3.\ \&
.el .ie \\$1=4 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\ \&
.el .ie \\$1=5 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\ \&
.el .ie \\$1=6 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\\n(H6.\ \&
.el .if \\$1=7 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\\n(H6.\\n(H7.\ \&
..
.de HZ \" End-of-heading processing.
.if n .in 3 \" Indent body of doc by 3 columns in nroff.
.if t .in 0 \" Don't indent in troff.
..
.if n .ds hB \&\" Page header/footer font begin in nroff.
.if t .ds hB \f9\" Page header/footer font begin in troff.
.if n .ds hE \&\" Page header/footer font end in nroff.
.if t .ds hE \fP\" Page header/footer font end in troff.
.if n .ds kB \&\" Doc header font begin in nroff.
.if t .ds kB \f(11\" Doc header font begin in troff.
.if n .ds kE \&\" Doc header font end in nroff.
.if t .ds kE \f1\" Doc header font end in troff.
.de tS \" Title start.
.SP 2 \" 2 blank lines.
.ce 99 \" Center (each line of) title.
.if t \{ .ft 11 \" Bold helvetica.
.S +2 D \} \" Bigger point size.
..
.de tF \" Title finish.
.ce \" Turn off centering.
.SP 1 \" 1 blank line.
.if t \{ .ft 1 \" Return to regular font.
.S P P \} \" Return to regular point size.
..
...\" -------------------------------------------------------------------------
...\" Special Appendix heading macro, .aH.
...\" -------------------------------------------------------------------------
.nr a 0 1 \" Appendix number.
.af a A \" Assign format upper-case alpabetic to number register a.
.de aH \" Appendix heading macro.
.if \\na=0 \{ .nr H1 0 \" Reset H1 to 0.
.HM A 1 1 1 1 1 1 \} \" Heading mark = Upper case alphabetic + arabics.
.HU "APPENDIX \\n+a. \\$1"
..
...\" -------------------------------------------------------------------------
...\" Paragraph stuff.
...\" -------------------------------------------------------------------------
.nr Pt 0 \" Paragraph type = left-justified.
.nr Pi 0 \" Paragraph indent = 0.
.nr Ps 1 \" Paragraph spacing = 1 blank space.
...\" -------------------------------------------------------------------------
...\" Special list macro, .aL (replaces .AL, for all levels).
...\" This should be used for almost all lists (including ".LI "\ "").
...\" The only exception is variable lists (.VL, indented by multiples of 6).
...\" -------------------------------------------------------------------------
.de aL
.nr g \\n(:g
...\" In-line lists should be numbered (by hand): (1), (2), (3), ...
.ie     \\ng=0 .LB 6 0 1 3 a \" 1st level: (a), (b), (c), ...
.el .ie \\ng=1 .LB 6 0 1 3 i \" 2nd level: (i), (ii), (iii), ...
.el .ie \\ng=2 .LB 6 0 1 4 a \" 3rd level: [a], [b], [c], ...
.el .ie \\ng=3 .LB 6 0 1 4 i \" 4th level: [i], [ii], [iii], ...
.el .ie \\ng=4 .LB 6 0 1 6 a \" 5th level: {a}, {b}, {c}, ...
.el .if \\ng=5 .LB 6 0 1 6 i \" 6th level: {i}, {ii}, {iii}, ...
..
.nr Ls 6 \" Blank lines between all list items, by default (but adjustable).
...\" -------------------------------------------------------------------------
...\" Footnote stuff; special footnote string, \*(f!.
...\" -------------------------------------------------------------------------
.if n .ds f! [\\n+(:p]\" Footnote string (replaces \*F in nroff).
.if t .ds f! \\*F\" Footnote string (same as \*F in troff).
.if n .FD 6 \" Footnotes not hyphenated or indented, label left justified.
.if t .FD 5 \" Footnotes hyphenated, not indented, label left justified.
.nr Fs 1 \" 1 blank line between footnotes.
...\" -------------------------------------------------------------------------
...\" Line adjustment stuff.
...\" -------------------------------------------------------------------------
.if n .nr Hy 0 \" No hyphenation in nroff.
.if t .nr Hy 1 \" Hyphenate in troff.
.if n .SA 0 \" Set adjust: left margin only in nroff.
.if t .SA 1 \" Set adjust: left and right margins in troff.
...\" -------------------------------------------------------------------------
...\" Miscellaneous stuff.
...\" -------------------------------------------------------------------------
.ta \" No tabs by default -- set them up by hand as needed.
.nr Si \n(Ls \" Default indent for .DS display macro = 6 (use in troff only).
...\" -------------------------------------------------------------------------
...\" Displays.
...\" -------------------------------------------------------------------------
.de cS \" Display start: no-fill, literal font, no indentation.
.P
.nf \" No fill mode.
.if t .ft 5 \" Constant width font in troff.
..
...\" Within .cS, ".ne N"'s can be added by hand, but should be minimized.
.de cF \" Display finish.
.if t .ft 1 \" Back to standard font in troff.
.fi \" Fill mode.
.P
..
.de dS \" Display start: no-fill, literal font, with indentation.
.P
.aL \" Use .aL macro for consistent indentation.
.nf \" No fill mode.
.LI "\ " \" List item will no (visible) marker.
.if t .ft 5 \" Constant width font in troff.
..
...\" Within .dS, ".ne N"'s can be added by hand, but should be minimized.
.de dF \" Display finish.
.if t .ft 1 \" Back to standard font in troff.
.fi \" Fill mode.
.LE
.P
..
.de iS \" Indent start: fill, regular font, with indentation.
.P
.aL
.LI "\ "
..
.de iF \" Indent finish.
.LE
.P
..
.ds nH NOTE\"Default note header string -- can be changed by author.
.de nS \" Note start: fill, italics font, with indentation.
.P
.aL \" Use .aL macro for consistent indentation.
.LI "\ " \" List item will no (visible) marker.
.if t .ft 2 \" Italics font in troff, and reverse roman <--> italic fonts:
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f1\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.ie \\n(.$=0 \\*(nH:\" Default header string if none supplied by author.
.el \\$1:\" Header string supplied by author as argument to .nS macro.
..
.de nF \" Note finish.
.if t .ft 1 \" Back to standard font in troff, and remap font macros:
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f2\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.LE
.P
..
...\" -------------------------------------------------------------------------
...\" Quotation marks and font toggles.
...\" -------------------------------------------------------------------------
.if n .ds qB \&"\" Quotation begin in nroff.
.if t .ds qB ``\" Quotation begin in troff.
.if n .ds qE \&"\" Quotation end in nroff.
.if t .ds qE ''\" Quotation end in troff.
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f2\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.if n .ds bB *\" Bold font begin in nroff.
.if t .ds bB \f3\" Bold font begin in troff.
.if n .ds bE *\" Bold font end in nroff.
.if t .ds bE \fP\" Bold font end in troff.
.if n .ds lB `\" Literal font begin in nroff.
.if t .ds lB \f5\" Literal font begin in troff.
.if n .ds lE '\" Literal font end in nroff.
.if t .ds lE \fP\" Literal font end in troff.
.if n .ds jB <\" Italics/emphasis literal font begin in nroff.
.if t .ds jB \fP\f6\" Italics/emphasis literal font begin in troff.
.if n .ds jE >\" Italics/emphasis literal font end in nroff.
.if t .ds jE \fP\f5\" Italics/emphasis literal font end in troff.
...\" -------------------------------------------------------------------------
...\" No diffmarks by default, i.e., define .mc to be null.
...\" (Comment out this null definition to turn diffmarking on.)
...\" -------------------------------------------------------------------------
.de mc
..
...\" =========================================================================
...\" Finally, it's time to start writing the document!
...\" The OSF-RFC author modifies the following header/footer info.
...\" (The major/minor number is assigned by the OSF-RFC Editor.)
...\" =========================================================================
...\" Copyright (C) 1996 Transarc Corporation - All rights reserved.
...\" $Header: /afs/tr/fs/dev/dfs-dev/src/file/docs/specs/scalar_hyper_type/RCS/64bit-changes.roff,v 1.2 1996/05/17 13:36:21 ota Exp $
.ND "August 1996" \" Date must be hard-coded.
.PH "$\*(hBOSF-RFC 51.3$DFS Support for Scalar 64-Bit Type$\\\\*(DT\*(hE$"
.PF "$\*(hBAnderson$DRAFT #1$Page \\\\n%\*(hE$" \" Draft version.
.PF "$\*(hBAnderson$$Page \\\\n%\*(hE$" \" Final version.
...\"
...\" Following are the first printed lines (header info) of the document:
...\"
\&\" Force top-of-first-page trap to position the following info correctly.
.tl $\*(kBOpen Software Foundation$$T. Anderson (Transarc)\*(kE$
.tl $\*(kBRequest For Comments: 51.3$$\*(kE$
.tl $\*(kB\*(DT$$\*(kE$
.tS \" Title, in all capitals (can span multiple lines):
DFS CHANGES TO SUPPORT A SCALAR 64-BIT TYPE
.tF
...\" =========================================================================
...\" Now, the actual body of the document!!
...\" Heading capitalization style:
...\"     1st level: CAPITALIZE ALL WORDS
...\"     2nd level: Capitalize Initial Letters of All (Significant) Words
...\"     3rd-7th level: Capitalize first letter of first word only
...\" =========================================================================
.P
.H 1 "INTRODUCTION" \" Always start with an introduction section.
.P
This document describes a cleanup made to the Transarc DFS code base to
make support for large data objects easier.  This work was inspired by
the earlier revisions of this RFC and specifically the concrete work at
DEC and Cray to export large files with DFS.
.P
The approach we took was to incorporate the wide ranging code changes
described by Steve Strange in [RFC 51.1], which allowed 64-bit
quantities to be represented efficiently using a scalar type when one is
available.  However, we needed to ensure backward compatibility with
existing persistent data structures, which meant that the scalar type
could not be used when an architecture independent format was needed.
We also made several different choices for names of global types and
macros to minimize the possibility of name space collisions.
.P
We also incorporated the changes Steve suggested in [RFC 51.2].  Those
changes which affected the DFS protocol were made earlier.  There
remained several internal changes, that should making ports to 64-bit
architectures easier.  These changes involve modifications to the DFS
file exporter (PX) so it remembers the maximum file size supported by
the client.  Analogous changes allow the DFS cache manager (CM) to track
the maximum file size supported by the server.
.P
.H 1 "OUTLINE OF WORK"
.P
The work described here has several general components: type changes,
hyper macro changes, platform independence considerations, and maximum
file size tracking.  The platform independence problem is further
divided into: RPC interfaces, Episode disk structures, ubik databases
for the fldb and backup system, and tape formats used by the backup
system.
.P
Existing DFS code often represented 64-bit quantities using a
\*(lBhyper\*(lE\*(lB type that was implemented as a structure
composed of two 32-bit integers.  To hide this implementation, a
collection of macros was provided to manipulate hyper\*(lEs.
However, the use of these macros was spotty, at best.  To
further confuse things, a similar type, called
\*(lBafsHyper\*(lE, was used in some code and another set of
macros existed to manipulate this type.  Generally these types
are called \*(qBhyper\*(qE\|'s (as opposed to
\*(qB\*(lBhyper\*(lE\*(qE\|'s) and the macros are referred to
collectively as \*(qBhyper macros\*(qE.
.P
.H 2 "Type Changes"
.P
An important part of the work was to provide a single hyper
type, called \*(lBafs_hyper_t\*(lE, to represent 64-bit
quantities wherever possible.  To support both scalar and
aggregate implementations of the type, hypers must be uniformly
accessed via a consistent set of macros.
.P
Several types were identified by [RFC 51.1] as containing 64-bit
quantities that were not represented in a natural way.  These
were the \*(lBafsToken\*(lE and \*(lBafsRecordLock\*(lE types,
which, for historical reasons, represented file offsets as two
non-contiguous 32-bit integers.
.P
The type \*(lBtkm_token_t\*(lE largely duplicated the
functionality of the RPC-defined \*(lBafsToken\*(lE type, so
these two types were combined in a new type called
\*(lBafs_token_t\*(lE.
.P
For consistency, the record lock type was renamed to
\*(lBafs_recordLock_t\*(lE.
.P
.H 2 "Hyper Macro Changes"
.P
The bulk of the changes of related to the use of hypers.  To
ensure that DFS code was portable between platforms with
different representations of the hyper, all references to hypers
were changed to use the appropriate macros.  Most important,
explicit reference to the \*(qBlow\*(qE and \*(qBhigh\*(qE
members of the (old) hyper structure were eliminated in favor of
accessing macros \*(lBAFS_hgetlo()\*(lE and
\*(lBAFS_hgethi()\*(lE.  These members cannot exist on platforms
that use a scalar 64-bit type.  The accessing macros replace the
awkward \*(lBhget32()\*(lE and \*(lBhget64()\*(lE.
.P
To minimize name space collisions the hyper handling macros were all
renamed to use the \*(lBAFS_\*(lE prefix.
.P
The \*(lBhset()\*(lE macro was eliminated because the compiler can
perform assignment efficiently for both scalar and non-scalar
representations.
.P
Several other minor changes were made to simplify the list of hyper
macros to make them easier to understand and use.  A full list of the
macros appears below.
.P
.H 2 "Platform Independence"
.P
The new hyper type is not suitable as an external representation for at
least two reasons.  First, the platform dependent implementation of the
hyper implies that the byte order is not fixed.  Second, the scalar type
can have different alignment requirements from a structure of two 32-bit
integers, so a structure containing a hyper will pack differently
depending on whether the hyper is implemented as a scalar or an
aggregate.  A good external representation needs to have a stable,
well-specified packing and byte order.
.P
Therefore, to maintain upward compatibility another type was
used to specifying externally visible or persistent formats.  To
meet these requirements, the type \*(lBdfsh_diskHyper_t\*(lE was
defined in \*(lBfile/util/hyper.h\*(lE.  It comes with two sets
of accessing macros depending on whether host byte order is
acceptable (as in Episode) or whether platform independent byte
order is necessary (as with ubik databases and the on-tape
structures used by the backup system).
.P
The new \*(lBafs_hyper_t\*(lE type is widely used in RPC
functions.  In that capacity the platform independence is
provided by the RPC system using the \*(lB[represent_as]\*(lE
mechanism specified in the \*(lBfile/config/common_data.acf\*(lE
file.  This automatically maps between types as explained in
[RFC 51.1] (e.g., \*(lBafsHyper\*(lE on the wire and
\*(lBafs_hyper_t\*(lE in memory).  Except for the type name
changes this work was implemented as described.
.P
.H 2 "Maximum File Size Tracking"
.P
A collection of changes was suggested in RFC 51.2.  One change involves
an enhancement to the protocol to exchange maximum supported file size
information between the client and server.  The minimal support for this
feature was added to DFS some time ago and is present in the OSF DCE
V1.2 code.  This preliminary work was extended to make future ports to
64-bit platforms easier.  Generally these changes followed those made by
DEC, but several additional changes were made and a few things were
implemented a bit differently than in the DEC code.  These changes
should interoperate with older 32-bit systems, and with the 64-bit
systems deployed by DEC and Cray.
.P
Additional members were added to the host structures used by the PX and
CM to track the maximum file size supported by the other machine.  This
is used to provide reasonable behavior when clients and servers have
different capabilities.  This information allows enhanced clients to
avoid writing a file longer than the server can support.  The CM returns
\*(lBEFBIG\*(lE when the application attempts to extend the file beyond
this limit.
.P
Several changes were made to token management.  The special
value used to represent a \*(qBwhole file\*(qE was changed from
2^31\(mi1 to 2^63\(mi1.  To make this work correctly with older
systems, two special mappings are performed.  On the client, the
byte ranges of tokens returned from an old server are mapped
from 2^31\(mi1 to 2^63\(mi1.  On the server, the byte ranges of tokens
being returned are modified so that 2^63\(mi1 is mapped to 2^31\(mi1.
.P
Several bugs were fixed (e.g., OT13445) and shortcomings addressed
(e.g., OT8872) which affected 64-bit operations.
.P
.H 1 "ISSUES NOT ADDRESSED"
.P
Several related issues were not addressed by this work:
.P
.aL
.LI
On some platforms the type \*(lBint\*(lE and type \*(lBlong\*(lE
are different sizes.  Because this is not true on any of the
platforms in use at Transarc, some errors due to mixing these
types are present.  There has been no effort in this work to
weed out those errors.
.LI
Transarc's DFS does not support files longer than 2^31\(mi1
bytes.  There are several parts to remedying this.  Part of the the
problem is due to the native OS (e.g., neither SunOS 5.4 nor AIX 3.2
support large files in their virtual memory systems).  Presumably DEC
and Cray have removed these limitations.  However, numerous components
within DFS have limitations that would prevent large files from working
immediately.  Mostly these problems are minor, but a significant testing
effort would be needed to verify large file support.
.LI
No interoperation testing between Transarc DFS code and DEC and/or Cray
products has been done.
.LE
.P
.H 1 "DETAILED CHANGES"
.P
Next is a detailed description of the changes that were made, following
the outline given above.
.P
.H 2 "Changes to Types"
.P
Several important types that contained 64-bit quantities were renamed or
combined.  A few changes in the member names were also made.  The types
now have the following names:
.P
.dS
   NEW TYPE            REPLACES
afs_hyper_t         hyper, afsHyper
afs_token_t         afsToken, tkm_token_t
afs_recordLock_t    afsRecordLock
.dF
.P
Here are the changed member names:
.P
.dS
   NEW MEMBER                    REPLACES
afs_token_t.expirationTime    tkm_token_t.expiration
afs_token_t.beginRange        tkm_token_t.startPosition
afs_token_t.endRange          tkm_token_t.endPosition
.dF
.P
Obsolete members representing parts of hypers were removed:
.P
.dS
   DELETED MEMBER                   NOW PART OF HYPER
afsToken.beginRangeExt           afs_token_t.beginRange
tkm_token_t.startPositionExt 
 
afsToken.endRangeExt             afs_token_t.endRange
tkm_token_t.endPositionExt 
 
afsRecordLock.l_start_pos_ext    afs_recordLock_t.l_start_pos
afsRecordLock.l_end_pos_ext      afs_recordLock_t.l_end_pos
.dF
.P
.H 2 "Hyper Macro Descriptions"
.P
Here is the list of macros provided for manipulating hypers.
.P
.aL
.LI
\*(lBint AFS_hcmp(afs_hyper_t a, afs_hyper_t b)\*(lE \*(EM
Returns a (negative, zero, or positive) value if
\*(lBa\*(lE is (less, equal, or greater) \*(lBb\*(lE.  This is
an unsigned comparison.  In other words, \*(lB(a \*(jBoper\*(jE
b)\*(lE can be expressed as \*(lB(AFS_hcmp(a, b) \*(jBoper\*(jE
0)\*(lE where \*(lB\*(jBoper\*(jE\*(lE is one of { \*(lB<\*(lE,
\*(lB<=\*(lE, \*(lB==\*(lE, \*(lB>\*(lE, \*(lB>=\*(lE }.
.LI
\*(lBint AFS_hcmp64(afs_hyper_t a, u_int32 hi, u_int32 lo)\*(lE
\*(EM like \*(lBAFS_hcmp()\*(lE but compares \*(lBa\*(lE with
\*(lB(hi<<32 + lo)\*(lE.
.LI
\*(lBint AFS_hsame(afs_hyper_t a, afs_hyper_t b)\*(lE \*(EM
Returns \*(lBa\*(lE non-zero value (TRUE) iff \*(lBa\*(lE has
the same value as \*(lBb\*(lE.
.LI
\*(lBint AFS_hiszero(afs_hyper_t a)\*(lE \*(EM Returns TRUE iff
\*(lBa\*(lE is zero.
.LI
\*(lBint AFS_hfitsinu32(afs_hyper_t a)\*(lE \*(EM Returns TRUE
iff 0 <= \*(lBa\*(lE < 2^32.
.LI
\*(lBint AFS_hfitsin32(afs_hyper_t a)\*(lE \*(EM Returns TRUE
iff \(mi2^31 <= \*(lBa\*(lE < 2^31.
.LI
\*(lBvoid AFS_hzero(afs_hyper_t a)\*(lE \*(EM Sets \*(lBa\*(lE
to zero.
.LI
\*(lBu_int32 AFS_hgetlo(afs_hyper_t a)\*(lE \*(EM Returns the 32
least significant bits of \*(lBa\*(lE.
.LI
\*(lBu_int32 AFS_hgethi(afs_hyper_t a)\*(lE \*(EM Returns the 32
most significant bits of \*(lBa\*(lE.
.LI
\*(lBvoid AFS_hset64(afs_hyper_t a, u_int32 hi, u_int32 lo)\*(lE \*(EM
sets \*(lBa\*(lE to \*(lB(hi<<32 + lo)\*(lE.  So that \*(lBAFS_hset64(h,
AFS_hgethi(h), AFS_hgetlo(h))\*(lE leaves \*(lBh\*(lE unchanged.
.LI
\*(lBAFS_HINIT(u_int32 hi, u_int32 lo)\*(lE \*(EM An initializer of type
\*(lBafs_hyper_t\*(lE.
.LI
\*(lBvoid AFS_hleftshift(afs_hyper_t a, u_int amt)\*(lE \*(EM
Shifts \*(lBa\*(lE left by \*(lBamt\*(lE bits; where 0 <
\*(lBamt\*(lE < 64.
.LI
\*(lBvoid AFS_hrightshift(afs_hyper_t a, u_int amt)\*(lE \*(EM
Logically shifts \*(lBa\*(lE right by \*(lBamt\*(lE bits; where
0 < \*(lBamt\*(lE < 64.
.LI
\*(lBvoid AFS_hset32(afs_hyper_t a, int32 i)\*(lE \*(EM Sets
\*(lBa\*(lE to the 64-bit sign extended value of \*(lBi\*(lE.
If \*(lBi\*(lE is unsigned use \*(lBAFS_hset64(a, 0, i)\*(lE.
.LI
\*(lBvoid AFS_hadd32(afs_hyper_t a, int32 i)\*(lE \*(EM Adds
\*(lBi\*(lE to \*(lBa\*(lE.
.LI
\*(lBvoid AFS_hadd(afs_hyper_t a, afs_hyper_t b)\*(lE \*(EM Adds
\*(lBb\*(lE to \*(lBa\*(lE.
.LI
\*(lBvoid AFS_hsub(afs_hyper_t a, afs_hyper_t b)\*(lE \*(EM
Subtracts \*(lBb\*(lE from \*(lBa\*(lE.
.LI
\*(lBvoid AFS_hnegate(afs_hyper_t a)\*(lE \*(EM Sets \*(lBa\*(lE
to its twos complement.
.LI
\*(lBvoid AFS_HOP(afs_hyper_t a, \*(jBop\*(jE, afs_hyper_t
b)\*(lE \*(EM like \*(lBa = a \*(jBop\*(jE b\*(lE, where
\*(lB\*(jBop\*(jE\*(lE should be one of { \*(lB"|"\*(lE ,
\*(lB"&"\*(lE, \*(lB"^"\*(lE, \*(lB"&~"\*(lE }.
.LI
\*(lBvoid AFS_HOP32(afs_hyper_t a, <op>, u_int32 u)\*(lE \*(EM
Works like \*(lBAFS_HOP\*(lE except that \*(lBu\*(lE is
logically extended to 64 bits by prepending 32 zero bits (i.e.,
no sign extension).
.LI
\*(lBvoid AFS_hincr(afs_hyper_t a)\*(lE \*(EM Short for
\*(lBAFS_hadd32(a, 1)\*(lE.
.LI
\*(lBvoid AFS_hdecr(afs_hyper_t a)\*(lE \*(EM Short for
\*(lBAFS_hadd32(a, \(mi1)\*(lE.
.LI
\*(lBint AFS_hissubset(afs_hyper_t a, afs_hyper_t b)\*(lE \*(EM
Returns TRUE iff all the bits set in \*(lBa\*(lE are also set in
\*(lBb\*(lE (\*(lBa\*(lE is a subset of \*(lBb\*(lE).
.LI
\*(lBAFS_HGETBOTH(afs_hyper_t a)\*(lE \*(EM A short-hand for
passing both halves of a hyper to a function, most significant
half first.  This is convenient for calling \*(lBprintf(\*(lE),
for instance.
.LE
.P
The following macros were eliminated;
.P
.aL
.LI
\*(lBhset\*(lE \*(EM Compiler can handle assignments of both scalar and
non-scalar types.
.LI
\*(lBhget32\*(lE \*(EM Too awkward.
.LI
\*(lBhget64\*(lE \*(EM Too awkward.
.LI
\*(lBhones\*(lE \*(EM Rarely used; easily replaced with
\*(lBAFS_hset64(a, \(mi1, \(mi1)\*(lE.
.LI
\*(lBhdef64\*(lE \*(EM Replaced by \*(lBHINIT\*(lE which only
provides an initializer.
.LE
.P
.H 2 "Platform Independence"
.P
The basic tools used to achieve platform independence were
defined in \*(lBfile/util/hyper.h\*(lE.  The type
\*(lBdfsh_diskHyper_t\*(lE was used whenever 32-bit alignment
was necessary to obtain the desired packing.
.P
.dS
typedef struct {
    u_int32 dh_high;
    u_int32 dh_low;
} dfsh_diskHyper_t;
.dF
.P
To convert back and forth between \*(lBafs_hyper_t\*(lE and
\*(lBdfsh_diskHyper_t\*(lE two sets of macros were used.  The
first set preserves host order and is used by Episode.
.P
.dS
#define DFSH_MemFromDiskHyper(h, dh) \e
    AFS_hset64(h, (dh).dh_high, (dh).dh_low)
#define DFSH_DiskFromMemHyper(dh, h) \e
    ((dh).dh_high = AFS_hgethi(h), \e
     (dh).dh_low = AFS_hgetlo(h))
.dF
.P
The second set uses \*(lBntohl\*(lE/\*(lBhtonl\*(lE on the
halves and was used when architecture neutrality was
needed: ubik databases and tapes.
.P
.dS
#define DFSH_MemFromNetHyper(h, dh) \e
    AFS_hset64(h, ntohl((dh).dh_high), ntohl((dh).dh_low))
#define DFSH_NetFromMemHyper(dh, h) \e
    ((dh).dh_high = htonl(AFS_hgethi(h)), \e
     (dh).dh_low = htonl(AFS_hgetlo(h)))
.dF
.P
.H 2 "Episode Changes to Preserve On-disk Format"
.P
Several changes were made to the Episode code to insure that the disk
representation was unaffected by the changes to the hyper type:
.P
.aL
.LI
In \*(lBfixed_anode.c\*(lE, modify \*(lBdiskAnode\*(lE by
changing length to be of type \*(lBdfsh_diskHyper_t\*(lE and
renaming it to be \*(lBdiskLength\*(lE.  Also change
\*(lBvolId\*(lE similarly, though this member is not used.
.LI
In \*(lBanode.p.h\*(lE, add a new length member to the
\*(lBepia_anode\*(lE structure of type \*(lBafs_hyper_t\*(lE.
This will be a copy of the \*(lBdiskLength\*(lE member but
maintained in host native format.
.LI
Also in \*(lBfixed_anode.c\*(lE, copy the \*(lBdiskLength\*(lE
member to the length member using
\*(lBDFSH_MemFromDiskHyper()\*(lE whenever an anode is
initialized from disk: in \*(lBOpen()\*(lE and
\*(lBepia_Create()\*(lE.  Make sure length-changing operations
affect both members using \*(lBDFSH_DiskFromMemHyper()\*(lE:
\*(lBepix_SetLength()\*(lE, \*(lBepix_MoveData()\*(lE,
\*(lBepix_InsertInline()\*(lE, and
\*(lBSalvageAnodeLength()\*(lE.
.LI
In \*(lBvolume.c\*(lE, modify the \*(lBdiskVolumeHeader\*(lE
structure to use the \*(lBdfsh_diskHyper_t\*(lE type to
represent \*(lBident.id\*(lE, \*(lBversion\*(lE,
\*(lBbackingVolId\*(lE, and the \*(lBupLevelIds\*(lE array.
.LI
Modify code in \*(lBepiv_Create()\*(lE,
\*(lBepiv_GetStatus()\*(lE, \*(lBepiv_GetIdent()\*(lE,
\*(lBepiv_GetVV()\*(lE, \*(lBepiv_SetStatus()\*(lE, and
\*(lBepiv_NewVolumeVersion()\*(lE to use
\*(lBDFSH_DiskFromMemHyper()\*(lE or
\*(lBDFSH_MemFromDiskHyper()\*(lE as appropriate when copying
between the disk volume header and in-memory structures such as
\*(lBepiv_status\*(lE and \*(lBepiv_ident\*(lE.
.LI
In \*(lBfile.c\*(lE, modify the \*(lBdiskStatus\*(lE structure
member \*(lBvolumeVersionNumber\*(lE to be a
\*(lBdfsh_diskHyper_t\*(lE.
.LI
In \*(lBfile.h\*(lE, modify the fast accessing macros for status
fields to use offsets in \*(lBdiskStatus\*(lE which can no
longer be assumed to be the same as the offsets in
\*(lBepif_status\*(lE.  This is done by defining explicit
constants giving the offsets, then changing the asserts done by
\*(lBepif_Init()\*(lE in \*(lBfile.c\*(lE to verify that the
offset are correct.  Similarly, in \*(lBepif_GetStatus()\*(lE
copy the auxiliary container lengths into the proper fields
using a case statement, since the offset arithmetic no longer
works.
.LI
Modify \*(lBepif_CreateE()\*(lE, \*(lBepif_GetStatus()\*(lE,
\*(lBepif_SetStatusAndMark()\*(lE, and \*(lBepiz_VerifyFileAux()\*(lE to
use \*(lBDFSH_DiskFromMemHyper()\*(lE or
\*(lBDFSH_MemFromDiskHyper()\*(lE as appropriate.
.LE
.P
.H 2 "Fileset Location Server Changes to Preserve Interoperability"
.P
The ubik database used to store fileset location information is shared
by all flservers using a byte-level replication protocol.  This protocol
has no knowledge of how the database is represented and so it cannot
perform any transformations to fix up byte ordering or member packing
differences between architectures.  Therefore, the format of the
database must be architecture-neutral.  The convention with the design
of ubik databases has been to use network-byte-order to represent 16 and
32 bit integers in the database.  A similar convention is needed for
hypers, both to ensure precise packing and to define consistent integer
byte ordering.
.P
The strategy was to clearly separate the structures used to
represent the database from those used to transmit data to and
from clients.  The hypers in the database representation were
changed to \*(lBdfsh_diskHyper_t\*(lE.  A new header file called
\*(lBflinternal.h\*(lE was created for definitions that are not
used by clients of the flserver.  The existing \*(lBvlentry\*(lE
structure was moved there and a new \*(lBdisk_vlheader\*(lE
structure was defined to match the \*(lBvital_vlheader\*(lE
structure already defined in \*(lBfldb_data.idl\*(lE.  The
\*(lBdisk_vlheader\*(lE members \*(lBmaxVolumeId\*(lE and
\*(lBtheCellId\*(lE became \*(lBdfsh_diskHyper_t\*(lE\|'s, as did
the \*(lBvlentry\*(lE members \*(lBvolumeId\*(lE (an array of
length \*(lBMAXTYPES\*(lE) and \*(lBcloneId\*(lE.
.P
The flserver code normally converts 16 and 32 bit integers
in-place when reading from or writing to the database.  However,
because of differences in alignment, this will not work with
hypers.  Therefore, hypers were converted from
\*(lBdfsh_diskHyper_t\*(lE to \*(lBafs_hyper_t\*(lE at the
points of use, with the help of temporary variables when
necessary.  The conversions were accomplished using
\*(lBDFSH_MemFromNetHyper()\*(lE or
\*(lBDFSH_NetFromMemHyper()\*(lE which parallel the macros used
in Episode but which also apply \*(lBntohl()\*(lE or
\*(lBhtonl()\*(lE to the high and low halves of the 64-bit
quantitiy.
.P
Here are the points of use that must be converted:
.P
.aL
.LI
In \*(lBVL_GetNewVolumeId()\*(lE and
\*(lBVL_GetNewVolumeIds()\*(lE \*(lBmaxVolumeId\*(lE is
increased for new volumes, by converting \*(lBmaxVolumeId\*(lE
to an \*(lBafs_hyper_t\*(lE using
\*(lBDFSH_MemFromNetHyper()\*(lE, bumping it using
\*(lBAFS_hadd32()\*(lE and storing it back into the database
header using \*(lBDFSH_NetFromMemHyper()\*(lE.
.LI
The functions \*(lBVL_ReplaceEntry()\*(lE, \*(lBVL_GetStats()\*(lE,
\*(lBvldbentry_to_vlentry()\*(lE, \*(lBvlentry_to_vldbentry()\*(lE,
and \*(lBvlentry_to_comvldbentry()\*(lE just copy structures to or from
the database representation.
.LI
A new database is constructed in \*(lBCheckInit()\*(lE and
\*(lBtheCellId\*(lE and \*(lBmaxVolumeId\*(lE members are
initialized here.
.LI
The \*(lBFindByID()\*(lE function needs to consult the
\*(lBvlentry\*(lE\|'s id, as do \*(lBHashVolid()\*(lE,
\*(lBUnhashVolid()\*(lE, and \*(lBNextEntry()\*(lE.
.LE
.P
.H 2 "Backup Changes to Preserve Ubik Database and Tape Formats
.P
The changes to the backup system had two parts.  The first was to ensure
that the volume id stored in the ubik backup database was converted to
and from a platform independent format.  This parallels the changes made
to the flserver.  In addition, hypers are written to tape in two cases,
once in the header of ordinary fileset dumps, and the other when the
ubik database is dumped to tape.  The dump and restore paths for the
latter case are handled differently, but the basic strategy was the same
as for the ubik database.  New structures were defined to separate the
structures recognized by the RPC marshaling code from the structures
used to lay out the ubik database and the on-tape format.
.P
The changes for the ubik database were simple because only a
single hyper is stored there: the id member of the
\*(lBvolInfo\*(lE structure defined in
\*(lBfile/bakserver/database.h\*(lE.  Its type was changed to
\*(lBdfsh_diskHyper_t\*(lE and conversions were accomplished
using \*(lBDFSH_MemFromNetHyper()\*(lE and
\*(lBDFSH_NetFromMemHyper()\*(lE as appropriate.  These
conversions appear in \*(lBFillVolEntry()\*(lE,
\*(lBVolInfoMatch()\*(lE, \*(lBGetVolInfo()\*(lE,
\*(lBprintVolInfo()\*(lE, and \*(lBvolsToBudbVol()\*(lE.  The
test code duplicates a small amount of this logic.  In
\*(lBtest/file/budb/database.h\*(lE, the \*(lBvolInfo\*(lE
structure must also be changed and the sole use of the member in
\*(lBtest/file/budb/budb_dump.c:print_volInfoBlock()\*(lE needs
to use \*(lBDFSH_MemFromNetHyper()\*(lE before printing the
volume's id.
.P
The changes for the on-tape format of fileset dumps were also
pretty easy because only a single member was affected: the
\*(lBvolumeID\*(lE member of the \*(lBvolumeHeader\*(lE
structure defined in \*(lBfile/bubasics/tcdata.p.h\*(lE.  This
member was converted to net-order in
\*(lBmakeVolumeHeader()\*(lE instead of in
\*(lBvolumeHeader_hton()\*(lE where the other members are
converted because hypers cannot be converted in-place as
described earlier.  The reverse conversion occurs in
\*(lBPositionTape()\*(lE and \*(lBfillRestoreBuffers()\*(lE.
Various routines in \*(lBfile/butc/recoverDb.c\*(lE also need to
be able to interpret backup tapes: \*(lBPrintVolumeHeader()\*(lE,
\*(lBvalidVolumeHeader()\*(lE,
\*(lBAddScanToDB()\*(lE, and \*(lBdebugPrintVolumeHeader()\*(lE
but not \*(lBVolHeaderToHost()\*(lE.
.P
Saving the ubik database itself to tape is a process that uses
completely separate data paths within the backup system.  The
dump is created by the bakserver using the
\*(lBBUDB_DumpDB()\*(lE RPC which produces a byte stream
suitable for writing directly to tape.  The byte stream is not
interpreted by the RPC marshaling code and so the structures
that describe the stream must use types that pack correctly and,
of course, network byte ordering is generated by the server.
Previously the per volume information was dumped as a
\*(lBbudb_volumeEntry\*(lE (but with integers in network byte
order).  Instead, a new structure was defined in
\*(lBfile/bakserver/budb.idl\*(lE called \*(lBbudb_dbVolume\*(lE
which is similar to \*(lBbudb_volumeEntry\*(lE except that the
volume id is represented as a pair of
\*(lBunsigned32\*(lE: \*(lBstruct { unsigned32 dh_high;
unsigned32 dh_low; }\*(lE.
The member names are the same as for the
\*(lBdfsh_diskHyper_t\*(lE type, but that type cannot be
directly included in the IDL file (however, the same
\*(lBDFSH_MemFromNetHyper()\*(lE and
\*(lBDFSH_NetFromMemHyper()\*(lE macros will work).
.P
The \*(lBbudb_dbVolume\*(lE structure is filled in by the
\*(lBbakserver\*(lE\|'s \*(lBBUDB_DumpDB()\*(lE function using
\*(lBvolsToBudbVol()\*(lE.  When a ubik database dump is
restored the client code reads the tape in
\*(lBrestoreDbDump()\*(lE and calls \*(lBvolumeEntry_ntoh()\*(lE
as a utility function (even though this function is linked into
the bakserver it is never called by the server; probably these
functions should be reorganized).
.P
.H 2 "Maximum File Size Tracking"
.P
Three members were added to the structures used by the CM and PX to
describe the hosts they communicate with:
.P
.dS
unsigned32 maxFileParm;         /* value received from host */
afs_hyper_t maxFileSize;        /* max supported by host */
unsigned supports64bit:1;       /* host has 64bit fixes */
.dF
.P
In the CM these are added to \*(lBcm_server\*(lE (in
\*(lBfile/cm/cm_server.h\*(lE).  In the PX these are added to
\*(lBfshs_host\*(lE (in \*(lBfile/fshost/fshs_host.h\*(lE).  The
\*(lBmaxFileParm\*(lE member preserves the value used to set the
maximum file size (encoding described below) so that it can be
easily returned in the response to the \*(lBSetParams()\*(lE
call.  The \*(lBmaxFileSize\*(lE member is set to the largest
file length than can be supported by the remote host.
.P
The \*(lBsupports64bit\*(lE boolean is set to one (TRUE) only if
the host provides a valid indication of its maximum file size
and claims that it does not need the backward compatibility
features provided for older systems.  This bit serves to
differentiate hosts that can handle 64-bit quantities (whatever
their maximum file size) from earlier systems that suffered from
various bugs and shortcomings adversely affecting interoperation
with 64-bit machines.
.P
There are two, mostly independent, mechanisms for informing the client
and server of the maximum file size of the remote host.  The first
involves the use of the \*(lBSetParams()\*(lE.  The second involves
passing this information via parameters to the
\*(lBTKN_InitTokenState()\*(lE and \*(lBAFS_SetContext()\*(lE functions.
.P
The \*(lBSetParams()\*(lE function is defined in both the AFS and TKN
interfaces; however, while the roles of RPC client and server are
reversed for the TKN interface, the definitions of the parameter words
are fixed in terms of the DFS client (the cache manager, a.k.a. CM) and DFS
server (the file exporter, a.k.a. PX).  The \*(lBTKN_SetParams()\*(lE
function recieves the maximum file size of the DFS server on input and
returns its own limit as the client's value in the output parameter.
The \*(lBAFS_SetParams()\*(lE function receives the DFS client's maximum
on input and returns its limit as the server value in the output
parameter.
.P
Both functions take a flag argument, which is basically a sub-opcode.
The other argument is a structure of twenty (20) 32-bit words plus a
validity mask.  Two new words are defined for specifying the maximum
file size supported by the client and the server.  These are added to
\*(lBfile/config/common_data.idl\*(lE:
.P
.dS
.ne 4
const unsigned32 AFS_CONN_PARAM_MAXFILE_CLIENT = 4;
const unsigned32 AFS_CONN_PARAM_MAXFILE_SERVER = 5;

const unsigned32 AFS_CONN_PARAM_SUPPORTS_64BITS = 0x10000;
.dF
.P
The \*(lBAFS_CONN_PARAM_MAXFILE_CLIENT\*(lE value, if valid and
non-zero, specifies the maximum file size information for the DFS
client.  Similarly, \*(lBAFS_CONN_PARAM_MAXFILE_SERVER\*(lE provides the
corresponding information about the DFS server.
.P
The format of both the client and server words is the same.  The
least significant octet specifies one small integer; call it
\*(qBa\*(qE.  The next least significant octet specifies another
number; call it \*(qBb\*(qE.  Subsequent bits are interpreted as flag
bits, only one of which is presently defined.  The others are
zero.  Thus 17 bits are defined by this work for communicating
the maximum file size; the remaining 15 bits could be used for
some future purpose.
.P
The value of the host's maximum file size is 2^a\(mi2^b and is
stored in the maxFileSize member of the appropriate host
structure.  If the \*(lBAFS_CONN_PARAM_SUPPORTS_64BITS\*(lE bit
is set the \*(lBsupports64bit\*(lE member is set to one (TRUE).
In addition, if the \*(lBmaxFileSize\*(lE value is not equal to
2^31\(mi1 then \*(lBsupports64bit\*(lE is also set to TRUE.  The
default value of \*(lBmaxFileSize\*(lE is 2^31\(mi1 and
\*(lBsupports64bit\*(lE is FALSE.
.P
For example, DEC presently uses 0x132c which expresses a value of
0xffffff80000 (2^44\(mi2^19), Cray uses 0x13f or 0x7ffffffffffffffe, and
Transarc uses uses 0x1001f meaning 0x7fffffff with 64bit support.  Older
systems use 0x1f or provide no value; they are assumed to have a maximum
file size of 2^31\(mi1 and get the benefit of the backward compatibility
features.
.P
A new value for the flag parameter to \*(lBSetParams()\*(lE should be
added to \*(lBfile/fsint/afs4int.idl\*(lE:
.P
.dS
const unsigned32 AFS_PARAM_SET_SIZE = 0x3;
.dF
.P
The behavior of this flag value should be the same as for the
value \*(lBAFS_PARAM_RESET_CONN (0x1)\*(lE.  This new flag value
is needed because the DEC and Cray ports only interpret the
\*(lBMAXFILE\*(lE values if the flag has this value.
.P
Regardless of the value of the \*(lBFlags\*(lE parameter, if the
input value is valid (the corresponding bit in
\*(lBafsConnParams.Mask\*(lE is set) the caller's host structure
(\*(lBfshs_host\*(lE or \*(lBcm_server\*(lE) should be updated.
.P
On output \*(lBSetParams()\*(lE should set both client and
server words in the output structure if it knows them.  It
should do this regardless of the \*(lBFlags\*(lE value and
whether or not an input value was specified.  This returns its
maximum file size to the caller and confirms receipt, possibly
via some earlier call, of the caller's maximum.
.P
When the \*(lBSetParams()\*(lE call returns the remote host's
value is extracted from the output \*(lBafsConnParams\*(lE
structure and processed as described above.
.P
The \*(lBTKN_SetParams()\*(lE function is not called at present, but is
instantiated in \*(lBfile/cm/cm_tknimp.c\*(lE,
\*(lBfile/rep/rep_main.c\*(lE, \*(lBfile/userInt/fts/volc_tokens.c\*(lE,
and \*(lBtest/file/itl/fx/itl_fxToken.c\*(lE.  Only the first of these
three and the \*(lBSAFS_SetParams()\*(lE function defined in
\*(lBfile/px/px_intops.c\*(lE, do the processing just described, the
others just return \*(lBEINVAL\*(lE.
.P
The DFS Client makes the \*(lBAFS_SetParams()\*(lE call to determine the
server's maximum file size in \*(lBcm_RecoverTokenState()\*(lE if it
does not already know the size via an earlier
\*(lBAFS_SetContext()\*(lE\ / \*(lBTKN_InitTokenState()\*(lE
exchange.  This ensures that the CM
knows whether the server can support 64-bit token ranges, before
restoring its token state with that server.  Because the server may have
rebooted since we last contacted it, \*(lBcm_ConnAndReset()\*(lE resets
\*(lBmaxFileParm\*(lE, \*(lBmaxFileSize\*(lE, and
\*(lBsupports64bit\*(lE before calling
\*(lBcm_RecoverTokenState()\*(lE.  That function calls a new
function, \*(lBcm_GetServerSize()\*(lE defined in
\*(lBfile/cm/cm_tknimp.c\*(lE, which makes the actual call to
\*(lBAFS_SetParams()\*(lE if \*(lBmaxFileParm\*(lE is zero and
passes the resulting server size parameter to the same function
used by \*(lBSTKN_SetParams()\*(lE,
\*(lBSTKN_InitTokenState()\*(lE, and
\*(lBcm_QueuedRecoverTokenState()\*(lE.
.P
The changes to \*(lBTKN_InitTokenState()\*(lE and
\*(lBAFS_SetContext()\*(lE are simpler; they both have serveral spare
parameters.  One spare input parameter to each is used to pass the
maximum file size information of the caller to the remote host.
.P
In \*(lBfile/fsint/tkn4int.idl\*(lE the description of
\*(lBTKN_InitTokenState()\*(lE is changed so that the
\*(lBspare1\*(lE input parameter becomes
\*(lBserverSizesAttrs\*(lE:
.P
.dS
.ne 3
error_status_t TKN_InitTokenState       
(/* provider_version(1) */
    [in]  handle_t    h,
    [in]  unsigned32  Flags,
    [in]  unsigned32  hostLifeGuarantee,
    [in]  unsigned32  hostRPCGuarantee,
    [in]  unsigned32  deadServerTimeout,
    [in]  unsigned32  serverRestartEpoch,
    [in]  unsigned32  serverSizesAttrs,
    [in]  unsigned32  spare2,
    [in]  unsigned32  spare3,
    [out] unsigned32 *spare4,
    [out] unsigned32 *spare5,
.ne 2
    [out] unsigned32 *spare6
);
.dF
.P
This function is instantiated as \*(lBSTKN_InitTokenState()\*(lE in four
places where the function definition needs to be updated:
\*(lBfile/cm/cm_tknimp.c\*(lE, \*(lBfile/rep/rep_main.c\*(lE,
\*(lBfile/userInt/fts/volc_tokens.c\*(lE, and
\*(lBtest/file/itl/fx/itl_fxToken.c\*(lE.  The parameter is ignored in
all of these except \*(lBcm_tknimp.c\*(lE.  In that case, the received
value is processed in the same way as described above for the
\*(lBSetParams()\*(lE functions.
.P
This function is called only from \*(lBtokenint_InitTokenState()\*(lE in
\*(lBfile/fshost/fshs_hostops.c\*(lE.  The seventh parameter is changed
from zero to the local maximum file size information encoded as
described above.
.P
The \*(lBTKN_InitTokenState()\*(lE call by the server is
triggered when the client calls \*(lBAFS_SetContext()\*(lE to
initialize a new connection and the server can find no
information about the client.  This function is defined in
\*(lBfile/fsint/afs4int.idl\*(lE and instantiated in
\*(lBfile/px/px_intops.c\*(lE.  The new definition changes the
spare input parameter \*(lBparm6\*(lE into
\*(lBclientSizesAttrs\*(lE.
.P
.dS
.ne 3
error_status_t AFS_SetContext
(/* provider_version(1) */
    [in] handle_t    h,
    [in] unsigned32  epochTime,
    [in] afsNetData *callbackAddr,
    [in] unsigned32  Flags,
    [in] afsUUID    *secObjectID,
    [in] unsigned32  clientSizesAttrs,
.ne 2
    [in] unsigned32  parm7
);
.dF
.P
The callers of \*(lBAFS_SetContext()\*(lE in
\*(lBfile/cm/cm_conn.c\*(lE (from both
\*(lBcm_ConnAndReset()\*(lE and \*(lBcm_ConnByHost()\*(lE),
\*(lBfile/rep/rep_host.c\*(lE,
\*(lEfile/userInt/fts/volc_tokens.c\*(lE, and
\*(lBtest/file/itl/fx/itl_fxAPI.c\*(lE pass their local maximum
file size information (encoded as above) as the second to last
parameter.  On receipt of the \*(lBAFS_SetContext()\*(lE the PX
processes the \*(lBclientSizesAttrs\*(lE parameter as described
for \*(lBAFS_SetParams()\*(lE.
.P
.H 2 "Enforcing Maximum File Sizes"
.P
The maximum file size information communicated via the
mechanisms just described are used in two different ways.  The
new CM uses the server's maximum length to prevent the client
application from creating a file larger than can be stored back
to the server.  This is important because the store-back process
happens largely in the background and errors cannot be reliably
communicated to the application.  To accomplish this
\*(lBcm_write()\*(lE and \*(lBcm_setattr()\*(lE return
\*(lBEFBIG\*(lE if these functions would try to extend the
length past what the server can support.
.P
The other area involves treatment of files larger than a client can
handle.  We follow the approach Cray took, which is also recommended by
the Large File Summit in its proposal to X/Open [LFS 96].  This approach
conservatively returns errors to applications that are unaware of the
existence of files larger than 2^31\(mi1 bytes.  In DFS there are two
layers at which we must apply this protection.  If the DFS client is old
it is protected by the PX which hides the large files from it.  However,
new clients see large files and protect their callers by hiding large
files from them.
.P
For old clients referencing large files, the server returns
\*(lBDFS_EOVERFLOW\*(lE from \*(lBSAFS_FetchStatus()\*(lE and
\*(lBSAFS_GetToken()\*(lE.  In response to
\*(lBSAFS_Lookup()\*(lE, \*(lBSAFS_LookupRoot()\*(lE and
\*(lBSAFS_BulkFetchStatus()\*(lE calls, the server returns
invalid status by setting \*(lBfileType\*(lE to
\*(lBInvalid\*(lE and refuses to return tokens for these files.
Other status returning operations (e.g.,
\*(lBSAFS_Rename()\*(lE) return invalid statuses for these files
and other operations that can return tokens (e.g.,
\*(lBSAFS_FetchData()\*(lE) do not do so for these large files.
.P
The new Transarc reference port of the CM, whose maximum file size
remains 2^31\(mi1, is modified to remember which files have lengths too
long to represent.  It returns the appropriate errors to applications
from vnode operations on those files.
.P
To do this a new bit is defined for the scache states word in
\*(lBfile/cm/cm_scache.h\*(lE called \*(lBSC_LENINVAL\*(lE.
This bit is set by \*(lBcm_MergeStatus()\*(lE in
\*(lBfile/cm/cm_vnodeops.c\*(lE when a valid status block is
received.  Its value is one if and only if the length is greater
than 2^31\(mi1.  The token management functions
\*(lBcm_HaveTokensRange()\*(lE (which was called
\*(lBcm_HaveTokens()\*(lE) and a new function
\*(lBcm_HaveTokens()\*(lE report that the
\*(lBTKN_STATUS_READ\*(lE token for these files is unavailable.
In addition, the functions \*(lBcm_GetTokens()\*(lE and
\*(lBcm_GetTokensRange()\*(lE return \*(lBEOVERFLOW\*(lE (or
\*(lBEFBIG\*(lE if \*(lBEOVERFLOW\*(lE is undefined) when a
\*(lBTKN_STATUS_READ\*(lE token is requested for such a file.
This error is propagated up to the vnode operations such as
\*(lBcm_getattr()\*(lE.
.P
In a similar vein, \*(lBSAFS_Readdir()\*(lE and
\*(lBSAFS_BulkFetchStatus()\*(lE are modified to return
\*(lBDFS_EOVERFLOW\*(lE to old clients if the
\*(lBNextOffsetp\*(lE parameter would be larger than 2^31\(mi1.
New clients receive (the possibly too large)
\*(lBNextOffset\*(lE intact, and return \*(lBEOVERFLOW\*(lE from
\*(lBcm_FetchDCache()\*(lE in \*(lBfile/cm/cm_dcache.c\*(lE and
from \*(lBcm_BulkFetchStatus()\*(lE in
\*(lBfile/cm/cm_dnamehash.c\*(lE if \*(lBNextOffset\*(lE is
larger than their local maximum file size.
.P
As a safety check, the PX also checks for requests that would increase
the length past what it can handle and rejects these with
\*(lBEFBIG\*(lE.  The checks are performed at the beginning of
\*(lBSAFS_FetchData()\*(lE, \*(lBSAFS_StoreData()\*(lE,
\*(lBSAFS_Readdir()\*(lE, \*(lBSAFS_BulkFetchStatus()\*(lE, and
\*(lBpx_PreSetExistingStatus()\*(lE.  The latter function handles status
setting operations that can change the length, such as
\*(lBSAFS_StoreStatus()\*(lE.
.P
The Large File Summit proposes returning \*(lBEOVERFLOW\*(lE, a new
error code, when a file's length is too large to represent.  At the
present, the Solaris platform defines \*(lBEOVERFLOW\*(lE but the others
do not.  In any case, these other platforms will not use the same value,
so DFS needs to define a platform independent value for this error as we
have done with other error codes.  \*(lBDFS_EOVERFLOW\*(lE was added to
the list in \*(lBfile/osi/osi_dfserrors.h\*(lE where it is defined as 94
(decimal).  The mapping table for each platforms was updated so that
this is mapped to \*(lBEOVERFLOW\*(lE on Solaris and \*(lBEFBIG\*(lE
otherwise.
.P
.H 2 "Token Byte Range Changes"
.P
Support for large files also depends upon being able to represent tokens
covering any byte range in large files.  While the token manager has no
trouble with byte ranges beyond 2^31\(mi1, limits on this range do
appear in other places.  Some of these are due to limits of the local
operating system but others are in platform independent code.  This code
needs to be made 64-bit ready.
.P
.H 3 "Whole file tokens"
.P
Many places in the code use the value 2^31\(mi1 to represent the maximum
possible file offset when specifying a byte range to cover a whole file.
To remedy this the default byte range for tokens is changed from
0..2^31\(mi1 to 0..2^63\(mi1.  This applies to whole file tokens requested by
the CM (e.g., \*(lBcm_GetTokens()\*(lE defined in
\*(lBfile/cm/cm_tokens.c\*(lE), to tokens optimistically granted by the PX
(e.g., using the macro \*(lBInitToken()\*(lE defined in
\*(lBfile/px/px_intops.c\*(lE; this macro was formerly called
\*(lBtkm_initToken()\*(lE and was defined in
\*(lBfile/tkm/tkm_tokens.h\*(lE, even though it was only used in
\*(lBpx_intops.c\*(lE) and for non-range file and volume tokens.
.P
.H 3 "TKC byte range representation"
.P
The TKC module manages tokens for access to local file systems that
may also be exported.  The representation it uses for byte ranges is
changed to use a newly defined type consisting of a pair of hypers.
.P
In \*(lBfile/tkc/tkc.h\*(lE a new type is defined:
.P
.dS
typedef struct {
    afs_hyper_t beginRange;
    afs_hyper_t endRange;
} tkc_byteRange_t;
.dF
.P
This type replaces the use of hypers to represent byte ranges: in
\*(lBstruct tkc_sets\*(lE and as a parameter to \*(lBtkc_Get()\*(lE,
\*(lBtkc_GetToken()\*(lE, \*(lBtkc_HaveTokens()\*(lE,
\*(lBtkc_GetLocks()\*(lE, and \*(lBtkc_Putlocks()\*(lE, and in callers
of \*(lBtkc_GetLocks()\*(lE and \*(lBtkc_PutLocks()\*(lE in the platform
specific xvnode implementations of the vnode file lock functions.
.P
Since the TKC does not use byte ranges on data tokens, the only
significant changes are in \*(lBtkc_PutLocks()\*(lE defined in
\*(lBfile/tkc/tkc_locks.c\*(lE.  Even in this function a straightforward
mapping of the old representation to the new one is sufficient.  At the
same time, a few local variables used to compare byte ranges were
changed from type \*(lBlong\*(lE to type \*(lBafs_hyper_t\*(lE.
.P
.H 3 "CM 64-bit byte range checks"
.P
The CM was not very good about checking all 64-bits of token byte ranges
in some cases.  In \*(lBRevokeDataToken()\*(lE, defined in
\*(lBfile/cm/cm_tknimp.c\*(lE, the comparison of cached chunk offsets
was ignoring the high bits of the byte range.  A similar problem existed
in the slice-and-dice evaluation performed by
\*(lBcm_TryLockRevoke()\*(lE in \*(lBfile/cm/cm_lockf.c\*(lE and the
loop over all dcache entries performed by
\*(lBcm_UpdateDCacheOnLineState()\*(lE in \*(lBfile/cm/cm_dcache.c\*(lE.
These were fixed by changing local variables to be hypers and using
hyper comparison macros throughout.
.P
.H 2 "Backward Compatibility with Older Systems"
.P
The maximum file size of systems that do not provide one is assumed to
be 2^31\(mi1.  This assumption allows new (64-bit capable) hosts to
accomodate most of the limitations of these systems.  However, several
problems require additional countermeasures.  These countermeasures are
employed whenever the remote host's maximum file size is equal to 2^31\(mi1
and the host hasn't explicitly said it supports 64-bit offsets by
specifying \*(lBAFS_CONN_PARAM_SUPPORTS_64BITS\*(lE when communicating
its maximum file size.
.P
These countermeasures mostly consist of mapping between the value
representing the largest possible file offset from 2^63\(mi1 used by new
hosts and 2^31\(mi1 which was used by old hosts.  This happens in these
places:
.P
.aL
.LI
In \*(lBCM_EndPartialTokenGrant()\*(lE received tokens coming
from old servers have their \*(lBendRanges\*(lE mapped from
2^31\(mi1 (or any larger value in case of truncation by the
server) to 2^63\(mi1.
.LI
In \*(lBSAFS_GetToken()\*(lE requests for tokens from old
clients are adjusted so the \*(lBendRange\*(lE is mapped from
2^31\(mi1 to 2^63\(mi1.
.LI
In \*(lBpx_SetTokenStruct()\*(lE tokens being return to an old
client have their \*(lBendRanges\*(lE mapped from 2^63\(mi1 to
2^31\(mi1.  If the resulting token has an empty byte range
(i.e., \*(lBbeginRange\*(lE was also above 2^31\(mi1), the token
is zeroed.
.LI
In \*(lBfshs_RevokeToken()\*(lE the column A and B tokens
offered to old clients during a revoke are eliminated if their
range started beyond 2^31\(mi1 and have their
\*(lBendRanges\*(lE truncated to 2^31\(mi1.  Tokens with empty
ranges after mapping are invalidated and the appropriate offered
bit is cleared to withdraw the offer.
.LE
.P
In addition, OT13445 describes a problem in which the most
significant 32 bits of the start and end position in
\*(lBafsRecordLock\*(lE were uninitialized.  The two recently
defined members \*(lBl_start_pos_ext\*(lE and
\*(lBl_end_pos_ext\*(lE, were never being set.  The changes
described above that use the IDL \*(lB[represent_as]\*(lE
mechanism fix this problem.  However, older systems still
produce lock ranges that may appear to contain garbage to a
64-bit host.
.P
To address this the high 32 bits of these ranges are cleared when they
come from old hosts.  This should present no operational problem since
old clients can not hold locks on files beyond 2^31\(mi1 nor can old
servers contain files longer than that.  The following functions contain
this protection:
.P
.aL
.LI
In \*(lBfshs_RevokeToken()\*(lE when processing the output returned from
\*(lBTKN_TokenRevoke()\*(lE.
.LI
In \*(lBcm_GetTokensRange()\*(lE after the call to
\*(lBAFS_GetToken()\*(lE.
.LI
In \*(lBcm_GetHereToken()\*(lE after the call to
\*(lBAFS_GetToken()\*(lE.
.LI
In \*(lBcm_RecoverSCacheToken()\*(lE after the call to
\*(lBAFS_GetToken()\*(lE.
.LE
.P
.H 2 "Miscellaneaous Changes"
.P
.H 3 "Printed representation"
.P
Unfortunately there is no good way to handle printing hypers in
a generic fashion.  While platforms that support a 64-bit scalar
type have some \*(lBprintf()\*(lE control string to convert
them, it was not feasible to parameterize all control strings.
.P
So, as a compromise, we have tried to standardize on
\*(lB%u,,%u\*(lE as the printed representation for hypers.  The
DFS code base contains a large variety of forms, many of which
were converted to this standard form.  Printing hypers with this
control string requires passing a pair of arguments explicitly
to \*(lBprintf()\*(lE.  This was simplified somewhat by liberal
use of the \*(lBDFSH_HGETBOTH()\*(lE macro.
.P
The util module now exports two new functions (declared in
\*(lB<dcedfs/hyper.h>\*(lE) to help with string representations.
.P
.aL
.LI
\*(lBchar *dfsh_HyperToStr(afs_hyper_t *h, char *s)\*(lE \*(EM Calls
\*(lBsprintf()\*(lE with \*(lB"%u,,%u"\*(lE as the control string.  Note
that it takes the \*(iBaddress\*(iE of a hyper for historical reasons.
As a convenience it returns its second argument.
.LI
\*(lBint dfsh_StrToHyper(const char *numString, afs_hyper_t
*hyperP, char **cp)\*(lE \*(EM Takes a string and converts it
into a hyper if possible.  If it succeeds, the value is returned
in \*(lB*hyperP\*(lE, a pointer to the first unused character in
\*(lBnumString\*(lE is returned in \*(lBcp,\*(lE and the
function returns zero.  The \*(lBcp\*(lE argument may be NULL if
no output string pointer is desired.
.P
The function is liberal about the input it accepts, for instance,
\*(lB"\(mi1"\*(lE, \*(lB"4294967295,,\(mi1"\*(lE and
\*(lB"0xffFFffff,,037777777777"\*(lE all produce a hyper containing 64
one bits.
.LE
.P
.H 3 "ICL logging"
.P
The ICL package has a hyper type, \*(lBICL_TYPE_HYPER\*(lE,
which takes the address of a hyper and inserts a pair of
\*(lBu_int32\*(lE\|'s into the log.  These integers are passed
directly to \*(lBprintf()\*(lE by \*(lBdfstrace()\*(lE, high
half first, so the format string should contain two integer
translation directives; typically a hyper is printed as
\*(lB%u,,%u\*(lE.  In several cases a pair of
\*(lBICL_TYPE_LONG\*(lEs were being passed to ICL traces where
it made more sense to pass the hyper by reference.  No changes
were necessary to the print strings.
.P
...\" =========================================================================
...\" Acknowledgements if any go here, at end of body of doc.
...\" =========================================================================
.P
.H 1 "ACKNOWLEDGEMENTS"
.P
Thanks to Steve Strange (DEC), Steve Lord (Cray), Carl Burnett (IBM),
Craig Everhart (Transarc) and Blake Lewis (Transarc) for very helpful
comments both on this document and the code changes it describes.
.P
...\" =========================================================================
...\" References go here, as an unnumbered heading.
...\" =========================================================================
.P
.HU "REFERENCES"
.P
.VL 12 0
.LI "[RFC\ 51.1]"
S. Strange, \*(qBDFS Source Code Cleanup to Support Both
32-Bit and 64-Bit Architectures\*(qE, DCE-RFC 51.1, February 1994.
.LI "[RFC\ 51.2]"
S. Strange, \*(qBA 32-Bit/64-Bit Interoperability Solution for DFS\*(qE,
DCE-RFC 51.2, June 1995.
.LI "[LFS 96]"
Large File Summit. "Adding Support for Arbitrary File Sizes to the
Single UNIX Specification", 20 March 1996,
http://www.sas.com:80/standards/large.file.
.LE
.P
...\" =========================================================================
...\" Author's address goes here, as unnumbered heading, at end of doc.
...\" =========================================================================
.P
.ne 3+5
.HU "AUTHOR'S ADDRESS"
.P
.tl $Ted Anderson$$Internet email: ota+@transarc.com$
.tl $Transarc Corporation$$Telephone: +1-412-338-4410$
.tl $707 Grant St.$$$
.tl $Pittsburgh, PA 15219$$$
.tl $USA$$$
...\" =========================================================================
...\" Done!
...\" =========================================================================
