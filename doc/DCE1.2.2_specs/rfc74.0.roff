...\" OSF-RFC 74.0
...\"
...\" FORMATTING INSTRUCTIONS for this RFC:
...\"       nroff -Tlpr rfc74.0.roff > rfc74.0.txt
...\"       troff -Tps rfc74.0.roff | <ps-post-processor> > rfc0.1.ps
...\" (Where "troff" means "device-independent troff", or "ditroff".)
...\"
...\" If troff is not supported for a given RFC, insert the following:
...\" .if t \{\
...\" .tm *** Troff not supported for this RFC.
...\" .ex \}
...\"
...\" =========================================================================
...\" This template first sets a bunch of *roff options (authors/readers
...\" don't usually have to know about these).
...\" Then it defines some strings and macros, many of which deal with
...\" things that differ between nroff & troff (some of these may not be
...\" perfect, but they're better than nothing -- to do a really good
...\" job would require a real semantic markup language.
...\" Convention: "Begin/End" for strings, "Start/Finish" for macros.
...\" Strings:
...\"       \*(f!        - Footnote string (replaces \*F).
...\"       \*(hB, \*(hE - Page header/footer font (internal use).
...\"       \*(kB, \*(kE - Doc header font (internal use).
...\"       \*(qB, \*(qE - Quotations.
...\"       \*(iB, \*(iE - Italics/emphasis in primary font.
...\"       \*(bB, \*(bE - Bold font.
...\"       \*(lB, \*(lE - Literal font.
...\"       \*(jB, \*(jE - Italics/emphasis in literal font.
...\"       \*(nH        - Default note header string.
...\" Macros:
...\"       .aH      - Appendix header macro (uses number register \na).
...\"       .aL      - Automatic list macro (replaces .AL; uses num reg \ng).
...\"       .tS, .tF - Title start/finish (internal use).
...\"       .cS, .cF - Displays (no-fill) without indentation.
...\"       .dS, .dF - Displays (no-fill) with indentation.
...\"       .iS, .iF - Indented (fill) text.
...\"       .nS, .nF - Note.
...\" -------------------------------------------------------------------------
...\" First, set up some number registers here (instead of on command line),
...\" and include the "mm" macro package here (instead of on command line).
...\" -------------------------------------------------------------------------
.if n .nr L 66 \" Nroff page length = 66 lines.
.if t .nr L 11i \" Troff page length = 11 inches.
.if n .nr W 72 \" Nroff page width = 72 columns.
.if t .nr W 6.5i \" Troff page width = 6.5 inches.
.if n .nr O 3 \" Nroff page offset = 3 columns.
.if t .nr O 0.75i \" Troff page offset = 0.75 inches.
.nr N 2 \" No header on page 1.
.so /usr/lib/tmac/tmac.m \" Points to "mm" package, in /usr/lib/macros.
...\" -------------------------------------------------------------------------
...\" Next, twiddle the "mm" package to suit our preferred style.
...\" -------------------------------------------------------------------------
...\" Point size and font types.
...\" -------------------------------------------------------------------------
.if n .fp 1 R \" "Regular" font ONLY -- don't use any others in nroff.
.if t \{ .S 10 12 \" Point size = 10, vertical spacing = 12.
...\" Note: Some systems give different names to these fonts.
.fp 1 R \" Times roman.
.fp 2 I \" Times italic.
.fp 3 B \" Times bold.
.fp 4 BI \" Times bold italic.
.fp 5 CW \" Courier.
.fp 6 CI \" Courier oblique.
.fp 7 CB \" Courier bold.
.fp 8 CX \" Courier bold oblique.
.fp 9 H \" Helvetica.
.fp 10 HI \" Helvetica oblique.
.fp 11 HB \" Helvetica bold.
.fp 12 HX \" Helvetica bold oblique.
.fp 13 S \} \" Special symbol font -- normally only called automatically.
...\" -------------------------------------------------------------------------
...\" Headings; page header and footers; titles.
...\" -------------------------------------------------------------------------
.nr Ej 0 \" No eject for first-level headings.
.nr Hs 7 \" Heading space level = blank line after heading (all levels).
.nr Hb 7 \" Heading break level = break after heading (all levels).
.nr Hi 1 \" Post-heading indent = paragraph indent.
.nr Hc 0 \" Heading centering = none.
.if n .ds HF 1 1 1 1 1 1 1 \" Heading fonts = regular (no underlining).
.if t .ds HF 11 11 11 11 11 11 11 \" Heading fonts = Helvetica bold.
.if t .ds HP 0 0 0 0 0 0 0 \" Heading point sizes (= default).
.HM 1 1 1 1 1 1 1 \" Heading mark = arabic (all levels).
.nr Hu 1 \" Unnumbered heading level = 1 (see aH macro, below).
.de HX \" Beginning-of-heading processing.
.in 0 \" Left justify headings.
.ie     \\$2=0 .ds }0\" Null string heading mark for HU.
.el .ie \\$1=1 .ds }0 \\n(H1.\ \&\" Heading marks = dotted sections + 1 space.
.el .ie \\$1=2 .ds }0 \\n(H1.\\n(H2.\ \&
.el .ie \\$1=3 .ds }0 \\n(H1.\\n(H2.\\n(H3.\ \&
.el .ie \\$1=4 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\ \&
.el .ie \\$1=5 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\ \&
.el .ie \\$1=6 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\\n(H6.\ \&
.el .if \\$1=7 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\\n(H6.\\n(H7.\ \&
..
.de HZ \" End-of-heading processing.
.if n .in 3 \" Indent body of doc by 3 columns in nroff.
.if t .in 0 \" Don't indent in troff.
..
.if n .ds hB \&\" Page header/footer font begin in nroff.
.if t .ds hB \f9\" Page header/footer font begin in troff.
.if n .ds hE \&\" Page header/footer font end in nroff.
.if t .ds hE \fP\" Page header/footer font end in troff.
.if n .ds kB \&\" Doc header font begin in nroff.
.if t .ds kB \f(11\" Doc header font begin in troff.
.if n .ds kE \&\" Doc header font end in nroff.
.if t .ds kE \f1\" Doc header font end in troff.
.de tS \" Title start.
.SP 2 \" 2 blank lines.
.ce 99 \" Center (each line of) title.
.if t \{ .ft 11 \" Bold helvetica.
.S +2 D \} \" Bigger point size.
..
.de tF \" Title finish.
.ce \" Turn off centering.
.SP 1 \" 1 blank line.
.if t \{ .ft 1 \" Return to regular font.
.S P P \} \" Return to regular point size.
..
...\" -------------------------------------------------------------------------
...\" Special Appendix heading macro, .aH.
...\" -------------------------------------------------------------------------
.nr a 0 1 \" Appendix number.
.af a A \" Assign format upper-case alpabetic to number register a.
.de aH \" Appendix heading macro.
.if \\na=0 \{ .nr H1 0 \" Reset H1 to 0.
.HM A 1 1 1 1 1 1 \} \" Heading mark = Upper case alphabetic + arabics.
.HU "APPENDIX \\n+a. \\$1"
..
...\" -------------------------------------------------------------------------
...\" Paragraph stuff.
...\" -------------------------------------------------------------------------
.nr Pt 0 \" Paragraph type = left-justified.
.nr Pi 0 \" Paragraph indent = 0.
.nr Ps 1 \" Paragraph spacing = 1 blank space.
...\" -------------------------------------------------------------------------
...\" Special list macro, .aL (replaces .AL, for all levels).
...\" This should be used for almost all lists (including ".LI "\ "").
...\" The only exception is variable lists (.VL, indented by multiples of 6).
...\" -------------------------------------------------------------------------
.de aL
.nr g \\n(:g
...\" In-line lists should be numbered (by hand): (1), (2), (3), ...
.ie     \\ng=0 .LB 6 0 1 3 a \" 1st level: (a), (b), (c), ...
.el .ie \\ng=1 .LB 6 0 1 3 i \" 2nd level: (i), (ii), (iii), ...
.el .ie \\ng=2 .LB 6 0 1 4 a \" 3rd level: [a], [b], [c], ...
.el .ie \\ng=3 .LB 6 0 1 4 i \" 4th level: [i], [ii], [iii], ...
.el .ie \\ng=4 .LB 6 0 1 6 a \" 5th level: {a}, {b}, {c}, ...
.el .if \\ng=5 .LB 6 0 1 6 i \" 6th level: {i}, {ii}, {iii}, ...
..
.nr Ls 6 \" Blank lines between all list items, by default (but adjustable).
...\" -------------------------------------------------------------------------
...\" Footnote stuff; special footnote string, \*(f!.
...\" -------------------------------------------------------------------------
.if n .ds f! [\\n+(:p]\" Footnote string (replaces \*F in nroff).
.if t .ds f! \\*F\" Footnote string (same as \*F in troff).
.if n .FD 6 \" Footnotes not hyphenated or indented, label left justified.
.if t .FD 5 \" Footnotes hyphenated, not indented, label left justified.
.nr Fs 1 \" 1 blank line between footnotes.
...\" -------------------------------------------------------------------------
...\" Line adjustment stuff.
...\" -------------------------------------------------------------------------
.if n .nr Hy 0 \" No hyphenation in nroff.
.if t .nr Hy 1 \" Hyphenate in troff.
.if n .SA 0 \" Set adjust: left margin only in nroff.
.if t .SA 1 \" Set adjust: left and right margins in troff.
...\" -------------------------------------------------------------------------
...\" Miscellaneous stuff.
...\" -------------------------------------------------------------------------
.ta \" No tabs by default -- set them up by hand as needed.
.nr Si \n(Ls \" Default indent for .DS display macro = 6 (use in troff only).
...\" -------------------------------------------------------------------------
...\" Displays.
...\" -------------------------------------------------------------------------
.de cS \" Display start: no-fill, literal font, no indentation.
.P
.nf \" No fill mode.
.if t .ft 5 \" Constant width font in troff.
..
...\" Within .cS, ".ne N"'s can be added by hand, but should be minimized.
.de cF \" Display finish.
.if t .ft 1 \" Back to standard font in troff.
.fi \" Fill mode.
.P
..
.de dS \" Display start: no-fill, literal font, with indentation.
.P
.aL \" Use .aL macro for consistent indentation.
.nf \" No fill mode.
.LI "\ " \" List item will no (visible) marker.
.if t .ft 5 \" Constant width font in troff.
..
...\" Within .dS, ".ne N"'s can be added by hand, but should be minimized.
.de dF \" Display finish.
.if t .ft 1 \" Back to standard font in troff.
.fi \" Fill mode.
.LE
.P
..
.de iS \" Indent start: fill, regular font, with indentation.
.P
.aL
.LI "\ "
..
.de iF \" Indent finish.
.LE
.P
..
.ds nH NOTE\"Default note header string -- can be changed by author.
.de nS \" Note start: fill, italics font, with indentation.
.P
.aL \" Use .aL macro for consistent indentation.
.LI "\ " \" List item will no (visible) marker.
.if t .ft 2 \" Italics font in troff, and reverse roman <--> italic fonts:
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f1\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.ie \\n(.$=0 \\*(nH:\" Default header string if none supplied by author.
.el \\$1:\" Header string supplied by author as argument to .nS macro.
..
.de nF \" Note finish.
.if t .ft 1 \" Back to standard font in troff, and remap font macros:
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f2\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.LE
.P
..
...\" -------------------------------------------------------------------------
...\" Quotation marks and font toggles.
...\" -------------------------------------------------------------------------
.if n .ds qB \&"\" Quotation begin in nroff.
.if t .ds qB ``\" Quotation begin in troff.
.if n .ds qE \&"\" Quotation end in nroff.
.if t .ds qE ''\" Quotation end in troff.
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f2\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.if n .ds bB *\" Bold font begin in nroff.
.if t .ds bB \f3\" Bold font begin in troff.
.if n .ds bE *\" Bold font end in nroff.
.if t .ds bE \fP\" Bold font end in troff.
.if n .ds lB `\" Literal font begin in nroff.
.if t .ds lB \f5\" Literal font begin in troff.
.if n .ds lE '\" Literal font end in nroff.
.if t .ds lE \fP\" Literal font end in troff.
.if n .ds jB <\" Italics/emphasis literal font begin in nroff.
.if t .ds jB \fP\f6\" Italics/emphasis literal font begin in troff.
.if n .ds jE >\" Italics/emphasis literal font end in nroff.
.if t .ds jE \fP\f5\" Italics/emphasis literal font end in troff.
...\" -------------------------------------------------------------------------
...\" No diffmarks by default, i.e., define .mc to be null.
...\" (Comment out this null definition to turn diffmarking on.)
...\" -------------------------------------------------------------------------
.de mc
..
...\" =========================================================================
...\" Finally, it's time to start writing the document!
...\" The OSF-RFC author modifies the following header/footer info.
...\" (The major/minor number is assigned by the OSF-RFC Editor.)
...\" =========================================================================
.ND "May 1995" \" Date must be hard-coded.
.PH "$\*(hBOSF-RFC 74.0$Server Preferences in DFS$\\\\*(DT\*(hE$"
.PF "$\*(hBBerman$DRAFT #1$Page \\\\n%\*(hE$" \" Draft version.
.PF "$\*(hBBerman$$Page \\\\n%\*(hE$" \" Final version.
...\"
...\" Following are the first printed lines (header info) of the document:
...\"
\&\" Force top-of-first-page trap to position the following info correctly.
.tl $\*(kBOpen Software Foundation$$S. Berman (Transarc)\*(kE$
.tl $\*(kBRequest For Comments: 74.0$$\*(kE$
.tl $\*(kB\*(DT$$\*(kE$
.tS \" Title, in all capitals (can span multiple lines):
SERVER PREFERENCES IN DFS
.tF
...\" =========================================================================
...\" Now, the actual body of the document!!
...\" Heading capitalization style:
...\"     1st level: CAPITALIZE ALL WORDS
...\"     2nd level: Capitalize Initial Letters of All (Significant) Words
...\"     3rd-7th level: Capitalize first letter of first word only
...\" =========================================================================
.P
.H 1 "INTRODUCTION" \" Always start with an introduction section.
.P
The goal of this work is to modify the DFS Cache Manager to adhere to a
set of user-specified preferences determining which hosts to contact for
various services.  This work proposes to give the DFS Cache Manager the
ability to allow administrative users to direct preference for one file
server over another.  It also chooses which server to contact first
intelligently in the absence of specified preferences.  Server preferences
in DFS will utilize a \*(qBrank\*(qE value issued to each file server
with which
the Cache Manager has communicated.  This rank value is examined whenever
a new fileset is accessed to determine the order in which servers
containing read-only replicas and read-write filesets will be sought out.
.P
.H 1 "BACKGROUND INFORMATION"
.P
In a DFS cell where some file servers contain read-write filesets and
others contain read-only replicas, we wish to select the file server that
is best able to provide the data to us.  \*(qBBest able\*(qE is a
qualitative term that may include such criteria as, file server cpu model
and current load, network \*(qBdistance\*(qE from the client, or even
network link throughput on the route between the client and servers.
Since many factors will be important in deciding server preferences, I do
not address these issues; instead I propose a method for setting and
abiding by server preferences, and leave the rest to the system
administrator.  In the case of no specified server preference, a
reasonable default value can be computed based only on what the network
connection is between the client and server.  These values will establish
an intelligent set of default preferences.
.P
The common file network topology is one in which the read-write version of
a particular fileset is located on a server host attached to the backbone
network, with read-only replicas on servers on each subnet.  Given a
\*(iBrandom\*(iE server selection, the load will be distributed evenly
across the fileservers, but (n\(mi1)/n requests will probably be
traversing the network backbone.  We wish to dictate a default preference
that would force the Cache Manager to prefer \*(qBcloser\*(qE servers over more
\*(qBdistant\*(qE servers.  In this analysis, \*(qBdistance\*(qE is
considered to be a
measure of how many network routing devices a message must pass through
before reaching its destination.
.P
The primary concern is network utilization, with load balancing a
secondary concern.  Note that the random technique did not achieve true
load balancing (\*(qBfrom each according to his ability, to each according to
his need\*(qE), either.  It merely tended to provide an equal work
distribution without regard to servers' capabilities.
.P
If other mitigating factors affect the performance of certain file servers
with respect to certain clients, then these factors will have to be
considered by the local system administrator, and addressed by setting
server preferences on individual clients using the provided command.  This
is the only sensible alternative since any attempt to dynamically compute
server preferences would be certain to overlook site-specific
configuration details.
.P
.H 1 "ARCHITECTURE OF PREFERENCES"
.P
The architecture of server preferences is based on replacing the random
selection from the available list of servers for a particular fileset with
a selection criteria based on a per-server \*(bBrank\*(bE value.  Rank is
an \*(lBunsigned short\*(lE value.  Lower rank values indicate higher
preference.
.P
In the existing DFS Cache Manager, a host that provides file data, file
location or replication services for any particular fileset is represented
internally in a \*(lBstruct cm_server\*(lE.  The rank value is stored
here.  Each fileset is represented in a \*(lBstruct cm_volume\*(lE which
contains two arrays of pointers to \*(lBcm_server\*(lE structures.  One
list points to fileset data servers, and the other list points to servers
to be contacted for read-only replica related services (keep-alive,
new-file versions for replica, etc.).
.P
These two lists and two associated per-server status lists get sorted in
order of increasing server rank, and hence, determine where to send RPC
service requests.  The preferred (lower rank value) servers are tried
first since they migrate to the heads of the lists.
.P
.H 1 "NEW IMPLEMENTATION"
.P
The proposal contains specifications for the general algorithms and data
structures needed for server preferences and a method for computing
default ranks.  There are several implementation problems to be solved
here.
.P
.aL
.LI
The server rank value must be stored somewhere.
.LI
Need to be able to set rank for a server without a corresponding
\*(lBstruct cm_server\*(lE.
.LI
Need to implement a network-topology-based default ranking algorithm.
.LI
Need to use rank to influence choice of server when making RPC.
.LI
Need to be able to get and set rank for a server through an API.
.LI
Must provide a user interface via the \*(lBcm\*(lE control program.
.LE
.P
.H 2 "Storing Server Rank"
.P
The Cache Manager creates a \*(lBcm_server\*(lE entry with information
about each known server when it first references that server.  This entry
contains a rank field which is set to an appropriate default value.  The
rank field will replace the random field in this structure.  A user
interface will allow the administratively empowered user to adjust this
value.  However if the user specifies a rank for a server which has no
associated \*(lBcm_server\*(lE structure then we must queue the rank
request for use
when that server is eventually contacted for the first time and the
\*(lBcm_server\*(lE structure set up for it.
.P
.H 2 "Ranks for Servers Not Yet Contacted"
.P
The system must be able to handle a request to set a server's rank even in
the absence of a \*(lBcm_server\*(lE structure for that server.  Such an
operation will require the recording of the desired rank for that server
in some holding area.  The server rank, type and IP address will be
recorded in a structure attached to a linked list of other such requests
that are considered outstanding.  These structures will be allocated at
time of request and freed when a newly contacted server has an IP address
and type which matches one of them.  The list is scanned when new entries
are made to prevent duplicate requests for the same IP address and type
being added.
.P
Whenever a new server structure for a file exporter or replication server
is added to the system, a function will try to establish its rank by
looking for another server with the same IP address and getting the rank
from there.  This keeps file and replication servers at the same rank, and
ensures they get sorted correctly.  Failing finding another server, the
system will search the list of outstanding requests for an entry with a
matching IP address and service type.  If no request is found it will
compute a default rank for the server based on the network adjacency
policy.  In this way we can ensure server ranks will be set according to
administrative preference, but without violating any of the locking
hierarchies involved in creating new \*(lBcm_server\*(lE structures.
.P
.H 2 "Computing Default Ranks"
.P
Sensible default server ranks must be determined without very much
administrative information available.  Therefore the choice is made to
compute default ranks solely on the basis of network adjacency and
connectivity parameters that can be determined by examining IP addresses
and network interfaces.
.P
Server ranks are in the range from 0 to 65534.  In the absence of
user-provided ranks, the Cache Manager will assign a default rank value as
follows:
.P
.aL
.LI
If the server machine has the same address as (i.e., \*(qBis\*(qE) the local
host, it will be assigned a rank of 5000 plus a small random number.
.LI
If subnetting is in use on an interface, and the server's address is in
the range of that subnet, the server will have an associated rank of
20000, plus a small random number.
.LI
Otherwise, if the server's address is in the range of the network, the
server will have a rank of 30000 plus a small random number.
.LI
A server located on a network which is not directly connected to this host
will be assigned a default rank of 40000 plus a small random number.
.LI
If no locality information can be determined in a particular kernel, the
default rank will always be 40000.
.LI
Ties (equal ranking) among servers which export the same fileset will be
resolved randomly.
.LE
.P
Note that any machine may potentially have more than one interface and
more than one IP address.  Therefore we search all interfaces and all
addresses configured to find the closest network connection to any server
when computing its default rank.
.P
For these computations, the definition of \*(qBsame network\*(qE and \*(qBsame
subnetwork\*(qE are taken to be in the context of the Internet Address
protocol, where specific classes (A,B,C,D) of networks have been defined
and their significant addressing digits for host, subnetwork, and
network are well understood.
.P
.H 2 "Using Server Rank to Implement Preferences"
.P
Implementing server preferences requires a method for using rank to
influence which server gets the RPC request for a particular service.  I
propose to do this by manipulating a part of the \*(lBcm_volume\*(lE
structure.
.P
Currently, when a new \*(lBcm_volume\*(lE structure (for a fileset) is
allocated, or an old one is reread from its place in the
\*(lBFilsetItems\*(lE disk file, it is installed in the system by the function
\*(lBcm_InstallVolumeEntry()\*(lE in \*(lBcm_volume.c\*(lE.  This function
finds all
the file servers and replication servers that service this fileset, and
places pointers to their \*(lBcm_server\*(lE structures into two arrays.
One array is for file servers, the other for replication servers.  After
filling them, it currently calls a function to sort these arrays based on
a random number.
.P
In a similar fashion, each time a new cell is accessed, a
\*(lBcm_cell\*(lE structure is allocated, and the FLDB servers for that
cell are identified.  Pointers to \*(lBcm_server\*(lE structures are then
filled into the \*(lBcellHosts\*(lE array for that cell.  These pointers
can be sorted just as the the ones above are.
.P
In \*(lBcm_server.c\*(lE, I propose to change the sorting function
\*(lBcm_SortServers()\*(lE to use the rank field instead of random.  This
function already sorts the entries in a host list by numerical value, so
no other changes will be needed to enforce host list sorting by rank.
Note that this function will sort these arrays in ascending rank order.
.P
The order that servers appear in these two arrays governs directly the
order in which they are polled to satisfy a service request.  The function
\*(lBcm_ConnByMHosts()\*(lE searches the array of server pointers passed in
for a connection to a server host.  The search proceeds in the order of
the array.  Only if the server is marked \*(qBdown\*(qE or a timeout
occurs does
the Cache Manager attempt to use the next server in the array.  This
applies for both file exporter servers and replication servers.  By
extension, FLDB servers are also sorted in the \*(lBstruct cm_cell\*(lE
for choosing which of several file location database servers to contact.
.P
Several new functions will need to be written to adjust the rank value for
both existing and new server structures.  Additionally, when an
administrator adjusts a server's rank, there will be a function to scan
the active set of filesets to determine which server lists will need to be
re-sorted based on the changed ranking.  The ranks for replication servers
and file servers on the same host will always be the same since these
services are always used together by the Cache Manager for read-only
fileset access.
.P
.H 2 "Programming API"
.P
Server preferences should be like other Cache Manager configuration
parameters.  They will be accessed and changed via the \*(lBpioctl\*(lE
interface.
All \*(lBcm pioctls\*(lE use a \*(lBstruct afs_ioctl\*(lE to carry
parameters to and
from the Cache Manager.  I propose to use this structure in the standard
way to add a \*(lBcm pioctl\*(lE interface.
.P
.H 3 "Pioctl VIOCSETSRVPREFS"
.P
The Set Server Preferences \*(lBpioctl\*(lE uses an array of the following
structures, passed in the \*(lBafs_ioctl.in\*(lE data area.  The user must
allocate this array and specify the size (in bytes) in the
\*(lBafs_ioctl.in_size\*(lE field of the pioctl request.
.P
.dS
.ne 8
struct spref {
    struct sockaddr_in  server;
                        /* socket address in network order */
    unsigned short      rank;
                        /* Server rank */
    unsigned short      flags;
                        /* Flags for cm to set on return */
};
.dF
.P
This \*(lBpioctl\*(lE can only be used by the local root user, otherwise
it will
fail with the error code \*(lBEPERM\*(lE.  The specified preferences will apply
equally to replication and file servers.  If neither a replication server
nor a file server can be found for a specified address, the request will
be queued into an outstanding request queue.  Flags may be set to
\*(lBCM_PREF_FLDB\*(lE to cause the preferences adjustment to apply to
only File
Location Database servers.  Normaly this \*(lBpioctl\*(lE will return zero.
.P
If \*(lBafs_ioctl.in_size\*(lE is larger than the supported maximum, the
\*(lBpioctl\*(lE will
return a non-zero return code, and the error code will be
\*(lBE2BIG\*(lE and no
data will be returned.  All of the preferences will remain unchanged.
.P
.H 3 "Pioctl VIOCGETSRVPREFS"
.P
This \*(lBpioctl\*(lE can be run by any user to extract the current set of
preferences.  \*(lBVIOCGETSRVPREFS\*(lE will accept an integer offset
into the Cache
Manager's list of servers, and will return addresses and ranks of servers
from that point on until the data area specified by the user is filled.
The \*(lBafs_ioctl.in\*(lE area should be a structure of the following
type:
.P
.dS
.ne 4
struct sprefrequest {
    unsigned short  offset;
    unsigned short  num_servers;
};
.dF
.P
The offset field should contain an integer offset into the Cache Manager's
list of servers.  A value of zero will indicate that the returned list
will begin at the beginning (i.e., offset zero).  The
\*(lBnum_servers\*(lE field
should be set to the size of (number of elements in) the
\*(lBservers[]\*(lE array of the \*(lBsprefinfo\*(lE structure described
below.  If the \*(lBafs_ioctl.in_size\*(lE field is smaller than
\*(lBsizeof(struct sprefrequest)\*(lE, \*(lBENOENT\*(lE will be returned.
.P
Several requests may be required in order to obtain the entire list of
servers.  The appropriate offset for each subsequent request will be the
value returned in the \*(lBnext_offset\*(lE field by the previous request,
unless there was no previous request, in which case, the appropriate
offset is zero.  The output from this \*(lBpioctl\*(lE is a structure of the
following type:
.P
.dS
.ne 5
struct sprefinfo {
    unsigned short  next_offset;
    unsigned short  num_servers;
    struct   spref  servers[];
};
.dF
.P
This structure is passed in the \*(lBafs_ioctl.out\*(lE data area of the
\*(lBioctl\*(lE structure, and must be allocated by the user.  The
maximum size of
the structure (in bytes) will also be specified in the
\*(lBafs_ioctl.out_size\*(lE field of the \*(lBpioctl\*(lE request.  Note that
\*(lBservers[]\*(lE is a variable length array whose size is constrained
by the smaller of the \*(lBafs_ioctl.out_size\*(lE field and the
\*(lBnum_servers\*(lE field of the \*(lBsprefrequest\*(lE structure.
.P
On return from this \*(lBpioctl\*(lE, \*(lBnum_servers\*(lE will contain
the number
of elements actually returned in the array, while \*(lBnext_offset\*(lE
will contain the value which should be passed in the \*(lBoffset\*(lE
field on the next invocation of \*(lBVIOCGETSRVPREFS\*(lE in order to continue
iteration through the list.  Under no circumstances will the returned
value of \*(lBnum_servers\*(lE ever be larger than that specified in the
\*(lBsprefrequest\*(lE structure, though it will often be smaller.  If
there are no more elements remaining in the list, \*(lBnext_offset\*(lE
will be zero.  This suggests that the next invocation of
\*(lBVIOCGETSRVPREFS\*(lE
should start from the beginning of the list.  The output list is comprised
of servers found in the server hash table first, and next servers listed
in the outstanding requests list.
.P
If the value of the \*(lBafs_ioctl.out_size\*(lE field of the
\*(lBpioctl\*(lE request is smaller than
.dS
.ne 1
sizeof(struct spref) * sprefrequest.num_servers + 2*sizeof(int)
.dF
server preferences information will be omitted by subsequent calls to this
iterator.  It will in effect, \*(qBfall through the cracks\*(qE between calls.
This will not cause any harm to the Cache Manager, only the quality of the
data returned by this \*(lBpioctl\*(lE will be adversely affected.  Also
note that
additions to the list of servers maintained by the Cache Manager between
subsequent calls to this iterator may cause information for some servers
to be omitted (effectively, the offsets have changed).  The output
\*(lBservers[]\*(lE array has each entry's \*(lBflag\*(lE value set to
indicate whether the entry found was for a file exporter, replication, or
FLDB server.
.P
.H 2 "User Interface"
.P
The default user interface to the server preference \*(lBpioctls\*(lE is
via the CM
command suite.  CM is modified so that the local root user can specify
server ranks directly.  The local root user will be able to set or
override the current rank of a particular server by using the
\*(lBsetpreferences\*(lE subcommand of CM.  The server ranks may be
examined via the
\*(lBgetpreferences\*(lE subcommand.  Any user may execute the
\*(lBgetpreferences\*(lE
subcommand.  The \*(lB-fldb\*(lE modifier flag is to indicate the user
is interested
in querying or modifying preferences for file location database (FLDB)
servers instead of file data and replication servers.
.P
.dS
.ne 5
cm setpreferences  [-server <machine rank>...]
                   [-path <filename>] [-stdin] [-fldb] [-help]

cm getpreferences  [-path <filename>] [-numeric] [-fldb]
                   [-help]
.dF
.P
Only the local root user may set server preferences.  The CM
\*(lBsetpreferences\*(lE subcommand will take data from any combination
of specified
sources, and will issue the necessary pioctls to effect the requested
changes.  Host names will be resolved to IP addresses using the local
resolver method.  The \*(lBgetpreferences\*(lE subcommand will resolve
address to
names (when possible) unless the \*(lB-numeric\*(lE switch is given.
Unresolved addresses will be in dotted decimal form.  Use of the
\*(lB-numeric\*(lE switch is highly recommended if the output is not
intended for human consumption.
.P
.H 1 "Cache Manager Code Changes"
.P
Changes to implement server preferences include new functions and data
structures to manipulate server ranks and server lists, and some changes
to strengthen the locking hierarchy protecting these lists.
.P
.H 2 "Changes to Existing CM Functions"
.P
The \*(lBcm_server\*(lE structure is changed so that the random field is
now called \*(lBrank\*(lE.  When creating a server structure in
\*(lBcm_GetServer()\*(lE the rank value is set by a new function called
\*(lBcm_DefaultRank()\*(lE.  The function for sorting server lists,
\*(lBcm_SortServers()\*(lE, is changed to observe the rank value when
sorting, and is always called with a lock held on the parent
\*(lBcm_volume\*(lE.
.P
A change is needed in \*(lBcm_ConnByMHosts()\*(lE to more aggressively
require the \*(lBvolp->lock\*(lE be held whenever looking into the volume
structure's server lists.  This is necessary to use the
\*(lBvolp->lock\*(lE as the semaphore for changing these server lists.
When resorting server lists we take this lock to prevent concurrent access
to arrays that are changing.
.P
Since \*(lBcm_ConnByMhosts()\*(lE also drops its locks while attempting to
use a server structure to obtain an RPC connection, we have to go a step
further to prevent the possibility of missing a server in a list that gets
resorted between RPC connection attempts.  This is done by use of the
generation count added to the \*(lBcm_volume\*(lE structure.  This count
is incremented after each resorting.  The count is read when we enter the
loop in \*(lBcm_ConnByMHosts()\*(lE and checked prior to each iteration.  If
it changes, we start over knowing that a list in this \*(lBcm_volume\*(lE
structure has been resorted.
.P
.H 2 "New CM Functions and Data Structures"
.P
Two new files, \*(lBcm_serverpref.c\*(lE and \*(lBcm_serverpref.h\*(lE,
will be added to the
source tree.  The first file will contain most of the new server
preference manipulation code.  However the new functions
\*(lBcm_FindNextServer()\*(lE, \*(lBcm_FindServerIP()\*(lE and
\*(lBcm_SetServerRank()\*(lE will be added to cm_server.c to provide
functionality that is needed for the implementation.  The reason for
putting these functions in \*(lBcm_server.c\*(lE is that they access the
server hash
table directly and modularity requires that they be located in the file
which contains the objects and locks that they manipulate.  Similarly, the
new function \*(lBcm_ReSortServers()\*(lE will be placed in
\*(lBcm_volume.c\*(lE
since it accesses the \*(lBcm_volume\*(lE structures and locks directly.
Also, \*(lBcm_ReSortCellSrvs()\*(lE will be placed in
\*(lBcm_cell.c\*(lE for the same reasons.
.P
.H 3 "cm_FindNextServer()"
.P
.dS
.ne 3
struct cm_server *
cm_FindNextServer(struct cm_server  *lastHad,
                  u_short            type);
.dF
.P
This function finds us the next server in the \*(lBcm_servers[]\*(lE (IP
address) hash table after the one passed in.  If \*(lBNULL\*(lE is
passed in, then it
returns the first server in the \*(lBcm_servers[]\*(lE hash table.  This
function acquires the \*(lBcm_serverlock\*(lE during the hash table
search.  The structure pointer it returns does not have a lock held or
reference count incremented.  It skips over \*(lBcm_server\*(lE structures
which have their \*(lBsType\*(lE field set to anything other than the
provided argument.
.P
.H 3 "cm_FindServerIP()"
.P
.dS
.ne 3
struct cm_server *
cm_FindServerIP(struct in_addr  *addrp,
                u_short          type);
.dF
.P
This function is similar to \*(lBcm_FindServer()\*(lE in that it returns a
server structure pointer, but this one will find the structure given the
type and the IP address.  This function must be called holding the
\*(lBcm_serverlock\*(lE for the hash table search.  It does not lock the
server structure, but its caller may do so providing it releases the
\*(lBcm_serverlock\*(lE.  Server structures are not currently ever deleted
from the \*(lBcm_servers[]\*(lE hash table so this locking strategy works.
The reason this function does not lock the hash table like
\*(lBcm_FindServer()\*(lE does is that his caller may wish to hold the lock
after an unsuccessful search to guarantee no race condition exists between
failing to find a server and adding a request queue element.
.P
.H 3 "cm_SetServerRank()"
.P
.dS
.ne 4
int
cm_SetServerRank(struct in_addr  *addrp,
                 u_short          rank,
                 u_short          svc);
.dF
.P
This function will set the rank value for the named server and type if it
is currently in the system.  If not, a rank request must be added to
request list.  Note that any \*(iBexisting\*(iE request for the same
server and service type must be deleted.  This function uses
\*(lBcm_FindServerIP()\*(lE and holds the \*(lBcm_serverlock\*(lE while
searching the hash table and adding a request.  This locking prevents the
possible race between adding a request and contacting the same server at
the same time.  This function returns zero after normal completion.
.P
.H 3 "cm_ReSortServers()"
.dS
.ne 2
void
cm_ReSortServers(struct cm_server  *serverp);
.dF
.P
Whenever an existing server preference has been reset we must carefully
sort all the server arrays in all volumes that contain a reference to that
server.  Fortunately, the \*(lBcm_fcache\*(lE stored in the
\*(lBFilesetItems\*(lE
file on disk do not contain \*(lBHost\*(lE arrays, so we can ignore them
and only
look at the \*(lBcm_volumes[]\*(lE.  The function
\*(lBcm_ReSortServers()\*(lE is a straightforward find and sort routine.  It
has to hold a read lock on \*(lBcm_volumelock\*(lE and a write lock on
each specific volume structure while it is being examined/sorted.  It is
unfortunate that we have to hold a global lock and a local volume lock for
this long, but the operation should not have to occur very often.
.P
There are several functions which read the \*(lBrepHosts[]\*(lE and
\*(lBserverHost[]\*(lE arrays.  These functions will have to be changed to
detect that the array has been resorted by examining the new per-array
generation counter.  This counter should be consulted whenever the arrays
are accessed to determine if the array was resorted since last examined.
.P
.H 3 "cm_ReSortCellSrvs()"
.dS
.ne 2
void
cm_ReSortCellSrvs(struct cm_server  *serverp);
.dF
.P
This function performs the same task as \*(lBcm_ReSortServers()\*(lE, but
for cell FLDB servers in the \*(lBcm_cell\*(lE structure's
\*(lBcellHosts[]\*(lE array.  It is implemented in a similar fashion as
\*(lBcm_ReSortServers()\*(lE described above.
.P
.H 3 "cm_SortServArrays()"
.dS
.ne 2
static void
cm_SortServArrays(struct cm_volume  *volp);
.dF
.P
This function works like \*(lBcm_SortServers()\*(lE, but recognizes the
association between the arrays \*(lBserverHost[]\*(lE,
\*(lBtimeBad[]\*(lE and
\*(lBperSrvReason[]\*(lE.  These three arrays all record data about the
same collection of servers.  They by necessity must be sorted together, so
this function is provided to handle this special case.
.P
.H 3 "Queued Rank Requests for Unknown Servers"
.P
The following structure definition and function prototypes describe the
mechanism for storing and retrieving preference requests for servers not
yet contacted by the Cache Manager.  The functions listed add, remove and
scan for a particular preference request.
.P
.dS
.ne 7
typedef struct cm_ServerRank {
    struct in_addr         server; /* IP address in
                                      network order */
    unsigned short         rank;   /* Server rank */
    struct cm_ServerRank  *next;  /* Next in list */
    struct cm_ServerRank  *prev;  /* Previous in list */
} cm_ServerRank_t;

.ne 3
static struct cm_ServerRank  *cm_ServerRankReqs = NULL;
static unsigned long          cm_RankReqsCnt = 0;
static osi_dlock_t            cm_RankReqsLock;

.ne 4
void
cm_AddRankRequest(struct in_addr  *addrp,
                  u_short          rank,
                  u_short          svc);

.ne 3
cm_ServerRank_t *
cm_ScanRankRequests(struct in_addr  *addrp,
                    u_short          svc);

.ne 2
static void
cm_RemoveRankRequest(cm_ServerRank_t  *srp);
.dF
.P
The list pointed to by \*(lBcm_ServerRankReqs\*(lE maintains all the user
specified ranks for servers not yet in the internal \*(lBcm_servers[]\*(lE
hash table.  This list is consulted whenever a new server structure
is allocated and needs its default rank to be set by
\*(lBcm_DefaultRank()\*(lE.
.P
.H 3 "cm_RandomRankAdj()"
.P
.dS
.ne 2
int
cm_RandomRankAdj(void);
.dF
.P
This function returns a random number in the range of 0 to 15, which is
used as a small, random adjustment applied to server ranks to prevent
ties.
.P
.H 3 "cm_DefaultRank()"
.P
.dS
.ne 3
u_short
cm_DefaultRank(struct in_addr  *addrp,
               u_short          type);
.dF
.P
This function returns a rank value for a new server structure.  It
replaces the call to the random value generator in
\*(lBcm_server.c\*(lE.  If a rank
request for the same IP address and service type exists in the request
queue, then that value will be used instead.  Otherwise the algorithm
described earlier is used to establish a default rank based on existence
of another server instance on this IP address, or the network topology.
.P
.H 3 "New Pioctl Interfaces"
.P
Two new \*(lBpioctl\*(lE definitions are added to
\*(lBkutils/ioctl.h\*(lE for preferences.
These are \*(lBVIOC_SETSPREFS\*(lE, and \*(lBVIOC_GETSPREFS\*(lE.  These
definitions
correspond to new functions located in \*(lBcm_pioctl.c\*(lE, called
\*(lBcm_PSetSrvPrefs()\*(lE and \*(lBcm_PGetSrvPrefs()\*(lE respectively.
.P
.dS
.ne 8
static long
cm_PGetServPrefs(struct cm_scache    *scp,
                 long                 function,
                 struct cm_rrequest  *rreqp,
                 char                *inDatap,
                 char                *outDatap,
                 long                 inSize,
                 long                *outSizep);
.dF
.P
This is the \*(lBpioctl\*(lE subcommand that implements the user interface for
getting all the server ranks.  It must iterate over the
\*(lBcm_servers[]\*(lE hash table and the \*(lBcm_RankRequest\*(lE queue.
.P
.dS
.ne 8
static long
cm_PSetServPrefs(struct cm_scache    *scp,
                 long                 function,
                 struct cm_rrequest  *rreqp,
                 char                *inDatap,
                 char                *outDatap,
                 long                 inSize,
                 long                *outSizep);
.dF
.P
This is the \*(lBpioctl\*(lE subcommand that implements the user interface for
setting the server rank.  See the user interface section for more
information about what the commands that invokes these functions can do.
.P
.H 2 "New OSI Functions and Data Structures"
.P
The following functions are added to the OSI layer to provide a machine
independent set of boolean interfaces to determine facts about the network
topology of the cell.  These functions are used only in
\*(lBcm_DefaultRank()\*(lE.
.P
.dS
.ne 2
int
osi_SameHost(struct in_addr  *addrp);
.dF
.P
Recognize if the address passed in is the same as the local
address for any interface attached.
.P
.dS
.ne 2
int
osi_SameSubNet(struct in_addr  *addrp);
.dF
.P
Recognize if the address passed in is on the same subnet
as the local address for any interface attached.
.P
.dS
.ne 2
int
osi_SameNet(struct in_addr  *addrp);
.dF
.P
Recognize if the address passed in is on the same net
as the local address for any interface attached.
.P
.H 2 "User Interface Functions"
.P
The following functions are added to the CM program to provide
the administrative commands for getting and setting server preferences:
.P
.dS
.ne 3
int
DoSetPrefs(struct cmd_syndesc  *aSyntax,
           char                *aRock);

.ne 3
int
DoGetPrefs(struct cmd_syndesc  *aSyntax,
           char                *aRock);

.ne 2
void
SetUpSetPrefs(void);

.ne 2
void
SetUpGetPrefs(void);
.dF
.P
These functions are written following the format of the other CM
subcommands.
.P
.H 1 TESTING
.P
Testing of the Server Preference package will proceed in two stages.
First a unit-test stage, which will attempt to exercise each component of
the server preference module individually in user space.  Second, a system
test stage where using a cell with some number of servers we exercise the
system and verify that server preferences are being followed.
.P
All of the new functions in \*(lBcm_serverpref.c\*(lE can be exercised
independently
by use of a test program that simulates what the rest of the Cache Manager
might do.  A user-space program that exports the global locks and data
structures that server prefs depend on will be able to test each function
for correctness.  Locking can be similarly tested using parallel threads
that create server setting requests and access servers.
.P
Appropriate ICL traces will be added to the server preference code as it
is developed.  Since no new global data structures are being added and
only one field of the \*(lBcm_server\*(lE structure is changing no
additional debugging interfaces will be needed.  Eventually it would be
helpful to add a debugging interface that would return the name of the
server that is being used for a particular fileset.
.P
After passing the unit tests, a CM kernel module with preferences will be
run in a test cell.  Here I will exercise the \*(lBpioctl\*(lE code and
the server
preference setting and getting modules.  Next I will conduct scenario
tests that will exercise and verify the server choices.
.P
By replicating some filesets across three servers located on different IP
subnets, the default server preference value choice will be tested.  Two
subnets will be required to effect this test, since there are four cases
of where the host can be located (self, same subnet, same net, other net).
.P
First, using \*(lBcm getpreferences\*(lE I can visually confirm that
generated server ranks conform to the described algorithm.  Next,
attempting to access the replicated filesets with ICL tracing enabled will
generate a trace dump that names the server that shipped the data.  Again
visual inspection will confirm the correct behavior of the system.
.P
The boundary conditions of the system can also be tested using some shell
scripts.  Adding too many preferences, parallel \*(lBcm
setpreferences\*(lE requests, and setting a request for a server at the
same time as first contacting it can all be accomplished using some shell
scripts and ICL trace analysis to verify correct behavior.
.P
Lastly, a \*(lBcm setpreferences\*(lE command to decrease the rank of a
server not currently preferred should result in fetching data from that
server instead for the next fetch.  This can also be visually confirmed in
the ICL trace dump.
.P
...\" =========================================================================
...\" Author's address goes here, as unnumbered heading, at end of doc.
...\" =========================================================================
.P
.ne 3+5
.HU "AUTHOR'S ADDRESS"
.P
.tl $Steven Berman$$Internet email: berman@transarc.com$
.tl $Transarc Corp.$$Telephone: +1-412-338-6993$
.tl $707 Grant Street$$$
.tl $Pittsburgh, PA 15219$$$
.tl $USA$$$
...\" =========================================================================
...\" Done!
...\" =========================================================================
