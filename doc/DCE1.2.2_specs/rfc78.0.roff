...\" OSF-RFC 78.0 
...\" 
...\" FORMATTING INSTRUCTIONS for this RFC: 
...\"       nroff -Tlpr rfc78.0.roff > rfc78.0.txt 
...\"       troff -Tps rfc78.0.roff | <ps-post-processor> > rfc78.0.ps 
...\" (Where "troff" means "device-independent troff", or "ditroff".) 
...\" 
...\" If troff is not supported for a given RFC, insert the following: 
...\" .if t \{\ 
...\" .tm *** Troff not supported for this RFC. 
...\" .ex \} 
...\" 
...\" =========================================================================
...\" This template first sets a bunch of *roff options (authors/readers 
...\" don't usually have to know about these). 
...\" Then it defines some strings and macros, many of which deal with 
...\" things that differ between nroff & troff (some of these may not be 
...\" perfect, but they're better than nothing -- to do a really good 
...\" job would require a real semantic markup language. 
...\" Convention: "Begin/End" for strings, "Start/Finish" for macros. 
...\" Strings: 
...\"       \*(f!        - Footnote string (replaces \*F). 
...\"       \*(hB, \*(hE - Page header/footer font (internal use). 
...\"       \*(kB, \*(kE - Doc header font (internal use). 
...\"       \*(qB, \*(qE - Quotations. 
...\"       \*(iB, \*(iE - Italics/emphasis in primary font. 
...\"       \*(bB, \*(bE - Bold font. 
...\"       \*(lB, \*(lE - Literal font. 
...\"       \*(jB, \*(jE - Italics/emphasis in literal font. 
...\"       \*(nH        - Default note header string. 
...\" Macros: 
...\"       .aH      - Appendix header macro (uses number register \na). 
...\"       .aL      - Automatic list macro (replaces .AL; uses num reg \ng). 
...\"       .tS, .tF - Title start/finish (internal use). 
...\"       .cS, .cF - Displays (no-fill) without indentation. 
...\"       .dS, .dF - Displays (no-fill) with indentation. 
...\"       .iS, .iF - Indented (fill) text. 
...\"       .nS, .nF - Note. 
...\" -------------------------------------------------------------------------
...\" First, set up some number registers here (instead of on command line), 
...\" and include the "mm" macro package here (instead of on command line). 
...\" -------------------------------------------------------------------------
.if n .nr L 66 \" Nroff page length = 66 lines.
.if t .nr L 11i \" Troff page length = 11 inches.
.if n .nr W 72 \" Nroff page width = 72 columns.
.if t .nr W 6.5i \" Troff page width = 6.5 inches.
.if n .nr O 3 \" Nroff page offset = 3 columns.
.if t .nr O 0.75i \" Troff page offset = 0.75 inches.
.nr N 2 \" No header on page 1.
.so /usr/lib/tmac/tmac.m \" Points to "mm" package, in /usr/lib/macros.
...\" -------------------------------------------------------------------------
...\" Next, twiddle the "mm" package to suit our preferred style.
...\" -------------------------------------------------------------------------
...\" Point size and font types.
...\" -------------------------------------------------------------------------
.if n .fp 1 R \" "Regular" font ONLY -- don't use any others in nroff.
.if t \{ .S 10 12 \" Point size = 10, vertical spacing = 12.
...\" Note: Some systems give different names to these fonts.
.fp 1 R \" Times roman.
.fp 2 I \" Times italic.
.fp 3 B \" Times bold.
.fp 4 BI \" Times bold italic.
.fp 5 CW \" Courier.
.fp 6 CI \" Courier oblique.
.fp 7 CB \" Courier bold.
.fp 8 CX \" Courier bold oblique.
.fp 9 H \" Helvetica.
.fp 10 HI \" Helvetica oblique.
.fp 11 HB \" Helvetica bold.
.fp 12 HX \" Helvetica bold oblique.
.fp 13 S \} \" Special symbol font -- normally only called automatically.
...\" -------------------------------------------------------------------------
...\" Headings; page header and footers; titles.
...\" -------------------------------------------------------------------------
.nr Ej 0 \" No eject for first-level headings.
.nr Hs 7 \" Heading space level = blank line after heading (all levels).
.nr Hb 7 \" Heading break level = break after heading (all levels).
.nr Hi 1 \" Post-heading indent = paragraph indent.
.nr Hc 0 \" Heading centering = none.
.if n .ds HF 1 1 1 1 1 1 1 \" Heading fonts = regular (no underlining).
.if t .ds HF 11 11 11 11 11 11 11 \" Heading fonts = Helvetica bold.
.if t .ds HP 0 0 0 0 0 0 0 \" Heading point sizes (= default).
.HM 1 1 1 1 1 1 1 \" Heading mark = arabic (all levels).
.nr Hu 1 \" Unnumbered heading level = 1 (see aH macro, below).
.de HX \" Beginning-of-heading processing.
.in 0 \" Left justify headings.
.ie     \\$2=0 .ds }0\" Null string heading mark for HU.
.el .ie \\$1=1 .ds }0 \\n(H1.\ \&\" Heading marks = dotted sections + 1 space.
.el .ie \\$1=2 .ds }0 \\n(H1.\\n(H2.\ \&
.el .ie \\$1=3 .ds }0 \\n(H1.\\n(H2.\\n(H3.\ \&
.el .ie \\$1=4 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\ \&
.el .ie \\$1=5 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\ \&
.el .ie \\$1=6 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\\n(H6.\ \&
.el .if \\$1=7 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\\n(H6.\\n(H7.\ \&
..
.de HZ \" End-of-heading processing.
.if n .in 3 \" Indent body of doc by 3 columns in nroff.
.if t .in 0 \" Don't indent in troff.
..
.if n .ds hB \&\" Page header/footer font begin in nroff.
.if t .ds hB \f9\" Page header/footer font begin in troff.
.if n .ds hE \&\" Page header/footer font end in nroff.
.if t .ds hE \fP\" Page header/footer font end in troff.
.if n .ds kB \&\" Doc header font begin in nroff.
.if t .ds kB \f(11\" Doc header font begin in troff.
.if n .ds kE \&\" Doc header font end in nroff.
.if t .ds kE \f1\" Doc header font end in troff.
.de tS \" Title start.
.SP 2 \" 2 blank lines.
.ce 99 \" Center (each line of) title.
.if t \{ .ft 11 \" Bold helvetica.
.S +2 D \} \" Bigger point size.
..
.de tF \" Title finish.
.ce \" Turn off centering.
.SP 1 \" 1 blank line.
.if t \{ .ft 1 \" Return to regular font.
.S P P \} \" Return to regular point size.
..
...\" -------------------------------------------------------------------------
...\" Special Appendix heading macro, .aH.
...\" -------------------------------------------------------------------------
.nr a 0 1 \" Appendix number.
.af a A \" Assign format upper-case alpabetic to number register a.
.de aH \" Appendix heading macro.
.if \\na=0 \{ .nr H1 0 \" Reset H1 to 0.
.HM A 1 1 1 1 1 1 \} \" Heading mark = Upper case alphabetic + arabics.
.HU "APPENDIX \\n+a. \\$1"
..
...\" -------------------------------------------------------------------------
...\" Paragraph stuff.
...\" -------------------------------------------------------------------------
.nr Pt 0 \" Paragraph type = left-justified.
.nr Pi 0 \" Paragraph indent = 0.
.nr Ps 1 \" Paragraph spacing = 1 blank space.
...\" -------------------------------------------------------------------------
...\" Special list macro, .aL (replaces .AL, for all levels).
...\" This should be used for almost all lists (including ".LI "\ "").
...\" The only exception is variable lists (.VL, indented by multiples of 6).
...\" -------------------------------------------------------------------------
.de aL
.nr g \\n(:g
...\" In-line lists should be numbered (by hand): (1), (2), (3), ...
.ie     \\ng=0 .LB 6 0 1 3 a \" 1st level: (a), (b), (c), ...
.el .ie \\ng=1 .LB 6 0 1 3 i \" 2nd level: (i), (ii), (iii), ...
.el .ie \\ng=2 .LB 6 0 1 4 a \" 3rd level: [a], [b], [c], ...
.el .ie \\ng=3 .LB 6 0 1 4 i \" 4th level: [i], [ii], [iii], ...
.el .ie \\ng=4 .LB 6 0 1 6 a \" 5th level: {a}, {b}, {c}, ...
.el .if \\ng=5 .LB 6 0 1 6 i \" 6th level: {i}, {ii}, {iii}, ...
..
.nr Ls 6 \" Blank lines between all list items, by default (but adjustable).
...\" -------------------------------------------------------------------------
...\" Footnote stuff; special footnote string, \*(f!.
...\" -------------------------------------------------------------------------
.if n .ds f! [\\n+(:p]\" Footnote string (replaces \*F in nroff).
.if t .ds f! \\*F\" Footnote string (same as \*F in troff).
.if n .FD 6 \" Footnotes not hyphenated or indented, label left justified.
.if t .FD 5 \" Footnotes hyphenated, not indented, label left justified.
.nr Fs 1 \" 1 blank line between footnotes.
...\" -------------------------------------------------------------------------
...\" Line adjustment stuff.
...\" -------------------------------------------------------------------------
.if n .nr Hy 0 \" No hyphenation in nroff.
.if t .nr Hy 1 \" Hyphenate in troff.
.if n .SA 0 \" Set adjust: left margin only in nroff.
.if t .SA 1 \" Set adjust: left and right margins in troff.
...\" -------------------------------------------------------------------------
...\" Miscellaneous stuff.
...\" -------------------------------------------------------------------------
.ta \" No tabs by default -- set them up by hand as needed.
.nr Si \n(Ls \" Default indent for .DS display macro = 6 (use in troff only).
...\" -------------------------------------------------------------------------
...\" Displays.
...\" -------------------------------------------------------------------------
.de cS \" Display start: no-fill, literal font, no indentation.
.P
.nf \" No fill mode.
.if t .ft 5 \" Constant width font in troff.
..
...\" Within .cS, ".ne N"'s can be added by hand, but should be minimized.
.de cF \" Display finish.
.if t .ft 1 \" Back to standard font in troff.
.fi \" Fill mode.
.P
..
.de dS \" Display start: no-fill, literal font, with indentation.
.P
.aL \" Use .aL macro for consistent indentation.
.nf \" No fill mode.
.LI "\ " \" List item will no (visible) marker.
.if t .ft 5 \" Constant width font in troff.
..
...\" Within .dS, ".ne N"'s can be added by hand, but should be minimized.
.de dF \" Display finish.
.if t .ft 1 \" Back to standard font in troff.
.fi \" Fill mode.
.LE
.P
..
.de iS \" Indent start: fill, regular font, with indentation.
.P
.aL
.LI "\ "
..
.de iF \" Indent finish.
.LE
.P
..
.ds nH NOTE\"Default note header string -- can be changed by author.
.de nS \" Note start: fill, italics font, with indentation.
.P
.aL \" Use .aL macro for consistent indentation.
.LI "\ " \" List item will no (visible) marker.
.if t .ft 2 \" Italics font in troff, and reverse roman <--> italic fonts:
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f1\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.ie \\n(.$=0 \\*(nH:\" Default header string if none supplied by author.
.el \\$1:\" Header string supplied by author as argument to .nS macro.
..
.de nF \" Note finish.
.if t .ft 1 \" Back to standard font in troff, and remap font macros:
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f2\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.LE
.P
..
...\" -------------------------------------------------------------------------
...\" Quotation marks and font toggles.
...\" -------------------------------------------------------------------------
.if n .ds qB \&"\" Quotation begin in nroff.
.if t .ds qB ``\" Quotation begin in troff.
.if n .ds qE \&"\" Quotation end in nroff.
.if t .ds qE ''\" Quotation end in troff.
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f2\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.if n .ds bB *\" Bold font begin in nroff.
.if t .ds bB \f3\" Bold font begin in troff.
.if n .ds bE *\" Bold font end in nroff.
.if t .ds bE \fP\" Bold font end in troff.
.if n .ds lB `\" Literal font begin in nroff.
.if t .ds lB \f5\" Literal font begin in troff.
.if n .ds lE '\" Literal font end in nroff.
.if t .ds lE \fP\" Literal font end in troff.
.if n .ds jB <\" Italics/emphasis literal font begin in nroff.
.if t .ds jB \fP\f6\" Italics/emphasis literal font begin in troff.
.if n .ds jE >\" Italics/emphasis literal font end in nroff.
.if t .ds jE \fP\f5\" Italics/emphasis literal font end in troff.
...\" -------------------------------------------------------------------------
...\" No diffmarks by default, i.e., define .mc to be null.
...\" (Comment out this null definition to turn diffmarking on.)
...\" -------------------------------------------------------------------------
.de mc
..
...\" =========================================================================
...\" Finally, it's time to start writing the document!
...\" The OSF-RFC author modifies the following header/footer info.
...\" (The major/minor number is assigned by the OSF-RFC Editor.)
...\" =========================================================================
.ND "January 1996" \" Date must be hard-coded.
.PH "$\*(hBOSF-RFC 78.0$Episode Vnode Synchronization$\\\\*(DT\*(hE$"
.PF "$\*(hBAnderson$DRAFT #1$Page \\\\n%\*(hE$" \" Draft version.
.PF "$\*(hBAnderson$$Page \\\\n%\*(hE$" \" Final version.
...\"
...\" Following are the first printed lines (header info) of the document:
...\"
\&\" Force top-of-first-page trap to position the following info correctly.
.tl $\*(kBOpen Software Foundation$$T. Anderson (Transarc)\*(kE$
.tl $\*(kBRequest For Comments: 78.0$$\*(kE$
.tl $\*(kB\*(DT$$\*(kE$
.tS \" Title, in all capitals (can span multiple lines):
EPISODE VNODE SYNCHRONIZATION
.tF
...\" =========================================================================
...\" Now, the actual body of the document!!
...\" Heading capitalization style:
...\"     1st level: CAPITALIZE ALL WORDS
...\"     2nd level: Capitalize Initial Letters of All (Significant) Words
...\"     3rd-7th level: Capitalize first letter of first word only
...\" =========================================================================
...\" Copyright (C) 1995, 1994 Transarc Corporation - All rights reserved.
...\" $Header: /afs/tr/fs/dev/dfs-dev/src/file/episode/docs/specs/vnode_synchronization/RCS/vnsync.design,v 1.1 1994/09/21 20:09:15 ota Exp $
.P
.H 1 "INTRODUCTION" \" Always start with an introduction section.
.P
This document describes a reorganization of the vnode synchronization
code used by Episode planned for the OSF/DCE 1.2 release.  It was
developed for Transarc's September 1994 DCE/DFS 1.0.3 release\*(f!
.FS
The V1.0.3 release is known internally as dfs-fwd-1.32.
.FE
on Solaris.  The changes made for the September 1995 DCE/DFS 1.1
release\*(f!
.FS
The V1.1 release is known internally as dfs-perf-1.42.
.FE
were insignificant.  This code is also present in the IBM DFS Product
for DCE V1.1 and V1.0.3.
.P
As used in this document, \*(bBvnode synchronization\*(bE refers
to maintaining the
consistency of vnodes and the data structures that surround them.  It
mostly excludes measures intended to protect the files and directories
that the vnodes represent.  For instance, the traditional vnode lock
(\*(lBvd_tlock\*(lE) protects the directory contents and file link counts and
similar concepts.  This document makes only passing reference to this
lock.  Similarly, the management of virtual memory associated with
vnodes is the province of another document.\*(f!
.FS
See description of Episode's virtual memory integration in RFC 75.0.
.FE
.P
The core of the idea was to replace the existing \*(bBB&CV\*(bE
(\*(qBbits and condition variable\*(qE) model with locks held
over the appropriate interval.  The use of locks is not
universally preferred, however.  In cases where it is common not
to block on a resource but to take some other action or where
the holder of the resource is not the same as the thread that
releases it, a B&CV mechanism is probably clearer.  For
instance, waiting for an open volume\*(f!
.FS
The terms \*(bBvolume\*(bE and \*(bBfileset\*(bE are used interchangeably.
.FE
is not implemented by seeking a lock for the
duration.
.P
A related issue is that the old vnode synchronization model used the
vnode lock for essentially everything.  This gross overloading of a
single lock imposes a good deal of complexity and confusion that can be
avoided by using several locks each protecting a well-defined set of
fields or operations.
.P
I wanted to avoid assuming that volume operations are generally single
threaded and to avoid, to the extent possible, depending on
\*(lBvol_open()\*(lE to
stop vnode operations.  These assumptions are complicated,
non-local, and violate the modular hierarchy.  If Episode (or at least
the vnode synchronization) can be made self-consistent without worrying
about the workings of \*(lBStartVnodeOp()\*(lE, it would be more
robust and easier
to understand.
.P
We use the vnode reference count freely within Episode to prevent vnodes
from being transmogrified
...\" \*(f!
...\" .FS
...\" transmogrify (origin unknown) (1656): to change or alter greatly
...\" and often with grotesque or humorous effect.
...\" .FE
during operations that must drop locks when they sleep.  This requires
that a few routines (e.g., \*(lBRecycle()\*(lE) carefully check the refcount.
.P
The old model had several fuzzy states, especially regarding open
volumes, which are made explicit.  This removes some confusing
ambiguities and overloadings and allows more comprehensive assertions
that the system is operating correctly.
.P
Consideration of the quota reservation problem is deferred to the VM
reorganization, which does away with reservation altogether (see
RFC 75.0).
.P
The solution to the problem of handling \*(lBVN_RELE()\*(lE on
\*(bBZLC\*(bE (zero link count) files in face of fileset operations\*(f!
.FS
Transarc defect db5505.
.FE
is to add careful volume glue\*(f!
.FS
The term \*(bBglue\*(bE used in DFS refers to two mechanisms
which add a layer of
processing on all vnode operations.  The first type of glue (\*(bBtoken
glue\*(bE) obtains the proper type of tokens to provide single-site semantics
to local operations on ufs or (locally mounted) Episode vnodes.  The
second type of glue (\*(bBvolume glue\*(bE) ensures that no vnode operations
run concurrently with incompatible volume operations.  The file system
independent portion of the VFS+ Interface interposes this glue as
appropriate.
.FE
to \*(lBVOP_INACTIVE\*(lE.  This allows \*(lBvnm_Inactive()\*(lE
to safely avoid deleting unlinked files during volume
operations.
.P
.H 1 "RATIONALE"
.P
An important goal of the reorganization was to improve the
maintainability of the vnode synchronization mechanisms.  There are two
general components to the maintainability problem.  First, the old
mechanisms were so complex and non-local that understanding them was
nearly impossible.  Improvements here will reduce long term maintenance
costs.
.P
Second, analysis of past defects indicates that more bugs were expected
as testing of Episode extended into new regimes.  Plans for the DCE/DFS
1.1 release called for more intensive fileset operations and routine use
of locally mounted filesets.  Both of these were likely to expose new
failure modes.  A new mechanism with well-defined invariants and based
on a deeper understanding of the operational environment faced by the
vnode system would eliminate bugs and make diagnosis and repair of
remaining problems easier and faster.
.P
A primary reason for the shortcomings of the old mechanism is that it
was developed incrementally, in response to an evolving understanding of
its requirements.  It was enhanced to handle virtual memory (VM)
integration, phantomized and stale vnodes and use by fileset operations.
These capabilities were \*(iBnot\*(iE designed in.  We now know far more
about the requirements placed upon the vnode system than we did in 1990
when it was first developed based on the BSD 4.3 model used by the IBM
RT AOS4 operating system.
.P
.H 1 "VIRTUAL MEMORY REQUIREMENTS"
.P
I refer to \*(lBPageIn()\*(lE as the generic request from the VM
system to fill a page by reading data from the file system.
\*(lBPageIn()\*(lE also handles "minor page faults".  Similarly,
I use \*(lBPageOut()\*(lE to refer to the generic VM request to
clean a page by writing it back to the file system.  I use the
terms \*(bBVM\*(bE and \*(bBpage cache\*(bE synonymously.
.P
On AIX, VM resources are locked before \*(lBPageIn()\*(lE is
called.  AIX vnodes that use VM contain an object called a \*(bBVM
segment\*(bE.  All VM accesses must use this segment, which must be
created before the first such access.  Both vnode reclamation
and file deletion must delete this segment.  Deleting the VM
segment waits for all pending \*(lBPageIn()\*(lE calls to
finish.  On AIX, a zero reference count does not imply that
there are no outstanding \*(lBPageIn()\*(lE requests.  The
existence of a segment is the only safe indicator.  Further,
deleting a VM segment is a destructive operation that must not
be attempted on a vnode that is in use.
.P
On AIX, \*(lBRecycle()\*(lE\*(f!
.FS
The function \*(lBRecycle()\*(lE (described in Procedure
Outlines) takes an unused vnode representing one file and
removes its identity so that it can be used to represent a
different file.
.FE
must exclude new VM users, without blocking \*(lBPageIn()\*(lE,
before deleting the VM segment.  The inactive\*(f!
.FS
The function \*(lBvnm_Inactive()\*(lE (described in Procedure
Outlines) is called by \*(lBVN_RELE()\*(lE, which calls
\*(lBVOP_INACTIVE()\*(lE when the vnode's reference count drops
to zero.  For Episode vnodes this turns into a call to
\*(lBvnm_inactive()\*(lE, which handles cleanup for referenced
vnodes.
.FE
procedure must also do this, but for the more obvious reason
that it may delete the underlying file.  When \*(lBPageIn()\*(lE
is blocked by a volume operation, or if the reference count is
non-zero, \*(lBRecycle()\*(lE must avoid this vnode.  Otherwise
it may safely delete the VM segment and proceed with the rest of
the reclamation activities.
.P
On AIX, \*(lBStopUse()\*(lE\*(f!
.FS
The function \*(lBvnm_StopUse()\*(lE (described in Procedure Outlines) is
used to put a fileset's vnodes into a state compatible with a volume
operation.  Generally this involves cleaning or invalidating cached data
for the vnode.
.FE
cannot delete the VM segment in order to pacify the page cache
since it must be able to operate on held vnodes.  However, it
must block \*(lBPageIn()\*(lE calls then clean or invalidate VM.
Because it blocks \*(lBPageIn()\*(lE, it must carefully interact
with \*(lBRecycle()\*(lE.
.nS
We assume that prohibiting reclamation of all vnodes for open
volumes would consume too many vnodes.  The problem with banning
\*(lBRecycle()\*(lE is that some volume operations are coded to
use vnodes primitives (e.g., dump and restore).  Since there is
no acceptable bound on the size of the largest volume we also
cannot specify a reasonable bound for the number of vnodes this
would consume.  However, prohibiting \*(lBRecycle()\*(lE during
volume operations might be more attractive if the volume
operations were changed to avoid vnode primitives.  This might
be a future simplification.
.nF
.P
On SunOS, the file system specific \*(lBPageIn()\*(lE procedure
consults VM, locks pages, and so forth.  The SunOS VM system
calls \*(lBPageIn()\*(lE with a held vnode.  This rules out any
synchronization mechanism that uses a lock on the reference
count to exclude VM users; the reference count lock must be at
the bottom of the locking hierarchy.
.P
On SunOS, the reference count is a reliable indicator of
potential \*(lBPageIn()\*(lE requests.  \*(lBRecycle()\*(lE and
\*(lBStopUse()\*(lE can both block VM users in \*(lBPageIn()\*(lE and
\*(lBRecycle()\*(lE can avoid vnodes with non-zero reference
counts.  There are no dependencies between \*(lBRecycle()\*(lE
and \*(lBStopUse()\*(lE.
.P
On both platforms, we assume \*(lBPageOut()\*(lE may be called
spontaneously, but only on vnodes with dirty pages.
.P
On both platforms, volume operations use vnodes to perform certain
operations.  They do not use VM and the page cache is clean or invalid
during these operations.
.P
.H 1 "FILESET OPERATIONS"
.P
When a volume is opened, inconsistent vnode operations are blocked.
Operations \*(iBnever\*(iE blocked by the volume glue are
\*(lBPageOut()\*(lE,\*(f!
.FS
\*(lBPageOut()\*(lE must not be blocked, otherwise
\*(lBStopUse()\*(lE could not clean dirty pages.
.FE
\*(lBVOP_INACTIVE()\*(lE (although, see Deleting Files
on special treatment for ZLC files), \*(lBVFS_ROOT()\*(lE, and
\*(lBVOPX_GETVOLUME()\*(lE.  The \*(lBPageIn()\*(lE\*(f!
.FS
On AIX, the vnode operation is \*(lBVOP_STRATEGY()\*(lE, which is called at
page-fault level and so never blocks.  The actual handling of
\*(lBPageIn()\*(lE or \*(lBPageOut()\*(lE requests is done by a
kernel process.  It must do its own volume synchronization.
.P
On SunOS, the glue treats \*(lBgetpage()\*(lE as a
\*(lBREADWRITE\*(lE operation, so blocks it during most volume
operations.  The Episode code does enough volume synchronization
to block writes and return unwritable page mappings during
\*(lBREADONLY\*(lE volume operations.
.FE
operation is glued
on SunOS but not on AIX where it is called at page-fault level.
Each volume operation places specific requirements on the cached
vnode state.  The semantics of each operation specify whether
the cached data must be invalidated or not and which vnode
operations may run concurrently.  All volume operations assume
that the fileset is consistent and quiescent for the duration.
.P
An open volume is the exclusive province of the thread that opened it.
This means that it may not be modified either implicitly or explicitly
by other users.  All vnode operations that modify status or data are
inconsistent with open volumes regardless of their open mode and are
blocked.  Deleting ZLC files is therefore
prohibited whenever a volume is open.  To accomplish this we defer the
last release (see Deleting Files, below).  Implicit
updates to a file's \*(lBatime\*(lE are discarded during volume operations.
.P
The implementation of Episode imposes other constraints.  Some
volume operations utilize the anode layer functions directly,
some use vnode primitives, and some make no use of per-file data
at all.  No volume operations reference or update VM.  This
means each volume operation\*(f!
.FS
In the present system, \*(lBvnm_StopUse()\*(lE cannot be called
during certain volume operations because of \*(lBxvolume\*(lE layer
locking problems.  As a result \*(lBvnm_StopUse()\*(lE is called
in a rather \*(iBad hoc\*(iE manner from places like
\*(lBvol_efsOpen()\*(lE and \*(lBvol_efsScan()\*(lE.  Assertions
on the current \*(lBStopUse()\*(lE open bits are present in
various volume operations to ensure that the correct level of
VM/vnode/anode consistency is present.
.FE
must be preceded by a step (\*(lBvnm_StopUse()\*(lE) which puts
the vnode system, including VM, into an appropriate state.
.P
Certain state information describing the current volume
operation is maintained for each volume.  This information is
derived from the volume handle's file system private data
pointer via the \*(qB\*(lBvnvl_\*(lE\*(qE module.  The locking
problems in the \*(lBxvolume\*(lE layer caused some difficulties in this
area.  In particular, it is not clear what lock protects the FS
private data structure.  However, the data in that structure
changes infrequently (e.g., at the beginning and end of volume
operations) and access is generally single threaded when it
does.  This can be cleaned up when the locking of volume handles
is clarified.
.P
The open volume state includes the following information:
.P
.aL
.LI
\*(lBvld_openbits\*(lE \*(EM
These bits indicate the types of vnode caching that
are allowed.  They are derived from the current volume operation and the
\*(lBvol_open()\*(lE modes.  The appropriate open bits may change as an open
volume progresses through a series of operations.  The vnode
system must be notified of these changes by calls to \*(lBvnm_StopUse()\*(lE.
.P
While these open bits allow for many possibilities, only a handful
are actually used.  These are given vaguely suggestive names with
the following descriptions:
.P
.aL
.LI
\*(lBopen-change-id\*(lE \*(EM
The identity of the volume is being changed, but the contents are
unaffected; this means swapid for clone or intra-server move.  It
requires writing all cached data through to the anode layer,
write-protecting the page mappings, and closing the anode handle, but
cached data do not have to be invalidated.
.LI
\*(lBopen-change-anode\*(lE \*(EM
The fileset's contents are being changed at the anode layer; this means
swapid for replica-release, reclone (backing fileset), unclone (backing
fileset), detach and destroy.\*(f!  It
.FS
A special open mode could be recognized for destroy that knows
that the containing files are being deleted.
\*(lBStopUse()\*(lE could then expunge dirty pages without being
required to write them through.  This might provide a useful
speedup for temporary filesets.
.FE
requires writing through and invalidating VM and other cached
state, such as the atime, and closing the anode handle.
.LI
\*(lBopen-read-anode\*(lE \*(EM
The fileset's contents are being examined by means of anode-layer
primitives; this means clone and reclone (front fileset).  It requires
writing all cached data through to the anode layer, write-protecting the
page mappings.  The cached data do not have to be invalidated, since
the contents of the fileset are not being changed.
.LI
\*(lBopen-change-vnode\*(lE \*(EM
The fileset's contents are being changed
but by means of vnode-using primitives; this means restore.
Since vnodes will be used during this operation, it is
pointless to flush cached status or close the anode handle.
However, since these modifications do not go through VM, the
page cache must be cleaned and invalidated.
.LI
\*(lBopen-read-vnode\*(lE \*(EM
The fileset's contents are only being examined by means of vnode-using
primitives; this means dump.  This state is analogous to
open-change-vnode, except that the contents of the fileset are not being
changed.  The requirements are the same except that the existing VM does
not have to be invalidated but must instead be write-protected.  Unclone
(front fileset) is also in this category.\*(f!
.FS
Ideally we could allow the front volume of a volume being uncloned to be
opened in the weakest possible way.  This is because we don't really
care about the state of the fileset being uncloned, it doesn't need to
represent a consistent snapshot so writes to the front fileset do not
need to be interrupted.  However, the locking that protects the VM
system's use of the block map is not at a convenient level for the
unclone operation.  This could be fixed by locating each vnode in the
front fileset, grabbing the \*(lBvd_vm.lock\*(lE and then doing the unclone.
.FE
.LI
\*(lBopen-noop\*(lE \*(EM
The fileset header is being examined or modified (gently); this means
getstatus, setquota and similar operations.  These have no impact on the
vnode pool.
.LE
.LI
\*(lBsideRail\*(lE \*(EM
On AIX, a list of deferred VM requests.
.LE
.P
.H 1 "PER-VNODE STATE"
.P
This section describes some of the Episode vnode fields that relate to
vnode synchronization.  These fields describe the vnode's identity, its
underlying anode representation, the data cached in the vnode or bits
describing cached data.
.P
These are protected using the \*(lBefs_lockvp()\*(lE and
\*(lBefs_unlockvp()\*(lE macros to manipulate the operating
system specific lock protecting the vnode reference count:
.P
.aL
.LI
\*(lBv_count\*(lE \*(EM
The vnode's reference count.  This field is really in the
system independent part of the vnode, but Episode makes some
references to it and the associated lock.
.LI
(held) \*(EM This is not an explicit bit, but means that the
\*(lBv_count\*(lE is at least one.
.LE
.P
These are protected by the global \*(lBvntableLock\*(lE:
.P
.aL
.LI
\*(lBvd_fid\*(lE \*(EM
The file identifier for the vnode.  The \*(lBvd_idLock\*(lE must
also be held to change this field.
.LI
(\*(lBNoIdentity\*(lE) \*(EM This isn't an explicit bit, but is
true iff fid is invalid.  If the vnode is held and
\*(lBNoIdentity\*(lE, the vnode can be referred to as
\*(bBstale\*(bE.\*(f!  All
.FS
Stale vnodes can be created by \*(lBvnm_Delete()\*(lE and
\*(lBvnm_StopUse()\*(lE, if a file is held across certain
fileset operations such as restore, reclone or destroy.  All
operations on all such vnodes fail with \*(lBESTALE\*(lE, except
\*(lBVOP_INACTIVE()\*(lE.
.FE
vnodes with identities are in the vnode hash table so
\*(lBNoIdentity\*(lE is synonymous with \*(lB!vd_onHash\*(lE.  A
vnode may not \*(iBlose\*(iE its identify unless the
\*(lBvd_idLock\*(lE is locked.  A \*(lBNoIdentity\*(lE vnode
will not \*(iBgain\*(iE an identity while it is held, in other
words, a stale vnode will stay that way until released.
.LI
\*(lBvd_volid\*(lE \*(EM
The containing volume's ID.  Only valid if fid also valid.
.LI
\*(lBvd_onHash\*(lE \*(EM
In the vnode hash table.  Implies \*(lB!NoIdentity\*(lE.
.LI
\*(lBvd_label\*(lE \*(EM
Vnode iteration label, see \*(lBvnm_StopUse()\*(lE.
.LI
\*(lBvd_onLRU\*(lE \*(EM
On the LRU list.
.LI
\*(lBvd_avoidRecycle\*(lE \*(EM Is set by \*(lBStopUse()\*(lE
when it has blocked \*(lBPageIn()\*(lE for a vnode with a VM
segment.  Used by \*(lBObtainVnode()\*(lE to traverse the LRU
list without dropping the vntableLock.
.LE
.P
The \*(lBvd_cache\*(lE substructure contains fields which
describe frequently changing attributes cached in the vnode.
This includes the access, modification and change times as well
as the file contents data version number.  The fileset version
number (\*(lBVV\*(lE) is not cached because its value is
maintained on a per-volume basis.  The intent to change the \*(lBVV\*(lE
is indicated by a dirty ctime.
.P
The \*(lBvd_cache\*(lE fields are protected by the \*(lBvd_cache.lock\*(lE:
.P
.aL
.LI
\*(lBnoChange\*(lE \*(EM
\*(lBatime\*(lE updates are ignored.
.LI
\*(lBnoStatus\*(lE \*(EM
Unused, parallels \*(lBnoAnode\*(lE.
.LI
\*(lBnoDirty\*(lE \*(EM
No unwritten status updates.
.LI
\*(lBnew[AMC]time\*(lE \*(EM
A bit for each time value, set if dirty.
.LI
\*(lBlast[AMC]time\*(lE \*(EM
Current time values.
.LI
\*(lBdataVersion\*(lE \*(EM
Current file data version number.
.LE
.P
The \*(lBvd_file\*(lE substructure contains fields relating to the anode level
representation of the file.  These fields, especially the anode handle,
are used by almost all vnode operations without the protection of the
\*(lBvd_file.lock\*(lE (see Locks).  The \*(lBvd_file.lock\*(lE must be locked
when these fields are changed:
.P
.aL
.LI
\*(lBnoAnode\*(lE \*(EM
Anode handle must stay closed.  Both volume and vnode
operations that require the anode handle should fail.
.LI
\*(lBnoDelete\*(lE \*(EM
Inactivation of vnodes for ZLC files does not reclaim space.  This is
set in various cases where deleting files would be a bad idea, for
example during volume ops and when the fileset is readonly.
.LI
\*(lBreadonly\*(lE \*(EM
File is in a readonly volume.  This bit is derived from
the volume header and is ignored if the volume is open.  This is
intended to cover replicated and backup filesets.  Filesets which
are locally mounted R/O are handled separately (see definition of
\*(lBEV_ISREADONLY\*(lE).  Filesets on R/O media will presumably need a new
mechanism to inform Episode of the readonly-ness of the media or
hardware.
.LI
\*(lBanode\*(lE \*(EM
Anode handle is open.
.LI
\*(lBanodeRO\*(lE \*(EM File is unwritable due to the presence
of a \*(bBCOW\*(bE (copy on write) file (namely, (\*(lBcopies>0\*(lE)).
This is intended to handle cases where an interrupted fileset
operation leaves some files in an otherwise R/W fileset with a
COW reference.
.LI
\*(lBap\*(lE \*(EM
Anode handle representing fid.
.LE
.P
The \*(lBvd_vm\*(lE substructure contains various bits
describing the state of the VM system as it relates to the
vnode.  These fields are protected by the \*(lBvd_vm.lock\*(lE:
.P
.aL
.LI
\*(lBnoReadable\*(lE \*(EM
Requests for new page mappings block.  Implies
\*(lBnoWritable\*(lE.
.LI
\*(lBnoWritable\*(lE \*(EM
Requests to return writable page mappings block.
.LI
\*(lBreadonly\*(lE \*(EM
Requests for writable page mappings that cannot be satisfied with
write-protected mappings fail.
.LI
\*(lBvalid\*(lE \*(EM
Valid pages may exist.
.LI
\*(lBdirty\*(lE \*(EM
Modified pages may exist.
.LI
\*(lBseg\*(lE \*(EM On AIX, has a VM segment (kept in
\*(lBvd_seg\*(lE).  The creation and deletion of the VM segment
are protected by the \*(lBvd_idLock\*(lE.  Never set on SunOS.
.LE
.P
.H 2 "Open Volume Restrictions"
.P
When a volume is opened, six bits are specified
(\*(lBopenbits\*(lE) that describe the allowable states for
cached data associated with the vnode.  Each bit controls part
of the vnode state space.  Setting the bit will restrict the
vnode from entering that state.  Of course, it may already be in
the restricted state, so the function that modifies these bits
(\*(lBvnm_StopUse()\*(lE) can also move the vnode out of the
restricted state when setting any bit.  These bits then can
refer both to state restrictions and to a process for forcing
the vnode out of the restricted state.  For example, specifying
\*(lBSTOPUSE_NO_DIRTYVM\*(lE prevents the creation of writable
page mappings (by setting \*(lBvd_vm.noWritable\*(lE), and cleans all
dirty pages (by calling \*(lBvnvm_Clean()\*(lE).
.P
Operations that violate open volume restrictions must be blocked
by volume synchronization (i.e., in
\*(lBvol_StartVnodeOp()\*(lE), rejected by the volume ops
dispatch code (in \*(lBafscall_volser()\*(lE using the \*(lBVOLCHECK()\*(lE
macro) or handled by Episode (e.g., \*(lBgetpage()\*(lE returns only R/O
pages).  For example, vnode-using primitives invoked by volume
operations that conflict with the volume open bits must be
avoided (e.g., specifying \*(lBSTOPUSE_NO_DIRTY\*(lE is
incompatible with restore operations).
.P
When the volume is closed, \*(lBvnm_StopUse()\*(lE is called
with an \*(lBopenbits\*(lE value of zero which returns all vnodes to
normal operation.
.P
The function \*(lBSetRestrictions()\*(lE processes these
\*(lBopenbits\*(lE to set or clear the various restriction bits
in the vnode:
.P
.aL
.LI
\*(lBSTOPUSE_NO_CHANGE\*(lE \*(EM
Containing fileset is open.  Operationally this
bit is assumed if any bits are specified.  Attempts to delete zero
link count files are ignored (calls to \*(lBvnm_inactive()\*(lE on such files
should be deferred anyway).  Implicit updates of \*(lBatime\*(lE are
discarded.
.LI
\*(lBSTOPUSE_NO_ANODE\*(lE \*(EM
Anode handle must be closed.  Calls to \*(lBPageIn()\*(lE
should \*(iBblock\*(iE and attempts to open the anode handle should
\*(iBpanic\*(iE.\*(f!  Implies
.FS
Episode can view failures of the
volume synchronization glue quite seriously since the
consistency of these operations is restricted to the kernel.
The \*(lBxvolume\*(lE layer will reject volume operations that
are inconsistent with the volume open mode so user-space errors
should not lead to panics.
.FE
\*(lBSTOPUSE_NO_DIRTY\*(lE.
.LI
\*(lBSTOPUSE_NO_STATUS\*(lE \*(EM
All cached status data must be written through and invalidated.
Operations that reference status data should fail.  Implies
\*(lBSTOPUSE_NO_VM\*(lE and \*(lBSTOPUSE_NO_DIRTY\*(lE.
.LI
\*(lBSTOPUSE_NO_DIRTY\*(lE \*(EM Updates to cached status data
must be written through.  Operations that modify status data
explicitly should fail.  Implies \*(lBSTOPUSE_NO_DIRTYVM\*(lE.
.LI
\*(lBSTOPUSE_NO_VM\*(lE \*(EM The VM must be written through and
invalidated.  Calls to \*(lBPageIn()\*(lE should \*(iBblock\*(iE.
Implies \*(lBSTOPUSE_NO_DIRTYVM\*(lE.
.LI
\*(lBSTOPUSE_NO_DIRTYVM\*(lE \*(EM The VM must be written
through.  Calls to \*(lBPageIn()\*(lE that require writable page
mappings must \*(iBblock\*(iE; others may return write-protected
mappings.
.LE
.P
To summarize the open modes use these \*(lBopenbits\*(lE bits in
addition to \*(lBnoChange\*(lE:
.P
.aL
.LI
\*(lBopen-change-id\*(lE \*(EM
\*(lBNO_ANODE+NO_DIRTY\*(lE
.br
Swapid (for clone and intra-server move).
.LI
\*(lBopen-change-anode\*(lE \*(EM
\*(lBNO_ANODE+NO_STATUS+NO_DIRTY\*(lE
.br
Swapid (for replica release), reclone (backing fileset),
unclone (backing fileset), destroy.
.LI
\*(lBopen-change-vnode\*(lE \*(EM
\*(lBNO_VM\*(lE
.br
Restore.
.LI
\*(lBopen-read-anode\*(lE \*(EM
\*(lBNO_DIRTY\*(lE
.br
Clone, reclone (front fileset).
.LI
\*(lBopen-read-vnode\*(lE \*(EM
\*(lBNO_DIRTYVM\*(lE
.br
Dump, unclone (front fileset).
.LI
\*(lBopen-noop\*(lE \*(EM
\*(lB0\*(lE
.br
Fileset header operations.
.LE
...\" .H 2 "Vnode State Diagram"
...\" .P
...\" The state diagram [see ./vnsync.design.xfig] uses some additional terms
...\" describing the states a vnode can be in.
...\"     id => !NoIdentity
...\"     zlc => Zero Link Count
...\"     vm => vd_vm.seg
...\"     swap => \*(lBSTOPUSE_NO_ANODE
...\" 	Note that swap does not imply !valid.
...\"     open => vd_file.noDelete
...\"     block => \*(lBSTOPUSE_NO_VM
...\"     clean => \*(lBSTOPUSE_NO_DIRTYVM
...\"     data => vd_vm.valid
...\"     mod => vd_vm.dirty
...\"
...\" Some implications from the diagram:
...\"     anode => id
...\"     data => id
...\"     data => vm
...\"     mod => data
...\"     block => clean
...\"     swap => clean
...\"
...\" The "no anode" column is only occupied when a volume is open for a
...\" heavy-duty operation such as change-id or change-anode, but not
...\" change-vnode (restore).
.P
.H 1 "GLOBAL DATA STRUCTURES"
.P
In addition to per-vnode fields, vnode synchronization uses several
global structures.  They are all protected by the
\*(lBvntableLock\*(lE:
.P
.aL
.LI
\*(lBvntable\*(lE \*(EM Hash table containing all vnodes with
identities.  The hash index is a function of the volid
and the fid's index.  A vnode on this list has \*(lBonHash\*(lE set.
.LI
\*(lBvntableLabel\*(lE \*(EM
Counter used by vnode iteration procedures.  See
\*(lBvnm_StopUse()\*(lE.
.LI
\*(lBlruList\*(lE \*(EM Contains all unused vnodes in least
recently used order.  Vnodes are added to the list by inactive
and removed by \*(lBObtainVnode()\*(lE.  They may be held or not
and may have an identity or not.  A vnode on this list has \*(lBonLRU\*(lE
set.
.LI
\*(lBstaleList\*(lE \*(EM
Contains vnodes with neither \*(lBonHash\*(lE nor \*(lBonLRU\*(lE set.  This
prevents us from completely losing track of stale but held vnodes.
This fifo shares the lru fifo's thread.
.LI
\*(lBvnCount\*(lE \*(EM
Is the number of currently allocated vnodes.
.LI
\*(lBvnCountTarget\*(lE \*(EM
Is the preferred number of vnodes, which can be set at initialization
time.  Free unused vnodes if we have allocated more than this.
.LI
\*(lBvnCountMax\*(lE \*(EM Never allocate more vnodes than this.
Return \*(lBENFILE\*(lE instead.  This is also an configuration
parameter; if it is zero no hard upper-bound on the number of
vnodes is enforced.
.LE
.P
.H 1 "PROCEDURE OUTLINES"
.P
This section briefly describes the primary functions involved with vnode
synchronization:\*(f!
.FS
For additional details see the code in
\*(lBfile/episode/vnops/efs_vnode.c\*(lE.
.FE
.P
.aL
.LI
\*(lBvnm_FindVnode()\*(lE \*(EM
Returns a held vnode representing a fid.  It locates an
existing vnode or obtains an unused vnode (allocating a new one if
necessary) by calling \*(lBObtainVnode()\*(lE then initializes the vnode by
calling \*(lBOpenVnode()\*(lE.  The caller must not have started a transaction.
.LI
\*(lBvnm_Allocate()\*(lE \*(EM
Returns a vnode without an identity for use by a yet-to-be-created file.
The caller must not have started a transaction.
.LI
\*(lBvnm_SetIdentity()\*(lE \*(EM
Takes a \*(lBNoIdentity\*(lE vnode and the fid of a new file
and its already opened anode handle, and makes the vnode refer to the
file.  We rely on the fact that the anode handle of a newly created
file is inaccessible to other users.  The case of racing \*(lBVGET\*(lE's for
colliding indexes is handled by waiting for those threads to notice
that all fid's with this index are stale.
.P
This is called when a transaction has already been started so we
must avoid heavyweight operations that could start a transaction.
.LI
\*(lBObtainVnode()\*(lE \*(EM
Locates a vnode for use by a file.  If the fid is
specified and a vnode for that fid already exists that vnode is
returned.  Otherwise a fresh vnode is obtained, either by calling
\*(lBRecycle()\*(lE or by allocating a new one.
.LI
\*(lBOpenVnode()\*(lE \*(EM
Attaches a vnode without an identity to a specified fid.
This can fail if a different vnode for that fid already exists.  It
can also fail if the fid does not match an existing file.  If called
from \*(lBvnm_SetIdentity()\*(lE an anode handle for a newly created file is
provided which we use instead of calling \*(lBepif_Open()\*(lE.
.P
This function uses the \*(lBvd_idLock\*(lE to ensure that there is never more
than one vnode referring to a file.
.LI
\*(lBRecycle()\*(lE \*(EM
Attempts to obliterate an unused vnode's current identity by
reclaiming its resources, then clearing its identity.  If the
specified vnode is being used or if, on AIX, its VM segment cannot
be deleted, the vnode is left untouched.
.P
This function holds the \*(lBvd_idLock\*(lE while checking the
vnode's reference count.  Since \*(lBOpenVnode()\*(lE grabs this lock also,
this ensures that \*(lBRecycle()\*(lE has (nearly) exclusive use
of the vnode and that destroying its identity is safe.
.LI
\*(lBvnm_inactive()\*(lE \*(EM
Does cleanup processing on a vnode when the caller is
dropping the last reference to it.  Has no effect if the reference
count is greater than one.  It deletes zero link count files on
non-open R/W volumes.  On AIX, it deletes the VM segment of a stale
vnode.
.LI
\*(lBvnm_Delete()\*(lE \*(EM This deletes the file corresponding
to a particular \*(lBvolp\*(lE/fid making the vnode
stale if it is in use.  Unlike inactive it takes no
consideration of the vnode's \*(lBrefCount\*(lE or the file's
\*(lBlinkCount\*(lE.  Used by \*(lBvol_efsDelete()\*(lE during restore.
.LI
\*(lBvnm_StopUse()\*(lE \*(EM
Takes a volume and an open mode.  It traverses all the
vnodes for that volume and puts them into a state compatible with
the open mode.  It is called with an open mode of zero before these
operations are released when the volume is being closed.
.P
We assume that a higher level lock protects the fileset so that
only one thread calls this routine at a time for each fileset.
It makes a single pass over the vnodes assuming that there is no
ongoing activity that would reestablish any inconsistent vnode
state.  Before this routine starts all incompatible vnode
operations are already blocked.
.P
The basic algorithm is to use the vnode hash table to locate all
vnodes of interest.  This is protected by the
\*(lBvntableLock\*(lE which we may not hold while flushing vnode
state.  So, under the \*(lBvntableLock\*(lE, we identify and
hold the \*(iBnext\*(iE vnode to work on.  Then we drop the
\*(lBvntableLock\*(lE and flush the \*(iBcurrent\*(iE vnode.  The next
vnode can become stale while the current vnode is being
processed.  In this rare case, the iteration is restarted.
.P
After each vnode is made consistent with the current volume open
mode it is marked with the label associated with the hash table
when we started.  This allows us to inexpensively skip it if we
must restart the iteration.  Any vnode created while
\*(lBvnm_StopUse()\*(lE is running will be labeled with the
current label (or a subsequent one) by \*(lBSetIdentity()\*(lE
and its \*(lBopenbits\*(lE are initialized to the same value by
\*(lBSetRestrictions()\*(lE called from \*(lBOpenVnode()\*(lE.
\*(lBvnm_StopUse()\*(lE can safely skip these also.  Therefore
all processed vnodes will remain consistent with the current
volume open mode because their restriction bits have been set
correctly and since only compatible vnode operations will be
running.
.P
If \*(lBSTOPUSE_NO_ANODE\*(lE is being cleared, the anode handle of each vnode
is, of course, reopened.  If this fails (e.g., because a reclone
operation removed files from the backing fileset) then the vnode is
made stale.
.LI
\*(lBSetRestrictions()\*(lE \*(EM Called by
\*(lBOpenVnode()\*(lE to initialize a new vnode or by
\*(lBStopUse()\*(lE to calculate the vnode state restrictions
from the current volume open bits.  It is called after the vnode
has been put into a state consistent with the current open mode
(e.g., if \*(lBSTOPUSE_NO_ANODE\*(lE is specified it sets
\*(lBvd_file.noAnode\*(lE and asserts that \*(lBvd_file.anode\*(lE is
false).
.LE
.P
.H 1 "DELETING FILES"
.P
Here is a summary of the steps we take to provide correct
semantics for ZLC files.  We carefully distinguish between
\*(iBunlink\*(iE (or \*(iBremove\*(iE), which reduces a file's
link count, and \*(iBdelete\*(iE, which deallocates all the
storage for a file and frees its anode.
.P
When a file is unlinked and its link count reaches zero, it
becomes a candidate for deletion.  The glue functions that can
unlink files and the file system independent fileset restore
code passes the vnode to the ZLC Manager which attempts to
obtain an \*(qBopen for delete\*(qE token.  It holds the vnode
until it succeeds in this.  When the delete token has been
obtained, the ZLC Manager knows that no remote users are using
the file, so it releases the vnode.
.P
When the vnode's reference count reaches zero,
\*(lBVOP_INACTIVE()\*(lE is invoked by the file system
independent macro \*(lBVN_RELE()\*(lE.  This will call a glue
(file system independent) function which calls \*(lBvol_StartBusyOp()\*(lE,
which fails if the containing volume is open.  In this case the
vnode is held on a per-volume (\*(lBvolp->v_vp\*(lE) list until the volume
is closed.  The \*(lBvol_close()\*(lE operation will release these vnodes
again.  In any case, \*(lBVOP_INACTIVE()\*(lE returns
successfully.
.P
Once \*(lBStartBusyOp()\*(lE succeeds, \*(lBvnm_inactive()\*(lE is called.
This operation will actually delete the file if its link count
is zero unless the volume is open\*(f!
.FS
\*(lBStartBusyOp()\*(lE always succeeds for the thread which has
the volume open.  This will allow \*(lBvnm_inactive()\*(lE to be
called on vnodes in open volumes (e.g., during dump or restore).
Under normal operation there should be no way that a volume
operation could release a vnode for a file with a link count of
zero since the vnode should have been passed to the ZLC Manager
by restore for token management.  Just to be safe, however, we
avoid deleting files in open volumes.
.FE
or readonly.
.P
The entire foregoing mechanism can be harmlessly invoked on
files whose link count is not zero.  Indeed,
\*(lBVOP_INACTIVE()\*(lE cannot safely check the link count
during some volume operations and so must defer inactivating
vnodes released during those operations.
.P
The above procedures ensure that, when \*(lBvnm_inactive()\*(lE
receives a vnode whose link count is zero and which is not in a
readonly volume, no volume operation is in progress and none
will start while it is running, and the delete token has been
obtained.  Thus, it will be safe to delete the file.
.P
The changes to add glue to \*(lBVOP_INACTIVE()\*(lE were done
under db5505.
.P
.H 2 "Undeleting Files During Restore"
.P
The old code used to delete each file before restoring it.  This
resulted in a requirement to undelete these files in the common
case where the new file's fid matches the old file's
fid and reattach the new file to the old vnode.  This
created all sorts of problems and this behavior was
changed.\*(f!
.FS
Transarc defect db5449: \*(qBFileset restore need not delete file on
creation always.\*(qE
.FE
.P
.H 2 "Making Stale Vnodes"
.P
The only way to create a stale vnode (i.e., held and
\*(lBNoIdentity\*(lE) is via a fileset operation.  This
statement, however, needs a slight qualification.  Actually
non-explicitly held vnodes, for instance those held during hash
table traversal, can become stale.  An explicit hold is a
\*(lBFAST_VN_HOLD\*(lE followed by a check of the fid under the
protection of the \*(lBvd_idlock\*(lE (see the description of the
\*(lBvd_idlock\*(lE in Locks).  The \*(lBvnm_FindVnode\*(lE function
always returns explicitly held vnodes.  A vnode with only an
internal hold can become stale if \*(lBvnm_inactive()\*(lE or
\*(lBRecycle()\*(lE is running concurrently.
.P
All vnode operations operate on explicitly held vnodes, so any
volume operation that can produce stale vnodes is inconsistent
with (virtually) all vnode operations.  Therefore vnode
operations generally need only check for stale vnodes on entry,
typically using the \*(lBEV_DEPHANTOM\*(lE macro.\*(f!  An
.FS
The name of this macro is a historical artifact: the process of
applying \*(lBStopUse()\*(lE to a vnode used to be called
\*(qBphantomization\*(qE.
.FE
example of an exception to this is \*(lBVOPX_GETVOLUME()\*(lE,
which, because it is unglued, must carefully check for
\*(lBNoIdentity\*(lE.
.P
.H 1 "LOCKS"
.P
Here is a description of the locks used for vnode
synchronization.  They appear in resource hierarchy order.  The
\*(lBStartTran\*(lE resource and the SunOS \*(lBpage_lock\*(lE
are also listed to show their position in the hierarchy:
.P
.aL
.LI
rw_lock \*(EM \*(lBvmmLenLock\*(lE \*(EM per vnode
.P
This is used only on AIX.  See RFC 75.0 for details.
.P
.LI
rw_tlock \*(EM \*(lBvd_tlock\*(lE \*(EM per vnode
.P
This lock protects the consistency of directories and some vnode
interface properties such as the link count.  It is held throughout most
vnode ops.  It is not used to protect the consistency of the vnodes
themselves, but only the objects the vnodes represent.
.P
.LI
mutex \*(EM \*(lBvd_idlock\*(lE \*(EM per vnode
.P
This lock protects a vnode's id from changing.  Procedures that
destroy a vnode's identity during normal operation, namely
\*(lBvnm_inactive()\*(lE and \*(lBRecycle()\*(lE, act only on
unused vnodes (see Making Stale Vnodes for a discussion of how a
vnode that is in use can have its identity removed).  These
functions must check the reference count after grabbing the
\*(lBvd_idlock\*(lE.  This prevents races between
\*(lBOpenVnode()\*(lE and \*(lBvnm_inactive()\*(lE or
\*(lBRecycle()\*(lE.  Users that have explicitly requested a
vnode for a particular fid must call
\*(lBvnm_FindVnode()\*(lE, which calls \*(lBOpenVnode()\*(lE.
That routine must lock the \*(lBvd_idlock\*(lE while verifying
that the vnode (from \*(lBObtainVnode()\*(lE) contains the requested
fid and that the fid matches an existing
file.  While the \*(lBvd_idlock\*(lE is held neither
\*(lBvnm_inactive()\*(lE nor \*(lBRecycle()\*(lE can clear the
vnode's identity, and after the \*(lBvd_idlock\*(lE is released
both of these routines will notice the vnode is in use and skip
it.
.P
This contrasts with non-explicit (or internal) vnode holders
(those which may bump the reference count from zero on a vnode
without concern for its identity) which are of two types: hash
table iterators and the VM system.  The former obtain the
\*(lBvd_idlock\*(lE after holding each vnode and check that the
vnode is not stale.  In the latter case the VM is cleared in the
process of removing the vnode's identity, so VM requests on
stale vnodes can safely be ignored.  Synchronization with volume
operations must be carefully considered in these cases.  If
vnode-destroying volume operations may be running concurrently
then careful examination of the vnode state under protection of
the \*(lBvd_idlock\*(lE is safe.  If such operations are known
to be excluded (which is the case for most vnode operations)
then checking the identity is safe as long as the
\*(lBvd_idlock\*(lE was grabbed at some point since the vnode
was held.
.P
Basically obtaining the \*(lBvd_idlock\*(lE converts an internal
hold into an explicit hold.
.P
To determine that a fid represents an existing file it
must be passed to \*(lBepif_Open()\*(lE to obtain the anode handle (kept in
\*(lBvd_file.ap\*(lE).  This handle is always valid in vnodes with
identities except during volume operations that require
disconnection between the anode and vnode representations.
.P
Because the ID lock is held for the duration of
\*(lBvnm_inactive()\*(lE and \*(lBRecycle()\*(lE, it is a high
level lock that can be held across VM operations.  It must not
be used in \*(lBPageIn()\*(lE or \*(lBPageOut()\*(lE.
.P
On AIX, \*(lBStopUse()\*(lE must also hold this lock to exclude
\*(lBvnm_inactive()\*(lE\*(f!
.FS
Of course, \*(lBvnm_inactive()\*(lE should already be blocked by
the volume glue in \*(lBVOP_INACTIVE()\*(lE.
.FE
and \*(lBRecycle()\*(lE while it blocks incompatible VM
operations.  This prevents the VM segment deletion from
deadlocking with blocked page faults.
.P
.LI
mutex \*(EM \*(lBvd_vm.lock\*(lE \*(EM per vnode
.P
This lock protects the vnode during state transitions related to
the virtual memory page cache.  It covers both the bits
specifying restrictions as well as the advisory bits describing
the current state of the page cache.  It is used during
\*(lBPageIn()\*(lE but not \*(lBPageOut()\*(lE.  On AIX, the
this lock protects the use of the VM segment.  See RFC 75.0 for
details.
.P
.LI
rw_lock \*(EM \*(lBvd_file.lock\*(lE \*(EM per vnode
.P
The lock protects the consistency of the anode's length and
block map.  It used by functions that reference or modify a
file's allocation map, for example \*(lBepia_Truncate()\*(lE.  An exception
to this rule is that \*(lBPageOut()\*(lE does not use this lock,
as that would make \*(lBPageOut()\*(lE implicitly depend upon
\*(lBPageIn()\*(lE.  Instead \*(lBPageOut()\*(lE relies on the
VM system's page lock when examining the block map while writing
out a dirty page.  See RFC 75.0 for details.
.P
.LI
\*(iBresource\*(iE \*(EM \*(lBStartTran\*(lE \*(EM global
.P
(Call \*(lBelbb_StartTran()\*(lE to begin a transaction.)
.P
.LI
mutex \*(EM \*(lBvd_cache.lock\*(lE \*(EM per vnode
.P
This lock protects the cached vnode status information, namely the three
times and data version number.  It is used when updating the times and
when flushing them through to the anode.
.P
As this lock is below \*(lBStartTran\*(lE in the resource
hierarchy, we may not start a transaction while holding the
lock.  This leads to some awkward code in \*(lBvnm_UpdateAnode()\*(lE, which
can be called without an already started transaction, but needs
a transaction to write through dirty status.
.P
.LI
rw_lock \*(EM \*(lBpage_lock\*(lE \*(EM per page [SunOS]
.P
(The SunOS page lock.)
.P
.LI
mutex \*(EM \*(lBvntableLock\*(lE \*(EM global
.P
This lock protects the fid, volid, iteration
label, and \*(lBonHash\*(lE and \*(lBonLRU\*(lE bits of all
vnodes.  It also protects the global state such as the hash
table and LRU and stale lists.
.P
.LI
mutex \*(EM \*(lBrefCountMutex\*(lE \*(EM per vnode [AIX]
.br
mutex \*(EM \*(lBv_lock\*(lE \*(EM per vnode [SunOS]
.P
This protects the vnode's reference count and is referenced via
the \*(lBefs_lockvp()\*(lE and \*(lBefs_unlockvp()\*(lE macros.
On AIX, we added this mutex to protect our uses of the \*(lBv_count\*(lE
field; the AIX kernel makes very little use of this field.
.LE
.P
...\" =========================================================================
...\" Author's address goes here, as unnumbered heading, at end of doc.
...\" =========================================================================
.P
.ne 3+5
.HU "AUTHOR'S ADDRESS"
.P
.tl $Ted Anderson$$Internet email: ted_anderson@transarc.com$
.tl $Transarc Corporation$$Telephone: +1-412-338-4410$
.tl $707 Grant St.$$$
.tl $Pittsburgh, PA 15219$$$
.tl $USA$$$
...\" =========================================================================
...\" Done!
...\" =========================================================================
