...\" OSF-RFC 90.0
...\"
...\" FORMATTING INSTRUCTIONS for this RFC (these may vary per RFC):
...\"       nroff -Tlpr rfc90.0.roff > rfc90.0.txt
...\"       troff -Tps rfc90.0.roff | <ps-post-processor> > rfc90.0.ps
...\" (Where "troff" means "device-independent troff", or "ditroff".)
...\"
...\" =========================================================================
...\" This template first sets a bunch of *roff options (authors/readers
...\" don't usually have to know about these).
...\" Then it defines some strings and macros, many of which deal with
...\" things that differ between nroff & troff (some of these may not be
...\" perfect, but they're better than nothing -- to do a really good
...\" job would require a real semantic markup language.
...\" Convention: "Begin/End" for strings, "Start/Finish" for macros.
...\" Strings:
...\"       \*(f!        - Footnote string (replaces \*F).
...\"       \*(hB, \*(hE - Page header/footer font (internal use).
...\"       \*(kB, \*(kE - Doc header font (internal use).
...\"       \*(qB, \*(qE - Quotations.
...\"       \*(iB, \*(iE - Italics/emphasis in primary font.
...\"       \*(bB, \*(bE - Bold font.
...\"       \*(lB, \*(lE - Literal font.
...\"       \*(jB, \*(jE - Italics/emphasis in literal font.
...\"       \*(nH        - Default note header string.
...\" Macros:
...\"       .aH      - Appendix header macro (uses number register \na).
...\"       .aL      - Automatic list macro (replaces .AL; uses num reg \ng).
...\"       .tS, .tF - Title start/finish (internal use).
...\"       .cS, .cF - Displays (no-fill) without indentation.
...\"       .dS, .dF - Displays (no-fill) with indentation.
...\"       .iS, .iF - Indented (fill) text.
...\"       .nS, .nF - Note.
...\" -------------------------------------------------------------------------
...\" First, set up some number registers here (instead of on command line),
...\" and include the "mm" macro package here (instead of on command line).
...\" -------------------------------------------------------------------------
.if n .nr L 66 \" Nroff page length = 66 lines.
.if t .nr L 11i \" Troff page length = 11 inches.
.if n .nr W 72 \" Nroff page width = 72 columns.
.if t .nr W 6.5i \" Troff page width = 6.5 inches.
.if n .nr O 3 \" Nroff page offset = 3 columns.
.if t .nr O 0.75i \" Troff page offset = 0.75 inches.
.nr N 2 \" No header on page 1.
.so /usr/lib/tmac/tmac.m \" Points to "mm" package, in /usr/lib/macros.
...\" -------------------------------------------------------------------------
...\" Next, twiddle the "mm" package to suit our preferred style.
...\" -------------------------------------------------------------------------
...\" Point size and font types.
...\" -------------------------------------------------------------------------
.if n .fp 1 R \" "Regular" font ONLY -- don't use any others in nroff.
.if t \{ .S 10 12 \" Point size = 10, vertical spacing = 12.
...\" Note: Some systems give different names to these fonts.
.fp 1 R \" Times roman.
.fp 2 I \" Times italic.
.fp 3 B \" Times bold.
.fp 4 BI \" Times bold italic.
.fp 5 CW \" Courier.
.fp 6 CI \" Courier oblique.
.fp 7 CB \" Courier bold.
.fp 8 CX \" Courier bold oblique.
.fp 9 H \" Helvetica.
.fp 10 HI \" Helvetica oblique.
.fp 11 HB \" Helvetica bold.
.fp 12 HX \" Helvetica bold oblique.
.fp 13 S \} \" Special symbol font -- normally only called automatically.
...\" -------------------------------------------------------------------------
...\" Headings; page header and footers; titles.
...\" -------------------------------------------------------------------------
.nr Ej 0 \" No eject for first-level headings.
.nr Hs 7 \" Heading space level = blank line after heading (all levels).
.nr Hb 7 \" Heading break level = break after heading (all levels).
.nr Hi 1 \" Post-heading indent = paragraph indent.
.nr Hc 0 \" Heading centering = none.
.if n .ds HF 1 1 1 1 1 1 1 \" Heading fonts = regular (no underlining).
.if t .ds HF 11 11 11 11 11 11 11 \" Heading fonts = Helvetica bold.
.if t .ds HP 0 0 0 0 0 0 0 \" Heading point sizes (= default).
.HM 1 1 1 1 1 1 1 \" Heading mark = arabic (all levels).
.nr Hu 1 \" Unnumbered heading level = 1 (see aH macro, below).
.de HX \" Beginning-of-heading processing.
.in 0 \" Left justify headings.
.ie     \\$2=0 .ds }0\" Null string heading mark for HU.
.el .ie \\$1=1 .ds }0 \\n(H1.\ \&\" Heading marks = dotted sections + 1 space.
.el .ie \\$1=2 .ds }0 \\n(H1.\\n(H2.\ \&
.el .ie \\$1=3 .ds }0 \\n(H1.\\n(H2.\\n(H3.\ \&
.el .ie \\$1=4 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\ \&
.el .ie \\$1=5 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\ \&
.el .ie \\$1=6 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\\n(H6.\ \&
.el .if \\$1=7 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\\n(H6.\\n(H7.\ \&
..
.de HZ \" End-of-heading processing.
.if n .in 3 \" Indent body of doc by 3 columns in nroff.
.if t .in 0 \" Don't indent in troff.
..
.if n .ds hB \&\" Page header/footer font begin in nroff.
.if t .ds hB \f9\" Page header/footer font begin in troff.
.if n .ds hE \&\" Page header/footer font end in nroff.
.if t .ds hE \fP\" Page header/footer font end in troff.
.if n .ds kB \&\" Doc header font begin in nroff.
.if t .ds kB \f(11\" Doc header font begin in troff.
.if n .ds kE \&\" Doc header font end in nroff.
.if t .ds kE \f1\" Doc header font end in troff.
.de tS \" Title start.
.SP 2 \" 2 blank lines.
.ce 99 \" Center (each line of) title.
.if t \{ .ft 11 \" Bold helvetica.
.S +2 D \} \" Bigger point size.
..
.de tF \" Title finish.
.ce \" Turn off centering.
.SP 1 \" 1 blank line.
.if t \{ .ft 1 \" Return to regular font.
.S P P \} \" Return to regular point size.
..
...\" -------------------------------------------------------------------------
...\" Special Appendix heading macro, .aH.
...\" -------------------------------------------------------------------------
.nr a 0 1 \" Appendix number.
.af a A \" Assign format upper-case alpabetic to number register a.
.de aH \" Appendix heading macro.
.if \\na=0 \{ .nr H1 0 \" Reset H1 to 0.
.HM A 1 1 1 1 1 1 \} \" Heading mark = Upper case alphabetic + arabics.
.HU "APPENDIX \\n+a. \\$1"
..
...\" -------------------------------------------------------------------------
...\" Paragraph stuff.
...\" -------------------------------------------------------------------------
.nr Pt 0 \" Paragraph type = left-justified.
.nr Pi 0 \" Paragraph indent = 0.
.nr Ps 1 \" Paragraph spacing = 1 blank space.
...\" -------------------------------------------------------------------------
...\" Special list macro, .aL (replaces .AL, for all levels).
...\" This should be used for almost all lists (including ".LI "\ "").
...\" The only exception is variable lists (.VL, indented by multiples of 6).
...\" -------------------------------------------------------------------------
.de aL
.nr g \\n(:g
...\" In-line lists should be numbered (by hand): (1), (2), (3), ...
.ie     \\ng=0 .LB 6 0 1 3 a \" 1st level: (a), (b), (c), ...
.el .ie \\ng=1 .LB 6 0 1 3 i \" 2nd level: (i), (ii), (iii), ...
.el .ie \\ng=2 .LB 6 0 1 4 a \" 3rd level: [a], [b], [c], ...
.el .ie \\ng=3 .LB 6 0 1 4 i \" 4th level: [i], [ii], [iii], ...
.el .ie \\ng=4 .LB 6 0 1 6 a \" 5th level: {a}, {b}, {c}, ...
.el .if \\ng=5 .LB 6 0 1 6 i \" 6th level: {i}, {ii}, {iii}, ...
..
.nr Ls 6 \" Blank lines between all list items, by default (but adjustable).
...\" -------------------------------------------------------------------------
...\" Footnote stuff; special footnote string, \*(f!.
...\" -------------------------------------------------------------------------
.if n .ds f! [\\n+(:p]\" Footnote string (replaces \*F in nroff).
.if t .ds f! \\*F\" Footnote string (same as \*F in troff).
.if n .FD 6 \" Footnotes not hyphenated or indented, label left justified.
.if t .FD 5 \" Footnotes hyphenated, not indented, label left justified.
.nr Fs 1 \" 1 blank line between footnotes.
...\" -------------------------------------------------------------------------
...\" Line adjustment stuff.
...\" -------------------------------------------------------------------------
.if n .nr Hy 0 \" No hyphenation in nroff.
.if t .nr Hy 1 \" Hyphenate in troff.
.if n .SA 0 \" Set adjust: left margin only in nroff.
.if t .SA 1 \" Set adjust: left and right margins in troff.
...\" -------------------------------------------------------------------------
...\" Miscellaneous stuff.
...\" -------------------------------------------------------------------------
.ta \" No tabs by default -- set them up by hand as needed.
.nr Si \n(Ls \" Default indent for .DS display macro = 6 (use in troff only).
...\" -------------------------------------------------------------------------
...\" Displays.
...\" -------------------------------------------------------------------------
.de cS \" Display start: no-fill, literal font, no indentation.
.P
.nf \" No fill mode.
.if t .ft 5 \" Constant width font in troff.
..
...\" Within .cS, ".ne N"'s can be added by hand, but should be minimized.
.de cF \" Display finish.
.if t .ft 1 \" Back to standard font in troff.
.fi \" Fill mode.
.P
..
.de dS \" Display start: no-fill, literal font, with indentation.
.P
.aL \" Use .aL macro for consistent indentation.
.nf \" No fill mode.
.LI "\ " \" List item will no (visible) marker.
.if t .ft 5 \" Constant width font in troff.
..
...\" Within .dS, ".ne N"'s can be added by hand, but should be minimized.
.de dF \" Display finish.
.if t .ft 1 \" Back to standard font in troff.
.fi \" Fill mode.
.LE
.P
..
.de iS \" Indent start: fill, regular font, with indentation.
.P
.aL
.LI "\ "
..
.de iF \" Indent finish.
.LE
.P
..
.ds nH NOTE\"Default note header string -- can be changed by author.
.de nS \" Note start: fill, italics font, with indentation.
.P
.aL \" Use .aL macro for consistent indentation.
.LI "\ " \" List item will no (visible) marker.
.if t .ft 2 \" Italics font in troff, and reverse roman <--> italic fonts:
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f1\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.ie \\n(.$=0 \\*(nH:\" Default header string if none supplied by author.
.el \\$1:\" Header string supplied by author as argument to .nS macro.
..
.de nF \" Note finish.
.if t .ft 1 \" Back to standard font in troff, and remap font macros:
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f2\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.LE
.P
..
...\" -------------------------------------------------------------------------
...\" Quotation marks and font toggles.
...\" -------------------------------------------------------------------------
.if n .ds qB \&"\" Quotation begin in nroff.
.if t .ds qB ``\" Quotation begin in troff.
.if n .ds qE \&"\" Quotation end in nroff.
.if t .ds qE ''\" Quotation end in troff.
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f2\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.if n .ds bB *\" Bold font begin in nroff.
.if t .ds bB \f3\" Bold font begin in troff.
.if n .ds bE *\" Bold font end in nroff.
.if t .ds bE \fP\" Bold font end in troff.
.if n .ds lB `\" Literal font begin in nroff.
.if t .ds lB \f5\" Literal font begin in troff.
.if n .ds lE '\" Literal font end in nroff.
.if t .ds lE \fP\" Literal font end in troff.
.if n .ds jB <\" Italics/emphasis literal font begin in nroff.
.if t .ds jB \fP\f6\" Italics/emphasis literal font begin in troff.
.if n .ds jE >\" Italics/emphasis literal font end in nroff.
.if t .ds jE \fP\f5\" Italics/emphasis literal font end in troff.
...\" -------------------------------------------------------------------------
...\" No diffmarks by default, i.e., define .mc to be null.
...\" (Comment out this null definition to turn diffmarking on.)
...\" -------------------------------------------------------------------------
.de mc
..
...\" =========================================================================
...\" Finally, it's time to start writing the document!
...\" The OSF-RFC author modifies the following header/footer info.
...\" (The major/minor number is assigned by the OSF-RFC Editor.)
...\" =========================================================================
.ND "February 1996" \" Date must be hard-coded.
.PH "$\*(hBOSF-RFC 90.0$Security Enhancements for DCE DFS$\\\\*(DT\*(hE$"
.PF "$\*(hBEverhart$DRAFT #90.0 [\n(yr-\n(mo-\n(dy]$Page \\\\n%\*(hE$" \" Draft.
.PF "$\*(hBEverhart$$Page \\\\n%\*(hE$" \" Final version.
...\"
...\" Following are the first printed lines (header info) of the document:
...\"
\&\" Force top-of-first-page trap to position the following info correctly.
.tl $\*(kBTransarc Corporation$$C. Everhart (Transarc)\*(kE$
.tl $\*(kBRequest For Comments: 90.0$$\*(kE$
.tl $\*(kB\*(DT$$\*(kE$
.tS \" Title, in all capitals (can span multiple lines):
SECURITY ENHANCEMENTS FOR DCE DFS
.tF
...\" =========================================================================
.P
.H 1 "INTRODUCTION"
.P
This document reviews the authentication that DCE DFS employs in
its RPC communications.  It proposes changes and extensions to
the DFS authentication model, not only to plug authentication
holes but also to allow DFS administrators to affect the levels
of authentication that DFS uses.
.P
.H 1 "AUTHENTICATION USAGE IN DFS"
.P
.H 2 "High-Level Review of Existing Usage"
.P
In DCE 1.1 and prior releases, DFS has used a mix of
authenticated and unauthenticated DCE RPCs.  Most
server-to-server communication has been authenticated at the
\*(lBrpc_c_protect_level_pkt_integ\*(lE level, except for
communication between peer \*(lBrepserver\*(lE processes, which
have been unauthenticated.  RPC communication initiated by
administrative commands (\*(lBfts\*(lE, \*(lBbos\*(lE,
\*(lBbak\*(lE) to user-space servers has always been
authenticated at the \*(lBrpc_c_protect_level_pkt_integ\*(lE
level or above, except for communication to
\*(lBrepserver\*(lEs, which again has been unauthenticated.  RPC
communication from the file exporter to the token-revocation
interfaces of the token clients (the DFS Cache Manager, the
\*(lBfts\*(lE and \*(lBdfsexport\*(lE commands, and the
\*(lBrepserver\*(lE process) has been unauthenticated.  Lastly,
communication initiated by the DFS Cache Manager has been mixed: RPC
calls to the user-space \*(lBflserver\*(lE and
\*(lBrepserver\*(lE processes have been unauthenticated, and
calls to the file exporter have been authenticated only when
they are made on behalf of correctly-authenticated users running
on the Cache Manager machine, and then only at the
\*(lBrpc_c_protect_level_pkt\*(lE level.
.P
.H 2 "Discussion"
.P
Several aspects of the existing authentication usage are
inadequate in the face of a variety of attacks.  Unauthenticated
communication precludes all kinds of defenses against possible
attacks; it should be used only as a last resort, if at all.
However, DFS in the DCE 1.1 and earlier releases uses
unauthenticated RPCs in several contexts where authentication is
available and where performance requirements are not
overwhelming.  In addition, in some contexts, it makes sense for
administrators to choose the relatively high level of security
offered by the \*(lBrpc_c_protect_level_pkt_privacy\*(lE
authentication level.
.P
The \*(lBrpc_c_protect_level_pkt\*(lE authentication level could
be the target of a data-substitution attack by a
network-bridge-level attacker, as noted in the article by Eric
Brewer et al. ([Brew95]).  The DCE
\*(lBrpc_c_protect_level_pkt_integ\*(lE level should be adequate
to prevent such data substitution, but the DFS Cache Manager is
using a lesser level of protection,
\*(lBrpc_c_protect_level_pkt\*(lE, for performance reasons.
Ideally, the administrators for the DFS Cache Manager's
communication would be able to control the protection level
being used, allowing them to choose a trade-off point between
performance and security.
.P
Other data-substitution attacks are possible in the DFS context,
such as altering the data returned by the \*(lBflserver\*(lE to
a DFS cache manager.  Since such data traffic is relatively
low-bandwidth, it costs little to use the higher protection
levels available with DCE RPC in all cases.
.P
.H 1 "PROPOSED CHANGES"
.P
The goal of this work is to close the authentication holes in a
backward-compatible fashion.  This work has several components:
.P
.aL
.LI
Alter the clients making RPCs to the \*(lBrepserver\*(lE (the
\*(lBfts\*(lE command, peer \*(lBrepserver\*(lE processes) to
use authenticated RPCs.
.LI
Alter the file exporter to make authenticated token revocation
RPCs when the exporter's token client passes in a usable
principal name.
.LI
Alter the token-obtaining clients of the file exporter to pass a
usable server principal name to the file exporter, so that token
revocation calls may be authenticated.  The principal name will
be for the server in the token-revocation protocol, which is the
client in the file-exporter protocol.
.LI
Alter the DFS Cache Manager's RPCs to the \*(lBflserver\*(lE and
the \*(lBrepserver\*(lE to be authenticated.
.LI
Alter the DFS Cache Manager's RPCs to the file exporter to have
their authentication controlled by the administrators for the
cache manager and for the file exporter.
.LE
.P
This last component of the proposed work may itself be broken
down into several sub-tasks, since administrators will wish for
a variety of fine controls on the behavior of their systems.
One central concept behind the administrative controls is that
we distinguish same-cell (intra-cell) communication from
inter-cell communication, so that a DFS Cache Manager will use
one set of guidelines for its intra-cell communication and
another set for its inter-cell communication.  The tasks that
implement the administrative controls include the following:
.P
.aL
.LI
Definition of an initial (preferred) selection of DCE RPC
authentication level and an authentication lower-bound level for
the intra-cell and inter-cell file exporter communications
carried out by the CM.
.LI
Addition of four new \*(lBdfsd\*(lE options by which these
levels may be set when a CM is initialized.
.LI
Addition of new \*(lBcm getprotectlevels\*(lE and \*(lBcm
setprotectlevels\*(lE subcommands to read and alter these levels
in the running CM when executed by the machine administrator, as
well as two new \*(lBpioctl()\*(lE sub-calls to obtain and set
these levels.
.LI
Addition of new distinguished DFS error codes that may be used
to communicate violations of authentication policy bounds from a
file exporter to a CM, along with CM modifications to react to
these error codes and track the exporter's limits.
.LI
Definition of DCE RPC authentication upper-bound and lower-bound
levels that a file exporter may use in its DCE RPC service, one
pair for intra-cell access and one pair for inter-cell access.
.LI
Addition of four new \*(lBfxd\*(lE options by which these levels
may be set when the file exporter is initialized.
.LI
Addition of advisory DCE RPC authentication upper-bound and
lower-bound levels that may be used when communicating with a
particular fileset, a new \*(lBfts setprotectlevels\*(lE
subcommand to set these levels in the FLDB entry for a fileset,
and consumption of four bytes of spares in both the
\*(lBvldbentry\*(lE passed across the RPC and in the \*(lBstruct
vlentry\*(lE saved in the Ubik database itself.
.LE
.P
.H 2 "Changes to Repserver Clients"
.P
The changes in this area are straightforward.  Both the
\*(lBfts\*(lE command and the \*(lBrepserver\*(lE itself are
altered to establish authentication on binding handles in use
for calls to \*(lBrepserver\*(lEs.  The \*(lBrepserver\*(lE
itself, when making these peer-to-peer calls, always has
available the authentication for the host's \*(lBdfs-server\*(lE
principal.  The \*(lBfts\*(lE command will use the
authentication of the calling user, if any, and will obey the
\*(lB-noauth\*(lE and \*(lB-localauth\*(lE command options as is
done for communication with the \*(lBftserver\*(lE as well.
.P
There is no backward-compatibility problem, in that the old
\*(lBrepserver\*(lE is able to accept authenticated calls, and
the new \*(lBrepserver\*(lE is not at the moment being changed
to require authentication in its incoming RPC calls.
.P
.H 2 "Authenticated Token Revocations"
.P
It is straightforward to authenticate token-revocation RPC calls
as the local machine identity (the host's \*(lBself\*(lE
identity).  The only difficulty is knowing the remote principal
to which the calls should be authenticated.  Fortunately, the
\*(lBAFS_SetContext()\*(lE RPC call already has room for the
principal name: the third parameter to the RPC is a pointer to
an \*(lBafsNetData\*(lE structure that has a
\*(lBprincipalName\*(lE field that was reserved for this
purpose.  Thus, the change here is to accept a value for the
principal name (for the token-revocation RPC server, thus for
the caller of the \*(lBAFS_SetContext()\*(lE RPC itself) and to
call \*(lBrpc_binding_set_auth_info()\*(lE to establish
authentication on the token-revocation binding.
.P
Old clients of the \*(lBAFS_SetContext()\*(lE RPC all clear the
entire \*(lBafsNetData\*(lE structure before using it, so the
file exporter may readily distinguish whether a principal name
has been filled in.  It may thus reliably determine whether it
should or should not attempt to authenticate the
token-revocation binding.
.P
.H 2 "Passing Principal Names to the File Exporter"
.P
Several processes in DFS need to obtain tokens in their ordinary
operation, and they must be altered to pass their principal name
to file exporters in order to allow those exporters to make
authenticated token-revocation calls.  These processes include
the DFS CM itself, the \*(lBrepserver\*(lE, the \*(lBfts\*(lE
command, and the \*(lBdfsexport\*(lE command.  These processes
will select a candidate principal name, will call
\*(lBrpc_server_register_auth_info()\*(lE with that information
to register the proper information with the runtime, and will
pass that principal name to the DFS file exporter for its use in
authenticating the outgoing token-revocation RPCs.
.P
The DFS CM can always use the principal name associated with the
machine identity (the host's \*(lBself\*(lE); the
\*(lBdfsd\*(lE program passes this principal name to the DFS CM
at initialization time as the fourth parameter to the
\*(lBCMOP_START_TKN\*(lE start-up system call.  The
\*(lBdfsexport\*(lE command, since it must run as local root,
may use the same identity.  The \*(lBrepserver\*(lE can use the
\*(lBdfs-server\*(lE principal.  The \*(lBfts\*(lE command
may or may not have access to a key table entry, so it may or
may not be able to make use of authenticated token-revocation
RPCs.  If \*(lBfts\*(lE is being run with its
\*(lB-localauth\*(lE option, it will use the
\*(lBdfs-server\*(lE principal.  Otherwise, if run as local
root, it will use the \*(lBself\*(lE machine principal.
Failing both of these, \*(lBfts\*(lE will not request any
authentication for its token revocations.
.P
There is no backward-compatibility problem with this new use of
the \*(lBafsNetData.principalName\*(lE field, since old-style
file exporters will completely ignore any value placed in this
field.
.P
.H 2 "Authenticating DFS CM Calls to the Flserver and the Repserver"
.P
RPCs from the DFS CM to these servers are currently being made
without authentication.  These calls may simply be made as the
machine's \*(lBself\*(lE identity, using the
\*(lBrpc_c_protect_level_pkt_integ\*(lE authentication level.
.P
Both the \*(lBflserver\*(lE and \*(lBrepserver\*(lE are able to
accept both authenticated and unauthenticated calls without
modification, so there is no problem with backward
compatibility.
.P
.H 2 "Authenticating DFS CM Calls to the File Exporter"
.P
In DCE 1.1 and earlier releases, RPCs from the DFS CM are made
with the authentication of the caller.  This allows for simple
access checks at the file exporter, since all the DCE PAC/EPAC
machinery identifies the calling application to the file
exporter for interpreting ACLs and other access information.
Thus, the distinction between unauthenticated and authenticated
RPCs, made to the file exporter, is important: the file exporter
will interpret the authentication state of the RPC as the
authentication state of the caller of the file system.  It would
be inappropriate for the DFS CM to start making RPCs from
unauthenticated clients as, say, RPCs authenticated with the
machine \*(lBself\*(lE principal, since the file exporter
would assign different privileges to such calls than it would to
truly unauthenticated calls.
.P
The variety of authorization services provided by DCE RPC offers
an excellent work-around.  The file exporter has always treated
as unauthenticated all incoming calls that are authorized with
anything other than the DCE PAC service
(\*(lBrpc_c_authz_dce\*(lE).  Thus, RPCs to the file exporter
for which the authorization service is the client principal name
(\*(lBrpc_c_authz_name\*(lE) will be interpreted as
unauthenticated.  The work-around is therefore that, when the
DFS CM might ordinarily wish to make an unauthenticated call to
a file exporter, it should instead use
\*(lBrpc_c_authz_name\*(lE authorization for that call with
authentication as the machine identity.  The range of DCE
authentication services is thus available for assuring data
integrity even for those calls that the DFS file exporter will
view as unauthenticated.
.P
Removing these unauthenticated calls is only a partial repair;
the performance/security tradeoff still requires attention.  DFS
in the DCE 1.1 and earlier releases uses
\*(lBrpc_c_protect_level_pkt\*(lE authentication, which does not
defend against the data-substitution attack cited in the article
by Eric Brewer et al. [Brew95].  However, simply increasing the
authentication level to \*(lBrpc_c_protect_level_pkt_integ\*(lE
would require all data transfers to incur an overhead of (very
roughly) one CPU second per megabyte of data for each of the
client and the server, and this is viewed as excessive in many
environments.  Thus, we define a collection of administrative
interfaces by which the authentication level may be selected by
the administrators of the client and the server ends of the
communication.  Generally, the server policy imposes hard upper
and lower bounds on the authentication levels at which it will
operate, and the client policy selects an initial desired value
for the authorization level as well as a lower bound for the
authorization level, below which it will refuse to operate.
Furthermore, these authorization policy values are duplicated: one
set of values is used for intra-cell communication (where
the client and the server are in the same DCE cell), and another
set of values is used for inter-cell communication.
.P
.H 3 "Initial and lower-bound authentication policy values for the CM"
.P
The DFS CM maintains both an initial value for DCE RPC
authentication level and a lower bound for that level.  The DFS
CM also maintains shadow copies of other bounds imposed by
policies on the file exporter, and it uses these bounds, as well
as its own lower bound, to guide its selection of authentication
level.
.P
The DFS CM maintains two independent pairs of authentication
values, so that at any given point, it will have an initial
level and a lower bound for use with intra-cell RPCs and a
separate initial level and lower bound for use with inter-cell
RPCs.
.P
Since the choice of DCE RPC authentication level is completely
driven by the client, and since these authentication features
have been in all prior releases of DCE, new clients will have no
trouble establishing new authentication levels with old servers.
.P
.H 3 "New dfsd options to initialize authentication bounds"
.P
The \*(lBdfsd\*(lE command accepts four new options by which the
DFS CM's authentication policy values may be initialized, as
follows:
.P
.aL
.LI
\*(lB-initiallocalprotectlevel \*(jBlevel\*(jE\*(lE specifies the
initial value for the intra-cell authentication level.
.LI
\*(lB-minlocalprotectlevel \*(jBlevel\*(jE\*(lE specifies the lower
bound for the intra-cell authentication level.
.LI
\*(lB-initialremoteprotectlevel \*(jBlevel\*(jE\*(lE specifies the
initial value for the inter-cell authentication level.
.LI
\*(lB-minremoteprotectlevel \*(jBlevel\*(jE\*(lE specifies the lower
bound for the inter-cell authentication level.
.LE
.P
The \*(lB\*(jBlevel\*(jE\*(lE value for this command may be
specified as any of: (1) the DCE identifiers
\*(lBrpc_c_protect_level_\*(jBXXX\*(jE\*(lE, or (2)
\*(lBrpc_c_authn_level_\*(jBXXX\*(jE\*(lE, as given in the
manual page for \*(lBrpc_binding_set_auth_info()\*(lE; (3) the
\*(lB\*(jBXXX\*(jE\*(lE suffixes themselves; or (4) the integers
to which they evaluate (0 through 6).
.P
The \*(lBdfsd\*(lE program passes these policy values to the DFS
CM as additional values in the \*(lBcm_cacheparams\*(lE
structure.  There is no backward-compatibility problem,
primarily because mutually-compatible versions of the
\*(lBdfsd\*(lE program and the DFS CM itself are presumed to be
installed together, and secondarily because the new values were
added to the end of the \*(lBcm_cacheparams\*(lE structure, so that at
least a new \*(lBdfsd\*(lE and an old CM will work together.
.P
.H 3 "New cm subcommands to read and alter authentication bounds"
.P
The \*(lBcm\*(lE command will provide two new subcommands,
\*(lBcm getprotectlevels\*(lE and \*(lBcm setprotectlevels\*(lE,
for examining and altering the authentication policy values in
the running DFS CM.  These policy values may be examined by
anyone on the machine, but altering the values is restricted to
processes running as the machine root.
.P
The new \*(lBcm getprotectlevels\*(lE subcommand accepts no
options (other than \*(lB-help\*(lE).  The new \*(lBcm
setprotectlevels\*(lE subcommand accepts the same set of four
options that were added to the \*(lBdfsd\*(lE command, above:
.P
.dS
.ne 3
% cm help getprotectlevels
cm getprotectlevels: get protection levels
Usage: cm getprotectlevels [-help]

.ne 7
% cm help setprotectlevels
cm setprotectlevels: set protection levels
Usage: cm setprotectlevels \e
       [-initiallocalprotectlevel <level>] \e
       [-minlocalprotectlevel <level>] \e
       [-initialremoteprotectlevel <level>] \e
       [-minremoteprotectlevel <level>] [-help]
.dF
.P
By default (in the reference port), the CM's protection policy
values are initialized as follows:
.P
.dS
.ne 3
% cm getprotectlevels
Initial protection level in the local cell: \e
        rpc_c_protect_level_pkt_integ
.ne 2
Minimum protection level in the local cell: \e
        rpc_c_protect_level_none
.ne 2
Initial protection level in non-local cells: \e
        rpc_c_protect_level_pkt_integ
.ne 2
Minimum protection level in non-local cells: \e
        rpc_c_protect_level_pkt
.dF
.P
Other default protection policy values may be chosen by a vendor
without loss of interoperability.  For example, in DCE 1.1 and
prior releases, DFS operated approximately as if the initial
protection level for all cells were
\*(lBrpc_c_protect_level_pkt\*(lE and the minimum protection
level for all cells were \*(lBrpc_c_protect_level_none\*(lE.
Vendors and administrators must consider the tradeoff between
security and performance in altering these default protection
policy values.
.P
To support these new subcommands, two new \*(lBpioctl()\*(lE
sub-calls will be added: \*(lBVIOC_GETPROTBNDS\*(lE, to read the
policy values, and \*(lBVIOC_SETPROTBNDS\*(lE, to change them.
.P
.H 3 "New DFS error codes for authentication level feedback to the CM"
.P
Six new error codes are defined to indicate to the DFS CM that
the CM's chosen authentication level exceeds a policy bound
value.  The error code values are defined in pairs, one to
indicate that the chosen level is too high (exceeds the policy's
upper bound) and the other to indicate that the chosen level is
too low (exceeds the policy's lower bound).  Three pairs are
allocated to allow independent policies to be described: an
exporter-wide policy, a per-fileset policy, and any other
policy:
.P
.aL
.LI
\*(lBFSHS_ERR_AUTHNLEVEL_S_TOO_HIGH\*(lE indicates that the
authentication level is too high for this file exporter.
.LI
\*(lBFSHS_ERR_AUTHNLEVEL_S_TOO_LOW\*(lE indicates that the
authentication level is too low for this file exporter.
.LI
\*(lBFSHS_ERR_AUTHNLEVEL_F_TOO_HIGH\*(lE indicates that the
authentication level is too high for this fileset.
.LI
\*(lBFSHS_ERR_AUTHNLEVEL_F_TOO_LOW\*(lE indicates that the
authentication level is too low for this fileset.
.LI
\*(lBFSHS_ERR_AUTHNLEVEL_G_TOO_HIGH\*(lE indicates that the
authentication level is too high for some other constraint.
.LI
\*(lBFSHS_ERR_AUTHNLEVEL_G_TOO_LOW\*(lE indicates that the
authentication level is too low for some other constraint.
.LE
.P
The client is expected to react to these error codes either by
adjusting its authentication level and retrying, or by giving up
if its own limits are exceeded.  The proposed DFS CM, however,
will not be able to react gracefully to all of these error
codes.  It maintains \*(iBshadow copies\*(iE of the policy
bounds within which it must operate, on both a per-exporter
basis and a per-fileset basis.  These bounds are initialized to
the widest possible range ([\*(lBrpc_c_protect_level_none\*(lE
\&... \*(lBrpc_c_protect_level_pkt_privacy\*(lE]).  When the CM
receives one of these error codes, it knows that one of its
shadow bounds is too generous, so it narrows the appropriate
bound by one level and selects a new authentication level at
which the RPC may be retried.  The CM will react to the
exporter-wide and per-fileset error codes in this way, since it
knows the object to which the policy applies.  However, for the
third pair of error codes, it has no understanding of what
internal limit should be adjusted, so if the DFS CM receives one
of these two error codes, it will fail the RPC call.
.P
This protocol for maintaining shadow copies of the
authentication policy bounds is efficient in practice, even if
each RPC adjusts a shadow bound by only one level, since there
are so few separate levels defined and the shadow bounds are
cached.
.P
In the proposed work, only the exporter-wide calls are actually
generated; the others are reserved for the future.
.P
These codes are, in a sense, backward-compatible with existing
DFS deployments, but those existing DFS deployments will not be
able to handle them gracefully.  That is, if a DFS CM from DCE
1.1 or earlier releases receives one of these error codes, it
will not know how to respond, so it will fail the RPC call.
This is appropriate behavior, in that the new DFS file exporter
will have returned one of these error codes to reflect a policy
that the CM's authentication choice must not be honored; since
an old-style DFS CM will be unable to alter its authentication
choice to meet the policy requirement, it must continue to fail.
However, this less-than-graceful handling of the compatibility
issue suggests that it is a serious matter for the file
exporter's administrator to impose policies about authentication
levels on the file exporter, since DCE 1.1-style DFS CMs will be
unable to respond well.
.P
.H 3 "Authentication bounds for DFS file exporters"
.P
For any of several reasons, the administrator for a file
exporter might wish to bound the authentication support that the
exporter may offer.  For example, the administrator may wish to
impose a lower bound in order to ensure that its data remains
secure in transport, or an upper bound to limit the security
overhead incurred by the exporter machine itself.  This proposal
includes the specification of such policy bounds for DFS file
exporters, again duplicated as one bounds pair for intra-cell
use and another bounds pair for inter-cell use.  When a file
exporter detects that an RPC that it is servicing is not within
the applicable bounds, it responds to the RPC with the
appropriate distinguished error code, either
\*(lBFSHS_ERR_AUTHN_LEVEL_S_TOO_HIGH\*(lE or
\*(lBFSHS_ERR_AUTHN_LEVEL_S_TOO_LOW\*(lE, as defined above.
.P
.H 3 "New fxd options to initialize authentication bounds"
.P
The mechanism by which the administrator indicates policy bounds
to the file exporter is a set of four new options to the
\*(lBfxd\*(lE command, the command that initializes the file
exporter:
.P
.aL
.LI
\*(lB-minlocalprotectlevel \*(jBlevel\*(jE\*(lE sets the lower bound for
the intra-cell authentication level for this file exporter.
.LI
\*(lB-maxlocalprotectlevel \*(jBlevel\*(jE\*(lE sets the upper bound for
the intra-cell authentication level for this file exporter.
.LI
\*(lB-minremoteprotectlevel \*(jBlevel\*(jE\*(lE sets the lower bound
for the inter-cell authentication level for this file exporter.
.LI
\*(lB-maxremoteprotectlevel \*(jBlevel\*(jE\*(lE sets the upper
bound for the inter-cell authentication level for this file
exporter.
.LE
.P
The values for \*(lB\*(jBlevel\*(jE\*(lE may be specified as in
the \*(lBdfsd\*(lE command or the new \*(lBcm\*(lE subcommands,
as described earlier.  The values are passed to the file
exporter via a pointer passed as the fourth argument to the
\*(lBPXOP_INITHOST\*(lE system call.
.P
Compatible versions of the \*(lBfxd\*(lE program and the file
exporter are expected to be installed together, so there should
be no issue of backward compatibility.
.P
.H 3 "New per-fileset advisory authentication bounds"
.P
This proposal includes the specification of per-fileset advisory
authentication policy bounds, stored in the FLDB along with the
data of the fileset, but not checked by the file exporter
itself.  These bounds are to be used by clients of the file
exporter when selecting authentication levels for RPCs that
operate on particular filesets, and they may in the future be
validated by the file exporter itself.  Within this work,
though, they may be used by administrators wishing to push
cooperating DFS CMs into using a particularly high or
particularly low authentication value for accesses to a given
fileset.  These bounds are duplicated to permit distinguishing
intra-cell accesses from inter-cell accesses.
.P
While these bounds are at the moment purely advisory, they may
in the future be enforced by the file exporter.  The
administrator is therefore cautioned against imposing
excessively restrictive bounds.
.P
These advisory bounds are specified by a new subcommand for the
\*(lBfts\*(lE program: \*(lBfts setprotectlevels\*(lE.  This
subcommand identifies a fileset and alters any or all of its
advisory authentication bounds.  The advisory authentication
bounds may be examined by any of the existing \*(lBfts\*(lE
subcommands that print FLDB entries, such as \*(lBfts
lsfldb\*(lE, \*(lBfts lsft\*(lE, and the like:
.P
.dS
.ne 10
% fts help setprotectlevels
fts setprotectlevels: set range of permissible protection \e
                      levels
Usage: fts setprotectlevels -fileset {<name> | <ID>} \e
       [-minlocalprotectlevel <level>] \e
       [-maxlocalprotectlevel <level>] \e
       [-minremoteprotectlevel <level>] \e
       [-maxremoteprotectlevel <level>] \e
       [-cell <cellname>] [{-noauth | -localauth}] \e
       [-verbose] [-help]
.dF
.P
Execution of this subcommand will require permission to alter
the FLDB entry for the given fileset, implying either membership
in the cell-wide \*(lBadmin.fl\*(lE list or membership in the
group that owns the FLDB server entry for all servers on which
copies of the fileset reside.  If this command is later enhanced
to allow the file exporter to enforce these limits, it will also
require membership in the \*(lBadmin.ft\*(lE list for the file
exporter on which one or more copies of the fileset reside.
.P
These advisory bounds are communicated to the \*(lBflserver\*(lE
by storing them in the first four bytes of the
\*(lBcharSpares\*(lE array in both the \*(lBvldbentry\*(lE and
\*(lBcompactvldbentry\*(lE structures.  The \*(lBflserver\*(lE
stores them in the FLDB itself by storing them in the first four
bytes of the \*(lBspares3\*(lE array in the \*(lBvlentry\*(lE
structure that is stored in the Ubik database itself.
.P
The proposed DFS CM will maintain copies of these bounds in its
in-memory structure and will use these bounds to adjust its
initial choice for authentication levels on a per-fileset basis.
However, the DFS CM will maintain independent per-fileset shadow
copies of any fileset-based authentication bounds, so that it
may react correctly to any future file exporters that enforce
per-fileset authentication policies.
.P
The current per-fileset authentication bounds are only advisory.
It would be preferable for the file exporter to be able to
enforce them.  Carrying this out would involve a good bit of
additional work in modifying the \*(lBfts setprotectlevels\*(lE
subcommand to set new status fields in one or more copies of the
indicated fileset, defining extensions to the fileset dump
format to represent these new bounds, enhancing the fileset dump
and restoration operations to capture and reinstate these
bounds, and causing the file exporter to verify the policy
bounds.  This may be done in the future based on the existing
values in the FLDB, so administrators should beware of setting
unduly restrictive per-fileset authentication bounds in the
knowledge that they are at present not enforced by the file
exporter.
.P
Since these per-fileset authentication bounds are represented
using fields that are at present spares initialized to zero,
there are few issues of backward compatibility.  One interesting
issue is that existing versions of the \*(lBflserver\*(lE will
not know about them.  If the \*(lBfts setprotectlevels\*(lE
subcommand is issued in a cell where none of the
\*(lBflserver\*(lE processes has been extended as in this
proposal, the command will appear to have succeeded but will
have had no effect.  If a cell has mixed versions of its
\*(lBflserver\*(lE processes, the subcommand will have an effect
only if the RPC to change the fileset's FLDB entry was directed
at an updated \*(lBflserver\*(lE processes.  Furthermore, even
if the FLDB had been updated via an updated \*(lBflserver\*(lE
process, if the FLDB information for a fileset is obtained by a
call to a non-updated \*(lBflserver\*(lE process, the
authentication bounds will not be present.  This last issue
affects not only the user-space \*(lBfts\*(lE and other
commands, but also the DFS CM itself, which learns of these
authentication bounds from calls made to an \*(lBflserver\*(lE
process.
.P
.H 1 "CONTINUING ISSUES AND PROBLEMS"
.P
.aL
.LI
There is no way to determine whether an
\*(lBrpc_c_authz_name\*(lE RPC caller is from the local cell or
another cell.  The proposed work-around is for the file exporter
to treat all clients as from a non-local cell until a
\*(lBrpc_c_authz_dce\*(lE request arrives that may then have the
identity of its cell checked.
.LI
This work assumes that there is a trust relationship between the
cell of the DFS Cache Manager and the cell of the file exporter,
since it expects to be able to fall back to authentication as
the \*(lBself\*(lE identity.  As of the current releases of
DCE, the \*(lBdfsbind\*(lE helper process cannot make successful
contact with untrusted cells, which therefore implies that the
DFS CM itself cannot contact such cells.  Since even the local
machine identity cannot be used to establish any authentication
with such cells, the DFS CM would need to allow completely
unauthenticated non-local access in order to successfully
communicate with the servers in such cells.
.LI
Bill Sommerfeld (HP) has suggested that the DFS CM limit its
behaviors on data that had been fetched over less-secure
channels.  In particular, he proposed that files fetched without
authentication should never be used as device special files, as
set-uid/set-gid executables, or in fact as executables at all.
While such a feature is desirable, our sense is that it would
require further design and elaboration to work smoothly,
including an enhanced cache model in the DFS CM in which every
cached datum would be tagged with the authentication level that
had been used in fetching it, and in which a cached datum could
potentially be re-fetched with a higher authentication level
before using it.  In addition, there would have to be
administrative controls on this behavior, and DFS already
provides some of these controls in the \*(lBcm setsetuid\*(lE
and \*(lBcm setdevok\*(lE functions.
.LI
Token-obtaining clients other than the DFS CM (the
\*(lBrepserver\*(lE process and the \*(lBfts\*(lE and
\*(lBdfsexport\*(lE commands) use authenticated
\*(lBrpc_c_protect_level_pkt_integ\*(lE whenever any DCE
authentication is available to them.  However, they do not know
how to react to the new error codes that indicate a violation of
authentication policy bounds, nor do they know how to choose
other authentication levels.  Thus, if an administrator imposes
a policy such that the \*(lBrpc_c_protect_level_pkt_integ\*(lE
authentication level is not allowed, they may be causing these
other programs to fail.
.LI
It would be possible for the DFS CM to react to the third pair
of new policy-violation error codes by retaining a third set of
shadow policy bounds in a transient structure used only for the
duration of a given RPC retry sequence.  This has not been done,
chiefly on efficiency grounds, since the adjustment of
authentication levels and retrying would have to be carried out
on each RPC.
.LI
While causing the per-fileset advisory authentication bounds to
be enforced by the file exporter itself is a sizable amount of
work, it is also desirable.
.LI
Future work should include providing the means for
administrators to control what minimum authentication levels are
required for various DFS services that are now honored
regardless of authentication state, e.g., the RPC service
provided by the \*(lBrepserver\*(lE process and some of the
service provided by the \*(lBflserver\*(lE process.  In
addition, it should be an option to use and possibly require
\*(lBrpc_c_protect_level_pkt_privacy\*(lE for some of these DFS
services.
.LE
.P
.H 1 "ACKNOWLEDGEMENTS"
.P
Thanks are due Dan Nydick (Transarc), Ted Anderson (Transarc),
Bill Sommerfeld (HP) and Mike Burati (HP) for their involvement
in resolving the initial design problems, in particular
discovering a reasonable method of allowing authenticated RPCs
to be made to a DFS file exporter without forcing the exporter
to use that authentication in deciding file access questions.
Rajesh Agarwalla (Transarc), Rich Salz (OSF), and Carl Burnett
(IBM) helped further broaden and refine the scope of the problem
and its solutions.  The author particularly thanks Carl Burnett
for contributing a draft of part of the code for the DFS Cache
Manager.  Dan Nydick earned still greater thanks both by
carrying out extensive testing and by providing valuable
suggestions for this document.
.P
...\" =========================================================================
...\" References go here, as an unnumbered heading.
...\" =========================================================================
.P
.HU "REFERENCES"
.P
.VL 12 0
.LI "[Brew95]"
\*(qBBasic Flaws in Internet Security and Commerce\*(qE, Eric
Brewer, Paul Gauthier, Ian Goldberg, and David Wagner, in
\*(iBhttp://http.cs.berkeley.edu/~gauthier/endpoint-security.html\*(iE,
10 October 1995.  Also posted to cypherpunks@toad.com mailing
list, 10 October 1995.
.LE
.P
...\" =========================================================================
...\" Author's address goes here, as unnumbered heading, at end of doc.
...\" =========================================================================
.P
.ne 3+6
.HU "AUTHOR'S ADDRESS"
.P
.tl $Craig Everhart$$Internet email: Craig_Everhart@transarc.com$
.tl $Transarc Corporation$$Telephone: +1-412-338-4400$
.tl $The Gulf Tower$$$
.tl $707 Grant Street$$$
.tl $Pittsburgh, PA  15219-1909$$$
.tl $USA$$$
...\" =========================================================================
...\" Done!
...\" =========================================================================
