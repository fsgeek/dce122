...\" OSF-RFC 68.3
...\"
...\" FORMATTING INSTRUCTIONS for this RFC (these may vary per RFC):
...\" 1. Set view to config spec that will pick up most recent
...\"    DCE_1.2.2 branch versions
...\" 2. cd /afs/ch/www/projects/osf.dce1.2.2/doc; pk_login_fs.mkdiffs
...\" 3. cd /afs/ch/www/projects/osf.dce1.2.2/doc; rm pk_login_fs.txt;nroff -Tlp pk_login_fs.roff >pk_login_fs.txt
...\" 4. telnet margalo
...\"    login <you>
...\"    ksh
...\"    export PATH=/usr/lbin:$PATH LPDEST=ps
...\"    /usr/afs/bin/klog aha
...\"    cd /afs/ch/www/projects/osf.dce1.2.2/doc; rm pk_login_fs.ps; eroff -p pk_login_fs.roff > pk_login_fs.ps
...\"    exit
...\"    exit
...\" =========================================================================
...\" DCE 1.2.2 Public Key Login - Functional Specification
...\" rcs information $Revision: 1.2 $ $Date: 96/12/23 10:02:44 $
...\" Before printing your specification, be sure to check all items in <..>
...\" and all lines preceded by ...\"PUBLISH_CHECK
...\" - To get line numbers in your spec, uncomment the ".nm 1" line just before
...\"   the INTRODUCTION.
...\" - To get change marks in your spec, assume your spec is "fs.roff",
...\"   and you want the change marks relative to revision "1.5":
...\"   a. Comment out the ".de mc" line below
...\"   b. Check out version you want as the base:
...\"      % /usr/bin/co -p -r1.5 fs.roff >fs.roff.1.1
...\"   c. Create a change-marked roff source using "diffmk":
...\"      % /usr/bin/diffmk fs.roff.1.5 fs.roff fs.roff.mk
...\"   d. Run fs.roff.mk through nroff and print as usual
...\" - To format the roff source (diffmk'd or plain) into formatted ASCII
...\"   text using nroff:
...\"      % /usr/bin/nroff -Tlp fs.roff.mk > fs.txt
...\" - To print the formatted ASCII text double-sided:
...\"      % /usr/bin/lp -od -dljdcepcl fs.txt
...\" - To create a "shar" file suitable for emailing to remote reviewers:
...\"      % /usr/bin/shar -ZcCsv fs.txt > fs.txt.shar
...\" =========================================================================
...\" This template first sets a bunch of *roff options (authors/readers
...\" don't usually have to know about these).
...\" Then it defines some strings and macros, many of which deal with
...\" things that differ between nroff & troff (some of these may not be
...\" perfect, but they're better than nothing -- to do a really good
...\" job would require a real semantic markup language.
...\" Convention: "Begin/End" for strings, "Start/Finish" for macros.
...\" Strings:
...\"       \*(f!        - Footnote string (replaces \*F).
...\"       \*(hB, \*(hE - Page header/footer font (internal use).
...\"       \*(kB, \*(kE - Doc header font (internal use).
...\"       \*(qB, \*(qE - Quotations.
...\"       \*(iB, \*(iE - Italics/emphasis in primary font.
...\"       \*(bB, \*(bE - Bold font.
...\"       \*(lB, \*(lE - Literal font.
...\"       \*(jB, \*(jE - Italics/emphasis in literal font.
...\"       \*(nH        - Default note header string.
...\" Macros:
...\"       .aH      - Appendix header macro (uses number register \na).
...\"       .aL      - Automatic list macro (replaces .AL; uses num reg \ng).
...\"       .tS, .tF - Title start/finish (internal use).
...\"       .cS, .cF - Displays (no-fill) without indentation.
...\"       .dS, .dF - Displays (no-fill) with indentation.
...\"       .iS, .iF - Indented (fill) text.
...\"       .nS, .nF - Note.
...\" -------------------------------------------------------------------------
...\" First, set up some number registers here (instead of on command line),
...\" and include the "mm" macro package here (instead of on command line).
...\" -------------------------------------------------------------------------
.if n .nr L 66 \" Nroff page length = 66 lines.
.if t .nr L 11i \" Troff page length = 11 inches.
.if n .nr W 72 \" Nroff page width = 72 columns.
.if t .nr W 6.5i \" Troff page width = 6.5 inches.
.if n .nr O 3 \" Nroff page offset = 3 columns.
.if t .nr O 0.75i \" Troff page offset = 0.75 inches.
.nr N 2 \" No header on page 1.
.so /usr/lib/tmac/tmac.m \" Points to "mm" package, in /usr/lib/macros.
...\" -------------------------------------------------------------------------
...\" Next, twiddle the "mm" package to suit our preferred style.
...\" -------------------------------------------------------------------------
...\" Point size and font types.
...\" -------------------------------------------------------------------------
.if n .fp 1 R \" "Regular" font ONLY -- don't use any others in nroff.
.if t \{ .S 10 12 \" Point size = 10, vertical spacing = 12.
...\" Note: Some systems give different names to these fonts.
.fp 1 R \" Times roman.
.fp 2 I \" Times italic.
.fp 3 B \" Times bold.
.fp 4 BI \" Times bold italic.
.fp 5 CW \" Courier.
.fp 6 CI \" Courier oblique.
.fp 7 CB \" Courier bold.
.fp 8 CX \" Courier bold oblique.
.fp 9 H \" Helvetica.
.fp 10 HI \" Helvetica oblique.
.fp 11 HB \" Helvetica bold.
.fp 12 HX \" Helvetica bold oblique.
.fp 13 S \} \" Special symbol font -- normally only called automatically.
...\" -------------------------------------------------------------------------
...\" Headings; page header and footers; titles.
...\" -------------------------------------------------------------------------
.nr Ej 0 \" No eject for first-level headings.
.nr Hs 7 \" Heading space level = blank line after heading (all levels).
.nr Hb 7 \" Heading break level = break after heading (all levels).
.nr Hi 1 \" Post-heading indent = paragraph indent.
.nr Hc 0 \" Heading centering = none.
.if n .ds HF 1 1 1 1 1 1 1 \" Heading fonts = regular (no underlining).
.if t .ds HF 11 11 11 11 11 11 11 \" Heading fonts = Helvetica bold.
.if t .ds HP 0 0 0 0 0 0 0 \" Heading point sizes (= default).
.HM 1 1 1 1 1 1 1 \" Heading mark = arabic (all levels).
.nr Hu 1 \" Unnumbered heading level = 1 (see aH macro, below).
.de HX \" Beginning-of-heading processing.
.in 0 \" Left justify headings.
.ie     \\$2=0 .ds }0\" Null string heading mark for HU.
.el .ie \\$1=1 .ds }0 \\n(H1.\ \&\" Heading marks = dotted sections + 1 space.
.el .ie \\$1=2 .ds }0 \\n(H1.\\n(H2.\ \&
.el .ie \\$1=3 .ds }0 \\n(H1.\\n(H2.\\n(H3.\ \&
.el .ie \\$1=4 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\ \&
.el .ie \\$1=5 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\ \&
.el .ie \\$1=6 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\\n(H6.\ \&
.el .if \\$1=7 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\\n(H6.\\n(H7.\ \&
..
.de HZ \" End-of-heading processing.
.if n .in 3 \" Indent body of doc by 3 columns in nroff.
.if t .in 0 \" Don't indent in troff.
..
.if n .ds hB \&\" Page header/footer font begin in nroff.
.if t .ds hB \f9\" Page header/footer font begin in troff.
.if n .ds hE \&\" Page header/footer font end in nroff.
.if t .ds hE \fP\" Page header/footer font end in troff.
.if n .ds kB \&\" Doc header font begin in nroff.
.if t .ds kB \f(11\" Doc header font begin in troff.
.if n .ds kE \&\" Doc header font end in nroff.
.if t .ds kE \f1\" Doc header font end in troff.
.de tS \" Title start.
.SP 2 \" 2 blank lines.
.ce 99 \" Center (each line of) title.
.if t \{ .ft 11 \" Bold helvetica.
.S +2 D \} \" Bigger point size.
..
.de tF \" Title finish.
.ce \" Turn off centering.
.SP 1 \" 1 blank line.
.if t \{ .ft 1 \" Return to regular font.
.S P P \} \" Return to regular point size.
..
...\" -------------------------------------------------------------------------
...\" Special Appendix heading macro, .aH.
...\" -------------------------------------------------------------------------
.nr a 0 1 \" Appendix number.
.af a A \" Assign format upper-case alpabetic to number register a.
.de aH \" Appendix heading macro.
.if \\na=0 \{ .nr H1 0 \" Reset H1 to 0.
.HM A 1 1 1 1 1 1 \} \" Heading mark = Upper case alphabetic + arabics.
.HU "APPENDIX \\n+a. \\$1"
..
...\" -------------------------------------------------------------------------
...\" Paragraph stuff.
...\" -------------------------------------------------------------------------
.nr Pt 0 \" Paragraph type = left-justified.
.nr Pi 0 \" Paragraph indent = 0.
.nr Ps 1 \" Paragraph spacing = 1 blank space.
...\" -------------------------------------------------------------------------
...\" Special list macro, .aL (replaces .AL, for all levels).
...\" This should be used for almost all lists (including ".LI "\ "").
...\" The only exception is variable lists (.VL, indented by multiples of 6).
...\" -------------------------------------------------------------------------
.de aL
.nr g \\n(:g
...\" In-line lists should be numbered (by hand): (1), (2), (3), ...
.ie     \\ng=0 .LB 6 0 1 3 a \" 1st level: (a), (b), (c), ...
.el .ie \\ng=1 .LB 6 0 1 3 i \" 2nd level: (i), (ii), (iii), ...
.el .ie \\ng=2 .LB 6 0 1 4 a \" 3rd level: [a], [b], [c], ...
.el .ie \\ng=3 .LB 6 0 1 4 i \" 4th level: [i], [ii], [iii], ...
.el .ie \\ng=4 .LB 6 0 1 6 a \" 5th level: {a}, {b}, {c}, ...
.el .if \\ng=5 .LB 6 0 1 6 i \" 6th level: {i}, {ii}, {iii}, ...
..
.nr Ls 6 \" Blank lines between all list items, by default (but adjustable).
...\" -------------------------------------------------------------------------
...\" Footnote stuff; special footnote string, \*(f!.
...\" -------------------------------------------------------------------------
.if n .ds f! [\\n+(:p]\" Footnote string (replaces \*F in nroff).
.if t .ds f! \\*F\" Footnote string (same as \*F in troff).
.if n .FD 6 \" Footnotes not hyphenated or indented, label left justified.
.if t .FD 5 \" Footnotes hyphenated, not indented, label left justified.
.nr Fs 1 \" 1 blank line between footnotes.
...\" -------------------------------------------------------------------------
...\" Line adjustment stuff.
...\" -------------------------------------------------------------------------
.if n .nr Hy 0 \" No hyphenation in nroff.
.if t .nr Hy 1 \" Hyphenate in troff.
.if n .SA 0 \" Set adjust: left margin only in nroff.
.if t .SA 1 \" Set adjust: left and right margins in troff.
...\" -------------------------------------------------------------------------
...\" Miscellaneous stuff.
...\" -------------------------------------------------------------------------
.ta \" No tabs by default -- set them up by hand as needed.
.nr Si \n(Ls \" Default indent for .DS display macro = 6 (use in troff only).
...\" -------------------------------------------------------------------------
...\" Displays.
...\" -------------------------------------------------------------------------
.de cS \" Display start: no-fill, literal font, no indentation.
.P
.nf \" No fill mode.
.if t .ft 5 \" Constant width font in troff.
..
...\" Within .cS, ".ne N"'s can be added by hand, but should be minimized.
.de cF \" Display finish.
.if t .ft 1 \" Back to standard font in troff.
.fi \" Fill mode.
.P
..
.de dS \" Display start: no-fill, literal font, with indentation.
.P
.aL \" Use .aL macro for consistent indentation.
.nf \" No fill mode.
.LI "\ " \" List item will no (visible) marker.
.if t .ft 5 \" Constant width font in troff.
..
...\" Within .dS, ".ne N"'s can be added by hand, but should be minimized.
.de dF \" Display finish.
.if t .ft 1 \" Back to standard font in troff.
.fi \" Fill mode.
.LE
.P
..
.de iS \" Indent start: fill, regular font, with indentation.
.P
.aL
.LI "\ "
..
.de iF \" Indent finish.
.LE
.P
..
.ds nH NOTE\"Default note header string -- can be changed by author.
.de nS \" Note start: fill, italics font, with indentation.
.P
.aL \" Use .aL macro for consistent indentation.
.LI "\ " \" List item will no (visible) marker.
.if t .ft 2 \" Italics font in troff, and reverse roman <--> italic fonts:
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f1\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.ie \\n(.$=0 \\*(nH:\" Default header string if none supplied by author.
.el \\$1:\" Header string supplied by author as argument to .nS macro.
..
.de nF \" Note finish.
.if t .ft 1 \" Back to standard font in troff, and remap font macros:
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f2\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.LE
.P
..
...\" -------------------------------------------------------------------------
...\" Quotation marks and font toggles.
...\" -------------------------------------------------------------------------
.if n .ds qB \&"\" Quotation begin in nroff.
.if t .ds qB ``\" Quotation begin in troff.
.if n .ds qE \&"\" Quotation end in nroff.
.if t .ds qE ''\" Quotation end in troff.
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f2\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.if n .ds bB *\" Bold font begin in nroff.
.if t .ds bB \f3\" Bold font begin in troff.
.if n .ds bE *\" Bold font end in nroff.
.if t .ds bE \fP\" Bold font end in troff.
.if n .ds lB `\" Literal font begin in nroff.
.if t .ds lB \f5\" Literal font begin in troff.
.if n .ds lE '\" Literal font end in nroff.
.if t .ds lE \fP\" Literal font end in troff.
.if n .ds jB <\" Italics/emphasis literal font begin in nroff.
.if t .ds jB \fP\f6\" Italics/emphasis literal font begin in troff.
.if n .ds jE >\" Italics/emphasis literal font end in nroff.
.if t .ds jE \fP\f5\" Italics/emphasis literal font end in troff.
..
...\" -------------------------------------------------------------------------
...\" No diffmarks by default, i.e., define .mc to be null.
...\" (Comment out this null definition to turn diffmarking on.)
...\" -------------------------------------------------------------------------
...\"PUBLISH_CHECK
...\".de mc
...\" $Revision: 1.2 $ $Date: 96/12/23 10:02:44 $ $Author: aha $
...\" =========================================================================
...\" Finally, it's time to start writing the document!
...\" The OSF-RFC author modifies the following header/footer info.
...\" (The major/minor number is assigned by the OSF-RFC Editor.)
...\" =========================================================================
...\"PUBLISH_CHECK
.ND "January 1997" \" Date must be hard-coded.
...\"PUBLISH_CHECK
.PH "$\*(hBOSF-RFC 68.3$DCE 1.2.2 Public Key Login$\\\\*(DT\*(hE$"
...\"PUBLISH_CHECK
.PF "$\*(hBAnderson, Cuti$$Page \\\\n%\*(hE$" \" Final version.
...\"PUBLISH_CHECK
...\".PF "$\*(hBAnderson, Cuti$DRAFT R\$Revision: 1.2 $Page \\\\n%\*(hE$" \" Draft version.
...\"
...\" Following are the first printed lines (header info) of the document:
...\"
\&\" Force top-of-first-page trap to position the following info correctly.
...\"PUBLISH_CHECK
.tl $\*(kBOpen Software Foundation$$A. Anderson (HP)\*(kE$
...\"PUBLISH_CHECK
.tl $\*(kBRequest For Comments: 68.3$$S. Cuti (HP)\*(kE$
.tl $\*(kB\*(DT$$\*(kE$
...\"PUBLISH_CHECK
.tS \" Title, in all capitals (can span multiple lines):
DCE 1.2.2 PUBLIC KEY LOGIN \*(EM
FUNCTIONAL SPECIFICATION
.tF
...\" =========================================================================
...\" Now, the actual body of the document!!
...\" Heading capitalization style:
...\"     1st level: CAPITALIZE ALL WORDS
...\"     2nd level: Capitalize Initial Letters of All (Significant) Words
...\"     3rd-7th level: Capitalize first letter of first word only
...\" =========================================================================
...\" -------------------------------------------------------------------------
...\" No line-numbers by default
...\" (Uncomment the .nm 1 line to turn line-numbering on.)
...\" -------------------------------------------------------------------------
...\"PUBLISH_CHECK
...\".nm 1 \" Do not line number the final draft
.P
.H 1 "INTRODUCTION" \" Always start with an introduction section.
...\"The first paragraph of the Introduction should be in the form of an
...\"*(iBabstract\*(iE, i.e., a brief description of the component or
...\"subsystem being specified.\*(f!
...\".FS
...\"Note that the formatting conventions of OSF RFC's are in effect,
...\"especially the use of \*(iBmacros\*(iE that simultaneously support ASCII
...\"and PostScript.  See [RFC 0.1] for details on those.  For an actual
...\"example of an RFC having the outline shown here, see [RFC 41.2].  (However,
...\"that RFC used an earlier version of the RFC macros \*(EM again, see
...\"[RFC 0.1] for details.)
...\".FE
.P
This document specifies the functionality required to integrate
public key mechanisms into DCE login, that is, into the initial DCE
Kerberos Ticket-Granting Ticket protocol.  This specification
obsoletes [RFC 68.2].
.P
The goal of this effort is to allow users to use a private key rather
than a shared-secret password to prove their identity to the DCE Key
Distribution Center (KDC) (a.k.a. Key Distribution Server, KDS).
.P
The immediate benefit is that, in the event of a compromise of the
KDC, public key users do not have any identifying information
exposed to the intruder.  If the KDC is compromised, all user secret
keys will be revealed to the intruder.  This means they become
worthless as a proof of identity, and therefore the cell administrator
must re-issue passwords to all such users before they can be allowed
to log-in to the cell.  Under the design described in this RFC, public
key users prove their identity by knowledge of a private key that is
never known to the KDC, and therefore a compromise of the KDC cannot
reveal these keys.
.P
The authentication information and protocol are based on the PK-INIT
Kerberos protocol [DRAFT-PKINIT] where the user's private key is stored
locally.
.P
A DCE Personal Security Module Interface is provided to abstract and hide
underlying details of public key algorithm implementations,
interfaces, and information storage mechanisms.
.P
A DCE Public Key Module API is provided to abstract and hide the
underlying details of
KDC and client public key acquisition for use in the Public Key Login
protocol.
.P
A DCE Private Key Module Interface is provided to abstract and hide the
underlying details of the private key storage mechanism.
.P
There are no changes to existing login APIs (\*(lBsec_login\*(lE)
other than for the addition of some new error status values, and no
need for changes to existing login utilities or user interfaces.
.P
...\"PUBLISH_CHECK
.H 2 "Changes Since Last Publication"
...\"If this is a revision of a previous version, give a list of changes.
.P
Changes since [RFC 68.2]:
.P
.aL
.LI
The public key login protocol was previously based on [ITU X.509] as
described in [RFC 85.0].  The protocol is now one of the protocols
specified in [DRAFT-PKINIT].
.LI
Support for public key generation has been added.
.LI
\*(lBdcecp\*(lE support for creating or modifying accounts to use
the public key login protocol has been added.
.LI
Two new interfaces, \*(lBsec_pubkey\*(lE and \*(lBsec_pvtkey\*(lE,
have been specified.
.LI
The \*(lBDCEPKModulusLength\*(lE ERA has been removed.  The modulus
length for key-pair generation is now specified as part of the
\*(lBdcecp\*(lE command.
.LI
The \*(lBDCEPKPrivateKeyStorage\*(lE ERA has been added.  This ERA is
used to identify the private key storage mechanism used by each
principal.
.LI
The format of public keys as stored in the
\*(lBDCEPKKeyEncipherment\*(lE and \*(lBDCEPKAuthentication\*(lE ERAs
has changed.  The keys are now stored as IDL-encoded structures of
type \*(lBsec_passwd_rec_t\*(lE, with \*(lBkey\*(lE of type
\*(lBsec_passwd_pubkey\*(lE.  This allows a version number to be
associated with each public key.
.LE
.P
.H 1 "TARGET"
.P
This technology is provided for customers who require less
reliance on the physical security of DCE Security servers.  It
may also be of interest to customers moving toward public key
based security mechanisms such as smart cards, or public key
based \*(qBSingle Sign On\*(qE facilities, although this
technology is only a starting point for such enhancements, which
are not part of this deliverable.
.P
.H 1 "GOALS AND NON-GOALS"
.P
.H 2 "Goals"
.P
.aL
.LI
Allow users to use a private key rather than a password to prove their
identity to the DCE Key Distribution Center.
.LI
Provide a standards-based mutual authentication protocol between the user
and the DCE Key Distribution Center.
.LI
The protocol must not require private keys to be stored in the DCE
Registry or to be transmitted across the wire protected by a
password-derived key.
.LI
Ease recovery from a compromise of the DCE Key Distribution Center.
.LI
Allow for use of public key algorithms that need not be RSA
(although the reference implementation uses the RSA BSAFE
library).
.LI
Allow for integration with public key formats that need not be
RSA-format keys (although the reference implementation uses
the RSA BSAFE library).
.LE
.P
.H 2 "Non-Goals"
.P
.aL
.LI
It is not a goal to support public key certificates in the reference
implementation, or to provide integration with the DCE Certification
API [RFC 80.0], or to assume the existence of a Certification
Authority.  The wire protocol is designed to allow integration of such
support in the future.\*(f!
.FS
Although it is expected that DCE will
support public key certificates eventually, the format of those
certificates is still undetermined.
.FE
.P
In the reference implementation, public keys are obtained by the
KDC from the DCE Registry.  If a client provides a certificate as part
of the authentication protocol, the KDC ignores the certificate
gracefully.
.LI
Server principals that use public key authentication to the KDC must
use the OSF DCE 1.2.2 User-to-User Protocol for authenticated
communication with DCE clients.  This is because non-User-to-User
Kerberos Service Tickets continue to be DES-encrypted under the
DES key of the server.  Extending public key technology into this
context is beyond the scope of this project.
.LI
It is not a goal of this project to integrate or test the DCE
Private Key Storage Server (see [RFC 94.0]) with the
functionality provided by this project.  Such integration and
testing is expected to be done by the provider of the DCE
Private Key Storage Server.
.LI
There is no specified or supported policy control for public keys
(such as control of lifetime, expiration, or length) other than
as specified in \*(qBPublic Key Policy Control\*(qE
under \*(qBFUNCTIONAL DEFINITION\*(qE.
.LE
.P
.H 1 "TERMINOLOGY"
.P
The same terminology and notation used in [RFC 85.0] is carried
over here, with a few additions:
.P
.aL
.LI
\*(bBPSM\*(bE \*(EM
Personal Security Module; a layer defined to abstract knowledge
of public and private key storage mechanisms and public key
cryptosystem operations and data types.
.LI
\*(bBERA\*(bE \*(EM
OSF DCE 1.1 Extended Registry Attribute.  See [RFC 6.0].
.LI
\*(bBASN.1\*(bE \*(EM
Abstract Syntax Notation 1.  A notation defined in [ITU X.208] for
describing abstract types and values.
.LI
\*(bBBER\*(bE \*(EM
Basic Encoding Rules.  A set of rules defined in [ITU X.209] and used
to encode ASN.1 values as strings of octets.  A single value can have
multiple valid BER encodings.
.LI
\*(bBDER\*(bE \*(EM
Distinguished Encoding Rules.  A restricted form of BER defined in
[ITU X.509] to eliminate most of the ambiguities in BER.
.LI
\*(bBSmart Card\*(bE \*(EM
A multi-purpose, tamper-resistant, portable personal security device,
utilizing VLSI chip technology for information storage and processing.
.LI
\*(bBUser\*(bE \*(EM
The human user (and any associated private key storage).
.LI
\*(bBClient\*(bE \*(EM
An application running on the user's workstation.  The login
process is an example of a client.
.LI
\*(lBCx\*(lE \*(EM
Certificate of X.
.LI
\*(lBK\*(lE \*(EM
Symmetric (session) key.
.LI
\*(lBKtgt\*(lE \*(EM
The session key to be used with a TGT.
.LI
\*(lB{M}Px\*(lE \*(EM
Message M encrypted with X's public key.
.LI
\*(lB{M}Sx\*(lE \*(EM
Message M signed by X.
.LI
\*(lBNx\*(lE \*(EM
A nonce (e.g., random number) generated by X.
.LI
\*(lBTx\*(lE \*(EM
A time stamp generated by X.
.LI
\*(bBKDC\*(bE \*(EM
The Kerberos Key Distribution Center.\*(f!
.FS
No distinction is made here between the Authentication Service and the
Ticket Granting Service (subservices of the KDC), for reasons of clarity.
.FE
.LI
\*(bBTGT\*(bE \*(EM
A Kerberos Ticket Granting Ticket.
.LE
.P
.H 1 "REQUIREMENTS"
.P
The technology must support an increase to the overall security of a
DCE cell.  It must also represent a genuine integration of public key
technology with the DCE login process.
.P
.H 1 "FUNCTIONAL DEFINITION"
.P
.H 2 "TGT Acquisition Protocol"
.P
The DCE Public Key TGT acquisition protocol is a subset of the
protocol described in [DRAFT-PKINIT], using the option for user's private
key being stored locally.
.nS
The protocol defined by [DRAFT-PKINIT] is very new, and is a candidate for
entry onto the IETF standards track.  Before it becomes standardized,
it may change in an incompatible and non-interoperable way.  It is the
intent of the authors that the DCE implementation track this protocol
as it evolves; however, resource and schedule constraints have
prevented us from implementing the full protocol in DCE 1.2.2.  Future
versions of DCE are expected to change to follow the successors to
[DRAFT-PKINIT] as well as maintain interoperability with DCE 1.2.2;
however, in the interests of greater interoperability, compliance with
[DRAFT-PKINIT] will have priority.
.nF
.P
The DCE login APIs
(\*(lBsec_login_validate_identity()\*(lE,
\*(lBsec_login_valid_and_cert_ident()\*(lE, and
\*(lBsec_login_validate_first()\*(lE) attempt to use this protocol
initially by default as long as Public Key authentication information
can be constructed.  If Public Key authentication information can not be constructed, then
the default for the initial attempt is the OSF DCE Third Party
protocol.
If OSF DCE Third Party authentication information can not be
constructed, then
the default for the initial attempt is the Timestamps protocol
(for which information can always be constructed).
.P
.nS
In the reference implementation, for backwards compatibility with
pre-1.2.2 servers, both the \*(lBKRB5_PADATA_ENC_UNIX_TIME\*(lE and
\*(lBKRB5_PADATA_ENC_TIMESTAMP\*(lE
PADATA are constructed.
.nF
.P
If the KDC is unable to authenticate the user with the supplied
public key pre-authentication data, the KDC returns error information.
.P
If the initial public key login attempt fails, then the
\*(lBsec_login\*(lE code falls back to the existing
symmetric key password-based authentication, unless the KDC
error information indicates that the principal is required to
use public key pre-authentication.  Sites that do not wish to
allow any fall-back must attach an instance of the
\*(lBpre_auth_req\*(lE ERA, with a value of \*(lB3\*(lE
(\*(lBPADATA-ENC-PUBLIC-KEY\*(lE), to each principal that is
required to use public key login.  With this ERA attached, the
KDC will not accept anything except a public key login for the
principal, even if attempted.
.P
A two-message protocol is used to acquire a TGT.  This protocol
relies, in part, on time stamps to guarantee the freshness of
messages.  There is no reason to adopt a challenge-response mechanism
since the subsequent Kerberos protocols rely on time stamps.
Since the TGT session key is encrypted with a random key
that is encrypted with the public key of the client, successful use of
the TGT implies the ability to decrypt this session key, and therefore
possession of the user's private key.
.P
The authentication information is transmitted in the pre-authentication
data fields of the standard Kerberos V5 \*(lBKRB_AS_REQ\*(lE and
\*(lBKRB_AS_REP\*(lE messages [IETF 1510] as new
\*(lBKRB5_PADATA_ROOT_CERT\*(lE and
\*(lBKRB5_PADATA_PUBLIC_REP\*(lE pre-authentication data types.
.P
.nS
As an implementation optimization and for backwards compatibility with
pre-1.2.2 servers, the client sends both Third-Party (PADATA-ENC-OSF-DCE)
and Public Key (PADATA-ENC-ROOT-CERT) PADATA in the initial TGT request.
The Third-Party PADATA is the first PADATA stored in the request.
Pre-1.2.2 servers examine and verify the first PADATA, and ignore any
remaining PADATA.  DCE 1.2.2 servers examine and verify each PADATA type.
If the Third-Party PADATA can not be verified, but the Public Key PADATA
can, then the KDC returns a TGT to the client using the Public Key
reply protocol.
.nF
.P
The protocol usage criteria can be diagrammed as follows.
.P
The \*(qBTP
can be built\*(qE column indicates whether a Third-Party PADATA
structure can be built by the \*(lBsec_login\*(lE client code.
.P
The
\*(qBPK can be built\*(qE column indicates whether Public Key
Protocol information can be built by the \*(lBsec_login\*(lE
client code.  This can be built only if the client has a \*(lBPSM\*(lE
and if the supplied passphrase is valid for gaining access to
that \*(lBPSM\*(lE.
.P
The
\*(qBPADATA sent\*(qE column indicates which PADATA types are sent in
the \*(lBKRB_AS_REQ\*(lE, and in what order.
.P
The \*(qBPADATA
verified\*(qE column indicates which PADATA type must pass
verification in order for a TGT to be returned and which protocol will
be used for the PADATA in the \*(lBKRB_AS_REP\*(lE.  If there is no
possibility of a TGT to be returned, the column indicates
\*(qBnone\*(qE.
.P
.cS
.ne 33
               TABLE 1: PROTOCOL USAGE CRITERIA

                                             PROTOCOLS
  VERSIONS                CASES                USED
--------------- -------------------------- --------------
client  server  TP can   PK can   password PADATA PADATA
version version be built be built valid    sent+  verified+
------- ------- -------- -------- -------- ------ ---------
1.2.2   1.2.2   yes      yes      yes      TP,PK  PK
1.2.2   1.2.2   yes      yes      no       TP,PK  PK
1.2.2   1.2.2   yes      no       yes      TP     TP*
1.2.2   1.2.2   yes      no       no       TP     none

1.2.2   1.2.2   no       yes      yes      TS,PK  PK
1.2.2   1.2.2   no       yes      no       TS,PK  PK
1.2.2   1.2.2   no       no       yes      TS     TS*
1.2.2   1.2.2   no       no       no       TS     none

1.2.2  <1.2.2   yes      yes      yes      TP,PK  TP
1.2.2  <1.2.2   yes      yes      no       TP,PK  none
1.2.2  <1.2.2   yes      no       yes      TP     TP
1.2.2  <1.2.2   yes      no       no       TP     none

1.2.2  <1.2.2   no       yes      yes      TS,PK  TS*
1.2.2  <1.2.2   no       yes      no       TS,PK  none
1.2.2  <1.2.2   no       no       yes      TS     TS*
1.2.2  <1.2.2   no       no       no       TS     none

<1.2.2  1.2.2   yes      N/A      yes      TP     TP*
<1.2.2  1.2.2   yes      N/A      no       TP     none

<1.2.2  1.2.2   no       N/A      yes      TS     TS*
<1.2.2  1.2.2   no       N/A      no       TS     none

.ne 11
* PADATA passes verification only if the client's effective
  pre_auth_req value allows the client to use this PADATA type.

+ TS: Timestamps PADATA
      (KRB5_PADATA_ENC_UNIX_TIME from pre-1.2.2 clients,
       KRB5_PADATA_ENC_UNIX_TIME followed by
          KRB5_PADATA_ENC_TIMESTAMP from 1.2.2 clients)
  TP: Third-Party PADATA (KRB5_PADATA_ENC_OSF_DCE)
  PK: Public Key PADATA
      (KRB5_PADATA_ENC_ROOT_CERT,
       KRB5_PADATA_ENC_PUBLIC_REP)
.cF
.P
.H 3 "Client-to-KDC Message"
.nS
The following protocol description is necessarily a high-level
simplification of the actual protocol used.  For full details, see
[DRAFT-PKINIT].
.nF
.P
.dS
C-->KDC:   {Rc,Cksum,Tc,Nc,KDC}Sc
.dF
.P
The client process signs a message including an optional list of root
certifiers trusted by the client, a checksum, a time stamp,
a nonce and the identity of the KDC.  The signature is done with the
client's private digital signature key.  This signed message is sent
to the KDC along with the client's (optional) certificate as the
contents of the PADATA field of a standard \*(lBKRB_AS_REQ\*(lE message.  The
client's identity is part of the existing \*(lBKRB_AS_REQ\*(lE message.
.P
.nS
In the reference implementation, client processes do not send a
certificate, and the list of root certifiers trusted by the client
is NULL.
.nF
.P
If the client supplies a certificate, the KDC may choose to ignore the
certificate and retrieve public keys directly from the DCE Registry.
Alternatively, the KDC may check revocation lists to establish the
validity of the certificate.
.P
.nS
In the reference implementation, the KDC ignores any certificates
sent by client processes and obtains public keys directly from the
DCE Registry.
.nF
.P
.H 3 "KDC-to-Client Message"
.P
.nS
The following protocol description is necessarily a high-level
simplification of the actual protocol used.  For full details, see
[DRAFT-PKINIT].
.nF
.dS
KDC-->C:   Ckdc,{{Kreply,Nc}Skdc}EncReplytmpKey,
           {EncReplytmpKey}Pc
.dF
.P
The KDC checks the time stamp and signature of the client's message.
If the time stamp is sufficiently current and the signature can be
verified using the client's public key, the KDC responds with a standard \*(lBKRB_AS_REP\*(lE
reply message in which the PADATA field contains
a random symmetric reply key
(\*(lBKreply\*(lE) and the client's nonce.  The reply key and client nonce
are first signed using the KDC's private digital signature key, then
encrypted using a temporary random symmetric key (\*(lBEncReplytmpKey\*(lE).  This
temporary random symmetric key is encrypted with
the client's public key-encipherment key [the combination of symmetrically
encrypted signed data and asymmetrically encrypted key is called \*(iBdigital
enveloping\*(iE].
The reply key is used to encrypt the encrypted portion of the standard
\*(lBKRB_AS_REP\*(lE, which includes the symmetric session key associated with
the TGT.
The KDC optionally includes its
certificate in the PADATA field of the response.  This certificate, if
included, must be signed by one of the root certifiers trusted by the client.
.P
The TGT is passed in the standard \*(lBKRB_AS_REP\*(lE ticket field.
The TGT is returned without additional encryption (portions of it were
encrypted by the KDC) since it is subsequently used in the clear by
the client.  The symmetric session key used in association with the
TGT is returned in the standard \*(lBEncKDCRepPart\*(lE field of the
\*(lBKRB_AS_REP\*(lE message.  This \*(lBEncKDCRepPart\*(lE field  is encrypted using the
reply key (\*(lBKreply\*(lE) returned in the signed and encrypted authentication data from the
KDC.
.P
.nS
In the reference implementation, the KDC does not send its certificate
in the response.  The public key of the KDC is cached locally on the client
node by the \*(lBdced\*(lE daemon, and can be read from the cache by the client.
.P
Vendors implementing smart cards may wish to store the public
key of the KDC on each user's smart card, and have the client obtain the KDC
public key from the smart card.
.nF
.P
By checking the signature on this response, the client can be assured
that the reply is from the KDC.  The session key can only be decrypted
by the legitimate client who possesses the private key needed
to decrypt the key encryption key.  The TGT and associated session key
are then used as normal.
.P
.H 3 "Changes to existing TGT acquisition protocols"
.P
When any TGT acquisition request is received, the DCE KDC checks for
an instance of the \*(lBpre_auth_req\*(lE ERA attached to the user
principal.  If found, the authentication attempt is rejected with the
\*(lBKDC_PREAUTH_FAILED\*(lE error if the value of the ERA is less
than the value associated with the protocol used by the TGT
acquisition request.  The public key login protocol has a higher
associated value than any previously specified preauthentication
protocol, including the various forms of encrypted timestamps and the
DCE 1.1 third-party protocol.
.P
.H 2 "Public Key Interfaces
.P
.H 3 "Overview"
.P
Public Key Login provides a number of layers and APIs.  Some of these
are provided to help satisfy export requirements.  Some are provided
to allow easy extension or enhancement by vendors.  Only one API \*(EM
\*(lBsec_pubkey\*(lE \*(EM is provided for user application use.
.P
The Public Key Login layers and APIs may be diagrammed as follows
as they are used internally by the DCE Security client library.
.P
.cS
.ne 15
       TABLE 2: PUBLIC KEY LOGIN LAYERS

 ___________________________________________________
|                                                   |
|                      sec_login                    |
|___________________________________________________|
|                                                   |
|                      sec_psm                      |
|___________________________________________________|
|                 |              |                  |
|  sec_pubkey     |  sec_pvtkey  |  crypto library  |
|_________________|______________|__________________|
|                 |      |       |
|  rsec_pk_cache  | PKSS | file  |
|_________________|______|_______|
.cF
.P
Descriptions of the individual interfaces follow.
.P
.H 3 "DCE Personal Security Module Interface"
.P
A \*(lBsec_psm\*(lE layer is defined to abstract knowledge of
public and private storage mechanisms and public key
cryptosystem functions and data types.  This interface is not
specified as an application program interface, but rather
as a way to allow replacement with a standard personal security
module interface as one emerges.
.P
This layer provides access to high-level security operations
such as \*(lBsign()\*(lE, \*(lBverify()\*(lE,
\*(lBencrypt()\*(lE, and \*(lBdecrypt()\*(lE, hiding the actual
implementations in lower layers.  The existing
\*(lBsec_login\*(lE API has been made a consumer of this interface.
.P
Only the user principal has the permissions needed to obtain
information from this layer, as access to the user's private key
requires knowledge of the user's password.
.P
.H 3 "Public Key Module API"
.P
A DCE Public Key Module API \*(EM \*(lBsec_pubkey\*(lE \*(EM
is provided to abstract and hide the details of
public key storage and acquisition for use in the Public Key Login protocol.
This mechanism is extensible to other storage and acquisition mechanisms and
for use by other protocols.  This API may be used directly by
DCE Applications.  It is also used internal to the DCE Public Key
protocol implementation.
.P
The mechanisms provided with the reference implementation are:
.aL
.LI
\*(lBsec_pk_domain_dce_general\*(lE: retrieval of a principal's public keys from
ERAs attached to the principal in the DCE Registry.  This mechanism may
be used for retrieval by any client for any principal.  This mechanism
may also be used for public key storage by a cell administrator, or other authorized
client.
.LI
\*(lBsec_pk_domain_kdc_cache\*(lE: retrieval of a principal's public keys from
a local cache file, backed up by retrieval via request to \*(lBdced\*(lE.  This
mechanism may be used only for retrieval of a krbtgt principal's key.  It is intended
for use by unauthenticated clients as part of the Public Key Login protocol.
.LI
\*(lBsec_pk_domain_kdc_refresh_refresh\*(lE: retrieval of a principal's public keys
via request to \*(lBdced\*(lE.  This mechanism may be used only for retrieval
of a krbtgt principal's key.  This mechanism causes the
\*(lBdced\*(lE daemon to refresh the
associated krbtgt principal's local public key cache file.
.LI
\*(lBsec_pk_domain_kdc_pk_init\*(lE: retrieval of a principal's keys directly from
the DCE Registry.  This mechanism is available only internal to the DCE
Security Server.
.LE
.P
.H 3 "Private Key Module Interface"
.P
A DCE Private Key Module Interface is provided to abstract and hide the
underlying details of the private key storage mechanism.  This
interface is extensible to other acquisition mechanisms and for
use by other protocols.  The DCE Private Key Module Interface is not
provided as an application API, but rather as a means for DCE
vendors to supply alternative key storage mechanisms.
.P
The storage mechanisms provided with the reference implementation
are:
.aL
.LI
\*(lBsec_psm_pkss_mechanism\*(lE: storage using the Public Key Storage Server
[RFC 94.0].
.LI
\*(lBsec_psm_file_mechanism\*(lE: storage using a local file.
.LI
\*(lBsec_psm_kdc_pk_init_mechanism\*(lE: storage in the DCE Registry.  This
mechanism is available only internal to the DCE Security Server.
.LE
.P
.H 2 "KDC Key Management"
.P
The KDC requires a public key pair in order to support the OSF DCE
Public Key Login protocol.  While the KDC uses the \*(lBsec_psm\*(lE
layer for accessing public key functions, it uses a
\*(lBsec_pvtkey\*(lE mechanism that accesses the DCE Registry
directly, both for security and for performance.  This mechanism is
only available within the \*(lBsecd\*(lE binary image.
.P
.H 3 "KDC Private and Public Key"
.P
The KDC private key used for authentication (generating signatures) is
stored in the DCE Registry.  It is stored, protected, and propagated
exactly as the DES symmetric KDC key is now stored, protected, and
propagated, by the implementation of a new password type:
\*(lBsec_passwd_pubkey\*(lE, and by the extension of internal
mechanisms for storage of keys.  This new type is used within the DCE
Registry, for propagation to DCE Registry replicas, and for the
encoding of public key values inside ERAs.  This new type may not be
specified by Registry clients.
.P
The KDC public key used for authentication is stored in the
\*(lBDCEPKAuthentication\*(lE ERA attached to the
\*(lBkrbtgt\*(lE principal for the cell.
.P
The DCE Registry sets or updates the KDC authentication public key key-pair when
the password of the krbtgt principal is set to a keytype of \*(lBsec_passwd_genprivkey\*(lE.
It uses the \*(lBmodulus_size\*(lE parameter in the keytype to determine
what modulus size to use.
.P
The \*(lBdcecp> account modify krbtgt/<cell>
-pkgenprivkey <modulus_size>\*(lE user interface can be used by a cell administrator
to set the KDC's key to a keytype of \*(lBsec_passwd_genprivkey\*(lE.
.P
.H 3 "KDC Public Key Caching"
.P
During login, a principal needs an authenticated copy of the public
key of the local KDC in order to verify that the TGT it obtains is
from the correct KDC.  However, the principal is not yet
authenticated, and so is unable to obtain an authenticated copy of an
ERA.  Since the \*(lBdced\*(lE daemon is authenticated (as the client host
principal), we make use of
this to obtain an authenticated copy of the KDC public key.
.P
The daemon, via the \*(lBrsec_pk_cache_kdc_key\*(lE remote interface,
supports client requests for updates or additions to a local cache
of KDC public authentication keys.  It retrieves
the authentication public key of a cell's KDC from the
\*(lBDCEPKAuthentication\*(lE ERA attached to the \*(lBkrbtgt\*(lE
principal for the cell, and writes it to the file
\*(lB/etc/opt/dce/security/kdc_pk_auth/\*(jBcell_name\*(jE/.key\*(lE
in ASN.1 DER encoding.
.P
The \*(lBsec_login\*(lE APIs retrieve required public keys
of local or foreign KDCs from the cache file for the cell.  If a
required KDC key file is not found, or if a KDC key fails to
decrypt the reply from the KDC successfully, \*(lBsec_login\*(lE
asks the local \*(lBdced\*(lE daemon to obtain or refresh the
required key.
.P
.H 2 "Public Key Policy Control"
.P
The modulus length of the KDC authentication public key is
determined by the value of the \*(lB-pkgenprivkey\*(lE parameter to
the \*(lBdcecp> account modify krbtgt/<cell>\*(lE command.  By default,
only the cell administrator is authorized to modify this account.
.P
Public keys may be revoked by removing the
\*(lBDCEPKKeyEncipherment\*(lE and \*(lBDCEPKAuthentication\*(lE
ERA instances from the principal.
.P
Usage of the public key login protocol can be mandated by attaching a
\*(lBpre_auth_req\*(lE ERA with a value of
\*(lBPADATA_ENC_PUBLIC_KEY\*(lE to a principal.  See
\*(qBChanges to existing TGT acquisition protocols\*(qE under the
\*(qBTGT Acquisition Protocol\*(qE sub-section under
\*(qBFUNCTIONAL DEFINITION\*(qE, and
\*(qBConfiguring Public Key Login Users\*(qE under
\*(qBMANAGEMENT INTERFACES\*(qE.
.P
Except as stated above, there is no specified or supported policy
control for public keys (such as control of lifetime, expiration, or
modulus length) included as part of this project.
.P
.H 2 "Passwords"
.P
During login operations, including \*(lBdce_login\*(lE and \*(lBdcecp>
login\*(lE, the string entered as the \*(lBpassword\*(lE value is used
first as a \*(lBpassphrase\*(lE in an attempt to access the
\*(lBPSM\*(lE.  If this fails, and the user is not identified as
requiring use of the public key authentication protocol, then the
string is used as a DCE shared-secret \*(lBpassword\*(lE.
.P
Except for login operations, the \*(lBdcecp -password\*(lE option
always refers to a user's DCE shared-secret \*(lBpassword\*(lE, while
the \*(lBoldpassphrase\*(lE and \*(lBnewpassphrase\*(lE options always
refer to a user's \*(lBPSM\*(lE \*(lBpassphrase\*(lE.
.P
A user's \*(lBPSM\*(lE \*(lBpassphrase\*(lE values may or may not match the DCE
shared-secret \*(lBpassword\*(lE value.
.P
.H 1 "DATA STRUCTURES"
.P
.H 2 "Public Key Login Base Types"
.P
The common base definitions for the DCE Public Key Login APIs are
defined in three new files
\*(lBsecurity/idl/sec_pk_base.idl\*(lE,
\*(lBsecurity/h/sec_pk.h\*(lE, and
\*(lBsecurity/h/sec_psm_base.h\*(lE, listed here:
.P
.H 3 "\*(lBsecurity/idl/sec_pk_base.idl\*(lE"
.P
.cS
...\" .so /dce/src/security/idl/sec_pk_base.idl
/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1990, 1991, 1992, 1993, 1996 Open Software
 *  Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE
 *  in the src directory for the full copyright text.
 */
/*
** Copyright (c) Hewlett-Packard Company 1996
** Unpublished work.  All Rights Reserved.
**
**       Public Key Base Definitions
*/

interface sec_pk_base {

/* s e c _ p k _ d o m a i n _ t
 *
 * A UUID associated with the application domain
 * in which a public or private key is used.
 */
typedef uuid_t sec_pk_domain_t;

/* s e c _ p k _ u s a g e _ f l a g s _ t
 *
 * A set of key usage flags indicating the uses for
 * a key or key-pair.
 *
 * These correspond to KeyUsage types defined in
 * DAM 1 (Dec 1995) to X.509 (1993)
 */
typedef unsigned32 sec_pk_usage_flags_t;

const unsigned32 sec_pk_usage_digitalSignature  = 0x1;
const unsigned32 sec_pk_usage_nonRepudiation    = 0x2;
const unsigned32 sec_pk_usage_keyEncipherment   = 0x4;
const unsigned32 sec_pk_usage_dataEncipherment  = 0x8;
const unsigned32 sec_pk_usage_keyAgreement      = 0x10;
const unsigned32 sec_pk_usage_keyCertSign       = 0x20;
const unsigned32 sec_pk_usage_offLineCRLSign    = 0x40;

const unsigned32 MAX_USAGES                     = 7;

/* s e c _ p k _ d a t a _ t
 *
 * A structure pointing to an X.509 or X.511
 * ASN.1 DER-encoded value.
 *
 * Rather than using this structure directly, users
 * should use one of the types that follow, which
 * indicate the type of information contained in the
 * particular structure instance.
 */
typedef struct{
    unsigned32       len;
    [ptr, size_is(len)]
        byte         *data;
} sec_pk_data_t;



/* s e c _ p k _ d a t a _ p _ t
 *
 * A pointer to a sec_pk_data_t
 * structure
 */
typedef [ptr] sec_pk_data_t   *sec_pk_data_p_t;

/* s e c _ p k _ g e n _ d a t a _ t
 *
 * A sec_pk_data_t structure containing len and data which are
 * parallel to sec_pk_data_t structure to hold
 * non-ASN.1 DER-encoded data, such as plaintext or ciphertext.
 */
typedef sec_pk_data_t sec_pk_gen_data_t;

/* s e c _ p k _ p u b k e y _ t
 *
 * A sec_pk_data_t structure containing an X.509
 * ASN.1 DER-encoded value of type
 * SubjectPublicKeyInfo
 *
 * The vendor's public key infrastructure is assumed
 * to provide functions for generating a public key
 * in this format.
 *
 * In the reference implementation, the BSAFE library
 * provides such a function.
 */
typedef sec_pk_data_t sec_pk_pubkey_t;

/* s e c _ p k _ p u b k e y _ p _ t
 *
 * A pointer to a sec_pk_pubkey_t structure
 */
typedef [ptr] sec_pk_pubkey_t *sec_pk_pubkey_p_t;


/* s e c _ p k _ p v t k e y _ t
 *
 * A sec_pk_data_t structure containing an ASN.1
 * DER-encoded private key value.  The
 * format will depend on the public key infrastructure.
 *
 * In the reference implementation, the structure will
 * contain a PKCS#8 private key of type PrivateKeyInfo.
 *
 * The vendor's public key infrastructure is assumed
 * to provide functions for generating a private key
 * in this format.
 */
typedef sec_pk_data_t sec_pk_pvtkey_t;

/* s e c _ p k _ p v t k e y _ p _ t
 *
 * A pointer to a sec_pk_pvtkey_t structure
 */
typedef [ptr] sec_pk_pvtkey_t *sec_pk_pvtkey_p_t;


/* s e c _ p k _ s i g n e d _ t
 *
 * A sec_pk_data_t structure containing an X.509
 * ASN.1 DER-encoded value of type
 * SIGNED.
 *
 * The vendor's public key infrastructure is assumed
 * to provide functions for generating signed data
 * in this format.
 *
 * In the reference implementation, the BSAFE library
 * provides such a function.
 */
typedef sec_pk_data_t sec_pk_signed_t;

/* s e c _ p k _ s i g n e d _ p _ t
 *
 * A pointer to a sec_pk_signed_t structure
 */
typedef [ptr] sec_pk_signed_t *sec_pk_signed_p_t;


/* s e c _ p k _ e n c r y p t e d _ t
 *
 * A sec_pk_data_t structure containing an X.509
 * ASN.1 DER-encoded value of type
 * ENCRYPTED.
 *
 * The vendor's public key infrastructure is assumed
 * to provide functions for generating encrypted data
 * in this format.
 *
 * In the reference implementation, the BSAFE library
 * provides such a function.
 */
typedef sec_pk_data_t sec_pk_encrypted_t;

/* s e c _ p k _ e n c r y p t e d _ p _ t
 *
 * A pointer to a sec_pk_encrypted_t structure
 */
typedef [ptr] sec_pk_encrypted_t *sec_pk_encrypted_p_t;

/* s e c _ p k _ a l g o r i t h m _ i d _ t
 *
 * A sec_pk_data_t structure containing an X.509
 * ASN.1 DER-encoded value of type
 * AlgorithmIdentifier.
 *
 * The vendor's public key infrastructure is assumed
 * to provide functions for providing
 * this format.
 *
 * In the reference implementation, the BSAFE library
 * provides such a function.
 */
typedef sec_pk_data_t sec_pk_algorithm_id_t;

/* s e c _ p k _ a l g o r i t h m _ i d _ p _ t
 *
 * A pointer to a sec_pk_algorithm_id_t structure
 */
typedef [ptr] sec_pk_algorithm_id_t *sec_pk_algorithm_id_p_t;
}
...\" END /dce/src/security/idl/sec_pk_base.idl
.cF
.P
.H 3 "\*(lBsecurity/h/sec_pk.h\*(lE"
.P
.cS
...\" .so /dce/src/security/h/sec_pk.h
/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1996 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE
 * in the src directory for the full copyright text.
 */
/*
 * Copyright (c) Hewlett-Packard Company 1996
 * Unpublished work. All Rights Reserved.
 */

#ifndef _SEC_PK_H_
#define _SEC_PK_H_

#include <dce/nbase.h>
#include <dce/sec_pk_base.h>
#include <dce/sec_psm_base.h>
#include <dce/sec_attr_base.h>

/* The following sec_pk_domain_t UUIDs are
 * architectural.  They cannot be changed without
 * destroying interoperability.
 */

/* sec_pk_domain_dce_general: for use by
 * authenticated clients in retrieving and storing
 * public and private keys */
extern uuid_t sec_pk_domain_dce_general;
              /* ae991638-5cbe-11cf-a22d-08000919ebb5 */

/* sec_pk_domain_kdc_cache: for use by
 * unauthenticated clients in retrieving the
 * public key of a krbtgt principal from the
 * dced-maintained krbtgt key cache.
 */
extern uuid_t sec_pk_domain_kdc_cache;
              /* e925f8b4-0a3a-11d0-94f1-08000919ebb5 */

/* sec_pk_domain_pk_kdc_cache_refresh: for use by
 * unauthenticated clients in retrieving a
 * refreshed cache copy of the public key of a
 * krbtgt principal.
 */
extern uuid_t sec_pk_domain_kdc_cache_refresh;
              /* f087b8e0-0a3a-11d0-9113-08000919ebb5 */

/* sec_pk_domain_kdc_pk_init: for use by the KDC
 * in performing sec_psm operations using its own
 * private key.
 */
extern uuid_t sec_pk_domain_kdc_pk_init;
              /* 7d2d9810-e721-11cf-9021-08000919ebb5 */

/* UUIDs of DCE public key-related ERAs
 *
 */

/* DCEPKAuthentication_id: UUID of the
 * DCEPKAuthentication ERA, used to hold a
 * principal's sec_pk_usage_digitalSignature
 * Public Key for use in the DCE Public Key Login
 * protocol
 */
extern uuid_t DCEPKAuthentication_id;
              /* d44dc60e-6230-11cf-98ed-08000919ebb5 */

/* DCEPKKeyEncipherment_id: UUID of the
 * DCEPKKeyEncipherment ERA, used to hold a
 * principal's sec_pk_usage_keyEncipherment Public
 * Key for use in the DCE Public Key Login
 * protocol
 */
extern uuid_t DCEPKKeyEncipherment_id;
              /* 76251f8c-6230-11cf-af89-08000919ebb5 */

/* DCEPKPrivateKeyStorage_id: UUID of the
 * DCEPKPrivateKeyStorage ERA, used to associate
 * a principal with a private key storage mechanism.
 * The UUIDs of the mechanisms themselves are contained in
 * file sec_psm_base.h
 */
extern uuid_t DCEPKPrivateKeyStorage_id;
              /* 1f79c78e-b026-11cf-b7c8-0800090a5254 */

/* Following format is used in the header of a public
 * or private key keyfile.  A PK keyfile is used both
 * by the dced in caching the public keys of krbtgt
 * principals, and also by dcecp in reading public
 * or private key values from a file supplied by
 * the user.
 *
 * The values used in the header are defined in
 * sec_pk.c
 */
typedef struct {
    char         keyfile_id[4];
    unsigned32   keyfile_fmt_ver;
} sec_pk_keyfile_hdr_t;

extern const sec_pk_keyfile_hdr_t sec_pk_keyfile_hdr;
#define DCEPKKEYFILE_ID sec_pk_keyfile_hdr.keyfile_id;
#define DCEPKKEYFILE_VER sec_pk_keyfile_hdr.keyfile_fmt_ver;

/* s e c _ p k _ d a t a _ i n i t
 *
 * Initializes sec_pk_data_t or its type-specific variants.
 *
 *   In Parameters:
 *       data_p  - pointer to a sec_pk_data_t
 *                 that is to be initialized.
 *                 data_p is returned
 *                 with data_p->len set to 0 and
 *                 data_p->data set to NULL.
 *
 *   Errors: none.
 */
#define sec_pk_data_init(data_p) \e
      do { sec_pk_data_t *__d = \e
        (data_p); __d->data = NULL; __d->len = 0; } \e
      while (0)

/* s e c _ p k _ d a t a _ c r e a t e
 *
 * Copies data to a sec_pk_data_t or its type-specific variants.
 *
 *   In Parameters:
 *       data, len
 *                pointer to, and length of, memory to be copied
 *   Out Parameters:
 *       data_out_p  - pointer to a sec_pk_data_t
 *                 that receives a pointer to the copied data.
 *
 *   Errors:
 *     error_status_ok    - success
 *     sec_pk_e_no_memory - malloc failed
 */
error_status_t sec_pk_data_create (
    unsigned8       *data,      /* [in] */
    size_t          len,        /* [in] */
    sec_pk_data_t   *data_out_p /* [out] */
);


/* s e c _ p k _ d a t a _ c o p y
 *
 * Copies a sec_pk_data_t or its type-specific variants.
 *
 *   In Parameters:
 *       data_in_p  - pointer to a sec_pk_data_t
 *                 that points to the memory to be copied
 *   Out Parameters:
 *       data_out_p  - pointer to a sec_pk_data_t
 *                 which receives a pointer to the copied data.
 *
 *   Errors:
 *     error_status_ok    - success
 *     sec_pk_e_no_memory - malloc failed
 */
error_status_t sec_pk_data_copy (
    sec_pk_data_t   *data_in_p, /* [in] */
    sec_pk_data_t   *data_out_p /* [out] */
);


/* s e c _ p k _ d a t a _ f r e e
 *
 * Frees memory associated with data of type
 * sec_pk_data_t or its type-specific variants.
 *
 *   In Parameters:
 *       data_p  - pointer to a sec_pk_data_t
 *                 that points to the memory
 *                 to be reclaimed.
 *                 data_p is returned
 *                 with data_p->data set to NULL and
 *                 data_p->len set to 0.
 *
 *   Errors: None
 */
void sec_pk_data_free (
    sec_pk_data_t   *data_p       /* [in,out] */
);


/* s e c _ p k _ d a t a _ z e r o _ a n d _ f r e e
 *
 * Zeroes out, then frees memory associated with data
 * of type sec_pk_data_t or its type-specific variants.
 *
 * This function, rather than sec_pk_data_free, should
 * be called for structures containing private or
 * secret keys.
 *
 *   In Parameters:
 *       data_p  - pointer to a sec_pk_data_t
 *                 that points to the memory
 *                 to be reclaimed.
 *                 data_p is returned with
 *                 data_p->data set to NULL,
 *                 and data_p->len set to 0.
 *
 *   Errors: none
 */
void sec_pk_data_zero_and_free (
    sec_pk_data_t   *data_p         /* [in,out] */
);

/* sec_pk_get_key_usage_count
 *
 *   In Parameters:
 *       key_usages  - a value of type sec_pk_usage_flags_t
 *           containing key usage flag settings
 *   Return value:
 *       integer count of the number of key usage
 *       flags set in key_usages
 *
 *   Errors: none
 *
extern int sec_pk_get_key_usage_count(
    sec_pk_usage_flags_t     key_usages
);


/* s e c _ p k _ a t t r _ w r i t e _ s e t u p
 *
 * Function:
 *     Set up an attribute value with public key data
 *     for call to rs_attr_update()
 *      -sets attr->attr_id to id
 *      -IDL-encodes the public key data as a
 *       sec_passwd_rec_t of type sec_passwd_pubkey
 *      -allocates attr->attr_value.tagged_union.bytes
 *      -copies IDL-encoded public key data to
 *       tagged_union.bytes->data
 *
 * In Parameters:
 *     alloc    - allocator (e.g. malloc or rpc_ss_allocate)
 *     dealloc  - deallocator (e.g. free or rpc_ss_free)
 *     attr     - pointer to an attribute to be set up
 *     id       - UUID of attribute to be written
 *     kvno     - pointer to key version number to be
 *                written; must not be 0!
 *     pk_data_p - pointer to a sec_pk_data_t
 *                containing the key value to
 *                be written as an attribute
 * Errors:
 *     error_status_ok
 *     sec_pk_e_no_memory - malloc failed
 *     sec_pk_e_no_key_value - input pk_data is empty
 *     sec_pk_e_key_vers_unsupported - input kvno is
 *         NULL, < 0, or > 255
 * Errors passed through from:
 *     sec_pwd_encode()
 */
error_status_t sec_pk_attr_write_setup(
    idl_void_p_t       (*alloc)(idl_size_t size),
    void               (*dealloc)(idl_void_p_t ptr),
    sec_attr_t         *attr,
    uuid_t             id,
    unsigned32         *kvno,
    sec_pk_data_t      *pk_data_p
);

#endif
...\" END /dce/src/security/h/sec_pk.h
.cF
.P
.H 3 "\*(lBsecurity/h/sec_psm_base.h\*(lE"
.P
.cS
...\" .so /dce/src/security/h/sec_psm_base.h
/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1996 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE
 * in the src directory for the full copyright text.
 */
/*
 * Copyright (c) Hewlett-Packard Company 1996
 * Unpublished work.  All Rights Reserved.
 */

#ifndef _SEC_PSM_BASE_H_
#define _SEC_PSM_BASE_H_

/* The following private key storage mechanism are
 * architectural.  They cannot be changed without
 * destroying interoperability.
 *
 * The UUIDs are defined in sec_psm.c
 */

extern uuid_t sec_psm_pkss_mechanism;
    /* 72053e72-b01a-11cf-8bf5-0800090a5254 */

extern uuid_t sec_psm_file_mechanism;
    /* 8687c5b8-b01a-11cf-b137-0800090a5254 */

extern uuid_t sec_psm_kdc_pk_init_mechanism;
    /* adb48ed4-e94d-11cf-ab4b-08000919ebb5 */

extern sec_pk_algorithm_id_t rsa_pkcs;
extern sec_pk_algorithm_id_t md5_rsa;
extern sec_pk_algorithm_id_t rsa_enc;

#define RSA_PKCS &rsa_pkcs
#define MD5RSA &md5_rsa
#define RSAENC &rsa_enc

#endif
...\" END /dce/src/security/h/sec_psm_base.h
.cF
.P
.H 2 "Password types"
.P
In order to allow a cell administrator to request the KDC to update its
authentication public key key-pair, two new password types are added to
the existing \*(lBsec_passwd_type_t\*(lE \*(lBenum\*(lE, and
definitions are added to the existing \*(lBsec_passwd_rec_t\*(lE
structure.  These modified types are specified in the file
\*(lBsecurity/idl/passwd.idl\*(lE, listed here:
.cS
...\" .so /dce/src/security/idl/passwd.idl
/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1990, 1991, 1992, 1993, 1996 Open Software
 *   Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE
 * in the src directory for the full copyright text.
 */
/*
** Copyright (c) Hewlett-Packard Company 1991, 1993, 1996
** Unpublished work. All Rights Reserved.
**
*/
/*
 * User Registry - Base password datatypes
 */

interface passwd

{

import "dce/sec_base.idl";
import "dce/sec_pk_base.idl";

const    unsigned32    sec_passwd_c_des_key_size      = 8;
typedef  byte sec_passwd_des_key_t[sec_passwd_c_des_key_size];

const    unsigned32    sec_passwd_str_max_len = 512;
const    unsigned32    sec_passwd_str_t_size  = 513;
typedef [string] char  sec_passwd_str_t[sec_passwd_str_t_size];

/* BSAFE1.2.1 limits modulus to 1024 bits, but we will support
 * up to 4096 bits. Public key is stored with private key.  The
 * extra 384 bytes of structure is accurate for BSAFE1.2.1, but
 * may not be sufficient for revisions supporting larger moduli.
 * This value should be checked if new BSAFE (or other RSA
 * encryption implementation) is used.
 */

.ne 2
const    unsigned32    sec_passwd_c_max_pk_modulus        = 4096;
                                                            /*bits*/
.ne 2
const    unsigned32    sec_passwd_c_max_pk_overhead       = 384;
                                                            /*bytes*/
const    unsigned32    sec_passwd_c_max_pk_key_size = \e
                (2*sec_passwd_c_max_pk_modulus/8) \e
                + sec_passwd_c_max_pk_overhead;

/* currently supported key types */
typedef enum {
    sec_passwd_none,
    sec_passwd_plain,
    sec_passwd_des,
    sec_passwd_pubkey,
    sec_passwd_genprivkey
} sec_passwd_type_t;


typedef  struct {
    sec_passwd_version_t  version_number;
    [string, ptr] char    *pepper;

    union switch (sec_passwd_type_t key_type) {

        case sec_passwd_plain:
            [string, ptr] char    *plain;

        case sec_passwd_des:
            sec_passwd_des_key_t  des_key;

        case sec_passwd_pubkey:
            sec_pk_data_t         pub_key;

        case sec_passwd_genprivkey:
            unsigned32            modulus_size;

    } key;
} sec_passwd_rec_t;
}
...\" END /dce/src/security/idl/passwd.idl
.cF
.P
.H 2 "pre_auth_req ERA"
.P
The existing \*(lBpre_auth_req\*(lE ERA is extended by the addition of
one more value.  The semantics remain consistent: pre-authentication
protocols associated with values lower than the value of the
\*(lBpre_auth_req\*(lE ERA are rejected by the KDC.
.P
.cS
Attribute Name: pre_auth_req
Attribute UUID: 6c9d0ec8-dd2d-11cc-abdd-080009353559
Attribute Encoding: sec_attr_enc_integer
ACL Manager Type: 06ab9320-0191-11ca-a9e8-08001e039d7d
Query Permissions Set:  sec_acl_perm_mgmt_info,
Update Permissions Set: sec_acl_perm_mgmt_info
Test Permissions Set:   sec_acl_perm_mgmt_info
Delete Permissions Set: sec_acl_perm_mgmt_info
Unique: TRUE
Reserved: TRUE
Intercell Action: REJECT
Trigger Type: NONE
Trigger Binding: NULL
Scope: ""
Multi-valued: FALSE
Comment: "values: {0=NONE, 1=PADATA_ENC_TIMESTAMPS,
          2=PADATA_ENC_THIRD_PARTY, 3=PADATA_ENC_PUBLIC_KEY}"
.cF
.P
.H 2 "DCEPKKeyEncipherment ERA"
.P
The \*(lBDCEPKKeyEncipherment\*(lE ERA is a reserved ERA that may be
attached to any principal object to hold the public key used in the
DCE authentication protocol to encrypt DCE session (conversation) keys
for that principal.
.P
The format of the \*(lBDCEPKKeyEncipherment\*(lE ERA is an IDL-encoded
byte-string of type \*(lBsec_passwd_rec_t\*(lE with key type \*(lBsec_passwd_pubkey\*(lE.
.P
.cS
Attribute Name: DCEPKKeyEncipherment
Attribute UUID: 76251f8c-6230-11cf-af89-08000919ebb5
Attribute Encoding: sec_attr_enc_bytes
ACL Manager Type: 06ab9320-0191-11ca-a9e8-08001e039d7d
Query Permissions Set:  sec_acl_perm_read
Update Permissions Set: sec_acl_perm_mgmt_info
Test Permissions Set:   sec_acl_perm_read
Delete Permissions Set: sec_acl_perm_mgmt_info
Unique: TRUE
Reserved: TRUE
Intercell Action: ACCEPT
Trigger Type: NONE
Trigger Binding: NULL
Scope: ""
Multi-valued: FALSE
Comment: "The principal's DCE key encryption public key value; an
          X.509 SubjectPublicKeyInfo value in ASN.1 DER format."
.cF
.P
.H 2 "DCEPKAuthentication ERA"
.P
The \*(lBDCEPKAuthentication\*(lE ERA is a reserved ERA that may be
attached to any user principal to hold the public key used in the DCE
authentication protocol to verify a signature from that user.
The \*(lBDCEPKAuthentication\*(lE ERA attached to the
cell's \*(lBkrbtgt\*(lE principal is the public key used by the
client to verify a
signature from the DCE KDC during DCE authentication.
The \*(lBDCEPKAuthentication\*(lE ERA attached to the
client principal is the public key used by the
KDC to verify a
signature from the client during DCE authentication.
.P
The format of the \*(lBDCEPKKeyEncipherment\*(lE ERA is an IDL-encoded
byte-string of type \*(lBsec_passwd_rec_t\*(lE with key type \*(lBsec_passwd_pubkey\*(lE.
.P
.cS
Attribute Name: DCEPKAuthentication
Attribute UUID: d44dc60e-6230-11cf-98ed-08000919ebb5
Attribute Encoding: sec_attr_enc_bytes
ACL Manager Type: 06ab9320-0191-11ca-a9e8-08001e039d7d
Query Permissions Set:  sec_acl_perm_read
Update Permissions Set: sec_acl_perm_mgmt_info
Test Permissions Set:   sec_acl_perm_read
Delete Permissions Set: sec_acl_perm_mgmt_info
Unique: TRUE
Reserved: TRUE
Intercell Action: ACCEPT
Trigger Type: NONE
Trigger Binding: NULL
Scope: ""
Multi-valued: FALSE
Comment: "The principal's DCE authentication public key value; an
          X.509 SubjectPublicKeyInfo value in ASN.1 DER format."
.cF
.P
.H 2 "DCEPKPrivateKeyStorage ERA"
.P
The \*(lBDCEPKPrivateKeyStorage\*(lE ERA is a reserved ERA that may be
attached to any user principal to identify the private key storage mechanism
of that user.
.P
The format of the \*(lBDCEPKPrivateKeyStorage\*(lE ERA is a UUID.
.P
.cS
Attribute Name: DCEPKPrivateKeyStorage
Attribute UUID: 1f79c78e-b026-11cf-b7c8-0800090a5254
Attribute Encoding: sec_attr_enc_uuid
ACL Manager Type: 06ab9320-0191-11ca-a9e8-08001e039d7d
Query Permissions Set:  sec_acl_perm_mgmt_info
Update Permissions Set: sec_acl_perm_mgmt_info
Test Permissions Set:   sec_acl_perm_mgmt_info
Delete Permissions Set: sec_acl_perm_mgmt_info
Unique: TRUE
Reserved: TRUE
Intercell Action: Reject
Trigger Type: NONE
Trigger Binding: NULL
Scope: ""
Multi-valued: FALSE
Comment: "Values: sec_psm_pkss_mechanism,
          sec_psm_file_mechanism,
          sec_psm_kdc_pk_init_mechanism"
.cF
.P
.H 1 "USER INTERFACES"
.P
.H 2 "Login"
.P
User interfaces to login utilities have not changed, except that
additional new error conditions may be reported.
.P
Login utilities such as \*(lBdce_login\*(lE invoke the existing
\*(lBsec_login\*(lE API, which changes only by the addition of
new error status values that can be returned.  Login utilities
still need to prompt for a user name and a
password.
.P
The \*(qBpassword\*(qE that the user supplies is first
tried by \*(lBsec_login\*(lE as a passphrase to access the user's
Personal Security Module.  If there is no Personal Security
Module, or if the passphrase fails to unlock the module, the
\*(qBpassword\*(qE is then tried automatically as a DCE password (unless the user is
identified as requiring public key).  See \*(qBTGT Acquisition
Protocol\*(qE under \*(qBFUNCTIONAL DEFINITION\*(qE for more
information.
.P
.H 2 "Key Storage and Retrieval"
.P
The existing \*(lBdcecp\*(lE user interface for reading and
writing ERA values may be used to read
or write the \*(lBDCEPKKeyEncipherment\*(lE,
\*(lBDCEPKAuthentication\*(lE, \*(lBDCEPKPrivateKeyStorage\*(lE, or \*(lBpre_auth_req\*(lE ERAs.
.P
The \*(lBDCEPKAuthentication\*(lE and \*(lBDCEPKKeyEncipherment\*(lE
 attributes must be IDL-encoded
byte-strings of type \*(lBsec_passwd_rec_t\*(lE with key type
\*(lBsec_passwd_pubkey\*(lE.
.P
New options for manipulating public and private key values
are defined for the \*(lBdcecp> account create\*(lE and \*(lBdcecp> account modify\*(lE
commands.  These allow setting a principal's private key value in
the Personal Security Module, and setting the
corresponding public key value in the DCE Registry.
.P
There is no user interface provided for reading the value of a
principal's private key.
.P
.H 3 "Existing dcecp operations for public key"
.P
Examples of accessing public key information using existing operations:
.P
.cS
dcecp> principal show <principal> -xattr
{DCEPKAuthentication {30 81 9f 30 0d 06 09 2a 86 48 86 f7 0d  \e
  01 01 01 05 00 03 81 \e
  8d 00 30 81 89 02 81 81 00 b3 b2 02 84 85 ea cf 0e b8 3e c6 \e
  7f c2 16 ff ea 30 79 cf a2 20 2f c5 ea 43 dc e5 39 f1 01 d2 \e
  50 52 7c 54 a9 2e 02 c3 8c 57 0c b5 46 b4 4b 0c 20 1d c6 66 \e
  6d 70 16 c2 d3 f2 39 0f 1a 3a 44 f1 ee 35 dd fb 16 77 e6 a7 \e
  6c c6 86 ba f5 e9 a2 54 54 60 43 7a 2e cd dd 36 0d 8e 0a 03 \e
  4f 12 22 95 ff e1 da 3e 25 b1 fb 0a ce f7 9d 95 a2 89 0b bd \e
  a6 9a c9 ec d7 c4 e4 4b 89 26 29 30 67 8f 14 89 b5 02 03 01 \e
  00 01}}
{DCEPKKeyEncipherment {30 81 9f 30 0d 06 09 2a 86 48 86 f7 0d \e
  01 01 01 05 00 03 81 \e
  8d 00 30 81 89 02 81 81 00 b2 c4 c2 b9 cd c3 9b 3b 8f 54 35 \e
  88 fc 22 8e 39 cd 3d 25 99 62 87 f0 0c 00 b9 55 cd f4 a4 b5 \e
  39 25 94 ee 23 5a 35 c6 da 2f 6f 5a a5 9a a3 b4 22 91 43 bf \e
  68 3d e8 51 63 43 d0 56 ba c0 86 a3 b2 10 1d e0 05 7e 34 b8 \e
  90 4a ed 06 88 ce 3e 52 08 ad 5a 2a ae 7c 3f 0a ce 3b 40 8f \e
  03 48 79 7d bd 6e c2 7e 3d 37 5e 8a 63 ff e8 09 5b 93 ad 04 \e
  12 ca d9 f2 2f 74 14 c6 c9 79 c5 34 cb 93 71 f9 5d 02 03 01 \e
  00 01}}
{DCEPKPrivateKeyStorage 8687c5b8-b01a-11cf-b137-0800090a5254}
{pre_auth_req 3}

dcecp> principal show krbtgt/<cell> -xattr
{DCEPKAuthentication {30 81 9f 30 0d 06 09 2a 86 48 86 f7 0d  \e
  01 01 01 05 00 03 81 \e
  8d 00 30 81 89 02 81 81 00 c3 6d 50 5f 28 da 55 e1 fb 94 ac \e
  2a 29 16 44 bd 62 d0 61 c5 e1 cd f2 a1 3a f6 1c e7 40 11 0a \e
  4d eb 80 38 5a b7 1b bf 25 ae 68 6b bc d7 ad 05 27 67 5b c3 \e
  bb f7 66 23 4b 59 a4 3f 9f 74 e1 a1 4a a5 9c 86 9c 23 58 b3 \e
  3f a9 45 5d d5 e6 33 21 79 4d 86 dd 35 2f fb a2 f6 59 76 ec \e
  06 b9 2d 5c 5c 75 61 c7 b4 ec 50 6d 30 02 6d d5 0a 45 ad 06 \e
  54 4e 60 c4 f8 77 3b 6c da 58 5d 99 f6 37 cb cb 3d 02 03 01 \e
  00 01}}
{DCEPKPrivateKeyStorage adb48ed4-e94d-11cf-ab4b-08000919ebb5}

dcecp> principal modify <principal> [ -add | -change ] \e
       {pre_auth_req 3}
.cF
.H 3 "New dcecp operations for public key"
.P
New options have been added to \*(lBdcecp\*(lE to assist cell
administrators in setting up accounts to use public key login.
.P
Syntax of new account create and modify options:
.P
.cS
Attribute name       Value
--------------       -----
-pkmechanism         file | pkss
-pksignatureusage    {<pk_attributes>}
-pkkeycipherusage    {<pk_attributes>}

pk_attributes        Value
-------------        -----
generatekey          Integer: value "default" or desired modulus size
privatekeyfile       File system path to private key
publickeyfile        File system path to public key
oldpassphrase        Passphrase string
newpassphrase        Passphrase string
.cF
.P
The value of the \*(lBgeneratekey\*(lE option
is the desired modulus size for the key.
.nS
In the reference implementation,
the default value for generatekey, indicated by specifying
the parameter value \*(lBdefault\*(lE, is 1024.
.nF
.P
\*(lB{publickeyfile ...}\*(lE and \*(lB{privatekeyfile ...}\*(lE
 may not be used together with \*(lB{generatekey  ...}\*(lE.
.P
\*(lB{publickeyfile ...}\*(lE and \*(lB{privatekeyfile ...}\*(lE
must always be specified together: if you have one, you must have the other.
.P
The \*(lB{newpassphrase ...}\*(lE for the \*(lB-pksignatureusage\*(lE
option must be the same as the \*(lB{newpassphrase ...}\*(lE
for the \*(lB-pkkeycipherusage\*(lE option.
.P
Examples:
.P
.H 4 "Setting up a public key account"
.P
.cS
dcecp> account create pk_account -group none
       -organization none -password pk_pwd
       -mypwd -dce-
       -pkmechanism file
       -pksignatureusage {
           {generatekey default}
           {newpassphrase pk_pass}
       }
       -pkkeycipherusage {
           {generatekey 512}
           {newpassphrase pk_pass}
       }
.cF
.P
.H 4 "Changing a key-pair obtained from an external source"
.P
.cS
dcecp> account modify pk_account
       -pksignatureusage {
           {privatekeyfile /tmp/pk_account.sigkeypvt}
           {publickeyfile /tmp/pk_account.sigkeypub}
           {oldpassphrase pk_pass}
       }
.cF
.P
.H 4 "Changing passphrase on existing keys"
.P
.cS
dcecp> account modify pk_account
       -pksignatureusage {
           {oldpassphrase pk_pass}
           {newpassphrase pk_pwd}
       }
       -pkkeycipherusage {
           {oldpassphrase pk_pass}
           {newpassphrase pk_pwd}
       }
.cF
.P
Key values obtained from an external source must be stored in a file
with identifying header information.
The \*(lBsec_pubkey_write_keyfile()\*(lE API may be used to
write a key value to a file in the correct format.
.P
It is up to the user to ensure that public and private key values
supplied to the user interfaces are
consistent with each other and are valid public key key-pairs.
.P
.H 2 "KDC Key Update"
.P
In order to allow a cell administrator to update the public key pair
of the DCE Security Server (KDC), a new \*(lB-pkgenprivkey\*(lE option
to the \*(lBdcecp> account modify\*(lE command is provided.
.P
Example:
.P
.cS
dcecp -c account modify krbtgt/dc.cell.ch.hp.com
     -pkgenprivkey default
.cF
.P
This option is invalid
except when used on the account of the \*(lBkrbtgt\*(lE principal of
the local cell.  It is also invalid except when executed by a user having
cell administrator privileges.
.P
The value of the \*(lB-pkgenprivkey\*(lE option is the desired modulus
size of the key to be generated.  It is recommended that KDC keys be
at least 1024 bits long.
.nS
In the reference implementation,
the default value for \*(lB-pkgenprivkey\*(lE, indicated by specifying
the parameter value \*(lBdefault\*(lE, is 1024.
.nF
.P
.H 1 "APIs and Interfaces"
.P
.H 2 "DCE Personal Security Module Interface"
.P
The interface to the DCE personal Security Module (\*(lBPSM\*(lE) Interface is defined in a new file
\*(lBsecurity/idl/sec_psm.idl\*(lE, listed here:
.P
.cS
...\" .so /dce/src/security/idl/sec_psm.idl
/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1996 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE
 * in the src directory for the full copyright text.
 */
/*
 * Copyright (c) Hewlett-Packard Company 1996
 * Unpublished work.  All Rights Reserved.
 *
 *       Personal Security Module (PSM) Interface
 *
 */

[
    local
]

interface sec_psm

{

    import "dce/sec_pk_base.idl";

    typedef void *sec_psm_handle_t;

/* PSM API */

/* sec_psm_open
 *
 * Open the personal security mechanism using password.
 *
 * Return status
 *   error_status_ok:    Success.
 *   other (non-zero):   sec_pvtkey_privileged
 *                       sec_pvtkey_no_more_memory
 *                       sec_psm_no_more_memory
 *
 * Input
 *
 *   name: Pointer to the user's canonical name within the
 *         specified domain.
 *   pwd: Pointer to the user's password.
 *   domain_id: Pointer to the application domain the user
 *              is operating on.
 *
 * Output
 *
 *   psm_handle: Pointer to an opaque handle to the personal
 *               security context data.
 *
 */

error_status_t sec_psm_open(
    [in]  void               *name,
    [in]  char               *pwd,
    [in]  sec_pk_domain_t    *domain_id,
    [out] sec_psm_handle_t   *psm_handle
);


/* sec_psm_close
 *
 * Close the personal security mechanism and cleanup the
 * personal security context data.  It also ensures any
 * confidential information such as passwords or private
 * key are zeroed.
 *
 * Return status
 *   error_status_ok:   Success.
 *   other (non-zero):  sec_psm_not_init
 *                      sec_psm_invalid_handle
 *                      sec_psm_internal_error
 *                      sec_pvtkey_invalid_handle
 *                      sec_pvtkey_mechanism_not_init
 *
 * Input
 *
 *   psm_handle: Pointer to an opaque handle to the personal
 *               security context data.  This handle should be
 *               obtained through sec_psm_open().
 *
 */

error_status_t sec_psm_close(
    [in]  sec_psm_handle_t    psm_handle
);

/* sec_psm_sign_data
 *
 * Compute the signature of the input data using the
 * signature algorithm specified in the arguments.
 *
 * The routine allocates memory for the data returned in
 * the signature parameter.  Users should call
 * sec_pk_data_free() to deallocate that memory.
 *
 * Return status
 *   error_status_ok:   Success.
 *   other (non-zero):  sec_psm_not_init
 *                      sec_psm_invalid_handle
 *                      sec_psm_unsupported_algorithm_id
 *                      sec_pvtkey_invalid_handle
 *                      sec_pvtkey_mechanism_not_init
 *                      sec_pvtkey_internal_error
 *                      sec_pvtkey_invalid_password
 *                      sec_pvtkey_multiple_key_usages
 *
 * Input
 *
 *   psm_handle: Pointer to an opaque handle to the personal
 *               security context data.  This handle should be
 *               obtained through sec_psm_open().
 *   signature_alg_id: The ASN.1 DER-encoded object ID of
 *               the signature algorithm, such as
 *               MD5WithRSAEncryption.
 *   key_usage: The usage of the private key which should be
 *              picked for this operation.
 *   data: Pointer to the ASN.1 DER-encoded data to be signed.
 *
 * Output
 *
 *   kvno: Key version number of the key used.
 *   signature: Pointer to a signature buffer pointer.
 *
 */

error_status_t sec_psm_sign_data(
    [in]  sec_psm_handle_t        psm_handle,
    [in]  sec_pk_algorithm_id_t   *signature_alg_id,
    [in]  sec_pk_usage_flags_t    key_usage,
    [in]  sec_pk_gen_data_t       *data,
    [out] unsigned32              *kvno,
    [out] sec_pk_signed_t         *signature
);


/* sec_psm_verify_data
 *
 * Verify the data.  Usually, you verify other people's signature.
 *
 * Return status
 *   error_status_ok:   Success.
 *   other (non-zero):  sec_psm_not_init
 *                      sec_psm_invalid_handle
 *                      sec_psm_unsupported_algorithm_id
 *                      sec_bsafe_decryption_failure
 *                      sec_pk_e_domain_unsupported,
 *                      sec_pk_e_usage_unsupported,
 *                      sec_rgy_object_not_found,
 *                      sec_rgy_not_authorized,
 *                      sec_attr_unauthorized
 *
 * Input
 *
 *   psm_handle: Pointer to an opaque handle to the personal
 *               security context data.  This handle should be
 *               obtained through sec_psm_open().
 *   signer_domain: pointer to the application domain of the
 *              principal; [see the sec_pubkey interface for more
 *              details.]
 *   signer_name: Pointer to the name of the principal which had
 *               signedthe data.
 *   kvno: Key version number of the key used.
 *   signature_alg_id: The ASN.1 DER-encoded object ID of the
 *              signature algorithm, such as MD5WithRSAEncryption.
 *   key_usage: The usage of the ;public key which should be
 *              picked for this operation.
 *   data: Pointer to the data to be verified
 *   signature: Pointer to the signature to be verified.
 *
 */

error_status_t sec_psm_verify_data(
    [in]  sec_psm_handle_t        psm_handle,
    [in]  sec_pk_domain_t         *signer_domain_id,
    [in]  void                    *signer_name,
    [in]  unsigned32              kvno,
    [in]  sec_pk_algorithm_id_t   *signature_alg_id,
    [in]  sec_pk_usage_flags_t    key_usage,
    [in]  sec_pk_gen_data_t       *data,
    [in]  sec_pk_signed_t         *signature
);


/* sec_psm_encrypt_data
 *
 * Encrypt the data in the algorithm specified.  The routine
 * allocates memory for the data returned in the cipher_data
 * parameter.  Users should call sec_pk_data_free() to
 * deallocate that memory.
 *
 * For reference implementation, only keyEncipherment key_usage
 * will be implemented.
 *
 * Usually you encrypt the data with other's public key.
 *
 * Return status
 *   error_status_ok:   Success.
 *   other (non-zero):  sec_psm_not_init
 *                      sec_psm_invalid_handle
 *                      sec_psm_unsupported_algorithm_id
 *                      sec_pk_e_domain_unsupported,
 *                      sec_pk_e_usage_unsupported,
 *                      sec_rgy_object_not_found,
 *                      sec_rgy_not_authorized,
 *                      sec_attr_unauthorized
 *
 * Input
 *
 *   psm_handle: Pointer to an opaque handle to the personal
 *               security context data.  This handle should be
 *               obtained through sec_psm_open().
 *   encryptee_domain: pointer to the application domain
 *               of the principal;
 *              [see the sec_pubkey interface for more details.]
 *   encryptee_name: Pointer to the name of the principal this
 *              data is encrypted for.
 *   encryption_alg_id: The ASN.1 DER-encoded object ID of
 *              encryption algorithm, such as RSA.
 *   key_usage: The usage of the public key this key pair
 *              belongs to.
 *   clear_data: Pointer to the ASN.1 DER-encoded data to be
 *               encrypted.
 *
 * Input, output
 *
 *   kvno: Key version number of the key used.
 *
 * Output
 *
 *   cipher_data: Pointer to the encrypted output buffer.
 */

error_status_t sec_psm_encrypt_data(
    [in]  sec_psm_handle_t              psm_handle,
    [in]  sec_pk_domain_t               *encryptee_domain,
    [in]  void                          *encryptee_name,
    [in,out]  unsigned32                *kvno,
    [in]  sec_pk_algorithm_id_t         *encryption_alg_id,
    [in]  sec_pk_usage_flags_t          key_usage,
    [in]  sec_pk_gen_data_t             *clear_data,
    [out] sec_pk_encrypted_t            *cipher_data
);

/* sec_psm_decrypt_data
 *
 * Decrypt the mechanism-specific encrypted data. The routine
 * allocates memory for the data returned in the clear_data
 * parameter.  Users should call sec_pk_data_free() to
 * deallocate that memory.
 *
 * For reference implementation, only keyEncipherment key_usage
 * will be implemented.
 *
 * Usually you decrypted the data with your own private key.
 *
 * Return status
 *   error_status_ok:   Success.
 *   other (non-zero):  sec_psm_not_init
 *                      sec_psm_invalid_handle
 *                      sec_psm_unsupported_algorithm_id
 *                      sec_bsafe_encryption_failure
 *                      sec_pvtkey_invalid_handle
 *                      sec_pvtkey_mechanism_not_init
 *                      sec_pvtkey_internal_error
 *                      sec_pvtkey_invalid_password
 *                      sec_pvtkey_multiple_key_usages
 *
 * Input
 *
 *   psm_handle: Pointer to an opaque handle to the personal
 *               security context data.  This handle should be
 *               obtained through sec_psm_open().
 *   kvno: Key version number of the key used.
 *   encryption_alg_id: The ASN.1 DER-encoded object ID of
 *               encryption algorithm, such as RSA.
 *   key_usage: The usage of the private key which should be
 *              picked for this operation.
 *   cipher_data: Pointer to encrypted cipher buffer.
 *
 * Output
 *
 *   clear_data: Pointer to decrypted clear text
 *                buffer pointer.
 */

error_status_t sec_psm_decrypt_data(
    [in]  sec_psm_handle_t              psm_handle,
    [in]  unsigned32                    kvno,
    [in]  sec_pk_algorithm_id_t         *encryption_alg_id,
    [in]  sec_pk_usage_flags_t          key_usage,
    [in]  sec_pk_encrypted_t            *cipher_data,
    [out] sec_pk_gen_data_t             *clear_data
);


/* sec_psm_gen_pub_key
 *
 * Generate public key according to key type.  The routine
 * allocates memory for the data returned in the key
 * parameters.  Users should call sec_pk_data_free() to
 * deallocate that memory.
 *
 * Currently it only supports RSADSI's public key.
 *
 * Return status
 *   error_status_ok:    Success.
 *   other (non-zero):   sec_psm_wrong_pub_key_type
 *                       sec_bsafe_alloc
 *
 * Input
 *
 *    key_type: Only RSA_PKCS is supported.
 *
 *    modulus_bit_size: Desired key-length.  The length of the
 *                       desired key.  Interpretation of this
 *                       parameter is algorithm-dependent; For RSA,
 *                       it shall be interpreted as the bit-length of
 *                       the key.
 *
 * Output
 *
 *    private_key:  Pointer to the encoded private key structure of
 *                  the newly-generated key.
 *    public_key: Pointer to the encoded public key structure of the
 *                 newly-generated key.
 *
 */

error_status_t sec_psm_gen_pub_key(
    [in]  sec_pk_algorithm_id_t   *key_type,
    [in]  unsigned32              modulus_bit_size,
    [in]  sec_pk_gen_data_t       *seed,
    [out] sec_pk_data_t           *public_key,
    [out] sec_pk_data_t           *private_key
);

/* ADMINISTRATIVE INTERFACES */

/* sec_psm_put_pub_key
 *
 * Store the public key pair with associated data into the personal
 * security mechanism.
 *
 * Return status
 *   error_status_ok:   Success.
 *   other (non-zero):  sec_psm_not_init
 *                      sec_psm_invalid_handle
 *                      sec_pk_e_domain_unsupported,
 *                      sec_pk_e_usage_unsupported,
 *                      sec_rgy_object_not_found,
 *                      sec_rgy_not_authorized,
 *                      sec_attr_unauthorized
 *                      sec_pvtkey_invalid_handle
 *                      sec_pvtkey_mechanism_not_init
 *                      sec_pvtkey_no_more_memory
 *                      sec_pvtkey_internal_error
 *      sec_pvtkey_same_domain_and_usage_key_already_exists.
 *
 * Input
 *
 *   psm_handle: Pointer to an opaque handle to the personal
 *               security context data.  This handle should be
 *               obtained through sec_psm_open().
 *   pwd:  Pointer to the user's password.
 *   key_usage: The usage of the public key this key pair
 *              belongs to.
 *   pvtkey: Pointer to the ASN.1 DER-encoded private key buffer.
 *   pubkey: Pointer to the ASN.1 DER-encoded public key buffer.
 *
 */

error_status_t sec_psm_put_pub_key(
    [in]  sec_psm_handle_t       psm_handle,
    [in]  char                   *pwd,
    [in]  sec_pk_usage_flags_t   key_usage,
    [in]  sec_pk_pubkey_t        *public_key,
    [in]  sec_pk_pvtkey_t        *private_key
);

/* sec_psm_update_pub_key
 *
 * Update the user's own public key pair or passphrase. The
 * oldpassphrase is specified to authenticate the user updating the
 * key.
 *
 * In the reference implementation, only a single version of a key
 * with a given key usage will be maintained.  Any old key version
 * will be overwritten.
 *
 * Return status
 *   error_status_ok:   Success.
 *   other (non-zero):  sec_psm_not_init
 *                      sec_psm_invalid_handle
 *                      sec_pk_e_domain_unsupported,
 *                      sec_pk_e_usage_unsupported,
 *                      sec_rgy_object_not_found,
 *                      sec_rgy_not_authorized,
 *                      sec_attr_unauthorized
 *                      sec_pvtkey_invalid_handle
 *                      sec_pvtkey_mechanism_not_init
 *                      sec_pvtkey_private_key_is_not_supplied
 *                      sec_pvtkey_new_password_required
 *                      sec_pvtkey_no_more_memory
 *                      sec_pvtkey_internal_error
 *                      sec_pvtkey_no_matched_private_key
 *                      sec_pvtkey_Invalid_password.
 *
 * Input
 *
 *   psm_handle: Pointer to an opaque handle to the personal
 *               security context data.  This handle should be
 *               obtained through sec_psm_open().
 *   oldpwd:  Pointer to the user's current password.
 *   newpwd:  Pointer to the user's new password.
 *   key_usage: The usage of the public key this key pair
 *              belongs to.
 *   pvtkey: Pointer to the ASN.1 DER-encoded private key buffer.
 *   pubkey: Pointer to the ASN.1 DER-encoded public key buffer.
 *
 */

error_status_t sec_psm_update_pub_key(
    [in]  sec_psm_handle_t       psm_handle,
    [in]  char                   *oldpwd,
    [in]  char                   *newpwd,
    [in]  sec_pk_usage_flags_t   key_usage,
    [in]  sec_pk_pubkey_t        *public_key,
    [in]  sec_pk_pvtkey_t        *private_key
);

}
...\" END /dce/src/security/idl/sec_psm.idl
.cF
.H 2 "DCE Public Key Module API"
.P
The interface to the DCE Public Key Module API is defined in a new file
\*(lBsecurity/idl/sec_pubkey.idl\*(lE, listed here:
.P
.cS
...\" .so /dce/src/security/idl/sec_pubkey.idl
/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1996 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE
 * for the full copyright text.
 */
/*
** Copyright (c) Hewlett-Packard Company 1996
** Unpublished work.  All Rights Reserved.
**
**   Public Key Storage and Retrieval Interface
*/

[
    local
]

interface sec_pubkey {

import "dce/rgynbase.idl";
import "dce/sec_pk_base.idl";

typedef error_status_t (*sec_pk_key_retrieval_fn_t)(
            [in] void *principal,
            [in] sec_pk_domain_t *domain,
            [in] sec_pk_usage_flags_t usage,
            [in,out] unsigned32 *kvno,
            [out] sec_pk_pubkey_t *pubkey_p
);

typedef error_status_t (*sec_pk_key_storage_fn_t)(
            [in] void *principal,
            [in] sec_pk_domain_t *domain,
            [in] sec_pk_usage_flags_t usage,
            [in,out] unsigned32 *kvno,
            [in] sec_pk_pubkey_t *pubkey_p
);

typedef struct
{
    sec_pk_domain_t domain;
    sec_pk_key_retrieval_fn_t r;
    sec_pk_key_storage_fn_t s;
} sec_pk_domain_def;

/*
 * s e c _ p u b k e y _ d e f i n e _ d o m a i n
 *
 * Define a public key storage domain.
 *
 * This extends the set of domains supported by the other
 * sec_pubkey functions within the current process.
 *
 * This is used to define "new" domains within the KDC
 * and within the pk-init client which fetch public keys directly
 * from known trusted sources.
 *
 * domain -- the new domain to define.
 *
 * retrieve -- pointer to a function which retrieves a public key,
 *     or NULL if retrievals are not possible in this domain.
 *
 * store -- pointer to a function which stores a public key,
 *     or NULL if storage is not possible in this domain.
 */
error_status_t sec_pubkey_define_domain (
    sec_pk_domain_t *domain,
    sec_pk_key_retrieval_fn_t retrieve,
    sec_pk_key_retrieval_fn_t store
);

/*
 * s e c _ p u b k e y _ f i n d _ d o m a i n
 *
 * find the functions implementing a public key storage domain.
 *
 * domain -- the domain to find.
 *
 * Returns NULL if domain is not implemented.
 */
sec_pk_domain_def *sec_pubkey_find_domain(
    sec_pk_domain_t *domain
);

/* PUBLIC KEY STORAGE AND RETRIEVAL OPERATIONS
 *
 * These interfaces are used within the sec_psm interface,
 * and the sec_login interface, but may also be used
 * directly by user applications.
 *
 */

/* s e c _ p u b k e y _ s t o r e
 *
 * Function:
 *     Store a public key value for a principal
 *
 *     Stores an X.509 DER-encoded public key value of type
 *     SubjectPublicKeyInfo in the public key storage
 *     facility.  This operation overwrites any
 *     existing public key storage for <principal>, and
 *     creates public key storage if none exists.
 *
 *     In the reference implementation:
 *     - only the sec_pk_domain_dce_pk_login domain
 *       supports the sec_pubkey_store operation
 *     - usage must be either sec_pk_usage_digitalSignature,
 *       sec_pk_usage_keyEncipherment, or both.
 *     - If usage is sec_pk_usage_digitalSignature the public
 *       key is stored in the DCEPKAuthentication ERA attached
 *       to the principal.
 *     - If usage is sec_pk_usage_keyEncipherment, the public key is
 *       stored in the DCEPKKeyEncipherment ERA.
 *
 *     Default ACLs for the reference implementation on the
 *     underlying ERA storage locations will allow only a
 *     principal with sec_admin privileges to perform
 *     this operation.  Sites may choose to modify the ACLs
 *     on the underlying ERAs to allow the owner principal
 *     to modify the public key as well, although sites
 *     should be aware that ability to modify a principal's
 *     public key equates to the ability to impersonate the
 *     principal.
 *
 * In Parameters:
 *     principal  - the canonical name in the specified
 *                  domain of the principal whose public
 *                  key is being stored (sec_rgy_name_t
 *                  containing /.../cell/principal in
 *                  reference implementation)
 *     domain     - a UUID identifying the domain in which
 *                  the key is used
 *                  (sec_pk_domain_dce_pk_login in
 *                  reference implementation)
 *     usage      - usage(s) of the key being stored
 *                  (sec_pk_usage_digitalSignature,
 *                  sec_pk_usage_keyEncipherment, or both
 *                  in reference implementation)
 *     kvno       - key version; if 0,
 *                  retrieves newest version.
 *     pubkey_p   - pointer to an X.509 DER-encoded public key
 *                  value of type SubjectPublicKeyInfo
 *
 * Out Parameters:
 *     None
 *
 * Errors:
 *     error_status_ok
 *     sec_pk_e_domain_unsupported,
 *     sec_pk_e_usage_unsupported,
 *     sec_pk_e_key_vers_unsupported
 *     sec_pk_e_no_memory
 *
 * Errors passed through from:
 *     uuid_equal
 *     sec_rgy_attr_update
 */
error_status_t sec_pubkey_store (
    [in]  void                  *principal,
    [in]  sec_pk_domain_t       *domain,
    [in]  sec_pk_usage_flags_t  usage,
    [in,out]  unsigned32            *kvno,
    [in]  sec_pk_pubkey_t     *pubkey_p
);

/* s e c _ p u b k e y _ r e t r i e v e
 *
 * Function:
 *     Retrieves an X.509 DER-encoded public key value with
 *     type SubjectPublicKeyInfo from the public key
 *     storage facility for a given principal.
 *
 *     In the reference implementation:
 *     - usage must be either sec_pk_usage_digitalSignature or
 *       sec_pk_usage_keyEncipherment
 *     - If usage is sec_pk_usage_digitalSignature the
 *       public key is retrieved from the
 *       DCEPKAuthentication ERA attached to the
 *       principal.
 *     - If usage is sec_pk_usage_keyEncipherment, the
 *       public key is retrieved from the
 *       DCEPKKeyEncipherment ERA.
 *
 *     Default ACLs for the reference implementation allow
 *     any principal to perform this operation.
 *
 * In Parameters:
 *     principal  - the canonical name in the specified
 *                  domain of the principal whose public
 *                  key is being retrieved
 *                  (sec_rgy_name_t in reference
 *                   implementation)
 *     domain     - a UUID identifying the domain in which
 *                  the key is used
 *     usage      - usage of the key being retrieved
 *                  (sec_pk_usage_digitalSignature, or
 *                  sec_pk_usage_keyEncipherment, but not
 *                   both, in reference implementation)
 *     kvno       - key version to be retrieved; if 0,
 *                  retrieves newest version.
 *
 * Out Parameters:
 *     pubkey_p   - pointer to an X.509 DER-encoded
 *                  public key value of type
 *                  SubjectPublicKeyInfo; storage for this
 *                  structure must be freed using the
 *                  sec_pk_data_free() function.
 *
 * Errors:
 *     error_status_ok
 *     sec_pk_e_key_vers_unsupported
 *     sec_pk_e_usage_unsupported
 *     sec_pk_e_key_attr_read_failed
 *     sec_pk_e_no_memory
 *
 * Errors passed through from:
 *     sec_id_global_parse_name
 *     sec_rgy_cell_bind
 *     sec_rgy_attr_cursor_alloc
 *     sec_rgy_attr_lookup_by_id
 *     uuid_equal
 */
error_status_t sec_pubkey_retrieve (
    [in]  void                   *principal,
    [in]  sec_pk_domain_t        *domain,
    [in]  sec_pk_usage_flags_t   usage,
    [in,out]  unsigned32         *kvno,
    [out] sec_pk_pubkey_t        *pubkey_p
);

/* s e c _ p u b k e y _ r e a d _ k e y f i l e
 *
 * Function:
 *    Read a key from a keyfile.  Keyfile is assumed
 *    to have format as follows:
 *    unsigned32  'P' 'K' 'E' 'Y'
 *    unsigned32  file format version# (must be 1 or 2)
 *    unsigned32  key_version (file format version 2 only)
 *    unsigned32  key_length
 *    byte        key[key_length]
 *
 * In Parameters:
 *    keyfilepath      -path to keyfile
 *    key_version_p    -NULL or pointer to key version number
 *                      desired; if 0, any key version accepted
 *
 * Out Parameters:
 *    key_version_p    -NULL or pointer to key version number
 *                      being returned
 *    file_fmt_ver_p   -address of file format version (NULL if
 *                      no output file format desired).  This will
 *                      be returned if it can be read, even if
 *                      version does not match or key can't be read.
 *    key_ret_p        -address of sec_pk_data_t key; caller must
 *                      allocate the sec_pk_data_t before calling
 *                      this function.  The caller must
 *                      deallocate key.data (and, if malloc'd,
 *                      key) when finished.  In the case of a
 *                      private key, key.data should be zeroed
 *                      before being deallocated.
 *
 * Errors:
 *     sec_pk_e_kf_param_not_alloc - A parameter other than
 *                                   file_fmt_ver_p NULL
 *     sec_pk_e_kf_open_err        - error opening the keyfile
 *     sec_pk_e_kf_read_err        - error reading the keyfile
 *     sec_pk_e_kf_format_err      - keyfile did not start with
 *                                   'P''K''E''Y'
 *     sec_pk_e_kf_version_err     - keyfile version not 1 or 2
 *     sec_pk_e_no_memory          - unable to allocate memory for
 *                                   key data
 */
error_status_t sec_pubkey_read_keyfile(
    [in]     char          *keyfilepath,
    [in]     unsigned32    *file_fmt_ver_p,
    [in,out] unsigned32    *key_version_p,
    [out]    sec_pk_data_t *key_ret_p
);

/* s e c _ p u b k e y _ w r i t e _ k e y f i l e
 *
 * Function:
 *    Write a key value to a keyfile.  Keyfile
 *    has following format:
 *    unsigned32  'P' 'K' 'E' 'Y'
 *    unsigned32  file format version# (2)
 *    unsigned32  key_version
 *    unsigned32  key_length
 *    byte        key[key_length]
 *
 * In Parameters:
 *    keyfilepath      -path to keyfile
 *    key_version_p    -pointer to key version to be written
 *    key_p            -address of sec_pk_data_t structure holding
 *                      the key to be written
 *
 * Out Parameters:
 *    key_version_p    -pointer to key version written
 *    file_fmt_ver_p   -address of file format version written
 *                      (NULL if you don't want this)
 *
 * Errors:
 *     sec_pk_e_kf_param_not_alloc - parameter other than
 *                                   file_fmt_ver_p NULL
 *     sec_pk_e_kf_open_err        - error opening the keyfile
 *                                   for writing
 *     sec_pk_e_kf_write_err       - error writing the keyfile
 */
error_status_t sec_pubkey_write_keyfile(
    [in]  char            *keyfilepath,
    [in]  sec_pk_data_t   *key_p,
    [in,out] unsigned32   *key_version_p,
    [out] unsigned32      *file_fmt_ver_p
);

}
...\" END /dce/src/security/idl/sec_pubkey.idl
.cF
.P
.H 2 "DCE Private Key Module Interface"
.P
The interface to the DCE Private Key Module Interface is defined in two new files
\*(lBsecurity/idl/sec_pvtkey.idl\*(lE and
\*(lBsecurity/psm/domestic/sec_pvtkey_switch.h\*(lE, listed here.
\*(lBsec_pvtkey_switch.h\*(lE
defines an interface for registering a private key storage mechanism.
\*(lBsec_pvtkey.idl\*(lE defines the interface between the \*(lBsec_psm\*(lE
layer and the \*(lBsec_pvtkey\*(lE layer.
.P
.H 3 "security/idl/sec_pvtkey.idl"
.P
.cS
...\" .so /dce/src/security/idl/sec_pvtkey.idl
/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1996 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE
 * in the src directory for the full copyright text.
 */
/*
 * Copyright (c) Hewlett-Packard Company 1996
 * Unpublished work.  All Rights Reserved.
 *
 *       Private Key Storage Interface
 */

[
    local
]

interface sec_pvtkey

{

    import "dce/rgybase.idl";
    import "dce/sec_pk_base.idl";


    typedef void *sec_pk_mechanism_handle_t;

    /* Capability should be uuid */

    typedef uuid_t sec_pk_pvtkey_capability;

/* sec_pvtkey_open
 *
 * Open (connect to) the private key storage service.  For file-based
 * keystore implementation, it creates the file for the follow up key
 * store.  It opens the file for the follow up key retrieval or key
 * update.  It can involve a password check (please note, password
 * check is not applicable to sys admin's operation).  For a
 * server-based implementation, it binds to the server.
 *
 * Return status
 *   error_status_ok:   Success.
 *   other (non-zero):
 *             for PKSS:
 *                      Can't initialize keystore container.
 *                      Can't locate keystore.
 *                      Can't communicate with keystore.
 *                      Access-control failure.
 *             for file base:
 *                      sec_pvtkey_privileged
 *                      sec_pvtkey_no_more_memory
 *
 * Input
 *
 *    Name: Pointer to the user's canonical name within the
 *          specified domain.
 *    domain_id: The application domain this key belongs to.
 *
 * Output
 *    handle: A pointer to an opaque handle to the private key
 *            context data.  The context data should contain the
 *            domain_id of the operation.
 */

error_status_t sec_pvtkey_open(
        [in]  char                      *name,
        [in]  sec_pk_domain_t           *domain_id,
        [out] sec_pk_mechanism_handle_t *handle
);

/* sec_pvtkey_close
 *
 * Close the connection to the private key storage service.  It also
 * frees the handle.  If there are sensitive data, the data should
 * be zeroed first.
 *
 * Return status
 *   error_status_ok:   Success.
 *   other (non-zero):  Can't close keystore container.
 *                      Can't locate keystore.
 *                      Can't communicate with keystore.
 *                      Access-control failure.
 *              for file base:
 *                      sec_pvtkey_invalid_handle
 *                      sec_pvtkey_mechanism_not_init
 *
 * Input
 *
 *    handle: A pointer to an opaque handle to the private key
 *            context data.  The context data should contain the
 *            domain_id of the operation.  The handle should be
 *            obtained throught sec_pvtkey_open().
 */

error_status_t sec_pvtkey_close(
        [in]  sec_pk_mechanism_handle_t handle
);

/* sec_pvtkey_capabilities
 *
 * Inquire about the capabilities of a key storage service.  Multiple
 * storage services may be supported by a client system, selected
 * according to username and/or domain_id.  If no keystore service
 * is defined for a given username and domain_id, all sec_pvtkey
 * operations for that name/domain will return the error
 * "Can't locate keystore".  Some services may not
 * support all storage service operations, and the
 * sec_pvtkey_capabilities function allows the PSM module to
 * interrogate a particular storage service to determine whether a
 * given feature or operation is supported.
 *
 * Return status
 *   error_status_ok:    Success.
 *   other (non-zero):   Can't locate keystore.
 *                       Can't communicate with keystore.
 *                  for file base:
 *                       sec_pvtkey_capability_not_supported
 *
 * Input
 *    Name: Pointer to the user's canonical name within the
 *          specified domain.
 *    capability_parameter: Pointer to the parameter specific to the
 *              capability specified.  In KEYGEN capability, it is
 *              public-key algorithm.  If specified as
 *              NULL, the default public-key algorithm (RSA)
 *              is implied.  Many capability queries will
 *              ignore this parameter.
 *    Feature:  Pointer to a uuid code identifying a service feature.
 *
 *              The following features are currently defined:
 *              Feature code            Feature
 *              ------------            -------
 *              SEC_PVTKEY_CAP_KEYGEN   Service can generate keys for
 *                                      the specified algorithm.
 *              SEC_PVTKEY_CAP_ANYALG   Service can store keys for
 *                                      any algorithm.
 *              SEC_PVTKEY_CAP_KEYALG   Service can store keys for
 *                                      the specified algorithm.
 *              SEC_PVTKEY_CAP_KEYDEL   Service can delete user's
 *                                      key.
 *
 * Output
 *    Supported: true if the feature is available, false if not.
 *
 */

error_status_t sec_pvtkey_capabilities(
        [in]  sec_pk_mechanism_handle_t handle,
        [in]  void *                    capability_parameter,
        [in]  sec_pk_pvtkey_capability  *feature,
        [out] boolean32                 *supported
   );

/* sec_pvtkey_store
 *
 * Store the user's keypair encrypted using the user's password in
 * the storage service.  The encryption mechanism is determined by
 * the service provider.  The public-key algorithm ID (such as
 * RSA, DSA) should be included in both the private_key and
 * public_key structures which are the final [in] parameters.  The
 * keys will be indexed by name, domain_id, key_usage and
 * key_version in the private key storage service in order to
 * allow retrieval via the sec_pvtkey_get API.
 *
 * If the specified key already exists in the keystore, the
 * routine will leave it unchanged and return a failure status.
 * To replace a key in a keystore, either use sec_pvtkey_update or
 * sec_pvtkey_update_generate, or call sec_pvtkey_delete followed
 * by sec_pvtkey_store.
 *
 * A keystore may enforce its own access-control requirements, and
 * an access-control failure will be indicated by an appropriate
 * status code, with the contents of the keystore unchanged.  For
 * example, a file-based keystore implementation may require that
 * the caller has write-access to the keystore file; a
 * server-based implementation may require that the caller has
 * appropriate ACL-based permission to create a new entry; a
 * memory-card implementation may require that the card be
 * write-enabled.
 *
 * Return status
 *   error_status_ok:   Success.
 *   other (non-zero):  Can't initialize keystore container.
 *                      Can't locate keystore.
 *                      Can't communicate with keystore.
 *                      Access-control failure.
 *                      Same domain and usage's key already exists.
 *                for file base:
 *                      sec_pvtkey_invalid_handle
 *                      sec_pvtkey_mechanism_not_init
 *                      sec_pvtkey_no_more_memory
 *                      sec_pvtkey_internal_error
 *               sec_pvtkey_same_domain_and_usage_key_already_exists.
 *
 * Input
 *
 *    handle: A pointer to an opaque handle to the private key
 *            context data.  The handle should be obtained through
 *            sec_pvtkey_open()

 *    pwd:  Pointer to the user's password.
 *    key_usage: The usage permitted of this keypair.  One key_usage
 *               at a time.
 *    key_vno: The key version number. (0 may be specified to
 *             indicate that the routine should select the next
 *             appropriate or newest key version number).
 *             (In the reference implementation, key_vno starts with
 *              1, then monotonically increases 1 for each update.)
 *    private_key: Pointer to the encoded private key
 *                 structure.
 *    public_key: Pointer to the encoded public key structure.
 *
 */

error_status_t sec_pvtkey_store(
        [in]  sec_pk_mechanism_handle_t handle,
        [in]  char                      *pwd,
        [in]  sec_pk_usage_flags_t      key_usage,
        [in]  unsigned32                key_vno,
        [in]  sec_pk_data_t             *private_key,
        [in]  sec_pk_data_t             *public_key
   );

/* sec_pvtkey_delete
 *
 * Delete the user's keypair from the storage device.
 *
 * Return status
 *   error_status_ok:   Success.
 *   other (non-zero):  Can't initialize keystore container.
 *                      Can't locate keystore.
 *                      Can't communicate with keystore.
 *                      Access-control failure.
 *                 for file base:
 *                      sec_pvtkey_key_deletion_not_supported
 *
 * Input
 *
 *    handle: A pointer to an opaque handle to the private key
 *            context data.  The handle should be obtained through
 *            sec_pvtkey_open()
 *    pwd:    Pointer to the user's password.
 *    key_usage: The usage of the key pair of the desired key. One
 *               key_usage at a time or NULL key usage.
 *               NULL value means "delete all the key_usages
 *               related to the user.
 *    key_vno: The version number of the desired key.  If 0 (zero) is
 *             specified, the function will select the most recent
 *             key version number.
 *
 */

error_status_t sec_pvtkey_delete(
        [in]  sec_pk_mechanism_handle_t handle,
        [in]  char                      *pwd,
        [in]  sec_pk_usage_flags_t      key_usage,
        [in]  unsigned32                key_vno
   );

/* sec_pvtkey_generate
 *

 * Generate a new keypair and store it in the keystore encrypted
 * using the user's password in the storage service.  The encryption
 * mechanism is determined by the service provider.  The keys will
 * be indexed by name, domain_id, key_usage and key_version in the
 * private key storage service in order to allow retrieval via the
 * sec_pvtkey_get API.
 *
 * If the specified key already exists in the keystore, the routine
 * will leave it unchanged and return a failure status.  To replace
 * a key in a keystore, either use sec_pvtkey_update or
 * sec_pvtkey_update_generate, or call sec_pvtkey_delete followed by
 * sec_pvtkey_store.
 *
 * A keystore may enforce its own access-control requirements, and
 * an access-control failure will be indicated by an appropriate
 * status code, with the contents of the keystore unchanged.  For
 * example, a file-based keystore implementation may require that
 * the caller has write-access to the keystore file; a server-based
 * implementation may require that the caller has appropriate
 * ACL-based permission to create a new entry; a memory-card
 * implementation may require that the card be write-enabled.
 *
 * Return status
 *   error_status_ok:   Success.
 *   other (non-zero):  Can't initialize keystore container.
 *                      Can't locate keystore.
 *                      Can't communicate with keystore.
 *                      Access-control failure.
 *                      Same domain and usage's key already exits.
 *                      Key generation not supported.
 *   for file base:
 *                      sec_pvtkey_key_generation_not_supported
 *
 * Input
 *
 *     handle: A pointer to an opaque handle to the private key
 *             context data.  The handle should be obtained through
 *             sec_pvtkey_open()
 *     pwd:    Pointer to the user's password.
 *     alg_id: Desired public-key algorithm.  If specified as
 *             NULL, the default public-key algorithm (RSA)
 *             shall be used.
 *     key_length: Desired key-length.  The length of the desired
 *                 key.  Interpretation of this parameter is
 *                 algorithm- dependent; For RSA, it shall be
 *                 interpreted as the bit-length of the key.  For
 *                 any algorithm, a value of 0xffffffff shall mean
 *                 the algorithm-specific default.
 *     key_usage: The usage of the public key this key pair
 *                 shall belongs to.
 *     key_vno: The key version number. (0 may be specified to
 *             indicate that the routine should select the next
 *             appropriate or newest key version number).
 *             (In the reference implementation, key_vno starts with
 *              1, then monotonically increases 1 for each update.)
 *
 * Output
 *
 *     public_key: Pointer to the encoded public key structure of the
 *     newly-generated key.
 *
 */

error_status_t sec_pvtkey_generate(
        [in]  sec_pk_mechanism_handle_t handle,
        [in]  char                      *pwd,
        [in]  sec_pk_algorithm_id_t     *alg_id,
        [in]  unsigned32                key_length,
        [in]  sec_pk_usage_flags_t      key_usage,
        [in]  unsigned32                key_vno,
        [out] sec_pk_data_t             *public_key
   );

/* sec_pvtkey_get
 *
 * Retrieve the user's keypair from the storage device.
 * The routine allocates memory for the data returned in the
 * private key and public key parameters.  Users should call
 * sec_pvtkey_free() to deallocate that memory.
 *
 * The keypair returned will be the first one found with a
 * stored key_usage value containing the input "key_usage" value.
 * i.e. the input value (which will typically have a single bit
 * set) will be "AND"d with the stored value (which may have many
 * bits set), and the will be returned if the result is not 0.
 *
 * Return status
 *   error_status_ok:   Success.
 *   other (non-zero):  Access control failure.
 *                      Can't locate keystore.
 *                      Can't communicate with keystore.
 *                      Can't find specified key.
 *                      Invalid password.
 *                for file base:
 *                      sec_pvtkey_invalid_handle
 *                      sec_pvtkey_mechanism_not_init
 *                      sec_pvtkey_internal_error
 *                      sec_pvtkey_invalid_password
 *                      sec_pvtkey_multiple_key_usages
 *
 * Input
 *
 *    handle: A pointer to an opaque handle to the private key
 *            context data.  The handle should be obtained through
 *            sec_pvtkey_open()
 *    pwd:  Pointer to the user's password.
 *    domain_id: The application domain of the desired key.
 *    key_usage: The usage of the public key of the desired key. One
 *               key_usage at a time.
 *
 * Input/Output
 *
 *    key_vno: The key version number. (0 may be specified to
 *             indicate that the routine should select the
 *             newest key version number).  The return value is
 *             the key version of the key returned.
 *
 * Output
 *
 *    private_key: Pointer to the encoded private key
 *                 structure.
 *    public_key   Pointer to the encoded public key
 *                 structure.
 *
 */

error_status_t sec_pvtkey_get(
       [in]  sec_pk_mechanism_handle_t handle,
       [in]  char                      *pwd,
       [in]  sec_pk_usage_flags_t      key_usage,
       [in, out]  unsigned32           *key_vno,
       [out] sec_pk_data_t             *private_key,
       [out] sec_pk_data_t             *public_key
   );

/* sec_pvtkey_update
 *
 * Update the user's keypair record in a keystore.  This API may be
 * used to change either the password, or the keypair, or both.
 * It may be invoked either by the user to change her own
 * keypair record (in which case the current_pwd parameter must
 * be supplied), or by a system administrator to change another
 * user's keypair record (in which case the current_pwd parameter
 * should be specified as NULL.
 *
 * Keystore implementations may impose their own access-control
 * requirements.  In particular, some keystore implementations
 * may not support administrative updates, or may require that
 * the caller have valid administrative DCE credentials.
 *
 * Return status
 *   error_status_ok:   Success.
 *   other (non-zero):  Access control failure.
 *                      Can't locate keystore.
 *                      Can't communicate with keystore.
 *                      Can't find specified record.
 *                      Invalid password.
 *                 for file base:
 *                      sec_pvtkey_invalid_handle
 *                      sec_pvtkey_mechanism_not_init
 *                      sec_pvtkey_private_key_is_not_supplied
 *                      sec_pvtkey_new_password_required
 *                      sec_pvtkey_no_more_memory
 *                      sec_pvtkey_internal_error
 *                      sec_pvtkey_no_matched_private_key
 *                      sec_pvtkey_Invalid_password.
 *
 * Input
 *
 *    handle: A pointer to an opaque handle to the private key
 *            context data.  The handle should be obtained through
 *            sec_pvtkey_open()
 *    current_pwd: Pointer to the user's current password.  Used to
 *                 authenticate the user when changing her own
 *                 password or keypair.  If this parameter is NULL,
 *                 the keystore will assume that the update is an
 *                 administrative action, and will enforce
 *                 administrative access-control
 *    new_pwd: Pointer to the user's new password.  If the user
 *             is changing her own key, and does not wish to change
 *             the associated password, this argument may be NULL
 *             (subject to any restrictions imposed by the keystore).
 *             If this is an administrative action, a valid new_pwd
 *             must be supplied.
 *    key_usage: The allowed usage for this keypair.  One
 *               key_usage at a time.
 *    private_key: Pointer to the encoded private key structure.
 *    public_key:  Pointer to the encoded public key structure.
 *                 If the user is changing her own password, and does
 *                 not wish to change the corresponding keypair, this
 *                 parameter may be NULL (subject to any restrictions
 *                 imposed by the keystore).  If this is an
 *                 administrative action, valid private and public
 *                 keys must be supplied.
 *
 * Output
 *    key_vno: The key version number. (0 may be specified to
 *             indicate that the routine should select the next
 *             appropriate or newest key version number).
 *             (In the reference implementation, key_vno starts with
 *              1, then monotonically increases 1 for each update.)
 *
 */

error_status_t sec_pvtkey_update(
        [in] sec_pk_mechanism_handle_t handle,
        [in] char                   *current_pwd,
        [in] char                   *new_pwd,
        [in] sec_pk_usage_flags_t   key_usage,
        [out] unsigned32            *key_vno,
        [in] sec_pk_data_t          *private_key,
        [in] sec_pk_data_t          *public_key
  );

/* sec_pvtkey_update_generate
 *
 * Update the user's keypair record for a keystore that supports
 * key generation.  This API may be used to change
 * either the keypair alone, or both the keypair and the password.
 * It may be invoked either by the user to change her own keypair
 * record (in which case the current_pwd parameter must be supplied),
 * or by a system administrator to change another user's keypair
 * record (in which case the current_pwd parameter should be
 * specified as NULL.
 *
 * Keystore implementations may impose their own access-control
 * requirements.  In particular, some keystore implementations
 * may not support administrative updates, or may require that
 * the caller have valid administrative DCE credentials.
 *
 *
 * Return status
 *   error_status_ok:    Success.
 *   other (non-zero):  Access control failure.
 *                      Can't locate keystore.
 *                      Can't communicate with keystore.
 *                      Can't find specified record.
 *                      Key generation not supported.
 *                      Invalid password.
 *                  for file base:
 *                      sec_pvtkey_key_generation_not_supported
 *
 * Input
 *
 *    handle: A pointer to an opaque handle to the private key
 *            context data.  The handle should be obtained through
 *            sec_pvtkey_open()
 *    current_pwd: Pointer to the user's current password.
 *                 Used to authenticate the user when changing her
 *                 own password or keypair.  If this parameter is
 *                 NULL, the keystore will assume that the update is
 *                 an administrative action, and will enforce
 *                 administrative access-control
 *    new_pwd: Pointer to the user's new password.  If the user
 *             is changing her own key, and does not wish to change
 *             the associated password, this argument may be NULL
 *             (subject to any restrictions imposed by the keystore).
 *             If this is an administrative action, a valid new_pwd
 *             must be supplied.
 *     alg_id: Desired public-key algorithm.  If specified as
 *             NULL, the default public-key algorithm (RSA)
 *             shall be used.
 *     key_length: Desired key-length.  The length of the desired
 *                 key.  Interpretation of this parameter is
 *                 algorithm-dependent; For RSA, it shall be
 *                 interpreted as the bit-length of the key.  For any
 *                 algorithm, a value of 0xffffffff shall mean the
 *                 algorithm-specific default.

 *     key_usage: The allowed usage for this keypair.  One at a time.
 *
 *
 * Output
 *
 *    key_vno: The key version number. (0 may be specified to
 *             indicate that the routine should select the next
 *             appropriate or newest key version number).
 *             (In the reference implementation, key_vno starts with
 *              1, then monotonically increases 1 for each update.)
 *    public_key:  The newly-generated public-key.
 *
 */

error_status_t sec_pvtkey_update_generate(
        [in] sec_pk_mechanism_handle_t handle,
        [in] char                   *current_pwd,
        [in] char                   *new_pwd,
        [in] sec_pk_algorithm_id_t  *alg_id,
        [in] unsigned32             key_length,
        [in] sec_pk_usage_flags_t   key_usages,
        [out] unsigned32            *key_vno,
        [out] sec_pk_data_t         *public_key
  );

}
...\" END /dce/src/security/idl/sec_pvtkey.idl
.cF
.P
.H 3 "security/psm/domestic/sec_pvtkey_switch.h"
.P
.cS
...\" .so /dce/src/security/psm/domestic/sec_pvtkey_switch.h
/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1996 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE
 *  in the src directory for the full copyright text.
 */
/*
 * (c) Copyright 1996,
 * Digital Equipment Corporation, Maynard, Massachusetts, USA
 * All Rights Reserved
 */
/*
 * Copyright (c) Hewlett-Packard Company 1996
 * Unpublished work.  All Rights Reserved.
 */

#ifndef SEC_PVTKEY_SWITCH_H_
#define SEC_PVTKEY_SWITCH_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <dce/sec_pk_base.h>
#include <dce/sec_pvtkey.h>
#include <dce/dcepsmmsg.h>


#define SEC_PVTKEY_SWITCH_FLAG_MATCHALL     1
#define SEC_PVTKEY_SWITCH_FLAG_TERMINATE    2
#define SEC_PVTKEY_SWITCH_FLAG_ENABLED      4

typedef struct {

    unsigned32 magic;

    unsigned32 flags;

    const uuid_t * keystore_uuid;

    char keystore_name[32]; /* Name must be 32 characters or less, */
                            /* and NULL-terminated if less.        */

    error_status_t (* open)(idl_char *name,
                            sec_pk_domain_t *domain_id,
                            sec_pk_mechanism_handle_t *handle);

    error_status_t (* close)(sec_pk_mechanism_handle_t handle);

    error_status_t (* capabilities)(sec_pk_mechanism_handle_t handle,
                                  idl_void_p_t capability_parameter,
                                  sec_pk_pvtkey_capability * feature,
                                  idl_boolean * supported);

    error_status_t (* store)(sec_pk_mechanism_handle_t handle,
                             idl_char *pwd,
                             sec_pk_usage_flags_t key_usages,
                             unsigned32 key_vno,
                             sec_pk_data_t *private_key,
                             sec_pk_data_t *public_key);

    error_status_t (* delete)(sec_pk_mechanism_handle_t handle,
                              idl_char *pwd,
                              sec_pk_usage_flags_t key_usages,
                              unsigned32 key_vno);

    error_status_t (* generate)(sec_pk_mechanism_handle_t handle,
                                idl_char *pwd,
                                sec_pk_algorithm_id_t *alg_id,
                                unsigned32 key_length,
                                sec_pk_usage_flags_t key_usage,
                                unsigned32 key_vno,
                                sec_pk_data_t *public_key);

    error_status_t (* get)(sec_pk_mechanism_handle_t handle,
                           idl_char *pwd,
                           sec_pk_usage_flags_t key_usage,
                           unsigned32 *key_vno,
                           sec_pk_data_t *private_key,
                           sec_pk_data_t *public_key);

    error_status_t (* update)(sec_pk_mechanism_handle_t handle,
                              idl_char *current_pwd,
                              idl_char *new_pwd,
                              sec_pk_usage_flags_t key_usages,
                              unsigned32 *key_vno,
                              sec_pk_data_t *private_key,
                              sec_pk_data_t *public_key);

   error_status_t (* update_generate)(
                                    sec_pk_mechanism_handle_t handle,
                                    idl_char *current_pwd,
                                    idl_char *new_pwd,
                                    sec_pk_algorithm_id_t *alg_id,
                                    unsigned32 key_length,
                                    sec_pk_usage_flags_t key_usages,
                                    unsigned32 *key_vno,
                                    sec_pk_data_t *public_key);

} keystore_epv;

/*
 *  s e c _ p v t k e y _ _ g e t _ u u i d _ e r a _ b y _ u u i d
 *
 * Retrieve a UUID-valued ERA from a specific principal entry in the
 * registry.  The desired ERA is specified by its UUID.
 */

unsigned32 sec_pvtkey__get_uuid_era_by_uuid(
                                  sec_rgy_name_t principal_name,
                                  const uuid_t * uuid,
                                  uuid_t * era_value);

/*
 * s e c _ p v t k e y _ _ l o o k u p _ k e y s t o r e
 *
 * Lookup the keystore associated with the specified user's DCE login
 * key.  Returns a pointer to the internal EPV for that keystore, or
 * NULL if the keystore was not found.
 */

extern unsigned32 sec_pvtkey__lookup_keystore(
                                   const char * username,
                                   const sec_pk_domain_t * domain_id,
                                   const keystore_epv ** keystore);
/*
 * s e c _ p s m _ _ i n i t _ s v c
 *
 * Initialize PSM serviceability messaging.
 * This routine might be better moved elsewhere; however currently
 * the sec_pvtkey_XXX routines are the only ones that use PSM
 * serviceability messages, so for the moment leave it here.
 *
 * The routine is threadsafe, and can be invoked multiple times
 * without ill effects.
 *
 */
extern void sec_psm__init_svc(void);

/*
 * s e c _ p v t k e y _ _ r e g i s t e r _ k e y s t o r e
 *
 * Register a new keystore implementation for the current image.
 * Keystores are registered either statically (for all images) via
 * sec_pvtkey_registered_keystores.c, or dynamically (for the current
 * image only) by calling this routine.  All parameters are input.
 * The routine adds the new keystore implementation to the list of
 * keystores.  The implementation of this list is fairly limited:
 *
 * 1.  There is a fixed-length list of keystores, and attempts to
 *     register more keystores than will fit in the list will return
 *     an error
 * 2.  Keystore implementations cannot be deleted from the list.
 *     However, apart for releasing the slot within the keystore
 *     list, the effect of keystore deletion can be achieved by
 *     re-registering the keystore you want to delete, setting
 *     replace = true and enabled = false.
 *
 */

extern unsigned32 sec_pvtkey__register_keystore(
    uuid_t * keystore_uuid, /* The UUID to which this pointer
                               points mustn't disappear! */
    const char * keystore_name,
                            /* Name should be 32 characters or less.
                               Used in serviceability messages.  This
                               is copied into the keystore list, so
                               it is OK for it to disappear after the
                               register_keystore call returns. */
    boolean32 enabled,      /* If true, the keystore will be enabled.
                               If false, the keystore will be
                               disabled. */
    boolean32 make_default, /* If true, this keystore will become
                               the new default keystore, to be
                               used if the registry doesn't tell
                               use which one to use. */
    boolean32 replace,      /* If true, this keystore will replace
                               any pre-existing keystore(s) with the
                               same UUID. If false, attempts to
                               re-register an already-existing
                               keystore will fail. */
    error_status_t (* open)(idl_char *name,
                            sec_pk_domain_t *domain_id,
                            sec_pk_mechanism_handle_t *handle),
    error_status_t (* close)(sec_pk_mechanism_handle_t handle),
    error_status_t (* capabilities)(
                                  sec_pk_mechanism_handle_t handle,
                                  idl_void_p_t capability_parameter,
                                  sec_pk_pvtkey_capability * feature,
                                  idl_boolean * supported),
    error_status_t (* store)(sec_pk_mechanism_handle_t handle,
                             idl_char *pwd,
                             sec_pk_usage_flags_t key_usages,
                             unsigned32 key_vno,
                             sec_pk_data_t *private_key,
                             sec_pk_data_t *public_key),
    error_status_t (* delete)(sec_pk_mechanism_handle_t handle,
                              idl_char *pwd,
                              sec_pk_usage_flags_t key_usages,
                              unsigned32 key_vno),
    error_status_t (* generate)(sec_pk_mechanism_handle_t handle,
                                idl_char *pwd,
                                sec_pk_algorithm_id_t *alg_id,
                                unsigned32 key_length,
                                sec_pk_usage_flags_t key_usage,
                                unsigned32 key_vno,
                                sec_pk_data_t *public_key),
    error_status_t (* get)(sec_pk_mechanism_handle_t handle,
                           idl_char *pwd,
                           sec_pk_usage_flags_t key_usage,
                           unsigned32 *key_vno,
                           sec_pk_data_t *private_key,
                           sec_pk_data_t *public_key),
    error_status_t (* update)(sec_pk_mechanism_handle_t handle,
                              idl_char *current_pwd,
                              idl_char *new_pwd,
                              sec_pk_usage_flags_t key_usages,
                              unsigned32 *key_vno,
                              sec_pk_data_t *private_key,
                              sec_pk_data_t *public_key),
    error_status_t (* update_generate)(
                                    sec_pk_mechanism_handle_t handle,
                                    idl_char *current_pwd,
                                    idl_char *new_pwd,
                                    sec_pk_algorithm_id_t *alg_id,
                                    unsigned32 key_length,
                                    sec_pk_usage_flags_t key_usages,
                                    unsigned32 *key_vno,
                                    sec_pk_data_t *public_key)
);

#ifdef __cplusplus
}
#endif

#endif
...\" END /dce/src/security/psm/domestic/sec_pvtkey_switch.h
.cF
.P
.H 2 "DCE Security Login API"
.P
The existing DCE Security Login API in file
\*(lBsecurity/idl/sec_login.idl\*(lE has changed to return
additional error status values for functions that support public key
operations or protocols.  Those changes are listed here.  No other
changes have been made to the login APIs.
.P
.cS
...\" .so /dce/src/security/idl/sec_login.idl.diff
*    sec_pk_e_domain_unsupported      - kdc_cache domain not
*                                       supported by sec_pubkey
*    sec_pk_e_usage_unsupported       - a private or public key of
*                                       the required type was not
*                                       located in the PSM
*    sec_pk_e_key_attr_read_failed    - unable to read principal's
*                                       DCEPKAuthentication or
*                                       DCEPKKeyEncipherment ERA
*    sec_pk_e_no_memory               - out of memory
*    sec_pk_e_cell_too_long           - the cell name is too long for
*                                       the public key API
*/
boolean32 sec_login_validate_identity (


*    sec_pk_e_usage_unsupported       - a private or public key of
*                                       the required type was not
*                                       located in the PSM
*    sec_pk_e_key_attr_read_failed    - unable to read principal's
*                                       DCEPKAuthentication or
*                                       DCEPKKeyEncipherment ERA
*    sec_pk_e_no_memory               - out of memory
*    sec_pk_e_cell_too_long           - the cell name is too long for
*                                       the public key API
*/
boolean32 sec_login_valid_and_cert_ident (


*    sec_pk_e_usage_unsupported       - a private or public key of
*                                       the required type was not
*                                       located in the PSM
*    sec_pk_e_key_attr_read_failed    - unable to read principal's
*                                       DCEPKAuthentication or
*                                       DCEPKKeyEncipherment ERA
*    sec_pk_e_no_memory               - out of memory
*    sec_pk_e_cell_too_long           - the cell name is too long for
*                                       the public key API
*/
boolean32 sec_login_validate_first (

...\" END /dce/src/security/idl/sec_login.idl.diff
.cF
.P
.H 2 "sec.sams"
.P
Error status values generated by the \*(lBsec_pubkey\*(lE interface are created
using the \*(lBSAMS\*(lE utility from the \*(lBsec.sams\*(lE file.
Application programs can access the error codes by including the
\*(lBsecsts.h\*(lE file generated by \*(lBSAMS\*(lE.
.P
Additions made to the \*(lBsecurity/idl/sec.sams\*(lE file follow.
.P
A new sub-component was added for public key errors:
.cS
...\" .so /dce/src/security/idl/sec.sams.diff
sub-component sec_s_pubkey "public_key" sec_i_svc_pubkey

start           !intable undocumented
code            sec_i_svc_pubkey
text            "Public key operations"
end
...\" END /dce/src/security/idl/sec.sams.diff
.cF
.P
The following new status codes were added for public key errors:
.cS
...\" .so /dce/src/security/idl/sec.sams.diff
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Start of public key messages           %
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

# Files : sec_pubkey.c

start
code            sec_pk_e_domain_unsupported
text            "Public key domain not supported for this
                 operation."
explanation     "The specified public key domain is not supported
                 for this operation."
action          "Login from another node with support for the
                 DCE Login domain; or use a valid public key
                 domain; or use a valid operation for the
                 specified domain."
sub-component   sec_s_pubkey
attributes      "svc_c_sev_fatal | svc_c_action_abort"
engineer        "Anne Anderson"
end

start
code            sec_pk_e_usage_unsupported
text            "Public key usage type not supported."
explanation     "The specified public key usage type is not
                 supported."
action          "Login from another node with support for the
                 user's public key login keys, or use a
                 supported public key usage type."
sub-component   sec_s_pubkey
attributes      "svc_c_sev_fatal | svc_c_action_abort"
engineer        "Anne Anderson"
end

start
code            sec_pk_e_key_vers_unsupported
text            "Key version not supported."
explanation     "For sec_pubkey_store, the key version must be
                 between 1 and 255; for sec_pubkey_retrieve,
                 the version number must be between 0 and 255."
action          "Call sec_pubkey interfaces with kvno set to
                 valid value."
sub-component   sec_s_pubkey
attributes      "svc_c_sev_fatal | svc_c_action_abort"
engineer        "Anne Anderson"
end

start
code            sec_pk_e_key_vers_unavailable
text            "Key version requested not found."
explanation     "Specified key version was not found."
action          "Request available key using version 0, or
                 request version of key that exists."
sub-component   sec_s_pubkey
attributes      "svc_c_sev_fatal | svc_c_action_abort"
engineer        "Anne Anderson"
end

start
code            sec_pk_e_key_attr_read_failed
text            "Public key attribute read failed."
explanation     "The value of at least one public key was not
                 read successfully."
action          "Make sure the principal has a public key
                 (DCEPKAuthentication ERA or DCEPKKeyEncipherment
                 ERA) attached; make sure sec.1.2.2 has been
                 enabled in the principal's cell; make sure the
                 DCEPK ERA schema entries have not been
                 modified."
sub-component   sec_s_pubkey
attributes      "svc_c_sev_fatal | svc_c_action_abort"
engineer        "Anne Anderson"
end

start
code            sec_pk_e_no_memory
text            "Insufficient memory for public key operation."
explanation     "Insufficient memory for public key operation."
action          "Install more memory."
sub-component   sec_s_pubkey
attributes      "svc_c_sev_fatal | svc_c_action_abort"
engineer        "Anne Anderson"
end

start
code            sec_pk_e_cell_too_long
text            "target cell name too long for cache file"
explanation     "Attempting to retrieve the public key for the
                 KDC of a cell whose cell name is too long to
                 create a cache file name."
action          "Configure and use a shorter cell name alias."
sub-component   sec_s_pubkey
attributes      "svc_c_sev_fatal | svc_c_action_abort"
engineer        "Anne Anderson"
end

start
code            sec_pk_e_no_key_value
text            "the public key value is NULL"
explanation     "Attempting to store a public key whose value
                 is NULL."
action          "Use a valid public key value."
sub-component   sec_s_pubkey
attributes      "svc_c_sev_fatal | svc_c_action_abort"
engineer        "Anne Anderson"
end

start
code            sec_pk_e_kf_param_not_alloc
text            "Return parameters NULL"
explanation     "The value of a return parameter was null.
                 Return parameters must point to pre-allocated
                 structures."
action          "Allocate the structure for the return value and
                 pass its address to the function."
sub-component   sec_s_pubkey
attributes      "svc_c_sev_fatal | svc_c_action_abort"
engineer        "Anne Anderson"
end

start
code            sec_pk_e_kf_open_err
text            "Error opening the keyfile."
explanation     "Specified keyfile could not be opened."
action          "Create keyfile or supply correct keyfile
                 pathname."
sub-component   sec_s_pubkey
attributes      "svc_c_sev_fatal | svc_c_action_abort"
engineer        "Anne Anderson"
end

start
code            sec_pk_e_kf_read_err
text            "Error reading the keyfile."
explanation     "Specified keyfile could not be read."
action          "Re-create keyfile or supply correct keyfile
                 pathname; verify permissions on keyfile."
sub-component   sec_s_pubkey
attributes      "svc_c_sev_fatal | svc_c_action_abort"
engineer        "Anne Anderson"
end

start
code            sec_pk_e_kf_write_err
text            "Error writing the keyfile."
explanation     "Specified keyfile could not be written."
action          "Supply correct keyfile pathname; create path
                 leading to keyfile; verify permissions on
                 keyfile."
sub-component   sec_s_pubkey
attributes      "svc_c_sev_fatal | svc_c_action_abort"
engineer        "Anne Anderson"
end

start
code            sec_pk_e_kf_format_err
text            "Keyfile not recognized."
explanation     "The keyfile is not a valid public or private
                 key keyfile."
action          "Check file pathname; be sure file is created
                 with correct format (header, version)."
sub-component   sec_s_pubkey
attributes      "svc_c_sev_fatal | svc_c_action_abort"
engineer        "Anne Anderson"
end

start
code            sec_pk_e_kf_version_err
text            "Keyfile version not supported."
explanation     "The keyfile version is not supported."
action          "Create keyfile with current software."
sub-component   sec_s_pubkey
attributes      "svc_c_sev_fatal | svc_c_action_abort"
engineer        "Anne Anderson"
end

start
code            sec_pk_e_rsdb_keystore_err
text            "Failed to register the rsdb keystore."
explanation     "Error registering the private key keystore
                 mechanism for the krbtgt key."
action          "Ensure libdce is compatible with secd."
sub-component   sec_s_pubkey
attributes      "svc_c_sev_fatal | svc_c_action_abort"
engineer        "Anne Anderson"
end

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# End of public key messages              %
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

start
code            sec_rsdb_acct_bad_keytype
text            "Only DES keys allowed for this account"
explanation     "An attempt was made to set a non-default keytype
                 for a principal where only DES keys are allowed.
                 Only the krbtgt principal is allowed to have
                 non-default keytypes."
action          "Use a DES keytype."
sub-component   sec_s_rs_rsdb
attributes      svc_c_sev_error
engineer        "Anne Anderson"
end

start
code            sec_pk_login_client_fail
text            "Could not acquire public key credentials: %s in %s"
notes           "first string is error message; second is code
                 location where error detected"
explanation     "A failure was detected while the client was
                 attempting to obtain credentials using public
                 key login protocols"
action          "Make a public key available to the client and
                 known to the KDC"
sub-component   sec_s_pubkey
attributes      svc_c_sev_notice_verbose
engineer        "Bill Sommerfeld"
end

# Files : rs_reserved.c
start
code            sec_res_pk_attr_sch_add_err
text            "Error adding an entry to the PK attribute
                 schema"
explanation     "?"
action          "?"
sub-component   sec_s_rs
attributes      svc_c_sev_error
end
...\" END /dce/src/security/idl/sec.sams.diff
.cF
.P
.H 2 "psm.sams"
.P
Error status values generated by the \*(lBsec_psm\*(lE interface are created
using the \*(lBSAMS\*(lE utility from the \*(lBpsm.sams\*(lE file.
Application programs can access the error codes by including the
\*(lBdcepsmmsg.h\*(lE file generated by \*(lBSAMS\*(lE.
.P
.cS
...\" .so /dce/src/security/h/psm.sams
# @OSF_COPYRIGHT@
# COPYRIGHT NOTICE
# Copyright (c) 1990, 1991, 1992, 1993, 1994, 1996 Open Software
#   Foundation, Inc.
# ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE
# for the full copyright text.
#
# All Rights Reserved
#
# Copyright (c) Hewlett-Packard Company 1996
# Unpublished work. All Rights Reserved.
#

component      psm
table          psm__table
technology     dce

serviceability table psm_svc_table handle psm_svc_handle
start
  sub-component psm_s_user     "psm_user"     psm_i_svc_user
  sub-component psm_s_bsafe    "psm_bsafe"    psm_i_svc_bsafe
  sub-component psm_s_pvtkey   "psm_pvtkey"   psm_i_svc_pvtkey
  sub-component psm_s_psm      "psm_psm"      psm_i_svc_psm
  sub-component psm_s_general  "psm_general"  psm_i_svc_general
end

#
## Message for RSA BSAFE 2.1 error code
#

start
code            sec_s_bsafe_algorithm_already_set
text            "BSAFE2: Algorithm object has already been set
                 with algorithm info"
explanation     "Algorithm object has already been set with
                 algorithm info"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_algorithm_info
text            "BSAFE2: Invalid algorithm info format"
explanation     "Invalid algorithm info format"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_algorithm_not_initialized
text            "BSAFE2: Algorithm object has not been
                 initialized"
explanation     "Algorithm object has not been initialized"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_algorithm_not_set
text            "Algorithm object has not been set with algorithm
                 info"
explanation     "Algorithm object has not been set with algorithm
                 info"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_algorithm_obj
text            "BSAFE2: Invalid algorithm object"
explanation     "Invalid algorithm object"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_alg_operation_unknown
text            "BSAFE2: Unknown operation for an algorithm or
                 algorithm info type"
explanation     "Unknown operation for an algorithm or algorithm
                 info type"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_alloc
text            "BSAFE2: Insufficient memory"
explanation     "Insufficient memory"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_cancel
text            "BSAFE2: Operation was canceled by the surrender
                 function"
explanation     "Operation was canceled by the surrender function"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_data
text            "BSAFE2: Generic data error"
explanation     "Generic data error"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_exponent_even
text            "BSAFE2: Public exponent in key pair generation
                 is not allowed to be even"
explanation     "Invalid even value for public exponent in key
                 pair generation"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_exponent_len
text            "BSAFE2: Invalid exponent length for public
                 exponent in key pair generation"
explanation     "Invalid exponent length for public exponent in
                 key pair generation"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_hardware
text            "BSAFE2: Cryptographic hardware error"
explanation     "Cryptographic hardware error"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_input_data
text            "BSAFE2: Invalid format for input data"
explanation     "Invalid format for input data"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_input_len
text            "BSAFE2: Invalid length for input data"
explanation     "Invalid length for input data"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_key_already_set
text            "BSAFE2: Key object has already been set with key
                 info"
explanation     "Key object has already been set with key info"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_key_info
text            "BSAFE2: Invalid key info format"
explanation     "Invalid key info format"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_key_len
text            "BSAFE2: Invalid key length"
explanation     "Invalid key length"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_key_not_set
text            "BSAFE2: Key object has not been set with key
                 info"
explanation     "Key object has not been set with key info"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_key_obj
text            "BSAFE2: Invalid key object"
explanation     "Invalid key object"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_key_operation_unknown
text            "BSAFE2: Unknown operation for a key info type"
explanation     "Unknown operation for a key info type"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_memory_obj
text            "BSAFE2: Invalid internal memory object"
explanation     "Invalid internal memory object"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_modulus_len
text            "BSAFE2: Invalid modulus length in public or
                 private key"
explanation     "Invalid modulus length in public or private key"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_not_initialized
text            "BSAFE2: Algorithm is not properly initialized"
explanation     "Algorithm is not properly initialized"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_not_supported
text            "BSAFE2: Unsupported operation requested"
explanation     "Unsupported operation requested"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_output_len
text            "BSAFE2: Output data is larger than supplied
                 buffer"
explanation     "Output data is larger than supplied buffer"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_over_32k
text            "BSAFE2: Data block exceeds 32,767 bytes"
explanation     "Data block exceeds 32,767 bytes"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_random_not_initialized
text            "BSAFE2: Random algorithm has not been
                 initialized"
explanation     "Random algorithm has not been initialized"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_random_obj
text            "BSAFE2: Invalid algorithm object for the random
                 algorithm"
explanation     "Invalid algorithm object for the random
                 algorithm"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_signature
text            "BSAFE2: Invalid signature"
explanation     "Invalid signature"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_wrong_algorithm_info
text            "BSAFE2: Wrong type of algorithm info"
explanation     "Wrong type of algorithm info"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_wrong_key_info
text            "BSAFE2: Wrong type of key info"
explanation     "Wrong type of key info"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_input_count
text            "BSAFE2: Update called an invalid number of
                 times for inputting data"
explanation     "Update called an invalid number of times for
                 inputting data"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_method_not_in_chooser
text            "Algorithm method required by the specified
                 algorithm not in algorithm chooser"
explanation     "Algorithm method required by the specified
                 algorithm not in algorithm chooser"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_output_count
text            "BSAFE2: Update called an invalid number of
                 times for outputting data"
explanation     "Update called an invalid number of times
                 for outputting data"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_unknown_error
text            "BSAFE2: Unknown bsafe error"
explanation     "Unknown bsafe error"
action          "?"
sub-component   psm_s_bsafe
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_decryption_failure
text            "BSAFE2: decryption failure"
explanation     "Wrong password or key supplied in decryption or
                 verification"
action          "Get the right password or key"
sub-component   psm_s_psm
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_s_bsafe_mod_size_out_of_range
text            "BSAFE2: key modulus length should be between 256
                 - 1024"
explanation     "key modulus length is too small or too big for
                 public key generation"
action          "Get the right modulus length"
sub-component   psm_s_psm
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end



#
## private key accessing mechanism errors.
#

start
code            sec_pvtkey_mechanism_not_init
text            "private key storage mechanism hasn't been
                 initialized"
explanation     "sec_pvtkey_open was not called before this
                 operation."
action          "?"
sub-component   psm_s_pvtkey
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_pvtkey_invalid_handle
text            "invalid sec_pvtkey_handle"
explanation     "Pvtkey handle is invalid, could be caused by
                 memory corruption."
action          "?"
sub-component   psm_s_pvtkey
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_pvtkey_same_domain_and_usage_key_already_exist
text            "same domain and usage key already exist"
explanation     "There is a private key with same domain, usage
                 existent in the key storage mechanism"
action          "?"
sub-component   psm_s_pvtkey
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code         sec_pvtkey_same_domain_and_usage_key_exist_with_diff_pwd
text            "Unable to update
                 same_domain_and_usage_key_already_exist key
                 because of different pwd"
explanation     "Either recreate the user account or use the
                 right password."
action          "?"
sub-component   psm_s_pvtkey
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_pvtkey_no_matched_private_key
text            "couldn't find a matched private key in the file"
explanation     "No private key is matched to the requested name,
                 domain, and key usage"
action          "?"
sub-component   psm_s_pvtkey
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_pvtkey_key_generation_not_supported
text            "key generation is not supported"
explanation     "private key generation is done in psm level for
                 file based key storage"
action          "?"
sub-component   psm_s_pvtkey
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_pvtkey_invalid_pwd
text            "invalid password"
explanation     "illegal password for fetching private key."
action          "?"
sub-component   psm_s_pvtkey
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_pvtkey_no_more_memory
text            "ran out of memory"
explanation     "Malloc failed because of no more memory"
action          "?"
sub-component   psm_s_pvtkey
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_pvtkey_key_deletion_not_supported
text            "private key deletion functionality is not
                 supported."
explanation     "private key deletion functionality is not
                 supported."
action          "?"
sub-component   psm_s_pvtkey
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_pvtkey_private_key_is_not_supplied
text            "private key is required for admin to update
                 user's private key"
explanation     "For admin to update user's private key record,
                 private key has to supplied."
action          "?"
sub-component   psm_s_pvtkey
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_pvtkey_new_password_required
text            "new password is required for updating the
                 password"
explanation     "New password is required for updating the
                 password of the private key"
action          "?"
sub-component   psm_s_pvtkey
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_pvtkey_internal_error
text            "sec_pvtkey module internal error.  Please
                 inform the developer."
explanation     "This is a developer coding error."
action          "?"
sub-component   psm_s_pvtkey
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_pvtkey_file_locked
text            "pvtkey file is locked by other process."
explanation     "Only one process, one thread can do a write
                 access to the pvtkey file at a time"
action          "Wait a while and try it later"
sub-component   psm_s_pvtkey
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_pvtkey_file_cannot_open_key_file
text            "pvtkey file cannot be opened."
explanation     "pvtkey file cannot be opened."
action          "Check the permission of the file"
sub-component   psm_s_pvtkey
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_pvtkey_privileged
text            "Not file owner or root"
explanation     "Must be the file owner or root account to
                 access pvtkey file"
action          "?"
sub-component   psm_s_pvtkey
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_pvtkey_capability_not_supported
text            "specified capability not supported"
explanation     "specified capability not supported in
                 this private key storage mechanism"
action          "?"
sub-component   psm_s_pvtkey
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_pvtkey_unsupported_capability_name
text            "specified capability name not supported"
explanation     "specified capability name not supported
                 in this private key storage mechanism"
action          "?"
sub-component   psm_s_pvtkey
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_pvtkey_multiple_key_usages
text            "too many key usages supplied"
explanation     "Multiple key usages supplied while only
                 one key usage allowed"
action          "?"
sub-component   psm_s_pvtkey
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_pvtkey_no_more_data
text            "read reach the end of file"
explanation     "No more data in the file"
action          "?"
sub-component   psm_s_pvtkey
attributes      "svc_c_sev_warning"
end


start
code            sec_pvtkey_wrong_passwd
text            "New passphrase doesn't match  other key pairs'
                 passphrase"
explanation     "The passphrases for all key pairs must be the
                 same"
action          "Change to the same passphrase and try it again"
sub-component   psm_s_pvtkey
attributes      "svc_c_sev_warning"
end

start
code            sec_pvtkey_version_not_exist
text            "The correct private key version not found"
explanation     "The correct private key version not found"
action          "Use version 0 to indicate using the most recent
                 one, or use the correct key version number"
sub-component   psm_s_pvtkey
attributes      "svc_c_sev_warning"
end

start
code            sec_pvtkey_old_pass_required
text            "Old passphrase required for this update"
explanation     "This is owner updating his key pair.  Old
                 passphrase is required to verify the passphrase"
action          "Supply the correct old passphrase"
sub-component   psm_s_pvtkey
attributes      "svc_c_sev_warning"
end

#
## psm
#

start
code            sec_psm_unable_to_open_pvtkey
text            "Unable to access private key storage mechanism"
explanation     "open a file or make a connection to private key
                 mechanism failed."
action          "?"
sub-component   psm_s_psm
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end


start
code            sec_psm_not_init
text            "PSM was not initialized"
explanation     "PSM need to be initialized before calling
                 any psm operations"
action          "Please call sec_psm_open before any other
                 psm operation"
sub-component   psm_s_psm
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_psm_invalid_handle
text            "Invalid psm handle"
explanation     "psm handle was corrupted"
action          "Check the memory corruption"
sub-component   psm_s_psm
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_psm_no_more_memory
text            "system ran out of memory"
explanation     "system ran our of memory during malloc"
action          "Increase the swap space or memory"
sub-component   psm_s_psm
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_psm_wrong_pub_key_type
text            "wrong public key type. The only supported
                 public key type is RSA_PKCS"
explanation     "The only supported public key type is RSA_PKCS"
action          "Use the right public key type"
sub-component   psm_s_psm
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_psm_internal_error
text            "psm internal error"
explanation     "psm internal error"
action          "Please inform engineer"
sub-component   psm_s_psm
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_psm_unsupported_algorithm_id
text            "unsupported crypto algorithm"
explanation     "unsupported crypto algorithm"
action          "Please choose supported one"
sub-component   psm_s_psm
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

#
# Messages added by Digital
#

start
code            sec_psm_keystore_not_found
text            "Keystore not found"
explanation     "A keystore could not be found for the
                 specified principal"
action          "Register a keystore for the principal"
sub-component   psm_s_psm
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_psm_keystore_list_corrupt
text            "Keystore list corrupt"
explanation     "Internal error - the list of registered
                 keystores is corrupt"
action          "Submit a problem report"
sub-component   psm_s_psm
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end


start
code            sec_psm_invalid_keystore_handle
text            "Invalid keystore handle"
explanation     "The sec_pvtkey_mechanism_handle_t was corrupt"
action          "Check for an error in the calling program"
sub-component   psm_s_psm
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_psm_keystore_attr_read_failed
text            "Keystore ERA retrieval failed"
explanation     "An attempt to retrieve a principal's keystore
                 ERA failed"
action          "Register a keystore for the principal"
sub-component   psm_s_psm
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_psm_keystore_already_registered
text            "Keystore already registered."
explanation     "The specified keystore is already registered"
action          "To change an existing keystore, set the replace
                 flag"
sub-component   psm_s_psm
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

start
code            sec_psm_keystore_list_full
text            "No space for a new keystore"
explanation     "There is no space left in the keystore list"
action          "None."
sub-component   psm_s_psm
attributes      "svc_c_sev_error | svc_c_action_exit_bad"
end

#
# Digital debugging messages
#

start
code            sec_psm_i_lookup_keystore
text            "Entering sec_pvtkey__lookup_keystore(%s)"
explanation     "Debugging message"
action          "None - Debugging message"
sub-component   psm_s_psm
attributes      svc_c_debug9
end

start
code            sec_psm_i_bad_domain
text            "sec_pvtkey__lookup_keystore(%s) failed - Bad
                 domain"
explanation     "Debugging message"
action          "None - Debugging message"
sub-component   psm_s_psm
attributes      svc_c_debug8
end

start
code            sec_psm_i_no_prin_keystore_era
text            "sec_pvtkey__lookup_keystore(%s) - No principal
                 keystore ERA"
explanation     "Debugging message"
action          "None - Debugging message"
sub-component   psm_s_psm
attributes      svc_c_debug8
end

start
code            sec_psm_i_no_def_keystore_era
text            "sec_pvtkey__lookup_keystore(%s) - No default
                 keystore ERA"
explanation     "Debugging message"
action          "None - Debugging message"
sub-component   psm_s_psm
attributes      svc_c_debug8
end

start
code            sec_psm_i_bad_keystore_list
text            "Keystore entry %d is corrupt"
explanation     "Internal error - The specified entry in the
                 registered keystore list is invalid"
action          "Submit a problem report"
sub-component   psm_s_psm
attributes      svc_c_sev_error
end

start
code            sec_psm_i_def_keystore
text            "sec_pvtkey__lookup_keystore(%s) - Using
                 default keystore %d (%.32s)"
explanation     "Debugging message"
action          "None - Debugging message"
sub-component   psm_s_psm
attributes      svc_c_debug8
end

start
code            sec_psm_i_no_keystore
text            "sec_pvtkey__lookup_keystore(%s) failed - No
                 appropriate keystore"
explanation     "Debugging message"
action          "None - Debugging message"
sub-component   psm_s_psm
attributes      svc_c_debug8
end

start
code            sec_psm_i_era_lookup_failure
text            "sec_pvtkey__lookup_keystore(%s) failed - Bad ERA
                 lookup (0x%x)"
explanation     "Debugging message"
action          "None - Debugging message"
sub-component   psm_s_psm
attributes      svc_c_debug8
end

start
code            sec_psm_i_chosen_keystore
text            "sec_pvtkey__lookup_keystore(%s) - Returning
                 keystore %d (%.32s)"
explanation     "Debugging message"
action          "None - Debugging message"
sub-component   psm_s_psm
attributes      svc_c_debug8
end

start
code            sec_psm_i_matchall_keystore
text            "sec_pvtkey__lookup_keystore(%s) - Returning
                 matchall keystore %d (%.32s)"
explanation     "Debugging message"
action          "None - Debugging message"
sub-component   psm_s_psm
attributes      svc_c_debug8
end

start
code            sec_psm_i_searching_explicit
text            "sec_pvtkey__lookup_keystore(%s) - Searching for
                 ERA-match keystore %s"
explanation     "Debugging message"
action          "None - Debugging message"
sub-component   psm_s_psm
attributes      svc_c_debug9
end

start
code            sec_psm_i_searching_matchall
text            "sec_pvtkey__lookup_keystore(%s) - Searching for
                 matchall keystore"
explanation     "Debugging message"
action          "None - Debugging message"
sub-component   psm_s_psm
attributes      svc_c_debug9
end

start
code            sec_psm_i_discarded_keystore
text            "sec_pvtkey__lookup_keystore(%s) - Discarded
                 keystore %d (%.32s, uuid %s)"
explanation     "Debugging message"
action          "None - Debugging message"
sub-component   psm_s_psm
attributes      svc_c_debug9
end

start
code            sec_psm_i_bad_keystore_id
text            "sec_pvtkey__lookup_keystore(%s) - Bad UUID in
                 keystore %d (%.32s)"
explanation     "Internal error - The specified entry in the
                 registered keystore list is invalid"
action          "Submit a problem report"
sub-component   psm_s_psm
attributes      svc_c_sev_error
end

start
code            sec_psm_i_bad_keystore_id1
text            "sec_pvtkey__register_keystore - Bad UUID in
                 keystore %d (%.32s)"
explanation     "Internal error - The specified entry in the
                 registered keystore list is invalid"
action          "Submit a problem report"
sub-component   psm_s_psm
attributes      svc_c_sev_error
end

#
## Messages for serviceability table
#

start           !intable undocumented
code            psm_i_svc_user
text            "PSM user operations\n"
end

start           !intable undocumented
code            psm_i_svc_bsafe
text            "BSAFE 2.1 (RSA) library operations"
end

start           !intable undocumented
code            psm_i_svc_pvtkey
text            "Private key accessing mechanism"
end

start           !intable undocumented
code            psm_i_svc_psm
text            "Personal security module framework"
end

start           !intable undocumented
code            psm_i_svc_general
text            "Personal security module general"
end
...\" END /dce/src/security/h/psm.sams
.cF
.P
.H 2 "dhd.sams"
.P
Error status values generated by the \*(lBrsec_pk_cache\*(lE interface are created
using the \*(lBSAMS\*(lE utility from the \*(lBdhd.sams\*(lE file.
Application programs can access the error codes by including the
\*(lBdcedhdmsg.h\*(lE file generated by \*(lBSAMS\*(lE.
.P
The following new sub-component is defined:
.P
.cS
...\" .so /dce/src/admin/dced/idl/dhd.sams.diff
sub-component dhd_s_pkcache "pkcache" dhd_i_svc_pkcache

start   !intable undocumented
code    dhd_i_svc_pkcache
text    "The dced KDC public key cache service"
end
...\" END /dce/src/admin/dced/idl/dhd.sams.diff
.cF
.P
The following new errors are defined:
.P
.cS
...\" .so /dce/src/admin/dced/idl/dhd.sams.diff
# -------- pkcache-specific
start collection 13

start
code            dced_s_pkcache_usage_unsupp
text            "Public key usage type unsupported."
explanation     "sec_login has requested an invalid
                 usage type for a KDC key.  Usage type must be
                 sec_pk_usage_digitalSignature"
action          "Make sure libdce and dced are from the same
                 release."
attributes      svc_c_sev_error
sub-component   dhd_s_pkcache
end

start
code            dced_s_pkcache_key_write_failure
text            "Cache of KDC key failed."
explanation     "Some error occurred during the attempt to write
                 the public key of the KDC into the file cache."
action          "None."
attributes      svc_c_sev_error
sub-component   dhd_s_pkcache
end

start
code            dced_s_pkcache_cell_invalid
text            "cell name invalid"
explanation     "The cell name requested is too long to form
                 a valid krbtgt principal name."
action          "Create shorter cellname alias for target cell."
attributes      svc_c_sev_error
sub-component   dhd_s_pkcache
end

start
code            dced_s_pkcache_mkdir_error
text            "directory creation error"
explanation     "Unable to create a directory component
                 of the KDC cache file path."
action          "Check permissions on DCELOCAL/etc/security to
                 ensure root can create directories and files
                 there."
attributes      svc_c_sev_error
sub-component   dhd_s_pkcache
end

start
code            dced_s_pkcache_key_fresh
text            "public key cache is fresh"
explanation     "The cache file for the requested cell's krbtgt
                 public key has been updated within the past 5
                 minutes"
action          "Either wait five minutes and request update
                 again, or read cached key value using the
                 sec_pubkey_retrieve_kdc_key interface."
attributes      svc_c_sev_error
sub-component   dhd_s_pkcache
end
...\" END /dce/src/admin/dced/idl/dhd.sams.diff
.cF
.P
.H 1 "REMOTE INTERFACES"
.P
.H 2 "KDC Public Key Cache API"
.P
Not-yet-authenticated clients using the DCE Public Key Login protocol
need access to a trusted copy of the public key of the KDC of the
cell to which they belong.  The following new remote interface has
been added to \*(lBdced\*(lE to support retrieval of the KDC public
key by an authenticated client (\*(lBdced\*(lE) on behalf of the
unauthenticated client.
.P
Applications should not invoke this interface directly, but rather
go through the \*(lBsec_pubkey_retrieve()\*(lE API using the
\*(lBsec_pk_domain_pk_kdc_cache\*(lE domain.  This will attempt to
read the public key from the cache file, and if that fails, will
call \*(lBdced\*(lE to obtain the key.
.P
If a key is successfully obtained using
\*(lBsec_pubkey_retrieve()\*(lE and the
\*(lBsec_pk_domain_pk_kdc_cache\*(lE domain, but the key obtained does
not successfully verify the KDC signature on the returned PADATA, it
may be due to the KDC public key pair having been changed since the
public key was cached on the local node.  In this case,
login clients may choose to invoke the \*(lBsec_pubkey_retrieve()\*(lE
API again, this time with the
\*(lBsec_pk_domain_pk_kdc_cache_refresh\*(lE domain.  This API will
first verify that the cached KDC key is at least 5 minutes old, and if
so will invoke the \*(lBrsec_pk_cache_kdc_key()\*(lE remote interface
to obtain a fresh cache copy of the KDC key.
.P
.cS
...\" .so /dce/src/security/idl/rsec_pk_cache.idl
/*
 * @OSF_COPYRIGHT@
 */
/*
 * Copyright (c) Hewlett-Packard Company 1996
 * Unpublished work. All Rights Reserved.
 *
 * rsec_pk_cache.idl - Remote request for dced to cache or
 * refresh the public key of a KDC
 *
 */

[
    uuid(d9a38608-688d-11cf-ae3c-08000919ebb5),
    pointer_default(ptr),
    version(1.1)
]

interface rsec_pk_cache {

import "dce/rgynbase.idl";
import "dce/sec_pk_base.idl";

/* r s e c _ p k _ c a c h e _ k d c _ k e y
 *
 * rsec_pk_cache_kdc_key - this routine requests dced to
 * obtain and cache, or refresh cache, of public key of
 * the KDC of a specified cell.  The key is cached in
 * the file ${KDC_PUBKEY_CACHE_DIR}/<cell>/${KDC_PUBKEY_CACHE_FILE}
 * (KDC_PUBKEY_CACHE_DIR/FILE defined in security/h/rca_fileloc.h).
 *
 * Keys may be retrieved from this file via the
 * sec_pubkey_retrieve() interface with domain
 * sec_pk_domain_pk_kdc_cache.  The sec_pubkey interface invokes
 * the rsec_pk_cache_kdc_key interface if the cache is empty or
 * a refresh request is being made.
 *
 * rsec_pk_cache_kdc_key refuses to refresh an existing
 * cache file if it has been written within the past five
 * minutes.  This is intended to stall denial-of-service
 * attacks.
 *
 * In Parameters
 *   cell           - canonical cell name (/.../cell_name)
 *   usage          - must be "sec_pk_usage_digitalSignature" in the
 *                    reference implementation.
 *   kvno           - pointer to key version desired (or NULL)
 *
 * Out Parameters
 *   kvno           - pointer to key version returned (or NULL)
 *   public_key     - DER-encoded public key value
 *
 * Returns:
 *   dced_s_pkcache_cellname_invalid - bad cellname
 *   dced_s_pkcache_usage_unsupp - usage value unsupported
 *   dced_s_pkcache_key_fresh - key was cached recently
 *            (within KEY_CACHE_STALE_SECS)
 */
error_status_t rsec_pk_cache_kdc_key (
    [in]    handle_t                handle,
    [in]    sec_rgy_name_t          cell,
    [in]    sec_pk_usage_flags_t    usage,
    [in,out] unsigned32             *kvno,
    [out]   sec_pk_pubkey_t         *pubkey_p
);
}
...\" END /dce/src/security/idl/rsec_pk_cache.idl
.cF
.P
.H 2 "krb.mvr"
.P
The DCE Public Key Login credentials are contained within
the pre-authentication data fields of the Kerberos V5
\*(lBKRB_AS_REQ\*(lE and \*(lBKRB_AS_REP\*(lE protocol messages
[IETF 1510].  The credentials are stored in pre-authentication
structures of new types \*(lBKRB5_PADATA_ROOT_CERT\*(lE and
\*(lBKRB5_PADATA_PUBLIC_REP\*(lE.
.P
The credentials used in the DCE public key TGT acquisition
protocol are defined in changes and additions to the existing file
\*(lBsecurity/krb5/lib/mvr/krb.mvr\*(lE, listed here.
.P
.nS
In the reference implementation, the \*(lBmavros\*(lE compiler is
used to generate ASN.1 DER encode and DER/BER decode stubs for use
within the \*(lBsec_login\*(lE and KDC implementations.  For
those constructs \*(lBmavros\*(lE is unable to handle, hand-generated
stubs have been constructed.
.nF
.P
.cS
...\" .so /dce/src/security/krb5/lib/mvr/krb5.mvr.diff
EncTicketPart ::=       [APPLICATION 3] SEQUENCE {
        flags[0]        TicketFlags,
        key[1]          EncryptionKey,
        crealm[2]       Realm,
        cname[3]        PrincipalName,
        transited[4]    TransitedEncoding,
        authtime[5]     KerberosTime,
        starttime[6]    KerberosTime OPTIONAL,
        endtime[7]      KerberosTime,
        renew-till[8]   KerberosTime OPTIONAL,
        caddr[9]        HostAddresses OPTIONAL,
        authorization-data[10]  AuthorizationData OPTIONAL
}

--
-- RFC 1510 (as of 6/10/96) currently marks the sname field of a
-- KDC-REQ-BODY as optional. DCE however, does not. Moreover, MIT's
-- current KRB5 implementation does not follow RFC 1510, which states
-- that the sname can only be absent when the ENC-TKT-IN-SKEY option
-- is specified. We have suggested changing the RFC to make sname a
-- mandatory field; this change will probably be in the next
-- revision.
--

--
-- additions from v5b6
-- !!! asn.1 is approximate..
--

ETYPE-INFO-ENTRY ::= SEQUENCE {
        etype[0]         INTEGER,
        salt[1]          OCTET STRING OPTIONAL
}

ETYPE-INFO ::= SEQUENCE OF ETYPE-INFO-ENTRY

PA-ENC-TS-ENC   ::= SEQUENCE {
        patimestamp[0]   KerberosTime, -- client's time
        pausec[1]        INTEGER OPTIONAL
}

--
-- Additions for Public Key Authentication --
--
PA-PK-AS-ROOT ::= SEQUENCE {
        rootCert[0]         SEQUENCE OF OCTET STRING,
        signedAuth[1]       SignedPKAuthenticator
}

SignedPKAuthenticator ::= SEQUENCE {
        authent[0]          PKAuthenticator,
        authentSig[1]       Signature
}

PKAuthenticator ::= SEQUENCE {
        cksum[0]            Checksum OPTIONAL,
        cusec[1]            INTEGER,
        ctime[2]            KerberosTime,
        nonce[3]            INTEGER,
        kdcRealm[4]         Realm,
        kdcName[5]          PrincipalName
}

Signature ::= SEQUENCE {
        sigType[0]          INTEGER,
        kvno[1]             INTEGER OPTIONAL,
        sigHash[2]          OCTET STRING
}
PA-PK-AS-REP ::= SEQUENCE {
        kdcCert[0]          SEQUENCE OF Certificate,
        encryptShell[1]     EncryptedData, -- EncPaPkAsRepPartShell
                                    -- encrypted by encReplyPartKey
        encryptKey[2]       EncryptedData  -- EncPaPkAsRepTmpKey
                                       -- encrypted by userPublicKey
}

EncPaPkAsRepPartShell ::= SEQUENCE {
        encReplyPart[0]     EncPaPkAsRepPart,
        encReplyPartSig[1]  Signature -- encReplyPart
                                      -- signed by kdcPrivateKey
}

EncPaPkAsRepPart ::= SEQUENCE {
        encReplyKey[0]      EncryptionKey,
        nonce[1]            INTEGER
}

EncPaPkAsRepTmpKey ::= SEQUENCE {
        encReplyTmpKey[0]   EncryptionKey
}

Certificate ::= SEQUENCE {
-- !!! large chunks temporary; not intended to be permanent..
--      version             [0]  Version, --  DEFAULT v1,
--      serialNumber        CertificateSerialNumber,
--      signature           AlgorithmIdentifier,
        issuer              PrincipalName,
--      validity            Validity,
        subjectRealm        Realm,
        subject             PrincipalName,
--      subjectPublicKeyInfo SubjectPublicKeyInfo,
--      issuerUniqueID   [1]  IMPLICIT UniqueIdentifier OPTIONAL,
--      subjectUniqueID  [2]  IMPLICIT UniqueIdentifier OPTIONAL,
        authentSig          Signature
}

--
-- End of Additions for Public Key Authentication --
--
...\" END /dce/src/security/krb5/lib/mvr/krb5.mvr.diff
.cF
.P
.H 2 "krb5.h"
.P
DCE types corresponding to the ASN.1 data that need to be manipulated
by DCE clients are defined in additions to the existing file
\*(lBsecurity/krb5/include/krb5/krb5.h\*(lE, shown here.
.P
.cS
...\" .so /dce/src/security/krb5/include/krb5/krb5.h.diff
#define OSF_DCE_ARCHAISM
#define OSF_DCE_FEATURE

typedef struct _krb5_pa_enc_ts {
    krb5_timestamp      patimestamp;
    krb5_int32          pausec;
} krb5_pa_enc_ts;

/********************
 * Public Key Login *
 ********************/

typedef struct _krb5_pk_authenticator {
    krb5_checksum  *cksum; /* checksum, includes type,
                              optional */
    krb5_int32     cusec;  /* client usec portion */
    krb5_timestamp ctime;  /* client sec portion */
    krb5_int32     nonce;  /* nonce */
    krb5_principal kdcname;/* KDC name/realm */
} krb5_pk_authenticator;

typedef struct _krb5_signed_pk_authenticator {
    krb5_pk_authenticator pk_authenticator;
    krb5_enc_data   authentsig; /* signature of
                                   pk_authenticator */
} krb5_signed_pk_authenticator;

typedef struct _krb5_pa_pk_as_root {
    krb5_data       root_cert;   /* not used in DCE Pubkey */
    krb5_signed_pk_authenticator authent;
} krb5_pa_pk_as_root;

typedef struct _krb5_enc_pa_pk_as_rep_part {
    krb5_keyblock  enc_reply_key; /* used to encrypt reply */
    krb5_int32     nonce;         /* copied from request */
} krb5_enc_pa_pk_as_rep_part;

typedef struct _krb5_enc_pa_pk_as_rep_part_shell {
    krb5_enc_pa_pk_as_rep_part reply;
    krb5_enc_data  replysig; /* signature of reply */
} krb5_enc_pa_pk_as_rep_part_shell;

typedef struct _krb5_pa_pk_as_rep {
    krb5_data     kdc_cert;          /* not used in DCE Pubkey */
    krb5_enc_data enc_tmp_key;       /* krb5_keyblock */
    krb5_enc_data enc_shell; /* krb5_enc_pa_pk_as_rep_part_shell */
} krb5_pa_pk_as_rep;

/***************************
 * End of Public Key Login *
 ***************************/

#endif /* OSF_DCE_FEATURE */


/*
 * This structure is returned in the e-data field of the KRB-ERROR
 * message when the error calling for an alternative form of
 * authentication is returned, KRB_AP_METHOD.
 */
typedef struct _krb5_alt_method {
#ifndef OSF_DCE_ARCHAISM
        krb5_magic      magic;
#endif
        krb5_int32      method;
        int             length;
        krb5_octet      *data;
} krb5_alt_method;

/*
 * A null-terminated array of this structure is returned by the KDC
 * as the data part of the ETYPE_INFO preauth type.  It informs the
 * client which encryption types are supported.
 */
typedef struct _krb5_etype_info_entry {
#ifndef OSF_DCE_ARCHAISM
        krb5_magic      magic;
#endif
        krb5_enctype    etype;
        int             length;
        krb5_octet      *salt;
} krb5_etype_info_entry;

typedef krb5_etype_info_entry ** krb5_etype_info;
...\" END /dce/src/security/krb5/include/krb5/krb5.h.diff
.cF
.P
.H 1 "MANAGEMENT INTERFACES"
.P
Minimal management interfaces are provided.  If a vendor chooses to add other
implementations of the DCE Personal Security Module, then the vendor
should expect to add management interfaces for configuring the new
mechanism for a cell or principal.
.P
.H 2 "Installation"
.P
Installing the new public key functionality requires only stopping
DCE, installing the software upgrades (client, security server), and
restarting DCE.
.P
.H 2 "DCE Security Service Configuration"
.P
.H 2 "Enabling OSF DCE 1.2.2 Features"
.P
By default, all OSF DCE 1.2.2 features are disabled in a cell
originally configured with a release prior to OSF DCE 1.2.2.
Once software supporting DCE Public Key Login has been installed on
all DCE Security Server replicas, public key functionality, along with
other OSF DCE 1.2.2 functionality, can be enabled using
the following \*(lBdcecp\*(lE command:
.P
.cS
dcecp> registry modify -version secd.dce.1.2.2
.cF
.P
When OSF DCE 1.2.2 features are enabled,
any DCE Security Server replicas that do not support OSF DCE 1.2.2 features are shut down
automatically.
.P
A new cell configured with OSF DCE 1.2.2 release software has
OSF DCE 1.2.2 features enabled from the start.
.P
.H 2 "Enabling Public Key Login"
.P
After the OSF DCE 1.2.2 features have been enabled,
the cell administrator can request generation of the
initial KDC public key key-pair using the following \*(lBdcecp\*(lE
command:
.P
.cS
dcecp> account modify krbtgt/<cell> -pkgenprivkey <modulus size>
.cF
.P
In response to this command, the DCE Security Registry
generates a key-pair for the KDC,
storing the public key portion in the
\*(lBDCEPKAuthentication\*(lE ERA attached to the
\*(lBkrbtgt\*(lE principal for the cell and storing the private key
in the Registry under existing Registry password-protection
encryption.
.P
On each client node supporting public key login, the
\*(lBdced\*(lE daemon retrieves the krbtgt principal's public key when
requested by \*(lBsec_login\*(lE, allowing authorized principals
to log in using DCE public keys on that client node.  See
\*(qBKDC Public Key Caching\*(qE under \*(qBFUNCTIONAL
DEFINITION\*(qE for more information.
.P
.H 2 "Configuring Public Key Login Users"
.P
The cell administrator must use the \*(lBdcecp> account create/modify
<user name> .... \*(lE command with the \*(lB-pkmechanism\*(lE,
\*(lB-pksignatureusage\*(lE, and \*(lB-pkkeycipherusage\*(lE options
to create a public key account or modify
a regular account to become a public key account.  See the \*(qBUSER
INTERFACES\*(qE section for more information.
.P
Optionally, the cell administrator can attach an instance of the
\*(lBpre_auth_req\*(lE ERA to the public key account principal with a value of
\*(lBPADATA-ENC-PUBLIC-KEY\*(lE (3) to prevent the principal
from logging in with any protocol other than public key.
.P
After the public key account has been created,
if the user's private key storage mechanism (\*(lB-pkmechanism\*(lE) is \*(lBfile\*(lE, the
cell administrator must move the user's private key file from the administrator's working
node, to the user's workstation and change the ownership of the file to the user.
The private key file is located in
\*(lB/opt/dcelocal/var/security/pk_file/<principal_UUID>\*(lE.
.P
By default, only the cell administrator can create or modify a user's public key
key-pair.
.P
Optionally, the cell administrator can allow a user to change her own
public key key-pair by changing the ACL of two ERAs \*(EM
\*(lBDCEPKAuthentication\*(lE and \*(lBDCEPKKeyEncipherment\*(lE.
The following \*(lBdcecp\*(lE command accomplishes this:
.P
.cS
dcecp>  xattr modify /.:/sec/xattrschema/DCEPKAuthentication
        -aclmgr {principal {query r} {update u}
                      {test r} {delete m}}
.cF
.P
.H 1 "RESTRICTIONS AND LIMITATIONS"
.P
.H 2 "Exportability"
.P
.H 3 "Export of Binary (Executable) Code"
.P
The functionality provided by the binary code for the
\*(lBsec_psm_encrypt_data()\*(lE and \*(lBsec_psm_decrypt_data()\*(lE
functions is not exportable unless its use is confined to the
authentication process in such a way that users are unable to use the
interfaces to encrypt and decrypt arbitrary data.
.P
There may also be export issues with the binary code for the
\*(lBsec_psm_sign_data()\*(lE and \*(lBsec_psm_verify_data()\*(lE
functions, depending on algorithm, usage, and key length.
.P
For U.S. vendors and ISVs, OSF DCE provides partial (source-code
level) support for building an internationally exportable
version of OSF DCE from the Domestic sources.  However, this
support does not necessarily extend to full (binary-code level)
support for building exportable binaries.  It is the
responsibility of each vendor/ISV to determine how to build such
a product for their platform, and to verify that the resulting
product is indeed exportable.
.P
To create an exportable product, each vendor should do the following to handle
the BSAFE library:
.aL
.LI
Make the necessary libdce Makefile change, so libbsafe2.a is linked
into the shared libdce in an exportable manner.  Please note, we
do not
recommend linking the BSAFE lib into an archive libdce due to export
and licensing issues.
.LI
Use "nm libbsafe2.a" to extract all the symbols in the BSAFE lib and
do all the necessary steps to hide or scramble all the BSAFE symbols
to meet the export requirements and potential licensing issues.
.LE
.P
Minimally, the following must be done to ensure that Public Key
Login limits its use of encryption:
.P
.iS
Define \*(lBDES_HIDDEN\*(lE for the build of any component
that would support encryption and/or decryption in the Domestic
build.
.P
No matter how the above is accomplished, it should be understood
that this is limited source-code level support, not full
binary-code level support for building the Domestic DCE sources
for export.  Each vendor remains responsible for making sure
that the above steps and any additional work to hide and remove
encryption have resulted in a product that complies with the
applicable export laws.\*(f!
.FS
This is the same advice that has held for all releases of DCE,
not just the present DCE 1.2.2 public key work.
.FE
.P
.H 3 "Export of Source Code"
.P
OSF DCE 1.2.2 source includes no-encryption stubs for the
operations in the \*(lBsec_psm\*(lE layer in the international
version, similar to those supplied now for DES.
.P
.H 2 "Size"
.P
The public key cryptosystem libraries do not add significantly to
the size of a DCE client.  The increase rates of the related libraries
and binaries are:
.P
.cS
libdce.sl:   .06 %
libdcecp.sl: .07 %

dced:        .05 %
secd:      14%
.cF
.P
.H 2 "Performance"
.P
The public key cryptosystem operations degrade the
performance of DCE client logins, due to the increased
complexity of the arithmetic operations involved.  Both public
key and non-public key logins are affected, since the
clients attempt the public key login protocol first.
.P
The performance result of different login protocols are as follows:
.P
The time it takes to perform a non-public key login in 1.2.2 is roughly 1.8 times
the time it takes in 1.2.1.   In 1.2.2, public key login takes
about 1.3 times the
time required for non-public key login.
.P
.nS
In the reference implementation, there has been no optimization done on the login protocols, and
it is expected that the time required for non-public key login in
1.2.2 could be reduced significantly.
.nF
.P
.H 1 "OTHER COMPONENT DEPENDENCIES"
.P
.H 2 "DCE Certification API"
.P
Integration with the DCE Certification API specified in [RFC 80.0] is
not included in this project.
.P
.H 2 "DCE Private Key Storage Server"
.P
Integration with the DCE Private Key Storage Server specified in
[RFC 94.0] is not included in this project, although some components
of the integration such as UUID values are shown in this specification.
Integration has been done as part of the overall OSF DCE 1.2.2 project
by the PKSS supplier.
.P
.H 2 "Pluggable Authentication Modules (PAM)"
.P
[RFC 86.0] outlines integration of \*(qBPluggable Authentication
Modules\*(qE (PAM) into DCE.  It is expected that the entire DCE Login
mechanism, in which the functionality specified here is buried, will
be wrapped inside a single PAM, and thus there will be no issues
specific to the public key aspects of DCE Login.  Since the timeframe
for [RFC 86.0] is beyond the timeframe for DCE Public Key Login, no
further investigation of integration will be done as part of the
Public Key Login project.
.P
.H 1 "COMPATIBILITY"
.P
.H 2 "Interoperability"
.P
Clients attempting to use the new protocols with a security
server that does not support the new protocols will receive an
error in the \*(lBKRB_AS_REP\*(lE indicating that the
pre-authentication data supplied is not supported
(\*(lBKRB5KDC_ERR_PADATA_TYPE_NOSUPP\*(lE).  The client
then (unless the \*(lBKRB_AS_REP\*(lE error information indicates the client is
required to use public key login) attempts to use the existing password-based protocol (which
will also fail if the principal does not have a valid DCE
password).
.P
Clients attempting to use the new protocols with a pre-DCE 1.1
security server (where PADATA is ignored) will receive
a standard pre-DCE 1.1 \*(lBKRB_AS_REP\*(lE with the TGT
protected by the user's long-term DCE key.
.P
Users who have invalid passwords, but valid entries for the
\*(lBDCEPKKeyEncipherment\*(lE and \*(lBDCEPKAuthentication\*(lE
ERAs will be unable to log in from client nodes that do not
support the new protocols, or that do not support a Personal
Security Module with access to the user's private key.
.P
See table in the \*(qBTGT Acquisition Protocol\*(qE section for
more information on compatibility.
.P
.H 2 "Migration"
.P
Migration code has been provided to convert existing DCE
1.2.1 security server data to DCE 1.2.2 formats.  Conversion of the DCE Registry database is triggered
automatically when \*(lBsecd\*(lE is started up by checking the
database version stored in the database against the version in
the binary.  If different, the automatic database conversion
code in \*(lBsecd\*(lE is invoked.
.P
Migration code has been provided that will allow public key protocols
to be enabled in the cell only when all replicas
support the protocols.  See \*(qBEnabling Public Key Login\*(qE
under \*(qBMANAGEMENT INTERFACES\*(qE.  Once the new protocols
have been enabled, it is not possible to add a non-public
key security server to the cell without reconfiguring all
security servers as non-public key servers.
.P
When the public key protocols are enabled, migration code
is invoked automatically to add the schema entries for
the \*(lBDCEPKKeyEncipherment\*(lE,
\*(lBDCEPKAuthentication\*(lE, and
\*(lBDCEPKPrivateKeyStorage\*(lE
ERAs.
.P
.H 1 "STANDARDS"
.P
[ITU X.208], [ITU X.209], [IETF 1510].
.P
.H 1 "OPEN ISSUES"
...\"PUBLISH_CHECK
.P
.aL
.LI
Size of pre-authentication data in the future when certificates are
supported.  The entire \*(lBKRB_AS_REQ\*(lE and \*(lBKRB_AS_REP\*(lE
messages need to fit into a UDP packet, so there is a size limit
of 1k bytes or so.
.P
The plan is to transmit the certificates out-of-band.  The pre-authentication
data could contain the signature of the certificate to be used.
.LE
...\" =========================================================================
...\" Appendices go here, using aH macros.
...\" =========================================================================
...\".aH "<APPENDIX TITLE>"
...\"<Appendix contents go here.>
...\" =========================================================================
...\" References go here, as an unnumbered heading.
...\" =========================================================================
.HU "REFERENCES"
.P
.VL 12 0
.LI "[DRAFT-PKINIT]"
IETF, \*(qBdraft-ietf-cat-kerberos-pk-init-01.txt\*(qE, by Clifford
Neuman, Brian Tung, and John Wray, June 1996.
Subsequently replaced by \*(qBdraft-ietf-cat-kerberos-pk-init-02.txt\*(qE
.LI "[IETF\ 1510]"
IETF, \*(qBRFC 1510: The Kerberos Network Authentication Service
(V5)\*(qE, by J. Kohl and C. Neuman, September 1993.
.LI "[ITU\ AM1]"
ITU, \*(qBPDAM 1 to ITU-T X.509 (1993) | ISO/IEC 9594-8:1995,
Information Technology \*(EM Open Systems Interconnection \*(EM The
Directory: Authentication Framework\*(qE, ISO/IEC JTC 1/SC 21 N 9214,
December 1994.
.LI "[ITU\ AM4]"
ITU, \*(qBPDAM 4 to ITU-T X.511 (1993) | ISO/IEC 9594-3:1995,
Information Technology \*(EM Open Systems Interconnections \*(EM The
Directory: Abstract Service Definition\*(qE, ISO/IEC JTC 1/SC 21 N,
24 November 1995.
.LI "[ITU\ X.208]"
ITU, \*(qBRecommendation X.208: Specification of abstract syntax
notation one (ASN.1)\*(qE, ISO/IEC 8824, 1987.
.LI "[ITU\ X.209]"
ITU, \*(qBRecommendation X.209: Specification of Basic Encoding Rules
for Abstract Syntax Notation One (ASN.1).\*(qE, ISO/IEC 8825, 1987.
.LI "[ITU\ X.509]"
ITU, \*(qBFinal Text of the 1993 Edition of ISO/IEC 9594-8/ITU-T Rec
X.509, Information Technology \*(EM Open Systems Interconnection \*(EM
The Directory: Authentication Framework\*(qE, ISO/IEC JTC 1/SC 31 N
8696, 28 June 1994.
.LI "[ITU\ X.511]"
ITU, \*(qBISO/IEC 9594-3/ITU-T Rec X.511, Information Technology
\*(EM Open Systems Interconnection \*(EM The Directory: Abstract Service
Definition\*(qE, 1993 (E).
.LI "[PKCS\ 8]"
RSA Laboratories, \*(qBPKCS #8: Private-Key Information Syntax
Standard\*(qE, Version 1.2, November 1, 1993.
.LI "[RFC\ 6.0]"
J. Pato, \*(qBA Generic Interface for Extended Registry
Attributes\*(qE, June 1992.
.LI "[RFC\ 68.1]"
A. Anderson, J. Wray, \*(qBDCE 1.2 Public-Key Login \*(EM Functional
Specification\*(qE, February 1995.
.LI "[RFC\ 80.0]"
J. Wray, \*(qBDCE Certification API \*(EM Functional
Specification\*(qE, January 1995.
.LI "[RFC\ 85.0]"
M. Warner, \*(qBImproved Public Key Login Protocols for DCE\*(qE,
October 1995.
.LI "[RFC\ 86.0]"
V. Samar, R. Schemers, \*(qBUnified Login with Pluggable
Authentication Modules (PAM)\*(qE, October 1995.
.LI "[RFC\ 94.0]"
J. Wray, \*(qBDCE Private Key Storage Server\*(qE, to appear.
.LE
.P
.ne 3+5
.HU "AUTHORS' ADDRESSES"
.P
...\"PUBLISH_CHECK
.tl $Anne H. Anderson$$Internet e-mail: aha@apollo.hp.com$
.tl $Hewlett-Packard Company$$Telephone: +1-508-436-5707$
.tl $300 Apollo Drive$$$
.tl $Chelmsford, MA 01824$$$
.tl $USA$$$
.P
.ne 5
...\"PUBLISH_CHECK
.tl $Sue-Fen Wang Cuti$$Internet e-mail: cuti@apollo.hp.com$
.tl $Hewlett-Packard Company$$Telephone: +1-508-436-4241$
.tl $300 Apollo Drive$$$
.tl $Chelmsford, MA 01824$$$
.tl $USA$$$
...\" Local Variables: ##
...\" fill-column: 70 ##
...\" mode: nroff ##
...\" End: ##
