...\" DCE-RFC 48.3
...\"
...\" FORMATTING INSTRUCTIONS for this document:
...\"       nroff -Tlpr rfc48.3.roff > rfc48.3.txt
...\"       pic rfc48.3.roff | troff -Tps | <ps-post-processor> > rfc48.3.ps
...\"       (Also uses xfig and fig2dev -L pic *.fig > *.pic.)
...\" (Where "troff" means "device-independent troff", or "ditroff".)
...\"
...\" If troff is not supported for a given RFC, insert the following:
...\" .if t \{\
...\" .tm *** Troff not supported for this RFC.
...\" .ex \}
...\"
...\" =========================================================================
...\" This template first sets a bunch of *roff options (authors/readers
...\" don't usually have to know about these).
...\" Then it defines some strings and macros, many of which deal with
...\" things that differ between nroff & troff (some of these may not be
...\" perfect, but they're better than nothing -- to do a really good
...\" job would require a real semantic markup language.
...\" Convention: "Begin/End" for strings, "Start/Finish" for macros.
...\" Strings:
...\"       \*(f!        - Footnote string (replaces \*F).
...\"       \*(hB, \*(hE - Page header/footer font (internal use).
...\"       \*(kB, \*(kE - Doc header font (internal use).
...\"       \*(qB, \*(qE - Quotations.
...\"       \*(iB, \*(iE - Italics/emphasis in primary font.
...\"       \*(bB, \*(bE - Bold font.
...\"       \*(lB, \*(lE - Literal font.
...\"       \*(jB, \*(jE - Italics/emphasis in literal font.
...\"       \*(nH        - Default note header string.
...\" Macros:
...\"       .aH      - Appendix header macro (uses number register \na).
...\"       .aL      - Automatic list macro (replaces .AL; uses num reg \ng).
...\"       .tS, .tF - Title start/finish (internal use).
...\"       .cS, .cF - Displays (no-fill) without indentation.
...\"       .dS, .dF - Displays (no-fill) with indentation.
...\"       .iS, .iF - Indented (fill) text.
...\"       .nS, .nF - Note.
...\" -------------------------------------------------------------------------
...\" First, set up some number registers here (instead of on command line),
...\" and include the "mm" macro package here (instead of on command line).
...\" -------------------------------------------------------------------------
.if n .nr L 66 \" Nroff page length = 66 lines.
.if t .nr L 11i \" Troff page length = 11 inches.
.if n .nr W 72 \" Nroff page width = 72 columns.
.if t .nr W 6.5i \" Troff page width = 6.5 inches.
.if n .nr O 3 \" Nroff page offset = 3 columns.
.if t .nr O 0.75i \" Troff page offset = 0.75 inches.
.nr N 2 \" No header on page 1.
.so /usr/lib/tmac/tmac.m \" Points to "mm" package, in /usr/lib/macros.
...\" -------------------------------------------------------------------------
...\" Next, twiddle the "mm" package to suit our preferred style.
...\" -------------------------------------------------------------------------
...\" Point size and font types.
...\" -------------------------------------------------------------------------
.if n .fp 1 R \" "Regular" font ONLY -- don't use any others in nroff.
.if t \{ .S 10 12 \" Point size = 10, vertical spacing = 12.
...\" Note: Some systems give different names to these fonts.
.fp 1 R \" Times roman.
.fp 2 I \" Times italic.
.fp 3 B \" Times bold.
.fp 4 BI \" Times bold italic.
.fp 5 CW \" Courier.
.fp 6 CI \" Courier oblique.
.fp 7 CB \" Courier bold.
.fp 8 CX \" Courier bold oblique.
.fp 9 H \" Helvetica.
.fp 10 HI \" Helvetica oblique.
.fp 11 HB \" Helvetica bold.
.fp 12 HX \" Helvetica bold oblique.
.fp 13 S \} \" Special symbol font -- normally only called automatically.
...\" -------------------------------------------------------------------------
...\" Headings; page header and footers; titles.
...\" -------------------------------------------------------------------------
.nr Ej 0 \" No eject for first-level headings.
.nr Hs 7 \" Heading space level = blank line after heading (all levels).
.nr Hb 7 \" Heading break level = break after heading (all levels).
.nr Hi 1 \" Post-heading indent = paragraph indent.
.nr Hc 0 \" Heading centering = none.
.if n .ds HF 1 1 1 1 1 1 1 \" Heading fonts = regular (no underlining).
.if t .ds HF 11 11 11 11 11 11 11 \" Heading fonts = Helvetica bold.
.if t .ds HP 0 0 0 0 0 0 0 \" Heading point sizes (= default).
.HM 1 1 1 1 1 1 1 \" Heading mark = arabic (all levels).
.nr Hu 1 \" Unnumbered heading level = 1 (see aH macro, below).
.de HX \" Beginning-of-heading processing.
.in 0 \" Left justify headings.
.ie     \\$2=0 .ds }0\" Null string heading mark for HU.
.el .ie \\$1=1 .ds }0 \\n(H1.\ \&\" Heading marks = dotted sections + 1 space.
.el .ie \\$1=2 .ds }0 \\n(H1.\\n(H2.\ \&
.el .ie \\$1=3 .ds }0 \\n(H1.\\n(H2.\\n(H3.\ \&
.el .ie \\$1=4 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\ \&
.el .ie \\$1=5 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\ \&
.el .ie \\$1=6 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\\n(H6.\ \&
.el .if \\$1=7 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\\n(H6.\\n(H7.\ \&
..
.de HZ \" End-of-heading processing.
.if n .in 3 \" Indent body of doc by 3 columns in nroff.
.if t .in 0 \" Don't indent in troff.
..
.if n .ds hB \&\" Page header/footer font begin in nroff.
.if t .ds hB \f9\" Page header/footer font begin in troff.
.if n .ds hE \&\" Page header/footer font end in nroff.
.if t .ds hE \fP\" Page header/footer font end in troff.
.if n .ds kB \&\" Doc header font begin in nroff.
.if t .ds kB \f(11\" Doc header font begin in troff.
.if n .ds kE \&\" Doc header font end in nroff.
.if t .ds kE \f1\" Doc header font end in troff.
.de tS \" Title start.
.SP 2 \" 2 blank lines.
.ce 99 \" Center (each line of) title.
.if t \{ .ft 11 \" Bold helvetica.
.S +2 D \} \" Bigger point size.
..
.de tF \" Title finish.
.ce \" Turn off centering.
.SP 1 \" 1 blank line.
.if t \{ .ft 1 \" Return to regular font.
.S P P \} \" Return to regular point size.
..
...\" -------------------------------------------------------------------------
...\" Special Appendix heading macro, .aH.
...\" -------------------------------------------------------------------------
.nr a 0 1 \" Appendix number.
.af a A \" Assign format upper-case alpabetic to number register a.
.de aH \" Appendix heading macro.
.if \\na=0 \{ .nr H1 0 \" Reset H1 to 0.
.HM A 1 1 1 1 1 1 \} \" Heading mark = Upper case alphabetic + arabics.
.HU "APPENDIX \\n+a.  \\$1"
..
...\" -------------------------------------------------------------------------
...\" Paragraph stuff.
...\" -------------------------------------------------------------------------
.nr Pt 0 \" Paragraph type = left-justified.
.nr Pi 0 \" Paragraph indent = 0.
.nr Ps 1 \" Paragraph spacing = 1 blank space.
...\" -------------------------------------------------------------------------
...\" Special list macro, .aL (replaces .AL, for all levels).
...\" This should be used for almost all lists (including ".LI "\ "").
...\" The only exception is variable lists (.VL, indented by multiples of 6).
...\" -------------------------------------------------------------------------
.de aL
.nr g \\n(:g
...\" In-line lists should be numbered (by hand): (1), (2), (3), ...
.ie     \\ng=0 .LB 6 0 1 3 a \" 1st level: (a), (b), (c), ...
.el .ie \\ng=1 .LB 6 0 1 3 i \" 2nd level: (i), (ii), (iii), ...
.el .ie \\ng=2 .LB 6 0 1 4 a \" 3rd level: [a], [b], [c], ...
.el .ie \\ng=3 .LB 6 0 1 4 i \" 4th level: [i], [ii], [iii], ...
.el .ie \\ng=4 .LB 6 0 1 6 a \" 5th level: {a}, {b}, {c}, ...
.el .if \\ng=5 .LB 6 0 1 6 i \" 6th level: {i}, {ii}, {iii}, ...
..
.nr Ls 6 \" Blank lines between all list items, by default (but adjustable).
...\" -------------------------------------------------------------------------
...\" Footnote stuff; special footnote string, \*(f!.
...\" -------------------------------------------------------------------------
.if n .ds f! [\\n+(:p]\" Footnote string (replaces \*F in nroff).
.if t .ds f! \\*F\" Footnote string (same as \*F in troff).
.if n .FD 6 \" Footnotes not hyphenated or indented, label left justified.
.if t .FD 5 \" Footnotes hyphenated, not indented, label left justified.
.nr Fs 1 \" 1 blank line between footnotes.
...\" -------------------------------------------------------------------------
...\" Line adjustment stuff.
...\" -------------------------------------------------------------------------
.if n .nr Hy 0 \" No hyphenation in nroff.
.if t .nr Hy 1 \" Hyphenate in troff.
.if n .SA 0 \" Set adjust: left margin only in nroff.
.if t .SA 1 \" Set adjust: left and right margins in troff.
...\" -------------------------------------------------------------------------
...\" Miscellaneous stuff.
...\" -------------------------------------------------------------------------
.ta \" No tabs by default -- set them up by hand as needed.
.nr Si \n(Ls \" Default indent for .DS display macro = 6 (use in troff only).
...\" -------------------------------------------------------------------------
...\" Displays.
...\" -------------------------------------------------------------------------
.de cS \" Display start: no-fill, literal font, no indentation.
.P
.nf \" No fill mode.
.if t .ft 5 \" Constant width font in troff.
..
...\" Within .cS, ".ne N"'s can be added by hand, but should be minimized.
.de cF \" Display finish.
.if t .ft 1 \" Back to standard font in troff.
.fi \" Fill mode.
.P
..
.de dS \" Display start: no-fill, literal font, with indentation.
.P
.aL \" Use .aL macro for consistent indentation.
.nf \" No fill mode.
.LI "\ " \" List item will no (visible) marker.
.if t .ft 5 \" Constant width font in troff.
..
...\" Within .dS, ".ne N"'s can be added by hand, but should be minimized.
.de dF \" Display finish.
.if t .ft 1 \" Back to standard font in troff.
.fi \" Fill mode.
.LE
.P
..
.de iS \" Indent start: fill, regular font, with indentation.
.P
.aL
.LI "\ "
..
.de iF \" Indent finish.
.LE
.P
..
.ds nH NOTE\"Default note header string -- can be changed by author.
.de nS \" Note start: fill, italics font, with indentation.
.P
.aL \" Use .aL macro for consistent indentation.
.LI "\ " \" List item will no (visible) marker.
.if t .ft 2 \" Italics font in troff, and reverse roman <--> italic fonts:
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f1\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.ie \\n(.$=0 \\*(nH:\" Default header string if none supplied by author.
.el \\$1:\" Header string supplied by author as argument to .nS macro.
..
.de nF \" Note finish.
.if t .ft 1 \" Back to standard font in troff, and remap font macros:
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f2\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.LE
.P
..
...\" -------------------------------------------------------------------------
...\" Quotation marks and font toggles.
...\" -------------------------------------------------------------------------
.if n .ds qB \&"\" Quotation begin in nroff.
.if t .ds qB ``\" Quotation begin in troff.
.if n .ds qE \&"\" Quotation end in nroff.
.if t .ds qE ''\" Quotation end in troff.
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f2\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.if n .ds bB *\" Bold font begin in nroff.
.if t .ds bB \f3\" Bold font begin in troff.
.if n .ds bE *\" Bold font end in nroff.
.if t .ds bE \fP\" Bold font end in troff.
.if n .ds lB `\" Literal font begin in nroff.
.if t .ds lB \f5\" Literal font begin in troff.
.if n .ds lE '\" Literal font end in nroff.
.if t .ds lE \fP\" Literal font end in troff.
.if n .ds jB <\" Italics/emphasis literal font begin in nroff.
.if t .ds jB \fP\f6\" Italics/emphasis literal font begin in troff.
.if n .ds jE >\" Italics/emphasis literal font end in nroff.
.if t .ds jE \fP\f5\" Italics/emphasis literal font end in troff.
...\" =========================================================================
...\" Create a macro to pretty-print C++
...\" =========================================================================
.if t .ds c C\v'-1p'++\v'+1p'
.if n .ds c C++
...\" =========================================================================
...\" Finally, it's time to start writing the document!
...\" The DCE-RFC author modifies the following header/footer info.
...\" (The major/minor number is assigned by the DCE-RFC Editor.)
...\" =========================================================================
.ND "April 1996" \" Date must be hard-coded.
.PH "$\*(hBOSF-RFC 48.3$\*c Support in DCE RPC$\\\\*(DT\*(hE$"
.PF "$\*(hBViveney$$Page \\\\n%\*(hE$" \" Final version.
...\"
...\" Following are the first printed lines (header info) of the document:
...\"
\&\" Force top-of-first-page trap to position the following info correctly.
.tl $\*(kBOpen Software Foundation$$R. Viveney (DEC)\*(kE$
.tl $\*(kBRequest For Comments: 48.3$$\*(kE$
.tl $\*(kB\*(DT$$\*(kE$
.tS \" Title, in all capitals (can span multiple lines):
\*c SUPPORT IN DCE RPC IDL \*(EM
FUNCTIONAL SPECIFICATION
.tF
...\" =========================================================================
...\" Now, the actual body of the document!!
...\" Heading capitalization style:
...\"     1st level: CAPITALIZE ALL WORDS
...\"     2nd level: Capitalize Initial Letters of All (Significant) Words
...\"     3rd-7th level: Capitalize first letter of first word only
...\" =========================================================================
...\".tr ~
...\".ds HP +4 +4
...\".nr Hu 1
...\".nr a 0
...\".af a A
...\".de aH
...\".nr Hc 1
...\".nr a +1
...\".nr P 0
...\".PH "'''Appendix \\na-\\\\\\\\nP'"
...\".SK
...\".HU "\\$2"
...\".nr Hc 0
...\".HM A
...\".nr H1 \\$1-1
...\".nr H2 0
...\"..
...\".ds HF 3 3 2 2 2 2 2
...\".ND "October 21, 1994"
...\".PH ""
...\".ft B
...\".S 24
...\".ce 4
...\"Digital Equipment Corporation
...\"
...\"Functional Specification for DCE IDL
...\"With \*c Support
...\".S 100
...\".ft R
...\".sp 3
...\".ft B
...\".S 18
...\" .ce 1
...\" ABSTRACT
...\" .S 100
...\" .ft R
...\" .P
...\" The OSF Distributed Computing Environment (DCE) provides the
...\" capabilities necessary for a \*c programmer to build an object-oriented
...\" distributed application.  Utilizing these features is not a simple task,
...\" however, due to the in-depth knowledge of DCE programming required.
...\" Without additional support, the \*c programmer would be required to
...\" write a large number of simple mapping routines to jacket the stubs and
...\" map from the network to the local object representation.
...\" This document
...\" describes a set of extensions to the DCE RPC Interface Definition
...\" Language (IDL) and run time
...\" library to support generation of \*c bindings to
...\" IDL interfaces.  This support enables the \*c programmer to create and
...\" utilize objects in DCE applications in a natural manner utilizing
...\" existing IDL interface definitions and without modification to the
...\" existing IDL network protocol.
...\" This document specifies what is considered to be the essential enhancements
...\" to the DCE IDL compiler for effectively using \*c and objects in
...\" a DCE environment.
...\" .PH "'''Page \\\\nP'"
...\" .bp
.P
.H 1 "INTRODUCTION" \" Always start with an introduction section.
.P
.H 2 "Existing DCE Support"
.P
The OSF Distributed Computing Environment (DCE) provides the
capabilities necessary for a \*c programmer to build an
object-oriented distributed application.  Utilizing these
features is not a simple task, however, due to the in-depth
knowledge of DCE programming required.  Without additional
support, the \*c programmer would be required to write a large
number of simple mapping routines to jacket the stubs and map
from the network to the local object representation.  This
document describes a set of extensions to the DCE RPC Interface
Definition Language (IDL) and run time library to support
generation of \*c bindings to IDL interfaces.  This support
enables the \*c programmer to create and utilize objects in DCE
applications in a natural manner utilizing existing IDL
interface definitions and without modification to the existing
IDL network protocol.  This document specifies what is
considered to be the essential enhancements to the DCE IDL
compiler for effectively using \*c and objects in a DCE
environment.
.P
\*(bBNote that this document supersedes RFC 48.2 as the definition of
IDL \*c support planned for OSF DCE 1.2.\*(bE
.P
.H 2 "Network Interfaces"
.P
The DCE model of accessing remote services is via the network
interface of the service.  The network interface of a service is
defined by an IDL definition that exactly describes the
signatures of the operations provided by the service.  An IDL
interface definition is, in an abstract sense, equivalent to a
\*c class.  It describes an entity that provides a set of
operations and (potentially) some encapsulated data on which
those operations act.  In order for \*c applications to make use
of this equivalence, it must be mapped into a \*c class
declaration.  This document describes the necessary support to
enable the \*c programmer to control the mapping of an IDL
interface definition into a \*c class declaration.
Conceptually, the network interface of a class can also be
viewed as a refinement of the existing three access levels
provided by \*c (public, private, and protected).  The network
interface allows remote access to the public member functions of
the class.  The primary restriction imposed by the network
access level is that direct access to member fields is
prohibited.
.P
.H 2 "Overview"
.P
This section provides a high level description of functionality
necessary to support using RPC to build distributed applications
with \*c.  Trying to make \*c itself distributed is a
tremendously complicated task beyond our abilities.
Specifically, we would have to modify the \*c compiler on each
platform to support our definition of distributed objects.
Obviously, this is not acceptable.  Thus, the scope of this
effort has been limited to allowing location-independent, and
transparent access to \*c objects (either local or remote).
This is accomplished by a layered approach.  RPC limits its
interaction with the \*c compiler to only generating standard
\*c code.  This does limit the capability somewhat, while still
providing a valuable paradigm for building distributed
applications.
.P
The notation used for describing the client/server communication
protocol for DCE RPC is the Interface Definition Language.  The
IDL language consists primarily of the declarative statements of
ANSI C (constants, typedefs, and function prototypes) which is
enhanced by attributes to provide the extended information
necessary to allow distribution.  The goal of \*c support is to
allow the mapping of constructs described in an interface
definition to be mapped into \*c in a natural way.  Extensions
to the existing Interface Definition Language are described
along with implementation details.  By retaining the current
language notation, we enable interoperability between
client/server pairs regardless of their implementation language.
.P
.H 1 "TERMINOLOGY"
.P
.aL
.LI
\*(bBObject\*(bE \*(EM
A term used to describe the aggregation of data and
functionality into a unit in a software process.
.LI
\*(bBDistributed Object\*(bE \*(EM
An object that spans more than one process.
.LI
\*(bBDCE Remote Object\*(bE \*(EM
An object that is not local to the process that is accessing it,
but rather, has its implementation remoted within the DCE
environment.
.LI
\*(bBObject Interface\*(bE \*(EM
An abstraction for accessing an object instance.
.LI
\*(bBObject Reference Base Class\*(bE \*(EM
A class definition that is the basis of all DCE remote objects.
It encapsulates any information needed to carry out remoteness
of objects.
.LI
\*(bBAbstract Base Class\*(bE \*(EM
A class generated by the IDL compiler directly from the
interface definition for use within client and server
applications.
.LI
\*(bBProxy Class\*(bE \*(EM
A class generated by the IDL compiler directly from the
interface definition for use by the underlying support for DCE
remote objects.  This class is the equivalent of the DCE client
stub in procedural DCE programming in that it forwards method
invocation to the remote object implementation.
.LI
\*(bBManager Class\*(bE \*(EM
A class definition supplied by the user that implements all the
operations defined by an IDL interface to support a DCE remote
object.
.LE
.H 1 "TARGET"
.P
This technology is targeted for DCE customers who want to use
\*c to build distributed applications, for object oriented
developers who want to distribute their applications using \*c
and for object oriented technologists who want to use DCE as a
framework for building a distributed object model.
.P
.H 1 "GOALS"
.P
.aL
.LI
Provide a framework for distributed objects over DCE.
.LI
Maintain backwards compatibility with prior versions of DCE.
.LI
Generate DCE stubs in the \*c language.
.LI
Allow interfaces as IDL parameters.
.LI
Allow for the creation/destruction of dynamic remote objects.
.LI
Allow for the registration of long lived objects.
.LI
Allow for binding to long lived objects.
.LI
Support single inheritance of interfaces with IDL language syntax
extensions.
.LI
Allow an object to re-bind to another interface in an inheritance hierarchy.
.LI
Allow clients to set authorization and authentication information in an
object reference.
.LI
Allow multiple implementations of a common interface.
.LI
Support the \*c reference operator as an IDL syntax attribute on parameters.
.LI
Provide for server management of object lookup.
.LI
Allow \*c static member functions in an IDL interface.
.LI
Support multiple protocols in an object reference.
.LI
Support new exceptions for error conditions.
.LI
Allow C clients to communicate with \*c object servers.
.LI
Provide location transparency for distributed objects.
.LI
Provide for native \*c objects as RPC parameters.
.LI
Provide for an automatic rebind policy on object references.
.LI
Extend enum support with assigned values.
.LI
Provide for security within an object reference.
.LI
Support for automatic generation of a manager class.
.LI
Support the use of a Naming service host profile along with automatic binding.
.LI
Allow for client specification of memory allocation routines.
.LE
.H 1 "REQUIREMENTS"
.P
A customer who wishes to develop DCE applications using this new
technology is required to have DCE and \*c products installed.
Application users will require the \*c runtime library.  No
dependencies are made on certain non-prevalent \*c features such
as templates, exceptions, and multiple inheritance.
.P
.H 1 "FUNCTIONAL IMPLEMENTATION SPECIFICATION"
.P
.H 2 "Description of Capabilities"
.P
This section presents an illustrative example, called
\*(lBMemo\*(lE, followed by a detailed description of the
capabilities which this specification supports.  The example
should be referenced while reading the capability descriptions.
These descriptions are intentionally abstract to defer
discussion of implementation issues described in later sections.
.P
The example uses the \*(lBauto_handle\*(lE feature of the IDL
language to construct a binding handle.  The advantage
\*(lBauto_handle\*(lE provides is that it alleviates the need
for the client programmer to deal with remoteness in finding a
compatible server.  Traditionally, the disadvantage of
\*(lBauto_handle\*(lE is that it is slower since the Naming
service must be referenced on every operation invocation that
uses it.  However, when a \*c object interface is used from a
client application, the binding information will be encapsulated
in the object proxy and member function invocations will use the
encapsulated object binding information.  The programmer will
not need to supply a binding handle on member function
invocations and will not incur the overhead involved with
\*(lBauto_handle\*(lE.  Non-member functions such as object
constructors and static interface member functions can still be
designed to use any of the DCE supported binding methods.  These
types of operations are actually normal DCE RPC operations in
all respects except that their names are more closely associated
with the interface name and are referenced by prefixing the
operation name with the interface name and the \*(lB::\*(lE
operator.
.P
.ne 3+14
.H 3 "Memo example: network interface (IDL file)"
.P
.dS
[uuid(70ff8220-6e1a-11cc-89ee-08002b2a1bca)]
interface Memo {
        typedef [string, ptr] char * net_string;

        Memo *newMemo([in, string] char *title);

        void write( [in, string] char *text );

        [string, ptr] char *read();

        boolean spellCheck( [in] Memo *m);

        void append( [in, string] net_string new_text);
}
.dF
.P
.ne 3+4
.H 3 "Memo example: attribute configuration file"
.P
.dS
[ auto_handle ]
interface Memo {
        [cxx_new(AnotherMemo)] newMemo;
}
.dF
.P
.ne 3+8
.H 3 "Memo example: generated network class"
.P
.dS
class Memo : public virtual rpc_object_reference {
public:
    static Memo *newMemo(char *title);
    void write(char *) = 0;
    char *read()       = 0;
    idl_boolean spellCheck(Memo *m) = 0;
    void append(char * new_text) = 0;
};
.dF
.P
.ne 3+3
.H 3 "SimpleMemo example: a user implementation of Memo"
.P
.dS
class SimpleMemo : public Memo {
private:
    char text[1000];

.ne 5
public:
    SimpleMemo() {text[0] = '\e0';};
    SimpleMemo(char *title) {
        strcpy(text, title);
    }

.ne 3
    void write(char *new_text) {
        strcpy(text, new_text);
    }

.ne 3
    char *read() {
        return text;
    }

.ne 3
    idl_boolean spellCheck(Memo *m) {
        return idl_true;
    }

.ne 3
    void append(char * new_text) {
        strcat(text, new_text);
    }
};
.dF
.P
.ne 3+20
.H 3 "Memo example: diagram of components"
.P
.if n \{\
.dS
        Host A                               Host B
+------------------------+       +-------------------------+
|  +------------------+  |       |  +-------------+        |
|  | Memo client stub |  |  RPC  |  | class Memo  |        |
|  |    (generated)   |============>| (generated) |        |
|  +------------------+  |       |  +-------------+        |
|          |             |       |         |               |
|          |             |       |         |               |
|    +-------------+     |       |  +-------------------+  |
|    | class Memo  |     |       |  | class AnotherMemo |  |
|    | (generated) |     |       |  |  (user provided)  |  |
|    +-------------+     |       |  +-------------------+  |
|          |             |       +-------------------------+
|          |             |
|  +------------------+  |
|  | class SimpleMemo |  |
|  |  (user provided) |  |
|  +------------------+  |
+------------------------+
.dF\
\}
.if t \{\
...\" #FIG 2.1
...\" 80 2
...\" 6 99 99 199 139
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 99 99 199 99 199 139 99 139 99 99 9999 9999
...\" 4 1 0 10 0 -1 0 0.00000 4 7 73 149 116 Memo client stub
...\" 4 1 0 10 0 -1 0 0.00000 4 9 47 149 131 (generated)
...\" -6
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 79 79 79 319 219 319 219 79 79 79 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 419 119 419 279 559 279 559 119 419 119 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 99 179 199 179 199 219 99 219 99 179 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 99 259 199 259 199 299 99 299 99 259 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 439 219 539 219 539 259 439 259 439 219 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 439 139 539 139 539 179 439 179 439 139 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 1 0
...\" 	0 0 1.000 4.000 8.000
...\" 	 149 139 149 179 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 1 0
...\" 	0 0 1.000 4.000 8.000
...\" 	 149 259 149 219 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 1 0
...\" 	0 0 1.000 4.000 8.000
...\" 	 489 219 489 179 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 1 0
...\" 	0 0 1.000 4.000 8.000
...\" 	 199 119 439 159 9999 9999
...\" 4 1 0 10 0 -1 0 0.00000 4 7 31 149 69 Host A
...\" 4 1 0 10 0 -1 0 0.00000 4 9 47 149 211 (generated)
...\" 4 1 0 10 0 -1 0 0.00000 4 7 49 149 196 class Memo
...\" 4 1 0 10 0 -1 0 0.00000 4 9 78 149 276 class SimpleMemo
...\" 4 1 0 10 0 -1 0 0.00000 4 9 47 489 171 (generated)
...\" 4 1 0 10 0 -1 0 0.00000 4 7 49 489 156 class Memo
...\" 4 1 0 10 0 -1 0 0.00000 4 7 84 489 236 class AnotherMemo
...\" 4 1 0 10 0 -1 0 0.00000 4 9 63 489 251 (user provided)
...\" 4 1 0 10 0 -1 0 0.00000 4 7 29 489 109 Host B
...\" 4 1 0 10 0 -1 0 0.00000 4 7 20 319 134 RPC
...\" 4 1 0 10 0 -1 0 0.00000 4 9 63 149 291 (user provided)
.dS
.PS
.ps 11
"\s10\fRMemo client stub\fP" at 1.863,9.078 
"\s10\fR(generated)\fP" at 1.863,8.890 
line from 0.988,9.512 to 0.988,6.513 to 2.737,6.513 to 2.737,9.512 to 0.988,9.512
line from 5.237,9.012 to 5.237,7.013 to 6.987,7.013 to 6.987,9.012 to 5.237,9.012
line from 1.238,8.262 to 2.487,8.262 to 2.487,7.763 to 1.238,7.763 to 1.238,8.262
line from 1.238,7.263 to 2.487,7.263 to 2.487,6.763 to 1.238,6.763 to 1.238,7.263
line from 5.487,7.763 to 6.737,7.763 to 6.737,7.263 to 5.487,7.263 to 5.487,7.763
line from 5.487,8.762 to 6.737,8.762 to 6.737,8.262 to 5.487,8.262 to 5.487,8.762
line -> from 1.863,8.762 to 1.863,8.262
line -> from 1.863,7.263 to 1.863,7.763
line -> from 6.112,7.763 to 6.112,8.262
line from 1.238,9.262 to 2.487,9.262 to 2.487,8.762 to 1.238,8.762 to 1.238,9.262
line -> from 2.487,9.012 to 5.487,8.512
"\s10\fR(user provided)\fP" at 1.863,6.890 
"\s10\fRHost A\fP" at 1.863,9.665 
"\s10\fR(generated)\fP" at 1.863,7.890 
"\s10\fRclass Memo\fP" at 1.863,8.078 
"\s10\fRclass SimpleMemo\fP" at 1.863,7.078 
"\s10\fR(generated)\fP" at 6.112,8.390 
"\s10\fRclass Memo\fP" at 6.112,8.578 
"\s10\fRclass AnotherMemo\fP" at 6.112,7.578 
"\s10\fR(user provided)\fP" at 6.112,7.390 
"\s10\fRHost B\fP" at 6.112,9.165 
"\s10\fRRPC\fP" at 3.987,8.853 
.PE
.dF\
\}
.P
.H 3 "Generated \*c class"
.P
Given the signatures of the set of public member functions (the
\*(lBMemo\*(lE IDL interface), a \*c class will be generated which
enables remote access to the class:
.P
.aL 6
.LI
The generated \*c class \*(lBMemo\*(lE is placed into a header
file that the application then includes.
.LI
In addition to a header file, RPC stub files are generated that
allow transparent access to instances of the class if they are
remote.
.LI
A client may utilize the \*(lBMemo\*(lE class via the RPC stubs
without having a local implementation of the class
(\*(lBSimpleMemo\*(lE) linked into the application.
.LI
The application-provided implementation of the class
\*(lBSimpleMemo\*(lE must be derived from the generated MemoMemo
class and be available on some server.
.LI
The application-provided implementation of the class may vary
from process to process.
.LE
.P
.H 3 "Location independent invocation"
.P
Public member functions of an interface are accessed the same,
regardless of whether the object is implemented locally or
remotely.
.P
Given the following code fragment, it is determined at run time
whether or not \*(lBx\*(lE is local or remote and requests are
processed accordingly.  Remoteness is visible only by the
increased potential for failure of the \*(lBread()\*(lE function
when it is executed remotely.
.P
.dS
.ne 2
Memo *x = GetfromInbox();
cout << x->read();
.dF
.P
.H 3 "Object creation"
.P
Objects may be created via standard \*c syntax.  Local instances
of the class may be instantiated directly using the name of the
class implementation:
.P
.dS
.ne 2
Memo *x = new SimpleMemo;
SimpleMemo y;
.dF
.P
If a creator function is exported as one of the public member
functions of the generated class then remote instances of the
class are instantiated using the creator function and a remote
constructor:
.p
.dS
.ne 1
Memo *x = Memo::newMemo("Memo Title");
.dF
.P
.H 3 "Named objects"
.P
IDL will support named objects.  A named object is an object
that is registered with a name service.  Objects may be named
and accessed by CDS name:
.P
.dS
.ne 3
Memo *x = Memo::bind((unsigned_char_t *)
          "/.:/messages/my_messages");
cout << x->read();
.dF
.P
Servers register named objects by invoking the
\*(lBregister_named_object()\*(lE member function:
.P
.dS
.ne 3
Memo *x = new SimpleMemo;
x->register_named_object(x, (unsigned_char_t *)
                            "/.:/messages/my_messages");
.dF
.P
.H 3 "Objects as parameters"
.P
Local and remote objects may be passed as parameters.
.P
Given the following code fragment, the local implementation \*(lBx\*(lE can
be accessed by the remote object \*(lBy\*(lE:
.P
.dS
.ne 3
Memo *x = new SimpleMemo;
Memo *y = Memo::newMemo("Memo Title");
y->spellCheck(x);
.dF
.P
Given the following code fragment, the remote object \*(lBy\*(lE
can be accessed by the local implementation \*(lBx\*(lE:
.P
.dS
.ne 3
Memo *x = new SimpleMemo;
Memo *y = Memo::newMemo("Memo Title");
idl_boolean ok = x->spellCheck(y);
.dF
.P
.H 2 "The RPC Object Model"
.P
In the RPC object model, objects exist and are directly
accessible only on a single server at a time.  Although clients
may access remote objects (via an RPC) as if they were local,
they are, in actuality, working with object references.  An
object reference is a type of proxy object (also known as a
surrogate object) which exists in the client address space.  It
is an instance of a \*c class generated by the IDL stub compiler
to describe the public interface of the remote class
(i.e., the public member functions).  It provides
transparent forwarding of member function invocations to the
remote object for which it is a proxy.  If a client wishes to
pass a local object to a server as a parameter, only a reference
to the object is passed, and therefore the object must have a
network interface.
.P
The RPC mechanism provided to identify an object is the object
UUID.  This generated identifier uniquely identifies an object
from all others across the entire network.  When combined with a
binding handle, the RPC run time can transparently route a
method invocation to the correct object on a remote server.
Thus, the network representation of an RPC object reference is
simply a UUID combined with a binding handle.  This identifier
is generated automatically for all network objects.
Additionally, RPC objects may be associated with entries in the
DCE name service which provides symbolic access to an object by
name.  This supports finding long-lived objects that may exist
beyond the lifetime of any particular server process (e.g., a
printer named \*(lB/.:/printers/ps_5\*(lE).  The diagram below
outlines the client/server interaction with remote objects
involved.
.P
.ne 14
.if n \{\
.dS
     Client                      Server
+---------------+          +----------------+
|               |          |                |
|     Memo      |          |      Memo      |
|      ^        |          |       ^        |
|      |        |          +.......|........+
|      |        |          |       |        |
|      |        |          |   SimpleMemo   |
|      |        |          |                |
+......|........+          +----------------+
|      |        |   RPC    |                |
|   MemoProxy ===============> Server Stub  |
|               |          |                |
+---------------+          +----------------+
.dF\
\}
.if t \{\
.PE\
...\" #FIG 2.1
...\" 80 2
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 79 79 79 319 219 319 219 79 79 79 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 419 79 419 319 559 319 559 79 419 79 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 1 0
...\" 	0 0 1.000 4.000 8.000
...\" 	 184 264 459 264 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 1 0
...\" 	0 0 1.000 4.000 8.000
...\" 	 149 254 149 144 9999 9999
...\" 2 1 2 1 -1 0 0 0 3.000 -1 0 0
...\" 	 79 199 219 199 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 1 0
...\" 	0 0 1.000 4.000 8.000
...\" 	 489 159 489 114 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 419 199 559 199 9999 9999
...\" 2 1 2 1 -1 0 0 0 3.000 -1 0 0
...\" 	 419 139 559 139 9999 9999
...\" 4 1 0 10 0 -1 0 0.00000 4 7 27 149 69 Client
...\" 4 1 0 10 0 -1 0 0.00000 4 7 26 489 69 Server
...\" 4 1 0 10 0 -1 0 0.00000 4 7 27 149 139 Memo
...\" 4 1 0 10 0 -1 0 0.00000 4 9 53 149 269 MemoProxy
...\" 4 1 0 10 0 -1 0 0.00000 4 7 46 489 269 Server stub
...\" 4 1 0 10 0 -1 0 0.00000 4 7 20 319 259 RPC
...\" 4 1 0 10 0 -1 0 0.00000 4 9 56 489 174 SimpleMemo
...\" 4 1 0 10 0 -1 0 0.00000 4 7 27 489 109 Memo
.dS
.PS
.ps 11
line from 5.237,9.512 to 5.237,6.513 to 6.987,6.513 to 6.987,9.512 to 5.237,9.512
line -> from 2.300,7.200 to 5.737,7.200
line -> from 1.863,7.325 to 1.863,8.700
dashwid = 0.037i
line dotted from 0.988,8.012 to 2.737,8.012
line -> from 6.112,8.512 to 6.112,9.075
line from 5.237,8.012 to 6.987,8.012
line dotted from 5.237,8.762 to 6.987,8.762
line from 0.988,9.512 to 0.988,6.513 to 2.737,6.513 to 2.737,9.512 to 0.988,9.512
"\s10\fRClient\fP" at 1.863,9.665
"\s10\fRMemo\fP" at 6.112,9.165
"\s10\fRServer\fP" at 6.112,9.665
"\s10\fRMemo\fP" at 1.863,8.790
"\s10\fRMemoProxy\fP" at 1.863,7.165
"\s10\fRServer stub\fP" at 6.112,7.165
"\s10\fRRPC\fP" at 3.987,7.290
"\s10\fRSimpleMemo\fP" at 6.112,8.353
.PE
.dF\
\}
.P
.H 2 "Utilizing RPC With \*c
.P
This section describes the application interface to RPC objects,
and explains how a \*c programmer can make use of them.  The
following are the conceptual steps needed to utilize RPC from
\*c:
.P
.aL
.LI
Obtain or create an interface definition using IDL.
.LI
Customize the mapping of object creator operations in the IDL
file with attributes in the ACF file.  (This step is only
necessary for dynamically created remote objects.)
.LI
Build the client:
.aL
.LI
Invoke the IDL compiler with a \*(lB-lang cxx\*(lE option to
generate a \*c header file containing the class declaration and
client stub which invokes the remote operations.
.LI
Write the client \*c code that utilizes the class.
.LI
Compile the client application code which utilizes the class.
.LI
Link the client application code and client stub to form the
complete application.
.LE
.LI
Build the server:
.aL
.LI
Invoke the IDL compiler with a \*(lB-lang cxx\*(lE option to
generate a \*c header file containing the types and constants of
the interface, and server \*c stub which accesses the remote
operations.  In the server, the class definition is provided by
the application.
.LI
Create a class implementation that provides the entire interface
defined in the IDL definition.
.LI
Compile the server application code which implements the class,
and the server initialization code which performs the necessary
RPC setup and optional object registration for named objects.
.LI
Link the server application code and server stubs to form the
complete application.
.LE
.LE
.P
The only significant differences between using RPC from C and
\*c is that in step (b) there are additional attributes which
control the mapping into \*c member functions, and there are
potentially additional steps in the server initialization in
step (d) to support named objects.
.P
.H 3 "Modeling an IDL interface as a \*c class: \
\*(lB\*(jBinterface-name\*(jE\*(lE and \
\*(lB\*(jBimplementation-name\*(jE\*(lE"
.P
An IDL interface is, in an abstract sense, equivalent to a \*c
class.  It describes an entity that provides a set of operations
and (potentially) some encapsulated data on which those
operations act.  In order for a \*c application to make use of
this equivalence, it must be somehow mapped into a \*c class
definition.  The IDL stub compiler will be extended to support
the \*(lB-lang cxx\*(lE option.  When present, this option
directs the compiler to generate the interface as a \*c class.
.P
In actuality, each IDL interface is represented by an abstract
\*c class which enables location independent invocation of
object methods via polymorphism whether the object is local or
remote.  The name of this class is taken from the interface
name.  It is derived from an RPC-provided class declaration
which encapsulates any necessary RPC support.  Each operation in
the interface is present in the class declaration as a pure
virtual public member function.  This generated class
encapsulates all of the public behavior of the IDL interface.  A
proxy class is also generated by the IDL compiler that is
derived from the abstract base class.  The operations in the
proxy class carry out the RPC calls to the server.
.P
Thus the following set of classes are involved for each IDL
interface which utilizes distributed RPC objects:
.P
.aL
.LI
IDL-generated \*(lB\*(jBinterface-name\*(jE\*(lE class:
.P
.dS
.ne 2
class \*(jBinterface-name\*(jE : \kxpublic virtual
\h'\nxu'rpc_object_reference
.dF
.P
This abstract class represents the behavior of the IDL interface
definition.
.LI
IDL-generated proxy class:
.P
.dS
.ne 2
class \*(jBinterface-name\*(jEProxy : \kxpublic virtual
\h'\nxu'\*(jBinterface-name\*(jE
.dF
.P
This class provides the proxy object when the object is not
local.  Method invocations are transparently forwarded to the
actual remote object instance.
.LI
User-provided \*(lB\*(jBimplementation-name\*(jE\*(lE class:
.P
.dS
.ne 1
class \*(jBimplementation-name\*(jE : public \*(jBinterface-name\*(jE
.dF
This is the actual implementation of the interface.  It provides
the name used when the application wishes to create a new local
object instance.  It may contain any desired data and/or member
functions necessary to implement the desired behaviors.  It
must, however, provide an implementation function for each of
the member functions in the abstract base class from which it is
derived.
.LE
.P
.H 3 "Identification of RPC object creators via the ACF"
.P
The following ACF attribute will be available to identify
operations that are used to create new remote objects:
.P
.P
.aL
.LI
\*(lB[cxx_new(\*(jB name \*(jE)]\*(lE attribute.
.P
Usage: operation.
.P
This attribute identifies the operation as a remote object
creator.  The remote creator function creates an object of type
\*(lB\*(jBname\*(jE\*(lE and returns an object reference.  The
\*(lB\*(jBname\*(jE\*(lE class must be derived from the
\*(lB\*(jBinterface-name\*(jE\*(lE class.  The operation must be
defined as returning a pointer to the
\*(lB\*(jBinterface-name\*(jE\*(lE class.  The generated
operation is accessed as a normal \*c static member function in
the \*(lB\*(jBinterface-name\*(jE\*(lE class.
.LE
.P
.H 3 "Object reference"
.P
Object parameters are specified in the interface definition as
the pointer type \*(lB\*(jBinterface-name\*(jE *\*(lE.  The wire
representation of an \*(lB\*(jBinterface-name\*(jE *\*(lE
parameter is an \*(lBObjectRef\*(lE, which is encapsulated in
the \*(lBrpc_object_reference\*(lE base class inherited by the
\*(lB\*(jBinterface-name\*(jE\*(lE class.  The IDL compiler will
generate code to marshal an \*(lB\*(jBinterface-name\*(jE *\*(lE
parameter into an \*(lBObjectRef\*(lE and to unmarshal an
\*(lBObjectRef\*(lE into an \*(lB\*(jBinterface-name\*(jE *\*(lE type.
Existing NDR types are used to construct a wire representation
of an object reference, thus requiring no protocol change of new
NDR type definitions.
.P
.H 3 "Object table"
.P
Objects created by a server are uniquely identified by an object
UUID associated with a binding handle.  A server that receives
an operation request on an implied \*(lBthis\*(lE pointer must
translate it to an actual object pointer.  An Object Table will
be maintained in the server's address space which maps an object
UUID to the real object address.  The Object Table is
implemented as a \*c class containing a table of object UUIDs,
interface UUIDs, and object addresses.  The interface UUID is
used to uniquely identify the object reference in a derivation
tree of interfaces.  An object that is derived from a single
interface does not use the interface UUID in the Object Table.
An Object Table entry also contains a list of clients associated
with the object.  An Object Table class has the following
interface as seen by the proxy class, and is presented here
solely as an aid to the understanding of the underlying RPC
object model:
.P
.dS
.ne 11
class RpcObjectTable {
public:
    // Constructor builds an Object Table with a default size
    RpcObjectTable(unsigned32 = DEFAULT_HASH_TABLE_SIZE);

    // Destructor
    virtual ~RpcObjectTable();

    // Subscript operator
    RpcHashTableElement &operator[](const uuid_t &);
}
.dF
.P
.ne 3+19
.H 3 "Object table layout"
.P
.if n \{\
.dS
               Object Table                        Object
+-------------------+-----------+--------+     Implementation
|                   | Interface | Object ----->+-----------+
| Object            |   UUID    |  Ptr   |     |   class   |
|  UUID             +-----------+--------+     |           |
|                   | Interface | Object ----->+-----------+
|                   |   UUID    |  Ptr   |     |   class   |
|                   +-----------+--------+     |           |
|                   | Interface | Object ----->+-----------+
|    +------+       |   UUID    |  Ptr   |     |   class   |
|    |Client|       +-----------+--------+     |           |
|    | List |       |     .     |   .    |     +-----------+
|    +-----\e+       |     .     |   .    |
+-----------\e-------+-----------+--------+
             \e
              v+--------------+
               |Client Binding|
               | Handle List  |
               +--------------+
.dF\
\}
.if t \{\
...\" #FIG 2.1
...\" 80 2
...\" 6 114 114 144 139
...\" 4 1 0 10 0 -1 0 0.00000 4 9 27 129 124 Object
...\" 4 1 0 10 0 -1 0 0.00000 4 7 27 129 139 UUID
...\" -6
...\" 6 99 214 159 249
...\" 2 2 0 1 -1 0 0 0 0.000 0 0 0
...\" 	 159 249 159 214 99 214 99 249 159 249 9999 9999
...\" 4 1 0 10 0 -1 0 0.00000 4 7 27 129 229 Client
...\" 4 1 0 10 0 -1 0 0.00000 4 7 17 129 244 List
...\" -6
...\" 6 219 209 229 244
...\" 4 1 0 10 0 -1 0 0.00000 4 1 3 224 244 .
...\" 4 1 0 10 0 -1 0 0.00000 4 1 3 224 214 .
...\" 4 1 0 10 0 -1 0 0.00000 4 1 3 224 229 .
...\" -6
...\" 6 309 209 319 244
...\" 4 1 0 10 0 -1 0 0.00000 4 1 3 314 244 .
...\" 4 1 0 10 0 -1 0 0.00000 4 1 3 314 214 .
...\" 4 1 0 10 0 -1 0 0.00000 4 1 3 314 229 .
...\" -6
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 79 79 79 259 359 259 359 79 79 79 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 459 79 459 199 559 199 559 79 459 79 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 459 119 559 119 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 459 159 559 159 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 179 79 179 259 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 269 79 269 259 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 179 119 359 119 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 179 159 359 159 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 179 199 359 199 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 1 0
...\" 	0 0 1.000 4.000 8.000
...\" 	 354 89 459 89 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 1 0
...\" 	0 0 1.000 4.000 8.000
...\" 	 354 129 459 129 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 1 0
...\" 	0 0 1.000 4.000 8.000
...\" 	 354 169 459 169 9999 9999
...\" 2 2 0 1 -1 0 0 0 0.000 0 0 0
...\" 	 319 339 319 289 219 289 219 339 319 339 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 1 0
...\" 	0 0 1.000 4.000 8.000
...\" 	 149 234 219 299 9999 9999
...\" 4 1 0 10 0 -1 0 0.00000 4 7 20 509 104 class
...\" 4 1 0 10 0 -1 0 0.00000 4 7 20 509 144 class
...\" 4 1 0 10 0 -1 0 0.00000 4 7 20 509 184 class
...\" 4 1 0 10 0 -1 0 0.00000 4 7 66 224 104 Interface UUID
...\" 4 1 0 10 0 -1 0 0.00000 4 9 60 314 104 Object Pointer
...\" 4 1 0 10 0 -1 0 0.00000 4 7 66 224 144 Interface UUID
...\" 4 1 0 10 0 -1 0 0.00000 4 7 66 224 179 Interface UUID
...\" 4 1 0 10 0 -1 0 0.00000 4 9 60 314 144 Object Pointer
...\" 4 1 0 10 0 -1 0 0.00000 4 9 60 314 179 Object Pointer
...\" 4 1 0 10 0 -1 0 0.00000 4 9 61 269 309 Client Binding
...\" 4 1 0 10 0 -1 0 0.00000 4 7 49 269 324 Handle List
...\" 4 1 0 10 0 -1 0 0.00000 4 9 52 224 69 Object Table
...\" 4 1 0 10 0 -1 0 0.00000 4 9 96 509 69 Object Implementation
.dS
.PS
.ps 11
"\s10\fRUUID\fP" at 1.613,8.790 
box with .sw at (1.24,7.39) width 0.75 height 0.44
"\s10\fRClient\fP" at 1.613,7.665 
"\s10\fRList\fP" at 1.613,7.478 
"\s10\fR.\fP" at 2.800,7.478 
"\s10\fR.\fP" at 2.800,7.853 
"\s10\fR.\fP" at 2.800,7.665 
"\s10\fR.\fP" at 3.925,7.478 
"\s10\fR.\fP" at 3.925,7.853 
"\s10\fR.\fP" at 3.925,7.665 
line from 0.988,9.512 to 0.988,7.263 to 4.487,7.263 to 4.487,9.512 to 0.988,9.512
line from 5.737,9.512 to 5.737,8.012 to 6.987,8.012 to 6.987,9.512 to 5.737,9.512
line from 5.737,9.012 to 6.987,9.012
line from 5.737,8.512 to 6.987,8.512
line from 2.237,9.512 to 2.237,7.263
line from 3.362,9.512 to 3.362,7.263
line from 2.237,9.012 to 4.487,9.012
line from 2.237,8.512 to 4.487,8.512
"\s10\fRObject\fP" at 1.613,8.978 
line from 2.237,8.012 to 4.487,8.012
"\s10\fRObject Implementation\fP" at 6.362,9.665 
line -> from 4.425,9.387 to 5.737,9.387
line -> from 4.425,8.887 to 5.737,8.887
line -> from 4.425,8.387 to 5.737,8.387
box with .sw at (2.74,6.26) width 1.25 height 0.62
line -> from 1.863,7.575 to 2.737,6.763
"\s10\fRclass\fP" at 6.362,9.228 
"\s10\fRclass\fP" at 6.362,8.728 
"\s10\fRclass\fP" at 6.362,8.228 
"\s10\fRInterface UUID\fP" at 2.800,9.228 
"\s10\fRObject Pointer\fP" at 3.925,9.228 
"\s10\fRInterface UUID\fP" at 2.800,8.728 
"\s10\fRInterface UUID\fP" at 2.800,8.290 
"\s10\fRObject Pointer\fP" at 3.925,8.728 
"\s10\fRObject Pointer\fP" at 3.925,8.290 
"\s10\fRClient Binding\fP" at 3.362,6.665 
"\s10\fRHandle List\fP" at 3.362,6.478 
"\s10\fRObject Table\fP" at 2.800,9.665 
.PE
.dF\
\}
.P
.H 3 "Interface inheritance"
.P
As with local \*c class declarations, a \*c network interface
may inherit behavior from another network interface.  This is
specified via the new IDL language operator \*(lB:\*(lE,
allowing single inheritance of interfaces.  The IDL grammar will
be modified to change an Interface Definition Header to:
.P
.dS
.ne 3
<inheritance_spec> ::= ":" <identifier>
<interface_header> ::= "interface" <identifier>
                       [ <inheritance_spec> ]
.dF
.P
The identifier specified in an \*(lBinheritance_spec\*(lE must
be the class name of another, previously declared IDL-generated
network interface.  If the IDL interface does not import or
contain the interface from which behavior is being inherited,
then an include statement should be specified in the ACF file to
assure the necessary declarations are available for the
generated header files.
.P
.H 3 "Object creation"
.P
For applications where object implementations are available in
the current process, the simplest method of object creation is
to simply create an instance of the class
\*(lB\*(jBimplementation-name\*(jE\*(lE.  As this is a standard
\*c class, RPC is not even involved in local object creation.
If the object is mobile across address spaces, then there is an
additional requirement that it be allocated via the \*c
\*(lBnew\*(lE operator, and the resulting object may only be
assigned to variables of type \*(lB\*(jBinterface-name\*(jE *\*(lE
from which it is derived.
.P
If there is not an implementation of the class
\*(lB\*(jBimplementation-name\*(jE\*(lE provided in the address
space, it is still possible to create instances of pointers to
the \*(lB\*(jBinterface-name\*(jE\*(lE class linked to an object
on a remote server if the interface provides a creator function
via the ACF file.  Invocation of the creator function will cause
an RPC to a server which provides an implementation of the
class.  On the server the actual constructor is invoked to
create the object and an \*(lBObjectRef\*(lE is returned to the
client.  On the client a proxy is created using the
\*(lBObjectRef\*(lE to provide transparent access to the actual
remote object and returned to the user.
.P
.H 3 "Object access"
.P
The manner in which client applications access objects depends
to some extent upon the type of processing being performed.
These decisions are application driven, and thus the
transparency of the resulting access is under control of the
programmer.
.P
Access to a remote object requires an instance of an RPC object
reference.  As described earlier, RPC object references are
encapsulated in a \*c proxy class generated by the IDL compiler.
An RPC object reference may be instantiated in the client
process in the following ways:
.P
.aL 6
.LI
Utilizing the defined remote object creator operation as
described previously.
.LI
Returning an object reference as an output parameter or function
result from a member function of another RPC object reference.
.LI
By calling one of the static bind operations generated into the
proxy class by the IDL compiler:
.aL
.LI
\*(lB\*(jBinterface-name\*(jE * bind(unsigned_char_t *)\*(lE
uses the \*(lBunsigned_char_t\*(lE parameter to search the name
space for binding handles.
.LI
\*(lB\*(jBinterface-name\*(jE * bind(uuid_t)\*(lE uses the UUID
parameter to search the name space for binding handles.
Searches are started at the default path specified by the
RPC-specific environment variable \*(lBRPC_DEFAULT_ENTRY\*(lE.
.LI
\*(lB\*(jBinterface-name\*(jE *
bind(rpc_binding_handle_t)\*(lE uses the binding handle
parameter as the object reference.
.LI
\*(lB\*(jBinterface-name\*(jE * bind(rpc_object_reference
*)\*(lE uses the object reference in the base class pointer
parameter as the object reference.
.LE
.P
Each of the four bind operations is available as a static member
function in the \*(lB\*(jBinterface-name\*(jE\*(lE class.
.LE
.P
.H 3 "Support for named objects"
.P
For the most part, the significant issues for supporting named
(long-lived) objects deal with initialization and registration
of the objects.  Servers for named objects need to perform some
of the following tasks.
.P
.H 4 "Named object creation/registration"
.P
This is accomplished by first creating the \*c object, assigning
the newly created object to an interface pointer variable, and
then invoking the \*(lBregister_named_object()\*(lE member
function with the desired name.  If the named object does not
yet exist in the name space, this invocation causes the name to
be created.  Otherwise, it simply registers the object with the
RPC run time for automatic lookup when requests are directed at
the object.  The \*(lBregister_named_object()\*(lE member
function also has an optional parameter which determines if the
object UUID is registered with the endpoint mapper.  If
specified as \*(lBTRUE\*(lE, it enables multiple servers for the
same interface, but a distinct set of named objects to be
running on the same machine concurrently.
.P
.H 4 "Named object lookup"
.P
Servers may elect not to register all of their objects at server
initialization time, but to provide their own lookup function.
The \*(lBthis\*(lE pointer will indicate that the object
reference needs to be registered in the Object Table as there
will be no entry for the specific object instance wanted.
.P
An ACF attribute will be available for the purpose of
identifying such lookup functions.  The operation modified by
the ACF attribute will be generated as a static member function
in the server stub and will be typed checked as returning an
\*(lBinterface *\*(lE value:
.P
.aL
.LI
\*(lB[cxx_lookup ( \*(jBname\*(jE )]\*(lE
.P
Usage: interface.
.P
This attribute identifies \*(lB\*(jBname\*(jE\*(lE as a special
lookup function.  The lookup function allows a server to manage
its own table of object pointers.  The function must be supplied
by the user and return a pointer to the
\*(lB\*(jBinterface-name\*(jE\*(lE class.  The generated server
stub will call the function identified by
\*(lB\*(jBname\*(jE\*(lE when it discovers that the object is
not registered with the object table.  If the object can not be
found by the server stub, an \*(lBrpc_x_object_not_found\*(lE
exception is raised and propagated to the client.
.LE
.P
.H 3 "Reference counting"
.P
Object references may be passed to other functions or duplicated
freely by client applications.  Similarly, object references
that refer to the same object may be passed to different client
applications by a server.  In order to keep track of copies of
object references, a private reference count is maintained by
the DCE runtime for all dynamic objects.  The runtime will
appropriately adjust reference counts for objects as they are
passed as parameters.
.P
.H 3 "Local objects"
.P
The IDL \*c extensions should not preclude a client application
from creating its own object instantiations.  If the user knows
an implementation class of an interface it can be used in the
normal way by calling the constructor function for the class.
If the object is to be used as an RPC object passed to a remote
procedure, the object pointer should be assigned to an interface
pointer for the class.  Then the interface pointer can be passed
as a parameter to any supporting remote procedure without
ramifications.  The underlying mechanism to do this will
essentially make the client a server of the object, logging the
object instance in the Object Table, tracking clients of the
object, and translating the object instance to an object
reference wire representation that is passed to the remote
procedure.
.P
In the following example, a \*(lBSimpleMemo\*(lE implementation
object is created locally, assigned to an interface pointer and
passed to a remote procedure.  The remote object references the
local object:
.P
.dS
.ne 6
Memo *mremote, *mlocal, *m;

mremote = Memo::bind((unsigned_char_t *)
          "/.:/MemoObjects/myObject1");
mlocal = new SimpleMemo("some text");
mremote->append(mlocal);
.dF
.P
.H 3 "Matrix example: location independent objects"
.P
This client-side example illustrates the use of distributed
objects to create and manipulate a matrix on a compute server
elsewhere in the network.  By virtue of automatic binding and
errors reported as exceptions, the \*(lBMatrix\*(lE object
\*(lBm\*(lE is utilized in a completely natural manner.  The
example consists of the following files, whose contents are
given below:
.P
.aL
.LI
\*(lBMatrix.idl\*(lE \*(EM
The interface definition which provides the public declaration
for the \*(lBMatrix\*(lE class.
.LI
\*(lBMatrix.acf\*(lE \*(EM
The ACF that identifies the object creator operation in the IDL file.
.LI
\*(lBClient.cxx\*(lE \*(EM
The actual example program which creates and manipulates the remote
\*(lBMatrix\*(lE objects.
.LE
.P
.ne 3+3
.H 4 "Matrix.idl"
.P
.cS
[uuid(c664b260-a5db-11cb-832c-08002b2a1bca)]
interface Matrix
{
.ne 6
    /* Create a 2x2 matrix. */
    Matrix * new2x2(
                         [in] double v11,
                         [in] double v12,
                         [in] double v21,
                         [in] double v22);

.ne 5
    /* Set a new value in the matrix. */
    void set(
             [in] long row,
             [in] long col,
             [in] double value);

.ne 4
    /* Get a value from the matrix. */
    double get(
               [in] long row,
               [in] long col);

.ne 2
    /* Return the inversion of the specified matrix. */
    Matrix * invert();

.ne 3
    /* Return the product. */
    Matrix * multiply(
                      [in] Matrix * m);

.ne 3
    /* Return the sum. */
    Matrix * add(
                 [in] Matrix * m);
}
.cF
.P
.ne 3+5
.H 4 "Matrix.acf"
.P
.cS
[ auto_handle ]
interface Matrix
{
    /* identify the remote object creator function */
    [cxx_new(MatrixImpl)] new2x2;
}
.cF
.P
.ne 3+7
.H 4 "Client.cxx"
.P
.cS
#include "Matrix.h"

void main ()
{
    // Utilizing automatic binding, a server is found and
    // a 2-dimensional matrix is created.
    Matrix *m = Matrix::new2x2(1,0,0,1);

.ne 2
    // Invert (executes on the compute server).
    Matrix *inverted_m = m->invert();

.ne 2
    // Local Matrix object.
    Matrix *l = new MatrixImpl(2,7,3,2);

.ne 3
    // Add inverted_m to l and return sum (executes locally)
    // Thus sum is a local object.
    Matrix *sum = l->add(inverted_m);

.ne 4
    // Perform the multiplication of sum and m (executes remotely)
    // Thus result is a reference to the remote object.
    Matrix *result = m->multiply(sum);
}
.cF
.P
.H 2 "IDL-Generated Class Hierarchy"
.P
When the \*(lB-lang cxx\*(lE option is used, the IDL compiler
will generate a \*c class hierarchy to support remote objects.
The base class for this hierarchy,
\*(lBrpc_object_reference\*(lE, includes any necessary
functionality to provide this support.  The
\*(lB\*(jBinterface-name\*(jE\*(lE abstract class provides the
public interface as defined in the interface description along
with object creator functions.  The
\*(lB\*(jBinterface-name\*(jE\*(lE\*(lBProxy\*(lE class
supplants the RPC client stub to carry out remote operations.
Users will provide their own object implementation class, which
must be derived from the \*(lB\*(jBinterface-name\*(jE\*(lE
abstract class.  The diagram below illustrates this class
hierarchy, which is then followed by a more detailed description
of the IDL generated classes:
.P
.ne 16
.if n \{\
.dS
         RPC Object Model Inheritance Diagram
+-----------------------------------------------------+
|       Client                         Server         |
|                                                     |
|                                                     |
| rpc_object_reference           rpc_object_reference |
|         ^                              ^            |
|         |                              |            |
|         |                              |            |
|   <interface-name>               <interface-name>   |
|         ^                              ^            |
|         |                              |            |
|         |                              |            |
| <interface-name>Proxy         <implementation-name> |
|                                                     |
+-----------------------------------------------------+
.dF\
\}
.if t \{\
...\" #FIG 2.1
...\" 80 2
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 79 79 79 279 559 279 559 79 79 79 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 1 0
...\" 	0 0 1.000 4.000 8.000
...\" 	 179 184 179 164 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 1 0
...\" 	0 0 1.000 4.000 8.000
...\" 	 179 224 179 204 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 1 0
...\" 	0 0 1.000 4.000 8.000
...\" 	 459 224 459 204 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 1 0
...\" 	0 0 1.000 4.000 8.000
...\" 	 459 184 459 164 9999 9999
...\" 4 1 0 10 0 -1 0 0.00000 4 9 164 319 69 RPC Object Model Inheritance Diagram
...\" 4 1 0 10 0 -1 0 0.00000 4 7 27 179 119 Client
...\" 4 1 0 10 0 -1 0 0.00000 4 7 26 459 119 Server
...\" 4 1 0 10 0 -1 0 0.00000 4 10 125 179 159 \f(CWrpc_object_reference\f1
...\" 4 1 0 10 0 -1 0 0.00000 4 10 125 459 159 \f(CWroc_object_reference\f1
...\" 4 1 0 10 0 -1 0 0.00000 4 9 98 179 199 \f(CIinterface-name\f1
...\" 4 1 0 10 0 -1 0 0.00000 4 9 98 459 199 \f(CIinterface-name\f1
...\" 4 1 0 10 0 -1 0 0.00000 4 9 128 459 239 \f(CIimplementation-name\f1
...\" 4 1 0 10 0 -1 0 0.00000 4 9 152 179 239 \f(CIinterface-name\f(CWProxy\f1
.dS
.PS
.ps 11
line -> from 2.237,8.200 to 2.237,8.450
line -> from 2.237,7.700 to 2.237,7.950
line -> from 5.737,7.700 to 5.737,7.950
line -> from 5.737,8.200 to 5.737,8.450
"\s10\fRRPC Object Model Inheritance Diagram\fP" at 3.987,9.665 
"\s10\fRClient\fP" at 2.237,9.040 
line from 0.988,9.512 to 0.988,7.013 to 6.987,7.013 to 6.987,9.512 to 0.988,9.512
"\s10\fRServer\fP" at 5.737,9.040 
"\s10\fR\f(CIinterface-name\f(CWProxy\f1\fP" at 2.237,7.540 
"\s10\fR\f(CWrpc_object_reference\f1\fP" at 2.237,8.540 
"\s10\fR\f(CWroc_object_reference\f1\fP" at 5.737,8.540 
"\s10\fR\f(CIinterface-name\f1\fP" at 2.237,8.040 
"\s10\fR\f(CIinterface-name\f1\fP" at 5.737,8.040 
"\s10\fR\f(CIimplementation-name\f1\fP" at 5.737,7.540 
.PE
.dF\
\}
.P
.H 3 "The \*(lBrpc_object_reference\*(lE class"
.P
The \*(lBrpc_object_reference\*(lE class definition provides a
framework for identifying, distributing, and tracking objects.
It is the base class for the IDL-generated
\*(lB\*(jBinterface-name\*(jE\*(lE class.  The interface to this
class has already been presented.  The details of the class
described below are subject to change according to design
decisions.
.P
An object reference, implemented by an \*(lBObjectRef\*(lE
structure contained within the \*(lBrpc_object_reference\*(lE
class, has already been defined to be minimally a binding handle
and a UUID.  The binding handle identifies the server providing
the object implementation and the UUID identifies the specific
object instance on the server.  It is the \*(lBObjectRef\*(lE
structure that is passed across the wire as the object
reference.  This definition is expanded here to allow an
\*(lBObjectRef\*(lE to contain an array of binding handle tower
associations.  All transport protocols supported by the server
will be stored in the binding handle array, allowing clients to
choose which protocol to use.  This is useful when one client
passes an object reference to another client that uses a
different protocol than the first to talk to the server.
.P
To support named objects, an \*(lBObjectRef\*(lE will also
contain a name field.  The name field identifies where in the
name space to search for the actual binding handles for the
object.  Clients may use this name field to search the name
space when none of the server binding handles in the array are
sufficient.  The server uses it to distinguish a named object
from a dynamic object so that named objects are not
inadvertently deleted by clients.
.P
A location flag and reference count are also encapsulated in an
\*(lBrpc_object_reference\*(lE class.  The location flag
identifies whether the object is implemented locally or remotely
and the reference count is used to track object lifetimes.
.P
.ne 12
.if n \{\
.dS
                 Object Reference
+--------+----------+--------+----------+-----------+
|        |  Server  |        |          |           |
| Object | Binding  | Object | Location | Reference |
|  UUID  | Handle   |  Name  |   Flag   |   Count   |
|        |  Array   |        |          |           |
+--------+----------+--------+----------+-----------+
^                            ^
|                            |
+-------- ObjectRef ---------+
.dF\
\}
.if t \{\
...\" #FIG 2.1
...\" 80 2
...\" 6 304 104 334 129
...\" 4 1 0 10 0 -1 0 0.00000 4 9 27 319 114 Object
...\" 4 1 0 10 0 -1 0 0.00000 4 7 24 319 129 Name
...\" -6
...\" 6 399 104 439 129
...\" 4 1 0 10 0 -1 0 0.00000 4 7 36 419 114 Location
...\" 4 1 0 10 0 -1 0 0.00000 4 9 19 419 129 Flag
...\" -6
...\" 6 109 104 139 129
...\" 4 1 0 10 0 -1 0 0.00000 4 9 27 124 114 Object
...\" 4 1 0 10 0 -1 0 0.00000 4 7 27 124 129 UUID
...\" -6
...\" 6 204 89 244 144
...\" 4 1 0 10 0 -1 0 0.00000 4 7 26 224 99 Server
...\" 4 1 0 10 0 -1 0 0.00000 4 9 32 224 114 Binding
...\" 4 1 0 10 0 -1 0 0.00000 4 7 30 224 129 Handle
...\" 4 1 0 10 0 -1 0 0.00000 4 9 25 224 144 Array
...\" -6
...\" 6 489 104 529 129
...\" 4 1 0 10 0 -1 0 0.00000 4 7 40 509 114 Reference
...\" 4 1 0 10 0 -1 0 0.00000 4 7 26 509 129 Count
...\" -6
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 79 79 79 159 559 159 559 79 79 79 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 174 79 174 159 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 464 79 464 159 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 369 79 369 159 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 0 0
...\" 	 274 79 274 159 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 1 0
...\" 	0 0 1.000 4.000 8.000
...\" 	 189 179 79 179 79 159 9999 9999
...\" 2 1 0 1 -1 0 0 0 0.000 -1 1 0
...\" 	0 0 1.000 4.000 8.000
...\" 	 244 179 369 179 369 159 9999 9999
...\" 4 1 0 10 0 -1 0 0.00000 4 9 69 319 69 Object Reference
...\" 4 1 0 10 0 -1 0 0.00000 4 9 42 219 184 ObjectRef
.dS
.PS
.ps 11
"\s10\fRName\fP" at 3.987,8.915 
"\s10\fRLocation\fP" at 5.237,9.103 
"\s10\fRFlag\fP" at 5.237,8.915 
"\s10\fRObject\fP" at 1.550,9.103 
"\s10\fRUUID\fP" at 1.550,8.915 
"\s10\fRServer\fP" at 2.800,9.290 
"\s10\fRBinding\fP" at 2.800,9.103 
"\s10\fRHandle\fP" at 2.800,8.915 
"\s10\fRArray\fP" at 2.800,8.728 
"\s10\fRObject\fP" at 3.987,9.103 
"\s10\fRReference\fP" at 6.362,9.103 
"\s10\fRObjectRef\fP" at 2.737,8.228 
"\s10\fRCount\fP" at 6.362,8.915 
line from 0.988,9.512 to 0.988,8.512 to 6.987,8.512 to 6.987,9.512 to 0.988,9.512
line from 2.175,9.512 to 2.175,8.512
line from 5.800,9.512 to 5.800,8.512
line from 4.612,9.512 to 4.612,8.512
line from 3.425,9.512 to 3.425,8.512
line -> from 2.362,8.262 to 0.988,8.262 to 0.988,8.512
line -> from 3.050,8.262 to 4.612,8.262 to 4.612,8.512
"\s10\fRObject Reference\fP" at 3.987,9.665 
.PE
.dF\
\}
.P
.H 3 "The \*(lB\*(jBinterface-name\*(jE\*(lE class"
.P
As outlined previously, this abstract base class defines the
publicly accessible interface of the class (i.e., the public
member functions).  The resulting declaration is provided in the
generated header file.  The name of this class is
\*(lB\*(jBinterface-name\*(jE\*(lE.
.P
The generated class is derived from the
\*(lBrpc_object_reference\*(lE class, and has a public, pure
virtual member function for each non-creator operation in the
IDL interface.  No constructor or destructor functions are
allowed in the IDL definition file for the interface.
Specifying such functions will cause a warning to be generated
and the function to be ignored.  The IDL compiler will generate
its own destructor function for the class.  No constructor
function is generated since this is an abstract base class.
.P
The presence of the
\*(lB[cxx_new(\*(jBimplementation-name\*(jE)]\*(lE
\*(iBoperation-name\*(iE attribute in the ACF file causes the
implementation for the \*(iBoperation-name\*(iE to be placed in
the \*(lB\*(jBinterface-name\*(jE\*(lE class as a public static
member function.
.P
For example, if the ACF file for the Matrix example contains:
.P
.dS
.ne 1
[cxx_new(MatrixImpl)] new2x2;
.dF
.P
then the generated signature for this function in
the \*(iBinterface-name\*(iE class is:
.dS
.ne 1
static Matrix * new2x2(\*(jBsame parameter list\*(jE);
.dF
.P
This member function is then used by client applications to
instantiate remote objects of type \*(lBMatrixImpl\*(lE and
return an interface pointer to the caller.  The IDL compiler
will do type checking to insure that the IDL definition for the
member function returns an \*(lB\*(jBinterface-name\*(jE *\*(lE.
.P
.H 3 "The \*(lB\*(jBinterface-name\*(jEProxy\*(lE class"
.P
A proxy class is derived from the abstract base class and is
named \*(lB\*(jBinterface-name\*(jEProxy\*(lE.  IDL provides an
implementation in \*(lB\*(jBinterface-name\*(jEProxy\*(lE for
each of the non-creator member functions defined in the
\*(lB\*(jBinterface-name\*(jE\*(lE class.  These implementation
functions provide access to remote instantiations of the class.
The proxy class implementation will be responsible for
translating between object interface pointers and object
references.
.P
While the client typically deals with
\*(lB\*(jBinterface-name\*(jE\*(lE type classes, it is the
derived proxy class that actually represents the remote object.
Polymorphism in the class hierarchy allows transparent access to
the remote procedure calls in the client stub.
.P
.H 2 "Representation of Binding Information"
.P
Another issue for client-side object representation is that of
determining the RPC binding to the server.  An RPC binding
represents the location of the RPC server.  Binding handles
(which in IDL terms are supplied per-operation) are not
particularly useful when attempting to act upon an object.
Presumably, the program will be acting upon an object which
exists on a remote server.  Therefore, the binding information
is inherent in the object and encapsulated in the
\*(lBrpc_object_reference\*(lE base class.  Binding information
is only specified in an operation when using one of the four
\*(lB\*(jBinterface-name\*(jE * bind()\*(lE static member
functions or an object creator operation.  (The latter case
actually depends upon how the binding method attribute is
specified in the IDL operation definition.  An
\*(lBauto_handle\*(lE attribute would cause the operation to not
require an explicit binding handle to be supplied when invoking
the operation.)
.P
.H 2 "Named object registration and access"
.P
The primary issue with respect to named objects is how they are
registered.  This consists of the following abstract steps:
.P
.aL
.LI
An entry in the DCE name space is created for this object if
needed.
.LI
If not already contained by the object, a UUID is associated
with the object.
.LI
The set of servers that support the object must be, somehow,
associated with the object name entry in the name space.
.LI
If multiple servers of the same interface are available on the
same node (this is determined by an optional argument to
\*(lBregister_named_object()\*(lE method in the
\*(lBrpc_object_reference\*(lE class), then the server must also
register each of the object UUID that it supports with the
endpoint mapper.
.LI
The object instances must be registered within the Object Table
such that requests to specific objects can be mapped into member
function invocations.
.LE
.P
All of these issues are encompassed within the single
\*(lBregister_named_object()\*(lE member function provided by
the \*(lBrpc_object_reference\*(lE class.
.P
.H 2 "The \*c Reference Operator (\*(lB&\*(lE)"
.P
When a parameter in the IDL file is specified as being passed by
reference by using the \*c reference operator (\*(lB&\*(lE), it
will be transmitted as a \*(lB[ref]\*(lE pointer.
.P
.H 2 "Static Interface Operations"
.P
In order to provide the specification of a static interface
operation, the IDL language is extended to support the
\*(lBstatic\*(lE keyword and \*(lBcxx_static\*(lE ACF attribute:
.P
.aL
.LI
\*(lBstatic \*(jBoperation_definition\*(jE\*(lE
.P
Usage: IDL.
.P
When used in an IDL file preceding an operation definition,
identifies the operation as a static member function of the
interface.
.LI
\*(lB[cxx_static] \*(jBoperation()\*(jE\*(lE
.P
Usage: ACF.
.P
When used in an ACF file as an operation attribute, identifies
the operation as a static member function of the interface.
.LI
\*(lB[cxx_static( \*(jBname\*(jE )] \*(jBoperation()\*(jE\*(lE
.P
Usage: ACF.
.P
When used in an ACF file as an operation attribute, identifies
the operation as a static member function of the interface which
invokes the function identified by \*(lB\*(jBname\*(jE\*(lE from
the server stub.
.LE
.P
.H 2 "Object Security"
.P
All generated object interfaces will support an operation which
allows the client to set authorization and authentication
information on the encapsulated object reference.
.P
All non-static member functions of an interface will implement
remoteness with an IDL-supplied explicit binding handle
parameter.  This parameter will be constructed on the the client
side from the encapsulated binding handle in the object proxy
and passed as an argument to the operation.  This handle
parameter is only used to provide remoteness and is not passed
as an argument to the manager object operation.
.P
Servers that wish to gain access to the binding handle parameter
from within a member function operation will be provided with an
interface which returns the binding handle.  Static member
functions and object creator operations can specify the use of
an explicit handle in the operation definition.  Access to the
binding handle from a member function is provided for the
purpose of implementing a reference monitor for validating
authentication and authorization.
.P
.H 2 "Object Location Transparency"
.P
Client applications may wish to create local objects of a remote
interface and pass them as \*(lB[in]\*(lE parameters to remote
procedures.  Similarly, server applications may want to access
non-local objects with a remote interface as they are passed in
as parameters.  This can be accomplished simply by linking the
server stub with the client application and the client stub with
the server application respectively.  Clients that pass an
object reference as a parameter to a remote procedure will
automatically become registered servers of the object interface.
.P
Should the client or server application not be linked with the
necessary stub, an exception will be raised indicating the need
for the stub at runtime.  Servers that raise such an exception
will propagate the exception back to the client:
.P
.aL
.LI
\*(lBrpc_x_no_server_stub\*(lE indicates that the server stub
was not linked with the client application and a local object
reference is being passed as an input parameter to a remote
procedure.
.LI
\*(lBrpc_x_no_client_stub\*(lE indicates that the client stub
was not linked with the server application and a reference is
being attempted for a non-local object reference.
.LE
.P
.H 2 "C Bindings to \*c Objects"
.P
In order to support C bindings to \*c objects, all IDL generated
header files will contain macros that will allow a \*c like
interface to remote objects.  Macro names will be the
concatenation of the interface name and operation name.  The
\*(lBthis\*(lE pointer will be a required user supplied
parameter on macros representing non-static member functions.
.P
.H 2 "\*c Bindings to C Servers"
.P
The DCE IDL compiler already generates client and server stubs
that allow access to operations from \*c.  By supplying an ACF
attribute making all operations in an IDL file a static member
function of an interface, the operations can be referenced in a
slightly more object oriented way from the client application by
prefixing the name with the \*(lB\*(jBinterface-name\*(jE::\*(lE syntax.
.P
.H 2 "Native \*c Objects as RPC Parameters"
.P
The passing of native \*c objects as an RPC parameter is support
by two techniques.  One technique involves the packaging of the
object's data into a compatible NDR format and the
reconstruction of the object on the receiver side of an RPC
call.  The other technique passes a reference to the actual
object as the RPC argument, allowing the server to make
callbacks to the real object.
.P
To pass an object by value, the ACF attribute
\*(lBrepresent_as\*(lE is applied to the class name.  The
developer would then supply the typical four routines to convert
the \*c object to NDR format, reconstruct the \*c object from
its NDR data format, and deallocation routines for the NDR and
\*c representation of the data.  The IDL language is extended to
support the \*(lBrepresent_as\*(lE attribute on unique pointer
types.
.P
To pass an object by reference, the ACF attribute
\*(lBcxx_delegate\*(lE is applied to an interface for the
object.  The IDL compiler will generate the necessary class
hierarchy and implementation methods to allow a delegate class
pointer as an RPC parameter.  When an invocation is made on the
delegate object reference, the DCE runtime will propagate the
method call back to the original object transparently.
.P
.H 2 "Automatic Rebind Policy"
.P
An object reference will contain potentially several binding
handles which can be used to communicate with the manager
object.  If a communication or connection error occurs, the
client stub can choose another appropriate binding handle to
try.  The policy for choosing a fail-over handle is set by the
\*(lBSetRebind()\*(lE API.  Choices include:
.P
.aL
.LI
\*(lBnever_rebind\*(lE \*(EM
Do not attempt to rebind the object reference.
.LI
\*(lBattempt_rebind\*(lE \*(EM
Attempt to rebind using only the encapsulated handles at most once each.
.LI
\*(lBwait_on_rebind\*(lE \*(EM
Attempt to rebind using the encapsulated handles until successful.
.LI
\*(lBattempt_rebind_n\*(lE \*(EM
Attempt to rebind using the encapsulated handles a maximum number of times.
.LE
.P
.H 2 "Generation of a \*c Manager Class"
.P
The IDL compiler will automatically generate a manager class for
the interface with the method bodies appropriately stubbed out.
Developers can then derive their own manager class from the
IDL-generated class and implement the various methods
incrementally.  This facilitates the development of server
applications by insuring that all interface operations in the
manager class have the correct signature while also providing an
implementation for all the pure virtual methods in the
interface.  To prohibit the generation of a manager class, the
IDL compile time option \*(lB-no_cxxmgr\*(lE is provided.
.P
.H 2 "Exception Model"
.P
The use of the DCE exception model is supported for exceptions.
.P
.H 2 "Extended \*(lBenum\*(lE Support"
.P
The IDL language includes an \*(lBenum\*(lE feature similar to
the supported by the C language.  The feature is extended to
allow the specific assignment of values to \*(lBenum\*(lE types.
.P
.H 2 "Automatic Binding and the Host Profile"
.P
The automatic binding feature of IDL queries the DCE Naming
service for an entry designated by the environment variable
\*(lBRPC_DEFAULT_ENTRY\*(lE.  If that environment variable is
not set, the DCE runtime will query the host's Naming service
profile for an entry matching the interface.
.P
.H 2 "Client Specification of Memory Allocation Routines"
.P
The IDL language is extended with an ACF interface attribute
\*(lBclient_memory(\*(jBmalloc_routine\*(jE,
\*(jBfree_routine\*(jE)\*(lE to specify the memory allocation
routines used by client stubs.  The routines specified as the
arguments to the attribute must match the system's signatures
for \*(lBmalloc()\*(lE and \*(lBfree()\*(lE.
.P
.H 1 "DATA STRUCTURES"
.P
The only new data structures exposed to the user are the class
definitions generated to support a distributed object given an
interface.  Specifically, this class definition would have the
same name as the interface it is built from.
.P
.H 1 "USER INTERFACE"
.P
The command line option \*(lB-lang cxx\*(lE to the IDL compiler
will cause the generation of \*c stubs for distributed object
support.
.P
The command line option \*(lB-no_cxxmgr\*(lE to the IDL compiler
will suppress the generation of a \*c manager class.
.P
.H 1 "APIs"
.P
.aL
.LI
\*(lB\*(jBinterface\*(jE * \*(jBinterface\*(jE::bind( unsigned_char_t * )\*(lE
.P
Usage: client.
.P
Allows the client to bind an interface pointer to a long lived
remote object using a name as advertised in the name space.
.LI
\*(lB\*(jBinterface\*(jE * \*(jBinterface\*(jE::bind( uuid_t * )\*(lE
.P
Usage: client.
.P
Allows the client to bind an interface pointer to a long lived
remote object using an object identifier and searching the name
space starting at the location indicated by the
\*(lBRPC_DEFAULT_ENTRY\*(lE environment variable.
.LI
\*(lB\*(jBinterface\*(jE * \*(jBinterface\*(jE::bind( rpc_binding_handle_t )\*(lE
.P
Usage: client.
.P
Allows the client to bind an interface pointer to a long lived
remote object using a binding handle.  The name space is not
accessed for this operation.
.LI
\*(lBvoid \*(jBinterface\*(jE::register_named_object( unsigned_char_t *, boolean32 = TRUE)\*(lE
.P
Usage: server.
.P
Allows the server to advertise and optionally register an object
with the Naming service and DCE runtime respectively.
.ne 7
.LI
.if t .ft 5 \" Constant width font in troff.
void \*(jBinterface\*(jE::secure(
.br
.nf
     unsigned char * = 0,                     // svr princ name
     unsigned32 = rpc_c_protect_level_default // prot level
     unsigned32 = rpc_c_authn_default         // authorization
     rpc_auth_identity_handle_t = NULL,       // auth identity
     unsigned32 authz_svc = rpc_c_authz_name  // authorization
)
.if t .ft 1 \" Back to standard font in troff.
.fi
.P
Usage: client.
.P
Allows the client to set authorization and authentication
information in an object reference.
.LI
\*(lBhandle_t \*(jBinterface\*(jE::get_binding_handle()\*(lE
.P
Usage: server.
.P
Allows access to the caller's binding handle within a manager
class method implementation.  Per call binding handles are
maintained in thread specific storage.
.ne 4
.LI
.if t .ft 5 \" Constant width font in troff.
void \*(jBinterface\*(jE::SetRebind()
.br
.nf
     DCERebindPolicy,   // rebind policy
     unsigned32 = 0     // for attempt_rebind_n
)
.if t .ft 1 \" Back to standard font in troff.
.fi \" Fill mode.
.P
Usage: client.
.P
Allows the client to specify a rebind policy for interface
method invocations that fail due to communication or connection
failures.  The default policy is \*(lBattemp_rebind\*(lE.
.LE
.P
.H 1 "REMOTE INTERFACES"
.P
None.
.P
.H 1 "MANAGEMENT INTERFACES"
.P
None.
.P
.H 1 "RESTRICTIONS AND LIMITATIONS"
.P
The use of non-prevalent \*c compiler options such as \*c
Templates and \*c Exceptions is avoided in the interest of
portability.
.P
.H 1 "OTHER COMPONENT DEPENDENCIES"
.P
.H 2 "DCE Naming"
.P
Named objects that are advertised by a server use the Naming
service APIs to advertise the object in the name space.  The use
of this capability is optional.
.P
.H 2 "DCE RPC"
.P
To transmit an object reference, an internal tower data
structure is used to enhance the efficiency of the remote
procedure call.  The DCE RPC component requires the addition of
two internal system programmer interfaces to convert between a
binding vector and a tower representation.
.P
.H 2 "\*c Compiler"
.P
A new runtime library will contain all the \*c support for DCE
distributed objects.  This library requires a \*c compiler in
order to be built.  Vendors not wishing to integrate this \*c
support into their DCE products do not need to build this
library, therefore eliminating the requirement of a \*c compiler
for building DCE 1.2.
.P
.H 1 "COMPATIBILITY"
.P
The IDL compiler with \*c extensions is fully backwards
compatible.
.P
.H 1 "STANDARDS"
.P
None.
.P
.H 1 "OPEN ISSUES"
.P
None.
.P
.H 1 "REFERENCES"
.P
None.
.P
...\" =========================================================================
...\" Author's address goes here, as unnumbered heading, at end of doc.
...\" =========================================================================
.ne 3+5
.HU "AUTHOR'S ADDRESS"
.P
.tl $Bob Viveney$$Internet email: viv@zko.dec.com$
.tl $Digital Equipment Corporation$$Telephone: +1-603-881-0362$
.tl $110 Spit Brook Road ZK2-3/Q18$$$
.tl $Nashua, NH 03062-2698$$$
.tl $USA$$$
...\" =========================================================================
...\" Done!
...\" =========================================================================
