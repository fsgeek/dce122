...\" OSF-RFC 88.0
...\"
...\" FORMATTING INSTRUCTIONS for this RFC:
...\"       nroff -Tlpr rfc88.0.roff > rfc88.0.txt
...\"       troff -Tps rfc88.0.roff | <ps-post-processor> > rfc88.0.ps
...\" (Where "troff" means "device-independent troff", or "ditroff".)
...\"
...\" If troff is not supported for a given RFC, insert the following:
...\" .if t \{\
...\" .tm *** Troff not supported for this RFC.
...\" .ex \}
...\"
...\" =========================================================================
...\" This template first sets a bunch of *roff options (authors/readers
...\" don't usually have to know about these).
...\" Then it defines some strings and macros, many of which deal with
...\" things that differ between nroff & troff (some of these may not be
...\" perfect, but they're better than nothing -- to do a really good
...\" job would require a real semantic markup language.
...\" Convention: "Begin/End" for strings, "Start/Finish" for macros.
...\" Strings:
...\"       \*(f!        - Footnote string (replaces \*F).
...\"       \*(hB, \*(hE - Page header/footer font (internal use).
...\"       \*(kB, \*(kE - Doc header font (internal use).
...\"       \*(qB, \*(qE - Quotations.
...\"       \*(iB, \*(iE - Italics/emphasis in primary font.
...\"       \*(bB, \*(bE - Bold font.
...\"       \*(lB, \*(lE - Literal font.
...\"       \*(jB, \*(jE - Italics/emphasis in literal font.
...\"       \*(nH        - Default note header string.
...\" Macros:
...\"       .aH      - Appendix header macro (uses number register \na).
...\"       .aL      - Automatic list macro (replaces .AL; uses num reg \ng).
...\"       .tS, .tF - Title start/finish (internal use).
...\"       .cS, .cF - Displays (no-fill) without indentation.
...\"       .dS, .dF - Displays (no-fill) with indentation.
...\"       .iS, .iF - Indented (fill) text.
...\"       .nS, .nF - Note.
...\" -------------------------------------------------------------------------
...\" First, set up some number registers here (instead of on command line),
...\" and include the "mm" macro package here (instead of on command line).
...\" -------------------------------------------------------------------------
.if n .nr L 66 \" Nroff page length = 66 lines.
.if t .nr L 11i \" Troff page length = 11 inches.
.if n .nr W 72 \" Nroff page width = 72 columns.
.if t .nr W 6.5i \" Troff page width = 6.5 inches.
.if n .nr O 3 \" Nroff page offset = 3 columns.
.if t .nr O 0.75i \" Troff page offset = 0.75 inches.
.nr N 2 \" No header on page 1.
.so /usr/lib/tmac/tmac.m \" Points to "mm" package, in /usr/lib/macros.
...\" -------------------------------------------------------------------------
...\" Next, twiddle the "mm" package to suit our preferred style.
...\" -------------------------------------------------------------------------
...\" Point size and font types.
...\" -------------------------------------------------------------------------
.if n .fp 1 R \" "Regular" font ONLY -- don't use any others in nroff.
.if t \{ .S 10 12 \" Point size = 10, vertical spacing = 12.
...\" Note: Some systems give different names to these fonts.
.fp 1 R \" Times roman.
.fp 2 I \" Times italic.
.fp 3 B \" Times bold.
.fp 4 BI \" Times bold italic.
.fp 5 CW \" Courier.
.fp 6 CI \" Courier oblique.
.fp 7 CB \" Courier bold.
.fp 8 CX \" Courier bold oblique.
.fp 9 H \" Helvetica.
.fp 10 HI \" Helvetica oblique.
.fp 11 HB \" Helvetica bold.
.fp 12 HX \" Helvetica bold oblique.
.fp 13 S \} \" Special symbol font -- normally only called automatically.
...\" -------------------------------------------------------------------------
...\" Headings; page header and footers; titles.
...\" -------------------------------------------------------------------------
.nr Ej 0 \" No eject for first-level headings.
.nr Hs 7 \" Heading space level = blank line after heading (all levels).
.nr Hb 7 \" Heading break level = break after heading (all levels).
.nr Hi 1 \" Post-heading indent = paragraph indent.
.nr Hc 0 \" Heading centering = none.
.if n .ds HF 1 1 1 1 1 1 1 \" Heading fonts = regular (no underlining).
.if t .ds HF 11 11 11 11 11 11 11 \" Heading fonts = Helvetica bold.
.if t .ds HP 0 0 0 0 0 0 0 \" Heading point sizes (= default).
.HM 1 1 1 1 1 1 1 \" Heading mark = arabic (all levels).
.nr Hu 1 \" Unnumbered heading level = 1 (see aH macro, below).
.de HX \" Beginning-of-heading processing.
.in 0 \" Left justify headings.
.ie     \\$2=0 .ds }0\" Null string heading mark for HU.
.el .ie \\$1=1 .ds }0 \\n(H1.\ \&\" Heading marks = dotted sections + 1 space.
.el .ie \\$1=2 .ds }0 \\n(H1.\\n(H2.\ \&
.el .ie \\$1=3 .ds }0 \\n(H1.\\n(H2.\\n(H3.\ \&
.el .ie \\$1=4 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\ \&
.el .ie \\$1=5 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\ \&
.el .ie \\$1=6 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\\n(H6.\ \&
.el .if \\$1=7 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\\n(H6.\\n(H7.\ \&
..
.de HZ \" End-of-heading processing.
.if n .in 3 \" Indent body of doc by 3 columns in nroff.
.if t .in 0 \" Don't indent in troff.
..
.if n .ds hB \&\" Page header/footer font begin in nroff.
.if t .ds hB \f9\" Page header/footer font begin in troff.
.if n .ds hE \&\" Page header/footer font end in nroff.
.if t .ds hE \fP\" Page header/footer font end in troff.
.if n .ds kB \&\" Doc header font begin in nroff.
.if t .ds kB \f(11\" Doc header font begin in troff.
.if n .ds kE \&\" Doc header font end in nroff.
.if t .ds kE \f1\" Doc header font end in troff.
.de tS \" Title start.
.SP 2 \" 2 blank lines.
.ce 99 \" Center (each line of) title.
.if t \{ .ft 11 \" Bold helvetica.
.S +2 D \} \" Bigger point size.
..
.de tF \" Title finish.
.ce \" Turn off centering.
.SP 1 \" 1 blank line.
.if t \{ .ft 1 \" Return to regular font.
.S P P \} \" Return to regular point size.
..
...\" -------------------------------------------------------------------------
...\" Special Appendix heading macro, .aH.
...\" -------------------------------------------------------------------------
.nr a 0 1 \" Appendix number.
.af a A \" Assign format upper-case alpabetic to number register a.
.de aH \" Appendix heading macro.
.if \\na=0 \{ .nr H1 0 \" Reset H1 to 0.
.HM A 1 1 1 1 1 1 \} \" Heading mark = Upper case alphabetic + arabics.
.HU "APPENDIX \\n+a. \\$1"
..
...\" -------------------------------------------------------------------------
...\" Paragraph stuff.
...\" -------------------------------------------------------------------------
.nr Pt 0 \" Paragraph type = left-justified.
.nr Pi 0 \" Paragraph indent = 0.
.nr Ps 1 \" Paragraph spacing = 1 blank space.
...\" -------------------------------------------------------------------------
...\" Special list macro, .aL (replaces .AL, for all levels).
...\" This should be used for almost all lists (including ".LI "\ "").
...\" The only exception is variable lists (.VL, indented by multiples of 6).
...\" -------------------------------------------------------------------------
.de aL
.nr g \\n(:g
...\" In-line lists should be numbered (by hand): (1), (2), (3), ...
.ie     \\ng=0 .LB 6 0 1 3 a \" 1st level: (a), (b), (c), ...
.el .ie \\ng=1 .LB 6 0 1 3 i \" 2nd level: (i), (ii), (iii), ...
.el .ie \\ng=2 .LB 6 0 1 4 a \" 3rd level: [a], [b], [c], ...
.el .ie \\ng=3 .LB 6 0 1 4 i \" 4th level: [i], [ii], [iii], ...
.el .ie \\ng=4 .LB 6 0 1 6 a \" 5th level: {a}, {b}, {c}, ...
.el .if \\ng=5 .LB 6 0 1 6 i \" 6th level: {i}, {ii}, {iii}, ...
..
.nr Ls 6 \" Blank lines between all list items, by default (but adjustable).
...\" -------------------------------------------------------------------------
...\" Footnote stuff; special footnote string, \*(f!.
...\" -------------------------------------------------------------------------
.if n .ds f! [\\n+(:p]\" Footnote string (replaces \*F in nroff).
.if t .ds f! \\*F\" Footnote string (same as \*F in troff).
.if n .FD 6 \" Footnotes not hyphenated or indented, label left justified.
.if t .FD 5 \" Footnotes hyphenated, not indented, label left justified.
.nr Fs 1 \" 1 blank line between footnotes.
...\" -------------------------------------------------------------------------
...\" Line adjustment stuff.
...\" -------------------------------------------------------------------------
.if n .nr Hy 0 \" No hyphenation in nroff.
.if t .nr Hy 1 \" Hyphenate in troff.
.if n .SA 0 \" Set adjust: left margin only in nroff.
.if t .SA 1 \" Set adjust: left and right margins in troff.
...\" -------------------------------------------------------------------------
...\" Miscellaneous stuff.
...\" -------------------------------------------------------------------------
.ta \" No tabs by default -- set them up by hand as needed.
.nr Si \n(Ls \" Default indent for .DS display macro = 6 (use in troff only).
...\" -------------------------------------------------------------------------
...\" Displays.
...\" -------------------------------------------------------------------------
.de cS \" Display start: no-fill, literal font, no indentation.
.P
.nf \" No fill mode.
.if t .ft 5 \" Constant width font in troff.
..
...\" Within .cS, ".ne N"'s can be added by hand, but should be minimized.
.de cF \" Display finish.
.if t .ft 1 \" Back to standard font in troff.
.fi \" Fill mode.
.P
..
.de dS \" Display start: no-fill, literal font, with indentation.
.P
.aL \" Use .aL macro for consistent indentation.
.nf \" No fill mode.
.LI "\ " \" List item will no (visible) marker.
.if t .ft 5 \" Constant width font in troff.
..
...\" Within .dS, ".ne N"'s can be added by hand, but should be minimized.
.de dF \" Display finish.
.if t .ft 1 \" Back to standard font in troff.
.fi \" Fill mode.
.LE
.P
..
.de iS \" Indent start: fill, regular font, with indentation.
.P
.aL
.LI "\ "
..
.de iF \" Indent finish.
.LE
.P
..
.ds nH NOTE\"Default note header string -- can be changed by author.
.de nS \" Note start: fill, italics font, with indentation.
.P
.aL \" Use .aL macro for consistent indentation.
.LI "\ " \" List item will no (visible) marker.
.if t .ft 2 \" Italics font in troff, and reverse roman <--> italic fonts:
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f1\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.ie \\n(.$=0 \\*(nH:\" Default header string if none supplied by author.
.el \\$1:\" Header string supplied by author as argument to .nS macro.
..
.de nF \" Note finish.
.if t .ft 1 \" Back to standard font in troff, and remap font macros:
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f2\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.LE
.P
..
...\" -------------------------------------------------------------------------
...\" Quotation marks and font toggles.
...\" -------------------------------------------------------------------------
.if n .ds qB \&"\" Quotation begin in nroff.
.if t .ds qB ``\" Quotation begin in troff.
.if n .ds qE \&"\" Quotation end in nroff.
.if t .ds qE ''\" Quotation end in troff.
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f2\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.if n .ds bB *\" Bold font begin in nroff.
.if t .ds bB \f3\" Bold font begin in troff.
.if n .ds bE *\" Bold font end in nroff.
.if t .ds bE \fP\" Bold font end in troff.
.if n .ds lB `\" Literal font begin in nroff.
.if t .ds lB \f5\" Literal font begin in troff.
.if n .ds lE '\" Literal font end in nroff.
.if t .ds lE \fP\" Literal font end in troff.
.if n .ds jB <\" Italics/emphasis literal font begin in nroff.
.if t .ds jB \fP\f6\" Italics/emphasis literal font begin in troff.
.if n .ds jE >\" Italics/emphasis literal font end in nroff.
.if t .ds jE \fP\f5\" Italics/emphasis literal font end in troff.
...\" -------------------------------------------------------------------------
...\" No diffmarks by default, i.e., define .mc to be null.
...\" (Comment out this null definition to turn diffmarking on.)
...\" -------------------------------------------------------------------------
.de mc
..
...\" =========================================================================
...\" Finally, it's time to start writing the document!
...\" The OSF-RFC author modifies the following header/footer info.
...\" (The major/minor number is assigned by the OSF-RFC Editor.)
...\" =========================================================================
.ND "December 1995" \" Date must be hard-coded.
.PH "$\*(hBOSF-RFC 88.0$Jukebox Backup for DFS$\\\\*(DT\*(hE$"
.PF "$\*(hBGait, Khale, Morin$DRAFT #1$Page \\\\n%\*(hE$" \" Draft version.
.PF "$\*(hBGait, Khale, Morin$$Page \\\\n%\*(hE$" \" Final version.
...\"
...\" Following are the first printed lines (header info) of the document:
...\"
\&\" Force top-of-first-page trap to position the following info correctly.
.tl $\*(kBOpen Software Foundation$$J. Gait (Transarc)\*(kE$
.tl $\*(kBRequest For Comments: 88.0$$A. Khale (Transarc)\*(kE$
.tl $\*(kB\*(DT$$J. Morin (Transarc)\*(kE$
.tS \" Title, in all capitals (can span multiple lines):
A JUKEBOX BACKUP SUBSYSTEM FOR DFS
.tF
...\" =========================================================================
...\" Now, the actual body of the document!!
...\" Heading capitalization style:
...\"     1st level: CAPITALIZE ALL WORDS
...\"     2nd level: Capitalize Initial Letters of All (Significant) Words
...\"     3rd-7th level: Capitalize first letter of first word only
...\" =========================================================================
.P
.H 1 "INTRODUCTION" \" Always start with an introduction section.
.P
The current DFS backup subsystem requires a backup operator to
respond to queries from the device controller.  In particular
\*(bBstorage units\*(bE (tapes) have to be manually
loaded.  Modern stacker and jukebox equipment encourage more
flexible approaches to managing backups that focus on storage
unit autoloading and default responses.  This RFC describes a
methodology for gracefully integrating stackers and jukeboxes
into the DFS backup subsystem in a way that supports unattended
backup of large-scale DFS file systems.
.P
.H 1 "OVERVIEW OF DFS BACKUP"
.P
The DFS backup subsystem supports dump and restore of DFS
filesets to and from tape.  (The restoration of an individual
file entails the restoration of its containing fileset.)  There
are four areas of strength in the DFS backup subsystem:
.P
.aL
.LI
\*(iBOn-line backup.\*(iE  The DFS backup subsystem supports
on-line dump of DFS filesets during operations with minimal
impact.  (The mechanism is to dump clones of the target
filesets.)
.LI
\*(iBSingle point of control.\*(iE  Since it is feasible to
carry on simultaneous backup to multiple \*(bBstorage
devices\*(bE (tape drives) on multiple machines in the cell, it
is possible for a great deal of management complexity to be
introduced.  The backup subsystem is designed to manage complex
activities as gracefully as possible by integrating all backup
operator actions at a single node in the DFS cell.
.LI
\*(iBMulti-fileset atomicity.\*(iE  It is possible to specify a
family of filesets that is atomically dumped and restored.  This
feature supports coherent backup and restore of mutually
interdependent filesets.  (Most commonly this feature is used to
treat the filesets in an aggregate together for purposes of
backup.)
.LI
\*(iBBackup for moving filesets.\*(iE  The files stored in DFS
may be transparently moved among the file servers in the cell at
(almost) any time.  Thus the backup subsystem is designed to
handle moving filesets.
.LE
.P
Each storage unit is \*(bBlabeled\*(bE by the backup subsystem.  The label
is written into the first 16 kbytes and contains a name for the
storage unit, a specification of the fileset being dumped, a
dump ID and date, and an expiration date, among other things.
The label is written in an internal DFS format \*(EM currently there
is no support for ANSI standard or IBM standard labels.  DFS
does not currently support permanent names for storage units.
(A permanent name could be known to the jukebox and used to
locate a particular storage unit during a restore.)
.P
There are three components to the backup subsystem: the
\*(bBdevice coordinator\*(bE, the \*(bBbackup program\*(bE, and
the \*(bBbackup database\*(bE.  These are discussed in the
following subsections.
.P
.H 2 "Device Coordinator"
.P
Each storage device used by the DFS backup subsystem is attached
to a DFS server machine that runs a process called a \*(bBdevice
coordinator\*(bE, or \*(bBbackup tape coordinator\*(bE
(\*(lBbutc\*(lE), for that storage device.  The
device coordinator is specific to the storage device being
coordinated, so if there are multiple storage devices attached
to the DFS server, then there is a device coordinator for each
one.  The device coordinator is responsible for managing the
storage device, its \*(bBdevice configuration file\*(bE and log
files stored on the same machine.  The set of device
coordinators in a DFS cell are distinguished from one another by
cell-wide unique device coordinator IDs.
.P
A device coordinator stores each fileset contiguously on a
storage unit, or on multiple storage units if necessary, and
separates filesets by an EOF, or \*(bBend of fileset\*(bE mark.
The size of the EOF is storage device dependent and may be as
large as 2 mbytes.  The device configuration file for the
storage device contains the name of the device, the size of the
storage unit, the size of the EOF mark, and the device
controller ID.
.P
The device coordinator has interactions with five other
entities:
.P
.aL
.LI
With the storage device while managing the storage units.
.LI
With the DFS file exporter while dump and restore operations are in
process.
.LI
With the user of the backup subsystem to effect physical operations
that require stereotypical operator action.
.LI
With the local file system to configure the storage device and
to log operations.
.LI
With the cell backup database.
.LE
.P
.H 3 "Interaction with the operator"
.P
There are a number of explicit interactions between the device
coordinator and the operator:
.P
.aL
.LI
The operator is prompted for the first storage unit.
.LI
The operator is prompted to change the storage unit.
.LI
When a restore operation experiences a failure, the operator is
prompted whether to proceed.
.LI
When a dump fileset operation fails, the operator is prompted whether to
retry the fileset, omit the fileset or abort the operation.
.LI
The operator may be prompted during \*(lBscantape\*(lE
operations whether there is an additional storage unit to be
scanned.
.LI
The operator may be prompted whether to label a storage unit.
.LE
.P
Any of these events halts backup operations subject to the
intervention of the backup operator.  Prompting for the first
storage unit can be turned off by starting the device
coordinator with the \*(lBnoautoquery\*(lE flag.  In this case
the first storage unit is assumed to be loaded.
.P
.H 2 "Backup Program"
.P
This is the central point for managing the backup subsystem and
is run by the backup operator on any client machine in the DFS
cell.  This \*(bBbackup program\*(bE (\*(lBbak\*(lE) has four
points of interaction with other entities:
.P
.aL
.LI
With the operator.  Tape coordinator operator interactions are
brought to the same client machine, but different windows.
.LI
With the ensemble of device coordinators hosted on various other
server machines in the cell.
.LI
With the cell backup database.  (A log is also kept and stored locally.)
.LI
With the DFS FLDB to obtain the locations of filesets.
.LE
.P
The backup program is the focus for the definition of fileset
families.
.P
.H 2 "Backup Database"
.P
The cell-wide \*(bBbackup database\*(bE records dump schedules, locations
of device coordinators, fileset families, etc.  The backup
database is maintained by a DFS server called the
\*(lBbakserver\*(lE.  The backup database must be complete and
consistent to guarantee that filesets can be restored, so it
must itself be backed-up.  Ultimately the backup of the backup
database resolves to halting DFS activity on the host, usually
via \*(lBbos\*(lE commands, and a resort to host vendor provided
backup utilities or to specialized DFS backup subsystem
commands.
.P
.H 1 "JUKEBOX BACKUP"
.P
Stackers and jukeboxes are capable of switching between physical
storage units automatically during dump operations, and
jukeboxes are capable of automatically switching between the
correct physical storage units during restore.  The DFS backup
subsystem supports these devices by providing an \*(bBauto
operation configuration file\*(bE that is read by \*(lBbutc\*(lE
when it starts a device coordinator process for the device,
configuring the device coordinator with the information taken
from the auto operation configuration file.  The auto operation
configuration file is placed in the directory
\*(lBdcelocal/var/dfs/backup\*(lE, and is given a name of the
form \*(lBconf_\*(jBdevice\*(jE\*(lE, where
\*(lB\*(jBdevice\*(jE\*(lE specifies a particular jukebox or
stacker.  Currently DFS uses the path name of the jukebox or
stacker to specify \*(lB\*(jBdevice\*(jE\*(lE.  (Note: the
\*(iBauto\*(iE operation configuration file is different from
the ordinary device configuration file, which defines the
physical device to the device coordinator.)
.P
The auto operation configuration file supports these parameters:
.P
.aL
.LI
\*(lBMOUNT\*(lE: The path to a procedure that performs
mount operations on physical storage units.
.LI
\*(lBUNMOUNT\*(lE: The path to a procedure that performs unmount
operations on physical storage units.
.LI
\*(lBASK\*(lE: Configures a set of default answers to prompts,
except for the initial prompt from the device coordinator.
.LI
\*(lBNAME_CHECK\*(lE: Normally the names of physical storage
units are checked; this parameter enables bypassing the name
check, hence makes it possible to recycle storage units without
relabeling them.
.LI
\*(lBFILE\*(lE: It is possible to use this mechanism to dump and
restore to and from a set of files, rather than to and from a
set of storage units in a stacker or jukebox; this parameter
relates to this capability.
.LE
.P
The \*(lBASK\*(lE parameter is used in conjunction with the
\*(lBnoautoquery\*(lE startup flag to \*(lBbutc\*(lE to
automate, as nearly as is possible, the manipulation of physical
storage units.  Any error while operating on storage devices is
interpreted by the device coordinator in a manner that is as
compatible as possible with unattended operation, as follows:
.P
.aL
.LI
\*(lBlabeltape\*(lE: If an error occurs during a \*(lBlabeltape\*(lE
operation, then the device coordinator prompts for another tape.
.LI
\*(lBdump\*(lE: An error during a \*(lBdump\*(lE operation
indicates a fileset error and the device coordinator accordingly
omits the fileset.
.LI
\*(lBrestore\*(lE: An error during \*(lBrestore\*(lE indicates a
fileset error, so the device coordinator omits the fileset.
.LI
\*(lBscantape\*(lE: An error during a \*(lBscantape\*(lE
operation means there is a problem in determining the next
storage device; the device coordinator prompts for it.
.LE
.P
These parameters are passed to the \*(lBmount\*(lE procedure:
.P
.aL
.LI
The path to the device.
.LI
The operation to be performed.
.LI
The number of times the physical storage unit has been
requested.
.LI
The name of the storage unit.
.LI
The dump identifier.
.LE
.P
The operation to be performed is drawn from one of the
\*(lBbak\*(lE commands: \*(lBdump\*(lE, \*(lBlabeltape\*(lE,
\*(lBreadlabel\*(lE, \*(lBrestore\*(lE, and \*(lBscantape\*(lE.
.P
These parameters are passed to the \*(lBunmount\*(lE procedure:
.P
.aL
.LI
The path to the device.
.LI
The operation to be performed.
.LE
.P
For the \*(lBunmount\*(lE procedure the operation to be
performed is always the \*(lBbak\*(lE command \*(lBunmount\*(lE.
.P
These scripts are written by the system administrator and are
executed by the device coordinator.  The system administrator
must still verify that filesets were successfully dumped and
must still physically update the external label on the storage
unit that contains the dumped fileset.
.P
.H 1 "CHANGES TO BACKUP FOR JUKEBOXES"
.P
The changes required in the DFS backup subsystem to support
stackers and jukeboxes are pervasive but not particularly
extensive.  The two important things to do are to make all
interactions between the device coordinator and the backup
operator selective and settable from the auto operation
configuration file, and to supply a callout routine that invokes
the procedures for \*(lBmount\*(lE and \*(lBunmount\*(lE that
are referenced in the auto operation configuration file and
defined by the system administrator on a per-device basis.
.P
.H 2 "Configuring the Tape Coordinator"
.P
Here are the four configurable parameters that have been introduced,
together with their default values:
.P
.dS
.ne 4
dump_namecheck = 1;
queryoperator  = 1;
opencallout    = (char *)0;
closecallout   = (char *)0;
.dF
.P
So by default storage unit names are checked, operations are
interactive and there is no callout to external routines to
mount and unmount storage units.  These values are resettable by
the device coordinator at startup to the values found in the
auto operation configuration file.  For a stacker or jukebox the
system administrator would set \*(lBqueryoperator\*(lE to 0 so
operation would be non-interactive, and would supply values for
\*(lBopencallout\*(lE and \*(lBclosecallout\*(lE that would
automatically mount and unmount storage units in the device.
.P
.H 2 "Callout to an External Procedure"
.P
Here is the callout pseudocode that supports automatic mount
and unmount:
.P
.dS
if (fork() == 0)
{
    callOut = opencallout;
    switch (opflag)
    {
        case READOPCODE:
            strcpy(opcode, "restore");
            break;
        case WRITEOPCODE:
            strcpy(opcode, "dump");
            break;
        case LABELOPCODE:
            strcpy(opcode, "labeltape");
            break;
        case READLABELOPCODE:
            strcpy(opcode, "readlabel");
            break;
        case SCANOPCODE:
            strcpy(opcode, "scantape");
            break;
        case CLOSEOPCODE:
            strcpy(opcode, "unmount");
            callOut = closecallout;
            break;
    }
    CO_argv[0] = callOut;
    CO_argv[1] = tapePath;
    CO_argv[2] = opcode;
    if (opflag == CLOSEOPCODE)
        CO_argv[3] = (char *)0;
    else
    {
        CO_argv[3] = tapecount;
        if (name)
            CO_argv[4] = name;
        if (dbDumpId)
            CO_argv[5] = dbDumpId;
        CO_argv[6] = (char *)0;
    }
    code = execve(callOut, CO_argv, (char *)0);
}
.dF
.P
The callout routine is passed a flag that indicates the opcode,
and this information is combined with global values that
describe the state of the storage device and the backup activity
to construct a callout to the \*(lBmount\*(lE or
\*(lBunmount\*(lE routine provided by the system administrator.
The callout routine is invoked whenever the device coordinator
performs one of the indicated activities and the default values
of the configuration parameters have been reset for unattended
operation.
.P
The callout routine passes five arguments (\*(lBCO_argv[1]\*(lE through
\*(lBCO_argv[5]\*(lE) to the \*(lBmount\*(lE routine:
.P
.aL
.LI
The pathname of the storage device.
.LI
The operation to be performed.
.LI
The number of times the device coordinator has called the script
while repeatedly attempting this same operation.  (For example,
in case there is some physical problem with the storage unit.)
.LI
The name of the storage unit.
.LI
The tape ID.
.LE
.P
Only the first two of these arguments are passed to the
\*(lBunmount\*(lE routine.
.P
.H 1 "EXAMPLE: JUKEBOX EMULATION"
.P
The \*(lBFILE\*(lE parameter described above allows stacker and
jukebox operation to be emulated using a set of files in place
of the storage units of a multi-unit storage device.  This
feature separates the behaviors of the software backup system
from the behaviors of physical devices and dramatically improves
the quality of life for developers of backup code.  This
presentation serves to make the new technology concrete in a way
that does not depend on specific stacker or jukebox
implementation.
.P
Here is a sample auto operation configuration file that might be
used to emulate the physical storage device used for backup
using a set of files:
.P
.dS
.ne 6
MOUNT /opt/dcelocal/var/dfs/backup/DEVICE/mount
UNMOUNT /opt/dcelocal/var/dfs/backup/DEVICE/unmount
ASK NO
NAME_CHECK YES
FILE YES
.dF
.P
This file is read by \*(lBbutc\*(lE when the backup subsystem is
started.  The auto operation configuration file specifies
executable procedures for \*(lBmount\*(lE and \*(lBunmount\*(lE,
disables all interaction with the backup operator, enables name
checking and directs that a file is to be used instead of a
physical storage unit.  The path to the file is specified in the
device configuration file.
.P
Here is a (simplified) shell procedure for the \*(lBMOUNT\*(lE parameter:
.P
.dS
Path=$1
Operation=$2
Requests=$3
TapeName=$4
TapeControllerId=$5
DATA_DIR=`dirname $Path`/data
SCAN_LOCK=$DATA_DIR/.scan
if [ $Operation = "scantape" ]
then
    ROOT=`echo $Path | \e
        awk -F"." '{ORS=".";for(i=1;i<NF;++i)print $i}'`
    EXT=`echo $Path | \e
        awk -F"." '{print $NF}'`
    if [ -f $SCAN_LOCK ]
    then
        FILE="$ROOT`expr $EXT + 1`"
    else
        touch $SCAN_LOCK
        FILE="$ROOT1"
    fi
    if [ -f $FILE ]
    then
        rm -f $Path
        ln -s $FILE $Path
        exit 0
    else
        exit 1
    fi
fi
if [ $Operation = "labeltape" ]
then
    exit 0
fi
if [ ($Operation != "dump") -a ($Operation != "restore") ]
then
    exit 1
fi
rm -f $SCAN_LOCK
if [ -f $Path ]
then
    rm -f $Path
fi
if [ ! -d $DATA_DIR ]
then
    mkdir -p $DATA_DIR
fi
if [ ! -f $DATA_DIR/$TapeControllerId.$TapeName ]
then
    touch $DATA_DIR/$TapeControllerId.$TapeName
fi
ln -s $DATA_DIR/$TapeControllerId.$TapeName $Path
exit $?
.dF
.P
Notice that the \*(lBPath\*(lE parameter is actually a link to a
file.  The link represents the currently mounted physical storage
unit.  The \*(lBRequests\*(lE parameter is not used in this
script but would normally be used in scripts to prevent infinite
loops.  An error code of 1 from the script instructs the device
coordinator to end the operation, and any error code greater than
1 directs the device coordinator to prompt the operator.
.P
Here is a shell procedure for the \*(lBUNMOUNT\*(lE parameter:
.P
.dS
.ne 7
Path=$1
Operation=$2
if [ -f $Path ]
then
    rm -f $Path
fi
exit 0
.dF
.P
Here is the content of a sample device configuration file
designed for emulating physical storage with a set of files:
.dS
.ne 1
140M 200K /opt/dcelocal/var/dfs/backup/DEVICE/link 0
.dF
.P
The value of \*(lBlink\*(lE is a symbolic link to the file that
emulates the currently mounted storage unit.  This storage unit
stores 140 mbytes, uses 200 kbyte EOF marks, and is controlled by
device controller 0.  (Actually, when dumping to files the
device coordinator does not write EOF marks, so the 200 kbyte
value is ignored in the above example.)
.P
.P
.H 1 "ACKNOWLEDGEMENTS"
.P
The following persons made significant contributions to the
stacker and jukebox backup subsystem for DFS:
.P
.aL
.LI
Rick Welch (Naval Research Laboratory).
.LI
Peter Chan (IBM).
.LI
Jayant Ramakrishnan (University of Maryland).
.LE
.P
...\" =========================================================================
...\" Author's address goes here, as unnumbered heading, at end of doc.
...\" =========================================================================
.P
.ne 3+5
.HU "AUTHORS' ADDRESSES"
.P
.tl $Jason Gait$$Internet email: gait@transarc.com$
.tl $Transarc Corp.$$Telephone: +1-412-338-6933$
.tl $707 Grant Street$$$
.tl $Pittsburgh, PA 15219$$$
.tl $USA$$$
.P
.ne 5
.tl $Abhijit Khale$$Internet email: khale@transarc.com$
.tl $Transarc Corp.$$Telephone: +1-412-338-6956$
.tl $707 Grant Street$$$
.tl $Pittsburgh, PA 15219$$$
.tl $USA$$$
.P
.ne 5
.tl $John Morin$$Internet email: morin@transarc.com$
.tl $Transarc Corp.$$Telephone: +1-412-338-6908$
.tl $707 Grant Street$$$
.tl $Pittsburgh, PA 15219$$$
.tl $USA$$$
...\" =========================================================================
...\" Done!
...\" =========================================================================
