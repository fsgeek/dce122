...\" OSF-RFC 89.0
...\"
...\" FORMATTING INSTRUCTIONS for this RFC:
...\"       nroff -Tlpr rfc89.0.roff > rfc89.0.txt
...\"       troff -Tps rfc89.0.roff | <ps-post-processor> > rfc89.0.ps
...\" (Where "troff" means "device-independent troff", or "ditroff".)
...\"
...\" If troff is not supported for a given RFC, insert the following:
...\" .if t \{\
...\" .tm *** Troff not supported for this RFC.
...\" .ex \}
...\"
...\" =========================================================================
...\" This template first sets a bunch of *roff options (authors/readers
...\" don't usually have to know about these).
...\" Then it defines some strings and macros, many of which deal with
...\" things that differ between nroff & troff (some of these may not be
...\" perfect, but they're better than nothing -- to do a really good
...\" job would require a real semantic markup language.
...\" Convention: "Begin/End" for strings, "Start/Finish" for macros.
...\" Strings:
...\"       \*(f!        - Footnote string (replaces \*F).
...\"       \*(hB, \*(hE - Page header/footer font (internal use).
...\"       \*(kB, \*(kE - Doc header font (internal use).
...\"       \*(qB, \*(qE - Quotations.
...\"       \*(iB, \*(iE - Italics/emphasis in primary font.
...\"       \*(bB, \*(bE - Bold font.
...\"       \*(lB, \*(lE - Literal font.
...\"       \*(jB, \*(jE - Italics/emphasis in literal font.
...\"       \*(nH        - Default note header string.
...\" Macros:
...\"       .aH      - Appendix header macro (uses number register \na).
...\"       .aL      - Automatic list macro (replaces .AL; uses num reg \ng).
...\"       .tS, .tF - Title start/finish (internal use).
...\"       .cS, .cF - Displays (no-fill) without indentation.
...\"       .dS, .dF - Displays (no-fill) with indentation.
...\"       .iS, .iF - Indented (fill) text.
...\"       .nS, .nF - Note.
...\" -------------------------------------------------------------------------
...\" First, set up some number registers here (instead of on command line),
...\" and include the "mm" macro package here (instead of on command line).
...\" -------------------------------------------------------------------------
.if n .nr L 66 \" Nroff page length = 66 lines.
.if t .nr L 11i \" Troff page length = 11 inches.
.if n .nr W 72 \" Nroff page width = 72 columns.
.if t .nr W 6.5i \" Troff page width = 6.5 inches.
.if n .nr O 3 \" Nroff page offset = 3 columns.
.if t .nr O 0.75i \" Troff page offset = 0.75 inches.
.nr N 2 \" No header on page 1.
.so /usr/lib/tmac/tmac.m \" Points to "mm" package, in /usr/lib/macros.
...\" -------------------------------------------------------------------------
...\" Next, twiddle the "mm" package to suit our preferred style.
...\" -------------------------------------------------------------------------
...\" Point size and font types.
...\" -------------------------------------------------------------------------
.if n .fp 1 R \" "Regular" font ONLY -- don't use any others in nroff.
.if t \{ .S 10 12 \" Point size = 10, vertical spacing = 12.
...\" Note: Some systems give different names to these fonts.
.fp 1 R \" Times roman.
.fp 2 I \" Times italic.
.fp 3 B \" Times bold.
.fp 4 BI \" Times bold italic.
.fp 5 CW \" Courier.
.fp 6 CI \" Courier oblique.
.fp 7 CB \" Courier bold.
.fp 8 CX \" Courier bold oblique.
.fp 9 H \" Helvetica.
.fp 10 HI \" Helvetica oblique.
.fp 11 HB \" Helvetica bold.
.fp 12 HX \" Helvetica bold oblique.
.fp 13 S \} \" Special symbol font -- normally only called automatically.
...\" -------------------------------------------------------------------------
...\" Headings; page header and footers; titles.
...\" -------------------------------------------------------------------------
.nr Ej 0 \" No eject for first-level headings.
.nr Hs 7 \" Heading space level = blank line after heading (all levels).
.nr Hb 7 \" Heading break level = break after heading (all levels).
.nr Hi 1 \" Post-heading indent = paragraph indent.
.nr Hc 0 \" Heading centering = none.
.if n .ds HF 1 1 1 1 1 1 1 \" Heading fonts = regular (no underlining).
.if t .ds HF 11 11 11 11 11 11 11 \" Heading fonts = Helvetica bold.
.if t .ds HP 0 0 0 0 0 0 0 \" Heading point sizes (= default).
.HM 1 1 1 1 1 1 1 \" Heading mark = arabic (all levels).
.nr Hu 1 \" Unnumbered heading level = 1 (see aH macro, below).
.de HX \" Beginning-of-heading processing.
.in 0 \" Left justify headings.
.ie     \\$2=0 .ds }0\" Null string heading mark for HU.
.el .ie \\$1=1 .ds }0 \\n(H1.\ \&\" Heading marks = dotted sections + 1 space.
.el .ie \\$1=2 .ds }0 \\n(H1.\\n(H2.\ \&
.el .ie \\$1=3 .ds }0 \\n(H1.\\n(H2.\\n(H3.\ \&
.el .ie \\$1=4 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\ \&
.el .ie \\$1=5 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\ \&
.el .ie \\$1=6 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\\n(H6.\ \&
.el .if \\$1=7 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\\n(H6.\\n(H7.\ \&
..
.de HZ \" End-of-heading processing.
.if n .in 3 \" Indent body of doc by 3 columns in nroff.
.if t .in 0 \" Don't indent in troff.
..
.if n .ds hB \&\" Page header/footer font begin in nroff.
.if t .ds hB \f9\" Page header/footer font begin in troff.
.if n .ds hE \&\" Page header/footer font end in nroff.
.if t .ds hE \fP\" Page header/footer font end in troff.
.if n .ds kB \&\" Doc header font begin in nroff.
.if t .ds kB \f(11\" Doc header font begin in troff.
.if n .ds kE \&\" Doc header font end in nroff.
.if t .ds kE \f1\" Doc header font end in troff.
.de tS \" Title start.
.SP 2 \" 2 blank lines.
.ce 99 \" Center (each line of) title.
.if t \{ .ft 11 \" Bold helvetica.
.S +2 D \} \" Bigger point size.
..
.de tF \" Title finish.
.ce \" Turn off centering.
.SP 1 \" 1 blank line.
.if t \{ .ft 1 \" Return to regular font.
.S P P \} \" Return to regular point size.
..
...\" -------------------------------------------------------------------------
...\" Special Appendix heading macro, .aH.
...\" -------------------------------------------------------------------------
.nr a 0 1 \" Appendix number.
.af a A \" Assign format upper-case alpabetic to number register a.
.de aH \" Appendix heading macro.
.if \\na=0 \{ .nr H1 0 \" Reset H1 to 0.
.HM A 1 1 1 1 1 1 \} \" Heading mark = Upper case alphabetic + arabics.
.HU "APPENDIX \\n+a. \\$1"
..
...\" -------------------------------------------------------------------------
...\" Paragraph stuff.
...\" -------------------------------------------------------------------------
.nr Pt 0 \" Paragraph type = left-justified.
.nr Pi 0 \" Paragraph indent = 0.
.nr Ps 1 \" Paragraph spacing = 1 blank space.
...\" -------------------------------------------------------------------------
...\" Special list macro, .aL (replaces .AL, for all levels).
...\" This should be used for almost all lists (including ".LI "\ "").
...\" The only exception is variable lists (.VL, indented by multiples of 6).
...\" -------------------------------------------------------------------------
.de aL
.nr g \\n(:g
...\" In-line lists should be numbered (by hand): (1), (2), (3), ...
.ie     \\ng=0 .LB 6 0 1 3 a \" 1st level: (a), (b), (c), ...
.el .ie \\ng=1 .LB 6 0 1 3 i \" 2nd level: (i), (ii), (iii), ...
.el .ie \\ng=2 .LB 6 0 1 4 a \" 3rd level: [a], [b], [c], ...
.el .ie \\ng=3 .LB 6 0 1 4 i \" 4th level: [i], [ii], [iii], ...
.el .ie \\ng=4 .LB 6 0 1 6 a \" 5th level: {a}, {b}, {c}, ...
.el .if \\ng=5 .LB 6 0 1 6 i \" 6th level: {i}, {ii}, {iii}, ...
..
.nr Ls 6 \" Blank lines between all list items, by default (but adjustable).
...\" -------------------------------------------------------------------------
...\" Footnote stuff; special footnote string, \*(f!.
...\" -------------------------------------------------------------------------
.if n .ds f! [\\n+(:p]\" Footnote string (replaces \*F in nroff).
.if t .ds f! \\*F\" Footnote string (same as \*F in troff).
.if n .FD 6 \" Footnotes not hyphenated or indented, label left justified.
.if t .FD 5 \" Footnotes hyphenated, not indented, label left justified.
.nr Fs 1 \" 1 blank line between footnotes.
...\" -------------------------------------------------------------------------
...\" Line adjustment stuff.
...\" -------------------------------------------------------------------------
.if n .nr Hy 0 \" No hyphenation in nroff.
.if t .nr Hy 1 \" Hyphenate in troff.
.if n .SA 0 \" Set adjust: left margin only in nroff.
.if t .SA 1 \" Set adjust: left and right margins in troff.
...\" -------------------------------------------------------------------------
...\" Miscellaneous stuff.
...\" -------------------------------------------------------------------------
.ta \" No tabs by default -- set them up by hand as needed.
.nr Si \n(Ls \" Default indent for .DS display macro = 6 (use in troff only).
...\" -------------------------------------------------------------------------
...\" Displays.
...\" -------------------------------------------------------------------------
.de cS \" Display start: no-fill, literal font, no indentation.
.P
.nf \" No fill mode.
.if t .ft 5 \" Constant width font in troff.
..
...\" Within .cS, ".ne N"'s can be added by hand, but should be minimized.
.de cF \" Display finish.
.if t .ft 1 \" Back to standard font in troff.
.fi \" Fill mode.
.P
..
.de dS \" Display start: no-fill, literal font, with indentation.
.P
.aL \" Use .aL macro for consistent indentation.
.nf \" No fill mode.
.LI "\ " \" List item will no (visible) marker.
.if t .ft 5 \" Constant width font in troff.
..
...\" Within .dS, ".ne N"'s can be added by hand, but should be minimized.
.de dF \" Display finish.
.if t .ft 1 \" Back to standard font in troff.
.fi \" Fill mode.
.LE
.P
..
.de iS \" Indent start: fill, regular font, with indentation.
.P
.aL
.LI "\ "
..
.de iF \" Indent finish.
.LE
.P
..
.ds nH NOTE\"Default note header string -- can be changed by author.
.de nS \" Note start: fill, italics font, with indentation.
.P
.aL \" Use .aL macro for consistent indentation.
.LI "\ " \" List item will no (visible) marker.
.if t .ft 2 \" Italics font in troff, and reverse roman <--> italic fonts:
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f1\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.ie \\n(.$=0 \\*(nH:\" Default header string if none supplied by author.
.el \\$1:\" Header string supplied by author as argument to .nS macro.
..
.de nF \" Note finish.
.if t .ft 1 \" Back to standard font in troff, and remap font macros:
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f2\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.LE
.P
..
...\" -------------------------------------------------------------------------
...\" Quotation marks and font toggles.
...\" -------------------------------------------------------------------------
.if n .ds qB \&"\" Quotation begin in nroff.
.if t .ds qB ``\" Quotation begin in troff.
.if n .ds qE \&"\" Quotation end in nroff.
.if t .ds qE ''\" Quotation end in troff.
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f2\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.if n .ds bB *\" Bold font begin in nroff.
.if t .ds bB \f3\" Bold font begin in troff.
.if n .ds bE *\" Bold font end in nroff.
.if t .ds bE \fP\" Bold font end in troff.
.if n .ds lB `\" Literal font begin in nroff.
.if t .ds lB \f5\" Literal font begin in troff.
.if n .ds lE '\" Literal font end in nroff.
.if t .ds lE \fP\" Literal font end in troff.
.if n .ds jB <\" Italics/emphasis literal font begin in nroff.
.if t .ds jB \fP\f6\" Italics/emphasis literal font begin in troff.
.if n .ds jE >\" Italics/emphasis literal font end in nroff.
.if t .ds jE \fP\f5\" Italics/emphasis literal font end in troff.
...\" -------------------------------------------------------------------------
...\" No diffmarks by default, i.e., define .mc to be null.
...\" (Comment out this null definition to turn diffmarking on.)
...\" -------------------------------------------------------------------------
.de mc
..
...\" =========================================================================
...\" Finally, it's time to start writing the document!
...\" The OSF-RFC author modifies the following header/footer info.
...\" (The major/minor number is assigned by the OSF-RFC Editor.)
...\" =========================================================================
.ND "December 1995" \" Date must be hard-coded.
.PH "$\*(hBOSF-RFC 89.0$Bulk Status for DFS$\\\\*(DT\*(hE$"
.PF "$\*(hBGait$DRAFT #1$Page \\\\n%\*(hE$" \" Draft version.
.PF "$\*(hBGait$$Page \\\\n%\*(hE$" \" Final version.
...\"
...\" Following are the first printed lines (header info) of the document:
...\"
\&\" Force top-of-first-page trap to position the following info correctly.
.tl $\*(kBOpen Software Foundation$$J. Gait (Transarc)\*(kE$
.tl $\*(kBRequest For Comments: 89.0$$\*(kE$
.tl $\*(kB\*(DT$$\*(kE$
.tS \" Title, in all capitals (can span multiple lines):
A BULK STATUS RPC FOR DFS
.tF
...\" =========================================================================
...\" Now, the actual body of the document!!
...\" Heading capitalization style:
...\"     1st level: CAPITALIZE ALL WORDS
...\"     2nd level: Capitalize Initial Letters of All (Significant) Words
...\"     3rd-7th level: Capitalize first letter of first word only
...\" =========================================================================
.P
.H 1 "INTRODUCTION" \" Always start with an introduction section.
.P
This RFC describes a new DFS RPC to return the status of files
in a directory in bulk form, rather than one file at a time.
The bulk status RPC is designed to largely replace the lookup
RPC by doing the work of many lookup RPCs in one RPC.  The
motivation is to improve the throughput, measured in files per
second, of directory browsing by reducing the number of RPCs
required to browse directories.  Directory browsing in DFS
currently requires at least an RPC (to lookup the status) for
each file in the directory.  For \*(qBsmall\*(qE directories (where the
definition of \*(qBsmall\*(qE should incorporate most ordinary working
user directories), the bulk status RPC browses the entire
directory in one RPC.  The bulk status RPC does not reduce the
amount of work done to browse the directory; both server and
client do precisely the same amount of work and the same data
travels over the wire.  However the efficiency introduced in the
bulk status RPC by reducing the RPC count may potentially
improve the throughput of directory browsing by a significant
amount (say, up to 50%).
.P
.H 2 "Bulk Status and DFS Semantics"
.P
DFS semantics allow an RPC to get in the way of other DFS
operations by causing cascaded RPC activity and by revoking
tokens needed to make progress.  Thus, a DFS RPC is competing
for system and token resources to complete a task that is
necessary for the operation of DFS.
.P
The bulk status RPC does not fit this picture.  First, the bulk
status RPC is intended to reduce the RPC count, so it should not
induce cascaded RPC activity.  Second, the bulk status RPC is
not required by DFS semantics, so it should not interfere with
the progress of any RPC that is required by DFS semantics, e.g.,
by revoking tokens or by consuming tokens in an uncontrolled
way.
.P
The bulk status RPC is comparatively heavy-duty in that it runs
far longer than any other RPC.  It seems right to introduce
mechanisms to prevent the bulk status RPC from exceeding the
already unbalanced execution time.  Thus the bulk status RPC
should not retry, either on the client or on the server.  It
follows that the server should not seek to re-obtain a lost
directory token.  Instead, the bulk status RPC is designed to
fallback gracefully to the conventional lookup RPC when
necessary.
.P
In line with the above discussion, clients that support the bulk
status RPC should not start superfluous bulk status RPCs to
servers that do not support the RPC.  At steady state clients
should only request bulk status service from servers that
provide it, otherwise lookup service is employed on a per-file
basis.
.P
.H 2 "The Mechanics of Retrieving Status in Bulk"
.P
In general it is not feasible (because space to store the
information is limited) to retrieve the status information for
all the files in a directory in one RPC (or even for all the
files in a single chunk of the directory), so a fixed window of
files (defaulting to \*(lBAFS_BULKMAX\*(lE) is bulk stat-ed on each RPC.
The value of \*(lBAFS_BULKMAX\*(lE should be large enough to incorporate
all the files in most user directories, but small enough to
limit the amount of system and token resources engrossed by the
call.  The window is moved through the directory so all files
are eventually stat-ed.  The bulk status RPC is expressly
designed to support directory browsing.  Directories are
normally browsed from beginning to end, so the file currently
being looked-up is understood to be in the window currently
being stat-ed, as long as the bulk status RPC is in the path of
a directory browser or the directory is small enough.  So, to
belabor what is by now self-evident, and for verisimilitude
supposing \*(lBAFS_BULKMAX\*(lE = 32, a lookup of the first file in the
directory actually collects the status of the first 32 files in
the directory, with lookups hitting the caches thereafter, until
the 33rd file, which results in collecting the next 32 files,
and so on.
.P
The catch is that not all directory access is by directory
browser.  Any other than a beginning to end parse of the
directory defeats the bulk status optimization, unless the
directory is small enough to be retrieved entirely in one bulk
status RPC.  Some examples of directory browsing are \*(lBls -l
directory\*(lE, \*(lBfind\*(lE and \*(lBdu\*(lE; the bulk status
RPC improves the throughput of these activities.  But \*(lBls -l
file\*(lE may cause a bulk status RPC for a window of files that
does not include the specified file.  Accordingly, there should
be a provision to turn off bulk status support on both the
client and the server, so system administrators have control
over usage patterns that break bulk status.  The decision
depends on the mix af applications on the client and in the
enterprise, and on the style of interactive use prevailing at
the site.
.P
.H 1 "GENERALIZED STATUS INFORMATION"
.P
In DFS the lookup (status) RPC returns the following information
for a single file:
.P
.aL
.LI
The file identifier, or fid.
.LI
The status of the file.
.LI
A token that at least allows read status for the file, and may
allow much more.
.LE
.P
The lookup RPC passes the name of the file to the server, and
processes a returned error code.  When the lookup RPC succeeds,
the client cache manager uses the name of the file as a key to
install the fid in the client name cache, and uses the fid as a
key to install the status and token in the client status
cache.  Subsequent invocations of lookup find the required
information locally until either the token is lost or the caches
are purged of the entry.
.P
A client that invokes the bulk status RPC does not know in
advance the names of the files whose status will be returned and
must be prepared to process per-file errors even though the RPC
may have succeeded.  Accordingly, the bulk status RPC returns
the following information for a window of files in a directory:
.P
.aL
.LI
The name of each file.
.LI
The corresponding fid.
.LI
The corresponding status.
.LI
A token for the file that at least allows read status.
.LI
An error code that is set by the file server on a per-file basis.
.LE
.P
This is the \*(bBgeneralized status\*(bE information for the
file.
.P
If the server returns an error for any file processed in the
bulk status RPC, the the client cache manager omits the file
when generating information for the name and status caches.
.P
In case the bulk status RPC itself returns an error, the
returned window of generalized status is not processed into the
name and status caches and there is no retry: the client
falls-back on the lookup RPC.
.P
.H 2 "Structure for Generalized Status"
.P
An instance of the following structure is returned by the server
to the client for each file being stat-ed:
.P
.dS
.ne 7
typedef struct bundledStat
{
    afsFid fid;
    afsFetchStatus stat;
    afsToken token;
    error_status_t error;
} bundledStat;
.dF
.P
In case an error occurs on the server while obtaining any of the
fid, status or token for the file, the error is set to an
appropriate value that indicates the character of the error.
(The file name is returned separately.)
.P
.H 2 "Conformant Array for Generalized Status"
.P
The ensemble of generalized status is returned by the server to
the client in a conformant array.  (See the OSF DCE Application
Development Guide, Rev 1.0, 17.14.5 for a discussion of
conformant arrays.  Put simply, a conformant array is sized at
run time, rather than at compile time.)
.P
.dS
.ne 6
typedef struct bulkStat
{
    unsigned32 bulkStat_len;
    [length_is(bulkStat_len)] bundledStat
                              bulkStat_val[AFS_BULKMAX];
} bulkStat;
.dF
.P
The conformant array only returns generalized status for
precisely the files that have been stat-ed on the server.  The
value of \*(lBAFS_BULKMAX\*(lE is the default maximum size of a
directory window.
.P
.H 1 "FORMAL DEFINITION OF BULK STATUS RPC"
.P
Here is a formal IDL definition of the bulk status RPC:
.P
.dS
.ne 14
error_status_t AFS_BulkStatus (
    [in]        handle_t        h,
    [in]        afsFid          *dirFidp,
    [in]        afsHyper        *offsetp,
    [in]        unsigned32      size,
    [in]        afsHyper        *minVVp,
    [in]        unsigned32      flags,
    [out]       bulkStat        *bulkStats,
    [out]       afsHyper        *nextOffsetp,
    [out]       afsFetchStatus  *outDirStatusp,
    [out]       afsToken        *outTokenp,
    [out]       afsVolSync      *syncp,
    [out]       pipe_t          *dirStream
);
.dF
.P
The parent directory and current offset are specified in
\*(lBdirFidp\*(lE and \*(lBffsetp\*(lE, while the server returns
a new offset in \*(lBnextOffsetp\*(lE The server returns status
and a token for the directory in \*(lBoutDirStatusp\*(lE and
\*(lBoutTokenp\*(lE.  The client informs the server of its
buffer size in the \*(lBsize\*(lE parameter and passes various
flags in the \*(lBflags\*(lE parameter.  The \*(lBminVVp\*(lE
and \*(lBsyncp\*(lE parameters are technically related to the
storing fileset.  The generalized status is returned in two
parts.  The file names are returned in directory wire format via
the \*(lBdirStream\*(lE pipe and the remaining status is
returned in the \*(lBbulkStats\*(lE conformant array.
.P
.H 1 "THE CLIENT ARCHTECTURE"
.P
The bulk status RPC is insinuated into the lookup code path in
\*(lBnh_dolookup()\*(lE.  The parameters to the lookup call are
the directory and the name of a file in the directory. The fid
for the file is returned as an out-parameter.  Following is a
sharply truncated pseudocode version.  The
\*(lBif(bulkStatFlag){}\*(lE clause is the new code added in
\*(lBns_dolookup()\*(lE to support bulk status.
.P
.dS
ns_dolookup(dscp,namep,...)
{
    int bulkStatFlag=1;

redo:
    /* acquire directory token */

    cm_GetTokens(dscp);

    /* access name cache */

    code = nh_lookup(dscp, namep, ...);

    if (!code)
        return 0;

    if (bulkStatFlag)
    {
        if (dscp->opens > 0)
        {
            /* bulk status RPC */

            cm_BulkFetchStatus(dscp);

            bulkStatFlag = 0;
            goto redo;
        }
    }

    /* lookup RPC */

    code = AFS_Lookup(dscp, namep, ...);
    return code;
}
.dF
.P
There are a number of points to make about this pseudocode
representation:
.P
.aL
.LI
The bulk status RPC is invoked in case the directory is open and
a file is being looked-up from the directory.
.LI
If the file being looked-up is found in the name cache, then no
RPC is necessary from this code path.
.LI
The bulk status RPC is invoked at most once for each call to
\*(lBns_dolookup()\*(lE.  This is enforced by the treatment of
\*(lBbulkStatFlag\*(lE.
.LI
The bulk status RPC is an order of magnitude more time-consuming
than the lookup RPC, so a directory token is re-acquired when
the RPC returns.
.LI
There has been time for some other thread to install the file in
the name cache, so even if the RPC fails, the name cache is
re-accessed.
.LE
.P
With the inclusion of the bulk status call, there are four
possible paths through \*(lBns_dolookup()\*(lE:
.P
.aL
.LI
The first path finds the file in the name cache and thus returns
without making any RPC.
.LI
The second path does a bulk status RPC and then finds the file
in the name cache.
.LI
The third path does a bulk status RPC, still fails to find the
file in the name cache, so also does a lookup RPC.  This may
occur if there is a token problem or if the file being looked-up
is not in the current window.
.LI
The fourth path enters the bulk status code path, aborts for
some reason (e.g., the server does not support bulk status) in
\*(lBcm_BulkFetchStatus()\*(lE before attempting the bulk status
RPC, then falls through to conventional lookup code paths.
.LE
.P
Thus this codepath may result in 0, 1 or 2 RPCs depending on
circumstances.
.P
.H 2 "Directory Windows"
.P
A \*(bBdirectory window\*(bE is a sequence of
\*(lBAFS_BULKMAX\*(lE or fewer files in directory lookup order.
The beginning of the window is determined by \*(lBoffsetp\*(lE
and the beginning of the next window is signaled by the server
to the client in \*(lBnextOffsetp\*(lE.  The maximum size of the
window is set by the server.  The default maximum value is
\*(lBAFS_BULKMAX\*(lE files (set in the IDL file that defines
the RPC), however the system administrator may reset this value
to a smaller number at runtime.
.P
.H 2 "Token Handling"
.P
It may be that a particular client invoking the bulk status RPC
does not desire the corresponding tokens to be returned as part
of the generalized status.  In this case the client may set a
bit in the \*(lBflags\*(lE parameter that instructs the server
to skip the token code altogether.
.P
DFS RPCs normally verify that the client still has the necessary
token when the actual RPC has completed, since it is always
possible that a token has been lost while the RPC was
in-progress.  The probability of losing the directory token
during the bulk status RPC is much higher than it is for other
RPCs because it runs over ten times longer.  Thus the
client-side bulk status RPC makes the check for lost token and
aborts if necessary, thereby falling through to conventional
lookup behavior.
.P
.H 2 "Disabling the RPC"
.P
For benchmarking purposes it is convenient to be able to disable
the bulk status RPC at runtime on a per-client basis.  Further,
the usage pattern of a particular client may not be favorable
for bulk status.  By default bulk status is enabled at each
client, however the system administrator may disable bulk status
on a particular client at runtime.
.P
.H 2 "Server Does Not Support Bulk Status"
.P
The success of DFS is largely predicated on pervasive
interoperability across platforms and across versions of DFS.
The bulk status RPC behaves gracefully across provider versions:
.P
.aL
.LI
When the server provides bulk status and the client does not,
then bulk status is never invoked by the client.
.LI
When the client provides bulk status and the server does not,
then the server returns an out-of-range error when it fields a
bulk status RPC.  On its first bulk status interaction with a
server that does not provide bulk status, the client gets this
error and marks the server accordingly.  The bulk status RPC is
bypassed for this server thereafter.
.LE
.P
It follows that, at steady state in the cell, clients only issue
bulk status RPCs to servers that support bulk status.  Otherwise
the client falls through to lookup RPCs, short-circuiting the
bulk status RPC.
.P
.H 2 "Retry Policy"
.P
DFS RPCs that implement DFS semantics make exceptional efforts
to complete successfully.  Part of these efforts involve
systematic retries on both the client and server sides of the
RPC.  The situation with bulk status is very different.  As it
does not contribute directly to DFS semantics, there is no
imperative for the RPC to succeed.  Because the bulk status RPC
is an order of magnitude more heavy duty than other RPCs, the
cost of retry efforts would be extraordinarily high.  Unlike
other DFS RPCs, there is a graceful fallback in case the bulk
status RPC fails.  Thus, the bulk status RPC is coded not to
fall into the built-in retry paths of client-side error
handling.  There is no retry on either the client or the server.
.P
.H 2 "Directory Handling"
.P
DFS RPCs that operate in a directory context normally verify
that some other client machine, or even some other thread on the
same client machine, has not changed the directory while the RPC
was in-progress.  The probability of this occurring during the
bulk status RPC is much higher than it is for other RPCs because
it runs over ten times longer.  Thus the bulk status RPC makes
explicit checks for other clients or other threads that might
have changed the directory during the RPC and aborts if
necessary, thereby falling through to conventional lookup
behavior.
.P
The first window of files for a directory is returned by the
bulk status RPC with generalized status for the directory and
its parent as the first two entries.  The client discards this
information as it is already in the name and status caches.
This optimization handles the general case of smallish
directories more efficiently.
.P
.H 1 "THE SERVER ARCHITECTURE"
.P
A DFS server will in general be responding to many concurrent
bulk status RPCs, so there is a concern to bound the resources
required to support bulk status on the server.  Accordingly, the
bulk status RPC limits the amount of space it requires to
marshal return parameters and selectively limits the number of
tokens that it consumes.
.P
.H 2 "Server Space Limit"
.P
There are several reasons why it is desirable to limit the space
requirement on the server for a bulk status RPC instance:
.P
.aL
.LI
The bulk status RPC is long-running and this may influence the
number of outstanding RPCs in progress at one time, hence
influence the cumulative space requirement.
.LI
The bulk status RPC is in the path of one of the most commonly
invoked user commands, influencing the number of outstanding
RPCs and the space requirement.
.LI
Marshalling the returned status array will anyway require
upwards of 10 kbytes, already an order of magnitude more than
any other RPC.
.LE
.P
Accordingly, the bulk status RPC acts to sharply upper bound the
space required to marshal the conformant array of returned
status.  The mechanism is to limit the number of files handled
per-call to \*(lBAFS_BULKMAX\*(lE.  The size of the returned
generalized status for a file is 236 bytes, so if
\*(lBAFS_BULKMAX\*(lE = 32 (for example), then the total
required per-RPC for status would be 7552 bytes.
.P
.H 2 "Token Handling"
.P
A DFS file server is confined to issuing a certain maximum total
number of tokens for files.  Therefore, it is desirable to
selectively limit the number of tokens returned by the bulk
status RPC to the client.  The default maximum is
\*(lBafsBulkStatMaxTok\*(lE, however the system administrator
may reset this value to a smaller (or larger) number at runtime.
As soon as this maximum is exceeded during a bulk status call,
the server stops getting (and returning) tokens for the rest of
the files in the window but does return the remaining
generalized status with no error and with the token cleared.
.P
The bulk status RPC is somewhat speculative in that it is
preloading generalized file status on the client with a prospect
but not a promise of gain.  In any case the bulk status RPC does
not contribute directly to DFS semantics, so it need not succeed
in returning current generalized status for every file in the
window.  Furthermore it would be counterproductive for the bulk
status RPC to get in the way of DFS semantics executing on other
clients.  Lastly, revoking a token in general involves an
additional RPC; it seems counterproductive for a long running
RPC to raise a cascaded RPC in its code path.  Hence the server
that handles a bulk status call does not revoke any existing
token while handling the call.  It follows that, although it
seeks to return the most optimistic token for each file in the
directory, the bulk status RPC may return less powerful tokens
for some files in the window, and may not always succeed in
getting even a \*(lBREAD_STATUS\*(lE token for the file.
.P
While processing filenames from the directory window, the server
tries to get a token for each file.  It may be the case that the
server will have to drop the directory token somewhere in the
(really quite convoluted) code that is executed while trying to
get a token for a file in the directory.  While dropped, the
token may be grabbed by some other RPC.  The indication to the
caller of the token code is only that the token was dropped; it
is an inference that it may have been lost.  When this happens
to a conventional DFS RPC, it retries in a safe manner until it
gets the desired file token while retaining the directory token.
This may take awhile, so it would seem that retrying here is not
desirable for the bulk status RPC.  Accordingly, the server
bails out of the bulk status RPC whenever it has to drop the
directory token.  At this point it is not feasible to trust the
generalized status for any file in the window.  The code marks
the status of each file invalid, clears the token field and
returns an error for each file in the window.  The error value
returned by the token code is also returned by the RPC, and the
client is coded to not retry in this case.
.P
.H 2 "Disabling the RPC"
.P
The bulk status RPC is much more heavy duty than any other RPC
and it does not contribute directly to DFS semantics, so it is
conceivable that a system administrator would prefer to disable
bulk status service on a server.  By default service is enabled,
however the system administrator may disable service at runtime.
.P
.H 2 "When Generalized Status is not Returned"
.P
When the server does not return generalized status for a
particular file, different conventions are used to so indicate:
.P
.aL
.LI
An absent token is indicated by clearing the token via a call to
\*(lBpx_ClearTokenStruct()\*(lE.
.LI
An absent status is indicated by setting it to
\*(lBInvalid\*(lE.
.LI
An absent fid is indicated by zero in the fid field.
.LE
.P
While processing filenames from the directory window, the server
tries to find a fid for each file.  In the event this fails for
a particular file, the server sets the error code in the
corresponding entry of the conformant array of generalized
status and continues to the next file in the window.
.P
While processing filenames from the directory window, the server
tries to obtain the current status of the file.  In case this
fails the server marks the status as bad, sets the error code
for the file in the array of generalized status fields and
continues to the next file in the window.
.P
.H 2 "Returning Directory Info"
.P
Almost all DFS RPCs that pass a directory as an in-parameter,
pass back the current status of the directory and a token for
the directory as out-parameters.  The bulk status RPC does this
too, however in case the directory token was dropped as
described in a previous section, then it is not safe to do this.
Thus when the RPC returns an error, then the returned directory
status and token is not merged with the current status (in fact
they are marked invalid and cleared, respectively).
.P
.H 1 "STATISTICS COLLECTION"
.P
The bulk status RPC makes provision to collect bulk status
related statistics, en suite with existing statistics
collection, on the client machines.  (The extent of statistics
collection on the server side is to just count the number of
times each RPC is called and the total number of RPCs.  So on the
server only these numbers are available.)  The statistics
collected reflect the efficiency with which the bulk status RPC
uses the name and status caches.  For each of these caches the
following counters are kept:
.P
.aL
.LI
The number (since reset) of times that a bulk status installed
entry was retrieved from the cache.
.LI
The number (since reset) of times that a bulk status installed
entry was recycled without having been accessed at all.
.LI
The number (since reset) of entries to the cache that were
installed by the bulk status RPC.
.LE
.P
The necessary counters for the name cache are collected in the
(pre-existing) \*(lBnh_stats\*(lE structure in the midst of
other counters.
.P
.dS
.ne 8
struct nh_stats
{
    /* ... */
    int bulkStatSeen;
    int bulkStatNotseen;
    int bulkStatEntered;
    /* ... */
} nh_stats;
.dF
.P
The \*(lBbulkStatSeen\*(lE counter is incremented in
\*(lBnh_lookup()\*(lE, the \*(lBbulkStatNotseen\*(lE counter is
incremented when the entry is recycled in \*(lBnh_enter()\*(lE
and when it is purged in \*(lBpurge()\*(lE, and the
\*(lBbulkStatEntered\*(lE counter is incremented in
\*(lBnh_enter()\*(lE.
.P
The necessary counters for the status cache are collected in the
(pre-existing) \*(lBcm_stats\*(lE structure in the midst of
other counters.
.P
.dS
.ne 16
struct cm_stats
{
    /* ... * /
    unsigned long statusCacheBulkstatSeen;
    unsigned long statusCacheBulkstatNotseen;
    unsigned long statusCacheBulkstatEntered;
    /* ... */
} cm_stats;
.dF
.P
The \*(lBstatusCacheBulkstatSeen\*(lE counter is incremented in
\*(lBcm_FindSCache()\*(lE, the
\*(lBstatusCacheBulkstatNotseen\*(lE counter is incremented in
\*(lBFlushSCache()\*(lE, and the
\*(lBstatusCacheBulkstatEntered\*(lE counter is incremented in
\*(lBcm_BulkFetchStatus()\*(lE.
.P
.H 1 "BENCHMARKING"
.P
The purpose of the bulk status RPC is to improve performance in
files per second of commands that consume the status of all the
files in a directory.  Three benchmarks are available to help
evaluate the effectiveness of the effort:
.P
.aL
.LI
\*(lBBIGDIR\*(lE \*(EM \*(lBls -l directory\*(lE is performed in
a flat directory; I construct directories whose size ranges
between 1000 and 10000 files, incrementing in units of 1000
files.
.LI
\*(lBDEEPDIR\*(lE \*(EM \*(lBls -lR directory\*(lE is performed
in a balanced directory tree; I construct a number of directory
trees that contain between 1000 and 10000 files, approximately,
incrementing in units of 1000 files.
.LI
\*(lBSEARCHDIR\*(lE \*(EM \*(lBfind \&. -name joe\*(lE is
performed in the DEEPDIR directory trees, where the file does
not exist.
.LE
.P
Anecdotally, these benchmarks show an average 50% performance
improvement for the bulk status RPC, as implemented according to
the above description, over conventional lookup, with the
differential at its best for smaller directories and closing for
larger directories, as of this writing.
.P
.H 1 "SYSADMIN RUNTIME CONTROLS"
.P
The bulk status RPC gives the system administrator active
control (currently via kernel mode \*(lBadb\*(lE) at runtime
over many bulk status related parameters.  The parameters
described all default to something reasonable, so there is
normally no need to change them:
.P
.aL
.LI
On the server:
.aL
.LI
To monitor the number of bulk status RPCs examine the structure
\*(lBafsStats\*(lE.
.LI
To control the maximum size of a directory window revalue
\*(lBafsMaxFilesBulkStat\*(lE to some number between 2 and
\*(lBAFS_BULKMAX\*(lE.  Do not set this value to be less than 2
or larger than \*(lBAFS_BULKMAX\*(lE.  The current value of
\*(lBAFS_BULKMAX\*(lE is 32.
.LI
To control the maximum number of tokens returned by the bulk
status RPC revalue \*(lBafsBulkStatMaxTok\*(lE to some
non-negative number.  The current default is 100.
.LI
To disable the bulk status RPC on the server clear
\*(lBafsBulkStatServerEnable\*(lE.
.LE
.LI
On the client:
.aL
.LI
To disable the bulk status RPC from this client clear
\*(lBcm_EnableBulkStat\*(lE.
.LI
To monitor the interaction of the bulk status RPC with the name
cache examine the structure \*(lBnh_stats\*(lE.
.LI
To monitor the interaction of the bulk status RPC with the
status cache examine the structure \*(lBcm_stats\*(lE.
.LE
.LE
.P
.H 1 "LAST COMMENTS"
.P
There are a few technical considerations that are as yet
imperfectly realized in the bulk status RPC, as currently
implemented:
.P
.aL
.LI
It is desirable to support a client option to limit the size of
the directory window.  At present the maximum size of the
directory window is determined, within limits, by the server and
by the formal definition of the RPC.
.LI
It is desirable to support a client option to limit the number
of tokens returned.  At present there is a server option to
limit the number of tokens returned and the client may ask the
server to return no tokens at all for files.
.LI
It is desirable to support a server option to return no tokens
(supported by setting \*(lBafsBulkStatMaxTok\*(lE to 0) and
further support a server option to return status for files in
the directory window precisely when a token is available for the
file.  At present the server revokes no token to acquire a
token, however the token code is a complex coil and it is
possible for the desired token to be available but for no
generalized status to be returned at all.
.LE
.P
.H 1 "ACKNOWLEDGEMENTS"
.P
The following persons made contributions, in the form of good
advice, comments and insistent suggestions, to the bulk status
RPC:
.P
.aL
.LI
Craig Everhart (Transarc).
.LI
Bruce Leverett (Transarc).
.LI
Lyle Seaman (Transarc).
.LI
Carl Burnett (IBM).
.LI
James Mostek (Transarc).
.LE
.P
...\" =========================================================================
...\" Author's address goes here, as unnumbered heading, at end of doc.
...\" =========================================================================
.P
.ne 3+5
.HU "AUTHOR'S ADDRESS"
.P
.tl $Jason Gait$$Internet email: gait@transarc.com$
.tl $Transarc Corp.$$Telephone: +1-412-338-6933$
.tl $707 Grant Street$$$
.tl $Pittsburgh, PA 15219$$$
.tl $USA$$$
...\" =========================================================================
...\" Done!
...\" =========================================================================
