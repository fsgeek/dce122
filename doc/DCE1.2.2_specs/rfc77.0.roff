...\" OSF-RFC 77.0
...\"
...\" FORMATTING INSTRUCTIONS for this RFC:
...\"       nroff -Tlpr rfc77.0.roff > rfc77.0.txt
...\"       troff -Tps rfc77.0.roff | <ps-post-processor> > rfc77.0.ps
...\" (Where "troff" means "device-independent troff", or "ditroff".)
...\"
...\" =========================================================================
...\" This template first sets a bunch of *roff options (authors/readers
...\" don't usually have to know about these).
...\" Then it defines some strings and macros, many of which deal with
...\" things that differ between nroff & troff (some of these may not be
...\" perfect, but they're better than nothing -- to do a really good
...\" job would require a real semantic markup language.
...\" Convention: "Begin/End" for strings, "Start/Finish" for macros.
...\" Strings:
...\"       \*(f!        - Footnote string (replaces \*F).
...\"       \*(hB, \*(hE - Page header/footer font (internal use).
...\"       \*(kB, \*(kE - Doc header font (internal use).
...\"       \*(qB, \*(qE - Quotations.
...\"       \*(iB, \*(iE - Italics/emphasis in primary font.
...\"       \*(bB, \*(bE - Bold font.
...\"       \*(lB, \*(lE - Literal font.
...\"       \*(jB, \*(jE - Italics/emphasis in literal font.
...\"       \*(nH        - Default note header string.
...\" Macros:
...\"       .aH      - Appendix header macro (uses number register \na).
...\"       .aL      - Automatic list macro (replaces .AL; uses num reg \ng).
...\"       .tS, .tF - Title start/finish (internal use).
...\"       .cS, .cF - Displays (no-fill) without indentation.
...\"       .dS, .dF - Displays (no-fill) with indentation.
...\"       .iS, .iF - Indented (fill) text.
...\"       .nS, .nF - Note.
...\" -------------------------------------------------------------------------
...\" First, set up some number registers here (instead of on command line),
...\" and include the "mm" macro package here (instead of on command line).
...\" -------------------------------------------------------------------------
.if n .nr L 66 \" Nroff page length = 66 lines.
.if t .nr L 11i \" Troff page length = 11 inches.
.if n .nr W 72 \" Nroff page width = 72 columns.
.if t .nr W 6.5i \" Troff page width = 6.5 inches.
.if n .nr O 3 \" Nroff page offset = 3 columns.
.if t .nr O 0.75i \" Troff page offset = 0.75 inches.
.nr N 2 \" No header on page 1.
.so /usr/lib/tmac/tmac.m \" Points to "mm" package, in /usr/lib/macros.
...\" -------------------------------------------------------------------------
...\" Next, twiddle the "mm" package to suit our preferred style.
...\" -------------------------------------------------------------------------
...\" Point size and font types.
...\" -------------------------------------------------------------------------
.if n .fp 1 R \" "Regular" font ONLY -- don't use any others in nroff.
.if t \{ .S 10 12 \" Point size = 10, vertical spacing = 12.
...\" Note: Some systems give different names to these fonts.
.fp 1 R \" Times roman.
.fp 2 I \" Times italic.
.fp 3 B \" Times bold.
.fp 4 BI \" Times bold italic.
.fp 5 CW \" Courier.
.fp 6 CI \" Courier oblique.
.fp 7 CB \" Courier bold.
.fp 8 CX \" Courier bold oblique.
.fp 9 H \" Helvetica.
.fp 10 HI \" Helvetica oblique.
.fp 11 HB \" Helvetica bold.
.fp 12 HX \" Helvetica bold oblique.
.fp 13 S \} \" Special symbol font -- normally only called automatically.
...\" -------------------------------------------------------------------------
...\" Headings; page header and footers; titles.
...\" -------------------------------------------------------------------------
.nr Ej 0 \" No eject for first-level headings.
.nr Hs 7 \" Heading space level = blank line after heading (all levels).
.nr Hb 7 \" Heading break level = break after heading (all levels).
.nr Hi 1 \" Post-heading indent = paragraph indent.
.nr Hc 0 \" Heading centering = none.
.if n .ds HF 1 1 1 1 1 1 1 \" Heading fonts = regular (no underlining).
.if t .ds HF 11 11 11 11 11 11 11 \" Heading fonts = Helvetica bold.
.if t .ds HP 0 0 0 0 0 0 0 \" Heading point sizes (= default).
.HM 1 1 1 1 1 1 1 \" Heading mark = arabic (all levels).
.nr Hu 1 \" Unnumbered heading level = 1 (see aH macro, below).
.de HX \" Beginning-of-heading processing.
.in 0 \" Left justify headings.
.ie     \\$2=0 .ds }0\" Null string heading mark for HU.
.el .ie \\$1=1 .ds }0 \\n(H1.\ \&\" Heading marks = dotted sections + 1 space.
.el .ie \\$1=2 .ds }0 \\n(H1.\\n(H2.\ \&
.el .ie \\$1=3 .ds }0 \\n(H1.\\n(H2.\\n(H3.\ \&
.el .ie \\$1=4 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\ \&
.el .ie \\$1=5 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\ \&
.el .ie \\$1=6 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\\n(H6.\ \&
.el .if \\$1=7 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\\n(H6.\\n(H7.\ \&
..
.de HZ \" End-of-heading processing.
.if n .in 3 \" Indent body of doc by 3 columns in nroff.
.if t .in 0 \" Don't indent in troff.
..
.if n .ds hB \&\" Page header/footer font begin in nroff.
.if t .ds hB \f9\" Page header/footer font begin in troff.
.if n .ds hE \&\" Page header/footer font end in nroff.
.if t .ds hE \fP\" Page header/footer font end in troff.
.if n .ds kB \&\" Doc header font begin in nroff.
.if t .ds kB \f(11\" Doc header font begin in troff.
.if n .ds kE \&\" Doc header font end in nroff.
.if t .ds kE \f1\" Doc header font end in troff.
.de tS \" Title start.
.SP 2 \" 2 blank lines.
.ce 99 \" Center (each line of) title.
.if t \{ .ft 11 \" Bold helvetica.
.S +2 D \} \" Bigger point size.
..
.de tF \" Title finish.
.ce \" Turn off centering.
.SP 1 \" 1 blank line.
.if t \{ .ft 1 \" Return to regular font.
.S P P \} \" Return to regular point size.
..
...\" -------------------------------------------------------------------------
...\" Special Appendix heading macro, .aH.
...\" -------------------------------------------------------------------------
.nr a 0 1 \" Appendix number.
.af a A \" Assign format upper-case alpabetic to number register a.
.de aH \" Appendix heading macro.
.if \\na=0 \{ .nr H1 0 \" Reset H1 to 0.
.HM A 1 1 1 1 1 1 \} \" Heading mark = Upper case alphabetic + arabics.
.HU "APPENDIX \\n+a. \\$1"
..
...\" -------------------------------------------------------------------------
...\" Paragraph stuff.
...\" -------------------------------------------------------------------------
.nr Pt 0 \" Paragraph type = left-justified.
.nr Pi 0 \" Paragraph indent = 0.
.nr Ps 1 \" Paragraph spacing = 1 blank space.
...\" -------------------------------------------------------------------------
...\" Special list macro, .aL (replaces .AL, for all levels).
...\" This should be used for almost all lists (including ".LI "\ "").
...\" The only exception is variable lists (.VL, indented by multiples of 6).
...\" -------------------------------------------------------------------------
.de aL
.nr g \\n(:g
...\" In-line lists should be numbered (by hand): (1), (2), (3), ...
.ie     \\ng=0 .LB 6 0 1 3 a \" 1st level: (a), (b), (c), ...
.el .ie \\ng=1 .LB 6 0 1 3 i \" 2nd level: (i), (ii), (iii), ...
.el .ie \\ng=2 .LB 6 0 1 4 a \" 3rd level: [a], [b], [c], ...
.el .ie \\ng=3 .LB 6 0 1 4 i \" 4th level: [i], [ii], [iii], ...
.el .ie \\ng=4 .LB 6 0 1 6 a \" 5th level: {a}, {b}, {c}, ...
.el .if \\ng=5 .LB 6 0 1 6 i \" 6th level: {i}, {ii}, {iii}, ...
..
.nr Ls 6 \" Blank lines between all list items, by default (but adjustable).
...\" -------------------------------------------------------------------------
...\" Footnote stuff; special footnote string, \*(f!.
...\" -------------------------------------------------------------------------
.if n .ds f! [\\n+(:p]\" Footnote string (replaces \*F in nroff).
.if t .ds f! \\*F\" Footnote string (same as \*F in troff).
.if n .FD 6 \" Footnotes not hyphenated or indented, label left justified.
.if t .FD 5 \" Footnotes hyphenated, not indented, label left justified.
.nr Fs 1 \" 1 blank line between footnotes.
...\" -------------------------------------------------------------------------
...\" Line adjustment stuff.
...\" -------------------------------------------------------------------------
.if n .nr Hy 0 \" No hyphenation in nroff.
.if t .nr Hy 1 \" Hyphenate in troff.
.if n .SA 0 \" Set adjust: left margin only in nroff.
.if t .SA 1 \" Set adjust: left and right margins in troff.
...\" -------------------------------------------------------------------------
...\" Miscellaneous stuff.
...\" -------------------------------------------------------------------------
.ta \" No tabs by default -- set them up by hand as needed.
.nr Si \n(Ls \" Default indent for .DS display macro = 6 (use in troff only).
...\" -------------------------------------------------------------------------
...\" Displays.
...\" -------------------------------------------------------------------------
.de cS \" Display start: no-fill, literal font, no indentation.
.P
.nf \" No fill mode.
.if t .ft 5 \" Constant width font in troff.
..
...\" Within .cS, ".ne N"'s can be added by hand, but should be minimized.
.de cF \" Display finish.
.if t .ft 1 \" Back to standard font in troff.
.fi \" Fill mode.
.P
..
.de dS \" Display start: no-fill, literal font, with indentation.
.P
.aL \" Use .aL macro for consistent indentation.
.nf \" No fill mode.
.LI "\ " \" List item will no (visible) marker.
.if t .ft 5 \" Constant width font in troff.
..
...\" Within .dS, ".ne N"'s can be added by hand, but should be minimized.
.de dF \" Display finish.
.if t .ft 1 \" Back to standard font in troff.
.fi \" Fill mode.
.LE
.P
..
.de iS \" Indent start: fill, regular font, with indentation.
.P
.aL
.LI "\ "
..
.de iF \" Indent finish.
.LE
.P
..
.ds nH NOTE\"Default note header string -- can be changed by author.
.de nS \" Note start: fill, italics font, with indentation.
.P
.aL \" Use .aL macro for consistent indentation.
.LI "\ " \" List item will no (visible) marker.
.if t .ft 2 \" Italics font in troff, and reverse roman <--> italic fonts:
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f1\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.ie \\n(.$=0 \\*(nH:\" Default header string if none supplied by author.
.el \\$1:\" Header string supplied by author as argument to .nS macro.
..
.de nF \" Note finish.
.if t .ft 1 \" Back to standard font in troff, and remap font macros:
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f2\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.LE
.P
..
...\" -------------------------------------------------------------------------
...\" Quotation marks and font toggles.
...\" -------------------------------------------------------------------------
.if n .ds qB \&"\" Quotation begin in nroff.
.if t .ds qB ``\" Quotation begin in troff.
.if n .ds qE \&"\" Quotation end in nroff.
.if t .ds qE ''\" Quotation end in troff.
.if n .ds iB _\" Italics/emphasis primary font begin in nroff.
.if t .ds iB \f2\" Italics/emphasis primary font begin in troff.
.if n .ds iE _\" Italics/emphasis primary font end in nroff.
.if t .ds iE \fP\" Italics/emphasis primary font end in troff.
.if n .ds bB *\" Bold font begin in nroff.
.if t .ds bB \f3\" Bold font begin in troff.
.if n .ds bE *\" Bold font end in nroff.
.if t .ds bE \fP\" Bold font end in troff.
.if n .ds lB `\" Literal font begin in nroff.
.if t .ds lB \f5\" Literal font begin in troff.
.if n .ds lE '\" Literal font end in nroff.
.if t .ds lE \fP\" Literal font end in troff.
.if n .ds jB <\" Italics/emphasis literal font begin in nroff.
.if t .ds jB \fP\f6\" Italics/emphasis literal font begin in troff.
.if n .ds jE >\" Italics/emphasis literal font end in nroff.
.if t .ds jE \fP\f5\" Italics/emphasis literal font end in troff.
...\" -------------------------------------------------------------------------
...\" No diffmarks by default, i.e., define .mc to be null.
...\" (Comment out this null definition to turn diffmarking on.)
...\" -------------------------------------------------------------------------
.de mc
..
...\" =========================================================================
...\" Finally, it's time to start writing the document!
...\" The OSF-RFC author modifies the following header/footer info.
...\" (The major/minor number is assigned by the OSF-RFC Editor.)
...\" =========================================================================
.ND "January 1996" \" Date must be hard-coded.
.PH "$\*(hBOSF-RFC 77.0$Supporting Multi-homed DFS Servers$\\\\*(DT\*(hE$"
.PF "$\*(hBMoyer$DRAFT #0.2$Page \\\\n%\*(hE$" \" Draft.
.PF "$\*(hBMoyer$$Page \\\\n%\*(hE$" \" Final version.
...\"
...\" Following are the first printed lines (header info) of the document:
...\"
\&\" Force top-of-first-page trap to position the following info correctly.
.tl $\*(kBOpen Software Foundation$$S. Moyer (Transarc)\*(kE$
.tl $\*(kBRequest For Comments: 77.0$$\*(kE$
.tl $\*(kB\*(DT$$\*(kE$
.tS \" Title, in all capitals (can span multiple lines):
SUPPORTING MULTI-HOMED DFS SERVERS
.tF
...\" =========================================================================
...\" Now, the actual body of the document!!
...\" Heading capitalization style:
...\"     1st level: CAPITALIZE ALL WORDS
...\"     2nd level: Capitalize Initial Letters of All (Significant) Words
...\"     3rd-7th level: Capitalize first letter of first word only
...\" =========================================================================
.P
.H 1 "INTRODUCTION" \" Always start with an introduction section.
.P
This RFC describes a method for supporting
multi-homed servers\*(f!
.FS
A multi-homed server is a server that resides on a host that has
two or more network connections.
.FE
in the DFS cache manager (CM).  The goal of this work is to
enhance DFS's fault-tolerance by enabling CMs to communicate with
a server via any of a set of specified addresses.
.P
An appropriate implementation of multi-homed server support will
have (at least) the following properties:
.P
.aL
.LI
CMs handle failures in network connections transparently to the
extent possible.
.LI
CMs actively manage knowledge
of the state of a server's network connections.
.LI
CMs obey the server-preference scheme.
.LE
.P
The following sections discuss the current CM implementation with
respect to managing server communication, and propose enhancements
to support multi-homed servers.
.P
.H 1 "CURRENT CM COMMUNICATION ARCHITECTURE"
.P
The cache manager employs two primary object types for
supporting CM-server communication: the \*(bBserver object\*(bE,
implemented by the server module \*(lBcm/cm_server.{h,c}\*(lE,
and the \*(bBconnection object\*(bE, implemented by the
connection module \*(lBcm/cm_conn.{h,c}\*(lE.  The CM represents
the state of a server as a \*(lBcm_server\*(lE structure, with
various connections (bindings) to that server represented as a
list of \*(lBcm_conn\*(lE structures hanging off the server
structure.  A \*(lBcm_server\*(lE structure contains, among
other state information, a single address that is used to create
bindings for that server.
.P
When the CM needs to perform a remote procedure call (RPC), one of
three functions can be employed to establish a server binding:
\*(lBcm_Conn()\*(lE,
\*(lBcm_ConnByMHosts()\*(lE,
or \*(lBcm_ConnByHost()\*(lE.  The
only one we will consider here is
\*(lBcm_ConnByHost()\*(lE,
since it is this function that actually establishes a binding, and since
it is used to implement the other two.
.P
The standard method for making an RPC in the CM is illustrated by the
following fragment of pseudo code:
.P
.dS
do {
    if (connp = cm_ConnByHost(serverp, ...)) {
        /* got server binding */
        result = server_RPC(connp->connp, ...);
    }
} while (cm_Analyze(connp, result, ...));
.dF
.P
Essentially, a connection is requested and, if obtained, the RPC
is performed.  The results of the
\*(lBcm_ConnByHost()\*(lE and the RPC (if any) are then
passed to
\*(lBcm_Analyze()\*(lE.
If the RPC was not performed successfully, for whatever reason,
then
\*(lBcm_Analyze()\*(lE determines if it should be attempted again.  Note
that it
is this methodology, when employed in conjunction with
\*(lBcm_ConnByMHosts()\*(lE,
that allows the cache manager to
contact alternative servers to perform an operation; e.g., to contact
an alternative fileset location server when the preferred server can
not be reached.
.P
Though the current CM communication architecture cleanly handles
non-persistent errors, and the use of alternative servers when appropriate,
it does not support multi-homed servers.  Recall that only a single
address is stored in a \*(lBcm_server\*(lE structure.
The next section details enhancements that support multiple addresses
per server.
.P
.H 1 "ENHANCED CM COMMUNICATION ARCHITECTURE"
.P
To support multi-homed servers, it is proposed that the cache
manager employ a third object type for CM-server communication:
the \*(bBsite object\*(bE, implemented by the site module
\*(lBcm/cm_site.{h,c}\*(lE.  A site object represents the state
of a server's network connections on a multi-homed host (site).
.P
Before the details of the site object are presented, it is useful to
see how it will be employed in the generic RPC methodology
illustrated above.
.P
In the current CM architecture, certain failure conditions cause
either \*(lBcm_ConnByHost()\*(lE or \*(lBcm_Analyze()\*(lE to call
\*(lBcm_ServerDown()\*(lE
to indicate that a server object appears to be
down.  The result of \*(lBcm_ServerDown()\*(lE indicates either that
the server is truly down, in which case it is flagged as such, or that
the server can be retried.
.P
In the enhanced CM architecture, a communications failure will cause
\*(lBcm_ServerDown()\*(lE to call the new function
\*(lBcm_SiteAddrDown()\*(lE
to indicate that a particular server address
is down.  The function \*(lBcm_SiteAddrDown()\*(lE performs a fail-over
to the next best available address for that server, if one
exists.  Thus, in the case
of a communications failure, \*(lBcm_ServerDown()\*(lE can indicate that
the server can be re-tried given a successful fail-over.
.P
.H 2 "Site Object Definition"
.P
The site object type will be
implemented by the site module \*(lBcm/cm_site.{h,c}\*(lE, which will
export the following data structures and functions.
.P
.H 3 "Data structures"
.P
.dS
/* site address declaration */
struct cm_siteAddr {
  struct cm_siteAddr  *next_sa;       /* next site addr */
  struct cm_siteAddr  *next_sahash;   /* next addr in hash */
  struct cm_site      *sitep;         /* associated site */
  struct sockaddr_in  addr;           /* address */
  ushort              rank;           /* address rank */
  ushort              state;          /* address state */
};

/* site object declaration */
struct cm_site {
  struct cm_site      *next_sitehash;   /* next site in hash */
  osi_dlock_t         lock;             /* site-data lock */
  struct cm_cell      *cellp;           /* cell */
  struct cm_siteAddr  *addrListp;       /* address list */
  struct cm_siteAddr  *addrCurp;        /* best ranking up
                                           addr */
  ulong               addrUpdateTime;   /* time addr list
                                           updated */
  struct cm_server    *serverp;         /* associated server */
  ushort              state;            /* site state flags */
};

/* note: site identified via (cellp, serverp->principal) pair;
   should be replaced by a UUID in the future */
.dF
.P
The CM will represent a server's host as a
\*(lBcm_site\*(lE structure, with the state of the server's network
connections represented as a list of
\*(lBcm_siteAddr\*(lE structures hanging off the site
structure.  Exactly one site object will exist for each server object
in the system.
.P
Maintaining per-server address
lists, and hence per-server address ranks and states,
enables both the server-preference scheme (discussed later) and
the communications fail-over mechanism to be implemented in
a server-centric fashion.  This architecture also accommodates the current
model whereby server addresses are specified
individually\*(f!
.FS
File-server/repserver address lists are actually specified in pairs.
.FE
and are obtained
from different sources; specifically, the FLDB for file-servers/repservers
and the CDS for flservers.
.P
.nS "NOTE FOR FUTURE DEVELOPMENT"
Maintaining per-server site information also enables a CM to communicate
with multiple DFS servers
of the same type residing (at least logically) on a single
machine; e.g., to help support access to DFS servers on machines hidden
behind a firewall.
.nF
.P
All \*(lBcm_siteAddr\*(lE structures are maintained in a hash table
hashed by address so that associated site and server structures can be
quickly located.  The primary purpose of hashing by address is to
support the server-preference scheme.
.P
.H 3 "Functions"
.P
.dS
/* cm_SiteAlloc() -- allocate a new site object.
 *
 * Parameters:
 *     siteCellp - host's cell
 *     siteNamep - host's principal name
 *     serverp   - associated server object
 */
struct cm_site *cm_SiteAlloc(struct cm_cell *siteCellp,
                             char *siteNamep,
                             struct cm_server *serverp);

/* cm_SiteAddrUpdate() -- replace list of server addresses with
 *     the list provided.
 *
 *     As a side effect, sets site fields addrList and addrCur
 *     appropriately.
 *
 * Parameters:
 *     sitep    - site object
 *     addrvp   - server-address vector
 *     addrvcnt - server-address vector size
 *
 * Returns:
 *      0 - update successful
 *     -1 - invalid arg; addr list unchanged
 */
int cm_SiteAddrUpdate(struct cm_site *sitep,
                      struct sockaddr_in *addrvp,
                      int addrvcnt);

/* cm_SiteAddrUpdateAllFLDB() -- for all
 *     file-servers/repservers on the specified host, replace
 *     list of server addresses with the full list in the FLDB.
 *
 *     As a side-effect, sets site fields addrList and addrCur
 *     appropriately for all relevant servers.
 *
 * Parameters:
 *     siteCellp - host's cell
 *     siteNamep - host's principal name
 *     addrp     - a known address for host
 */
void cm_SiteAddrUpdateAllFLDB(struct cm_cell *siteCellp,
                              char *siteNamep,
                              struct sockaddr_in *addrp);

/* cm_SiteAddrSetRankAll() -- for all servers of the specified
 *     type, assign rank to the specified address.
 *
 *     Note that server types SRT_FX and SRT_REP are treated as
 *     equivalent; specifying either updates address rank for
 *     both.
 *
 *     As a side-effect, sets site fields addrList and addrCur
 *     appropriately for all relevant servers.
 *
 * Parameters:
 *     addrp - address
 *     rank  - rank
 *     svc   - server type (SRT_FX, SRT_REP, SRT_FL)
 *
 * Returns:
 *      0 - server address rank set
 *     -1 - failed; address not found
 */
int cm_SiteAddrSetRankAll(struct sockaddr_in *addrp,
                          int rank,
                          int svc);

/* cm_SiteAddrDown() -- report failed communication to server
 *     address; perform address fail-over.
 *
 *     A successful address fail-over updates the site field
 *     addrCur to point to the best up address for the server.
 *
 *     An unsuccessful fail-over occurs when all server
 *     addresses are marked down; in this case the site field
 *     addrCur is set to the (down) address addrList.
 *
 * Parameters:
 *     sitep  - site object
 *     addrp  - server address
 *
 * Returns:
 *      0 - successful address fail-over
 *     -1 - unsuccessful address fail-over; all server
 *          addresses down
 */
int cm_SiteAddrDown(struct cm_site *sitep,
                    struct sockaddr_in *addrp);

/* cm_SiteAddrUp() -- mark all server addresses as up.
 *
 *     As a side-effect, sets site field addrCur to addrList.
 *
 * Parameters:
 *     sitep - site object
 */
void cm_SiteAddrUp(struct cm_site *sitep);

/* cm_SiteAddrPingBad() -- ping server on all addresses marked
 *     down.
 *
 *     Attempts to ping server on all addresses marked down to
 *     determine if the connection has been restored.
 *     Successful pings result in the address being marked up.
 *
 *     As a side-effect, sets site field addrCur appropriately.
 *
 * Parameters:
 *     sitep - site object
 */
void cm_SiteAddrPingBad(struct cm_site *sitep);
.dF
.P
The above functions provide a simple interface for creating site objects
and manipulating their state.
.P
.H 2 "Site Object Integration"
.P
Site objects will be integrated into the existing CM code base in a
straight-forward fashion, with most modifications concentrated in
the server module.  Below is a discussion of the significant modifications
that will take place; many minor updates are required that will not be
presented in this document.
.P
.H 3 "Server module modifications"
.P
The \*(lBcm_server\*(lE structure in the file \*(lBcm/cm_server.h\*(lE will
be modified as follows:
.P
.aL
.LI
\*(lBstruct cm_server *nextUUID\*(lE \*(EM Remove.
.LI
\*(lBstruct cm_cell *cellp\*(lE \*(EM Remove.
.LI
\*(lBstruct sockaddr_in serverAddr\*(lE \*(EM Remove.
.LI
\*(lBu_short rank\*(lE \*(EM Remove.
.LI
\*(lBstruct cm_site *sitep\*(lE \*(EM Add.
.LI
\*(lBint failoverCount\*(lE \*(EM Add.
.LE
.P
Data fields removed from the server structure are subsumed by
equivalent fields in the site structure now referenced
by \*(lBsitep\*(lE.  The hash chain link
\*(lBnextUUID\*(lE becomes obsolete as it will
no longer be necessary for the server module to link
\*(lBcm_server\*(lE
structures into two hash tables, one hashed by IP address
(\*(lBcm_servers[]\*(lE)
and the other
by server UUID
(\*(lBcm_serverUUID[]\*(lE).  Instead, the server module will maintain
a single hash table
(\*(lBcm_servers[]\*(lE)
with server entries hashed by UUID; the hash link employed
will be the existing \*(lBnext\*(lE pointer, since it is already used
throughout the CM code to scan through all server structures.  The
new field
\*(lBfailoverCount\*(lE
represents the number of address fail-overs
since the last successful server RPC; it is used for fail-over
throttling as discussed later.
.P
Though many of the functions in the file \*(lBcm/cm_server.c\*(lE will
be modified, most are simple updates to access data items now stored
in the associated \*(lBcm_site\*(lE structure.  The functions requiring
significant operational modifications are the following:
.P
.aL
.LI
\*(lBcm_GetServer()\*(lE \*(EM This function locates/allocates a
server object.  It will be modified to call
\*(lBcm_SiteAlloc()\*(lE when a new server object is allocated.  Server
structures will be placed in a hash table hashed by UUID only.
.LI
\*(lBcm_ServerDown()\*(lE \*(EM This function is called to report
that a server appears to be down.  As previously discussed,
this function will be modified to
perform address fail-over by calling the new function
\*(lBcm_SiteAddrDown()\*(lE to report a failed communication.  The result
of address fail-over, and the value of
\*(lBfailoverCount\*(lE, can then be taken into account when determining
if the server is \*(qBreally\*(qE down.
.LI
\*(lBCheckDownServer()\*(lE \*(EM This function pings a server marked
down to determine if it has come back up.  It will be modified to
ping each server address in rank order until successful or all
addresses have been tried.
.LI
\*(lBcm_SetServerRank()\*(lE \*(EM This function is called to set
the rank value of a server (server address).  The function will be
modified to call
\*(lBcm_SiteAddrSetRankAll()\*(lE to do the actual work.  A discussion
of the use of address ranks in the server-preference scheme for
multi-homed servers is
presented in a later section.
.LE
.P
.H 3 "Other modifications"
.P
The impact on other CM modules of employing site objects is
minimal, with the major changes summarized as follows:
.P
.aL
.LI
\*(lBcm/cm_conn.c\*(lE: \*(lBcm_ConnByHost()\*(lE \*(EM This function
locates/creates a connection (binding) to a server and,
for file-server connections, may also perform the RPC
\*(lBAFS_SetContext()\*(lE.  The function will be re-named
\*(lBConnByAddr()\*(lE, and will be
modified to create
bindings for a specified server address, and to
reset
\*(lBfailoverCount\*(lE after a successful
\*(lBAFS_SetContext()\*(lE call.
.P
A new \*(lBcm_ConnByHost()\*(lE will be implemented which has
the same signature and semantics as the current function with that
name.  This function will call
\*(lBConnByAddr()\*(lE until either a server binding is
obtained, or all of
the server's addresses have been tried.
.LI
\*(lBcm/cm_conn.c\*(lE: \*(lBcm_ConnByMHosts()\*(lE \*(EM This
function attempts
to get a binding for any one of a set of servers, in
accordance with the server-preference scheme.  It will be modified
to utilize
\*(lBConnByAddr()\*(lE, rather than (the new)
\*(lBcm_ConnByHost()\*(lE,
so that addresses can be tried for binding in rank order across the
set of all servers.
.P
The current implementation of this function requires that sets of
server references in volume and cell objects be kept sorted by
rank.  This requirement is made obsolete in moving to multi-homed
server support with an address-oriented preference scheme.
.LI
\*(lBcm/cm_rrequest.c\*(lE: \*(lBcm_Analyze()\*(lE \*(EM As
previously illustrated,
this function determines if an RPC should be attempted again.  It will
be modified to reset
\*(lBfailoverCount\*(lE after a successful RPC to a server.
.LI
\*(lBcm/cm_cell.c\*(lE: \*(lBcm_NewCell()\*(lE \*(EM This
function creates/updates
a cell object, which contains, among other cell-related information,
an array of pointers to server objects representing the flservers in
the cell.  In the current implementation, this function calls
\*(lBcm_GetServer()\*(lE once for each flserver in the cell in order
to (re-)establish this array.  It will be modified so that for each
flserver it will also call
\*(lBcm_SiteAddrUpdate()\*(lE to update/create the list of server
addresses.
.nS "NOTE"
Currently, only one address per flserver is passed to
\*(lBcm_NewCell()\*(lE.  However, the machinery is in place and needs
only to be enabled so that the dfsbind process can pass to the CM all
flserver addresses obtained from the CDS.  Enabling this code will
be part of the modifications required for this project.
.nF
.LI
\*(lBcm/cm_volume.c\*(lE: \*(lBcm_InstallVolumeEntry()\*(lE \*(EM This function
updates a volume object from information obtained from
the FLDB (\*(lBstruct vldbentry\*(lE).  A volume object contains,
among other information, two arrays of pointers to server objects, one
for file servers and one for replication servers, with an entry in each
for each machine that houses the fileset (volume).  As is the case
with cell objects, these array entries are defined via calls to
\*(lBcm_GetServer()\*(lE.  Thus this function will be modified in a similar
fashion to \*(lBcm_NewCell()\*(lE.  However, in addition to calling
\*(lBcm_SiteAddrUpdate()\*(lE, this function may also call
\*(lBcm_SiteAddrUpdateAllFLDB()\*(lE as discussed below in the
section on address acquisition.
.LI
\*(lBcm/cm_daemons.c\*(lE: \*(lBcm_Daemon()\*(lE \*(EM This function arranges
for a thread pool to perform various background processing tasks.  It
will be modified to schedule a thread to periodically iterate
through the list of servers, calling
\*(lBcm_SiteAddrPingBad()\*(lE for each active server.  This is discussed
below in the section on address revival.
.LE
.P
.H 2 "Operational Overview"
.P
Given the site object definition and integration discussed above, a complete
operational overview of multi-homed server support can now be
presented.
.P
.H 3 "Address fail-over"
.P
Address fail-over is performed transparently within the canonical
CM RPC framework:
.P
.dS
do {
    if (connp = cm_ConnByHost(serverp, ...)) {
        /* got server binding */
        result = server_RPC(connp->connp, ...);
    }
} while (cm_Analyze(connp, result, ...));
.dF
.P
A communication failure detected by either \*(lBcm_ConnByHost()\*(lE
(in \*(lBConnByAddr()\*(lE)
or \*(lBcm_Analyze()\*(lE results in a call to
\*(lBcm_ServerDown()\*(lE, which will perform address fail-over
by calling
\*(lBcm_SiteAddrDown()\*(lE to report the failed communication.  The
result of address fail-over can then be taken into account in determining
if the server is to be marked down.
.P
.H 3 "Address revival"
.P
Just as performing address fail-over is important to
over-all system operation,
so is determining when previously failed addresses are again available.
Making a previously failed network connection available for use
provides the opportunity for increased fault-tolerance,
in the form of an additional connection for future fail-overs,
and increased performance,
in the form of an additional connection that may be
\*(qBbetter\*(qE than one currently being used.  The following is a
description of the two methods by which address revival is
performed: the first for servers marked as being down, and the second for
servers marked as being up.
.P
As part of actively maintaining server state information, the CM schedules
a background thread to periodically call
\*(lBcm_CheckDownServers()\*(lE which pings all servers marked down
to determine if they have come back up.  \*(lBcm_CheckDownServers()\*(lE
iterates through the list of server
objects, calling \*(lBCheckDownServer()\*(lE for each server marked
down.  \*(lBCheckDownServer()\*(lE will call \*(lBcm_SiteAddrUp()\*(lE
to mark all the server's addresses as up, and then will ping the server
at each address in rank order until either successful or all
addresses have been tried.
.P
Similarly, a background thread will be scheduled to periodically
iterate through the list of server objects, calling
\*(lBcm_SiteAddrPingBad()\*(lE for each
active (up) server.  \*(lBcm_SiteAddrPingBad()\*(lE attempts to ping a
server on all addresses marked down to determine if the
connection has been restored.
.P
Together, these background threads will actively maintain each server's
address-list state.
.P
.H 3 "Address acquisition"
.P
In addition to maintaining each server's address-list state for currently
known addresses, the CM must actively maintain the set of known addresses
for each server.  Recall that a server's address list is defined
after the server object and associated site object are
created.  In \*(lBcm_NewCell()\*(lE, the function
\*(lBcm_SiteAddrUpdate()\*(lE will be called with the list of all
flserver addresses obtained from
the CDS.  In \*(lBcm_InstallVolumeEntry()\*(lE, the function
\*(lBcm_SiteAddrUpdate()\*(lE will be called with the list of all
file-server/repserver addresses obtained from the
FLDB via a \*(lBvldbentry\*(lE structure.
.P
Though the flserver address list
provided in
\*(lBcm_NewCell()\*(lE
will represent all of the
addresses specified for use by the server, this
is not necessarily the case for the file-server/repserver address list
provided in \*(lBcm_InstallVolumeEntry()\*(lE.  The
reason is that a \*(lBvldbentry\*(lE structure can contain a maximum
of 16 addresses, which must be divided among all fileset instances, of
which there can be as many as 16.  Thus in the worst case (a fileset with
15 replicas), the \*(lBvldbentry\*(lE structure will contain one address
per host.  Note that this can occur in spite of the fact that the FLDB can
always contain four (4) addresses per file-server
machine (file-server/repserver).
.P
To address this problem, the \*(lBcm_site\*(lE module exports the function
\*(lBcm_SiteAddrUpdateAllFLDB()\*(lE, which attempts to update
the address lists of the file-server/repserver on a given host from
the FLDB via the \*(lBVL_GetSiteInfo()\*(lE
function.\*(f!  \*(lBVL_GetSiteInfo()\*(lE
.FS
\*(lBcm_SiteAddrUpdateAllFLDB()\*(lE will update more than one
file-server/repserver on a host if extant; e.g., to support
multiple DFS servers behind a firewall.
.FE
returns all addresses (up to four)
specified for use by a file-server/repserver on a host.  But
because \*(lBcm_SiteAddrUpdateAllFLDB()\*(lE is a potentially
high-latency operation, it will not be called directly
by the thread executing \*(lBcm_InstallVolumeEntry()\*(lE (which could
need to call it up to 15 times), but instead will be called by a
worker-thread scheduled by that thread.
.P
The CM also schedules a background thread that periodically (every hour)
calls \*(lBcm_CheckVolumeNames()\*(lE to
iterate through all volume objects and mark them as requiring
checking.  The next time the volume object is employed, it's state
will be updated from the FLDB via
\*(lBcm_InstallVolumeEntry()\*(lE.  As a result,
the CM will automatically (on-demand) track file-server/repserver
address-list changes in the FLDB.
.P
Similarly, the CM times-out cell information (after 24 hours) and
refreshes it via
\*(lBcm_NewCell()\*(lE.  As a result,
the CM will automatically (on-demand) track flserver
address-list changes in the CDS.
.P
.nS "NOTE"
A problem with using \*(lBVL_GetSiteInfo()\*(lE to get file-server/repserver
address information is that it requires knowing one address
in the desired list.  An administrator could potentially change addresses
for a given file-server/repserver in the FLDB before address list
completion, in which case a complete list might not be obtained
until after the next time
\*(lBcm_CheckVolumeNames()\*(lE is executed.  One
possible solution (among many) is to implement an flserver operation
that would retrieve site information based on host principal name.  In
practice, this should not really be a concern.
.P
Future updates to the flserver protocol may obviate the need for the
\*(lBcm_SiteAddrUpdateAllFLDB()\*(lE function, except when dealing
with older versions of the flserver.
.nF
.P
.H 3 "Server-preference scheme"
.P
The cache manager implements a preference scheme whereby
server addresses are assigned a specified or computed
rank.  Address rank is used
to determine fail-over ordering when obtaining information from one
or more servers.
.P
Because the CM currently supports only a single address
per server, assigning address ranks is equivalent to assigning
server ranks.  However, with multi-homed server support, the CM
will exhibit the intended semantics: when attempting to contact one of
a set of servers (where set size can be one), the CM will
employ \*(iBaddresses\*(iE in rank order.
.P
Supporting address-preference semantics is the reason that
\*(lBcm_ConnByHost()\*(lE and
\*(lBcm_ConnByMHosts()\*(lE
will be implemented via
\*(lBConnByAddr()\*(lE.  In doing so,
\*(lBcm_ConnByHost()\*(lE
can try for binding all (up) addresses in rank order for a particular
server, while
\*(lBcm_ConnByMHosts()\*(lE
can try for binding all (up) addresses in rank order across a
set of servers.
.P
.H 2 "Performance Issues"
.P
This section identifies several performance issues alluded to
throughout this document.  These are really tuning issues concerned
more with \*(qBhow much\*(qE rather than with \*(qBhow\*(qE.  No
specific tuning values are given; this will require some analysis
and experimentation.
.P
.aL
.LI
Fail-over throttling \*(EM In performing address fail-over, the
server structure field \*(lBfailoverCount\*(lE is used to count
the number of address fail-overs since the last successful RPC
to that server.  This value is used to limit the number of fail-overs
that can occur before a server is deemed to be dead.\*(f!  Restricting
.FS
As an exception, a file-server is never deemed to be dead until the
host lifetime expires.
.FE
fail-overs in this manner bounds the amount of time that is spent
attempting to contact a server that is likely to be down.  The
fail-over count limit must be chosen to balance operation latency with
fault-tolerance effort.
.P
Note that throttling is not applied in the server module function
\*(lBCheckDownServer()\*(lE, which pings a server marked down to
determine if it has come back up, so that all addresses can be tried.
.LI
Daemon period \*(EM To revive failed addresses for functioning
servers, the CM arranges for \*(lBcm_SiteAddrPingBad()\*(lE
to be called periodically for each active server.  The period for
this function
must be chosen to balance the potential benefit with the
overhead.  However,
since (observed) address failure should not occur often, execution overhead
should normally be low.  Thus a period on the order of 15 minutes
is probably not unreasonable.
.LE
.P
.H 1 "CONCLUSIONS"
.P
This document proposes a method for supporting multi-homed servers
in the DFS cache manager which meets the stated objectives, namely:
.P
.aL
.LI
transparent handling of network connection failures,
.LI
active management of each server's network connection state, and
.LI
compliance with the server-preference scheme.
.LE
.P
These objectives are met by introducing a \*(iBsite object\*(iE into
the existing CM communication architecture to represent the state
of a server's network connections.  It is shown that
site objects can be integrated into the code base
in a straightforward fashion, with most significant modifications
concentrated in the server module.
.P
.H 1 "ACKNOWLEDGMENTS"
.P
The author wishes to acknowledge the valuable comments of many of the
folks at Transarc, in particular Ted Anderson, Steve Berman, Craig Everhart,
Bruce Leverett, Dan Nydick,
Lyle Seaman, M. C. Srivas and Bill Zumach.
.P
...\" =========================================================================
...\" Author's address goes here, as unnumbered heading, at end of doc.
...\" =========================================================================
.P
.ne 3+5
.HU "AUTHOR'S ADDRESS"
.P
.tl $Steven Moyer$$Internet email: moyer@transarc.com$
.tl $Transarc Corp.$$Telephone: +1-412-338-2047$
.tl $707 Grant Street$$$
.tl $Pittsburgh, PA 15219$$$
.tl $USA$$$
...\" =========================================================================
...\" Done!
...\" =========================================================================
