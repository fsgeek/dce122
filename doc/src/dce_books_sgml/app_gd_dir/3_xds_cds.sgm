<!--
# COPYRIGHT NOTICE
# Copyright (c) 1990-1996 Open Software Foundation, Inc. 
# ALL RIGHTS RESERVED (DCE). See the file named COPYRIGHT.DCE in the 
# src directory for the full copyright text. 
# 
# 
# HISTORY
# $Log: 3_xds_cds.sgm,v $
# Revision 1.1.2.11  1996/12/17  19:28:54  damon
# 	Expanded OSF C O P Y R I G H T   N O T I C E
# 	[1996/12/17  19:22:31  damon]
#
# Revision 1.1.2.10  1996/12/09  21:13:03  carrig
# 	{enh,R1.2.2}
# 	Wide Pgm Listing
# 	[1996/12/09  21:11:11  carrig]
# 
# Revision 1.1.2.9  1996/12/09  00:07:15  carrig
# 	{enh,R1.2.2}
# 	Put in editor's comments
# 	[1996/12/09  00:05:39  carrig]
# 
# Revision 1.1.2.8  1996/10/23  18:48:34  carrig
# 	{enh,R1.2.2}
# 	Ready for editor (2)
# 	[1996/10/23  18:46:52  carrig]
# 
# Revision 1.1.2.7  1996/10/22  21:05:45  carrig
# 	{enh,R1.2.2}
# 	Fixed tables
# 	[1996/10/22  21:04:32  carrig]
# 
# Revision 1.1.2.6  1996/10/21  20:34:14  carrig
# 	{enh,R1.2.2}
# 	Worked on tables
# 	[1996/10/21  20:32:37  carrig]
# 
# Revision 1.1.2.5  1996/10/17  21:08:46  carrig
# 	{enh,R1.2.2}
# 	Worked on tables
# 	[1996/10/17  21:07:11  carrig]
# 
# 	{enh,R1.2.2}
# 	Worked on tables
# 	[1996/10/17  20:54:21  carrig]
# 
# Revision 1.1.2.4  1996/10/16  21:33:24  carrig
# 	{enh,R1.2.2}
# 	First pass at tables
# 	[1996/10/16  21:31:25  carrig]
# 
# Revision 1.1.2.3  1996/10/07  17:58:49  wardr
# 	{enh,R1.2.2}
# 	Update for sgml conversion
# 	[1996/10/07  17:58:26  wardr]
# 
# Revision 1.1.2.2  1996/09/28  15:21:26  weir
# 	Cleaned up old history
# 	[1996/09/28  15:19:49  weir]
# 
# Revision 1.1.2.1  1996/09/25  20:27:54  weir
# 	Initial submission
# 	[1996/09/25  20:26:27  weir]
# 
# $EndLog$
# 
-->
<!---->
<!-- Fragment document type declaration subset:
ArborText, Inc., 1988-1993, v.4001
<!DOCTYPE Book PUBLIC "-//Davenport//DTD DocBook V2.4//EN" [
<!ENTITY  DCEADG.CDSXC.pic.1  SYSTEM "eps/obj1.eps" NDATA EPS>
<!ENTITY  DCEADG.CDSXC.pic.2  SYSTEM "eps/obj2.eps" NDATA EPS>
<!ENTITY  DCEADG.CDSXC.pic.3  SYSTEM "eps/obj3.eps" NDATA EPS>
<!ENTITY  DCEADG.CDSXC.pic.4  SYSTEM "eps/xds_obj.eps" NDATA EPS>
<!ENTITY  DCEADG.CDSXC.pic.5  SYSTEM "eps/gds_objects.eps" NDATA EPS>
<!ENTITY  DCEADG.CDSXC.pic.6  SYSTEM "eps/objresult1.eps" NDATA EPS>
<!ENTITY  DCEADG.CDSXC.pic.7  SYSTEM "eps/objresult2.eps" NDATA EPS>
<!ENTITY  DCEADG.CDSXC.pic.8  SYSTEM "eps/objresult3.eps" NDATA EPS>
<!ENTITY  DCEADG.CDSXC.pic.9  SYSTEM "eps/attribute_list_obj.eps" NDATA EPS>
<!ENTITY  DCEADG.CDSXC.pic.10  SYSTEM "eps/ds_dn_obj.eps" NDATA EPS>
<!ENTITY  DCEADG.CDSXC.pic.11  SYSTEM "eps/entry_mod_list_obj.eps" NDATA EPS>
<!ENTITY  DCEADG.CDSXC.pic.12  SYSTEM "eps/entry_info_selection_obj.eps" NDATA EPS>
]>
-->
<!-- OLD HISTORY-->
<!-- Revision 1.1.8.2  1996/09/03  17:20:34  wardr-->
<!-- 	{enh,R1.2.2}-->
<!-- 	Update for sgml conversion-->
<!-- 	[1996/09/03  17:20:23  wardr]-->
<!---->
<!-- Revision 1.1.6.9  1995/06/15  16:28:00  rcb-->
<!-- 	edited 1.1 version, PRENTICE HALL reformat-->
<!-- 	[1995/06/13  19:25:06  rcb]-->
<!-- -->
<!-- 	edited 1.1 version, PRENTICE HALL reformat-->
<!-- 	[1995/06/05  16:19:10  rcb]-->
<!-- -->
<!-- Revision 1.1.6.8  1994/11/15  20:47:47  neilson-->
<!-- 	Converted book title references to macro form.-->
<!-- 	[1994/11/15  18:57:50  neilson]-->
<!-- -->
<!-- Revision 1.1.6.7  1994/11/03  23:32:52  neilson-->
<!-- 	Substituted macros for book names in cross refs.-->
<!-- 	[1994/11/03  01:38:35  neilson]-->
<!-- -->
<!-- 	Substituted macros for book names in cross refs.-->
<!-- -->
<!-- Revision 1.1.6.6  1994/10/20  14:52:08  weir-->
<!-- 	Corrected some cross-references-->
<!-- 	[1994/10/20  14:51:38  weir]-->
<!-- -->
<!-- Revision 1.1.6.5  1994/10/18  20:54:55  weir-->
<!-- 	{def,10340,R1.1}-->
<!-- 	Corrected various OM-to-CDS table entries-->
<!-- 	[1994/10/18  20:54:20  weir]-->
<!-- -->
<!-- Revision 1.1.6.4  1993/02/23  02:27:40  lipsky-->
<!-- 	Changes made: Added syntax mapping table-->
<!-- 	File name:  src/app_gd/directory/xds_cds/3_xds_cds-->
<!-- 	CR: 7200-->
<!-- 	[1993/02/23  02:25:35  lipsky]-->
<!-- -->
<!-- Revision 1.1.6.3  1993/01/28  18:40:19  cjd-->
<!-- 	Embedded copyright notice-->
<!-- 	[1993/01/28  17:59:36  cjd]-->
<!-- -->
<!-- Revision 1.1.6.2  1992/11/20  15:24:16  weir-->
<!-- 	Moved into 1.0.2doc tree-->
<!-- 	[1992/11/20  15:21:06  weir]-->
<!-- -->
<!-- Revision 1.1.4.5  1992/11/11  23:45:40  buckler-->
<!-- 	Corrected index entries-->
<!-- 	[1992/11/11  22:49:04  buckler]-->
<!-- -->
<!-- Revision 1.1.4.4  1992/10/27  20:59:08  lmk-->
<!-- 	Prentice-Hall edits only-->
<!-- 	[1992/10/27  20:56:42  lmk]-->
<!-- -->
<!-- Revision 1.1.4.3  1992/10/14  15:11:42  steiner-->
<!-- 	Second P-H edit pass, from Eddie.-->
<!-- 	[1992/10/14  15:11:11  steiner]-->
<!-- -->
<!-- Revision 1.1.4.2  1992/09/09  15:40:34  steiner-->
<!-- 	First editing pass.-->
<!-- 	[1992/09/08  21:37:58  steiner]-->
<!-- -->
<!-- Revision 1.1.2.8  1992/08/05  20:42:39  weir-->
<!-- 	Fixed typeless RDNs (for real this time).-->
<!-- 	[1992/08/05  20:42:06  weir]-->
<!-- -->
<!-- Revision 1.1.2.7  1992/07/23  19:30:19  weir-->
<!-- 	Fixed typeless RDN.-->
<!-- 	[1992/07/23  19:29:33  weir]-->
<!-- -->
<!-- Revision 1.1.2.6  1992/07/21  15:38:01  weir-->
<!-- 	Small fix to example code.-->
<!-- 	[1992/07/21  15:37:21  weir]-->
<!-- -->
<!-- Revision 1.1.2.5  1992/07/21  14:23:20  weir-->
<!-- 	Last cleanup.-->
<!-- 	[1992/07/21  14:22:39  weir]-->
<!-- -->
<!-- Revision 1.1.2.4  1992/07/20  20:04:13  weir-->
<!-- 	Adjusted part of the example code.-->
<!-- 	[1992/07/20  20:03:29  weir]-->
<!-- -->
<!-- Revision 1.1.2.3  1992/07/09  20:39:09  weir-->
<!-- 	Revised version.-->
<!-- 	[1992/07/09  20:38:39  weir]-->
<!-- -->
<!-- Revision 1.1.2.2  1992/05/08  19:52:02  weir-->
<!-- 	bogus submit-->
<!-- -->
<!-- 	 Revision 1.1.1.5  1992/05/08  19:46:15  weir-->
<!-- 	xxx-->
<!-- -->
<!-- 	 Revision 1.1.1.4  1992/05/08  19:25:41  weir-->
<!-- 	xxx-->
<!-- -->
<!-- 	 Revision 1.1.1.3  1992/05/08  19:18:34  weir-->
<!-- 	bogus submit-->
<!-- -->
<!-- 	 Revision 1.1.1.2  1992/05/08  19:16:59  weir-->
<!-- 	bogus submit-->
<!-- 	[1992/05/08  19:51:06  weir]-->
<!-- -->
<Chapter Id="DCEADG.CDSXC.div.1">
<Title>XDS and the DCE Cell Namespace</Title>
<Para>This chapter describes the use of the XDS programming interface
when accessing the CDS namespace.
The first section provides an introduction to using XDS in the CDS
namespace.
Section 3.2 describes XDS objects and how they are used to access CDS
data.
Section 3.3 provides a step-by-step procedure for writing an XDS program
to access CDS.
Section 3.4 provides examples of using the XOM interface to manipulate
objects.
Section 3.5 provides details of the structure of XDS/CDS objects.
Finally, Section 3.6 provides translation tables between XDS and CDS
for attributes and data types.
</Para>
<Sect1 Id="DCEADG.CDSXC.div.2">
<Title>Introduction to Accessing CDS with XDS</Title>
<Para>Outside of the DCE cells and their separate namespaces is the
global namespace
in which the cell names themselves are entered, and where all intercell
references are resolved.
Two directory services participate in the global namespace.
The first is the X.500-compliant GDS
supplied with DCE.
The second is DNS, with which DCE interacts,
but is not a part of DCE.
</Para>
<Para>The global and cell directory services are accessed implicitly by RPC
applications using the NSI interface.
GDS and CDS can also be accessed explicitly by using
the XDS interface.
With XDS, application programmers can
gain access to GDS,
a powerful general-purpose distributed database service,
which can be used for many other things besides intercell binding.
XDS can also be used to access the <Symbol Role="Variable">cell</Symbol> namespace directly,
as this chapter describes.
</Para>
<Para>An XDS application looks very different from the
RPC-based DCE applications.
This is partly because there is no dependency in XDS on the
DCE RPC interface, although you can use both interfaces in the same
application.
Also, XDS is a
generalized directory interface, oriented more toward performing large
database operations than toward fine-tuning the contents of RPC entries.
Nevertheless, XDS can be used as a general access mechanism on the
CDS namespace.
</Para>
<Sect2 Id="DCEADG.CDSXC.div.3">
<Title>Using the Reference Material in This Chapter</Title>
<Para>Complete descriptions of all the XDS and XOM functions used in CDS operations
can be found in the &DCEDr;, which you should have beside you 
as you read through the examples in this chapter.
In particular, refer to that manual for information
about XDS error objects, which are not discussed in this chapter. 
</Para>
<Para>Complete descriptions for all objects required as <Symbol Role="Variable">input</Symbol> parameters by
XDS functions when accessing a CDS namespace can be found in Section
3.5.
Abbreviated
definitions for these same objects can be found with all the others in
Part 4.  XOM functions are
general-purpose utility routines that operate on objects of any class, and
take the rest of their input in conventional form.
</Para>
<Para>Slightly less detailed descriptions of the <Symbol Role="Variable">output</Symbol> objects you can
expect to receive when accessing CDS through XDS are also given in
Section 3.5. You do not have to construct objects of
these classes yourself; you just have to know their general structure so
that you can disassemble them using XOM routines.
</Para>
<Para><?sml-need 5>No information is given in this chapter about the <Literal>DS_status</Literal> error
objects that are returned by unsuccessful XDS functions; a description of
all the subclasses of <Literal>DS_status</Literal> requires a chapter in itself.  Code
for a rudimentary general-purpose <Literal>DS_status</Literal>-handling routine can be
found in the <Filename>teldir.c</Filename> XDS sample program in Chapter 7 of this
guide.
</Para>
</Sect2>
<Sect2 Id="DCEADG.CDSXC.div.4">
<Title>What You Cannot Do with XDS</Title>
<Para>XDS allows you to perform general operations on CDS entry attributes,
something which you cannot do through the DCE RPC NSI interface.
However, there are certain things you cannot do to cell directory
entries even through XDS:
</Para>
<ItemizedList>
<ListItem>
<Para>You cannot create or modify directory entries; the
<Function>ds_modify_rdn(&thinsp;)</Function> function does not work in a CDS namespace.  These
operations must be performed through the CDS control program (<Command>cdscp</Command>).  
For more information, see the &DCEAr;.
</Para>
</ListItem>
<ListItem>
<Para>You cannot perform XDS searches on the cell namespace; the XDS function
<Function>ds_search(&thinsp;)</Function> does not work.  This is mainly because the CDS has no
concept of a hierarchy of entry attributes, such as the X.500 schema.
The <Function>ds_compare(&thinsp;)</Function> function, however, does work.
</Para>
</ListItem>
</ItemizedList>
</Sect2>
<Sect2 Id="DCEADG.CDSXC.div.5">
<Title>Registering A Nonlocal Cell</Title>
<Para>If you are planning to use XDS to access the cell namespace in a one-cell
environment (that is, your cell does not need to communicate
with other DCE cells), you do not need to set up a cell entry in
GDS for your cell because the XDS functions
simply call the appropriate statically linked CDS routines to access the
cell namespace.  In these circumstances, XDS always tries to access the
local cell
when given an untyped (non-X.500) name.
</Para>
<Para>For XDS to be able to access any nonlocal cell namespace, that cell must
be registered (that is, have an entry) in the global namespace.
</Para>
<Para>For information on setting up your cell name, see the &DCEAg;.
</Para>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.CDSXC.div.6">
<Title>XDS Objects</Title>
<Para>The XDS interface differs
from the other DCE component interfaces in that it is <Replaceable>object oriented</Replaceable>.
The following subsections explain two things: first,
what object-oriented
programming means in terms of using XDS; and second, how to use XDS to
access CDS.
</Para>
<Para>Imagine a generalized data structure that always has
the same data <Symbol Role="Variable">type</Symbol>,
and yet can contain any kind of data, and any amount of it.  Functions
could pass these structures back and forth in the same way all the time, and
yet they could use the same structures for any kind of data they wanted to
store or transfer.  Such a data structure, if it existed, would be a true
<Symbol Role="Variable">object</Symbol>.  Programming language constructs allow interfaces to pretend
that they use objects, although the realities of implementation are not
usually so simple.
</Para>
<Para>XDS is such an interface. For the most part, XDS functions neither accept
nor return values in any form but as objects.  The objects themselves are
indeed always the same data type; namely, pointers to arrays of <Symbol Role="Variable">object descriptor</Symbol> (C <Literal>struct</Literal>) elements.
Contained within these <Literal>OM_descriptor</Literal>
element structures are unions that can actually accommodate all the different
kinds of values an object can be called on to hold.  In order to allow the
interface to make sense of the unions, each <Literal>OM_descriptor</Literal> also contains 
a <Literal>syntax</Literal> field, which indicates the data type of that descriptor's
union.
There is also a record of what the descriptor's value
actually is; for example, whether it is a name, a number, an address,
a list, and so on.  This information is held in the descriptor's <Literal>type</Literal> field.
</Para>
<Para>These <Literal>OM_descriptor</Literal> elements, which are referred to
as <Replaceable>object descriptors</Replaceable> or <Replaceable>descriptors</Replaceable>, are the basic building blocks
of <Symbol Role="Variable">all</Symbol> XDS objects; every actual XDS object reduces to arrays of them.
Each descriptor contains three items:
</Para>
<ItemizedList>
<ListItem>
<Para>A <Literal>type</Literal> field, which identifies the descriptor's value
</Para>
</ListItem>
<ListItem>
<Para>A <Literal>syntax</Literal> field, which indicates the data type of the <Literal>value</Literal>
field
</Para>
</ListItem>
<ListItem>
<Para>The <Literal>value</Literal> field, which is a union
</Para>
</ListItem>
</ItemizedList>
<Para>Figure 3-1 illustrates one such object descriptor.
<!-- Figure obj1: Figure of one descriptor.-->
<!-- pix/obj1.pic-->
</Para>
<?sml-need 1.5i>
<Figure>
<Title>One Object Descriptor</Title>
<Graphic Format="EPS" Entityref="DCEADG.CDSXC.pic.1"></Graphic>
</Figure>
<?sml-space .5>
<?sml-space .5>
<Para>Note that, from an abstract point of view, <Literal>syntax</Literal> is just an implementation
detail.  The scheme really consists only of a type/value pair.
The <Literal>type</Literal> gives
an identity to the object (something like CDS entry attribute, CDS entry name,
or DUA access point), and the <Literal>value</Literal> is some data associated with that
identity, just as a variable has a name that gives meaning to the value it
holds, and the value itself.
</Para>
<Para>In order to make the representation of objects as logical and as flexible as
possible, these two logical components of every object, <Literal>type</Literal> and
<Literal>value</Literal>, are themselves each represented by separate object descriptors.
Thus, the first element of every complete object descriptor array is
a descriptor whose <Literal>type</Literal> field identifies its <Literal>value</Literal> field as
containing the name of the kind (or <Symbol Role="Variable">class</Symbol>) of this object,
and the <Literal>syntax</Literal> field indicates how that name <Literal>value</Literal> should be
read.  Next is usually one (or more, if the object is
multivalued) object descriptor whose <Literal>type</Literal> field identifies its
<Literal>value</Literal> field as containing some value appropriate for this class of
object.
Finally, every complete object descriptor array ends with a descriptor element
that is identified by its fields as being a NULL-terminating element.
</Para>
<Para>Thus, a
minimum-size descriptor array consists of just two elements: the
first contains its class identity, and the second is a NULL
(it is legitimate
for objects not to have values).  When an object does have a value, it
is held in the <Literal>value</Literal> field of a descriptor whose <Literal>type</Literal> field
communicates the value's meaning.
</Para>
<Para>Figure 3-2 illustrates the arrangement of a complete
object descriptor array.
<!-- Figure obj2: Figure of a full object descriptor array: three elements.-->
<!-- pix/obj2.pic-->
</Para>
<Figure>
<Title>A Complete Object Represented</Title>
<Graphic Format="EPS" Entityref="DCEADG.CDSXC.pic.2"></Graphic>
</Figure>
<?sml-space .5>
<Sect2 Id="DCEADG.CDSXC.div.7">
<Title>Object Attributes</Title>
<Para>The generic term for any object value is <Symbol Role="Variable">attribute</Symbol>. In this sense, an
object is nothing but a collection of attributes, and every object descriptor
describes one attribute.  The first attribute's value
identifies the object's class, and this determines all the other
attributes the object is supposed to have.
One or more other attributes follow,
which contain the object's working values.
The NULL
object descriptor at the
end is an implementation detail, and is not a part of the object.
</Para>
<Para>Note that, depending on the
attribute it represents, a descriptor's
<Literal>value</Literal> field can contain a pointer to another array of object descriptors.
In other words, an object's value can be
another object.
</Para>
<Para>Figure 3-3 shows a three-layer compound object: the top-level
superobject, <Literal>dn_object</Literal>, contains the subobject <Literal>rdn1</Literal>, which in
turn contains the subobject <Literal>ava1</Literal>.
<!-- Figure obj3: Figure of representation of a two-layer object.-->
<!-- pix/obj3.pic-->
</Para>
<Figure>
<Title>A Three-Layer Compound Object</Title>
<Graphic Format="EPS" Entityref="DCEADG.CDSXC.pic.3" role="page-wide" Scalefit="1" Reprodep="400" Reprowid="400"></Graphic>
</Figure>
<?sml-space .5>
</Sect2>
<Sect2 Id="DCEADG.CDSXC.div.8">
<Title>Interface Objects and Directory Objects</Title>
<Para>GDS is composed of directory objects that reflect
the X.500 design.
The XDS interface also works with objects.
However, there is a big difference between
directory and XDS objects.
Programmers do not work directly with
the directory objects; they are composed of attributes
that make up the directory service's implementation of entries.
</Para>
<Para>Programmers work with XDS objects. XDS objects have explicit data
representations that can be directly manipulated
with programming language operators.  Some of these techniques
are described in this chapter; others can be found in Chapter 7.
</Para>
<Para>XDS and GDS terminology sometimes suggests that XDS objects are somehow
direct representations of the directory objects to which they communicate
information.  This is not the case, however.  You never directly
see or manipulate the directory objects; the XDS interface objects
are used only to pass parameters to the XDS calls, which in turn request
GDS (or CDS) to perform operations on the directory objects.
The XDS objects are therefore somewhat arbitrary structures defined
by the interface.
</Para>
<Para>Figure 3-4 illustrates the relationship between XDS (also
called <Replaceable>interface</Replaceable>)
objects and directory objects.
The figure shows an application passing several properly initialized XDS
objects to some XDS function; it then takes some action, which affects
the attribute contents of certain directory objects.  The application never
works with the directory objects; it works with the
XDS interface objects.
</Para>
<Para>A side effect of the existence of a separate XDS interface and GDS or CDS
directory objects is the existence of attributes for both kinds of
objects as well.  Because the purpose of XDS objects is to feed data into and
extract data from directory objects, programmers work
with XDS objects whose attributes have <Symbol Role="Variable">directory</Symbol> object
attributes as their values.
You should keep in mind the
distinction between directory objects and interface
objects.
<!-- Figure : Showing different kinds of object...-->
<!-- newpix/xds_obj.pic-->
</Para>
<?sml-need 7i>
<Figure>
<Title>Directory Objects and XDS Interface Objects</Title>
<Graphic Format="EPS" Entityref="DCEADG.CDSXC.pic.4" Scalefit="1" Reprodep="400" Reprowid="400"></Graphic>
</Figure>
<?sml-space .5>
</Sect2>
<Sect2 Id="DCEADG.CDSXC.div.9">
<Title>Directory Objects and Namespace Entries</Title>
<Para>The GDS namespace is a hierarchical collection of entries. The name of
each of these entries is an attribute of a directory object.
The object is accessed through XDS by stating its name attribute.
</Para>
<Para>Figure 3-5 shows the relationship of entry names in the GDS
namespace to the GDS directory objects to which they refer. 
</Para>
<Para><!-- Figure : showing relationship of objects to entries.-->
<!--          shows same as above, PLUS cell-binding info, AND-->
<!--              specific paths.-->
<!-- pix/gds_objects.pic-->
</Para>
<Figure>
<Title>Directory Objects and Namespace Entries</Title>
<Graphic Format="EPS" Entityref="DCEADG.CDSXC.pic.5" Scalefit="1" Reprodep="400" Reprowid="400"></Graphic>
</Figure>
<?sml-space .5>
</Sect2>
<Sect2 Id="DCEADG.CDSXC.div.10">
<Title>Values That an Object Can Contain</Title>
<Para>There are many different classes of objects defined for the XDS interface;
still more are defined by the X.500 standard for general directory use.  But
only a small number of classes are needed for XDS/CDS operations, and only
those classes are discussed in this chapter.  Information about other
classes can be found in Part 4 of this guide.
</Para>
<Para>The class that an object belongs to determines what sort of information
the object can contain.  Each object class consists of a list of attributes
that objects must have.  For example, you would expect an object in the
directory entry name class to be required to have an attribute to hold
the entry name string.  However, it is not sufficient to simply place a
string like the following into an object descriptor:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>/.../C=US/O=OSF/OU=DCE/hosts/tamburlaine/self
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>A full directory entry name such as the preceding
one is called in XDS a <FirstTerm>distinguished name</FirstTerm> (DN),
meaning that the entry name is fully qualified
(distinct) from root to entry name.  To properly represent the entry name
in an object, you must look up the definition of the XDS distinguished
name object class and build an object that has the set of attributes that
the definition prescribes.
</Para>
</Sect2>
<Sect2 Id="DCEADG.CDSXC.div.11">
<Title>Building a Name Object</Title>
<Para>Complete definitions for all the object classes required as input for XDS
functions can be found in Section 3.5.  Among them is the class for
distinguished name objects, called <Literal>DS_C_DS_DN</Literal>.
There you will learn that this class
of object has two attributes: its class attribute,
which identifies it as a <Literal>DS_C_DS_DN</Literal> object, and a second
attribute, which occurs multiple times in the object.
Each instance of this attribute contains as its value one
piece of the full name; for example, the
directory name <Literal>hosts</Literal>.
</Para>
<Para><?sml-need 4>The <Literal>DS_C_DS_DN</Literal> attribute
that holds the entry name piece, or relative distinguished name (RDN),
is defined by the class rules to hold, not a string, but
another object of the RDN class (<Literal>DS_C_DS_RDN</Literal>).
</Para>
<Para><?sml-need 12>Thus, a static declaration of the descriptor array representing the <Literal>DS_C_DS_DN</Literal>
object would look like the following:
</Para>
<InformalExample>
<Para><ProgramListing>
static OM_descriptor    Full_Entry_Name_Object[] = {

     OM_OID_DESC(OM_CLASS, DS_C_DS_DN),
/*   &caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;                                         */
/*   Macro to put an "OID string" in a descrip-          */
/*     tor's type field and fill its other               */
/*     fields with appropriate values.                   */

     {DS_RDNS, OM_S_OBJECT, {0, Country_RDN}},
/*    &caret;&caret;&caret;&caret;&caret;&caret;&caret;  &caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;      &caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;              */
/*     type      syntax            value                 */
/*                                                       */
/*     (the "value" union is in fact here a              */
/*      structure; the 0 fills a pad field in            */
/*      that structure.)                                 */
 
     {DS_RDNS, OM_S_OBJECT, {0, Organization_RDN}},
     {DS_RDNS, OM_S_OBJECT, {0, Org_Unit_RDN}},
     {DS_RDNS, OM_S_OBJECT, {0, Hosts_Dir_RDN}},
     {DS_RDNS, OM_S_OBJECT, {0, Tamburlaine_Dir_RDN}},
     {DS_RDNS, OM_S_OBJECT, {0, Self_Entry_RDN}},

     OM_NULL_DESCRIPTOR
/*   &caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;                                  */
/*    Macro to fill a descriptor with proper             */
/*      NULL values.                                     */

};
</ProgramListing></Para>
</InformalExample>
<Para>The use of the <Literal>OM_OID_DESC</Literal> and <Literal>OM_NULL_DESCRIPTOR</Literal> macros
slightly obscures the layout of this declaration.  However, each line
contains code to initialize exactly one <Literal>OM_descriptor</Literal> object;
the array consists of eight objects.
</Para>
<Para><?sml-need 5>The names (such as <Literal>Country_RDN</Literal>) in the descriptors' <Literal>value</Literal>
fields refer to the other descriptor arrays, which separately
represent the relative name objects.
(The order of the C
declaration in the source file is opposite to the order
described here.) Because <Literal>DS_C_DS_RDN</Literal> objects are now
called for, the next step is to look at what attributes that class
requires.
</Para>
<Para>The definition for <Literal>DS_C_DS_RDN</Literal> can be found in Section
3.5.2.6.
This class object is
defined, like <Literal>DS_C_DS_DN</Literal>, to have only one attribute (with
the exception of the
<Literal>OM_Object</Literal> attribute, which is mandatory for all objects).
The one attribute, <Literal>DS_AVAS</Literal>, holds the value
of one relative name.
The syntax of this value
is <Literal>OM_S_OBJECT</Literal>, meaning that <Literal>DS_AVAS</Literal>'s value is
a pointer to yet another object descriptor array:
</Para>
<InformalExample>
<Para><ProgramListing>
static OM_descriptor    Country_RDN[] = {
 
     OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),

     {DS_AVAS, OM_S_OBJECT, {0, Country_Value}},
 
     OM_NULL_DESCRIPTOR
};
</ProgramListing></Para>
</InformalExample>
<Para>Note that there should also be five other similar declarations, one
for each of the other <Literal>DS_C_DS_RDN</Literal> objects held in <Literal>DS_C_DS_DN</Literal>.
</Para>
<Para>The declarations have the same meanings as they did in the previous
example. <Literal>Country_Value</Literal> is the name of the descriptor array that
represents the object of class <Literal>DS_C_AVA</Literal>, which we are now about
to look up.
</Para>
<Para>The rules for the <Literal>DS_C_AVA</Literal> class can be found in this chapter just
after <Literal>DS_C_DS_RDN</Literal>.  They tell us that <Literal>DS_C_AVA</Literal> objects have
two attributes aside from the omnipresent <Literal>OM_Object</Literal>; namely:
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>DS_ATTRIBUTE_VALUES</Literal>
</Para>
<Para>This attribute holds the object's value.
</Para>
</ListItem>
<ListItem>
<Para><Literal>DS_ATTRIBUTE_TYPE</Literal>
</Para>
<Para>This attribute gives the meaning of the object's value.
</Para>
</ListItem>
</ItemizedList>
<Para><?sml-need 6>In this instance, the meaning of the string <Literal>US</Literal> is that it is a country
name.  There is a particular directory service attribute value for this;
it is identified by an OID that is associated with the label
<Literal>DS_A_COUNTRY_NAME</Literal> (the OIDs held in objects are represented in
string form).
Accordingly, we make that OID the value of <Literal>DS_ATTRIBUTE_TYPE</Literal>,
and we make the name string itself the value of <Literal>DS_ATTRIBUTE_VALUES</Literal>, as shown.
<?sml-point-size 11></Para>
<InformalExample>
<Para><ProgramListing>
<?Pub _font TypeSize="8pt">
static OM_descriptor    Country_Value[] = {

    OM_OID_DESC(OM_CLASS, DS_C_AVA),

    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_COUNTRY_NAME),

    {DS_ATTRIBUTE_VALUES, OM_S_PRINTABLE_STRING, OM_STRING("US")},
/*                                               &caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;&caret;  */
/*                                              Macro to properly */
/*        fill the "value" union with the NULL-terminated string. */

     OM_NULL_DESCRIPTOR
};
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<Para>There are also five other <Literal>DS_C_AVA</Literal> declarations, one
for each of the
five other separate name piece objects referred to in the <Literal>DS_C_DS_RDN</Literal>
superobjects.
</Para>
</Sect2>
<Sect2 Id="DCEADG.CDSXC.div.12">
<Title>A Complete Object</Title>
<Para>The previous sections described how an object is created:
you look up the rules for
the object class you require, and then add the attributes called for
in the definition.  Whenever some attribute is defined to have an object
as its value, you have to look up the class rules for the new object
and declare a further descriptor array for it.  In this way, you continue
working down through layers of subobjects until you reach an object class that
contains no subobjects as values; at that point, you are finished.
<!-- Objects are built or planned top-down, although if declared-->
<!--  they are declared bottom-up.-->
</Para>
<Para>Normally,
you do not statically declare objects in
real applications.  The steps outlined
in the preceding text
are given as a method for determining what an object
looks like.  Once you have done that, you can then write routines to create
the objects dynamically.  An example of how to do this can be found in the
<Filename>teldir.c</Filename> example application in Chapter 7 of this guide.
</Para>
<Para><?sml-need 6>The process of object building is somewhat easier than it sounds. There are
only five different object classes needed for input to XDS functions
when accessing CDS, and only one of those, the <Literal>DS_C_DS_DN</Literal> class,
has more than one level of subobjects.  The rules for all five of these
classes can be found in Part 4 of this guide.
In order to use the GDS references, you should
know a few things about class hierarchy.
</Para>
</Sect2>
<Sect2 Id="DCEADG.CDSXC.div.13">
<Title>Class Hierarchy</Title>
<Para>Object classes are hierarchically organized so that some classes may be located
above some classes in the hierarchy and below others in the hierarchy.
In any such system of subordinate
classes, each next lower class inherits all the attributes prescribed for the
class immediately above it, plus whatever attributes are defined peculiarly for
it alone.  If the hierarchy continues further down, cumulative collection of
attributes continues to accumulate.  If there were a class for every letter of
the alphabet, starting at the highest level with A and continuing down to
the lowest level with Z, and if each succeeding letter was a subclass of its
predecessor, the Z class would possess all the attributes of all the other
letters, as well as its own, while the A class would possess only the A
class attributes.
</Para>
<Para>XDS/XOM classes are seldom nested more than two or at most three layers.
All inherited attributes are explicitly listed in the object
descriptions that follow,
so you do not have to worry about class hierarchies here.  However, the complete
descriptions of XDS/XOM objects in Part 4 of this guide rely on
statements of class inheritance to fill out their attribute lists for the
different classes.  Refer to Part 4
for information about
the classes of objects that can be returned by XDS calls in order to be
able to handle those returned objects.
</Para>
</Sect2>
<Sect2 Id="DCEADG.CDSXC.div.14">
<Title>Class Hierarchy and Object Structure</Title>
<Para>Note that <Symbol Role="Variable">class hierarchy</Symbol> is different from
<Symbol Role="Variable">object structure</Symbol>.  Object structure is the layering of object arrays that
was previously described in the <Literal>DS_C_DS_DN</Literal> declaration in Section
3.2.5. It
occurs when one object contains another object as the value of one or
more of its attributes.
</Para>
<Para>This is what is meant by recursive objects: one object
can point to another object as one of its attribute values.
The layering of subobjects
below superobjects in this way is described repeatedly in Section
3.5.
</Para>
<Para>The only practical significance of class hierarchy is
in determining all the attributes a certain object class must have.  Once
you have done this, you may find that a certain attribute requires as its
value some other object.  The result is a compound object,
but this is completely determined by the attributes for
the particular class you are looking at.
</Para>
</Sect2>
<Sect2 Id="DCEADG.CDSXC.div.15">
<Title>Public and Private Objects and XOM</Title>
<Para>In Section 3.2.5, you saw how a multilevel
XDS object can be statically declared in C code.  Now imagine that you have
written an application that contains such a static <Literal>DS_C_DS_DN</Literal> object
declaration.  From the point of view of your application, that object is
nothing but a series of arrays, and you can manipulate them with all the
normal programming operators, just as you can any other data type.
Nevertheless, the object is syntactically perfectly acceptable to any XDS
(or XOM) function that is prepared to receive a <Literal>DS_C_DS_DN</Literal> object.
</Para>
<Para>Objects are also created by the XDS functions themselves; this is the
way they usually return information to callers.  However, there is a
difference between objects generated by the XDS interface
and objects that are
explicitly declared by the application: you cannot access the former,
<Symbol Role="Variable">private</Symbol>, objects in the direct way that you can the latter, <Symbol Role="Variable">public</Symbol>,
objects.
</Para>
<Para>These two kinds of objects are the same as far as their
classes and attributes are concerned.  The only difference between them
is in the way they are accessed.  The public objects that an
application explicitly creates or declares in its own memory area are just
as accessible as any of the other data storage it uses.
However, private objects
are created and held in the XDS interface's own system memory.  Applications
get handles to private objects, and, in order to access the private objects'
contents, they have to pass the handles to object management functions.  The
object management (XOM) functions make up a sort of all-purpose companion
interface to XDS.  Whereas XDS functions typically require some specific
class object as input, the XOM
functions accept objects of any class and perform useful operations on them.
</Para>
<Para>If a private object needs to be manipulated,
one of the XOM functions, <Function>om_get(&thinsp;)</Function>, can be called to make
a public copy of the private object.
Then, calling the XOM <Function>om_create(&thinsp;)</Function>
function allows applications to generate private objects manipulable by
<Function>om_get(&thinsp;)</Function>.  The main significance of private as opposed to public
objects is that they do not have to be explicitly operated on; instead,
you can access them cleanly through the XOM interface and let it do most
of the work.  You still have to know something about the objects'
logical representation, however, to use XOM.
</Para>
<Para>Except for a few more details, which will be mentioned as needed, this is
practically all there is to XDS object representation.
</Para>
</Sect2>
<Sect2 Id="DCEADG.CDSXC.div.16">
<Title>XOM Objects and XDS Library Functions</Title>
<Para>To call an XDS library function, do the following:
</Para>
<OrderedList>
<ListItem>
<Para>Decide what input parameters you must supply to the function.
</Para>
</ListItem>
<ListItem>
<Para>Bundle up these parameters in objects (that is, arrays of object descriptors)
in an XDS format.
</Para>
</ListItem>
</OrderedList>
<Para>Almost all data returned to you by an XDS function is enclosed
in objects, which you must parse to recover the information that
you want.  This task is made almost automatic by a library function 
supplied with
the companion X/Open OSI-Abstract-Data Manipulation (XOM) interface.
</Para>
<Para>With XDS, the programmer has to perform a lot of
call parameter management, but in other respects the interface is easy to use.
The
XDS functions' dependence on objects makes them easy to call, once you have the
objects themselves correctly set up.
</Para>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.CDSXC.div.17">
<Title>Accessing CDS Using the XDS Step-by-Step Procedure</Title>
<Para>You now know all that you need to know to work with a cell
namespace through XDS.
The following subsections provide a walk-through
of the steps of some typical XDS/CDS operations.
They
describe what is involved in using XDS to access existing CDS
attributes.
They then describe how you can create and access
new CDS entry attributes.
</Para>
<Sect2 Id="DCEADG.CDSXC.div.18">
<Title>Reading and Writing Existing CDS Entry Attributes With XDS</Title>
<Para>Suppose that you want to use XDS to read some information from the
following CDS entry:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>/.../C=US/O=OSF/OU=DCE/hosts/tamburlaine/self
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>As explained in the &DCEAg;,
the <Filename>/.:/hosts/</Filename><Symbol Role="Variable">hostname/</Symbol><Literal>self</Literal> entry, which is created at the time
of cell configuration, contains binding information for the machine
<Symbol Role="Variable">hostname</Symbol>.  Since this is a simple RPC NSI entry, there is not very much
in the entry that is interesting to read, but this entry is used as
an example anyway as a simple demonstration.
</Para>
<Para>Following are the header inclusions and general data declarations:
</Para>
<InformalExample>
<Para><ProgramListing>#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;xom.h>
#include &lt;xds.h>
#include &lt;xdsbdcp.h>
<!-- #include <xdsgds.h>-->
#include &lt;xdscds.h>
</ProgramListing></Para>
</InformalExample>
<Para><?sml-need 6>Note that the <Filename>xom.h</Filename> and <Filename>xds.h</Filename> header files must be included in the
order shown in the preceding example.  Also note that
the <Filename>xdscds.h</Filename> header file is brought in for the sake of
<Literal>DSX_TYPELESS_RDN</Literal>.  This file is where the CDS-significant OIDs 
are defined.  The <Filename>xdsbdcp.h</Filename> file
contains information necessary to the Basic Directory Contents
Package, which is the basic version of the XDS interface you can use
in this program. 
</Para>
<Para>The XDS/XOM interface defines numerous object identifier string constants,
which are
used to identify the many object classes, parts, and pieces (among other
things)
that it needs to know about.  In order to make sure that these OID constants
do not collide with any other constants, the interface refers to them with the string
<Literal>OMP_O_</Literal> prefixed to the user-visible
form; for example, <Literal>DS_C_DS_DN</Literal>
becomes <Literal>OMP_O_DS_C_DS_DN</Literal> internally.
In order to make application instances
consistent with the internal form, use <Literal>OM_EXPORT</Literal> to import
<Symbol Role="Variable">all</Symbol> XDS-defined or
XOM-defined OID constants used in your application.
</Para>
<InformalExample>
<Para><ProgramListing>OM_EXPORT( DS_A_COUNTRY_NAME )
OM_EXPORT( DS_A_OBJECT_CLASS )
OM_EXPORT( DS_A_ORG_UNIT_NAME )
OM_EXPORT( DS_A_ORG_NAME )

OM_EXPORT( DS_C_ATTRIBUTE )
OM_EXPORT( DS_C_ATTRIBUTE_LIST )
OM_EXPORT( DS_C_AVA )
OM_EXPORT( DS_C_DS_DN )
OM_EXPORT( DS_C_DS_RDN )
OM_EXPORT( DS_C_ENTRY_INFO_SELECTION )
OM_EXPORT( DSX_TYPELESS_RDN )

/* ... Special OID for an untyped (that is, nonX.500)       */
/* relative distinguished name. Defined in xdscds.h header. */
</ProgramListing></Para>
</InformalExample>
<Para>A further important effect of <Literal>OM_EXPORT</Literal> is that it builds an <Literal>OM_string</Literal>
structure to hold the exported OID hexadecimal
string.  As explained in
the previous chapter, OIDs are not numeric values, but strings.  Comparisons
and similar operations on OIDs must access them as strings.  Once an OID has
been exported, you can access it by using its declared name.
For example, the hexadecimal
string representation of <Literal>DS_C_ATTRIBUTE</Literal> is contained in
<Literal>DS_C_ATTRIBUTE.elements</Literal>, and the length of this string is contained
in <Literal>DS_C_ATTRIBUTE.length</Literal>.
</Para>
<Sect3 Id="DCEADG.CDSXC.div.19">
<Title>Significance of Typed and Untyped Entry Names</Title>
<Para>Next are the static declarations for the lowest layer of objects that
make up the global name (distinguished name)
of the CDS directory entry you want to read.  These lowest-level
objects contain the string values for each part of the name.  Remember
that the first three parts of the name (excluding the global prefix
<Filename>/.../</Filename>, which is not represented) constitute the cell name, as
follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>/C=US/O=OSF/OU=DCE/
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>In this example, assume that GDS is being used as
the cell's global directory service, so the cell name is represented in
X.500 format, and each part of it is typed in the object
representation; for example, <Literal>DS_A_COUNTRY_NAME</Literal> is the
<Literal>DS_ATTRIBUTE_TYPE</Literal> in the <Literal>Country_String_Object</Literal>.  If you were
using DNS, the cell name might be something like the following:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>osf.org.dce
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>In this case, the entire string <Literal>osf.org.dce</Literal> would be held in a single 
object whose <Literal>DS_ATTRIBUTE_TYPE</Literal> would be <Literal>DSX_TYPELESS_RDN</Literal>.
</Para>
<Para><Literal>DSX_TYPELESS_RDN</Literal> is a special type that marks a name piece as not
residing in an X.500 namespace.  If the object resides under a
typed X.500 name, as is the case in the declared object structures, then
it serves as a delimiter for the end of the cell name GDS looks up, and
the beginning of the name that is passed to a CDS server in that
cell, assuming that the cell has access to GDS;
if not, such a name cannot be resolved.  In the following name, the
untyped portion is at the beginning:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>/.../osf.org.dce/hosts/zenocrate/self
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>In this case, the name is passed immediately by XDS via the local CDS
(and the GDA) to DNS for resolution of the cell name.  Thus, the typing
of entry names determines which directory service a global
directory entry name is sent to for resolution.
</Para>
</Sect3>
<Sect3 Id="DCEADG.CDSXC.div.20">
<Title>Static Declarations</Title>
<Para>The following are the static declarations you need:
<?sml-point-size 11></Para>
<InformalExample>
<Para><ProgramListing>
<?Pub _font TypeSize="8pt">
/*****************************************************************/
/* Here are the objects that contain the string values for each  */
/*  part of the CDS entry's global name...                       */

static OM_descriptor    Country_String_Object[] = {
 OM_OID_DESC(OM_CLASS, DS_C_AVA),
 OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_COUNTRY_NAME),
 {DS_ATTRIBUTE_VALUES, OM_S_PRINTABLE_STRING, OM_STRING("US")},
 OM_NULL_DESCRIPTOR
};

static OM_descriptor    Organization_String_Object[] = {
 OM_OID_DESC(OM_CLASS, DS_C_AVA),
 OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_ORG_NAME),
 {DS_ATTRIBUTE_VALUES, OM_S_PRINTABLE_STRING, OM_STRING("OSF")},
 OM_NULL_DESCRIPTOR
};

static OM_descriptor    Org_Unit_String_Object[] = {
 OM_OID_DESC(OM_CLASS, DS_C_AVA),
 OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_ORG_UNIT_NAME),
 {DS_ATTRIBUTE_VALUES, OM_S_PRINTABLE_STRING, OM_STRING("DCE")},
 OM_NULL_DESCRIPTOR
};

static OM_descriptor    Hosts_Dir_String_Object[] = {
 OM_OID_DESC(OM_CLASS, DS_C_AVA),
 OM_OID_DESC(DS_ATTRIBUTE_TYPE, DSX_TYPELESS_RDN),
 {DS_ATTRIBUTE_VALUES, OM_S_PRINTABLE_STRING, OM_STRING("hosts")},
 OM_NULL_DESCRIPTOR
};

static OM_descriptor    Tamburlaine_Dir_String_Object[] = {
 OM_OID_DESC(OM_CLASS, DS_C_AVA),
 OM_OID_DESC(DS_ATTRIBUTE_TYPE, DSX_TYPELESS_RDN),
 {DS_ATTRIBUTE_VALUES, OM_S_PRINTABLE_STRING, OM_STRING("tamburlaine")},
 OM_NULL_DESCRIPTOR
};

<?sml-need 6>static OM_descriptor    Self_Entry_String_Object[] = {
 OM_OID_DESC(OM_CLASS, DS_C_AVA),
 OM_OID_DESC(DS_ATTRIBUTE_TYPE, DSX_TYPELESS_RDN),
 {DS_ATTRIBUTE_VALUES, OM_S_PRINTABLE_STRING, OM_STRING("self")},
 OM_NULL_DESCRIPTOR
};
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<Para>The string objects are contained by a next-higher level of objects
that identify the strings as being pieces (RDNs)
of a fully qualified directory entry name (DN).
Thus, the <Literal>Country_RDN</Literal> object contains <Literal>Country_String_Object</Literal>
as the value of its <Literal>DS_AVAS</Literal> attribute; <Literal>Organization_RDN</Literal>
contains <Literal>Organization_String_Object</Literal>, and so on.
<?sml-point-size 11></Para>
<InformalExample>
<Para><ProgramListing>/*****************************************************************/
/* Here are the "relative distinguished name" objects. 

static OM_descriptor    Country_RDN[] = {
 OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
 {DS_AVAS, OM_S_OBJECT, {0, Country_String_Object}},
 OM_NULL_DESCRIPTOR
};

static OM_descriptor    Organization_RDN[] = {
 OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
 {DS_AVAS, OM_S_OBJECT, {0, Organization_String_Object}},
 OM_NULL_DESCRIPTOR
};

static OM_descriptor    Org_Unit_RDN[] = {
 OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
 {DS_AVAS, OM_S_OBJECT, {0, Org_Unit_String_Object}},
 OM_NULL_DESCRIPTOR
};

static OM_descriptor    Hosts_Dir_RDN[] = {
 OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
 {DS_AVAS, OM_S_OBJECT, {0, Hosts_Dir_String_Object}},
 OM_NULL_DESCRIPTOR
};

static OM_descriptor    Tamburlaine_Dir_RDN[] = {
 OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
 {DS_AVAS, OM_S_OBJECT, {0, Tamburlaine_Dir_String_Object}},
 OM_NULL_DESCRIPTOR
};

<?sml-need 5>static OM_descriptor    Self_Entry_RDN[] = {
 OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
 {DS_AVAS, OM_S_OBJECT, {0, Self_Entry_String_Object}},
 OM_NULL_DESCRIPTOR
};
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<Para>At the highest level, all the subobjects are gathered together in the
DN object named <Literal>Full_Entry_Name_Object</Literal>.
</Para>
<InformalExample>
<Para><ProgramListing>/***********************************************************/

static OM_descriptor    Full_Entry_Name_Object[] = {
     OM_OID_DESC(OM_CLASS, DS_C_DS_DN),
     {DS_RDNS, OM_S_OBJECT, {0, Country_RDN}},
     {DS_RDNS, OM_S_OBJECT, {0, Organization_RDN}},
     {DS_RDNS, OM_S_OBJECT, {0, Org_Unit_RDN}},
     {DS_RDNS, OM_S_OBJECT, {0, Hosts_Dir_RDN}},
     {DS_RDNS, OM_S_OBJECT, {0, Tamburlaine_Dir_RDN}},
     {DS_RDNS, OM_S_OBJECT, {0, Self_Entry_RDN}},
     OM_NULL_DESCRIPTOR
};
</ProgramListing></Para>
</InformalExample>
</Sect3>
<Sect3 Id="DCEADG.CDSXC.div.21">
<Title>Other Necessary Objects for <Function>ds_read(&thinsp;)</Function></Title>
<Para>The <Function>ds_read(&thinsp;)</Function> procedure takes requests in
the form of a <Literal>DS_C_ENTRY_INFO_SELECTION</Literal> class
object.  However, if you refer to the recipe for this object class in
Section 3.5, you will find that it is much simpler
than the name object;
it contains no subobjects, and
its declaration is straightforward.
</Para>
<Para>The value of the <Literal>DS_ALL_ATTRIBUTES</Literal> attribute specifies
that all attributes be read from the CDS entry, which is specified
in the <Literal>Full_Entry_Name_Object</Literal> variable.
</Para>
<Para>Note that the term <Symbol Role="Variable">attribute</Symbol> is used slightly differently in CDS and
XDS contexts.
In
XDS, attributes describe the values that can be held by various object
classes; they can be thought of as <FirstTerm>object fields.</FirstTerm>  In
CDS, attributes describe the values that can be associated with a
directory entry.
The following code fragment shows the definition of a
<Literal>DS_C_ENTRY_INFO_SELECTION</Literal> object:
</Para>
<InformalExample>
<Para><ProgramListing><?sml-need 7>static OM_descriptor    Entry_Info_Select_Object[] = {

    OM_OID_DESC(OM_CLASS, DS_C_ENTRY_INFO_SELECTION),
    {DS_ALL_ATTRIBUTES, OM_S_BOOLEAN, OM_TRUE},
    {DS_INFO_TYPE, OM_S_ENUMERATION, DS_TYPES_AND_VALUES},
    OM_NULL_DESCRIPTOR
};
</ProgramListing></Para>
</InformalExample>
</Sect3>
<Sect3 Id="DCEADG.CDSXC.div.22">
<Title>Miscellaneous Declarations</Title>
<Para>The following are declarations for miscellaneous variables:
<?sml-point-size 10></Para>
<InformalExample>
<Para><ProgramListing>
<?Pub _font TypeSize="8pt">
OM_workspace          xdsWorkspace;
     /* ...will contain handle to our "workspace"  */

DS_feature featureList[] = {

     { OM_STRING(OMP_O_DS_BASIC_DIR_CONTENTS_PKG), OM_TRUE },
     { 0 }
};
     /* ...list of service "packages" we will want from XDS  */

OM_private_object     session;
     /* ...will contain handle to a bound-to directory session  */


DS_status             dsStatus;
     /* ...status return from XDS calls  */

OM_return_code        omStatus;
     /* ...status return from XOM calls  */

OM_sint               dummy;
     /* ...for unsupported ds_read() argument  */

OM_private_object     readResultObject;
     /* ...to receive entry information read from CDS by "ds_read()" */

<?sml-need 5>
OM_type I_want_entry_object[] = {DS_ENTRY, OM_NO_MORE_TYPES};
OM_type I_want_attribute_list[] = {DS_ATTRIBUTES, OM_NO_MORE_TYPES};
OM_type I_want_attribute_value[] = {DS_ATTRIBUTE_VALUES, \
                                    OM_NO_MORE_TYPES};
     /* ...arrays to pass to "om_get()" to extract subobjects */
     /*  from the result object returned by "ds_read()"       */

<?sml-need 3>OM_value_position number_of_descriptors;
     /* ...to hold number of attribute descriptors returned   */
     /*  by "om_get()                                         */

OM_public_object entry;
     /* ...to hold public object returned by "om_get()"       */
<!-- -->
<!-- OM_string_length      offset;-->
<!--      /* ...to input/output string offsets for "om_read()"     */-->
<!-- -->
<!-- OM_string *valueRead;-->
<!--      /* ...to hold string value returned by "om_read()"       */-->
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
</Sect3>
<Sect3 Id="DCEADG.CDSXC.div.23">
<Title>The Main Program</Title>
<Para>This section describes the main program. Three calls usually precede
any use of XDS.
</Para>
<Para>First, <Function>ds_initialize(&thinsp;)</Function> is called to set up a <Symbol Role="Variable">workspace</Symbol>.
A workspace is a memory area in which XDS can generate objects
that will be used
to pass information to the application.  If the call is successful,
it returns a handle that must be saved for the <Function>ds_shutdown(&thinsp;)</Function> call.
If the call is unsuccessful, it returns
NULL, but this example does not check for errors.
</Para>
<InformalExample>
<Para><ProgramListing>xdsWorkspace = ds_initialize();
</ProgramListing></Para>
</InformalExample>
<Para>If GDS is being used as the global directory service, the service
packages are specified next.
Packages
consist of groups of objects, together with the associated supporting
interface functionality, designed to be used for some specific end.  For
example, to access the (X.500) Global Directory, specify
<Literal>DSX_GDS_PKG</Literal>.
This example uses the
basic XDS service so <Literal>DS_BASIC_DIR_CONTENTS_PKG</Literal> is specified.
The <Symbol Role="Variable">featureList</Symbol> parameter to <Function>ds_version(&thinsp;)</Function> is an array, not
an object, since packages are not being handled yet:
</Para>
<InformalExample>
<Para><ProgramListing>dsStatus = ds_version(featureList, xdsWorkspace);
</ProgramListing></Para>
</InformalExample>
<Para>Note that, if you are <Symbol Role="Variable">not</Symbol> using GDS as your global directory service
(in other words, if you are using XDS by itself), then you should <Symbol Role="Variable">not</Symbol>
call <Function>ds_version(&thinsp;)</Function>.
</Para>
<Para><?sml-need 8>From this point on, status is returned by XDS functions via a <Literal>DS_status</Literal>
variable. <Literal>DS_status</Literal> is a handle to a private object, whose value
is <Literal>DS_SUCCESS</Literal> (that is, NULL) if the call was successful.  If
something went wrong, the information in the (possibly complex) private
error object has to be analyzed through calls to <Function>om_get(&thinsp;)</Function>,
which is one
of the general-purpose object management functions that belongs to XDS's
companion interface XOM. Usage of <Function>om_get(&thinsp;)</Function> is demonstrated later on
in this program, but return status is not checked in this example.
</Para>
<Para>The third necessary call is to <Function>ds_bind(&thinsp;)</Function>.
This call brings up
the directory service, which binds to a Directory System Agent (DSA),
the GDS server,
through a Directory User Agent (DUA), the
GDS client.  The <Literal>DS_DEFAULT_SESSION</Literal>
parameter calls for a default session.  The alternative is to build and
fill out your own <Literal>DS_C_SESSION</Literal> object, specifying such things as
DSA addresses, and pass that.
The default is used in this example:
<?sml-point-size 11></Para>
<InformalExample>
<Para><ProgramListing>
dsStatus = ds_bind(DS_DEFAULT_SESSION, xdsWorkspace, &amp;session);
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
</Sect3>
<Sect3 Id="DCEADG.CDSXC.div.24">
<Title>Reading a CDS Attribute</Title>
<Para>At this point, you can read a set of object attributes from the cell
namespace entry.  Call <Function>ds_read(&thinsp;)</Function> with the two objects
that specify the entry to be read and the specific entry attribute you
want:
<?sml-point-size 11></Para>
<InformalExample>
<Para><ProgramListing>
<?Pub _font TypeSize="8pt">
dsStatus = ds_read(session, DS_DEFAULT_CONTEXT, Full_Entry_Name_Object,
          Entry_Info_Select_Object, &amp;readResultObject, &amp;dummy);
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<Para>The <Literal>DS_DEFAULT_CONTEXT</Literal> parameter could be substituted with a
<Literal>DS_C_CONTEXT</Literal> object, which would typically be reused during a series
of related XDS calls.  This object specifies and records
how GDS should
perform the operation, how much progress has been made in resolving a
name, and so on.
</Para>
<Para><?sml-need 33>If the call succeeds, the private object <Literal>readResultObject</Literal> contains
a series of <Literal>DS_C_ATTRIBUTE</Literal> subobjects, one for each attribute read
from the cell name entry.  A complete recipe for the <Literal>DS_C_READ_RESULT</Literal>
object can be found in Chapter 11, but the following is a skeletal outline
of the object's structure:
</Para>
<InformalExample>
<Para><ProgramListing>DS_C_READ_RESULT
        DS_ENTRY: object(DS_C_ENTRY_INFO)
<!--     (...The information extracted from the directory entry of the-->
<!--      target object.)-->
        DS_ALIAS_DEREFERENCED: OM_S_BOOLEAN
<!--     (I from DS_C_COMMON_RESULTS)-->
<!--     (...Indicates whether the name of the target object that was passed-->
<!--      to ds_read(\|) included an alias that was dereferenced to determine the-->
<!--      entry name.)-->
        DS_PERFORMER: object(DS_C_NAME)
<!--     (I from DS_C_COMMON_RESULTS)-->
<!--     (...Not supported in DCE.)-->

    DS_C_ENTRY_INFO
            DS_FROM_ENTRY: OM_S_BOOLEAN
<!--     (...Indicates whether the information was extracted from the specified object's-->
<!--      entry, rather than from a copy of the entry.)-->
            DS_OBJECT_NAME: object(DS_C_NAME)
<!--     (...The target object's distinguished name.)-->
            DS_ATTRIBUTES: one or more object(DS_C_ATTRIBUTE)
<!--     (I from DS_C_ATTRIBUTE_LIST)-->
<!--     (...The information extracted from the directory entry of the target-->
<!--      object.)-->

        DS_C_NAME == DS_C_DS_DN 
                DS_RDNS: object(DS_C_DS_RDN)

            DS_C_DS_RDN
                    DS_AVAS: object(DS_C_AVA)

                DS_C_AVA
                        DS_ATTRIBUTE_TYPE: OID string
                        DS_ATTRIBUTE_VALUES: anything

        DS_C_ATTRIBUTE <Symbol Role="Variable">&mdash;one for each attribute read</Symbol>
                DS_ATTRIBUTE_TYPE: OID string
<!--     (...The attribute type that indicates the class of information given by-->
<!--      this attribute.)-->
                DS_ATTRIBUTE_VALUES: anything
<!--     (...The values themselves.  Hooray!)-->
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>        DS_C_ATTRIBUTE
                DS_ATTRIBUTE_TYPE: OID string
                DS_ATTRIBUTE_VALUES: anything
</ProgramListing></Para>
</InformalExample>
<Para>Figure 3-6 illustrates the general object structure of a
<Literal>DS_C_READ_RESULT</Literal>, showing only the object-valued 
attributes, and only one <Literal>DS_C_ATTRIBUTE</Literal> subobject.
<!-- Figure x: -->
<!-- pix/objresult1.pic-->
</Para>
<?sml-need 5i>
<Figure>
<Title>The DS_C_READ_RESULT Object Structure</Title>
<Graphic Format="EPS" Entityref="DCEADG.CDSXC.pic.6"></Graphic>
</Figure>
<?sml-space .5>
</Sect3>
<Sect3 Id="DCEADG.CDSXC.div.25">
<Title>Handling the Result Object</Title>
<Para>The next goal is to extract
the instances of the
<Literal>DS_C_ATTRIBUTE</Literal> subsubclass, one for each attribute read,
from the returned object.
The first step is to make a public copy of
<Literal>readResultObject</Literal>, which is a <Symbol Role="Variable">private</Symbol> object, and therefore
does not allow access to the object descriptors themselves.
Using the XOM <Function>om_get(&thinsp;)</Function> function,
you can make a public copy of <Literal>readResultObject</Literal>, and at the same time
specify that only the relevant parts of it be preserved in the copy.  Then, with
a couple of calls to <Function>om_get(&thinsp;)</Function>, you can reduce the object to manageable
size, leaving a superobject whose immediate subobjects are
fairly easily accessed.
</Para>
<Para><?sml-need 12>The <Function>om_get(&thinsp;)</Function> function
takes as its third input parameter an <Literal>OM_type_list</Literal>, which is
an array of <Literal>OM_type</Literal>.
Possible parameters are <Literal>DS_ENTRY</Literal>, <Literal>DS_ATTRIBUTES</Literal>,
<Literal>DS_ATTRIBUTE_VALUES</Literal>, and
anything that can legitimately appear in an object
descriptor's <Literal>type</Literal> field.
The types specified in this parameter are interpreted
according to the options specified in the preceding parameter.
For example, the relevent attribute from the read result is
<Literal>DS_ENTRY</Literal>.
It contains the <Literal>DS_C_ENTRY_INFO</Literal> object,
which in turn contains the <Literal>DS_C_ATTRIBUTE</Literal> objects.
The <Literal>DS_C_ATTRIBUTE</Literal> objects contain the
data read from the cell directory name entry.
Therefore, you should specify the
<Literal>OM_EXCLUDE_ALL_BUT_THESE_TYPES</Literal> option,
which has the effect of excluding
everything but the contents of the object's <Literal>DS_ENTRY</Literal> type attribute.
</Para>
<Para>The <Literal>OM_EXCLUDE_SUBOBJECTS</Literal> option is also ORed
into the parameter.
Why would you not preserve the subobjects of
<Literal>DS_C_ENTRY_INFO</Literal>?
Because <Function>om_get(&thinsp;)</Function>
works only on private, not on public, objects.
If you were to use <Function>om_get(&thinsp;)</Function> on the
entire object substructure, you would not be able to continue getting
the subobjects, and
instead you would have to follow the object pointers down to the
<Literal>DS_C_ATTRIBUTE</Literal>.  However, when <Function>om_get(&thinsp;)</Function> excludes
subobjects from a copy,
it does not really leave them out; it merely leaves the subobjects private,
with a handle to the private objects where pointers would have been.
This allows you to
continue to call <Function>om_get(&thinsp;)</Function> as long as there are more subobjects.
</Para>
<Para><?sml-need 20>The following is the first call:
</Para>
<InformalExample>
<Para><ProgramListing>/* The DS_C_READ_RESULT object that ds_read() returns has  */
/* one subobject, DS_C_ENTRY_INFO; it in turn has two sub- */
/* objects, that is a DS_C_NAME which holds the object's   */
/* distinguished name (which we don't care about here),    */
/* and a DS_C_ATTRIBUTE which contains the attribute info  */
/* we read; that one we want.  So we climb down to it ...  */
/* This om_get() will "return" the entry-info object ...   */

omStatus = om_get(readResultObject,
                  OM_EXCLUDE_ALL_BUT_THESE_TYPES +
                  OM_EXCLUDE_SUBOBJECTS,
                  I_want_entry_object,
                  OM_FALSE,
                  OM_ALL_VALUES,
                  OM_ALL_VALUES,
                  &amp;entry,
                  &amp;number_of_descriptors);
</ProgramListing></Para>
</InformalExample>
<Para>The <Literal>number_of_descriptors</Literal> parameter contains the number of
attribute descriptors returned in the public copy,
not in any excluded subobjects.
</Para>
<Para>If an XOM function is successful, it returns an <Literal>OM_SUCCESS</Literal> code.
Unsuccessful
calls to XOM functions do not return error objects, but rather return
simple error codes.
The interface assumes that, if the XOM
function does not accept your object, then you will not be able to get much
information from any further objects.
The return status is not checked in this example.
</Para>
<Para><?sml-need 19>The return parameter <Literal>entry</Literal> should now contain a pointer to the
<Literal>DS_C_ENTRY_INFO</Literal> object with the following immediate 
structure.  (The number of instances of <Literal>DS_ATTRIBUTES</Literal> depends 
on the number of attributes read from the entry.)
</Para>
<InformalExample>
<Para><ProgramListing>
    DS_C_ENTRY_INFO
    DS_FROM_ENTRY: OM_S_BOOLEAN
    DS_OBJECT_NAME: object(DS_C_NAME)
    DS_ATTRIBUTES: object(DS_C_ATTRIBUTE)
    <Replaceable>DS_C_ATTRIBUTE</Replaceable>
    <Replaceable>DS_ATTRIBUTE_TYPE</Replaceable>: OID string
    <Replaceable>DS_ATTRIBUTE_VALUES</Replaceable>: anything
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>    
    DS_ATTRIBUTES: object(DS_C_ATTRIBUTE)
                          object(DS_C_ATTRIBUTE)
    <Replaceable>DS_C_ATTRIBUTE</Replaceable>
    <Replaceable>DS_ATTRIBUTE_TYPE</Replaceable>: OID string
    <Replaceable>DS_ATTRIBUTE_VALUES</Replaceable>: anything
</ProgramListing></Para>
</InformalExample>
<Para>The italics indicate private subobjects.  Figure 3-7 shows the 
<Literal>DS_C_ENTRY_INFO</Literal> object.  Only one
instance of a <Literal>DS_C_ATTRIBUTE</Literal> subobject is 
shown in the figure; usually there are several such subobjects, 
all at the same level, each containing information about one of 
the attributes read from the entry.  These subobjects are represented 
in <Literal>DS_C_ENTRY_INFO</Literal> as a series of descriptors of type
<Literal>DS_ATTRIBUTES</Literal>, each of which has as its value a 
separate <Literal>DS_C_ATTRIBUTE</Literal> subobject.
<!-- Figure x: -->
<!-- pix/objresult2.pic-->
</Para>
<?sml-need 4i>
<Figure>
<Title>The DS_C_ENTRY_INFO Object Structure</Title>
<Graphic Format="EPS" Entityref="DCEADG.CDSXC.pic.7"></Graphic>
</Figure>
<?sml-space .5>
<?sml-space .5>
<Para>Now extract the separate attribute values of the entry that
was read.
These were returned as separate object values of <Literal>DS_ATTRIBUTES</Literal>;
each one has an object class of <Literal>DS_C_ATTRIBUTE</Literal>.  To return any one of
these subobjects, a second call to <Function>om_get(&thinsp;)</Function> is necessary, as follows:
</Para>
<InformalExample>
<Para><ProgramListing><?sml-need 30>/* The second om_get() returns one selected subobject      */
/* from the DS_C_ENTRY_INFO subobject we just got.  The    */
/* contents of "entry" as we enter this call is the        */
/* private subobject which is the value of DS_ATTRIBUTES.  */
/* If we were to make the following call with the          */
/* OM_EXCLUDE_SUBOBJECTS and without the                   */
/* OM_EXCLUDE_ALL_BUT_THESE_VALUES flags, we would get     */
/* back an object consisting of six private subobjects,    */
/* one for each of the attributes returned.  Note the      */
/* values for initial and limiting position: "2"           */
/* specifies that we want only the third DS_C_ATTRIBUTE    */
/* subobject to be gotten (the subobjects are numbered     */
/* from 0, not from 1), and the "3" specifies that we want */
/* no more than that--in other words, the limiting value   */
/* must always be one more than the initial value if the   */
/* latter is to have any effect.                           */
/* OM_EXCLUDE_ALL_BUT_THESE_VALUES is likewise required    */ 
/* for the initial and limiting values to have any         */
/* effect ...                                              */

omStatus = om_get(entry->value.object.object,
                  OM_EXCLUDE_ALL_BUT_THESE_TYPES
                  + OM_EXCLUDE_SUBOBJECTS
                  + OM_EXCLUDE_ALL_BUT_THESE_VALUES,
                  I_want_attribute_list,
                  OM_FALSE,
                  ((OM_value_position) 2),
                  ((OM_value_position) 3),
                  &amp;entry,
                  &amp;number_of_descriptors);
</ProgramListing></Para>
</InformalExample>
<Para>Note the value that is passed as the first parameter.
Since <Function>om_get(&thinsp;)</Function> does not work on public
objects, pass it the handle of the private subobject explicitly.  To
do this you have to know the arrangement of the descriptor's value union,
which is defined in <Filename>xom.h</Filename>. 
</Para>
</Sect3>
<Sect3 Id="DCEADG.CDSXC.div.26">
<Title>Representation of Object Values</Title>
<Para>The following is the layout of the <Literal>object</Literal> field in a descriptor's
<Literal>value</Literal> union:
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct {
	OM_uint32       padding;
	OM_object       object;
} OM_padded_object;
</ProgramListing></Para>
</InformalExample>
<Para>The following is the layout of the <Literal>value</Literal> union itself:
</Para>
<InformalExample>
<Para><ProgramListing>typedef union OM_value_union {
	OM_string         string;
	OM_boolean        boolean;
	OM_enumeration    enumeration;
	OM_integer        integer;
	OM_padded_object  object;
} OM_value;
</ProgramListing></Para>
</InformalExample>
<Para>The following is the layout of the descriptor itself:
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct OM_descriptor_struct {
	OM_type	                type;
	OM_syntax               syntax;
	union OM_value_union    value;
} OM_descriptor;
</ProgramListing></Para>
</InformalExample>
<Para>Thus, if <Literal>entry</Literal> is a pointer to the <Literal>DS_C_ENTRY_INFO</Literal>
object, then the private handle to the <Literal>DS_C_ATTRIBUTE</Literal> object 
you want next is the following:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>entry&minus;>value.object.object
</UserInput></ProgramListing></Para>
</InformalExample>
<?sml-break>
<?sml-need 10>
</Sect3>
<Sect3 Id="DCEADG.CDSXC.div.27">
<Title>Extracting an Attribute Value</Title>
<Para>The last call yielded one separate
<Literal>DS_C_ATTRIBUTE</Literal> subsubobject from the original returned result object:
</Para>
<InformalExample>
<Para><ProgramListing>DS_C_ATTRIBUTE
	DS_ATTRIBUTE_TYPE: OID string
	DS_ATTRIBUTE_VALUES: anything
</ProgramListing></Para>
</InformalExample>
<Para>Figure 3-8 illustrates what is left.
<!-- pix/objresult3.pic-->
</Para>
<Figure>
<Title>The DS_C_ATTRIBUTE Object Structure</Title>
<Graphic Format="EPS" Entityref="DCEADG.CDSXC.pic.8"></Graphic>
</Figure>
<?sml-space .4>
<?sml-space .5>
<Para>A final call to <Function>om_get(&thinsp;)</Function> returns the single object descriptor
that contains the actual value of the single attribute you selected from the
returned object:
</Para>
<InformalExample>
<Para><ProgramListing>omStatus = om_get(entry->value.object.object,
                  OM_EXCLUDE_ALL_BUT_THESE_TYPES,
                  I_want_attribute_value,
                  OM_FALSE,
                  OM_ALL_VALUES,
                  OM_ALL_VALUES,
                  &amp;entry,
                  &amp;number_of_descriptors);
</ProgramListing></Para>
</InformalExample>
<Para>At this point, the value of <Literal>entry</Literal> is the base address of an object
descriptor whose <Literal>entry&minus;>type</Literal> is <Literal>DS_ATTRIBUTE_VALUES</Literal>.
Depending on the value found in <Literal>entry&minus;>syntax</Literal>, the value of
the attribute can be read from <Literal>entry&minus;>value.string</Literal>,
<Literal>entry&minus;>value.integer</Literal>,
<Literal>entry&minus;>value.boolean</Literal>, or <Literal>entry&minus;>value.enumeration</Literal>.  
</Para>
<Para>For example, suppose the value of <Literal>entry&minus;>syntax</Literal> is 
<Literal>OM_S_OCTET_STRING</Literal>.  The attribute value, represented as an 
octet string (<Symbol Role="Variable">not</Symbol> terminated by a NULL), is found in 
<Literal>entry&minus;>value.string.elements</Literal>; its length
is found in <Literal>entry&minus;>value.string.length</Literal>.
</Para>
<Para><?sml-need 4>You can check any attribute value against the value you get from 
the <Command>cdscp</Command> command by entering the following:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>cdscp show object /.:/hosts/tamburlaine/self
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>For further information on <Command>cdscp</Command>, see the &DCEAr;.
</Para>
<Para>Note that you can always call <Function>om_get(&thinsp;)</Function> to get
the <Symbol Role="Variable">entire</Symbol> returned object from an
XDS call.  This yields a full structure of object descriptors that you can manipulate
like any other data structure.  To do this with the <Function>ds_read(&thinsp;)</Function> return object
would have required the following call:
</Para>
<InformalExample>
<Para><ProgramListing>/* make a public copy of ENTIRE object...   */

omStatus = om_get(readResultObject,
                  OM_NO_EXCLUSIONS,
                  ((OM_type_list) 0),
                  OM_FALSE,
                  ((OM_value_position) 0),
                  ((OM_value_position) 0),
                  &amp;entry,
                  &amp;number_of_descriptors);
</ProgramListing></Para>
</InformalExample>
<Para>At the end of every XDS session, you need to unbind from GDS and then deallocate
the XDS and XOM structures and other storage.  You must also explicitly deallocate
any service-generated objects, whether public or private, with calls to <Function>om_delete(&thinsp;)</Function>, as follows:
</Para>
<InformalExample>
<Para><ProgramListing>
/* delete service-generated public or private objects... */

omStatus = om_delete(readResultObject);
omStatus = om_delete(entry);

/* unbind from the GDS...  */
dsStatus = ds_unbind(session);

/* close down the workspace... */
dsStatus = ds_shutdown(xdsWorkspace);

exit();
</ProgramListing></Para>
</InformalExample>
</Sect3>
</Sect2>
<Sect2 Id="DCEADG.CDSXC.div.28">
<Title>Creating New CDS Entry Attributes</Title>
<Para>The following subsections provide
the procedure and some code examples for creating new
CDS entry attributes.
</Para>
<Sect3 Id="DCEADG.CDSXC.div.29">
<Title>Procedure for Creating New Attributes</Title>
<Para>To create new attributes of your own on cell namespace entries, you must do
the following:
</Para>
<OrderedList>
<ListItem>
<Para>Allocate a new ISO OID for the new attribute.  For
information on how to do this, see Chapter 2 of this guide and the &DCEAg;.
</Para>
</ListItem>
<ListItem>
<Para>Enter the new attribute's name and OID in the file
<Filename>/.:/opt/dcelocal/etc/cds_attributes</Filename>.  
This text file contains OID-to-readable string mappings that are used,
for example, by <Command>cdscp</Command> when it displays
CDS entry attributes.  Each entry also gives a syntax for 
reading the information in the entry itself.  This should be congruent 
with the format of the data
you intend to write in the attribute.  For more information about the
<Literal>cds_attributes</Literal> file, see the &DCEAg;.
</Para>
</ListItem>
<ListItem>
<Para>In the <Filename>xdscds.h</Filename> header file, define an appropriate OID string
constant to represent the new attribute.
</Para>
<Para>For example, the following shows the <Filename>xdscds.h</Filename> definition for the
CDS <Literal>CDS_Class</Literal> attribute:
</Para>
<InformalExample>
<Para>
<ProgramListing>
<UserInput>
#define OMP_O_DSX_A_CDS_Class      "\x2B\x16\x01\x03\x0F"
</UserInput>
</ProgramListing>
</Para>
</InformalExample>
<Para>Note the XDS internal form of the name. This is what <Literal>DSX_A_CDS_Class</Literal>
looks like when it has been exported using
<Literal>OM_EXPORT</Literal> in an application, as all OIDs
must be.  Thus, if you wanted to create a CDS attribute called
<Literal>CDS_Brave_New_Attrib</Literal>, you would obtain an OID from your
administrator and
add the following line to <Filename>xdscds.h</Filename>:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>
#define OMP_O_DSX_A_CDS_Brave_New_Attrib "<Symbol Role="Variable">your_OID</Symbol>"
</UserInput></ProgramListing></Para>
</InformalExample>
</ListItem>
<ListItem>
<Para>In an application, call the XDS <Function>ds_modify_entry(&thinsp;)</Function> routine to add the
attribute to the cell namespace entry of your choice.
</Para>
</ListItem>
</OrderedList>
</Sect3>
<Sect3 Id="DCEADG.CDSXC.div.30">
<Title>Coding Examples</Title>
<Para>In the following code fragments, a set of declarations similar to those in
the previous examples is assumed. 
</Para>
<Para>The <Function>ds_modify_entry(&thinsp;)</Function> function, which is called to add new attributes
to an entry or to write new values into existing attributes, requires
a <Literal>DS_C_ENTRY_MOD_LIST</Literal> input object whose contents specify the
attributes and values to be written to the entry.  The name, as always, is
specified in a <Literal>DS_C_DS_DN</Literal> object.  The following is
a static declaration of
such a list, which consists of two attributes:
</Para>
<InformalExample>
<Para><ProgramListing>static OM_descriptor    Entry_Modification_Object_1[] = {
  OM_OID_DESC(OM_CLASS, DS_C_ENTRY_MOD),
  OM_OID_DESC(DS_ATTRIBUTE_TYPE, DSX_A_CDS_Brave_New_Attrib),
  {DS_ATTRIBUTE_VALUES, OM_S_PRINTABLE_STRING,
	OM_STRING("O brave new attribute")},
  {DS_MOD_TYPE, OM_S_ENUMERATION, DS_ADD_ATTRIBUTE},
  OM_NULL_DESCRIPTOR
};

static OM_descriptor    Entry_Modification_Object_2[] = {
  OM_OID_DESC(OM_CLASS, DS_C_ENTRY_MOD),
  OM_OID_DESC(DS_ATTRIBUTE_TYPE, DSX_A_CDS_Class),
  {DS_ATTRIBUTE_VALUES, OM_S_PRINTABLE_STRING, \
      OM_STRING("Miscellaneous")},
  {DS_MOD_TYPE, OM_S_ENUMERATION, DS_ADD_ATTRIBUTE},
  OM_NULL_DESCRIPTOR
};

static OM_descriptor    Entry_Modification_List_Object[] = {
  OM_OID_DESC(OM_CLASS, DS_C_ENTRY_MOD_LIST),
  {DS_CHANGES, OM_S_OBJECT, {0, Entry_Modification_Object_1}},
  {DS_CHANGES, OM_S_OBJECT, {0, Entry_Modification_Object_2}},
  OM_NULL_DESCRIPTOR
};
</ProgramListing></Para>
</InformalExample>
<Para>A full description of this object can be found in Section 3.5.
There could be any number of
additional attribute changes in the list; this would mean additional
<Literal>DS_C_ENTRY_MOD</Literal> objects declared, and an additional <Literal>DS_CHANGES</Literal>
descriptor declared and initialized in the <Literal>DS_C_ENTRY_MOD_LIST</Literal>
object. 
</Para>
<Para>With the <Literal>DS_C_ENTRY_MOD_LIST</Literal> class object having been declared as shown
previously, the following code fragment illustrates
how to call XDS to write a new attribute value (actually two new
values since two attributes are contained in the list object).  Note that any
of the attributes may be new, although the entry itself must already exist.
</Para>
<InformalExample>
<Para><ProgramListing>dsStatus = ds_modify_entry(session,    /* Directory session */
                                     /* from "ds_bind()"       */
         DS_DEFAULT_CONTEXT, /* Usual directory context        */
         Full_Entry_Name_Object, /* Entry name object          */
         Entry_Modification_List_Object, /* Entry Modification */
                                         /* object             */
                 &amp;dummy);        /* Unsupported argument   */
</ProgramListing></Para>
</InformalExample>
<Para>If the entire entry is new, you must call <Function>ds_add_entry(&thinsp;)</Function>. This function
requires an input object of class <Literal>DS_C_ATTRIBUTE_LIST</Literal>, whose contents
specify the attributes (and values) to be attached to the new entry.
Following is the static declaration for an attribute list that
contains three attributes:
<?sml-point-size 11></Para>
<InformalExample>
<Para><ProgramListing>
<?Pub _font TypeSize="8pt">
static OM_descriptor    Class_Attribute_Object[] = {
     OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE),
     OM_OID_DESC(DS_ATTRIBUTE_TYPE, DSX_A_CDS_Class),
     {DS_ATTRIBUTE_VALUES, OM_S_PRINTABLE_STRING, OM_STRING("Printer")},
     OM_NULL_DESCRIPTOR
};

static OM_descriptor    ClassVersion_Attribute_Object[] = {
     OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE),
     OM_OID_DESC(DS_ATTRIBUTE_TYPE, DSX_A_CDS_ClassVersion),
     {DS_ATTRIBUTE_VALUES, OM_S_PRINTABLE_STRING, OM_STRING("1.0")},
     OM_NULL_DESCRIPTOR
};

<?sml-need 6>static OM_descriptor    My_Own_Attribute_Object[] = {
     OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE),
     OM_OID_DESC(DS_ATTRIBUTE_TYPE, DSX_A_CDS_My_OwnAttribute),
     {DS_ATTRIBUTE_VALUES, OM_S_PRINTABLE_STRING, OM_STRING("zorro")},
     OM_NULL_DESCRIPTOR
};

static OM_descriptor    Attribute_List_Object[] = {
     OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE_LIST),
     {DS_ATTRIBUTES, OM_S_OBJECT, {0, Class_Attribute_Object}},
     {DS_ATTRIBUTES, OM_S_OBJECT, {0, ClassVersion_Attribute_Object}},
     {DS_ATTRIBUTES, OM_S_OBJECT, {0, My_Own_Attribute_Object}},
     OM_NULL_DESCRIPTOR
};
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<Para>The <Function>ds_add_entry(&thinsp;)</Function> function
also requires a <Literal>DS_C_DS_DN</Literal> class object
containing the new entry's full name, for example:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>/.../osf.org.dce/subsys/doc/my_book
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>where every member of the name exists except for the last one, <Literal>my_book</Literal>.
Assuming that <Literal>Full_Entry_Name_Object</Literal> is a <Literal>DS_C_DS_DN</Literal> object,
the following code shows what the call would look like:
</Para>
<InformalExample>
<Para><ProgramListing>
dsStatus = ds_add_entry(session,    /* Directory session   */
                                      /* from "ds_bind()"      */
           DS_DEFAULT_CONTEXT,  /* Usual directory context     */
           Full_Entry_Name_Object,    /* Name of new entry     */
           Attribute_List_Object,     /* Attributes to be      */
                     /* attached to new entry, with values     */
           &amp;dummy);               /* Unsupported argument  */
</ProgramListing></Para>
</InformalExample>
</Sect3>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.CDSXC.div.31">
<Title>Object-Handling Techniques</Title>
<Para>The following subsections describe
the use of XOM and discuss dynamic object
creation.
</Para>
<Sect2 Id="DCEADG.CDSXC.div.32">
<Title>Using XOM to Access CDS</Title>
<Para>The following code fragments demonstrate an alternative way to set up the
entry modification object for a <Function>ds_modify_entry(&thinsp;)</Function> call, mainly for
the sake of showing how the <Function>om_put(&thinsp;)</Function> and <Function>om_write(&thinsp;)</Function> functions
are used. 
</Para>
<Para>The following technique is used to initialize the modification object:
</Para>
<OrderedList>
<ListItem>
<Para>The <Function>om_create(&thinsp;)</Function> function
is called to generate a private object of a specified
class.
</Para>
</ListItem>
<ListItem>
<Para>The <Function>om_put(&thinsp;)</Function> function
is called to copy statically declared attributes into
a declared private object.
</Para>
</ListItem>
<ListItem>
<Para>The <Function>om_write(&thinsp;)</Function> function
is called to write the value string, which is to be
assigned to the attribute, into the private object.
</Para>
</ListItem>
<ListItem>
<Para>The <Function>om_get(&thinsp;)</Function> function
is called to make the private object public.
</Para>
</ListItem>
<ListItem>
<Para>The object is now public, and its
address is inserted into the
<Literal>DS_C_ENTRY_MOD_LIST</Literal> object's <Literal>DS_CHANGES</Literal> attribute.
</Para>
</ListItem>
</OrderedList>
<Para><?sml-need 18>The following new declarations are necessary:
<?sml-point-size 11></Para>
<InformalExample>
<Para><ProgramListing>
<?Pub _font TypeSize="8pt">
OM_private_object newAttributeMod_priv;
     /* ...handle to a private object to "om_put()" to                */

OM_public_object newAttributeMod_pub;
     /* ...to hold public object from "om_get()"                      */

OM_type types_to_include[] = {DS_ATTRIBUTE_TYPE, DS_ATTRIBUTE_VALUES,
                              DS_MOD_TYPE, OM_NO_MORE_TYPES};
     /* ...that is, all attribute values of the Entry Modification    */
     /*  object.  For "om_put()" and "om_get()"                       */

char *my_string = "O brave new attribute"; 
     /* ...value I want to write into attribute                       */

OM_value_position number_of_descriptors;
     /* ...to hold value returned by "om_get()"                       */
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<Para>First, use XOM to generate a private object of the desired class:
<?sml-point-size 11></Para>
<InformalExample>
<Para><ProgramListing>
<?Pub _font TypeSize="8pt">
omStatus = om_create(DS_C_ENTRY_MOD,  /* Class of object              */
                 OM_TRUE,   /* Initialize attributes per defaults     */
                 xdsWorkspace,  /* Our workspace handle               */
                 &amp;newAttributeMod_priv);  /* Created object handle    */
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<Para>Next, copy the public object's attributes into the private object:
<?sml-point-size 11></Para>
<InformalExample>
<Para><ProgramListing>
<?Pub _font TypeSize="8pt">
omStatus = om_put(newAttributeMod_priv, /* Private object to copy     */
                                        /*  attributes into           */
                 OM_REPLACE_ALL, /* Which attributes to replace in    */
                                  /*  destination object              */
                 Entry_Modification_Object, /* Source object to copy  */
                                             /*  attributes from      */
                 types_to_include, /* List of attribute types we      */
                                    /* want copied                    */
                 0, 0); /* Start-stop index for multivalued           */
                         /*  attributes; ignored with OM_REPLACE_ALL  */
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<Para>Since <Function>om_put(&thinsp;)</Function> ignores the class of the source object (the object
from which attributes are being copied), it is not necessary to declare
class descriptors for the source objects.  In other words, the static
declarations could have omitted the <Literal>OM_CLASS</Literal> initializations if this
technique were being used, for example:
</Para>
<InformalExample>
<Para><ProgramListing><?sml-need 10>static OM_descriptor    Entry_Modification_Object_2[] = {

/*     OM_OID_DESC(OM_CLASS, DS_C_ENTRY_MOD),              */
/*     Not needed for "om_put()" ...                       */

     OM_OID_DESC(DS_ATTRIBUTE_TYPE, DSX_A_CDS_Class),
     {DS_ATTRIBUTE_VALUES, OM_S_PRINTABLE_STRING, \
       OM_STRING("Miscellaneous")},
     {DS_MOD_TYPE, OM_S_ENUMERATION, DS_ADD_ATTRIBUTE},
     OM_NULL_DESCRIPTOR
};
</ProgramListing></Para>
</InformalExample>
<Para>The <Literal>OM_CLASS</Literal> was already properly initialized by <Function>om_create(&thinsp;)</Function>.
</Para>
<Para>Next, write the attribute value string into the private object:
<?sml-point-size 11></Para>
<InformalExample>
<Para><ProgramListing>
<?Pub _font TypeSize="8pt">
omStatus = om_write(newAttributeMod_priv,/* Private object to write to */
                    DS_ATTRIBUTE_VALUES, /* Attribute type whose value */
                                         /*  we're writing             */
                    0, /* Descriptor index if attribute is multivalued */
                    OM_S_PRINTABLE_STRING, /* Syntax of value          */
                    0, /* Offset in source string to write from        */
                    my_string); /* Source string to write from         */
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<Para><?sml-need 10>Now make the whole thing public again:
<?sml-point-size 11></Para>
<InformalExample>
<Para><ProgramListing>
<?Pub _font TypeSize="8pt">
omStatus = om_get(newAttributeMod_priv, /* Private object to get       */
                  0,                    /* Get everything              */
                  types_to_include,     /* All attribute types         */
                  0,                    /* Unsupported argument        */
                  0, 0, /* Start-stop descriptor index for multival-   */
                        /*  ued attributes; ignored in this case       */
                  &amp;newAttributeMod_pub, /* Pointer to returned copy    */
                  &amp;number_of_descriptors); /* Number of attribute      */
                                           /*  descriptors returned    */
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<Para>Finally, insert the address of the subobject into its superobject:
</Para>
<InformalExample>
<Para><ProgramListing>Entry_Modification_List_Object[1].value.object.object = \
  newAttributeMod_pub;
</ProgramListing></Para>
</InformalExample>
</Sect2>
<Sect2 Id="DCEADG.CDSXC.div.33">
<Title>Dynamic Creation of Objects</Title>
<!-- Coding technique discussed with Helmut: you can declare "template"-->
<!--  static descriptor arrays and use these as sources to om_put(\|) from-->
<!--  to om_create(\|)'d class instances.  In an application of any size -->
<!--  this should cut down the declarations sizably.  Recode the first-->
<!--  example with this method.-->
<Para>Objects can be completely dynamically allocated and initialized; however,
you have to implement the routines to do this yourself.
The examples in this section are code fragments; for complete examples,
see Chapter 7.
</Para>
<Para>Initialization of object structures can be automated by declaring macros
or functions to do this.  For example, the following macro initializes
one object descriptor with a full set of appropriate values:
</Para>
<InformalExample>
<Para><ProgramListing>/* Put a C-style (NULL-terminated) string into an object and */
/* set all the other descriptor fields to requested values   */
#define FILL_OMD_STRING( desc, index, typ, syntx, val ) \
        desc[index].type = typ; \
        desc[index].syntax = syntx; \
        desc[index].value.string.length = \
          (OM_element_position)strlen(val); \
        desc[index].value.string.elements = val;
</ProgramListing></Para>
</InformalExample>
<Para><?sml-need 6>When generating objects, use <Function>malloc(&thinsp;)</Function> to allocate
space for
the number of objects desired, and then use macros (or functions) such as the
preceding
one to initialize the descriptors.  The following code fragment shows how this
can be done for the top-level object of a <Literal>DS_C_DS_DN</Literal> object, such as the one
described near the beginning of this chapter.  Recall that <Literal>DS_C_DS_DN</Literal>
has a separate <Literal>DS_RDNS</Literal> descriptor for each name piece in the
full name.
<?sml-break><?sml-point-size 11></Para>
<InformalExample>
<Para><ProgramListing>
<?Pub _font TypeSize="8pt">
/* Calculate number of "DS_RDNS" attributes there should be ... */
numberOfPieces = <Replaceable>number_of_name_pieces;</Replaceable>

/* Allocate space for that many descriptors, plus one for the   */
/* object class at the front, and a NULL descriptor at the back */

Name_Object = (OM_object)malloc((numberOfPieces + 2) \
 * sizeof(OM_descriptor));
if(Name_Object == NULL)                    /* "malloc()" failed */
return OM_MEMORY_INSUFFICIENT;

/* Initialize it as a DS_C_DS_DN object by placing that class   */
/*  identifier in the first position...                         */

FILL_OMD_XOM_STRING(Name_Object, 0, OM_CLASS,
    OM_S_OBJECT_IDENTIFIER_STRING, DS_C_DS_DN)
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<Para><?sml-need 5>Note that all these steps would have to be repeated for each of the
<Literal>DS_C_DS_RDN</Literal> objects required as attribute values of the <Literal>DS_C_DS_DN</Literal>.
Then a tier of <Literal>DS_C_AVA</Literal> objects would have to be created in the
same way, since each of the <Literal>DS_C_DS_RDN</Literal>s requires one of them as
<Symbol Role="Variable">its</Symbol> attribute value.
</Para>
<Para>You could now use <Function>om_create(&thinsp;)</Function> and <Function>om_put(&thinsp;)</Function> to generate a private
copy of this object, if so desired.
</Para>
<Para>The application is responsible for managing the memory it allocates
for such dynamic object creation.
</Para>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.CDSXC.div.34">
<Title>XDS/CDS Object Recipes</Title>
<Para>The following subsections contain shorthand for object classes.
For example, if you look at the reference pages for the <Literal>ds_</Literal><Symbol Role="Variable">*</Symbol><Literal>(&thinsp;)</Literal>
functions, you will see that an object of class <Literal>DS_C_NAME</Literal> is required
to hold entry names you want to pass to the call, <Symbol Role="Variable">not</Symbol> <Literal>DS_C_DS_DN</Literal>
as is stated in this chapter.  However, <Literal>DS_C_NAME</Literal> is in fact an abstract
class with only one subclass <Literal>DS_C_DS_DN</Literal> so, in this
chapter, <Literal>DS_C_DS_DN</Literal> is used.
</Para>
<Sect2 Id="DCEADG.CDSXC.div.35">
<Title>Input XDS/CDS Object Recipes</Title>
<Para>In general, the objects you work with in an XDS/CDS application
fall into two categories:
</Para>
<ItemizedList>
<ListItem>
<Para>Objects you have to supply as <Symbol Role="Variable">input parameters</Symbol> to XDS functions
</Para>
</ListItem>
<ListItem>
<Para>Objects returned to you as <Symbol Role="Variable">output</Symbol> by XDS functions
</Para>
</ListItem>
</ItemizedList>
<Para>This section describes only the first category,
since you have to construct these input objects yourself.
</Para>
<Para>Table 3-1 shows XDS functions and the objects given to them
as input parameters.
</Para>
<Para><?sml-need 5>Only items significant to CDS are listed in the table.
<Literal>DS_C_SESSION</Literal> and <Literal>DS_C_CONTEXT</Literal> are ignored.
<Literal>DS_C_SESSION</Literal> is returned by <Function>ds_bind(&thinsp;)</Function>, which usually
receives the <Literal>DS_DEFAULT_SESSION</Literal> constant
as input.
<Literal>DS_C_CONTEXT</Literal> is
usually substituted by the <Literal>DS_DEFAULT_CONTEXT</Literal> constant.
</Para>
<Note>
<Para><Literal>DS_C_NAME</Literal> is an abstract class that has the single subclass
<Literal>DS_C_DS_DN</Literal>.  Therefore, <Literal>DS_C_NAME</Literal> is practically the same
thing as <Literal>DS_C_DS_DN</Literal>.
</Para>
</Note>
<?sml-need 22>
<Table Frame="all" Remap="center" Orient="Port">
<Title>Directory Service Functions With Their Required Input Objects</Title>
<TGroup Cols="2">
<ColSpec Colsep="1" Align="Left" Colwidth="1*" Colname="col1" Colnum="1">
<ColSpec Align="Left" Colwidth="1.5*" Colname="col2" Colnum="2">
<THead>
<Row>
<Entry Rowsep="1"><Literal>Function</Literal></Entry>
<Entry Rowsep="1"><Literal>Input Object</Literal></Entry>
</Row>

</THead>
<TBody>
<Row>
<Entry><Function>ds_add_entry(&thinsp;)</Function></Entry>
<Entry><Literal>DS_C_NAME</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1"></Entry>
<Entry Rowsep="1"><Literal>DS_C_ATTRIBUTE_LIST</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Function>ds_bind(&thinsp;)</Function></Entry>
<Entry Rowsep="1">None</Entry>
</Row>
<Row>
<Entry><Function>ds_compare(&thinsp;)</Function></Entry>
<Entry><Literal>DS_C_NAME</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1"></Entry>
<Entry Rowsep="1"><Literal>DS_C_AVA</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Function>ds_initialize(&thinsp;)</Function></Entry>
<Entry Rowsep="1">None</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Function>ds_list(&thinsp;)</Function></Entry>
<Entry Rowsep="1"><Literal>DS_C_NAME</Literal></Entry>
</Row>
<Row>
<Entry><Function>ds_modify_entry(&thinsp;)</Function></Entry>
<Entry><Literal>DS_C_NAME</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1"></Entry>
<Entry Rowsep="1"><Literal>DS_C_ENTRY_MOD_LIST</Literal></Entry>
</Row>
<Row>
<Entry><Function>ds_read(&thinsp;)</Function></Entry>
<Entry><Literal>DS_C_NAME</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1"></Entry>
<Entry Rowsep="1"><Literal>DS_C_ENTRY_INFO_SELECTION</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Function>ds_remove_entry(&thinsp;)</Function></Entry>
<Entry Rowsep="1"><Literal>DS_C_NAME</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Function>ds_shutdown(&thinsp;)</Function></Entry>
<Entry Rowsep="1">None</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Function>ds_unbind(&thinsp;)</Function></Entry>
<Entry Rowsep="1">None</Entry>
</Row>
<Row>
<Entry><Function>ds_version(&thinsp;)</Function></Entry>
<Entry>None</Entry>
</Row>
</TBody>
</TGroup>
</Table>
<?sml-break>
<?sml-need 20>
</Sect2>
<Sect2 Id="DCEADG.CDSXC.div.36">
<Title>Input Object Classes for XDS/CDS Operations</Title>
<Para>The following subsections contain information about all the object
types required as input to any of the XDS functions that can be used to
access CDS. In order to use these functions successfully, you must be
able to construct and modify the objects that the functions
expect as their input parameters.
XDS functions require most of their input parameters to be
wrapped in a nested series of data structures that represent
objects, and these functions deliver their output returns to callers in the
same object form.
</Para>
<Para>Objects that are returned to you by the interface are not difficult to
manipulate because
the <Function>om_get(&thinsp;)</Function> function allows you to go through them and
retrieve only the value parts you are
interested in, and discard the parts of data structures you are not
interested in.
However, any objects you are
required to supply as <Symbol Role="Variable">input</Symbol> to an XDS or XOM function are another
matter: you must build and initialize these object structures yourself.
</Para>
<Para>The basics of object building have already been explained earlier in this
chapter.
Each object described in the
following subsections is accompanied by a static declaration in C of a very
simple instance of that object class.  The objects in an
application are usually built dynamically (this technique
was demonstrated earlier in this chapter).
The static declarations
that follow give a simple example of what the objects
look like.
</Para>
<Para>An object's properties, such as
what sort of values it can hold, how many of them
it can hold, and so on, are determined by the <Symbol Role="Variable">class</Symbol> the object belongs
to.
Each class consists of one or more <Symbol Role="Variable">attributes</Symbol> that an
object can have.
The attributes hold whatever values the object contains.
Thus, the objects are data structures that all look the
same (and can be handled in the same way) from the outside,
but whose specific data fields are
determined by the class each object belongs to.
At the abstract level, objects
consist of attributes, just as structures consist of fields.
<?sml-break><?sml-need 15></Para>
<Sect3 Id="DCEADG.CDSXC.div.37">
<Title>XDS/CDS Object Types</Title>
<Para>Following is a list of all the object types that are
described in the following subsections.  Most of these
objects are object structures; that is, compounds consisting of
superobjects that contain subobjects as some of their values.
These subobjects
may in turn contain other objects, and so on.  Subobjects are indicated
by indentation.
A <Literal>DS_C_DS_DN</Literal> object contains at least one
<Literal>DS_C_DS_RDN</Literal> object, and each <Literal>DS_C_DS_RDN</Literal> contains one
<Literal>DS_C_AVA</Literal> object.  Note that subobjects can, and often do, exist by
themselves, depending on what object class is called for by a given
function.  This list contains all the possible kinds of objects that can
be required as input for any XDS/CDS operation.
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>DS_C_ATTRIBUTE_LIST</Literal>
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>DS_C_ATTRIBUTE</Literal>
</Para>
</ListItem>
</ItemizedList>
</ListItem>
<ListItem>
<Para><Literal>DS_C_DS_DN</Literal>
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>DS_C_DS_RDN</Literal>
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>DS_C_AVA</Literal>
</Para>
</ListItem>
</ItemizedList>
</ListItem>
</ItemizedList>
</ListItem>
<ListItem>
<Para><Literal>DS_C_ENTRY_MOD_LIST</Literal>
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>DS_C_ENTRY_MOD</Literal>
</Para>
</ListItem>
</ItemizedList>
</ListItem>
<ListItem>
<Para><Literal>DS_C_ENTRY_INFO_SELECTION</Literal>
</Para>
</ListItem>
</ItemizedList>
<Para>In each section, information is provided for the described object's
attributes.  All its attributes are listed.
</Para>
<Para>The illustrations in the following sections can be compared to the same
object classes' tabular definitions later in this guide.
</Para>
</Sect3>
<Sect3 Id="DCEADG.CDSXC.div.38">
<Title>The <Literal>DS_C_ATTRIBUTE_LIST</Literal> Object</Title>
<Para>A <Literal>DS_C_ATTRIBUTE_LIST</Literal> class object is required as input to
<Function>ds_add_entry(&thinsp;)</Function>.
The object contains a list of the directory attributes
you want associated with the entry that is to be added.
</Para>
<Para><?sml-need 11>Its general structure is as follows:
</Para>
<ItemizedList>
<ListItem>
<Para>Attribute List class type attribute
</Para>
</ListItem>
<ListItem>
<Para>Zero or more Attribute objects:
</Para>
<ItemizedList>
<ListItem>
<Para>Attribute class type attribute
</Para>
</ListItem>
<ListItem>
<Para>Attribute Type attribute
</Para>
</ListItem>
<ListItem>
<Para>Zero or more Attribute Value(s)
</Para>
</ListItem>
</ItemizedList>
</ListItem>
</ItemizedList>
<Para>Thus, a <Literal>DS_C_ATTRIBUTE_LIST</Literal> object containing one attribute
consists of two object descriptor arrays because
each additional attribute in
the list requires an additional descriptor array to represent it.
The subobject arrays' names (that is, addresses) are the contents of
the value fields in the <Literal>DS_ATTRIBUTES</Literal> object descriptors.
</Para>
<Para>Figure 3-9 shows the attributes of the <Literal>DS_C_ATTRIBUTE_LIST</Literal> object.
</Para>
<?sml-need 5i>
<Figure>
<Title>The DS_C_ATTRIBUTE_LIST Object</Title>
<Graphic Scalefit="1" Reprodep="400" Reprowid="400" Format="EPS" Entityref="DCEADG.CDSXC.pic.9" role="page-wide"></Graphic>
</Figure>
<?sml-space .5>
<?sml-need 4>
<ItemizedList>
<ListItem>
<Para><Literal>OM_CLASS</Literal>
</Para>
<Para>The value of this attribute is an OID string that identifies
the object's class; its value is always <Literal>DS_C_ATTRIBUTE_LIST</Literal>.
</Para>
</ListItem>
<ListItem>
<Para><Literal>DS_ATTRIBUTES</Literal>
</Para>
<Para>This is an attribute whose value is another object of class
<Literal>DS_C_ATTRIBUTE</Literal> (see Section 3.5.2.3).
The attribute is defined by a
separate array of object descriptors whose base address is the value
of the <Literal>DS_ATTRIBUTES</Literal> attribute.
Note that there can be any number of
instances of this attribute and, therefore, any number of subobjects.
</Para>
</ListItem>
</ItemizedList>
</Sect3>
<Sect3 Id="DCEADG.CDSXC.div.39">
<Title>The <Literal>DS_C_ATTRIBUTE</Literal> Object</Title>
<Para>An object of this class can be an attribute of a <Literal>DS_C_ATTRIBUTE_LIST</Literal>
object (see Section 3.5.2.2).
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>OM_CLASS</Literal>
</Para>
<Para>The value of this attribute is an OID string that identifies
the object's class; its value is always <Literal>DS_C_ATTRIBUTE</Literal>.
</Para>
</ListItem>
<ListItem>
<Para><Literal>DS_ATTRIBUTE_TYPE</Literal>
</Para>
<Para>The value of this attribute, which is an OID string, identifies the
directory attribute whose value is contained in this object.
</Para>
</ListItem>
<ListItem>
<Para><Literal>DS_ATTRIBUTE_VALUES</Literal>
</Para>
<Para>These are the actual values for the directory attribute represented by
this <Literal>DS_C_ATTRIBUTE</Literal> object.  Both the value syntax and the number of
values depend on what directory attribute this is; that is,
they depend on the value of <Literal>DS_ATTRIBUTE_VALUE</Literal>.
</Para>
</ListItem>
</ItemizedList>
</Sect3>
<Sect3 Id="DCEADG.CDSXC.div.40">
<Title>Example Definition of a <Literal>DS_C_ATTRIBUTE_LIST</Literal> Object</Title>
<Para>The following code fragment is a definition of a
<Literal>DS_C_ATTRIBUTE_LIST</Literal> object.
</Para>
<InformalExample>
<Para><ProgramListing>static OM_descriptor    Single_Attribute_Object[] = {
 OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE),
 OM_OID_DESC(DS_ATTRIBUTE_TYPE, DSX_A_CDS_Class),
 {DS_ATTRIBUTE_VALUES, OM_S_PRINTABLE_STRING, \
   OM_STRING("Printer")},
 OM_NULL_DESCRIPTOR
};
static OM_descriptor    Attribute_List_Object[] = {
 OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE_LIST),
 {DS_ATTRIBUTES, OM_S_OBJECT, {0, Single_Attribute_Object}},
 OM_NULL_DESCRIPTOR
};
</ProgramListing></Para>
</InformalExample>
</Sect3>
<Sect3 Id="DCEADG.CDSXC.div.41">
<Title>The <Literal>DS_C_DS_DN</Literal> Object</Title>
<Para><Literal>DS_C_DS_DN</Literal> class objects are used to hold the full names of directory
entries (distinguished names).
You
need an object of this class to pass directory entry names to the following
XDS functions:
</Para>
<ItemizedList>
<ListItem>
<Para><Function>ds_add_entry(&thinsp;)</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>ds_compare(&thinsp;)</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>ds_list(&thinsp;)</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>ds_modify_entry(&thinsp;)</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>ds_read(&thinsp;)</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>ds_remove_entry(&thinsp;)</Function>
</Para>
</ListItem>
</ItemizedList>
<Para>Figure 3-10 shows the attributes of a <Literal>DS_C_DS_DN</Literal> object.
</Para>
<?sml-need 5i>
<Figure>
<Title>DS_C_DS_DN Object Attributes</Title>
<Graphic Format="EPS" Entityref="DCEADG.CDSXC.pic.10" Scalefit="1" Reprodep="400" Reprowid="400" role="page-wide"></Graphic>
</Figure>
<?sml-space .5>
<?sml-space .5>
<ItemizedList>
<ListItem>
<Para><Literal>OM_CLASS</Literal>
</Para>
<Para>The value of this attribute is an OID string that identifies
the object's class; its value is <Literal>DS_C_DS_DN</Literal>.
</Para>
</ListItem>
<ListItem>
<Para><Literal>DS_RDNS</Literal>
</Para>
<Para>This is an attribute whose value is another object
of class <Literal>DS_C_DS_RDN</Literal> (see
Section 3.5.2.6).
The <Literal>DS_C_DS_RDN</Literal> object is
defined by a
separate array of object descriptors whose base address is the value
of the <Literal>DS_RDNS</Literal> attribute.
</Para>
<Para>There are as many <Literal>DS_RDNS</Literal> attributes in a <Literal>DS_C_DS_DN</Literal> object
as there are separate name components in the full directory entry name.
For example, suppose you wanted to represent the following CDS entry name:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>/.../C=US/O=OSF/OU=DCE/hosts/brazil/self
</UserInput></ProgramListing></Para>
</InformalExample>
<Para><?sml-need 7>This would require a total of six instances of the <Literal>DS_RDNS</Literal> 
attribute in the <Literal>DS_C_DS_DN</Literal> object.
The <Filename>/.../</Filename> (global root prefix) is
not represented.  This means that
another six object descriptor arrays are required to hold the
RDN objects, as well as six object descriptors in
the present object, one to hold (as the value of a <Literal>DS_RDNS</Literal> attribute)
a pointer to each array.
</Para>
<Para>Note that the order of these <Literal>DS_RDNS</Literal> attributes is significant; that
is, the first <Literal>DS_RDNS</Literal> should contain as its value a pointer to the
array representing the <Literal>C=US</Literal> part of the name; the next <Literal>DS_RDNS</Literal>
should contain as its value a pointer to the array representing the
<Literal>O=OSF</Literal> part, and so on.  The root part of the name is not represented
at all.
</Para>
</ListItem>
</ItemizedList>
</Sect3>
<Sect3 Id="DCEADG.CDSXC.div.42">
<Title>The <Literal>DS_C_DS_RDN</Literal> Object</Title>
<Para><Literal>DS_C_DS_RDN</Literal> class objects are required as values for the <Literal>DS_RDNS</Literal>
attributes of <Literal>DS_C_DS_DN</Literal> objects.
(For an illustration of its
structure, see Figure 3-10.)
<Literal>RDN</Literal>
refers to the X.500 term <FirstTerm>RDN</FirstTerm> that is used to signify a
part of a full entry name.
Separate objects of this class are not usually
required as input to XDS functions.
</Para>
<Para>The standard permits multiple AVAs in an RDN, but the DCE Directory and
XDS API restrict an RDN to one AVA.
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>OM_CLASS</Literal>
</Para>
<Para>The value of this attribute is an OID string that identifies
the object's class; its value is always <Literal>DS_C_DS_RDN</Literal>.
</Para>
</ListItem>
<ListItem>
<Para><Literal>DS_AVAS</Literal>
</Para>
<Para>This is an attribute whose value is yet another object
of class <Literal>DS_C_AVA</Literal> (see Section
3.5.2.7).
The <Literal>DS_C_AVA</Literal> object is defined by a
separate array of object descriptors whose base address is the value
of the <Literal>DS_AVAS</Literal> attribute.
</Para>
<Para>Note that there can only be one instance of this attribute in
the <Literal>DS_C_RDN</Literal> object.
The object descriptor array describing
this object always consists of three object descriptor structures:
the first describes the object's class, the second
describes the <Literal>DS_AVAS</Literal>
attribute, and the third descriptor is the terminating
NULL.
</Para>
</ListItem>
</ItemizedList>
</Sect3>
<Sect3 Id="DCEADG.CDSXC.div.43">
<Title>The <Literal>DS_C_AVA</Literal> Object</Title>
<Para>The <Literal>DS_C_AVA</Literal> class object is used to hold an actual value.
The value is usually in the form of one of the many different XOM string
types. (For an illustration of its structure, see Figure 3-10.)
</Para>
<Para>In calls to <Function>ds_compare(&thinsp;)</Function>, an object of this type is required to hold
the type and value of the attribute that you want compared with those in
the entry you specify.
It holds the type and value in a separate <Literal>DS_C_DS_DN</Literal> object.
</Para>
<Para><Literal>DS_C_AVA</Literal> is also included here because it is a required subsubobject
of <Literal>DS_C_DS_DN</Literal> itself.
<Literal>DS_C_AVA</Literal> is the subobject in which the name
part's actual literal value is held.
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>OM_CLASS</Literal>
</Para>
<Para>The value of this attribute is an OID string that identifies
the object's class; its value is always <Literal>DS_C_AVA</Literal>.
</Para>
</ListItem>
<ListItem>
<Para><Literal>DS_ATTRIBUTE_TYPE</Literal>
</Para>
<Para>The value of this attribute, which is an OID string, identifies the
directory attribute whose value is contained in this object.
</Para>
</ListItem>
<ListItem>
<Para><Literal>DS_ATTRIBUTE_VALUES</Literal>
</Para>
<Para>This is the literal value of what is represented by this <Literal>DS_C_AVA</Literal>
object.
</Para>
<Para>If the <Literal>DS_C_AVA</Literal> object
is a subobject of <Literal>DS_C_DS_RDN</Literal> (and therefore also of
<Literal>DS_C_DS_DN</Literal>), then the value is a string representing
the part of the directory entry name represented by this object.  For
example, if the <Literal>DS_C_DS_RDN</Literal> object
contains the <Literal>O=OSF</Literal> part of an entry
name, then the string <Literal>OSF</Literal> is
the value of the <Literal>DS_ATTRIBUTE_VALUES</Literal>
attribute, and <Literal>DS_A_COUNTRY_NAME</Literal> is the value of the
<Literal>DS_ATTRIBUTE_TYPE</Literal> attribute.
</Para>
<Para>On the other hand, if <Literal>DS_C_AVA</Literal> contains an entry attribute type
and value to be passed to <Function>ds_compare(&thinsp;)</Function>,
then <Literal>DS_ATTRIBUTE_TYPE</Literal> identifies the type of the
attribute, and <Literal>DS_ATTRIBUTE_VALUES</Literal> contains a value, which is
appropriate for the attribute type,
to be compared with the entry value.
</Para>
<Para><?sml-need 9>For example, suppose you wanted to compare a certain value with a CDS entry's
<Literal>CDS_Class</Literal> attribute's value.  The identifiers for all the valid CDS
entry attributes are found in the file 
<Filename>/.:/opt/dcelocal/etc/cds_attributes</Filename>.
The value of <Literal>DS_ATTRIBUTE_TYPE</Literal> would be <Literal>CDS_Class</Literal>,
which is the label of an object identifier string, and <Literal>DS_ATTRIBUTE_VALUES</Literal>
would contain some desired value, in the correct syntax for <Literal>CDS_Class</Literal>.
The syntax also is found in the <Literal>cds_attributes</Literal> file; for <Literal>CDS_Class</Literal>
it is <Literal>byte</Literal>; that is, a character string.
</Para>
</ListItem>
</ItemizedList>
</Sect3>
<Sect3 Id="DCEADG.CDSXC.div.44">
<Title>Example Definition of a <Literal>DS_C_DS_DN</Literal> Object</Title>
<Para>The following code fragment shows an example definition for a
<Literal>DS_C_DS_DN</Literal> object.
</Para>
<InformalExample>
<Para><ProgramListing>static OM_descriptor    Entry_String_Object[] = {
 OM_OID_DESC(OM_CLASS, DS_C_AVA),
 OM_OID_DESC(DS_ATTRIBUTE_TYPE, DSX_TYPELESS_RDN),
 {DS_ATTRIBUTE_VALUES, OM_S_PRINTABLE_STRING, \
   OM_STRING("brazil")},
 OM_NULL_DESCRIPTOR
};

static OM_descriptor    Entry_Part_Object[] = {
 OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
 {DS_AVAS, OM_S_OBJECT, {0, Entry_String_Object}},
 OM_NULL_DESCRIPTOR
};

static OM_descriptor    Entry_Name_Object[] = {
 OM_OID_DESC(OM_CLASS, DS_C_DS_DN),
 {DS_RDNS, OM_S_OBJECT, {0, Entry_Part_Object}},
 OM_NULL_DESCRIPTOR
};
</ProgramListing></Para>
</InformalExample>
</Sect3>
<Sect3 Id="DCEADG.CDSXC.div.45">
<Title>The <Literal>DS_C_ENTRY_MOD_LIST</Literal> Object</Title>
<Para><Literal>DS_C_ENTRY_MOD_LIST</Literal> class
objects, which contain a list of changes to be made to some
directory entry, must be passed to <Function>ds_modify_entry(&thinsp;)</Function>.
<Literal>DS_C_ENTRY_MOD_LIST</Literal> objects have the
attributes shown in Figure 3-11.
</Para>
<Figure>
<Title>The DS_C_ENTRY_MOD_LIST Object</Title>
<Graphic Format="EPS" Entityref="DCEADG.CDSXC.pic.11" Scalefit="1" Reprodep="400" Reprowid="400" role="page-wide"></Graphic>
</Figure>
<?sml-space .5>
<?sml-space .5>
<ItemizedList>
<ListItem>
<Para><Literal>OM_CLASS</Literal>
</Para>
<Para>The value of this attribute is an OID string that identifies
the object's class; its value is always <Literal>DS_C_ENTRY_MOD_LIST</Literal>.
</Para>
</ListItem>
<ListItem>
<Para><Literal>DS_CHANGES</Literal>
</Para>
<Para>This is an attribute whose value is another object
of class <Literal>DS_C_ENTRY_MOD</Literal>
(see Section 3.5.2.10).
The <Literal>DS_C_ENTRY_MOD</Literal> object is defined by a
separate array of object descriptors whose base address is the value
of the <Literal>DS_CHANGES</Literal> attribute.
</Para>
<Para>Note that there can be one or more instances of this attribute in the object,
which is why it is called <Literal>_LIST</Literal>.
Each attribute contains one separate
entry modification.  To learn how the modification itself is specified, see
Section 3.5.2.10.
The order of multiple instances of this attribute is significant
because, if more
than one modification is specified, the modifications are performed by
<Function>ds_modify_entry(&thinsp;)</Function> in the order in which the <Literal>DS_CHANGES</Literal> attributes
appear in the <Literal>DS_C_ENTRY_MOD_LIST</Literal> object.
</Para>
</ListItem>
</ItemizedList>
</Sect3>
<Sect3 Id="DCEADG.CDSXC.div.46">
<Title>The <Literal>DS_C_ENTRY_MOD</Literal> Object</Title>
<Para>The <Literal>DS_C_ENTRY_MOD</Literal> class object
holds the information associated
with a directory entry modification.
(For an illustration of its structure,
see Figure 3-11.) Each <Literal>DS_C_ENTRY_MOD</Literal> object describes
one modification.
To create a list of modifications suitable to be passed
to a <Function>ds_modify_entry(&thinsp;)</Function> call, describe each modification
in a separate <Literal>DS_C_ENTRY_MOD</Literal> object, and then insert these
objects as multiple instances of the <Literal>DS_CHANGES</Literal> attribute in a
<Literal>DS_C_ENTRY_MOD_LIST</Literal> object (see Section 3.5.2.9).
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>OM_CLASS</Literal>
</Para>
<Para>The value of this attribute is an OID string that identifies
the object's class; its value is always <Literal>DS_C_ENTRY_MOD</Literal>.
</Para>
</ListItem>
<ListItem>
<Para><Literal>DS_ATTRIBUTE_TYPE</Literal>
</Para>
<Para>The value of this attribute, which is an OID string, identifies the
directory attribute whose modification is described in this object.
</Para>
</ListItem>
<ListItem>
<Para><Literal>DS_ATTRIBUTE_VALUES</Literal>
</Para>
<Para>These are the values required for the entry modification; their
type and number depend on both the entry type and the modification
requested.
</Para>
</ListItem>
<ListItem>
<?sml-need 12>
<Para><Literal>DS_MOD_TYPE</Literal>
</Para>
<Para>The value of this attribute identifies the kind of modification requested.
It can be one of the following:
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>DS_ADD_ATTRIBUTE</Literal>
</Para>
<Para>The attribute specified by <Literal>DS_ATTRIBUTE_TYPE</Literal> is not currently in
the entry.  It should be added, along
with the value(s) specified by <Literal>DS_ATTRIBUTE_VALUES</Literal>,
to the entry.
The entry itself is specified in a separate
<Literal>DS_C_DS_DN</Literal> object, which is also passed to <Function>ds_modify_entry(&thinsp;)</Function>.
</Para>
</ListItem>
<ListItem>
<Para><Literal>DS_ADD_VALUES</Literal>
</Para>
<Para>The specified attribute is currently in the entry.  The value(s) specified by
<Literal>DS_ATTRIBUTE_VALUES</Literal> should be added to it.
</Para>
</ListItem>
<ListItem>
<Para><Literal>DS_REMOVE_ATTRIBUTE</Literal>
</Para>
<Para>The specified attribute is currently in the entry and should be
deleted from the entry.  Any values specified by <Literal>DS_ATTRIBUTE_VALUES</Literal>
are ignored.
</Para>
</ListItem>
<ListItem>
<Para><Literal>DS_REMOVE_VALUES</Literal>
</Para>
<Para>The specified attribute is currently in the entry.  One or more values, specified
by <Literal>DS_ATTRIBUTE_VALUES</Literal>, should be removed from it.
</Para>
</ListItem>
</ItemizedList>
</ListItem>
</ItemizedList>
</Sect3>
<Sect3 Id="DCEADG.CDSXC.div.47">
<Title>Example Definition of a <Literal>DS_C_ENTRY_MOD_LIST</Literal> Object</Title>
<Para>The following code fragment is an example definition of a
<Literal>DS_C_ENTRY_MOD_LIST</Literal> object.
</Para>
<InformalExample>
<Para><ProgramListing><?sml-need 15>OM_string my_uuid;

static OM_descriptor    Entry_Mod_Object[] = {
 OM_OID_DESC(OM_CLASS, DS_C_ENTRY_MOD),
 OM_OID_DESC(DS_ATTRIBUTE_TYPE, DSX_UUID),
 {DS_ATTRIBUTE_VALUES, OM_S_OCTET_STRING, my_uuid},
 {DS_MOD_TYPE, OM_S_ENUMERATION, DS_ADD_ATTRIBUTE},
 OM_NULL_DESCRIPTOR
};

static OM_descriptor    Entry_Mod_List_Object[] = {
 OM_OID_DESC(OM_CLASS, DS_C_ENTRY_MOD_LIST),
 {DS_CHANGES, OM_S_OBJECT, {0, Entry_Mod_Object}},
 OM_NULL_DESCRIPTOR
};
</ProgramListing></Para>
</InformalExample>
</Sect3>
<Sect3 Id="DCEADG.CDSXC.div.48">
<Title>The <Literal>DS_C_ENTRY_INFO_SELECTION</Literal> Object</Title>
<Para>When you call <Function>ds_read(&thinsp;)</Function> to read one or more attributes from a CDS entry,
you specify in the <Literal>DS_C_ENTRY_INFO_SELECTION</Literal>
object the entry attributes you want to read.
</Para>
<Para>The <Literal>DS_C_ENTRY_INFO_SELECTION</Literal>
object contains the attributes shown in Figure 3-12.
</Para>
<Figure>
<Title>The DS_C_ENTRY_INFO_SELECTION Object</Title>
<Graphic Format="EPS" Entityref="DCEADG.CDSXC.pic.12" role="page-wide"></Graphic>
</Figure>
<?sml-space .5>
<?sml-space .5>
<Para><?sml-need 6>Note that this object class has no subobjects.
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>OM_CLASS</Literal>
</Para>
<Para>The value of this attribute is an OID string that
identifies the object's class; its value is always
<Literal>DS_C_ENTRY_INFO_SELECTION</Literal>.
</Para>
</ListItem>
<ListItem>
<Para><Literal>DS_ALL_ATTRIBUTES</Literal>
</Para>
<Para>This attribute is a simple Boolean option whose value indicates whether
all the entry's attributes are to be read, or only some of them.  Its
possible values are as follows:
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>OM_TRUE</Literal>, meaning
that all attributes in the directory entry should be read.  Any values
specified by the <Literal>DS_ATTRIBUTES_SELECTED</Literal> attribute are ignored.
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_FALSE</Literal>, meaning
that only some of the entry attributes should be read; namely, those
specified by the <Literal>DS_ATTRIBUTES_SELECTED</Literal> attribute.
</Para>
</ListItem>
</ItemizedList>
</ListItem>
<ListItem>
<Para><Literal>DS_ATTRIBUTES_SELECTED</Literal>
</Para>
<Para>The value of this attribute, which is an OID string,
identifies the entry attribute to be read.  Note that this attribute's
value has meaning only if the value of <Literal>DS_ALL_ATTRIBUTES</Literal> is <Literal>OM_FALSE</Literal>;
if it is <Literal>OM_TRUE</Literal>, the value of <Literal>DS_ATTRIBUTES_SELECTED</Literal> is ignored.
</Para>
<Para>Note also that there are multiple instances of this attribute if more than
one attribute, but not all of them, is to be selected for reading.  Each
separate instance of <Literal>DS_ATTRIBUTES_SELECTED</Literal> has as its value an
OID string that identifies one directory entry attribute to be read.  If
<Literal>DS_ATTRIBUTES_SELECTED</Literal> is present but does not have
a value, <Function>ds_read(&thinsp;)</Function>
reads the entry but does not return any attribute data; this technique can
be used to verify the existence of a directory entry.
</Para>
</ListItem>
<ListItem>
<Para><Literal>DS_INFO_TYPE</Literal>
</Para>
<Para>The value of this attribute specifies what information is to be read from
each attribute specified by <Literal>DS_ATTRIBUTES_SELECTED</Literal>.  The two possible
values are as follows:
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>DS_TYPES_ONLY</Literal>, meaning that
only the attribute types of the selected attributes should be read.
</Para>
</ListItem>
<ListItem>
<Para><Literal>DS_TYPES_AND_VALUES</Literal>, meaning that
both the attribute types and the attribute values of the selected attributes
should be read.
</Para>
</ListItem>
</ItemizedList>
</ListItem>
</ItemizedList>
<?sml-break>
<?sml-need 15>
</Sect3>
<Sect3 Id="DCEADG.CDSXC.div.49">
<Title>Example Definition of a <Literal>DS_C_ENTRY_INFO_SELECTION</Literal> Object</Title>
<Para>The following code fragment provides an example definition of a
<Literal>DS_C_ENTRY_INFO_SELECTION</Literal> object.
</Para>
<InformalExample>
<Para><ProgramListing>static OM_descriptor    Entry_Info_Select_Object[] = {
 OM_OID_DESC(OM_CLASS, DS_C_ENTRY_INFO_SELECTION),
 OM_OID_DESC(DS_ATTRIBUTES_SELECTED, DSX_A_CDS_Class),
 {DS_ALL_ATTRIBUTES, OM_S_BOOLEAN, OM_FALSE},
 {DS_INFO_TYPE, OM_S_ENUMERATION, DS_TYPES_AND_VALUES},
 OM_NULL_DESCRIPTOR
};
</ProgramListing></Para>
</InformalExample>
</Sect3>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.CDSXC.div.50">
<Title>Attribute and Data Type Translation</Title>
<Para>This section provides translations between CDS and XDS for attributes and
data types.
Table 3-2 provides the OM syntax for CDS attributes.
Table 3-3 provides the OM syntax for CDS data types.
Table 3-4 defines the mapping of CDS data types to OM syntaxes.
</Para>
<?sml-need 4i>
<Table Frame="all" Remap="center" Orient="Port">
<Title>CDS Attributes to OM Syntax Translation</Title>
<TGroup Cols="2">
<ColSpec Colsep="1" Align="Left" Colwidth="1*" Colname="col1" Colnum="1">
<ColSpec Align="Left" Colwidth="1.5*" Colname="col2" Colnum="2">
<THead>
<Row>
<Entry Rowsep="1"><Literal>CDS Attribute</Literal></Entry>
<Entry Rowsep="1"><Literal>OM Syntax</Literal></Entry>
</Row>
</THead>
<TBody>
<Row>
<Entry><Literal>CDS_CTS</Literal></Entry>
<Entry><Literal>OM_S_OCTET_STRING</Literal></Entry>
</Row>
<Row>
<Entry><Literal>CDS_UTS</Literal></Entry>
<Entry><Literal>OM_S_OCTET_STRING</Literal></Entry>
</Row>
<Row>
<Entry><Literal>CDS_Class</Literal></Entry>
<Entry><Literal>OM_S_OCTET_STRING</Literal></Entry>
</Row>
<Row>
<Entry><Literal>CDS_ClassVersion</Literal></Entry>
<Entry><Literal>OM_S_INTEGER</Literal></Entry>
</Row>
<Row>
<Entry><Literal>CDS_ObjectUID</Literal></Entry>
<Entry><Literal>OM_S_OCTET_STRING</Literal></Entry>
</Row>
<Row>
<Entry><Literal>CDS_AllUpTo</Literal></Entry>
<Entry><Literal>OM_S_OCTET_STRING</Literal></Entry>
</Row>
<Row>
<Entry><Literal>CDS_Convergence</Literal></Entry>
<Entry><Literal>OM_S_INTEGER</Literal></Entry>
</Row>
<Row>
<Entry><Literal>CDS_InCHName</Literal></Entry>
<Entry><Literal>OM_S_INTEGER</Literal></Entry>
</Row>
<Row>
<Entry><Literal>CDS_DirectoryVersion</Literal></Entry>
<Entry><Literal>OM_S_INTEGER</Literal></Entry>
</Row>
<Row>
<Entry><Literal>CDS_UpgradeTo</Literal></Entry>
<Entry><Literal>OM_S_INTEGER</Literal></Entry>
</Row>
<Row>
<Entry><Literal>CDS_LinkTimeout</Literal></Entry>
<Entry><Literal>OM_S_INTEGER</Literal></Entry>
</Row>
<Row>
<Entry><Literal>CDS_Towers</Literal></Entry>
<Entry><Literal>OM_S_OCTET_STRING</Literal></Entry>
</Row>
</TBody>
</TGroup>
</Table>
<?sml-space .5>
<Table Frame="all" Remap="center" Orient="Port">
<Title>OM Syntax to CDS Data Types Translation</Title>
<TGroup Cols="2">
<ColSpec Colsep="1" Align="Left" Colwidth="3*" Colname="col1" Colnum="1">
<ColSpec Align="Left" Colwidth="1*" Colname="col2" Colnum="2">
<THead>
<Row>
<Entry Rowsep="1"><Literal>OM Syntax</Literal></Entry>
<Entry Rowsep="1"><Literal>CDS Data Type</Literal></Entry>
</Row>
</THead>
<TBody>
<Row>
<Entry><Literal>OM_S_TELETEX_STRING</Literal></Entry>
<Entry><Literal>cds_char</Literal></Entry>
</Row>
<Row>
<Entry><Literal>OM_S_OBJECT_IDENTIFIER_STRING</Literal></Entry>
<Entry><Literal>cds_byte</Literal></Entry>
</Row>
<Row>
<Entry><Literal>OM_S_OCTET_STRING</Literal></Entry>
<Entry><Literal>cds_byte</Literal></Entry>
</Row>
<Row>
<Entry><Literal>OM_S_PRINTABLE_STRING</Literal></Entry>
<Entry><Literal>cds_char</Literal></Entry>
</Row>
<Row>
<Entry><Literal>OM_S_NUMERIC_STRING</Literal></Entry>
<Entry><Literal>cds_char</Literal></Entry>
</Row>
<Row>
<Entry><Literal>OM_S_BOOLEAN</Literal></Entry>
<Entry><Literal>cds_long</Literal></Entry>
</Row>
<Row>
<Entry><Literal>OM_S_INTEGER</Literal></Entry>
<Entry><Literal>cds_long</Literal></Entry>
</Row>
<Row>
<Entry><Literal>OM_S_UTC_TIME_STRING</Literal></Entry>
<Entry><Literal>cds_char</Literal></Entry>
</Row>
<Row>
<Entry><Literal>OM_S_ENCODING_STRING</Literal></Entry>
<Entry><Literal>cds_byte</Literal></Entry>
</Row>
</TBody>
</TGroup>
</Table>
<?Pub _newpage>
<?sml-need 4i>
<Table Frame="all" Remap="center" Orient="Port">
<Title>CDS Data Types to OM Syntax Translation</Title>
<TGroup Cols="2">
<ColSpec Colsep="1" Align="Left" Colwidth="1*" Colname="col1" Colnum="1">
<ColSpec Align="Left" Colwidth="2*" Colname="col2" Colnum="2">
<THead>
<Row>
<Entry Rowsep="1"><Literal>CDS Data Type</Literal></Entry>
<Entry Rowsep="1"><Literal>OM Syntax</Literal></Entry>
</Row>
</THead>
<TBody>
<Row>
<Entry><Literal>cds_none</Literal></Entry>
<Entry><Literal>OM_S_NULL</Literal></Entry>
</Row>
<Row>
<Entry><Literal>cds_long</Literal></Entry>
<Entry><Literal>OM_S_INTEGER</Literal></Entry>
</Row>
<Row>
<Entry><Literal>cds_short</Literal></Entry>
<Entry><Literal>OM_S_INTEGER</Literal></Entry>
</Row>
<Row>
<Entry><Literal>cds_small</Literal></Entry>
<Entry><Literal>OM_S_INTEGER</Literal></Entry>
</Row>
<Row>
<Entry><Literal>cds_uuid</Literal></Entry>
<Entry><Literal>OM_S_OCTET_STRING</Literal></Entry>
</Row>
<Row>
<Entry><Literal>cds_Timestamp</Literal></Entry>
<Entry><Literal>OM_S_OCTET_STRING</Literal></Entry>
</Row>
<Row>
<Entry><Literal>cds_Version</Literal></Entry>
<Entry><Literal>OM_S_PRINTABLE_STRING</Literal></Entry>
</Row>
<Row>
<Entry><Literal>cds_char</Literal></Entry>
<Entry><Literal>OM_S_TELETEX_STRING</Literal></Entry>
</Row>
<Row>
<Entry><Literal>cds_byte</Literal></Entry>
<Entry><Literal>OM_S_OCTET_STRING</Literal></Entry>
</Row>
</TBody>
</TGroup>
</Table>
</Sect1>
</Chapter>
<!--+ 09/23/96 11:54:18
    | tagMorph:  $Id: 3_xds_cds.sgm,v 1.1.2.11 1996/12/17 19:28:54 damon Exp $
    | tagMorph library:  $Id: 3_xds_cds.sgm,v 1.1.2.11 1996/12/17 19:28:54 damon Exp $
    | sml-to-docbook:  1.21
    +-->












