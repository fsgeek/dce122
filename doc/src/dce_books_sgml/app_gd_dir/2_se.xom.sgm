<!--
# COPYRIGHT NOTICE
# Copyright (c) 1990-1996 Open Software Foundation, Inc. 
# ALL RIGHTS RESERVED (DCE). See the file named COPYRIGHT.DCE in the 
# src directory for the full copyright text. 
# 
# 
# HISTORY
# $Log: 2_se.xom.sgm,v $
# Revision 1.1.2.12  1996/12/17  19:28:46  damon
# 	Expanded OSF C O P Y R I G H T   N O T I C E
# 	[1996/12/17  19:22:24  damon]
#
# Revision 1.1.2.11  1996/12/09  21:12:55  carrig
# 	{enh,R1.2.2}
# 	Wide Pgm Listing
# 	[1996/12/09  21:11:00  carrig]
# 
# Revision 1.1.2.10  1996/12/09  00:07:07  carrig
# 	{enh,R1.2.2}
# 	Put in editor's comments
# 	[1996/12/09  00:05:28  carrig]
# 
# Revision 1.1.2.9  1996/10/23  18:48:27  carrig
# 	{enh,R1.2.2}
# 	Ready for editor (2)
# 	[1996/10/23  18:46:42  carrig]
# 
# Revision 1.1.2.8  1996/10/22  21:05:38  carrig
# 	{enh,R1.2.2}
# 	Fixed tables
# 	[1996/10/22  21:04:20  carrig]
# 
# Revision 1.1.2.7  1996/10/21  20:34:07  carrig
# 	{enh,R1.2.2}
# 	Worked on tables
# 	[1996/10/21  20:32:25  carrig]
# 
# Revision 1.1.2.6  1996/10/17  21:08:39  carrig
# 	{enh,R1.2.2}
# 	Worked on tables
# 	[1996/10/17  21:07:02  carrig]
# 
# 	{enh,R1.2.2}
# 	Worked on tables
# 	[1996/10/17  20:54:09  carrig]
# 
# Revision 1.1.2.5  1996/10/16  21:33:17  carrig
# 	{enh,R1.2.2}
# 	First pass at tables
# 	[1996/10/16  21:31:14  carrig]
# 
# Revision 1.1.2.4  1996/10/08  14:14:29  weir
# 	Fixed comment delimiter typo
# 	[1996/10/08  14:14:08  weir]
# 
# Revision 1.1.2.3  1996/10/07  17:49:19  wardr
# 	{enh,R1.2.2}
# 	Update for sgml conversion
# 	[1996/10/07  17:48:45  wardr]
# 
# Revision 1.1.2.2  1996/09/28  15:21:19  weir
# 	Cleaned up old history
# 	[1996/09/28  15:19:41  weir]
# 
# Revision 1.1.2.1  1996/09/25  20:27:44  weir
# 	Initial submission
# 	[1996/09/25  20:26:20  weir]
# 
# $EndLog$
# 
-->
<!---->
<!-- Fragment document type declaration subset:
ArborText, Inc., 1988-1993, v.4001
<!DOCTYPE Book PUBLIC "-//Davenport//DTD DocBook V2.4//EN" [
<!ENTITY  DCEADG.REFSE.pic.1  SYSTEM "eps/fig1.eps" NDATA EPS>
]>
-->
<!-- OLD HISTORY-->
<!-- Revision 1.1.10.1  1996/09/03  18:40:50  wardr-->
<!-- 	{enh,R1.2.2}-->
<!-- 	Update for sgml conversion-->
<!-- 	[1996/09/03  18:40:00  wardr]-->
<!---->
<!-- Revision 1.1.8.10  1995/06/15  16:26:16  rcb-->
<!-- 	edited 1.1 version, PRENTICE HALL reformat-->
<!-- 	[1995/06/13  19:36:18  rcb]-->
<!-- -->
<!-- 	edited 1.1 version, PRENTICE HALL reformat-->
<!-- 	[1995/06/12  20:52:17  rcb]-->
<!-- -->
<!-- Revision 1.1.8.9  1994/11/03  23:32:01  neilson-->
<!-- 	Substituted macros for book names in cross refs.-->
<!-- 	[1994/11/03  01:38:26  neilson]-->
<!-- -->
<!-- 	Substituted macros for book names in cross refs.-->
<!-- -->
<!-- Revision 1.1.8.8  1994/08/05  15:58:24  rnollman-->
<!-- 	[rnolman] - Checkin after OSF edits-->
<!-- 	[1994/08/05  15:57:02  rnollman]-->
<!-- -->
<!-- 	[rnollman] - checkin afaterafter incorporating OSF edits-->
<!-- -->
<!-- Revision 1.1.8.5  1994/05/19  13:30:28  weir-->
<!-- 	Fixed build error-->
<!-- 	[1994/05/19  13:29:52  weir]-->
<!-- -->
<!-- Revision 1.1.8.4  1994/05/14  22:41:54  rnollman-->
<!-- 	last beta submittal-->
<!-- 	[1994/05/14  22:37:24  rnollman]-->
<!-- -->
<!-- Revision 1.1.8.3  1994/05/10  21:20:48  rnollman-->
<!-- 	final update for beta-->
<!-- 	[1994/05/10  21:20:34  rnollman]-->
<!-- -->
<!-- Revision 1.1.8.2  1993/11/11  21:41:34  rnollman-->
<!-- 	update SNI copyright-->
<!-- 	[1993/11/11  21:41:19  rnollman]-->
<!-- -->
<!-- Revision 1.1.8.1  1993/10/27  15:20:16  rnollman-->
<!-- 	replacing old version of chapter with new version from Dublin-->
<!-- 	[1993/10/27  15:19:58  rnollman]-->
<!-- -->
<!-- Revision 1.1.6.3  1993/01/28  18:39:15  cjd-->
<!-- 	Embedded copyright notice-->
<!-- 	[1993/01/28  17:58:25  cjd]-->
<!-- -->
<!-- Revision 1.1.6.2  1992/11/19  21:53:18  weir-->
<!-- 	Moved into 1.0.2doc tree-->
<!-- 	[1992/11/19  21:46:54  weir]-->
<!-- -->
<!-- Revision 1.1.4.7  1992/11/11  23:41:34  buckler-->
<!-- 	Corrected index entries-->
<!-- 	[1992/11/11  22:45:02  buckler]-->
<!-- -->
<!-- Revision 1.1.4.6  1992/11/06  16:01:50  lmk-->
<!-- 	Prentice-Hall index edits only-->
<!-- 	[1992/11/06  15:57:33  lmk]-->
<!-- -->
<!-- Revision 1.1.4.5  1992/10/30  15:16:12  lmk-->
<!-- 	Prentice-Hall index entries only-->
<!-- 	[1992/10/30  15:14:35  lmk]-->
<!-- -->
<!-- Revision 1.1.4.4  1992/10/27  20:57:59  steiner-->
<!-- 	A few more P-H edits, mostly reformatting a table.-->
<!-- 	[1992/10/27  20:57:39  steiner]-->
<!-- -->
<!-- Revision 1.1.4.3  1992/10/20  22:27:05  buckler-->
<!-- 	Pre-Prentice-Hall editorial review-->
<!-- 	[1992/10/20  22:24:51  buckler]-->
<!-- -->
<!-- Revision 1.1.4.2  1992/10/06  18:48:10  steiner-->
<!-- 	First P-H edit pass, edits from Eddie.-->
<!-- 	[1992/10/06  18:47:39  steiner]-->
<!-- -->
<!-- Revision 1.1.2.4  1992/06/15  15:20:23  buckler-->
<!-- 	Fixed various formatting problems-->
<!-- 	[1992/06/15  15:16:38  buckler]-->
<!-- -->
<!-- Revision 1.1.2.3  1992/06/12  21:00:10  buckler-->
<!-- 	Incorporated changes from Brian Keane (Dublin) markup-->
<!-- 	[1992/06/12  20:59:06  buckler]-->
<!-- -->
<!-- Revision 1.1.2.2  1992/06/10  21:18:23  marty-->
<!-- 	Doc drop from Dublin-->
<!-- 	[1992/06/10  21:14:47  marty]-->
<!-- -->
<!---->
<Chapter Id="DCEADG.REFSE.div.1">
<Title>XOM Service Interface</Title>
<!-- /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *-->
<!-- * COPYRIGHT   (C)  SIEMENS NIXDORF INFORMATIONSSYSTEME AG 1994   *-->
<!-- *                  ALL RIGHTS RESERVED                           *-->
<!-- *                                                                *-->
<!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */-->
<Para>This chapter describes the following aspects of the XOM service interface:
</Para>
<ItemizedList>
<ListItem>
<Para>The conformance of the DCE X/Open OSI-Abstract-Data Manipulation (XOM)
implementation to the X/Open specification.
</Para>
</ListItem>
<ListItem>
<Para>The data types whose data values are the parameters and results of
the functions that the service makes available to the client.
</Para>
</ListItem>
<ListItem>
<Para>An overview of the functions that the service makes available to the client.
For a complete description of these functions, see the corresponding
reference pages.
</Para>
</ListItem>
<ListItem>
<Para>The return codes that indicate the outcomes (in particular,
the exceptions) that the functions can report.
</Para>
</ListItem>
</ItemizedList>
<Para>See Chapter 7 for examples of using the XOM interface.
</Para>
<Sect1 Id="DCEADG.REFSE.div.2">
<Title>Standards Conformance</Title>
<Para>The DCE XOM implementation conforms to the following specification:
</Para>
<Para><Replaceable>X/Open CAE Specification</Replaceable>,
<Replaceable>OSI-Abstract-Data Manipulation (XOM)</Replaceable> (November 1991)
</Para>
<Para>The following apply to the DCE XOM implementation:
</Para>
<ItemizedList>
<ListItem>
<Para>Multiple workspaces for XDS objects are supported.
</Para>
</ListItem>
<ListItem>
<Para>The OM package is supported.
</Para>
</ListItem>
<ListItem>
<Para>The <Function>om_encode(&thinsp;)</Function> and <Function>om_decode(&thinsp;)</Function> functions are not supported.
The transfer of objects between workspaces is not
envisaged within the DCE environment.  The OM
classes used by the DCE XDS/XOM API are not encodable.
</Para>
</ListItem>
<ListItem>
<Para>Translation to local character sets is supported.
</Para>
</ListItem>
</ItemizedList>
</Sect1>
<Sect1 Id="DCEADG.REFSE.div.3">
<Title>XOM Data Types</Title>
<Para>The data types of the XOM service interface
are defined in this section and listed in
Table 18-1.
These data types are repeated in the XOM reference pages (see
<Filename>xom.h(4xom)</Filename> ).
</Para>
<Table Frame="all" Remap="center" Orient="Port">
<Title>XOM Service Interface Data Types</Title>
<TGroup Cols="2">
<ColSpec Colsep="1" Align="Left" Colwidth="207*" Colname="col1" Colnum="1">
<ColSpec Align="Left" Colwidth="248*" Colname="col2" Colnum="2">
<THead>
<Row>
<Entry Rowsep="1"><Literal>Data Type</Literal></Entry>
<Entry Rowsep="1"><Literal>Description</Literal></Entry>
</Row>
</THead>
<TBody>
<Row>
<Entry Rowsep="1"><Literal>OM_boolean</Literal></Entry>
<Entry Rowsep="1">
Type definition for a Boolean data value.
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>OM_descriptor</Literal></Entry>
<Entry Rowsep="1">
Type definition for describing an 
attribute type and value.
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>OM_enumeration</Literal></Entry>
<Entry Rowsep="1">
Type definition for an Enumerated data 
value.
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>OM_exclusions</Literal></Entry>
<Entry Rowsep="1">
Type definition for the <Symbol Role="Variable">exclusions</Symbol> 
parameter for <Function>om_get(&thinsp;)</Function>.
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>OM_integer</Literal></Entry>
<Entry Rowsep="1">
Type definition for an Integer data 
value.
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>OM_modification</Literal></Entry>
<Entry Rowsep="1">
Type definition for the <Symbol Role="Variable">modification</Symbol> 
parameter for <Function>om_put(&thinsp;)</Function>.
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>OM_object</Literal></Entry>
<Entry Rowsep="1">
Type definition for a handle to either a 
private or a public object.
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>OM_object_identifier</Literal></Entry>
<Entry Rowsep="1">
Type definition for an object identifier 
data value.
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>OM_private_object</Literal></Entry>
<Entry Rowsep="1">
Type definition for a handle to an 
object in an implementation-defined, or 
private, representation.
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>OM_public_object</Literal></Entry>
<Entry Rowsep="1">
Type definition for a defined representation
of an object that can be directly interrogated
by a programmer.
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>OM_return_code</Literal></Entry>
<Entry Rowsep="1">
Type definition for a value returned 
from all OM functions, indicating either that 
the function succeeded or why it failed.
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>OM_string</Literal></Entry>
<Entry Rowsep="1">
Type definition for a data value of one 
of the String syntaxes.
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>OM_syntax</Literal></Entry>
<Entry Rowsep="1">
Type definition for identifying a syntax 
type.
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>OM_type</Literal></Entry>
<Entry Rowsep="1">
Type definition for identifying an OM 
attribute type.
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>OM_type_list</Literal></Entry>
<Entry Rowsep="1">
Type definition for enumerating a 
sequence of OM attribute types.
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>OM_value</Literal></Entry>
<Entry Rowsep="1">
Type definition for representing any 
data value.
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>OM_value_length</Literal></Entry>
<Entry Rowsep="1">
Type definition for indicating the number of bits,
octets, or characters in a string.
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>OM_value_position</Literal></Entry>
<Entry Rowsep="1">
Type definition for designating a 
particular location within a String data 
value.
</Entry>
</Row>
<Row>
<Entry><Literal>OM_workspace</Literal></Entry>
<Entry>
Type definition for identifying an 
application-specific API that implements OM, 
such as directory or message handling.
</Entry>
</Row>
</TBody>
</TGroup>
</Table>
<Para>Some data types are defined in terms of the following
<Replaceable>intermediate data types</Replaceable>,
<IndexTerm Id="DCEADG.REFSE.indx.1">
<Primary>intermediate data type</Primary>
</IndexTerm> whose precise definitions in C are defined by the system:
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>OM_sint</Literal>
</Para>
<Para>The positive and negative integers that can be represented in 16 bits
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_sint16</Literal>
</Para>
<Para>The positive and negative integers that can be represented in 16 bits
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_sint32</Literal>
</Para>
<Para>The positive and negative integers that can be represented in 32 bits
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_uint</Literal>
</Para>
<Para>The nonnegative integers that can be represented in 16 bits
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_uint16</Literal>
</Para>
<Para>The nonnegative integers that can be represented in 16 bits
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_uint32</Literal>
</Para>
<Para>The nonnegative integers that can be represented in 32 bits
</Para>
</ListItem>
</ItemizedList>
<Note>
<Para>The <Literal>OM_sint</Literal> and <Literal>OM_uint</Literal> data types are defined
by the range of integers they must accommodate.
As typically declared in the C interface,
they are defined by the range of integers permitted by the
host machine's word size.
The latter range, however, always encompasses the former.
</Para>
</Note>
<Para>The type definitions for these data types are as follows:
</Para>
<InformalExample>
<Para><ProgramListing>typedef int             OM_sint;
typedef short           OM_sint16;
typedef long int        OM_sint32;
typedef unsigned        OM_uint;
typedef unsigned short  OM_uint16;
typedef long unsigned   OM_uint32;
</ProgramListing></Para>
</InformalExample>
<Sect2 Id="DCEADG.REFSE.div.4">
<Title>OM_boolean</Title>
<Para>The C declaration for an <Literal>OM_boolean</Literal> data value
is as follows:
</Para>
<InformalExample>
<Para><ProgramListing>typedef OM_uint32 OM_boolean;
</ProgramListing></Para>
</InformalExample>
<Para>A data value of this data type is a Boolean;
<IndexTerm Id="DCEADG.REFSE.indx.2">
<Primary>Boolean</Primary>
</IndexTerm>that is, either FALSE or TRUE.
</Para>
<Para>FALSE (<Literal>OM_FALSE</Literal>) is indicated by 0 (zero).
TRUE is indicated by any other integer,
although the symbolic constant <Literal>OM_TRUE</Literal>
refers to the integer 1 specifically.
</Para>
</Sect2>
<Sect2 Id="DCEADG.REFSE.div.5">
<Title>OM_descriptor</Title>
<Para>The <Literal>OM_descriptor</Literal> data type is used to describe
an attribute type and value.  Its C declaration is as follows:
<IndexTerm Id="DCEADG.REFSE.indx.3">
<Primary>attribute</Primary>
<Secondary>type</Secondary>
<Tertiary>describing</Tertiary>
</IndexTerm></Para>
<InformalExample>
<Para><ProgramListing>typedef struct OM_descriptor_struct
{
   OM_type        type;
   OM_syntax      syntax;
   union  OM_value_union value;
}  OM_descriptor;
</ProgramListing></Para>
</InformalExample>
<Note>
<Para>Other components are encoded in high bits of the syntax member.
</Para>
</Note>
<Para>See the <Literal>OM_value</Literal> data type described in Section 18.2.16 or the
<Filename>xom.h(4xom)</Filename> reference page for a description of the 
<Literal>OM_value_union</Literal> structure.
</Para>
<Para>A data value of this type is a descriptor, which embodies an attribute value.
An array of descriptors can represent all the values of
all the attributes of an object, and is the representation called
<Literal>OM_public_object</Literal>.
<IndexTerm Id="DCEADG.REFSE.indx.4">
<Primary>object</Primary>
<Secondary>public</Secondary>
</IndexTerm>A descriptor has the following components:
</Para>
<ItemizedList>
<ListItem>
<Para><Symbol Role="Variable">type</Symbol>
</Para>
<Para>An <Literal>OM_type</Literal> data type. It identifies the data type of the attribute value.
</Para>
</ListItem>
<ListItem>
<?sml-need 7>
<Para><Symbol Role="Variable">syntax</Symbol>
</Para>
<Para>An <Literal>OM_syntax</Literal> data type. It identifies the syntax of the attribute value.
Components 3 to 7 (that is, the components <Symbol Role="Variable">long-string</Symbol> through
<Symbol Role="Variable">private</Symbol> that follow)
are encoded in the high-order
bits of this structure member.  Therefore, the syntax always needs to be
masked with the constant <Literal>OM_S_SYNTAX</Literal>.  An example is the following:
</Para>
<InformalExample>
<Para><ProgramListing>my_syntax = my_public_object[3].syntax &amp;
            OM_S_SYNTAX;

my_public_object[4].syntax =
my_syntax + (my_public_object[4].syntax &amp;
~OM_S_SYNTAX);
</ProgramListing></Para>
</InformalExample>
</ListItem>
<ListItem>
<Para><Symbol Role="Variable">long-string</Symbol>
</Para>
<Para>An <Literal>OM_boolean</Literal> data type. It is <Literal>OM_TRUE</Literal> only if the
descriptor is a service-generated descriptor and
the length of the value is greater than
an implementation-defined limit.
</Para>
<Para>This component occupies bit 15 (0x8000) of
the syntax and is represented by the constant <Literal>OM_S_LONG_STRING</Literal>.
</Para>
</ListItem>
<ListItem>
<Para><Symbol Role="Variable">no-value</Symbol>
</Para>
<Para>An <Literal>OM_boolean</Literal> data type. It is <Literal>OM_TRUE</Literal> only
if the descriptor is a service-generated descriptor
and the value is not present
because <Literal>OM_EXCLUDE_VALUES</Literal> or <Literal>OM_EXCLUDE_MULTIPLES</Literal>
is set in <Function>om_get(&thinsp;)</Function>.
</Para>
<Para>This component occupies bit 14 (0x4000) of
the syntax and is represented by the constant
<Literal>OM_S_NO_VALUE</Literal>.
</Para>
</ListItem>
<ListItem>
<Para><Symbol Role="Variable">local-string</Symbol>
</Para>
<Para>An <Literal>OM_boolean</Literal> data type, significant only if the
syntax is one of the string syntaxes.
It is <Literal>OM_TRUE</Literal> only if the string is
represented in an implementation-defined
local character set.  The local character set may be more
amenable for use as keyboard input or display output than the nonlocal
character set, and it can include specific treatment of line
<IndexTerm Id="DCEADG.REFSE.indx.5">
<Primary>character set</Primary>
<Secondary>local</Secondary>
</IndexTerm>termination sequences.  Certain interface functions can convert
information in string syntaxes to or from the local representation,
which may result in a loss of information.
</Para>
<Para><?sml-need 4>This component occupies bit 13 (0x2000) of
the syntax and is represented by the constant
<Literal>OM_S_LOCAL_STRING</Literal>.
The DCE XOM implementation does not support translation of strings to a
local character set.
</Para>
</ListItem>
<ListItem>
<Para><Symbol Role="Variable">service-generated</Symbol>
</Para>
<Para><IndexTerm Id="DCEADG.REFSE.indx.6">
<Primary>service-generated descriptor</Primary>
</IndexTerm>An <Literal>OM_boolean</Literal> data type.
It is <Literal>OM_TRUE</Literal> only if the descriptor is a
service-generated descriptor and the first descriptor of a public object, or
the defined part of a private object (see the 
<Symbol Role="Variable">*</Symbol><Literal>(3xom)</Literal> reference pages).
</Para>
<Para>This component occupies bit 12 (0x1000) of
the syntax and is represented by the constant
<Literal>OM_S_SERVICE_GENERATED</Literal>.
</Para>
</ListItem>
<ListItem>
<Para><Symbol Role="Variable">private</Symbol>
</Para>
<Para>An <Literal>OM_boolean</Literal> data type.
It is
<Literal>OM_TRUE</Literal> only if the descriptor in the
service-generated public object
contains a reference to the handle of a private subobject, or in the defined
part of a private object.
</Para>
<Note>
<Para>This applies only when the descriptor is a service-generated descriptor.
The client need
not set this bit in a client-generated descriptor that contains
a reference to
a private object.
</Para>
</Note>
<Para>In the C interface, this component occupies bit 11 (0x0800) of the syntax
and is represented by the constant <Literal>OM_S_PRIVATE</Literal>.
</Para>
</ListItem>
<ListItem>
<Para><Symbol Role="Variable">value</Symbol>
</Para>
<Para>An <Literal>OM_value</Literal> data type. It identifies the attribute value.
<IndexTerm Id="DCEADG.REFSE.indx.7">
<Primary>value</Primary>
<Secondary>OM attribute</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.REFSE.indx.8">
<Primary>attribute</Primary>
<Secondary>value</Secondary>
<Tertiary>OM</Tertiary>
</IndexTerm></Para>
</ListItem>
</ItemizedList>
</Sect2>
<Sect2 Id="DCEADG.REFSE.div.6">
<Title>OM_enumeration</Title>
<Para><IndexTerm Id="DCEADG.REFSE.indx.9">
<Primary>enumeration</Primary>
</IndexTerm>The <Literal>OM_enumeration</Literal> data type is used to indicate
an Enumerated data value.  Its C declaration is as follows:
</Para>
<InformalExample>
<Para><ProgramListing>typedef OM_sint32 OM_enumeration;
</ProgramListing></Para>
</InformalExample>
<Para>A data value of this data type is an attribute value whose
syntax is <Literal>OM_S_ENUMERATION</Literal>.
</Para>
</Sect2>
<Sect2 Id="DCEADG.REFSE.div.7">
<Title>OM_exclusions</Title>
<Para>The <Literal>OM_exclusions</Literal> data type is used for the <Symbol Role="Variable">exclusions</Symbol> parameter of
<Function>om_get(&thinsp;)</Function>.  Its C declaration is as follows:
</Para>
<InformalExample>
<Para><ProgramListing>typedef OM_uint OM_exclusions;
</ProgramListing></Para>
</InformalExample>
<Para>A data value of this data type is an unordered set of one or
more values, all of which are distinct.  Each value indicates
an exclusion, as defined by <Function>om_get(&thinsp;)</Function>, and is chosen
from the following set:
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>OM_EXCLUDE_ALL_BUT_THESE_TYPES
</Literal></Para>
</ListItem>
<ListItem>
<Para><Literal>OM_EXCLUDE_MULTIPLES</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_EXCLUDE_ALL_BUT_THESE_VALUES</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_EXCLUDE_VALUES</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_EXCLUDE_SUBOBJECTS</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_EXCLUDE_DESCRIPTORS</Literal>
</Para>
</ListItem>
</ItemizedList>
<Para>Alternatively, the single value
<Literal>OM_NO_EXCLUSIONS</Literal>
can be chosen; this selects the entire object.
</Para>
<Para>Each value except <Literal>OM_NO_EXCLUSIONS</Literal>
is represented by a distinct bit.  The presence of the value
is represented as 1; its absence is represented as 0 (zero).  Thus,
multiple exclusions are requested by
ORing the values that indicate the individual
exclusions.
</Para>
</Sect2>
<Sect2 Id="DCEADG.REFSE.div.8">
<Title>OM_integer</Title>
<Para>The <Literal>OM_integer</Literal> data type is used to indicate an integer data value.
Its C declaration is as follows:
</Para>
<InformalExample>
<Para><ProgramListing>typedef OM_sint32 OM_integer;
</ProgramListing></Para>
</InformalExample>
<Para>A data value of this data type is an attribute value whose
syntax is <Literal>OM_S_INTEGER</Literal>.
</Para>
</Sect2>
<Sect2 Id="DCEADG.REFSE.div.9">
<Title>OM_modification</Title>
<Para>The <Literal>OM_modification</Literal> data type is used for the <Symbol Role="Variable">modification</Symbol>
parameter of <Function>om_put(&thinsp;)</Function>.  Its C declaration is as follows:
</Para>
<InformalExample>
<Para><ProgramListing>typedef OM_uint OM_modification;
</ProgramListing></Para>
</InformalExample>
<Para>A data value of this data type indicates a kind of
modification, as defined by <Function>om_put(&thinsp;)</Function>.  It is chosen
from the following set:
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>OM_INSERT_AT_BEGINNING
</Literal></Para>
</ListItem>
<ListItem>
<Para><Literal>OM_INSERT_AT_CERTAIN_POINT</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_INSERT_AT_END</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_REPLACE_ALL</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_REPLACE_CERTAIN_VALUES</Literal>
</Para>
</ListItem>
</ItemizedList>
</Sect2>
<Sect2 Id="DCEADG.REFSE.div.10">
<Title>OM_object</Title>
<Para>The <Literal>OM_object</Literal> data type is used as a handle to either a
private or a public object.
<IndexTerm Id="DCEADG.REFSE.indx.10">
<Primary>object</Primary>
<Secondary>private</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.REFSE.indx.11">
<Primary>object</Primary>
<Secondary>public</Secondary>
</IndexTerm>Its C declaration is as follows:
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct OM_descriptor_struct *OM_object;
</ProgramListing></Para>
</InformalExample>
<Para>A data value of this data type represents an object,
which can be either public or private.
It is an ordered sequence of one or more instances
of the <Literal>OM_descriptor</Literal> data type.
See the <Literal>OM_private_object</Literal> and <Literal>OM_public_object</Literal>
data types for restrictions on that sequence (Sections 18.2.9 and
18.2.10, respectively).
</Para>
</Sect2>
<Sect2 Id="DCEADG.REFSE.div.11">
<Title>OM_object_identifier</Title>
<Para>The <Literal>OM_object_identifier</Literal> data type is used as an ASN.1 object identifier.
Its C declaration is as follows:
</Para>
<InformalExample>
<Para><ProgramListing>typedef OM_string OM_object_identifier;
</ProgramListing></Para>
</InformalExample>
<Para>A data value of this data type contains
an octet string that comprises the contents octets of the
BER encoding of an ASN.1 object identifier.
</Para>
<Sect3 Id="DCEADG.REFSE.div.12">
<Title>C Declaration of Object Identifiers</Title>
<Para>Every application program that uses a class or another object
identifier must explicitly import it into every compilation unit (C source
module) that uses it.  Each such class or object identifier name must
be explicitly exported from just one compilation module.  Most
application programs find it convenient to export all the names
they use from the same compilation unit.  Exporting and importing is
performed by using the following two macros:
</Para>
<ItemizedList>
<ListItem>
<Para>The importing macro makes the class or other object identifier constants
available within a compilation unit.
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>OM_IMPORT</Literal><Symbol Role="Variable">(class_name</Symbol><Literal>)
</Literal></Para>
</ListItem>
<ListItem>
<Para><Literal>OM_IMPORT</Literal>(<Symbol Role="Variable">OID_name</Symbol><Literal>)</Literal>
</Para>
</ListItem>
</ItemizedList>
</ListItem>
<ListItem>
<Para>The exporting macro allocates memory for the constants that
represent the class or another object identifier.
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>OM_EXPORT</Literal>(<Symbol Role="Variable">class_name</Symbol>)</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_EXPORT</Literal>(<Symbol Role="Variable">OID_name</Symbol><Literal>)</Literal>
</Para>
</ListItem>
</ItemizedList>
</ListItem>
</ItemizedList>
<Para>Object identifiers are defined in the appropriate header files, with the
definition
identifier having the prefix <Literal>OMP_O_</Literal> followed by the variable
name for the object identifier.  The constant itself provides the
hexadecimal value of the object identifier string.
</Para>
</Sect3>
<Sect3 Id="DCEADG.REFSE.div.13">
<Title>Use of Object Identifiers in C</Title>
<Para>The following macro initializes a descriptor:
</Para>
<InformalExample>
<Para><ProgramListing><Literal>OM_OID_DESC(</Literal><Symbol Role="Variable">type, OID_name</Symbol><Literal>)</Literal>
</ProgramListing></Para>
</InformalExample>
<Para>It sets the <Symbol Role="Variable">type</Symbol> component to that
given, sets the <Symbol Role="Variable">syntax</Symbol> component to
<Literal>OM_S_OBJECT_IDENTIFIER_STRING</Literal>,
and sets the <Symbol Role="Variable">value</Symbol> component to the specified object identifier.
</Para>
<Para>The following macro initializes a descriptor to mark the end of a
client-allocated public object:
</Para>
<InformalExample>
<Para><ProgramListing><Literal>OM_NULL_DESCRIPTOR</Literal>
</ProgramListing></Para>
</InformalExample>
<Para>For each class, there is a global
variable of type <Literal>OM_STRING</Literal> with the same name;
for example, the External class has a variable called <Literal>OM_C_EXTERNAL</Literal>.
This is also the case for other object identifiers; for example,
the object identifier for BER rules has a variable called
<Literal>OM_BER</Literal>.
This global variable can be supplied as a
parameter to functions when required.
</Para>
<Para>This variable is valid only when it is exported by an <Literal>OM_EXPORT</Literal>
macro and imported by an <Literal>OM_IMPORT</Literal> macro in the compilation
units that use it.  This variable cannot form part of a descriptor, but
the value of its length and elements components can be used.
The following code fragment provides
examples of the use of the macros and constants.
</Para>
<InformalExample>
<Para><ProgramListing><?sml-need 35>/* Examples of the use of the macros and constants */

#include &lt;xom.h>

OM_IMPORT(OM_C_ENCODING)
OM_IMPORT(OM_CANONICAL_BER)

/*  The following sequence must appear in just one compilation
 *  unit in place of the above:
 *
 *  #include &lt;xom.h>
 *
 *  OM_EXPORT(OM_C_ENCODING)
 *  OM_EXPORT(OM_CANONICAL_BER)
 */

main(&thinsp;)
{
/* Use #1 - Define a public object of class Encoding
 *          (Note: xxxx is a Message Handling class which 
 *           can be encoded)
 */
OM_descriptor my_public_object[] = {
        OM_OID_DESC(OM_CLASS, OM_C_ENCODING),
        OM_OID_DESC(OM_OBJECT_CLASS, MA_C_xxxx),
        { OM_OBJECT_ENCODING, OM_S_ENCODING_STRING, \
          some_BER_value },
        OM_OID_DESC(OM_RULES, OM_CANONICAL_BER),
        OM_NULL_DESCRIPTOR
        };

/* Use #2 - Pass class Encoding as parameter to om_instance(&thinsp;)
 */
return_code = om_instance(my_object, OM_C_ENCODING,
&amp;boolean_result);
}
</ProgramListing></Para>
</InformalExample>
</Sect3>
</Sect2>
<Sect2 Id="DCEADG.REFSE.div.14">
<Title>OM_private_object</Title>
<Para>The <Literal>OM_private_object</Literal> data type is used as a handle to an object in an
implementation-defined or private representation.
Its C declaration is as follows:
</Para>
<InformalExample>
<Para><ProgramListing>typedef OM_object OM_private_object;
</ProgramListing></Para>
</InformalExample>
<Para>A data value of this data type is the designator or handle
to a private object.
It comprises a single descriptor whose <Symbol Role="Variable">type</Symbol> component is
<Literal>OM_PRIVATE_OBJECT</Literal>
and whose <Symbol Role="Variable">syntax</Symbol> and <Symbol Role="Variable">value</Symbol> components are unspecified.
</Para>
<Note>
<Para>The descriptor's <Symbol Role="Variable">syntax</Symbol>
and <Symbol Role="Variable">value</Symbol> components are essential to the service's proper
operation with respect to the private object.
</Para>
</Note>
</Sect2>
<Sect2 Id="DCEADG.REFSE.div.15">
<Title>OM_public_object</Title>
<Para>The <Literal>OM_public_object</Literal> data type is used to define an
object that can be directly accessed by a programmer.
Its C declaration is as follows:
</Para>
<InformalExample>
<Para><ProgramListing>typedef OM_object OM_public_object;
</ProgramListing></Para>
</InformalExample>
<Para>A data value of this data type is a public object.
It comprises one or more (usually more) descriptors,
all but the last of which represent values of attributes of the object.
</Para>
<Para>The descriptors for the values of a particular attribute
with two or more values are adjacent to one another in the sequence.
Their order is that of the values they represent.
The order of the resulting groups of descriptors is unspecified.
</Para>
<Para>Since the Class attribute specific to the Object class is represented
among the descriptors, it must be represented before any other attributes.
Regardless of whether or not the Class attribute is present, the syntax
field of the first descriptor must have the <Literal>OM_S_SERVICE_GENERATED</Literal>
bit set or cleared appropriately.
</Para>
<Para><?sml-need 4>The last descriptor signals the end of the sequence of
descriptors.  The last descriptor's <Symbol Role="Variable">type</Symbol> component is
<Literal>OM_NO_MORE_TYPES</Literal> and
its <Symbol Role="Variable">syntax</Symbol> component is
<Literal>OM_S_NO_MORE_SYNTAXES</Literal>.
The last descriptor's <Symbol Role="Variable">value</Symbol> component is unspecified.
</Para>
</Sect2>
<Sect2 Id="DCEADG.REFSE.div.16">
<Title>OM_return_code</Title>
<Para>The <Literal>OM_return_code</Literal> data type is used for a value that is
returned from all
OM functions, indicating either that the function succeeded or
why it failed.
Its C declaration is as follows:
</Para>
<InformalExample>
<Para><ProgramListing>typedef OM_uint OM_return_code;
</ProgramListing></Para>
</InformalExample>
<Para>A data value of this data type is the integer in the range 0 to  2<?sml-size -2><Superscript>16</Superscript><?sml-size +2>
that indicates an outcome of an interface function.
It is chosen from the set specified in Section 18.4.
</Para>
<Para>Integers in the narrower
range 0 to 2<?sml-size -2><Superscript>15</Superscript><?sml-size +2> are used to indicate the return codes they define.
<IndexTerm Id="DCEADG.REFSE.indx.12">
<Primary>return codes</Primary>
</IndexTerm></Para>
</Sect2>
<Sect2 Id="DCEADG.REFSE.div.17">
<Title>OM_string</Title>
<Para>The <Literal>OM_string</Literal> data type is used for a data value of String syntax.
Its C declaration is as follows:
</Para>
<InformalExample>
<Para><ProgramListing>typedef OM_uint32 OM_string_length;
typedef struct {
      OM_string_length length;
      void *elements;
} OM_string;

#define OM_STRING(string)&bsol;
      { (OM_string_length)(sizeof(string)-1), (string) }
</ProgramListing></Para>
</InformalExample>
<Para>A data value of this data type is a string; that is,
an instance of a String syntax.
A string is specified either in terms of its length or whether or not
it terminates with NULL.
</Para>
<Para><?sml-need 7>A string has the following components:
</Para>
<ItemizedList>
<ListItem>
<Para><Symbol Role="Variable">length</Symbol> (<Literal>OM_string_length</Literal>)
</Para>
<Para><IndexTerm Id="DCEADG.REFSE.indx.13">
<Primary>string</Primary>
<Secondary>length</Secondary>
</IndexTerm>The number of octets by means of which the string
is represented, or the
<Literal>OM_LENGTH_UNSPECIFIED</Literal> value
<IndexTerm Id="DCEADG.REFSE.indx.14">
<Primary>length-unspecified</Primary>
</IndexTerm>if the string terminates with NULL.
</Para>
</ListItem>
<ListItem>
<Para><Symbol Role="Variable">elements</Symbol>
</Para>
<Para>The string's elements.
<IndexTerm Id="DCEADG.REFSE.indx.15">
<Primary>elements, string</Primary>
</IndexTerm>The bits of a bit string are
represented as a sequence of octets (see Figure 18-1).
The first octet
stores the number of unused bits in the last octet.  The bits in
the bit string, commencing with the first bit and proceeding
to the trailing bit, are placed in bits 7 to 0 of the
second octet.  These are followed by bits 7 to 0 of the
third octet, then by bits 7 to 0 of each
octet in turn, followed by as many bits as are required of the
final octet, commencing with bit 7.
</Para>
</ListItem>
</ItemizedList>
<Figure>
<Title>OM_String Elements</Title>
<Graphic Format="EPS" Entityref="DCEADG.REFSE.pic.1"></Graphic>
</Figure>
<!-- .dI ../directory/ref/Pics/fig1.pic-->
<Para>The service supplies a string value with a specified length.
The client can supply a string value to the service in either form,
either with a specified length or terminated with NULL.
</Para>
<Para><?sml-need 7>The characters of a character string are represented as any sequence of
<IndexTerm Id="DCEADG.REFSE.indx.16">
<Primary>character string</Primary>
</IndexTerm>octets permitted as the primitive contents octets of the BER
encoding of an ASN.1 type value.  The ASN.1 type defines the
type of character string.  A 0 (zero) value character follows
the characters of the character string,
but is not encompassed by the <Symbol Role="Variable">length</Symbol> component.
Thus, depending on the type of character string,
the 0 (zero) value character
can delimit the characters of the character string.
</Para>
<Para><?sml-need 3>The <Literal>OM_STRING</Literal> macro
is provided for creating a data value of this data type, given
only the value of its <Symbol Role="Variable">elements</Symbol> component.
The macro,
however,
applies to octet strings and character strings, but not to bit strings.
</Para>
</Sect2>
<Sect2 Id="DCEADG.REFSE.div.18">
<Title>OM_syntax</Title>
<Para>The <Literal>OM_syntax</Literal> data type is used to identify a syntax type.
Its C declaration is as follows:
</Para>
<InformalExample>
<Para><ProgramListing>typedef OM_uint16 OM_syntax;
</ProgramListing></Para>
</InformalExample>
<Para>A data value of this data type is an integer in the
range 0 to 2<?sml-size -2><Superscript>9</Superscript><?sml-size +2> that indicates an individual syntax
or a set of syntaxes taken together.
</Para>
<Para>The data value is chosen from among the following:
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>OM_S_BIT_STRING</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_S_BOOLEAN</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_S_ENCODING_STRING</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_S_ENUMERATION</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_S_GENERAL_STRING</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_S_GENERALIZED_TIME_STRING</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_S_GRAPHIC_STRING</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_S_IA5_STRING</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_S_INTEGER</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_S_NULL</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_S_NUMERIC_STRING</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_S_OBJECT</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_S_OBJECT_DESCRIPTOR_STRING</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_S_OBJECT_IDENTIFIER_STRING</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_S_OCTET_STRING</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_S_PRINTABLE_STRING</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_S_TELETEX_STRING</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_S_VIDEOTEX_STRING</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_S_VISIBLE_STRING</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>OM_S_UTC_TIME_STRING</Literal>
</Para>
</ListItem>
</ItemizedList>
<IndexTerm Id="DCEADG.REFSE.indx.17">
<Primary>encoding</Primary>
</IndexTerm>
<Para>Integers in the narrower range
<IndexTerm Id="DCEADG.REFSE.indx.18">
<Primary>integers</Primary>
</IndexTerm> 0 to 2<?sml-size -2><Superscript>9</Superscript><?sml-size +2> are used to indicate the syntaxes they define.
The integers in the range 2<?sml-size -2><Superscript>9</Superscript><?sml-size +2> to 2<?sml-size -2><Superscript>10</Superscript><?sml-size +2> are
reserved for vendor extensions.
Wherever possible, the integers used are the same as the corresponding
ASN.1 universal class number.
</Para>
</Sect2>
<Sect2 Id="DCEADG.REFSE.div.19">
<Title>OM_type</Title>
<Para>The <Literal>OM_type</Literal> data type is used to identify an OM attribute type.
<IndexTerm Id="DCEADG.REFSE.indx.19">
<Primary>attribute</Primary>
<Secondary>OM type</Secondary>
</IndexTerm>Its C declaration is as follows:
</Para>
<InformalExample>
<Para><ProgramListing>typedef OM_uint16 OM_type;
</ProgramListing></Para>
</InformalExample>
<Para>A data value of this data type is an integer
in the range 0 to 2<?sml-size -2><Superscript>16</Superscript><?sml-size +2> that indicates 
a type in the context of a package.
However, the following values in Table 18-2
are assigned meanings by the respective data
types.
</Para>
<Table Frame="all" Remap="center" Orient="Port">
<Title>Assigning Meanings to Values</Title>
<TGroup Cols="2">
<ColSpec Colsep="1" Align="Left" Colwidth="1*" Colname="col1" Colnum="1">
<ColSpec Align="Left" Colwidth="1*" Colname="col2" Colnum="2">
<thead>
<Row>
<Entry rowsep="1"><Literal>Value</Literal></Entry>
<Entry rowsep="1"><Literal>Data Type</Literal></Entry>
</Row>
</thead>
<tbody>

<Row>
<Entry rowsep="1"><Literal>OM_NO_MORE_TYPES</Literal></Entry>
<Entry rowsep="1"><Literal>OM_type_list</Literal></Entry>
</Row>
<Row>
<Entry rowsep="1"><Literal>OM_PRIVATE_OBJECT</Literal></Entry>
<Entry rowsep="1"><Literal>OM_private_object</Literal></Entry>
</Row>
</TBody>
</TGroup>
</Table>
<Para><IndexTerm Id="DCEADG.REFSE.indx.20">
<Primary>object</Primary>
<Secondary>private</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.REFSE.indx.21">
<Primary>object</Primary>
<Secondary>public</Secondary>
</IndexTerm></Para>
<Para>Integers in
the narrower range 0 to 2<?sml-size -2><Superscript>15</Superscript><?sml-size +2> are used
to indicate the types they define.
</Para>
</Sect2>
<Sect2 Id="DCEADG.REFSE.div.20">
<Title>OM_type_list</Title>
<Para>The <Literal>OM_type_list</Literal> data type is used to enumerate a
sequence of OM attribute types.
<IndexTerm Id="DCEADG.REFSE.indx.22">
<Primary>attribute</Primary>
<Secondary>type</Secondary>
</IndexTerm>Its C declaration is as follows:
</Para>
<InformalExample>
<Para><ProgramListing>typedef OM_type *OM_type_list;
</ProgramListing></Para>
</InformalExample>
<Para>A data value of this data type is an ordered sequence of
zero or more type numbers, each of which
is an instance of the <Literal>OM_type</Literal> data type.
</Para>
<Para>An additional data value,
<Literal>OM_NO_MORE_TYPES</Literal>,
follows and thus delimits the sequence.
The C representation of the sequence is an array.
</Para>
</Sect2>
<Sect2 Id="DCEADG.REFSE.div.21">
<Title>OM_value</Title>
<Para>The <Literal>OM_value</Literal> data type is used to represent any data value.
<IndexTerm Id="DCEADG.REFSE.indx.23">
<Primary>value</Primary>
<Secondary>OM data</Secondary>
</IndexTerm>Its C declaration is as follows:
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct {
      OM_uint32 padding;
      OM_object object;
} OM_padded_object;

typedef union OM_value_union {
      OM_string         string;
      OM_boolean        boolean;
      OM_enumeration    enumeration;
      OM_integer        integer;
      OM_padded_object  object;
} OM_value;
</ProgramListing></Para>
</InformalExample>
<Note>
<Para>The first type definition (in particular, its <Literal>padding</Literal>
component) aligns the
<Literal>object</Literal> component with the <Symbol Role="Variable">elements</Symbol> component of
the <Literal>string</Literal> component in the second type definition.
This facilitates initialization in C.
</Para>
<Para>The identifier <Literal>OM_value_union</Literal> is defined for reasons of
compilation order.
It is used in the definition of the <Literal>OM_descriptor</Literal> data type.
</Para>
</Note>
<Para>A data value of this data type is an attribute value.
It has no components if the value's syntax is
<Literal>OM_S_NO_MORE_SYNTAXES</Literal> or <Literal>OM_S_NO_VALUE</Literal>.
Otherwise, it has one of the following components:
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>string</Literal>
</Para>
<Para>The value if its syntax is a string syntax
<IndexTerm Id="DCEADG.REFSE.indx.24">
<Primary>string</Primary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para><Literal>boolean</Literal>
</Para>
<Para>The value if its syntax is <Literal>OM_S_BOOLEAN</Literal>
<IndexTerm Id="DCEADG.REFSE.indx.25">
<Primary>Boolean</Primary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para><Literal>enumeration</Literal>
</Para>
<Para>The value if its syntax is <Literal>OM_S_ENUMERATION</Literal>
<IndexTerm Id="DCEADG.REFSE.indx.26" SpanEnd="DCEADG.REFSE.indx.9"></Para>
</ListItem>
<ListItem>
<Para><Literal>integer</Literal>
</Para>
<Para>The value if its syntax is <Literal>OM_S_INTEGER</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>object</Literal>
</Para>
<Para>The value if its syntax is <Literal>OM_S_OBJECT</Literal>
</Para>
</ListItem>
</ItemizedList>
<Note>
<Para>A data value of this data type is only displayed as a component of a descriptor.
Thus, it is always accompanied by indicators of the value's
syntax.
The latter indicator reveals which component is present.
</Para>
</Note>
</Sect2>
<Sect2 Id="DCEADG.REFSE.div.22">
<Title>OM_value_length</Title>
<Para>The <Literal>OM_value_length</Literal> data type is used to indicate the number of bits,
octets,
or characters in a string.
<IndexTerm Id="DCEADG.REFSE.indx.27">
<Primary>character string</Primary>
<Secondary>length</Secondary>
</IndexTerm>Its C declaration is as follows:
</Para>
<InformalExample>
<Para><ProgramListing>typedef OM_uint32 OM_value_length;
</ProgramListing></Para>
</InformalExample>
<Para>A data value of this data type is an integer in the range
0 to 2<?sml-size -2><Superscript>32</Superscript><?sml-size +2>
that represents the number of bits in a bit string,
octets in an octet string,
or characters in a character string.
<IndexTerm Id="DCEADG.REFSE.indx.28">
<Primary>character string</Primary>
</IndexTerm></Para>
<Note>
<Para>This data type is not used in the definition of the interface.
It is provided for use by client programmers for defining
attribute constraints.
</Para>
</Note>
</Sect2>
<Sect2 Id="DCEADG.REFSE.div.23">
<Title>OM_value_position</Title>
<Para>The <Literal>OM_value_position</Literal> data type is used to indicate an attribute value's
position within an attribute.
Its C declaration is as follows:
</Para>
<InformalExample>
<Para><ProgramListing>typedef OM_uint32 OM_value_position;
</ProgramListing></Para>
</InformalExample>
<Para><IndexTerm Id="DCEADG.REFSE.indx.29" SpanEnd="DCEADG.REFSE.indx.18">A data value of this data type is an integer in the range
0 to 2<?sml-size -2><Superscript>32</Superscript><?sml-size +2>-1
that indicates the position of a value within an attribute.
However, the value <Literal>OM_ALL_VALUES</Literal>
has the meaning assigned to it by <Function>om_get(&thinsp;)</Function>.
</Para>
</Sect2>
<Sect2 Id="DCEADG.REFSE.div.24">
<Title>OM_workspace</Title>
<Para><IndexTerm Id="DCEADG.REFSE.indx.30">
<Primary>workspace</Primary>
</IndexTerm>The <Literal>OM_workspace</Literal> data type is used to identify an application-specific
API that implements OM; for example, directory or message handling.
Its C declaration is as follows:
</Para>
<InformalExample>
<Para><ProgramListing>typedef void *OM_workspace;
</ProgramListing></Para>
</InformalExample>
<Para>A data value of this data type is the designator or handle for a workspace.
</Para>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.REFSE.div.25">
<Title>XOM Functions</Title>
<Para>This section provides an overview of the XOM service interface functions as
listed in Table 18-3.  For a full description of these functions,
see the <Symbol Role="Variable">*</Symbol><Literal>(3xom)</Literal> reference pages. 
</Para>
<?sml-need 30>
<Table Frame="all" Remap="center" Orient="Port">
<Title>XOM Service Interface Functions</Title>
<TGroup Cols="2">
<ColSpec Colsep="1" Align="Left" Colwidth="1*" Colname="col1" Colnum="1">
<ColSpec Align="Left" Colwidth="1*" Colname="col2" Colnum="2">
<thead>
<Row>
<Entry rowsep="1"><Literal>Function</Literal></Entry>
<Entry rowsep="1"><Literal>Description</Literal></Entry>
</Row>
</thead>
<tbody>

<Row>
<Entry Rowsep="1"><Function>om_copy(&thinsp;)</Function></Entry>
<Entry Rowsep="1">Copies a private object.</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Function>om_copy_value(&thinsp;)</Function></Entry>
<Entry Rowsep="1">Copies a string between private objects.</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Function>om_create(&thinsp;)</Function></Entry>
<Entry Rowsep="1">Creates a private object.</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Function>om_decode(&thinsp;)</Function></Entry>
<Entry Rowsep="1">
Not supported by the DCE XOM
interface; it returns an <Literal>OM_FUNCTION_DECLINED</Literal> error.
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Function>om_delete(&thinsp;)</Function></Entry>
<Entry Rowsep="1">Deletes a private or service-generated object.</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Function>om_encode(&thinsp;)</Function></Entry>
<Entry Rowsep="1">
Not supported by the DCE XOM
interface; it returns an <Literal>OM_FUNCTION_DECLINED</Literal> error.
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Function>om_get(&thinsp;)</Function></Entry>
<Entry Rowsep="1">
Gets copies of attribute values from a private object.
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Function>om_instance(&thinsp;)</Function></Entry>
<Entry Rowsep="1">Tests an object's class.</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Function>om_put(&thinsp;)</Function></Entry>
<Entry Rowsep="1">Puts attribute values into a private object.</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Function>om_read(&thinsp;)</Function></Entry>
<Entry Rowsep="1">Reads a segment of a string in a private object.</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Function>om_remove(&thinsp;)</Function></Entry>
<Entry Rowsep="1">Removes attribute values from a private object.</Entry>
</Row>
<Row>
<Entry><Function>om_write(&thinsp;)</Function></Entry>
<Entry>Writes a segment of a string into a private object.</Entry>
</Row>
</TBody>
</TGroup>
</Table>
<Para>The purpose and range of capabilities of the service interface functions
can be summarized as follows:
</Para>
<ItemizedList>
<ListItem>
<Para><Function>om_copy(&thinsp;)</Function>
</Para>
<Para>This function creates an independent copy of an existing private object
and all its subobjects.
The copy is placed in the workspace of the original object,
or in another workspace specified by the DCE client.
</Para>
</ListItem>
<ListItem>
<Para><Function>om_copy_value(&thinsp;)</Function>
</Para>
<Para>This function replaces an existing attribute value or inserts a new value
in one private object with a copy of an existing attribute value
found in another.
Both values must be strings.
</Para>
</ListItem>
<ListItem>
<?sml-need 15>
<Para><Function>om_create(&thinsp;)</Function>
</Para>
<Para>This function creates a new private object that is an instance of 
a particular class.
The object can be initialized with the attribute values specified as
initial in the class definition.
The service does not permit the client to explicitly create instances of 
all classes, but rather only those indicated
by a package's definition as having this property.
</Para>
</ListItem>
<ListItem>
<Para><Function>om_delete(&thinsp;)</Function>
</Para>
<Para>This function deletes a service-generated public object
or makes a private object inaccessible.
</Para>
</ListItem>
<ListItem>
<Para><Function>om_get(&thinsp;)</Function>
</Para>
<Para>This function creates a new public object that is an exact, but independent, copy of an existing private object.
The client can request certain exclusions,
each of which reduces the copy to a part of the original.
The client can also request that values be converted from one syntax to another before they are returned.
</Para>
<Para>The copy can exclude attributes of types other than those specified, values
at positions other than those specified within an attribute,
values of multivalued attributes,
copies of (not handles for) subobjects,
or all attribute values.  Excluding all attribute
values reveals only an attribute's presence.
</Para>
</ListItem>
<ListItem>
<Para><Function>om_instance(&thinsp;)</Function>
</Para>
<Para>This function determines whether an object is an instance of a particular class.
The client can determine an object's class simply by inspection.
This function is useful since it reveals that an object
is an instance of a particular class,
even if the object is an instance of a subclass of that class.
</Para>
</ListItem>
<ListItem>
<Para><Function>om_put(&thinsp;)</Function>
</Para>
<Para>This function places or replaces in one private object
copies of the attribute values of another
public or private object.
</Para>
<Para>The source values can be inserted before any existing destination values,
before the value at a specified position in the destination attribute,
or after any existing destination values.
Alternatively,
the source values can be substituted for any existing destination values or for the values at specified positions in the destination attribute.
</Para>
</ListItem>
<ListItem>
<?sml-need 6>
<Para><Function>om_read(&thinsp;)</Function>
</Para>
<Para>This function reads a segment of a value of an attribute of a private object.
The value must be a string.
The value can first be converted from one syntax to another.
This function enables the client to read an arbitrarily long value without requiring that the service place a copy of the entire value in memory.
</Para>
</ListItem>
<ListItem>
<Para><Function>om_remove(&thinsp;)</Function>
</Para>
<Para>This function removes and discards particular values of an attribute of a private object.
The attribute itself is removed if no values remain.
</Para>
</ListItem>
<ListItem>
<Para><Function>om_write(&thinsp;)</Function>
</Para>
<Para>This function writes a segment of an attribute value to a private object.
The value must be a string.
The segment can first be converted from one syntax to another.
The written segment becomes the value's last segment since
any elements beyond it are discarded.
The function enables the client to write an arbitrarily long value without having to place a copy of the entire value in memory.
</Para>
</ListItem>
</ItemizedList>
</Sect1>
<Sect1 Id="DCEADG.REFSE.div.26">
<Title>XOM Return Codes</Title>
<Para>This section defines
the return codes of the service interface,
<IndexTerm Id="DCEADG.REFSE.indx.31">
<Primary>return codes</Primary>
<Secondary>service interface</Secondary>
</IndexTerm>and thus the exceptions that can prevent the successful
completion of an interface function.
</Para>
<Para>Refer to the <Literal>ERRORS</Literal> section of the <Symbol Role="Variable">*</Symbol><Literal>(3xom)</Literal> references pages
for a list of the errors that each function can return.  For an explanation of 
these error codes, refer to the &DCETg;.
</Para>
<Para>The return code values are as follows:
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>0</Literal></Term>
<ListItem>
<Para><Literal>OM_SUCCESS</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>1</Literal></Term>
<ListItem>
<Para><Literal>OM_ENCODING_INVALID</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>2</Literal></Term>
<ListItem>
<Para><Literal>OM_FUNCTION_DECLINED</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>3</Literal></Term>
<ListItem>
<Para><Literal>OM_FUNCTION_INTERRUPTED</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>4</Literal></Term>
<ListItem>
<Para><Literal>OM_MEMORY_INSUFFICIENT</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>5</Literal></Term>
<ListItem>
<Para><Literal>OM_NETWORK_ERROR</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>6</Literal></Term>
<ListItem>
<Para><Literal>OM_NO_SUCH_CLASS</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>7</Literal></Term>
<ListItem>
<Para><Literal>OM_NO_SUCH_EXCLUSION</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>8</Literal></Term>
<ListItem>
<Para><Literal>OM_NO_SUCH_MODIFICATION</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>9</Literal></Term>
<ListItem>
<Para><Literal>OM_NO_SUCH_OBJECT</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>10</Literal></Term>
<ListItem>
<Para><Literal>OM_NO_SUCH_RULES</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>11</Literal></Term>
<ListItem>
<Para><Literal>OM_NO_SUCH_SYNTAX</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>12</Literal></Term>
<ListItem>
<Para><Literal>OM_NO_SUCH_TYPE</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>13</Literal></Term>
<ListItem>
<Para><Literal>OM_NO_SUCH_WORKSPACE</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>14</Literal></Term>
<ListItem>
<Para><Literal>OM_NOT_AN_ENCODING</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>15</Literal></Term>
<ListItem>
<Para><Literal>OM_NOT_CONCRETE</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>16</Literal></Term>
<ListItem>
<Para><Literal>OM_NOT_PRESENT</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>17</Literal></Term>
<ListItem>
<Para><Literal>OM_NOT_PRIVATE</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>18</Literal></Term>
<ListItem>
<Para><Literal>OM_NOT_THE_SERVICES</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>19</Literal></Term>
<ListItem>
<Para><Literal>OM_PERMANENT_ERROR</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>20</Literal></Term>
<ListItem>
<Para><Literal>OM_POINTER_INVALID</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>21</Literal></Term>
<ListItem>
<Para><Literal>OM_SYSTEM_ERROR</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>22</Literal></Term>
<ListItem>
<Para><Literal>OM_TEMPORARY_ERROR</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>23</Literal></Term>
<ListItem>
<Para><Literal>OM_TOO_MANY_VALUES</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>24</Literal></Term>
<ListItem>
<Para><Literal>OM_VALUES_NOT_ADJACENT</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>25</Literal></Term>
<ListItem>
<Para><Literal>OM_WRONG_VALUE_LENGTH</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>26</Literal></Term>
<ListItem>
<Para><Literal>OM_WRONG_VALUE_MAKEUP</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>27</Literal></Term>
<ListItem>
<Para><Literal>OM_WRONG_VALUE_NUMBER</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>28</Literal></Term>
<ListItem>
<Para><Literal>OM_WRONG_VALUE_POSITION</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>29</Literal></Term>
<ListItem>
<Para><Literal>OM_WRONG_VALUE_SYNTAX</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>30</Literal></Term>
<ListItem>
<Para><Literal>OM_WRONG_VALUE_TYPE</Literal>
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Sect1>
</Chapter>
<!--+ 09/23/96 11:54:18
    | tagMorph:  $Id: 2_se.xom.sgm,v 1.1.2.12 1996/12/17 19:28:46 damon Exp $
    | tagMorph library:  $Id: 2_se.xom.sgm,v 1.1.2.12 1996/12/17 19:28:46 damon Exp $
    | sml-to-docbook:  1.21
    +-->
