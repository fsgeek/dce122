<!--
# @OSF_COPYRIGHT@
# 
# 
# HISTORY
# $Log: nameservice.sgm,v $
# Revision 1.1.2.6  1996/11/25  18:18:56  carrig
# 	{enh,R1.2.2}
# 	VarListEntry, Figure, Table, Code Examples
# 	[1996/11/25  18:18:13  carrig]
#
# Revision 1.1.2.5  1996/11/23  23:04:41  weir
# 	No change
# 	[1996/11/23  23:04:11  weir]
# 
# Revision 1.1.2.4  1996/11/21  18:06:53  weir
# 	Shortened some source lines
# 	[1996/11/21  18:05:59  weir]
# 
# Revision 1.1.2.3  1996/11/21  16:52:38  weir
# 	Corrected entity declarations, etc.
# 	[1996/11/21  16:51:47  weir]
# 
# Revision 1.1.2.2  1996/11/20  22:28:04  weir
# 	Added entity declarations
# 	[1996/11/20  22:27:23  weir]
# 
# Revision 1.1.2.1  1996/11/20  21:56:17  weir
# 	Initial submission
# 	[1996/11/20  21:55:16  weir]
# 
# $EndLog$
-->
<!-- Fragment document type declaration subset:
ArborText, Inc., 1988-1993, v.4001
<!DOCTYPE Book PUBLIC "-//Davenport//DTD DocBook V2.4//EN" [
<!ENTITY  ADGISG.NAMESV.pic.1  SYSTEM "eps/nameservice_01.eps" NDATA EPS>
<!ENTITY  ADGISG.NAMESV.pic.2  SYSTEM "eps/nameservice_02.eps" NDATA EPS>
<!ENTITY  ADGISG.NAMESV.pic.3  SYSTEM "eps/nameservice_03.eps" NDATA EPS>
<!ENTITY  ADGISG.NAMESV.pic.4  SYSTEM "eps/nameservice_04.eps" NDATA EPS>
<!ENTITY  ADGISG.NAMESV.pic.5  SYSTEM "eps/nameservice_05.eps" NDATA EPS>
<!ENTITY  ADGISG.NAMESV.pic.6  SYSTEM "eps/nameservice_06.eps" NDATA EPS>
<!ENTITY  ADGISG.NAMESV.pic.7  SYSTEM "eps/nameservice_07.eps" NDATA EPS>
<!ENTITY  ADGISG.NAMESV.pic.8  SYSTEM "eps/nameservice_08.eps" NDATA EPS>
<!ENTITY  ADGISG.NAMESV.pic.9  SYSTEM "eps/nameservice_09.eps" NDATA EPS>
<!ENTITY  ADGISG.NAMESV.pic.10  SYSTEM "eps/nameservice_10.eps" NDATA EPS>
]>
-->
<!-- COPYRIGHT NOTICE-->
<!-- Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.-->
<!-- ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for-->
<!-- the full copyright text.-->
<!-- -->
<!-- -->
<!-- OLD HISTORY-->
<!-- Revision 1.1.4.1  1996/03/21  17:06:33  wardr-->
<!-- 	{edit R1.2.1}-->
<!-- 	Release Edits-->
<!-- 	[1996/03/21  17:05:44  wardr]-->
<!---->
<!-- Revision 1.1.2.12  1995/06/27  17:04:15  buckler-->
<!-- 	1.1 edits and Prentice Hall reformat-->
<!-- 	[1995/06/27  17:03:04  buckler]-->
<!-- -->
<!-- Revision 1.1.2.11  1994/11/22  16:46:26  neilson-->
<!-- 	Replaced book cross references with standard macros.-->
<!-- 	[1994/11/22  16:46:06  neilson]-->
<!-- -->
<!-- Revision 1.1.2.10  1994/11/22  15:41:35  weir-->
<!-- 	Some index work done-->
<!-- 	[1994/11/22  15:40:33  weir]-->
<!-- -->
<!-- Revision 1.1.2.9  1994/11/15  16:25:49  weir-->
<!-- 	No change-->
<!-- 	[1994/11/15  16:25:11  weir]-->
<!-- -->
<!-- Revision 1.1.2.8  1994/10/20  20:56:22  weir-->
<!-- 	Fixed a few typos-->
<!-- 	[1994/10/20  20:55:54  weir]-->
<!-- -->
<!-- Revision 1.1.2.7  1994/10/19  20:48:18  weir-->
<!-- 	Review comments-->
<!-- 	[1994/10/19  20:47:27  weir]-->
<!-- -->
<!-- Revision 1.1.2.6  1994/10/19  16:02:53  weir-->
<!-- 	Review comments and edits-->
<!-- 	[1994/10/19  16:02:07  weir]-->
<!-- -->
<!-- Revision 1.1.2.5  1994/10/11  14:05:50  weir-->
<!-- 	Updates-->
<!-- 	[1994/10/11  14:04:57  weir]-->
<!-- -->
<!-- Revision 1.1.2.4  1994/09/23  19:57:47  weir-->
<!-- 	Updates for review-->
<!-- 	[1994/09/23  19:56:57  weir]-->
<!-- -->
<!-- Revision 1.1.2.3  1994/08/17  20:56:27  weir-->
<!-- 	First set of updates-->
<!-- 	[1994/08/17  20:55:43  weir]-->
<!-- -->
<!-- Revision 1.1.2.2  1994/08/11  20:36:45  jhh-->
<!-- 	expand copyright-->
<!-- 	[1994/08/11  19:58:54  jhh]-->
<!-- -->
<!-- Revision 1.1.2.1  1994/07/06  20:56:18  weir-->
<!-- 	Initial submit-->
<!-- 	[1994/07/06  20:55:50  weir]-->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
<Chapter Id="ADGISG.NAMESV.div.1">
<Title>Using the DCE Name Service</Title>
<!-- - -->
<!-- -->
<Para>Correct use of the DCE RPC Name Service Interface (NSI) is essential to the
operation of a distributed application, since NSI is the medium through
which the application's distributed parts must find each other.  NSI
works with named database entries which are hierarchically organized into
subdirectories and referenced by the familiar pathname convention.
<!-- -->
<!-- -->
<!-- -->
<!---->
<!---->
<!-- - -->
</Para>
<Sect1 Id="ADGISG.NAMESV.div.2">
<Title>Introduction to Using NSI</Title>
<!-- - -->
<!-- -->
<!-- -->
<!---->
<Para><IndexTerm Id="ADGISG.NAMESV.indx.1">
<Primary>names</Primary>
<Secondary>difference of from objects</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.NAMESV.indx.2">
<Primary>object</Primary>
<Secondary>difference of from names</Secondary>
</IndexTerm>It is important to remember that names and objects are separate things in DCE.
Consider, for example, these two DCE names:
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>/.../tinseltown.org/dce/printers/macmillan

/.../tinseltown.org/dce/employees/goethe
</UserInput></ProgramListing></Para>
</InformalExample>
<!-- -->
<Para><?sml-need 10>These strings are <Symbol Role="Variable">not</Symbol> filenames or file directory names; if you attempt
to execute the <Command>ls</Command> command on them, you will only get an error message.
They are pathnames that identify entries in the DCE Directory Service, which
<IndexTerm Id="ADGISG.NAMESV.indx.3">
<Primary>namespace</Primary>
<Secondary>defined</Secondary>
</IndexTerm>is DCE's database for storing distributed information.  This database is often
informally referred to as the <FirstTerm>namespace</FirstTerm>.
</Para>
<Para>The most important type of distributed information stored in the namespace
is information that enables RPC clients to rendezvous with RPC servers; it is
called <FirstTerm>binding information</FirstTerm>.  The directory service can be used to hold
other kinds of data too, but the main subject of the following discussions
will be its use as a binding repository.
</Para>
<Para>The set of binding name entries is like a huge data structure of pointers from
object names to object locations, and the directory service is used mostly as
a public DCE locational database, enabling servers to advertise themselves and
the objects and resources that they manage, and clients in turn to find and
access them.  You should never confuse objects with their names; the two are
separate things.  In particular, the directory service data associated with a
name is held in one place (namely, the directory server's database), while the
data associated with the object named is held in other place (namely, the object
server's database).
</Para>
<Para>How then, you might ask, are filenames represented in DCE? Here are two examples
<IndexTerm Id="ADGISG.NAMESV.indx.4">
<Primary>filenames</Primary>
<Secondary>representation of in DCE</Secondary>
</IndexTerm>of remote filenames:
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>/.../tinseltown.org/fs/doc/jones/app.gd/chap2.ps

/.../tinseltown.org/fs/doc/tolstoy/novels/war_and_peace/chap2.ps
</UserInput></ProgramListing></Para>
</InformalExample>
<!-- -->
<Para>As you may have guessed, these too are namespace entries, but the entries
in this case refer to remote files, and the entry name as a whole is the
remote filename.  What makes these names different from the other
two names given earlier is their third element, <Filename>fs/</Filename>,
which identifies a <FirstTerm>junction</FirstTerm> from the DCE Directory Service's namespace
into the DCE Distributed File Service's own, separately maintained, namespace.
</Para>
<Para><?sml-need 15>What happens is that <Filename>/.../tinseltown.org/fs</Filename>
is the DFS file server's DCE namespace entry, and any attempt by a file service
client to access a file object whose name begins with
<Filename>/.../tinseltown.org/fs</Filename>
will implicitly bind to this server, which will then be responsible for finding,
in its own namespace, the file object referred to by
<Filename>doc/jones/app.gd/chap2.ps</Filename> or
<Filename>doc/tolstoy/novels/war_and_peace/chap2.ps</Filename>
and performing the requested operations on it.
<!---->
<!---->
<!---->
<!---->
<!---->
<!-- - -->
</Para>
<Sect2 Id="ADGISG.NAMESV.div.3">
<Title>The UUID</Title>
<!-- - -->
<!---->
<Para>Thus, it is a mistake to suppose that a name is identical to an object. The
name merely points in the direction of the object it names.  Objects do,
however, have identifiers.  These are the 128-bit universal unique identifier
(UUID) data structures, which are the identities that the DCE components
recognize.  They are not usually seen by users, although they play a part in
the object-finding process.
</Para>
<Para>UUIDs are used within DCE to identify all sorts of things. From the
standpoint of the application programmer, they have two main uses: to
identify objects and to identify interfaces. 
<!-- -->
<!-- -->
<!---->
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.NAMESV.div.4">
<Title>Object UUIDs</Title>
<!-- - -->
<!---->
<Para>Although <FirstTerm>object</FirstTerm> is necessarily a rather vague term, a reasonable
definition would be the following: an object is any DCE entity that can be
accessed by a client, and which can be represented by a namespace entry and
identified therein by a UUID.  This category can include servers, devices,
and other resources.  UUIDs that are used in this way are called <FirstTerm>object
UUIDs</FirstTerm> in order to distinguish them from the other main use of UUIDs, namely
to identify interfaces (<Replaceable>interface UUIDs</Replaceable>).  The difference between these
two uses consists only in the way the UUIDs are interpreted by the name
service and RPC runtime.  Note that it follows from this discussion that an
interface is usually <Symbol Role="Variable">not</Symbol> an object.  Clients do not normally access an
interface as such; the interface is rather a description of the rules of
access.
</Para>
<Para><?sml-need 10>As far as the DCE RPC and name service mechanisms are concerned, it is enough
if a client is brought into contact with some server, as long as that server
offers the service the client is looking for; in other words, as long as
the server offers the interface the client wants to use.  To accomplish this
rendezvous, interface UUIDs are sufficient.  They are also mandatory.  There
cannot be a client/server relationship without an interface, and the entire RPC
runtime mechanism is dependent on the concept of interfaces.
</Para>
<Para>Object UUIDs are different. The RPC runtime usually does not care if they
are present or not.  But if they are present, they activate various runtime
mechanisms that allow clients and servers to be much more specific (always
within the bounds of a given interface) about what servers are bound to,
and/or what resources the servers will use to fulfill the clients' requests.
How this works is explained later in this chapter.
<!-- -->
<!---->
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.NAMESV.div.5">
<Title>Interface UUIDs</Title>
<!-- - -->
<!---->
<Para>Every IDL-compiled interface specification has its own UUID associated with
it, and the IDL-generated stub routines include this interface UUID with
every operation request or return sent over the network by clients and
servers.  In this way receiving stubs ensure that they and the sending stubs
are sharing exactly the same interface.  If the interface UUIDs are different,
or are not present, then the remote call will not be completed.  But
interface UUIDs, although they are required, play only a secondary role in a
client's finding the interface (that is, finding a server that offers
the interface); the main tool for this is NSI,
which makes use of the DCE Directory Service, as explained later in
this part of the chapter.
<!-- -->
<!-- -->
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.NAMESV.div.6">
<Title>Summary: Names and UUIDs</Title>
<!-- - -->
<!---->
<Para>Both names and UUIDs identify objects. But names are separable from the
objects they identify, and are only as trustworthy as the binding information
their entries contain.  UUIDs, on the other hand, are inalienable identifiers.
Once the desired binding information for an interface or an interface/object
combination has been found and used, the name that was used to retrieve it
can be forgotten; it is of no further use.  This is not true of either interface
or object UUIDs.
</Para>
<Para>Note that names become completely unnecessary only if clients have some other
means of obtaining valid binding information for the desired service, such as
string bindings.
<!-- -->
<!-- -->
</Para>
<Para>The following figure illustrates how the information a client finds through a
name is turned into network contact with the object named.
<!-- -->
<!-- - -->
<!-- - -->
<!-- Figure : to illustrate the hierarchy of identifiers-->
<!-- - -->
<!-- - -->
<!-- pix/figobj.pic-->
</Para>
<?sml-need 2.9i>
<Figure>
<Title>How a Name Turns into an Object</Title>
<Graphic Format="EPS" Entityref="ADGISG.NAMESV.pic.1"></Graphic>
</Figure>
<?sml-space .5>
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
</Sect2>
</Sect1>
<Sect1 Id="ADGISG.NAMESV.div.7">
<Title>Binding to an Object</Title>
<!-- - -->
<!-- -->
<Para>The difference between, for example, reading a local file on a single machine
and performing the same read on a remote file in DCE is like the difference
between reading information from a phone book yourself and dialing an operator
for the same information.  The remote operation requires the addition of another
active entity that can be requested to perform it, since you cannot.  Associated
with every piece of remote data available on a network is a remote server to
manage that data and make it available.  The user may not see the server; even
the client may be unaware of it, but it is there.
</Para>
<Para><?sml-need 10>The DCE documentation often speaks of ``binding to an object.'' In reality,
clients can bind only to servers, which then may be requested to perform
operations on objects that are under their management.  However, it is possible
for a server to put bindings into namespace entries that are named for the
objects that it manages.  Furthermore, these exported bindings can be tagged with
object UUIDs in such a way that incoming remote calls from clients can be
applied by the server to the object whose name entry the binding was read from
(the details of this technique are described later in this chapter).  When an
application uses this kind of binding model, it is reasonable to say that the
client is logically bound to the object, although it is physically always bound
to the server that manages the object.
<!---->
<!--  Note that the server could in fact be the-->
<!--  object.-->
<!-- -->
<!-- -->
<!-- - -->
</Para>
</Sect1>
<Sect1 Id="ADGISG.NAMESV.div.8">
<Title>Junctions</Title>
<!-- - -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<Para>Namespace junctions are another example of the hidden server effect. The
following remote filename was discussed earlier:
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>/.../tinseltown.org/fs/doc/jones/app.gd/chap2.ps
</UserInput></ProgramListing></Para>
</InformalExample>
<!-- -->
<Para>There it was explained that
<Filename>doc/jones/app.gd/chap2.ps</Filename>
is an entry in DCE DFS's own namespace, while
<Filename>/.../tinseltown.org/fs</Filename>
is a DCE namespace entry. Suppose a user enters the following:
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>ls -l /.../tinseltown.org/fs/doc/jones/app.gd
</UserInput></ProgramListing></Para>
</InformalExample>
<!-- -->
<Para>The clerk agent program (called as a result of the user's entering <Command>ls</Command>)
will bind to the remote file server via its
<Filename>/.../tinseltown.org/fs</Filename>
DCE namespace entry, and pass to it the residual DFS entry name
<Filename>doc/jones/app.gd</Filename>
along with other parameters. The <Command>ls</Command> command behaves this way because
the underlying (VFS+ layer) system calls are coded that way.  The DFS server
then performs the request (note that the details of interaction within DFS
are somewhat more complex than implied by this description).  The user only
types the command line; the rest is done by DCE, and a directory listing
appears on the user's screen.
</Para>
<Para><?sml-need 10>Because the VFS+ system routines, which are used by all possible clients of
DFS services (for example, commands like <Command>ls</Command> and <Command>rm</Command>, library
routines like <Function>fopen(&thinsp;)</Function> and
<Function>fclose(&thinsp;)</Function>), know about the remote
file server at
<Filename>/.../tinseltown.org/fs</Filename>
and bind to it correctly, the transition from the DCE to the DFS namespace
is completely transparent to users.  And this is how junctions work.  As long
as all possible clients behave correctly with a name that includes a junction,
the junction will not be perceptible to the clients' users.
<!-- -->
<!-- -->
<!-- - -->
</Para>
<Sect2 Id="ADGISG.NAMESV.div.9">
<Title>A Junction Example</Title>
<!-- - -->
<!-- -->
<Para>The next figure illustrates the principle of junctions. A junction server,
which is reached normally through binding information in the DCE namespace,
maintains its own namespace of named objects.  The junction server's clients
allow users to refer to these objects by actually concatenating the server's
entry name and an object's internal name.  The client then in effect breaks
this string apart by contacting the server named in the first part of the
string, and passing to it the second part, which is a valid name within the
server's namespace.  The client's user seems to access the object directly.
<!-- -->
<!-- -->
<!-- - -->
<!-- - -->
<!-- Figure : to illustrate junctions-->
<!-- - -->
<!-- - -->
<!-- pix/figjunc.pic-->
</Para>
<?sml-need 3i>
<Figure>
<Title>A Namespace Junction</Title>
<Graphic Format="EPS" Entityref="ADGISG.NAMESV.pic.2"></Graphic>
</Figure>
<?sml-space .5>
<!-- -->
<!-- -->
<Para><?sml-need 10>The dashed lines in the above figure show the progress of the client's efforts
to get access to the desired object, which involves acquiring a binding to the
junction server, making contact with it, and passing to it the object's name.
The solid line shows the apparent direct access to the object that the
client's user seems to enjoy.  The dotted lines show other possible paths of
access to the other objects that the server manages.
</Para>
<Para>Junction protocol is generally a private matter between an application's
clients and servers.  However, the <Command>acl_edit</Command> command uses a generalized
protocol.
<!-- -->
<!-- -->
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.NAMESV.div.10">
<Title>Junctions and the ACL Editor</Title>
<!-- - -->
<!---->
<Para>The binding routines that <Command>acl_edit</Command> uses are discriminating enough to
detect a junction anywhere in an entry name that is passed to it.  This allows
a distributed application to have its own namespace for objects with ACLs on
them, rather than burdening the DCE namespace by separately exporting binding
information for every one of these objects.  The separate objects have to be
made publicly accessible somehow because entities should be able to access
ACLs directly, regardless of whether they happen to already be in contact with
the server that manages the ACL'ed object, and indeed regardless of whether or
not they happen to be a client of the particular server to which the objects
belong.
</Para>
<Para>Suppose, for example, a user enters
the following
in order to interactively edit the ACL for the printer object <Literal>cotta</Literal>,
where the namespace entry for a print server is
<Filename>/.../tinseltown.org/dce/dce_print</Filename>,
and there is no
<Filename>/.../tinseltown.org/dce/dce_print/cotta</Filename>
entry in the DCE namespace: 
<!---->
<!---->
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>acl_edit&ensp;&ensp;/.../tinseltown.org/dce/dce_print/cotta
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The binding routine, <Function>sec_acl_bind(&thinsp;)</Function>, which
is called internally by <Command>acl_edit</Command>, receives an error when it tries to bind
to the object <Literal>cotta</Literal>.  However, the DCE Directory Service also tells it
how much of the name it passed is valid.  The
<Function>sec_acl_bind(&thinsp;)</Function> routine then
retries the binding operation, this time through the valid entry name
<Filename>/.../tinseltown.org/dce/dce_print</Filename>
and passes the residual part of the name (<Literal>cotta</Literal>) as a parameter. Now it
is up to the application ACL manager to interpret the residual name correctly
and find the requested ACL.
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
</Para>
</Sect2>
</Sect1>
<Sect1 Id="ADGISG.NAMESV.div.11">
<Title>Name Service Terminology</Title>
<!-- - -->
<!-- -->
<Para>DCE RPC NSI is an RPC-based interface that uses the DCE Cell Directory
Service (CDS) as its database.  The NSI routines do not constitute a general
interface into CDS as such; they are a set of specialized routines whose
purpose is simply to provide ways for RPC servers to advertise themselves
to RPC clients, and for clients to find and bind to them.
</Para>
<Para>In fact there is no public general application programming interface (API)
to CDS.  There is a general CDS interface that is used internally by the DCE
components, but applications normally access CDS through NSI.  Applications
can get full access to CDS, if necessary, by using the XDS interface.
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
</Para>
<Sect2 Id="ADGISG.NAMESV.div.12">
<Title>CDS Entries</Title>
<!-- - -->
<!-- -->
<Para>NSI uses a subset of the many possible kinds of CDS entry in order to
accomplish its tasks.  CDS entries are characterized by the CDS attributes
they have; each entry can have one or more such attributes.  Each separate
attribute defines that entry's ability to contain one or more items of a
particular kind of simple or complex information.
<!-- -->
<!-- -->
</Para>
<Para>The name service creates and uses CDS entries that use only the following
four attributes:
<!-- -->
<!-- -->
</Para>
<VariableList>
<VarListEntry>
<Term><FirstTerm>binding</FirstTerm></Term>
<ListItem>
<Para>The entry has a field that can contain one or more sets of binding information.
When the field is read, a binding handle that contains the necessary
information from one of these sets is returned, in no particular order.
<!-- -->
<!---->
<!---->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><FirstTerm>object</FirstTerm></Term>
<ListItem>
<Para>The entry has a field that can contain one or more object UUIDs.  When the
field is read, one of the UUIDs is returned, in no particular order.
<!-- -->
<!-- -->
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Replaceable>group</Replaceable></Term>
<ListItem>
<Para>The entry has a field that can contain a pool of one or more references to
other (independently existing) NSI entries; each time the field is read, one
of these entries is returned.  Different entries are returned on successive
reads, but the order of return is undefined.  
</Para>
<Para><?sml-need 10>Note that the other NSI
entries referred to in the group can themselves be server or group entries.
As a result, the act of reading from a group attribute can, depending on
the actual API routine called, lead to a series of nested operations.
Any nesting is transparent to the client application, however, which seems
to perform a simple read and to receive the contents of a single entry in
return.
<!-- -->
<!-- -->
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>profile</Literal></Term>
<ListItem>
<Para>The entry has a field that can contain one or more prioritized elements, each of
which consists of a reference to another (independently existing) NSI entry.
When the field is read, the elements are read in a specified order.  The entry
referred to in the element may itself be a server or a group or a profile.  As
a result, any element may in fact, depending on the actual API routine called,
resolve on access to a nested path of referred-to entries.  As with group entries,
this is transparent to the client application.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
<!-- -->
<Para>Although a single entry could contain both group and profile attributes
(and for that matter, binding and object attributes as well), it is not
a good idea to mix attributes in this way because the results of importing
(reading) from such an entry are too indeterminate.
</Para>
<Para>The typical name service entries are as follows:
<!-- -->
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>server&ensp;entry</Literal></Term>
<ListItem>
<?sml-break>
<Para>Contains a binding and an object attribute, making it suitable for containing
the necessary binding information for a single server.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>group&ensp;entry</Literal></Term>
<ListItem>
<?sml-break>
<Para>Contains a group attribute.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>profile&ensp;entry</Literal></Term>
<ListItem>
<?sml-break>
<Para>Contains a profile attribute.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
<Para>There are no official names for hybrid entries that contain other combinations
of attributes, which is perhaps another reason for not creating such entries.
</Para>
<Para>The general name for entries that contain any of these attributes is <Replaceable>NSI
entries</Replaceable>, since they are a by-product and tool of the NSI DCE RPC library
routines.
<!---->
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.NAMESV.div.13">
<Title>CDS Entry Attributes</Title>
<!-- - -->
<!-- -->
<Para>Within the DCE Directory Service, entry attributes such as the four previously
described attributes are identified by object identifiers (OIDs).  This is an
exception to the general rule that things in DCE are identified by UUID.
</Para>
<Para>OIDs are not seen by applications that restrict themselves to using only the
name service routines (<Literal>rpc_ns_</Literal><Symbol Role="Variable">*</Symbol>
<Literal>(&thinsp;)</Literal>), but these identifiers are
important for applications that use the X/Open Directory Services (XDS)
interface to create new attributes for use with namespace entries.
</Para>
<Para>As was seen in the immediately preceding sections, the name service makes
use of only four different entry attributes in various application-specified
or administrator-specified combinations.  CDS, however, contains definitions
for many more than these, and attributes from this supply of already existing
ones can be added by applications to NSI entries through the XDS interface.
Attributes that already exist are already properly identified, so applications
that use these attributes do not have to concern themselves with the OIDs,
except to the extent of making sure that they handle them properly.
</Para>
<Para>A further possibility is that an application requires new attributes for
use with namespace entries.  Such attributes can be created using the XDS
interface.  When it creates new attributes, the application is responsible
for tagging them with new, properly allocated OIDs.
</Para>
<Para>Unlike UUIDs, OIDs are not generated by command or function call.  They
originate from the International Organization for Standardization (ISO), which
allocates them in hierarchically organized blocks to recipients. 
Each recipient (typically an organization of some kind) is then responsible
for ensuring that the OIDs it received are used uniquely.
</Para>
<Para>For example, the following OID
identifies the NSI profile entry attribute. This number was assigned by the
Open Software Foundation out of a block of numbers, beginning with the digits
<Literal>1.3.22</Literal>, which was allocated to it by ISO, and OSF is responsible for
making sure that <Literal>1.3.22.1.1.4</Literal> is not used to identify any other attribute.
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>1.3.22.1.1.4
</UserInput></ProgramListing></Para>
</InformalExample>
<!-- -->
<Para><?sml-need 10>When applications have occasion to handle OIDs, they do so directly, since the
numbers do not change and should not be reused.  However, for users' convenience,
CDS also maintains a file (whose name is
<Filename>/opt/dcelocal/etc/cds_attributes</Filename>) that
lists string equivalents for all the OIDs in use in a cell, in entries like the
following:
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>1.3.22.1.1.4        RPC_Profile     byte
</UserInput></ProgramListing></Para>
</InformalExample>
<!-- -->
<Para>This allows users to see <Literal>RPC_Profile</Literal> in output, rather than the
mysterious <Literal>1.3.22.1.1.4</Literal>.  Further details about the <Literal>cds_attributes</Literal>
file and OIDs can be found in the &DCEAc;.
</Para>
<Para>Broadly speaking, the procedure you should follow to create new attributes 
on CDS entries consists therefore of three steps:
<!-- -->
</Para>
<OrderedList>
<ListItem>
<Para>Request and receive, from your locally designated authority, OIDs for the
attributes you intend to create.
</Para>
</ListItem>
<ListItem>
<Para>Update the <Literal>cds_attributes</Literal> file with the new attributes' OIDs and
labels; that is, if you want your application to be able to use string
name representations for OIDs in output.
</Para>
</ListItem>
<ListItem>
<Para>Using XDS, write the routines to create, add, and access the attributes.
</Para>
</ListItem>
</OrderedList>
<!-- -->
<Para>Non-NSI attributes on NSI entries can be very useful, even though you
cannot access the extra attributes through the name service routines
but must use XDS instead.
<!-- -->
<!---->
<!-- -->
<!-- - -->
</Para>
</Sect2>
</Sect1>
<Sect1 Id="ADGISG.NAMESV.div.14">
<Title>Binding</Title>
<!-- - -->
<!---->
<Para>In order to highlight the essentials of name lookup and storage and the
management of binding information, many details of DCE RPC operation are
either greatly simplified in the following descriptions or omitted altogether.
<!-- -->
<!-- -->
</Para>
<Para>A binding is a package of information that describes how a client can contact
and communicate with a particular server.  Although the underlying protocol
that implements the communication can be connectionless or connection-oriented,
the relationship itself is still expressed as a binding.
<!-- -->
<!-- -->
<!-- - -->
</Para>
<Sect2 Id="ADGISG.NAMESV.div.15">
<Title>Importing and Exporting Bindings</Title>
<!-- - -->
<!-- -->
<Para>The name service exists to store server binding information into the cell
namespace, and to retrieve that information for clients.  Using NSI, servers
export their binding information to be stored under meaningful names, and clients
import these bindings by looking up those names.  Thus, the locations of the servers
can change, but clients can continue to use the same names to get bindings to the
servers.  The following figure shows how client and server use the name service.
<!---->
</Para>
<?sml-need 2.75i>
<Figure>
<Title>Client and Server Use of the Name Service</Title>
<Graphic Format="EPS" Entityref="ADGISG.NAMESV.pic.3"></Graphic>
</Figure>
<?sml-space .5>
<!-- - -->
<!-- - -->
<!-- Figure 04: showing server exporting, client importing, binding info.-->
<!-- - -->
<!-- - -->
<!-- pix/fig02.pic-->
<!---->
<!---->
<!---->
<?sml-space .5>
<Para>When a prospective client attempts to import binding information from a
namespace entry that it looks up by name, the binding is checked by NSI
for compatibility with the client.  This is done by comparing interface
UUIDs.  The client presents an interface UUID when it begins the binding
import operation; the UUID of the interface being offered is exported to
the name entry, but not in the binding handle itself, by the server.  If
these interface UUIDs match, then the binding handle contained in the
entry is considered compatible by the RPC runtime and is returned to the
client.  If more than one handle is contained in the entry (this is often
the case), they are returned one by one on successive imports.  NSI also
checks for protocol compatibility.
</Para>
<Para>The import routines will return only client-compatible bindings, but a
client can sift through the returned bindings and make its own choice
as to which ones to use, based on its own criteria.  The technique by which
this is done consists of converting the bindings into string bindings,
and then inspecting (or comparing) the strings.
<!-- -->
<!-- -->
</Para>
<Para>Note that binding handles do <Symbol Role="Variable">not</Symbol> include an interface UUID. Binding
handles do contain a host address, an endpoint, and an optional object UUID,
among other things.  The interface UUID is associated with the interface's
stub code, which inserts it into outgoing RPCs and checks it in incoming
ones, thus guaranteeing client/server operational compatibility.  This allows
binding handles to be used very flexibly: once a client has successfully
bound to a server, it can utilize any of the interfaces that server offers,
simply by making the desired remote call.
<!-- -->
<!-- -->
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.NAMESV.div.16">
<Title>Summary</Title>
<!-- - -->
<!-- -->
<Para>The mapping from name to server that occurs when bindings are imported from
the namespace is indirect because binding is a two-step process: first the
binding handle is obtained by lookup from a named entry, and then the handle
is used to reach a server.  The crucial point is that the imported handle
will not usually contain a complete binding to a specific server (namely,
the one that happened to export it).  Completion of the partial binding
occurs later, when the client makes its first remote procedure call;
the RPC runtime uses UUIDs, not names, to determine how it should complete
a binding.
<!---->
<!---->
<!-- - -->
</Para>
</Sect2>
</Sect1>
<Sect1 Id="ADGISG.NAMESV.div.17">
<Title>Partial Binding and the Endpoint Mapper</Title>
<!-- - -->
<!---->
<!-- -->
<Para>Binding handles imported by clients from the namespace normally contain only
partial binding information.  The exported binding information is sufficient
to locate the DCE host daemon on the server's host (the machine the server
resides on), but it does not yet include a specific endpoint (UDP or TCP port
number) for the desired service on that host. 
<!---->
<!-- The exception to this statement is interfaces that contain-->
<!--	well-known endpoints.-->
<!---->
</Para>
<Para>The reason for omitting dynamic endpoint information in exported binding handles
is to avoid unnecessary multiplication of accesses to the namespace.  Since
dynamically generated endpoints are necessarily reassigned every time a server
starts up, entering them into the namespace (and thus forcing CDS to propagate
the new information throughout the various directory replicas) would greatly
increase namespace housekeeping chores.
</Para>
<Para>Thus, the last step in the binding process is obtaining an endpoint. The step
is performed transparently as far as the client is concerned.  It is accomplished
by the endpoint mapper service of the DCE host daemon, <Literal>dced</Literal>, when the client
makes its first call to the partially bound-to server.  The endpoint mapper service
manages its own private database of server endpoints for the host on which it is
located.  The endpoints are registered by the servers as part of their startup
routine.
</Para>
<Para>The binding information that accompanies a prospective client's first remote
procedure call takes that call to the well-known endpoint of <Literal>dced</Literal> on the
exporting server's host machine.  The endpoint mapper now takes over.  It looks up
a valid endpoint for the requested service, copies it into the binding handle,
and transfers the call to that endpoint.  Subsequent calls from the client, which
now has a binding with one of the server's endpoints, will bypass the endpoint
mapper.
</Para>
<Para>The endpoint mapper picks an appropriate endpoint for an incoming partial binding
by matching interface UUIDs by default.  Any endpoint that has been registered under
an interface UUID that matches the incoming interface UUID, which identifies the
interface requested by the prospective client, is eligible for selection.  This
mapping process is called <Replaceable>forwarding</Replaceable> when it occurs with connectionless
protocols, and <Replaceable>mapping</Replaceable> when it occurs with connection-oriented protocols.
</Para>
<Para>The following figure shows the endpoint mapper service completing a binding.
<!---->
<!---->
</Para>
<?sml-need 2.75i>
<Figure>
<Title>The Endpoint Mapper Service Completes a Binding</Title>
<Graphic Format="EPS" Entityref="ADGISG.NAMESV.pic.4"></Graphic>
</Figure>
<?sml-space .5>
<!-- - -->
<!-- - -->
<!-- Figure 05: showing endpoint mapper operation-->
<!-- - -->
<!-- - -->
<!-- pix/fig03.pic-->
<!-- -->
<!-- -->
<!-- -->
<Para><?sml-need 10>There is an exception to this scheme.  Some servers are designed to
occupy well-known addresses.  The DCE host daemon itself, <Literal>dced</Literal>,
is reached in this way, making its accessibility independent of whether
or not the namespace is accessible.  The endpoint(s) of a well-known
address do not change; they are usually specified in the application's
interface specification (contained in its <Filename>.idl</Filename> file).
<!-- -->
<!--  see Step A3 in Chapter 1, Section 1.5.3, of this guide).-->
<!-- -->
Bindings to servers that use well-known endpoints are already complete at the
time of import; the endpoint mapper never sees these bindings.
<!-- -->
<!---->
<!---->
<!---->
<!-- - -->
</Para>
</Sect1>
<Sect1 Id="ADGISG.NAMESV.div.18">
<Title>Interface Ambiguity and Partial Bindings</Title>
<!-- - -->
<!---->
<Para>The interface UUID, which was generated by the IDL compiler, uniquely
identifies the set of operations that the client will access through that
interface.  In short, it identifies the interface.  An interface UUID may also
happen to identify a server which offers that interface.  But if more
than one server on the same host offers the same interface (which could
easily be the case), the interface UUID alone will not be sufficient to
identify a <Replaceable>specific</Replaceable> server.  The result is that if a remote call comes
in with such an ambiguous interface and a partial binding, the endpoint
mapper will have to randomly choose any one of its eligible registered
endpoints, complete the binding with it, and send the call on to that server.
</Para>
<Para>Imagine several print servers residing on the same machine (see Figure 5-5).
Each server manages a group of printers that share a common physical location.
All the printers in room A are managed by the A print server, all the
printers in room B by the B print server, and so on.  Now suppose each
of these servers has a separate entry in the namespace.  The following figure
shows the sequence of events that occurs.
</Para>
<Para><!-- .ne 40-->
<!-- .nP-->
<?sml-need 4.5i></Para>
<Figure>
<Title>Print Server Entries in Namespace</Title>
<Graphic Format="EPS" Entityref="ADGISG.NAMESV.pic.5"></Graphic>
</Figure>
<?sml-space .5>
<!-- - -->
<!-- - -->
<!-- Figure 06: showing undistinguished print server entries-->
<!-- - -->
<!-- - -->
<!-- pix/fig04.pic-->
<!---->
<!---->
<?sml-space .5>
<Para>The following steps describe the sequence of events shown in the above
figure:
<!-- -->
</Para>
<OrderedList>
<ListItem>
<Para>The client imports a partial binding to the <Symbol Role="Variable">printer</Symbol> interface from
the entry A in the namespace.
</Para>
</ListItem>
<ListItem>
<Para>The client makes its first call with the binding it imported from A.
</Para>
</ListItem>
<ListItem>
<Para>The endpoint mapper at print server A's host, when it receives the call
from the client, has no way of knowing which of the four print servers
it should map the call to, since all four servers have registered their
endpoints under the same interface.  It therefore picks one at random
to complete the binding.
</Para>
</ListItem>
</OrderedList>
<!-- -->
<Para>The entry names are different, but the partial binding information contained
in the entries is identical, since the servers' host machine is the same.
The interface UUID included in the call is no help, since that same interface
is offered by all the servers.  A client seeking a print server may not care
to which server (and thus to which printer) its request goes, but then again,
it may care.  If it does, there is a way it can specify a server so that the
endpoint mapper can select an appropriate endpoint to complete the partial
binding.
<!-- -->
<!-- -->
<!---->
<!-- - -->
</Para>
</Sect1>
<Sect1 Id="ADGISG.NAMESV.div.19">
<Title>Using Object UUIDs to Avoid Binding Ambiguity</Title>
<!-- - -->
<!---->
<Para>Binding handles can contain, besides host address and endpoint information,
an object UUID as well.  The endpoint mapper will try to match an object
UUID contained in a binding handle with one of the object UUIDs associated
with its map of registered endpoints.  This allows even a partial binding to
specify a target more precisely than just by host machine.  Since object UUIDs
are generated by the <Function>uuid_create(&thinsp;)</Function> function call (see the
&DCEDr;), servers can create as many of them as
they need.
<!-- -->
<!-- -->
<!-- -->
<!-- -->
</Para>
<Para>For the print server example discussed in the previous section, the namespace
entries for the servers could be set up as shown in the following figure.
</Para>
<?sml-need 4.6i>
<Figure>
<Title>Print Server Name Entries with Object UUIDs</Title>
<Graphic Format="EPS" Entityref="ADGISG.NAMESV.pic.6"></Graphic>
</Figure>
<?sml-space .5>
<!-- - -->
<!-- - -->
<!-- Figure 07: showing print server entries with object UUIDs-->
<!-- - -->
<!-- - -->
<!-- pix/fig05.pic-->
<!---->
<!---->
<Para><?sml-need 10>The following steps describe the sequence of events shown in the preceding
figure:
<!-- -->
</Para>
<OrderedList>
<ListItem>
<Para>The client imports a partial binding to the <Symbol Role="Variable">printer</Symbol> interface from
the entry A in the namespace.
</Para>
</ListItem>
<ListItem>
<Para>The client makes its first call with the binding it imported from A.
</Para>
</ListItem>
<ListItem>
<Para>This time the endpoint mapper at print server A's host is able to match
the call with A's registered endpoints, because the endpoints have been
registered with both the <Symbol Role="Variable">printer</Symbol> interface and print server A's
object UUID, and the incoming call's partial binding also contains print
server A's object UUID.
</Para>
</ListItem>
</OrderedList>
<!-- -->
<Para>Each server has exported a set of partial bindings that differs from all
other servers' by its object UUID (which thus becomes, in effect, a server
ID).  If, for example, server A has properly registered its endpoints with
the same object UUID as the one it exported its bindings with, the endpoint
mapper will make sure that a partial binding exported from server A's name
entry will result in a full binding to server A.
<!---->
<!---->
</Para>
<Para>Now suppose that each print server sets up a separate namespace entry for
each printer it manages.  The printers themselves would, in effect, be
identified by their own object UUIDs.  The following figure illustrates this.
<!-- -->
</Para>
<?sml-need 6.5i>
<Figure>
<Title>Separate Printer Name Entries</Title>
<Graphic Format="EPS" Entityref="ADGISG.NAMESV.pic.7"></Graphic>
</Figure>
<?sml-space .5>
<!-- - -->
<!-- - -->
<!-- Figure 08: showing printer entries with object UUIDs-->
<!-- - -->
<!-- - -->
<!-- pix/fig06.pic-->
<!---->
<!---->
<?sml-space .5>
<Para>Now a client will be able to access a specific printer by importing
a binding handle from that printer's name entry.  The endpoint mapper
at the target host would compare the object UUID in the partial binding
with the object UUIDs registered by the print servers, and select an
<!---->
<!-- ...these having been registered at the same time as the endpoints-->
<!--	were registered.-->
<!---->
appropriate server.  The server in turn would also use the object UUID to
select the correct printer for the request, if it managed more than one
printer.  A namespace set up in this way with a separate entry that contains
a unique object UUID for each accessible service resource is called
an <FirstTerm>object-oriented</FirstTerm> namespace.
<!-- -->
<!---->
<!---->
<!-- - -->
</Para>
</Sect1>
<Sect1 Id="ADGISG.NAMESV.div.20">
<Title>An Object-Oriented Namespace</Title>
<!-- - -->
<!---->
<Para><Replaceable>Object-specific entries</Replaceable> are namespace entries that each contain binding
information only for one specific object or resource, as demonstrated in the
last printer service shown in the last previous figure. <Replaceable>Object</Replaceable> can mean
any of several things, depending on what kind of service the application's
servers are offering.  Here are some examples.
<!---->
<!-- -->
<!-- -->
<!---->
</Para>
<Table Frame="all" Remap="center" Orient="Port">
<Title>Some Examples of Objects</Title>
<TGroup Rowsep="0" Colsep="0" Cols="2">
<ColSpec Colsep="1" Align="Left" Colwidth="1*" Colname="col1" Colnum="1">
<ColSpec Align="Left" Colwidth="1*" Colname="col2" Colnum="2">
<TBody>
<Row>
<Entry Rowsep="1" Align="Center"><Literal>Service</Literal></Entry>
<Entry Rowsep="1" Align="Center"><Literal>Object(s)</Literal></Entry>
</Row>
<Row>
<Entry>Printing</Entry>
<Entry>A specific printer</Entry>
</Row>
<Row>
<Entry>Process Server</Entry>
<Entry>A specific server</Entry>
</Row>
<Row>
<Entry>Queue Service</Entry>
<Entry>The print queue, the kill
queue, the backup queue
</Entry>
</Row>
</TBody>
</TGroup>
</Table>
<!--no-op:  l-->
<!--no-op:  b-->
<!---->
<!-- -->
<Para>Thus, for a client that wants to have a file printed, it is natural to allow
it to specify a printer as a destination.  Therefore, the client would bind to
the print server through a name entry that specifies a printer.  To send
something to a different printer, the client would import a binding from the
name entry for that other printer.  The server may (or may not) be identical,
but the object UUID in the binding handle returned would uniquely specify the
one printer represented by that entry.
</Para>
<Para>On the other hand, consider an application that returns statistics about the
processes currently active on a group of machines.  In this case it would be
reasonable to regard the server as the object.  In the namespace entries for
such an application, each entry would uniquely represent one server.  A client
would import a binding from the name entry for the server it wanted to work
with.
</Para>
<Para>In other words, <FirstTerm>object</FirstTerm> is a handy way of saying ``the thing that clients
will want to access'' in order to accomplish the task set for the application.
If the namespace is organized correctly, clients will be able to import
bindings from these objects' entries.
<!-- -->
<!-- -->
<!---->
<!-- - -->
</Para>
</Sect1>
<Sect1 Id="ADGISG.NAMESV.div.21">
<Title>Setting Up an Object-Oriented Namespace</Title>
<!-- - -->
<!---->
<Para>Once you have distinguished the objects your application uses, you must decide
on an appropriate set of names for the entries themselves.  The entries can be
created either by the application (server), if it has the necessary privileges,
or by a system administrator using the <Command>rpccp</Command> command interface.
<!-- -->
<!-- -->
</Para>
<Para>After the entries have been created, each server must do the following:
<!-- -->
</Para>
<OrderedList>
<ListItem>
<Para>Create an object UUID for each object managed by the server under an interface,
insert it into the binding handle(s) for that object, and export the handle(s)
for each object to a separate entry in the namespace.
</Para>
<Para>Note that the object UUID should be generated and exported in general <Replaceable>only
once</Replaceable> per created namespace entry, and not each time the server starts up
(see the example that follows of how to do this).  When a newly restarted
server exports its partial bindings, nothing actually happens in the namespace
because the partial binding information remains the same (unless the server
has moved to a different machine).  However, if the object UUIDs are regenerated,
then the change in exported information will force needless update activity in
CDS, which is where the entries exist.
</Para>
</ListItem>
<ListItem>
<Para>Register with the endpoint mapper the full bindings (including endpoints)
obtained for the interface; <Function>rpc_ep_register(&thinsp;)</Function> performs this operation.
</Para>
</ListItem>
</OrderedList>
<!---->
<Para>One way of avoiding unnecessary regeneration of object UUIDs would be to have a
restarted server check the namespace for the presence of its previously exported
object UUIDs, as demonstrated in the following code fragment.  Refer to the
&DCEDr; for further information on the function
calls.
<!-- -->
<?sml-break><?sml-need 3.5i></Para>
<InformalExample>
<Para><ProgramListing>have_object = false;

/* Create an inquiry context for inspecting the object  */
/* 	UUIDs exported to "my_entry_name"...            */
rpc_ns_entry_object_inq_begin(my_entry_name_syntax,
                              my_entry_name,
                              &amp;context, &amp;st);

/* If we successfully created context, look at          */
/*	object UUIDs...                                 */
if (st == rpc_s_ok)
{
    /* Try to get one object UUID from the entry...     */
    rpc_ns_entry_object_inq_next(context, &amp;obj, &amp;st);

    /* If an object UUID is there already, we don't     */
    /*	need to generate another one...                 */
    have_object = (st == rpc_s_ok)

    /* Delete the inquiry context...                    */
    rpc_ns_entry_object_inq_done(&amp;context, &amp;st);
    

/* If there were no object UUIDs in the entry,          */
/*	generate one now...                             */
if (! have_object)
{
    uuid_create(&amp;obj, &amp;st);

    /* Put it in an object UUID vector...               */
    objvec.count = 1;
    objvec.id[0] = &amp;uuid;
}

/* Export bindings.  If an object UUID was generated,    */
/*	export it too...                                 */
rpc_ns_binding_export( my_entry_name_syntax,
                       my_entry_name,
                       my_interface_spec,
                       my_bindings,
                       have_object ? NULL : &amp;objvec, &amp;st);
</ProgramListing></Para>
</InformalExample>
<!-- -->
<Para><?sml-need 10>Whenever you want to offer more than one instance of the same interface on the
same host, you <Replaceable>must</Replaceable> distinguish by object UUID the binding information
in the name entries exported by the servers, if it is important to distinguish
among the servers when binding to them.  Otherwise, the endpoint mapper's
selection of an endpoint with which to complete the binding from among all the
servers on that host that offer the appropriate interface will be random.
</Para>
<Para>The next figure illustrates what such an object-oriented namespace should look
like.
</Para>
<?sml-need 5.7i>
<Figure>
<Title>Object-Oriented Namespace Organization</Title>
<Graphic Format="EPS" Entityref="ADGISG.NAMESV.pic.8"></Graphic>
</Figure>
<?sml-space .5>
<!-- - -->
<!-- - -->
<!-- Figure 09: showing recommended namespace organization-->
<!-- - -->
<!-- - -->
<!-- pix/fig07.pic-->
<!---->
<!-- -->
<!-- -->
<!---->
<?sml-space .5>
<Para>Each entry has a name denoting the object represented, although the names are
not shown in this figure.
<!-- -->
<!-- -->
</Para>
<Para>Under this model, clients bind to servers via named objects in the namespace,
each of which contains enough specific information in its partial binding to
allow the endpoint mapper at the destination host to choose an appropriate
endpoint for the incoming RPC.
</Para>
<Para><?sml-need 8>By setting a namespace up this way, however, you do not necessarily restrict
yourself to this one model for accessing binding information.  Through the use
of two other types of entry, groups and profiles, which can be superimposed on
the simple object model, you can set up models where clients bind to abstractions
such as services, or directly to the servers themselves.  These techniques are
described in the next section.
</Para>
<Para>Nevertheless, at this point you have enough information to set up a namespace
that consists of an entirely flat expanse of separate resource entries.
Bindings can be imported by clients by looking up specific names.  If the client
has no specific name to look up, or if the lookup on the name(s) it has fails,
it has no alternative way of binding to a server.
<!---->
<!---->
<!-- - -->
</Para>
</Sect1>
<Sect1 Id="ADGISG.NAMESV.div.22">
<Title>Groups and Profiles</Title>
<!-- - -->
<!-- -->
<Para>Name lookups can be made more flexible with two other types of entry; namely,
groups and profiles. 
<!-- -->
<!---->
<!-- - -->
</Para>
<Sect2 Id="ADGISG.NAMESV.div.23">
<Title>Group Entries</Title>
<!-- - -->
<!-- -->
<Para>A group entry consists essentially of multiple independent other entries whose
names are also associated under the group name.  These other entries can be
simple (single-name) entries, or they may themselves be group entries.  Doing an
import from the group entry will return the contents (the binding handles) of
its included entries (which are called <Replaceable>members</Replaceable>), but the selection is made by
the DCE RPC runtime, and from the client's point of view is undefined and
implementation dependent.
</Para>
<Para><?sml-need 10>In practice, the way this works with the usual binding import operations is as
follows.  Clients normally import bindings by first calling 
<Function>rpc_ns_binding_import_begin(&thinsp;)</Function> to 
set up an import context.  Once this
is done, successive calls to <Function>rpc_ns_binding_import_next(&thinsp;)</Function> will return
binding handles from namespace entries until the handles have all been returned
or the client decides to stop; the client decides which handle(s) to use based
on its own criteria.  When it is finished importing, it calls
<Function>rpc_ns_binding_import_done(&thinsp;)</Function> to free the context.
<!-- -->
<!-- -->
</Para>
<Para>The kind of entry the information is returned from is usually unknown to the
client, which needs to know only a name to look up and the interface UUID by
which it wants to bind.  If the name is that of a simple server entry, then the
bindings contained in that entry only will be returned.  If the name is of a
group entry, then bindings will be returned from members (single entries) of
the group, selected (by the RPC runtime) in an undefined order.  If one or more
members of the group are themselves groups, then the same thing happens
recursively whenever these lower-level groups are accessed.
</Para>
<Para>Note that the group entry and its members are separate things. The group
entry can be deleted, but its former members will continue to exist as
independent entries, unless they too are explicitly deleted.  Thus, you can
implement a namespace organization where the same bindings can be imported
through individual simple entries or through group entries, depending on how
the client is coded.
<!-- -->
<!---->
<!---->
<!---->
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.NAMESV.div.24">
<Title>Profiles</Title>
<!-- - -->
<!-- -->
<Para>A profile entry specifies a search path or hierarchy of search paths to be
followed through the namespace in order to obtain a binding to a server that
offers a specified interface.
</Para>
<Para>When a client imports from an entry that happens to be a profile, successive
imports (accomplished by calling
<Function>rpc_ns_binding_import_next(&thinsp;)</Function>) return
the contents of entries that are read as a result of following the specified
path through the namespace.  All this is transparent to the client, which sees
only the bindings returned.  Profiles can be used to set up default paths and
groups of paths for users.  The <SystemItem Class="EnvironVar">RPC_DEFAULT_ENTRY_NAME</SystemItem> environment
variable, which is the default entry name used by the name service in import
operations, usually contains the name of a profile.
</Para>
<Para><?sml-need 10>As with groups, the entries contained in profiles, which are called <Replaceable>elements</Replaceable>,
exist independently of the profile entry itself.
</Para>
<Para>A very important property of profiles is that they allow clients to know
little or nothing about the organization of the namespace itself.  Using
the default case as an example, consider the following: if the profile at
<SystemItem Class="EnvironVar">RPC_DEFAULT_ENTRY_NAME</SystemItem> has been set up with elements containing entries
for all possible active servers for a particular application, clients can
simply import from this name and trust the profile mechanism to walk through the
various compatible possibilities and return binding handles via successive calls
to <Function>rpc_ns_binding_import_next(&thinsp;)</Function>. (Note that a profile entry is not limited
to containing entries for just one interface; thus, <SystemItem Class="EnvironVar">RPC_DEFAULT_ENTRY_NAME</SystemItem>
could be set up to contain <Replaceable>all</Replaceable> the defaults for a cell.)
<!-- -->
<!-- -->
<!---->
<!-- -->
<!---->
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.NAMESV.div.25">
<Title>Summary of Namespace Entry Types</Title>
<!-- - -->
<!-- -->
<Para>Clients access binding information in the namespace by looking up (by name)
one of three different kinds of entry:
<!-- -->
</Para>
<ItemizedList>
<ListItem>
<Para>A server entry
</Para>
</ListItem>
<ListItem>
<Para>A group entry, which contains other entries whose contents are returned to the
caller when it reads the group entry
</Para>
</ListItem>
<ListItem>
<Para>A profile entry, which specifies a path of entries to be searched whose contents
are returned to the caller when it reads the profile entry
</Para>
</ListItem>
</ItemizedList>
<!-- -->
<Para>Lookups behave differently depending on the kind of entry read. If an entry is a
simple server entry, then the search begins and ends right there, whether successful
or not.  If the entry is a group, then the lookup is more complicated.  A binding will
be returned from among those that are found to be compatible by the name service,
but within that category the selection is undefined.  If the entry is a profile, then
a specified path of entries is searched.  The entries in this path may themselves be
other profiles, or groups, or simple entries.  The search continues until either a
compatible binding is found, or the entire path has been unsuccessfully traversed.
<!---->
<!---->
<!---->
<!-- - -->
</Para>
</Sect2>
</Sect1>
<Sect1 Id="ADGISG.NAMESV.div.26">
<Title>Three Models for Accessing Binding Information</Title>
<!-- - -->
<!-- -->
<Para>By adding groups and profiles to the object-specific namespace organization
originally described, you can implement any or all of the following three
basic models for accessing binding information:
<!-- -->
</Para>
<ItemizedList>
<ListItem>
<Para>Clients bind to services
</Para>
</ListItem>
<ListItem>
<Para>Clients bind to servers
</Para>
</ListItem>
<ListItem>
<Para>Clients bind to resources or objects
</Para>
</ListItem>
</ItemizedList>
<!-- -->
<Para>Each of the three models is described in the following sections.
<!-- -->
<!-- -->
<!---->
<!-- - -->
</Para>
<Sect2 Id="ADGISG.NAMESV.div.27">
<Title>Access By Services</Title>
<!-- - -->
<!-- -->
<Para>Servers have separate namespace entries; each server distinguishes the bindings
it exports with its own identifier; that is, an object UUID that it generates
for itself <Replaceable>the first time it starts up</Replaceable>.  These separate server entries are
also members of group namespace entries, which represent services.  The criterion
for membership in a service group is that all the servers in it export the
interface that identifies that service. (They may happen to export
other interfaces as well.)
</Para>
<Para>Clients, in effect, bind to services by importing their binding handles from
the group entries.  Note, however, that the server-specific entries still exist
independently and are accessible to lookup.
</Para>
<Para>This model is appropriate for applications where clients do not care which
server they happen to bind to or where that server is located as long as it
offers the desired service.  The eligible servers are pooled into a group entry
from which bindings to one of them are selected in an undefined order and
returned whenever a client performs an import operation from the group entry.
<!-- -->
<!---->
<!---->
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.NAMESV.div.28">
<Title>Access By Servers</Title>
<!-- - -->
<!-- -->
<Para>In this model, distinct servers have separate and distinct name entries, and
clients import bindings directly from the server entries.  Hence, an application
using this kind of binding model will own just as many simple entries in
the namespace as there are active servers.
</Para>
<Para>Since the client in this model is looking for a specific server, imports will
be done directly from the server entries.  The only exception to this rule would
be where two or more instances of a server were active on the same host, and it
was indifferent to the client as to which one it is bound to.  The entries for
the multiple same-host servers then could be put into a group entry, and
binding imports done from the group.
<!---->
<!-- -->
<!-- -->
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.NAMESV.div.29">
<Title>Access By Objects</Title>
<!-- - -->
<!-- -->
<Para>Servers operate on or manage multiple objects. Clients use these objects
(via the servers) as resources.  For each such resource, the server creates
a separate namespace entry and exports its binding information there,
distinguishing each object entry with its (the object's) own object UUID.
</Para>
<Para>An example of this model is the printer service that was previously described.
Clients will import directly from the name entry of the resource they want to
use.  For this kind of application, there will generally be more namespace
entries than active servers, since each server presumably manages more than
one object.  If the name entries have been set up correctly and the servers
have properly registered the object UUIDs they created, there will be no
difficulty in routing any partial binding to the correct server (namely, the
server that manages the object or resource specified).
<!-- -->
<!-- -->
<!---->
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.NAMESV.div.30">
<Title>Summary of Binding Models</Title>
<!-- - -->
<!-- -->
<Para>Although the name service allows other approaches, we recommend that whenever
possible you use the object-oriented scheme to organize your namespace entries.
There are at least two good reasons for doing so.  First, it is easy to
administer; at the simple entry level, things really are simple.  Second, this
is the most flexible foundation for building other more complicated access
models using group entries and profiles.
</Para>
<Para>The separate name entries in your namespace should contain bindings that will
unambiguously resolve to specific server instances.  Since interface UUIDs are
often offered by more than one server, more information than just an interface
UUID is needed in order to give an RPC with a partial binding the required
specificity.  Object UUIDs provide this extra information.  When using object
UUIDs to distinguish bindings in this way, servers must take care to preserve
their uniqueness across name entries.
</Para>
<Para>Finally, profile entries allow clients to walk through a specified search path
of namespace entries and yet be completely ignorant of the actual names
themselves.  While name independence may not be desirable for an object-based
or resource-based distributed application, it can be a powerful mechanism when
used with other models.
</Para>
<Para>As you are setting up the namespace organization for your application, remember
that there is not a direct exact mapping from names to bound servers.  Different
names, once imported from, may resolve to identical bindings if the partial
bindings were exported on the same interface, from the same host, and not
otherwise distinguished from each other by object UUIDs.  It is the application
developer's responsibility to tailor an application's export and import
procedures so that this mapping behaves as intended.
<!---->
<!-- ...in other words, you could say that the mapping from name ->-->
<!--	binding is discontinuous.-->
<!---->
<!-- - -->
</Para>
</Sect2>
</Sect1>
<Sect1 Id="ADGISG.NAMESV.div.31">
<Title>Models Based on Non-CDS Databases</Title>
<!-- - -->
<!-- -->
<Para>The three models previously described are not mutually exclusive; if the
namespace is set up correctly, all three can coexist at the same time.  All
three of the models are implemented through the functionality of the DCE RPC
name service.
</Para>
<Para>Although the emphasis in this discussion has been placed on the storage and
retrieval of binding information, the namespace entries can be used to store
additional states for objects.  In order to do this, an application would have
to create additional attributes on the CDS entries it intended to use because
the name service recognizes only the four NSI attributes: <FirstTerm>binding</FirstTerm>,
<FirstTerm>object</FirstTerm>, <Replaceable>group</Replaceable>, and <Literal>profile</Literal>.
</Para>
<Para>Such additional entry attributes would be created and accessed through XDS.
However, whenever you find yourself contemplating extending the name service
in this manner, you should carefully consider whether the name service (and,
consequently, CDS) is the best mechanism for doing what you want to do.
<!-- -->
<!-- -->
</Para>
<Para>In the preceding example, where an object-oriented namespace containing
separate entries for individual printers was described, only the identifier
for the printer (the object UUID) and the binding for the server that managed
it were stored in the CDS entry.  Other information, such as what jobs are
currently queued for the printer, who owns the jobs, and so on, was maintained
by the server.  This data could be stored in CDS only by creating new attributes
to put it in, but it would be changing too quickly for CDS to efficiently keep
up with it anyway.  The performance of both the application and CDS would suffer
from such an arrangement.
</Para>
<Para>It is possible to imagine distributed applications whose resources (the objects
they are managing) are of such a nature that they could be more efficiently
managed through a private application-implemented database.  Suppose the number
of managed objects is very large, or that the state of the objects is volatile.
It would certainly be a bad idea to try to use CDS to store this kind of
information, which would be changing much more rapidly than CDS's ability to
propagate the updates.
<!-- -->
<!---->
<!---->
<!-- - -->
</Para>
<Sect2 Id="ADGISG.NAMESV.div.32">
<Title>Example of a Privately Managed Database</Title>
<!-- - -->
<!---->
<Para>As an example of such a privately managed database, consider a print service
where jobs are submitted not to individual printers, but rather to a generic
printer service.  The client, <Command>lpr</Command>, binds (probably through a group entry)
to some certain print server, and sends the job to be printed to that server,
which then, after some thought, sends the job to one of the printers that it
manages.
</Para>
<Para>Consider, for example, what happens if a user invokes the client <Literal>cancel</Literal>
sometime later to stop
a job.  If, for example, the original command was
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>lpr War_and_Peace.ps
</UserInput></ProgramListing></Para>
</InformalExample>
<!-- -->
<Para>and the subsequent request to cancel is
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>cancel War_and_Peace.ps
</UserInput></ProgramListing></Para>
</InformalExample>
<!-- -->
<Para>then how does the server that <Literal>cancel</Literal> binds to find the right job to
delete? There is no guarantee that <Literal>cancel</Literal> will bind to the same server
that happened to receive the original print request, so having each print
server keep track of its own jobs would not be the answer.
</Para>
<Para>One way to keep track of jobs queued would be to have a dedicated <Replaceable>job
location server</Replaceable> as part of the application.  Each time a print server queued
a job to a printer it would record the fact (with all the pertinent details)
with the location server.  Whenever a job completed, the server would again
notify the location server to remove its record of that job from its database.
A client <Literal>cancel</Literal> then binds first to the location service, where it
receives the name of the print server associated with the job it wants to
cancel.  It then looks up that name, binds to the right print server, and
sends the cancel request.  In effect, the location server has become a name
service for <Literal>cancel</Literal>.
</Para>
<Para>This method of organizing activity results in a split-model database. The
print servers' binding information is managed through CDS, as usual, and the
location server manages other more volatile information associated with those
same servers.
</Para>
<Para>Another way a server could maintain its own database of named objects would
be by implementing a junction.
<!-- -->
<!-- -->
<!-- -->
<!---->
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.NAMESV.div.33">
<Title>Combining Models</Title>
<!-- - -->
<!-- -->
<Para>In designing a binding access model for an application, consider also whether
it may be appropriate to combine some of the models previously discussed.  In
the print service application, it may be desirable for servers to also offer
a management interface to specific servers rather than to specific objects;
for example, <Command>lpr</Command>, <Command>lpq</Command>, and <Command>lprm</Command> are generic application
clients, so it is appropriate for them to bind to printer objects, but if
<Literal>lpr_mgmt</Literal> is supposed to manage characteristics of a whole service, then
it should bind to servers. 
<!---->
<!-- or: ACL on printer distinct from the ACL on-->
<!--     the printer manager. -->
<!---->
<!---->
<!---->
<!-- - -->
</Para>
</Sect2>
</Sect1>
<Sect1 Id="ADGISG.NAMESV.div.34">
<Title>An Object-Oriented Model with Grouped Binding Information</Title>
<!-- - -->
<!---->
<Para>The following variation on the object-oriented binding model shows how the
group attribute can be used in object entries.  In this model, each of the
object entries contains, as before, an object UUID that will uniquely identify
(either to the endpoint mapper on the exporting server's machine, and/or to the
server itself) the object referred to by that entry.  However, the object entries
do not contain any binding information.  Instead, a group attribute in each
object entry refers clients' import operations back to the server's own separate
entry, which contains the binding information for that server.
</Para>
<Para>The namespace ingredients of this model are the following:
<!-- -->
</Para>
<ItemizedList>
<ListItem>
<Para>A single namespace entry for the server, which contains a binding attribute
and, possibly, an object attribute.  Thus, this entry contains all the binding
information that is exported to the namespace by the server.
</Para>
</ListItem>
<ListItem>
<Para>One namespace entry for each object that the server offers.  Each entry
contains an object attribute that contains that object's UUID, and a
group attribute that refers back to the exporting server's namespace
entry.
</Para>
</ListItem>
</ItemizedList>
<!-- -->
<Para>Note that the object entries consist of a combination of attributes not
encountered before (object and group).  Although unorthodox combinations
of attributes are not generally recommended, they can sometimes be useful,
as in this example.
</Para>
<Para>The advantages of this scheme are twofold:
<!-- -->
</Para>
<ItemizedList>
<ListItem>
<Para>It greatly reduces the amount of server-provoked export activity into the
namespace.
</Para>
</ListItem>
<ListItem>
<Para>It allows the server application to associate a people-readable name (that
is, the name of each object's namespace entry) with a UUID.
</Para>
</ListItem>
</ItemizedList>
<!-- -->
<Para>When the server is first activated it creates all the namespace entries,
exports the objects' UUIDs into the object entries, and initializes the group
attributes to refer to the server entry.  It exports its binding information
into the server entry only.  From then on, whenever it is restarted, all the
server needs to do is reexport its binding information into the single server
entry.  Everything else remains the same; that is, the objects' UUIDs have not
changed, nor has the name of the server entry to which the object entries'
group attributes refer.
<!-- -->
<!-- (Note however that, depending on the probability-->
<!-- of more than one server's managing some common set of objects, it may be-->
<!-- advisable for the server to verify the UUIDs it intends to export to the-->
<!-- server entry against the UUIDs in the already-existing CDS objects it will-->
<!-- be managing.)-->
<!-- -->
Thus, instead of exporting bindings to every one of
its object entries on subsequent startups, the server exports to only one
entry.
</Para>
<Para>Of course, if the system were restarted or the namespace reinitialized, then
the original start-up process would have to be repeated.
</Para>
<Para>The slight disadvantage of this scheme occurs on the client side, where the
import process becomes somewhat more complicated than it would be if all
necessary information (both binding and object UUID) could be read
in from the same entry.
<!---->
<!---->
<!-- - -->
</Para>
</Sect1>
<Sect1 Id="ADGISG.NAMESV.div.35">
<Title>Server and Client Steps</Title>
<!-- - -->
<!-- -->
<!-- -->
<Para>The following subsections describe in detail, from both the server's and the
client's side, how this model works.
<!---->
<!-- - -->
</Para>
<Sect2 Id="ADGISG.NAMESV.div.36">
<Title>Server Export</Title>
<!-- - -->
<!---->
<Para>This section lists the steps that the server must perform to set up and
initialize its namespace.  Each step consists of the NSI function that must be
called to perform the operation.
<!-- -->
<!-- -->
</Para>
<OrderedList>
<ListItem>
<Para><Function>uuid_create(&thinsp;)</Function>
</Para>
<Para>To create an object UUID for each object that the server intends to export.
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_server_register_if(&thinsp;)</Function>
</Para>
<Para>To register interface(s) and EPVs with the RPC
runtime. (This is also where manager types, if any, are registered.)
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_server_use_all_protseqs(&thinsp;)</Function>
</Para>
<Para>To request bindings from the RPC runtime for each object.
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_server_inq_bindings(&thinsp;)</Function>
</Para>
<Para>To get the binding handles for each object.
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_binding_export(&thinsp;)</Function>
</Para>
<Para>To export the binding information of the objects' common server and the object
UUIDs for each of the namespace objects to the server's own separate name entry.
This step is performed <Replaceable>only once</Replaceable> for each collection of objects managed
by the same server.
<!-- -->
<!-- -->
</Para>
<Para>The final three steps set up the grouped collection of service objects. Note
that the next two steps are executed once for each object managed by the
server:
<!-- -->
<!-- -->
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_binding_export(&thinsp;)</Function>
<!-- -->
<!-- Change (1) for CR7254: make the following one paragraph (previously-->
<!--  "A NULL" began a second paragraph...-->
<!-- -->
</Para>
<Para>To export each object's object UUID to its own name entry. A NULL
is passed as the <Symbol Role="Variable">binding_vec</Symbol> parameter to specify that only an object UUID,
and no bindings are being exported.
</Para>
<Para>Note that each object UUID must be exported to <Replaceable>both</Replaceable> the object name
entry and the server entry; hence the need for this export operation in
addition to the operation described in Step 5 above.
<!---->
<!-- This is necessary because, when a client imports-->
<!-- a binding through an object's group entry, it will have already read-->
<!-- the object's UUID from its entry.  That object UUID will then be contained-->
<!-- in the handle structure which the client presents...-->
<!---->
<!---->
<!-- -->
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_group_mbr_add(&thinsp;)</Function>
</Para>
<Para>To add the server's name entry (created in the first step) as the sole member
of an NSI group attribute in each of the separate objects' name entries created
in the second step.
<?sml-break><?sml-need 10></Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ep_register(&thinsp;)</Function>
<!-- -->
<!-- Change (2) for CR7254: make clear that this routine is only called once...-->
<!--  -->
<!-- -->
</Para>
<Para>To register each object's UUID with the server's host machine's endpoint mapper.
Note that <Function>rpc_ep_register(&thinsp;)</Function> takes an object UUID vector as an argument,
and generates from this all the necessary relationsips between UUIDs and bindings;
thus the call is made only once.
<!-- -->
<!-- -->
</Para>
<Para>The point of this step is to make sure that when presented with an object UUID in an
incoming RPC, the endpoint mapper can look that UUID up in its database and find an
endpoint that has been registered with it.  Registering the server's bindings
(that is, endpoints) with all object UUIDs will accomplish this.
</Para>
</ListItem>
</OrderedList>
<!-- -->
<!-- -->
<Para>Step 6 above is made necessary by the way the ACL editor's binding
mechanism works. (Applications gain access to the ACLs that
an application maintains on its objects through the client agent <Command>acl_edit</Command>,
which uses a standard DCE-wide interface for ACL operations.) The <Command>acl_edit</Command>
mechanism contains code that allows it to bind to the server that implements
the ACL manager responsible for the object whose ACL is desired.  However,
these generalized binding routines necessarily conform to certain fixed ways
of doing things.  If the <Command>acl_edit</Command> binding mechanism obtains an exported
object's object UUID from the object entry, it will use that object UUID in
its subsequent import through the group attribute.
</Para>
<Para>Thus, the object UUID will be contained in the handle structure that the
client presents to the <Function>rpc_ns_binding_import_next(&thinsp;)</Function> call, expecting
it to be filled in with binding information.  However, the RPC runtime always
tries to match such an input object UUID with a UUID contained in the entry
that the caller is trying to import from.  If no matching object UUID is found,
no binding information will be returned.  Thus, <Replaceable>all</Replaceable> the single object
UUIDs separately exported to the object entries must be exported to the server
entry as well, if the exported objects are to have ACLs accessible through the
<Command>acl_edit</Command> mechanism.
<!-- -->
<!---->
<!-- -->
</Para>
<Para>The following figure illustrates the resulting namespace arrangement.
<!---->
<!---->
<!-- - -->
<!-- - -->
<!-- Figure: showing hybrid-entry binding model with group attributes-->
<!--		on export.-->
<!-- - -->
<!-- - -->
<!-- pix/fighybexp.pic-->
</Para>
<Para><!-- .ne 30-->
<?sml-need 4.5i></Para>
<Figure>
<Title>The Export Operation in a Model with Grouped Bindings</Title>
<Graphic Format="EPS" Entityref="ADGISG.NAMESV.pic.9"></Graphic>
</Figure>
<?sml-space .5>
<!-- -->
<!-- -->
<?sml-space .5>
<Para>This generic server manages four objects, called simply A, B, C,
and D.  One entry is created for each of these objects, and a separate entry
is created for the server itself, where the binding information is held.
</Para>
<Para>The result of all this is that there is now one more namespace entry for a
given service instance than there would have been with the object-oriented
model discussed earlier.  The group attribute in each entry is a level of
indirection that allows the server to dispense with exporting many copies of
the same thing.
</Para>
<Para>If a directory with the proper permissions has been set up for it in the
namespace by the system administrator, a server should be able to create the
object entries simply by making the calls described here.
<!---->
<!---->
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.NAMESV.div.37">
<Title>Client Import</Title>
<!-- - -->
<!---->
<Para>To bind to an object managed by the server as previously described, a client
performs the following series of library calls:
<!-- -->
<!---->
</Para>
<ItemizedList>
<ListItem>
<Para><Function>rpc_ns_entry_object_inq_begin(&thinsp;)</Function>
</Para>
<Para>To set up an object inquiry context; the client application here specifies
the name of the desired namespace object entry.
<?sml-break><?sml-need 8></Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_entry_object_inq_next(&thinsp;)</Function>
</Para>
<Para>To return the object UUID that the server exported to the object's entry.
<!-- -->
<!-- CR7254 change (3): Make clear that the returned object UUID is passed-->
<!--   to rpc_ns_binding_import_begin(); it does not have to be manually-->
<!--   inserted into the binding handle.-->
<!-- -->
</Para>
<Para>This UUID (which will be passed to the
<Function>rpc_ns_binding_import_begin(&thinsp;)</Function>
routine, below) will enable the server host's endpoint mapper to accurately map
the incoming remote procedure call to the server that exported this entry.
</Para>
<Para>The UUID may also be used by the server itself to determine which object
the client wants to access.  Note that although this set of library routines
is designed to accommodate schemes in which multiple object UUIDs have been
exported to the same entry, the model described here requires that <Replaceable>only
one</Replaceable> object UUID (the unique identifier of the object to bind to) be
exported.
<!-- -->
<!-- -->
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_entry_object_inq_done(&thinsp;)</Function>
</Para>
<Para>To delete the object inquiry context.
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_binding_import_begin(&thinsp;)</Function>
</Para>
<Para>To set up a binding import context.
</Para>
<Para>Note that the object UUID that was returned by the call to
<Function>rpc_ns_entry_object_inq_next(&thinsp;)</Function> must be passed to
<Function>rpc_ns_binding_import_begin(&thinsp;)</Function>; as a result of this the import
operation (<Function>rpc_ns_binding_import_next(&thinsp;)</Function>) will return only a binding
with that object UUID.
</Para>
<Para>An alternative to using the binding import routines would be to use the group
member inquiry (<Literal>rpc_ns_group_mbr_inq_</Literal><Symbol Role="Variable">*</Symbol>
<Literal>(&thinsp;)</Literal>) routines to learn the name
of the entry referred to in the group attribute, and then to do a direct import
from that entry.
</Para>
<Para>The reason for using the <Literal>rpc_ns_group_mbr_inq_</Literal><Symbol Role="Variable">*</Symbol>
<Literal>(&thinsp;)</Literal> routines, rather
than the normal import functions (<Literal>rpc_ns_binding_</Literal><Symbol Role="Variable">*</Symbol>
<Literal>(&thinsp;)</Literal>), would be to
make sure that the group (and not some other) attribute in the entry is read.
The <Function>rpc_ns_binding_import_next(&thinsp;)</Function> routine is defined to successively
exhaust the contents of an entry's
<!-- -->
</Para>
<ItemizedList>
<ListItem>
<Para><FirstTerm>binding</FirstTerm> attribute
</Para>
</ListItem>
<ListItem>
<Para><Replaceable>group</Replaceable> attribute
</Para>
</ListItem>
<ListItem>
<Para><Literal>profile</Literal> attribute
</Para>
</ListItem>
</ItemizedList>
<!-- -->
<Para><?sml-need 8>Since the model described here employs object entries with only group attributes
and no binding or profile attributes, using the normal import routine should work
fine.
<!-- -->
<!-- -->
<!-- -->
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_binding_import_next(&thinsp;)</Function>
</Para>
<Para>To read the entry's group attribute.
</Para>
<Para>The name service's access to (and return of the binding handle from) the entry's
group attribute is transparent and unerring because there is only one set of
binding information associated with a given entry in this scheme, and that
information is found only in the group attribute.  Note that if there had been
more than one member in the group, which in fact is generally the case when
group attributes are used, then the order of return would be random.  Or if there
had been binding information associated with <Replaceable>both</Replaceable> attributes, then here also
the order in which binding handles would be returned would be random; that is, the
caller might get a handle from the simple name attribute first, and then the
handles exported to the group members, or it might get one or more of the group's
member's handles, then one or more of the simple entry's handles, and so on.
<!---->
<!---->
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_binding_import_done(&thinsp;)</Function>
</Para>
<Para>To delete the binding import context.
<!-- .LI "7."-->
<!-- \*Lrpc_binding_set_object(\|)\*O-->
<!-- .P-->
<!-- To insert the object's object UUID into the imported binding handle.-->
</Para>
</ListItem>
</ItemizedList>
<!-- -->
<!-- -->
<Para>The next figure illustrates this activity.
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
<!-- - -->
<!-- Figure: showing hybrid-entry binding model with group attributes-->
<!--		on import.-->
<!-- - -->
<!-- - -->
<!-- pix/fighybimp.pic-->
<!-- -->
<!-- .ne 40-->
</Para>
<?sml-need 5.5i>
<Figure>
<Title>Importing from a Model That Uses Grouped Bindings</Title>
<Graphic Format="EPS" Entityref="ADGISG.NAMESV.pic.10"></Graphic>
</Figure>
<?sml-space .5>
<!-- -->
<!-- -->
<?sml-space .5>
<Para>The client shown in the figure imports a binding for object A.  This
becomes (through the group attribute) a referral back to the server's entry
where the bindings are held, and a binding is indirectly imported from the
server entry.  The object UUID for A is read, in a separate operation,
directly from the object's entry.  With this information in its binding
handle, the client makes its first remote call through the server's
interface.  The call finds its way to the endpoint mapper via the partial
binding information, and the endpoint mapper completes the binding by
looking up the object UUID, which was registered there by the server.
<!-- -->
<!-- -->
<!---->
<!-- - -->
</Para>
</Sect2>
</Sect1>
<Sect1 Id="ADGISG.NAMESV.div.38">
<Title>Global Organization of the Namespace</Title>
<!-- - -->
<!---->
<Para>Since DCE is designed to support very large namespaces, it uses a hierarchical
service for binding.  The global scale is separated into cells whose boundaries
are administratively defined.  For example, a company using DCE might have a cell
containing its employees and local services.  The cell namespace administrator
could decide to put all the service entries in a single directory if the cell
were small.
</Para>
<Para>Both the import and export name service operations support default values derived
from environment variables; for example, 
<SystemItem Class="EnvironVar">RPC_DEFAULT_ENTRY_NAME</SystemItem>.  The
environment variables can be set by start-up files to the name of a well-known
directory within the cell.  The only remaining decision then will be how to name
the actual entries within the directory.  One easy method is to use mnemonic names,
or names of interfaces such as <Literal>binop</Literal>, <Literal>spm_library</Literal>, and so on.  If these
entries are only being accessed by clients through profiles, their names will not
be directly visible to the client anyway.
</Para>
<Para>But now imagine a larger organization. The administrator will want to define some
naming hierarchy based on geography, organization, or other criteria.  Somewhere
within this hierarchy some writable directories (or parent directories) would be
created, which could contain server entries, profiles, and so on.  If clients are
using only profiles to access bindings, then this organization will still be
transparent to them.  If clients want to bind to specific servers or objects, then
more attention must be paid to the names given the servers' or objects' entries.
The names should in some way reflect the organization, geography, or other relevant
aspects of the server or object.
<!-- -->
</Para>
<Para>In summary, the important points to keep in mind are the following:
<!-- -->
</Para>
<ItemizedList>
<ListItem>
<Para>The model should be appropriate for the organization and permit efficient
administration of the namespace.
</Para>
</ListItem>
<ListItem>
<Para>There should be simple guidelines for naming objects and services so that
users have a good chance of guessing the right answer.
</Para>
</ListItem>
</ItemizedList>
</Sect1>
</Chapter>
<!--+ 11/13/96 22:48:26
    | tagMorph:  $Id: nameservice.sgm,v 1.1.2.6 1996/11/25 18:18:56 carrig Exp $
    | tagMorph library:  $Id: nameservice.sgm,v 1.1.2.6 1996/11/25 18:18:56 carrig Exp $
    | sml-to-docbook:  1.24
    +-->
