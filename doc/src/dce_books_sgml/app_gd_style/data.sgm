<!--
# @OSF_COPYRIGHT@
# 
# 
# HISTORY
# $Log: data.sgm,v $
# Revision 1.1.2.5  1996/11/25  18:18:48  carrig
# 	{enh,R1.2.2}
# 	VarListEntry, Figure, Table, Code Examples
# 	[1996/11/25  18:18:01  carrig]
#
# Revision 1.1.2.4  1996/11/23  23:02:55  weir
# 	Removed thinsp entities in parenthesized index entries
# 	[1996/11/23  23:01:56  weir]
# 
# Revision 1.1.2.3  1996/11/21  18:06:43  weir
# 	Shortened some source lines
# 	[1996/11/21  18:05:48  weir]
# 
# Revision 1.1.2.2  1996/11/21  16:52:30  weir
# 	Corrected entity declarations, etc.
# 	[1996/11/21  16:51:37  weir]
# 
# Revision 1.1.2.1  1996/11/20  21:56:02  weir
# 	Initial submission
# 	[1996/11/20  21:55:08  weir]
# 
# $EndLog$
-->
<!-- Fragment document type declaration subset:
ArborText, Inc., 1988-1993, v.4001
<!DOCTYPE Book PUBLIC "-//Davenport//DTD DocBook V2.4//EN" [
]>
-->
<!-- COPYRIGHT NOTICE-->
<!-- Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.-->
<!-- ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for-->
<!-- the full copyright text.-->
<!-- -->
<!-- -->
<!-- OLD HISTORY-->
<!-- Revision 1.1.4.1  1996/03/21  17:06:36  wardr-->
<!-- 	{edit R1.2.1}-->
<!-- 	Release Edits-->
<!-- 	[1996/03/21  17:05:47  wardr]-->
<!---->
<!-- Revision 1.1.2.11  1995/06/27  17:46:21  buckler-->
<!-- 	More 1.1 edits.-->
<!-- 	[1995/06/27  17:45:58  buckler]-->
<!-- -->
<!-- Revision 1.1.2.10  1995/06/27  17:04:02  buckler-->
<!-- 	1.1 edits and Prentice Hall reformat-->
<!-- 	[1995/06/27  17:02:54  buckler]-->
<!-- -->
<!-- Revision 1.1.2.9  1994/11/15  16:30:00  weir-->
<!-- 	No change-->
<!-- 	[1994/11/15  16:29:37  weir]-->
<!-- -->
<!-- Revision 1.1.2.8  1994/10/20  20:56:17  weir-->
<!-- 	Fixed a few typos-->
<!-- 	[1994/10/20  20:55:47  weir]-->
<!-- -->
<!-- Revision 1.1.2.7  1994/10/19  20:48:10  weir-->
<!-- 	Review comments-->
<!-- 	[1994/10/19  20:47:15  weir]-->
<!-- -->
<!-- Revision 1.1.2.6  1994/10/19  16:02:44  weir-->
<!-- 	Review comments and edits-->
<!-- 	[1994/10/19  16:01:51  weir]-->
<!-- -->
<!-- Revision 1.1.2.5  1994/10/12  22:03:35  jshirley-->
<!-- 	Moved Context Handles and Pipes discussions to RPC Topics chapter.-->
<!-- 	[1994/10/12  22:02:58  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.4  1994/10/11  14:05:45  weir-->
<!-- 	Updates-->
<!-- 	[1994/10/11  14:04:51  weir]-->
<!-- -->
<!-- Revision 1.1.2.3  1994/09/28  20:58:12  weir-->
<!-- 	Updates-->
<!-- 	[1994/09/28  20:57:33  weir]-->
<!-- -->
<!-- Revision 1.1.2.2  1994/06/13  18:22:33  devobj-->
<!-- 	cr10872 - fix copyright-->
<!-- 	[1994/06/13  18:19:55  devobj]-->
<!-- -->
<!-- Revision 1.1.2.1  1994/03/11  23:04:54  rom-->
<!-- 	{enh, 10129, R1.1}-->
<!-- 	Initial split of App Dev Guide into three books and creation of-->
<!-- 	Intro and Style Guide.-->
<!-- 	[1994/03/11  23:01:48  rom]-->
<!-- -->
<!---->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
<Chapter Id="ADGISG.DATA.div.1">
<Title>RPC Parameters</Title>
<!-- - -->
<!-- -->
<Para>The RPC mechanism attempts to provide a data model as close as
possible to the familiar local call model.  For example, you can pass
data by reference&mdash;by passing a pointer to a data item&mdash;despite
the fact that client and server do not share an address space.
Nevertheless, there are significant differences in both the syntax and
semantics of RPC parameter data compared with C language local call
<IndexTerm Id="ADGISG.DATA.indx.1">
<Primary>RPC</Primary>
<Secondary>parameter data</Secondary>
</IndexTerm>data.  For example, RPC provides directional attributes, conformant
arrays, discriminated unions, and pipes, constructs which have no
equivalents in C.  Each requires an IDL specific syntax and has
new semantics.  Also, familiar constructs, such as pointers, closely
mimic their local C language counterparts, but nevertheless must
behave differently in some circumstances.
</Para>
<Para>The DCE RPC programmer is thus confronted with a number of unfamiliar
style and policy issues.  The policy issues have mainly to do with
which data types to use in given circumstances: for example, would you
be better off using an array or a pipe to transfer a large block of
data?  This chapter contains recommendations that should help you make
such choices.  The style issues arise from the rich and unfamiliar
syntax for RPC parameters which can make the mechanics of using many
of the RPC data types seem rather daunting.  This chapter contains
numerous examples of basic data passing styles.
<IndexTerm Id="ADGISG.DATA.indx.2">
<Primary>basic data passing styles</Primary>
</IndexTerm>
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
</Para>
<Sect1 Id="ADGISG.DATA.div.2">
<Title>Execution Semantics</Title>
<!-- - -->
<!-- -->
<Para>Before we begin to discuss the RPC data types themselves, a slight
digression is necessary.  Whatever data you pass, all RPCs must deal
with the unreliable nature of remote network connections.  A call may
not complete due to a network failure, possibly leaving the call
operations in an indeterminate state.  For this reason, the IDL
provides execution semantics attributes that applications can use
to request certain (limited) guarantees about call completness.
</Para>
<Para>Ideally, in order for an application to behave in a determinate
fashion, each operation needs to be invoked exactly once each time it
is invoked.  This requirement can be relaxed somewhat for idempotent
operations: those which have the same effect when they are invoked one
or more times.  In this case, an application can settle for
at-least-once semantics.
<IndexTerm Id="ADGISG.DATA.indx.3">
<Primary>idempotent semantics</Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.DATA.indx.4">
<Primary>at-least-once semantics</Primary>
</IndexTerm></Para>
<Para>Unfortunately, with a remote procedure call, there is no way to
guarantee either exactly once or at-least-once call semantics.
Instead, RPC provides <Literal>at-most-once</Literal> and <Literal>idempotent</Literal>
semantics.  When a call completes and returns to the client, then
at-most-once semantics is equivalent to exactly-once semantics, and
idempotent semantics is equivalent to at-least-once.  When a
call fails to return to the client&mdash;either because of a server or
communications failure&mdash;the semantics make the following
guarantees:
<!-- -->
<!-- -->
<!-- -->
</Para>
<VariableList>
<VarListEntry role="linebreak">
<Term><Literal>at-most-once</Literal></Term>
<ListItem>
<?sml-break>
<Para>The call was invoked on the server either 0 or 1 times.  If the call
was invoked, it may or may not have completed execution.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>idempotent</Literal></Term>
<ListItem>
<?sml-break>
<Para>The call was invoked on the server 0 or more times.  If the call was
invoked, it may or may not have completed execution for any invocation.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
<!-- -->
<Para>In reality, idempotent semantics provides no guarantee for
calls that fail to return to the client.  In fact,
DCE provides no guarantee about how idempotent semantics are actually
implemented.  It is perfectly correct to implement idempotency
by using at-most-once semantics, and depending on protocol and
implementation, this may be the case.  Idempotent semantics is therefore
really a hint from the application that a call is a candidate to be
retried if the implementation uses a retry strategy.
</Para>
<Para>These characteristics lead to two kinds of policy guidelines for call
semantics.  The first has to do with the behavior required of
idempotent operations.  An operation is a good candidate for
idempotent semantics if it either changes no state on the
server (such as, a read operation), or if the server state will be the
same even if the same call is invoked more than once (such as, a call
that writes the same record) with the same <Literal>[in]</Literal> data.  Note that in
either of these cases, the result returned by a call may not be the
same on each retry, since some other thread or process may have
modified server state.  A server that allows simultaneous reads and
writes provides a good example.  However, the runtime does guarantee
commutativity of operations on the same association: an idempotent
call will not be retried if a later call on the same association has
been invoked.
</Para>
<Para>The second policy issue has to do with how applications respond to
call failures.  The issues are the same for idempotent and
at-most-once calls.  In neither case can the client know whether the
server manager operation was invoked, and, if it was invoked, whether
it was completed.  This leads to three possible failure states:
<!-- -->
<!-- -->
</Para>
<OrderedList>
<ListItem>
<Para>The manager operation was not invoked.
</Para>
</ListItem>
<ListItem>
<Para>The manager operation was invoked but did not complete.
</Para>
</ListItem>
<ListItem>
<Para>The manager operation was invoked and completed, but failed to return to
the client.
</Para>
</ListItem>
</OrderedList>
<!-- -->
<!-- -->
<Para>The burden of determining which state applies, and implementing
recovery actions rests almost entirely with the
application.  The RPC mechanism provides limited support for cleanup in
the case of applications that use context handles to maintain state
between calls.  Application provided context rundown routines will be
called on behalf of the application if a communications failure is
detected.
<!-- This mechanism is described more fully in Section XXXXX.-->
Beyond this rather elementary mechanism, DCE RPC does not provide any
internal support for transaction processing, roll-back, or
other recovery mechanisms.  For applications where error recovery and
maintainance of consistent state is essential, these must be
implemented by the application programmer.  The topic is beyond the
realm of this policy guide.
</Para>
<Para><?sml-need 10>IDL also provides two execution semantic attributes of somewhat more limited
use: <Literal>broadcast</Literal> and <Literal>maybe</Literal>.  Broadcast semantics may be used with
<IndexTerm Id="ADGISG.DATA.indx.5">
<Primary><Literal>broadcast</Literal> semantic attribute</Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.DATA.indx.6">
<Primary><Literal>maybe</Literal> semantic attribute</Primary>
</IndexTerm>connectionless transports when there are multiple servers on the local network
that can handle a call.  The client broadcasts the call request to all servers,
and completes the call with one of them.  Maybe semantics provides a calling
style that may be used when a call has no <Literal>[out]</Literal> or <Literal>[in, out]</Literal>
parameters.  The call is attempted once, and no response is returned.  Both
<Literal>broadcast</Literal> and <Literal>maybe</Literal> semantics implictly require that the operation
be idempotent. 
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
</Para>
</Sect1>
<Sect1 Id="ADGISG.DATA.div.3">
<Title>Parameter Semantics</Title>
<!-- - -->
<!-- -->
<Para>RPC calls and the RPC API specify directional attributes for their
parameters, even though such attributes are not formally supported by
C.  As a general rule, an <Literal>[in]</Literal> parameter is one that must be passed
with a meaningful value and an <Literal>[out]</Literal> parameter is one whose value
will be changed by the call.  An <Literal>[in,out]</Literal> parameter is therefore
one which must have a meaningful value on input and which may be
changed on output.
</Para>
<Para>The following table summarizes parameter semantics:
<!-- -->
<!-- -->
<IndexTerm Id="ADGISG.DATA.indx.7">
<Primary>parameter semantics</Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.DATA.indx.8">
<Primary>semantics</Primary>
<Secondary>parameter</Secondary>
</IndexTerm>
<!-- -->
</Para>
<Table Frame="all" Remap="center" Orient="Port">
<Title>Parameter Semantics</Title>
<TGroup Rowsep="0" Colsep="0" Cols="3">
<ColSpec Colsep="1" Align="Left" Colwidth="1*" Colname="col1" Colnum="1">
<ColSpec Colsep="1" Align="Center" Colwidth="1*" Colname="col2" Colnum="2">
<ColSpec Align="Center" Colwidth="1*" Colname="col3" Colnum="3">
<TBody>
<Row>
<Entry Rowsep="1"><Literal>Semantics</Literal></Entry>
<Entry Rowsep="1" Align="Left"><Literal>Meaningful value input</Literal></Entry>
<Entry Rowsep="1" Align="Left"><Literal>Changed on output
<!-- WARNING: ghost column #4: -->
</Literal></Entry>
</Row>
<Row>
<Entry><Literal>[in]</Literal></Entry>
<Entry>yes</Entry>
<Entry>no
<!-- WARNING: ghost column #4: -->
</Entry>
</Row>
<Row>
<Entry><Literal>[out]</Literal></Entry>
<Entry>no</Entry>
<Entry>yes
<!-- WARNING: ghost column #4: -->
</Entry>
</Row>
<Row>
<Entry><Literal>[in,out]</Literal></Entry>
<Entry>yes</Entry>
<Entry>yes
<!-- WARNING: ghost column #4: -->
</Entry>
</Row>
</TBody>
</TGroup>
</Table>
<!-- -->
<!-- -->
<Para>An <Literal>[out]</Literal> or( <Literal>[in,out]</Literal>) parameter is one whose value is
changed by the call, so it must be passed by reference, that is, as a
pointer to the datum of interest.  RPCs and the RPC APIs therefore
always specify output parameters as pointers.  The address passed must
always point to valid storage.  For example, the ubiquitous
<Symbol Role="Variable">status</Symbol> parameter may be declared in the IDL as follows:
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing>[out] error_status_t *status
</ProgramListing></Para>
</InformalExample>
<!-- -->
<Para><?sml-need 10>The application code then needs to declare a variable such as
the following,
and pass it as <Literal>&amp;st</Literal> to each RPC:
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing>error_status_t st;
</ProgramListing></Para>
</InformalExample>
<!-- -->
<Para>When a call allocates storage for an output parameter, it is declared
as a pointer to a pointer.  For example:
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing>rpc_binding_vector_t  **binding_vector
</ProgramListing></Para>
</InformalExample>
<!-- -->
<Para>The application follows the same rule as in the <Literal>status</Literal> case,
declaring a variable such as the following,
and then passing this as <Literal>&amp;binding_vec</Literal>: 
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing>rpc_binding_vector_t *binding_vec
</ProgramListing></Para>
</InformalExample>
<!-- -->
<Para>This obeys all the rules
for output parameters: the address passed to the call points to valid
storage, but the contents of that storage need not contain a
meaningful value (in this case, need not be a valid pointer).  A
simple rule of thumb for output parameters is to declare a variable
with one less asterisk than contained in the IDL (or RPC API)
declaration and pass its address when calling the operation.
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
</Para>
<Sect2 Id="ADGISG.DATA.div.4">
<Title>Parameter Memory Management</Title>
<!-- - -->
<!-- -->
<Para><IndexTerm Id="ADGISG.DATA.indx.9">
<Primary>memory management, parameter</Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.DATA.indx.10">
<Primary>allocating</Primary>
<Secondary>parameter memory</Secondary>
</IndexTerm>RPC attempts to extend local procedure call parameter memory management
semantics to a situation in which the calling and called procedure no
longer share the same memory space.  In effect, parameter memory has
to be allocated twice, once on the client side, once on the server
side.  Stubs do as much of the extra allocation work as possible so
that the complexities of parameter allocation are transparent to
applications.  In some cases, however, applications may have to manage
parameter memory in a way that differs from the usual local procedure
call semantics. 
</Para>
<Para><?sml-need 10>For the purposes of memory allocation, three classes of parameters must
to be considered:
<!-- -->
<!-- -->
</Para>
<ItemizedList>
<ListItem>
<Para>Nonpointer types
</Para>
</ListItem>
<ListItem>
<Para>Reference pointers
</Para>
</ListItem>
<ListItem>
<Para>Full pointers
</Para>
</ListItem>
</ItemizedList>
<IndexTerm Id="ADGISG.DATA.indx.11">
<Primary>nonpointer type parameters</Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.DATA.indx.12">
<Primary>reference pointers</Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.DATA.indx.13">
<Primary>full pointer parameters</Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.DATA.indx.14">
<Primary>parameters</Primary>
<Secondary>nonpointer types</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.DATA.indx.15">
<Primary>parameters</Primary>
<Secondary>reference pointers</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.DATA.indx.16">
<Primary>parameters</Primary>
<Secondary>full pointers</Secondary>
</IndexTerm>
<!-- -->
<Para>For all types, the client application supplies parameters to the client
stub, which marshals them for transmission to the server.  The client
application is entirely responsible for managing the memory occupied
by the passed parameters.  On the server side, the server stub allocates
and frees all memory required for the received parameters themselves.
</Para>
<Para>In the case of the pointer types, however, the application and stubs must
manage memory not only for the parameters themselves, but also for the
pointed-to nodes.  In this case, the memory management requirements depend
both on the pointer type and on the parameter's directional attributes.
</Para>
<Para>The rules are described in the following sections.
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.DATA.div.5">
<Title>Client Side Allocation</Title>
<!-- - -->
<!-- -->
<VariableList>
<!-- -->
<VarListEntry role="linebreak">
<Term><Literal>in</Literal>&ensp;parameters</Term>
<ListItem>
<?sml-break>
<Para>For all pointer types, the client application must allocate memory for the
pointed-to nodes.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>out</Literal>&ensp;parameters</Term>
<ListItem>
<?sml-break>
<Para>For reference pointers, the client application must allocate memory
for the pointed-to nodes, unless the pointer is part of a data
structure created by server manager code.  For parameters containing
full pointers, the stub allocates memory for the pointed-to nodes.
<!-- -->
<?sml-break><?sml-need 10></Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>in, out</Literal>&ensp;parameters</Term>
<ListItem>
<?sml-break>
<Para>For reference pointers, the client application must allocate memory
for the pointed-to nodes.  For full pointers, on making the call, the
client application must allocate memory for the pointed-to node.  On
return, the stub keeps track of whether each parameter is the original
full pointer passed by the client, or a new pointer allocated by the
server.  If a pointer is unchanged, the returned data overwrites the
existing pointed-to node.  If a pointer is new, the stub allocates
memory for the pointed-to node.  When a parameter contains
pointers, such as an element in a linked list, the stub keeps track
of the chain of references, allocating nodes as necessary.
</Para>
<Para>It is the client application's responsibility to free any memory
allocated by the stub for new nodes.  Clients can call the routine
<Function>rpc_sm_client_free(&thinsp;)</Function> for this purpose.
<IndexTerm Id="ADGISG.DATA.indx.17">
<Primary><Function>rpc_sm_client_free()</Function></Primary>
</IndexTerm></Para>
<Para>If the server deletes or eliminates a reference to a pointed to node,
an <Replaceable>orphaned</Replaceable> node may be created on the client side.  It is the
client application's responsibility to keep track of memory that it
has allocated for pointed-to nodes and to deal with any nodes for
which the server no longer has references.
<IndexTerm Id="ADGISG.DATA.indx.18">
<Primary>orphaned node</Primary>
</IndexTerm>
<!-- -->
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
</Sect2>
<Sect2 Id="ADGISG.DATA.div.6">
<Title>Server Side Allocation</Title>
<!-- - -->
<!-- -->
<VariableList>
<!-- -->
<VarListEntry role="linebreak">
<Term><Literal>in</Literal>&ensp;parameters</Term>
<ListItem>
<?sml-break>
<Para>For all pointer types, the stub manages all memory for pointed-to nodes.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>out</Literal>&ensp;parameters</Term>
<ListItem>
<?sml-break>
<Para>For reference pointers, the stub allocates memory for the pointed-to
nodes as long as the size of the targets can be determined at compile
time.  When the manager routine is entered, such reference pointers
point to valid storage.  For parameters that contain full pointers,
the server manager code must allocate memory for pointed-to nodes.
Servers can call the routine <Function>rpc_sm_allocate(&thinsp;)</Function> for this purpose.
<IndexTerm Id="ADGISG.DATA.indx.19">
<Primary><Function>rpc_sm_allocate()</Function></Primary>
</IndexTerm>
<!-- -->
<?sml-break><?sml-need 10></Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>in, out</Literal>&ensp;parameters</Term>
<ListItem>
<?sml-break>
<Para>For reference pointers, the stub allocates memory for pointed-to nodes
if either the size of the pointed to nodes can be determined at
compile time or the reference pointers point to values received from
the client.  When the manager routine is entered, such reference
pointers point to valid storage.  For full pointers, the stub allocates
memory for the original pointed-to nodes.  The server manager code
must allocate memory if it creates new references.  Servers can call
the routine <Function>rpc_sm_allocate(&thinsp;)</Function> for this purpose.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
<Para>The server stub automatically frees all memory allocated with
<Function>rpc_sm_allocate(&thinsp;)</Function>.
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
</Para>
</Sect2>
</Sect1>
<Sect1 Id="ADGISG.DATA.div.7">
<Title>RPC Data Types</Title>
<!-- - -->
<!-- -->
<Para><IndexTerm Id="ADGISG.DATA.indx.20">
<Primary>RPC</Primary>
<Secondary>data types</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.DATA.indx.21">
<Primary>primitive data types</Primary>
</IndexTerm>IDL provides both a number of primitive data types&mdash;such as various
sizes of integers and floats, bytes, and booleans&mdash;as well as pointers
and a variety of constructed types based on the primitive types.  The use of
the primitive types is quite straightforward.  The only important policy
issues have to do with IDL data type to C data type mappings and with
character handling.  Pointers and the constructed types raise many more
policy and style issues, and the bulk of this chapter is devoted to
describing them.
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
</Para>
<Sect2 Id="ADGISG.DATA.div.8">
<Title>IDL to C Type Mappings</Title>
<!-- - -->
<!-- -->
<IndexTerm Id="ADGISG.DATA.indx.22">
<Primary>mappings</Primary>
<Secondary>IDL to C</Secondary>
</IndexTerm>
<Para>Many of the primitive C data types represent items of different sizes
on different machines.  For example, an <Literal>int</Literal> may be 16 bits on
one machine and 32 bits on another.  These ambiguities can cause portability
problems for some C programs, and they are intolerable for RPC
programs.  A parameter to an RPC call must represent the same size
data item on both the client and server machine, whatever the machine
architectures.
</Para>
<Para>This means that when IDL declarations are compiled to generate C
language headers and stubs, a given IDL type must always be declared
in the corresponding C code as a C type of a specific length, no matter
what machine the IDL compilation is done on.  
</Para>
<Para><?sml-need 10>To achieve this, the following must be true:
<!-- -->
<!-- -->
</Para>
<OrderedList>
<ListItem>
<Para>Each IDL primitive type is always represented in the generated C
files, by a specific defined C type
</Para>
</ListItem>
<ListItem>
<Para>Each of the specific defined C types is defined by the local
implementation of DCE so that it represents a data type of the
correct length.
</Para>
</ListItem>
</OrderedList>
<!-- -->
<Para>For example, a parameter declared in the IDL as a <Literal>short</Literal>, will be
declared in the IDL generated header file as the defined type
<Literal>idl_short_int</Literal>.  Each implementation of DCE then defines the
<Literal>idl_shor_int</Literal> type correctly for the local C compiler and machine
architecture to be an integer 16 bits long.  For example, on a 32-bit
machine, the <Literal>idl_short_int</Literal> type is typically defined as a
<Literal>short int</Literal>.
</Para>
<Para>When you write application code that refers to a parameter declared in
the IDL, you must use a type that declares a data item of the same
length.  The safest policy is to use the same specific defined C type
used in the headers and stubs.  For example, your IDL file
might declare the following:
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing>void my_op([in,out] short var); 
</ProgramListing></Para>
</InformalExample>
<!-- -->
<Para>In this case, your server manager code would contain an function that looks
something like this:
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing>void my_op(idl_short_int var)
{
        .
        .
        .
}
</ProgramListing></Para>
</InformalExample>
<!-- -->
<Para>On a 32-bit machine, your code could probably use a <Literal>short</Literal> safely
(since that is how your implementation probably defines <Literal>idl_short_int</Literal>,
but such usage is not portable to other machine types and is therefore not
recommended.
</Para>
<Para>The following table shows the IDL to C type mappings for the IDL primitive
types.
<!-- -->
<!-- -->
<!-- -->
</Para>
<?sml-need 6.5i>
<Table Frame="all" Remap="center" Orient="Port" role="page-wide">
<Title>IDL/NDR/C Type Mappings: Part 1</Title>
<TGroup Rowsep="0" Colsep="0" Cols="4">
<ColSpec Rowsep="1" Colsep="1" Align="Left" Colwidth="1*" Colname="col1" Colnum="1">
<ColSpec Rowsep="1" Colsep="1" Align="Left" Colwidth="1*" Colname="col2" Colnum="2">
<ColSpec Rowsep="1" Colsep="1" Align="Left" Colwidth="1*" Colname="col3" Colnum="3">
<ColSpec Rowsep="1" Align="Left" Colwidth="1*" Colname="col4" Colnum="4">
<THead>
<Row>
<Entry Rowsep="1"><Literal>IDL Type</Literal></Entry>
<Entry Rowsep="1"><Literal>NDR Type</Literal></Entry>
<Entry Rowsep="1"><Literal>Defined C Type</Literal></Entry>
<Entry Rowsep="1"><Literal>C Type</Literal></Entry>
</Row>
</THead>
<TBody>
<Row>
<Entry><Literal>boolean	</Literal></Entry>
<Entry><Literal>boolean</Literal></Entry>
<Entry><Literal>idl_boolean</Literal></Entry>
<Entry><Literal>unsigned char</Literal></Entry>
</Row>
<Row>
<Entry><Literal>char</Literal></Entry>
<Entry><Literal>character</Literal></Entry>
<Entry><Literal>idl_char</Literal></Entry>
<Entry><Literal>unsigned char</Literal></Entry>
</Row>
<Row>
<Entry><Literal>byte</Literal></Entry>
<Entry><Literal>uninterpreted octet</Literal></Entry>
<Entry><Literal>idl_byte</Literal></Entry>
<Entry><Literal>unsigned char</Literal></Entry>
</Row>
<Row>
<Entry><Literal>small</Literal></Entry>
<Entry><Literal>small</Literal></Entry>
<Entry><Literal>idl_small_int</Literal></Entry>
<Entry><Literal>char</Literal></Entry>
</Row>
<Row>
<Entry><Literal>short</Literal></Entry>
<Entry><Literal>short</Literal></Entry>
<Entry><Literal>idl_short_int</Literal></Entry>
<Entry><Literal>short int</Literal></Entry>
</Row>
<Row>
<Entry><Literal>long</Literal></Entry>
<Entry><Literal>long</Literal></Entry>
<Entry><Literal>idl_long_int</Literal></Entry>
<Entry><Literal>long int</Literal></Entry>
</Row>
<Row>
<Entry><Literal>hyper</Literal></Entry>
<Entry><Literal>hyper</Literal></Entry>
<Entry><Literal>idl_hyper_int</Literal></Entry>
<Entry>
16-Bit or 32-Bit Machines:
Big Endian:
<Literal>struct {
    long high;
    unsigned long low;
  }</Literal>
 
Little Endian:
<Literal>struct {
    unsigned long low;
    long high;
  }</Literal>
 
64-Bit Machines:
<Literal>long</Literal>
<?sml-fill></Entry>
</Row>
<Row>
<Entry><Literal>unsigned small</Literal></Entry>
<Entry><Literal>unsigned small</Literal></Entry>
<Entry><Literal>idl_usmall_int</Literal></Entry>
<Entry><Literal>unsigned char</Literal></Entry>
</Row>
<Row>
<Entry><Literal>unsigned short</Literal></Entry>
<Entry><Literal>unsigned short</Literal></Entry>
<Entry><Literal>idl_ushort_int</Literal></Entry>
<Entry><Literal>unsigned short int</Literal></Entry>
</Row>
<Row>
<Entry><Literal>unsigned long</Literal></Entry>
<Entry><Literal>unsigned long</Literal></Entry>
<Entry><Literal>idl_ulong_int</Literal></Entry>
<Entry><Literal>unsigned long int</Literal></Entry>
</Row>
<Row>
<Entry><Literal>unsigned hyper</Literal></Entry>
<Entry><Literal>unsigned hyper</Literal></Entry>
<Entry><Literal>idl_uhyper_int</Literal></Entry>
<Entry>
16-Bit or 32-Bit Machines:
Big Endian:
<Literal>struct {
    unsigned long high;
    unsigned long low;
  }</Literal>
 
Little Endian:
<Literal>struct {
    unsigned long low;
    unsigned long high;
  }</Literal>
 
64-Bit Machines:
<Literal>unsigned long</Literal>
<?sml-fill></Entry>
</Row>
</TBody>
</TGroup>
</Table>
<?sml-point-size 9>
<!--no-op:  12-->
<?sml-indent -1i>
<?sml-point-size 12>
<!--no-op:  14-->
<?sml-indent>
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<?sml-break>
<?sml-need 4.5i>
<Table Frame="all" Remap="center" Orient="Port" role="page-wide">
<Title>IDL/NDR/C Type Mappings: Part 2</Title>
<TGroup Rowsep="0" Colsep="0" Cols="4">
<ColSpec Rowsep="1" Colsep="1" Align="Left" Colwidth="1*" Colname="col1" Colnum="1">
<ColSpec Rowsep="1" Colsep="1" Align="Left" Colwidth="1*" Colname="col2" Colnum="2">
<ColSpec Rowsep="1" Colsep="1" Align="Left" Colwidth="1*" Colname="col3" Colnum="3">
<ColSpec Rowsep="1" Align="Left" Colwidth="1*" Colname="col4" Colnum="4">
<TBody>
<Row>
<Entry Rowsep="1"><Literal>IDL Type</Literal></Entry>
<Entry Rowsep="1"><Literal>NDR Type</Literal></Entry>
<Entry Rowsep="1"><Literal>Defined C Type</Literal></Entry>
<Entry Rowsep="1"><Literal>C Type</Literal></Entry>
</Row>
<Row>
<Entry><Literal>float</Literal></Entry>
<Entry><Literal>float</Literal></Entry>
<Entry><Literal>idl_float</Literal></Entry>
<Entry><Literal>float</Literal></Entry>
</Row>
<Row>
<Entry><Literal>double</Literal></Entry>
<Entry><Literal>double</Literal></Entry>
<Entry><Literal>idl_double</Literal></Entry>
<Entry><Literal>double</Literal></Entry>
</Row>
<Row>
<Entry><StructName Role="typedef">handle_t</StructName></Entry>
<Entry><Literal>not transmitted</Literal></Entry>
<Entry><StructName Role="typedef">handle_t</StructName></Entry>
<Entry><Literal>void *</Literal> </Entry>
</Row>
<Row>
<Entry><StructName Role="typedef">error_status_t</StructName></Entry>
<Entry><Literal>unsigned long</Literal></Entry>
<Entry><Literal>idl_ulong_int</Literal></Entry>
<Entry><Literal>unsigned long int</Literal></Entry>
</Row>
<Row>
<Entry><Literal>ISO_LATIN_1</Literal></Entry>
<Entry><Literal>uninterpreted octet</Literal></Entry>
<Entry><Literal>ISO_LATIN_1</Literal></Entry>
<Entry><Literal>byte</Literal></Entry>
</Row>
<Row>
<Entry><Literal>ISO_MULTI_LINGUAL</Literal></Entry>
<Entry><Literal>(Note 1.)</Literal></Entry>
<Entry><Literal>ISO_MULTI_LINGUAL</Literal></Entry>
<Entry>
<Literal>struct{
    byte row;
    byte column;
}
<?sml-fill></Literal></Entry>
</Row>
<Row>
<Entry><Literal>ISO_UCS</Literal></Entry>
<Entry><Literal>(Note 1.)</Literal></Entry>
<Entry><Literal>ISO_UCS</Literal></Entry>
<Entry>
<Literal>struct{
    byte group; 
    byte plane;
    byte row; 
    byte column;
}
<?sml-fill></Literal></Entry>
</Row>
</TBody>
</TGroup>
</Table>
<?sml-point-size 9>
<!--no-op:  12-->
<?sml-indent +.8i>
<?sml-point-size 12>
<!--no-op:  14-->
<?sml-indent>
<!-- -->
<!-- -->
<!-- -->
<Para>In addition to the IDL primitive type mappings defined in the table,
implementations provide a set of convenient typedefs that map the
listed defined types into types that explicitly name amounts of
storage.  These are defined in IDL as follows:
<!-- -->
<?sml-break><?sml-point-size 11>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing role="page-wide">typedef unsigned small  unsigned8;        /* positive 8-bit integer  */
typedef unsigned short  unsigned16;       /* positive 16-bit integer */
typedef unsigned long   unsigned32;       /* positive 32-bit integer */
typedef small           signed8;          /* signed 8-bit integer    */
typedef short           signed16;         /* signed 16-bit integer   */
typedef long            signed32;         /* signed 32-bit integer   */
typedef unsigned32      boolean32;	  /* a 32-bit boolean        */
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<!--no-op:  14-->
<!-- -->
<Para>They are defined in C as follows:
<!-- -->
<?sml-break><?sml-point-size 11>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing>typedef idl_usmall_int unsigned8;
typedef idl_ushort_int unsigned16;
typedef idl_ulong_int unsigned32;
typedef idl_small_int signed8;
typedef idl_short_int signed16;
typedef idl_long_int signed32;
typedef unsigned32 boolean32;
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<!--no-op:  14-->
<!-- -->
<Para><?sml-need 10>As a matter of programming style, these types have the advantage that
the size of the declared data items is explicitly stated.  For this reason
their use in both IDL declarations and application C code is recommended.
Note also that the following IDL and C typedefs
are also made available by implementations a convenient portable
declaration for status parameters:
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing>typedef unsigned long   error_status_t;

typedef idl_ulong_int error_status_t;
</ProgramListing></Para>
</InformalExample>
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
</Sect2>
<Sect2 Id="ADGISG.DATA.div.9">
<Title>Character Handling</Title>
<!-- - -->
<!-- -->
<Para>When passed as an RPC paramter, the IDL <Literal>char</Literal> type is
automatically subject to ASCII-EBCDIC conversion, depending on the
character encodings used by the client and server machines.
Therefore, the contents of a <Literal>char</Literal> type may not be the same for
the sender and receiver.  This allows clients and servers to maintain
the same semantics when passing characters between machines that use
different encodings.  For example, the character <Literal>a</Literal> is
represented by a byte with the value 61h on an ASCII machine, and a
byte with the value 81h on an EBCDIC machine.  RPC automatically makes
the conversion so that a character parameter that prints as <Literal>a</Literal>
on the client machine also prints as <Literal>a</Literal> when recieved by the
server.
</Para>
<Para>However, if what your application really intends is to pass a byte
with the value 61h from client to server, such translation is clearly
not what you want.  To avoid this potential problem, when passing byte
data with noncharacter semantics, use the IDL <Literal>byte</Literal> type.
</Para>
<Para>Also note that IDL provides three international character types for
use with nonASCII, nonEBCDIC character sets: <Literal>ISO_LATIN_1</Literal>,
<Literal>ISO_MULTI_LINGUAL</Literal>, and <Literal>ISO_UCS</Literal>.  To ensure portability, your
application should use these types to declare character data in one of
these sets.
<IndexTerm Id="ADGISG.DATA.indx.23">
<Primary>character sets</Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.DATA.indx.24">
<Primary><Literal>ISO_LATIN_1</Literal> character set</Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.DATA.indx.25">
<Primary><Literal>ISO_MULTI_LINGUAL</Literal> character set</Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.DATA.indx.26">
<Primary><Literal>ISO_UCS</Literal> character set</Primary>
</IndexTerm>
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.DATA.div.10">
<Title>Pointers</Title>
<!-- - -->
<!-- -->
<Para><IndexTerm Id="ADGISG.DATA.indx.27">
<Primary>RPC</Primary>
<Secondary>pointers</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.DATA.indx.28">
<Primary>pointers</Primary>
<Secondary>RPC</Secondary>
</IndexTerm>RPC pointers differ from local pointers in one key respect: there is
no shared address space between client and server.  This means that
the stubs need to marshall the pointed-to data itself.  To do so, the
stubs must be able to dereference any pointer passed as a parameter.
This means that a pointer, <Replaceable>even if it does not point at useful
data</Replaceable>, must be initialized either to NULL or to a valid address
before it is passed as a parameter.  This behavior may be
counter-intuitive for programmers used to local procedure calls, where
pointers may be freely passed whether they have been initialized or
not, and is a common source of programming grief for remote procedure
calls.
</Para>
<Para>To be able to marshall pointer referents, the stubs need to
know, either at compile time or at runtime, how much data to
transmit; that is, they need to know the size of the pointed to
object.  This can require a good deal of work on the part of the stubs
in the case of varying or conformant arrays and objects like linked
lists.
</Para>
<Para>One effect of this is that pointers only reference the marshalled data
itself; that is, data of the size determined by the stub.  For
example, passing an <Literal>idl_char *</Literal> parameter causes the stub to
marshall a single <Literal>idl_char</Literal>, since that is the size of the object
pointed to by an <Literal>idl_char *</Literal>.  Typically, a local procedure call
passes a <Literal>char *</Literal> type in order to pass the address of an array of
characters, not a single <Literal>char</Literal>; but a remote routine that tries
to move such a pointer beyond the transmitted <Literal>char</Literal> will very
likely find itself pointing to invalid storage and certainly not to
the intended string.
</Para>
<Para>A similar case is illustrated in the sample code: a client passes an
array and an <Literal>[in, out, ptr]</Literal> pointer to an array element.  If the
server sets the pointer to point to some element of the passed array,
then it will point to memory holding a copy of that element when the
call returns to the client.  It will not point to any part of the
passed-in array itself, and any attempt to increment or decrement the
pointer on the client side will leave it pointing to an invalid location.
</Para>
<Para>This is one example of the fact that you cannot assume that the results
of pointer arithmetic will be the same for a local and remote procedure
call.  To give another example, suppose a call passes two parameters:
a data structure and a pointer to the type of the data structure, set
to NULL.  If the server application then sets the pointer to point to
the data structure, the client stub will allocate new storage for the
returned data structure and set the returned pointer to point to it.
As a result, the returned pointer will not point to the original
structure, but to a copy of it in stub maintained memory.
</Para>
<Para>This may seem like an IDL limitation, but in fact, the real issue is
that the client and server address spaces are different, and
some operations in one address space cannot be reflected in the other.
Specifically, the server application cannot meaningfully interpret an
address in the client address space, and vice versa.  So, as in the
last example, the server cannot set a pointer to point to a structure
in the client address space; it can only ask the client stub to mirror
any changes made at the server.
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
</Para>
<Sect3 Id="ADGISG.DATA.div.11">
<Title>Memory Allocation Routines</Title>
<!-- - -->
<!-- -->
<Para>The stubs will do their best to allocate any new memory required for
marshalled pointed-to nodes so that the marshalling is transparent to the
application.  On the server side, stub allocated memory exists for the scope
of the manager routine call.  The stub frees such memory once the nodes have
been marshalled.  On the client side, however, the stubs obviously cannot
free the memory they have marshalled since they are returning the data to
the client application.  Therefore, in order to avoid memory leaks, when a
client makes an RPC that results in the client stub allocating memory, the
client application needs to call <Function>rpc_sm_client_free(&thinsp;)</Function> to free the
pointed-to memory.
<IndexTerm Id="ADGISG.DATA.indx.29">
<Primary>allocating</Primary>
<Secondary>new memory</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.DATA.indx.30">
<Primary>memory</Primary>
<Secondary>allocating new</Secondary>
</IndexTerm></Para>
<Para>When a server manager routine needs to allocate new memory for a
pointed-to node, it can do so either statically or by making a call to
a memory allocation routine.  In the latter case, however, the manager
cannot deallocate the memory it has allocated, since the pointer must
be valid when the call returns (so that the stubs can marshall the
data.)  Only the stub can free such memory.  In order to permit this,
server managers need to call <Function>rpc_sm_allocate(&thinsp;)</Function> to allocate
memory for parameters.  The stubs free all memory allocated by
<Function>rpc_sm_allocate(&thinsp;)</Function> once they have marshalled the required
data, thus avoiding memory leaks.
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
</Para>
</Sect3>
<Sect3 Id="ADGISG.DATA.div.12">
<Title>Pointer Types</Title>
<!-- - -->
<!-- -->
<Para>For reasons of efficiency, IDL distinguishes between reference
<Literal>[ref]</Literal>, full <Literal>[ptr]</Literal>, and unique <Literal>[unique]</Literal> pointers.  As
we saw above, even though pointers are used by applications to pass
data by reference, the lack of shared address space means that the
stubs have to pass the data by value and provide the receiver with a
reference to the passed data.
<IndexTerm Id="ADGISG.DATA.indx.31">
<Primary>reference pointers</Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.DATA.indx.32">
<Primary>unique pointers</Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.DATA.indx.33">
<Primary>pointers</Primary>
<Secondary>reference</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.DATA.indx.34">
<Primary>pointers</Primary>
<Secondary>unique</Secondary>
</IndexTerm></Para>
<Para>In the simplest case, a pointer always points to the same memory:
that is, its value does not change.  In such a case the stubs always
marshall the passed value from and to the same memory location on the
sender and receiver respectively.  This style of marshalling is
provided by <Literal>[ref]</Literal> pointers.
</Para>
<Para>When the value of a pointer changes during a call, the stubs have a
more complex task.  Suppose, for example, an <Literal>[in, out]</Literal> pointer is
NULL before an RPC and is set by the server application to point
to some data structure allocated by the server.  As in the <Literal>[ref]</Literal>
pointer case, the server stub needs to marshall the (new) referent and
the client to unmarshall it, but the client stub also needs to do two
more things: it needs to allocate space for the unmarshalled referent,
and it needs to point the previously NULL pointer to it.  Similarly,
for a pointer that initially points to one memory location and is
changed during an RPC to point to another, the client stub needs to
allocate new memory to hold the unmarshalled value of the new referent
and to change the pointer value accordingly.  Not all of the extra
work is confined to the client stub either.  Obviously, the client
stub needs to find out that the value of the pointer has changed, so
the server has to marshall, and the RPC protocol to transmit, extra
data to indicate this.  This style of marshalling is provided by full
(<Literal>[ptr]</Literal>) pointers, and it obviously requires more overhead than
reference pointer marshalling.
<IndexTerm Id="ADGISG.DATA.indx.35">
<Primary>marshalling pointers</Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.DATA.indx.36">
<Primary>pointers</Primary>
<Secondary>marshalling</Secondary>
</IndexTerm></Para>
<Para>Unique pointers provide for an intermediate case: a pointer that always
points either to a single memory location or is NULL.  Such a
pointer may change from NULL to a nonnull value or from a nonnull
value to NULL, but never has more than one nonnull value.  Such a
pointer is marshalled more efficiently than a full pointer, but not as
efficiently as a reference pointer.
</Para>
<Para>Applications should consider the <Literal>[ref]</Literal> and <Literal>[unique]</Literal>
pointer types as optimizations.  A full <Literal>[ptr]</Literal> pointer can always
be used.  The <Literal>[ref]</Literal> and <Literal>[unique]</Literal> pointer types may be used
whenever the application is guaranteed to meet the restrictive conditions
under which these types work.
</Para>
<Para><?sml-need 8>As a guide to using the pointer types, there are a few general rules
and a number of special cases, having mainly to do with embedded
pointers and data of variable size.  The rules are as follows:
<IndexTerm Id="ADGISG.DATA.indx.37">
<Primary>pointers</Primary>
<Secondary>embedded</Secondary>
</IndexTerm>
<!-- -->
<!-- -->
</Para>
<ItemizedList>
<ListItem>
<Para>In passing parameters, you need to distinguish carefully between
top-level and lower-level pointers.  A top-level pointer is a pointer
passed as an argument to a call.  A lower-level pointer is one
contained in the referent of a top-level pointer.  The directional
semantics <Literal>[out]</Literal> and <Literal>[in, out]</Literal> both require parameters to
be passed by reference and hence always require a top-level pointer.
</Para>
<Para>The model is, essentially, that the client provides a container into
which the returned value is written.  In the <Literal>[out]</Literal> parameter case, the
contents of the container are assumed to be unimportant on input and
are not marshaled by the client stub.  In the <Literal>[in, out]</Literal> case, the
contents are assumed to be meaningful and are passed to the server.
</Para>
<Para>The top-level pointer is thus the address of the parameter container,
and obviously, this value should not change during the course of the
call.  If it did, the return value would be written to some undetermined
place in the client address space.  Hence, the top level of <Literal>[out]</Literal>
and <Literal>[in, out]</Literal> parameters have reference pointer semantics.  The IDL
compiler enforces this for <Literal>[out]</Literal> parameters by permitting only the
<Literal>[ref]</Literal> attribute.  It does not force this for <Literal>[in, out]</Literal>
parameters, but the behavior is exactly the same.  Remember, the actual
parameters of an RPC call are always passed by value: hence a call cannot
change the value of a top-level pointer.  It can only change the value of
something passed by reference.
<!-- -->
</Para>
</ListItem>
<ListItem>
<Para>To pass an <Literal>[in]</Literal> parameter by reference, you can pass its address
as a pointer of either style.  The server stub will allocate and
deallocate the required memory for the pointer referent.  Since an
<Literal>[in]</Literal> pointer has no reason to change its value, it is at least
slightly more efficient to use a reference pointer in this case.
<!-- -->
</Para>
</ListItem>
<ListItem>
<Para>Since <Literal>[out]</Literal> semantics do not consider the contents of such
storage to be meaningful, an <Literal>[out]</Literal> parameter is not marshalled
on the call.  The server stub will allocate memory to hold the
referent as long as the size of the referent is known at compile time.
The stub obviously cannot allocate memory for referents whose size is
determined arbitrarily by the the server application.  For such
parameters (such as linked lists) the server application must allocate
space.  
</Para>
<Para><?sml-need 10>One tricky case to consider is a linked list.  The server stub
allocates space for the head element, since it knows the size of such
an element.  The server manager then allocates space for the remaining
elements and marshalls them back to the client.  The client stub will
allocate all necessary space for the server-created receive parameters.
</Para>
<Para>A server-created structure may contain reference pointers which
the server may then set to point to objects it also allocates.  All of
this will be mirrored by the client stub.  Note that this does not
violate the rules for reference pointers, since the contained pointers
do not change value during the call; they are created by the server
application and passed back to the client exactly the same way that
top-level reference pointers are created by clients and passed to
servers.
</Para>
<Para>When an application wishes to have the callee allocate space for an
<Literal>[out]</Literal> parameter, it needs to use two levels of indirection: a
reference pointer to a full pointer to the data structure to be
allocated.  The client allocates the full pointer, setting it to
NULL, and passes its address to the call.  The server application
then allocates the data structure and sets the full pointer to point to
it.  The client stub will then allocate space for the data structure on
the return.
<!-- -->
</Para>
</ListItem>
<ListItem>
<Para>An <Literal>[in, out]</Literal> reference pointer behaves exactly like the <Literal>[out]</Literal>
reference pointer case, except that the server stub may be able to
allocate space for a referent even if its size is not known at compile
time.  This will be the case when the client application creates an
instance of a variable sized referent, such as a linked list.  In such
a case, the server stub will allocate sufficient space for the referent
supplied by the client.
<!-- -->
</Para>
</ListItem>
<ListItem>
<Para>You must take care when a server deallocates a <Literal>[ptr]</Literal> pointer
referent.  For an <Literal>[in, out]</Literal> parameter, the client-side stub does
not deallocate the client-side referent, but the application should
treat the referent as undefined, as if, in effect, the deallocated
pointer referent had been unmarshalled by the client stub.  By
default, in the case of an <Literal>[in]</Literal> parameter, the value of the
pointer referent remains unchanged on the client side.  However, this
default behavior can be modified by applying the <Literal>[reflect_deletions]</Literal>
attribute to the operation.  In this case, the client-side stub will
deallocate the pointer referent.  The client and server must use the
<Literal>rpc_sm_</Literal><Symbol Role="Variable">*</Symbol> routines to allocate and free memory for this reflection
of deletions to work.
<!-- -->
<!-- [I find this behavior bizzare and-->
<!-- inexplicable, and I can't make it work either.]-->
<!-- -->
<?sml-break><?sml-need 10></Para>
</ListItem>
<ListItem>
<Para>For an <Literal>[in, out]</Literal> parameter which is a <Literal>[ptr]</Literal> pointer, if the
server sets the parameter value to NULL, the client will no longer
be able to dereference the pointer on return.  If the client has no other
means to reference the original pointed-to node, the node is said to
be <Replaceable>orphaned</Replaceable>: the client will be unable to free it.
</Para>
</ListItem>
</ItemizedList>
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
</Sect3>
<Sect3 Id="ADGISG.DATA.div.13">
<Title>Pointer Examples</Title>
<!-- - -->
<!-- -->
<Para>The following sample code demonstrates the basic properties of pointers. The
first example demonstrates pointer arithmetic and how changes in the server
address space can be reflected back to the client using full pointers.  In the
<Filename>.idl</Filename> file we declare a type that is an array of three integers, and a
type that is a pointer to an integer.  The operation takes the array as an
<Literal>[in]</Literal> parameter and the pointer as an <Literal>[in, out]</Literal> parameter.
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing>const unsigned32 ARRAY_SIZE = 3;

typedef unsigned32 num_array[ARRAY_SIZE];
typedef [ptr] unsigned32 *num_ptr;

void ptr_test1(
  [in] handle_t handle,
  [in, out] num_ptr *client_ptr,
  [in ] num_array client_array,
  [out] error_status_t *status
);
</ProgramListing></Para>
</InformalExample>
<!-- -->
<Para><?sml-need 20>The server manager code to implement this points the client pointer to
the beginning of the array and then increments it once:
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing>void 
ptr_test1(
    handle_t h,
    num_ptr *client_ptr,
    num_array client_array,
    error_status_t *status
)
{
    *status = 0;
    *client_ptr = client_array;
    ++(*client_ptr);
}
</ProgramListing></Para>
</InformalExample>
<!-- -->
<Para>On return, the client's version of the pointer will point to memory that
holds the second element of the array.  It will not point to the array itself,
however.  The client code demonstrates this:
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing>num_ptr client_ptr = NULL;
num_array client_array = {25, 50, 75};

ptr_test1(binding_h, &amp;client_ptr, client_array, &amp;status);

/*
 * The test function pointed the client pointer to the
 * second array element.  On return, this points to memory
 * that holds this value.
 */

printf("Client pointer points to %i, *client_ptr);

/* However, if we now increment the pointer, it
 * points to unintialized memory.  This shows the
 * limits of mirroring. 
 * *** WARNING: You may dump core here !! ***
 */

client_ptr++;
printf("Client pointer now points to %i, *client_ptr);
</ProgramListing></Para>
</InformalExample>
<!-- -->
<Para>What happens here is that the client stub allocates space for the
new referent of <Literal>client_ptr</Literal> when the call returns.  This space
now holds the value in the second element of the array.  The
pointer no longer points to the original array but to this newly
allocated space.  You can see this clearly when the client attempts to
increment the pointer.  Instead of pointing to the third element of
the array, it points to some undetermined place in memory, and the
client may fail when it tries to dereference the pointer.
</Para>
<Para>As an exercise, you could change the code to declare a pointer to the
<Literal>num_array</Literal> defined type rather than to an integer.  Then you could
have the server manager point this to the input array and return it
without incrementing the pointer.  The returned pointer will now reference
a copy of the original client array with all its elements.  It will not,
however reference the original array itself.
</Para>
<Para>The second pointer example illustrates passing a linked list. The
<Filename>.idl</Filename> declaration is as follows:
<!-- -->
<?sml-break><?sml-point-size 9>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct link {
  unsigned32 value;
  [ptr] struct link *next; 
} link_t;

void ptr_test2(
  [in] handle_t handle,
  [in, out, ref] link_t *head,
  [out] error_status_t *status
);
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<!--no-op:  14-->
<!-- -->
<Para>The server manager code is as follows:
<!-- -->
<?sml-break><?sml-point-size 9>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing role="page-wide">void 
ptr_test2(
    handle_t handle,
    link_t *head,
    error_status_t *status
)
{
    link_t *element;

    if (head)
    {
        element = head;
        while (element->next)
            element = element->next;

<?sml-break><?sml-need 10>        /* Add another element to the list... */
        element->next = (link_t*) rpc_sm_allocate(sizeof(link_t), status);
        element->next->value = element->value * 2;
        element->next->next = NULL;
    }
    *status = error_status_ok;
};
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<!--no-op:  14-->
<!-- -->
<Para>The manager operation adds a new element to the end of the linked
list.  Note that the <Symbol Role="Variable">head</Symbol> parameter has <Literal>[in, out]</Literal>
semantics here: we must pass in a pointer to a valid element. (The
next example shows how to implement an <Symbol Role="Variable">[out]</Symbol> parameter that is
allocated by the operation.)
</Para>
<Para>In this and the following example, we use <Function>rpc_sm_allocate(&thinsp;)</Function>
to allocate data on the server side.  This gives the semantics you
probably want for a dynamically allocated referent for a pointer
parameter: on return, the data is automatically deallocated on the
server, and further manager operations that access this data do so via
a pointer parameter passed by the client.  Memory leaks on the server
are thus avoided.
</Para>
<Para>An application must be very cautious if it attempts to use pointer
parameters in a way that contradicts such semantics: for example, by
returning a pointer to static global storage on the server.  In such a
case, the server and client versions of such storage can easily become
inconsistent.  A context handle, which the client must not modify, is
typically what you want in such a case.
</Para>
<Para>The client code for the linked list test is as follows:
<!-- -->
<?sml-break><?sml-point-size 9>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing>link_t first, *element;
int i;
first.value = 2;
first.next = NULL; 

for (i = 0; i &lt; 8; i++)
    ptr_test2(binding_h, &amp;first, &amp;status);

element = &amp;first;
while (element->next)
{
    printf("%i, ", element->value);
    element = element->next;
}
printf("%i, element->value);
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<!--no-op:  14-->
<!-- -->
<Para><?sml-need 10>The client passes in the head element, and then calls the server
several times to add more elements to the list.  Finally, the client
prints out the list.
</Para>
<Para>The next pointer example illustrates how the stubs automatically
allocate memory for an <Literal>[out]</Literal> parameter.  The client application
allocates a NULL pointer to the data structure of interest and passes
the address of this pointer as the <Literal>[out]</Literal> parameter.  The server
manager allocates a structure, and on return the client stub allocates
it too, automatically.
</Para>
<Para>The <Filename>.idl</Filename> declaration is as follows:
<!-- -->
<?sml-break><?sml-point-size 11>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct {
    [ref] unsigned32 *value;
} number;

typedef [ptr] number *number_ptr;

void ptr_test3(
    [in] handle_t handle,
    [out, ref]  number_ptr *client_ptr,
    [out] error_status_t *status 
);
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<!--no-op:  14-->
<!-- -->
<Para>The server manager operation is then as follows:
<!-- -->
<?sml-break><?sml-point-size 11>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing role="page-wide">void 
ptr_test3(
    handle_t handle,
    number_ptr *client_ptr,
    error_status_t *status 
)
{
    number_ptr nptr;
    unsigned32 *nval;
    nptr = (number_ptr) rpc_sm_allocate(sizeof(number), status);
    nval = (unsigned32 *) rpc_sm_allocate(sizeof(unsigned32), status);
    *nval = 256;
    nptr->value = nval;
    *client_ptr = nptr;
    *status = error_status_ok;
};
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<!--no-op:  14-->
<!-- -->
<Para><?sml-need 15>The client test code looks like this:
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing>number_ptr client_ptr = NULL;

ptr_test3(binding_h, &amp;client_ptr, &amp;status);
printf("Value = %i, (unsigned32)* (client_ptr->value));
</ProgramListing></Para>
</InformalExample>
<!-- -->
<Para>Note the use of <Literal>[ref]</Literal> pointers here. The top-level <Literal>[ref]</Literal>
pointer (the one passed as a parameter to the call) must point to valid
storage when the call is made even though the pointer is not
marshalled when the call is made.  This follows the rules for <Literal>[ref]</Literal>
pointers: they may not be NULL and may not change value during a
call.  The returned structure also contains a <Literal>[ref]</Literal>
pointer, and the client stub does automatically allocate space for its
referent when the call returns.  This is an exception to the rule that
an <Literal>[out]</Literal> <Literal>[ref]</Literal> pointer must point to valid storage when
the call is made.  In this case, the pointer is embedded in a
structure which is created by the server.  As long as the top-level
pointer points to valid storage (to hold the returned structure), the
client stub will allocate space for the referents of any newly-created
<Literal>[ref]</Literal> pointers that it contains.
</Para>
<Para>The final example illustrates node deletion. The <Filename>.idl</Filename> declaration is
as follows:
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing>[reflect_deletions] void ptr_test4(  
                    [in] handle_t handle,
                    [in, out, ptr] unsigned32 *number,
                    [out] error_status_t *status);
</ProgramListing></Para>
</InformalExample>
<!-- -->
<Para>The server code to implement this operation frees the memory pointed
to by the input pointer and returns the pointer:
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing>void
ptr_test4(
     handle_t h,
     unsigned32 *number,
     error_status_t *status
)
{
     *number = 32;
     rpc_sm_free(number, status);
     *status = error_status_ok;
};
</ProgramListing></Para>
</InformalExample>
<!-- -->
<Para>The client code is as follows:
<!-- -->
<?sml-break><?sml-point-size 11>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing>unsigned32 *num;

rpc_sm_enable_allocate(&amp;status);
num = (unsigned32*) rpc_sm_allocate(sizeof(unsigned32), &amp;status);
*num = 64;
ptr_test4(binding_h, num, &amp;status);
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<!--no-op:  14-->
<!-- -->
<!-- .P-->
<!-- [The last example still does not work.  When it does, it needs some-->
<!-- client code that attempts (all you can really do is attempt) to show-->
<!-- that the pointed to memory was deallocated.]-->
<!-- -->
<Para>There are so many ways to use (and misuse) IDL pointers that it would
be impossible to give a complete set of examples. 
The section on arrays contains more pointer examples.
<!-- -->
<!-- For an extensive pointer-->
<!-- example using pointers and structures to manipulate a tree, see-->
<!-- Chapter 17, Section 17.14.7.11 [better check this !!] of the \*LDCE-->
<!-- Application Development Guide\*O.-->
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
</Para>
</Sect3>
</Sect2>
<Sect2 Id="ADGISG.DATA.div.14">
<Title>Context Handles</Title>
<!-- - -->
<!-- -->
<Para><IndexTerm Id="ADGISG.DATA.indx.38">
<Primary>context handles</Primary>
</IndexTerm>Context handle semantics vary according to the application role. On the
server side, the semantics are those of a full pointer.  To the client
application, a context handle has similar semantics to a fully bound
server binding handle, except that the client may not perform any
operations to modify it.  To the client it represents a binding to context
maintained by a specific a server instance.  Because the context handle
may also specify an object UUID, it may also bind to a specific type
manager in the server instance; that is, a context handle refers to
context maintained by a specific type manager in a specific server
instance.  It is valid over a series of calls within this scope.  To
enforce this, a context handle is intended to be passed as an explicit
binding parameter for each operation that refers to the maintained
context.  Any attempt to use a context handle outside this scope will fail.
Context handles are described in more detail in 
the &DCEDk;.
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
<?sml-break><?sml-need 2.5i></Para>
</Sect2>
<Sect2 Id="ADGISG.DATA.div.15">
<Title>Arrays</Title>
<!-- - -->
<!-- -->
<Para><IndexTerm Id="ADGISG.DATA.indx.39">
<Primary>arrays</Primary>
</IndexTerm>Array parameters provide an efficient way to pass contiguous blocks of
data with little application overhead.  The stubs take care of
serializing and reassembling the passed data transparently to the
application.  When an application is interested in passing an entire buffer
or some contiguous portion of a buffer synchronously&mdash;so that all of
the data is made available to the receiver at the same time&mdash;arrays
provide the most efficient mechanism.  Pipes provide no advantage
unless the data is to be processed asynchronously.
</Para>
<Para>Arrays may be passed as RPC parameters, but, as in the case of other
RPC data, the stubs need to know the size of data to be marshalled.
The simple solution is to declare arrays of fixed size in the IDL.
This can be inefficient however, since array sizes may vary at
runtime, and since not all data in an array may need to be passed on
every call.  Therefore, IDL provides a variety of field attributes
(<Literal>max_is</Literal>, <Literal>min_is</Literal>, <Literal>size_is</Literal>, <Literal>last_is</Literal>,
<Literal>first_is</Literal>, and <Literal>length_is</Literal>) to permit the size and bounds of
the marshalled data to be determined at runtime.  Note that passing a
pointer to an array is not any more efficient as a way to deal with
the problem of varying array sizes.  Remember that marshalling a
pointer requires marshalling the pointer's referent, so the array data
will be marshalled anyway.  Note also that the IDL language does not
permit declaring a pointer to a varying array.
<IndexTerm Id="ADGISG.DATA.indx.40">
<Primary>marshalling pointers</Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.DATA.indx.41">
<Primary>pointers</Primary>
<Secondary>marshalling</Secondary>
</IndexTerm></Para>
<Para>The size of the array data marshalled is determined in one of two
ways.  In a <FirstTerm>conformant array</FirstTerm>, the size of the array is not
declared in the IDL declaration, and one of the <Literal>max_is</Literal> or
<Literal>size_is</Literal> attributes is used to determine the size of the
marshalled data at runtime.  In a <FirstTerm>varying array</FirstTerm>, the size of the
array is declared in the <Filename>.idl</Filename> file, but one or more of the other
field attributes determines what range of elements is actually marshalled.
Arrays may be both conformant and varying at the same time.
</Para>
<Para>Each field attribute is associated with some variable whose value is
known at runtime.  The scope of this association is within either an
operation declaration or a structure declaration.  That is, when the
array is a parameter of an operation, the field attribute variables
must also be parameters of the same operation.  Similarly, when the
array is a member of a structure, the field attribute variables must
be members of the same structure.
</Para>
<Para>The following samples show a series of array declarations using some
of the many possible forms:
<!-- -->
<?sml-break><?sml-need 10><?sml-point-size 9>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing role="page-wide">/* An array of fixed size */

typedef char char5array[5];
typedef char5array *char5ptr;

void array_test1(
    [in] handle_t handle,
    [in] char5ptr a_pointer,
    [out] error_status_t *status); 

/* A conformant array: the size is determined at runtime */

void array_test2(
    [in] handle_t handle,
    [in] unsigned32 size,
    [in, size_is(size)] char an_array[],
    [out] error_status_t *status); 

/*
 * A varying array: the portion of the array transmitted is
 * determined at runtime
 */

typedef struct{
    unsigned32 first;
    unsigned32 length;
    [first_is(first), length_is(length)] char array[0..10];
}v_struct;

void array_test3(
    [in] handle_t handle,
    [in] v_struct v_array,
    [out] error_status_t *status); 

/*
 * A conformant and varying array: both size and the portion
 * transmitted are determined at runtime
 */

typedef struct{
    unsigned32 size;
    unsigned32 first;
    unsigned32 length;
    [size_is(size), first_is(first), length_is(length)] char array[0..*];
}cv_struct;

void array_test4(
    [in] handle_t handle,
    [in] cv_struct *cv_array,
    [out] error_status_t *status); 

</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<!--no-op:  14-->
<!-- -->
<Para><?sml-need 10>The examples show clearly how field attribute variables are related to
array declarations.
</Para>
<Para>In the second operation declaration, a conformant array is declared as
an operation parameter (<Symbol Role="Variable">an_array</Symbol>), so that the field attribute
variable (<Symbol Role="Variable">size</Symbol>) must also be a parameter of the interface.  In
the third and fourth operations, varying and conformant-varying
arrays are declared within structures, so that the field attribute
variables (<Symbol Role="Variable">size</Symbol>, <Symbol Role="Variable">first</Symbol>, and <Symbol Role="Variable">length</Symbol>) must also be
members of the same structures.
</Para>
<Para>The server manager sample code to test these declarations is as
follows:
<!-- -->
<!-- -->
<?sml-break><?sml-point-size 9>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing role="page-wide">void array_test1(
    handle_t handle,
    char5ptr a_pointer,
    error_status_t *status 
)
{
    printf("Array test 1);
    printf("%c %c , (*a_pointer)[0],(*a_pointer)[1]);
    *status = error_status_ok;
};

void array_test2(
    handle_t handle,
    unsigned32 size,
    idl_char an_array[],
    error_status_t *status
)
{
    unsigned32 i;

    printf("Array test 2);
    for ( i = 0; i &lt; size; i++)
    {
        printf("%c ",an_array[i]);
        printf(");
    }
    *status = error_status_ok;
}

void array_test3(
    handle_t handle,
    v_struct v_array,
    error_status_t *status
)
{
    unsigned32 i;

    printf("Array test 3);
    for ( i = v_array.first; i &lt; v_array.first + v_array.length; i++)
        printf("subscript %i value %c, i, v_array.array[i]);
    *status = error_status_ok;
}

void array_test4(
    handle_t handle,
    cv_struct *cv_array,
    error_status_t *status
)
{
    unsigned32 i;

    printf("Array test 4);
    for (i = (*cv_array).first; i &lt; (*cv_array).first + (*cv_array).length; i++)
        printf("subscript %i value %c, i, (*cv_array).array[i]);
    *status = error_status_ok;
}
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<!--no-op:  14-->
<!-- -->
<Para>The client sample code is as follows:
<!-- -->
<?sml-break><?sml-point-size 9>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing role="page-wide">char5array fixed_array = {'a','b','c','d','e'};

v_struct varying_array = {3,4,{'a','b','c','d','e','f','g','h','i','j'}};

struct {
    unsigned32 size;
    unsigned32 first;
    unsigned32 length;
    char array[10];
}cv_array = {10, 4, 5, {'a','b','c','d','e','f','g','h','i','j'}};

array_test1(binding_h, &amp;fixed_array, &amp;status);

array_test2(binding_h, 5, fixed_array, &amp;status);

array_test3(binding_h, varying_array, &amp;status);

array_test4(binding_h, &amp;cv_array, &amp;status);
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<!--no-op:  14-->
<!-- -->
<Para><?sml-need 15>The server output will look like this:
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing>Array test 1
a b 
Array test 2
a 
b 
c 
d 
e 
Array test 3
subscript 3 value d
subscript 4 value e
subscript 5 value f
subscript 6 value g
Array test 4
subscript 4 value e
subscript 5 value f
subscript 6 value g
subscript 7 value h
subscript 8 value i
</ProgramListing></Para>
</InformalExample>
<!-- -->
<Para>Note that for the last test, the declared structure contains a conformant
and varying array.  The C language does not provide any intrinsic
support for conformant arrays, and the actual IDL-generated header
declaration for the type <Literal>cv_struct</Literal> looks as follows:
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct  {
    unsigned32 size;
    unsigned32 first;
    unsigned32 length;
    idl_char array[1];
} cv_struct;
</ProgramListing></Para>
</InformalExample>
<!-- -->
<Para><?sml-need 10>The declared structure contains an array only one element in length.
When creating an instance of this type, the application must allocate
a data structure of the correct size, either statically, as in the
sample client code (the data item <Symbol Role="Variable">cv_array</Symbol>), or dynamically.
The recipient of such a data structure (in this case, the server
manager code), can then determine the actual size of the marshalled
data by examining relevant field attribute variables (in this case,
the structure's <Symbol Role="Variable">size</Symbol> member).  Note also that IDL requires a
structure containing a conformant array to be passed by reference;
that is, as a pointer referent.
</Para>
<Para>Conformant and varying arrays provide a way to pass blocks of
contiguous data of varying sizes and ranges.  However, there is no
intrinsic mechanism for passing sparse arrays efficiently.
Applications may, however, supply their own mechanisms for compressing
and passing large, sparse arrays using the <Literal>[transmit_as]</Literal>
mechanism.
<!-- -->
<!-- An example is shown in  Section XXXXX.XXX.-->
<!-- -->
</Para>
<Para>There are a number of complications that can arise when using arrays
of pointers.  For example, an <Literal>[out]</Literal> or <Literal>[in, out]</Literal> conformant
array of pointers, accompanied by an <Literal>[out]</Literal> or <Literal>[in, out]</Literal>
field attribute variable, could potentially be of any size when
returned to a caller.  For <Literal>[ref]</Literal> pointers, which may not be
NULL, the client must therefore ensure that all possible returned
pointers in such an array actually point to valid storage.  You can easily
avoid such complications by sticking to the more straightforward array
usages discussed here.  However, if you find your application needs to
use arrays in some more esoteric way, you should refer to the <CiteTitle>AES/DC -
RPC Volume</CiteTitle>, Chapter 4, which contains a complete set of array and
pointer usage rules.
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.DATA.div.16">
<Title>Structures and Unions</Title>
<!-- - -->
<!-- -->
<Para>There are no important policy issues relating to structures and unions
as RPC parameters.  Pointers and arrays as members of structures and
unions are sometimes treated differently from separately declared
types.  By embedding pointers and arrays in structures and unions, you
can sometimes achieve behavior that cannot be obtained by passing them
as separate parameters.
<!-- -->
<!-- See Sections XXXX [Arrays] and XXXX [Pointers] for examples.-->
</Para>
<Para><?sml-need 10>
<IndexTerm Id="ADGISG.DATA.indx.42">
<Primary>structures</Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.DATA.indx.43">
<Primary>unions</Primary>
</IndexTerm>Structures and unions can be used wherever they would be used in a non-RPC
application.  IDL structures differ from C language structures in one
important respect: they may contain conformant arrays, which are not
supported by C.  A structure that contains a conformant array is
itself conformant; that is, the size of the structure may not be
determined until runtime.  Applications need to do some extra work to
determine the size of, and allocate, conformant structures.
<!-- -->
<!-- An example is given in Section XXXX [Arrays]. As is shown in Section XXXX-->
<!-- [Pointers],-->
<!-- -->
When structures are used to create linked lists and trees,
the stubs do considerable work to insure that server allocated data is
reflected back to the client.
</Para>
<Para>IDL union syntax is quite different from C syntax, since IDL unions
must be <Replaceable>discriminated</Replaceable> so that stubs can determine which of the
contained data types to marshal.  As with conformant and varying
arrays, which use a field attribute variable to determine array size
and bounds at runtime, IDL unions use a <Replaceable>discriminator</Replaceable> variable
to determine which data type is marshalled.
</Para>
<Para>IDL unions may be <Replaceable>encapsulated</Replaceable> or <Replaceable>non-encapsulated</Replaceable>. In an
encapsulated union, the IDL compiler packages the union type and the
discriminator in a structure.  In a nonencapsulated union, the IDL
switch_is] attribute is used to identify a discriminator variable.
In this case, as in the case of array field attribute variables, the
application must declare the discriminator and the union together,
either as members of a structure or as parameters of an operation.
<IndexTerm Id="ADGISG.DATA.indx.44">
<Primary>IDL</Primary>
<Secondary>unions</Secondary>
</IndexTerm></Para>
<Para>When a union is passed as a parameter, the value of the discriminator
must either match one of the constants declared in the <Literal>switch</Literal>
construct, or the switch must contain a <Literal>default</Literal> case.  Otherwise,
a stub marshalling error will occur.
</Para>
<Para>Following are several examples of IDL union syntax. They are
accompanied by the resulting IDL generated C header file declarations,
and show how applications must refer to the union constructs declared
in the IDL.  The first example shows a set of declarations for an
encapsulated union.  The union holds either of two structures, one
containing UUIDs, the other unsigned integers.
<!-- -->
<?sml-break><?sml-need 20></Para>
<InformalExample>
<Para><ProgramListing>typedef struct two_uuid_s_t {
    uuid_t          uuid1;
    uuid_t          uuid2;
} two_uuid_t;

typedef struct two_uint_s_t {
    unsigned32      uint1;
    unsigned32      uint2;
} two_uint_t;

typedef enum {
    uuids,
    uints
} union_contents;

typedef union switch (union_contents type){
    case uuids:
        two_uint_t  integers;
    case uints:
        two_uuid_t  ids;
} test_union_t;
</ProgramListing></Para>
</InformalExample>
<!-- -->
<Para>The resulting IDL generated C header declarations look like as follows:
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct two_uuid_s_t{
    uuid_t uuid1;
    uuid_t uuid2;
}two_uuid_t;

typedef struct two_uint_s_t{
    unsigned32 uint1;
    unsigned32 uint2;
}two_uint_t;

typedef enum{
    uuids,	
    uints
}union_contents;

<?sml-break><?sml-need 10>typedef struct{
    union_contents type;
    union {
        /* case(s): 0 */
        two_uint_t integers;
        /* case(s): 1 */
        two_uuid_t ids;
    } tagged_union;
}test_union_t;
</ProgramListing></Para>
</InformalExample>
<!-- -->
<Para>The IDL compiler packages the encapsulated union as a structure with
the discriminant as the first member.  To pass the union as an
<Literal>[in]</Literal> or <Literal>[in, out]</Literal> parameter, the calling application must set the
<Symbol Role="Variable">type</Symbol> field of this structure to either of the enumeration values
<Literal>integers</Literal> or <Literal>ids</Literal>.  To return the union as an <Literal>[out]</Literal> or
<Literal>[in, out]</Literal> parameter, the callee must similarly be sure that the
value of the <Symbol Role="Variable">type</Symbol> field is correctly set.  To discover which
data type was marshalled, the recipient can check the value of the
<Symbol Role="Variable">type</Symbol> field.
</Para>
<Para>The following is an example of non-encapsulated union usage. The <Filename>.idl</Filename>
declaration is as follows:
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing>typedef
    [switch_type(long)] union {
       [case (1,3)] float a_float;
       [case (2)] short b_short;
       [default]; /* An empty arm */
    } n_e_union_t;
</ProgramListing></Para>
</InformalExample>
<Para>The C header declaration of the non-encapsulated union generated by
the IDL compiler is as follows:
<!-- -->
</Para>
<InformalExample>
<Para><ProgramListing>typedef
    union {
        float a_float;
        short b_short;
    } n_e_union_t;
</ProgramListing></Para>
</InformalExample>
<!-- -->
<Para>In this case, the discriminant must be separately declared in order
for the union to be marshalled.  The IDL <Literal>[switch_is]</Literal> attribute
identifies the discriminant for an instance of the declared union
type.  Two examples of such <Filename>.idl</Filename> declarations follow:
<!-- -->
<?sml-break><?sml-point-size 11>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing>/*
 * A structure that includes the union declared above and a member
 * that is used as the discriminant.  This structure can be passed
 * as an RPC parameter.
 */

typedef
    struct {
       long a;               
       [switch_is(a)] n_e_union_t b;
    } a_struct;

/*
 * An operation declaration that passes the declared union type
 * along with a discriminant.
 */

void op1 (
    [in] handle_t h,
    [in, switch_is (s)] n_e_union_t u,
    [in] long s
);
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<!--no-op:  14-->
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
</Sect2>
<Sect2 Id="ADGISG.DATA.div.17">
<Title>Pipes</Title>
<!-- - -->
<!-- -->
<Para><IndexTerm Id="ADGISG.DATA.indx.45">
<Primary>pipes</Primary>
</IndexTerm>Pipes allow <Replaceable>application-level optimization</Replaceable> of bulk data transfer, by
allowing the communication and processing of data to overlap.  The actual data
communications occur at about the same speed as arrays.  However, pipes can
reduce latency (how soon the application sees each ``chunk'' of data) and
memory utilization.  The intent is that the pipe routines should actually
process the data and then get rid of it (for example, summarize it; write
it to a file; pass it to another thread) rather than merely write it into
an array.  If an application desires to pass all of a stream of data and
process it synchronously, then an array will probably be more efficient,
since it entails considerably less processing overhead, as well as being
simpler to program.
For more on pipes as a topic in RPC application development, see
the &DCEDk;.
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.DATA.div.18">
<Title>The transmit_as Attribute</Title>
<!-- - -->
<!-- -->
<Para>The <Literal>[transmit_as]</Literal> attribute provides applications a way to
do their own marshalling of data types.  This is primarily useful
as a way to deal with data structures that the stubs cannot marshall
efficiently, such as sparse arrays.  Following is an example of code
to compress and reconstruct a large array by removing and then
replacing all the zero-valued elements:
</Para>
<Para>The <Filename>.idl</Filename> declarations are as follows:
<!-- -->
<?sml-break><?sml-point-size 9>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing role="page-wide">/*
 * Transmit_as example: Here we turn a large sparse array into
 * a small conformant array for transmission.  The server is able
 * to reconstitute the sparse array.
 */

const long int S_ARRAY_SIZE = 32;

typedef struct{
    unsigned32 value;
    unsigned32 subscript;	
} a_element;

typedef struct{
    unsigned32 size;
    [size_is(size)] a_element array[];
}compact_array_t;

typedef [transmit_as(compact_array_t)] unsigned32 sparse_array_t[S_ARRAY_SIZE];
 
void ship_array(
    [in] handle_t handle,
    [in] sparse_array_t *array,
    [out] error_status_t *status
);
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<!--no-op:  14-->
<!-- -->
<Para>All the callback routines are placed in a single module that is linked
with both client and server (in this case, for the <Literal>test</Literal> interface).
As an alternative, the appropriate callbacks could be declared
separately within the client and server modules:
<!-- -->
<?sml-break><?sml-need 20><?sml-point-size 9>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing role="page-wide">/*
 * test_xmit.c:  
 *
 * The routines required to implement a [transmit_as] type.
 */

#include "test.h"

/* The to_xmit routine must allocate all space for the transmitted
 * type.  In general, the stubs have no way to determine how to allocate
 * space for the transmitted type.  Here, for example, the to_xmit
 * routine determines the size of a conformant array.
 */

void sparse_array_t_to_xmit(sparse_array_t *s_array,
                            compact_array_t **c_array
)
{
    unsigned32 i,j;
    unsigned32 csize;

    /* Count up the number of nonzero elements in the sparse array */

    for (i = 0, csize = 0; i &lt; S_ARRAY_SIZE; i++)
    {
        if ((*s_array)[i] != 0)
        {
            csize++;
        }
    }

    /* Allocate a structure to hold the compact array */

    *c_array = (compact_array_t *)calloc(csize*2 + 1, sizeof(unsigned32));
    ((compact_array_t)**c_array).size = csize;

    /* Fill in the compact array from the nonzero elements */

    for (i = 0, j = 0; i &lt; S_ARRAY_SIZE; i++)
    {
        if ((*s_array)[i] != 0)
        {
            ((compact_array_t)**c_array).array[j].value = (*s_array)[i]; 
            ((compact_array_t)**c_array).array[j++].subscript = i; 
        }
    }
}

<?sml-break><?sml-need 10>/*
 * The from_xmit routine may not have to allocate any space for the
 * presented type.  The presented type is always of a definite size
 * (conformant, varying, etc. types are not permitted), so the stub
 * provides an instance of the top level of the presented type.  In 
 * this case, for example, s_array points to an instance of a sparse
 * array.  If the presented type contains any pointers, the from_xmit
 * routine needs to allocate space for the referents and the free_inst
 * routine needs to free them.
 */

void sparse_array_t_from_xmit(compact_array_t *c_array,
                              sparse_array_t *s_array)
{
    unsigned32 i,j;
    for (i = 0; i &lt; ((compact_array_t) * c_array).size; i++)
    {
        j = ((compact_array_t)*c_array).array[i].subscript;
        (*s_array)[j] = ((compact_array_t)*c_array).array[i].value;
    }
}

/* This routine is called to free anything allocated by the 
 * to_xmit routine.
 */

void sparse_array_t_free_xmit(compact_array_t *c_array)
{
    free(c_array);
}

/* This routine is called to free anything allocated by the 
 * from_xmit routine.  Since from_xmit doesn't allocate anything
 * this is a null routine.
 */

void sparse_array_t_free_inst(sparse_array_t *s_array)
{
  
}
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<!--no-op:  14-->
<!-- -->
<Para><?sml-need 15>The client code to excercise the sparse array transmitted
type is as follows:
<!-- -->
<?sml-break><?sml-point-size 11>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing>sparse_array_t test_array;

/* Create a sparse array with only three nonzero members */

memset(test_array,0,sizeof(unsigned32)*S_ARRAY_SIZE);
test_array[0] = 2;
test_array[20] = 4;
test_array[31] = 8;

/*
 * When compressed, this array requires 7 32-bit integers, as opposed
 * 32 32-bit integers for the uncompressed array.  If you don't care
 * about reconstructing the sparse array on the server side, you can
 * get even more efficiency.
 */

ship_array(binding_h, &amp;test_array, &amp;status);
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<!--no-op:  14-->
<!-- -->
<Para>The server manager code is as follows:
<!-- -->
<?sml-break><?sml-point-size 11>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing>void ship_array(
    handle_t binding_h,
    sparse_array_t *array,
    error_status_t *status
)
{
    int i;

    /* 
     * Print the elements of the sparse array. 
     */

    for (i = 0; i &lt; S_ARRAY_SIZE; i++)
    {
        printf("%i, (*array)[i]);
    }
    *status = error_status_ok;
}
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<!--no-op:  14-->
<!-- -->
<Para><?sml-need 10>Note that the <Literal>free_inst</Literal> routine will not be needed if the
transmitted type does not contain pointers.  However, the routine is
called by the stub automatically in any case, so at least a null
routine must be provided.  As an exercise, you might add <Function>printf(&thinsp;)</Function>s
to each callback to see when it is called.  You could also add code to
show the format of the transmitted array before it is reconstructed by
the <Literal>from_xmit</Literal> routine.  Finally, you can create an even more
efficient compression by not attempting to reconstruct the original array
on the server side.
</Para>
</Sect2>
</Sect1>
</Chapter>
<!--+ 11/13/96 22:48:26
    | tagMorph:  $Id: data.sgm,v 1.1.2.5 1996/11/25 18:18:48 carrig Exp $
    | tagMorph library:  $Id: data.sgm,v 1.1.2.5 1996/11/25 18:18:48 carrig Exp $
    | sml-to-docbook:  1.24
    +-->
