<!--
# @OSF_COPYRIGHT@
# 
# 
# HISTORY
# $Log: intro.sgm,v $
# Revision 1.1.2.6  1996/11/25  18:18:53  carrig
# 	{enh,R1.2.2}
# 	VarListEntry, Figure, Table, Code Examples
# 	[1996/11/25  18:18:08  carrig]
#
# Revision 1.1.2.5  1996/11/23  23:02:59  weir
# 	Removed thinsp entities in parenthesized index entries
# 	[1996/11/23  23:02:00  weir]
# 
# Revision 1.1.2.4  1996/11/21  18:06:49  weir
# 	Shortened some source lines
# 	[1996/11/21  18:05:54  weir]
# 
# Revision 1.1.2.3  1996/11/21  16:52:35  weir
# 	Corrected entity declarations, etc.
# 	[1996/11/21  16:51:43  weir]
# 
# Revision 1.1.2.2  1996/11/20  22:28:00  weir
# 	Added entity declarations
# 	[1996/11/20  22:27:19  weir]
# 
# Revision 1.1.2.1  1996/11/20  21:56:11  weir
# 	Initial submission
# 	[1996/11/20  21:55:13  weir]
# 
# $EndLog$
-->
<!-- Fragment document type declaration subset:
ArborText, Inc., 1988-1993, v.4001
<!DOCTYPE Book PUBLIC "-//Davenport//DTD DocBook V2.4//EN" [
<!ENTITY  ADGISG.INTRO.pic.1  SYSTEM "eps/intro_01.eps" NDATA EPS>
]>
-->
<!-- COPYRIGHT NOTICE-->
<!-- Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.-->
<!-- ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for-->
<!-- the full copyright text.-->
<!-- -->
<!-- -->
<!-- OLD HISTORY-->
<!-- Revision 1.1.4.1  1996/03/21  17:06:30  wardr-->
<!-- 	{edit R1.2.1}-->
<!-- 	Release Edits-->
<!-- 	[1996/03/21  17:05:40  wardr]-->
<!---->
<!-- Revision 1.1.2.27  1995/06/27  17:04:11  buckler-->
<!-- 	1.1 edits and Prentice Hall reformat-->
<!-- 	[1995/06/27  17:02:48  buckler]-->
<!-- -->
<!-- 	More 1.1 edits.-->
<!-- 	[1995/06/23  13:35:02  buckler]-->
<!-- -->
<!-- Revision 1.1.2.26  1995/06/19  13:16:48  rcb-->
<!-- 	edited 1.1 version, PRENTICE HALL reformat-->
<!-- 	[1995/06/19  13:15:57  rcb]-->
<!-- -->
<!-- Revision 1.1.2.25  1994/11/15  20:47:59  neilson-->
<!-- 	Converted book title references to macro form.-->
<!-- 	[1994/11/15  18:58:05  neilson]-->
<!-- -->
<!-- Revision 1.1.2.24  1994/11/15  16:22:47  weir-->
<!-- 	Indexing added-->
<!-- 	[1994/11/15  16:22:04  weir]-->
<!-- -->
<!-- Revision 1.1.2.23  1994/10/25  14:10:53  jshirley-->
<!-- 	{def,9830,R1.1} Added dced documentation (dce_server API).-->
<!-- 	[1994/10/25  14:10:30  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.22  1994/10/21  16:53:17  weir-->
<!-- 	Still more cross-references-->
<!-- 	[1994/10/21  16:52:53  weir]-->
<!-- -->
<!-- Revision 1.1.2.21  1994/10/20  20:56:19  weir-->
<!-- 	Fixed a few typos-->
<!-- 	[1994/10/20  20:55:50  weir]-->
<!-- -->
<!-- Revision 1.1.2.20  1994/10/20  20:18:09  weir-->
<!-- 	Corrected some cross-references-->
<!-- 	[1994/10/20  20:17:30  weir]-->
<!-- -->
<!-- Revision 1.1.2.19  1994/10/19  22:47:40  jshirley-->
<!-- 	Fixed dce_server_register_data_t in Register the Server section-->
<!-- 	[1994/10/19  22:47:17  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.18  1994/10/19  20:48:14  weir-->
<!-- 	Review comments-->
<!-- 	[1994/10/19  20:47:22  weir]-->
<!-- -->
<!-- Revision 1.1.2.17  1994/10/19  16:02:48  weir-->
<!-- 	Review comments and edits-->
<!-- 	[1994/10/19  16:02:01  weir]-->
<!-- -->
<!-- Revision 1.1.2.16  1994/09/30  17:05:51  zahn-->
<!-- 	Made final updates to IDL sections in-->
<!-- 	this chapter per discussion with J.  Shirley.-->
<!-- 	[1994/09/30  17:05:36  zahn]-->
<!-- -->
<!-- Revision 1.1.2.15  1994/09/28  20:58:08  weir-->
<!-- 	Updates-->
<!-- 	[1994/09/28  20:57:30  weir]-->
<!-- -->
<!-- Revision 1.1.2.14  1994/09/28  20:21:06  neilson-->
<!-- 	CR 10129 - additional material, finished.-->
<!-- 	[1994/09/28  20:20:26  neilson]-->
<!-- -->
<!-- Revision 1.1.2.13  1994/09/28  15:10:35  weir-->
<!-- 	Updates to first sections-->
<!-- 	[1994/09/28  15:09:58  weir]-->
<!-- -->
<!-- Revision 1.1.2.12  1994/09/27  19:01:12  neilson-->
<!-- 	CR 10129 - additional material.  Not completed yet.-->
<!-- 	[1994/09/27  19:00:33  neilson]-->
<!-- -->
<!-- Revision 1.1.2.11  1994/09/26  13:00:38  jshirley-->
<!-- 	Made updates to the Server DCE Host Daemon section and the-->
<!-- 	Server Initialization section with respect to dced and its API.-->
<!-- 	[1994/09/26  12:59:26  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.10  1994/09/23  22:07:09  neilson-->
<!-- 	CR 10129 - additional material.  Not completed yet.-->
<!-- 	[1994/09/23  22:06:33  neilson]-->
<!-- -->
<!-- Revision 1.1.2.9  1994/09/20  17:43:32  zahn-->
<!-- 	Added missing "end comment" command.-->
<!-- 	[1994/09/20  17:43:17  zahn]-->
<!-- -->
<!-- Revision 1.1.2.8  1994/09/19  15:26:06  zahn-->
<!-- 	Added information about interface definition-->
<!-- 	development steps from app_gd/intro/CHAP1/*-->
<!-- 	as planned.-->
<!-- -->
<!-- 	Revised sections on UUID generator and IDL, IDL-->
<!-- 	compiler copied to this file from app_gd/rpc/2_components.gpsml-->
<!-- 	(old file name) to conform to IDL info from old chapter 1.-->
<!-- 	Moved sections around to improve flow and for better-->
<!-- 	organization and presentation of concepts.  Removed references-->
<!-- 	to timop and some obsolete features in IDL sections.-->
<!-- 	Removed references to old steps (A5/Section xxx).-->
<!-- 	Commented out old calendar example.  Commented out-->
<!-- 	2 sections that I think should be moved to RPC-->
<!-- 	section of app_gd and made notes in the source-->
<!-- 	about this.-->
<!-- 	[1994/09/19  15:25:46  zahn]-->
<!-- -->
<!-- Revision 1.1.2.7  1994/08/16  18:26:19  jshirley-->
<!-- 	Changed section on DCE Host Daemon.  Removed extra '>'s and fixed-->
<!-- 	book reference from *(Ac to \*(Ac.-->
<!-- 	[1994/08/16  18:25:58  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.6  1994/08/15  19:06:24  neilson-->
<!-- 	Added DCE Host Daemon material for jshirley.-->
<!-- 	[1994/08/15  18:27:38  neilson]-->
<!-- -->
<!-- 	Added sections from app_gd/intro/CHAP1, per plan.-->
<!-- 	[1994/08/15  18:12:43  neilson]-->
<!-- -->
<!-- Revision 1.1.2.5  1994/08/12  19:23:22  jshirley-->
<!-- 	Updated Servier Initialization sections.  Added more for Serviceability-->
<!-- 	and Server Termination.-->
<!-- 	[1994/08/12  19:23:06  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.4  1994/08/11  21:08:35  jshirley-->
<!-- 	Inserted and updated Server Initialization sections, first cut.-->
<!-- 	[1994/08/11  21:08:12  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.3  1994/07/07  15:11:58  jshirley-->
<!-- 	Added the new heading structure.-->
<!-- 	[1994/07/07  15:11:26  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.2  1994/06/13  18:22:36  devobj-->
<!-- 	cr10872 - fix copyright-->
<!-- 	[1994/06/13  18:19:59  devobj]-->
<!-- -->
<!-- Revision 1.1.2.1  1994/03/11  23:05:06  rom-->
<!-- 	{enh, 10129, R1.1}-->
<!-- 	Initial split of App Dev Guide into three books and creation of-->
<!-- 	Intro and Style Guide.-->
<!-- 	[1994/03/11  23:01:53  rom]-->
<!-- -->
<!---->
<!-- - -->
<Chapter Id="ADGISG.INTRO.div.1">
<Title>Introduction to DCE Application Programming</Title>
<!-- - -->
<Para>The majority of this first chapter consists of a fairly detailed overview of
each of the separate steps that a developer usually has to perform (or have
the application perform) from the beginning of coding to the end of execution
of a successful DCE application.
</Para>
<Para>Before you begin a serious study of the contents of any part of this guide,
or indeed of any other book in the DCE documentation set, you should read
the &DCEIn;.  It contains clear and comprehensive
overviews, with illustrations, of all the DCE components and of the
integrated DCE as a whole; many concepts and details are explained there
that are necessary to a full understanding of what is described here.
</Para>
<Para>If you do not find information about topics you are interested in either
in this guide or in the &DCEDr;, 
you should also look in the &DCEAg; and the
&DCEAr;.  For example, the DCE Cell Directory Service (CDS)
is not accessed directly by applications (except through DCE RPC NSI or
through XDS) so most of the discussion of CDS as a separate component is
found in the administration documentation.  Although the DCE Security Service
is documented in the development books, certain aspects of it important to
application developers (for example, adding new principals to the security
registry database) are found only in the administration books.
</Para>
<Para>Several key methods underlie the successful development of DCE
applications programs.  These methods, explained in this chapter, are
as follows:
</Para>
<ItemizedList>
<ListItem>
<Para>A set of tools for distinguishing the component applications programs,
for describing how they work together, and for manipulating and
managing DCE components both locally and remotely.
</Para>
</ListItem>
<ListItem>
<Para>A method for establishing the interface between the component parts.
</Para>
</ListItem>
<ListItem>
<Para>Methods to install and register a server, so that clients can use it.
</Para>
</ListItem>
<ListItem>
<Para>Methods to set up clients so they can use servers.
</Para>
</ListItem>
</ItemizedList>
<!-- - -->
<Sect1 Id="ADGISG.INTRO.div.2">
<Title>Development Overview</Title>
<!-- - -->
<Para>Most of the effort of developing a DCE application usually lies in the
familiar steps of planning, writing and compiling the necessary C code,
linking the result with the DCE library and other modules, and executing it
(perhaps repeatedly).  However, there is an important preliminary task which
must be performed before you write any other code.  Before you can implement
the application's client and server, you must write and compile an interface
definition file in which you define the application's client/server interface.
</Para>
<Para>This interface, defined in the DCE Interface Definition Language (IDL),
consists of a set of <Replaceable>prototypes</Replaceable> for the remote procedure
calls your client(s) will be requesting your server(s) to execute.  After
you have written this file, you compile it with the DCE IDL compiler.  The final
output of IDL compilation is a pair of object files, one for the server
<IndexTerm Id="ADGISG.INTRO.indx.1">
<Primary>IDL</Primary>
</IndexTerm>module and one for the client, which you must later link with the compiled
output of your server and client implementation code.  These two IDL output
files contain the server and client stub code, where all the details of remote
execution, data transfer, and so on, are managed (in conjunction with the
DCE runtime).
</Para>
<Para>The IDL compiler also generates a header file for inclusion in the server
and client source files.  It contains all the declarations
that result from the IDL file definitions.  Among these are, for example,
the interface specification identifier, which will be used at runtime to
describe the interface being defined in the programs.
<IndexTerm Id="ADGISG.INTRO.indx.2">
<Primary>interface</Primary>
</IndexTerm></Para>
<Para>Once you have linked the stub files (and the DCE library) to their respective
client and server modules, the IDL-generated stubs make the client and server
<IndexTerm Id="ADGISG.INTRO.indx.3">
<Primary>stubs</Primary>
</IndexTerm>seem to communicate directly through the operation signatures you defined in the
original <Filename>.idl</Filename> file, although in actuality client/server communications
pass back and forth through layers of stub and runtime processing, which are
necessary to send and receive the data over the network.  
Figure 1-1 illustrates
how the combination of IDL (by means of the stubs it generates) and the RPC
runtime routines shields both client and server from the details of network
communications.
</Para>
<Para><!-- - -->
<!-- - -->
<!-- Figure figfirst: showing the effect of IDL on the "look" of RPC-->
<!-- - -->
<!-- - -->
<!-- pix/figfirst.pic-->
<?sml-need 3.6i></Para>
<Figure>
<Title>The Combined Effect of IDL and the RPC Runtime</Title>
<Graphic Format="EPS" Entityref="ADGISG.INTRO.pic.1"></Graphic>
</Figure>
<?sml-space .5>
<Para>Once the work of defining an interface has been completed, the task of
implementing the interface (that is, coding the operations, along with
the rest of the necessary initialization and management routines, in some
programming language) begins.  The rest of this chapter consists of detailed
explanations of the DCE application development steps from start to finish.
For a practical example of the result of such a process, refer to the code
for the DCE sample application, which is reprinted in full in the appendix
of this book.
</Para>
<Para>Each of the DCE components (with the exception of CDS, which is accessed
through the RPC NS API) is discussed in depth in separate parts of
this guide.  You should also refer often to the
&DCEDr;, which contains reference pages for all of the
DCE library routines mentioned in the following sections.
<!-- - -->
</Para>
</Sect1>
<Sect1 Id="ADGISG.INTRO.div.3">
<Title>Overview of DCE Application Development Steps</Title>
<!-- - -->
<Para>The rest of this chapter consists of a step-by-step checklist of every single
one of the decisions that a programmer must make in developing a typical DCE
application.  Each set of decisions or choices is combined into one step.  The
combination of all these steps takes you from the initial coding stages into
and through the normal course of execution of the application itself.  The
underlying intention of this arrangement is to give you a useful mental model
of the overall code development process.
<!-- .P-->
<!-- Figure 1-2 summarizes the organization of the steps.-->
<!-- - -->
<!-- The 5 basic movements illustrated:-->
<!-- 			      IDL-->
<!-- 			   /       \-->
<!-- 		         /   [1-5]   \-->
<!-- 		       v               v-->
<!-- 		    CLIENT	     SERVER-->
<!-- 		      |		        | Set-up     [6-17]-->
<!-- 		      |		        | Listen-->
<!-- 		      v  .  .  .  .  .  v-->
<!-- [18-20]    Bind |-->
<!-- 	       Invoke |-->
<!-- 		      v  .  .  .  .  .  |<-^-->
<!-- 				        | Service |  [21-27]-->
<!-- 				        | Listen  |-->
<!-- 		      |  .  .  .  .  .  v->-->
<!-- [28-29]  Return |-->
<!-- 	     Continue |-->
<!-- 		      v-->
</Para>
<Para>The four basic phases of DCE application development are as follows:
<!-- NEW TOTAL == 21-->
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>A.</Literal></Term>
<ListItem>
<Para><Literal>CLIENT and SERVER:</Literal> Define the IDL interface [Steps <Literal>A1</Literal> to
<Literal>A4</Literal>]
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>B.</Literal></Term>
<ListItem>
<Para><Literal>SERVER:</Literal> Set up and listen [Steps <Literal>B1</Literal> to <Literal>B8</Literal>]
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>C.</Literal></Term>
<ListItem>
<Para><Literal>CLIENT:</Literal> Bind to and invoke the server [Steps <Literal>C1</Literal> to <Literal>C4</Literal>]
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>D.</Literal></Term>
<ListItem>
<Para><Literal>SERVER:</Literal> Service request(s) [Steps <Literal>D1</Literal> to <Literal>D5</Literal>]
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para>Following is an overview list of all 21 steps, separated into the four main
phases previously described.  Each step's numeral is followed by a
<Filename>/</Filename> (slash) and the terms <Literal>Client</Literal> and/or <Literal>Server</Literal> to
indicate whether it applies to the application's server or client, or both.
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>A.</Literal></Term>
<ListItem>
<Para><Literal>CLIENT and SERVER:</Literal>&ensp;&ensp;Define the IDL interface
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>A1/Client and Server:</Literal></Term>
<ListItem>
<Para>Generate the interface UUID
<IndexTerm Id="ADGISG.INTRO.indx.4">
<Primary>interface</Primary>
<Secondary>UUID</Secondary>
</IndexTerm></Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>A2/Client and Server:</Literal></Term>
<ListItem>
<Para>Write the <Filename>.idl</Filename> file
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>A3/Client and Server:</Literal></Term>
<ListItem>
<Para>Write the <Filename>.acf</Filename> file (optional)
<IndexTerm Id="ADGISG.INTRO.indx.5">
<Primary>attribute configuration file</Primary>
</IndexTerm></Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>A4/Client and Server:</Literal></Term>
<ListItem>
<Para>Process the files with the IDL compiler
<IndexTerm Id="ADGISG.INTRO.indx.6">
<Primary>IDL</Primary>
<Secondary>compiler</Secondary>
</IndexTerm></Para>
</ListItem>
</VarListEntry>
</VariableList>
<?sml-space>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>B.</Literal></Term>
<ListItem>
<Para><Literal>SERVER:</Literal>&ensp;&ensp;Initialization
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>B1/Server:</Literal></Term>
<ListItem>
<Para>Set up for serviceability
<IndexTerm Id="ADGISG.INTRO.indx.7">
<Primary>serviceability</Primary>
</IndexTerm></Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>B2/Server:</Literal></Term>
<ListItem>
<Para>Set up the server's objects
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>B3/Server:</Literal></Term>
<ListItem>
<Para>Set up security
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>B4/Server:</Literal></Term>
<ListItem>
<Para>Define the manager entry point vectors
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>B5/Server:</Literal></Term>
<ListItem>
<Para>Register the server
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>B6/Server:</Literal></Term>
<ListItem>
<Para>Specify multithreadedness
<IndexTerm Id="ADGISG.INTRO.indx.8">
<Primary>multithreadedness</Primary>
</IndexTerm></Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>B7/Server:</Literal></Term>
<ListItem>
<Para>Listen for incoming service requests
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>B8/Server:</Literal></Term>
<ListItem>
<Para>Clean up when server terminates
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<?sml-space>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>C.</Literal></Term>
<ListItem>
<Para><Literal>CLIENT:</Literal>&ensp;&ensp;Bind to and invoke the server
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>C1/Client:</Literal></Term>
<ListItem>
<Para>Multithreaded client design
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>C2/Client:</Literal></Term>
<ListItem>
<Para>Import the binding information from the namespace (CDS)
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>C3/Client:</Literal></Term>
<ListItem>
<Para>Annotate the binding handle for security
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>C4/Client:</Literal></Term>
<ListItem>
<Para>Invoke an RPC interface operation
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<?sml-space>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>D.</Literal></Term>
<ListItem>
<Para><Literal>SERVER:</Literal>&ensp;&ensp;Service the request
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>D1/Server:</Literal></Term>
<ListItem>
<Para>Get the client's credentials
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>D2/Server:</Literal></Term>
<ListItem>
<Para>Get the object's access control list
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>D3/Server:</Literal></Term>
<ListItem>
<Para>Make the authorization decision
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>D4/Server:</Literal></Term>
<ListItem>
<Para>Service the request
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>D5/Server:</Literal></Term>
<ListItem>
<Para>Return the results to the client and resume listening
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</ListItem>
</VarListEntry>
</VariableList>
<!-- - -->
</Sect1>
<Sect1 Id="ADGISG.INTRO.div.4">
<Title>DCE Application Development Tools</Title>
<!-- - -->
<Para>The following DCE tools allow developers to define and manage a set of
programs intended to run in a DCE environment.
</Para>
<ItemizedList>
<ListItem>
<Para>Unique identification
</Para>
<Para>Because DCE involves the interaction of many distinct programs,
operating on several processors that may be quite remote from each
other, every entity (such as programs, interface definitions, and so
forth) needs a unique identifier.  This identifier is provided by the
UUID generator.
<IndexTerm Id="ADGISG.INTRO.indx.9">
<Primary><Command>uuidgen</Command></Primary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para>Interface definition language
<IndexTerm Id="ADGISG.INTRO.indx.10">
<Primary>interface definition language (IDL)</Primary>
</IndexTerm></Para>
<Para>Applications programs that are to work within DCE can be written in
any of several programming languages.  The two halves of a
client/server pair need not be in the same language.  In order to
permit this flexibility, each application's client/server interface
uses a common language, called IDL.  It is supported by an IDL Compiler.
</Para>
</ListItem>
<ListItem>
<Para>Attribute configuration language
<IndexTerm Id="ADGISG.INTRO.indx.11">
<Primary>attribute configuration language</Primary>
</IndexTerm></Para>
<Para>To allow developers to control the interface between local
applications code and the RPC interface, there is an optional
attribute configuration language supported by the IDL compiler.
</Para>
</ListItem>
<ListItem>
<Para>Remote DCE management
</Para>
<Para>A host daemon (<Literal>dced</Literal>) and a control program (<Literal>dcecp</Literal>) provide
capabilities for management of a host and its servers.
</Para>
</ListItem>
</ItemizedList>
<!-- - -->
<Sect2 Id="ADGISG.INTRO.div.5">
<Title>The DCE UUID Generator</Title>
<!-- - -->
<Para>The 
<IndexTerm Id="ADGISG.INTRO.indx.12">
<Primary>UUID</Primary>
<Secondary>generator</Secondary>
</IndexTerm>UUID generator <Command>uuidgen</Command> is an interactive utility
that creates UUIDs (universal unique identifiers). 
A UUID is a hexadecimal number that contains information that
makes it unique from all other UUIDs.  Applications use UUIDs to identify
many kinds of entities, including interface definitions.  Consequently,
application developers typically use the UUID generator when they
are creating their interface definition files.
</Para>
<Para>To run the UUID generator, issue the <Command>uuidgen</Command> command.
This command offers several options, including an option to
create a template interface definition file (an
<Filename>.idl</Filename> file) containing a newly generated interface UUID.
For complete information about generating UUIDs and template
interface definition files, see the &DCEDk;.  See this volume also
for a discussion of UUIDs and their use in DCE applications.  Refer to 
the <Filename MoreInfo="RefEntry">uuidgen(1rpc)</Filename> reference page for a description of the <Command>uuidgen</Command>
utility and its options.
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.INTRO.div.6">
<Title>DCE Interface Definition Language</Title>
<!-- - -->
<Para>As was mentioned earlier in this chapter, developing a DCE application involves
writing and compiling an
<!-- .gL "interface definition"-->
<IndexTerm Id="ADGISG.INTRO.indx.13">
<Primary>RPC</Primary>
<Secondary>interface</Secondary>
<Tertiary>definition</Tertiary>
</IndexTerm>interface definition, which defines the application's client/server interface.
Application developers use IDL to write
the interface definition.  IDL is a high-level descriptive language whose syntax
resembles that of ANSI C.  IDL is a declarative, not a procedural, language.  Some
of the important attributes specified with IDL are the following:
</Para>
<ItemizedList>
<ListItem>
<Para>For interfaces
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>uuid</Literal></Term>
<ListItem>
<Para>Specifies the interface's UUID.  
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>version</Literal></Term>
<ListItem>
<Para>Specifies the interface major and minor version number. 
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</ListItem>
<ListItem>
<Para>For parameters
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>in</Literal></Term>
<ListItem>
<IndexTerm Id="ADGISG.INTRO.indx.14">
<Primary>parameters</Primary>
<Secondary><Literal>in</Literal></Secondary>
</IndexTerm>
<Para>Signifies a parameter whose value is passed from the client to the
server.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>out</Literal></Term>
<ListItem>
<IndexTerm Id="ADGISG.INTRO.indx.15">
<Primary>parameters</Primary>
<Secondary><Literal>out</Literal></Secondary>
</IndexTerm>
<Para>Signifies a parameter whose value is passed from the server to the
client.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</ListItem>
<ListItem>
<Para>For data types
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>handle</Literal></Term>
<ListItem>
<Para>Specifies a customized binding handle.  Chapter 4 discusses binding
handles and binding methods in more detail.
<IndexTerm Id="ADGISG.INTRO.indx.16">
<Primary>handle</Primary>
<Secondary>binding</Secondary>
</IndexTerm></Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>context_handle</Literal></Term>
<ListItem>
<IndexTerm Id="ADGISG.INTRO.indx.17">
<Primary>handle</Primary>
<Secondary>context</Secondary>
</IndexTerm>
<Para>Specifies a context handle, which is a pointer to state
information that the server uses and which is maintained across RPC
invocations.  An example of a context handle is a file pointer.
For more information about context handles,
see the &DCEDk;. 
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</ListItem>
</ItemizedList>
<Para>IDL's operation attributes include specifiers for execution semantics:
<IndexTerm Id="ADGISG.INTRO.indx.18">
<Primary>execution semantics</Primary>
</IndexTerm>whether the operation can be safely executed more than once,
whether a response is expected, and so on.  The default is that operations
can be executed at-most-once.  Parameters (the arguments
supplied by the client when it makes the remote call) can be specified
as input to the server, output to the client, or both.
See the &DCEDk; for a complete description of IDL syntax and usage.
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.INTRO.div.7">
<Title>The DCE IDL Compiler</Title>
<!-- - -->
<Para>The DCE IDL compiler <Command>idl</Command> processes interface
<IndexTerm Id="ADGISG.INTRO.indx.19">
<Primary>IDL</Primary>
<Secondary>compiler</Secondary>
</IndexTerm>definitions written in IDL and generates header files and stub object code.
(The compiler generates source code for the stubs in ANSI C.) The
code generated from an interface definition by the compiler includes client
and server stubs.
</Para>
<Para>The compiler also generates a data structure called 
<IndexTerm Id="ADGISG.INTRO.indx.20">
<Primary>RPC</Primary>
<Secondary>interface</Secondary>
<Tertiary>specification</Tertiary>
</IndexTerm>the interface specification, 
which contains identifying and descriptive information about
the compiled interface, and creates a companion global variable, 
<!-- .gL "interface handle"-->
<IndexTerm Id="ADGISG.INTRO.indx.21">
<Primary>RPC</Primary>
<Secondary>interface</Secondary>
<Tertiary>handle</Tertiary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.22">
<Primary>interface</Primary>
<Secondary>handle</Secondary>
<Tertiary>RPC</Tertiary>
</IndexTerm>the interface handle, which 
is a reference to the interface specification. 
Each header file generated by the IDL compiler contains the reference 
the application code needs to access the interface handle.  The interface handle
allows the 
application code to refer to the interface specification in calls to the RPC
<IndexTerm Id="ADGISG.INTRO.indx.23">
<Primary>interface specification</Primary>
</IndexTerm>runtime.  Runtime operations obtain required information about the interface,
such as its UUID and version numbers, directly from the interface specification. 
</Para>
<Para>You run the IDL compiler by issuing the <Command>idl</Command> command. See the 
<Filename MoreInfo="RefEntry">idl(1rpc)</Filename> reference page for a description of the <Command>idl</Command> command
and its options.
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.INTRO.div.8">
<Title>The Attribute Configuration File</Title>
<!-- - -->
<Para>Application developers can use an optional attribute configuration
file to tailor how an RPC interface appears to
local application code and how the local application code
interacts with the RPC interface.
The 
<IndexTerm Id="ADGISG.INTRO.indx.24">
<Primary>attribute configuration file</Primary>
</IndexTerm>attribute configuration file is written
in the attribute configuration language, which is a companion language
to IDL.  When the IDL compiler is invoked, it searches for an attribute
configuration file in addition to processing the interface definition file.
</Para>
<Para>An attribute configuration file
modifies how the IDL compiler interprets an interface definition.
For example, an attribute configuration
file can specify a subset of operations declarations
for a client stub so that the client stub contains declarations for
only the operations that the client application code needs for its
remote procedure calls.  Limiting the client's access to the
remote procedures offered by servers reduces the size of the client stub.
Another action you can control with an attribute configuration
file is defining how a client
establishes a binding with a server that implements the called
interface.
</Para>
<Para>For complete information on the set of attribute configuration
file attributes, see the &DCEDk;.
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.INTRO.div.9">
<Title>The DCE Host Daemon</Title>
<!-- - -->
<IndexTerm Id="ADGISG.INTRO.indx.25">
<Primary>DCE host daemon</Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.26">
<Primary>daemon</Primary>
<Secondary>DCE host</Secondary>
</IndexTerm>
<Para>Each DCE host runs a DCE host daemon (<Literal>dced</Literal>) to provide remote DCE
management services for a host and its servers.  The <Literal>dced</Literal> provides
<IndexTerm Id="ADGISG.INTRO.indx.27">
<Primary><Literal>dced</Literal></Primary>
</IndexTerm>remote management of DCE-related host and server data, it provides remote
control of a host's servers, and it maintains host-specific state for DCE
such as the host's login identity.
From the server's perspective, <Literal>dced</Literal> is a central point where
all servers can consistently inform their host about themselves.
From the host's perspective, <Literal>dced</Literal> gives clients, management
applications, and DCE administrators (via <Literal>dcecp</Literal>) 
<IndexTerm Id="ADGISG.INTRO.indx.28">
<Primary><Literal>dcecp</Literal></Primary>
</IndexTerm>a focal point from which to find out about (and even control) servers.
</Para>
<Para>The most important feature of the <Literal>dced</Literal> is that it provides the 
<IndexTerm Id="ADGISG.INTRO.indx.29">
<Primary>endpoint</Primary>
<Secondary>map</Secondary>
</IndexTerm>endpoint mapper service.  
This service maintains the host's local endpoint map for
local RPC servers and looks up endpoints for RPC clients. 
<IndexTerm Id="ADGISG.INTRO.indx.30">
<Primary>endpoint</Primary>
<Secondary>RPC</Secondary>
</IndexTerm>An endpoint is the address of a specific instance of a server that is
executing in a particular address space on a given host.
<IndexTerm Id="ADGISG.INTRO.indx.31">
<Primary>RPC</Primary>
<Secondary>server instances</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.32">
<Primary>instance, server</Primary>
</IndexTerm>Each endpoint can be used on a host by only one server at a time.
<IndexTerm Id="ADGISG.INTRO.indx.33">
<Primary>endpoint</Primary>
<Secondary>map</Secondary>
</IndexTerm>The endpoint map is the system-specific database on each host, 
in which servers register their endpoints and associated addressing
information (information about communication protocols, objects, and so on).
A server registers separate endpoints for each of its RPC interfaces
and any objects the server offers with the interface.
</Para>
<Para>If a client makes a remote procedure call to a host without providing an
endpoint, the <Literal>dced</Literal> searches its endpoint map for the
endpoint of a compatible server.   Upon finding a suitable endpoint, 
the endpoint mapper service (depending on the protocols used) 
forwards the call to that endpoint or
returns the endpoint to the client's runtime, 
which sends the call to the server at that endpoint.
</Para>
<Para>Other remote services of <Literal>dced</Literal> include host data management, 
<IndexTerm Id="ADGISG.INTRO.indx.34">
<Primary><Literal>dced</Literal></Primary>
<Secondary>host data management</Secondary>
</IndexTerm>server control, security validation, and key table management.
<IndexTerm Id="ADGISG.INTRO.indx.35">
<Primary><Literal>dced</Literal></Primary>
<Secondary>key table management</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.36">
<Primary><Literal>dced</Literal></Primary>
<Secondary>security validation</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.37">
<Primary><Literal>dced</Literal></Primary>
<Secondary>server control</Secondary>
</IndexTerm>These are described in detail in the &DCEDk;.
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.INTRO.div.10">
<Title>The DCE API</Title>
<!-- - -->
<Para>DCE provides a wide range of application programming interface
routines.  All of the following are available:
</Para>
<ItemizedList>
<ListItem>
<Para>A set of general DCE routines routines provide the means for
configuration, handling messages, using the backing store, and managing
the DCE daemon, as well as other purposes. 
</Para>
</ListItem>
<ListItem>
<Para>The DCE thread routines provide thread control, including thread creation,
conditional waiting, priorities, and locks.
</Para>
</ListItem>
<ListItem>
<Para>The DCE remote procedure call routines provide tools to
establish and manage servers, and also include utilities for use by
clients and by servers.
</Para>
</ListItem>
<ListItem>
<Para>The DCE directory service routines are a set of X/OPEN directory
service routines that provide access to the Global Directory Service
(GDS) and CDS. 
</Para>
</ListItem>
<ListItem>
<Para>The DCE distributed time service routines obtain timestamps, translate
between timestamp formats, and perform time calculations.  The
routines can be used from server or clerk systems to determine event
sequencing, duration, and scheduling.
</Para>
</ListItem>
<ListItem>
<Para>The DCE security service routines allow developers to create
network services with complete access to all the authentication and
authorization capabilities of DCE Security Service and facilities.
</Para>
</ListItem>
</ItemizedList>
<!-- - -->
</Sect2>
<Sect2 Id="ADGISG.INTRO.div.11">
<Title>The DCE Control Program</Title>
<!-- - -->
<Para>Although the DCE control program, <Literal>dcecp</Literal>, is intended as an
<IndexTerm Id="ADGISG.INTRO.indx.38">
<Primary><Literal>dcecp</Literal></Primary>
</IndexTerm>administrator's tool, developers will find it invaluable for examining
and modifing many aspects of the DCE environment.  It can be used in
constructing installation scripts, as in the following examples:
</Para>
<ItemizedList>
<ListItem>
<Para>For exporting binding information to a namespace, instead of putting C
<IndexTerm Id="ADGISG.INTRO.indx.39">
<Primary>binding</Primary>
<Secondary>exporting</Secondary>
</IndexTerm>code in your application to call the NSI routines, <Literal>rpc_ns_</Literal><Symbol Role="Variable">*</Symbol><Literal>(&thinsp;)</Literal>,
<IndexTerm Id="ADGISG.INTRO.indx.40">
<Primary>NSI routines</Primary>
</IndexTerm>you could write a <Literal>dcecp</Literal> script that calls <Command>rpcentry export</Command>
<IndexTerm Id="ADGISG.INTRO.indx.41">
<Primary><Command>rpcentry export</Command></Primary>
</IndexTerm>and its related commands.
</Para>
</ListItem>
<ListItem>
<Para>For installation, you might need to create a principal
name and/or set an access control list (ACL) 
on it.  Instead of writing C code in
<IndexTerm Id="ADGISG.INTRO.indx.42">
<Primary>ACL</Primary>
</IndexTerm>your application's initialization section to call <Literal>sec_rgy_pgo_</Literal><Symbol Role="Variable">*</Symbol><Literal>(&thinsp;)</Literal>
and <Literal>sec_acl_</Literal><Symbol Role="Variable">*</Symbol><Literal>(&thinsp;)</Literal>, you could ship a <Literal>dcecp</Literal> script that
includes the following:
</Para>
<InformalExample>
<Para><ProgramListing>principal create ...
acl mod /.:/sec/principal/...
</ProgramListing></Para>
</InformalExample>
</ListItem>
<ListItem>
<Para>It is recommended that you have <Literal>dced</Literal> start your application by
using server configuration information.  It is generally better to do
<IndexTerm Id="ADGISG.INTRO.indx.43">
<Primary>server</Primary>
<Secondary>configuration information</Secondary>
</IndexTerm>this by writing a <Literal>dcecp</Literal> script that sets up the server
configuration information (the arguments to start the executable)
rather than doing it with C code that calls the
<Function>dced_server_create()</Function> API.
</Para>
</ListItem>
</ItemizedList>
<Para>In general, <Literal>dcecp</Literal> scripts for server configuration allow better
<IndexTerm Id="ADGISG.INTRO.indx.44">
<Primary><Literal>dcecp</Literal></Primary>
<Secondary>scripts</Secondary>
</IndexTerm>flexibility than embedded C code.  Furthermore, unlike embedded code,
the script does not persist after configuration is done.
</Para>
<Para>The DCE control program can also be useful for debugging, as the
following examples show:
</Para>
<ItemizedList>
<ListItem>
<Para>You can check exported infoformation in the namespace with
<Command>rpcentry show</Command> or <Command>rpcgroup, rpcprofile show</Command>.
<IndexTerm Id="ADGISG.INTRO.indx.45">
<Primary><Literal>dcecp</Literal></Primary>
<Secondary><Command>rpcprofile show</Command></Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.46">
<Primary><Literal>dcecp</Literal></Primary>
<Secondary><Command>rpcgroup show</Command></Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.47">
<Primary><Literal>dcecp</Literal></Primary>
<Secondary><Command>rpcentry show</Command></Secondary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para>You can use <Command>server ping</Command> to see if your server is
<IndexTerm Id="ADGISG.INTRO.indx.48">
<Primary><Literal>dcecp</Literal></Primary>
<Secondary><Command>server ping</Command></Secondary>
</IndexTerm>running and receiving requests.
</Para>
</ListItem>
<ListItem>
<Para>If your server was set up to be started by <Literal>dced</Literal>, you can start
it by using the <Command>server start</Command> command and can 
<IndexTerm Id="ADGISG.INTRO.indx.49">
<Primary><Literal>dcecp</Literal></Primary>
<Secondary><Command>server start</Command></Secondary>
</IndexTerm>view the startup parameters by using <Command>server show -executing</Command>.
<IndexTerm Id="ADGISG.INTRO.indx.50">
<Primary><Literal>dcecp</Literal></Primary>
<Secondary><Command>server show -executing</Command></Secondary>
</IndexTerm></Para>
</ListItem>
</ItemizedList>
<!-- - -->
</Sect2>
</Sect1>
<Sect1 Id="ADGISG.INTRO.div.12">
<Title>The Interface Definition</Title>
<!-- - -->
<Para>Once you have designed your DCE application and have decided
which procedures are needed, and which will be remote procedures,
the next step in developing the application is to write one or
more interface definitions that describe the remote procedures
your application's clients will be requesting your application's
servers to run.
</Para>
<Para><?sml-need 4>To create an interface definition, use the following steps:
</Para>
<OrderedList>
<ListItem>
<Para>Generate an interface UUID and a skeleton <Filename>.idl</Filename> file with
the <Command>uuidgen</Command> utility.
<IndexTerm Id="ADGISG.INTRO.indx.51">
<Primary><Command>uuidgen</Command></Primary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para>Write your interface operation declarations in IDL, using
the skeleton <Filename>.idl</Filename> file you generated with <Command>uuidgen</Command>
as a base.
</Para>
</ListItem>
<ListItem>
<Para>Write the attribute configuration file.  This is an optional
<IndexTerm Id="ADGISG.INTRO.indx.52">
<Primary>attribute configuration file</Primary>
</IndexTerm>step that you take only if you want to alter the IDL output
in various ways.
</Para>
</ListItem>
<ListItem>
<Para>Compile the completed interface definition file with the IDL compiler.
</Para>
</ListItem>
</OrderedList>
<Para>The following sections describe these steps in more detail.
<!-- - -->
</Para>
<Sect2 Id="ADGISG.INTRO.div.13">
<Title>Generating the Interface UUID</Title>
<!-- - -->
<Para>Interfaces, like most other objects and entities in DCE, are identified by
associating each one with a 128-bit universal unique identifier
(UUID).  An interface's UUID serves to identify it far and wide throughout
<IndexTerm Id="ADGISG.INTRO.indx.53">
<Primary>UUID</Primary>
<Secondary>interface</Secondary>
<Tertiary>generating</Tertiary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.54">
<Primary>interface</Primary>
<Secondary>UUID</Secondary>
<Tertiary>generating</Tertiary>
</IndexTerm>DCE.  Every interface in a DCE application must have a UUID assigned to it.
</Para>
<Para>When you define a new interface, you must generate a UUID for it.
Consequently, the first step in developing an interface definition is to
run the <Command>uuidgen</Command> utility to generate a UUID for the interface.
</Para>
<Para>Typically, you run the <Command>uuidgen</Command> command with the <Option>i</Option> option
when generating an interface UUID.  The command line has the following syntax:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>uuidgen -i > <Symbol Role="Variable">your_interface_name</Symbol><Filename>.idl
</Filename></UserInput></ProgramListing></Para>
</InformalExample>
<IndexTerm Id="ADGISG.INTRO.indx.55">
<Primary><Command>uuidgen</Command></Primary>
</IndexTerm>
<Para>where <Symbol Role="Variable">your_interface_name</Symbol> is the name you have given your interface,
and <Filename>.idl</Filename> is the suffix that all interface definitions use by convention.
The <Command>uuidgen</Command> utility generates a file named <Symbol Role="Variable">your_interface_name</Symbol><Filename>.idl</Filename>,
that contains a skeleton of an interface definition and includes the newly
generated UUID for the interface.  See the &DCEDk; for more information about the
contents of this skeleton file.  Refer to the <Filename MoreInfo="RefEntry">uuidgen(1rpc)</Filename> reference page
for a complete description of <Command>uuidgen</Command>.
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.INTRO.div.14">
<Title>Writing the Interface Definition File</Title>
<!-- - -->
<Para>The <Filename>.idl</Filename> file is where the set of remote operations that
<IndexTerm Id="ADGISG.INTRO.indx.56">
<Primary>IDL</Primary>
<Secondary>file</Secondary>
</IndexTerm>constitute the interface are defined.  The <Filename>.idl</Filename> file defines
and characterizes the interfaces to the server implementations
of the remote operations (which you write, in C source code,
then compile and link to the stub code output by the IDL compiler).
Thus, an <Filename>.idl</Filename> file's contents is like a set of
<Replaceable>network prototypes</Replaceable> for a set of operations.  The IDL definitions
in the interface definition file determine not only how the
operations ``look'' to client and server (that is, the
operations' call signatures, parameter types, and so on), but also what the
data looks like when it is transmitted back and forth between clients and
servers in a distributed application.
</Para>
<Para>An interface definition file consists of the following two basic components: 
</Para>
<ItemizedList>
<ListItem>
<Para>An interface header 
</Para>
<Para><IndexTerm Id="ADGISG.INTRO.indx.57">
<Primary>RPC</Primary>
<Secondary>interface</Secondary>
<Tertiary>header</Tertiary>
</IndexTerm>An interface header contains an interface UUID, interface
version numbers, and an interface name.  An
<IndexTerm Id="ADGISG.INTRO.indx.58">
<Primary>RPC</Primary>
<Secondary>interface</Secondary>
<Tertiary>name</Tertiary>
</IndexTerm>interface name 
is an easy-to-read local name that is not guaranteed to be 
unique; it is merely a convenience.  It is helpful if the interface name 
reflects the nature or purpose of the interface.
</Para>
</ListItem>
<ListItem>
<Para>An interface body 
</Para>
<Para><IndexTerm Id="ADGISG.INTRO.indx.59">
<Primary>RPC</Primary>
<Secondary>interface</Secondary>
<Tertiary>body</Tertiary>
</IndexTerm>An interface body declares any application-specific data types and
constants, and contains directives for including data types and constants from
other interfaces.  The interface body also contains the operation
declaration of each remote procedure to be accessed through the interface.
An 
<IndexTerm Id="ADGISG.INTRO.indx.60">
<Primary>operations</Primary>
<Secondary>declaration of</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.61">
<Primary>RPC</Primary>
<Secondary>interface</Secondary>
<Tertiary>operation declaration</Tertiary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.62">
<Primary>operations</Primary>
<Secondary>IDL</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.63">
<Primary>IDL</Primary>
<Secondary>operations</Secondary>
</IndexTerm>operation declaration identifies
the parameters of a procedure in terms of their data types, access method, and
call order, and declares the data type of the return value (if any).
</Para>
</ListItem>
</ItemizedList>
<Para>The skeletal interface definition produced by the <Command>uuidgen</Command> utility
provides an interface header that contains the newly generated UUID for
the interface, a version number, and a dummy string <Literal>INTERFACENAME</Literal>.
<IndexTerm Id="ADGISG.INTRO.indx.64">
<Primary>interface</Primary>
<Secondary>version number</Secondary>
</IndexTerm>Replace this dummy string with the name of your interface, then
add any additional interface header attributes your application 
requires.  (See the &DCEDk; for a complete description of interface
header attributes).
</Para>
<Para><?sml-need 7>The skeletal interface definition file also provides an interface body,
which consists solely of <Literal>{&thinsp;}</Literal>, that is, an empty pair of braces.
You fill in the space between the braces with your RPC interface's
import, constant, type, and operation declarations, written in IDL.
The &DCEDk; explains this process in more detail.  In addition, the same 
volume for a complete
description of the IDL syntax for specifying import, constant, type, and
operation declarations.
</Para>
<Para>Note that a server can implement more than one interface.
In this case, you define each interface in a separate <Filename>.idl</Filename> file
<IndexTerm Id="ADGISG.INTRO.indx.65">
<Primary>interface</Primary>
<Secondary>multiple definitions</Secondary>
</IndexTerm>and compile it separately with the IDL compiler.  You then link the implemented
interface operations in various source code files with the IDL output.
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.INTRO.div.15">
<Title>Writing the Attribute Configuration File</Title>
<!-- - -->
<Para>The attribute configuration file (<Filename>.acf</Filename>) is an optional additional
<IndexTerm Id="ADGISG.INTRO.indx.66">
<Primary>attribute configuration file</Primary>
</IndexTerm>input file to the IDL compiler, that, if present, affects the IDL
compiler's output in various ways.  The difference between the purpose of
the <Filename>.idl</Filename> and an <Filename>.acf</Filename> file is that while the <Filename>.idl</Filename> file
defines how the network communications between the client and server are handled,
the <Filename>.acf</Filename> file, if one is present, affects only the interaction between
the stub code modules and the developer code that they support.  In other words,
changing the contents of an <Filename>.acf</Filename> file has no effect on the network
communications between the client and server.
</Para>
<Para>Nevertheless, some of the features offered by an <Filename>.acf</Filename> file are very
important, and they cannot be obtained by any other means.  For example,
The <Literal>comm_status</Literal> attribute configuration
file attribute allows the status code of a
<IndexTerm Id="ADGISG.INTRO.indx.67">
<Primary><Literal>comm_status</Literal> attribute</Primary>
</IndexTerm>communications failure that occurs in an RPC to be stored as a parameter or
returned as a result, rather than being raised to the caller code as an
exception.  This attribute can only be declared in an <Filename>.acf</Filename> file; 
it cannot be declared in an <Filename>.idl</Filename> file.
Another very important function of the <Filename>.acf</Filename> file is the specification
of a binding method to be used by remote clients of the application.  Three
<IndexTerm Id="ADGISG.INTRO.indx.68">
<Primary>binding</Primary>
<Secondary>methods</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.69">
<Primary>binding</Primary>
<Secondary>handle</Secondary>
</IndexTerm>methods are available, as follows:
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>auto_handle</Literal>
<IndexTerm Id="ADGISG.INTRO.indx.70">
<Primary>binding</Primary>
<Secondary>automatic method</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.71">
<Primary>binding</Primary>
<Secondary>implicit method</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.72">
<Primary>binding</Primary>
<Secondary>explicit method</Secondary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para><Literal>implicit_handle</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>explicit_handle</Literal> (the default)
</Para>
</ListItem>
</ItemizedList>
<Para><?sml-need 3>These binding methods are described in Chapter 4 of this guide.
The binding method you choose determines how much attention your
server's clients will have to devote to the upkeep of their binding handles.
</Para>
<Para>See the &DCEDk; for a description of the attribute configuration
file attributes
<IndexTerm Id="ADGISG.INTRO.indx.73">
<Primary>attribute configuration file</Primary>
</IndexTerm>available for use in attribute configuration files.
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.INTRO.div.16">
<Title>Processing the Files with the IDL Compiler</Title>
<!-- - -->
<Para>IDL's input is an <Symbol Role="Variable">xxx</Symbol><Filename>.idl</Filename> and (optionally) an <Symbol Role="Variable">xxx</Symbol><Filename>.acf</Filename>
<IndexTerm Id="ADGISG.INTRO.indx.74">
<Primary>IDL</Primary>
<Secondary>compiler</Secondary>
</IndexTerm>file.  Its default output is a header (<Symbol Role="Variable">xxx</Symbol><Filename>.h</Filename>) file, that contains
definitions and declarations derived from the input for general use in
the development source code, and two stub files, one for the client and
<IndexTerm Id="ADGISG.INTRO.indx.75">
<Primary>stubs</Primary>
<Secondary>files</Secondary>
</IndexTerm>one for the server, which contain runtime code for marshalling and
unmarshalling, message handling, and all the other details of managing
network communications.  The stub files are output as object code
(<Symbol Role="Variable">xxx</Symbol><Filename>_cstub.o</Filename> and <Symbol Role="Variable">xxx</Symbol><Filename>_sstub.o</Filename>) suitable for linking with
the developer's compiled code.  The IDL compiler generates C source code
as an intermediate step in the compilation process, and the output of this
step can also be saved in a pair of files (<Symbol Role="Variable">xxx</Symbol><Filename>_cstub.c</Filename> and
<IndexTerm Id="ADGISG.INTRO.indx.76">
<Primary><Filename>_cstub.c</Filename> file</Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.77">
<Primary><Filename>_sstub.c</Filename> file</Primary>
</IndexTerm><Symbol Role="Variable">xxx</Symbol><Filename>_sstub.c</Filename>).
</Para>
<Para>In order for a pair of client and server stubs to interoperate, they should
be generated from the same interface definition (<Filename>.idl</Filename>) file, but they
do <Symbol Role="Variable">not</Symbol> have to be generated with the same attribute configuration file
(<Filename>.acf</Filename>).  The compatibility rules for interface version numbers also
<IndexTerm Id="ADGISG.INTRO.indx.78">
<Primary>interface</Primary>
<Secondary>version number</Secondary>
<Tertiary>compatibility</Tertiary>
</IndexTerm>apply (see the &DCEDk;).
</Para>
<Para>For further information on the IDL compiler, see the <Filename MoreInfo="RefEntry">idl(1rpc)</Filename>
reference page.
<!-- - -->
</Para>
</Sect2>
</Sect1>
<Sect1 Id="ADGISG.INTRO.div.17">
<Title>Server Initialization</Title>
<!-- - -->
<Para>Servers must initialize some data and notify various DCE services
<IndexTerm Id="ADGISG.INTRO.indx.79">
<Primary>server</Primary>
<Secondary>initialization of</Secondary>
</IndexTerm>about themselves prior to servicing RPC requests.  At a minimum, 
servers must register with DCE and then go into a wait state listening 
for remote procedure calls. 
In addition to these minimum tasks, your application may first
parse the input arguments,
obtain information about how it was started using <Literal>dced</Literal> API calls,
and establish the proper message tables and locale for internationalization.
</Para>
<Para>DCE applications should be started in such a way that they can be
controlled by <Literal>dced</Literal>.  When the server is installed, the <Command>dcecp
server create</Command> operation (or a custom made server management
<IndexTerm Id="ADGISG.INTRO.indx.80">
<Primary><Literal>dcecp</Literal></Primary>
<Secondary><Command>server create</Command></Secondary>
</IndexTerm>application) is commonly used to establish the server's
configuration with its host <Literal>dced</Literal>.  This configuration data
<IndexTerm Id="ADGISG.INTRO.indx.81">
<Primary><Literal>dced</Literal></Primary>
<Secondary>configuration data for</Secondary>
</IndexTerm>includes among other things the program name and its arguments, 
the CDS entry name to use for exporting to the name service, 
and the valid starting methods.
Installing your servers in this way does not compromise their security
because <Literal>dced</Literal> operations are protected with ACLs,
and the major advantages include the following:
</Para>
<ItemizedList>
<ListItem>
<Para>You do not have write any complex management code for each server
</Para>
</ListItem>
<ListItem>
<Para>Your servers are like other DCE servers in that they can
all be managed consistently
</Para>
</ListItem>
</ItemizedList>
<Para>Depending on how the server is configured, the <Literal>dced</Literal> can start
it in the following ways:
</Para>
<ItemizedList>
<ListItem>
<Para>At boot time when the DCE daemon itself starts
</Para>
</ListItem>
<ListItem>
<Para>Explicitly via the <Command>dcecp server start</Command> operation (or from another
<IndexTerm Id="ADGISG.INTRO.indx.82">
<Primary><Literal>dcecp</Literal></Primary>
<Secondary><Command>server start</Command></Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.83">
<Primary><Function>dced_server_start()</Function></Primary>
</IndexTerm>application that called <Function>dced_server_start(&thinsp;)</Function>)
</Para>
</ListItem>
<ListItem>
<Para>Automatically when a remote procedure call comes in for the server
</Para>
</ListItem>
<ListItem>
<Para>After a failure of the server it can be restarted
</Para>
</ListItem>
</ItemizedList>
<Para><?sml-need 13>If <Literal>dced</Literal> did not start the server, it cannot control it.
Therefore, one of the first things your server should do is to verify that
<Literal>dced</Literal> started it by obtaining the configuration information, as in
the following:
</Para>
<InformalExample>
<Para><ProgramListing>server_t  *server_conf;
 . 
 .
 .
dce_server_inq_server(&amp;server_conf, &amp;status);
if(status != error_status_ok) { 
    .
    .    
    .
</ProgramListing></Para>
</InformalExample>
<Para>Additional routines, such as <Function>dce_server_inq_uuids(&thinsp;)</Function> and
<IndexTerm Id="ADGISG.INTRO.indx.84">
<Primary><Function>dce_server_inq_uuids()</Function></Primary>
</IndexTerm><Function>dce_server_inq_attr(&thinsp;)</Function>, are also useful for obtaining
<IndexTerm Id="ADGISG.INTRO.indx.85">
<Primary><Function>dce_server_inq_attr()</Function></Primary>
</IndexTerm>information from <Literal>dced</Literal> about the running server.
</Para>
<Para><?sml-need 5>Robust servers usually perform some or all of the following
initialization tasks:
<IndexTerm Id="ADGISG.INTRO.indx.86">
<Primary>server</Primary>
<Secondary>initialization of</Secondary>
</IndexTerm></Para>
<ItemizedList>
<ListItem>
<Para>Set up for serviceability which includes 
establishing message routing, 
debug levels, and
internal message tables.
</Para>
</ListItem>
<ListItem>
<Para>Set up the server's objects.
This includes creating and storing UUIDs for all necessary objects 
and object types, and grouping objects by type.
</Para>
</ListItem>
<ListItem>
<Para>Set up the security environment which includes
setting authentication information,
establishing the server's principal identity, and
creating ACL managers for each type of ACL object.
</Para>
</ListItem>
<ListItem>
<Para>Define manager entry point vectors (EPVs) for each set of 
interface operations.
</Para>
</ListItem>
<ListItem>
<Para>Register the server with DCE.  This includes the following:
registering the interfaces and the associated EPVs for the operations,
establishing the network protocol sequences and endpoints on which the
server will listen,
registering endpoints and other binding information in the endpoint
mapper service, 
and exporting binding information to the CDS namespace.
</Para>
</ListItem>
<ListItem>
<Para>Specify how the server will be multithreaded.
</Para>
</ListItem>
<ListItem>
<Para>Listen for incoming requests for remote procedure calls.
</Para>
</ListItem>
<ListItem>
<Para>Clean up the program state and environment affected by the server prior
to the server's termination.
</Para>
</ListItem>
</ItemizedList>
<!-- - -->
<Sect2 Id="ADGISG.INTRO.div.18">
<Title>Setting Up for Serviceability</Title>
<!-- - -->
<Para>Serviceability standardizes the server messages displayed or logged. 
<IndexTerm Id="ADGISG.INTRO.indx.87">
<Primary>serviceability</Primary>
</IndexTerm>It acts on a set of standard message catalogs and application-specific
<IndexTerm Id="ADGISG.INTRO.indx.88">
<Primary>message catalogs</Primary>
</IndexTerm>catalogs generated from the <Command>sams</Command> utility.  Some of the obvious
<IndexTerm Id="ADGISG.INTRO.indx.89">
<Primary><Command>sams</Command> utility</Primary>
</IndexTerm>advantages the serviceability facility gives servers over using the
standard C library routines such as <Function>printf(&thinsp;)</Function> and
<Function>fprintf(&thinsp;)</Function> include the following:
</Para>
<ItemizedList>
<ListItem>
<Para>Messages do not need to be hard-coded into applications
<!-- .LI-->
<!-- Internationalization issues such as locale and language can be automatic-->
</Para>
</ListItem>
<ListItem>
<Para>Message routing can be better controlled
</Para>
</ListItem>
</ItemizedList>
<Para>The following routine shows how a server can report a status
code returned from an API routine:
<IndexTerm Id="ADGISG.INTRO.indx.90">
<Primary><Function>dce_error_inq_text()</Function></Primary>
</IndexTerm><?sml-break><?sml-point-size 11>
<!--no-op:  13-->
</Para>
<InformalExample>
<Para><ProgramListing role="page-wide">void
print_server_error(
char *caller,           /* Routine that received the error.         */
error_status_t status)  /* Status we want to print the message for. */
{
    dce_error_string_t error_string;
    int print_status;

    dce_error_inq_text(status, error_string, &amp;print_status);
    dce_svc_printf(SERVER_ERROR_MSG, caller, error_string);
}
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<!--no-op:  14-->
<Para>The <Function>dce_error_inq_text(&thinsp;)</Function> routine looks up the status number
in a standard table and returns a string of text that describes the
error status.
The serviceability routine <Function>dce_svc_printf(&thinsp;)</Function> then displays the
<IndexTerm Id="ADGISG.INTRO.indx.91">
<Primary><Function>dce_svc_printf()</Function></Primary>
</IndexTerm>message, logs it to one or more files, or both.
</Para>
<Para>The following code shows some typical tasks when setting up the server
for serviceability:
<IndexTerm Id="ADGISG.INTRO.indx.92">
<Primary><Function>dce_svc_routing()</Function></Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.93">
<Primary><Function>dce_svc_register()</Function></Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.94">
<Primary><Function>dce_svc_debug_routing()</Function></Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.95">
<Primary><Function>dce_msg_define_msg_table()</Function></Primary>
</IndexTerm><?sml-break><?sml-point-size 11>
<!--no-op:  13-->
</Para>
<InformalExample>
<Para><ProgramListing role="page-wide"><?sml-need 12>/* The following calls set up default routing of serviceability     */
/*  messages.                                                       */
for (i = 0, route_error = FALSE; (i &lt; MAX_DEFAULT_ROUTES) 
					&amp;&amp; (!route_error); i++)
{
    printf("Setting default route %s ...&bsol;n", default_routes[i]);
    dce_svc_routing(default_routes[i], &amp;status);
    if (status != svc_s_ok)
    {
        print_server_error("dce_svc_routing(default_routes[i])", status);
    }
}

/* Get serviceability handle...                                     */
smp_svc_handle = dce_svc_register(smp_svc_table, 
			(idl_char*)"smp", &amp;status);
if (status != error_status_ok)
{
    print_server_error("dce_svc_register()", status);
    exit(1);
}

/* Set the default serviceability debug level and route...          */
dce_svc_debug_routing(default_debug_route, &amp;status);

/* Set up in-memory serviceability message table...                 */
dce_msg_define_msg_table(smp__table,
	sizeof smp__table / sizeof smp__table[0],
	&amp;status);
if (status != error_status_ok)
{
    print_server_error("dce_msg_define_msg_table()", status);
    exit(1);
}

dce_svc_printf(SIGN_ON_MSG);
    .
    .
    .
DCE_SVC_DEBUG((smp_svc_handle, 
	smp_s_server, 
	svc_c_debug4, 
	"Calling dce_server_sec_begin()");
</ProgramListing></Para>
</InformalExample>
<IndexTerm Id="ADGISG.INTRO.indx.96">
<Primary><Function>DCE_SVC_DEBUG()</Function></Primary>
</IndexTerm>
<!-- - -->
</Sect2>
<Sect2 Id="ADGISG.INTRO.div.19">
<Title>Setting Up the Server's Objects</Title>
<!-- - -->
<Para>The term <FirstTerm>object</FirstTerm> is a very general term that has meaning specific
<IndexTerm Id="ADGISG.INTRO.indx.97">
<Primary>object</Primary>
<Secondary>UUIDs</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.98">
<Primary>object</Primary>
<Secondary>server objects</Secondary>
</IndexTerm>to each application.  DCE uses object UUIDs to uniquely identify any object.  
The creation of object UUIDs, the determination of what (if anything)
constitutes an object for a server application, and the association of
these objects' UUIDs into collective types are all your application design
decisions.  
</Para>
<Para>Object UUIDs have a double use in the routing of RPCs, and you may at first
find this a bit confusing.
One use of object UUIDs is in the DCE RPC binding mechanism so that clients 
<IndexTerm Id="ADGISG.INTRO.indx.99">
<Primary>RPC</Primary>
<Secondary>binding mechanism</Secondary>
</IndexTerm>can distinguish between specific resources, and another use of object
UUIDs in routing involves grouping objects into types so that 
a server can support different implementations of the same interface.
(DCE servers also use type UUIDs to associate objects for each ACL manager.)
<IndexTerm Id="ADGISG.INTRO.indx.100">
<Primary>object</Primary>
<Secondary>and ACL managers</Secondary>
</IndexTerm></Para>
<Para>If an application makes use of object UUIDs in bindings, 
<IndexTerm Id="ADGISG.INTRO.indx.101">
<Primary>object</Primary>
<Secondary>UUIDs</Secondary>
<Tertiary>in bindings</Tertiary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.102">
<Primary>object</Primary>
<Secondary>UUIDs</Secondary>
<Tertiary>exporting</Tertiary>
</IndexTerm>it makes them accessible to clients by exporting them with its
bindings when a server registers with DCE.
</Para>
<Para>The following shows sample code to create UUIDs for server objects and how
to store them using the backing store API:
<IndexTerm Id="ADGISG.INTRO.indx.103">
<Primary>backing store</Primary>
<Secondary>API</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.104">
<Primary><Function>dce_db_store_by_uuid()</Function></Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.105">
<Primary><Function>dce_db_store_by_name()</Function></Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.106">
<Primary><Function>uuid_create()</Function></Primary>
</IndexTerm><?sml-break><?sml-point-size 11>
<!--no-op:  13-->
</Para>
<InformalExample>
<Para><ProgramListing role="page-wide"> .
 .
 .
/* A "well-known" residual name for the management "object":         */
#define MGMT_OBJ_NAME "server_mgmt"
/*                                                                   */
/* A residual name for a sample object:                              */
#define SAMPLE_OBJECT_NAME "sample_object"
 .
 .
 .
/* These are the backing store database handles:                     */
dce_db_handle_t db_acl, db_object, db_name;
 .
 .
 .
<?sml-need 4>/* A UUID for a sample object:                                       */
uuid_t sample_object_uuid = {/* 00415371-f29a-1d3d-b8c8-0000c0d4de56 */
    0x00415371, 0xf29a, 0x1d3d, 0xb8, 0xc8, 0x00, 0x00, 0xc0, 0xd4, 
							0xde, 0x56 };
<?sml-need 4>    .
    .
    .
    uuid_create(&amp;server_uuid, &amp;status);
    ..
    ..
    ..
    dce_db_store_by_uuid(db_object, object_uuid, (void *)&amp;sample_data, 
							status);
    if (*status != error_status_ok)
    {
	print_server_error("dce_db_store_by_uuid()", *status);
	return;
    }

    /* Finally, store the object UUID keyed by the object */
    /* ("residual") name...                               */

    dce_db_store_by_name(db_name, (char *)object_name, object_uuid, 
							status);
    .
    .
    .
</ProgramListing></Para>
</InformalExample>
<Para>Names are established so that applications can refer to objects in a
way other than through the cumbersome UUID.  Object UUIDs are
generated in the following two ways:
</Para>
<ItemizedList>
<ListItem>
<Para>The <Command>uuidgen -s</Command> command generates the C-structure form of a UUID
<IndexTerm Id="ADGISG.INTRO.indx.107">
<Primary>UUID</Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.108">
<Primary><Command>uuidgen</Command></Primary>
</IndexTerm>that can then be hard-coded into applications
</Para>
</ListItem>
<ListItem>
<Para>The <Function>uuid_create(&thinsp;)</Function> routine generates a UUID ``on-the-fly.''
<IndexTerm Id="ADGISG.INTRO.indx.109">
<Primary><Function>uuid_create()</Function></Primary>
</IndexTerm></Para>
</ListItem>
</ItemizedList>
<Para>After creating backing store headers (if desired) and opening the
backing store databases, UUIDs are stored by calling the
<Function>dce_db_store_by_uuid(&thinsp;)</Function> routine.
<IndexTerm Id="ADGISG.INTRO.indx.110">
<Primary><Function>dce_db_store_by_uuid()</Function></Primary>
</IndexTerm>To store names associated with the UUIDs, call the 
<Function>dce_db_store_by_name(&thinsp;)</Function> routine.
<IndexTerm Id="ADGISG.INTRO.indx.111">
<Primary><Function>dce_db_store_by_name()</Function></Primary>
</IndexTerm>
<!-- - -->
</Para>
<Sect3 Id="ADGISG.INTRO.div.20">
<Title>Object UUIDs in Bindings</Title>
<!-- - -->
<IndexTerm Id="ADGISG.INTRO.indx.112">
<Primary>object</Primary>
<Secondary>UUIDs</Secondary>
<Tertiary>in bindings</Tertiary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.113">
<Primary>object</Primary>
<Secondary>UUIDs</Secondary>
<Tertiary>exporting</Tertiary>
</IndexTerm>
<Para>Object UUIDs are often used in the DCE RPC binding mechanism. 
The details of RPC binding are explained in Section 1.5.5,
and more thoroughly in Chapter 4.
It all comes down to this: 
clients import only <Symbol Role="Variable">partial</Symbol> bindings from the namespace. 
<IndexTerm Id="ADGISG.INTRO.indx.114">
<Primary>binding</Primary>
<Secondary>partial</Secondary>
</IndexTerm>These will carry them only as far as the endpoint mapper service of the
<IndexTerm Id="ADGISG.INTRO.indx.115">
<Primary><Literal>dced</Literal></Primary>
<Secondary>endpoint mapper service</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.116">
<Primary>endpoint</Primary>
<Secondary>dynamic</Secondary>
</IndexTerm><Literal>dced</Literal> on the destination server's host; 
it is <Literal>dced</Literal>'s job to resolve the binding with a dynamic endpoint.
</Para>
<Para>This means that some registration of bindings must be done by a server with
<IndexTerm Id="ADGISG.INTRO.indx.117">
<Primary>binding</Primary>
<Secondary>registration of</Secondary>
</IndexTerm>the endpoint mapper.
The minimum two items that have to be registered are interface UUIDs and 
<IndexTerm Id="ADGISG.INTRO.indx.118">
<Primary>interface</Primary>
<Secondary>UUID</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.119">
<Primary>UUID</Primary>
<Secondary>interface</Secondary>
</IndexTerm>bindings (the latter of which contains the server's dynamically 
allocated endpoints).  With this information available,
<IndexTerm Id="ADGISG.INTRO.indx.120">
<Primary>endpoint</Primary>
<Secondary>dynamic</Secondary>
</IndexTerm>the endpoint mapper can inspect the incoming RPCs interface UUIDs, 
select one of the endpoints that was registered under them, 
and resolve the partial bindings. 
In addition, a server can register its object UUIDs with its endpoint mapper. 
This allows lookups of endpoints by object UUID rather than interface UUID; 
the advantage is that object UUIDs are much more specific than interface UUIDs,
which may be registered by multiple servers at the same host.
<IndexTerm Id="ADGISG.INTRO.indx.121">
<Primary>server</Primary>
<Secondary>multiple servers on one host</Secondary>
</IndexTerm>
<!-- - -->
</Para>
</Sect3>
<Sect3 Id="ADGISG.INTRO.div.21">
<Title>Making Object-UUID/Type-UUID Associations</Title>
<!-- - -->
<Para>To group together objects into types, the server makes an RPC library call
repeatedly to associate whatever objects it expects will appear in incoming
RPCs with a type UUID.  The association is made between each of the expected
<IndexTerm Id="ADGISG.INTRO.indx.122">
<Primary>type</Primary>
<Secondary>UUID</Secondary>
</IndexTerm>incoming object UUIDs and the type UUID.  The following is an example:
<IndexTerm Id="ADGISG.INTRO.indx.123">
<Primary><Function>rpc_object_set_type()</Function></Primary>
</IndexTerm></Para>
<InformalExample>
<Para><ProgramListing>rpc_object_set_type(<Symbol Role="Variable">obj_uuid</Symbol>, <Symbol Role="Variable">type_uuid</Symbol>, &amp;status);
</ProgramListing></Para>
</InformalExample>
<Para>A type UUID is nothing but a special kind of object UUID.  <Replaceable>Type</Replaceable>
in this context refers to a group of ordinary object UUIDs that have all been
associated with another specially generated common object UUID, which
can then be used to identify that group of objects collectively.
<IndexTerm Id="ADGISG.INTRO.indx.124">
<Primary>object</Primary>
</IndexTerm></Para>
<Para><?sml-need 4>The type UUIDs in turn are associated with the entry points of 
manager modules in the server when the server registers with DCE. 
An incoming RPC with a <Replaceable>typed</Replaceable> object UUID 
in its binding will be automatically
<IndexTerm Id="ADGISG.INTRO.indx.125">
<Primary>type</Primary>
<Secondary>manager</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.126">
<Primary>manager</Primary>
<Secondary>type</Secondary>
</IndexTerm>vectored by the server's runtime to the appropriate associated type
manager.
</Para>
<Para>Note that it is not necessary to call <Function>rpc_object_set_type(&thinsp;)</Function> at
all if you intend to register only one set of manager routine
implementations per interface.
<!-- - -->
</Para>
</Sect3>
<Sect3 Id="ADGISG.INTRO.div.22">
<Title>Summary of Mechanisms that Rely on Object UUIDs</Title>
<!-- - -->
<Para>The type UUIDs and the type manager vectoring mechanism have nothing to do 
with the use of the object UUIDs themselves as lookups for the host
endpoint mapper.  The type manager vectoring occurs after 
object UUID binding happens, at the server.
Note also that object UUID binding happens only once in an uninterrupted
client/server session; after the partial binding is completed, communications
<IndexTerm Id="ADGISG.INTRO.indx.127">
<Primary>binding</Primary>
<Secondary>partial</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.128">
<Primary>type</Primary>
<Secondary>manager</Secondary>
</IndexTerm>proceed directly between the client and server.  Type manager vectoring, on
the other hand, occurs every time an incoming RPC contains
an object UUID.
</Para>
<Para>The very different nature of the two mechanisms just discussed is somewhat
obscured by the order in which they are initialized in the steps in 
this chapter.  The following list shows the relevant server steps, 
with an indication in each instance to which mechanism they are related:
</Para>
<OrderedList>
<ListItem>
<Para>When setting up the server's objects, 
groups of object UUIDs are associated under type UUIDs in the RPC runtime
related to the type vectoring mechanism.
</Para>
</ListItem>
<ListItem>
<Para>When defining the manager EPVs, 
<IndexTerm Id="ADGISG.INTRO.indx.129">
<Primary>manager</Primary>
<Secondary>entry point vectors</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.130">
<Primary>EPV (entry point vector)</Primary>
</IndexTerm>each type UUID is associated with a manager EPV (in the RPC runtime)
related to the type vectoring mechanism.
</Para>
</ListItem>
<ListItem>
<Para>When registering the server,
object UUIDs and server endpoints are registered with the server's endpoint
mapper and the server bindings (containing the object UUIDs) are exported 
into the namespace.  These are related to the endpoint mapping mechanism.
<IndexTerm Id="ADGISG.INTRO.indx.131">
<Primary>endpoint</Primary>
<Secondary>mapping mechanism</Secondary>
</IndexTerm></Para>
</ListItem>
</OrderedList>
<!-- - -->
</Sect3>
</Sect2>
<Sect2 Id="ADGISG.INTRO.div.23">
<Title>Setting Up Security</Title>
<!-- - -->
<Para>To set up the security environment, the server makes the following DCE
library call:
<IndexTerm Id="ADGISG.INTRO.indx.132">
<Primary><Function>dce_server_sec_begin()</Function></Primary>
</IndexTerm><?sml-break></Para>
<InformalExample>
<Para><ProgramListing>dce_server_sec_begin(dce_server_c_login | \
dce_server_c_manage_key, &amp;status);
</ProgramListing></Para>
</InformalExample>
<Para>The flags in the first parameter represent the following security issues:
</Para>
<ItemizedList>
<ListItem>
<Para>Establish the server principal identity
</Para>
<Para><IndexTerm Id="ADGISG.INTRO.indx.133">
<Primary>server</Primary>
<Secondary>principal identity</Secondary>
<Tertiary>establishing</Tertiary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.134">
<Primary>login context</Primary>
</IndexTerm>When first invoked, a server process uses the login context of the user
who invoked it, until it assumes its own identity by accessing its
secret key, which is analogous to a user's password, and using it
<IndexTerm Id="ADGISG.INTRO.indx.135">
<Primary>keys</Primary>
<Secondary>secret key</Secondary>
</IndexTerm>to get its own login context.   
Of course, it is possible for a server to simply continue using its inherited
login context.  In that case, all it needs to do is use the security login 
routines to obtain its principal name and explicitly get its login context.
<IndexTerm Id="ADGISG.INTRO.indx.136">
<Primary>keys</Primary>
<Secondary>managing server key</Secondary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para>Manage the server key
</Para>
<Para>When a server has its own identity, it takes on responsibility for
the upkeep of its password using the security key management routines.
</Para>
</ListItem>
</ItemizedList>
<IndexTerm Id="ADGISG.INTRO.indx.137">
<Primary>authenticated RPC</Primary>
</IndexTerm>
<Para>The decision whether or not to use authenticated remote procedure calls
is something of a cooperative matter between the client and the server.
When the client calls <Function>rpc_binding_set_auth_info(&thinsp;)</Function>,
it registers its preferences about the same things.
The client's and server's choices are not required to agree in order for the
client to successfully reach the server.  If the client's authentication and 
authorization choices do not agree with what the server expects, 
<IndexTerm Id="ADGISG.INTRO.indx.138">
<Primary>authorization</Primary>
</IndexTerm>it is up to the server to decide whether or not to go ahead with the
operations, and how far to cooperate with client requests.
</Para>
<Para>To control access to the server's objects, ACL
<IndexTerm Id="ADGISG.INTRO.indx.139">
<Primary>access control list (ACL)</Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.140">
<Primary>ACL</Primary>
<Secondary>manager</Secondary>
</IndexTerm>managers are also set up.
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.INTRO.div.24">
<Title>Defining the Manager Entry Point Vectors for Each Set of Operations</Title>
<!-- - -->
<Para><Replaceable>Manager</Replaceable> is the DCE term for the part of a server that actually implements
a set of interface operations (the remote procedures), as distinguished 
from the more or less generic server initialization code described here.
(see <Filename>sample_manager.c</Filename> for an example of manager code).
A manager EPV is the data structure in which
<IndexTerm Id="ADGISG.INTRO.indx.141">
<Primary>entry point vector</Primary>
<Secondary>manager</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.142">
<Primary>manager</Primary>
<Secondary>entry point vectors</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.143">
<Primary>entry point vector</Primary>
<Secondary>addresses in</Secondary>
</IndexTerm>is recorded the entry addresses of the application routines that implement the
server's operations, as offered through an interface.  The server's stub code
uses the EPV to dispatch incoming RPCs to the requested operations. 
For each interface the server supports, a default manager EPV is generated
automatically by the IDL compiler.
In order for the RPC runtime to properly dispatch remote procedure calls
to the correct procedure, the server initialization code must declare 
the default EPVs and then register them with the runtime, as shown in
the following example:
</Para>
<InformalExample>
<Para><ProgramListing>extern rdaclif_v1_0_epv_t dce_acl_v1_0_epv;
extern sample_bind_v1_0_epv_t sample_bind_epv;
</ProgramListing></Para>
</InformalExample>
<Para>We will later describe registering the EPVs with the RPC runtime.
</Para>
<Para>If more than one version of the same interface is to be supported by the same
server, another EPV is needed for each additional interface version. 
Interface version numbers are specified by the <Literal>version</Literal> attribute in the
<IndexTerm Id="ADGISG.INTRO.indx.144">
<Primary>interface</Primary>
<Secondary>version number</Secondary>
</IndexTerm><Filename>.idl</Filename> file. 
Additional EPVs are also required if the application implements the procedures
in more than one way.  For example, some applications invoke the same remote
procedure to operate on different types of objects.
<IndexTerm Id="ADGISG.INTRO.indx.145">
<Primary>entry point vector</Primary>
<Secondary>multiple</Secondary>
</IndexTerm>Different objects would likely require different implementations, 
and thus more than one manager procedure would be coded.
The type manager RPC runtime mechanism, properly utilized,
allows a server to declare multiple EPVs under the same interface, 
and to have the RPC runtime vector (direct) the incoming remote calls to the
correct implementation code. 
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.INTRO.div.25">
<Title>Registering the Server</Title>
<!-- - -->
<IndexTerm Id="ADGISG.INTRO.indx.146">
<Primary>server</Primary>
<Secondary>registering</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.147">
<Primary><Function>dce_server_register()</Function></Primary>
</IndexTerm>
<Para>To register the server with DCE, the server calls the following:
</Para>
<InformalExample>
<Para><ProgramListing>dce_server_register(    
    dce_server_c_ns_export,   /* flag says register */
    server_conf,              /* server with CDS    */
    &amp;register_data,
    &amp;server_handle,
    &amp;status
);
</ProgramListing></Para>
</InformalExample>
<Para>The <Function>dce_server_register(&thinsp;)</Function> routine affects a number of
components and services in DCE including the RPC runtime, 
the local endpoint mapper service, 
and if the <Literal>dce_server_c_ns_export</Literal> flag is set, even the CDS namespace.
The <Literal>server_conf</Literal> structure is obtained with a call to the
<Function>dce_server_inq_server(&thinsp;)</Function> routine and represents the
configuration <Literal>dced</Literal> used to start the server.
This contains information needed to register the server too.
The <Literal>register_data</Literal> structure contains data about the server's 
<IndexTerm Id="ADGISG.INTRO.indx.148">
<Primary><Literal>register_data</Literal> structure</Primary>
</IndexTerm>interfaces, entry point vectors, and type UUIDs.
</Para>
<Para>The following subsections describe the details about what happens when
you register a server.
<!-- - -->
</Para>
<Sect3 Id="ADGISG.INTRO.div.26">
<Title>Registering the Interface, Type UUID, and EPV with RPC Runtime</Title>
<!-- - -->
<IndexTerm Id="ADGISG.INTRO.indx.149">
<Primary>UUID</Primary>
<Secondary>type</Secondary>
<Tertiary>registering</Tertiary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.150">
<Primary>UUID</Primary>
<Secondary>interface</Secondary>
<Tertiary>registering</Tertiary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.151">
<Primary>entry point vector</Primary>
<Secondary>registering</Secondary>
</IndexTerm>
<Para>Earlier we described how to establish an EPV for
each set of operations provided by interfaces.
Remember that an EPV is a list of pointers to procedures.
The first affect of registering the server is to register the
services offered (represented by IDL interfaces) and the associated
EPVs with the RPC runtime.
Registering interfaces with their associated EPVs allow the RPC
runtime to use the EPVs to direct an incoming remote procedure call to
the correct procedure implemented in the server's manager code.
</Para>
<Para><?sml-need 6>We also described earlier the type manager mechanism which uses a type
UUID to group together object UUIDs.  With this mechanism,
a different EPV can be associated with each type UUID so that different 
manager code can be called, depending on an object's type UUID.
After these EPVs are registered with the runtime, 
incoming RPC binding that contain a typed object can be routed by the
runtime to the correct manager code.
</Para>
<Para>The data structure the server uses to establish its services is of
type <StructName Role="typedef">dce_server_register_data_t</StructName>.
This data structure is initialized prior to the
<Function>dce_server_register(&thinsp;)</Function> routine call as in the following example:
<IndexTerm Id="ADGISG.INTRO.indx.152">
<Primary><StructName Role="typedef">dce_server_register_data_t</StructName> structure</Primary>
</IndexTerm></Para>
<InformalExample>
<Para><ProgramListing>dce_server_register_data_t  register_data[2];
.
.
. 
register_data.ifhandle[0]  = rdaclif_v1_0_s_ifspec;
register_data.epv[0]       = NULL;   /* use the default epv */
register_data[0].num_types = 0;         
register_data[0].types     = NULL;
register_data.ifhandle[1]  = sample_bind_v1_0_s_ifspec;
register_data.epv[1]       = NULL;   /* use the default epv */
register_data[1].num_types = 0;
register_data[1].types     = NULL;
</ProgramListing></Para>
</InformalExample>
<Para>The <Function>dce_server_register(&thinsp;)</Function> routine usually establishes all the services
for a server at once.  This is a reasonable approach for most
applications, but some interfaces for services may have dependencies
on the order in which they are enabled.  After the server calls
<Function>dce_server_register(&thinsp;)</Function>, it can use a series of calls to
<Function>dce_server_disable_service(&thinsp;)</Function> and 
<Function>dce_server_enable_service(&thinsp;)</Function>
<IndexTerm Id="ADGISG.INTRO.indx.153">
<Primary><Function>dce_server_disable_service()</Function></Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.154">
<Primary><Function>dce_server_enable_service()</Function></Primary>
</IndexTerm>to disable and then later reenable any interface offered by the server.
<!-- - -->
</Para>
</Sect3>
<Sect3 Id="ADGISG.INTRO.div.27">
<Title>Telling RPC Runtime What Protocol Sequences to Use</Title>
<!-- - -->
<IndexTerm Id="ADGISG.INTRO.indx.155">
<Primary>protocol sequences</Primary>
<Secondary>RPC</Secondary>
<Tertiary>requesting</Tertiary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.156">
<Primary>endpoint</Primary>
<Secondary>dynamic</Secondary>
</IndexTerm>
<Para>The second thing registering the server does is it obtains a set of
endpoints and associates them with the desired protocol sequences.  
Endpoints are the host's address
numbers on which the server can receive incoming calls.  
This begins the process of actually setting up the
information that the server's clients will need in order to bind to it. 
</Para>
<Para><?sml-need 3>The endpoints are usually dynamically generated each time the server starts.
However, some applications may use well-known endpoints that are the
<IndexTerm Id="ADGISG.INTRO.indx.157">
<Primary>endpoint</Primary>
<Secondary>well-known</Secondary>
</IndexTerm>same every time the server starts.
If well-known endpoints are used, they are typically defined in the
interface definition with the <Literal>endpoint</Literal> attribute.
</Para>
<Para>In the default case, all valid protocol sequences are used when the
<Function>dce_server_register(&thinsp;)</Function> routine is called. 
The <Literal>dce_server_c_no_protseq</Literal> flag can be passed in the first argument
to the routine in cases where dynamic assignment of endpoints is not
desired; for example, when well-known endpoints (specified in the
IDL definition) are being used.
<!-- However, if you use-->
<!-- the \*Ldce_server_c_no_protseq\*O flag in the first argument to the-->
<!-- routine, you can later establish a specific protocol sequence with the-->
<!-- \*Ldce_server_use_protseq(\|)\*O routine.-->
<!-- .P-->
<!-- \*L<<REVIEWERS: IS THIS RIGHT?>>\*O-->
<!-- No- protseq first - Then register.  The no_protseq flag is for special cases-->
<!-- like well-known ep's in the subset of available protseqs.-->
<!-- - -->
</Para>
</Sect3>
<Sect3 Id="ADGISG.INTRO.div.28">
<Title>Registering the Binding Information with the Endpoint Mapper Service</Title>
<!-- - -->
<IndexTerm Id="ADGISG.INTRO.indx.158">
<Primary>binding</Primary>
<Secondary>registration of</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.159">
<Primary>endpoint</Primary>
<Secondary>mapper service</Secondary>
</IndexTerm>
<Para>After server registration obtains the endpoints, the endpoints,
protocol sequences, and object UUIDs are
registered with the endpoint mapper service of the local host's <Literal>dced</Literal>.
</Para>
<Para>Typically the server has received a certain number of
endpoints dynamically allocated on its host machine. 
However, when prospective clients import binding information from the
namespace, they get partial bindings.
<IndexTerm Id="ADGISG.INTRO.indx.160">
<Primary>binding</Primary>
<Secondary>partial</Secondary>
</IndexTerm>When they first try to contact their server, 
the partial binding will get them only as far as the server's endpoint
mapper service.
<IndexTerm Id="ADGISG.INTRO.indx.161">
<Primary>endpoint</Primary>
<Secondary>registering</Secondary>
</IndexTerm>The purpose of registering endpoints is to 
let the endpoint mapper know what endpoints belong to the server so that
it can fill in the partial bindings as they arrive and route the incoming
remote calls on their proper ways.  Subsequent remote calls executed with
the same bindings will go straight to the server, since the bindings are
now complete.
</Para>
<Para>The purpose of registering endpoints together with object UUIDs is to
account for all possible incoming object UUIDs (that is, object UUIDs that
could appear in incoming partial bindings arriving at the endpoint mapper),
and to associate with each of them one of the server's allocated endpoints.
Then the endpoint mapper can simply look up the object UUID, find an endpoint,
insert it into the binding, and send the RPC on to its destination.
<IndexTerm Id="ADGISG.INTRO.indx.162">
<Primary>interface</Primary>
<Secondary>UUID</Secondary>
<Tertiary>and incoming RPCs</Tertiary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.163">
<Primary>UUID</Primary>
<Secondary>object UUIDs</Secondary>
<Tertiary>and interface UUIDs</Tertiary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.164">
<Primary>interface</Primary>
<Secondary>generic</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.165">
<Primary>server instances</Primary>
<Secondary>distinguishing</Secondary>
</IndexTerm></Para>
<Para><?sml-need 13>An incoming RPC <Symbol Role="Variable">always</Symbol> has an interface UUID associated with it;
therefore, if a server registers all of its endpoints with the interface
it is offering, this will usually be sufficient for the endpoint mapper to
send the incoming requests to one of the servers that offer the desired
interface, even if there is more than one such server active on the machine.
However, if the application is designed in such a way that the binding
operation should not be generalized to the interface but must be made more
specific (in other words, this server's clients should always bind <Symbol Role="Variable">to
this server and no other</Symbol>, even if some other server happens to offer
the same interface), then object UUIDs must be used to accomplish this.
<Replaceable>Generic</Replaceable> interfaces offered by an application (such as the remote ACL
or the DCE serviceability interface) require an object UUID in order to
distinguish the application's <Replaceable>instance</Replaceable> of them; unique interfaces,
however, do not require an object UUID.
<IndexTerm Id="ADGISG.INTRO.indx.166">
<Primary>UUID</Primary>
<Secondary>object UUIDs</Secondary>
<Tertiary>and endpoint mapping</Tertiary>
</IndexTerm></Para>
<Para>Of course, the server's interface UUID must also be included in each
object UUID/endpoint mapping, since no RPC will pass the endpoint mapper
if it does not have a matching interface UUID for its destination server.
Therefore, the endpoint mapper takes either two or three types of item
to be registered, namely
</Para>
<ItemizedList>
<ListItem>
<Para>Endpoints
</Para>
</ListItem>
<ListItem>
<Para>Interface UUID
</Para>
</ListItem>
<ListItem>
<Para>Object UUIDs (optionally)
</Para>
</ListItem>
</ItemizedList>
<Para>It then generates a cross-product table of all possible combinations of
all values of the items.  This allows it to find a valid endpoint for every
possible valid object UUID/interface UUID combination.
</Para>
<Para>The endpoint mapper is the first point of decision for an incoming RPC
with a partial binding.  The mapper makes its decision <Symbol Role="Variable">solely</Symbol> on the
basis of the contents of its endpoint map.  The object/type and manager EPV
registrations that were done earlier have no effect on the endpoint mapper. 
Only after a client request arrives at the server
does the server's runtime routines dispatch the request among multiple
managers, if type managers have been registered by the server. 
The endpoint mapper knows nothing about registered object types. 
<?sml-break><?sml-need 12>
<!-- - -->
</Para>
</Sect3>
<Sect3 Id="ADGISG.INTRO.div.29">
<Title>Exporting the Binding Information to the Namespace</Title>
<!-- - -->
<IndexTerm Id="ADGISG.INTRO.indx.167">
<Primary>binding</Primary>
<Secondary>exporting</Secondary>
</IndexTerm>
<Para>The final task of server registration (if the
<Literal>dce_server_c_ns_export</Literal> flag is set in the
<Function>dce_server_register(&thinsp;)</Function> call) is
<IndexTerm Id="ADGISG.INTRO.indx.168">
<Primary><Function>dce_server_register()</Function></Primary>
</IndexTerm>to export the binding information to the namespace.  In the usual case,
where the server's endpoints have been dynamically allocated to it, the
endpoint information will not be included in the exported handles.  Instead,
this information will be filled in by the host's endpoint mapper as the
partially bound handles arrive at the host in incoming RPCs. 
<IndexTerm Id="ADGISG.INTRO.indx.169">
<Primary>binding</Primary>
<Secondary>partial</Secondary>
</IndexTerm>However, if the endpoints are well-known, they will be
included in the exported binding handles, and clients will thus import fully
bound handles.
</Para>
<Para>If you wish, you can use the lower level RPC routine
<Function>rpc_ns_binding_export(&thinsp;)</Function> to export individual services to the
<IndexTerm Id="ADGISG.INTRO.indx.170">
<Primary><Function>rpc_ns_binding_export()</Function></Primary>
</IndexTerm>namespace, but in this case you should first be sure the flag
<Literal>dce_server_c_ns_export</Literal> is not set in the
<Function>dce_server_register(&thinsp;)</Function> routine.
<IndexTerm Id="ADGISG.INTRO.indx.171">
<Primary>binding</Primary>
<Secondary>handle</Secondary>
</IndexTerm></Para>
<Para>As a final note, a client must have a binding handle in order to reach
a server, but it does not have to get the handle from the name service. 
However, the name service is the recommended way for clients and
servers to find each other because it is a convenient and easy to use
service built into DCE.
<!-- - -->
</Para>
</Sect3>
</Sect2>
<Sect2 Id="ADGISG.INTRO.div.30">
<Title>Specifying Multithreadedness</Title>
<!-- - -->
<Para>The application may also spawn an additional thread for a signal handler.
An example follows:
<IndexTerm Id="ADGISG.INTRO.indx.172">
<Primary><Function>pthread_create()</Function></Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.173">
<Primary><Function>dce_svc_printf()</Function></Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.174">
<Primary>threads</Primary>
<Secondary>RPC</Secondary>
<Tertiary>multiple</Tertiary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.175">
<Primary>multithreadedness</Primary>
<Secondary>in servers</Secondary>
<Tertiary>specifying</Tertiary>
</IndexTerm></Para>
<InformalExample>
<Para><ProgramListing>if (pthread_create(&amp;sigcatcher,
        pthread_attr_default,
        (pthread_startroutine_t)signal_handler,
        (void*)0))
{
    dce_svc_printf(NO_SIGNAL_CATCHER_MSG);
    exit(1);
}
</ProgramListing></Para>
</InformalExample>
<Para><?sml-need 9>The <Symbol Role="Variable">max_calls_exec</Symbol> parameter to the
<Function>rpc_server_listen(&thinsp;)</Function> routine
<IndexTerm Id="ADGISG.INTRO.indx.176">
<Primary><Function>rpc_server_listen()</Function></Primary>
<Secondary>and <Replaceable>max_calls_exec</Replaceable> parameter</Secondary>
</IndexTerm>specifies the number of operations that the server can perform concurrently
in response to client requests.  The <Symbol Role="Variable">max_calls_exec</Symbol> parameter is also used
to derive the size of a buffer (the call request buffer) for incoming client
<IndexTerm Id="ADGISG.INTRO.indx.177">
<Primary>buffer</Primary>
<Secondary>incoming RPC call request</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.178">
<Primary>RPC</Primary>
<Secondary>incoming calls</Secondary>
<Tertiary>specifying concurrency of</Tertiary>
</IndexTerm>requests that cannot be immediately executed. <Symbol Role="Variable">max_calls_exec</Symbol> specifies
the upper limit for the number of RPC threads that will be spawned by the
RPC runtime to handle incoming remote procedure calls.  Thus, an important
side effect of <Function>rpc_server_listen(&thinsp;)</Function>, when the specified concurrency
<IndexTerm Id="ADGISG.INTRO.indx.179">
<Primary><Function>rpc_server_listen()</Function></Primary>
</IndexTerm>is greater than 1, is to create multiple threads of execution in the server.
</Para>
<Para>The threads are automatically spawned to handle whatever operation is
requested by the client.  If the maximum number of manager threads is already
<IndexTerm Id="ADGISG.INTRO.indx.180">
<Primary>threads</Primary>
<Secondary>manager</Secondary>
</IndexTerm>active and more incoming calls arrive, the RPC runtime buffers them in a call
request buffer.   The size of the call request buffer depends on the
<Symbol Role="Variable">max_calls_exec</Symbol> parameter; the larger the parameter, the bigger
the buffer.  Incoming calls beyond the call 
request buffer capacity are rejected (with an error code) by the RPC runtime.
</Para>
<Para>Although the execution threads are automatically managed by the
RPC runtime, the developer is responsible for coding the manager routines
according to thread-safe guidelines so that the threads will execute properly.
<IndexTerm Id="ADGISG.INTRO.indx.181">
<Primary>threadsafeness</Primary>
</IndexTerm>For further information on thread-safe programming practices, 
see Chapter 2.
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.INTRO.div.31">
<Title>Listening for Incoming Service Requests</Title>
<!-- - -->
<Para>In order to begin listening for incoming remote procedure calls,
the server calls the following RPC library routine:
<IndexTerm Id="ADGISG.INTRO.indx.182">
<Primary><Function>rpc_server_listen()</Function></Primary>
</IndexTerm></Para>
<InformalExample>
<Para><ProgramListing>rpc_server_listen(<Symbol Role="Variable">max_calls_exec</Symbol>, &amp;status);
</ProgramListing></Para>
</InformalExample>
<Para>The <Replaceable>max_calls_exec</Replaceable> parameter specifies the number of concurrent
remote procedure calls the server can execute.
This call normally begins a ``semi-infinite'' loop, execution of which is
terminated only by one of the following events:
</Para>
<ItemizedList>
<?sml-need 6>
<ListItem>
<Para>One of the server's manager routines calls
<Function>rpc_mgmt_stop_server_listening(&thinsp;)</Function>
</Para>
</ListItem>
<ListItem>
<Para>One of the server's clients makes a remote call using the routine
<Function>rpc_mgmt_stop_server_listening(&thinsp;)</Function>. (Note that the server can intercept
<IndexTerm Id="ADGISG.INTRO.indx.183">
<Primary><Function>rpc_mgmt_stop_server_listening()</Function></Primary>
</IndexTerm>such a remote call and either allow or prevent it by installing a
function with <Function>rpc_mgmt_set_authorization_fn(&thinsp;)</Function>).
<IndexTerm Id="ADGISG.INTRO.indx.184">
<Primary><Function>rpc_mgmt_set_authorization_fn()</Function></Primary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para>A management application makes a remote procedure call using the
routine <Function>dced_server_stop(&thinsp;)</Function>
<IndexTerm Id="ADGISG.INTRO.indx.185">
<Primary><Function>dced_server_stop()</Function></Primary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para>An administrator (or administrative script) uses the <Command>dcecp server
<IndexTerm Id="ADGISG.INTRO.indx.186">
<Primary><Literal>dcecp</Literal></Primary>
<Secondary><Command>server stop</Command></Secondary>
</IndexTerm>stop</Command> <Replaceable>server_name</Replaceable> operation
</Para>
</ListItem>
<ListItem>
<Para>A signal or exception occurs
</Para>
</ListItem>
</ItemizedList>
<Para>From the point of view of the server, the call to
<Function>rpc_server_listen(&thinsp;)</Function>
blocks until the <Function>rpc_mgmt_stop_server_listening(&thinsp;)</Function> routine is called.
When this happens, the RPC runtime stops accepting incoming
client requests to the server, and when all the currently executing operations
are completed, the call to <Function>rpc_server_listen(&thinsp;)</Function> returns.
</Para>
<Para>Server operations can also be terminated by an exception or signal. DCE
Threads defines all exceptions as <Replaceable>terminating</Replaceable>, which means that execution
<IndexTerm Id="ADGISG.INTRO.indx.187">
<Primary>exceptions</Primary>
<Secondary>terminating</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.188">
<Primary>exceptions</Primary>
<Secondary>signals and</Secondary>
</IndexTerm>must be caught by an exception handler (if one exists) and then be resumed
<IndexTerm Id="ADGISG.INTRO.indx.189">
<Primary>exception handlers</Primary>
</IndexTerm>there, or the process will be terminated.  Certain signals are defined by DCE
Threads as exceptions, which means that these signals have the same general
characteristics as exceptions.
For more information on the DCE Threads exception handling interface, see
<IndexTerm Id="ADGISG.INTRO.indx.190">
<Primary>exceptions</Primary>
<Secondary>handling interface</Secondary>
</IndexTerm>Chapter 2.
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.INTRO.div.32">
<Title>Cleaning Up Code When the Server Terminates</Title>
<!-- - -->
<Para>If (or when) the server terminates execution, it should undo its initialization
that affected other facilities and services of DCE.  Facilities affected include
the CDS namespace, the endpoint mapper service, and backing store databases such
as those used for ACL managers.  For the most part, API routines that cause these
kinds of effects have a corresponding API routine to undo them.  The following
sections describe the series of routines typically used to clean up after an
application.
<!-- - -->
</Para>
<Sect3 Id="ADGISG.INTRO.div.33">
<Title>Unregistering the Server</Title>
<!-- - -->
<Para>Two important aspects of registering the server is that it registered
the interfaces and EPVs with the RPC runtime, and it established the
endpoints (or addresses) on which the server listened for requests.  
If the endpoint map contains <Replaceable>stale</Replaceable> data,
<IndexTerm Id="ADGISG.INTRO.indx.191">
<Primary>endpoint</Primary>
<Secondary>stale data in map</Secondary>
</IndexTerm>it can create for a client a fully bound binding that is not valid.
Even though the endpoint mapper service does its own housecleaning
periodically, there is the possibility that these invalid bindings
could be created and used.  
Therefore, it is a good idea to call the following routine:
<IndexTerm Id="ADGISG.INTRO.indx.192">
<Primary><Function>dce_server_unregister()</Function></Primary>
</IndexTerm></Para>
<InformalExample>
<Para><ProgramListing>dce_server_unregister(<Symbol Role="Variable">server_handle</Symbol>, &amp;status);
</ProgramListing></Para>
</InformalExample>
<Para>In addition to unregistering the server's address information from the local
<IndexTerm Id="ADGISG.INTRO.indx.193">
<Primary>unregistering server address information</Primary>
</IndexTerm>endpoint mapper's database, this routine unregisters all the services
(interfaces and EPVs) from the RPC runtime as well.  
</Para>
<Para>If your application requires a partial shutdown or a particular order
to the shutdown of services, you can use more specific routines such
as <Function>rpc_ep_unregister(&thinsp;)</Function> and
<Function>dce_server_disable_service(&thinsp;)</Function>.
<IndexTerm Id="ADGISG.INTRO.indx.194">
<Primary><Function>rpc_ep_unregister()</Function></Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.195">
<Primary><Function>dce_server_disable_service()</Function></Primary>
</IndexTerm>
<!-- - -->
</Para>
</Sect3>
<Sect3 Id="ADGISG.INTRO.div.34">
<Title>Unexporting from the Namespace</Title>
<!-- - -->
<Para>If the server is going to be out of service for an extended period,
it should unexport any information it previously caused to be placed
<IndexTerm Id="ADGISG.INTRO.indx.196">
<Primary>unexporting server namespace information</Primary>
</IndexTerm>in the namespace.
This will prevent future prospective clients from being misled into
attempting to reach the server when it does not exist,
and also will help to conserve resources in the namespace.
</Para>
<Para>Unexporting is automatic when
<Function>dce_server_unregister(&thinsp;)</Function> is called
if the <Literal>dce_server_c_ns_export</Literal> flag was set when the
corresponding <Function>dce_server_register(&thinsp;)</Function> was called.
For more specific control, an individual service previously exported
is removed from the namespace with the following routine:
<IndexTerm Id="ADGISG.INTRO.indx.197">
<Primary>namespace</Primary>
<Secondary>unexporting information from</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.198">
<Primary><Function>rpc_ns_binding_unexport()</Function></Primary>
</IndexTerm></Para>
<InformalExample>
<Para><ProgramListing>rpc_ns_binding_unexport(<Symbol Role="Variable">entry_name_syntax</Symbol>, \
<Symbol Role="Variable">entry_name</Symbol>, <Symbol Role="Variable">if_handle</Symbol>,  <Symbol Role="Variable">obj_uuid_vector</Symbol>, &amp;status);
</ProgramListing></Para>
</InformalExample>
<Para>The CDS namespace is designed to store location data for extended
periods of time.
<!-- - -->
</Para>
</Sect3>
<Sect3 Id="ADGISG.INTRO.div.35">
<Title>Cleaning Up Security Information</Title>
<!-- - -->
<Para>A call to the <Function>dce_server_sec_begin(&thinsp;)</Function> routine should have a
<IndexTerm Id="ADGISG.INTRO.indx.199">
<Primary><Function>dce_server_sec_begin()</Function></Primary>
</IndexTerm>corresponding call to the <Function>dce_server_sec_done(&thinsp;)</Function> routine to
<IndexTerm Id="ADGISG.INTRO.indx.200">
<Primary><Function>dce_server_sec_done()</Function></Primary>
</IndexTerm>release resources allocated.  In addition, your code should close any
backing store databases used for ACL management.
<!-- - -->
</Para>
</Sect3>
</Sect2>
</Sect1>
<Sect1 Id="ADGISG.INTRO.div.36">
<Title>The Client Binding and RPC Invocation</Title>
<!-- - -->
<Para>To use RPC, a client must first establish a binding to the server.
The following steps cover bindings and binding handles.  
</Para>
<Para>The programmer designing clients must decide whether or not to use
threads, and should have an understanding of multithreaded clients.
DCE provides a set of tools for multithreaded programming; 
these are described in Chapter 2.
<!-- - -->
</Para>
<Sect2 Id="ADGISG.INTRO.div.37">
<Title>Importing the Binding Information from the Namespace</Title>
<!-- - -->
<IndexTerm Id="ADGISG.INTRO.indx.201">
<Primary>binding</Primary>
<Secondary>choices of</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.202">
<Primary>binding</Primary>
<Secondary>methods</Secondary>
</IndexTerm>
<Para>The first important thing that the client does is to acquire a binding to
the server it wants to request services from.  From the client's point of
view, there are several binding choices to be made.
</Para>
<Para>The first choice is in regard to the binding method to be used; however,
this is determined and implemented as part of
the development coding process (the <Filename>.acf</Filename> file).  The binding method
chosen has an effect both on what the client has to do in the present step
to acquire bindings, and subsequently on what it must do to maintain them.
<IndexTerm Id="ADGISG.INTRO.indx.203">
<Primary>binding</Primary>
<Secondary>explicit method</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.204">
<Primary>binding</Primary>
<Secondary>implicit method</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.205">
<Primary>binding</Primary>
<Secondary>automatic method</Secondary>
</IndexTerm>In this step, it will be assumed that either the explicit or implicit method
was chosen.  If auto-binding were chosen, there would be no need for a
discussion, since the client would then have nothing to do.
<!-- - -->
</Para>
<Sect3 Id="ADGISG.INTRO.div.38">
<Title>Getting a Handle</Title>
<!-- - -->
<IndexTerm Id="ADGISG.INTRO.indx.206">
<Primary>binding</Primary>
<Secondary>acquiring a handle</Secondary>
</IndexTerm>
<Para>The second choice involves how to get a binding handle. Again, this is a
choice that is at least partially dependent on decisions already made.
The client can always generate a binding handle for itself; the problem is
where to get the information that belongs in it.  There are two general
solutions, as follows:
<IndexTerm Id="ADGISG.INTRO.indx.207">
<Primary>namespace</Primary>
<Secondary>importing binding handles from</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.208">
<Primary>binding</Primary>
<Secondary>string</Secondary>
<Tertiary>converting binding information into</Tertiary>
</IndexTerm></Para>
<ItemizedList>
<ListItem>
<Para>The client imports from the namespace binding handles that already contain
the necessary information, or
</Para>
</ListItem>
<ListItem>
<Para>The client receives the information in string form from user input, from a
file, from another server, or from any other source.  It then converts the
string into a binding by calling
<Function>rpc_binding_from_string_binding(&thinsp;)</Function>.
<IndexTerm Id="ADGISG.INTRO.indx.209">
<Primary><Function>rpc_binding_from_string_binding()</Function></Primary>
</IndexTerm></Para>
</ListItem>
</ItemizedList>
<Para>The normal way for a server to make its location known to clients is to export
<IndexTerm Id="ADGISG.INTRO.indx.210">
<Primary>namespace</Primary>
<Secondary>exporting binding information into</Secondary>
</IndexTerm>its binding information into the namespace.  The client can then call the 
following RPC name service library routines to import one or more bindings 
from the specified namespace entry: 
<IndexTerm Id="ADGISG.INTRO.indx.211">
<Primary><Function>rpc_ns_binding_import_begin()</Function></Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.212">
<Primary><Function>rpc_ns_binding_import_next()</Function></Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.213">
<Primary><Function>rpc_ns_binding_import_done()</Function></Primary>
</IndexTerm><?sml-break><?sml-point-size 11>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing>rpc_ns_binding_import_begin(<Symbol Role="Variable">entry_name_syntax</Symbol>, <Symbol Role="Variable">entry_name</Symbol>, \
<Symbol Role="Variable">if_handle</Symbol>, <Symbol Role="Variable">obj_uuid</Symbol>, &amp;import_context, &amp;status);
 
rpc_ns_binding_import_next(<Symbol Role="Variable">import_context</Symbol>, &amp;binding_handle, \
&amp;status);
 
rpc_ns_binding_import_done(<Symbol Role="Variable">import_context</Symbol>, &amp;status);
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<!--no-op:  14-->
<Para>The name service sees to it that only compatible bindings exported under the
<IndexTerm Id="ADGISG.INTRO.indx.214">
<Primary>binding</Primary>
<Secondary>importing compatible</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.215">
<Primary>object</Primary>
<Secondary>UUIDs</Secondary>
<Tertiary>importing binding handles</Tertiary>
</IndexTerm>specified interface, with the optionally specified object UUID, will be
returned to the client. (Note that the interface specification is <Symbol Role="Variable">not</Symbol>
contained in the binding, although it is exported to the namespace entry
where it is used by the name service for matching entries to prospective
importers.) The object UUID specified by <Symbol Role="Variable">obj_uuid</Symbol> is contained in the
binding, if it is present.  This is the object UUID that was (optionally)
registered under a type UUID in an earlier step.  Even if <Symbol Role="Variable">obj_uuid</Symbol>
is not specified in the import call, it will be returned in the 
binding handle(s) if it was exported by the server.
<!-- - -->
</Para>
</Sect3>
<Sect3 Id="ADGISG.INTRO.div.39">
<Title>Determing the Entry Name</Title>
<!-- - -->
<IndexTerm Id="ADGISG.INTRO.indx.216">
<Primary>namespace</Primary>
<Secondary>entry name in</Secondary>
<Tertiary>importing from</Tertiary>
</IndexTerm>
<Para>To determine how the client knows the entry name to import from, the
simplest method is to have the user type it in on the command line.
<!-- - -->
</Para>
</Sect3>
<Sect3 Id="ADGISG.INTRO.div.40">
<Title>Binding Compatibility</Title>
<!-- - -->
<IndexTerm Id="ADGISG.INTRO.indx.217">
<Primary>binding</Primary>
<Secondary>compatibility</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.218">
<Primary>protocol sequences</Primary>
<Secondary>RPC runtime and</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.219">
<Primary>protocol sequences</Primary>
<Secondary>and binding compatibility</Secondary>
</IndexTerm>
<Para>The protocol sequence used must be supported by both the RPC
runtime and the operating system on the client's machine.  However, the
RPC runtime implicitly takes care of binding compatibility when it returns
bindings to importing clients; only compatible bindings are returned.
</Para>
<Para>The <Function>rpc_network_inq_protseqs(&thinsp;)</Function> and
<IndexTerm Id="ADGISG.INTRO.indx.220">
<Primary><Function>rpc_network_inq_protseqs()</Function></Primary>
</IndexTerm><Function>rpc_network_is_protseq_valid(&thinsp;)</Function> routines
can be used to return all supported
<IndexTerm Id="ADGISG.INTRO.indx.221">
<Primary><Function>rpc_network_is_protseq_valid()</Function></Primary>
</IndexTerm>protocol sequences and to determine whether a specified protocol is supported,
respectively.
</Para>
<Para>To find out what protocol sequence is used in a binding handle, 
make the following series of calls:
<IndexTerm Id="ADGISG.INTRO.indx.222">
<Primary><Function>rpc_binding_to_string_binding()</Function></Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.223">
<Primary><Function>rpc_string_binding_parse()</Function></Primary>
</IndexTerm><?sml-break><?sml-point-size 11>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing>rpc_binding_to_string_binding(<Symbol Role="Variable">binding</Symbol>, &amp;string_binding, &amp;status);

rpc_string_binding_parse(<Symbol Role="Variable">string_binding</Symbol>, NULL, &amp;protseq, \
NULL, NULL, NULL, &amp;status);
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<!--no-op:  14-->
<!-- - -->
</Sect3>
</Sect2>
<Sect2 Id="ADGISG.INTRO.div.41">
<Title>Annotating the Binding Handle for Security</Title>
<!-- - -->
<Para>Now that the client has a binding, it is almost ready to begin RPC operations.
One last preliminary task remains; namely, to specify various security-related
parameters to the RPC runtime, which will govern the (security) conduct of the
ensuing client/server relationship.  If the client does not require
authentication, it can skip this step completely.  The result will be that no
authentication will take place between the client and server.  It will then be
up to the server to decide how far to go with an unauthenticated client.
<!-- - -->
</Para>
<Sect3 Id="ADGISG.INTRO.div.42">
<Title>Preparation</Title>
<!-- - -->
<Para>What the client essentially wants to do now is call the routine
<Function>rpc_binding_set_auth_info(&thinsp;)</Function> in order to specify all the necessary
<IndexTerm Id="ADGISG.INTRO.indx.224">
<Primary><Function>rpc_binding_set_auth_info()</Function></Primary>
</IndexTerm>security parameters.  However, when it does this, it should be able to specify
its server's principal name, so that the server it binds to can be
<IndexTerm Id="ADGISG.INTRO.indx.225">
<Primary>principal name</Primary>
<Secondary>server</Secondary>
<Tertiary>how a client determines</Tertiary>
</IndexTerm>authenticated <Symbol Role="Variable">to the client</Symbol>. (The server's principal name is the name
by which the server is known to the DCE Security Service.)  The client must also
supply a handle to its own login context when it calls
<IndexTerm Id="ADGISG.INTRO.indx.226">
<Primary>login context</Primary>
<Secondary>handle</Secondary>
</IndexTerm><Function>rpc_binding_set_auth_info(&thinsp;)</Function>.
</Para>
<Para>There are several ways to determine the server's principal name, as
follows:
<IndexTerm Id="ADGISG.INTRO.indx.227">
<Primary>binding</Primary>
<Secondary>annotating handle for security</Secondary>
</IndexTerm></Para>
<ItemizedList>
<ListItem>
<Para>The server's principal name could be hardcoded in the client.  This
is not recommended practice for reasons of robustness and flexibility.
</Para>
</ListItem>
<ListItem>
<Para>The client can be handed the name as input from the command line when
it is invoked.
<!-- .LI-->
<!-- The name can be stored in the namespace.  NOT SECURE-->
</Para>
</ListItem>
<ListItem>
<Para>The principal name can be the same as the name entry (binding information)
name.
</Para>
</ListItem>
<ListItem>
<Para>The client can query the server's principal name by calling
<Function>rpc_mgmt_inq_princ_name(&thinsp;)</Function>.  It can then check group membership by calling
<IndexTerm Id="ADGISG.INTRO.indx.228">
<Primary><Function>rpc_mgmt_inq_princ_name()</Function></Primary>
</IndexTerm><Function>sec_rgy_pgo_is_member(&thinsp;)</Function>, using a known tested group.
<IndexTerm Id="ADGISG.INTRO.indx.229">
<Primary><Function>sec_rgy_pgo_is_member()</Function></Primary>
</IndexTerm></Para>
</ListItem>
</ItemizedList>
<Para>The reason for checking group membership has to do with authorization-related
<IndexTerm Id="ADGISG.INTRO.indx.230">
<Primary>group membership</Primary>
<Secondary>reason for checking</Secondary>
</IndexTerm>decisions that the client may need to consider.  It is not necessarily enough
to know that a server has a certain identity; it may also be necessary that
it belong to a certain group in order for it to be fully authorized, from the
client's point of view, to receive the data that the client will send.  In other
words, the client may need to make a decision about the server similar in nature
to that which the server makes about the client, when
it checks the client's authorization, via ACLs, to do the things it wants to do.
Security can be just as important for the client as for the server; this is the
justification for having to make the extra calls described here.
</Para>
<Para>The client retrieves its login context with the following security 
<IndexTerm Id="ADGISG.INTRO.indx.231">
<Primary>binding</Primary>
<Secondary>annotating handle for security</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.232">
<Primary>login context</Primary>
<Secondary>client</Secondary>
<Tertiary>retrieving</Tertiary>
</IndexTerm>library routine:
<IndexTerm Id="ADGISG.INTRO.indx.233">
<Primary><Function>sec_login_get_current_context()</Function></Primary>
</IndexTerm></Para>
<InformalExample>
<Para><ProgramListing>sec_login_get_current_context(&amp;login_context, &amp;status);
</ProgramListing></Para>
</InformalExample>
<Para>However, this is not usually necessary. The client can, by passing a NULL
value to <Function>rpc_binding_set_auth_info(&thinsp;)</Function>, simply
<IndexTerm Id="ADGISG.INTRO.indx.234">
<Primary><Function>rpc_binding_set_auth_info()</Function></Primary>
</IndexTerm>use its default login context.
</Para>
<Para>In any case, note that this login context already exists; the client merely
retrieves it. (The client inherited its login context from the user principal
who executed it.) The client can now set up for authenticated RPC.
<!-- - -->
</Para>
</Sect3>
<Sect3 Id="ADGISG.INTRO.div.43">
<Title>Setting Up for Authenticated RPC</Title>
<!-- - -->
<IndexTerm Id="ADGISG.INTRO.indx.235">
<Primary>authentication</Primary>
<Secondary>setting up for</Secondary>
</IndexTerm>
<Para>The client makes the following call in order to set up the security
characteristics of the communications it is about to enter into with
the server:
<IndexTerm Id="ADGISG.INTRO.indx.236">
<Primary><Function>rpc_binding_set_auth_info()</Function></Primary>
</IndexTerm><?sml-break><?sml-point-size 11>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing>rpc_binding_set_auth_info(<Symbol Role="Variable">binding</Symbol>, \
<Symbol Role="Variable">server_princ_name</Symbol>, <Symbol Role="Variable">protect_level</Symbol>, <Symbol Role="Variable">authn_svc</Symbol>, <Symbol Role="Variable">login_context</Symbol>, \
<Symbol Role="Variable">authz_svc</Symbol>, &amp;status);
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<!--no-op:  14-->
<Para>The security parameters specified here include <Symbol Role="Variable">protect_level</Symbol> for level
of protection performed (for example, authenticate only at the beginning of
each RPC, or authenticate everything received by the server), <Symbol Role="Variable">authn_svc</Symbol>
for the authentication service (including ``none''), and <Symbol Role="Variable">authz_svc</Symbol> for
the type of client authorization information that will be supplied to the server.
</Para>
<Para>The usual practice is to pass NULL for <Symbol Role="Variable">login_context</Symbol> here, and thus
use the default context.
</Para>
<Para><IndexTerm Id="ADGISG.INTRO.indx.237">
<Primary>authentication</Primary>
<Secondary>client's decision to use or not</Secondary>
</IndexTerm>Note that it is the client who chooses whether or not to use authenticated RPC,
as well as the level of authentication, and how much authorization information
about itself to send.  It is then up to the server to accept this arrangement or
reject it, or to allow some limited operation with the client, or whatever else
it might decide.  The server decides which authentication to use.  The client also
specifies an authentication service (in <Symbol Role="Variable">authn_svc</Symbol>), but if this differs
<IndexTerm Id="ADGISG.INTRO.indx.238">
<Primary>authentication</Primary>
<Secondary>services</Secondary>
</IndexTerm>from what the server specified, the call to
<Function>rpc_binding_set_auth_info(&thinsp;)</Function> 
will fail and an error will be returned to the client.
</Para>
<Para>There is an important difference between the rationales of authentication and
authorization.  Authentication is performed by the RPC runtime and is only
<IndexTerm Id="ADGISG.INTRO.indx.239">
<Primary>authentication</Primary>
<Secondary>and authorization</Secondary>
</IndexTerm>indirectly felt by client and server; authorization, however, is for the most
part implemented explicitly in the server code if it is implemented at all.
This difference is the reason for the larger number of authentication-related
arguments that have to be specified in this step.
</Para>
<Para>For further information about authenticated RPC, see the &DCEDk;.
<!-- -->
<!-- Chapter 2 contains sections on server key management, which is part -->
<!-- of the authenticated RPC mechanism, and on the practical details-->
<!-- involved in writing an ACL manager.-->
<!-- - -->
</Para>
</Sect3>
</Sect2>
<Sect2 Id="ADGISG.INTRO.div.44">
<Title>Invoking Remote Procedure Calls</Title>
<!-- - -->
<Para>This step is the culmination of all the foregoing steps; here the client
makes its first remote call to the server.  This call, which will obviously
be application specific (its definition was specified in the application's
<Filename>.idl</Filename> file, and possibly modified by the
<Filename>.acf</Filename> file), will look something like the following:
</Para>
<InformalExample>
<Para><ProgramListing>my_rpc_op(<Symbol Role="Variable">binding_handle</Symbol>, <Symbol Role="Variable">arg1</Symbol>, <Symbol Role="Variable">arg2</Symbol>, <Symbol Role="Variable">arg3</Symbol>);
</ProgramListing></Para>
</InformalExample>
<Para>Note that the presence of the binding handle as a parameter means that
explicit binding handles are being used.
</Para>
<Para>Note also that after all the preceding talk about interfaces, no interface
<IndexTerm Id="ADGISG.INTRO.indx.240">
<Primary>interface</Primary>
<Secondary>ensuring compatibility of between server and client</Secondary>
</IndexTerm>handle appears in the parameter list.  The RPC runtime takes care internally
of making sure that the interface offered by the server exactly matches what
the client expects.  The <Function>my_rpc_op(&thinsp;)</Function> routine was (or should have been)
defined as part of the application's interface.  When the
client calls <Function>my_rpc_op(&thinsp;)</Function> in the present step, the client stub code
(which was generated during the IDL compilation step) will include the
correct UUID for the interface the routine is associated with in the data
sent out on the network.  The RPC runtime uses the interface specification
<IndexTerm Id="ADGISG.INTRO.indx.241">
<Primary>interface</Primary>
<Secondary>specification in stubs</Secondary>
</IndexTerm>included with each RPC as a ``fingerprint'' to ensure that the operation
being requested of a server is in fact implemented by that server.  This
ensures that interface compatibility is never dependent on the vagaries of
application code.
<?sml-break><?sml-need 25>
<!-- - -->
</Para>
<Sect3 Id="ADGISG.INTRO.div.45">
<Title>The Possibility of Binding Failure</Title>
<!-- - -->
<IndexTerm Id="ADGISG.INTRO.indx.242">
<Primary>binding</Primary>
<Secondary>failure</Secondary>
</IndexTerm>
<Para>Perhaps the most important thing to mention about this step
is that it may not at first succeed.  Remember that the client imported
a <Symbol Role="Variable">partial</Symbol> binding to the server.  Completion of the binding, and
therefore of the remote call, depends on the endpoint mapper's being
able to successfully complete the incoming binding with a good endpoint
for either the specified server (if one is specified) or for one of its
own choosing.  This in turn depends on the up-to-dateness of the host's
endpoint database, and that depends on such things as other servers'
being conscientious about unregistering themselves when terminating,
and so on.  Even the target host specified may not be valid when the call
is made because of any one of the various network problems that can
occur.
</Para>
<Para>In other words, the client should regard an unused binding not as a firm
promise that comes directly from the server, but rather as a well-meant
expression of intent passed on by the name service and based on
circumstances not entirely under anyone's control.  This is the reason
for the series of binding import calls described earlier.  The prudent
thing for a client to do after importing a binding is,
therefore, to assume that it will have to perform one or more times a 
series of steps something like the contents of the following loop:
</Para>
<OrderedList>
<ListItem>
<Para>Annotate the binding handle for security.
</Para>
</ListItem>
<ListItem>
<Para>Try it out: attempt a remote call with it.
</Para>
</ListItem>
<ListItem>
<Para>If the call succeeds, discard the binding import context and proceed to
<IndexTerm Id="ADGISG.INTRO.indx.243">
<Primary>binding</Primary>
<Secondary>discarding import context</Secondary>
</IndexTerm>step 5 in this loop.
</Para>
</ListItem>
<ListItem>
<Para>Otherwise, if the call fails, import the next binding and return to step 1
in this loop.
</Para>
</ListItem>
<ListItem>
<Para>Proceed with remote operations until finished.
</Para>
</ListItem>
</OrderedList>
<Para>If all imported bindings happen to fail, this could be because the client's
cache of bindings has become stale.  The client could then try calling
<Function>rpc_ns_mgmt_handle_set_exp_age(&thinsp;)</Function> with a low timeout value, and
<IndexTerm Id="ADGISG.INTRO.indx.244">
<Primary><Function>rpc_ns_mgmt_handle_set_exp_age()</Function></Primary>
</IndexTerm>then retry the previous loop.  
A last resort could be to allow the user to type
in a string binding.
<IndexTerm Id="ADGISG.INTRO.indx.245">
<Primary>binding</Primary>
<Secondary>automatic method</Secondary>
</IndexTerm></Para>
<Para>Note that if you are using the auto-binding method and the binding becomes
unusable for some reason, the RPC runtime will rebind under most conditions.
<!-- - -->
</Para>
</Sect3>
<Sect3 Id="ADGISG.INTRO.div.46">
<Title>The Result of Successful Binding</Title>
<!-- - -->
<Para>If <Function>my_rpc_op(&thinsp;)</Function> or its equivalent does succeed, the binding will
as a result be complete (even if it was partial before), and the
information in it can be regarded with much more assurance from then on.
Subsequent remote procedure calls by the client to the same server will
go straight to the bound-to server.
<!-- - -->
</Para>
</Sect3>
</Sect2>
</Sect1>
<Sect1 Id="ADGISG.INTRO.div.47">
<Title>The Server's Manager of RPC Requests</Title>
<!-- - -->
<Para>As was explained, server threads are automatically
spawned by the RPC runtime in the server manager to handle incoming remote
procedure calls from clients.  The number of calls that can be concurrently
handled depends on the value of the <Symbol Role="Variable">max_calls_exec</Symbol> parameter specified
in the call to <Function>rpc_server_listen(&thinsp;)</Function>.  The
thread is created by the RPC runtime and begins execution in the operation
requested.  When the operation is completed, the thread is automatically
terminated (by the RPC runtime).
<!-- ..."Well, sort of- they're cached" (Rich Salz).-->
</Para>
<Para>See also the &DCEDk; and the &DCEDr;
for a comprehensive discussion of DCE threads.
<!-- - -->
</Para>
<Sect2 Id="ADGISG.INTRO.div.48">
<Title>Getting the Client's Credentials</Title>
<!-- - -->
<IndexTerm Id="ADGISG.INTRO.indx.246">
<Primary>credentials</Primary>
<Secondary>client's</Secondary>
<Tertiary>retrieval by server</Tertiary>
</IndexTerm>
<Para>As mentioned in the previous step, authentication, if it was specified by
the client, has already occurred if the client's request is received by
the server manager.  If the client fails to authenticate itself to the server
runtime, its remote procedure call fails before reaching the server's RPC
code.
</Para>
<Para>Authentication, if specified by the client and offered by the server, is
performed by the RPC runtime; it is not a responsibility of the application
code.  However, it is up to the application to formulate its own security
policy with regard to the client, based on the following:
</Para>
<ItemizedList>
<ListItem>
<Para>The level at which the client has been authenticated.
</Para>
</ListItem>
<ListItem>
<Para>The client's authorization; that is, whether the client should be allowed to
access resources it may request.
</Para>
</ListItem>
</ItemizedList>
<IndexTerm Id="ADGISG.INTRO.indx.247">
<Primary>authentication</Primary>
<Secondary>determining client's information</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.248">
<Primary>authorization</Primary>
<Secondary>determining client's information</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.249">
<Primary><Function>rpc_binding_inq_auth_caller()</Function></Primary>
</IndexTerm>
<Para>In order to find out the client's authentication and authorization information,
the server calls the following RPC library routine:
<?sml-break><?sml-point-size 11>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing>rpc_binding_inq_auth_caller(<Symbol Role="Variable">binding_handle</Symbol>,
<Symbol Role="Variable">privs</Symbol>, <Symbol Role="Variable">server_princ_name</Symbol>, &bsol;
    <Symbol Role="Variable">protect_level</Symbol>, <Symbol Role="Variable">authn_svc</Symbol>, <Symbol Role="Variable">authz_svc</Symbol>, &amp;status);
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<!--no-op:  14-->
<Para>The parameters in this call are analogous to the similarly named parameters in
the registration routines.  The server can
learn what level of authentication, what authentication service, and what
server principal name the client specified.  Of most interest, however, are
the <Symbol Role="Variable">privs</Symbol> and <Symbol Role="Variable">authz_svc</Symbol> parameters.  The <Symbol Role="Variable">privs</Symbol>
parameter is a pointer to whatever information the client is willing to let
the server know about its privilege attributes; <Symbol Role="Variable">authz_svc</Symbol> tells what
this information is.  It could be any one of the following:
</Para>
<ItemizedList>
<ListItem>
<Para>The client's privilege attribute certificate (PAC), containing the client's
<IndexTerm Id="ADGISG.INTRO.indx.250">
<Primary>privilege attribute certificate</Primary>
</IndexTerm>principal and group UUIDs.  These can be used to look up the client's privilege
<IndexTerm Id="ADGISG.INTRO.indx.251">
<Primary>group UUID</Primary>
<Secondary>client's</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.252">
<Primary>principal UUID</Primary>
<Secondary>client's</Secondary>
</IndexTerm>attributes in ACLs, whose entries are keyed by principal and
group UUID.
</Para>
</ListItem>
<ListItem>
<Para>The client's principal name (a string).  This also can be used to look
<IndexTerm Id="ADGISG.INTRO.indx.253">
<Primary>principal name</Primary>
<Secondary>client's</Secondary>
<Tertiary>used for authorization</Tertiary>
</IndexTerm>through ACLs, provided that the lists have been annotated
with such name strings.
</Para>
</ListItem>
<ListItem>
<Para>Nothing.  The client chooses not to provide any authorization information.
</Para>
</ListItem>
</ItemizedList>
<Para>From now on, it is the server's decision, as implemented by the developer,
how to respond to the client's requests for services and resources, depending
on the security information the server has learned about it.  A non-ACL-based
strategy may be implemented using the client's principal name string for
lookups.  The ACL-based strategy, which is supported by a DCE interface,
is described further in the next step.
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.INTRO.div.49">
<Title>Getting the Object's ACL</Title>
<!-- - -->
<IndexTerm Id="ADGISG.INTRO.indx.254">
<Primary>access control list (ACL)</Primary>
<Secondary>retrieving an object's</Secondary>
</IndexTerm>
<Para>This step is reached if the client requests access to any object, resource,
or service that is managed by the server, to which ACLs are attached.  As
previously mentioned, the application must implement its own ACL manager
if it wants to use ACLs to control access to its resources.  For further
details on how to go about creating an ACL manager, see Chapter 3.
</Para>
<Para>In order to allow applications to as easily as possible offer an ACL interface
that is uniform with that used by the DCE components themselves, the remote
ACL interface has been built into the DCE library, and client applications
<IndexTerm Id="ADGISG.INTRO.indx.255">
<Primary>remote ACL (<Literal>rdacl</Literal>) interface</Primary>
<Secondary>use of by DCE applications</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.256">
<Primary><Literal>rdacl</Literal> interface</Primary>
<Secondary>use of by DCE applications</Secondary>
</IndexTerm>can perform operations on ACLs through another interface, also part of the DCE
library, which calls through the remote interface to the appropriate manager.
The remote interface, consisting of <Literal>rdacl_</Literal>
<Symbol Role="Variable">*</Symbol><Literal>(&thinsp;)</Literal> calls, must be
implemented by the server application; clients execute the local
<Literal>sec_acl_</Literal><Symbol Role="Variable">*</Symbol><Literal>(&thinsp;)</Literal>
routines, which are linked to every DCE application
as part of <Literal>libdce</Literal>.
</Para>
<Para>For the client, all that is necessary is to possess a binding to the object
whose ACL is to be operated on.  As long as the application exposes the
resources it manages as accessible objects (via the namespace), then the
DCE ACL interface provides for a client's being able to bind to the object
by calling <Function>sec_acl_bind(&thinsp;)</Function>.  (In fact, this kind of object-oriented
<IndexTerm Id="ADGISG.INTRO.indx.257">
<Primary><Function>sec_acl_bind()</Function></Primary>
</IndexTerm>binding model can be very useful, and is discussed in further detail in
<IndexTerm Id="ADGISG.INTRO.indx.258">
<Primary>object-oriented binding model</Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.259">
<Primary>ACL</Primary>
<Secondary>handles</Secondary>
</IndexTerm>Chapter 4.) 
Note that the <Literal>sec_acl_</Literal><Symbol Role="Variable">*</Symbol>
<Literal>(&thinsp;)</Literal> routines use an <FirstTerm>ACL handle</FirstTerm>
to specify the object whose ACL is to be accessed, so
<Function>sec_acl_bind(&thinsp;)</Function>
must always be called to obtain this handle, even if the client is already
bound to the object's server.
</Para>
<Para><IndexTerm Id="ADGISG.INTRO.indx.260">
<Primary><Command>acl_edit</Command></Primary>
</IndexTerm>There is a user interface into the ACL operations, 
embodied in the <Command>acl_edit</Command> command.  For further information, see the 
&DCEAr;.
</Para>
<Para>Server applications can use the DCE ACL library routines to implement ACL
managers.  The DCE ACL library is an implementation of the remote ACL 
(<Literal>rdacl</Literal>)
interface, designed in such a way as to allow any DCE application to 
use it instead
of having to implement the interface itself.  In DCE 1.0, 
applications that wished
to use the DCE ACL functionality had to implement the full remote interface
themselves; in DCE 1.1 this is no longer necessary.  For further information,
see Chapter 3.
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.INTRO.div.50">
<Title>Making the Authorization Decision</Title>
<!-- - -->
<IndexTerm Id="ADGISG.INTRO.indx.261">
<Primary>authorization</Primary>
<Secondary>making decision</Secondary>
</IndexTerm>
<Para>In this step, the server's ACL manager inspects the ACL of the resource
(object) under question, determines whether the client is authorized for the
requested access, and takes the appropriate action.
<!-- A standard algorithm is used to accomplish this.-->
<IndexTerm Id="ADGISG.INTRO.indx.262">
<Primary>ACL</Primary>
<Secondary>types</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.263">
<Primary>type</Primary>
<Secondary>managers</Secondary>
<Tertiary>ACL</Tertiary>
</IndexTerm></Para>
<Para>The application may choose to implement more than one type of ACL (reflecting
the different kinds of objects and resources to be protected), thus resulting
in several ACL <Replaceable>type managers</Replaceable>.
</Para>
<Para>Although it is up to the application to implement its own ACL storage, testing
algorithms and manager types, there are certain DCE-wide design conventions
that should be kept in mind and departed from only for good reason.  Among these
are the following:
<IndexTerm Id="ADGISG.INTRO.indx.264">
<Primary>ACL</Primary>
<Secondary>design guidelines</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.265">
<Primary>ACL</Primary>
<Secondary>standard DCE entry types</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.266">
<Primary>privileges</Primary>
<Secondary>standard DCE</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.267">
<Primary>access algorithm</Primary>
<Secondary>standard DCE</Secondary>
</IndexTerm></Para>
<ItemizedList>
<ListItem>
<Para>Standard DCE ACL entry types: the kinds of entry that can occur in an 
ACL (for example, <Literal>user</Literal>, <Replaceable>group</Replaceable>, and so on).
</Para>
</ListItem>
<ListItem>
<Para>Standard privileges: the kinds of access that a principal can have
to a protected object (for example, read, write, and so on).
</Para>
</ListItem>
<ListItem>
<Para>Standard inheritance rules: these rules govern the default characteristics of
ACLs created for newly created objects.
</Para>
</ListItem>
<ListItem>
<Para>Standard access algorithm: the order in which a client's credentials are matched
against the various possible entry types.
</Para>
</ListItem>
</ItemizedList>
<Para>Information about these topics for application developers designing their own
ACL model can be found in the &DCEDk;, in which all the DCE 
authorization conventions are described in detail.
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.INTRO.div.51">
<Title>Servicing the RPC Request</Title>
<!-- - -->
<Para>If the client's request is determined to be properly authorized, then the
requested operation can proceed.
</Para>
<Para>Note that this step and steps D3 and D4 (as discussed in Section 1.2) 
are somewhat intertwined.  Something like the following could occur:
</Para>
<OrderedList>
<ListItem>
<Para>The server wakes up in some routine defined in its manager code.  For example,
if the client executed the call <Function>my_rpc_op(&thinsp;)</Function>, then the server will
wake up in the routine that implements this remote call.
</Para>
</ListItem>
<ListItem>
<Para>Execution of the <Function>my_rpc_op(&thinsp;)</Function> routine requires the <Literal>insert</Literal>
privilege for the application's database <Literal>my_database</Literal>.  So
<Function>my_rpc_op(&thinsp;)</Function> begins by checking the client's relevant privilege
attribute by making an internal call to the application's ACL manager.
</Para>
</ListItem>
<ListItem>
<Para>If the client is found to have the requisite privilege,
<Function>my_rpc_op(&thinsp;)</Function> proceeds.
</Para>
</ListItem>
</OrderedList>
<Para>The remote procedure executed in this step is written by the application
developer.
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.INTRO.div.52">
<Title>Returning the Results and Resuming Listening</Title>
<!-- - -->
<Para>At the completion of the operation, the RPC thread that was automatically
spawned to execute it is terminated by the RPC runtime.  As far as the server
is concerned, it is still blocking on the call to
<Function>rpc_server_listen(&thinsp;)</Function>
which was made earlier.  If <Symbol Role="Variable">max_calls_exec</Symbol> was
<IndexTerm Id="ADGISG.INTRO.indx.268">
<Primary><Function>rpc_server_listen()</Function></Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.269">
<Primary>threads</Primary>
<Secondary>RPC</Secondary>
<Tertiary>multiple</Tertiary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.270">
<Primary>multithreadedness</Primary>
<Secondary>in servers</Secondary>
<Tertiary>behavior of</Tertiary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.271">
<Primary><Function>rpc_server_listen()</Function></Primary>
<Secondary>and <Replaceable>max_calls_exec</Replaceable> parameter</Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.272">
<Primary>buffer</Primary>
<Secondary>incoming RPC call request</Secondary>
</IndexTerm>specified to be greater than 1 in that call, other threads may still be
executing at this time in response to other requests that have been received
from other clients.  In any case, the call to
<Function>rpc_server_listen(&thinsp;)</Function> will
not return until one of the server's own management routines, or a client,
makes a successful call to
<Function>rpc_mgmt_stop_server_listening(&thinsp;)</Function>.  If this
<IndexTerm Id="ADGISG.INTRO.indx.273">
<Primary><Function>rpc_mgmt_stop_server_listening()</Function></Primary>
</IndexTerm>happens, the RPC runtime will stop accepting incoming client requests to the
server.  When all the currently executing operations have been completed, the
call to <Function>rpc_server_listen(&thinsp;)</Function> will return.
</Para>
<Para>The other way that execution can be thrown out of the
<Function>rpc_server_listen(&thinsp;)</Function>
call is as a result of a signal or exception.
<IndexTerm Id="ADGISG.INTRO.indx.274">
<Primary>signals</Primary>
<Secondary>and <Function>rpc_server_listen()</Function></Secondary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.275">
<Primary>exceptions</Primary>
<Secondary>and <Function>rpc_server_listen()</Function></Secondary>
</IndexTerm>
<!-- For more about this possibility,-->
<!-- see Step B9.-->
<!-- (Section 1.5.14).-->
</Para>
<Para>From the server's point of view, the result of completing the remotely called
routine is that it reenters the <Replaceable>listen</Replaceable> loop, waiting for further remote
calls.  The server's runtime handles all the communications details of actually
sending any requested data to the client.
<!-- ..."Implies serial, but it's parallel invocation" (Rich Salz).-->
<IndexTerm Id="ADGISG.INTRO.indx.276">
<Primary>remote call</Primary>
<Secondary>server's return from</Secondary>
</IndexTerm></Para>
<Para>From the client's point of view, the server's return at the end of its
remotely called routine results in the client's returning from a seemingly
locally executed routine.
<!-- - -->
</Para>
<Sect3 Id="ADGISG.INTRO.div.53">
<Title>Continuing</Title>
<!-- - -->
<Para>The client now goes on about its business, which may include performing
other remote procedure calls.
</Para>
<Para>Note that there is no housekeeping burden placed on the client with regard
to the termination of the relationship with a server.  However, a long-lived
client might want to make use of the <Function>rpc_binding_free(&thinsp;)</Function> routine to
<IndexTerm Id="ADGISG.INTRO.indx.277">
<Primary><Function>rpc_binding_free()</Function></Primary>
</IndexTerm>
<IndexTerm Id="ADGISG.INTRO.indx.278">
<Primary>binding</Primary>
<Secondary>freeing memory used by handle</Secondary>
</IndexTerm>free memory that was allocated for no-longer-used handles.  The client should
also call <Function>rpc_ns_binding_import_done(&thinsp;)</Function> to clean up the resources used
<IndexTerm Id="ADGISG.INTRO.indx.279">
<Primary><Function>rpc_ns_binding_import_done()</Function></Primary>
</IndexTerm>by the NSI routines.  If another binding handle will be needed later on, then
<Function>rpc_ns_binding_import_begin(&thinsp;)</Function> will be recalled.
<IndexTerm Id="ADGISG.INTRO.indx.280">
<Primary><Function>rpc_ns_binding_import_begin()</Function></Primary>
</IndexTerm>
<!-- - -->
</Para>
</Sect3>
</Sect2>
</Sect1>
<Sect1 Id="ADGISG.INTRO.div.54">
<Title>About DCE Programming Style</Title>
<!-- - -->
<IndexTerm Id="ADGISG.INTRO.indx.281">
<Primary>DCE programming style</Primary>
<Secondary>recommended</Secondary>
</IndexTerm>
<!-- -->
<Para>The &DCEDi; (hereafter, the
<CiteTitle>Style Guide</CiteTitle>) attempts to bridge a gap.  On one side stands
the tutorial and reference material provided by the rest of the &DCEDg;
and by the &DCEDr;.
In theory, this material provides complete
documentation of the <Replaceable>mechanisms</Replaceable> of DCE application programming.
In particular, it documents the syntax and semantics of every DCE API
interface and IDL construct and provides a service-by-service guide to
their use.
</Para>
<Para>On the other side stands the formal application portability
specification provided by the <CiteTitle>AES/DC</CiteTitle>.  This provides a
<Replaceable>policy</Replaceable> guide of a specific kind: if applications wish to be
portable among DCE implementations, they need to follow the AES
guidelines.
</Para>
<Para>Between these two poles of DCE documentation, there is still a great
deal of room to maneuver.  The DCE application programming facilities
provide such a large number of mechanisms, so many possible ways of
doing things, that it is often difficult for the programmer to decide
among them.  The guidelines provided by the <CiteTitle>AES/DC</CiteTitle> are limited
to only one (albeit an important one) policy issue: portability.
The DCE programmer is still left with many decisions about issues that
do not arise in the typical local programming environment: how to use the
name services, which security services to employ, how many threads to
use, and so on.
</Para>
<Para>The <CiteTitle>Style Guide</CiteTitle> attempts to answer many of these questions or
at least to provide the grounds upon which an application programmer can
base decisions.  Of course, the coverage in these relatively few pages
in not exhaustive.  The number of implementation issues raised by the
available DCE application programming mechanisms is potentially
unlimited.  The <CiteTitle>Style Guide</CiteTitle> attempts to cover the major
issues that are likely to confront most programmers at some stage in
DCE application design and development. 
</Para>
<Para>Aside from attempting to anticipate your questions, the <CiteTitle>Style
Guide</CiteTitle> may also raise issues that you may not even have considered.
DCE covers a great deal of ground that is probably unfamiliar to
most application developers, such as multithreading and distributed
security.  When moving in such unfamiliar territory, it is easy to
overlook potential problems.  The <CiteTitle>Style Guide</CiteTitle> attempts to alert
you to major stumbling blocks in each area.
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
</Para>
<Sect2 Id="ADGISG.INTRO.div.55">
<Title>Mechanism, Policy, and Style</Title>
<!-- - -->
<!-- -->
<Para>The <CiteTitle>Style Guide</CiteTitle> is based on what is, to some degree, a fiction: that
application development issues can be nicely divided between
<Replaceable>mechanism</Replaceable> on one hand and <Replaceable>policy and style</Replaceable> on the other.
In theory, the <Replaceable>mechanisms</Replaceable> of DCE programming refer to the
syntax and semantics required by APIs, IDL constructs, services, and
the like.  These are the things about which the programmer has no
choice: they must either be done according to the documentation or not
done at all. <Replaceable>Policy</Replaceable> and <Replaceable>style</Replaceable>, on the other hand, are supposed
to refer to the things about which the programmer can make a choice:
specifically, which mechanisms to use in given circumstances.
</Para>
<Para>In practice, the distinction between mechanism and policy/style is
often vague.  The other parts of the DCE application development
documentation set contain much that could be considered policy and
style guidance.  And, for reasons discussed in some detail in the next
section, the <CiteTitle>Style Guide</CiteTitle> often contains descriptions of the
mechanisms of DCE programming.
</Para>
<Para>Nevertheless, the <CiteTitle>Style Guide</CiteTitle> does attempt to keep to the ground
of policy and style issues.  It assumes that you already know what
mechanisms are available and attempts to provide guidance about the
choices you have in using those mechanisms.  One result is that the
<CiteTitle>Style Guide</CiteTitle> is not a tutorial; it often assumes knowlege of
terms and concepts that are explained elsewhere in the programmer's
documentation.  
</Para>
<Para><?sml-need 5>On the other hand, the <CiteTitle>Style Guide</CiteTitle> does in many
cases provide high-level discussions of the organization and
principals of DCE services, such as the security services.  The
assumption is that you may already know many of the details but may
lack an overall framework.  Often, such a general model is
just what you need to be able to make rational policy decisions.
</Para>
<Para>The distinction between policy and style is itself somewhat vague. In
general, <Replaceable>policy</Replaceable> refers to the things you <Replaceable>should</Replaceable> do in an
application program.  You can usually identify a policy recommendation
because the words ``should,'' ``must'' or ``recommended'' appear.
<FirstTerm>Style</FirstTerm> is a more general term that includes policy (hence 
``<CiteTitle>Style Guide</CiteTitle>''), but that also covers a variety of other
suggestions about how you might do things.  Much of the sample code
included in the <CiteTitle>Style Guide</CiteTitle> embodies not only the recommended
policies, but also provides illustrations of possible styles of usage.
Such suggestions are intended to be helpful, but unless they are
couched in the language of policy, should be considered entirely
optional.
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.INTRO.div.56">
<Title>Policy and Style Issues</Title>
<!-- - -->
<!-- -->
<Para>Remote application programming, using DCE, imposes some special requirements on
applications that are not relevant to most local applications.  A DCE application
is a multicomponent system in which the various components interact dynamically
as the program operates.  Obviously, the application developer is concerned with
creating two major types of components, servers and clients, but these 
application specific components also enter into relationships with 
other DCE components.  For
example, most applications will be clients of naming and security services.  
Server applications that provide ACL managers may act, in turn, as 
servers to <Literal>dcecp</Literal>
ACL commands.  Many similar client/server relationships may be 
created during the operation of a distributed application. 
</Para>
<Para>Furthermore, even components that do not communicate directly share 
common resources, such as directory and security services.  Components 
use these services to exchange specific kinds of data, such as bindings, 
and such exchanges can succeed only when they are made according to the 
correct protocols.  For example, a server needs to
organize the way it exports bindings to a name service so that clients can succeed
in finding them.  Similarly, clients and servers can only succeed at authenticated
communications if the correct registry and ACL data has been created and if each
follows the correct incantations to make use of this data.
</Para>
<Para>A particular constraint on DCE applications is that they must take into account the
administrative overhead of a distributed system.  Servers need to consider such issues
as the location and availability of the services they need, the structure of the
namespace into which they export their bindings, the DCE identity and privileges
under which the server must run, and many similar issues.  A successful server will be
one that interacts correctly with other components while imposing a minimal load on
the DCE environment and, most important, can be successfully and easily administered.
</Para>
<Para>To meet these requirements, application components must interact with each other
and with other DCE components in a consistent and well-behaved manner.  In this
context, one can think of DCE applications as having to meet application-level
and administrative interoperability requirements.  The <Symbol Role="Variable">Style Guide</Symbol> is, in
part, a guide to such requirements.  Given the enormous variety of programming
and administrative mechanisms that DCE makes available to the programmer, the
<Symbol Role="Variable">Style Guide</Symbol> provides a set of policy recommendations for the use of those
mechanisms that will maximize the application-level and administrative
interoperability of DCE applications.
</Para>
<Para>In addition to being complex, DCE application programming involves elements that
are likely to be unfamiliar to many programmers, such as remote parameter passing,
name services, and distributed security services.  Another goal of the <Symbol Role="Variable">Style
Guide</Symbol> is to suggest wise uses for these tools, since many of the familiar local
programming models are inadequate.  These recommended policies are especially
important in the area of security: an application that fails to follow them is
likely to be insecure.  Recommended policies in some other areas, such as execution
semantics and locking, may also fundamentally affect the integrity of a distributed
application and should not be lightly ignored.  Other policies, such as those relating
to parameter passing affect mainly appliction performance.
</Para>
<Para>The simple unfamiliarity of many of the concepts can make the actual coding of an RPC
application a daunting task.  In traditional C programming you can usually begin with
familiar models&mdash;often, with existing code&mdash;but with RPC you are unlikely to have
such starting points.  Therefore, this guide also provides extensive examples that
illustrate the basic uses of many important elements.  For example, in developing an
ACL manager, you may well be able to use the sample ACL manager as a starting point.
</Para>
<Para>The sample code is intended to suggest certain styles of usage that will probably prove
useful in many situations.  Obviously, these styles are only sugggestions: you will
certainly develop your own DCE programming style as you develop DCE applications.
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
</Para>
</Sect2>
<Sect2 Id="ADGISG.INTRO.div.57">
<Title>General Policies</Title>
<!-- - -->
<!-- -->
<!-- -->
<IndexTerm Id="ADGISG.INTRO.indx.282">
<Primary>server</Primary>
<Secondary>design guidelines</Secondary>
</IndexTerm>
<!-- -->
<Para>The <CiteTitle>Style Guide</CiteTitle> embodies a variety of basic assumptions. These
form the basis for a set of high-level policy recommendations that
cross the boundaries of the specific services discussed in later chapters.
These are as follows:
</Para>
<ItemizedList>
<ListItem>
<!-- -->
<IndexTerm Id="ADGISG.INTRO.indx.283">
<Primary>server</Primary>
<Secondary>recommended design of interfaces</Secondary>
</IndexTerm>
<!-- -->
<Para>Servers are generalized providers of the services specified by their
published (IDL) interfaces.  That is, servers should encapsulate the
services they provide in such a way that naive clients, with no
knowledge of the specifics of server implementation, can successfully
make use of these services via the remote interfaces.  In this sense,
servers are much like libraries.  One should not assume that
clients will be written by someone with knowledge of server internals.
Where appropriate, define wrapper routines for the IDL operations to shield
developers from binding handles and other RPC peculiarities.
</Para>
</ListItem>
<ListItem>
<!-- -->
<IndexTerm Id="ADGISG.INTRO.indx.284">
<Primary>server</Primary>
<Secondary>binding information recommendations</Secondary>
</IndexTerm>
<!-- -->
<Para>Servers should make their resources known to clients using standard
mechanisms.  In particular, they should export their bindings
according to the recommended service models, use name and endpoint
services rather than fixed bindings and well-known endpoints, and
associate exported objects with UUIDs.
</Para>
</ListItem>
<ListItem>
<!-- -->
<IndexTerm Id="ADGISG.INTRO.indx.285">
<Primary>clients</Primary>
<Secondary>portability of</Secondary>
</IndexTerm>
<!-- -->
<!-- -->
<IndexTerm Id="ADGISG.INTRO.indx.286">
<Primary>server</Primary>
<Secondary>portability of</Secondary>
</IndexTerm>
<!-- -->
<Para>Clients and servers should be portable, using DCE provided
mechanisms instead of operating system and transport-dependent
mechanisms.  For example, data streams should be communicated via the
RPC pipe mechanism rather than socket calls.  The AES/DC is
<!-- -->
<IndexTerm Id="ADGISG.INTRO.indx.287">
<Primary>pipe mechanism</Primary>
</IndexTerm>
<!-- -->
the definitive guide to application portability using the
DCE mechanisms.
</Para>
</ListItem>
<ListItem>
<Para>Distributed applications make greater administrative demands than
<!-- -->
<IndexTerm Id="ADGISG.INTRO.indx.288">
<Primary>distributed applications</Primary>
<Secondary>administrative demands of</Secondary>
</IndexTerm>
<!-- -->
nondistributed ones.  Clients and servers need to be written with an
eye to minimizing and simplifying administrative tasks.  This means,
for example, that
</Para>
<ItemizedList>
<ListItem>
<Para>Applications need to be as configuration and location independent
as possible.  In particular, this means giving careful thought to
the use of name services for advertizing and finding resources.
</Para>
</ListItem>
<ListItem>
<Para>Applications require both local and DCE identities and 
privileges.  They should follow the recommended models for  
acquiring and maintaining these privileges and identities.
</Para>
</ListItem>
<ListItem>
<?sml-need 5>
<Para>Servers should be administratively interoperable; that is, they
should behave like the standard DCE servers, exporting the
recommended management interfaces,  exporting ACL managers, 
logging errors and messages, and providing for the standard 
startup and shutdown mechanisms.
</Para>
</ListItem>
</ItemizedList>
</ListItem>
<ListItem>
<Para>Distributed security is inherently more complex than local system
security (you can't just ``lock the door'').  Applications should follow
the recommended security policies rigorously.
<!-- -->
<!-- They should avoid-->
<!-- ad hoc security solutions which are as likely to compromise security-->
<!-- as to enhance it.-->
<!-- -->
</Para>
</ListItem>
<ListItem>
<Para>Clients and servers should follow the recommended
internationalization guidelines to ensure character set
interoperability.
</Para>
</ListItem>
</ItemizedList>
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- - -->
</Sect2>
</Sect1>
</Chapter>
<!--+ 11/13/96 22:48:26
    | tagMorph:  $Id: intro.sgm,v 1.1.2.6 1996/11/25 18:18:53 carrig Exp $
    | tagMorph library:  $Id: intro.sgm,v 1.1.2.6 1996/11/25 18:18:53 carrig Exp $
    | sml-to-docbook:  1.24
    +-->
