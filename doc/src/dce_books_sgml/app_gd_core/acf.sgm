<!--
# @OSF_COPYRIGHT@
# 
# 
# HISTORY
# $Log: acf.sgm,v $
# Revision 1.1.2.8  1996/12/14  20:24:11  wardr
# 	{edit,R1.2.2}
# 	penultimate format fixes
# 	[1996/12/14  20:22:02  wardr]
#
# Revision 1.1.2.7  1996/12/13  22:10:47  wardr
# 	{edit,R1.2.2}
# 	Fixed formatting problems
# 	[1996/12/13  22:08:36  wardr]
# 
# Revision 1.1.2.6  1996/12/12  21:30:27  wardr
# 	{edit,R1.2.2}
# 	Fixed formatting problems
# 	[1996/12/12  21:28:34  wardr]
# 
# Revision 1.1.2.5  1996/12/12  16:49:26  carrig
# 	{enh,R1.2.2}
# 	Minor edits
# 	[1996/12/12  16:47:15  carrig]
# 
# Revision 1.1.2.4  1996/12/06  21:10:06  carrig
# 	{enh,R1.2.2}
# 	Second pass for editor
# 	[1996/12/06  21:07:58  carrig]
# 
# Revision 1.1.2.3  1996/12/05  21:38:56  carrig
# 	{enh,R1.2.2}
# 	First pass to prepare for editing
# 	[1996/12/05  21:37:02  carrig]
# 
# Revision 1.1.2.2  1996/12/02  15:41:04  weir
# 	Removed thinsp entities, corrected other minor errors
# 	[1996/12/02  15:39:15  weir]
# 
# Revision 1.1.2.1  1996/12/01  20:43:29  weir
# 	Initial submission
# 	[1996/12/01  20:41:36  weir]
# 
# $EndLog$
-->
<!-- Fragment document type declaration subset:
ArborText, Inc., 1988-1993, v.4001
<!DOCTYPE Book PUBLIC "-//Davenport//DTD DocBook V2.4//EN" [
]>
-->
<!-- COPYRIGHT NOTICE-->
<!-- Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.-->
<!-- ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for-->
<!-- the full copyright text.-->
<!-- -->
<!-- -->
<!-- OLD HISTORY-->
<!-- Revision 1.1.6.2  1996/09/17  18:59:13  wardr-->
<!-- 	{def,CR13428,R1.2.2}-->
<!-- 	idl info missing from guide-->
<!-- 	[1996/09/17  18:57:55  wardr]-->
<!---->
<!-- Revision 1.1.6.1  1996/05/10  21:27:45  wardr-->
<!-- 	{enh,R1.2.2}-->
<!-- 	Removed Changebars-->
<!-- 	[1996/05/10  21:27:12  wardr]-->
<!-- -->
<!-- Revision 1.1.4.4  1996/03/27  13:07:20  wardr-->
<!-- 	{edit R1.2.1}-->
<!-- 	More Release Edits-->
<!-- 	[1996/03/27  13:06:54  wardr]-->
<!-- -->
<!-- Revision 1.1.4.3  1995/11/10  19:31:06  wardr-->
<!-- 	{enh CR13032 R1.2.1} Final touchup and indexing.-->
<!-- 	[1995/11/10  19:30:45  wardr]-->
<!-- -->
<!-- Revision 1.1.4.2  1995/11/02  01:09:20  wardr-->
<!-- 	{enh CR13032 R1.2.1} Do final edits-->
<!-- 	[1995/11/02  01:09:02  wardr]-->
<!-- -->
<!-- Revision 1.1.4.1  1995/09/15  21:49:47  wardr-->
<!-- 	{enh, 13032, R1.1}-->
<!-- 	adding xidl information-->
<!-- 	[1995/09/15  21:48:28  wardr]-->
<!-- -->
<!-- Revision 1.1.2.15  1995/06/07  14:37:11  rcb-->
<!-- 	PRENTICE HALL reformat; final edits and changes-->
<!-- 	[1995/06/05  19:55:37  rcb]-->
<!-- -->
<!-- 	a couple of edits from DEC that I left out before-->
<!-- 	[1995/05/01  18:24:38  rcb]-->
<!-- -->
<!-- 	PRENTICE HALL reformat-->
<!-- 	[1995/05/01  17:39:54  rcb]-->
<!-- -->
<!-- 	incorporated 1.1 edits-->
<!-- 	[1995/05/01  16:01:53  rcb]-->
<!-- -->
<!-- Revision 1.1.2.14  1994/10/28  15:14:11  jshirley-->
<!-- 	Some final edits from Rico.-->
<!-- 	[1994/10/28  15:13:50  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.13  1994/10/27  19:42:49  jshirley-->
<!-- 	Final edits.-->
<!-- 	[1994/10/27  19:41:34  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.12  1994/10/06  18:13:32  zahn-->
<!-- 	{edt,5284,R1.1}-->
<!-- -->
<!-- 	Added index entries for i18n attributes-->
<!-- 	and corrected some index entries.-->
<!-- 	[1994/10/06  18:13:13  zahn]-->
<!-- -->
<!-- Revision 1.1.2.11  1994/10/04  20:11:04  zahn-->
<!-- 	{edt,5284,R1.1}-->
<!-- -->
<!-- 	Updated cross-references to internationalized.gpsml-->
<!-- 	(Chapter 15) and changed references from "byte"-->
<!-- 	to "cs_byte" where applicable.-->
<!-- 	[1994/10/04  20:10:41  zahn]-->
<!-- -->
<!-- Revision 1.1.2.10  1994/09/15  19:27:21  zahn-->
<!-- 	{def,10547,R1.1}-->
<!-- -->
<!-- 	Added that the heap attribute is ignored-->
<!-- 	for pipes, context handles, and scalars.-->
<!-- 	[1994/09/15  19:26:38  zahn]-->
<!-- -->
<!-- Revision 1.1.2.9  1994/09/06  16:04:00  zahn-->
<!-- 	{edt,11292,R1.1}-->
<!-- -->
<!-- 	Fixed mismatched change marker pair.-->
<!-- 	[1994/09/06  16:03:44  zahn]-->
<!-- -->
<!-- Revision 1.1.2.8  1994/08/12  14:37:50  zahn-->
<!-- 	Merged with changes from 1.1.2.7-->
<!-- 	[1994/08/12  14:37:42  zahn]-->
<!-- -->
<!-- 	{review,9601,R1.1}-->
<!-- -->
<!-- 	Added Mariko Romagna's corrections-->
<!-- 	to the i18n ACF attribute documentation.-->
<!-- 	[1994/08/12  14:34:12  zahn]-->
<!-- -->
<!-- Revision 1.1.2.7  1994/08/11  20:36:26  jhh-->
<!-- 	expand copyright-->
<!-- 	[1994/08/11  19:58:27  jhh]-->
<!-- -->
<!-- Revision 1.1.2.6  1994/07/20  22:43:52  zahn-->
<!-- 	{def,11369,R1.1}-->
<!-- -->
<!-- 	Corrected references to obsolete-->
<!-- 	rpc_s_no_more_entries-->
<!-- -->
<!-- 	{enh,10505,R1.1}-->
<!-- -->
<!-- 	added some example code to binding_callout-->
<!-- 	section.-->
<!-- 	[1994/07/20  22:43:37  zahn]-->
<!-- -->
<!-- Revision 1.1.2.5  1994/07/20  18:13:43  zahn-->
<!-- 	{enh,10505,R1.1}-->
<!-- -->
<!-- 	Added a new section at the end of this chapter-->
<!-- 	that describes the binding_callout ACF interface-->
<!-- 	attribute.  Also added binding_callout information-->
<!-- 	to tables, syntax descriptions, and ACF bnf.-->
<!-- 	[1994/07/20  18:13:25  zahn]-->
<!-- -->
<!-- Revision 1.1.2.4  1994/07/18  20:44:02  zahn-->
<!-- 	{enh,11292,R1.1}-->
<!-- -->
<!-- 	Added syntax descriptions to 1.0.3 ACF attribute-->
<!-- 	documentation supplied by Digital, updated ACF-->
<!-- 	syntax summaries to include both 1.0.3 and 1.1-->
<!-- 	ACF attribute syntaxes, and added syntax descriptions-->
<!-- 	for new 1.1 ACF attribute (binding_callout)-->
<!-- -->
<!-- 	{edt,9601,R1.1}-->
<!-- -->
<!-- 	Revised descriptions of 1.0.3 ACF attributes-->
<!-- 	supplied by Digital for conformance to OSF style-->
<!-- 	to other ACF attribute descriptions in the ACF-->
<!-- 	chapter.-->
<!-- -->
<!-- 	{def,10526,R1.1}-->
<!-- -->
<!-- 	Consolidated descriptions of i18n ACF attributes-->
<!-- 	that formerly existed in app_gd/rpc/10b_ichar_support.gpsml-->
<!-- 	into sections on each attribute.  Removed information-->
<!-- 	that is repeated in the DCE RPC API reference pages-->
<!-- 	for automatic code set conversion.-->
<!-- 	[1994/07/18  20:43:45  zahn]-->
<!-- -->
<!-- Revision 1.1.2.3  1994/07/13  19:41:48  zahn-->
<!-- 	{def.10526,R1.1}-->
<!-- -->
<!-- 	Added 10b_ichar_support.gpsml wholesale as-->
<!-- 	a section "Attributes for Internationalized RPC".-->
<!-- 	Section still needs to be reviewed for deletions,-->
<!-- 	possible movement into idl.gpsml or internationalized.gpsml.-->
<!-- 	[1994/07/13  19:40:37  zahn]-->
<!-- -->
<!-- Revision 1.1.2.2  1994/07/12  22:18:14  zahn-->
<!-- 	{def,10526,R1.1}-->
<!-- -->
<!-- 	Moved part of section on encode, decode attributes-->
<!-- 	here from section "Creating Portable Data with the-->
<!-- 	IDL Encoding Services" in /app_gd/rpc/topics.gpsml-->
<!-- 	and included pointer to "Creating Portable..." chapter.-->
<!-- 	[1994/07/12  22:17:57  zahn]-->
<!-- -->
<!-- Revision 1.1.2.1  1994/07/08  16:01:43  jshirley-->
<!-- 	{def,10526,R1.1}-->
<!-- 	Created new file for the RPC reorganization based on the old file-->
<!-- 	.../rpc/10_acf.gpsml.-->
<!-- 	[1994/07/08  16:01:17  jshirley]-->
<!-- -->
<!---->
<!---->
<Chapter Id="DCEADG.RPCACF.div.1">
<Title>Attribute Configuration Language</Title>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.1">
<Primary>Attribute Configuration Language</Primary>
</IndexTerm>The Attribute Configuration Language is used for writing an Attribute
Configuration File (ACF).
Use the attributes in the ACF
to modify the interaction between 
the application code and stubs without affecting the client/server network
interaction.
</Para>
<Sect1 Id="DCEADG.RPCACF.div.2">
<Title>Syntax Notation Conventions</Title>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.2">
<Primary>Attribute Configuration Language</Primary>
<Secondary>syntax</Secondary>
</IndexTerm>The syntax of the Attribute Configuration Language is similar to the syntax
of IDL.  For syntax information, see the
syntax notation conventions for the IDL.
</Para>
<Para>The use of <Literal>[ ]</Literal>&nbsp; (brackets) 
can be either a required part of the syntax or can
denote that a string is optional to the syntax.  To differentiate 
this, brackets that are required are shown as [ ]&nbsp; (plain square brackets). 
Brackets that contain optional strings are shown as <Symbol Role="Variable">[ ]&nbsp;</Symbol> (italicized 
square brackets).
</Para>
<Para>A <Literal>|</Literal> (vertical bar) denotes a logical OR. 
</Para>
</Sect1>
<Sect1 Id="DCEADG.RPCACF.div.3">
<Title>Attribute Configuration File</Title>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.3">
<Primary>attributes</Primary>
<Secondary>ACF</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.4">
<Primary>ACF</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.5">
<Primary>ACF</Primary>
<SeeAlso>Attribute Configuration Language</SeeAlso>
</IndexTerm>The ACF changes the way the IDL compiler
interprets the interface definition, written in IDL. 
<IndexTerm Id="DCEADG.RPCACF.indx.6">
<Primary>IDL</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.7">
<Primary>Interface Definition Language</Primary>
<See>IDL</See>
</IndexTerm>The IDL file defines
a means of interaction between a client and a server.  For new server
implementations
<IndexTerm Id="DCEADG.RPCACF.indx.8">
<Primary>client</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.9">
<Primary>server</Primary>
</IndexTerm>to be compatible across the network with existing servers, the interaction
between the client and server must not be modified.  If the interaction
between an application and a specific stub needs to change, you 
must provide an ACF when you build this stub.
</Para>
<Para>The ACF affects only the interaction between the generated stub code
and the local application code; it has no effect on the interaction
between local and remote stubs.  Therefore, client and server writers
are likely to have different attribute configuration files that they
can modify as desired.
</Para>
<Sect2 Id="DCEADG.RPCACF.div.4">
<Title>Naming the ACF</Title>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.10">
<Primary>ACF</Primary>
<Secondary>naming</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.11">
<Primary>ACF</Primary>
<Secondary>file extension</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.12">
<Primary>file</Primary>
<Secondary>name, ACF</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.13">
<Primary>file</Primary>
<Secondary>extension, ACF</Secondary>
</IndexTerm>To name the ACF, replace the extension of the IDL
file (<Filename>.idl</Filename>) with the extension of the ACF (<Filename>.acf</Filename>).
For example, the ACF associated with 
<Symbol Role="Variable">my_idl_filename</Symbol><Filename>.idl </Filename> is <Symbol Role="Variable">my_idl_filename</Symbol><Filename>.acf</Filename>.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCACF.div.5">
<Title>Compiling the ACF</Title>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.14">
<Primary>ACF</Primary>
<Secondary>compiling</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.15">
<Primary>compiling</Primary>
<Secondary>ACF</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.16">
<Primary>idl command</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.17">
<Primary>commands</Primary>
<Secondary>idl</Secondary>
</IndexTerm>When you issue the <Command>idl</Command> command, naming the IDL file to 
compile, it searches for a corresponding ACF
and compiles it along with the IDL file.  The compiler also searches 
for any ACF (there can be more than one) associated with any imported 
IDL files.  The stubs that the compiler creates contain the appropriate 
modifications.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCACF.div.6">
<Title>ACF Features</Title>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.18">
<Primary>ACF</Primary>
<Secondary>features</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.19">
<Primary>ACF</Primary>
<Secondary>attribute list</Secondary>
</IndexTerm>The following list contains the ACF attributes and the features associated
with the attributes:
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>include</Literal>&ensp;statement: 
Includes header files in the generated code
</Para>
</ListItem>
<ListItem>
<Para><Literal>auto_handle</Literal>, <Literal>explicit_handle</Literal>, <Literal>implicit_handle</Literal>,
<Literal>binding_callout</Literal>: Controls binding
</Para>
</ListItem>
<ListItem>
<Para><Literal>comm_status</Literal>, <Literal>fault_status</Literal>: 
Indicates parameters to hold status conditions occurring in the call
</Para>
</ListItem>
<ListItem>
<Para><Literal>cs_char</Literal>, <Literal>cs_tag_rtn</Literal>, <Literal>cs_stag</Literal>,
<Literal>cs_drtag</Literal>, <Literal>cs_rtag</Literal>: Controls the transmission of
international (non-PCS) characters
</Para>
</ListItem>
<ListItem>
<Para><Literal>code</Literal>, <Literal>nocode</Literal>: 
Controls which operations of the IDL file are compiled
</Para>
</ListItem>
<ListItem>
<Para><Literal>encode</Literal>, <Literal>decode</Literal>:
Controls the generation of IDL encoding services stubs to perform encoding
or decoding operations
</Para>
</ListItem>
<ListItem>
<Para><Literal>extern_exceptions</Literal>:
Indicates user-defined parameters to hold status conditions occurring in the
call
</Para>
</ListItem>
<ListItem>
<Para><Literal>represent_as</Literal>: 
Controls conversion between local and network data types
</Para>
</ListItem>
<ListItem>
<Para><Literal>enable_allocate</Literal>: 
Forces the initialization of the memory management routines
</Para>
</ListItem>
<ListItem>
<Para><Literal>heap</Literal>: 
Specifies objects to be allocated from heap memory
</Para>
</ListItem>
<ListItem>
<Para><Literal>cxx_lookup, cxx_delegate, cxx_new, cxx_static</Literal>: 
Specifies C++ features
</Para>
</ListItem>
</ItemizedList>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.RPCACF.div.7">
<Title>Structure</Title>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.20">
<Primary>ACF</Primary>
<Secondary>structure</Secondary>
</IndexTerm>The structure of the ACF is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">interface_header</Symbol>
<Literal>{</Literal>
<Symbol Role="Variable">interface_body</Symbol>
<Literal>}</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para><?sml-need 4>Follow these structural rules when creating an ACF:
</Para>
<ItemizedList>
<ListItem>
<Para>The basename of the ACF must be the same as the basename of the IDL file
although the extensions are different.
</Para>
</ListItem>
<ListItem>
<Para>The interface name in the ACF must be the same as
the interface name in the corresponding IDL file.
</Para>
</ListItem>
<ListItem>
<Para>With a few exceptions, any type, parameter,
or operation names in the ACF must be declared in the IDL file,
or defined in files included by use of the <Literal>include</Literal> statement, 
as the same class of name.
</Para>
</ListItem>
<ListItem>
<Para>Except for additional status parameters, any parameter name that occurs
within an operation in the ACF must also occur
within that operation in the IDL file.
</Para>
</ListItem>
</ItemizedList>
<Sect2 Id="DCEADG.RPCACF.div.8">
<Title>ACF Interface Header</Title>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.21">
<Primary>ACF</Primary>
<Secondary>header</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.22">
<Primary>header</Primary>
<Secondary>ACF</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.23">
<Primary>interface</Primary>
<Secondary>header</Secondary>
</IndexTerm>The ACF interface header has the following structure:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">[</Symbol>[<Symbol Role="Variable">acf_attribute_list</Symbol>]<Symbol Role="Variable">] </Symbol><Literal>interface</Literal> <Symbol Role="Variable">idl_interface_name</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Symbol Role="Variable">acf_attribute_list</Symbol> is optional. The interface header
attributes can include one or more of the following attributes, entered 
within brackets.  If you use more than one attribute, separate them with
commas and include the list within a single pair of brackets.
(Note that some of these attributes can be used in the ACF body also.
See Section 19.3.2 for more information.)
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>code</Literal>
<IndexTerm Id="DCEADG.RPCACF.indx.24">
<Primary>code attribute</Primary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para><Literal>nocode</Literal>
<IndexTerm Id="DCEADG.RPCACF.indx.25">
<Primary>nocode attribute</Primary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para><Literal>implicit_handle</Literal><Literal>(</Literal><Symbol Role="Variable">handle_type</Symbol> <Symbol Role="Variable">handle_name</Symbol><Literal>)</Literal>
<IndexTerm Id="DCEADG.RPCACF.indx.26">
<Primary>implicit_handle attribute</Primary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para><Literal>auto_handle</Literal>
<IndexTerm Id="DCEADG.RPCACF.indx.27">
<Primary>auto_handle attribute</Primary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para><Literal>explicit_handle</Literal>
<IndexTerm Id="DCEADG.RPCACF.indx.28">
<Primary>explicit_handle attribute</Primary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para><Literal>encode</Literal>
<IndexTerm Id="DCEADG.RPCACF.indx.29">
<Primary>encode attribute</Primary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para><Literal>decode</Literal>
<IndexTerm Id="DCEADG.RPCACF.indx.30">
<Primary>decode attribute</Primary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para><Literal>binding_callout(</Literal><Symbol Role="Variable">routine_name</Symbol><Literal>)</Literal>
<IndexTerm Id="DCEADG.RPCACF.indx.31">
<Primary>binding_callout attribute</Primary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<?sml-need 3>
<Para><Literal>extern_exceptions(</Literal><Symbol Role="Variable">exception_name[</Symbol><Literal>,</Literal><Symbol Role="Variable">exception_name]...</Symbol><Literal>)
<IndexTerm Id="DCEADG.RPCACF.indx.32">
<Primary>extern_exceptions attribute</Primary>
</IndexTerm></Literal></Para>
</ListItem>
<ListItem>
<Para><Literal>cs_tag_rtn(</Literal><Symbol Role="Variable">tag_set_routine</Symbol><Literal>)</Literal>
<IndexTerm Id="DCEADG.RPCACF.indx.33">
<Primary>cs_tag_rtn attribute</Primary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para><Literal>cxx_lookup</Literal>(<Symbol Role="Variable">function_name</Symbol>)
<IndexTerm Id="DCEADG.RPCACF.indx.34">
<Primary>cxx_lookup</Primary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<IndexTerm Id="DCEADG.RPCACF.indx.35">
<Primary>cxx_delegate</Primary>
</IndexTerm>
<Para><Literal>cxx_delegate</Literal>(<Symbol Role="Variable">class_name</Symbol>)
</Para>
</ListItem>
</ItemizedList>
<Para>The following example shows how to use more than one attribute in 
the ACF interface header:
</Para>
<InformalExample>
<Para><ProgramListing>[auto_handle, binding_callout(rpc_ss_bind_authn_client)] \
  interface phone_direct
{
}
</ProgramListing></Para>
</InformalExample>
</Sect2>
<Sect2 Id="DCEADG.RPCACF.div.9">
<Title>ACF Interface Body</Title>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.36">
<Primary>ACF</Primary>
<Secondary>body</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.37">
<Primary>interface</Primary>
<Secondary>body</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.38">
<Primary>body, ACF</Primary>
</IndexTerm>The ACF interface body can contain the elements in the following
list.  Note that
some of the attributes listed here can also be used in the ACF header,
as described in Section 19.3.1. If you use more than one attribute,
separate them with commas and include the list within a single pair of
brackets.
</Para>
<ItemizedList>
<ListItem>
<Para>An <Literal>include</Literal> statement
<IndexTerm Id="DCEADG.RPCACF.indx.39">
<Primary>include statement</Primary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para>A declared type</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>typedef </Literal><Symbol Role="Variable">[</Symbol><Literal>[represent_as (</Literal><Symbol Role="Variable">local_type_name</Symbol><Literal>)] | </Literal><Literal>[heap]</Literal> | 
<Literal>[cs_char (</Literal><Symbol Role="Variable">local_type_name</Symbol><Literal>)]</Literal><Symbol Role="Variable">] </Symbol><Symbol Role="Variable">type_name</Symbol><Literal>;</Literal></UserInput></ProgramListing></Para>
<IndexTerm Id="DCEADG.RPCACF.indx.40">
<Primary>represent_as attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.41">
<Primary>heap attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.42">
<Primary>cs_char attribute</Primary>
</IndexTerm>
</InformalExample>
</ListItem>
<ListItem>
<Para>An operation</Para>
<IndexTerm Id="DCEADG.RPCACF.indx.43">
<Primary>comm_status attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.44">
<Primary>fault_status attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.45">
<Primary>enable_allocate attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.46">
<Primary>cs_tag_rtn attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.47">
<Primary>encode attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.48">
<Primary>decode attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.49">
<Primary>errors</Primary>
<Secondary>attributes</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.50">
<Primary>status</Primary>
<Secondary>attributes</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.51">
<Primary>failures</Primary>
<Secondary>attributes</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.52">
<Primary>failures</Primary>
<SeeAlso>status</SeeAlso>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.53">
<Primary>errors</Primary>
<SeeAlso>status</SeeAlso>
</IndexTerm>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">[</Symbol><Literal>[explicit_handle]</Literal> | <Literal>[comm_status]</Literal> | <Literal>[fault_status]</Literal> |
<Literal>[code]</Literal> | <Literal>[nocode]</Literal> | <Literal>[enable_allocate]</Literal> |
<Literal>[cxx_new</Literal>(<Symbol Role="Variable">manager_class</Symbol>)<Literal>]</Literal> | <Literal>[cxx_static]</Literal> | <Literal>[cxx_static</Literal>(<Symbol Role="Variable">local_function</Symbol>)<Literal>]</Literal> | 
<Literal>[encode]</Literal> | <Literal>[decode]</Literal> | <Literal>[cs_tag_rtn (</Literal><Symbol Role="Variable">tag_set_routine</Symbol><Literal>)]</Literal><Symbol Role="Variable">] 
operation_name </Symbol><Literal>(</Literal><Symbol Role="Variable">[parameter_list]</Symbol><Literal>);
</Literal></UserInput></ProgramListing></Para>
</InformalExample>
<Para><?sml-need 6>A <FirstTerm>parameter_list</FirstTerm> is a list of zero or more parameter
names as they appear in the corresponding operation definition of
the IDL file.  You do not need to use all the parameter names that
occur in the IDL operation definition; use only those to which you attach
an ACF attribute.  If you use more than one parameter name, the names must
be separated by commas.
</Para>
</ListItem>
<ListItem>
<Para>A parameter within an operation
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">[</Symbol><Literal>[comm_status]</Literal> | <Literal>[fault_status]</Literal> | <Literal>[heap]</Literal> | 
<Literal>[cs_stag]</Literal> | <Literal>[cs_drtag]</Literal> | <Literal>[cs_rtag]</Literal><Symbol Role="Variable">] parameter_name</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<IndexTerm Id="DCEADG.RPCACF.indx.54">
<Primary>cs_drtag attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.55">
<Primary>cs_rtag attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.56">
<Primary>cs_stag attribute</Primary>
</IndexTerm>
</ListItem>
</ItemizedList>
</Sect2>
<Sect2 Id="DCEADG.RPCACF.div.10">
<Title>The include Statement and the C++ Attributes cstub and sstub</Title>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.57">
<Primary>include statement in ACF</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.58">
<Primary>cstub attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.59">
<Primary>sstub attribute</Primary>
</IndexTerm>The <Literal>include</Literal> statement specifies any additional header files you
want included in the generated stub code.  You can specify more than
one header file.  The <Literal>include</Literal> statement is placed in the body of
the ACF and has the following syntax:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>include "</Literal><Symbol Role="Variable">filename</Symbol><Literal>" </Literal><Symbol Role="Variable">[</Symbol><Literal>,"</Literal><Symbol Role="Variable">filename</Symbol><Literal>"</Literal><Symbol Role="Variable">]</Symbol> ...<Literal>;</Literal>

<Symbol Role="Variable">[</Symbol> <Literal>[sstub | cstub | sstub, cstub]</Literal><Symbol Role="Variable">]</Symbol> <Literal>include "</Literal><Symbol Role="Variable">filename</Symbol><Literal>"</Literal>;
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>Do not specify the directory name or file extension when you use the
<Literal>include</Literal> statement.  The compiler appends the <Filename>.h</Filename> extension.
If you want to specify the directory name(s), use the <Option>cc_opt</Option> or
<Option>I</Option> IDL compiler command options.
</Para>
<Para>Use the <Literal>include</Literal> statement whenever you use the 
<Literal>represent_as, implicit_handle, cs_char, cxx_static, 
cxx_new, cxx_lookup</Literal>, or <Literal>cxx_delegate</Literal>
attributes and the specified type is not defined or imported in the
IDL file.
</Para>
<Para>The <Literal>sstub</Literal> and <Literal>cstub</Literal> attributes are optional.  By default,
the IDL compiler places directives only in the <Command>idl</Command>-generated
header file when neither the <Literal>sstub</Literal> nor <Literal>cstub</Literal> attributes
are used. These attributes restrict where <Literal>#include</Literal> compiler
directives are placed in order to include application-specific header
files in C++ client and server stub files.  In C++ applications, local
and remote versions of operations are included together by linking in
both the client and server stubs.  C++ applications need to control 
<Literal> #include</Literal> compiler directives so that the
operations for local objects can be easily renamed to avoid name
conflicts with the operations for remote objects.

</Para>
<Para>The following table shows to which output file the IDL compiler
places the <Literal>#include</Literal> compiler directive for the application-specific file.  
Note, that the idl-generated header file is always included automatically in each stub.
<!---->
<!-- TABLE TITLE: The ACF include Statement and Generated Compiler Directives-->
<?sml-point-size 11>
<!--no-op:  13-->
</Para>
<InformalTable Frame="all" Remap="center" Orient="Port" role="page-wide">
<TGroup Rowsep="1" Colsep="1" Cols="6">
<ColSpec Rowsep="0" Colsep="0" Colwidth="0.01*">
<ColSpec Rowsep="1" Colsep="1" Align="Left" Colwidth="2*" Colname="col1" Colnum="1">
<ColSpec Rowsep="1" Colsep="1" Align="Center" Colwidth="1*" Colname="col2" Colnum="2">
<ColSpec Rowsep="1" Colsep="1" Align="Center" Colwidth="1*" Colname="col3" Colnum="3">
<ColSpec Rowsep="1" Colsep="1" Align="Center" Colwidth="1*" Colname="col4" Colnum="4">
<ColSpec Rowsep="0" Colsep="1" Colwidth="0.01*" Colname="col5" Colnum="5">
<thead>
<row>
<entry rowsep="0" colsep="0"></entry>
<entry rowsep="1" colsep="0"></entry>
<entry rowsep="1" colsep="0"></entry>
<entry rowsep="1" colsep="0"></entry>
<entry rowsep="1" colsep="0"></entry>
<entry rowsep="1" colsep="1"></entry>
</row>
<Row>
<Entry rowsep="0"></Entry>
<Entry><Literal>ACF Statement</Literal></Entry>
<Entry><Literal>Header File</Literal></Entry>
<Entry><Literal>Client Stub</Literal></Entry>
<Entry><Literal>Server Stub </Literal></Entry>
<Entry></Entry>
</Row>
</thead>
<tbody>
<Row>
<Entry rowsep="0"></Entry>
<Entry><Literal>include</Literal> "<Symbol Role="Variable">file</Symbol>";</Entry>
<Entry><Literal>X</Literal></Entry>
<Entry></Entry>
<Entry> </Entry>
<Entry></Entry>
</Row>
<Row>
<Entry rowsep="0"></Entry>
<Entry><Literal>[cstub] include</Literal> "<Symbol Role="Variable">file</Symbol>";</Entry>
<Entry></Entry>
<Entry><Literal>X</Literal></Entry>
<Entry> </Entry>
<Entry></Entry>
</Row>
<Row>
<Entry rowsep="0"></Entry>
<Entry><Literal>[sstub] include</Literal> "<Symbol Role="Variable">file</Symbol>";</Entry>
<Entry></Entry>
<Entry></Entry>
<Entry>X </Entry>
<Entry></Entry>
</Row>
<Row>
<Entry rowsep="0"></Entry>
<Entry><Literal>[cstub, sstub] include</Literal> "<Symbol Role="Variable">file</Symbol>";</Entry>
<Entry></Entry>
<Entry><Literal>X</Literal></Entry>
<Entry>X </Entry>
<Entry></Entry>
</Row>

<row>
<entry rowsep="1" colsep="0"></entry>
<entry rowsep="1" colsep="0"></entry>
<entry rowsep="1" colsep="0"></entry>
<entry rowsep="1" colsep="0"></entry>
<entry rowsep="1" colsep="0"></entry>
<entry rowsep="1" colsep="1"></entry>
</row>

</TBody>
</TGroup>
</InformalTable>
<?sml-point-size 12>
<!--no-op:  14-->
<?sml-space .5>
<!--.H 3 "The include Statement"-->
<!--.PP-->
<!--.iX "include statement"-->
<!--.iX "represent_as attribute"-->
<!--.iX "implicit_handle attribute"-->
<!--.iX "cs_char attribute"-->
<!--This statement specifies any additional header files you want included in-->
<!--the generated stub code.  You can specify more than one header file.-->
<!--Do not specify the directory name or file extension when -->
<!--you use the \*Linclude\*O statement.  The -->
<!--compiler appends the correct extension for the -->
<!--language you are using.  For C, the compiler-->
<!--appends the \*L.h\*O extension.-->
<!--If you want to specify the directory name(s), use the \*L-cc_opt\*O or-->
<!--\*L-I\*O IDL compiler command arguments.-->
<!--.P-->
<!--Use the \*Linclude\*O statement whenever you use the \*Lrepresent_as\*O,-->
<!--\*Limplicit_handle\*O, or \*Lcs_char\*O attributes and the specified-->
<!--type is not defined or imported in the IDL file.-->
<!--.P-->
<!--The \*Linclude\*O statement has the following syntax.  (An example-->
<!--is shown with the \*Lrepresent_as\*O example in Section 19.3.9.)-->
<!--.iS-->
<!--\*Linclude "\*Vfilename\*L";\*O-->
<!--.iE-->
</Sect2>
<Sect2 Id="DCEADG.RPCACF.div.11">
<Title>The auto_handle Attribute</Title>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.60">
<Primary>auto_handle attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.61">
<Primary>automatic binding</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.62">
<Primary>binding</Primary>
<Secondary>automatic</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.63">
<Primary>runtime</Primary>
</IndexTerm>This attribute causes the client stub and RPC runtime to manage the
binding to the server by using a directory service.  Any operation in the
interface that has no parameter containing binding information
is bound automatically to a server so the client does not
have to specify a binding to a server.
</Para>
<Para RevisionFlag="Changed">When an operation is automatically bound, the client does not
have to specify the server on which an operation executes.  If
you make a call on an operation without explicit binding information
in an interface for which you have
specified <Literal>auto_handle</Literal>, and no client/server binding
currently exists, the client stub selects an available server
and establishes a binding.  This binding is used for this call
and subsequent calls to all operations in the interface
that do not include explicit binding information, while the
server is still available.
<?og-ChangeStart def,13492,R1.2.2,idl info missing from guide"></Para>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.64">
<Primary RevisionFlag="Changed">host profile</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.65">
<Primary RevisionFlag="Changed">RPC_DEFAULT_ENTRY</Primary>
</IndexTerm>When a client uses the automatic binding method, 
DCE must use the name service to obtain binding information.
However, the client host must have a starting entry 
from which to begin the namespace search.
If the <Literal RevisionFlag="Changed">RPC_DEFAULT_ENTRY</Literal> environment variable 
is defined on the client host, DCE uses the entry in that variable
to obtain binding information. 
If <Literal RevisionFlag="Changed">RPC_DEFAULT_ENTRY</Literal> is not defined, 
DCE looks for binding information from the host's 
name service profile.
<?og-ChangeEnd def,13492,R1.2.2,idl info missing from guide"></Para>
<Para>Server termination, network failure, or other problems can cause a
break in binding.  If this occurs during the execution of an automatically
bound operation, the client stub issues the call to another server, provided
one is available and the operation is idempotent, or it
determines that the call did not start to run on the server.
Similarly, if a communications or server failure occurs
between calls, the client stub binds to another server for
the next call, if a server is available.
</Para>
<Para>If the client stub is unable to find a server to run
<IndexTerm Id="DCEADG.RPCACF.indx.66">
<Primary>exceptions</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.67">
<Primary>status</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.68">
<Primary>failures</Primary>
</IndexTerm>the operation, it reports this by returning the status code
<Literal>rpc_s_no_more_bindings</Literal> in the <Literal>comm_status</Literal> parameter,
or by raising the exception <Literal>rpc_x_no_more_bindings</Literal> if
the operation does not use the <Literal>comm_status</Literal> attribute
<IndexTerm Id="DCEADG.RPCACF.indx.69">
<Primary>comm_status attribute</Primary>
</IndexTerm>for error reporting.  Note that, if a binding breaks, the search
for another server begins at the directory service entry
following the one where the binding broke.  This means that,
even if a server earlier in the list becomes available, it
is not treated as a candidate for binding.
After the RPC runtime tries each server in the list, it reinitializes
the list of server candidates and tries again.  If the second attempt
is unsuccessful, the RPC runtime reports the status code
<Literal>rpc_s_no_more_bindings</Literal>.
The next call on an operation in the interface starts from the top
of the list when looking for a server to bind to. 
</Para>
<Para>The <Literal>auto_handle</Literal> attribute can occur at most once in the ACF.
</Para>
<Para>If an interface uses the<Literal> auto_handle</Literal> attribute, the presence
of a binding handle or context handle parameter in an operation 
overrides <Literal>auto_handle</Literal> for that operation.
</Para>
<Para>The <Literal>auto_handle </Literal>attribute declaration has the following syntax.
(See the example at the end of this section.)
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>[auto_handle] interface </Literal><Symbol Role="Variable">interface_name</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>You cannot use <Literal>auto_handle</Literal> if you use <Literal>implicit_handle</Literal> or if
you use <Literal>explicit_handle</Literal> in the interface header.
You also cannot use <Literal>auto_handle</Literal> if you use the <Literal>encode</Literal> or
<Literal>decode</Literal> ACF attributes.
<!--.ne 4.0i-->
<!--.TB "auto_handle Example"-->
<!--.rs-->
<!--.sp 3.5i-->
<!--.in +3.5i-->
<!--.P! pictures/11_idl_acf_60.ps 3.20i-->
</Para>
<Para><Literal>Example Using the auto_handle Attribute</Literal>
</Para>
<Para><Literal>ACF</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>[auto_handle] interface math_1
{
}
</ProgramListing></Para>
</InformalExample>
<Para><Literal>IDL File</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>[uuid(b3c86900-2d27-11c9-ab09-08002b0ecef1)]
interface math_1
{
/* This operation has no handle parameter,
 * therefore, uses automatic binding.
 */
long add([in] long a, 
         [in] long b);

/*
 * This operation has an explicit handle parameter, h, 
 * that overrides the [auto_handle] ACF attribute.
 * Explicit handles also override [implicit_handle].
 */
long subtract ([in] handle_t h,
               [in] long a, 
               [in] long b);
}
</ProgramListing></Para>
</InformalExample>
</Sect2>
<Sect2 Id="DCEADG.RPCACF.div.12">
<Title>The explicit_handle Attribute</Title>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.70">
<Primary>explicit_handle attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.71">
<Primary>binding</Primary>
<Secondary>explicit</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.72">
<Primary>explicit binding</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.73">
<Primary>additional parameter</Primary>
</IndexTerm>This attribute allows the application program to manage the binding to
the server.
The <Literal>explicit_handle</Literal> attribute indicates that a binding handle is
passed to the runtime as an operation parameter. 
</Para>
<Para>The <Literal>explicit_handle</Literal> attribute has the following syntax.
(See the example at the end of this section.)
</Para>
<Para>For an interface:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>[explicit_handle]</Literal> <Literal>interface</Literal> <Symbol Role="Variable">interface_name</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>For an operation:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>[explicit_handle]</Literal> <Symbol Role="Variable">operation_name</Symbol> <Literal>(</Literal><Symbol Role="Variable">[</Symbol><Symbol Role="Variable">parameter_list]</Symbol><Literal>);
</Literal></UserInput></ProgramListing></Para>
</InformalExample>
<Para>When used as an ACF interface attribute, the <Literal>explicit_handle</Literal> attribute
applies to all operations in the IDL file.  When used as an ACF operation 
attribute, this attribute applies to only the operation you specify.
</Para>
<Para>If you use the <Literal>explicit_handle</Literal> attribute as an ACF interface attribute,
you must not use the <Literal>auto_handle</Literal> or <Literal>implicit_handle</Literal> attributes.
Also, you cannot use the <Literal>encode</Literal> and <Literal>decode</Literal> attributes if you
use <Literal>explicit_handle</Literal>.
</Para>
<Para>Using the <Literal>explicit_handle</Literal> attribute on an interface or operation
has no effect on operations in IDL that have explicit binding information 
in their parameter lists.
</Para>
<Para><Literal>Example Using the explicit_handle Attribute</Literal>
</Para>
<Para><Literal>ACF</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>[explicit_handle] interface math_2
{

  /* This causes the operation, as called by the client, to 
   * have the parameter handle_t IDL_handle, at the start of 
   * the parameter list, before the parameters specified here 
   * in the IDL file.
   */
}
</ProgramListing></Para>
</InformalExample>
<Para><?sml-need 8><Literal>IDL File</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>[uuid(41ce5b80-0ba7-11ca-87ba-08002b111685)]
interface math_2
{
long add([in] long a,
         [in] long b);
}
</ProgramListing></Para>
</InformalExample>
</Sect2>
<Sect2 Id="DCEADG.RPCACF.div.13" RevisionFlag="Changed">
<Title>The implicit_handle Attribute</Title>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.74">
<Primary>implicit_handle attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.75">
<Primary>binding</Primary>
<Secondary>implicit</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.76">
<Primary>implicit binding</Primary>
</IndexTerm>This attribute allows the application program to manage the binding
to the server.  You specify the data type and name of the handle variable
as part of the <Literal>implicit_handle</Literal> attribute. 
The <Literal>implicit_handle</Literal> attribute
informs the compiler of the name and type of the global variable through which
the binding handle is implicitly passed to the client stub.
A variable of this
type and name is defined in the client stub code, and
the application initializes the variable before making a call to this
interface.
</Para>
<Para>The <Literal>implicit_handle</Literal> attribute declaration has the following
syntax.  (See the example at the end of this section.)
</Para>
<Para>For an interface:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>[implicit_handle (</Literal><Symbol Role="Variable">handle_type handle_name</Symbol><Literal>)] interface</Literal> <Symbol Role="Variable">interface_name</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>If an interface uses the <Literal>implicit_handle</Literal> attribute, the presence
of a binding handle or <Literal>in</Literal> or <Literal>in,out</Literal>
context handle parameter in an operation overrides the implicit
handle for that operation.
</Para>
<Para>The <Literal>implicit_handle</Literal> attribute can occur at most once in the ACF.
</Para>
<Para>You cannot use the <Literal>implicit_handle</Literal> attribute if you
are using the <Literal>auto_handle</Literal> attribute or the <Literal>explicit_handle</Literal>
attribute as an interface attribute.
You also cannot use <Literal>implicit_handle</Literal> if you use the <Literal>encode</Literal> or
<Literal>decode</Literal> ACF attributes.
</Para>
<Para>If the type in the<Literal> implicit_handle</Literal> clause is not <StructName Role="typedef">handle_t</StructName>,
then it is treated as if it has the <Literal>handle</Literal> attribute.
<!-- .cS-->
<!-- For-->
<!-- more information, refer to the description of the \*Lhandle\*O-->
<!-- attribute in Chapter 17 of this guide.-->
<!-- .cE-->
</Para>
<Para>The ACF in the following example modifies the <Literal>math_3</Literal> interface to use
an implicit handle.
<!--.ne 3.0i-->
<!--.TB "implicit_handle Example"-->
<!--.rs-->
<!--.sp 2.5i-->
<!--.in -0.1i-->
<!--.P! pictures/11_idl_acf_50.ps 2.5i-->
</Para>
<Para><Literal>Example Using the implicit_handle Attribute</Literal>
</Para>
<Para><Literal>ACF</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>[implicit_handle(user_handle_t global_handle)] interface math_3
{
/*
 * Since user_handle_t is not a type defined in IDL, you
 * must specify an header file that contains the definition
 */
include "user_handle_t_def";
}
</ProgramListing></Para>
</InformalExample>
<Para><Literal>IDL File</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>[uuid(a01d0280-2d27-11c9-9fd3-08002b0ecef1)]
interface math_3
{
long add([in] long a, 
         [in] long b);
}
</ProgramListing></Para>
</InformalExample>
<?og-ChangeStart def,13492,R1.2.2,idl info missing from guide">
</Sect2>
<Sect2 Id="DCEADG.RPCACF.div.14">
<Title RevisionFlag="Changed">The client_memory Attribute</Title>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.77">
<Primary RevisionFlag="Changed">client_memory ACF attribute</Primary>
</IndexTerm>While marshalling parameters, the client stub uses built-in 
routines to manage memory. 
You can use the <Literal RevisionFlag="Changed">client_memory</Literal> attribute to specify different 
memory allocation and free routines. 
The <Literal RevisionFlag="Changed">client_memory</Literal> attribute has the following syntax 
in the ACF header:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal RevisionFlag="Changed">[client_memory(</Literal><Symbol Role="Variable" RevisionFlag="Changed">malloc_routine, free_routine</Symbol><Literal RevisionFlag="Changed">)] interface</Literal> <Symbol Role="Variable" RevisionFlag="Changed">idl
_interface_name</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para RevisionFlag="Changed">The routines you specify must have the same respective
procedure declarations as the system's 
<Function>malloc()</Function> and <Function>free()</Function> routines. 
</Para>
<Para RevisionFlag="Changed">Applications need to manage memory consistently, 
so if your application needs to do other memory allocation, 
be sure to use the same routines you specified 
with the <Literal>client_memory</Literal> attribute.
</Para>
<Para RevisionFlag="Changed">You can use the <Literal>client_memory</Literal> attribute in conjunction 
with RPC stub support API routines such as 
<Function>rpc_sm_set_client_alloc_free()</Function> and
<Function>rpc_sm_swap_client_alloc_free()</Function>.
<?og-ChangeEnd def,13492,R1.2.2,idl info missing from guide"></Para>
</Sect2>
<Sect2 Id="DCEADG.RPCACF.div.15">
<Title>The comm_status and fault_status Attributes</Title>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.78">
<Primary>comm_status attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.79">
<Primary>fault_status attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.80">
<Primary>status</Primary>
<Secondary>attributes</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.81">
<Primary>communication failure</Primary>
<Secondary>status attributes</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.82">
<Primary>exceptions</Primary>
<Secondary>server</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.83">
<Primary>server</Primary>
<Secondary>exceptions</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.84">
<Primary>exceptions</Primary>
<Secondary>client</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.85">
<Primary>client</Primary>
<Secondary>exceptions</Secondary>
</IndexTerm>The <Literal>comm_status</Literal> and <Literal>fault_status</Literal> attributes 
cause the status code of any communications failure or server
runtime failure that occurs in a remote procedure call to be stored 
in a parameter or returned as an operation result, instead of being 
raised to the client application code as an exception.
</Para>
<Para>The <Literal>comm_status</Literal> attribute causes communications failures to
be reported through a specified parameter.  The <Literal>fault_status</Literal>
attribute causes server failures to be reported through a specified
parameter.  Applying both attributes causes all remote and communications
failures to be reported through status.  Any local exception caused by
an error during marshalling, correctness checking performed by the
client stubs, or an error in application routines continues to be
returned as an exception.
</Para>
<Para>The <Literal>comm_status</Literal> and <Literal>fault_status</Literal> attributes have the following
syntax.  (See the examples at the end of this section.)
</Para>
<Para>For an operation:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>[comm_status</Literal> | <Literal>fault_status] </Literal><Symbol Role="Variable">operation_name </Symbol><Literal>(</Literal><Symbol Role="Variable">[parameter_list]</Symbol><Literal>);</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>For a parameter:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">operation_name</Symbol> <Literal>([comm_status</Literal> | <Literal>fault_status] </Literal><Symbol Role="Variable">parameter_name</Symbol><Literal>);</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Note>
<Para>You can apply one of each attribute to the same operation and/or 
parameter at the same time.  Separate the attributes with a comma. 
(See the example at the end of this section.)
</Para>
<Para>If the parameter named in a <Literal>comm_status</Literal> or <Literal>fault_status</Literal> attribute
is in the parameter list for the operation in the IDL file, then it must have
the <Literal>out</Literal> attribute in the IDL file. (Additional ACF parameters
do not have <Literal>in</Literal> and <Literal>out</Literal> directional attributes.)
</Para>
</Note>
<Para>If the status attribute occurs on the operation,
the returned value result must be defined as type <StructName Role="typedef">error_status_t</StructName>
in the IDL file. 
If an error occurs during execution of the operation,
the error code is returned as the operation result.  If the operation
completes successfully, the value returned to the client is the
value returned by the manager code.</Para>
<IndexTerm Id="DCEADG.RPCACF.indx.86">
<Primary>unsigned32 type</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.87">
<Primary>error_status_t type</Primary>
<SeeAlso>unsigned32 type</SeeAlso>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.88">
<Primary>additional parameter</Primary>
</IndexTerm>
<Note>
<Para>The <StructName Role="typedef">error_status_t</StructName> type is equivalent to <Literal>unsigned32</Literal>,
which is the data type used by the RPC runtime for an error status.
The status code <Literal>error_status_ok</Literal> is equivalent to <Literal>rpc_s_ok</Literal>,
which is the RPC runtime success status code.
</Para>
</Note>
<Para>If the status attribute occurs on a parameter, the parameter
name does not have to be defined in the IDL file,
although it can be.  Note the following:
</Para>
<ItemizedList>
<ListItem>
<Para>If the parameter name is one used in the IDL file,
then that parameter must be an output parameter of 
type <StructName Role="typedef">error_status_t</StructName>.  If the operation completes 
successfully, the value of this
parameter is the value returned by the manager code.
</Para>
</ListItem>
<ListItem>
<?sml-need 8>
<Para>If the parameter name is different from any name defined
within the operation definition in the IDL file, the IDL compiler
creates an extra output parameter of type <StructName Role="typedef">error_status_t</StructName>
in the application code after the last parameter defined in the IDL
file.  In a successfully completed remote call, this extra parameter
has the value <Literal>error_status_ok</Literal>.
</Para>
</ListItem>
</ItemizedList>
<Para>In either case, if an error occurs during the remote
call, the error code is returned to the parameter that has the
status attribute. (See the &DCETg; for an explanation of status codes.)
</Para>
<Para>If you define both additional <Literal>comm_status</Literal> and 
additional <Literal>fault_status</Literal>
parameters, they are automatically added at the end of the
procedure declaration in the order of specification in the ACF.
</Para>
<Para>In the following example, there are three possible uses of the 
status attributes: as the operation result of <Literal>add</Literal>, as a parameter
of<Literal> subtract</Literal> as defined in the IDL file, and as an additional parameter
of <Literal>multiply</Literal>.
</Para>
<Para><!--.ne 4.0i-->
<!--.TB "comm_status Example"-->
<!--.rs-->
<!--.sp 3.5i-->
<!--.in +1.875i-->
<!--.P! pictures/11_idl_acf_40.ps 3.5i-->
</Para>
<Para><Literal>Example Using the comm_status and fault_status Attributes</Literal>
</Para>
<Para><Literal>ACF</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>[auto_handle] interface math_4
{
[comm_status,fault_status] add();

subtract ([comm_status,fault_status] s);

/*
 * 'sts' is not a parameter in the interface definition of
 * operation 'multiply'. This specifies that the application
 * wants a trailing parameter 'sts' that is of type
 * error_status_t, after the parameters a and b.
 */
multiply ([comm_status] c_sts,[fault_status] f_sts);
}
</ProgramListing></Para>
</InformalExample>
<Para><?sml-need 14><Literal>IDL File</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>[uuid(91365000-2d28-11c9-ad5a-08002b0ecef1)]
interface math_4
{
error_status_t add ([in] double a,
                    [in] double b,
                    [out] double *c);
double subtract ([in] double a,
                [in] double b,
                [out] error_status_t *s);
double multiply ([in] double a,
                 [in] double b);
}
</ProgramListing></Para>
</InformalExample>
<Para><Filename>server.c</Filename>
</Para>
<InformalExample>
<Para><ProgramListing>/* 
 * The three server procedures below illustrate the different 
 * models of comm_status and fault_status appearing in the 
 * idl and acf declarations above.  
 * 
 * RPC automatically passes back DCE error codes through 
 * comm_status and fault_status.  These examples differ in 
 * their handling of the nonerror case.   
 */
    
error_status_t add (double a, 
                    double b, 
                    double * c)
<?sml-need 15>{
    ...
    *c = answer;

    /* 
     * comm_status and fault_status are operation attributes.
     * If no error occurs, the client will see the value that 
     * the server returns.    
     * 
     * We return error_status_ok here for the normal 
     * successful case. 
     */
    
    return error_status_ok;
}

double subtract (double a, 
                 double b, 
                 error_status_t * s)
{
    /* 
     * "s" appears in both the idl definition and the acf 
     * specification.  
     * 
     * In the successful case, the client is returned the 
     * value that the server puts in *s.  Therefore, assume
     * success here. 
     */
    
    *s = error_status_ok;

    ...
    return answer;
}

<?sml-need 22>double multiply (double a, 
                 double b, 
                 error_status_t * c_sts, 
	         error_status_t * f_sts)
{
    /* 
     * c_sts and f_sts appear in the acf, but do not appear 
     * in the idl definition.  In this case, c_sts and f_sts 
     * are placed at the end of the parameter list generated 
     * by the idl compiler.  To conform to the prototype 
     * generated by idl, your server code must also declare 
     * these parameters. 
     *
     * In the successful case, c_sts and f_sts are 
     * automatically returned to the client as 
     * error_status_ok.  Even though c_sts and f_sts are 
     * parameters to the function, the server code must not 
     * modify these parameters or store through them. 
     */
    
    ...
    return answer;
}
</ProgramListing></Para>
</InformalExample>
</Sect2>
<Sect2 Id="DCEADG.RPCACF.div.16">
<Title>The code and nocode Attributes</Title>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.89">
<Primary>code attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.90">
<Primary>nocode attribute</Primary>
</IndexTerm>The <Literal>code</Literal> and <Literal>nocode</Literal> attributes allow you to control
which operations in the IDL file have client stub code generated
for them by the compiler.  These attributes affect only the generation
of a client stub; they have no effect when generating the server stub.
</Para>
<Para>The <Literal>code</Literal> and <Literal>nocode</Literal> attributes have the following
syntax.  (See the example at the end of this section.)
</Para>
<Para>For an interface:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>[code</Literal> | <Literal>nocode]</Literal> <Literal>interface</Literal> <Symbol Role="Variable">interface_name</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para><?sml-need 3>For an operation:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>[code</Literal> | <Literal>nocode ]</Literal> <Symbol Role="Variable">operation_name</Symbol> <Literal>(</Literal><Symbol Role="Variable">[parameter_list]</Symbol><Literal>);</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>When you specify <Literal>nocode</Literal> as an attribute on an ACF interface,
stub code is not generated for the operations in the corresponding
IDL interface unless you also specify <Literal>code</Literal> for the particular
operation(s) for which you want stub code generated. 
Similarly, when you specify <Literal>code</Literal> (the default) as an attribute on an ACF
interface, stub code is generated for the operations in the corresponding
IDL interface unless you also specify <Literal>nocode</Literal> for the particular
operations for which you do not want stub code generated.
</Para>
<Para>Do <Symbol Role="Variable">not</Symbol> use <Literal>nocode</Literal> on any of the operations if the compiler
is generating only server stub code because it has no effect.
Server stubs must always contain generated code for all operations.
</Para>
<Para>In the following example, the IDL compiler generates client stub code
for the operations <Literal>open</Literal>, <Literal>read</Literal>, and <Literal>close</Literal>,
but not for the operation <Literal>write</Literal>.
An alternative method for specifying the same behavior is to
use <Literal>[nocode]</Literal> <Function>write()</Function> in the ACF.
</Para>
<Para><!--.ne 2.5i-->
<!--.TB "code and nocode Example"-->
<!--.rs-->
<!--.sp 2.0i-->
<!--.in +3.125i-->
<!--.P! pictures/11_idl_acf_10.ps 2.0i-->
</Para>
<Para><Literal>Example Using the code and nocode Attributes</Literal>
</Para>
<Para><Literal>ACF</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>[nocode,auto_handle] interface open_read_close
{
[code] open();
[code] read();
[code] close();
}
</ProgramListing></Para>
</InformalExample>
<Para><?sml-need 10><Literal>IDL File</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>[uuid(2166d580-0c69-11ca-811d-08002b111685)]
interface open_read_close
{
void open (...);
void read (...);
void write (...);
void close (...);
}
</ProgramListing></Para>
</InformalExample>
<!-- .cS-->
<!-- .H 3 "The in_line and out_of_line Attributes"-->
<!-- .PP-->
<!-- .iX "in_line attribute"-->
<!-- .iX "out_of_line attribute"-->
<!-- .iX "client" "auxiliary file"-->
<!-- .iX "server" "auxiliary file"-->
<!-- .iX "auxiliary file"-->
<!-- The \*Lin_line\*O and \*Lout_of_line\*O attributes control whether-->
<!-- marshalling and unmarshalling are performed by inline code-->
<!-- .iX "marshalling"-->
<!-- .iX "routines" "marshalling"-->
<!-- or by out-of-line code through a subroutine call.-->
<!-- By default, \*Lin_line\*O code controls marshalling and unmarshalling.-->
<!-- You can apply either attribute to an interface or a type.-->
<!-- .zA "defect,4793,R1.0.2,add restrictions of in_line and out_of_line"-->
<!-- (The \*Lin_line\*O and \*Lout_of_line\*O attributes are not valid on-->
<!-- operations or parameters.)-->
<!-- .zZ "defect,4793,R1.0.2,add restrictions of in_line and out_of_line"-->
<!-- Both attributes-->
<!-- apply only to nonscalar types; they-->
<!-- do not affect the marshalling of scalars. -->
<!-- The \*Lout_of_line\*O-->
<!-- attribute reduces stub size at the expense of reducing execution speed.-->
<!-- Note that the procedures necessary for marshalling \*Lout_of_line\*O-->
<!-- types are generated into an auxiliary module.  It is necessary to-->
<!-- build the client and/or server auxiliary file into your application, -->
<!-- along with the client and/or server stub module.-->
<!-- .zA "defect,4793,R1.0.2,add 28 char limit for out_of_line"-->
<!-- The maximum length of a name for any type which has the-->
<!-- \*Lout_of_line\*O attribute is 28 characters.-->
<!-- .zZ "defect,4793,R1.0.2,add 28 char limit for out_of_line"-->
<!-- .P-->
<!-- The \*Lin_line\*O and \*Lout_of_line\*O attributes have-->
<!-- the following syntax.  (See the examples at the end of this section.)-->
<!-- .P-->
<!-- For an interface:-->
<!-- .iS-->
<!-- \*L[in_line\*O | \*Lout_of_line]\*O \*Linterface\*O \*Vinterface_name\*L;\*O-->
<!-- .iE-->
<!-- .P-->
<!-- For a type:-->
<!-- .iS-->
<!-- \*Ltypedef\*O \*L[in_line\*O | \*Lout_of_line] \*Vtype_name\*L;\*O-->
<!-- .iE-->
<!-- .zA "defect,4793,R1.0.2,add restrictions of in_line and out_of_line"-->
<!-- The \*Lin_line\*O and \*Lout_of_line\*O attributes cannot be applied-->
<!-- to the same interface or type.-->
<!-- .zZ "defect,4793,R1.0.2,add restrictions of in_line and out_of_line"-->
<!-- .P-->
<!-- In the following example, the compiler generates inline marshalling-->
<!-- code for data type \*Lmy_t\*O, but out-of-line marshalling-->
<!-- code (subroutines) for any other nonscalar types defined in-->
<!-- the IDL file.-->
<!-- ...\".PP-->
<!-- ...\".ne 3.5i-->
<!-- ...\".TB "in_line Example"-->
<!-- ...\".rs-->
<!-- ...\".sp 2.5i-->
<!-- ...\".in +1.125i-->
<!-- ...\".P! pictures/11_idl_acf_20.ps 2.50i-->
<!-- .sp-->
<!-- \*LExample Using the in_line Attribute\*O-->
<!-- .sp-->
<!-- \*LACF\*O-->
<!-- .P-->
<!-- .oS-->
<!-- \*C[out_of_line] interface move_fields\*O-->
<!-- \*C{\*O-->
<!-- \*Ctypedef [in_line] my_t;\*O-->
<!-- \*C}\*O-->
<!-- .oE-->
<!-- .sp-->
<!-- \*LIDL File\*O-->
<!-- .P-->
<!-- .zA "defect,6742,R1.0.2,lowercase UUIDs"-->
<!-- .oS-->
<!-- \*C[uuid (2f74e680-2d26-11c9-880e-08002b0ecef1)]\*O-->
<!-- \*Cinterface move_fields\*O-->
<!-- \*C{\*O-->
<!-- \*Ctypedef struct\*O-->
<!-- \*C    {\*O-->
<!-- \*C    long   my_val; \*O-->
<!-- \*C    float  my_float; \*O-->
<!-- \*C    double my_double; \*O-->
<!-- \*C    } my_t;\*O-->
<!-- \*C}\*O-->
<!-- .oE-->
<!-- .zZ "defect,6742,R1.0.2,lowercase UUIDs"-->
<!-- .PP-->
<!-- In the following example, code space is minimized by having \*Ldir_t\*O-->
<!-- marshalled through a procedure call rather than duplicating-->
<!-- the marshalling code in the stub routines for \*Ladd\*O, \*Llookup\*O,-->
<!-- and \*Ldelete\*O.-->
<!-- .P-->
<!-- ...\".ne 4.0i-->
<!-- ...\".TB "out_of_line Example"-->
<!-- ...\".rs-->
<!-- ...\".sp 3.5i-->
<!-- ...\".in -0.5i-->
<!-- ...\".P! pictures/11_idl_acf_30.ps 3.5i-->
<!-- .sp-->
<!-- \*LExample Using the out_of_line Attribute\*O-->
<!-- .sp-->
<!-- \*LACF\*O-->
<!-- .P-->
<!-- .oS-->
<!-- \*C[auto_handle] interface phonedir\*O-->
<!-- \*C{\*O-->
<!-- \*C/*\*O-->
<!-- \*C * The interface uses dir_t in several places.  Save code\*O-->
<!-- \*C * space that is generated for the stub by making it\*O-->
<!-- \*C * [out_of_line].\*O-->
<!-- \*C */\*O-->
<!-- \*Ctypedef [out_of_line] dir_t;\*O-->
<!-- \*C}\*O-->
<!-- .oE-->
<!-- .sp-->
<!-- \*LIDL File\*O-->
<!-- .P-->
<!-- .zA "defect,6742,R1.0.2,lowercase UUIDs"-->
<!-- .oS-->
<!-- \*C[uuid(06a12100-2d26-11c9-aa24-08002b0ecef1)]\*O-->
<!-- \*Cinterface phonedir\*O-->
<!-- \*C{\*O-->
<!-- \*Ctypedef struct\*O-->
<!-- \*C    {\*O-->
<!-- \*C    short int  area_code;\*O-->
<!-- \*C    long int   phone_num;\*O-->
<!-- \*C    char       last_name[20];\*O-->
<!-- \*C    char       first_name[15];\*O-->
<!-- \*C    char       city[20];\*O-->
<!-- \*C    } dir_t;\*O-->
<!-- \*Cvoid add ([in] dir_t *info);\*O-->
<!-- \*Cvoid lookup ([in] char city[20],\*O-->
<!-- \*C             [in] char last_name[20],\*O-->
<!-- \*C             [in] char first_name[15],\*O-->
<!-- \*C             [out] dir_t *info);\*O-->
<!-- \*Cvoid delete ([in] dir_t *info);\*O-->
<!-- \*C}\*O-->
<!-- .oE-->
<!-- .zZ "defect,6742,R1.0.2,lowercase UUIDs"-->
<!-- .P-->
<!-- .zA "defect,5843,R1.0.2,add example of out_of_line module linking"-->
<!-- When you are building your application, you must link the generated modules-->
<!-- together.  For example, suppose you use the \*Lout_of_line\*O attribute-->
<!-- on the interface phonedir or on a type in that interface.  When you link a-->
<!-- client for interface phonedir you must include the generated file-->
<!-- phonedir.caux.o as well as phonedir_cstub.o.  When you link a server for-->
<!-- interface phonedir you must include the generated file phonedir_saux.o as-->
<!-- well as phonedir_sstub.o.-->
<!-- .zZ "defect,5843,R1.0.2,add example of out_of_line module linking"-->
<!-- .cE-->
</Sect2>
<Sect2 Id="DCEADG.RPCACF.div.17">
<Title>The represent_as Attribute</Title>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.91">
<Primary>represent_as attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.92">
<Primary>local type</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.93">
<Primary>network</Primary>
<Secondary>type</Secondary>
</IndexTerm>This attribute associates a local data type 
that your application code uses with a data type defined in the IDL file.
Use of the <Literal>represent_as</Literal> attribute means that, during marshalling 
and unmarshalling, conversions occur between the data type used by the
application code and the data type specified in the IDL.
</Para>
<Para>The <Literal>represent_as</Literal> attribute has the following syntax.  (See
the example at the end of this section.)
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>typedef</Literal> <Literal>[represent_as (</Literal><Symbol Role="Variable">local_type_name</Symbol><Literal>)] </Literal><Symbol Role="Variable">net_type_name</Symbol><Literal>;</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Symbol Role="Variable">local_type_name</Symbol> is the local data type that the application
code uses.  You can define it in the IDL file or in an application header
file.  If you do not define it in the IDL file, use the <Literal>include</Literal>
statement in the ACF to make its definition available to the stubs.
</Para>
<Para>The <Symbol Role="Variable">net_type_name</Symbol> is the data type that is defined in the IDL file.
</Para>
<Para>The <Literal>represent_as</Literal> attribute can appear at most once in
a <Literal>typedef</Literal> declaration in an ACF.
</Para>
<Para>If you use the <Literal>represent_as</Literal> attribute, you must write routines
that perform the conversions between the local and network types,
and routines that release the memory storage used to hold the converted
data.  The conversion routines are part of your application code.
</Para>
<Para>The suffix for the routine names, the function of each, and
where they are used (client or server) appear in the following list:
</Para>
<ItemizedList>
<ListItem>
<Para><Function>_from_local()</Function>: 
<IndexTerm Id="DCEADG.RPCACF.indx.94">
<Primary>routines</Primary>
<Secondary>ACF</Secondary>
</IndexTerm>Allocates storage instance of the network type and
converts from the local type to the
network type (used for client and server).
</Para>
</ListItem>
<ListItem>
<Para><Function>_to_local()</Function>: 
Converts from the network type to the
local type (used for client and server).
</Para>
</ListItem>
<ListItem>
<Para><Function>_free_inst()</Function>: 
Frees storage instance used for the
network type (used by client and server).
</Para>
</ListItem>
<ListItem>
<Para><Function>_free_local()</Function>: 
Frees storage used by the server
for the local type (used in server).  This routine frees any object pointed 
to by its argument but does not attempt to free the argument itself.
</Para>
</ListItem>
</ItemizedList>
<Para>Suppose that the <Literal>represent_as</Literal> attribute is applied to either the type of
a parameter or to a component of a parameter and that the parameter
has the <Literal>out</Literal> or <Literal>in,out</Literal> attribute.  Then, the <Function>_free_local()</Function>
routine will be called automatically for the data item that has
the type to which the <Literal>represent_as</Literal> attribute was applied.
</Para>
<Para>Suppose that the <Literal>represent_as</Literal> attribute is applied
to the type of a parameter and that the parameter has only the <Literal>in</Literal>
attribute.  Then, the <Function>_free_local()</Function> routine will be called
automatically.
</Para>
<Para>Finally, suppose that the <Literal>represent_as</Literal>
attribute is applied to the type of a component of a parameter and that
the parameter has only the <Literal>in</Literal> attribute.  Then, the <Function>_free_local()</Function>
routine will not be called automatically for the component; the
manager application code must release any resources that the
component uses, possibly by explicitly calling the <Function>_free_local()</Function>
routine.
</Para>
<Para>Append the suffix of the routine name
to the <Symbol Role="Variable">net_type_name</Symbol>.  The syntax for these routines is as
follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>void</Literal> <Symbol Role="Variable">net_type_name</Symbol><Literal>_from_local (
 (</Literal><Symbol Role="Variable">local_type_name </Symbol><Literal>*),
 (</Literal><Symbol Role="Variable">net_type_name </Symbol><Literal>**))</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>void</Literal> <Symbol Role="Variable">net_type_name</Symbol><Literal>_to_local  (
 (</Literal><Symbol Role="Variable">net_type_name </Symbol><Literal>*),
 (</Literal><Symbol Role="Variable">local_type_name </Symbol><Literal>*))</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>void</Literal> <Symbol Role="Variable">net_type_name</Symbol><Literal>_free_inst  ((</Literal><Symbol Role="Variable">net_type_name </Symbol><Literal>*))</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>void</Literal> <Symbol Role="Variable">net_type_name</Symbol><Literal>_free_local ((</Literal><Symbol Role="Variable">local_type_name </Symbol><Literal>*))</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para><!--.ne 4.0i-->
<!--.TB "represent_as Example"-->
<!--.rs-->
<!--.sp 3.5i-->
<!--.in -0.375i-->
<!--.P! pictures/11_idl_acf_70.ps 3.5i-->
</Para>
<Para><?sml-need 20><Literal>Example Using the represent_as Attribute</Literal>
</Para>
<Para><Literal>ACF</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>[auto_handle] interface phonedir
{
/*
 * You must specify an included file that contains the
 * definition of my_dir_t.
 */
include "user_types";

/*
 * The application code wants to pass data type my_dir_t
 * rather than dir_t.  The [represent_as] clause allows
 * this, and you must supply routines to convert dir_t
 * to/from my_dir_t.
 */
typedef [represent_as(my_dir_t)] dir_t;
}
</ProgramListing></Para>
</InformalExample>
<Para><Literal>IDL File</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>[uuid(06a12100-2d26-11c9-aa24-08002b0ecef1)]
interface phonedir
{
typedef struct
    {
    short int  area_code;
    long int   phone_num;
    char       last_name[20];
    char       first_name[15];
    char       city[20];
    } dir_t;
void add ([in] dir_t *info);
void lookup ([in] char city[20],
             [in] char last_name[20],
             [in] char first_name[15],
             [out] dir_t *info);
void delete ([in] dir_t *info);
}
</ProgramListing></Para>
</InformalExample>
</Sect2>
<Sect2 Id="DCEADG.RPCACF.div.18">
<Title>The enable_allocate Attribute</Title>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.95">
<Primary>enable_allocate attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.96">
<Primary>allocating memory</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.97">
<Primary>memory</Primary>
<Secondary>allocating</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.98">
<Primary>routines</Primary>
<Secondary>RPC</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.99">
<Primary>freeing memory</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.100">
<Primary>memory</Primary>
<Secondary>freeing</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.101">
<Primary>routines</Primary>
<Secondary>RPC</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.102">
<Primary>server</Primary>
<Secondary>memory management</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.103">
<Primary>memory</Primary>
<Secondary>management</Secondary>
<Tertiary>server</Tertiary>
</IndexTerm>The <Literal>enable_allocate</Literal> attribute on an operation causes the
server stub to initialize the <Function>rpc_ss_allocate()</Function> routine.
The <Function>rpc_ss_allocate()</Function>
routine requires initialization of its environment before it can be
called.  The server stub automatically initializes (enables) 
<Function>rpc_ss_allocate()</Function> if the operation
uses either full pointers or a type with the <Literal>represent_as</Literal> attribute.
If the operation does not meet either of these conditions, but the manager
application code needs to make use of the <Function>rpc_ss_allocate()</Function> and
<Function>rpc_ss_free()</Function> routines, then use
the <Literal>enable_allocate</Literal> attribute to force the stub code to enable.
</Para>
<Para>The <Literal>enable_allocate</Literal> attribute has the following syntax.
</Para>
<Para>For an operation:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>[enable_allocate]</Literal> <Symbol Role="Variable">operation_name</Symbol> <Literal>(</Literal><Symbol Role="Variable">[</Symbol><Symbol Role="Variable">parameter_list]</Symbol><Literal>);</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<!--.ne 4.0i-->
<!--.TB "enable_allocate Example"-->
<!--.rs-->
<!--.sp 3.5i-->
<!--.in +3.5i-->
<!--.P! need input-->
<Para><Literal>Example Using the enable_allocate Attribute</Literal>
</Para>
<Para><Literal>ACF</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>[auto_handle] interface phonedir
{
[enable_allocate] lookup ();
}
</ProgramListing></Para>
</InformalExample>
<Para><?sml-need 20><Literal>IDL File</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>[uuid(06a12100-2d26-11c9-aa24-08002b0ecef1)]
interface phonedir
{
typedef struct
    {
    short int  area_code;
    long int   phone_num;
    char       last_name[20];
    char       first_name[15];
    char       city[20];
    } dir_t;
void add ([in] dir_t *info);
void lookup ([in] char city[20],
             [in] char last_name[20],
             [in] char first_name[15],
             [out] dir_t *info);
void delete ([in] dir_t *info);
}
</ProgramListing></Para>
</InformalExample>
</Sect2>
<Sect2 Id="DCEADG.RPCACF.div.19">
<Title>The heap Attribute</Title>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.104">
<Primary>heap attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.105">
<Primary>memory</Primary>
<Secondary>heap attribute</Secondary>
</IndexTerm>This attribute specifies that the server stub's copy of a
parameter or of all parameters of a specified type 
is allocated in heap memory rather than on the stack.
</Para>
<Para>The <Literal>heap</Literal> attribute has the following syntax.  (See the
example at the end of this section.)
</Para>
<Para>For a type:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>typedef</Literal> <Literal>[heap]</Literal> <Symbol Role="Variable">type_name</Symbol><Literal>;</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>For a parameter:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">operation_name</Symbol> <Literal>([</Literal><Literal>heap] </Literal><Symbol Role="Variable">parameter_name</Symbol><Literal>);</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para><?sml-need 3>Any identifier occurring as a parameter name within
an operation declaration in the ACF must also be a parameter name
<IndexTerm Id="DCEADG.RPCACF.indx.106" SpanEnd="DCEADG.RPCACF.indx.3">within the corresponding operation declaration in IDL.               
</Para>
<Para>The <Literal>heap</Literal> attribute is ignored for pipes, context handles,
and scalars.
</Para>
<Para><Literal>Example Using the heap Attribute</Literal>
</Para>
<Para><Literal>ACF</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>[auto_handle] interface galaxies
{
typedef [heap] big_array;
}
</ProgramListing></Para>
</InformalExample>
<Para><Literal>IDL File</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>[uuid(e61de280-0d0b-11ca-6145-08002b111685)]
interface galaxies
{
typedef long big_array[1000];
}
</ProgramListing></Para>
</InformalExample>
</Sect2>
<Sect2 Id="DCEADG.RPCACF.div.20">
<Title>The extern_exceptions Attribute</Title>
<IndexTerm Id="DCEADG.RPCACF.indx.107">
<Primary>extern_exceptions attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.108">
<Primary>exceptions</Primary>
<Secondary>extern_exceptions attribute</Secondary>
</IndexTerm>
<Para>By default, the IDL compiler declares and initializes
all exceptions listed in an <Literal>exceptions</Literal> interface
attribute in the stub code that it generates.
You can use the <Literal>extern_exceptions</Literal> attribute
to override this behavior; the <Literal>extern_exceptions</Literal>
attribute allows you to specify one or more exceptions listed in the
exceptions interface attribute that you do not want
the idl-generated stub code to declare.
If the <Literal>extern_exceptions</Literal> attribute appears with no list, it has
the same effect as if all IDL-defined exceptions were specified in the
list.
</Para>
<Para>The <Literal>extern_exceptions</Literal> attribute has the following syntax.
(See the example at the end of this section.)
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>[extern_exceptions (</Literal><Symbol Role="Variable">exception_name [</Symbol><Literal>,</Literal><Symbol Role="Variable">exception_name]</Symbol>...<Literal>)]</Literal>
<Literal>interface</Literal><Symbol Role="Variable"> interface_name</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para><?sml-need 5>The <Literal>extern_exceptions</Literal> attribute indicates that the
specified exceptions are defined and initialized in some other external
manner before calling the <Literal>extern_exceptions</Literal> attribute.
They may be predefined exceptions
(such as <Literal>exc_e_exquota</Literal>) that were provided by another
interface, or
exceptions that are defined and initialized explicitly by the application
itself.
</Para>
<Para><Literal>Example Using the extern_exceptions Attribute</Literal>
</Para>
<Para>In the following example, the exception named in the list
in the <Literal>extern_exceptions</Literal> attribute in the ACF is
not defined or initialized in the idl-generated stub code.
All of the other exceptions listed in the <Literal>exceptions</Literal> interface
attribute are defined and initialized in the generated stub.
</Para>
<Para><Literal>ACF</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>[extern_exceptions(exc_e_exquota)] interface binop {}
/*
 *The exc_e_exquota exception is a predefined exception 
 *(provided in exc_handling.h) and so does not need 
 *to be declared and initialized in the idl-generated stub.
 */
</ProgramListing></Para>
</InformalExample>
<Para><Literal>IDL File</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>[uuid(06255501-08af-11cb-8c4f-08002b13d56d),
version (1.1),
  exceptions (
      exc_e_exquota,
      binop_e_aborted,
      binop_e_too_busy,
      binop_e_shutdown)
] interface binop
  {
      long binop_add(
           [in] long a,
           [in] long b
           );
   }
</ProgramListing></Para>
</InformalExample>
</Sect2>
<Sect2 Id="DCEADG.RPCACF.div.21">
<Title>The encode and decode Attributes</Title>
<IndexTerm Id="DCEADG.RPCACF.indx.109">
<Primary>encode attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.110">
<Primary>decode attribute</Primary>
</IndexTerm>
<Para>The <Literal>encode</Literal> and <Literal>decode</Literal> attributes are used in
conjunction with IDL encoding services routines (<Literal>idl_es</Literal><Symbol Role="Variable">*</Symbol>)
to enable RPC applications to encode data types in input parameters
into a byte stream and decode data types in output parameters
from a byte stream without invoking the RPC runtime.
Encoding and decoding operations are analogous to marshalling
and unmarshalling, except that the data is stored locally and
is not transmitted over the network.
</Para>
<Para>The stubs that perform encoding or decoding operations
are different from the stubs that perform RPC operations.
The ACF attributes <Literal>encode</Literal> and <Literal>decode</Literal> 
direct the IDL compiler to generate encoding or
decoding stubs for operations defined in a corresponding IDL interface
rather than generating RPC stubs for those operations.
</Para>
<Para>The <Literal>encode</Literal> and <Literal>decode</Literal> attributes have the
following syntax. (See the example at the end of this section.)
</Para>
<Para>For an interface:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>[encode]</Literal> | <Literal>[decode]</Literal> | <Literal>[encode,decode] interface</Literal><Symbol Role="Variable"> interface_name</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>For an operation:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>[encode]</Literal> | <Literal>[decode]</Literal> | <Literal>[encode,decode] </Literal><Symbol Role="Variable">operation_name</Symbol><Literal> (</Literal><Symbol Role="Variable">[parameter_list]</Symbol><Literal>);</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>When used as an ACF interface attribute, the <Literal>encode</Literal>
and <Literal>decode</Literal> attributes apply to all operations defined in the
corresponding IDL file.  When used as an ACF operation attribute, <Literal>encode</Literal>
and <Literal>decode</Literal> apply only to the operation you specify.
If you apply the <Literal>encode</Literal> or <Literal>decode</Literal> attribute to
an ACF interface or operation, you must not use the <Literal>auto_handle</Literal>
or the <Literal>implicit_handle</Literal> ACF attributes.
</Para>
<Para>When you apply the <Literal>encode</Literal> or <Literal>decode</Literal> attribute to an operation,
the IDL compiler generates IDL encoding services stubs that
support encoding or decoding, depending on the attribute used,
in the client stub code; it does not generate stub code for the
operation in the server stub.  To generate an IDL encoding services
stub that supports both encoding and decoding, apply both attributes
to the operation.
</Para>
<Para><?sml-need 5>If you apply the <Literal>encode</Literal> or <Literal>decode</Literal> attribute to all
of the operations in an interface, no server stub is generated.
If you apply the <Literal>encode</Literal> and <Literal>decode</Literal> attributes to
some, but not all, of the operations in an interface, the stubs
for the operations that do not have the <Literal>encode</Literal> and <Literal>decode</Literal>
attributes applied to them are generated as RPC stubs into the server
stub module.
</Para>
<Para>When data encoding takes place, only the operation's <Literal>in</Literal> parameters
provide data for the encoding.
When data decoding takes place, the decoded data is delivered
only to the operation's <Literal>out</Literal> parameters.
<IndexTerm Id="DCEADG.RPCACF.indx.111">
<Primary>interaction of attributes</Primary>
</IndexTerm></Para>
<Para>If data is being both encoded and decoded, you generally 
declare all of the operation's parameters to be
<Literal>in</Literal>,<Literal>out</Literal>.  However, you can encode data by using the
<Literal>in</Literal> parameters of one operation, and decode it by using the
<Literal>out</Literal> parameters of another operation if the types and order of
the <Literal>in</Literal> and <Literal>out</Literal> parameters are the same.
For equivalence, the IDL encoding services treat a function result
as an <Literal>out</Literal> parameter that appears after all other <Literal>out</Literal> parameters.
</Para>
<Para>In the following example, the IDL compiler generates IDL encoding
services stub code for the <Literal>in_array_op1</Literal>, <Literal>out_array_op1</Literal>,
and <Literal>array_op2</Literal> operations, but not for the <Literal>array_op3</Literal> operation.
The stub code generated for the <Literal>in_array_op1</Literal> operation
supports encoding, the stub code generated for the <Literal>out_array_op1</Literal>
operation supports decoding, and the stub code generated for
the <Literal>array_op2</Literal> operation supports both encoding and decoding.
The stub code generated for the <Literal>array_op3</Literal> is an RPC client stub.
For further information on using the IDL encoding services,
see Chapter 18 of this guide and the reference
pages for the <Literal>idl_es_</Literal><Symbol Role="Variable">*</Symbol><Literal>(3rpc)</Literal> routines.
</Para>
<Para><Literal>Example Using the encode and decode Attributes</Literal>
</Para>
<Para><Literal>ACF</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>interface es_array
{
    [encode] in_array_op1();
    [decode] out_array_op1();
    [encode, decode] array_op2();
}
</ProgramListing></Para>
</InformalExample>
<Para><?sml-need 10><Literal>IDL File</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>[uuid(20aac780-5398-11c9-b996-08002b13d56d), version(0)]
interface es_array
{
    void in_array_op1([in] handle_t h, [in] long arr[100]);
    void out_array_op1([in] handle_t h, [out] long arr[100]);
    void array_op2([in] handle_t h, [in,out] long big[100]);
    void array_op3([in] handle_t h, [in,out] long big[100]);
}
</ProgramListing></Para>
</InformalExample>
<Para><!---->
<!---->
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCACF.div.22">
<Title>The cs_char Attribute</Title>
<IndexTerm Id="DCEADG.RPCACF.indx.112">
<Primary>cs_char attribute</Primary>
</IndexTerm>
<!---->
<Para>The <Literal>cs_char</Literal> attribute is intended for use in internationalized
RPC applications.  It is used in conjunction with the <Literal>cs_stag</Literal>,
<Literal>cs_drtag</Literal>, <Literal>cs_rtag</Literal> and <Literal>cs_tag_rtn</Literal>
attributes and the DCE RPC routines for automatic code set conversion
to provide RPC applications with a mechanism for ensuring character
and code set interoperability between clients and servers transferring
international (non-PCS) characters.
</Para>
<Para>The <Literal>cs_char</Literal> attribute is very similar in function to
the <Literal>represent_as</Literal> attribute, in that it associates a local data type 
that your application code uses with a data type defined in the IDL file.
The <Literal>cs_char</Literal> attribute permits the application code to use
the local data type for international character data and converts
between the local data type and the format specified in the IDL file
when transferring international characters over the network.
The <Literal>cs_char</Literal> ACF attribute permits the conversion of 
characters, arrays of characters, and strings of characters between
the format in which the application code requires them and the format
in which they are transmitted over the network.
</Para>
<Para>As with <Literal>represent_as</Literal>, use of the <Literal>cs_char</Literal> attribute
means that, during marshalling and unmarshalling, conversions occur
between the data type that the application code is using and the data
type specified in IDL.  In the case of <Literal>cs_char</Literal>, the
local data type is automatically converted between the local data
type in the local code set encoding and the <Literal>idl_byte</Literal> data
type in the <FirstTerm>network</FirstTerm> code set encoding.  The network code set
is the code set encoding that the application code, through the use
of the DCE RPC automatic code set conversion routines, has selected
to use when transmitting the international characters over the
network.
</Para>
<Para><?sml-need 7>The <Literal>cs_char</Literal> attribute differs from the <Literal>[transmit_as]</Literal>
attribute in that it does not affect the network contract between
the client and server.  It differs from the <Literal>[represent_as]</Literal> attribute
in that multiple data items (for example, the characters of an array or string)
can be converted with a single stub call to user-written conversion
code, and that the conversion can modify array size and data limit
information between what is transmitted over the network and what is
used by application code.
</Para>
<Para>The <Literal>cs_char</Literal> attribute has the following syntax.  (See
the examples at the end of this section.)
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>typedef</Literal> <Literal>[cs_char (</Literal><Symbol Role="Variable">local_type_name</Symbol><Literal>)] </Literal><Symbol Role="Variable">net_type_name</Symbol><Literal>;</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Symbol Role="Variable">local_type_name</Symbol> is the local data type that the application
code uses.  You can define it in the IDL file or in an application header
file.  If you do not define it in the IDL file, use the <Literal>include</Literal>
statement in the ACF to make its definition available to the stubs.
</Para>
<Para>The <Symbol Role="Variable">net_type_name</Symbol> is the data type that is defined in the IDL file.
When used with the <Literal>cs_char</Literal> attribute, this data type is always
<Literal>byte</Literal> in the IDL file.
</Para>
<Para>If you use the <Literal>cs_char</Literal> attribute, you must write the following
stub support routines for each local type that you define:
</Para>
<ItemizedList>
<ListItem>
<Para>Routines that check the buffer storage requirements for international
character data to be converted to determine whether or not
more buffer space needs to be allocated to hold the converted data
</Para>
</ListItem>
<ListItem>
<Para>Routines to perform conversion between local and network code sets
</Para>
</ListItem>
</ItemizedList>
<Para>The suffix for the routine names, the function of each, and where
they are used (client or server) appear in the following list:
</Para>
<ItemizedList>
<ListItem>
<Para><Symbol Role="Variable">local_type_name</Symbol><Function>_net_size()</Function>: Calculates the necessary buffer size
for code set conversion from a local code set to a network code set.  Client
and server stubs call this routine before they marshall any international
character data.
</Para>
</ListItem>
<ListItem>
<Para><Symbol Role="Variable">local_type_name</Symbol><Function>_local_size()</Function>: Calculates the necessary buffer
size for code set conversion from a network code set to a local code set.
Client and server stubs call this routine before they unmarshall any 
international character data.
</Para>
</ListItem>
<ListItem>
<?sml-need 3>
<Para><Symbol Role="Variable">local_type_name</Symbol><Function>_to_netcs()</Function>: Converts international character data
from a local code set to a network code set.  Client and server stubs call this
routine before they marshall any international character data.
</Para>
</ListItem>
<ListItem>
<?sml-need 3>
<Para><Symbol Role="Variable">local_type_name</Symbol><Function>_from_netcs()</Function>: Converts international character
data from a network code set to a local code set.  Client and server stubs call
this routine before they unmarshall any international character data.
</Para>
</ListItem>
</ItemizedList>
<Para>You specify the name for the local data type in
the <Symbol Role="Variable">local_type_name</Symbol> portion of the function name.
The name that you specify cannot exceed 20 characters because
the entire generated name must not exceed the 31-character limit
for C identifiers.
</Para>
<Para>For each piece of international character data being marshalled,
the <Literal>_net_size</Literal> and <Literal>_to_netcs</Literal> routines are called once each.
For each piece of international character data being unmarshalled, the
<Literal>_local_size</Literal> and <Literal>_from_netcs</Literal> routines are
called once each.
</Para>
<Para>DCE RPC provides buffer sizing and code set conversion
routines for the <Literal>cs_byte</Literal> and <StructName Role="typedef">wchar_t</StructName> data types
(the <Literal>cs_byte</Literal> type is equivalent to the <Literal>byte</Literal> type).
If they meet the needs of your application, you can use
these RPC routines (<Literal>cs_byte_</Literal><Symbol Role="Variable">*</Symbol> and
<StructName Role="typedef">wchar_t_</StructName><Symbol Role="Variable">*</Symbol>) instead of providing your own routines.
</Para>
<Para>If you do provide your own routines for buffer sizing and
code set conversion, they must follow a specific signature.
See the reference pages for the <Literal>cs_byte_</Literal><Symbol Role="Variable">*</Symbol><Literal>(3rpc)</Literal> and
<StructName Role="typedef">wchar_t_</StructName><Symbol Role="Variable">*</Symbol><Literal>(3rpc)</Literal> routines 
for a complete description of the required signatures 
for these routines.
</Para>
<Para><!--Restrictions-->
When international character data is to be unmarshalled, a stub
needs to have received a description of the code set being used
before it receives the data.  For this reason,
the <Literal>cs_char</Literal> attribute cannot be applied to the base
type of a pipe or to a type used in constructing the base type of a pipe.
</Para>
<Para>The <Literal>cs_char</Literal> attribute also cannot be applied to a
type if there is an array that has this type as a base type 
and the array has more than one dimension, or if the attributes
<Literal>min_is</Literal>, <Literal>max_is</Literal>, <Literal>first_is</Literal>, <Literal>last_is</Literal>,
or <Literal>string</Literal> have been applied to the array.
As a result, all instances of the type to which <Literal>cs_char</Literal> has
been applied must be scalars or one-dimensional arrays.  Only
the <Literal>length_is</Literal> and/or <Literal>size_is</Literal> attributes
can be applied to these arrays.
</Para>
<Para><?sml-need 7>The following restrictions apply to the use
of variables that appear in array attributes: 
</Para>
<ItemizedList>
<ListItem>
<Para>Any parameter that is referenced by a <Literal>size_is</Literal> or
<Literal>length_is</Literal> attribute of an array parameter whose base type 
has the <Literal>cs_char</Literal> attribute cannot be referenced by any attribute
of an array parameter whose base type does not have the 
<Literal>cs_char</Literal> attribute.
</Para>
</ListItem>
<ListItem>
<Para>Any structure field that is referenced by a <Literal>size_is</Literal> or
<Literal>length_is</Literal> attribute of an array field whose base type 
has the <Literal>cs_char</Literal> attribute cannot be referenced by any attribute
of an array field whose base type does not have the <Literal>cs_char</Literal> 
attribute.
</Para>
</ListItem>
</ItemizedList>
<Para>The <Literal>cs_char</Literal> attribute cannot interact with
the <Literal>transmit_as</Literal> or <Literal>represent_as</Literal> attributes.
This restriction imposes the following rules:
</Para>
<ItemizedList>
<ListItem>
<Para>The <Literal>cs_char</Literal> attribute cannot be applied to a type that has the
<Literal>transmit_as</Literal> attribute, nor can it be applied to a type in whose
definition a type with the <Literal>transmit_as</Literal> attribute is used.
</Para>
</ListItem>
<ListItem>
<Para>The <Literal>cs_char</Literal> attribute cannot be applied to a type that has the
<Literal>represent_as</Literal> attribute, nor can it be applied to a type in
whose definition a type with the <Literal>represent_as</Literal> attribute is used.
</Para>
</ListItem>
<ListItem>
<Para>The <Literal>cs_char</Literal> attribute cannot be applied to the transmitted
type specified in a <Literal>transmit_as</Literal> attribute or to any type
used in defining such a transmitted type.
</Para>
</ListItem>
</ItemizedList>
<Para>The <Literal>cs_char</Literal> attribute cannot be applied to any type that
is the type of the referent of a pointer that has a
<Literal>max_is</Literal> or <Literal>size_is</Literal> attribute applied to it.
It also cannot be applied to the base type
of an array parameter that has the <Literal>unique</Literal> or
<Literal>ptr</Literal> attribute applied to it.
</Para>
<Para>An application that uses the <Literal>cs_char</Literal> ACF attribute
cannot use the IDL encoding services <Literal>encode</Literal> and <Literal>decode</Literal>
ACF attributes.
</Para>
<Para><Literal>Examples Using the cs_char Attribute</Literal>
</Para>
<Para>Arrays of <Literal>cs_char</Literal> can be fixed, varying, conformant, or
conformant varying.  The treatment of a scalar <Literal>cs_char</Literal> is
similar to that of a fixed array of one element.
The following examples show the relationship between IDL declarations
and declarations in the generated header file when the
<Literal>cs_char</Literal> attribute has been applied.
The examples assume that the ACF contains the type definition:
</Para>
<InformalExample>
<Para><ProgramListing>typedef [cs_char(ltype)] my_byte;
</ProgramListing></Para>
</InformalExample>
<Para><?sml-need 5>For a fixed array, if the IDL file contains
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct {
    my_byte fixed_array[80];
} fixed_struct;
</ProgramListing></Para>
</InformalExample>
<Para>the declaration generated in the header file is
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct {
    ltype fixed_array[80];
} fixed_struct;
</ProgramListing></Para>
</InformalExample>
<Para>The number of array elements in the local and network representations of
the data must be the same as the array size stated in the IDL.
</Para>
<Para>For a varying array, if the IDL file contains
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct {
    long l;
    [length_is(l)] my_byte varying_array[80];
} varying_struct;
</ProgramListing></Para>
</InformalExample>
<Para>the declaration generated in the header file is
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct {
    idl_long_int l;
    ltype varying_array[80];
} varying_struct;
</ProgramListing></Para>
</InformalExample>
<Para>Neither the number of array elements in the local representation nor the
number of array elements in the network representation may exceed
the array size in the IDL.
</Para>
<Para>For a conformant array, if the IDL file contains
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct {
    long s;
    [size_is(s)] my_byte conf_array[];
} conf_struct;
</ProgramListing></Para>
</InformalExample>
<Para><?sml-need 6>the declaration generated in the header file is
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct {
    idl_long_int s;
    ltype conf_array[1];
} conf_struct;
</ProgramListing></Para>
</InformalExample>
<Para>The number of array elements in the local representation and the number of
array elements in the network representation need not be the same.  The
conversions between these numbers are done in the user-provided
<Literal>_net_size</Literal> and <Literal>_local_size</Literal> routines.
</Para>
<Para>For a conformant varying array, if the IDL file contains
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct {
    long s;
    long l;
    [size_is(s), length_is(l)] my_byte open_array[];
} open_struct;
</ProgramListing></Para>
</InformalExample>
<Para>the declaration generated in the header file is
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct {
    idl_long_int s;
    idl_long_int l;
    ltype open_array[1];
} open_struct;
</ProgramListing></Para>
</InformalExample>
<Para>The maximum number of array elements in the local representation and the
maximum number of array elements in the network representation need not
be the same.  The conversions between these numbers are done in the
user-provided <Literal>_net_size</Literal> and <Literal>_local_size</Literal> routines.
</Para>
<Para>For fixed or varying arrays, the size of the storage available to
hold the local data is determined by the array size specified in IDL and
the local type specified in the <Literal>cs_char</Literal> attribute.
For conformant or conformant varying arrays, you must determine the
transformations between local storage size and network storage size without
reference to the characters being transmitted or received.
Where a variable-width character set is in use, this means
making the most conservative assumption about the size of the data.
<!---->
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCACF.div.23">
<Title>The cs_stag, cs_drtag, and cs_rtag Attributes</Title>
<!---->
<IndexTerm Id="DCEADG.RPCACF.indx.113">
<Primary>cs_stag attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.114">
<Primary>cs_drtag attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.115">
<Primary>cs_rtag attribute</Primary>
</IndexTerm>
<Para>The <Literal>cs_stag</Literal>, <Literal>cs_drtag</Literal>, and <Literal>cs_rtag</Literal> attributes
are used in conjunction with the <Literal>cs_char</Literal> and (optionally)
the <Literal>cs_tag_rtn</Literal> attributes and DCE RPC routines for automatic
code set conversion to provide internationalized RPC applications 
with a mechanism to ensure character and code set interoperability
between clients and servers handling international character data.
</Para>
<Para>The <Literal>cs_stag</Literal>, <Literal>cs_drtag</Literal>, and <Literal>cs_rtag</Literal> attributes
are parameter ACF attributes that correspond to the sending tag,
desired receiving tag, and receiving tag parameters defined
in operations in the IDL file that handle international character
data.  These operation parameters <FirstTerm>tag</FirstTerm> international
characters being passed in the operation's input and output
parameters with code set identifying information.  The <Literal>cs_stag</Literal>,
<Literal>cs_drtag</Literal>, and <Literal>cs_rtag</Literal> ACF parameter attributes declare
the tag parameters in the corresponding operation definition to be special
code set parameters.
</Para>
<Para>The <Literal>cs_stag</Literal> attribute has the following syntax:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">operation_name </Symbol><Literal>([cs_stag]</Literal><Symbol Role="Variable"> parameter_name</Symbol><Literal>);</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Literal>cs_stag</Literal> attribute identifies the code set used when
the client sends international characters to the server.
Operations defined in the IDL file that specify international
characters in <Literal>in</Literal> parameters must use the <Literal>cs_stag</Literal>
attribute in the associated ACF.
</Para>
<Para>The <Literal>cs_drtag</Literal> attribute has the following syntax:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">operation_name </Symbol><Literal>([cs_drtag]</Literal><Symbol Role="Variable"> parameter_name</Symbol><Literal>);</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Literal>cs_drtag</Literal> attribute identifies the code set the
client would like the server to use when returning
international characters.
</Para>
<Para>The <Literal>cs_rtag</Literal> attribute has the following syntax:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">operation_name </Symbol><Literal>([cs_rtag]</Literal><Symbol Role="Variable"> parameter_name</Symbol><Literal>);</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Literal>cs_rtag</Literal> attribute identifies the code set that is
actually used when the server sends international
characters to the client.  Operations defined in the IDL file
that specify international characters in <Literal>out</Literal> parameters
must apply the <Literal>cs_rtag</Literal> attribute in the associated ACF.
</Para>
<Para><Literal>Example Using the cs_stag, cs_drtag, and cs_rtag Attributes</Literal>
</Para>
<Para>Here is an example ACF for an IDL file in which the operation
<Literal>my_op</Literal> has the tag parameters <Literal>my_stag</Literal>, <Literal>my_drtag</Literal>,
and <Literal>my_rtag</Literal>, whose types are either <Literal>unsigned long</Literal>
or <Literal>[ref] unsigned long</Literal>.
</Para>
<InformalExample>
<Para><ProgramListing><?sml-point-size 11>my_op( [cs_stag] my_stag, [cs_drtag] my_drtag, [cs_rtag] my_rtag);
<?sml-point-size 12></ProgramListing></Para>
</InformalExample>
<Para>For more information about the <Literal>cs_stag</Literal>, <Literal>cs_drtag</Literal>, and <Literal>cs_rtag</Literal>
ACF attributes and their use in internationalized RPC applications,
see Chapter 16 of this guide.
<!---->
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCACF.div.24">
<Title>The cs_tag_rtn Attribute</Title>
<!---->
<IndexTerm Id="DCEADG.RPCACF.indx.116">
<Primary>cs_tag_rtn attribute</Primary>
</IndexTerm>
<Para>The <Literal>cs_tag_rtn</Literal> attribute is an ACF attribute for use in
RPC applications that handle international character data.
This attribute specifies the name of a user-written routine
that the client and server stubs will call to set an operation's
code set tag parameters to specific code set values.
The <Literal>cs_tag_rtn</Literal> attribute is an optional ACF attribute that
you can use to provide code set tag transparency
for callers of your interface's operations.
If an operation that transfers international character
data has the <Literal>cs_tag_rtn</Literal> attribute applied to it
in the corresponding ACF, the code set tag parameters
will not appear in the operation's definition
within the generated header file.  If the <Literal>cs_tag_rtn</Literal>
attribute is not used, the operation's caller must
provide appropriate values to the operation's code set tag
parameters before international character data is marshalled.
</Para>
<Para>The <Literal>cs_tag_rtn</Literal> attribute has the following syntax. (See the
example at the end of this section.)
</Para>
<Para>For an interface:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>[cs_tag_rtn(</Literal><Symbol Role="Variable">tag_set_routine</Symbol><Literal>)] interface </Literal><Symbol Role="Variable">interface_name</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>For an operation:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>[cs_tag_rtn(</Literal><Symbol Role="Variable">tag_set_routine</Symbol><Literal>)] </Literal><Symbol Role="Variable">operation_name </Symbol><Literal>(</Literal><Symbol Role="Variable">[parameter_list]</Symbol><Literal>);</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para><?sml-need 4>When used as an ACF interface attribute, the <Literal>cs_tag_rtn</Literal> attribute
applies to all operations defined in the corresponding IDL file.
When used as an ACF operation attribute, the <Literal>cs_tag_rtn</Literal>
attribute applies only to the operation you specify.
</Para>
<Para>The <Symbol Role="Variable">tag_set_routine</Symbol> is the name of the stub support routine
that the client and server stubs will call to set the operation's
code set tag parameters.  The IDL compiler will generate a function
prototype for <Symbol Role="Variable">tag_set_routine</Symbol> in the generated header file.
</Para>
<Para>Applications can specify the DCE RPC tag-setting routine
<Function>rpc_cs_get_tags()</Function> if it meets their applications' needs,
or they can write their own tag-setting routines.  The routine name
must be distinct from any type name, procedure name, constant name,
or enumeration name appearing in the interface definition.
It must also have a specific calling signature.  See the 
<Filename MoreInfo="RefEntry">rpc_cs_get_tags(3rpc)</Filename> reference page for a complete
description of the required routine signature.
</Para>
<Para>When the tag-setting routine is called from a client stub,
it is called before any <Literal>in</Literal> parameters are marshalled.
When called from a server stub,
it is called before any <Literal>out</Literal> parameters are marshalled.
For more information on the <Literal>cs_tag_rtn</Literal> attribute and
its use in internationalized RPC applications, see Chapter 16 of this
guide.
</Para>
<Para><Literal>Example Using the cs_tag_rtn Attribute</Literal>
</Para>
<Para>As shown in the following example, the <Literal>cs_tag_rtn</Literal> attribute
is used in conjunction with the <Literal>cs_char</Literal>, <Literal>cs_stag</Literal>,
<Literal>cs_drtag</Literal>, and <Literal>cs_rtag</Literal> ACF attributes.
In the example, the stub generated for <Literal>a_op</Literal> will call the tag-setting
routine <Literal>set_tags</Literal> to set the code set tag parameters to specific
values before any data is marshalled.  For <Literal>b_op</Literal>, it is the
responsibility of the operation's caller to ensure that
the code set tag parameters are set correctly before any data is marshalled.
</Para>
<Para><?sml-need 21><Literal>IDL File</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>typedef byte my_byte;

void a_op(
    [in] unsigned long stag,
    [in] unsigned long drtag,
    [out] unsigned long *p_rtag,
    [in] long s, 
    [in, out] long *p_l, 
    [in, out, size_is(s), length_is(*p_l)] my_byte a[]
);

void b_op(
    [in] unsigned long stag,
    [in] unsigned long drtag,
    [out] unsigned long *p_rtag,
    [in] long s, 
    [in, out] long *p_l, 
    [in, out, size_is(s), length_is(*p_l)] my_byte a[]
);
</ProgramListing></Para>
</InformalExample>
<Para><Literal>ACF</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>typedef [cs_char(ltype)] my_byte;

[cs_tag_rtn(set_tags)] a_op( [cs_stag] stag,
                         [cs_drtag] drtag, 
                         [cs_rtag] p_rtag );

                     b_op( [cs_stag] stag,
                           [cs_drtag] drtag, 
                           [cs_rtag] p_rtag );
</ProgramListing></Para>
</InformalExample>
<Para><?sml-need 18><Literal>Generated Header File</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>typedef byte my_byte;

void a_op(
    /* [in] */ idl_long_int s, 
    /* [in, out] */ idl_long_int *p_l, 
    /* [in, out, size_is(s), length_is(*p_l)] */ ltype a[]
);

void b_op(
    /* [in] */ idl_ulong_int stag,
    /* [in] */ idl_ulong_ing drtag,
    /* [out] */ idl_ulong_int *p_rtag,
    /* [in] */ idl_long_int s, 
    /* [in, out] */ idl_long_int *p_l, 
    /* [in, out, size_is(s), length_is(*p_l)] */ ltype a[]
);
</ProgramListing></Para>
</InformalExample>
</Sect2>
<Sect2 Id="DCEADG.RPCACF.div.25">
<Title>The binding_callout Attribute</Title>
<IndexTerm Id="DCEADG.RPCACF.indx.117">
<Primary>binding_callout attribute</Primary>
</IndexTerm>
<Para>The <Literal>binding_callout</Literal> attribute permits you to specify
the name of a routine that the client stub is to call
automatically to modify a server binding handle before
it initiates a remote procedure call.
This attribute is intended for use by client applications
that employ the automatic binding method through the
<Literal>auto_handle</Literal> ACF interface attribute.  In automatic
binding, it is the client stub, rather than the client
application code, that obtains the binding handle to
the server.  The <Literal>binding_callout</Literal> attribute allows
a client application using automatic binding to modify the
binding handle obtained by the client stub.  Without this attribute,
it is impossible for the client application to modify the binding
handle before the client stub attempts to initiate a remote
procedure call to the selected server.
</Para>
<Para>Clients typically use this attribute to augment automatic
binding handles with security context, for example, so that
authenticated RPC is used between client and server.
</Para>
<Para><?sml-need 4>The <Literal>binding_callout</Literal> attribute has the following syntax.
(See the example at the end of this section.)
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>[binding_callout(</Literal><Symbol Role="Variable">routine_name</Symbol><Literal>)] interface </Literal><Symbol Role="Variable">interface_name</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Symbol Role="Variable">routine_name</Symbol> specifies the name of a binding callout routine
that the client stub will call to modify the server binding handle
before initiating the remote procedure call to the server.
The IDL compiler will generate a function prototype for
<Symbol Role="Variable">routine_name</Symbol> in the generated header file.
</Para>
<Para>You can specify the name of a routine that you supply, or
you can specify the DCE RPC routine <Function>rpc_ss_bind_authn_client()</Function>
to modify the binding handle if it meets the needs of your application.
See the <Filename MoreInfo="RefEntry">rpc_ss_bind_authn_client(3rpc)</Filename> reference page for more
information.
</Para>
<Para>The binding callout routine you provide must have a specific
routine signature.  See the <Filename MoreInfo="RefEntry">rpc_ss_bind_authn_client(3rpc)</Filename>
reference page for information about the required routine signature.
</Para>
<Para>The <Literal>binding_callout</Literal> attribute can occur at most once in the ACF
and applies to all of the operations in the corresponding IDL file.
</Para>
<Para>A binding callout routine should return the <Literal>error_status_ok</Literal>
status code when it successfully modifies the binding handle or determines
that no action is necessary.  This status code causes the client
stub to initiate the remote procedure call.
</Para>
<Para>A binding callout routine can also return error status. If it
does, the client stub does not initiate the remote procedure call.
Instead, if the <Literal>auto_handle</Literal> attribute has been applied in
the ACF, the client stub attempts to locate another server
of the interface and then calls the binding callout routine again.
If <Literal>auto_handle</Literal> is not in use, the client stub invokes its
normal error-handling logic.  A binding callout routine for a
client using <Literal>auto_handle</Literal> can return the status code
<Literal>rpc_s_no_more_bindings</Literal> to prevent the client stub from
searching for another server and instead invoking its error-handling logic
immediately.
</Para>
<Para>By default, the client stub handles an error condition by
raising an exception.  If a binding callout routine returns
one of the <Literal>rpc_s_</Literal> status codes, the client stub raises
a matching <Literal>rpc_x_</Literal> exception.  However, if a binding callout
routine returns any other type of status code, the client stub
will most likely raise it as an ``unknown status'' exception.
</Para>
<Para><?sml-need 5>If the <Literal>comm_status</Literal> parameter ACF attribute has been
applied to an operation, the client stub handles an error
condition by returning the error status value in the
<Literal>comm_status</Literal> parameter.  Consequently, a binding callout
routine can return any error status value to the client application
code if the <Literal>comm_status</Literal> attribute has been applied to
the operation.
</Para>
<Para>A binding callout routine can raise a user-defined exception,
rather than return a status code, to report application-specific
error conditions back to the client application code using exceptions.
<!-- DCE 1.2 WRITER: please check above statement and rewrite to -->
<!-- clarify if possible.  The callout routine raises exceptions -->
<!-- *in order to* report error conditions *by way of* exceptions -->
<!-- rather than status codes? This is the current sense of it I think.-->
</Para>
<Para><Literal>Example Using the binding_callout Attribute</Literal>
</Para>
<Para><Literal>ACF</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>[auto_handle,binding_callout(my_bh_callout)] interface \
  bindcall
{
}
</ProgramListing></Para>
</InformalExample>
<Para><Literal>Generated Header File (bindcall.h)</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>void my_bh_callout(
     rpc_binding_handle_t *p_binding,
     rpc_if_handle_t interface_handle,
     error_status_t *p_st
);
</ProgramListing></Para>
</InformalExample>
<?sml-need 25>
</Sect2>
<Sect2 Id="DCEADG.RPCACF.div.26">
<Title>The C++ Attributes cxx_new, cxx_static, cxx_lookup, and cxx_delegate </Title>
<Para>The IDL compiler uses an ACF to do the following for C++ applications:
</Para>
<ItemizedList>
<ListItem>
<Para>Declare a server's manager class and object constructor by using 
<Literal>cxx_new</Literal>.
</Para>
</ListItem>
<ListItem>
<Para>Declare interface member functions as static by using the 
<Literal>cxx_static</Literal> attribute, 
if  they are not already declared in the interface definition file.
</Para>
</ListItem>
<ListItem>
<Para>Rename static member functions by using <Literal>cxx_static.</Literal>.
</Para>
</ListItem>
<ListItem>
<Para>Specify a lookup function by using the <Literal>cxx_lookup</Literal> attribute.  
The server calls this application-specific function 
automatically if a client requests a known object not currently maintained by the server.
</Para>
</ListItem>
<ListItem>
<Para>Specify a delegate interface class by using the <Literal>cxx_delegate</Literal> attribute. 
A third-party class is encapsulated by a delegate class so it can be used in RPCs
without modifying the original class.
</Para>
</ListItem>
<ListItem>
<Para>Control in which stub files application-specific header files are included.  
(See also the <Literal>include</Literal> statement and the<Literal> cstub</Literal> and <Literal>sstub</Literal> attributes.)
</Para>
</ListItem>
</ItemizedList>
<Sect3 Id="DCEADG.RPCACF.div.27">
<Title>Using cxx_new to Declare an Object Creator Function</Title>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.118">
<Primary>cxx_new attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.119">
<Primary>object creator function</Primary>
</IndexTerm>Member functions may be specified as static object creator functions
by applying the <Literal>cxx_new</Literal> attribute to the function name.  An
object creator function allows clients to dynamically create remote
objects of an interface class.  Servers require this feature to
specify their implementation-specific manager class, and clients can
use this feature to specify their local implementation of the
interface class.  The <Literal>cxx_new</Literal> attribute is applied to an
operation and has the following format:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>[cxx_new (</Literal><Symbol Role="Variable">manager_class</Symbol><Literal>) ]</Literal> <Symbol Role="Variable">creator_function</Symbol><Literal>( );</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The associated IDL file must contain a function that returns a pointer
to the interface class and that matches the <Symbol Role="Variable">creator_function</Symbol>
name.
</Para>
<Para>The <Symbol Role="Variable">manager_class</Symbol> argument to the <Literal>cxx_new </Literal>attribute
specifies the class name the application uses to locally implement the
interface class.  The server stub requires the <Symbol Role="Variable">manager_class,
</Symbol>which must be declared for it in a header file and included by
using the <Literal>sstub</Literal> attribute with the <Literal>include</Literal> statement.
The format in C++ of the <Symbol Role="Variable">manager_class</Symbol> declaration is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><Literal>class</Literal> <Replaceable>manager_class </Replaceable>: <Replaceable>public</Replaceable> <Replaceable>interface_class </Replaceable><Literal>{</Literal>
        // The constructor, destructor, function declarations, and data.
        <Literal>...
}</Literal>
</ProgramListing></Para>
</InformalExample>
<Para>The manager class may include not only a constructor to create objects
of the class, but also all the nonstatic member functions declared in
the interface class.  A server implements the <Symbol Role="Variable">manager_class</Symbol>
member functions in its manager code.  Manager code handles
requests from clients for all of the interface's member functions
(static and nonstatic), including the <Symbol Role="Variable">creator_function</Symbol> which
dynamically creates interface objects on the server for the client.
</Para>
<Para>When a client calls the <Symbol Role="Variable">creator_function</Symbol>, the client stub
executes a proxy function that uses RPCs to execute a manager class
constructor on a server.  A client can use the <Symbol Role="Variable">manager_class</Symbol>
argument to specify a class name when implementing its own local
version of the interface class.  In this case, the client links into
its application the <Command>idl</Command>-generated server stub along with a local
implementation of the interface class.  When the client uses the
<Literal>new</Literal> operator to creates objects of the <Symbol Role="Variable">manager_class</Symbol> type,
the object is local and no RPCs are involved.

</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCACF.div.28">
<Title>Using cxx_static to Specify Static Interface Member Functions</Title>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.120">
<Primary>cxx_static attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.121">
<Primary>static function specification</Primary>
</IndexTerm>Member functions can be specified as static by applying the
<Literal>cxx_static</Literal> attribute to the function name.  The <Literal>cxx_static</Literal>
attribute is an operation attribute with a format as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>[cxx_static</Literal> <Symbol Role="Variable">[</Symbol>(<Symbol Role="Variable">local_function</Symbol>)<Symbol Role="Variable">]</Symbol> <Literal>]</Literal>  <Symbol Role="Variable">member_function( )</Symbol>;
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Symbol Role="Variable">member_function</Symbol> name must match a function named in the
associated IDL file.
</Para>
<Para>Both remote and local versions of objects are implemented in an
application by linking in both client and server stubs.  A client
links in the server stub to implement client-local versions of
interface objects.  A server links in the client stub to allow access
to remote (in this case, client-local) objects that are passed in as
parameters to member functions.  The <Symbol Role="Variable">local_function</Symbol> argument to
the <Literal>cxx_static</Literal> attribute specifies the function name that the
application uses to locally implement the static member function and
avoid name conflicts with the remote version of the function (always
defined in the client stub).
</Para>
<Para>The server implements a static function named <Symbol Role="Variable">member_function</Symbol> in
its manager code if no<Symbol Role="Variable"> local_function</Symbol> is specified.  However, if
a <Symbol Role="Variable">local_function</Symbol> is specified, the server implements a static
function named <Symbol Role="Variable">local_function</Symbol> in its manager code.  In this
case, the <Symbol Role="Variable">manager_function</Symbol> is automatically implemented in the
client stub which is linked into the application (along with the server stub)
to handle marshalling of parameters that are client- local objects
(remote to the server).  When there is a<Symbol Role="Variable"> local_function</Symbol>, it
must be declared for the server stub in a header file and
included by using the <Literal>sstub</Literal> attribute with the <Literal>include</Literal>
statement in the ACF.
</Para>
<Para>When a client calls the static <Symbol Role="Variable">member_function</Symbol>, the client stub
executes a proxy function that uses RPCs to execute the associated
remote function on a server.  A client uses the <Symbol Role="Variable">local_function</Symbol>
argument to specify a function name to use when implementing its own
local version of the <Symbol Role="Variable">member_function</Symbol>.  In this case, in addition
to linking in the client stub, the client application also links in
the <Command>idl</Command>-generated server stub with a local implementation of the
function.  When you develop a client, it might be easier if you think of 
the server stub as a local-implementation stub, because, 
when the client calls the static <Symbol Role="Variable">local_function</Symbol>, the
call is strictly local and no RPCs are involved. 
If you compile an interface such that a server stub is not generated, 
the <Symbol Role="Variable">local_function</Symbol> argument to <Literal>cxx_static</Literal> is ignored.
</Para>
<Para>An interface can instead specify static member functions by using the
<Literal>static</Literal> keyword in the interface definition, in front of a member
function.

</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCACF.div.29">
<Title>Using cxx_lookup to Declare a Server's Object Lookup Function</Title>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.122">
<Primary>cxx_lookup attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.123">
<Primary>object lookup function</Primary>
</IndexTerm>If a client requests the use of a known object that is not yet in the
server's runtime, the server can automatically look it up and create
it by using an application-specific function.  The object lookup
function name is specified by using the <Literal>cxx_lookup</Literal> attribute in
an ACF header.  The ACF format is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>cxx_lookup (</Literal><Symbol Role="Variable">object_lookup_function</Symbol>)
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Symbol Role="Variable">object_lookup_function</Symbol> must be declared in a header file and
included in the server stub by using the <Literal>sstub</Literal> attribute with
the<Literal> include</Literal> statement in the ACF.  The C++ function declaration must have the
following format:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">interface_name</Symbol> <Literal>*</Literal><Symbol Role="Variable">object_lookup_function</Symbol><Literal>( uuid_t * );</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The lookup function has one input pointer argument of type
<StructName Role="typedef">uuid_t</StructName> representing the UUID of the object desired.  The
function returns a pointer to the interface class.  The returned
pointer represents the newly created object.  If the object cannot be
found or created, the function must return a zero.

</Para>
</Sect3>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.RPCACF.div.30">
<Title>Summary of Attributes</Title>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.124">
<Primary>ACF</Primary>
<Secondary>table of attributes</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.125">
<Primary>auto_handle attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.126">
<Primary>explicit_handle attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.127">
<Primary>implicit_handle attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.128">
<Primary>comm_status attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.129">
<Primary>fault_status attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.130">
<Primary>attributes</Primary>
<Secondary>code</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.131">
<Primary>encode attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.132">
<Primary>decode attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.133">
<Primary>code attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.134">
<Primary>nocode attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.135">
<Primary>represent_as attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.136">
<Primary>enable_allocate attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.137">
<Primary>heap attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.138">
<Primary>cs_char attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.139">
<Primary>cs_tag_rtn attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.140">
<Primary>cs_stag attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.141">
<Primary>cs_drtag attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.142">
<Primary>cs_rtag attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.143">
<Primary>extern_exceptions attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.144">
<Primary>binding_callout attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.145">
<Primary>cxx_delegate attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.146">
<Primary>cxx_lookup attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.147">
<Primary>cxx_new attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.148">
<Primary>cxx_static attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.149">
<Primary>cstub attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.150">
<Primary>sstub attribute</Primary>
</IndexTerm>The following table lists the attributes available for use in the ACF
and where in the file the attribute can be used.
</Para>
<?sml-need 6i>
<Table Frame="all" Remap="center" Orient="Port">
<Title>Summary of the ACF Attributes</Title>
<TGroup Rowsep="1" Colsep="1" Cols="2">
<ColSpec Colsep="1" Align="Left" Colwidth="1*" Colname="col1" Colnum="1">
<ColSpec Align="Left" Colwidth="1.5*" Colname="col2" Colnum="2">
<thead>
<Row>
<Entry Rowsep="1"><Literal>Attribute</Literal></Entry>
<Entry Rowsep="1"><Literal>Where Used</Literal></Entry>
</Row>
</thead>
<tbody>
<Row>
<Entry><Literal>auto_handle</Literal></Entry>
<Entry>Interface header</Entry>
</Row>
<Row>
<Entry><Literal>binding_callout</Literal></Entry>
<Entry>Interface header</Entry>
</Row>
<Row>
<Entry><Literal>code</Literal></Entry>
<Entry>Interface header, operation</Entry>
</Row>
<Row>
<Entry><Literal>comm_status</Literal></Entry>
<Entry>Operation, parameter</Entry>
</Row>
<Row>
<Entry><Literal>cs_char</Literal></Entry>
<Entry>Type</Entry>
</Row>
<Row>
<Entry><Literal>cs_drtag</Literal></Entry>
<Entry>Parameter</Entry>
</Row>
<Row>
<Entry><Literal>cs_rtag</Literal></Entry>
<Entry>Parameter</Entry>
</Row>
<Row>
<Entry><Literal>cs_stag</Literal></Entry>
<Entry>Parameter</Entry>
</Row>
<Row>
<Entry><Literal>cs_tag_rtn</Literal></Entry>
<Entry>Operation, interface header</Entry>
</Row>
<Row>
<Entry><Literal>cxx_delegate</Literal></Entry>
<Entry>Interface header</Entry>
</Row>
<Row>
<Entry><Literal>cxx_lookup</Literal></Entry>
<Entry>Interface header</Entry>
</Row>
<Row>
<Entry><Literal>cxx_new</Literal></Entry>
<Entry>Operation</Entry>
</Row>
<Row>
<Entry><Literal>cxx_static</Literal></Entry>
<Entry>Operation</Entry>
</Row>
<Row>
<Entry><Literal>cstub</Literal></Entry>
<Entry>include statement</Entry>
</Row>
<Row>
<Entry><Literal>decode</Literal></Entry>
<Entry>Operation, interface header</Entry>
</Row>
<Row>
<Entry><Literal>enable_allocate</Literal></Entry>
<Entry>Operation</Entry>
</Row>
<Row>
<Entry><Literal>encode</Literal></Entry>
<Entry>Operation, interface header</Entry>
</Row>
<Row>
<Entry><Literal>explicit_handle</Literal></Entry>
<Entry>Interface header, operation</Entry>
</Row>
<Row>
<Entry><Literal>extern_exceptions</Literal></Entry>
<Entry>Interface header</Entry>
</Row>
<Row>
<Entry><Literal>fault_status</Literal></Entry>
<Entry>Operation, parameter</Entry>
</Row>
<Row>
<Entry><Literal>heap</Literal></Entry>
<Entry>Type, parameter</Entry>
</Row>
<Row>
<Entry><Literal>implicit_handle</Literal></Entry>
<Entry>Interface header</Entry>
</Row>
<Row>
<Entry><Literal>nocode</Literal></Entry>
<Entry>Interface header, operation</Entry>
</Row>
<Row>
<Entry><Literal>represent_as</Literal></Entry>
<Entry>Type</Entry>
</Row>
<Row>
<Entry><Literal>sstub</Literal></Entry>
<Entry>include statement</Entry>
</Row>
</TBody>
</TGroup>
</Table>
<?sml-need 25>
</Sect1>
<Sect1 Id="DCEADG.RPCACF.div.31">
<Title>Attribute Configuration Language</Title>
<Para><IndexTerm Id="DCEADG.RPCACF.indx.151">
<Primary>ACF</Primary>
<Secondary>grammar synopsis</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCACF.indx.152">
<Primary>Attribute Configuration Language</Primary>
<Secondary>syntax</Secondary>
</IndexTerm>This section summarizes the ACF syntax, in extended BNF notation.
</Para>
<InformalExample>
<Para><ProgramListing><?sml-point-size 11>
<!--no-op:  13-->
&lt;acf_interface> ::=
   &lt;acf_interface_header> "{" &lt;acf_interface_body> "}"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_interface_header> ::=
   [ &lt;acf_interface_attr_list> ] "interface" &lt;idl_interface_name>
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_interface_attr_list> ::= "[" &lt;acf_interface_attrs> "]"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_interface_attrs> ::=
   &lt;acf_interface_attr> [ "," &lt;acf_interface_attr> ] ...
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_interface_attr> ::= &lt;acf_code_attr> 
   | &lt;acf_nocode_attr> 
   | &lt;acf_auto_handle_attr>
   | &lt;acf_explicit_handle_attr>
   | &lt;acf_implicit_handle_attr>
   | &lt;acf_cs_tag_rtn_attr>
   | &lt;acf_extern_exceps_attr>
   | &lt;acf_encode_attr>
   | &lt;acf_decode_attr>
   | &lt;acf_binding_callout_attr>
   | &lt;acf_delegate_attr>
   | &lt;acf_lookup_attr>
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_auto_handle_attr> ::= "auto_handle"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_explicit_handle_attr> ::= "explicit_handle"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_implicit_handle_attr> ::=
   "implicit_handle" "(" &lt;acf_named_type> &lt;Identifier> ")"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_extern_exceps_attr> ::=
   "extern_exceptions" "(" &lt;acf_ext_excep_list> ")"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_ext_exceps_list> ::=
   "&lt;acf_ext_excep> ["," &lt;acf_ext_excep] ...
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_ext_excep> ::= &lt;Identifier>
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_binding_callout_attr> ::=
   "binding_callout" "(" &lt;acf_bind_call_rtn_name> ")"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_delegate_attr> ::= "cxx_delegate" "(" acf_delegate_name ")"

&lt;acf_delegate_name> ::= &lt;Identifier>

&lt;acf_lookup_attr> ::= "cxx_lookup" "(" acf_lookup_name ")"

&lt;acf_lookup_name> ::= &lt;Identifier>
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_bind_call_rtn_name> ::= &lt;Identifier>
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_interface_name> ::= &lt;Identifier>
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_interface_body> ::= [ &lt;acf_body_element> ] ...
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_body_element> ::= &lt;acf_include> ";" 
   | &lt;acf_type_declaration> ";"
   | &lt;acf_operation> ";"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_include> ::= [ &lt;acf_include_attr> ] \
             "include" &lt;acf_include_list>
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_include_attr> ::= "sstub" | "cstub" | "sstub" "," "cstub"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_include_list> ::= &lt;acf_include_name> \
             [ "," &lt;acf_include_name> ] ...
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_include_name> ::= """ &lt;filename> """
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_type_declaration> ::= typedef [ &lt;acf_type_attr_list> ] \
                                             &lt;acf_named_type>
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_named_type> ::= &lt;Identifier>
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_type_attr_list> ::= "[" &lt;acf_type_attrs> "]"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_type_attrs> ::= &lt;acf_type_attr> [ "," &lt;acf_type_attr> ] ...
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_type_attr> ::= &lt;acf_represent_attr> 
   | &lt;acf_cs_char_attr>
   | &lt;acf_heap_attr>
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_represent_attr> ::= "represent_as" "(" &lt;acf_repr_type> ")"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_cs_char_attr> ::=
 "cs_char" "C" "(" &lt;acf_cs_char_type> ")"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_cs_char_type> ::= &lt;acf_named_type>
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_repr_type> ::= &lt;acf_named_type>
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_operation> ::= [ &lt;acf_op_attr_list> ] &lt;Identifier> "(" 
   [ &lt;acf_parameters> ] ")"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_op_attr_list> ::= "[" &lt;acf_op_attrs> "]"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_op_attrs> ::= &lt;acf_op_attr> [ "," &lt;acf_op_attr> ] ...
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing><?sml-need 9>&lt;acf_op_attr> ::= &lt;acf_explicit_handle_attr>
   | &lt;acf_comm_status_attr>
   | &lt;acf_cs_tag_rtn_attr>
   | &lt;acf_encode_attr>
   | &lt;acf_decode_attr> 
   | &lt;acf_fault_status_attr>
   | &lt;acf_code_attr> 
   | &lt;acf_nocode_attr>
   | &lt;acf_enable_allocate_attr>
   | &lt;acf_static_attr>
   | &lt;acf_new_attr>
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_cs_tag_rtn_attr> ::=
 "cs_tag_rtn" "(" &lt;acf_cs_tag_rtn_name> ")"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_cs_tag_rtn_name> ::=
 &lt;Identifier>
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_parameters> ::= &lt;acf_parameter> [ "," &lt;acf_parameter> ] ...
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_parameter> ::= [ &lt;acf_param_attr_list> ] &lt;Identifier>
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_param_attr_list> ::= "[" &lt;acf_param_attrs> "]"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_param_attrs> ::= &lt;acf_param_attr> [ "," &lt;acf_param_attr> ] ...
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_param_attr> ::= &lt;acf_comm_status_attr> 
   | &lt;acf_fault_status_attr>
   | &lt;acf_cs_stag_attr>
   | &lt;acf_cs_drtag_attr>
   | &lt;acf_cs_rtag_attr>
   | &lt;acf_heap_attr>
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_code_attr> ::= "code"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_nocode_attr> ::= "nocode"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_encode_attr> ::= "encode"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_decode_attr> ::= "decode"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_cs_stag_attr> ::= "cs_stag"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_cs_drtag_attr> ::= "cs_drtag"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_cs_rtag_attr> ::= "cs_rtag"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_comm_status_attr> ::= "comm_status"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_fault_status_attr> ::= "fault_status"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_enable_allocate_attr> ::= "enable_allocate"
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_static_attr> ::= "cxx_static" | "cxx_static" \
         "(" &lt;acf_static_name> ")"

&lt;acf_static_name> ::= &lt;Identifier>
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_new_attr> ::= "cxx_new" "(" &lt;acf_new_name> ")"

&lt;acf_new_name> ::= &lt;Identifier>
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>&lt;acf_heap_attr> ::= "heap" 
<?sml-point-size 12>
<!--no-op:  14-->
</ProgramListing></Para>
</InformalExample>
<Para>
</Para>
</Sect1>
</Chapter>
<!--+ 11/27/96 19:53:47
    | tagMorph:  $Id: acf.sgm,v 1.1.2.8 1996/12/14 20:24:11 wardr Exp $
    | tagMorph library:  $Id: acf.sgm,v 1.1.2.8 1996/12/14 20:24:11 wardr Exp $
    | sml-to-docbook:  1.25
    +-->
