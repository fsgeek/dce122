<!--
# COPYRIGHT NOTICE
# Copyright (c) 1990-1996 Open Software Foundation, Inc. 
# ALL RIGHTS RESERVED (DCE). See the file named COPYRIGHT.DCE in the 
# src directory for the full copyright text. 
# 
# 
# HISTORY
# $Log: certification.sgm,v $
# Revision 1.1.2.14  1996/12/17  22:16:18  weir
# 	Last comments
# 	[1996/12/17  22:15:58  weir]
#
# Revision 1.1.2.13  1996/12/17  19:28:28  damon
# 	Expanded OSF C O P Y R I G H T   N O T I C E
# 	[1996/12/17  19:22:09  damon]
# 
# Revision 1.1.2.12  1996/12/15  16:18:49  weir
# 	editorial changes
# 	[1996/12/15  16:18:26  weir]
# 
# 	No change
# 	[1996/12/15  16:09:25  weir]
# 
# Revision 1.1.2.11  1996/12/09  14:07:03  weir
# 	Small corrections
# 	[1996/12/09  14:06:35  weir]
# 
# Revision 1.1.2.10  1996/12/08  23:15:39  weir
# 	Fixed two typos
# 	[1996/12/08  23:15:04  weir]
# 
# Revision 1.1.2.9  1996/12/08  23:06:52  weir
# 	Another update
# 	[1996/12/08  23:06:27  weir]
# 
# Revision 1.1.2.8  1996/12/08  22:49:27  weir
# 	Some formatting adjustments
# 	[1996/12/08  22:49:05  weir]
# 
# Revision 1.1.2.7  1996/12/08  22:43:22  weir
# 	Updates
# 	[1996/12/08  22:43:02  weir]
# 
# Revision 1.1.2.6  1996/12/03  01:56:13  weir
# 	Minor fixes
# 	[1996/12/03  01:55:53  weir]
# 
# Revision 1.1.2.5  1996/12/03  01:01:07  weir
# 	Minor changes
# 	[1996/12/03  01:00:46  weir]
# 
# Revision 1.1.2.4  1996/12/02  20:50:37  weir
# 	Free of SGML errors
# 	[1996/12/02  20:50:20  weir]
# 
# Revision 1.1.2.3  1996/12/02  19:21:45  weir
# 	Fixed some SGML errors
# 	[1996/12/02  19:21:24  weir]
# 
# Revision 1.1.2.2  1996/12/02  19:00:18  weir
# 	SGML conversion, first pass
# 	[1996/12/02  18:59:59  weir]
# 
# Revision 1.1.2.1  1996/12/02  15:41:09  weir
# 	Removed thinsp entities, corrected other minor errors
# 	[1996/12/02  15:39:21  weir]
# 
# $EndLog$
# 
-->
<!-- Fragment document type declaration subset:
ArborText, Inc., 1988-1993, v.4001
<!DOCTYPE Book PUBLIC "-//Davenport//DTD DocBook V2.4//EN" [
<!ENTITY DCEADG.SECCERT.ent.1  SYSTEM "eps/cert_api_organization.eps" NDATA eps>
<!ENTITY DCEADG.SECCERT.ent.2  SYSTEM "eps/certificate_chain.eps" NDATA eps>
<!ENTITY DCEADG.SECCERT.ent.3  SYSTEM "eps/certificate_parts.eps" NDATA eps>
<!ENTITY DCEADG.SECCERT.ent.4  SYSTEM "eps/how_pkeys_work_1.eps" NDATA eps>
<!ENTITY DCEADG.SECCERT.ent.5  SYSTEM "eps/how_pkeys_work_2.eps" NDATA eps>
]>
-->
<!-- OLD HISTORY  -->
<!--   -->
<!-- Revision 1.1.2.1  1996/10/16  19:40:05  weir  -->
<!-- 	Initial submission  -->
<!-- 	[1996/10/16  19:39:38  weir]  -->
<!--   -->
<!--   -->
<!-- Certification Application Guide chapter  -->
<!-- ============================================================================ -->
<!-- ============================================================================ -->
<Chapter RevisionFlag="changed">
<!-- ============================================================================ -->
<Title>The DCE Certification Service</Title>
<!-- ============================================================================ -->
<para>
The DCE certification service provides for the secure retrieval
of public keys, stored (through the DCE directory service) under
the names of the principals with which the keys are associated.
It is a name-to-public key translation service intended to be used
both by DCE components and DCE applications. The keys are stored in
data structures called ``certificates''.
</para>
<!-- -->
<para>
Rules that define which entities are trusted to create certificates
for which principals are embodied in policy modules, which have
the job of retrieving, upon request, the public keys from the certificates
(and verifying the certificates themselves when doing so).
</para>
<!-- -->
<para>
DCE certification is a ``secondary'' facility, in that the service it
provides is useful only in the context of some other application
activity. Essentially, it does nothing but return public keys when
presented with principal names (provided that the public keys have
been properly stored under the names in the first place). It is then
up to the application to do something useful with the keys.
</para>
<!-- -->
<para>
This chapter is not intended to provide detailed guidance on how DCE
applications should use public keys, although some discussion of
public key usage is included. It is mainly concerned with explaining
how DCE applications can use the certification service to store and
retrieve the keys.
</para>
<!-- -->
<!-- ============================================================================ -->
<!-- ============================================================================ -->
<Sect1>
<Title>Who Needs to Use the Certification API?</Title>
<!-- ============================================================================ -->
<!-- -->
<para>
The DCE certification service is intended to form one part of an implementation of a
public key based authentication (and data protection) service in DCE. Thus the
first-level users of the certification API will be various components of DCE itself;
for example, RPC. However, the certification service can also be (and is intended to be)
used by distributed applications that wish to use public keys for their own authentication
or data protection purposes. The high-level public key retrieval routines
are designed for this kind of use.
</para>
<!-- -->
<!-- -->
<!-- -->
<para>
The low-level certification routines, on the other hand, are intended for
applications that wish to implement and add new policies and/or cryptographic
modules. For example, adding a new policy will involve the following development
task(s):
</para>
<!-- -->
<ItemizedList>
<ListItem>
<para>
Implementing and registering a policy module
(see below)
</para>
<!-- -->
<para>
For example, a mail application that wished to institute
its own model for authenticating users by public key
would need to have its own policy module.
</para>
</ListItem>
<!-- ============================================================================ -->
<ListItem>
<para>
(Optional) Implementing and registering a cryptographic
module (see below)
</para>
<!-- -->
<para>
Cryptographic modules implement the various signature algorithms
required to allow policy modules to verify retrieved certificates.
Policy modules are generally concerned only with signature verification,
and (due to licensing constraints) signature generation functions are not
supplied with the cryptographic modules provided with the DCE reference
implementation. Applications that wish to use the public keys returned by
the DCE certification facility will typically augment the supplied
verification functions with signature generation routines.
</para>
</ListItem>
<!-- ============================================================================ -->
</ItemizedList>
<!-- -->
<para>
Other possible users of the DCE certification API might be developers who wish to
implement their own signature algorithms (cryptographic modules). (Signature
algorithms are specified in a field in the certificate; they are selected at the
time a certificate is created.) Only developers who wish to add to the available
signature algorithms, or who wish to add signature generation capability to a
supplied algorithm, will need to implement new cryptographic modules.
</para>
<!-- -->
<para>
The low-level certification API is not
intended to be accessed directly by run-of-the-mill DCE applications.
<!-- If your development tasks do not fall into any of the several special        -->
<!-- categories listed above in this section, you can ignore the rest of          -->
<!-- the contents of this chapter.                                                -->
</para>
<!-- -->
</Sect1>
<!-- ============================================================================ -->
<Sect1>
<Title>Overview of DCE Certification</Title>
<!-- ============================================================================ -->
<!-- -->
<para>
In the discussion that follows, note that the term ``principal'' does not necessarily
mean or imply ``DCE principal''. In a general sense, a principal is any name that can
be authenticated&mdash;that is, any name that has one or more associated key(s). A DCE
principal (one that is registered in the DCE registry) has DES key(s) maintained within
the registry, while a public key (PK) principal has one or more public keys (generally
stored within certificates). The only situation in which a PK principal has to be a DCE
principal is where an application is using the ``registry retrieval'' policy (see
``Direct secd Lookup: DCE Registry Lookup Policy Model'' below), since this policy
retrieves the principal's public keys from a its registry entry.
</para>
<!-- -->
<para>
The DCE certification service provides for the secure storage and
retrieval (by principal name) of public keys. The keys are stored
in the DCE directory service, under the principal names with which
they are to be associated.
</para>
<!-- -->
<para>
Principals' public keys are thus easily accessible through the
namespace. However, in order to be regarded as valid (certified),
the public key information must be properly ``signed'' by the
certifying authority (CA) authorized to deposit public key
information for the principal in question. The public key, with
the signature of the CA that issued it, is stored (together with
various other data) in a format defined by the ISO 9594-8/X.509
standard and called a ``certificate''. Just who the authorized
certifying authority for a given certificate is is defined by the
trust policy model applicable to the subject in whose name the
certificate is issued.
</para>
<!-- -->
<para>
The CA's signature is in the form of a checksum on the public key
encrypted with the CA's own private key, and verifiable by decrypting
with the CA's public key. The certificates are thus secure from
tampering by any entity but the authorized (according to the
defined policy model) CA, which alone possesses the private key
required to sign the data. 
</para>
<!-- -->
<!-- -->
<!-- ============================================================================ -->
<Sect2>
<Title>Use of Public Keys</Title>
<!-- ============================================================================ -->
<!-- -->
<para>
The DCE certification service stores and retrieves ``public'' keys.
The important characteristic of such keys is that they exist and
operate as pairs. Messages encrypted under one of the keys can
be decrypted by means of the other (and vice versa); but messages
cannot be encrypted and decrypted by means of the same key.
</para>
<!-- -->
<!-- ============================================================================ -->
<!-- Figure 1 -->
<Figure>
<Title>How Public Keys Work: Part 1</Title>
<Graphic Scalefit="1" Reprodep="300" Reprowid="300" Format="EPS" Entityref="DCEADG.SECCERT.ent.4"></Graphic>
<!-- <Graphic Format="EPS" Entityref="DCEADG.SECCERT.ent.4"></Graphic> -->
</Figure>
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- ============================================================================ -->
<!-- Figure 2 -->
<Figure>
<Title>How Public Keys Work: Part 2</Title>
<Graphic Scalefit="1" Reprodep="300" Reprowid="300" Format="EPS" Entityref="DCEADG.SECCERT.ent.5"></Graphic>
<!-- <Graphic Format="EPS" Entityref="DCEADG.SECCERT.ent.5"></Graphic> -->
</Figure>
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<para>
This asymmetric behavior of the public key-pair makes it ideal
for network authentication purposes. One of the keys can be freely
publicized in the network, and the other kept secret with, say,
a server principal who desires to use it to authenticate itself.
The server does this, whenever it is contacted by a prospective
client, by simply encrypting a message under its secret key and
sending it back to the client. The client then attempts to decrypt
the message using the public key it knows belongs to the principal
it wishes to contact. If it can decrypt the message, it regards
the server as having authenticated itself. The same procedure
can be used to authenticate the client (using a different key-pair).
</para>
<!-- -->
<para>
An important detail in the above scenario is that the prospective
client ``knows'' that the public key it uses to decrypt the server's
message really is that server's public key. The other (unmentioned)
detail is that the client has to get the public key from somewhere.
The secure distribution of the public keys is the job of the DCE
certification service.
</para>
<!-- -->
<para>
It is not desirable to have all the public keys indiscriminately
accessible to everybody, because then no one will have a reliable
criterion for believing whose key is whose. The public keys must
be deposited in such a way that users can always be sure that a given
public key really ``belongs'' to the principal it is supposed to belong
to; otherwise entities will be able to impersonate each other simply
by switching public keys in the database they are retrieved from.
Thus there needs to be some way to make sure that only authorized
entities have access to principals' public keys.
</para>
<!-- -->
<para>
The certification service ``certifies'' public keys by storing them
with ``signatures'' generated by the distributors of the keys.
The authenticating signatures on certificates are themselves
implemented by public/private key pairs. A signature is simply the
data of which the certificate consists, encrypted under the issuer's
private key. A potential user of the certificate must possess the
certificate issuer's public key. The issuer's public key can then
be passed (along with the certificate contents, including the signature)
to a library routine that will check whether the signature can be
successfully decrypted to produce the information in the rest of the
certificate. If the signature thus tested is found to be authentic,
the user of the certificate can be certain that it was issued by the
entity whose public key it checked against the certificate signature
&mdash; namely, the principal that is supposed to have issued the certificate.
The public key signature thus ensures the authenticity of data that
can be distributed (and thus easily accessed) via the namespace.
</para>
<!-- -->
<para>
A principal's public key can also be used by entities to protect
data being sent to the principal. Data encrypted under the public
key can be decrypted only by the possessor of the private key.
</para>
<!-- -->
</Sect2>
<!-- ============================================================================ -->
<Sect2>
<Title>Contents of Certificates</Title>
<!-- ============================================================================ -->
<!-- -->
<para>
The primary information that any certificate contains is the public
key that is to be associated with some principal name. ``Issuance'' of
a certificate means that the certificate is deposited into the name
service, and attached (as a directory attribute) to the principal
name it is to be associated with. Certificates are issued by
certifying authorities (CAs); the CA's signature on the certificate
is what certifies the public key information that the certificate
contains.
</para>
<!-- -->
<para>
A certificate contains the following information:
</para>
<!-- -->
<VariableList>
<VarListEntry role="linebreak">
<Term><Replaceable>subject name</Replaceable></Term>
<ListItem>
<para>
The name of the principal for whom the certificate
was issued. This is the name under which the
certificate contents will be read by users.</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Replaceable>issuer name</Replaceable></Term>
<ListItem>
<para>
The principal name of the issuer of the certificate,
a CA (certifying authority) authorized to issue
certificates for the subject.</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Replaceable>version number</Replaceable></Term>
<ListItem>
<para>
Identifies the X.509 format version of the
certificate.</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Replaceable>serial number</Replaceable></Term>
<ListItem>
<para>
The certificate serial number, used to identify
certificates in certificate revocation lists (CRLs).</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Replaceable>start time</Replaceable></Term>
<ListItem>
<para>
The time from which the certificate's contents are
considered to be valid.</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Replaceable>end time</Replaceable></Term>
<ListItem>
<para>
The time until which the certificate's contents are
valid.</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Replaceable>signature algorithm</Replaceable></Term>
<ListItem>
<para>
An OID (object identifier) that identifies the
algorithm used to encrypt the certificate signature.</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Replaceable>parameters</Replaceable></Term>
<ListItem>
<para>
Any parameters necessary to pass to the signature
verification algorithm.</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Replaceable>signature</Replaceable></Term>
<ListItem>
<para>
A checksum of the certificate data, encrypted under
the certificate issuer's private key, successful
verification of which, by means of the issuer's
public key, constitutes authentication of the
certificate.</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Replaceable>subject key</Replaceable></Term>
<ListItem>
<para>
The public key that is to be associated with the
subject of the certificate (named by ``subject name'').</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Replaceable>subject UUID</Replaceable></Term>
<ListItem>
<para>
(Optional) A UUID that identifies the certificate subject.</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Replaceable>issuer UUID</Replaceable></Term>
<ListItem>
<para>
(Optional) A UUID that identifies the issuer of the certificate.</para>
</ListItem>
</VarListEntry>
<!-- -->
</VariableList>
<!-- -->
<!-- -->
<para>
The most important ingredients of a certificate are: the principal
name which it is stored under; the public key which it contains;
and the signature of the CA that issued it. These can be illustrated
as shown in the following diagram:</para>
<!-- -->
<!-- -->
<!-- ============================================================================ -->
<!-- Figure 3 -->
<Figure>
<Title>The Essential Parts of a Certificate</Title>
<!-- <Graphic Scalefit="1" Reprodep="300" Reprowid="300" Format="EPS" Entityref="DCEADG.SECCERT.ent.3"></Graphic> -->
<Graphic Format="EPS" Entityref="DCEADG.SECCERT.ent.3"></Graphic>
</Figure>
<!-- -->
<!-- -->
</Sect2>
<!-- ============================================================================ -->
<Sect2>
<Title>Component Parts of the DCE Certification API</Title>
<!-- ============================================================================ -->
<!-- -->
<para>
The DCE certification API is organized into four groups of routines:
</para>
<!-- -->
<ItemizedList>
<ListItem>
<para>
Routines for implementing and registering cryptographic modules
</para>
<!-- -->
<para>
Cryptographic modules embody the signature algorithms
that are used to sign and verify certificates. Certificates
are signed by certifying authorities (which are usually
invoked by system administrators or some other specially
privileged authority to create certificates), and are
retrieved (and verified) by policy modules (which are called
by various applications seeking principals' public keys).
</para>
</ListItem>
<!-- -->
<ListItem>
<para>
Low-level certificate access and manipulation routines
</para>
<!-- -->
<para>
These routines represent the primitive certificate
access operations which are used in the implementation
of policy modules.
</para>
</ListItem>
<!-- -->
<ListItem>
<para>
Routines for implementing and registering policy modules
</para>
<para>
Policy modules embody the rules and mechanisms for
finding the public keys that are associated with some
specific set of principals.
</para>
<para>
High-level routines for use by applications that wish to
access the certification service
</para>
</ListItem>
</ItemizedList>
<!-- -->
<para>
The following diagram shows how these four groups of functionality
are related to each other and to their two main groups of user:
namely, system administrators and DCE applications.
</para>
<!-- -->
<!-- -->
<!-- ============================================================================ -->
<!-- Figure 4 -->
<Figure>
<Title>Certification API Organization</Title>
<!-- <Graphic Scalefit="1" Reprodep="300" Reprowid="300" Format="EPS" Entityref="DCEADG.SECCERT.ent.1"></Graphic> -->
<Graphic Format="EPS" Entityref="DCEADG.SECCERT.ent.1"></Graphic>
</Figure>
<!-- -->
<!-- -->
<!-- -->
<para>
Note that certifying authorities merely create the certificates and
deposit them in a place from which they can be retrieved (the
namespace); they play no part in the retrieval process itself. In
fact, this could be said to be the main reason for certificates
in the first place: they allow a facility such as the directory
service to be used as the distribution point for public keys (that is,
they allow an application to not have to arrange for getting its
keys to prospective clients by some private mechanism), and at the
same time they assure users that the key information that they
contain has not been tampered with.
</para>
<!-- -->
</Sect2>
<!-- -->
<!-- -->
<!-- -->
<!-- ============================================================================ -->
<Sect2>
<Title>High Level Certification API</Title>
<!-- ============================================================================ -->
<!-- -->
<para>
The following certification API routines are intended for general DCE application
use:
</para>
<!-- -->
<!-- -->
<!-- -->
<ItemizedList>
<ListItem><para>
<Function>pkc_get_registered_policies(3sec)</Function>
</para></ListItem>
<ListItem><para>
<Function>pkc_init_trustlist(3sec)</Function>
</para></ListItem>
<ListItem><para>
<Function>pkc_append_to_trustlist(3sec)</Function>
</para></ListItem>
<ListItem><para>
<Function>pkc_init_trustbase(3sec)</Function>
</para></ListItem>
<ListItem><para>
<Function>pkc_retrieve_keyinfo(3sec)</Function>
</para></ListItem>
<ListItem><para>
<Function>pkc_get_key_count(3sec)</Function>
</para></ListItem>
<ListItem><para>
<Function>pkc_get_key_data(3sec)</Function>
</para></ListItem>
<ListItem><para>
<Function>pkc_get_key_trust_info(3sec)</Function>
</para></ListItem>
<ListItem><para>
<Function>pkc_get_key_certifier_count(3sec)</Function>
</para></ListItem>
<ListItem><para>
<Function>pkc_get_key_certifier_info(3sec)</Function>
</para></ListItem>
<ListItem><para>
<Function>pkc_free_trustlist(3sec)</Function>
</para></ListItem>
<ListItem><para>
<Function>pkc_free_trustbase(3sec)</Function>
</para></ListItem>
<ListItem><para>
<Function>pkc_free_keyinfo(3sec)</Function>
</para></ListItem>
<ListItem><para>
<Function>pkc_free(3sec)</Function>
</para></ListItem>
</ItemizedList>
<!-- -->
<!-- -->
<!-- -->
<para>
Key retrieval consists basically of two operations:
</para>
<!-- -->
<OrderedList>
<ListItem>
<para>
Generating an ``initial trust base''&mdash;a starting point for future
certification paths, consisting of a list of principals and their keys.
An application would normally generate its initial trust base on startup.
</para>
</ListItem>
<!-- -->
<ListItem>
<para>
Using the trust base to retrieve key(s) for a specified principal.
</para>
</ListItem>
<!-- -->
</OrderedList>
<!-- -->
<!-- -->
<!-- -->
<Para>
In outline, a typical pattern for an application's use of the high-level
API might proceed according to the following series of calls:
</Para>
<!-- -->
<OrderedList>
<ListItem>
<Para><Function>pkc_get_registered_policies(3sec)</Function>
</Para>
<Para>Called once for the lifetime of the application. It returns a set of OIDs,
which point to all currently installed policies.
<!-- -->
</Para>
</ListItem>
<ListItem>
<Para><Function>pkc_init_trustlist(3sec)</Function>
</para>
<para>
The caller creates an empty ``trust list'' to hold the set of
certificates it initially trusts.
</para>
<!-- -->
</ListItem>
<ListItem>
<Para><Function>pkc_append_to_trustlist(3sec)</Function>
</Para>
<Para>Called one or more times, to add certificates or keys
which the caller trusts to its list of trusted keys.
</Para>
<Para>Steps 2 and 3 together build up the initial trust list.
</Para>
</ListItem>
<!-- -->
<ListItem>
<Para><Function>pkc_init_trustbase(3sec)</Function>
</Para>
<Para>
Computes a trust base, given the initial trust list.
The caller uses one of the OIDs returned in Step 1, together with the
list of trust items constructed in Steps 2 and 3, to access a policy
and initialize a ``trust base'' containing all the certificates
initially trusted under the specified policy, given the initial list of
trusted keys.
</para>
<!-- -->
</ListItem>
<ListItem>
<Para><Function>pkc_retrieve_keylist(3sec)</Function>
</Para>
<Para>Called one or more times, for each individual's public key that needs
to be looked up.
<!-- -->
</Para>
</ListItem>
<ListItem>
<Para><Function>pkc_free_trustlist(3sec)</Function>
</Para>
<para>
Frees storage allocated for the trust list.</para>
</ListItem>
<!-- -->
<ListItem>
<Para><Function>pkc_free_trustbase(3sec)</Function>
</Para>
<para>
Frees storage allocated for the trust base.
</para>
<!-- -->
</ListItem>
</OrderedList>
<!-- -->
<!-- -->
<!-- -->
</Sect2>
<!-- -->
<!-- -->
<!-- -->
<!-- ============================================================================ -->
<Sect2>
<Title>Policy Models</Title>
<!-- ============================================================================ -->
<!-- -->
<para>
A policy model (or trust policy model) is simply some scheme or
set of rules that dictates which certifying authorities are
authorized to issue certificates for which principals. In other
words, the policy model will prescribe whose signature is to be
regarded as a valid certifier for any given principal's certificates.
The policy module which embodies these rules will use them in
verifying the certificates it reads from the namespace.
</para>
<!-- -->
<para>
Since the certificates themselves are stored and accessed through
the DCE directory service (either GDS or CDS), one obvious policy
model will be to organize the certifying authorities' reponsibilities
according to the same hierarchies. However, models that employ
other certifying hierarchies, or no hierarchy at all, are also
possible.
</para>
<!-- -->
<!-- -->
<!-- ============================================================================ -->
<Sect3>
<Title>Certification Paths</Title>
<!-- ============================================================================ -->
<!-- -->
<para>
The mechanism that the certification service uses to embody more
complex models is certification paths. A certification path is
implemented by a sequence of certificates. Rather than immediately
accessing a given principal's certificate to determine its public
key, the user must access the beginning of a chain of certificates
in order to get to the final certificate that contains the desired
principal's public key. The intervening certificates consist of a
series of public keys of CAs, each certified by the next CA in the
chain.
</para>
<!-- -->
<para>
The following diagram shows how a certificate chain might be
used to find the public key of a principal, <Emphasis>X</Emphasis>:
</para>
<!-- -->
<!-- -->
<!-- -->
<!-- ============================================================================ -->
<!-- Figure 5 -->
<Figure>
<Title>A Certificate Chain</Title>
<Graphic Scalefit="1" Reprodep="300" Reprowid="300" Format="EPS" Entityref="DCEADG.SECCERT.ent.2"></Graphic>
<!-- <Graphic Format="EPS" Entityref="DCEADG.SECCERT.ent.2"></Graphic> -->
</Figure>
<!-- -->
<!-- -->
<para>
In a policy model that uses certification paths, a given principal's
public key is found by beginning with a certificate signed by a CA
that is trusted by the entity requesting the public key (in the above
diagram, the trusted CA is CA0). This certificate contains the
public key of the next CA in the path, namely CA1. The policy module
reads this certificate, learns the key of the next CA, CA2, and so
on, until the certificate for X, the original target, is found.
</para>
<!-- -->
<para>
The idea of certificate chains is to propagate authenticity via
certifying authorities while not propagating the authorities'
responsibility, thus reducing the effects of the compromise of
single authorities, wherever they may exist in the hierarchy of
authorities.
</para>
<!-- -->
<!-- -->
<!-- -->
</Sect3>
</Sect2>
</Sect1>
<!-- ============================================================================ -->
<Sect1>
<Title>Implementing and Registering a Cryptographic Module</Title>
<!-- ============================================================================ -->
<!-- -->
<para>
The routines in an application's cryptographic module make up the lowest level of
functionality in the certification mechanism. Each module consists of a set of (at
most) five routines, the most important of which are its <Function>sign()</Function>
and <Function>verify()</Function> routines. (Note, however, that the <Function>sign()</Function>
routine is not mandatory.)
</para>
<!-- -->
<!-- -->
<!-- ============================================================================ -->
<Sect2>
<Title>Contents of a Cryptographic Module</Title>
<!-- ============================================================================ -->
<!-- -->
<para>
Cryptographic modules are registered in the form of <Literal>pkc_signature_algorithm_t</Literal>
structures, which contain the entry points for the following developer-supplied routines:
</para>
<!-- -->
<VariableList>
<VarListEntry>
<Term><Function>open()</Function></Term>
<ListItem>
<para>
Opens the module</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry>
<Term><Function>close()</Function></Term>
<ListItem>
<para>
Closes the module</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry>
<Term><Function>verify()</Function></Term>
<ListItem>
<para>
Verifies a certificate signature</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry>
<Term><Function>sign()</Function></Term>
<ListItem>
<para>
Affixes a signature to a certificate
</para>
<!-- -->
<para>
<Function>verify()</Function> and <Function>sign()</Function> are the routines that will actually call
the encryption/decryption functions appropriate to the algorithm.</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry>
<Term><Function>name()</Function></Term>
<ListItem>
<para>
Returns the algorithm name, a character string that can be used in
auditing or diagnostic messages.</para>
</ListItem>
</VarListEntry>
<!-- -->
</VariableList>
<!-- -->
<para>
The <Literal>pkc_signature_algorithm_t</Literal> structure also contains the following
data fields:
</para>
<!-- -->
<!-- -->
<ItemizedList>
<ListItem>
<!-- -->
<!-- -->
<!-- -->
<!-- Instead of calling this a "certificate version number", call it -->
<!--   just "version number", or perhaps "crypto registration API    -->
<!--   version number"...                                            -->
<para>
a version number</para>
<para>
Note that the version field of a cryptographic module is not the same thing
as the version number of a certificate. A crypto module's version number is
the version of the certification API that it is designed for (which in particular
specifies the format of the <Literal>pkc_signature_algorithm_t</Literal> structure
used to register the crypto module).
</para>
</ListItem>
<ListItem>
<para>
an object identifier (OID) identifying the signature algorithm</para>
</ListItem>
</ItemizedList>
<!-- -->
<!-- -->
<!-- -->
</Sect2>
<!-- ============================================================================ -->
<Sect2>
<Title>Accessing a Registered Cryptographic Module</Title>
<!-- ============================================================================ -->
<!-- -->
<!-- -->
<!-- -->
<para>
Signature algorithms are identified by object identifiers (the character
string returned by <Function>name()</Function> is intended for use in diagnostic or
auditing messages). Certificates contain a field which identifies by OID
the algorithm used to sign that certificate.
</para>
<!-- -->
<!-- ============= -->
<para>
Policy implementors are recommended to access cryptographic modules mainly
through the following routines, which perform all locking necessary to make the
calls thread safe, and also transparently handle any context information that a
given cryptographic implementation may need.
</para>
<ItemizedList>
<ListItem><para>
<Function>pkc_crypto_get_registered_algorithms(3sec)</Function>
</para>
<para>
Call this routine to get an OID set describing the currently registered
algorithm implementations.
</para>
</ListItem>
<!-- -->
<ListItem><para>
<Function>pkc_crypto_sign(3sec)</Function>
</para><para>
Call this routine to get data signed.
</para>
</ListItem>
<!-- -->
<ListItem><para>
<Function>pkc_crypto_verify_signature(3sec)</Function>
</para><para>
Call this routine to verify signed data.
</para>
</ListItem>
<!-- -->
<ListItem><para>
<Function>pkc_crypto_generate_keypair(3sec)</Function>
</para><para>
Call this routine to generate a pair of public/private keys.
</para>
</ListItem>
</ItemizedList>
<!-- -->
<!-- -->
<para>
Information about a cryptographic module may be obtained by calling
<Function>pkc_crypto_lookup_algorithm(3sec)</Function>.
</para>
<!-- -->
<!-- -->
<Para>Data can also be signed and verified by looking up the desired algorithm (with
<Function>pkc_crypto_lookup_algorithm(3sec)</Function>) and then explicitly calling
the module's <Function>(sign)()</Function> or <Function>verify()</Function> routine,
although in this case the calling application must take care to avoid
multi-threading issues, and is also responsible for opening the crypto module
prior to use, and closing it afterwards.
</para>
<!-- -->
<!-- -->
<!-- ============= -->
<!-- -->
<!-- -->
<para>
A list of the OIDs of all currently registered cryptographic modules can be
obtained by calling <Function>pkc_crypto_get_registered_algorithms()</Function>.
You can then access information about a specific module by calling the
<Function>pkc_crypto_lookup_algorithm()</Function> routine. To sign data with a
private key or to verify signed data with a public key,
either <Function>pkc_crypto_verify_signature()</Function> or
<Function>pkc_crypto_sign()</Function> can be called.
</para>
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<para>
In the low-level certificate interrogation API, the <Function>verify()</Function>
routine is automatically called by the
<Function>pkc_crypto_verify_signature(3sec)</Function> routine.
</para>
<!-- -->
</Sect2>
<!-- ============================================================================ -->
<Sect2>
<Title>Signature Algorithms Provided by DCE Certification</Title>
<!-- ============================================================================ -->
<!-- -->
<para>
The signature algorithms provided with DCE 1.2.2 are <Literal>md2WithRSA</Literal> and
<Literal>md5WithRSA</Literal>.
</para>
<!-- -->
<!-- -->
<!-- -->
</Sect2>
<!-- -->
<!-- -->
<!-- -->
<!-- ============================================================================ -->
<Sect2>
<Title>Registering a Cryptographic Module</Title>
<!-- ============================================================================ -->
<!-- -->
<para>
Perform the following steps to register a cryptographic module:
</para>
<!-- -->
<!-- -->
<!-- -->
<OrderedList>
<!-- -->
<ListItem>
<para>
Implement the <Function>name()</Function> and <Function>verify()</Function> functions.
These two routines must be implemented.
</para>
</ListItem>
<!-- -->
<ListItem>
<para>
If your module needs to perform any initialization or finalization tasks,
implement <Function>open()</Function> and/or <Function>close()</Function>
routines for them. (These two routines are optional.)
</para>
</ListItem>
<!-- -->
<ListItem>
<para>
Implement <Function>sign()</Function> and <Function>generate_keypair()</Function>
functions if necessary. (These two routines are optional.)
</para>
</ListItem>
<!-- -->
<ListItem>
<para>
Create a <Literal>pkc_signature_algorithm_t</Literal> structure containing the
entrypoints of the routines implemented in Steps 1 to 3 (use <Literal>NULL</Literal>
for the entrypoint of any unimplemented routines), and use this structure to register
the algorithm implementation.
</para>
</ListItem>
<!-- -->
</OrderedList>
<!-- -->
<!-- -->
<!-- -->
</Sect2>
</Sect1>
<!-- ============================================================================ -->
<Sect1>
<Title>Implementing and Registering a Policy Module</Title>
<!-- ============================================================================ -->
<!-- -->
<para>
A certification trust model simply prescribes which certifying
authorities (CAs) can legitimately issue (create and sign)
certificates for which principals. A trust model is implemented
by a policy module. The ultimate purpose of the certification
service is to return public keys, and it is the job of the routines
in a policy module to do this. Looked at from this point of view,
policy modules are mainly distinguished from each other by the two
following things:
</para>
<!-- -->
<!-- -->
<ItemizedList>
<ListItem>
<para>
Which principals a policy module is willing to return keys
for.</para>
</ListItem>
<ListItem>
<para>
Which CAs a module is willing to trust the signatures of
on the certificates from which it retrieves keys.</para>
</ListItem>
</ItemizedList>
<!-- -->
<para>
A principal's certificates will be retrieved from a directory
service entry (exactly what entry depends on the policy used),
<!-- -->
<!-- A given principal's certificates aren't necessarily stored under             -->
<!-- the principal's directory entry.  For example, the standard                  -->
<!-- hierarchical policy will retrieve certificates stored                        -->
<!-- under either the principal or the certificate signatory.                     -->
<!-- -->
<!-- -->
and the policy module
will only look for certain signatures known to it on the certificates
it retrieves. However, direct retrieval via the subject's directory
entry name is only one trust model. There can be many others. For
example, see the discussion of certification paths above.
</para>
<!-- -->
<!-- -->
<!-- ============================================================================ -->
<Sect2>
<Title>Policy Modules Provided with DCE Certification</Title>
<!-- ============================================================================ -->
<!-- -->
<para>
Several certification policy modules are provided by DCE. These
policies are described in the following sections.
</para>
<!-- -->
<!-- -->
<!-- ============================================================================ -->
<Sect3>
<Title>Direct secd Lookup: DCE Registry Lookup Policy Model</Title>
<!-- ============================================================================ -->
<!-- -->
<para>
The registry lookup policy module simply looks up principals' public keys in the DCE
registry, and returns them. These keys are not held in certificates, but are stored
as extended registry attributes.
</para>
<!-- -->
<para>
If a caller of the high-level certificate retreival API has DCE credentials, then
the registry retrieval policy will authenticate the registry as part of the retrieval
operation. If no credentials are available, no authentication is possible. In this case,
keys will still be returned, but the certificate API will indicate to the caller that
the keys are untrusted.
</para>
<!-- -->
<!-- -->
<!-- -->
</Sect3>
<!-- ============================================================================ -->
<Sect3>
<Title>DCE Hierarchical Trust Policy</Title>
<!-- ============================================================================ -->
<!-- -->
<!-- -->
<!-- -->
<para>
The DCE hierarchical trust policy supplied with DCE 1.2.2 supports hierarchical
cells/DASS style trust paths. A trust path between principals A and B consists
of zero or more up links, followed by zero or one cross link, followed by zero or
more down links. The DCE hierarchical trust policy extension uses the DCE namespace
certificate store extension (NCSE) for certificate retrieval.
</para>
<!-- -->
<para>
Each cell is assumed to operate as a certification authority (CA) for top level
principals registered within that cell. Thus, the CA for the cell <Literal>over_cell</Literal>
is assumed to create a certificate for, say, the principal <Literal>felix</Literal> within
<Literal>over_cell</Literal>, where the certificate signatory is ``over_cell'' and the
certificate target is ``over_cell/felix''. If a cell employs structured names
for principals, each level is considered to act as a CA for its subordinate. For
example, if cell ``over_cell'' contains a principal <Literal>admin/JohnSmith</Literal>, then
<Literal>over_cell/admin/JohnSmith</Literal> is certified by two certificates, the first signed
by <Literal>over_cell</Literal> and certifying <Literal>over_cell/admin</Literal>, and the second signed by
<Literal>over_cell/admin</Literal> and certifying <Literal>over_cell/admin/JohnSmith</Literal>.
</para>
<!-- -->
<para>
To avoid requiring that the cell's root CDS directory be used for storing
certificates for the cell's principals, the DCE NCSE provided in DCE 1.2.2
allows any directory (in CDS or GDS) to be given an attribute (with OID
<Literal>1.3.24.9.15</Literal>) that names a subdirectory (of the directory to
which the attribute is given) within which certificates are to be stored. The
value of this attribute is a string which will be appended to the name of the
directory to give the name of a new directory within which certificates will be
stored.
</para>
<para>
For example, if the root directory in the cell <Literal>over_cell</Literal> is the
directory to which this ``certificate directory'' attribute is attached,
and the attribute contains the value <Literal>principals</Literal>, the DCE NCSE will
attempt to retrieve the certificate for <Literal>over_cell/P</Literal> from the CDS
directory <Literal>over_cell/principals/P</Literal>. If the ``certificate directory''
attribute is missing or empty, the cell root directory will be searched
for principal certificates. (Note that the insertion of the ``certificate
directory'' attribute value applies only to locating certificates within
the directory service; the above certificate would contain the name <Literal>over_cell/P</Literal>
as its actual subject.)
</para>
<!-- -->
<para>
At most one ``certificate directory'' attribute is considered when looking for
certificates for a given name, according to the following algorithm:
</para>
<ItemizedList>
<ListItem>
<para>
Starting with the name for which certificates are desired, RDNs are removed from
the right of the name until either a directory is found that contains the ``certificate
directory'' attribute, or the namespace root is reached.</para>
</ListItem>
</ItemizedList>
<!-- -->
<!-- Add the following para to the end of this section: -->
<!-- -->
<para>
In general, CDS administrators should define the ``certificate directory''
attribute within each CDS root directory, rather than storing certificates
within the root directory.  As well as reducing clutter in the cell root
directory, doing this has efficiency benefits (terminating the search for the
certificate directory at each CDS root), and also prevents the definition of
this attribute at a higher level within the DCE global namespace from
influencing the placement of certificates within a cell's namespace.
</para>
<!-- -->
</Sect3>
<!-- -->
<!-- ============================================================================ -->
<!-- To avoid having to perform this resolution for each certificate              -->
<!-- retrieved on a given trust path, and to allow certain other caching          -->
<!-- options within the NCSE, each NCSE certificate retrieval function            -->
<!-- takes a context object as a parameter, and the NCSE uses this object         -->
<!-- to store information about the structure of the namespace.                   -->
<!-- ============================================================================ -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- ============================================================================ -->
<Sect3>
<Title>PEM-like Policy</Title>
<!-- ============================================================================ -->
<!-- -->
<para>
No explicit PEM-like policy is provided with DCE 1.2.2; however, the DCE hierarchical
policy may be used in a PEM-like fashion by specifying root CA keys as the initial
trust list, rather than keys belonging to the caller's immediate CA.
</para>
<!-- -->
<!-- -->
<!-- -->
</Sect3>
</Sect2>
</Sect1>
<!-- ============================================================================ -->
<Sect1>
<Title>The Low Level Certificate Manipulation API</Title>
<!-- ============================================================================ -->
<!--                                                                              -->
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<!-- The low-level API has been completely re-designed.  See the header file      -->
<!-- "pkc_certs.h" for details.  Key differences are:                             -->
<!--                                                                              -->
<!-- + A C++ interface, including objects to represent and manipulate             -->
<!--   certificates                                                               -->
<!--                                                                              -->
<!-- + Caches are now "trust lists"                                               -->
<!--                                                                              -->
<!-- + No backing store interface is supported.                                   -->
<!--                                                                              -->
<!--                                                                              -->
<Para>The certificate manipulation API is a C++ interface. C++ must be used to
retrieve the certificates into trust lists and manilupulate them there.</para>
<!-- -->
<para>
The contents of the 
</para>
<!-- -->
<InformalExample><para>
			<FileName>/usr/include/dce/asn.h</FileName>
</para></InformalExample>
<!-- -->
<para>and
</para>
<!-- -->
<InformalExample><para>
			<FileName>/usr/include/dce/x509.h</FileName>
</para></InformalExample>
<!-- -->
<para>
header files define some of the basic types used by the low-level certificate
manipulation routines, including the actual structure of certificates. Following
is a list of the low-level certificate routines defined in the</para>
<!-- -->
<InformalExample><para>
			<FileName>/usr/include/dce/pkc_certs.h</FileName>
</para></InformalExample>
<!-- -->
<para>
file:
</para>
<!-- -->
<!-- -->
<!-- -->
<ItemizedList>
<ListItem><para>
<Function>pkc_add_trusted_key(3sec)</Function>
</para></ListItem>
<ListItem><para>
<Function>pkc_lookup_keys_in_trustlist(3sec)</Function>
</para></ListItem>
<ListItem><para>
<Function>pkc_lookup_key_in_trustlist(3sec)</Function>
</para></ListItem>
<ListItem><para>
<Function>pkc_lookup_element_in_trustlist(3sec)</Function>
</para></ListItem>
<ListItem><para>
<Function>pkc_check_cert_against_trustlist(3sec)</Function>
</para></ListItem>
<ListItem><para>
<Function>pkc_revoke_certificate(3sec)</Function>
</para></ListItem>
<ListItem><para>
<Function>pkc_revoke_certificates(3sec)</Function>
</para></ListItem>
<!-- <ListItem><para>                                 -->
<!-- <Function>pkc_prune_trustlist(3sec)</Function>   -->
<!-- </para></ListItem>                               -->
<ListItem><para>
<Function>pkc_delete_trustlist(3sec)</Function>
</para></ListItem>
<ListItem><para>
<Function>pkc_copy_trustlist(3sec)</Function>
</para></ListItem>
<!-- -->
<ListItem><para>
<Function>pkc_display_trustlist(3sec)</Function>
</para></ListItem>
</ItemizedList>
<!-- -->
<!-- -->
<!-- -->
<!--
<VariableList>
<VarListEntry role="linebreak">
<Term><Function>pkc_alloc()</Function></Term>
<ListItem>
<para>
Used by the certification routines to allocate storage.</para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>pkc_free()</Function></Term>
<ListItem>
<para>
Releases storage that was allocated by any of the certification routines
to return data.</para>
</ListItem>
</VarListEntry>
</VariableList>
-->
<!-- -->
<!-- -->
<!-- -->
<!-- ============================================================================ -->
<Sect2>
<Title>Policy Module Implementation</Title>
<!-- ============================================================================ -->
<!--                                                                              -->
<!--                                                                              -->
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<!-- A policy module's external interface has been expanded somewhat.  See the    -->
<!-- new "pkc_plcy_reg.h" header file.  Key retrieval now consists of two         -->
<!-- operations:                                                                  -->
<!--                                                                              -->
<!-- i)  generating an "initial trustbase" - a starting point for future          -->
<!-- certification paths, consisting of a list of principals and their keys.      -->
<!-- An application would normally generate its initial trustbase on startup.     -->
<!--                                                                              -->
<!-- ii) Using the trustbase to retrieve key(s) for a specified principal.        -->
<!-- -->
<!-- -->
<!-- -->
<para>
Implementation of a policy module consists essentially of writing
<Function>establish_trustbase()</Function>, <Function>delete_trustbase()</Function>,
<Function>retrieve_keyinfo()</Function> and <Function>delete_keyinfo()</Function>
routines, and associated interrogation routines. The module will find certificates
for principal names according to the rules set out for that module, verify their
signatures, and return the public keys found in them to the original callers.
</para>
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- ============================================================================ -->
<Sect3>
<Title>Certificate Revocation Lists (CRLs)</Title>
<!-- ============================================================================ -->
<!-- -->
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<!-- Use of CRLs is policy-specific.  pkc_certs provides objects for parsing -->
<!-- and manipulating CRLs, and for using them to invalidate portions of a -->
<!-- trust-list. -->
<!-- -->
<para>
Certificate revocation lists are lists of certificates whose contents are no
longer to be believed. Use of CRLs is policy-specific. <Literal>pkc_certs</Literal> provides
objects for parsing and manipulating CRLs, and for using them to invalidate
portions of a trust list.
</para>
<!-- -->
<!-- -->
</Sect3>
</Sect2>
<!-- ============================================================================ -->
<Sect2>
<Title>Accessing a Registered Policy Module</Title>
<!-- ============================================================================ -->
<!-- -->
<!-- -->
<para>
Policy modules are registered in the form of <Literal>pkc_policy_t</Literal> structures,
which contain the entry points for the following developer-written routines:
</para>
<!-- -->
<VariableList>
<VarListEntry>
<Term><Function>open()</Function></Term>
<ListItem>
<para>
opens the module</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry>
<Term><Function>close()</Function></Term>
<ListItem>
<para>
closes the module</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Function>retrieve_keyinfo()</Function></Term>
<ListItem>
<para>
returns the public key for a specified principal name</para>
</ListItem>
</VarListEntry>
<!-- -->
<!-- -->
<VarListEntry>
<Term><Function>name()</Function></Term>
<ListItem>
<para>
Returns the name of the policy.
</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry>
<Term><Function>establish_trustbase()</Function></Term>
<ListItem>
<para>
Creates a trust base.
</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry>
<Term><Function>delete_trustbase()</Function></Term>
<ListItem>
<para>
Deletes a trust base.
</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry>
<Term><Function>delete_keyinfo()</Function></Term>
<ListItem>
<para>
Deletes a <Literal>keyinfo</Literal> handle.
</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry>
<Term><Function>get_key_count()</Function></Term>
<ListItem>
<para>
Returns the number of keys a <Literal>keyinfo</Literal> handle
contains.
</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry>
<Term><Function>get_key_data()</Function></Term>
<ListItem>
<para>
Retrieves an individual key.
</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry>
<Term><Function>get_key_trust()</Function></Term>
<ListItem>
<para>
Returns the type of trust established for a specific key.
</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry>
<Term><Function>get_key_certifier_count()</Function></Term>
<ListItem>
<para>
Returns the number of certifiers in the trust path that certified a key.
</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry>
<Term><Function>get_key_certifier_info()</Function></Term>
<ListItem>
<para>
Returns information about a specific certifier of a key.
</para>
</ListItem>
</VarListEntry>
<!-- -->
</VariableList>
<!-- -->
<para>
The <Literal>pkc_policy_t</Literal> structure also contains the following data fields:
</para>
<!-- -->
<ItemizedList>
<ListItem>
<para>
a certificate version number</para>
</ListItem>
<!-- -->
<ListItem>
<para>
an object identifier (OID) identifying the policy module</para>
</ListItem>
<!-- -->
</ItemizedList>
<!-- -->
<para>
Policy modules, similarly to signature algorithms (cryptographic
modules), are identified by object identifiers (the character string returned
by <Function>name()</Function> is intended for use in diagnostic or auditing messages).
</para>
<!-- -->
<para>
Also similarly to cryptographic modules, there are two ways in which
cryptographic modules can be accessed: either by a single call to which the
identifying OID is passed (this is the recommended method); or by calling
<Function>pkc_plcy_lookup_policy(3sec)</Function> and then (for example)
the module's <Function>(*retrieve_key)()</Function> routine to obtain the
public key (a list of the OIDs of all currently registered policy modules can be
obtained by calling <Function>pkc_plcy_get_registered_policies()</Function>).
</para>
<!-- -->
<!-- -->
<!-- -->
</Sect2>
<!-- -->
<!-- -->
<!-- -->
<!-- ============================================================================ -->
<Sect2>
<Title>Registering a Policy Module</Title>
<!-- ============================================================================ -->
<!-- -->
<!-- -->
<para>
You must implement the following routines in any policy module:
</para>
<!-- -->
<!-- -->
<!-- -->
<!-- you probably only need a section similar to the crypto module implementation -->
<!-- section that says how to construct a pkc_policy_t structure and invoke       -->
<!-- pkc_plcy_register_policy() to register it.                                   -->
<!-- -->
<!-- -->
<!-- -->
<VariableList>
<!-- -->
<VarListEntry>
<Term><Function>name()</Function></Term>
<ListItem>
<para>
Returns the name of the policy.</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Function>establish_trustbase()</Function></Term>
<ListItem>
<para>
Creates a trust base, which is a policy-specific data structure
based on the initial set of trusted keys.</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Function>retrieve_keyinfo()</Function></Term>
<ListItem>
<para>
Given a trust base, returns a handle to keys for a specific principal.</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Function>delete_trustbase()</Function></Term>
<ListItem>
<para>
Deletes a trust base.</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Function>delete_keyinfo()</Function></Term>
<ListItem>
<para>
Deletes a <Literal>keyinfo</Literal> handle.</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Function>get_key_count()</Function></Term>
<ListItem>
<para>
Given a <Literal>keyinfo</Literal> handle, returns the number of keys it
contains.</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Function>get_key_data()</Function></Term>
<ListItem>
<para>
Retrieves an individual key from a <Literal>keyinfo</Literal> handle</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Function>get_key_trust()</Function></Term>
<ListItem>
<para>
Returns the type of trust established for a specific key, and
the purpose(s) for which that trust applies.</para>
</ListItem>
</VarListEntry>
<!-- -->
</VariableList>
<!-- -->
<!-- -->
<!-- -->
<para>
The following policy routines are optional:
</para>
<!-- -->
<!-- -->
<!-- -->
<VariableList>
<!-- -->
<VarListEntry>
<Term><Function>open()</Function></Term>
<Term><Function>close()</Function></Term>
<ListItem>
<para>
These routines perform any initialization and/or finalization tasks required
by the module.</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Function>get_key_certifier_count()</Function></Term>
<ListItem>
<para>
This routine is required only for policies that return
<Literal>CERTIFIED_TRUST</Literal> keys; it returns the number of
certifiers in the trust path that certified a key.</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Function>get_key_certifier_info()</Function></Term>
<ListItem>
<para>
This routine is required if the module implements
<Function>get_key_certifier_count()</Function>. It returns information about
a specific certifier with the certification path of a specific key.
Certifier 0 is the immediate certifier of the key; certifier 1 is the CA that
certified certifier 0, and so on.</para>
</ListItem>
</VarListEntry>
<!-- -->
</VariableList>
<!-- -->
<!-- -->
<!-- -->
<para>
Once you have implemented all necessary routines for you module, you must
create a <Literal>pkc_policy_t</Literal> structure containing their entrypoints.
Unimplemented routines' entrypoints should be specified as <Literal>NULL</Literal>.
</para>
<!-- -->
<!-- -->
<!-- -->
</Sect2>
<!-- -->
<!-- -->
<!-- -->
<!-- ============================================================================ -->
<Sect2>
<Title>Registering the module</Title>
<!-- ============================================================================ -->
<!-- -->
<para>
The module is registered by calling the registration function and passing it
a <Literal>pkc_policy_t</Literal> structure, which contains the entry points for the module
routines described above:
</para>
<!-- -->
<InformalExample><para>
			<Function>pkc_plcy_register_policy()</Function>
</para></InformalExample>
<!-- -->
<!-- -->
</Sect2>
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
</Sect1>
</Chapter>
<!-- ============================================================================ -->
