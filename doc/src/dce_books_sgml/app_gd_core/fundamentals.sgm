<!--
# @OSF_COPYRIGHT@
# 
# 
# HISTORY
# $Log: fundamentals.sgm,v $
# Revision 1.1.2.8  1996/12/14  20:24:25  wardr
# 	{edit,R1.2.2}
# 	penultimate format fixes
# 	[1996/12/14  20:22:22  wardr]
#
# Revision 1.1.2.7  1996/12/13  22:11:08  wardr
# 	{edit,R1.2.2}
# 	Fixed formatting problems
# 	[1996/12/13  22:08:55  wardr]
# 
# Revision 1.1.2.6  1996/12/12  21:30:45  wardr
# 	{edit,R1.2.2}
# 	Fixed formatting problems
# 	[1996/12/12  21:28:53  wardr]
# 
# Revision 1.1.2.5  1996/12/12  16:49:44  carrig
# 	{enh,R1.2.2}
# 	Minor edits
# 	[1996/12/12  16:47:32  carrig]
# 
# Revision 1.1.2.4  1996/12/06  21:10:24  carrig
# 	{enh,R1.2.2}
# 	Second pass for editor
# 	[1996/12/06  21:08:20  carrig]
# 
# Revision 1.1.2.3  1996/12/05  21:39:14  carrig
# 	{enh,R1.2.2}
# 	First pass to prepare for editing
# 	[1996/12/05  21:37:23  carrig]
# 
# Revision 1.1.2.2  1996/12/02  15:41:22  weir
# 	Removed thinsp entities, corrected other minor errors
# 	[1996/12/02  15:39:34  weir]
# 
# Revision 1.1.2.1  1996/12/01  20:43:50  weir
# 	Initial submission
# 	[1996/12/01  20:41:51  weir]
# 
# $EndLog$
-->
<!-- Fragment document type declaration subset:
ArborText, Inc., 1988-1993, v.4001
<!DOCTYPE Book PUBLIC "-//Davenport//DTD DocBook V2.4//EN" [
<!ENTITY  DCEADG.RPCFUN.ent.1  SYSTEM "eps/4_remoteness_01.ps" NDATA eps>
<!ENTITY  DCEADG.RPCFUN.ent.2  SYSTEM "eps/4_remoteness_04.ps" NDATA eps>
<!ENTITY  DCEADG.RPCFUN.ent.3  SYSTEM "eps/4_remoteness_06.ps" NDATA eps>
]>
-->
<!-- COPYRIGHT NOTICE-->
<!-- Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.-->
<!-- ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for-->
<!-- the full copyright text.-->
<!-- -->
<!-- -->
<!-- OLD HISTORY-->
<!-- Revision 1.1.4.1  1996/03/27  13:32:23  wardr-->
<!-- 	{edit R1.2.1}-->
<!-- 	More Release Edits-->
<!-- 	[1996/03/27  13:31:47  wardr]-->
<!---->
<!-- Revision 1.1.2.10  1995/06/07  14:37:56  rcb-->
<!-- 	PRENTICE HALL reformat; final edits and changes-->
<!-- 	[1995/06/05  19:55:55  rcb]-->
<!-- -->
<!-- 	PRENTICE HALL reformat-->
<!-- 	[1995/04/17  18:05:16  rcb]-->
<!-- -->
<!-- 	incorporated 1.1 edits-->
<!-- 	[1995/04/17  17:34:31  rcb]-->
<!-- -->
<!-- Revision 1.1.2.9  1994/10/27  22:54:07  jshirley-->
<!-- 	Fix minor edit so book will build.-->
<!-- 	[1994/10/27  22:53:52  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.8  1994/10/27  19:42:54  jshirley-->
<!-- 	Final edits.-->
<!-- 	[1994/10/27  19:41:47  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.7  1994/09/14  19:21:12  jshirley-->
<!-- 	{def,10526,R1.1,Reorg RPC chapters.-->
<!-- 	[1994/09/14  19:20:36  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.6  1994/09/01  18:37:36  buckler-->
<!-- 	{enh, 8569, R1.1}-->
<!-- 	Added another caveat about input argument size limit.-->
<!-- 	[1994/09/01  18:36:47  buckler]-->
<!-- -->
<!-- Revision 1.1.2.5  1994/09/01  18:27:14  buckler-->
<!-- 	{enh, 8569, R1.1}-->
<!-- 	Added caveats about broadcasting.-->
<!-- 	[1994/09/01  18:26:22  buckler]-->
<!-- -->
<!-- Revision 1.1.2.4  1994/08/11  20:36:29  jhh-->
<!-- 	expand copyright-->
<!-- 	[1994/08/11  19:58:31  jhh]-->
<!-- -->
<!-- Revision 1.1.2.3  1994/07/13  15:02:14  jshirley-->
<!-- 	{def,10220,R1.1} Remove reference to rpcd and sec_clientd-->
<!-- 	[1994/07/13  15:01:31  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.2  1994/07/11  15:48:48  jshirley-->
<!-- 	{def,10526,R1.1}-->
<!-- 	Swapped order of two sections.  Now have UUID followed by Comm.  Protocol-->
<!-- 	discusions.-->
<!-- 	[1994/07/11  15:48:22  jshirley]-->
<!-- -->
<!-- 	{def,10526,R1.1}-->
<!-- 	Merged in information from old files (1_intro.gpsml,2_components.gpsml,-->
<!-- 	6_advanced_topics.gpsml) and modified headings.-->
<!-- 	Data is still in a rough state.-->
<!-- 	[1994/07/11  15:35:37  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.1  1994/07/07  19:12:04  jshirley-->
<!-- 	{def,10526,R1.1}-->
<!-- 	Created new file for the RPC reorganization based on the-->
<!-- 	old file 4_remoteness.gpsml.-->
<!-- 	[1994/07/07  19:11:35  jshirley]-->
<!-- -->
<!-- -->
<Chapter Id="DCEADG.RPCFUN.div.1">
<Title>RPC Fundamentals</Title>
<Para>DCE RPC provides a call environment that behaves essentially like a local call
environment.  However, some special requirements are imposed on remote procedure
calls by the remoteness of calling code to the called procedure.
Therefore, a remote procedure
call may not always behave exactly like a local procedure call. 
</Para>
<Para>This chapter discusses the following topics:
</Para>
<ItemizedList>
<ListItem>
<Para>Universal unique identifiers
</Para>
</ListItem>
<ListItem>
<Para>Communications protocols
</Para>
</ListItem>
<ListItem>
<Para>Binding information
</Para>
</ListItem>
<ListItem>
<Para>Endpoints
</Para>
</ListItem>
<ListItem>
<Para>Execution semantics
</Para>
</ListItem>
<ListItem>
<Para>Communication failures
</Para>
</ListItem>
<ListItem>
<Para>Scaling applications
</Para>
</ListItem>
<ListItem>
<Para>RPC Objects
</Para>
</ListItem>
</ItemizedList>
<!-- END .ML (bulleted) list-->
<Para><?sml-need 5>Distributed applications have the following implications:
</Para>
<ItemizedList>
<ListItem>
<Para>Client/server relationship&mdash;binding
</Para>
<Para>Like a local procedure call,
a remote procedure call depends on a static relationship between the calling
code and the called procedure.  In a local application,
this relationship is established by linking the calling and called code.
Linking gives the calling code access to the address 
of each procedure to be called.
Enabling a remote procedure call to go to the right procedure
requires a similar relationship
<IndexTerm Id="DCEADG.RPCFUN.indx.1">
<Primary>binding</Primary>
</IndexTerm>(called a <Symbol Role="Variable">binding</Symbol>) between a client and a server.
A binding is a temporary relationship that depends on a
communications link between the client and server RPC runtimes.
A client establishes a binding over a specific protocol sequence to a specific
host system and endpoint.
</Para>
</ListItem>
<ListItem>
<Para>Independent address spaces
</Para>
<Para>The calling code and called remote procedure reside in different address
spaces, generally on separate systems.  The calling and called code cannot
share global variables or other global program state such as open files. 
All data shared between the caller and the called remote procedure must be
specified as procedure parameters in the IDL specification.  
Unlike a local procedure call that
commonly uses the call-by-reference passing mechanism for input/output
parameters, remote procedure calls with input/output parameters have
copy-in/copy-out semantics due to the differing address spaces of the
calling and called code.
These two passing mechanisms are only slightly different, and most
procedure calls are not sensitive to the differences between
call-by-reference and copy-in/copy-out semantics.
</Para>
</ListItem>
<ListItem>
<Para>Independent failure
</Para>
<Para>Distributing a calling program and the called procedures to physically separate
machines increases the complexity of procedure calls.  Remoteness introduces
issues such as a remote system crash, communications failures, 
naming and binding
issues, security problems, and protocol incompatibilities.  Such issues can
require error handling that is unnecessary for local procedure calls. 
Also, as with local procedure calls, remote procedure calls are subject
to execution errors that arise from the procedure call itself. 
</Para>
</ListItem>
</ItemizedList>
<Sect1 Id="DCEADG.RPCFUN.div.2">
<Title>Universal Unique Identifiers</Title>
<IndexTerm Id="DCEADG.RPCFUN.indx.2">
<Primary>UUIDs</Primary>
</IndexTerm>
<Para>Each UUID contains information, including a timestamp and a host identifier.
Applications
use UUIDs to identify many kinds of entities.  DCE RPC identifies 
several uses of UUIDs, according to the kind of entities each identifies: 
</Para>
<ItemizedList>
<ListItem>
<Para>Interface UUID
</Para>
<Para>A UUID that identifies a specific RPC interface.  An interface UUID
is declared in an RPC interface definition (an IDL file) and is
a required element of the interface.  For example:
</Para>
<InformalExample>
<Para><ProgramListing>uuid(2fac8900-31f8-11ca-b331-08002b13d56d),
</ProgramListing></Para>
</InformalExample>
</ListItem>
<ListItem>
<Para>Object UUID
</Para>
<Para>A UUID that identifies an entity for an application; for example, a resource,
a service, or a particular instance of a server.
An application defines an RPC object by associating the object with its own
UUID known as an 
<!-- .gL "object UUID"-->
<IndexTerm Id="DCEADG.RPCFUN.indx.3">
<Primary>object</Primary>
<Secondary>UUID</Secondary>
</IndexTerm><FirstTerm>object UUID</FirstTerm>. 
The object UUID exists independently of the object, unlike an interface UUID.
A server usually generates UUIDs for its
objects as part of initialization.  A given object UUID is meaningful only
while a server is offering the corresponding RPC object to clients. 
</Para>
<Para>To distinguish a specific use of an object UUID, 
a UUID is sometimes labeled for the entity it identifies.
For example, an object UUID that is used to identify a particular instance
of a server is known as an 
<IndexTerm Id="DCEADG.RPCFUN.indx.4">
<Primary>instance</Primary>
<Secondary>RPC UUID</Secondary>
</IndexTerm><FirstTerm>instance UUID</FirstTerm>.
</Para>
</ListItem>
<ListItem>
<Para>Type UUID
</Para>
<Para><IndexTerm Id="DCEADG.RPCFUN.indx.5">
<Primary>type</Primary>
<Secondary>UUID</Secondary>
</IndexTerm>A UUID that identifies a set of RPC objects and an
associated manager (the set of remote procedures that
implements an RPC interface for objects of that type).
This is often called a <Symbol Role="Variable">manager type UUID</Symbol>.
</Para>
</ListItem>
</ItemizedList>
<!-- .ML (bulleted) list-->
<Para>Servers can 
create object and type UUIDs by calling the <Function>uuid_create()</Function> routine.
</Para>
</Sect1>
<Sect1 Id="DCEADG.RPCFUN.div.3">
<Title>Communications Protocols</Title>
<Para>A communications link depends on a set of communications protocols.  
A
<!-- .gL "communications protocol"-->
<IndexTerm Id="DCEADG.RPCFUN.indx.6">
<Primary>communications</Primary>
<Secondary>protocols</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCFUN.indx.7">
<Primary>communications</Primary>
<Secondary>RPC protocol</Secondary>
</IndexTerm>communications protocol is a clearly defined set of operational
rules and procedures for communications.
<IndexTerm Id="DCEADG.RPCFUN.indx.8">
<Primary>protocol</Primary>
<Secondary>for RPC communications</Secondary>
</IndexTerm></Para>
<Para>Communications protocols include a 
transport protocol
(from the Transport Layer of the OSI network architecture) 
<!-- .gL "transport protocol"-->
<IndexTerm Id="DCEADG.RPCFUN.indx.9">
<Primary>transport protocol</Primary>
</IndexTerm>such as the Transmission Control Protocol (TCP) 
or the User Datagram Protocol (UDP); 
and the
<!-- .gL "network protocol"-->
<IndexTerm Id="DCEADG.RPCFUN.indx.10">
<Primary>network</Primary>
<Secondary>protocol</Secondary>
</IndexTerm>corresponding network protocol
(from the OSI Network Layer) such as 
the Internet Protocol (IP).
</Para>
<Para>For an RPC client and server to communicate, their RPC
runtimes must use at least one
identical communications protocol, including a common
RPC protocol, transport protocol, and network protocol.
<!-- .gL "RPC protocol"-->
<!-- .iX "RPC protocol" "definition of"-->
<IndexTerm Id="DCEADG.RPCFUN.indx.11">
<Primary>RPC</Primary>
<Secondary>protocol</Secondary>
</IndexTerm>An RPC protocol is a communications protocol 
that supports the semantics of the DCE RPC 
API and runs over specific combinations of
transport and network protocols.
DCE RPC provides two RPC protocols:
the connectionless RPC protocol and the connection-oriented RPC protocol.  
</Para>
<ItemizedList>
<ListItem>
<Para>Connectionless (Datagram) RPC protocol
<!-- .gL "connectionless RPC protocol"-->
<IndexTerm Id="DCEADG.RPCFUN.indx.12">
<Primary>connectionless RPC protocol</Primary>
</IndexTerm></Para>
<Para>This protocol runs over a connectionless transport protocol
such as UDP.  
The connectionless protocol supports broadcast calls.
</Para>
</ListItem>
<ListItem>
<Para>Connection-oriented RPC protocol
<!-- .gL "connection-oriented RPC protocol"-->
<IndexTerm Id="DCEADG.RPCFUN.indx.13">
<Primary>connection-oriented RPC protocol</Primary>
</IndexTerm></Para>
<Para><!---->
This protocol runs over a connection-oriented transport protocol
such as TCP.
</Para>
</ListItem>
</ItemizedList>
<Para>Each binding uses a single RPC protocol and a single pair of
transport and network protocols.  Only certain combinations of communications
protocols are functionally valid (are actually useful for
interoperation); for instance, the RPC connectionless protocol cannot
run over connection-oriented transport protocols such as TCP.
<!-- or NSP.-->
DCE RPC supports the following combinations of communications
protocols (as provided by OSF):
</Para>
<ItemizedList>
<ListItem>
<Para>RPC connection-oriented protocol over 
the Internet Protocol Suite, Transmission Control Protocol (TCP/IP)
<!-- .LI-->
<!-- RPC connection-oriented over DECnet Network Services Protocol -->
<!-- (NSP) (DECnet Phase IV)-->
<!-- .LI-->
<!-- RPC connection-oriented over Open Systems Interconnection -->
<!-- ...\" (ISO TP4) -->
<!-- (DECnet Phase V)-->
</Para>
</ListItem>
<ListItem>
<Para>RPC connectionless protocol over 
the Internet Protocol Suite, User Datagram Protocol (UDP/IP)
<!-- .LI -->
<!-- RPC connectionless over Domain Datagram Service-->
</Para>
</ListItem>
</ItemizedList>
</Sect1>
<Sect1 Id="DCEADG.RPCFUN.div.4">
<Title>Binding Information</Title>
<!-- .gL "binding information"-->
<IndexTerm Id="DCEADG.RPCFUN.indx.14">
<Primary>binding</Primary>
<Secondary>information</Secondary>
</IndexTerm>
<Para>Binding information includes a set of information that
identifies a server to a client or a client to a server. 
Each instance of 
binding information contains all or part of a single address.  The RPC runtime
maintains binding information for RPC servers and clients.  To make a
specific instance of locally maintained binding information available to a
given server or client, the runtime creates a local reference known as a 
<!-- .gL "binding handle"-->
<IndexTerm Id="DCEADG.RPCFUN.indx.15">
<Primary>binding</Primary>
<Secondary>handle</Secondary>
</IndexTerm><FirstTerm>binding handle</FirstTerm>.  Servers and clients use binding handles to refer to
binding information in runtime calls or remote procedure calls. 
A server obtains a complete list of its binding handles from its RPC runtime. 
A client obtains one binding handle at a time from its RPC runtime. 
Figure 12-1 illustrates a binding.
</Para>
<Figure>
<Title>A Binding</Title>
<Graphic Entityref="DCEADG.RPCFUN.ent.1" Scalefit="1" Reprowid="300" Reprodep="300"></Graphic>
</Figure>
<!-- DEC-file name .P! pictures/rpc-binding.ps 3.0i-->
<?sml-space .5>
<Para>Binding information includes the following components:
</Para>
<ItemizedList>
<ListItem>
<!-- .gL "protocol sequence"-->
<IndexTerm Id="DCEADG.RPCFUN.indx.16">
<Primary>protocol</Primary>
<Secondary>sequence</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCFUN.indx.17">
<Primary>RPC</Primary>
<Secondary>protocol</Secondary>
<Tertiary>sequence</Tertiary>
</IndexTerm>
<Para>Protocol sequence
</Para>
<Para>A valid combination of communications protocols
presented by the runtime as a character string. 
Each protocol sequence includes 
a network protocol, a transport protocol, and an RPC protocol that works with
them. 
</Para>
<Para>An RPC server tells the runtime which protocol sequences to use
when listening for calls to the server,
and its binding information contains those protocol sequences.
</Para>
</ListItem>
<ListItem>
<IndexTerm Id="DCEADG.RPCFUN.indx.18">
<Primary>network</Primary>
<Secondary>addressing information</Secondary>
</IndexTerm>
<Para>Network addressing information
</Para>
<Para>Includes the network address and the endpoint of a server.
</Para>
<ItemizedList>
<ListItem>
<!-- .gL "network address"-->
<IndexTerm Id="DCEADG.RPCFUN.indx.19">
<Primary>network</Primary>
<Secondary>address</Secondary>
</IndexTerm>
<Para>The network address identifies a specific host system on a network.
The format of the address depends on the network protocol 
portion of the protocol sequence. 
</Para>
</ListItem>
<ListItem>
<IndexTerm Id="DCEADG.RPCFUN.indx.20">
<Primary>endpoint</Primary>
<Secondary>role of within server address</Secondary>
</IndexTerm>
<Para>The endpoint acts as the address of a specific server instance within the
host system.  The format of the endpoint depends on the transport protocol
portion of the protocol sequence.  For each protocol sequence a server instance
uses, it requires a unique endpoint. 
A given endpoint can be used by only one server per system, 
assigned by the local system on a first-come, first-served basis. 
</Para>
</ListItem>
</ItemizedList>
</ListItem>
<ListItem>
<Para>Transfer Syntax
</Para>
<Para>The server's RPC runtime 
must use a transfer syntax that matches one used by
the client's RPC runtime.
<IndexTerm Id="DCEADG.RPCFUN.indx.21">
<Primary>transfer syntax</Primary>
</IndexTerm>A transfer syntax is a set of encoding rules used for the network
transmission of data and the conversion to and from different local data
representations.  A shared transfer syntax enables communications between
systems that represent local data differently. 
DCE RPC currently uses a single transfer syntax, 
Network Data Representation (NDR). 
<IndexTerm Id="DCEADG.RPCFUN.indx.22">
<Primary>Network Data Representation</Primary>
<See>NDR</See>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCFUN.indx.23">
<Primary>NDR</Primary>
</IndexTerm>NDR encodes data into a byte stream for transmission over a network. 
A transfer syntax such as NDR enables machines with different formats to
exchange data successfully.  
(The DCE RPC communications protocols support the negotiation of
transfer syntax.  However, at present, the outcome of a
transfer-syntax negotiation is always NDR.)
</Para>
</ListItem>
<ListItem>
<Para>RPC protocol version numbers
</Para>
<Para>The client and server 
runtimes must use compatible versions of the RPC protocol
specified by the client in the protocol sequence.  The major version number of
the RPC protocol used by the server must equal the specified major version
number.  The minor version number of the RPC protocol used by the server must be
greater than or equal to the specified minor version number. 
<IndexTerm Id="DCEADG.RPCFUN.indx.24">
<Primary>minor version number</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCFUN.indx.25">
<Primary>major version number</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCFUN.indx.26">
<Primary>version numbers</Primary>
</IndexTerm>
<!-- .iX "RPC protocol" "minor version number" -->
<!-- .iX "RPC protocol" "major version number" -->
<IndexTerm Id="DCEADG.RPCFUN.indx.27">
<Primary>RPC</Primary>
<Secondary>protocol</Secondary>
<Tertiary>version numbers</Tertiary>
</IndexTerm></Para>
</ListItem>
</ItemizedList>
<Sect2 Id="DCEADG.RPCFUN.div.5">
<Title>Server Binding Information</Title>
<Para>Binding information for a server is known as 
<!-- .gL "server binding information"-->
<IndexTerm Id="DCEADG.RPCFUN.indx.28">
<Primary>server</Primary>
<Secondary>binding information</Secondary>
</IndexTerm><FirstTerm>server binding information</FirstTerm>.
A binding handle that refers to server binding information is known as a 
<!-- .gL "server binding handle"-->
<IndexTerm Id="DCEADG.RPCFUN.indx.29">
<Primary>server</Primary>
<Secondary>binding handle</Secondary>
</IndexTerm><FirstTerm>server binding handle</FirstTerm>.  The use of server binding handles
differs on servers and clients.
</Para>
<Sect3 Id="DCEADG.RPCFUN.div.6">
<Title>Server Binding On a Server</Title>
<Para>Servers use a list of server binding handles.  Each represents one way to
establish a binding with the server.  Before exporting 
binding information to a namespace, a server
tells the RPC runtime which RPC protocol sequences to use for the RPC
interfaces the server supports.  For each protocol sequence, the server runtime
creates one or more server binding handles. 
Each server binding handle refers to binding information for a single potential
binding, including a protocol sequence, a network (host) address, an endpoint
(server address), a transfer syntax, and an RPC protocol 
version number. 
</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCFUN.div.7">
<Title>Server Binding On a Client</Title>
<Para>A client uses a single
server binding handle that refers to the server binding information 
the client needs for making one or more remote procedure calls to a 
given server.
Server binding information on a client contains
binding information for one potential binding. 
</Para>
<Para>On a client, server binding information always
includes a protocol sequence and the network address of the server's host
system.  However,
sometimes a client obtains binding information that lacks an endpoint,
resulting in a partially bound binding handle.
<!-- .gL "partially bound binding handle"-->
<IndexTerm Id="DCEADG.RPCFUN.indx.30">
<Primary>partially bound binding handle</Primary>
</IndexTerm>A partially bound binding handle corresponds to a system, but not to a
particular server instance.  When a client makes a remote procedure call
using a partially bound binding handle, the client runtime gets an endpoint
either from the interface specification (if one a well-known endpoint
is specified) 
or from the endpoint map on the server's system. 
Bindings almost never use well-known endpoints.
Adding the endpoint to the server binding information results
in a 
<!-- .gL "fully bound binding handle"-->
<IndexTerm Id="DCEADG.RPCFUN.indx.31">
<Primary>fully bound binding handle</Primary>
</IndexTerm>fully bound binding handle, which 
contains an endpoint and corresponds to a specific server instance.
Note clients can get a partially bound handle even if a server is not running.
</Para>
</Sect3>
</Sect2>
<Sect2 Id="DCEADG.RPCFUN.div.8">
<Title>Defining a Compatible Server</Title>
<IndexTerm Id="DCEADG.RPCFUN.indx.32">
<Primary>compatible</Primary>
<Secondary>binding information</Secondary>
<Tertiary>RPC</Tertiary>
</IndexTerm>
<Para>Compatible binding information identifies a server whose communications
capabilities (RPC protocol and protocol version, 
network and transport protocols, and transfer syntax) are compatible with those
of the client.  Compatible binding information is sufficient for establishing a
binding.  However, binding information is insufficient for ensuring that the
binding is to a compatible server.
</Para>
<Para>The additional information required that a client imposes on the RPC runtime
includes an RPC interface identifier and an object UUID, as follows:
</Para>
<ItemizedList>
<ListItem>
<Para>Interface identifier
</Para>
<Para>The interface UUID and version numbers of an RPC interface:
</Para>
<ItemizedList>
<ListItem>
<Para>Interface UUID:
<IndexTerm Id="DCEADG.RPCFUN.indx.33">
<Primary>RPC</Primary>
<Secondary>interface</Secondary>
<Tertiary>UUID</Tertiary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCFUN.indx.34">
<Primary>interface</Primary>
<Secondary>UUID</Secondary>
<Tertiary>RPC use of</Tertiary>
</IndexTerm>The interface UUID, unlike the interface name,  clearly identifies the
RPC interface across time and space. 
</Para>
</ListItem>
<ListItem>
<Para>Interface version number:
The combined major and minor
version numbers identify one generation of an interface. 
</Para>
<Para><IndexTerm Id="DCEADG.RPCFUN.indx.35">
<Primary>minor version number</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCFUN.indx.36">
<Primary>major version number</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCFUN.indx.37">
<Primary>version numbers</Primary>
</IndexTerm>
<!-- .iX "RPC interface" "minor version number" -->
<!-- .iX "RPC interface" "major version number" -->
<IndexTerm Id="DCEADG.RPCFUN.indx.38">
<Primary>RPC</Primary>
<Secondary>interface</Secondary>
<Tertiary>version numbers</Tertiary>
</IndexTerm>Version numbers allow multiple versions of an RPC interface to
coexist.  Strict rules govern valid changes to an interface and
determine whether different versions of an interface are compatible.
For a description of these rules, see Chapter 18 on IDL syntax
and usage. 
</Para>
<Para>The runtime uses the version number of an RPC interface to decide whether the
version offered by a given server is compatible with the version requested by a
client.  The offered and requested interface are compatible under the following
conditions: 
</Para>
<ItemizedList>
<ListItem>
<Para>The interface requested by the client and the interface offered by the server
have the same major version number.
</Para>
</ListItem>
<ListItem>
<Para>The interface requested by the client has a minor version number less than or
equal to that of the interface offered by the server.
</Para>
</ListItem>
</ItemizedList>
<!-- .ML (bulleted) list-->
</ListItem>
</ItemizedList>
</ListItem>
<ListItem>
<?sml-need 10>
<Para>Object UUID
</Para>
<Para>A UUID that identifies a particular object.
</Para>
<Para>An object is a distinct computing resource,
<!-- .gL "object"-->
<IndexTerm Id="DCEADG.RPCFUN.indx.39">
<Primary>object</Primary>
<Secondary>RPC</Secondary>
<Tertiary>use of</Tertiary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCFUN.indx.40">
<Primary>RPC</Primary>
<Secondary>object</Secondary>
</IndexTerm>such as a particular database, a specific RPC service that a remote 
procedure can access, and so on; for example, personal calendars may 
be RPC objects to a calendar service.  Accessing an object
requires including its object UUID with the binding information used for
establishing a binding.  A client can request a specific RPC object when
requesting new binding information, or the client can ask the runtime to
associate an object UUID with binding information the client already has
available. 
</Para>
<Para><IndexTerm Id="DCEADG.RPCFUN.indx.41">
<Primary>nil UUID</Primary>
<Secondary>RPC</Secondary>
</IndexTerm>Sometimes the object UUID is the nil UUID;
when calling an RPC runtime routine, 
you can represent the nil UUID by specifying NULL. 
In this case, the object UUID does not represent any object. 
Often, however, the object UUID represents a specific RPC object and
is a non-nil value. 
To create a non-nil object UUID, a server calls the 
<Function>uuid_create()</Function> routine,
which returns a UUID that the server then associates with a
particular object.
</Para>
<Para>If a client requests a non-nil object UUID, the client runtime
uses that UUID as one of the criteria for a compatible server.
When searching the namespace for server binding
information, the client runtime looks for the requested 
interface identifier and object UUID.
The endpoint map service uses this same information
to help find a compatible server.
</Para>
</ListItem>
</ItemizedList>
<Para>Figure 12-2 illustrates the aspects of a server and
its system that are identified by the client's server binding information,
requested interface identifier, and requested object UUID.
</Para>
<Figure>
<Title>Information Used to Identify a Compatible Server</Title>
<Graphic Entityref="DCEADG.RPCFUN.ent.2" Scalefit="1" Reprowid="300" Reprodep="300"></Graphic>
</Figure>
<!-- DEC-file name .P! pictures/rpc-binding-compat-info.ps 3.0i-->
</Sect2>
<Sect2 Id="DCEADG.RPCFUN.div.9">
<Title>How Clients Obtain Server Binding Information</Title>
<Para>When a client initiates a series of related remote procedure calls, the RPC
runtime tries to establish a binding, which requires the address of a
compatible server.
An RPC client can use compatible binding information obtained from either a
namespace or from a string representation of the binding
information.  Using the namespace is the most common approach. 
</Para>
<Para>Establishing a binding also involves requesting an endpoint from
the endpoint mapper of the server's system. 
</Para>
<Sect3 Id="DCEADG.RPCFUN.div.10">
<Title>Binding Information in a Namespace</Title>
<Para>Usually, a server exports binding information for one or more of its
interface identifiers and its object UUIDs, if any, to an 
entry in a namespace.  The namespace is provided by a directory service such
as the DCE Cell Directory Service (CDS).  The namespace entry to which a
server exports binding information is known as a <FirstTerm>server entry</FirstTerm>. 
</Para>
<Para>To learn about a server that offers a given RPC interface 
and object, if any, a client
can import binding information from a server entry belonging to that server. 
A client can delegate the finding of servers from the namespace to a stub. 
In this case, if a binding is accidentally broken, the RPC runtime
automatically tries to establish a new binding with a compatible server.
</Para>
<Para>Advantages of using a directory service to obtain binding information
include the following:
</Para>
<ItemizedList>
<ListItem>
<Para>It is convenient for large RPC environments.  Initial overhead of
understanding and configuring a directory service is balanced by easier
management over time.
</Para>
</ListItem>
<ListItem>
<Para>Management of data in a directory service is more automated.
</Para>
</ListItem>
<ListItem>
<Para>It is effective in dynamic end-user environments.
</Para>
</ListItem>
<ListItem>
<Para>Binding information is stored in a named server entry.  Data can be
dynamic.  Servers can automatically place their binding information in
the namespace.  Changes in binding information are made once by a
server or administrator and then propagated automatically by the directory
service to the replicas of the data.
</Para>
</ListItem>
<ListItem>
<Para>There is centralized administration of data in a namespace.  Sophisticated
access control is possible.
</Para>
</ListItem>
<ListItem>
<Para>It supports searching for and choosing services based on an interface
identifier and object UUID.  Clients access data by specifying an
entry name.  Groups and profiles in directory service entries provide
search paths for importing binding information.
</Para>
</ListItem>
</ItemizedList>
</Sect3>
<Sect3 Id="DCEADG.RPCFUN.div.11">
<Title>Binding Information in Strings</Title>
<Para>Occasionally, a client can receive binding information in the form of a string
(also known as a 
<IndexTerm Id="DCEADG.RPCFUN.indx.42">
<Primary>string</Primary>
<Secondary>bindings</Secondary>
</IndexTerm><FirstTerm>string binding</FirstTerm>).
The client can receive a string binding (or the information to compose a string
binding) from many sources; for example, an application-specific
environment variable, a file, or the application user.  
The client must call the RPC runtime to convert a string binding to a
binding handle. 
The runtime returns this binding handle to the client to use for
remote procedure calls.  
</Para>
<Para>String representations of binding information have several possible components.
The binding information includes an RPC protocol sequence, a network
address, and an endpoint.  The protocol sequence is mandatory; the endpoint is
optional; and for a server on the client's system, the network address is
optional.  Also, a string binding optionally associates an object UUID with
the binding information. 
</Para>
<Para>The string bindings have the following format:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><?sml-point-size 11><Symbol Role="Variable">obj-uuid</Symbol><Literal>@</Literal><Symbol Role="Variable">rpc-protocol-seq</Symbol><Literal>:</Literal><Symbol Role="Variable">network-addr</Symbol><Literal>[</Literal><Symbol Role="Variable">endpoint</Symbol><Literal>,</Literal><Symbol Role="Variable">option-name</Symbol><Literal>=</Literal><Symbol Role="Variable">opt-value</Symbol>...<Literal>]</Literal>
<?sml-point-size 12></UserInput></ProgramListing></Para>
</InformalExample>
<Para>or
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><?sml-point-size 11><Symbol Role="Variable">obj-uuid</Symbol><Literal>@</Literal><Symbol Role="Variable">rpc-protocol-seq</Symbol><Literal>:</Literal><Symbol Role="Variable">network-addr</Symbol><Literal>[</Literal><Literal>endpoint=</Literal><Symbol Role="Variable">endpoint</Symbol><Literal>,</Literal><Symbol Role="Variable">option-name</Symbol><Literal>=</Literal><Symbol Role="Variable">opt-value</Symbol>...<Literal>]</Literal>
<?sml-point-size 12></UserInput></ProgramListing></Para>
</InformalExample>
<Para>The following example string binding contains all possible components:
</Para>
<InformalExample>
<Para><ProgramListing role="page-wide"><?sml-point-size 10>b07122e2-83df-11c9-be29-08002b1110fa@ncacn_ip_tcp:130.105.1.1.123[2001]
<?sml-point-size 12></ProgramListing></Para>
</InformalExample>
<Para><?sml-need 5>The following example string binding contains only the protocol 
sequence and network address:
</Para>
<InformalExample>
<Para><ProgramListing>ncacn_ip_tcp:130.105.1.1.123
</ProgramListing></Para>
</InformalExample>
<Para>For more information about the string binding format, 
see the RPC introduction reference
page, <Filename MoreInfo="RefEntry">rpc_intro(3rpc)</Filename>.
</Para>
<Para><IndexTerm Id="DCEADG.RPCFUN.indx.43">
<Primary>directory service</Primary>
<Secondary>when to use</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCFUN.indx.44">
<Primary>string</Primary>
<Secondary>bindings</Secondary>
</IndexTerm>String bindings are useful in small environments; for example,
when developing and testing an application. 
However, string bindings are inappropriate as the principal way of
providing binding information to clients. 
Applications should use the directory service to advertise binding information. 
</Para>
</Sect3>
</Sect2>
<Sect2 Id="DCEADG.RPCFUN.div.12">
<Title>Client Binding Information for Servers</Title>
<Para>When making a remote procedure call, the client runtime provides information
about the client to the server runtime.  This information, known as 
<IndexTerm Id="DCEADG.RPCFUN.indx.45">
<Primary>client</Primary>
<Secondary>binding information</Secondary>
<Tertiary>RPC</Tertiary>
</IndexTerm><FirstTerm>client binding information</FirstTerm>, includes the following information:
</Para>
<ItemizedList>
<ListItem>
<Para>The address where the call originated (network address and endpoint)
</Para>
</ListItem>
<ListItem>
<Para>The RPC protocol used by the client for the call
</Para>
</ListItem>
<ListItem>
<Para>The object UUID that a client requests
</Para>
</ListItem>
<ListItem>
<Para>The client authentication information (if present) 
</Para>
</ListItem>
</ItemizedList>
<Para>The server runtime maintains the client binding information and makes it
available to the server application by a 
<!-- .gL "client binding handle"-->
<IndexTerm Id="DCEADG.RPCFUN.indx.46">
<Primary>client</Primary>
<Secondary>binding handle</Secondary>
<Tertiary>RPC</Tertiary>
</IndexTerm>client binding handle.
Figure 12-3 illustrates the relationships between
what a client supplies when establishing a binding and the corresponding
client binding information.
<!-- -->
</Para>
<?sml-need 4i>
<Figure>
<Title>Client Binding Information Resulting from a Remote Procedure Call</Title>
<Graphic Entityref="DCEADG.RPCFUN.ent.3" Scalefit="1" Reprowid="300" Reprodep="300"></Graphic>
</Figure>
<!-- DEC-file name .P! pictures/rpc-client-binding-info.ps 4.0i-->
<?sml-space .5>
<Para>The callouts in the figure refer to the following:
</Para>
<OrderedList>
<ListItem>
<Para>The requested object UUID, which may be the nil UUID
</Para>
</ListItem>
<ListItem>
<Para>Client authentication information, which is optional
</Para>
</ListItem>
<ListItem>
<Para>The address from which the client is making the remote procedure call,
which the communications protocols supply to the server
</Para>
</ListItem>
</OrderedList>
<!-- .AL (numbered) list-->
<Para>A server application can use the client binding handle to
ask the RPC runtime about the object UUID requested by a client or
about the client's authentication information.
</Para>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.RPCFUN.div.13">
<Title>Endpoints</Title>
<Para>An endpoint is the address of a specific server instance on a host system.
Two kinds of endpoints exist: well-known endpoints and dynamic endpoints. 
</Para>
<Sect2 Id="DCEADG.RPCFUN.div.14">
<Title>Well-Known Endpoints</Title>
<Para>A
<!-- .gL "well-known endpoint"-->
<IndexTerm Id="DCEADG.RPCFUN.indx.47">
<Primary>well-known endpoint</Primary>
</IndexTerm>well-known endpoint is a preassigned stable address that a server 
uses every time it runs.  Well-known endpoints typically are assigned by a
central authority responsible for a transport protocol; for example, the
Internet Assigned Numbers Authority assigns endpoint values for the IP family of
protocols.  If you use well-known endpoints for a server, you should register
them with the appropriate authority. 
</Para>
<Para>Well-known endpoints can be declared for an interface (in the interface
declaration) or for a server instance, as follows:
</Para>
<ItemizedList>
<ListItem>
<Para>Any interface definition can be associated with one or more endpoints,
along with the RPC protocol sequence corresponding to each endpoint
(the <Literal>endpoint</Literal> attribute).
</Para>
<Para>When compiling an interface, the IDL compiler stores each combination of
endpoint and protocol sequence in the interface specification.
If a call is made using binding information that lacks an
endpoint, the RPC runtime automatically looks in the interface specification
for a well-known endpoint specified for the protocol sequence obtained from the
binding information.  If the interface specification contains an appropriate
endpoint, the runtime adds it to the binding information. 
</Para>
</ListItem>
<ListItem>
<Para>Alternatively, server-specific, well-known endpoints can be defined in server
application code.  When asking the runtime to use a given protocol sequence, the
server supplies the corresponding endpoints to the RPC runtime. 
On a given system, each endpoint can be used by only one server at a time.
If server application code contains a hardcoded endpoint or the server's
installers always specify the same well-known endpoint, only one instance of
the server can run per system. 
</Para>
</ListItem>
</ItemizedList>
<Para>When a server exports its binding information to a namespace server
entry, the export
operation includes any well-known endpoints within the server 
binding information stored in the server entry. 
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCFUN.div.15">
<Title>Dynamic Endpoints</Title>
<Para>A 
<!-- .gL "dynamic endpoint"-->
<IndexTerm Id="DCEADG.RPCFUN.indx.48">
<Primary>dynamic endpoint</Primary>
</IndexTerm>dynamic endpoint is requested and assigned at runtime. 
For some transport protocols, the number of endpoints is limited;
for example, TCP/IP and UDP/IP use a 16-bit number for endpoints,
which allows 65,535 endpoints. 
When the supply of endpoints for a transport protocol is limited, 
the protocol ensures an adequate supply of endpoints by limiting the
portion that can be reserved as well-known endpoints.  
A transport, on request, dynamically makes its remaining endpoints
available on a first-come, first-served basis to specific processes
such as RPC server instances. 
</Para>
<Para>When a server requests dynamic endpoints, the server's RPC runtime asks
the operating system for a unique dynamic endpoint for each protocol sequence
the server is using.  For a given protocol sequence, the local implementation
of the corresponding transport protocol provides the requested endpoints.  When
an RPC server with dynamic endpoints stops listening, its dynamic endpoints are
released. 
</Para>
<Para>Because of the transient nature of dynamic endpoints, the NSI
of the RPC API does not export them to a namespace; 
however, NSI does export the rest of the server's binding information. 
References to expired endpoints would remain
indefinitely in server entries, causing clients to import and try,
unsuccessfully, to establish bindings to nonexistent endpoints. 
Therefore, 
the export operation removes dynamic endpoints before
adding binding information to a server entry; the exported server address
contains only network addressing information.  The import operation returns a
partially bound binding handle.  The client makes its first remote procedure
call with the partially bound handle, and the endpoint mapper service on the
server's system resolves the binding handle with the endpoint of a
compatible server.  
To make dynamic endpoints available to 
clients that are using partially bound binding handles, 
<!-- DCE 1.2 WRITER: check above two lines for correctness-->
a server must register its dynamic endpoints
in the local endpoint map. 
<!--.nS note-->
<!--Register all endpoints to enable administrators to view all the-->
<!--endpoints of RPC servers by showing the endpoint map elements.  To do this,-->
<!--use the \*Ldcecp endpoint show\*O operation of the DCE control program.-->
<!--.nE-->
</Para>
<Para>By using object UUIDs, a server can ensure that a client that imports a
partially bound handle obtains one of a particular
server's endpoints.  
This requires that the server do the following:
</Para>
<OrderedList>
<ListItem>
<Para>Specify a list of one or more object UUIDs that are unique to the server.
</Para>
</ListItem>
<ListItem>
<Para>Export the list of object UUIDs.
</Para>
</ListItem>
<ListItem>
<?sml-need 4>
<Para>Supply the list of object UUIDs to the endpoint map service when
registering endpoints.
</Para>
</ListItem>
<ListItem>
<Para>If the server provides different managers that implement an
interface for different types of objects, the server must specify
the type of each object.
</Para>
</ListItem>
</OrderedList>
<!-- .ML (bulleted) list-->
<Para>To request binding information for a particular server, a client specifies one
of the server's object UUIDs, which is then associated with the server binding
information the client uses for making a remote procedure call. 
</Para>
<Note>
<Para>If a client requests the nil object UUID when importing from
a server entry containing object UUIDs, the client runtime
selects one of those object UUIDs and associates it with the imported
server binding information.  This object UUID guarantees that the
call goes to the server that exported the binding information and
object UUID to the server entry.
</Para>
</Note>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.RPCFUN.div.16">
<Title>Execution Semantics</Title>
<Para>Execution semantics
<IndexTerm Id="DCEADG.RPCFUN.indx.49">
<Primary>execution semantics</Primary>
</IndexTerm>identify the ability of a procedure to execute more than once during a given
remote procedure call.  
The communications environment that underlies remote procedure calls
affects their reliability.  A communications link can break for a
variety of reasons such as a server termination, a remote system 
crash, a network failure, and so forth; all invocations of remote
procedures risk disruption due to communications failures.  However,
some procedures are more sensitive to such failures, and their impact depends
partly on how reinvoking an operation affects its results. 
</Para>
<Para>To maximize valid outcomes for its operations, 
the operation declarations of an RPC interface definition indicate the effect
of multiple invocations on the outcome of the operations. 
</Para>
<Para>Table 12-1 summarizes the execution semantics for DCE RPC calls. 
</Para>
<?sml-need 5i >

<Table Frame="all" Remap="center" Orient="Port" role="page-wide">
<Title>Execution Semantics for DCE RPC Calls</Title>
<TGroup Rowsep="1" Colsep="1" Cols="3">
<ColSpec Colsep="1" Align="Left" Colwidth="1*" Colname="col1" Colnum="1">
<ColSpec Align="Left" Colwidth="1*" Colname="col2" Colnum="2">
<ColSpec Align="Left" Colwidth="2*" Colname="col3" Colnum="3">
<spanspec nameend="col3" namest="col2" spanname="2to3">
<thead>
<Row>
<Entry Rowsep="1"><Literal>Semantics</Literal></Entry>
<Entry Rowsep="1" Spanname="2to3"><Literal>Meaning</Literal></Entry>
</Row>
</thead>
<tbody>
<Row>
<Entry Rowsep="1"><Literal>at-most-once</Literal></Entry>
<Entry Rowsep="1" Spanname="2to3">
<!-- .gL "at-most-once semantics" -->
<IndexTerm Id="DCEADG.RPCFUN.indx.50">
<Primary>at-most-once semantics</Primary>
</IndexTerm>The operation must execute either once, partially, or not at all; for
example, adding or deleting an appointment from a calendar can
use <Literal>at-most-once</Literal> semantics.  This is
the default execution semantics for remote procedure calls.
</Entry>
</Row>
<Row>
<Entry Rowsep="0"><Literal>idempotent</Literal></Entry>
<Entry Rowsep="1" Spanname="2to3">
<!-- .gL "idempotent semantics" -->
<IndexTerm Id="DCEADG.RPCFUN.indx.51">
<Primary>idempotent semantics</Primary>
</IndexTerm>The operation can execute more than once; executing more than once using the
same input arguments produces identical outcomes without undesirable side
effects; for example, an operation that reads a block of an immutable file is
<Literal>idempotent</Literal>. 
DCE RPC supports <Literal>maybe</Literal> semantics and <Literal>broadcast</Literal> semantics
as special forms of <Literal>idempotent</Literal> operations.
</Entry>
</Row>
<Row>
<Entry Rowsep="0"></Entry>
<Entry Rowsep="1"><Literal>Semantics</Literal></Entry>
<Entry Rowsep="1"><Literal>Meaning</Literal>
</Entry>
</Row>
<Row>
<Entry Rowsep="0"></Entry>
<Entry Rowsep="1"><Literal>maybe</Literal></Entry>
<Entry Rowsep="1">
<!-- .gL "maybe semantics" -->
<IndexTerm Id="DCEADG.RPCFUN.indx.52">
<Primary>maybe semantics</Primary>
</IndexTerm>The caller neither requires nor receives any response or fault indication for
an operation, even though there is no guarantee that the operation completed.
An operation with <Literal>maybe</Literal> semantics 
is implicitly idempotent and must lack output parameters. 
</Entry>
</Row>
<Row>
<Entry Rowsep="0"></Entry>
<Entry><Literal>broadcast</Literal></Entry>
<Entry>
<!-- .gL "broadcast semantics" -->
<IndexTerm Id="DCEADG.RPCFUN.indx.53">
<Primary>broadcast semantics</Primary>
</IndexTerm>The operation is always broadcast to one server on each host system
on the local network, rather than delivered to a specific server, and
one reply is returned to the client.
An operation with <Literal>broadcast</Literal>
semantics is implicitly <Literal>idempotent</Literal>. 
</Entry>
</Row>
</TBody>
</TGroup>
</Table>
<?sml-indent +.5i>
<?sml-indent -.5i>
<?sml-space .5>
<Para><?sml-need 6>The broadcast capabilities of RPC runtime have a number 
of distinct limitations:
</Para>
<ItemizedList>
<ListItem>
<Para>Not all systems and networks support broadcasting.  In particular,
broadcasting is not supported by the RPC connection-oriented
protocol.
</Para>
</ListItem>
<ListItem>
<Para>Broadcasts are limited to hosts on the local network.
</Para>
</ListItem>
<ListItem>
<Para>Broadcasts make inefficient use of network bandwidth and processor
cycles.  
</Para>
</ListItem>
<ListItem>
<Para>The RPC runtime library does not support <Literal>at-most-once</Literal> semantics
for broadcast operations; it applies <Literal>idempotent</Literal> semantics
to all such operations.
</Para>
</ListItem>
<ListItem>
<Para>The input arguments for broadcast calls are limited to
944 bytes.
</Para>
</ListItem>
</ItemizedList>
</Sect1>
<Sect1 Id="DCEADG.RPCFUN.div.17">
<Title>Communications Failures</Title>
<IndexTerm Id="DCEADG.RPCFUN.indx.54">
<Primary>cancels</Primary>
<Secondary>RPC</Secondary>
<Tertiary>use of</Tertiary>
</IndexTerm>
<Para>If a server detects a communications failure during a remote
procedure call, the server runtime attempts to terminate the now
orphaned call by sending a cancel to the called procedure. 
A <Symbol Role="Variable">cancel</Symbol> is a mechanism by which a client thread of execution
notifies a server thread of execution
(the to be canceled thread) to terminate as soon as possible. 
A cancel sent by the RPC runtime after a communications
failure initiates orderly termination for a remote procedure call.
<!-- WRITER'S NOTE:  threads concepts still not introduced, so I'm-->
<!-- making a nebulous statement about such cancels.-->
(For a brief discussion of how cancels work with
remote procedure calls, see the discussions with respect to Threads.)
</Para>
<Para>Applications that use context handles to establish a client context require a
context rundown procedure to 
<!-- .gL "context rundown procedure"-->
<IndexTerm Id="DCEADG.RPCFUN.indx.55">
<Primary>context rundown procedure</Primary>
</IndexTerm>enable the server to clean up client context when it is no longer needed. 
The name of the context rundown procedure is determined from the type
name of the context handle declared in the interface definition; 
this ensures that the stub knows about the procedure in
the server application code. 
If a
communications link with a client is lost while a server is maintaining context
for the client, the RPC runtime will inform the server to invoke the context
rundown procedure.  
For a more thorough discussion of context handles see Chapter 17.
</Para>
</Sect1>
<Sect1 Id="DCEADG.RPCFUN.div.18">
<Title>Scaling Applications</Title>
<!--Future Writers: this seems like it should be in the Style Guide somewhere.-->
<!---->
<Para>Unlike local applications, RPC applications require network resources, 
which are possible bottlenecks to scaling an RPC application.
RPC clients and servers require network resources that are not required by
local programs.  The main network resources to consider are
network bandwidth, endpoints, 
<!-- .gL "network descriptor"-->
<IndexTerm Id="DCEADG.RPCFUN.indx.56">
<Primary>network</Primary>
<Secondary>descriptor</Secondary>
</IndexTerm>network descriptors (the identifiers of potential network channels such
as UNIX sockets), kernel buffers and, for a connection-oriented transport,
the connections.  Also, RPC applications place extra demands on system resources
such as memory buffers, various quotas, and the CPU. 
</Para>
<Para>The number of remote procedure calls that a server can support depends
on various factors, such as the following:
</Para>
<ItemizedList>
<ListItem>
<Para>The resources of the server and the network
</Para>
</ListItem>
<ListItem>
<Para>The requirements of each call
</Para>
</ListItem>
<ListItem>
<Para>The number of calls that can be concurrently offered at some level of
service
</Para>
</ListItem>
<ListItem>
<Para>The performance requirements
</Para>
</ListItem>
</ItemizedList>
<Para>An accurate analysis of the requirements of a given server involves detailed
work load and resource characterization and modeling techniques.  Although
measurement of live configurations under load will offer the best information,
general guidelines apply.  You should consider the connection, buffering,
bandwidth, and CPU resources as the most likely RPC bottlenecks to scaling. 
Use these application requirements to scale resources. 
</Para>
<Para>Many system implementations limit the number of network connections per
process.  This limit provides an upper bound on the number of clients that can
be served concurrently using the connection-oriented protocol.  Some
UNIX based systems set this limit at 64.  However, except for applications
that use context handles, the connection-oriented RPC runtime allows pooling
of connections.  Pooling permits simultaneously supporting more clients than the
maximum number of connections, provided they do not all make calls at the same
instant and occasionally can wait briefly. 
</Para>
</Sect1>
<Sect1 Id="DCEADG.RPCFUN.div.19">
<Title>RPC Objects</Title>
<Para>DCE RPC enables clients to find servers that offer specific RPC objects.
An
<!-- .gL "object"-->
<IndexTerm Id="DCEADG.RPCFUN.indx.57">
<Primary>object</Primary>
<Secondary>RPC</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCFUN.indx.58">
<Primary>RPC</Primary>
<Secondary>object</Secondary>
</IndexTerm>RPC object is an entity that an RPC server defines and identifies to
its clients.  Frequently, an RPC object is a distinct computing resource such as
a particular database, directory, device, process, or processor.  Identifying a
resource as an RPC object enables an application to ensure that clients can use
an RPC interface to operate on that resource.  An RPC object can also be an
abstraction that is meaningful to an application such as a service or the
location of a server. 
</Para>
<Para>RPC objects are defined by application code. 
The RPC runtime provides substantial flexibility to applications about whether,
when, and how they use RPC objects.  RPC applications generally use RPC objects
to enable clients to find and access a specific server.  When servers are
completely interchangeable, using RPC objects may be unnecessary.  However, when
clients need to distinguish between two servers that offer the same RPC
interface, RPC objects are essential.  If the servers offer distinct computing
resources, each server can identify itself by treating its resources as RPC
objects.  Alternatively, each server can establish itself as an RPC object that
is distinct from other instances of the same server.
</Para>
<Para>RPC objects also enable a single server to distinguish among alternative
implementations of an RPC interface, as long as each implementation 
<!-- fully supports the semantics of the RPC interface and-->
operates on a distinct type of object.  To offer multiple implementations of
an RPC interface, a server must identify RPC objects, classify them into types,
and associate each type with a specific implementation.
</Para>
<Para>The set of remote procedures that implements an RPC interface for a given type
of object is known as a 
<!-- .gL "manager"-->
<IndexTerm Id="DCEADG.RPCFUN.indx.59">
<Primary>manager</Primary>
<Secondary>RPC</Secondary>
</IndexTerm><FirstTerm>manager</FirstTerm>.  The tasks performed by a 
manager depend on the type of object on which the
manager operates.  For example, one manager of a queue-management interface may
operate on print queues, while another manager may operate on batch queues. 
</Para>
</Sect1>
</Chapter>
<!--+ 11/27/96 19:53:47
    | tagMorph:  $Id: fundamentals.sgm,v 1.1.2.8 1996/12/14 20:24:25 wardr Exp $
    | tagMorph library:  $Id: fundamentals.sgm,v 1.1.2.8 1996/12/14 20:24:25 wardr Exp $
    | sml-to-docbook:  1.25
    +-->
