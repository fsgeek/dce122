<!--
# @OSF_COPYRIGHT@
# 
# 
# HISTORY
# $Log: idl.sgm,v $
# Revision 1.1.2.9  1996/12/15  17:23:36  wardr
# 	{edit,R1.2.2}
# 	Updated copyrights
# 	[1996/12/15  17:23:13  wardr]
#
# Revision 1.1.2.8  1996/12/14  20:24:27  wardr
# 	{edit,R1.2.2}
# 	penultimate format fixes
# 	[1996/12/14  20:22:25  wardr]
# 
# Revision 1.1.2.7  1996/12/13  22:11:11  wardr
# 	{edit,R1.2.2}
# 	Fixed formatting problems
# 	[1996/12/13  22:08:58  wardr]
# 
# Revision 1.1.2.6  1996/12/12  21:30:48  wardr
# 	{edit,R1.2.2}
# 	Fixed formatting problems
# 	[1996/12/12  21:28:56  wardr]
# 
# Revision 1.1.2.5  1996/12/12  16:49:48  carrig
# 	{enh,R1.2.2}
# 	Minor edits
# 	[1996/12/12  16:47:36  carrig]
# 
# Revision 1.1.2.4  1996/12/06  21:10:26  carrig
# 	{enh,R1.2.2}
# 	Second pass for editor
# 	[1996/12/06  21:08:24  carrig]
# 
# Revision 1.1.2.3  1996/12/05  21:39:16  carrig
# 	{enh,R1.2.2}
# 	First pass to prepare for editing
# 	[1996/12/05  21:37:27  carrig]
# 
# Revision 1.1.2.2  1996/12/02  15:41:24  weir
# 	Removed thinsp entities, corrected other minor errors
# 	[1996/12/02  15:39:37  weir]
# 
# Revision 1.1.2.1  1996/12/01  20:43:53  weir
# 	Initial submission
# 	[1996/12/01  20:41:54  weir]
# 
# $EndLog$
-->
<!-- Fragment document type declaration subset:
ArborText, Inc., 1988-1993, v.4001
<!DOCTYPE Book PUBLIC "-//Davenport//DTD DocBook V2.4//EN" [
]>
-->
<!-- COPYRIGHT NOTICE-->
<!-- Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.-->
<!-- ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for-->
<!-- the full copyright text.-->
<!-- -->
<!-- -->
<!-- OLD HISTORY-->
<!-- Revision 1.1.7.4  1996/09/17  18:59:07  wardr-->
<!-- 	{def,CR13428,R1.2.2}-->
<!-- 	idl info missing from guide-->
<!-- 	[1996/09/17  18:57:50  wardr]-->
<!---->
<!-- Revision 1.1.7.3  1996/09/06  13:08:13  wardr-->
<!-- 	{def,13469, R1.2.2}-->
<!-- 	document limit on linked-list marshalling-->
<!-- 	[1996/09/06  13:07:39  wardr]-->
<!-- -->
<!-- Revision 1.1.7.2  1996/08/16  17:27:04  sherman-->
<!-- 	{def,13428,R1.2.2}-->
<!-- 	Remove align attribute-->
<!-- 	[1996/08/16  17:26:34  sherman]-->
<!-- -->
<!-- Revision 1.1.7.1  1996/05/10  21:27:38  wardr-->
<!-- 	{enh,R1.2.2}-->
<!-- 	Removed Changebars-->
<!-- 	[1996/05/10  21:27:08  wardr]-->
<!-- -->
<!-- Revision 1.1.5.5  1996/03/27  13:07:17  wardr-->
<!-- 	{edit R1.2.1}-->
<!-- 	More Release Edits-->
<!-- 	[1996/03/27  13:06:49  wardr]-->
<!-- -->
<!-- Revision 1.1.5.4  1996/03/07  20:12:20  weir-->
<!-- 	Commented out several iX entries- they cause AIX build errors-->
<!-- 	[1996/03/07  20:11:31  weir]-->
<!-- -->
<!-- Revision 1.1.5.3  1995/11/10  18:50:18  wardr-->
<!-- 	{enh CR13032 R1.2.1} Final touchup and indexing.-->
<!-- 	[1995/11/10  18:49:19  wardr]-->
<!-- -->
<!-- Revision 1.1.5.2  1995/11/02  01:05:59  wardr-->
<!-- 	{enh CR13032 R1.2.1} Do final edits-->
<!-- 	[1995/11/02  01:05:34  wardr]-->
<!-- -->
<!-- Revision 1.1.5.1  1995/09/15  21:49:43  wardr-->
<!-- 	{enh, 13032, R1.1}-->
<!-- 	adding xidl information-->
<!-- 	[1995/09/15  21:48:25  wardr]-->
<!-- -->
<!-- Revision 1.1.2.11  1995/06/07  14:38:08  rcb-->
<!-- 	PRENTICE HALL reformat; final edits and changes-->
<!-- 	[1995/06/05  19:56:02  rcb]-->
<!-- -->
<!-- 	a couple of edits from DEC that I left out before-->
<!-- 	[1995/05/01  18:10:16  rcb]-->
<!-- -->
<!-- 	PRENTICE HALL reformat-->
<!-- 	[1995/04/27  16:01:06  rcb]-->
<!-- -->
<!-- 	incorporated 1.1 edits-->
<!-- 	[1995/04/26  15:44:09  rcb]-->
<!-- -->
<!-- Revision 1.1.2.10  1994/10/28  15:14:08  jshirley-->
<!-- 	Some final edits from Rico.-->
<!-- 	[1994/10/28  15:13:46  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.9  1994/10/27  19:42:56  jshirley-->
<!-- 	Final edits.-->
<!-- 	[1994/10/27  19:41:51  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.8  1994/10/12  21:53:11  jshirley-->
<!-- 	{def,10160,R1.1} Pipe documentation needs improvement.-->
<!-- 	    Moved some info. to a more complete pipes discussion.-->
<!-- 	[1994/10/12  21:52:09  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.7  1994/09/01  18:37:38  buckler-->
<!-- 	{enh, 8569, R1.1}-->
<!-- 	Added another caveat about input argument size limit.-->
<!-- 	[1994/09/01  18:37:14  buckler]-->
<!-- -->
<!-- Revision 1.1.2.6  1994/09/01  18:27:17  buckler-->
<!-- 	{enh, 8569, R1.1}-->
<!-- 	Added caveats about broadcasting.-->
<!-- 	[1994/09/01  18:26:47  buckler]-->
<!-- -->
<!-- Revision 1.1.2.5  1994/08/11  20:36:30  jhh-->
<!-- 	expand copyright-->
<!-- 	[1994/08/11  19:58:34  jhh]-->
<!-- -->
<!-- Revision 1.1.2.4  1994/07/19  21:02:36  zahn-->
<!-- 	{enh,11063,R1.1}-->
<!-- -->
<!-- 	Incorporated T. Jordahl's review comments on-->
<!-- 	the "opaque" context handle documentation.-->
<!-- 	[1994/07/19  21:02:16  zahn]-->
<!-- -->
<!-- Revision 1.1.2.3  1994/07/19  17:31:17  zahn-->
<!-- 	{enh,11063,R1.1}-->
<!-- -->
<!-- 	Added documentation for "opaque" context handles-->
<!-- 	to the description of "normal" context handles.-->
<!-- 	[1994/07/19  17:30:56  zahn]-->
<!-- -->
<!-- Revision 1.1.2.2  1994/07/18  20:24:33  zahn-->
<!-- 	{enh,10513,R1.1}-->
<!-- -->
<!-- 	Modified the section on Strings to describe-->
<!-- 	the integer-string types for 1.1.-->
<!-- -->
<!-- 	Also moved an example of the exceptions attribute here-->
<!-- 	from the file /app_gd/rpc/topics.gpsml (section on error-->
<!-- 	handling) and changed/corrected the syntax description.-->
<!-- 	[1994/07/18  20:24:11  zahn]-->
<!-- -->
<!-- Revision 1.1.2.1  1994/07/08  15:52:59  jshirley-->
<!-- 	{def,10526,R1.1}-->
<!-- 	Created new file for the RPC reorganization based on the old file-->
<!-- 	.../rpc/9_idl.gpsml.-->
<!-- 	[1994/07/08  15:52:32  jshirley]-->
<!-- -->
<!---->
<!---->
<Chapter Id="DCEADG.RPCIDL.div.1">
<Title>Interface Definition Language</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.1">
<Primary>interface</Primary>
<Secondary>definitions</Secondary>
</IndexTerm>
<Para>This chapter describes how to construct an Interface Definition Language 
(IDL) file.  First, it describes the IDL syntax notation conventions and 
lexical elements.  It then describes the interface definition structure 
and the individual language elements supported by the IDL compiler.
</Para>
<Sect1 Id="DCEADG.RPCIDL.div.2">
<Title>The Interface Definition Language File</Title>
<Para>The IDL file defines all aspects of an
interface that affect data passed over the network between a caller (client) 
and a callee (server).  An interface definition file has the suffix <Filename>.idl</Filename>.
In order for a caller and callee to interoperate, they
both need to incorporate the same interface definition.
</Para>
</Sect1>
<Sect1 Id="DCEADG.RPCIDL.div.3">
<Title>Syntax Notation Conventions</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.2">
<Primary>IDL</Primary>
<Secondary>syntax notation</Secondary>
</IndexTerm>
<Para>In addition to the documentation conventions described in the 
Preface of this guide, the IDL syntax uses the special notation
described in the following subsections.
</Para>
<Sect2 Id="DCEADG.RPCIDL.div.4">
<Title>Typography</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.3">
<Primary>IDL</Primary>
<Secondary>typography</Secondary>
</IndexTerm>
<Para>IDL documentation uses the following typefaces:
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>Bold</Literal></Term>
<ListItem>
<Para><Literal>Bold</Literal> typeface indicates a literal item.  Keywords and literal punctuation
are represented in bold typeface.  Identifiers used in a particular example
are represented in bold typeface when mentioned in the text.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">Italic</Symbol></Term>
<ListItem>
<Para><Symbol Role="Variable">Italic</Symbol> typeface indicates a symbolic item for which
you need to substitute a particular value.  In IDL syntax descriptions,
all identifiers that are not keywords are represented in italic typeface.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><ComputerOutput>Constant width</ComputerOutput></Term>
<ListItem>
<Para><ComputerOutput>Constant width</ComputerOutput> typeface is used for source code
examples (in IDL or in C) that are displayed separately from regular text.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.5">
<Title>Special Symbols</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.4">
<Primary>IDL</Primary>
<Secondary>special symbols</Secondary>
</IndexTerm>
<Para>IDL documentation uses the following symbolic notations:
</Para>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">[item]</Symbol></Term>
<ListItem>
<Para><Symbol Role="Variable">Italic</Symbol> brackets surrounding an item, which may include brackets in
regular typeface, indicate that the item contained within them is optional.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>[<Symbol Role="Variable">item</Symbol>]</Term>
<ListItem>
<Para>Brackets shown in regular typeface surrounding a variable <Symbol Role="Variable">item</Symbol>
indicate that the brackets are a required when the item is
included, whether or not the item itself is required.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">item</Symbol> ...</Term>
<ListItem>
<Para>Ellipsis points following an item indicate that
the item may occur one or more times.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">item</Symbol> <Literal>,</Literal> ...</Term>
<ListItem>
<?sml-need 4>
<Para>If an item&ensp; is followed by&ensp; a literal
punctuation&ensp; character&ensp; and then by ellipsis points, the item may occur
either once without the punctuation character or more than once
with the punctuation character separating each instance.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>...</Term>
<ListItem>
<Para>If ellipsis points are shown on a line by themselves, the item
or set of items in the preceding line may occur any number of additional
times.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">item</Symbol> | <Symbol Role="Variable">item</Symbol></Term>
<ListItem>
<Para>If several&ensp; items are shown separated
by vertical bars, exactly one of those items must occur.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.RPCIDL.div.6">
<Title>IDL Lexical Elements</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.5">
<Primary>IDL</Primary>
<Secondary>lexical elements</Secondary>
</IndexTerm>
<Para>The following subsections describe these IDL lexical elements:
</Para>
<ItemizedList>
<ListItem>
<Para>Identifiers
</Para>
</ListItem>
<ListItem>
<Para>Keywords
</Para>
</ListItem>
<ListItem>
<Para>Punctuation characters
</Para>
</ListItem>
<ListItem>
<Para>Whitespace
</Para>
</ListItem>
<ListItem>
<Para>Case sensitivity
</Para>
</ListItem>
</ItemizedList>
<Sect2 Id="DCEADG.RPCIDL.div.7">
<Title>Identifiers</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.6">
<Primary>IDL</Primary>
<Secondary>identifiers</Secondary>
</IndexTerm>
<Para>The character set for IDL identifiers comprises the alphabetic characters
A to Z and a to z, the digits 0 to 9, and the <Literal>_</Literal> (underscore) character. 
An identifier must start with an alphabetic character.
</Para>
<Para>No IDL identifier can exceed 31 characters.  In some cases, an identifier
has a shorter maximum length because the IDL compiler uses the identifier
as a base from which to construct other identifiers; we identify such
cases as they occur.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.8">
<Title>Keywords</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.7">
<Primary>IDL</Primary>
<Secondary>keywords</Secondary>
</IndexTerm>
<Para>IDL reserves some identifiers as keywords.  In the text of this chapter,
keywords are represented in <Literal>bold</Literal> typeface, 
and identifiers chosen by application
developers are represented in <Symbol Role="Variable">italic</Symbol> typeface.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.9">
<Title>Punctuation Characters</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.8">
<Primary>IDL</Primary>
<Secondary>punctuation characters</Secondary>
</IndexTerm>
<Para>IDL uses the following graphic characters:
</Para>
<InformalExample>
<Para><ProgramListing>"  '  (  )  *  ,  .  /  :  ;  | =  [  \  ]  {  }
</ProgramListing></Para>
</InformalExample>
<Para>The <Literal>{</Literal> (left brace) and <Literal>}</Literal> (right brace) characters
are national replacement set characters that may not be available
on all keyboards.  Wherever IDL specifies a left brace, the 
<Literal>??&lt;</Literal> trigraph
may be substituted.  Wherever IDL specifies a
right brace, the <Literal>??></Literal> trigraph may be substituted.
</Para>
<Para>Use of these trigraph sequences adds the following punctuation characters
to the set in the preceding list:
</Para>
<InformalExample>
<Para><ProgramListing>&lt;  >  ?
</ProgramListing></Para>
</InformalExample>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.10">
<Title>Whitespace</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.9">
<Primary>IDL</Primary>
<Secondary>whitespace</Secondary>
</IndexTerm>
<Para>Whitespace is used to delimit other constructs.  IDL defines the following
whitespace constructs:
</Para>
<ItemizedList>
<ListItem>
<Para>A space
</Para>
</ListItem>
<ListItem>
<Para>A carriage return
</Para>
</ListItem>
<ListItem>
<Para>A horizontal tab
</Para>
</ListItem>
<ListItem>
<Para>A form feed at the beginning of a line
</Para>
</ListItem>
<ListItem>
<Para>A comment
</Para>
</ListItem>
<ListItem>
<Para>A sequence of one or more of the preceding whitespace
constructs
</Para>
</ListItem>
</ItemizedList>
<Para>A keyword, identifier, or number not preceded by a punctuation character
must be preceded by whitespace.  A keyword, identifier, or number not
followed by a punctuation character must be followed by whitespace.
Unless we note otherwise, any punctuation character may be preceded
and/or followed by whitespace.
</Para>
<Para>When enclosed in <Literal>""</Literal> (double quotes) or <Literal>''&nbsp;</Literal> (single quotes),
whitespace constructs are treated literally.  Otherwise, they
serve only to separate other lexical elements and are ignored.
<IndexTerm Id="DCEADG.RPCIDL.indx.10">
<Primary>IDL</Primary>
<Secondary>comments</Secondary>
</IndexTerm></Para>
<Para>Just as in C, 
the character sequence <Literal>/*</Literal> (slash and asterisk) begins a comment,
and the character sequence <Literal>*/</Literal> (asterisk and slash)
ends a comment.  For example:
</Para>
<InformalExample>
<Para><ProgramListing>/* all natural */
import "potato.idl";  /* no preservatives */
</ProgramListing></Para>
</InformalExample>
<Para>Comments do not nest.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.11">
<Title>Case Sensitivity</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.11">
<Primary>IDL</Primary>
<Secondary>case sensitivity</Secondary>
</IndexTerm>
<Para>The IDL compiler does not force the case of 
identifiers in the generated code.
</Para>
<Para>The only case sensitivity issue that you have to be aware of 
is the implications involved in calling generated stubs 
from languages other than C.
</Para>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.RPCIDL.div.12">
<Title>IDL Versus C</Title>
<Para>IDL resembles a subset of ANSI C. The major difference between 
IDL and C is that there are no executable statements in IDL.
</Para>
<Sect2 Id="DCEADG.RPCIDL.div.13">
<Title>Declarations</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.12">
<Primary>IDL</Primary>
<Secondary>declarations</Secondary>
</IndexTerm>
<Para>An interface definition specifies how operations are called, not how
they are implemented.  IDL is therefore a purely declarative language.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.14">
<Title>Data Types</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.13">
<Primary>IDL</Primary>
<Secondary>data types</Secondary>
</IndexTerm>
<Para>To support applications written in languages other than C, IDL defines
some data types that do not exist in C and extends some data types
that do exist in C. For example, IDL defines a Boolean data type.
</Para>
<Para>Some C data types are supported by IDL only with modifications or
restrictions.  For example, unions must be discriminated, and all 
arrays must be accompanied by bounds information.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.15">
<Title>Attributes</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.14">
<Primary>IDL</Primary>
<Secondary>attributes</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.15">
<Primary>attributes</Primary>
<Secondary>IDL</Secondary>
</IndexTerm>
<Para>The stub modules that are generated from an interface definition require
more information about the interface than can be expressed in C. For
example, stubs must know whether an operation parameter is an input
or an output.
</Para>
<Para>The additional information required to define a network interface
is specified via IDL attributes.  IDL attributes can apply to types,
to structure members, to operations, to operation parameters, or to the
interface as a whole.  Some attributes are legal in only one of the
preceding contexts; others are legal in more than one context.  
An attribute is always represented in <Literal>[ ] </Literal> 
(brackets) before the item to which it applies.  For
example, in an operation declaration, inputs of the operation are
preceded by the <Literal>in</Literal> attribute and outputs are preceded by
the <Literal>out</Literal> attribute:
<IndexTerm Id="DCEADG.RPCIDL.indx.16">
<Primary>attributes</Primary>
<Secondary>out</Secondary>
</IndexTerm></Para>
<InformalExample>
<Para><ProgramListing>void arith_add (
     [in] long a,
     [in] long b,
     [out] long *c,
     );
</ProgramListing></Para>
</InformalExample>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.RPCIDL.div.16">
<Title>Interface Definition Structure</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.17">
<Primary>interface</Primary>
<Secondary>definitions</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.18">
<Primary>IDL</Primary>
<Secondary>interface definition structure</Secondary>
</IndexTerm>
<Para>An interface definition has the following structure:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>[<Symbol Role="Variable">interface_attribute</Symbol><Literal>,</Literal> ...] <Literal>interface</Literal> <Symbol Role="Variable">interface_name</Symbol>
<Literal>{</Literal>
<Symbol Role="Variable">declarations</Symbol>
<Literal>}</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The portion of an interface definition that precedes the <Literal>{</Literal> (left brace)
is the interface header.  The remainder of the definition is the interface
body.  Interface header syntax and interface body syntax are 
described separately in the following two subsections.
</Para>
<Sect2 Id="DCEADG.RPCIDL.div.17">
<Title>Interface Definition Header</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.19">
<Primary>IDL</Primary>
<Secondary>interface definition header</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.20">
<Primary>interface</Primary>
<Secondary>definitions</Secondary>
<Tertiary>header</Tertiary>
</IndexTerm>
<Para>The interface header comprises a list of interface attributes enclosed
in <Literal>[ ] </Literal> (brackets), the keyword <Literal>interface</Literal>, and the interface name:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>[<Symbol Role="Variable">interface_attribute</Symbol><Literal>,</Literal> ...] <Literal>interface</Literal> <Symbol Role="Variable">interface_name</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>Interface names, together with major and minor version numbers, are
used by the IDL compiler to construct identifiers for interface specifiers,
entry point vectors, and entry point vector types.  If the
major and minor version numbers are single digits, the interface name
can be up to 17 characters long.
</Para>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.21">
<Primary>C++ output from IDL</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.22">
<Primary>IDL inheritance operator</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.23">
<Primary>inherit an interface</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.24">
<Primary>interface inheritance</Primary>
</IndexTerm>For C++  output, the interface header can also inherit an interface 
by using the inheritance operator (:) as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>[<Symbol Role="Variable">interface_attribute</Symbol><Literal>,</Literal> ...] <Literal>interface</Literal> <Symbol Role="Variable">interface_name</Symbol> <Literal>:</Literal> <Symbol Role="Variable">inherited_interface</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<?sml-break>
<?sml-need 20>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.18">
<Title>Interface Definition Body</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.25">
<Primary>IDL</Primary>
<Secondary>interface definition body</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.26">
<Primary>interface</Primary>
<Secondary>definitions</Secondary>
</IndexTerm>
<Para>The <Symbol Role="Variable">declarations</Symbol> in an interface definition body are
one or more of the following:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">import_declaration
constant_declaration
type_declaration
operation_declaration</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>A <Literal>;</Literal> (semicolon) terminates each declaration,
and <Literal>{ }</Literal> (braces) enclose the entire
body.
<IndexTerm Id="DCEADG.RPCIDL.indx.27">
<Primary>IDL</Primary>
<Secondary>import declarations</Secondary>
</IndexTerm></Para>
<Para>Import declarations must precede other declarations in the interface
body.
Import declarations specify
the names of other IDL interfaces that define types and constants
used by the importing interface.
</Para>
<Para>Constant, type, and operation declarations specify the constants,
types, and operations that the interface exports.  These declarations
can be coded in any order, provided any constant or type is defined
before it is used.
</Para>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.RPCIDL.div.19">
<Title>Overview of IDL Attributes</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.28">
<Primary>uuid attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.29">
<Primary>version attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.30">
<Primary>endpoint</Primary>
<Secondary>attribute</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.31">
<Primary>local attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.32">
<Primary>pointer_default attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.33">
<Primary>broadcast attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.34">
<Primary>maybe attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.35">
<Primary>reflect_deletions attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.36">
<Primary>exceptions</Primary>
<Secondary>attribute</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.37">
<Primary>idempotent attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.38">
<Primary>in attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.39">
<Primary>out attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.40">
<Primary>ignore attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.41">
<Primary>max_is attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.42">
<Primary>min_is attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.43">
<Primary>size_is attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.44">
<Primary>first_is attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.45">
<Primary>last_is attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.46">
<Primary>length_is attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.47">
<Primary>string</Primary>
<Secondary>attribute</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.48">
<Primary>ptr attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.49">
<Primary>ref attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.50">
<Primary>handle</Primary>
<Secondary>attribute</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.51">
<Primary>context_handle attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.52">
<Primary>transmit_as attribute</Primary>
</IndexTerm>
<Para>Table 18-1 lists the attributes allowed in interface definition
files and specifies the declarations in which they can occur.
</Para>
<?sml-need 5i>
<Table Frame="all" Remap="center" Orient="Port">
<Title>IDL Attributes</Title>
<TGroup Rowsep="1" Colsep="1" Cols="2">
<ColSpec Colsep="1" Align="Left" Colwidth="1*" Colname="col1" Colnum="1">
<ColSpec Align="Left" Colwidth="1*" Colname="col2" Colnum="2">
<thead>
<Row>
<Entry Rowsep="1"><Literal>Attribute</Literal></Entry>
<Entry Rowsep="1"><Literal>Where Used</Literal></Entry>
</Row>
</thead>
<tbody>
<Row>
<Entry><Literal>uuid</Literal></Entry>
<Entry>Interface definition headers</Entry>
</Row>
<Row>
<Entry><Literal>version</Literal></Entry>
<Entry></Entry>
</Row>
<Row>
<Entry><Literal>endpoint</Literal></Entry>
<Entry></Entry>
</Row>
<Row>
<Entry><Literal>exceptions</Literal></Entry>
<Entry></Entry>
</Row>
<Row>
<Entry><Literal>pointer_default</Literal></Entry>
<Entry></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>local</Literal></Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry><Literal>broadcast</Literal></Entry>
<Entry>Operations</Entry>
</Row>
<Row>
<Entry><Literal>maybe</Literal></Entry>
<Entry></Entry>
</Row>
<Row>
<Entry><Literal>idempotent</Literal></Entry>
<Entry></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>reflect_deletions</Literal></Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry><Literal>in</Literal></Entry>
<Entry>Parameters</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>out</Literal></Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>ignore</Literal></Entry>
<Entry Rowsep="1">Structures</Entry>
</Row>
<Row>
<Entry><Literal>max_is</Literal></Entry>
<Entry>Arrays</Entry>
</Row>
<Row>
<Entry><Literal>min_is</Literal></Entry>
<Entry></Entry>
</Row>
<Row>
<Entry><Literal>size_is</Literal></Entry>
<Entry></Entry>
</Row>
<Row>
<Entry><Literal>first_is</Literal></Entry>
<Entry></Entry>
</Row>
<Row>
<Entry><Literal>last_is</Literal></Entry>
<Entry></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>length_is</Literal></Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>string</Literal></Entry>
<Entry Rowsep="1">Arrays</Entry>
</Row>
<Row>
<Entry><Literal>ptr</Literal></Entry>
<Entry>Pointers</Entry>
</Row>
<Row>
<Entry><Literal>ref</Literal></Entry>
<Entry></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>unique</Literal></Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>handle</Literal></Entry>
<Entry Rowsep="1">Customized handles</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>context_handle</Literal></Entry>
<Entry Rowsep="1">Context handles</Entry>
</Row>
<Row>
<Entry><Literal>transmit_as</Literal></Entry>
<Entry>Type declarations</Entry>
</Row>
</TBody>
</TGroup>
</Table>
</Sect1>
<Sect1 Id="DCEADG.RPCIDL.div.20">
<Title>Interface Definition Header Attributes</Title>
<Para>The following subsections describe in detail the usage and semantics of the IDL
attributes that can be used in interface definition headers.
The attributes provided for interface definition headers are as follows:
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>uuid</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>version</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>endpoint</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>exceptions</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>pointer_default</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>local</Literal>
</Para>
</ListItem>
</ItemizedList>
<Sect2 Id="DCEADG.RPCIDL.div.21">
<Title>The uuid Attribute</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.53">
<Primary>uuid attribute</Primary>
</IndexTerm>
<Para>The<Literal> uuid</Literal> attribute specifies the Universal Unique Identifier
(UUID) that is assigned to an interface.  The <Literal>uuid</Literal> attribute 
takes the following form:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>uuid (</Literal><Symbol Role="Variable">uuid_string</Symbol><Literal>)
</Literal></UserInput></ProgramListing></Para>
</InformalExample>
<Para>A <Symbol Role="Variable">uuid_string</Symbol> is the string representation of a UUID. This
string is typically generated as part of a skeletal interface definition
by the utility <Command>uuidgen</Command>.  A <Symbol Role="Variable">uuid_string</Symbol> contains
one group of 8 hexadecimal digits, three groups of 4 hexadecimal
digits, and one group of 12 hexadecimal digits, with hyphens separating
the groups, as in the following example:
</Para>
<InformalExample>
<Para><ProgramListing>01234567-89ab-cdef-0123-456789abcdef
</ProgramListing></Para>
</InformalExample>
<Para>A new UUID should be generated for any new interface.  If several versions
of one interface exist, all versions should have the same interface
UUID but different version numbers.  A client and a server cannot communicate
unless the interface imported by the client and the interface exported
by the server have the same UUID. The client and server stubs in an
application must be generated from the same interface definition or
from interface definitions with identical <Literal>uuid</Literal> attributes.
</Para>
<Para>Any remote interface must have the <Literal>uuid</Literal> attribute.  An interface
must have either the <Literal>uuid</Literal> attribute or the <Literal>local</Literal>
attribute, but cannot have both.
</Para>
<Para>The <Literal>uuid</Literal> attribute can appear at most once in an interface.
</Para>
<Para>The following example illustrates use of the <Literal>uuid</Literal> attribute:
</Para>
<InformalExample>
<Para><ProgramListing>uuid(4ca7b4dc-d000-0d00-0218-cb0123ed9876)
</ProgramListing></Para>
</InformalExample>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.22">
<Title>The version Attribute</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.54">
<Primary>version attribute</Primary>
</IndexTerm>
<Para>The <Literal>version</Literal> attribute specifies a particular version of a
remote interface.  The <Literal>version</Literal> attribute takes the following form:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>version (</Literal><Symbol Role="Variable">major </Symbol><Symbol Role="Variable">[</Symbol><Literal>.&thinsp;</Literal><Symbol Role="Variable">minor </Symbol><Symbol Role="Variable">]</Symbol><Literal>)
</Literal></UserInput></ProgramListing></Para>
</InformalExample>
<Para>A version number can be either a pair of integers (the major
and minor version numbers) or a single integer (the major version
number).  If both major and minor version numbers are supplied, the
integers should be separated by a period without whitespace.  If no
minor version number is supplied, 0 (zero) is assumed.
</Para>
<Para>The following examples illustrate use of the <Literal>version</Literal> attribute:
</Para>
<InformalExample>
<Para><ProgramListing>version (1.1)   /* major and minor version numbers */

version (3)     /* major version number only */
</ProgramListing></Para>
</InformalExample>
<Para>The <Literal>version</Literal> attribute can be omitted altogether, in which
case the interface is assigned 0.0 as the default version number.
</Para>
<Para>A client and a server can communicate only if the following requirements
are met:
</Para>
<ItemizedList>
<ListItem>
<Para>The interface imported by the client and the interface
exported by the server have the same major version number.
</Para>
</ListItem>
<ListItem>
<Para>The interface imported by the client has a minor version
number less than or equal to that of the interface exported by the
server.
</Para>
</ListItem>
</ItemizedList>
<Para><?sml-need 4>You must increase either the minor version number or the major version
number when you make any compatible change to an interface definition.
You must not decrease
the minor version number unless you simultaneously increase the major
version number.
</Para>
<Para>You must increase the major version number when you make any incompatible
change to an interface definition. (See the definition of compatible
changes that follows.) You cannot decrease the major version number.
</Para>
<Para>The following are considered compatible changes to an interface definition:
</Para>
<ItemizedList>
<ListItem>
<Para>Adding operations to the interface, if and only if
the new operations are declared after all existing operation declarations
in the interface definition.
</Para>
</ListItem>
<ListItem>
<Para>Adding type and constant declarations, if the new
types and constants are used only by operations added at the same
time or later.  Existing operation declarations cannot have 
their signatures modified.
</Para>
</ListItem>
</ItemizedList>
<Para>The <Symbol Role="Variable">major</Symbol> and <Symbol Role="Variable">minor</Symbol> integers in the <Literal>version</Literal>
attribute can range from 0 to 65,535, inclusive.  However, these typically
are small integers and are increased in increments of one.
</Para>
<Para>The following are considered incompatible changes to an interface definition:
</Para>
<ItemizedList>
<ListItem>
<Para>Changing the signature of an existing operation
</Para>
</ListItem>
<ListItem>
<Para>Changing the order of existing operations
</Para>
</ListItem>
<ListItem>
<Para>Adding a new operation other than at the end
</Para>
</ListItem>
</ItemizedList>
<Para>The <Literal>version</Literal> attribute can appear at most once in an interface.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.23">
<Title>The endpoint Attribute</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.55">
<Primary>endpoint</Primary>
<Secondary>attribute</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.56">
<Primary>protocol</Primary>
<Secondary>family</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.57">
<Primary>port</Primary>
</IndexTerm>
<Para>The <Literal>endpoint</Literal> attribute specifies the well-known endpoint 
or endpoints on which servers that export the interface will listen. 
The <Literal>endpoint</Literal> attribute takes the following form:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>endpoint (</Literal><Symbol Role="Variable">endpoint_spec</Symbol><Literal>,</Literal> ...<Literal>)
</Literal></UserInput></ProgramListing></Para>
</InformalExample>
<Para><?sml-need 3>Each <Symbol Role="Variable">endpoint_spec</Symbol> is a string in the following form:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>" <Symbol Role="Variable">family </Symbol><Literal>:</Literal> [<Symbol Role="Variable">endpoint</Symbol>]<Literal> "
</Literal></UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Symbol Role="Variable">family</Symbol> identifies a protocol family.  The following
are accepted values for <Symbol Role="Variable">family</Symbol>:
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>ncacn_ip_tcp</Literal>:
NCA Connection over Internet Protocol: Transmission
Control Protocol (TCP/IP)
<!-- .LI "\*Lncacn_dnet_nsp\*O"-->
<!-- NCA Connection over DECnet: Network Services-->
<!-- Protocol (DECnet Phase IV)-->
<!-- .LI "\*Lncacn_osi_nsp\*O"-->
<!-- NCA Connection over Open Systems Interconnection:-->
<!-- Network Services Protocol (DECnet Phase V)-->
<!-- .LI "\*Lncacn_osi_tp4\*O"-->
<!-- NCA Connection over Open Systems Interconnection:-->
<!-- ISO Transport Protocol Class 4-->
</Para>
</ListItem>
<ListItem>
<Para><Literal>ncadg_ip_udp</Literal>:
NCA Datagram over Internet Protocol: User
Datagram Protocol (UDP/IP)
<!-- .cS-->
<!-- DIGITAL_BEGIN-->
<!-- ** To include Digital Equipment Corporation and HP/Apollo protocol-->
<!-- ** sequences, add the following four lines.  Also, either add-->
<!-- ** ncadg_dds to the two examples later in this file or replace-->
<!-- ** "ncacn_ip_tcp:[1025]" with "ncadg_dds:[19]" - just the way it-->
<!-- ** was in V1.0 (with a print date of December 31, 1991).  Of course,-->
<!-- ** remove the .zA ... .zZ lines just after the .cE line.-->
<!-- .LI "\*Lncadg_dds\*O"-->
<!-- NCA Datagram over Domain Datagram Service (DDS)-->
<!-- DIGITAL_END-->
<!-- .cE-->
</Para>
</ListItem>
</ItemizedList>
<Para>The <Symbol Role="Variable">endpoint</Symbol> identifies a well-known endpoint for the
specified <Symbol Role="Variable">family</Symbol>.  The values accepted for <Symbol Role="Variable">endpoint</Symbol>
depend on the <Symbol Role="Variable">family</Symbol> but typically are integers within a
limited range.  IDL does not define valid <Symbol Role="Variable">endpoint</Symbol>
values.
</Para>
<Para>Well-known endpoint values are typically assigned by the central
authority that ``owns'' a protocol.  For example, the Internet Assigned 
Numbers Authority assigns well-known
endpoint values for the IP protocol family.
</Para>
<Para>At compile time, the IDL compiler checks each <Symbol Role="Variable">endpoint_spec</Symbol>
only for gross syntax.  At runtime, stubs pass the <Symbol Role="Variable">family</Symbol>
and <Symbol Role="Variable">endpoint</Symbol> strings to the RPC runtime, which validates
and interprets them.
</Para>
<Para>Most applications should not use well-known endpoints and should
instead use dynamically assigned opaque endpoints.  Most interfaces
designed for use by applications should therefore not have the
<Literal>endpoint</Literal> attribute.
</Para>
<Para>The following example illustrates use of the <Literal>endpoint</Literal> attribute:
</Para>
<InformalExample>
<Para><ProgramListing>endpoint ("ncacn_ip_tcp:[1025]", "ncadg_ip_udp:[6677]")
</ProgramListing></Para>
</InformalExample>
<Para>The <Literal>endpoint</Literal> attribute can appear at most once in an interface.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.24">
<Title>The exceptions Attribute</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.58">
<Primary>exceptions</Primary>
<Secondary>attribute</Secondary>
</IndexTerm>
<Para>The <Literal>exceptions</Literal> attribute specifies a set of user-defined exceptions
that can be generated by the server implementation of the interface.  The
<Literal>exceptions</Literal> attribute takes the following form:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>exceptions (</Literal><Symbol Role="Variable">exception_name</Symbol> [<Literal>,</Literal><Symbol Role="Variable">exception_name</Symbol>] ...<Literal>)</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para><?sml-need 16>The following is a sample declaration of an <Literal>exceptions</Literal> attribute:
</Para>
<InformalExample>
<Para><ProgramListing>[uuid(06255501-08AF-11CB-8C4F-08002B13D56D),
version (1.1),
  exceptions (
      exc_e_exquota,
      binop_e_aborted,
      binop_e_too_busy,
      binop_e_shutdown)
] interface binop
  {
      long binop_add(
           [in] long a,
           [in] long b
           );
   }
</ProgramListing></Para>
</InformalExample>
<Para>See Chapter 17 for more information on using exceptions.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.25">
<Title>The pointer_default Attribute</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.59">
<Primary>pointer_default attribute</Primary>
</IndexTerm>
<Para>IDL supports two kinds of pointer semantics.  The <Literal>pointer_default</Literal>
attribute specifies the default semantics for pointers that are declared
in the interface definition.  The 
<Literal>pointer_default</Literal> attribute takes the following form:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>pointer_default (</Literal><Symbol Role="Variable">pointer_attribute</Symbol>)
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>Possible values for <Symbol Role="Variable">pointer_attribute</Symbol> are <Literal>ref, unique,</Literal> and
<Literal>ptr</Literal>.
</Para>
<Para>The default semantics established by the <Literal>pointer_default</Literal>
attribute apply to the following usages of pointers:
</Para>
<ItemizedList>
<ListItem>
<Para>A pointer that occurs in the declaration of a member
of a structure or a union.
</Para>
</ListItem>
<ListItem>
<Para>A pointer that does not occur at the top level of an operation parameter
declared with more than one pointer operator.  A top-level pointer is one
that is not the target of another pointer and is not a field of a
data structure that is the target of a pointer.
(See Section 18.14.7.2 for more information on top-level pointers.)
</Para>
</ListItem>
</ItemizedList>
<Para>Note that the <Literal>pointer_default</Literal> attribute does not apply to 
a pointer that is the return value of an operation because this is 
always a full pointer.
</Para>
<Para>The default semantics can be overridden by pointer attributes in the
declaration of a particular pointer.  If an interface definition does
not specify <Literal>pointer_default</Literal> and contains a declaration that
requires default pointer semantics, the IDL compiler will issue a
warning.  For additional information on pointer semantics, 
refer to Section 18.14.7.1. 
</Para>
<Para>The <Literal>pointer_default</Literal> attribute can appear at most once in an interface.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.26">
<Title>The local Attribute</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.60">
<Primary>local attribute</Primary>
</IndexTerm>
<Para>The <Literal>local</Literal> attribute indicates that an interface definition
does not declare any remote operations and that the IDL compiler should
therefore generate only header files, not stub files.  The 
<Literal>local</Literal> attribute takes the following form:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>local</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>An interface containing operation definitions must have either 
the <Literal>local</Literal> attribute or the <Literal>uuid</Literal> attribute.
No interface can have both.
</Para>
<Para>The <Literal>local</Literal> attribute can appear at most once in an interface.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.27">
<Title>Rules for Using Interface Definition Header Attributes</Title>
<Para>An interface cannot have both the <Literal>local</Literal> attribute and the <Literal>uuid</Literal>
attribute.  In an interface definition that contains any operation
declarations, either <Literal>local</Literal> or <Literal>uuid</Literal> must be specified.
In an interface definition that contains no operation declarations,
both <Literal>local</Literal> and <Literal>uuid</Literal> can be omitted.
</Para>
<Para>The <Literal>local</Literal>, <Literal>uuid</Literal>, and <Literal>version</Literal> attributes cannot
be coded more than once.  If the <Literal>endpoint</Literal> or the
<Literal>pointer_default</Literal> attribute is coded more than once, the IDL
compiler issues a warning and, where conflicts exist, the IDL compiler
accepts the last value specified.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.28">
<Title>Examples of Interface Definition Header Attributes</Title>
<Para>The following example uses the <Literal>uuid</Literal> and <Literal>version</Literal>
attributes:
</Para>
<InformalExample>
<Para><ProgramListing>[uuid(df961f80-2d24-11c9-be74-08002b0ecef1), version(1.1)]
interface my_interface_name
</ProgramListing></Para>
</InformalExample>
<Para>The following example uses the <Literal>uuid</Literal>, <Literal>endpoint</Literal>, and <Literal>version</Literal> attributes:
</Para>
<InformalExample>
<Para><ProgramListing>[uuid(0bb1a080-2d25-11c9-8d6e-08002b0ecef1),
endpoint("ncacn_ip_tcp:[1025]", "ncacn_ip_tcp:[6677]"),
version(3.2)]
interface my_interface_name
</ProgramListing></Para>
</InformalExample>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.RPCIDL.div.29">
<Title>Import Declarations</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.61">
<Primary>import declarations</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.62">
<Primary>IDL</Primary>
<Secondary>import declarations</Secondary>
</IndexTerm>
<Para>The IDL <Symbol Role="Variable">import_declaration</Symbol> specifies interface definition files
that declare types and constants used by the importing interface.
It takes the following form:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>import </Literal><Symbol Role="Variable">file</Symbol><Literal>,</Literal>... <Literal>;</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Symbol Role="Variable">file</Symbol> argument is the pathname, enclosed in double quotes,
of the interface definition you are importing.  This pathname can be
relative; the <Option>I</Option> option of the IDL compiler allows you to
specify a  directory from which to resolve import pathnames.
</Para>
<Para>The effect of an import declaration is as if all constant, type, and
import declarations from the imported file occurred in the importing
file at the point where the import declaration occurs.  Operation
declarations are not imported.
</Para>
<Para>For example, suppose that the interface definition <Filename>aioli.idl</Filename>
contains a declaration to import the definitions for the <Literal>garlic</Literal>
and <Literal>oil</Literal> interfaces:
</Para>
<InformalExample>
<Para><ProgramListing>import "garlic.idl", "oil.idl";
</ProgramListing></Para>
</InformalExample>
<Para>The IDL compiler will generate a C header file named <Filename>aioli.h</Filename>
that contains the following <Literal>#include</Literal> directives:
</Para>
<InformalExample>
<Para><ProgramListing>#include "garlic.h"
#include "oil.h"
</ProgramListing></Para>
</InformalExample>
<Para>The stub files that the compiler generates will not contain code for
any <Literal>garlic</Literal> and <Literal>oil</Literal> operations.
</Para>
<Para>Importing an interface many times has the same effect as importing
it once.
</Para>
</Sect1>
<Sect1 Id="DCEADG.RPCIDL.div.30">
<Title>Constant Declarations</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.63">
<Primary>constant declarations</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.64">
<Primary>IDL</Primary>
<Secondary>const declaration</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.65">
<Primary>IDL</Primary>
<Secondary>constant declarations</Secondary>
</IndexTerm>
<Para>The IDL <Symbol Role="Variable">constant_declaration</Symbol> can take any one of the following forms:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>const</Literal> <Symbol Role="Variable">integer_type_spec identifier</Symbol> <Literal>=</Literal> <Symbol Role="Variable">integer</Symbol> | <Symbol Role="Variable">value</Symbol> | <Symbol Role="Variable">integer_const_expression</Symbol><Literal>;
const boolean</Literal> <Symbol Role="Variable">identifier</Symbol> <Literal>=</Literal> <Literal>TRUE</Literal> | <Literal>FALSE</Literal> | <Symbol Role="Variable">value</Symbol><Literal>;
const char</Literal> <Symbol Role="Variable">identifier</Symbol> <Literal>=</Literal> <Symbol Role="Variable">character</Symbol> | <Symbol Role="Variable">value</Symbol><Literal>;
const char*</Literal> <Symbol Role="Variable">identifier</Symbol> <Literal>=</Literal> <Symbol Role="Variable">string</Symbol> | <Symbol Role="Variable">value</Symbol><Literal>;
const void*</Literal> <Symbol Role="Variable">identifier</Symbol> <Literal>=</Literal> <Literal>NULL</Literal> | <Symbol Role="Variable">value</Symbol><Literal>;</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Symbol Role="Variable">integer_type_spec</Symbol> is the data type of the integer constant 
you are declaring.  The <Symbol Role="Variable">identifier</Symbol> is the name of the constant.  
The <Symbol Role="Variable">integer</Symbol>, <Symbol Role="Variable">integer_const_expression</Symbol>, <Symbol Role="Variable">character</Symbol>, 
<Symbol Role="Variable">string</Symbol>, or <Symbol Role="Variable">value</Symbol> specifies the value to be 
assigned to the constant.
<IndexTerm Id="DCEADG.RPCIDL.indx.66">
<Primary>constants</Primary>
<Secondary>integers</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.67">
<Primary>constants</Primary>
<Secondary>strings</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.68">
<Primary>integers</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.69">
<Primary>strings</Primary>
</IndexTerm>A <Symbol Role="Variable">value</Symbol> can be any previously
defined constant.
</Para>
<Para>IDL provides only integer, Boolean, character, string, and null pointer
constants.
<IndexTerm Id="DCEADG.RPCIDL.indx.70">
<Primary>constant expressions</Primary>
</IndexTerm></Para>
<Para>Following are examples of constant declarations:
</Para>
<InformalExample>
<Para><ProgramListing>const short TEN = 10;
const boolean FAUX = FALSE;
const char* DSCH = "Dmitri Shostakovich";
</ProgramListing></Para>
</InformalExample>
<Sect2 Id="DCEADG.RPCIDL.div.31">
<Title>Integer Constants</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.71">
<Primary>integers</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.72">
<Primary>constants</Primary>
<Secondary>integers</Secondary>
</IndexTerm>
<Para>An <Symbol Role="Variable">integer_type_spec</Symbol> is a <Symbol Role="Variable">type_specifier</Symbol> for an
integer, except that the <Symbol Role="Variable">int_size</Symbol> for an integer 
constant cannot be <Literal>hyper</Literal>.
</Para>
<Para>An <Symbol Role="Variable">integer</Symbol> is the decimal representation of an integer.  IDL 
also supports the C notation for hexadecimal, octal, and long integer 
constants.
</Para>
<Para>You can specify any previously defined integer constant as the <Symbol Role="Variable">value</Symbol>
of an integer constant.
</Para>
<Para>You can specify any arithmetic expression as the 
<Symbol Role="Variable">integer_const_expression</Symbol> that evaluates to an integer constant.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.32">
<Title>Boolean Constants</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.73">
<Primary>Booleans</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.74">
<Primary>constants</Primary>
<Secondary>Booleans</Secondary>
</IndexTerm>
<Para>A Boolean constant can take one of two values: TRUE or FALSE.
</Para>
<Para>You can specify any previously defined Boolean constant as the <Symbol Role="Variable">value</Symbol>
of a Boolean constant.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.33">
<Title>Character Constants</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.75">
<Primary>characters</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.76">
<Primary>constants</Primary>
<Secondary>characters</Secondary>
</IndexTerm>
<Para>A <Symbol Role="Variable">character</Symbol> is an ASCII character enclosed in single quotes.  A white 
space character is interpreted literally.  The <Literal>&bsol;</Literal> (backslash)
character introduces an escape sequence, as defined
in the ANSI C standard.  The <Literal>'</Literal> (single quote) character can
be coded as the <Symbol Role="Variable">character</Symbol> only if it is escaped by a backslash.
</Para>
<Para>You can specify any previously defined character constant as
the <Symbol Role="Variable">value</Symbol> of a character constant.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.34">
<Title>String Constants</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.77">
<Primary>strings</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.78">
<Primary>constants</Primary>
<Secondary>strings</Secondary>
</IndexTerm>
<Para>A <Symbol Role="Variable">string</Symbol> is a sequence of ASCII characters enclosed in double quotes.  
Whitespace characters are interpreted literally.
The <Literal>&bsol;</Literal> (backslash) character introduces an escape sequence,
as defined in the ANSI C standard.  The <Literal>"</Literal> (double quote) character
can be coded in a <Symbol Role="Variable">string</Symbol> only if it is escaped by a backslash.
</Para>
<Para>You can specify any previously defined string constant as the <Symbol Role="Variable">value</Symbol>
of a string constant.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.35">
<Title>NULL Constants</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.79">
<Primary>null constants</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.80">
<Primary>constants</Primary>
<Secondary>nulls</Secondary>
</IndexTerm>
<Para>A <Literal>void*</Literal> constant can take only one literal value: NULL.
</Para>
<Para>You can specify any previously defined <Literal>void*</Literal> constant as
the <Symbol Role="Variable">value</Symbol> of a <Literal>void*</Literal> constant.
</Para>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.RPCIDL.div.36">
<Title>Type Declarations</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.81">
<Primary>type</Primary>
<Secondary>declarations</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.82">
<Primary>typedef declaration</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.83">
<Primary>types</Primary>
<Secondary>IDL</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.84">
<Primary>named types</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.85">
<Primary>IDL</Primary>
<Secondary>named types</Secondary>
</IndexTerm>
<Para>The IDL <Symbol Role="Variable">type_declaration</Symbol> enables you to associate a
name with a data type and to specify attributes of the data type.
It takes the following form:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>typedef </Literal><Symbol Role="Variable">[</Symbol>[<Symbol Role="Variable">type_attribute</Symbol><Literal>,</Literal> ...]<Symbol Role="Variable">] type_specifier type_declarator</Symbol><Literal>,</Literal> ... <Literal>;</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>A <Symbol Role="Variable">type_attribute</Symbol> specifies characteristics of the type being
declared.
</Para>
<Para>The <Symbol Role="Variable">type_specifier</Symbol> can specify a base type, a constructed
type, a predefined type, or a named type.
A function pointer can be specified if the <Literal>local</Literal> attribute has been
specified.
</Para>
<Para>Each <Symbol Role="Variable">type_declarator</Symbol> is a name for the type being defined.  Note, though, 
that a <Symbol Role="Variable">type_declarator</Symbol> can also be preceded by an <Literal>*</Literal>
(asterisk), followed by <Literal>[] </Literal> (brackets), and can
include <Literal>(&ensp;)</Literal> (parentheses) to indicate the precedence of its
components.
</Para>
<Sect2 Id="DCEADG.RPCIDL.div.37">
<Title>Type Attributes</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.86">
<Primary>IDL</Primary>
<Secondary>type attributes</Secondary>
</IndexTerm>
<Para>A <Symbol Role="Variable">type_attribute</Symbol> can be any of the following:
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>handle</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.87">
<Primary>handle</Primary>
<Secondary>attribute</Secondary>
</IndexTerm>The type being declared is a user-defined,
customized-handle type.
</Para>
</ListItem>
<ListItem>
<Para><Literal>context_handle</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.88">
<Primary>context_handle attribute</Primary>
</IndexTerm>The type being declared is a
context-handle type.
</Para>
</ListItem>
<ListItem>
<Para><Literal>transmit_as</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.89">
<Primary>transmit_as attribute</Primary>
</IndexTerm>The type being declared is a <FirstTerm>presented type</FirstTerm>.  When it is passed in
remote procedure calls, it is converted to a specified <FirstTerm>transmitted type</FirstTerm>.
</Para>
</ListItem>
<ListItem>
<Para><Literal>ref</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.90">
<Primary>ref attribute</Primary>
</IndexTerm>The type being declared is a reference pointer.
</Para>
</ListItem>
<ListItem>
<Para><Literal>ptr</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.91">
<Primary>ptr attribute</Primary>
</IndexTerm>The type being declared is a full pointer.
</Para>
</ListItem>
<ListItem>
<Para><Literal>unique</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.92">
<Primary>unique attribute</Primary>
</IndexTerm>The type being declared is a unique pointer.
</Para>
</ListItem>
<ListItem>
<Para><Literal>string</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.93">
<Primary>string</Primary>
<Secondary>attribute</Secondary>
</IndexTerm>The array type being declared is a string type.
</Para>
</ListItem>
</ItemizedList>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.38">
<Title>Base Type Specifiers</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.94">
<Primary>base type specifiers</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.95">
<Primary>type</Primary>
<Secondary>specifiers</Secondary>
</IndexTerm>
<Para>IDL base types include integers, floating-point numbers, characters,
a <Literal>boolean</Literal> type, 
a <Literal>byte</Literal> type, a <Literal>void</Literal> type, and a primitive handle type.
</Para>
<Para>Table 18-2 lists the IDL base data type 
specifiers.  Where applicable, the table shows the 
size of the corresponding transmittable type and the type 
macro emitted by the IDL compiler for resulting declarations.
</Para>
<?sml-need 4.5i>
<Table Frame="all" Remap="center" Orient="Port">
<Title>Base Data Type Specifiers</Title>
<TGroup Rowsep="1" Colsep="1" Cols="5">
<ColSpec Align="Center" Colwidth="1*" Colname="col1" Colnum="1">
<ColSpec Align="Center" Colwidth="1*" Colname="col2" Colnum="2">
<ColSpec Colsep="1" Align="Left" Colwidth="1*" Colname="col3" Colnum="3">
<ColSpec Colsep="1" Align="Left" Colwidth="1*" Colname="col4" Colnum="4">
<ColSpec Align="Left" Colwidth="1*" Colname="col5" Colnum="5">
<thead>
<Row>
<Entry Colsep="0" Rowsep="0"></Entry>
<Entry Colsep="0" Rowsep="0"><Literal>Specifier</Literal></Entry>
<Entry Colsep="1" Rowsep="0"></Entry>
<Entry Colsep="1" Rowsep="0"></Entry>
<Entry Colsep="1" Rowsep="0"><Literal>Type Macro</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1" Colsep="0"><Literal>(sign)</Literal></Entry>
<Entry Rowsep="1" Colsep="0"><Literal>(size)</Literal></Entry>
<Entry Rowsep="1" Colsep="1"><Literal>(type)</Literal></Entry>
<Entry Rowsep="1" Colsep="1"><Literal>Size</Literal></Entry>
<Entry Rowsep="1" Colsep="1"><Literal>Emitted by idl</Literal></Entry>
</Row>
</thead>
<tbody>
<Row>
<Entry Rowsep="1"></Entry>
<Entry Rowsep="1"><Literal>small</Literal></Entry>
<Entry Rowsep="1"><Literal>int</Literal></Entry>
<Entry Rowsep="1">8 bits</Entry>
<Entry Rowsep="1"><Literal>idl_small_int</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1"></Entry>
<Entry Rowsep="1"><Literal>short</Literal></Entry>
<Entry Rowsep="1"><Literal>int</Literal></Entry>
<Entry Rowsep="1">16 bits</Entry>
<Entry Rowsep="1"><Literal>idl_short_int</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1"></Entry>
<Entry Rowsep="1"><Literal>long</Literal></Entry>
<Entry Rowsep="1"><Literal>int</Literal></Entry>
<Entry Rowsep="1">32 bits</Entry>
<Entry Rowsep="1"><Literal>idl_long_int</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1"></Entry>
<Entry Rowsep="1"><Literal>hyper</Literal></Entry>
<Entry Rowsep="1"><Literal>int</Literal></Entry>
<Entry Rowsep="1">64 bits</Entry>
<Entry Rowsep="1"><Literal>idl_hyper_int</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>unsigned</Literal></Entry>
<Entry Rowsep="1"><Literal>small</Literal></Entry>
<Entry Rowsep="1"><Literal>int</Literal></Entry>
<Entry Rowsep="1">8 bits</Entry>
<Entry Rowsep="1"><Literal>idl_usmall_int</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>unsigned</Literal></Entry>
<Entry Rowsep="1"><Literal>short</Literal></Entry>
<Entry Rowsep="1"><Literal>int</Literal></Entry>
<Entry Rowsep="1">16 bits</Entry>
<Entry Rowsep="1"><Literal>idl_ushort_int</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>unsigned</Literal></Entry>
<Entry Rowsep="1"><Literal>long</Literal></Entry>
<Entry Rowsep="1"><Literal>int</Literal></Entry>
<Entry Rowsep="1">32 bits</Entry>
<Entry Rowsep="1"><Literal>idl_ulong_int</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>unsigned</Literal></Entry>
<Entry Rowsep="1"><Literal>hyper</Literal></Entry>
<Entry Rowsep="1"><Literal>int</Literal></Entry>
<Entry Rowsep="1">64 bits</Entry>
<Entry Rowsep="1"><Literal>idl_uhyper_int</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1"></Entry>
<Entry Rowsep="1"></Entry>
<Entry Rowsep="1"><Literal>float</Literal></Entry>
<Entry Rowsep="1">32 bits</Entry>
<Entry Rowsep="1"><Literal>idl_short_float</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1"></Entry>
<Entry Rowsep="1"></Entry>
<Entry Rowsep="1"><Literal>double</Literal></Entry>
<Entry Rowsep="1">64 bits</Entry>
<Entry Rowsep="1"><Literal>idl_long_float</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1"></Entry>
<Entry Rowsep="1"></Entry>
<Entry Rowsep="1"><Literal>char</Literal></Entry>
<Entry Rowsep="1">8 bits</Entry>
<Entry Rowsep="1"><Literal>idl_char</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1"></Entry>
<Entry Rowsep="1"></Entry>
<Entry Rowsep="1"><Literal>boolean</Literal></Entry>
<Entry Rowsep="1">8 bits</Entry>
<Entry Rowsep="1"><Literal>idl_boolean</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1"></Entry>
<Entry Rowsep="1"></Entry>
<Entry Rowsep="1"><Literal>byte</Literal></Entry>
<Entry Rowsep="1">8 bits</Entry>
<Entry Rowsep="1"><Literal>idl_byte</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1"></Entry>
<Entry Rowsep="1"></Entry>
<Entry Rowsep="1"><Literal>void</Literal></Entry>
<Entry Rowsep="1">&mdash;</Entry>
<Entry Rowsep="1"><StructName Role="typedef">idl_void_p_t</StructName></Entry>
</Row>
<Row>
<Entry></Entry>
<Entry></Entry>
<Entry><StructName Role="typedef">handle_t</StructName></Entry>
<Entry>&mdash;</Entry>
<Entry>&mdash;</Entry>
</Row>
</TBody>
</TGroup>
</Table>
<?sml-space .5>
<Para>The base types are described individually later in this chapter.
<IndexTerm Id="DCEADG.RPCIDL.indx.96">
<Primary>idl_ macros</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.97">
<Primary>IDL</Primary>
<Secondary>idl_macros</Secondary>
</IndexTerm></Para>
<Para>Note that you can use the <Literal>idl_</Literal> macros in the code you write for
an application to ensure that your type declarations are consistent
with those in the stubs, even when the application is ported to
another platform.  The <Literal>idl_</Literal> macros are especially useful when
passing constant values to RPC calls.  For maximum portability, all
constants passed to RPC calls declared in your network interfaces
should be cast to the appropriate type because the size of integer
constants (like the size of the <Literal>int</Literal> data type) is ambiguous in
the C language.
</Para>
<Para>The <Literal>idl_</Literal> macros are defined in <Filename>dce/idlbase.h</Filename>, which 
is included by header files that the IDL compiler generates.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.39">
<Title>Constructed Type Specifiers</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.98">
<Primary>constructed type specifiers</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.99">
<Primary>type</Primary>
<Secondary>specifiers</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.100">
<Primary>IDL</Primary>
<Secondary>constructed type specifiers</Secondary>
</IndexTerm>
<Para>IDL constructed types include structures, unions, enumerations, 
pipes, arrays, and pointers. (In IDL, as in C, arrays and pointers
are specified via declarator constructs rather than type specifiers.)
Following are the keywords used to declare constructed type specifiers:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>struct
union
enum
pipe
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>Constructed types are described in detail later in this chapter.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.40">
<Title>Predefined Type Specifiers</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.101">
<Primary>predefined type specifiers</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.102">
<Primary>type</Primary>
<Secondary>specifiers</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.103">
<Primary>IDL</Primary>
<Secondary>predefined type specifiers</Secondary>
</IndexTerm>
<Para>While IDL per se does not have any predefined types, DCE RPC IDL 
implicitly imports <Filename>nbase.idl</Filename>, which does predefine some types.  
Specifically, <Filename>nbase.idl</Filename> predefines an error status type, 
several international character data types, and many other types.  
Following are the keywords used to declare these <Replaceable>predefined</Replaceable> type
specifiers:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>error_status_t
ISO_LATIN_1
ISO_MULTI_LINGUAL
ISO_UCS
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The error status type and international characters are described 
in detail later in this chapter.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.41">
<Title>Type Declarator</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.104">
<Primary>type</Primary>
<Secondary>declarators</Secondary>
</IndexTerm>
<Para>An IDL <Symbol Role="Variable">type_declarator</Symbol> can be either a simple declarator or 
a complex declarator.
</Para>
<Para>A simple declarator is just an identifier.
</Para>
<Para>A complex declarator is an identifier that specifies an 
array, a function pointer, or a pointer.
</Para>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.RPCIDL.div.42">
<Title>Operation Declarations</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.105">
<Primary>operation</Primary>
<Secondary>declaration</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.106">
<Primary>operations</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.107">
<Primary>IDL</Primary>
<Secondary>operation declaration</Secondary>
</IndexTerm>
<Para>The IDL <Symbol Role="Variable">operation_declaration</Symbol> can take the following forms:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">[</Symbol>[<Symbol Role="Variable">operation_attribute</Symbol><Literal>,</Literal> ...]<Symbol Role="Variable">] [</Symbol><Literal>static</Literal><Symbol Role="Variable">] type_specifier operation_identifier </Symbol><Literal>(</Literal><Symbol Role="Variable">parameter_declaration</Symbol><Literal>,</Literal> ...);

<Symbol Role="Variable">[</Symbol>[<Symbol Role="Variable">operation_attribute</Symbol><Literal>,</Literal> ...]<Symbol Role="Variable">] [</Symbol><Literal>static</Literal><Symbol Role="Variable">] type_specifier operation_identifier </Symbol><Literal>(</Literal><Symbol Role="Variable">[</Symbol><Literal>void</Literal><Symbol Role="Variable">]</Symbol><Literal>);</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>Use the first form for an operation that has one or more parameters;
use the second form for an operation that has no parameters.
<IndexTerm Id="DCEADG.RPCIDL.indx.108">
<Primary>static keyword</Primary>
</IndexTerm>Use the <Literal>static</Literal> keyword if the operation is a static member function 
of the interface class (C++ output only).
</Para>
<Para>An <Symbol Role="Variable">operation_attribute</Symbol> can take the following forms:
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>idempotent</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.109">
<Primary>idempotent attribute</Primary>
</IndexTerm>The operation is idempotent.
</Para>
</ListItem>
<ListItem>
<Para><Literal>broadcast</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.110">
<Primary>broadcast attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.111">
<Primary>broadcasting</Primary>
</IndexTerm>The operation is always
to be broadcast.
</Para>
</ListItem>
<ListItem>
<Para><Literal>maybe</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.112">
<Primary>maybe attribute</Primary>
</IndexTerm>The caller of the operation does
not require and will not receive any response.
</Para>
</ListItem>
<ListItem>
<Para><Literal>reflect_deletions</Literal>:
If <Function>rpc_ss_free()</Function> is applied by application code on the server side
to memory used for the referent of a full pointer that is part of an
<Literal>[in]</Literal> parameter, the storage occupied by that referent on the client side
is released.
</Para>
</ListItem>
<ListItem>
<Para><Literal>ptr</Literal>:
The operation returns a full pointer.
This attribute must be supplied if the operation returns a 
pointer result and reference pointers are the default
for the interface.
</Para>
</ListItem>
<ListItem>
<?sml-need 3>
<Para><Literal>context_handle</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.113">
<Primary>context_handle attribute</Primary>
</IndexTerm>The operation returns a context handle.
</Para>
</ListItem>
<ListItem>
<Para><Literal>string</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.114">
<Primary>string</Primary>
<Secondary>attribute</Secondary>
</IndexTerm>The operation returns a string.
</Para>
</ListItem>
</ItemizedList>
<IndexTerm Id="DCEADG.RPCIDL.indx.115">
<Primary>type</Primary>
<Secondary>specifiers</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.116">
<Primary>operations</Primary>
</IndexTerm>
<Para>The <Symbol Role="Variable">type_specifier</Symbol> in an operation declaration specifies
the data type that the operation returns, if any.  This type must be
either a scalar type or a previously defined type.  If the
operation does not return a result, its <Symbol Role="Variable">type_specifier</Symbol> must
be <Literal>void</Literal>.
<IndexTerm Id="DCEADG.RPCIDL.indx.117">
<Primary>operation</Primary>
<Secondary>declaration</Secondary>
</IndexTerm></Para>
<Para>For information on the semantics of pointers as operation return values, 
refer to the discussion of pointers in Section 18.14.7.
</Para>
<Para>The <Symbol Role="Variable">operation_identifier</Symbol> in an operation declaration is an
identifier that names the operation.
<IndexTerm Id="DCEADG.RPCIDL.indx.118">
<Primary>operations</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.119">
<Primary>parameters</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.120">
<Primary>IDL</Primary>
<Secondary>parameter declarations</Secondary>
</IndexTerm></Para>
<Para>Each <Symbol Role="Variable">parameter_declaration</Symbol> in an operation declaration declares
a parameter of the operation.  A <Symbol Role="Variable">parameter_declaration</Symbol> takes
the following form:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>[<Symbol Role="Variable">parameter_attribute</Symbol><Literal>,</Literal> ...] <Symbol Role="Variable">type_specifier parameter_declarator</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>Parameter declarations and the parameter attributes are described 
separately in the following sections.
</Para>
<Sect2 Id="DCEADG.RPCIDL.div.43">
<Title>Operation Attributes</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.121">
<Primary>operation</Primary>
<Secondary>attributes</Secondary>
</IndexTerm>
<Para>Operation attributes determine the semantics to be applied by the
RPC client and server protocol when an operation is called.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.44">
<Title>Operation Attributes: Execution Semantics</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.122">
<Primary>idempotent attribute</Primary>
</IndexTerm>
<Para>The <Literal>idempotent</Literal> attribute specifies that an operation is idempotent;
that is, it can safely be executed more than once.
</Para>
<IndexTerm Id="DCEADG.RPCIDL.indx.123">
<Primary>broadcast attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.124">
<Primary>broadcasting</Primary>
</IndexTerm>
<Para>The <Literal>broadcast</Literal> attribute specifies that an operation is to
be broadcast to all hosts on the local network each time the operation
is called.  The client receives output arguments from the first reply
to return successfully, and all subsequent replies are discarded.
</Para>
<Para>An operation with the <Literal>broadcast</Literal> attribute is implicitly idempotent.
</Para>
<Para>Note that the broadcast capabilities of RPC runtime have a number 
of distinct limitations:
</Para>
<ItemizedList>
<ListItem>
<Para>Not all systems and networks support broadcasting.  In particular,
broadcasting is not supported by the RPC connection-oriented
protocol.
</Para>
</ListItem>
<ListItem>
<Para>Broadcasts are limited to hosts on the local network.
</Para>
</ListItem>
<ListItem>
<Para>Broadcasts make inefficient use of network bandwidth and processor
cycles.  
</Para>
</ListItem>
<ListItem>
<Para>The RPC runtime library does not support <Literal>at-most-once</Literal>
semantics for broadcast operations; it applies <Literal>idempotent</Literal>
semantics to all such operations.
</Para>
</ListItem>
<ListItem>
<Para>The input arguments for broadcast calls are limited to
944 bytes.
</Para>
</ListItem>
</ItemizedList>
<IndexTerm Id="DCEADG.RPCIDL.indx.125">
<Primary>maybe attribute</Primary>
</IndexTerm>
<Para>The <Literal>maybe</Literal> attribute specifies that the caller of an operation
does not expect any response.  An operation with the <Literal>maybe</Literal>
attribute cannot have any output parameters and cannot return anything.
Delivery of the call is not guaranteed.
</Para>
<Para>An operation with the <Literal>maybe</Literal> attribute is implicitly idempotent.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.45">
<Title>Operation Attributes: Memory Management</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.126">
<Primary>reflect_deletions attribute</Primary>
</IndexTerm>
<Para>Use the <Literal>reflect_deletions</Literal> attribute to mirror the release of memory
from server pointer targets to client pointer targets.  When you use
the <Literal>reflect_deletions</Literal> attribute, memory occupied by pointer targets on the
client will be released when the corresponding pointer targets on the server are
released.  This is only true for pointer targets that are components of
<Literal>[in]</Literal> parameters of the operation.
By default, the mechanism used by RPC to release the pointer targets is the 
C language <Function>free()</Function>
function unless the client code is executing as part of RPC
server application code, in which case the <Literal>rpc_ss_free</Literal>()
function is used.  You can override the default by
calling <Literal>rpc_ss_set_client_alloc_free</Literal>() or <Literal>rpc_ss_swap_client_alloc_free</Literal>() before
the call to the remote operation.
</Para>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.RPCIDL.div.46">
<Title>Parameter Declarations</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.127">
<Primary>operation</Primary>
<Secondary>declaration</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.128">
<Primary>parameters</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.129">
<Primary>operations</Primary>
</IndexTerm>
<Para>A <Symbol Role="Variable">parameter_declaration</Symbol> is used in an operation declaration to 
declare a parameter of the operation.  A <Symbol Role="Variable">parameter_declaration</Symbol> 
takes the following form:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>[<Symbol Role="Variable">parameter_attribute</Symbol><Literal>,</Literal> ...] <Symbol Role="Variable">type_specifier parameter_declarator</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>If an interface does
not use implicit handles or use interface-based binding,
the first parameter must be an explicit handle that gives
the object UUID and location.  The handle parameter can be of a primitive
handle type, <StructName Role="typedef">handle_t</StructName>, or a nonprimitive user-defined handle type.
<IndexTerm Id="DCEADG.RPCIDL.indx.130">
<Primary>handle</Primary>
</IndexTerm></Para>
<Para>A <Symbol Role="Variable">parameter_attribute</Symbol> can be any of the following:
</Para>
<ItemizedList>
<ListItem>
<Para><Symbol Role="Variable">array_attribute</Symbol>:
<IndexTerm Id="DCEADG.RPCIDL.indx.131">
<Primary>array</Primary>
<Secondary>attributes</Secondary>
</IndexTerm>One of several attributes that
specifies the characteristics of arrays.
</Para>
</ListItem>
<ListItem>
<Para><Literal>in</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.132">
<Primary>in attribute</Primary>
</IndexTerm>The parameter is an input attribute.
</Para>
</ListItem>
<ListItem>
<Para><Literal>out</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.133">
<Primary>out attribute</Primary>
</IndexTerm>The parameter is an output attribute.
</Para>
</ListItem>
<ListItem>
<Para><Literal>ref</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.134">
<Primary>ref attribute</Primary>
</IndexTerm>The parameter is a reference pointer;
it cannot be NULL and cannot be an aliased pointer.
</Para>
</ListItem>
<ListItem>
<Para><Literal>ptr</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.135" SpanEnd="DCEADG.RPCIDL.indx.91">The parameter is a full pointer; it can be NULL and can be an
aliased pointer.
</Para>
</ListItem>
<ListItem>
<Para><Literal>unique</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.136" SpanEnd="DCEADG.RPCIDL.indx.92">The parameter is a unique pointer; it can be NULL.
</Para>
</ListItem>
<ListItem>
<Para><Literal>string</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.137">
<Primary>string</Primary>
<Secondary>attribute</Secondary>
</IndexTerm>The parameter is a string.
</Para>
</ListItem>
<ListItem>
<Para><Literal>context_handle</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.138">
<Primary>context_handle attribute</Primary>
</IndexTerm>The parameter is a context handle.
</Para>
</ListItem>
<ListItem>
<Para><Literal>switch_is</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.139">
<Primary>switch_is attribute</Primary>
</IndexTerm></Para>
</ListItem>
</ItemizedList>
<Para>The directional attributes <Literal>in</Literal> and <Literal>out</Literal> specify the
directions in which a parameter is to be passed.  The <Literal>in</Literal> attribute
specifies that the parameter is passed from the caller to the callee.
The <Literal>out</Literal> attribute specifies that the parameter is passed
from the callee to the caller.
</Para>
<Para>An output parameter must be passed
by reference and therefore must be declared with an explicit <Literal>*</Literal>
(asterisk).  (Note that an array is implicitly passed by reference 
and so an output array does not require an explicit <Literal>*</Literal>.) 
At least one directional attribute must be specified for each
parameter of an operation.
</Para>
<Para>An explicit handle parameter must have
at least the <Literal>in</Literal> attribute.
</Para>
<Para>The <Literal>ref, unique,</Literal> and <Literal>ptr</Literal> attributes are 
described later in Section 18.14.7. 
The <Literal>string</Literal> attribute is described in Section 18.14.6. 
The <Literal>context_handle</Literal> attribute is 
described in Section 18.14.9.1.
</Para>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.140">
<Primary>parameters</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.141">
<Primary>type</Primary>
<Secondary>specifiers</Secondary>
</IndexTerm>The <Symbol Role="Variable">type_specifier</Symbol> in a parameter declaration specifies the
data type of the parameter.
</Para>
<Para>The <Symbol Role="Variable">declarator</Symbol> in a parameter declaration can be any simple
or complex declarator.
</Para>
<Para>A parameter with the <Literal>out</Literal> attribute must be either an array
or an explicitly declared pointer.  An explicitly declared pointer
is declared by a <Symbol Role="Variable">pointer_declarator</Symbol>, rather than by a 
<Symbol Role="Variable">simple_declarator</Symbol> with a named pointer type as its <Symbol Role="Variable">type_specifier</Symbol>.
</Para>
<Para>For information on the semantics of pointers as operation parameters, 
refer to the discussion of pointers in Section 18.14.7.
<IndexTerm Id="DCEADG.RPCIDL.indx.142">
<Primary>directional attributes</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.143">
<Primary>in attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.144">
<Primary>out attribute</Primary>
</IndexTerm></Para>
</Sect1>
<Sect1 Id="DCEADG.RPCIDL.div.47">
<Title>Basic Data Types</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.145">
<Primary>IDL</Primary>
<Secondary>basic data types</Secondary>
</IndexTerm>
<Para>The following subsections describe the basic data types provided by 
IDL and the treatment of international characters 
within IDL.  The basic data types are as follows:
</Para>
<ItemizedList>
<ListItem>
<Para>Integer types
</Para>
</ListItem>
<ListItem>
<Para>Floating-point types
</Para>
</ListItem>
<ListItem>
<Para>The <Literal>char</Literal> type
</Para>
</ListItem>
<ListItem>
<Para>The <Literal>boolean</Literal> type
</Para>
</ListItem>
<ListItem>
<Para>The <Literal>byte</Literal> type
</Para>
</ListItem>
<ListItem>
<Para>The <Literal>void</Literal> type
</Para>
</ListItem>
<ListItem>
<Para>The <StructName Role="typedef">handle_t</StructName> type
</Para>
</ListItem>
<ListItem>
<Para>The <StructName Role="typedef">error_status_t</StructName> type
</Para>
</ListItem>
</ItemizedList>
<Para>Section 18.14 describes the constructed data types that are 
built on the basic data types.
</Para>
<Sect2 Id="DCEADG.RPCIDL.div.48">
<Title>Integer Types</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.146">
<Primary>integers</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.147">
<Primary>int type</Primary>
</IndexTerm>
<Para>IDL provides four sizes of signed and unsigned integer data types,
specified as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">int_size [</Symbol><Literal>int</Literal><Symbol Role="Variable">]</Symbol>
<Literal>unsigned</Literal> <Symbol Role="Variable">int_size [</Symbol><Literal>int</Literal><Symbol Role="Variable">]</Symbol>
<Symbol Role="Variable">int_size </Symbol><Literal>unsigned </Literal><Symbol Role="Variable">[</Symbol><Literal>int</Literal><Symbol Role="Variable">]
</Symbol></UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Symbol Role="Variable">int_size</Symbol> can take the following values:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>hyper
<IndexTerm Id="DCEADG.RPCIDL.indx.148">
<Primary>hyper type</Primary>
</IndexTerm>long
<IndexTerm Id="DCEADG.RPCIDL.indx.149">
<Primary>long type</Primary>
</IndexTerm>short
<IndexTerm Id="DCEADG.RPCIDL.indx.150">
<Primary>short type</Primary>
</IndexTerm>small
<IndexTerm Id="DCEADG.RPCIDL.indx.151">
<Primary>small type</Primary>
</IndexTerm></UserInput></ProgramListing></Para>
</InformalExample>
<Para>The<Literal> hyper</Literal> types are represented in 64 bits.  A <Literal>long</Literal>
is 32 bits.  A <Literal>short</Literal> is 16 bits.  A <Literal>small</Literal> is 8 bits.
</Para>
<Para>The
<IndexTerm Id="DCEADG.RPCIDL.indx.152">
<Primary>integers</Primary>
</IndexTerm>keyword <Literal>int</Literal> is optional and has
no effect.  The
<IndexTerm Id="DCEADG.RPCIDL.indx.153">
<Primary>unsigned integer types</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.154">
<Primary>IDL</Primary>
<Secondary>unsigned integer types</Secondary>
</IndexTerm>keyword <Literal>unsigned</Literal> denotes an unsigned integer type; it can 
occur either before or after the size keyword.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.49">
<Title>Floating-Point Types</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.155">
<Primary>floating-point numbers</Primary>
</IndexTerm>
<Para>IDL provides two sizes of floating-point data types, specified
as follows:
</Para>
<InformalExample>
<ProgramListing><UserInput>float</UserInput>
<UserInput>double</UserInput>
</ProgramListing>
</InformalExample>
<IndexTerm Id="DCEADG.RPCIDL.indx.156">
<Primary>float type</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.157">
<Primary>double type</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.158">
<Primary>IDL</Primary>
<Secondary>types</Secondary>
<See>types, IDL</See>
</IndexTerm>
<Para>
A <Literal>float</Literal> is represented in 32 bits.  A <Literal>double</Literal> is represented
in 64 bits.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.50">
<Title>The char Type</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.159">
<Primary>characters</Primary>
</IndexTerm>
<Para>The IDL character type is specified as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">[</Symbol><Literal>unsigned</Literal><Symbol Role="Variable">] </Symbol><Literal>char</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>A<Literal> char</Literal> is unsigned and is represented in 8 bits.
</Para>
<Para>The keyword <Literal>unsigned</Literal> is optional and has no effect.  IDL does
not support a signed character type.  IDL provides the <Literal>small</Literal> 
data type for representing signed 8-bit integers.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.51">
<Title>The boolean Type</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.160">
<Primary>IDL</Primary>
<Secondary>boolean type</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.161">
<Primary>boolean type</Primary>
</IndexTerm>
<Para>The IDL <Literal>boolean</Literal> type is specified as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>boolean
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>A <Literal>boolean</Literal> is represented in 8 bits.  A <Literal>boolean</Literal> is
a logical quantity that assumes one of two values: 
TRUE or FALSE.
Zero is FALSE and any nonzero value is TRUE.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.52">
<Title>The byte Type</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.162">
<Primary>IDL</Primary>
<Secondary>byte type</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.163">
<Primary>byte type</Primary>
</IndexTerm>
<Para>The IDL <Literal>byte</Literal> type is specified as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>byte</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>A<Literal> byte</Literal> is represented in 8 bits.  The data representation
format of <Literal>byte</Literal> data is guaranteed not to change when the
data is transmitted by the RPC mechanism.
</Para>
<Para>The IDL integer, character, and floating-point types (and hence
any types constructed from these) are all subject to format conversion
when they are transmitted between hosts that use
different data representation formats.  You can protect data
of any type from format conversion by transmitting that type as an
array of <Literal>byte</Literal>.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.53">
<Title>The void Type</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.164">
<Primary>void type</Primary>
</IndexTerm>
<Para>The IDL <Literal>void</Literal> type is specified as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>void</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Literal>void</Literal> type may be used to do the following:
</Para>
<ItemizedList>
<ListItem>
<Para>Specify the type of an operation that does not
return a value
</Para>
</ListItem>
<ListItem>
<Para>Specify the type of a context handle parameter,
which must be <Literal>void*</Literal>
</Para>
</ListItem>
<ListItem>
<Para>Specify the type of a NULL pointer constant, which
must be <Literal>void*</Literal>
</Para>
</ListItem>
</ItemizedList>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.54">
<Title>The handle_t Type</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.165">
<Primary>handle_t type</Primary>
</IndexTerm>
<Para>The IDL primitive handle type is specified as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><StructName Role="typedef">handle_t</StructName>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>A <StructName Role="typedef">handle_t</StructName> is a primitive handle type that is opaque to application
programs but meaningful to the RPC runtime library.  Section 18.14.8
discusses primitive and nonprimitive handle types.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.55">
<Title>The error_status_t Type</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.166">
<Primary>error_status_t type</Primary>
</IndexTerm>
<Para>IDL provides the following 
predefined data type to hold RPC communications status
information:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><StructName Role="typedef">error_status_t</StructName>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The values that can be contained in the <StructName Role="typedef">error_status_t</StructName> data type
are compatible with the <Literal>unsigned long</Literal> and <Literal>unsigned32</Literal> IDL data types.
These data types are used for status values in the DCE.
</Para>
<Para><?sml-need 8>The
<StructName Role="typedef">error_status_t</StructName> data type contains an additional semantic to indicate that
this particular <Literal>unsigned long</Literal> contains a DCE format error status value.
This additional semantic enables the IDL compiler to perform any
necessary translation when moving the status value between systems
with differing hardware architectures and software operating systems.
If you are using status codes that are not in the DCE error status format
or if you do not require such conversion, use an <Literal>unsigned long</Literal> instead
of <StructName Role="typedef">error_status_t</StructName>.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.56">
<Title>International Characters</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.167">
<Primary>international characters</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.168">
<Primary>IDL</Primary>
<Secondary>international characters</Secondary>
</IndexTerm>
<Para>The implicitly imported <Filename>nbase.idl</Filename> 
provides predefined data types to support present and emerging
international standards for the representation of characters and strings:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>ISO_LATIN_1
ISO_MULTI_LINGUAL
ISO_UCS
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>Data of type <Literal>char</Literal> is subject to ASCII-EBCDIC conversion
when transmitted by the RPC mechanism.  The predefined international
character types are constructed from the base type <Literal>byte</Literal> and
are thereby protected from data representation format conversion.
</Para>
<Para>The <Literal>ISO_LATIN_1</Literal> type is represented in 8 bits and is predefined
as follows:
</Para>
<InformalExample>
<Para><ProgramListing>typedef byte ISO_LATIN_1;
</ProgramListing></Para>
</InformalExample>
<Para>The <Literal>ISO_MULTI_LINGUAL</Literal> type is represented in 16 bits and
is predefined as follows:
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct {
     byte row, column;
     } ISO_MULTI_LINGUAL;
</ProgramListing></Para>
</InformalExample>
<Para>The <Literal>ISO_UCS</Literal> type is represented in 32 bits and is predefined
as follows:
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct {
     byte group, plane, row, column;
     } ISO_UCS;
</ProgramListing></Para>
</InformalExample>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.RPCIDL.div.57">
<Title>Constructed Data Types</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.169">
<Primary>IDL</Primary>
<Secondary>constructed types</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.170">
<Primary>constructed data types</Primary>
</IndexTerm>
<Para>The following subsections describe the constructed data types that are 
provided by IDL.  The constructed types are built on the basic 
data types, which are described in Section 18.13.  
The constructed data types are as follows:
</Para>
<ItemizedList>
<ListItem>
<Para>Structures
</Para>
</ListItem>
<ListItem>
<Para>Unions
</Para>
</ListItem>
<ListItem>
<Para>Enumerations
</Para>
</ListItem>
<ListItem>
<Para>Pipes
</Para>
</ListItem>
<ListItem>
<Para>Arrays
</Para>
</ListItem>
<ListItem>
<Para>Strings
</Para>
</ListItem>
</ItemizedList>
<Para>In IDL, as in C, arrays and pointers are specified via 
declarator constructs.  The other constructed types are 
specified via type specifiers.
</Para>
<Sect2 Id="DCEADG.RPCIDL.div.58">
<Title>Structures</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.171">
<Primary>structure member attributes</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.172">
<Primary>IDL</Primary>
<Secondary>structures</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.173">
<Primary>struct type</Primary>
</IndexTerm>
<Para>The <Symbol Role="Variable">type_specifier</Symbol> for a structure type can take the following
forms:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>struct </Literal><Symbol Role="Variable">[tag]
 </Symbol><Literal>{</Literal>
 <Symbol Role="Variable">struct_member</Symbol><Literal>;</Literal>
 ...
 <Literal>}

struct </Literal><Symbol Role="Variable">tag</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>A <Symbol Role="Variable">tag</Symbol>, if supplied in a specifier of the first form, becomes
a shorthand form for the set of member declarations that follows it.  Such
a <Symbol Role="Variable">tag</Symbol> can subsequently be used in a specifier of the second
form.
</Para>
<Para>A <Symbol Role="Variable">struct_member</Symbol> takes the following form:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">[</Symbol>[<Symbol Role="Variable">struct_member_attribute</Symbol><Literal>,</Literal> ...]<Symbol Role="Variable">] type_specifier declarator</Symbol><Literal>,</Literal> ...<Literal>;</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>A <Symbol Role="Variable">struct_member_attribute</Symbol> can be any of the following:
</Para>
<ItemizedList>
<ListItem>
<Para><Symbol Role="Variable">array_attribute</Symbol>:
<IndexTerm Id="DCEADG.RPCIDL.indx.174">
<Primary>array</Primary>
<Secondary>attributes</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.175">
<Primary>IDL</Primary>
<Secondary>array attributes</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.176">
<Primary>array_attribute attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.177">
<Primary>attributes</Primary>
<Secondary>array_attribute</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.178">
<Primary>attributes</Primary>
<Secondary>array</Secondary>
<See>arrays</See>
</IndexTerm>One of several attributes
that specify characteristics of arrays.
</Para>
</ListItem>
<ListItem>
<Para><Literal>ignore</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.179">
<Primary>ignore attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.180">
<Primary>attributes</Primary>
<Secondary>ignore</Secondary>
</IndexTerm>An attribute indicating
that the pointer member being declared is not to be transmitted
in remote procedure calls.
</Para>
</ListItem>
<ListItem>
<Para><Literal>ref</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.181">
<Primary>ref attribute</Primary>
</IndexTerm>An attribute indicating that
the pointer member being declared is a reference pointer; it cannot
be NULL and cannot be an alias.
</Para>
</ListItem>
<ListItem>
<Para><Literal>ptr</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.182">
<Primary>ptr attribute</Primary>
</IndexTerm>An attribute indicating that
the pointer member being declared is a full pointer; 
it can be NULL and can be an alias.
</Para>
</ListItem>
<ListItem>
<Para><Literal>unique</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.183">
<Primary>unique attribute</Primary>
</IndexTerm>An attribute indicating that
the pointer member being declared is a unique pointer.
</Para>
</ListItem>
<ListItem>
<Para><Literal>string</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.184">
<Primary>string</Primary>
<Secondary>attribute</Secondary>
</IndexTerm>An attribute indicating that
the array member being declared is a string.
</Para>
</ListItem>
<ListItem>
<Para><Literal>switch_is</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.185">
<Primary>switch_is attribute</Primary>
</IndexTerm></Para>
</ListItem>
</ItemizedList>
<Para>A structure can contain a conformant array (conformant structure) 
only as its last member.
And such a structure can be contained by another structure only as its
last member, and so on. 
A conformant structure cannot be returned by an operation as its value
and cannot be simply an <Literal>out</Literal> parameter.
Note that a structure can contain any number of <Replaceable>pointer to</Replaceable>
conformant arrays.
Structure fields defined as pointers to an array base type and with
one or more of the array size attributes define pointers to conformant
arrays.  Since the size of the pointer field in the structure is
fixed, the structure itself is not conformant, although the array that
it points to is conformant.
</Para>
<Para>A structure cannot contain a pipe or context handle.
</Para>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.186">
<Primary>ignore attribute</Primary>
</IndexTerm>The <Literal>ignore</Literal> attribute specifies that
the pointer is not to be transmitted in remote procedure calls.
Note that the <Literal>ignore</Literal> attribute can be applied only to a pointer that
is a member of a structure.  The <Literal>ignore</Literal> attribute is not allowed
in a type declaration that defines a pointer type.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.59">
<Title>Unions</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.187" SpanEnd="DCEADG.RPCIDL.indx.83">
<IndexTerm Id="DCEADG.RPCIDL.indx.188">
<Primary>unions</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.189">
<Primary>IDL</Primary>
<Secondary>unions</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.190">
<Primary>union type</Primary>
</IndexTerm>
<Para>IDL provides two types of unions: encapsulated and nonencapsulated. 
An IDL union must be discriminated.  In an encapsulated union, the
discriminator is part of the union.  In a nonencapsulated union, the
discriminator is not part of the union.
</Para>
<Para>The following <Symbol Role="Variable">type_specifier</Symbol> can be used to indicate either kind of
union.
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>union </Literal><Symbol Role="Variable">[tag]</Symbol> 
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>A definition of the union identified by <Symbol Role="Variable">tag</Symbol> must appear elsewhere in the
interface definition.
</Para>
<Sect3 Id="DCEADG.RPCIDL.div.60">
<Title>Encapsulated Unions</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.191">
<Primary>encapsulated unions</Primary>
</IndexTerm>
<Para>To define an encapsulated union, use the following syntax:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>union </Literal><Symbol Role="Variable">[tag]</Symbol> <Literal>switch</Literal> <Symbol Role="Variable">(disc_type_spec discriminator)</Symbol> <Symbol Role="Variable">[union_name</Symbol>]
<Literal>{</Literal>
 <Symbol Role="Variable">case
 </Symbol>...
 <Symbol Role="Variable">[default_case]
 </Symbol><Literal>}
</Literal></UserInput></ProgramListing></Para>
</InformalExample>
<Para>If a <Symbol Role="Variable">tag</Symbol> is supplied, it can be used in a <Symbol Role="Variable">type_specifier</Symbol> of the form
shown in Section 18.14.2.
</Para>
<Para>The <Symbol Role="Variable">disc_type_spec</Symbol> indicates the type of the <Symbol Role="Variable">discriminator</Symbol>,
which can be an integer, a character, a <Literal>boolean</Literal>, or an enumeration.
</Para>
<Para>The <Symbol Role="Variable">union_name</Symbol> specifies a name to be used in C code generated
by the IDL compiler.  When the IDL compiler generates C code to represent
an IDL union, it embeds the union and its discriminator in a C structure.
The name of the IDL union becomes the name of the C structure.  If
you supply a <Symbol Role="Variable">union_name</Symbol> in your type declaration, the compiler
assigns this name to the embedded C union; otherwise, the compiler
assigns the generic name <Literal>tagged_union</Literal>.
</Para>
<Para>A <Symbol Role="Variable">case</Symbol> contains one or more labels and may contain a member
declaration:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>case </Literal><Replaceable>constant</Replaceable><Literal>:</Literal>
... 
<Replaceable>[union_member]</Replaceable><Literal>;</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>Each label in a <Symbol Role="Variable">case</Symbol> specifies a constant.  The <Symbol Role="Variable">constant</Symbol> can
take any of the forms accepted in an integer, character, or Boolean
constant declaration, each of which is described earlier 
in this chapter.
</Para>
<Para>A <Symbol Role="Variable">default_case</Symbol> can be coded anywhere in the list of cases:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>default</Literal><Literal>:</Literal>
<Symbol Role="Variable">[union_member]</Symbol><Literal>;</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>A <Symbol Role="Variable">union_member</Symbol> takes the following form:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">[</Symbol>[<Symbol Role="Variable">union_member_attribute</Symbol><Literal>,</Literal> ...]<Symbol Role="Variable">] type_specifier declarator</Symbol><Literal>;</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>A <Symbol Role="Variable">union_member_attribute</Symbol> can be any of the following:
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>ptr</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.192">
<Primary>ptr attribute</Primary>
</IndexTerm>An attribute indicating that
the pointer member being declared is a full pointer; 
it can be NULL and can be an alias.
</Para>
</ListItem>
<ListItem>
<Para><Literal>string</Literal>:
<IndexTerm Id="DCEADG.RPCIDL.indx.193">
<Primary>string</Primary>
<Secondary>attribute</Secondary>
</IndexTerm>An attribute indicating that
the character array member being declared is a string.
</Para>
</ListItem>
</ItemizedList>
<Para>In any union, the type of the discriminator and the type of all constants
in all case labels must resolve to the same type.  At the time the
union is used, the value of the discriminator selects a member, as
follows:
</Para>
<ItemizedList>
<ListItem>
<Para>If the value of the discriminator matches the constant
in any label, the member associated with the label
is selected.
</Para>
</ListItem>
<ListItem>
<Para>If there is no label whose constant matches the value
of the discriminator and there is a default case, the default member
is selected.
</Para>
</ListItem>
<ListItem>
<Para>If there is no label whose constant matches the value
of the discriminator and there is no default case, no member is selected
and the exception <Literal>rpc_x_invalid_tag</Literal> is raised.
</Para>
</ListItem>
</ItemizedList>
<Para>Note that IDL prohibits duplicate constant label values.
</Para>
<Para>A <Symbol Role="Variable">union</Symbol>_<Symbol Role="Variable">member</Symbol> can contain only one declarator.
If no <Symbol Role="Variable">union_member</Symbol> is supplied, the member is NULL; if
that member is selected when the union is used, no data is passed.  
But note that the discriminator is always passed.
</Para>
<Para>A union cannot contain a pipe, a conformant array, a varying array,
or any structure that contains a conformant or varying array.
A union also cannot contain a <Literal>ref</Literal> or <Literal>unique</Literal> pointer or any 
structure that contains a <Literal>ref</Literal> or <Literal>unique</Literal> pointer.
</Para>
<Para>The following is an example of an encapsulated union.
</Para>
<InformalExample>
<Para><ProgramListing>/* IDL construct /*

   typedef
       union fred switch (long a) ralph {
            case 1: float b;
            case 2: long c;
       } bill;

/* becomes in the generated header file /*

  typedef
      struct fred {
          long a;
          union {
              float b;
              long c;
          } ralph;
      } bill;
</ProgramListing></Para>
</InformalExample>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.61" RevisionFlag="Changed">
<Title>Nonencapsulated Unions</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.194">
<Primary>nonencapsulated union</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.195">
<Primary>union</Primary>
<Secondary>nonencapsulated</Secondary>
</IndexTerm>
<Para>To define a nonencapsulated union, use the following syntax:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">[switch_type(datatype)]</Symbol> <Literal>union</Literal> <Symbol Role="Variable">[tag]</Symbol>
<Literal>{</Literal>
 <Symbol Role="Variable">case
 </Symbol>...
 <Symbol Role="Variable">[default_case]
 </Symbol><Literal>}
</Literal></UserInput></ProgramListing></Para>
</InformalExample>
<Para>If a <Symbol Role="Variable">tag</Symbol> is supplied, it can be used in a <Symbol Role="Variable">type_specifier</Symbol> of the form
shown in Section 18.14.2.
</Para>
<Para>A parameter or a structure field that is a nonencapsulated union must have an
attribute attached to it.  This attribute has the following form:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>switch_is</Literal>(<Symbol Role="Variable">attr_var</Symbol>)
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>where <Symbol Role="Variable">attr_var</Symbol> is the name of the parameter or structure field that is the
discriminator for the union.
</Para>
<Para>If a nonencapsulated union is used as a structure field, the discriminator of
the union must be a field of the same structure.  If a nonencapsulated union is
used as a parameter of an operation, the discriminator must be another
parameter of the same operation.
</Para>
<Para>The following example shows uses of a nonencapsulated union.
</Para>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.196">
<Primary>nonencapsulated union</Primary>
<Secondary>code example</Secondary>
</IndexTerm></Para>
<InformalExample>
<Para><ProgramListing>typedef 
  [switch_type(long)] union {
    [case (1,3)] float a_float;
    [case (2)] short b_short;
    [default] ; /* An empty arm.  Nothing is shipped. */
  } n_e_union_t;

typedef
  struct {
    long a; /* The discriminant for the    */
	    /* union later in this struct. */
    [switch_is (a)] n_e_union_t b;
  } a_struct;

/* Note switch can follow union in operation */
void op1 (
   [in] handle_t h,
   [in,switch_is (s)] n_e_union_t u,
   [in] long s  );
</ProgramListing></Para>
</InformalExample>
<?sml-break>
<?sml-need 20>
<?og-ChangeStart def,13492,R1.2.2,idl info missing from guide">
</Sect3>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.62">
<Title RevisionFlag="Changed">Enumeration</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.197">
<Primary RevisionFlag="Changed">enumeration</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.198">
<Primary RevisionFlag="Changed">IDL</Primary>
<Secondary RevisionFlag="Changed">enumerations</Secondary>
</IndexTerm>
<Para RevisionFlag="Changed">An IDL enumeration provides names for integers.  It is specified as
follows:
</Para>
<InformalExample>
<Para><ProgramListing><Literal RevisionFlag="Changed">enum {</Literal><Replaceable RevisionFlag="Changed">identifier[</Replaceable>= <Replaceable RevisionFlag="Changed">integer], ...</Replaceable><Literal RevisionFlag="Changed">}</Literal>
</ProgramListing></Para>
</InformalExample>
<Para RevisionFlag="Changed">Each identifier in an enumeration is assigned an integer, either
explicitly in the interface or automatically by the IDL compiler.  If
all the identifiers are unassigned, the IDL compiler begins assigning
0 (zero) to the first identifier, 1 to the next identifier, and so on.
If an unassigned identifier follows an assigned one, the compiler
restarts number assignment with the next consecutive integer.  An
enumeration can have up to 32,767 identifiers.
</Para>
<Para RevisionFlag="Changed">Assignments can be made in any order, and multiple identifiers can
have the same value. For example:
</Para>
<InformalExample>
<Para><ProgramListing RevisionFlag="Changed">typedef  enum {
	SHOVEL = 9, AX, MATTOCK = 3, PITCHFORK, SPADE = 9
	} yard_tools;
/* values assigned: SHOVEL:9, AX:10, MATTOCK:3, PITCHFORK:4, */
/* SPADE:9                                                   */
</ProgramListing></Para>
</InformalExample>
<?og-ChangeEnd def,13492,R1.2.2,idl info missing from guide">
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.63">
<Title>Pipes</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.199">
<Primary>pipes</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.200">
<Primary>IDL</Primary>
<Secondary>pipes</Secondary>
</IndexTerm>
<Para>IDL supports pipes as a mechanism for transferring large quantities of
typed data.  An IDL pipe is an open-ended sequence of elements of one
type.  A pipe permits application-level optimization of bulk data
transfer by allowing the overlap of communication and processing.
Applications that process a stream of data as it arrives, rather than
simply storing the data in memory, can make efficient use of the pipe
mechanism.
</Para>
<Para>A pipe is specified as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>pipe</Literal> <Symbol Role="Variable">type_specifier</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Symbol Role="Variable">type_specifier</Symbol> specifies the type for the elements of
the pipe.  This type cannot be a pointer type, a type
that contains a pointer, a conformant type, a context
handle, a <StructName Role="typedef">handle_t</StructName> element type, 
or a data type that is declared as <Literal>transmit_as</Literal>. 
</Para>
<Para>A pipe type can be used to declare only the type of an operation parameter.  
IDL recognizes three kinds of pipes, based on the three operation parameters:
</Para>
<ItemizedList>
<ListItem>
<Para>An <Literal>in</Literal> pipe is for transferring data from a client to a server.  It 
allows the callee (server) to pull an open-ended stream of typed data 
from the caller (client).  
</Para>
</ListItem>
<ListItem>
<?sml-need 5>
<Para>An <Literal>out</Literal> pipe is for transferring data from a server to a client.  
It allows the callee (server) to push the stream of data to 
the caller (client).
</Para>
</ListItem>
<ListItem>
<Para>An <Literal>in,out</Literal> pipe provides for two-way data transfer between a client 
and server by combining the behavior of <Literal>in</Literal> and <Literal>out</Literal> pipes.
</Para>
</ListItem>
</ItemizedList>
<Para>A pipe can be defined only through a <Literal>typedef</Literal> 
declaration.  Anonymous pipe types are not supported.
</Para>
<Para>At the interface between the stub and the application-specific code
(for both the client and server), 
a pipe appears as a simple callback mechanism.  To the user
code, the processing of a pipe parameter appears to be synchronous.
The IDL implementation of pipes in the RPC stub and runtime allows the
apparent callbacks to occur without requiring actual remote callbacks.
As a result, pipes provide an efficient transfer mechanism for large
amounts of data.
</Para>
<Para>Note however, that pipe data communications occur at about the
same speed as arrays.  Pipes can improve latency and minimum memory
utilization, but not throughput.  Pipes are intended for use where the
receiver can process the data in some way as it arrives, for example
by writing it to a file or passing it to a consumer thread.  If the
intent is to store the data in memory for later processing, pipes
offer no advantage over arrays.
</Para>
<Sect3 Id="DCEADG.RPCIDL.div.64">
<Title>IDL Pipes Example</Title>
<Para>To illustrate the IDL implementation of pipes, consider the following 
IDL fragment:
</Para>
<InformalExample>
<Para><ProgramListing>typedef
   pipe element_t pipe_t;
</ProgramListing></Para>
</InformalExample>
<Para>When the code containing this fragment is compiled, the IDL compiler 
will generate the following declarations in the derived header file:
</Para>
<InformalExample>
<Para><ProgramListing><?sml-need 20>typedef struct pipe_t {
    void (* pull)(
       rpc_ss_pipe_state_t state,
       element_t *buf,
       idl_ulong_int esize,
       idl_ulong_int *ecount
    );
   void (* push)(
      rpc_ss_pipe_state_t state,
      element_t *buf,
      idl_ulong_int  ecount
   );
   void (* alloc)(
      rpc_ss_pipe_state_t state,
      idl_ulong_int bsize,
      element_t **buf,
      idl_ulong_int *bcount
   );
   rpc_ss_pipe_state_t state;
} pipe_t;
</ProgramListing></Para>
</InformalExample>
<Para>The pipe data structure specifies pointers to three separate routines and a
pipe state.
The client application has to implement these routines for the client
stub to call, and the server manager must call the associated
routines generated in the server stub.
</Para>
<Para>The <Literal>pull</Literal> routine is used for an input pipe.  
It pulls the next chunk of data from the client application into the pipe.
The input parameters include the pipe <Literal>state</Literal>, 
the buffer (<Literal>*buf</Literal>) containing a chunk of data, 
and the size of the buffer (<Literal>esize</Literal>) in terms of the number of
pipe data elements.
The output parameter is the actual count (<Literal>*ecount</Literal>) of the 
number of pipe data elements in the buffer.
</Para>
<Para>The <Literal>push</Literal> routine is used for an output pipe.  
It pushes the next chunk of data from the pipe to the client application.
The input parameters include the pipe <Literal>state</Literal>,
the buffer (<Literal>*buf</Literal>) containing a chunk of data,
and a count (<Literal>ecount</Literal>) of the number of pipe data elements in the buffer. 
</Para>
<Para><?sml-need 9>The <Literal>alloc</Literal> routine allocates a buffer for the pipe data.
The input parameters include the pipe <Literal>state</Literal> and
the requested size of the buffer (<Literal>bsize</Literal>) in bytes.
The output parameters include a pointer to the allocated buffer (<Literal>**buf</Literal>),
and the actual count (<Literal>bcount</Literal>) of the number of bytes in the buffer.
The routine allocates memory from which pipe data 
can be marshalled or into which pipe data can be marshalled. 
If less memory is allocated than requested, 
the RPC runtime uses the smaller 
memory and makes more callbacks to the user.  If the routine allocates 
more memory than requested, the excess memory is not used.
</Para>
<Para>Finally, the <Literal>state</Literal> is used to coordinate between these routines.
</Para>
<Para>For more on how to write the code for the client and server manager,
see Chapter 17.
</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.65">
<Title>Rules for Using Pipes</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.201" SpanEnd="DCEADG.RPCIDL.indx.199">
<IndexTerm Id="DCEADG.RPCIDL.indx.202" SpanEnd="DCEADG.RPCIDL.indx.200">
<Para>Observe the following rules when defining pipes in IDL:
</Para>
<ItemizedList>
<ListItem>
<Para>Pipe types must only be parameters.  In other words, 
pipes of pipes, arrays of pipes, and structures or unions containing 
pipes as members are illegal.
</Para>
</ListItem>
<ListItem>
<Para>A pipe cannot be a function result.
</Para>
</ListItem>
<ListItem>
<Para>The element type of a pipe cannot be a pointer or contain a pointer. 
</Para>
</ListItem>
<ListItem>
<Para>The element type of a pipe cannot be a <Literal>context_handle</Literal> or 
<StructName Role="typedef">handle_t</StructName> type. 
</Para>
</ListItem>
<ListItem>
<Para>A pipe type cannot be used in the definition of another type.  
For example, the following code fragment is illegal:
</Para>
<InformalExample>
<Para><ProgramListing>typedef
   pipe char pipe_t;

typedef
   pipe_t * pipe_p_t;
</ProgramListing></Para>
</InformalExample>
</ListItem>
<ListItem>
<Para>A pipe type cannot have the <Literal>transmit_as</Literal> attribute. 
</Para>
</ListItem>
<ListItem>
<Para>The element type of a pipe cannot 
have the <Literal>transmit_as</Literal> attribute. 
</Para>
</ListItem>
<ListItem>
<?sml-need 3>
<Para>A pipe parameter can be passed by value or by reference.  
A pipe that is passed by reference (that is, has an <Literal>*</Literal> (asterisk)) 
cannot have the <Literal>ptr</Literal> or <Literal>unique</Literal> parameter 
attributes.
</Para>
</ListItem>
<ListItem>
<Para>Pipes that pass data from the client to the server must be processed 
in the order in which they occur in an operation's signature.  All such 
pipes must be processed before data is sent from the server to the 
client.
</Para>
</ListItem>
<ListItem>
<Para>Pipes that pass data from the server to the client must be processed 
in the order in which they occur in an operation's signature.  No such 
pipes must be processed until all data has been sent from the client to the 
server. 
</Para>
</ListItem>
<ListItem>
<Para>Manager routines must reraise RPC pipe and communications
exceptions so that client stub code and server stub code
continue to execute properly.
</Para>
<Para>For example, consider an interface that has an
<Literal>out</Literal> pipe along with other <Literal>out</Literal>
parameters.  Suppose that the following sequence of
events occurs:
</Para>
<ItemizedList>
<ListItem>
<Para>The manager routine closes the pipe by writing an empty chunk whose
length is 0 (zero).
</Para>
</ListItem>
<ListItem>
<Para>The manager routine attempts to write another chunk of data to the pipe.
</Para>
</ListItem>
<ListItem>
<Para>The generated <Literal>push</Literal> routine raises the exception
<Literal>rpc_x_fault_pipe_closed</Literal>.
</Para>
</ListItem>
<ListItem>
<Para>The manager routine catches the exception and does not reraise it.
</Para>
</ListItem>
<ListItem>
<Para>The manager routine exits normally.
</Para>
</ListItem>
<ListItem>
<Para>The server stub attempts to marshall the <Literal>out</Literal> parameters.
</Para>
</ListItem>
</ItemizedList>
<Para>After this sequence, neither the server stub nor the client stub
can continue to execute properly.
</Para>
<Para>To avoid this situation, you <Symbol Role="Variable">must</Symbol> reraise the exception. 
</Para>
</ListItem>
<ListItem>
<Para>A pipe cannot be used in an operation that has the 
<Literal>broadcast</Literal> or <Literal>idempotent</Literal> attribute. 
</Para>
</ListItem>
<ListItem>
<Para>The element type of a pipe cannot be a conformant structure.
</Para>
</ListItem>
<ListItem>
<Para>The maximum length of pipe type IDs is 29 characters. 
</Para>
</ListItem>
</ItemizedList>
</Sect3>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.66">
<Title>Arrays</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.203">
<Primary>IDL</Primary>
<Secondary>array</Secondary>
<See>array</See>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.204">
<Primary>array</Primary>
</IndexTerm>
<Para>IDL supports the following types of arrays:
</Para>
<ItemizedList>
<ListItem>
<Para>Fixed: The size of the array is defined in IDL 
and all of the data in the array is transferred during the call.
<!-- DCE 1.2 WRITER: changed "defined in the IDL"-->
<!-- above to                "defined in IDL"-->
<!-- should it be            "defined in the IDL file?"-->
<!-- Pls verify this change-->
<IndexTerm Id="DCEADG.RPCIDL.indx.205">
<Primary>IDL</Primary>
<Secondary>array</Secondary>
<Tertiary>fixed</Tertiary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.206">
<Primary>array</Primary>
<Secondary>fixed</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.207">
<Primary>fixed array</Primary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para>Conformant: The size of the array is determined at runtime.
At least one bound of the array is determined at runtime by a value
referenced through a  
<Literal>min_is</Literal>, <Literal>max_is</Literal>, or <Literal>size_is</Literal> attribute.  All of the 
data in the array is transferred during the call.
<IndexTerm Id="DCEADG.RPCIDL.indx.208">
<Primary>IDL</Primary>
<Secondary>array</Secondary>
<Tertiary>conformant</Tertiary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.209">
<Primary>array</Primary>
<Secondary>conformant</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.210">
<Primary>conformant array</Primary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para>Varying: The size of the array is defined in IDL 
but the part of its contents transferred during the call is determined 
by the values of fields or parameters named in one or more data 
limit attributes.  The data limit attributes are <Literal>first_is</Literal>, 
<Literal>length_is</Literal>, and <Literal>last_is</Literal>.
<!-- DCE 1.2 WRITER: changed "defined in the IDL"-->
<!-- above to                "defined in IDL"-->
<!-- should it be            "defined in the IDL file?"-->
<!-- Pls verify this change-->
<IndexTerm Id="DCEADG.RPCIDL.indx.211">
<Primary>IDL</Primary>
<Secondary>array</Secondary>
<Tertiary>varying</Tertiary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.212">
<Primary>array</Primary>
<Secondary>varying</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.213">
<Primary>varying array</Primary>
</IndexTerm></Para>
</ListItem>
</ItemizedList>
<Para>An array can also be both conformant and varying (or, as it is sometimes
termed, <FirstTerm>open</FirstTerm>).
<IndexTerm Id="DCEADG.RPCIDL.indx.214">
<Primary>IDL</Primary>
<Secondary>array</Secondary>
<Tertiary>conformant and varying</Tertiary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.215">
<Primary>array</Primary>
<Secondary>conformant and varying</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.216">
<Primary>conformant and varying array</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.217">
<Primary>varying and conformant array</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.218">
<Primary>IDL</Primary>
<Secondary>array</Secondary>
<Tertiary>open</Tertiary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.219">
<Primary>array</Primary>
<Secondary>open</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.220">
<Primary>open array</Primary>
</IndexTerm>In this case, the size of the array is determined at 
runtime by the value of the field or parameter referenced by the 
<Literal>min_is</Literal>, <Literal>max_is</Literal> or <Literal>size_is</Literal> attributes.  The part of its 
contents transferred during the call is determined by the values of fields
or parameters named in one or more of the data limit attributes.
</Para>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.221">
<Primary>array</Primary>
<Secondary>array_declarator</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.222">
<Primary>array_declarator</Primary>
</IndexTerm>
An IDL array is declared via an <Symbol Role="Variable">array_declarator</Symbol>
construct whose syntax is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">array_identifier array_bounds_declarator </Symbol>...
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>An <Symbol Role="Variable">array_bounds_declarator</Symbol> must be specified for each dimension
of an array.
</Para>
<Sect3 Id="DCEADG.RPCIDL.div.67">
<Title>Array Bounds</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.223">
<Primary>array</Primary>
<Secondary>bounds</Secondary>
</IndexTerm>
<Para>The <Symbol Role="Variable">array_bounds_declarator</Symbol> for the first dimension of an
array can take any of the following forms:
</Para>
<VariableList>
<VarListEntry role="linebreak">
<Term><Literal>[</Literal><Symbol Role="Variable">lower </Symbol><Literal>.. </Literal><Symbol Role="Variable">upper</Symbol><Literal>]</Literal></Term>
<ListItem>
<Para>The lower bound
is <Symbol Role="Variable">lower</Symbol>.  The upper bound is <Symbol Role="Variable">upper</Symbol>.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>[</Literal><Symbol Role="Variable">size</Symbol><Literal>]</Literal></Term>
<ListItem>
<Para>The lower bound is 0 (zero).  The upper
bound is <Symbol Role="Variable">size</Symbol> &minus;&ensp;1.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>[*]</Literal></Term>
<ListItem>
<Para>The lower bound is 0 (zero).  The upper bound is determined by a
<Literal>max_is</Literal> or <Literal>size_is</Literal> attribute.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>[ ]</Literal></Term>
<ListItem>
<Para>The lower bound is 0 (zero).  The upper bound is determined by a
<Literal>max_is</Literal> or <Literal>size_is</Literal> attribute.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>[</Literal><Symbol Role="Variable">lower</Symbol><Literal> .. ]</Literal></Term>
<ListItem>
<Para>The lower bound
is <Symbol Role="Variable">lower</Symbol>.  The upper bound is determined by a <Literal>max_is</Literal>
or <Literal>size_is</Literal> attribute.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>[* .. </Literal><Symbol Role="Variable">upper</Symbol><Literal>]</Literal></Term>
<ListItem>
<Para>The lower bound is determined by a <Literal>min_is</Literal> attribute.  The upper bound is
<Symbol Role="Variable">upper</Symbol>.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>[* .. *</Literal><Literal>]</Literal></Term>
<ListItem>
<Para>The lower bound is determined by a <Literal>min_is</Literal> attribute.  The upper bound is
determined by a <Literal>size_is</Literal> or <Literal>max_is</Literal> attribute.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.68">
<Title>Conformance in Dimensions Other Than the First</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.224">
<Primary>conformance in dimensions other than the first</Primary>
</IndexTerm>
<Para>If a multidimensional array is conformant in a dimension other than the first,
the C description for this array, which is located in the header 
(<Filename>.h</Filename>) file
generated by the IDL compiler, will be a one-dimensional conformant array of
the appropriate element type.  This occurs because there is no ``natural''
C binding for conformance in dimensions other than the first.
</Para>
<Para>The following examples show how IDL type definitions and parameter
declarations that contain bounds in dimensions other than the first are
translated into their C equivalents at runtime.
</Para>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.225">
<Primary>conformance in dimensions other than the first</Primary>
<Secondary>code example</Secondary>
</IndexTerm><Literal>IDL Type Definition:</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct {
    long a;
    long e;
    [max_is(,,e),min_is(a)] long g7[*..1][2..9][3..*];
} t3;
</ProgramListing></Para>
</InformalExample>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.226">
<Primary>conformance in dimensions other than the first</Primary>
<Secondary>code example</Secondary>
</IndexTerm><Literal>C Translation:</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct  {
  idl_long_int a;
  idl_long_int e;
  idl_long_int g7[1];
</ProgramListing></Para>
</InformalExample>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.227">
<Primary>conformance in dimensions other than the first</Primary>
<Secondary>code example</Secondary>
</IndexTerm><Literal>IDL Parameter Declaration:</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>[in,out,max_is(,,e),min_is(a)] long g7[*..1][2..9][3..*];
</ProgramListing></Para>
</InformalExample>
<Para><Literal>C Translation:</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>/* [in, out] */ idl_long_int g7[]
</ProgramListing></Para>
</InformalExample>
<Para>Arrays that have a nonzero first lower bound and a first upper bound that is
determined at runtime are translated into the equivalent C
representation of a conformant array, as shown in the following IDL type
definition and parameter declaration examples:
</Para>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.228">
<Primary>conformance in dimensions other than the first</Primary>
<Secondary>code example</Secondary>
</IndexTerm><Literal>IDL Type Definition:</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct  {
           long s;
           [size_is(s)] long fa3[3..*][-4..1][-1..2];
} t1;
</ProgramListing></Para>
</InformalExample>
<Para><Literal>C Translation:</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct  {
  idl_long_int s;
  idl_long_int fa3[1][6][4];
} t1;
</ProgramListing></Para>
</InformalExample>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.229">
<Primary>conformance in dimensions other than the first</Primary>
<Secondary>code example</Secondary>
</IndexTerm><Literal>IDL Parameter Declaration:</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>[in,out,size_is(s)] long fa3[3..*][-4..1][-1..2]
</ProgramListing></Para>
</InformalExample>
<Para><Literal>C Translation:</Literal>     				               
</Para>
<InformalExample>
<Para><ProgramListing>/* [in, out] */ idl_long_int fa3[][6][4]
</ProgramListing></Para>
</InformalExample>
<!-- .cS-->
<!-- The \*Varray_bounds_declarator\*O for each-->
<!-- of these dimensions can therefore take only the following forms:-->
<!-- .iX "array" "multidimensional"-->
<!-- .VL 1.50i-->
<!-- .LI "\*L[\*Vlower \*L.. \*Vupper\*L]\*O"-->
<!-- The lower bound-->
<!-- is \*Vlower\*O.  The upper bound is \*Vupper\*O.-->
<!-- .LI "\*L[\*Vsize\*L]\*O"-->
<!-- The lower bound is 0 (zero).  The upper-->
<!-- bound is \*Vsize\*O \-\ 1.-->
<!-- .LE-->
<!-- .P-->
<!-- In all forms of \*Varray_bounds_declarator\*O the \*Vlower\*O-->
<!-- and \*Vupper\*O must resolve to integer constants.-->
<!-- .cE-->
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.69">
<Title>Array Attributes</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.230">
<Primary>array</Primary>
<Secondary>attributes</Secondary>
</IndexTerm>
<Para>Array attributes specify the size of an array or the part of an array that is
to be transferred during a call.  An array attribute specifies a 
variable that is either a field in the 
same structure as the array or a parameter in the same operation 
as the array.
</Para>
<Para>An <Symbol Role="Variable">array_attribute</Symbol> can take the following forms:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>min_is (</Literal><Symbol Role="Variable">[*</Symbol><Symbol Role="Variable">] variable</Symbol><Literal>)
max_is (</Literal><Symbol Role="Variable">[</Symbol><Literal>*</Literal><Symbol Role="Variable">] variable</Symbol><Literal>)
size_is (</Literal><Symbol Role="Variable">[</Symbol><Literal>*</Literal><Symbol Role="Variable">] variable</Symbol><Literal>)
last_is (</Literal><Symbol Role="Variable">[</Symbol><Literal>*</Literal><Symbol Role="Variable">] variable</Symbol><Literal>)
first_is (</Literal><Symbol Role="Variable">[</Symbol><Literal>*</Literal><Symbol Role="Variable">] variable</Symbol><Literal>)
length_is (</Literal><Symbol Role="Variable">[</Symbol><Literal>*</Literal><Symbol Role="Variable">] variable</Symbol><Literal>)
</Literal></UserInput></ProgramListing></Para>
</InformalExample>
<Para>where <Symbol Role="Variable">variable</Symbol> specifies a variable whose value at runtime will 
determine the bound or element count for the associated 
dimension.  A pointer variable is indicated by preceding the 
variable name with an <Literal>*</Literal> (asterisk).  
</Para>
<Para>If the array is a member of 
a structure, any referenced variables must be members of the same structure.  
If the array is a parameter of an operation, any referenced 
variables must be 
parameters of the same operation.
</Para>
<Para>Only the <Literal>..._is(</Literal><Symbol Role="Variable">variable</Symbol><Literal>)</Literal> form is allowed when
the array is a field of a structure.  In this case, the 
<Literal>..._is(*</Literal><Symbol Role="Variable">variable</Symbol><Literal>)</Literal> form is not allowed.
</Para>
<Para>Note that an array with an array attribute (that is, a conformant or varying 
array) is not allowed to have the <Literal>transmit_as</Literal> attribute.
</Para>
<Sect4 Id="DCEADG.RPCIDL.div.70">
<Title>The <Literal>min_is</Literal> Attribute</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.231">
<Primary>min_is attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.232">
<Primary>array</Primary>
<Secondary>attributes</Secondary>
<Tertiary>min_is</Tertiary>
</IndexTerm>
<Para>The <Literal>min_is</Literal> attribute is used to specify the
variable(s) from which the values of one or more lower bounds of the array
will be obtained at runtime.
If any dimension of an array has an unspecified lower bound, the array
must have a <Literal>min_is</Literal> attribute.  A variable must be identified
for each such dimension.
The following examples show the syntax of the <Literal>min_is</Literal> attribute:
</Para>
<InformalExample>
<Para><ProgramListing>
<?sml-point-size 10>
<!--no-op:  12-->
<?sml-need 12>/* Assume values of variables are as follows
    long a = -10;
    long b = -20;
    long c = -30;
*/

long [min_is(a)] g1[*..10];           /* g1[-10..10]          */
long [min_is(a)] g2[*..10][4];        /* g2[-10..10[0..3]     */
long [min_is(a,b)] g3[*..10][*..20];  /* g3[-10..10][-20..20] */
long [min_is(,b)] g4[2][*..20];       /* g4[0..1][-20..20]    */
long [min_is(a,,c)] g5[*..7][2..9][*..8]; 
                               /* g5[-10..7][2..9][-30..8]    */
long [min_is(a,b,)] g6[*..10][*..20][3..8]; 
                             /* g6[-10..10][-20..20][3..8]    */
<?sml-point-size 12>
<!--no-op:  14-->
</ProgramListing></Para>
</InformalExample>
<Para>The following examples show the <Literal>min_is</Literal> attribute being
applied to the first dimension of an array in an IDL type definition
and parameter declaration, and how the definition or parameter is translated
into its C equivalent:
</Para>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.233">
<Primary>array</Primary>
<Secondary>attributes</Secondary>
<Tertiary>min_is</Tertiary>
</IndexTerm><Literal>IDL Type Definition:</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct {
         long n;
	 [min_is(n)] long fa3[*..10][-4..1][-1..2]
} t2;
</ProgramListing></Para>
</InformalExample>
<Para><Literal>C Translation:</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct  {
  idl_long_int n;
  idl_long_int fa3[1][6][4];
} t2;
</ProgramListing></Para>
</InformalExample>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.234">
<Primary>array</Primary>
<Secondary>attributes</Secondary>
<Tertiary>min_is</Tertiary>
</IndexTerm><Literal>IDL Parameter Declaration:</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>[in,out,min_is(n)] long fa3[*..10][-4..1][-1..2]
</ProgramListing></Para>
</InformalExample>
<Para><Literal>C Translation:</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>/* [in, out] */ idl_long_int fa3[][6][4]
</ProgramListing></Para>
</InformalExample>
</Sect4>
<Sect4 Id="DCEADG.RPCIDL.div.71">
<Title>The <Literal>max_is</Literal> Attribute</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.235">
<Primary>max_is attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.236">
<Primary>array</Primary>
<Secondary>attributes</Secondary>
<Tertiary>max_is</Tertiary>
</IndexTerm>
<Para>The <Literal>max_is</Literal> attribute is used to specify the variables from which the
values of one or more upper bounds of the array are obtained at runtime.  If
any dimension of an array has an unspecified upper bound, the array must have
a <Literal>max_is</Literal> or <Literal>size_is</Literal> attribute.  A variable must be identified for
each dimension in which the upper bound is unspecified.  In a <Literal>max_is</Literal>
attribute, the value in the identified variable specifies the maximum array
index in that dimension.  An array with one or more unspecified upper bounds
may have a <Literal>max_is</Literal> attribute or a <Literal>size_is</Literal> attribute, but not both.
</Para>
<Para>The <Literal>max_is</Literal> attribute is for use with conformant 
arrays. 
The following is an example of the <Literal>max_is</Literal> attribute:
</Para>
<InformalExample>
<Para><ProgramListing><?sml-point-size 10>
<?Pub _font TypeSize="8pt">
<!--no-op:  12-->
/* Assume values of variables are as follows:
    long a = 10;
    long b = 20;
    long c = 30;
*/

long [max_is(a)] f1[];           /* f1[0..10] /*
long [max_is(a)] f2[][4];        /* f2[0..10][0..3]  */
long [max_is(a,b)] f3[][];       /* f3[0..10][0..20] */
long [max_is(,b)] f4[2][];       /* f4[0..1][0..20] */
long [max_is(a,,c)] f5[1..*][2..9][3..*];  /* f5[1..10][2..9][3..30] */
long [max_is(a,b,)] f6[1..*][2..*][3..8];  /* f6[1..10][2..20][3..8] */
<?sml-point-size 12>
<!--no-op:  14-->
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
</Sect4>
<Sect4 Id="DCEADG.RPCIDL.div.72">
<Title>The <Literal>size_is</Literal> Attribute</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.237">
<Primary>size_is attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.238">
<Primary>array</Primary>
<Secondary>attributes</Secondary>
<Tertiary>size_is</Tertiary>
</IndexTerm>
<Para>The <Literal>size_is</Literal> attribute is used to specify the variables from which the
values of the element counts for one or more dimensions of the array are
obtained at runtime.  If any dimension of an array has an unspecified upper
bound, the array must have a <Literal>max_is</Literal> or <Literal>size_is</Literal> attribute.  A
variable must be identified for each dimension in which the upper bound is
unspecified.  In a <Literal>size_is</Literal> attribute, the value in the identified
variable specifies the number of elements in that dimension.
An array with one or more unspecified upper bounds may have a <Literal>max_is</Literal>
attribute or a <Literal>size_is</Literal> attribute, but not both.
</Para>
<Para>The size of a dimension is defined as the upper bound, minus the 
lower bound, + 1.
</Para>
<Para>The <Literal>size_is</Literal> attribute is for use with conformant 
arrays.  The following is an example of the <Literal>size_is</Literal> attribute:
</Para>
<InformalExample>
<Para><ProgramListing><?sml-need 16>/* Assume the following values for the referenced variables:
   n3 = 5;
   x2 = 12;
   x3 = 14;
   z2 = 9;
   z3 = 10;
*/

/* The following declaration */

int [min_is(,,n3),max_is(,x2,x3)] hh[3..13,4..*,*..*];

/* specifies the same data to be  */
/* transmitted as the declaration */

int [min_is(,,n3),size_is(,z2,z3)] hh[3..13,4..*,*..*];
</ProgramListing></Para>
</InformalExample>
</Sect4>
<Sect4 Id="DCEADG.RPCIDL.div.73">
<Title>The <Literal>last_is</Literal> Attribute</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.239">
<Primary>last_is attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.240">
<Primary>array</Primary>
<Secondary>attributes</Secondary>
<Tertiary>last_is</Tertiary>
</IndexTerm>
<Para>The <Literal>last_is</Literal> attribute is one of the attributes that can be used to allow
the amount of data in an array that will be transmitted to be determined at
runtime.  Each <Literal>last_is</Literal> attribute specifies an upper data limit, which is
the highest index value in that dimension for the array elements to be
transmitted.  If the entry in a <Literal>last_is</Literal> attribute for a dimension is
empty, the effect is as if the upper bound in that dimension had been
specified.
</Para>
<Para>An array can have either the <Literal>last_is</Literal> attribute or the 
<Literal>length_is</Literal> attribute, but not both.
</Para>
<Para>When an array with the <Literal>last_is</Literal> attribute is used in a remote 
procedure call, the elements actually passed in the call can be a 
subset of the maximum possible.
</Para>
<Para>The <Literal>last_is</Literal> attribute is for use with varying 
arrays.  The following is an example of the <Literal>last_is</Literal> attribute:
</Para>
<InformalExample>
<Para><ProgramListing><?sml-point-size 10>
<?Pub _font TypeSize="8pt">
<!--no-op:  12-->
<?sml-need 17>/* Assume the following values for the referenced variables:
    long a = 1;
    long b = 2;
    long c = 3;
    long e = 25;
    long f = 35;
*/

long [last_is(a,b)] bb1[10][20]; /* transmit bb1[0..1][0..2] */
long [last_is(a,b)] bb2[-1..10][-2..20][-3..30];
                                 /* transmit bb2[-1..1][-2..2][-3..30] */
long [last_is(a,,c)] bb3[-1..10][-2..20][-3..30];
                                 /* transmit bb3[-1..1][-2..20][-3..3] */
long [last_is(,b,c),max_is(,e)] cc1[10][][30];
                                 /* transmit cc1[0..9][0..2][0..3] */
long [last_is(a,b),max_is(,e,f)] cc2[-4..4][][];
                                 /* transmit cc2[-4..1][0..2][0..35] */
<?sml-point-size 12>
<!--no-op:  14-->
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
</Sect4>
<Sect4 Id="DCEADG.RPCIDL.div.74">
<Title>The <Literal>first_is</Literal> Attribute</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.241">
<Primary>first_is attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.242">
<Primary>array</Primary>
<Secondary>attributes</Secondary>
<Tertiary>first_is</Tertiary>
</IndexTerm>
<Para>The <Literal>first_is</Literal> attribute is one of the attributes that can be used to
allow the amount of data in an array that will be transmitted to be determined
at runtime.  Each <Literal>first_is</Literal> attribute specifies a lower data limit,
which is the lowest index value in that dimension for the array elements to be
transmitted.  If the entry in a <Literal>first_is</Literal> attribute for a dimension is
empty, the effect is as if the lower bound in that dimension had been
specified.
</Para>
<Para>When an array with the <Literal>first_is</Literal> attribute is used in a remote 
procedure call, the elements actually passed in the call can be a 
subset of the maximum possible.
</Para>
<Para>The <Literal>first_is</Literal> attribute is for use with varying 
arrays.  The following is an example of the <Literal>first_is</Literal> attribute:
</Para>
<InformalExample>
<Para><ProgramListing>
<?Pub _font TypeSize="8pt">
<?sml-point-size 10>
<!--no-op:  12-->
<?sml-need 24>/* Assume the following values for the referenced variables:
    long p = -1;
    long q = -2;
    long r = -3;
    long t = -25;
    long u = -35;
    long x = 1;
    long y = 2;
    long z = 3;
*/

long [first_is(p)] dd1[-10..10];             /* transmit dd1[-1..10] */
long [first_is(p),last_is(x)] dd2[-10..10];  /* transmit dd2[-1..1] */
long [first_is(p,q)] ee1[-10..10][-20..20];
                          /* transmit ee1[-1..10][-2..20] */
long [first_is(p,q)] ee2[-10..10][-20..20][-30..30];
                          /* transmit ee2[-1..10][-2..20][-30..30] */
long [first_is(p,q,r),last_is(,,z)] ee3[-10..10][-20..20][-30..30]:
                          /* transmit ee3[-1..10][-2..20[-3..30] */ 
double [first_is(,q,r),min_is(,t)] ff1[10][*..2][-30..30];
                          /* transmit ff1[0..9][-2..2][-3..30] */
double [first_is(p,q),min_is(,t,u)] ff2[-4..4][*..2][*..35];
                          /* transmit ff2[-1..4][-2..2][-35..35] */
double [max_is(x,,z),min_is(,t,u),first_is(p,,r)] ff3[-20..*][*..30][*..*]
                          /* transmit ff3[-1..1][-25..30][-3..3] */
<?sml-point-size 12>
<!--no-op:  14-->
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
</Sect4>
<Sect4 Id="DCEADG.RPCIDL.div.75">
<Title>The <Literal>length_is</Literal> Attribute</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.243">
<Primary>length_is attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.244">
<Primary>array</Primary>
<Secondary>attributes</Secondary>
<Tertiary>length_is</Tertiary>
</IndexTerm>
<Para>The <Literal>length_is</Literal> attribute is one of the attributes that can be used to
allow the amount of data in an array that will be transmitted to be determined
at runtime.  Each <Literal>length_is</Literal> attribute specifies the number of elements in
that dimension to be transmitted.  If the entry in a <Literal>length_is</Literal> attribute
for a dimension is empty, the effect is for the highest index value in that
dimension for the elements to be transmitted to be determined from the upper
bound in that dimension.
</Para>
<Para>An array can have either the <Literal>last_is</Literal> 
attribute or the <Literal>length_is</Literal> attribute, but not both.  
</Para>
<Para>When an array with the <Literal>length_is</Literal> attribute is used in a remote 
procedure call, the elements actually passed in the call can be a 
subset of the maximum possible.
</Para>
<Para>The <Literal>length_is</Literal> attribute is for use with varying 
arrays.  The following is an example of the <Literal>length_is</Literal> attribute:
</Para>
<InformalExample>
<Para><ProgramListing><?sml-need 10>/* Assume the following values for the referenced variables:
    n3 = 5;
    f2 = 10;
    a1 = 11;
    a2 = 12;
    a3 = 14;
    e1 = 9;
    e2 = 3;
    e3 = 10;
*/

<?sml-need 7>/* The following declaration: */

int [min_is(,,n3),first_is(,f2,),last_is(a1,a2,a3)] \
  gg[3..13,4..14,*..15];

/* specifies the same data to be   */
/* transmitted as the declaration: */

int [min_is(,,n3),first_is(,f2,),length_is(e1,e2,e3)] \
  gg[3..13,4..14,*..15];
</ProgramListing></Para>
</InformalExample>
</Sect4>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.76">
<Title>Rules for Using Arrays</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.245">
<Primary>array</Primary>
<Secondary>rules for</Secondary>
</IndexTerm>
<Para>Observe the following rules when defining arrays in IDL:
</Para>
<ItemizedList>
<ListItem>
<Para>A structure can contain only one conformant array, which must be 
the last member in the structure.
</Para>
</ListItem>
<ListItem>
<Para>Conformant arrays are not valid in unions.
</Para>
</ListItem>
<ListItem>
<Para>A structure parameter containing a conformant array can be passed only by 
reference.
</Para>
</ListItem>
<ListItem>
<Para>Arrays that have the <Literal>transmit_as</Literal> attribute cannot be conformant 
or varying arrays.
</Para>
</ListItem>
<ListItem>
<Para>The structure member or parameter referenced in an array attribute cannot 
be defined to have either the <Literal>represent_as</Literal> or 
<Literal>transmit_as</Literal> attribute.
</Para>
</ListItem>
<ListItem>
<?sml-need 2>
<Para>Array bounds must be integers.  Array attributes can reference only 
structure members or parameters of integer type.
</Para>
</ListItem>
<ListItem>
<Para>A parameter that is referenced by an array 
attribute on a conformant array must have the <Literal>in</Literal> attribute.
</Para>
</ListItem>
<ListItem>
<Para>Array elements cannot be context handles or pipes, or conformant arrays or
conformant structures.
</Para>
</ListItem>
</ItemizedList>
</Sect3>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.77">
<Title>Strings</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.246">
<Primary>IDL</Primary>
<Secondary>strings</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.247">
<Primary>strings</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.248">
<Primary>string</Primary>
<Secondary>attribute</Secondary>
</IndexTerm>
<Para>IDL implements strings as one-dimensional arrays to which 
the <Literal>string</Literal> attribute is assigned.  The element type of 
the array must resolve to one of the following:
</Para>
<ItemizedList>
<ListItem>
<Para>Type <Literal>char</Literal>
</Para>
</ListItem>
<ListItem>
<Para>Type <Literal>byte</Literal>
</Para>
</ListItem>
<ListItem>
<Para>A structure all of whose members are of type <Literal>byte</Literal> or of 
a named type that resolves to <Literal>byte</Literal>
</Para>
</ListItem>
<ListItem>
<Para>A named type that resolves to one of the previous three types
</Para>
</ListItem>
<ListItem>
<Para>Type <Literal>unsigned short</Literal>
</Para>
</ListItem>
<ListItem>
<Para>Type <Literal>unsigned long</Literal>
</Para>
</ListItem>
<ListItem>
<Para>A named type that resolves to <Literal>unsigned short</Literal> or <Literal>unsigned long</Literal>
</Para>
</ListItem>
</ItemizedList>
<Para>Strings built from <Literal>byte</Literal> or <Literal>char</Literal> data types are referred to
as <FirstTerm>byte-string types</FirstTerm> while strings built from <Literal>unsigned short</Literal>
or <Literal>unsigned long</Literal> types are called <FirstTerm>integer-string types</FirstTerm>.
Integer string types allow for multioctet character sets whose
characters are represented by 16-bit or 32-bit quantities,
rather than as groups of bytes.  For example:
</Para>
<InformalExample>
<Para><ProgramListing><?sml-need 14>/* A structure that contains a fixed string */
/* and a conformant string */
typedef unsigned long PRIVATE_CHAR_32;
typedef struct {
   [string] PRIVATE_CHAR_32 fixed[27];
   [string] PRIVATE_CHAR_32 conf[];
} two_strings;
</ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>/* A structure that contains pointers to two strings */
typedef unsigned short PRIVATE_CHAR_16;
typedef struct {
   [string] PRIVATE_CHAR_16 *astring;
   [string] PRIVATE_CHAR_16 *bstring;
} stringptrs;
</ProgramListing></Para>
</InformalExample>
<Para>Integer-string types use the array element zero (0) to
specify the string terminator, while byte-string types
use the NULL character.  Both byte-type and
integer-type strings conform to the same usage rules.
<!-- DCE 1.2 WRITERS: please check above paragraph-->
</Para>
<Para>An array with the <Literal>string</Literal> attribute represents a string
of characters.  The <Literal>string</Literal> attribute does not specify the
format of the string or the mechanism for determining its length.
Implementations of IDL provide string formats and mechanisms
for determining string lengths that are compatible with the programming
languages in which applications are written.
For DCE RPC IDL, the number of characters in a <Literal>string</Literal> array 
includes the NULL terminator (for byte-string types) or the
zero (0) terminator (for integer-string types), and the entire
terminated string is passed between stubs.
</Para>
<Para>The <Symbol Role="Variable">array_bounds_declarator</Symbol> for a <Literal>string</Literal> array 
determines the maximum number of characters in the array.  
Note that, when you declare a string, you must allocate space 
for one more than the maximum number of characters the string is to 
hold.  For instance, if a string is to store 80 characters, the string 
must be declared with a size of 81:
</Para>
<InformalExample>
<Para><ProgramListing>/* A string type that holds 80 characters */
typedef
   [string] char string_t [81];
</ProgramListing></Para>
</InformalExample>
<Para>If an array has the <Literal>string</Literal> attribute or if the type of an
array has the <Literal>string</Literal> attribute, the array cannot have the 
<Literal>first_is</Literal>, the <Literal>last_is</Literal>, or the <Literal>length_is</Literal> attribute.
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.78">
<Title>Pointers</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.249">
<Primary>pointers</Primary>
</IndexTerm>
<Para>Use the following syntax to declare an IDL pointer:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>*</Literal><Symbol Role="Variable">[</Symbol><Literal>*</Literal><Symbol Role="Variable">]...pointer_identifier</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Literal>*</Literal> (asterisk) is the pointer operator, and multiple asterisks indicate
multiple levels of indirection.
</Para>
<Sect3 Id="DCEADG.RPCIDL.div.79">
<Title>Pointer Attributes</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.250">
<Primary>ref attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.251">
<Primary>ptr attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.252">
<Primary>unique attribute</Primary>
</IndexTerm>
<Para>Pointers are used for several purposes, including implementing a 
parameter passing
mechanism that allows a data value to be returned, and  building complex
data structures.
</Para>
<Para>IDL offers three classes of pointers: reference pointers, full pointers, and
unique pointers.
The attributes that indicate these pointers are as follows:
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>ref</Literal>: Indicates reference pointers.  This is the default for top-level
pointers used in parameters.
</Para>
</ListItem>
<ListItem>
<Para><Literal>ptr</Literal>: Indicates full pointers. 
</Para>
</ListItem>
<ListItem>
<Para><Literal>unique</Literal>: Indicates unique pointers.
</Para>
</ListItem>
</ItemizedList>
<Para>Pointer attributes are used in parameters, in structure and union members,
and in type definitions. 
In some instances, IDL infers the applicable pointer class from its usage.
However, most pointer declarations require that you specify a pointer
class by using one of the following methods:
<IndexTerm Id="DCEADG.RPCIDL.indx.253">
<Primary>pointer_default attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.254">
<Primary>default</Primary>
<Secondary>pointer semantics</Secondary>
</IndexTerm></Para>
<ItemizedList>
<ListItem>
<Para>Use the <Literal>ref</Literal>, <Literal>ptr</Literal>, or <Literal>unique</Literal> attribute in the pointer
declaration.
</Para>
</ListItem>
<ListItem>
<Para>Use the <Literal>pointer_default</Literal> attribute in the IDL interface heading.
The default pointer class is determined
by the <Literal>pointer_default</Literal> attribute.
</Para>
</ListItem>
</ItemizedList>
<Para>Pointer attributes are applied only to the top-level pointer within the
declaration.  If multiple pointers are declared in a single declaration,
the <Literal>pointer_default</Literal> established applies to all but the top-level
pointer. (See Section 18.14.7.2, which
describes pointer attributes in parameters.)
</Para>
<Para>Examples of pointers are shown at the end of this section.
</Para>
<Sect4 Id="DCEADG.RPCIDL.div.80">
<Title>Reference Pointers</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.255">
<Primary>ref attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.256">
<Primary>reference pointer</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.257">
<Primary>aliasing</Primary>
</IndexTerm>A reference pointer is the least complex form of pointer.  The most common use
for this class of pointer is as a passing mechanism; for example, passing
an integer by reference.  Reference pointers have significantly better
performance than full pointers, but are restrictive; you cannot create a
linked list by using a reference pointer because a reference pointer cannot
have a NULL value, and the list cannot be terminated.
</Para>
<Para>A reference pointer has the following characteristics:
</Para>
<ItemizedList>
<ListItem>
<Para>It always points to valid storage; it can never have a NULL value.
</Para>
</ListItem>
<ListItem>
<Para>Its value does not change during a call; it always
points to the same storage on return from the call as it did 
when the call was made.
</Para>
</ListItem>
<ListItem>
<Para>It does not support aliasing; it cannot point to a storage area that
is pointed to by any other pointer used in a parameter of 
the same operation.
</Para>
</ListItem>
</ItemizedList>
<Para>When a manager routine is entered, all the reference pointers in its parameters
will point to valid storage, except those reference pointers that 
point neither to targets whose size can be determined at compile time nor 
to values that have been received from the client.
</Para>
<Para>In the following example, the size of the targets of the reference
pointers can be calculated at compilation time:
</Para>
<InformalExample>
<Para><ProgramListing>typedef [ref] long *rpl;

void op1( [in] long f, 
          [in] long l, 
          [in,first_is(f),last_is(l)] rpl rpla[10] );
</ProgramListing></Para>
</InformalExample>
<Para>For this example, when the manager is entered,
all the pointers in <Literal>rpla</Literal> will point to usable storage, although only
<Literal>*rpla[f]</Literal> through <Literal>*rpla[l]</Literal> 
will be the values received from the client.
</Para>
<Para><?sml-need 8>Conversely, the size of the targets of the reference pointers cannot
be calculated at compile time in the following example:
</Para>
<InformalExample>
<Para><ProgramListing>typedef [ref,string] char *rps;

void op1( [in] long f, 
          [in] long l, 
          [in,first_is(f),last_is(l)] rps rpsa[10] );
</ProgramListing></Para>
</InformalExample>
<Para>In this case, only <Literal>rpsa[f]</Literal> through <Literal>rpsa[l]</Literal>, which point to
values received from the client, will point to usable storage.
</Para>
</Sect4>
<Sect4 Id="DCEADG.RPCIDL.div.81" RevisionFlag="Changed">
<Title>Full Pointers</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.258">
<Primary>ptr attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.259">
<Primary>full pointer</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.260">
<Primary>aliasing</Primary>
</IndexTerm>A full pointer is the most complex form of pointer.  It supports 
all capabilities associated with pointers.  For example,
by using a full pointer you can build complex data structures such
as linked lists, trees, queues, or arbitrary graphs.
</Para>
<Para>A full pointer has the following characteristics:
</Para>
<ItemizedList>
<ListItem>
<Para>Its value can change during a call;
it can change from a NULL to non-NULL value, 
non-NULL to NULL, or
from one non-NULL value to another non-NULL value.
</Para>
</ListItem>
<ListItem>
<Para>It supports aliasing; it can point to a storage area that
is also pointed to by any other full pointer used in a parameter of 
the same operation.  However, all such pointers must point to the beginning of
the structure.  There is no support for pointers to substructures or to
overlapping storage areas.  For example, if the interface definition code
contains the following:
</Para>
<InformalExample>
<Para><ProgramListing><?sml-need 14>[uuid(0e256080-587c-11ca-878c-08002b111685), version(1.0)]
interface overlap
{
  typedef struct {
          long bill;
          long charlie;
  } foo;
  typedef struct {
          long fred;
          foo ken;
  } bar;

  void op ( [in] foo *f, [in] bar *b );
}
</ProgramListing></Para>
</InformalExample>
<Para>and the client application code includes the following:
</Para>
<InformalExample>
<Para><ProgramListing>bar bb;
 .
 .
 .
op ( &amp;bb.ken, &amp;bb );
</ProgramListing></Para>
</InformalExample>
<Para>then the server stub treats these two separate parameters as distinct, 
and the manager application code does not see them as overlapping storage.
</Para>
</ListItem>
<ListItem>
<Para>It allows dynamically allocated data to be returned from a call.
</Para>
</ListItem>
</ItemizedList>
<?og-ChangeStart def, 13469, R1.2.2, document limit on linked-list marshalling">
<Para>Note that you might need to take some extra steps if you use large
linked lists in your application.  Linked lists are marshalled and
unmarshalled using recursion which can cause the stack size to grow.
Linked lists usually do not cause problems in simple clients that do
not spawn threads for remote procedure calls. In this case, the stack
can grow as needed.
</Para>
<Para>Large linked lists can cause problems in servers because the server's
thread-stack usually cannot grow automatically.  Large lists can
overrun the stack, causing the server to crash.
</Para>
<Para>DCE offers several ways to avoid this server memory problem while
using large linked lists.
</Para>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.261">
<Primary>rpc_mgmt_set_server_stack_size() routine</Primary>
</IndexTerm>One method is to increase the server stack size using the
<Function>rpc_mgmt_set_server_stack_size()</Function> routine.  This method is
useful when you suspect that the linked list is just slightly larger
than the server stack. For information about using the
<Function>rpc_mgmt_set_server_stack_size()</Function> routine, refer to the OSF DCE
Application Development Reference.
</Para>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.262">
<Primary>transmit_as idl attribute</Primary>
</IndexTerm>If you suspect that the list size is much greater than the stack, you
can convert the list to an array using the <Literal>transmit_as</Literal> idl
attribute.  Servers handle arrays by allocating memory from the heap
rather than from the stack. For information about using the
<Literal>transmit_as</Literal> idl attribute, refer to Chapter 19 in this guide.
<?og-ChangeEnd def, 13469, R1.2.2, document limit on linked-list marshalling"></Para>
</Sect4>
<Sect4 Id="DCEADG.RPCIDL.div.82">
<Title>Unique Pointers</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.263">
<Primary>pointers</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.264">
<Primary>unique pointers</Primary>
</IndexTerm>
<Para>A unique pointer is more flexible than a reference pointer.  However,
both types of pointers share several important characteristics.
</Para>
<Para>A unique pointer has the following characteristics:
</Para>
<ItemizedList>
<ListItem>
<Para>It can have a NULL value.
</Para>
</ListItem>
<ListItem>
<Para>It can change from NULL to non-NULL during a call.
This change 
results in memory being allocated on return from the call, whereby the 
result is stored in the allocated memory.
</Para>
</ListItem>
<ListItem>
<?sml-need 4>
<Para>It can change from non-NULL to NULL during a call.  This
change can result in the orphaning of the memory pointed
to on return from the call.  Note that,
if a unique pointer changes from one
non-NULL value to another non-NULL value,
the change is ignored.
</Para>
</ListItem>
<ListItem>
<Para>It does not identify particular extents of memory, but only extents of
memory that are suitable for storing the data.  If it is important
to know that the data is being stored in a specific memory location, then you
should use a full pointer.
</Para>
</ListItem>
<ListItem>
<Para>If it has a value other than NULL, output data is placed
in existing storage.
</Para>
</ListItem>
</ItemizedList>
<Para>Unique pointers are similar to reference pointers in the following ways:
</Para>
<ItemizedList>
<ListItem>
<Para>No storage pointed to by a unique pointer can be reached from any other
name in the operation.  That is, a unique pointer does not allow aliasing
of data within the operation.
</Para>
</ListItem>
<ListItem>
<Para>Data returned from the called subroutine is written into the existing storage
specified by the unique pointer, if the pointer did not have the value
NULL.
</Para>
</ListItem>
</ItemizedList>
<Para>With regard to performance, unique pointers have an advantage over full
pointers because unique pointers do not support the referencing of
common data by more than one pointer (aliasing), and they are significantly
more flexible than reference pointers because they can have a value of
NULL.
</Para>
<Para>Unique pointers are particularly suitable for creating optional parameters
(because you can specify them as NULL) and for simple tree
or singly linked-list data structures.  You specify the three different levels
of pointers by attributes, as follows:
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>[ref]</Literal></Term>
<ListItem>
<Para>Reference pointers
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>[unique]</Literal></Term>
<ListItem>
<Para>Unique pointers
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>[ptr]</Literal></Term>
<ListItem>
<Para>Full pointers
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para><?sml-need 16>The following example shows how a unique pointer can be used:
<IndexTerm Id="DCEADG.RPCIDL.indx.265">
<Primary>unique pointers</Primary>
<Secondary>example</Secondary>
</IndexTerm></Para>
<InformalExample>
<Para><ProgramListing>[
    uuid(D37A0E80-5D23-11C9-B199-08002B13D56D)
] interface Unique_ptrs
{
    typedef [ref]    long *r_ptr;
    typedef [unique] long *u_ptr;
    typedef [ptr]    long *f_ptr;

    void op1 (
      [ref,in,out,string]	 char *my_rname,
      [unique,in,out,string] char *my_uname,
      [ptr,in,out,string]	 char *my_pname
    	 );
}
</ProgramListing></Para>
</InformalExample>
</Sect4>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.83">
<Title>Pointer Attributes in Parameters</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.266">
<Primary>parameters</Primary>
</IndexTerm>A pointer attribute can be applied to a parameter only if the 
parameter contains an explicit pointer declaration (<Literal>*</Literal>).  
</Para>
<Para>By default, a single pointer (<Literal>*</Literal>) operator in a parameter list
of an operation declaration is treated as a reference pointer.
To override this, specify 
a pointer attribute for the parameter. 
<IndexTerm Id="DCEADG.RPCIDL.indx.267">
<Primary>pointer levels</Primary>
</IndexTerm>When there is more than one pointer operator, or
multiple levels of indirection in the parameter list, the
rightmost pointer is the top-level pointer; all 
pointers to the left of the rightmost pointer
are of a lower level.  The top-level pointer
is treated as a reference pointer by default; the lower-level
pointers have the semantics specified by the 
<Literal>pointer_default</Literal> attribute in the interface.
</Para>
<Para>The following example illustrates the use of top- and lower-level
pointers:
</Para>
<InformalExample>
<Para><ProgramListing>void op1 ([in] long **p_p_l)
</ProgramListing></Para>
</InformalExample>
<Para>In this example, <Literal>p_p_l</Literal> is a pointer to a pointer to a long integer.
The first or leftmost pointer (<Literal>*</Literal>) signifies that the pointer to the
long integer is a lower-level pointer, and the second or rightmost pointer (*)
signifies that the
pointer to the pointer is a top-level pointer.
</Para>
<Para><?sml-need 4>Any pointer
attribute you specify for the parameter applies to the top-level pointer only.
Note that unless you specify a pointer attribute, the top-level explicit
pointer declaration in a parameter defaults to a reference pointer
even if the <Literal>pointer_default(ptr)</Literal> interface
attribute is specified.
</Para>
<Para>Using a reference pointer improves performance but is 
more restrictive.  For example, the pointer declared in the following
operation, for the parameter <Literal>int_value</Literal>, is a reference
pointer.  An application call to this operation can never specify NULL
as the value of <Literal>int_value</Literal>. 
</Para>
<InformalExample>
<Para><ProgramListing>void op ([in] long *int_value);
</ProgramListing></Para>
</InformalExample>
<Para>To pass a NULL value, use a full pointer.  The following two
methods make <Literal>int_value</Literal> into a full pointer:
</Para>
<ItemizedList>
<ListItem>
<Para>Applying the <Literal>ptr</Literal> attribute to the declaration of
the parameter, <Literal>int_value</Literal>:
</Para>
<InformalExample>
<Para><ProgramListing>void op ([in, ptr] long *int_value);
</ProgramListing></Para>
</InformalExample>
</ListItem>
<ListItem>
<Para>Using the <Literal>pointer_default (ptr)</Literal>
attribute in an interface header :
</Para>
<InformalExample>
<Para><ProgramListing>[uuid(135e7f00-1682-11ca-bf61-08002b111685,
 pointer_default(ptr),
 version(1.0)] interface full_pointer
{
typedef long *long_ptr;
void op ([in] long_ptr int_value);
}
</ProgramListing></Para>
</InformalExample>
</ListItem>
</ItemizedList>
<Para>A NULL pointer can also be passed via a unique pointer.
</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.84">
<Title>Array Attributes on Pointers</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.268">
<Primary>pointers</Primary>
<Secondary>array attributes on</Secondary>
</IndexTerm>To apply array attributes to pointers, use the
<Literal>max_is</Literal> or <Literal>size_is</Literal> attributes.
When applied to a pointer, the 
<Literal>max_is</Literal> and <Literal>size_is</Literal> attributes
convert the pointer from a single element of a certain type 
to a pointer to an array of elements of that type.
The number of elements in the array is determined by the 
variable in the  
<Literal>max_is</Literal> and <Literal>size_is</Literal> attributes.
</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.85">
<Title>Pointer Attributes in Function Results</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.269">
<Primary>function results, pointers</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.270">
<Primary>pointers</Primary>
<Secondary>in function results</Secondary>
</IndexTerm>Function results that are pointers are always treated as full
pointers.  The <Literal>ptr</Literal> attribute is allowed on function results
but it is not mandatory.  The <Literal>ref</Literal> pointer attribute is never
allowed on function results.
</Para>
<Para>A function result that is a pointer always indicates new storage.
A pointer parameter can reference storage that was allocated
before the function was called, but a function result cannot.
</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.86">
<Title>Pointers in Structure Fields and Union Case</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.271">
<Primary>pointer_default attribute</Primary>
</IndexTerm>If a pointer is declared in a member of a structure or union, its default
is determined by the <Literal>pointer_default</Literal> attribute you specify for the 
interface.  To
override this, specify a pointer attribute for the member.
</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.87">
<Title>Resolving a Possible Pointer Ambiguity</Title>
<Para>A declaration of the following form
raises a possible ambiguity about the type of <Symbol Role="Variable">myarray</Symbol>:
</Para>
<InformalExample>
<Para><ProgramListing><?sml-point-size 11>void op ([in, out] long s, [in, out, size_is(s)] long **myarray);
<?sml-point-size 12></ProgramListing></Para>
</InformalExample>
<Para>IDL defines <Symbol Role="Variable">myarray</Symbol> in this case to be an array of pointers to
<Literal>longs</Literal>, not a pointer to an array of <Literal>longs</Literal>.  The
<Literal>max_is</Literal> and <Literal>size_is</Literal> attributes always apply to the
top-level, or rightmost, * (asterisk) in the IDL signature of a
parameter.
</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.88">
<Title>Rules for Using Pointers</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.272" SpanEnd="DCEADG.RPCIDL.indx.249">Use the following rules when developing code in IDL:
</Para>
<ItemizedList>
<ListItem>
<Para>Do not use the full pointer attribute on the following: 
</Para>
<ItemizedList>
<ListItem>
<Para>The parameter in the first parameter position, when that
parameter is of type <StructName Role="typedef">handle_t</StructName> or is of a type with the
<Literal>handle</Literal> attribute.
</Para>
</ListItem>
<ListItem>
<Para>Context handle parameters.
<IndexTerm Id="DCEADG.RPCIDL.indx.273">
<Primary>context handle</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.274">
<Primary>handle</Primary>
<Secondary>attribute</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.275">
<Primary>first_is attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.276">
<Primary>last_is attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.277">
<Primary>length_is attribute</Primary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para>A parameter that has the output attribute (<Literal>out</Literal>), but not the input
attribute (<Literal>in</Literal>).
</Para>
</ListItem>
</ItemizedList>
</ListItem>
<ListItem>
<Para>The element type of a pipe must not be a pointer or a structure
containing a pointer.  
</Para>
</ListItem>
<ListItem>
<Para>A member of a union or a structure contained in a union 
cannot contain a reference pointer.
</Para>
</ListItem>
<ListItem>
<Para>A reference pointer must point to valid storage at the time the call is made.
</Para>
</ListItem>
<ListItem>
<Para>A parameter containing a varying array of reference pointers must 
have all array elements
initialized to point to valid storage even if only a portion of the array
is input, since the manager code (the application code supporting
an interface on a server) may use the remaining array
elements. (Recall that a varying array is one to which any of the
array attributes <Literal>first_is, last_is, length_is</Literal> is
applied).
</Para>
</ListItem>
<ListItem>
<Para>The type name in a declaration that defines a pointer type must have
no more than 28 characters.
</Para>
</ListItem>
</ItemizedList>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.89">
<Title>Memory Management for Pointed-to Nodes</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.278">
<Primary>memory</Primary>
<Secondary>management</Secondary>
</IndexTerm>A full pointer can change its value across a call.  Therefore, stubs must be able
to manage memory for the pointed-to nodes.  Managing memory involves
allocating and freeing memory for user data structures. 
</Para>
<Sect4 Id="DCEADG.RPCIDL.div.90">
<Title>Allocating and Freeing Memory</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.279">
<Primary>allocating memory</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.280">
<Primary>freeing memory</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.281">
<Primary>memory</Primary>
<Secondary>freeing</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.282">
<Primary>memory</Primary>
<Secondary>allocating</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.283">
<Primary>memory</Primary>
<Secondary>routines</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.284">
<Primary>routines</Primary>
<Secondary>RPC</Secondary>
</IndexTerm>Manager code within RPC servers usually uses the
<Function>rpc_ss_allocate()</Function> routine to allocate storage.  Storage that is
allocated by <Function>rpc_ss_allocate()</Function> is released by the server stub after
any output parameters have been marshalled by the stubs.
Storage allocated by other allocators is not released automatically but
must be freed by the manager code. 
When the manager code makes a remote call, the default memory management 
routines are <Function>rpc_ss_allocate()</Function> and
<Function>rpc_ss_free()</Function>.
</Para>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.285">
<Primary>idl_void_p_t type</Primary>
</IndexTerm><?sml-need 3>The syntax of the <Function>rpc_ss_allocate()</Function> routine is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>idl_void_p_t rpc_ss_allocate (idl_size_t </Literal><Symbol Role="Variable">size</Symbol><Literal>);</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Symbol Role="Variable">size</Symbol> parameter specifies the size of the memory allocated.
</Para>
<Note>
<Para>In ANSI standard C environments, <StructName Role="typedef">idl_void_p_t</StructName> is defined
as <Literal>void *</Literal> and in other environments is defined as <Literal>char *</Literal>.
</Para>
</Note>
<Para>Use <Function>rpc_ss_free()</Function>
to release storage allocated by
<Function>rpc_ss_allocate()</Function>.  You can also use
the <Function>rpc_ss_free()</Function> routine to release storage pointed to by a
full pointer in an input parameter and have the freeing of the memory
reflected on return to the calling application by specifying the
<Literal>reflect_deletions</Literal> attribute as an <Symbol Role="Variable">operation_attribute</Symbol>.  See
Section 18.4.1 for more information.
</Para>
<Para>The syntax of the routine is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>void rpc_ss_free (idl_void_p_t</Literal> <Symbol Role="Variable">node_to_free</Symbol><Literal>);</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Symbol Role="Variable">node_to_free</Symbol> parameter specifies the location 
of the memory to be freed.
</Para>
</Sect4>
<Sect4 Id="DCEADG.RPCIDL.div.91">
<Title>Enabling and Disabling Memory Allocation</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.286">
<Primary>enabling memory</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.287">
<Primary>disabling memory</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.288">
<Primary>memory</Primary>
<Secondary>enabling</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.289">
<Primary>memory</Primary>
<Secondary>disabling</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.290">
<Primary>idl_void_p_t type</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.291">
<Primary>routines</Primary>
<Secondary>RPC</Secondary>
</IndexTerm>It may be necessary to call manager routines 
from different environments; for example, when the 
application is both a client and a server of the same interface.  In this
case, the same routine may be called both from server manager code and
from client code. 
The <Function>rpc_ss_allocate()</Function> routine, when used by the manager code
to allocate memory, must be initialized before its first use.
The stub performs the initialization automatically.  Code,
other than stub code, that calls 
a routine, which in turn calls <Function>rpc_ss_allocate()</Function>, first calls
the <Function>rpc_ss_enable_allocate()</Function> routine. 
</Para>
<Para>The syntax of the routine is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>void rpc_ss_enable_allocate (void);</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para><?sml-need 5>The environment set up by the <Function>rpc_ss_enable_allocate()</Function>
routine is released by calling the <Function>rpc_ss_disable_allocate()</Function>
routine.  This routine releases all memory allocated by calls to
<Function>rpc_ss_allocate()</Function> since the
call to <Function>rpc_ss_enable_allocate()</Function> was made.  It also
releases memory that was used by the memory management mechanism for
internal bookkeeping.
</Para>
<Para>The syntax of the <Function>rpc_ss_disable_allocate()</Function> routine is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>void rpc_ss_disable_allocate (void);</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
</Sect4>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.92">
<Title>Advanced Memory Management Support</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.292">
<Primary>memory</Primary>
<Secondary>advanced management support</Secondary>
</IndexTerm>Memory management may also involve
setting and swapping the mechanisms used for allocating and
freeing memory.
The default memory management routines are <Function>malloc()</Function> and 
<Function>free()</Function>, except when the remote call occurs within manager code, in which
case the default memory
management routines are <Function>rpc_ss_allocate()</Function> and <Function>rpc_ss_free()</Function>.
</Para>
<Sect4 Id="DCEADG.RPCIDL.div.93">
<Title>Setting the Client Memory Mechanism</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.293">
<Primary>memory</Primary>
<Secondary>management</Secondary>
<Tertiary>client</Tertiary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.294">
<Primary>client</Primary>
<Secondary>memory management</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.295">
<Primary>setting</Primary>
<Secondary>client memory</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.296">
<Primary>memory</Primary>
<Secondary>setting client</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.297">
<Primary>routines</Primary>
<Secondary>RPC</Secondary>
</IndexTerm>Use the <Function>rpc_ss_set_client_alloc_free()</Function> 
routine to establish the routines used in
allocating and freeing memory.
</Para>
<Para>The syntax of the routine is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>void rpc_ss_set_client_alloc_free (</Literal>
<Literal>
     idl_void_p_t (*</Literal><Symbol Role="Variable">p_allocate</Symbol><Literal>) (</Literal>
<Literal>
        idl_size_t </Literal><Symbol Role="Variable">size</Symbol><Literal>),</Literal>
<Literal>
      void (*</Literal><Symbol Role="Variable">p_free</Symbol><Literal>) (
         idl_void_p_t </Literal><Symbol Role="Variable">ptr</Symbol><Literal>)
      );</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Symbol Role="Variable">p_allocate</Symbol> parameter points to a routine that has the same
procedure declaration as the <Function>malloc()</Function> routine, and is
used by the client stub when performing memory allocation.
The <Symbol Role="Variable">p_free</Symbol> parameter points to a routine that has the same
procedure declaration as the <Function>free()</Function> routine, and is
used by the client stub to free memory.
</Para>
</Sect4>
<Sect4 Id="DCEADG.RPCIDL.div.94">
<Title>Swapping Client Memory Mechanisms</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.298">
<Primary>client</Primary>
<Secondary>memory</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.299">
<Primary>memory</Primary>
<Secondary>swapping memory</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.300">
<Primary>swapping client memory</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.301">
<Primary>routines</Primary>
<Secondary>RPC</Secondary>
</IndexTerm>This routine exchanges the current client allocation and freeing mechanism
for one supplied in the call. 
The primary purpose of this routine is to simplify the
writing of modular routine libraries in which RPC calls are made.  To
preserve modularity, any dynamically allocated memory returned by a modular
routine library must be allocated with a specific memory allocator.  When
dynamically allocated memory is returned by an RPC call that is then returned
to the user of the routine library, use
<Function>rpc_ss_swap_client_alloc_free()</Function>, before making the RPC call, 
to make sure the desired memory allocator is used.  Prior to returning,
the modular routine library calls 
<Function>rpc_ss_set_client_alloc_free()</Function>
to restore the previous memory management mechanism.
</Para>
<Para>The syntax of the routine is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>void rpc_ss_swap_client_alloc_free (
      idl_void_p_t (*</Literal><Symbol Role="Variable">p_allocate</Symbol><Literal>) (
         idl_size_t </Literal><Symbol Role="Variable">size</Symbol><Literal>),
      void (*</Literal><Symbol Role="Variable">p_free</Symbol><Literal>) (
         idl_void_p_t </Literal><Symbol Role="Variable">ptr</Symbol><Literal>),
      idl_void_p_t (**</Literal><Symbol Role="Variable">p_p_old_allocate</Symbol><Literal>) (
         idl_size_t </Literal><Symbol Role="Variable">size</Symbol><Literal>),
      void (**</Literal><Symbol Role="Variable">p_p_old_free</Symbol><Literal>) (
         idl_void_p_t </Literal><Symbol Role="Variable">ptr</Symbol><Literal>)
      );
</Literal></UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Symbol Role="Variable">p_allocate</Symbol> parameter points to a routine that has the same
procedure declaration as the <Function>malloc()</Function> routine, and is used by the
client stub when performing memory allocation.
The <Symbol Role="Variable">p_free</Symbol> parameter points to a routine that has the same
procedure declaration as the <Function>free()</Function> routine, and is used by the
client stub to free memory.
The <Symbol Role="Variable">p_p_old_allocate</Symbol> parameter points to a pointer to a
routine that has the same
procedure declaration as the <Function>malloc()</Function> routine, and is the
default routine used for memory allocation in the client stub.
The <Symbol Role="Variable">p_p_old_free</Symbol> parameter points to a pointer to a
routine that has the same
procedure declaration as the <Function>free()</Function> routine, and is used
for memory release in the client.
</Para>
</Sect4>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.95">
<Title>Use of Thread Handles in Memory Management</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.302">
<Primary>memory</Primary>
<Secondary>management</Secondary>
<Tertiary>server threads</Tertiary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.303">
<Primary>server</Primary>
<Secondary>threads</Secondary>
</IndexTerm><IndexTerm Id="DCEADG.RPCIDL.indx.304" SpanEnd="DCEADG.RPCIDL.indx.283">
<IndexTerm Id="DCEADG.RPCIDL.indx.305">
<Primary>thread</Primary>
<Secondary>memory management for</Secondary>
</IndexTerm>There are two situations where control of memory
management requires the use of thread handles.  The more
common situation is when the manager thread spawns additional threads.
The less common situation is when a program transitions from being a
client to being a server, then reverts to being a client. 
</Para>
<Sect4 Id="DCEADG.RPCIDL.div.96">
<Title>Spawning Threads</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.306">
<Primary>spawning server threads</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.307">
<Primary>memory</Primary>
<Secondary>server threads</Secondary>
</IndexTerm>When a remote procedure call invokes the manager code, 
the manager code may wish to spawn additional threads to complete the
task for which it was called.  To spawn additional threads that are
able to perform memory management, the manager code must first call
the <Function>rpc_ss_get_thread_handle()</Function> routine to get its thread handle
and then pass that thread handle to each spawned thread.  Each spawned
thread that uses the <Function>rpc_ss_allocate()</Function> and <Function>rpc_ss_free()</Function>
routines for memory management first calls the
<Function>rpc_ss_set_thread_handle()</Function> routine by using the handle obtained by
the original manager thread.
</Para>
<Para>These routine calls allow the
manager and its spawned threads to share a common memory management
environment.  This common environment enables memory allocated by the
spawned threads to be used in returned parameters, and causes all
allocations in the common memory management environment to be released
when the manager thread returns to the server stub. 
</Para>
<Para>The main manager thread must not return control to the server stub
before all the threads it spawned complete execution; otherwise,
unpredictable results may occur.
</Para>
<Para>The listener thread can cancel the main manager thread if the
remote procedure call is orphaned or if a cancellation occurs on the
client side of the application.  You should code the main manager thread
to terminate any spawned threads before it exits.  The code should
anticipate exits caused by an unexpected exception or by being canceled.
</Para>
<Para><?sml-need 9>Your code can handle all of these cases by 
including a <Literal>TRY/FINALLY</Literal> block to
clean up any spawned threads if a cancellation or other exception
occurs.  If unexpected exceptions do not concern you, then your code can
perform two steps.  They are
disabling cancelability before threads are spawned followed by enabling
cancelability after the join operation finishes and after testing for any
pending cancel operations.  Following this disable/enable sequence
prevents routine <Function>pthread_join()</Function> from producing a cancel point in a
manager thread that has spawned threads which, in turn, share thread
handles with the manager thread.
</Para>
</Sect4>
<Sect4 Id="DCEADG.RPCIDL.div.97">
<Title>Transitioning from Client to Server to Client</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.308">
<Primary>clients becoming servers</Primary>
</IndexTerm>Immediately before the program changes from a client to a
server, it must obtain a handle on its environment as a client by calling
<Function>rpc_ss_get_thread_handle()</Function>.  When it reverts from a server to
a client, it must reestablish the client environment by calling
the <Function>rpc_ss_set_thread_handle()</Function> routine, supplying the previously
obtained handle as a parameter.
</Para>
</Sect4>
<Sect4 Id="DCEADG.RPCIDL.div.98">
<Title>Syntax for Thread Routines</Title>
<Para>The syntax for the <Function>rpc_ss_get_thread_handle()</Function> routine is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>rpc_ss_thread_handle_t  rpc_ss_get_thread_handle(void);</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The syntax for the <Function>rpc_ss_set_thread_handle()</Function> routine is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>void rpc_ss_set_thread_handle (
     rpc_ss_thread_handle_t </Literal><Symbol Role="Variable">id</Symbol>
<Literal>
     );
</Literal></UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Function>rpc_ss_thread_handle_t()</Function> value identifies the thread to the
RPC stub support library.  The <Symbol Role="Variable">id</Symbol> parameter indicates the thread
handle passed to the spawned thread by its creator, or the
thread handle returned by the previous call to 
<Function>rpc_ss_get_thread_handle()</Function>.
</Para>
</Sect4>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.99">
<Title>Rules for Using the Memory Management Routines</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.309">
<Primary>memory</Primary>
<Secondary>management</Secondary>
<Tertiary>usage rules</Tertiary>
</IndexTerm>You can use the <Function>rpc_ss_allocate()</Function> routine in the following 
environments:
</Para>
<ItemizedList>
<ListItem>
<Para>The manager code for an operation that has a full pointer in its
argument list
</Para>
</ListItem>
<ListItem>
<Para>The manager code for an operation to which the <Literal>enable_allocate</Literal> 
ACF attribute is applied
</Para>
</ListItem>
<ListItem>
<Para>Code that is not called from a server stub but that has called
the <Function>rpc_ss_enable_allocate()</Function> routine
</Para>
</ListItem>
<ListItem>
<Para>A thread, spawned by code of any of the previous three types, that has
made a call to the <Function>rpc_ss_set_thread_handle()</Function> routine using a
thread handle obtained by this code
</Para>
</ListItem>
</ItemizedList>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.100">
<Title>Examples Using Pointers</Title>
<Para>The examples in this subsection contain the following files, listed here with
the function of each file:
</Para>
<VariableList>
<VarListEntry role="linebreak">
<Term><Filename>STRING_TREE.IDL</Filename></Term>
<ListItem>
<Para>Defines data types and interfaces
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Filename>CLIENT.C</Filename></Term>
<ListItem>
<Para>User of the interface
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Filename>MANAGER.C</Filename></Term>
<ListItem>
<Para>Server code that implements the procedure
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Filename>SERVER.C</Filename></Term>
<ListItem>
<Para>Declares the server; enables the client code to find the interface it needs
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Filename>STRING_TREE.OUTPUT</Filename></Term>
<ListItem>
<Para>Shows the output
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para><?sml-need 29><Literal>The STRING_TREE.IDL Example</Literal>
</Para>
<InformalExample>
<Para><ProgramListing><?sml-point-size 10>
<!--no-op:  12-->
[uuid(0144d600-2d28-11c9-a812-08002b0ecef1), version(0)]
interface string_tree
{
  /*
   * Maximum length of a string in the tree
   */
  const long int st_c_name_len = 32;

  /*
   * Definition of a node in the tree.
   */
  typedef struct node
  {
      [string] char name[0..st_c_name_len];
      [ptr] struct node *left;
      [ptr] struct node *right;
  } st_node_t;

  /*
   * Operation that prunes the left subtree of the specified
   * tree and returns it as the value.
   */
  st_node_t *st_prune_left (
      [in, out] st_node_t *tree /* root of tree by ref */
      );
}
<?sml-point-size 12>
<!--no-op:  14-->
</ProgramListing></Para>
</InformalExample>
<Para><Literal>The CLIENT.C Example</Literal>
</Para>
<InformalExample>
<Para><ProgramListing><?sml-point-size 10>
<!--no-op:  12-->
#include &lt;stdio.h>
#include "string_tree.h"

#include &lt;stdlib.h>

/*
** Routine to print a depiction of the tree
*/
void st_print_tree (tree, indent)
  st_node_t *tree;
  int  indent;
{
  int i;
  if (tree == NULL) return;
  for (i = 0; i &lt; indent; i++) printf("    ");
  printf("%s\n",tree->name);
  st_print_tree(tree->left, indent + 1);
  st_print_tree(tree->right, indent + 1);
}

<?sml-need 7>/*
** Create a tree with a few nodes
*/
st_node_t *st_make_tree()
{
  st_node_t *root = (st_node_t *)malloc(sizeof(st_node_t));
  strcpy(root->name,"Root Node");

  /* left subtree node */
  root->left =  (st_node_t *)malloc(sizeof(st_node_t));
  strcpy(root->left->name,"Left subtree");    

  /* left subtree children */
  root->left->right = NULL;
  root->left->left = (st_node_t *)malloc(sizeof(st_node_t));
  strcpy(root->left->left->name,"Child of left subtree");    
  root->left->left->left = NULL;
  root->left->left->right = NULL;

  /* right subtree node */
  root->right =  (st_node_t *)malloc(sizeof(st_node_t));
  strcpy(root->right->name,"Right subtree");    
  root->right->left = NULL;
  root->right->right = NULL;

  return root;
}

main()
{
  st_node_t *tree;
  st_node_t *subtree;

  /* setup and print original tree */
  tree = st_make_tree();
  printf("Original Tree:\n");
  st_print_tree(tree, 1);

  /* call the prune routine */
  subtree = st_prune_left (tree);

  /* print the resulting trees */
  printf("\nPruned Tree:\n");
  st_print_tree(tree, 1);

  printf("\nPruned subtree:\n");
  st_print_tree(subtree, 1);
  }
<?sml-point-size 12>
<!--no-op:  14-->
</ProgramListing></Para>
</InformalExample>
<Para><?sml-need 6><Literal>The MANAGER.C Example</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>
<?Pub _font TypeSize="8pt">
<?sml-point-size 10>
<!--no-op:  12-->
#include &lt;stdio.h>
#include "string_tree.h"

/*
** Prune the left subtree of the specified tree and return
** it as the function value.  
*/
st_node_t *st_prune_left (tree)
  /* [in,out] */  st_node_t *tree;
{
  st_node_t *left_sub_tree = tree->left;
  tree->left = (st_node_t *)NULL;
  return left_sub_tree;
}
<?sml-point-size 12>
<!--no-op:  14-->
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
<Para><Literal>The SERVER.C Example</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>
<?Pub _font TypeSize="8pt">
<?sml-point-size 10>
<!--no-op:  12-->
#include &lt;stdio.h>
#include "string_tree.h"  /* header created by idl compiler */
#define check_error(s, msg) if(s != rpc_s_ok) \
  {fprintf(stderr, "%s", msg); exit(1);}

main ()
{
  unsigned32              status;   /* error status (nbase.h) */
  rpc_binding_vector_p_t  binding_vector;
                            /* set of binding handles (rpc.h) */ 
                         
  rpc_server_register_if(   /* register interface with RPC runtime */
    string_tree_v0_0_s_ifspec, 
                        /* interface specification (string_tree.h) */ 
    NULL,                     
    NULL,                     
    &amp;status                                    /* error status */
  );
  check_error(status, "Can't register interface\n");

  rpc_server_use_all_protseqs(     /* establish protocol sequences */
    rpc_c_protseq_max_calls_default, 
                          /* concurrent calls server takes (rpc.h) */ 
    &amp;status
  );
  check_error(status, "Can't establish protocol sequences\n");

<?sml-need 5>  rpc_server_inq_bindings( /* get set of this server's binding handles */
    &amp;binding_vector,          
    &amp;status
  ); 
  check_error(status, "Can't get binding handles\n");

<?sml-need 8>  rpc_ep_register(      /* register addresses in endpoint map database */
    string_tree_v0_0_s_ifspec,              /* interface specification */
    binding_vector,      /* (string_tree.h) the set of binding handles */
    NULL,                     
    "",                       
    &amp;status 
  );
  check_error(status, "Can't add address to the endpoint database\n");

  rpc_ns_binding_export(                  /* establish namespace entry */
    rpc_c_ns_syntax_dce,           /* syntax of the entry name (rpc.h) */
    "string_tree",                  /* entry name in directory service */
    &amp;string_tree_v0_0_s_ifspec,             /* interface specification */
    binding_vector,      /* (string_tree.h) the set of binding handles */
    NULL,
    &amp;status 
  );
  check_error(status, "Can't export to directory service\n");

  rpc_binding_vector_free(              /* free set of binding handles */
    &amp;binding_vector,
    status
  ); 
  check_error(status, "Can't free binding handles and vector\n");

  rpc_server_listen(                        /* listen for remote calls */
    rpc_c_listen_max_calls_default, 
                           /* concurrent calls server executes (rpc.h) */
    &amp;status
  );
  check_error(status, "rpc listen failed\n");
}   
<?sml-point-size 12>
<!--no-op:  14-->
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
<Para><?sml-need 13><Literal>The STRING_TREE.OUTPUT Example</Literal>
</Para>
<InformalExample>
<Para><ProgramListing><?sml-point-size 10>
<!--no-op:  12-->
Original Tree:
    Root Node
       Left subtree
           Child of left subtree
       Right subtree
Pruned Tree:
    Root Node
        Right subtree
Pruned subtree:
    Left subtree
        Child of left subtree
<?sml-point-size 12>
<!--no-op:  14-->
</ProgramListing></Para>
</InformalExample>
</Sect3>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.101">
<Title>Customized Handles</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.310">
<Primary>customized handles</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.311">
<Primary>IDL</Primary>
<Secondary>customized handles</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.312">
<Primary>handle</Primary>
<Secondary>customized</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.313">
<Primary>handle</Primary>
<Secondary>attribute</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.314">
<Primary>types</Primary>
<Secondary>IDL</Secondary>
</IndexTerm>
<Para>The <Literal>handle</Literal> attribute specifies that the type being declared
is a user-defined, nonprimitive handle type, and is to be used in
place of the predefined primitive handle type <StructName Role="typedef">handle_t</StructName>.
The term <FirstTerm>customized handle</FirstTerm> is used to denote a nonprimitive handle.
</Para>
<Para>The following example declares a customized handle type 
<StructName Role="typedef">filehandle_t</StructName>, a structure containing the textual 
representations of a host and a pathname:
</Para>
<InformalExample>
<Para><ProgramListing>typedef [handle] struct {
     char host[256];
     char path[1024];
     } filehandle_t;
</ProgramListing></Para>
</InformalExample>
<Para>If the handle parameter is the first parameter in the list,
then it is a customized handle that is used to determine the binding for the
call, and it must have the <Literal>in</Literal> attribute or the <Literal>in,out</Literal> attributes.
A handle parameter that 
is not the first parameter in the parameter list need not have the
<Literal>in</Literal> or <Literal>in,out</Literal> attributes.
</Para>
<Para>Note that a <StructName Role="typedef">handle_t</StructName> parameter that is the first parameter in the list
must not have the <Literal>transmit_as</Literal> attribute.
</Para>
<Para><?sml-need 6>To build an application that uses customized handles, you must write
custom binding and unbinding routines, and you must link those routines
with your application client code.  At runtime, each time the client
calls an operation that uses a customized handle, the client stub calls
the custom binding routine before it sends the remote procedure call
request, and the client stub calls the custom unbinding routine after
it receives a response.
</Para>
<Para>The following paragraphs specify C prototypes for customized binding
and unbinding routines; in these prototypes, <Symbol Role="Variable">CUSTOM</Symbol> is the
name of the customized handle type.
</Para>
<Para>The custom binding routine <Symbol Role="Variable">CUSTOM</Symbol><Literal>_bind</Literal> generates a primitive 
binding handle from a customized handle and returns the primitive 
binding handle:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><StructName Role="typedef">handle_t</StructName> <Symbol Role="Variable">CUSTOM</Symbol><Literal>_bind</Literal> (<Symbol Role="Variable">CUSTOM c-handle</Symbol><Literal>)</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The custom unbinding routine <Symbol Role="Variable">CUSTOM</Symbol><Literal>_unbind</Literal> takes two
inputs, a customized handle and the primitive 
binding handle that was generated from
it, and has no outputs:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>void</Literal> <Symbol Role="Variable">CUSTOM</Symbol><Literal>_unbind (</Literal>
<Symbol Role="Variable"> CUSTOM c-handle</Symbol><Literal>,
 handle_t </Literal><Symbol Role="Variable">rpc-handle</Symbol><Literal>)</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>A custom unbinding routine typically frees the primitive 
binding handle and any
unneeded resources associated with the customized handle, but it is not
required to do anything.
</Para>
<Para>Because the <Literal>handle</Literal> attribute can occur only in a 
type declaration, a customized handle must 
have a named type.  Because 
customized handle type names are used to construct 
custom binding and unbinding
routine names, these names cannot exceed 24 characters.
</Para>
<Para>A customized handle can be coded either in a 
parameter list as an explicit
handle or in an interface header as an implicit handle.
<?sml-break><?sml-need 16></Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.102">
<Title>Context Handles</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.315">
<Primary>handle</Primary>
<Secondary>context</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.316">
<Primary>context handle</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.317">
<Primary>context handle</Primary>
<Secondary>attribute</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.318">
<Primary>context_handle attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.319">
<Primary>server</Primary>
<Secondary>state</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.320">
<Primary>saved server state</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.321">
<Primary>opaque pointer</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.322">
<Primary>pointers</Primary>
<Secondary>opaque</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.323">
<Primary>address space association</Primary>
</IndexTerm>Manager code often maintains state information for a client. 
A handle to this state information is passed to the
client in an output parameter or as an operation result. 
The client passes the unchanged handle-to-the-state information as 
an input or input/output parameter of a subsequent manager
operation that the client
calls to manipulate that data structure.  This handle-to-the-state 
information is called a <FirstTerm>context handle</FirstTerm>.  A 
context handle is implemented as an untyped pointer or a pointer
to a structure by tag name.
<IndexTerm Id="DCEADG.RPCIDL.indx.324">
<Primary>pointers</Primary>
</IndexTerm></Para>
<Para>The manager causes the untyped pointer or the structure pointer
to point to the state information it will need the next time the
client asks the manager to manipulate the context.  For the
client, the context handle is an opaque pointer (<StructName Role="typedef">idl_void_p_t</StructName>
or an opaque structure tag).
<IndexTerm Id="DCEADG.RPCIDL.indx.325">
<Primary>pointers</Primary>
</IndexTerm>The client receives or supplies the context handle by means
of the parameter list but does not perform any transformations on it.
</Para>
<Para>The RPC runtime maintains the context handle, providing
<IndexTerm Id="DCEADG.RPCIDL.indx.326">
<Primary>runtime</Primary>
</IndexTerm>an association between the client and
the address space running the manager and the state information
within that address space.
</Para>
<Para>If a manager supports multiple interfaces, and a
client obtains a context handle by performing an operation from one of
these interfaces, the client can then supply the context handle
to an operation from another of these interfaces.
</Para>
<Para>A context handle can only be exchanged between the server process that
created it and the client process for which it was created.
No other client except the one that obtained the
context handle can use it without causing an application error. 
</Para>
<Sect3 Id="DCEADG.RPCIDL.div.103">
<Title>The context_handle Attribute</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.327">
<Primary>context_handle attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.328">
<Primary>handle</Primary>
<Secondary>context</Secondary>
</IndexTerm>Specify a context handle by one of the following methods:
</Para>
<ItemizedList>
<ListItem>
<Para>Use the <Literal>context_handle</Literal> attribute on a parameter of 
type <Literal>void *</Literal>.
</Para>
</ListItem>
<ListItem>
<Para>Use the <Literal>context_handle</Literal> attribute on a type that is defined
as <Literal>void *</Literal>.
</Para>
</ListItem>
<ListItem>
<Para>Use the <Literal>context_handle</Literal> attribute on a type that is defined as
a pointer to a structure by tag name.
</Para>
</ListItem>
</ItemizedList>
<Para><?sml-need 4>For example, in the IDL file, you
can define a context handle within a type declaration as follows:
</Para>
<InformalExample>
<Para><ProgramListing>typedef [context_handle] void * my_context;
</ProgramListing></Para>
</InformalExample>
<Para>or within a parameter declaration as follows:
</Para>
<InformalExample>
<Para><ProgramListing>[in, context_handle] void * my_context;
</ProgramListing></Para>
</InformalExample>
<Para>You can also define a context handle within a type declaration
as a forward reference to a structure type by tag, as follows:
</Para>
<InformalExample>
<Para><ProgramListing>typedef [context_handle] struct opaque_struct * opaque_ch_t;
</ProgramListing></Para>
</InformalExample>
<Para>Note that you do not need to define the structure type in the IDL file;
it is a forward reference to a structure whose definition can be
included into the server code, either from a private <Filename>.h</Filename> file
or from a server IDL file.  As a result, the structure type is opaque
to the client.  This method of defining a context handle provides
type checking and permits the server code to avoid extensive
casting when manipulating the context handle.
</Para>
<Para>A structure type in a context handle type definition must be
referenced by tag name and not by type name.  So, for example, the
first of the following declarations is valid, while the second
is not:
</Para>
<InformalExample>
<Para><ProgramListing>typedef [context_handle] struct struct_tag * valid_ch_t; 
                                                  /* valid */

typedef [context_handle] struct_type * invalid_ch_t; 
                                                  /* error */
</ProgramListing></Para>
</InformalExample>
<Para>The following example illustrates context handles defined as untyped
pointers and as pointers to structures by tag name.
</Para>
<InformalExample>
<Para><ProgramListing><?sml-need 19>/* A context handle implemented as untyped pointer */
typedef [context_handle] void * void_ch_t;

/* A context handle implemented as a  */
/* pointer to a structure by tag name */
typedef [context_handle] struct opaque_struct * opaque_ch_t;

/* Operations using both types of context handles */
void ch_oper(
     [in] void_ch_t v1,
     [in,out] void_ch_t *v2,
     [out] void_ch_t *v3,
     [in] opaque_ch_t *o2,
     [out] opaque_ch_t *o3
);

void_ch_t void_ch_oper ([in] handle_t h);

opaque_ch_t opaque_ch_oper([in] handle_t h);
</ProgramListing></Para>
</InformalExample>
<Para>It is possible to define a structure type in a context handle in the IDL
file; for example, the following structure definition
can either precede or follow the definition of <StructName Role="typedef">valid_ch_t</StructName>
in the example previously shown:  
</Para>
<InformalExample>
<Para><ProgramListing>typedef struct struct_tag {long l;} struct_type;
</ProgramListing></Para>
</InformalExample>
<Para>This practice is not recommended, however,
since it violates the opaqueness of the context handle type.
</Para>
<Para>The type name in a context handle declaration must be no longer than 23
characters.
</Para>
<Para>The first operation on a context creates a context handle that the
server procedure passes to the client.  
The client then passes the unmodified handle back to the server in a
subsequent remote call.  The called procedure interprets the context
handle.  For example, to specify a procedure that a client can use to
obtain a context handle, you can define the following:
</Para>
<InformalExample>
<Para><ProgramListing>typedef [context_handle] void * my_context;
void op1(
   [in]handle_t h,
   [out] my_context * this_object);
</ProgramListing></Para>
</InformalExample>
<Para><?sml-need 4>To specify a procedure that a client can call to make use of a previously
obtained context handle, you can define the following:
</Para>
<InformalExample>
<Para><ProgramListing>void op2([in] my_context this_object);
</ProgramListing></Para>
</InformalExample>
<Para>To close a context, and to clean the context on the client side, you
can define the following:
</Para>
<InformalExample>
<Para><ProgramListing>[in, out, context_handle] void * my_context;
</ProgramListing></Para>
</InformalExample>
<Para>The resources associated with a context handle are reclaimed when, and
only when, the manager changes the value of the <Literal>in,out</Literal> context
handle parameter from non-NULL to NULL.
</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.104">
<Title>The Context Rundown Procedure</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.329">
<Primary>context rundown procedure</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.330">
<Primary>rundown</Primary>
<See>context rundown procedure</See>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.331">
<Primary>routines</Primary>
<Secondary>context rundown</Secondary>
</IndexTerm>Some uses of context handles may require you to write a 
context rundown procedure in the application code
for the server.  If communications between the client and server are
<IndexTerm Id="DCEADG.RPCIDL.indx.332">
<Primary>communication failure</Primary>
<Secondary>context rundown</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.333">
<Primary>context handle</Primary>
<Secondary>resource recovery</Secondary>
</IndexTerm>broken while the server is maintaining context for the client, RPC
invokes the context rundown procedure on the server to recover the
resources represented by the context handle.  If you declare a context
handle as a named type, you must supply a rundown procedure for
that type.
</Para>
<Para>When a context requires a context rundown procedure, you must define a
named type that has the <Literal>context_handle</Literal> attribute. 
For each different
context handle type, you must provide a context rundown procedure as
part of the manager code.
</Para>
<Para>The format for the rundown procedure name is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">context_type_name</Symbol><Literal>_rundown</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>A rundown procedure takes one parameter, the handle of the context to be
run down, and delivers no result.  For example, if you declare the following:
</Para>
<InformalExample>
<Para><ProgramListing>typedef [context_handle] void * my_context;
</ProgramListing></Para>
</InformalExample>
<Para><?sml-need 3>then the rundown procedure is as follows:
</Para>
<InformalExample>
<Para><ProgramListing>void my_context_rundown (my_context this_object);
</ProgramListing></Para>
</InformalExample>
<Para>Server application code that uses a certain context handle may be
executing in one or more server threads at the time that RPC detects that
communications between the server and the client that is using that context
have broken.  The context rundown routine will not be invoked until a return
of control to the server stub has happened in each of the threads that were
using the context handle.
</Para>
<Para>If application code in any of these threads destroys the context before
returning control to the server stub from which it was called, your context
rundown procedure will not be executed.
</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.105">
<Title>Creating New Context</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.334">
<Primary>context handle</Primary>
<Secondary>creating new</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.335">
<Primary>creating</Primary>
<Secondary>context</Secondary>
</IndexTerm>
<Para>When a client makes its first request to the manager to manipulate 
context, the manager creates context information and
returns this information to the client through a 
parameter of the type <Literal>context_handle</Literal>.  This parameter 
must be an output parameter or an
input/output parameter whose value is NULL when the call is made.
A context handle can also be a function result.
</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.106">
<Title>Reclaiming Client Memory Resources for the Context Handle</Title>
<Para>In the event that a communications error causes the context handle 
to be unusable, the resources that maintain the context handle must
be reclaimed.  Use the <Function>rpc_ss_destroy_client_context()</Function> routine
in the client application to reclaim the client-side resources and
to set the context handle value to NULL.
</Para>
<Para>The syntax of the routine is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>void rpc_ss_destroy_client_context(
     void *</Literal><Symbol Role="Variable">p_unusable_context_handle);</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.107">
<Title>Relationship of Context Handles and Binding</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.336">
<Primary>context handle</Primary>
<Secondary>and binding</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.337">
<Primary>binding</Primary>
<Secondary>context handle</Secondary>
</IndexTerm>
<Para>For the client, the context handle specifies 
the state within a server and also contains binding
information.  If an operation has an input context handle or 
input/output context handle that is not NULL, it is not necessary
to supply any
other binding information.  A context handle that has only the <Literal>in</Literal>
attribute cannot be NULL. If an operation has 
<Literal>in,out</Literal> context handle parameters
but no <Literal>in</Literal> context handle parameters, at least one of the
<Literal>in,out</Literal> context handle parameters cannot be NULL.
However, if the only context handle
parameters in an operation are output, they carry
no binding information.  In this case, you must use another method to
bind the client to a server.
</Para>
<Para>If you specify multiple context handles in an operation, all active
context handles must map to the same remote address space on the same
server or the call fails.  (A context handle is active while it
represents context information that the server maintains for the
client.  It is inactive if no context has yet been created, or if the
context is no longer in use.)
</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.108">
<Title>Rules for Using Context Handles</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.338">
<Primary>context handle</Primary>
<Secondary>usage rules</Secondary>
</IndexTerm>
<Para>The following rules apply to using context handles:
</Para>
<ItemizedList>
<ListItem>
<Para>A context handle can be a parameter or a function result. 
You cannot use context handles
as an array element, as a structure or union member, or as 
the element type of a pipe.
</Para>
</ListItem>
<ListItem>
<Para>A context handle cannot have the <Literal>transmit_as</Literal> or <Literal>ptr</Literal> 
attributes.
</Para>
</ListItem>
<ListItem>
<Para>An input-only context handle cannot be NULL.
</Para>
</ListItem>
<ListItem>
<Para>A context handle cannot be pointed to, except by a top-level reference
pointer.
</Para>
</ListItem>
</ItemizedList>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.109">
<Title>Examples Using Context Handles</Title>
<Para>The following examples show a sample IDL file that uses
context handles and a sample context rundown procedure
file.
</Para>
<Para><Literal>Example of an IDL File That Uses a Context Handle</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>/*
 * Filename: context_handle.idl
 */
[uuid(f38f5080-2d27-11c9-a96d-08002b0ecef1),
 pointer_default(ref), version (1.0)] 
interface files
{
/* File context handle type */
typedef [context_handle] void * file_handle_t;  
/* File specification type */
typedef [string] char * filespec_t;             
/* File read buffer type */
typedef [string] char buf_t[*];                 

 /*
  * The file_open call requires that the client has located a 
  * file server interface files and that an RPC handle that is 
  * bound to that server be passed as the binding parameter h.
  *
  * Operation to OPEN a file; returns context handle for that 
  * file.
  */
file_handle_t file_open         
(                               
 /* RPC handle bound to file server */
    [in] handle_t h,            
 /* File specification of file to open */
    [in] filespec_t fs          
);

<?sml-need 20> /*
  * The file_read call is able to use the context handle 
  * obtained from the file_open as the binding parameter, 
  * thus an RPC handle is not necessary.
  *
  * Operation to read from an opened file; returns true if
  * not end-of-file 
  */
boolean file_read               
(
 /* Context handle of opened file */
    [in] file_handle_t fh,      
 /* Maximum number of characters to read */
    [in] long buf_size,         
 /* Actual number of characters of data read */
    [out] long *data_size,      
 /* Buffer for characters read */
    [out, size_is(buf_size), length_is(*data_size)] \
      buf_t buffer
);
 /* Operation to close an opened file */
void file_close                 
(                               
 /* Valid file context handle goes [in]. On successful close, 
  * null is returned.
  */
    [in,out] file_handle_t *fh  
);
}
</ProgramListing></Para>
</InformalExample>
<Para><?sml-need 32><Literal>Example of a Context Rundown Procedure</Literal>
</Para>
<InformalExample>
<Para><ProgramListing>/*
 * fh_rundown.c:  A context rundown procedure.
 */

#include &lt;stdio.h>
#include "context_handle.h"   /* IDL-generated header file */

void file_handle_t_rundown
(
    file_handle_t file_handle   /* Active context handle */
                                 * (open file handle)    */
)

{
    /*
     * This procedure is called by the RPC runtime on the 
     * SERVER side when communication is broken between the 
     * client and server.  This gives the server the 
     * opportunity to reclaim resources identified by the 
     * passed context handle.  In this case, the passed 
     * context handle identifies a file, and simply closing 
     * the file cleans up the state maintained by the context 
     * handle, that is "runs down" the context handle.  Note 
     * that the file_close manager operation is not used here; 
     * perhaps it could be, but it is more efficient to use 
     * the underlying file system call to do the close.
     *
     * File handle is void*, it must be cast to FILE*
     */
    fclose((FILE *)file_handle);
}
</ProgramListing></Para>
</InformalExample>
</Sect3>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.RPCIDL.div.110">
<Title>IDL Support for C++</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.339">
<Primary>IDL support for C++</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.340">
<Primary>C++ support in IDL</Primary>
</IndexTerm>Most of the IDL features apply to both C and C++ applications.  
However,
just as C++ is an extension to C, this section describes additional IDL
features required to use IDL effectively with C++.
</Para>
<Para>When the IDL compiler compiles an interface definition, it typically
generates a header file and one or more intermediate stub files in C
or C++, and then it invokes the appropriate compiler to generate
object stub files.  The IDL Compiler generates C language intermediate
<!-- COMMENTED OUT FOR AIX:-->
<!-- .iX "-lang cxx option"-->
<IndexTerm Id="DCEADG.RPCIDL.indx.341">
<Primary>generating C++ files</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.342">
<Primary>C++</Primary>
<Secondary>generating from IDL</Secondary>
</IndexTerm>stub files by default, but you can use the <Option>lang cxx</Option> option to
cause it to generate C++ files instead.
</Para>
<Para>This section describes the following topics:
</Para>
<ItemizedList>
<ListItem>
<Para>The <Command>idl</Command>-generated class hierarchy
</Para>
<Para>This is important for a basic understanding of how to integrate 
the interface into an object-oriented application.
</Para>
</ListItem>
<ListItem>
<Para>Interface inheritance
</Para>
<Para>One interface can be derived from another, just as classes are derived 
from other classes.
</Para>
</ListItem>
<ListItem>
<Para>Static operations
</Para>
<Para>Static operations specify member functions that are called 
independently from an object.  All other operations specify 
nonstatic member functions which are only invoked with respect to 
an existing object.
</Para>
</ListItem>
<ListItem>
<Para>Reference parameters
</Para>
<Para>Reference parameters are passed by reference instead of being passed by value. 
</Para>
</ListItem>
<ListItem>
<Para><Command>idl</Command>-generated member functions
</Para>
<Para>Several member functions are generated by IDL and made part of the interface class.  
These functions perform useful operations for all interfaces.
</Para>
</ListItem>
</ItemizedList>
<Sect2 Id="DCEADG.RPCIDL.div.111">
<Title>The idl-generated Class Hierarchy</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.343">
<Primary>idl-generated class hierarchy</Primary>
</IndexTerm>For C++ applications, the interface definition specifies a public
interface class.  This means that IDL data types specify public data
members of the interface class, and IDL operations specify member
functions.  The IDL compiler generates this<Symbol Role="Variable"> interface class</Symbol>
within C++ class hierarchies for both the client and server.  The RPC
network mechanisms are encapsulated in a class above the interface
class.  Clients use (and servers implement) the objects of
classes below the interface class.

</Para>
<Sect3 Id="DCEADG.RPCIDL.div.112">
<Title>The rpc_object_reference Base Class</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.344">
<Primary><Literal>rpc_object_reference</Literal> base class</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.345">
<Primary>base class <Literal>rpc_object_reference</Literal></Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.346">
<Primary>RPC encapsulation</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.347">
<Primary>encapsulating RPCs</Primary>
</IndexTerm>Because C++ makes it easy to hide information, the IDL compiler
generates an <Literal>rpc_object_reference</Literal> <Symbol Role="Variable">base class</Symbol> for
identifying, distributing, and tracking objects.  All interface
classes inherit the <Literal>rpc_object_reference</Literal> class, 
which encapsulates the following information:
</Para>
<ItemizedList>
<ListItem>
<Para>Object binding information, including server binding information 
and an object UUID representing the object on the particular server
</Para>
</ListItem>
<ListItem>
<Para>Transport protocol information for the server
</Para>
</ListItem>
<ListItem>
<Para>A name identifying an optional location in the namespace for
the object's binding information
</Para>
</ListItem>
<ListItem>
<Para>A location flag indicating whether the object is on the
local system or a remote system
</Para>
</ListItem>
<ListItem>
<Para>A reference count to keep track of how many clients
currently access the object
</Para>
</ListItem>
</ItemizedList>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.113">
<Title>The Interface Class</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.348">
<Primary>interface class</Primary>
</IndexTerm>For each interface, the IDL compiler generates and places in the
header file the interface class derived from the
<Literal>rpc_object_reference</Literal> class.  The class name generated is the
interface name specified in the interface definition.  For example,
the compiler generates the following class:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>class </Literal> <Symbol Role="Variable">interface_name</Symbol><Literal> : public  virtual   rpc_object_reference</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>This is an abstract class that contains public functions for all the
operations specified in the IDL interface.  The member functions that
are not static object creator functions are defined as pure virtual
functions.  In C++, an abstract class contains at least one pure
virtual function, which means that the implementation is postponed
until a later, derived class.  Therefore, object instances cannot be
created for abstract classes, and thus the interface class is not
implemented but is only a declaration.  Other classes must be derived
from the interface class so that objects can be created for clients
and servers.
</Para>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.349">
<Primary>constructor</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.350">
<Primary>destructor</Primary>
</IndexTerm>No constructor operations are allowed in the interface definition, and
the IDL compiler does not generate one because no objects are created
for the interface class.  No destructor operations are allowed in the
interface definition, but the compiler generates one automatically for
the interface class.

</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.114">
<Title>The Client's Proxy Class</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.351">
<Primary>client proxy class</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.352">
<Primary>proxy class for client</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.353">
<Primary>object reference</Primary>
</IndexTerm>The IDL compiler places in the header file a<Symbol Role="Variable"> proxy class</Symbol> derived
from the interface class.  An instance of a proxy class is also known
as an <Symbol Role="Variable">object reference</Symbol>, which clients use to access a remote
object.  This class provides proxy (or surrogate) objects on the
client whose member functions (or methods) transparently perform the
RPCs that invoke the actual remote object's member functions on the
server.  The proxy class name is generated from the interface name and
the word <Literal>Proxy</Literal>, as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>class</Literal> <Symbol Role="Variable">interface_name</Symbol><Literal>Proxy : public</Literal> <Symbol Role="Variable">interface_name</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>Implementations of the proxy class's member functions are automatically
generated in the client stub and represent the client's implementation
of the interface's operations.

</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.115">
<Title>The Server's Manager Class</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.354">
<Primary>server manager class</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.355">
<Primary>manager class for server</Primary>
</IndexTerm>A <Symbol Role="Variable">manager class</Symbol> is required for servers to implement the interface.
The class is generated by the IDL compiler and derived from the 
interface class as follows:
</Para>
<InformalExample>
<Para><ProgramListing>class  <Symbol Role="Variable">interface_name</Symbol><Literal>_Mgr</Literal> : public <Symbol Role="Variable"> interface_name </Symbol> {
public:
    .
    .
    .
}
</ProgramListing></Para>
</InformalExample>
<Para>The class is placed in a header file whose name is based on the 
IDL file and an <Literal>_mgr</Literal> suffix. 
When generated, the manager class contains empty
functions of all the nonstatic member functions of the interface class.  
The member function implementations and other
implementation details of this class are called <Symbol Role="Variable">manager code</Symbol>.

</Para>
</Sect3>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.116">
<Title>The Interface Inheritance Operator</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.356">
<Primary>interface inheritance</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.357">
<Primary>inheritance of interfaces</Primary>
</IndexTerm>An interface definition can inherit properties of a previously defined
interface, just as a C++ class can inherit properties of previously
defined classes.  You can modify an interface
definition to inherit an interface by using the inheritance operator
(<Literal>:</Literal>) in the interface header, as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>[<Symbol Role="Variable">interface_attribute, ...</Symbol><Literal>] interface</Literal> <Symbol Role="Variable">interface_name</Symbol> <Symbol Role="Variable">[ : inherited_interface ]</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>This <Command>idl</Command>-generated header file contains the inherited interface's data 
types and interface class.  The interface definition must also declare the
information in the inherited interface's header file by using an
<Literal>import</Literal> declaration in the body of the interface.  The following
<IndexTerm Id="DCEADG.RPCIDL.indx.358">
<Primary>derived interface</Primary>
</IndexTerm>example shows how the <Literal>derived</Literal> interface inherits another
interface and imports that interface's definition file. The inherited
interface definition file is named<Filename> inherit.idl</Filename>, and the
interface it contains is named <Literal>inherit</Literal>.
</Para>
<InformalExample>
<Para><ProgramListing>interface derived : inherit
{
	import "inherit.idl";
	.
	.
	.
}
</ProgramListing></Para>
</InformalExample>
<Para>A interface may inherit only one interface; 
that is, multiple interface inheritance is not allowed.

</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.117">
<Title>The static Keyword for Operations</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.359">
<Primary>static keyword</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.360">
<Primary>IDL</Primary>
<Secondary>static keyword</Secondary>
</IndexTerm>In C++ applications, the interface definition operations specify the
member functions of the interface class.  The majority of the member
functions are invoked by an existing object, but some operations are
intended to work regardless of whether an object invokes them or not.
Static member functions are invoked independently from any object and
are good for such things as object creator functions and for obtaining
a class's static data; that is, data that is class-wide and
independent from a specific object.
</Para>
<Para>Static member functions may be specified in an interface definition by
using the <Literal>static</Literal> keyword in front of the operation, 
in one of the following ways:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>static </Literal> <Symbol Role="Variable">return_type operation_identifier</Symbol><Literal>(...);</Literal>

<Literal>[</Literal><Symbol Role="Variable">operation_attribute</Symbol>, ...<Literal>] static</Literal>  <Symbol Role="Variable">return_type operation_identifier</Symbol><Literal>(...);</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>Instead of using the <Literal>static</Literal> keyword in the interface definition,
you can use the <Literal>cxx_static</Literal> attribute in an ACF.
</Para>
<Para>Since non-static member functions are invoked by an object for which
the application must already have a binding, nonstatic operations
cannot have a binding handle parameter.  If you want to use explicit
binding for an interface, only static operations can have a binding
handle as the first parameter.

</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.118">
<Title>The C++ Reference Operator (&amp;) on Parameters</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.361">
<Primary>C++ reference operator, &amp;</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.362">
<Primary>reference operator, &amp;</Primary>
</IndexTerm>C++ passes arguments by value; however, to override this and cause a
member function argument to be passed by reference, apply the
reference operator (<Literal>&amp;</Literal>) to the parameter in the interface definition.
Specify a reference parameter as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>[<Symbol Role="Variable">parameter_attribute,...</Symbol>]  <Symbol Role="Variable">parameter_type </Symbol> &amp;<Symbol Role="Variable">parameter</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.363">
<Primary>ref attribute</Primary>
</IndexTerm>Using the reference operator on a parameter is the same as applying
the reference pointer attribute (<Literal>[ref]</Literal>) to a pointer parameter.

</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCIDL.div.119">
<Title>Functions Generated by IDL</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.364">
<Primary>idl-generated functions for C++</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.365">
<Primary>functions generated by IDL</Primary>
</IndexTerm>The IDL compiler generates some additional member functions for an
interface class.  For clients, these functions include overloaded
static member functions to bind to remote named objects in various
ways and a member function to set security information.  For servers,
additional member functions exist to advertise named objects and get
the binding handle on which a member function was called from within
the member function implementation.
</Para>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.366">
<Primary>overloaded functions</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.367">
<Primary>object reference</Primary>
</IndexTerm>Four overloaded functions for binding clients to known objects are
named<Literal> bind()</Literal>.  The functions otherwise differ by the type of
parameter passed in.  Three of these functions are intended for use
with named objects and one is used to swap between interfaces when an
object supports more than one interface.  
Each <Function>bind()</Function> function obtains an <Symbol Role="Variable">object reference</Symbol>
(instance of a proxy class) by returning a pointer to the interface class.
These functions are described in the following sections.

</Para>
<Sect3 Id="DCEADG.RPCIDL.div.120">
<Title>The bind() Function for Binding by an Object's Name</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.368">
<Primary>binding by object name</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.369">
<Primary><Function>bind()</Function> by object name</Primary>
</IndexTerm>A client can bind to a named object (an object whose name is
advertised in a name service) by calling the <Command>idl</Command>-generated <Literal>bind() </Literal> static member function with the name service name as an argument.
The function's prototype is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">interface_class</Symbol> * <Symbol Role="Variable">interface_class</Symbol><Literal>::bind( unsigned_char_t  *)</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>This function takes a pointer argument of type <StructName Role="typedef">unsigned_char_t</StructName>
that points to a name service name.  The function returns a pointer to
the interface class.  For example:
</Para>
<InformalExample>
<Para><ProgramListing>char *CDS_name = "/.:/object_name";
IF_class * object = IF_class::bind( (unsigned_char_t *) CDS_name);
</ProgramListing></Para>
</InformalExample>
<Para>If the entry contains more than one binding, one is returned at
random. The function obtains a full binding (the binding information
includes a server's endpoint.)
</Para>
<Para>Before a client uses this function, a persistent object on a server
typically places its name and binding information in the name service
by using the <Command>idl</Command>-generated <Function>register_named_object()</Function> member
function.
</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.121">
<Title>The bind() Function for Binding by an Object's UUID</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.370">
<Primary>binding by object UUID</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.371">
<Primary><Function>bind()</Function> by object UUID</Primary>
</IndexTerm>A client can bind to a named object by using the object's UUID as an
argument to the <Command>idl</Command>-generated <Literal> bind()</Literal> static member
function.  This function's prototype is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">interface_class</Symbol> <Literal>* </Literal>interface_class<Literal>::bind( uuid_t &amp;)</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>This function takes an argument of type<Literal> uuid_t</Literal> that is the UUID
of a named object.  The function returns a pointer to the interface
class.  For example:
</Para>
<InformalExample>
<Para><ProgramListing>uuid_t objectUUID;
interface_class * object = interface_class::bind(objectUUID);
</ProgramListing></Para>
</InformalExample>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.372">
<Primary>RPC_DEFAULT_ENTRY</Primary>
</IndexTerm>The search in the namespace for an entry that contains the matching
UUID begins with the default entry named in the
<Literal>RPC_DEFAULT_ENTRY</Literal> environment variable. The binding obtained is
fully bound.

</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.122">
<Title>The bind() Function for Binding by Binding Handle</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.373">
<Primary>binding by object binding handle</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.374">
<Primary><Function>bind()</Function> by object binding handle</Primary>
</IndexTerm>A client can bind to a known object directly by using a binding handle
as an argument to the <Command>idl</Command>-generated <Function>bind()</Function> static member
function.  This function's prototype is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">interface_class</Symbol> * <Symbol Role="Variable">interface_class</Symbol><Literal>::bind( rpc_binding_handle_t)</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>This function takes an argument of type <StructName Role="typedef">rpc_binding_handle_t</StructName>
that is a binding handle to an object.  The function returns a pointer
to the interface class.  For example:
</Para>
<InformalExample>
<Para><ProgramListing>rpc_binding_handle_t bindingHandle;
interface_class * object = interface_class::bind(bindingHandle);
</ProgramListing></Para>
</InformalExample>
<Para>This function does not use the name service because the client obtains
the binding information and binding handle prior to the call.  The
binding handle can be either partially or fully bound. If the binding
handle is partially bound, it becomes fully bound when the object
calls a member function.

</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.123">
<Title>The bind() Function for Binding by Object Reference</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.375">
<Primary>binding by object reference</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.376">
<Primary><Function>bind()</Function> by object reference</Primary>
</IndexTerm>Depending on the application, objects can have the behavior of more
than one interface class.  However, your code can access only one
interface's member functions at a time.  A client uses the
<Command>idl</Command>-generated <Function>bind()</Function> static member function with an existing
object reference as an argument to bind to a different interface.
This function's prototype is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">different_interface_class</Symbol> * <Symbol Role="Variable">different_interface_class</Symbol><Literal>::bind( rpc_object_reference *)</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>This function takes a pointer argument of type
<Literal>rpc_object_reference</Literal> that is an existing object reference to an
interface class.  The function returns a pointer to a different
interface class that the object also supports.  The original object is
obtained through a previous <Function>bind()</Function> call, an object creator
function, or an output parameter of a member function. For example:
</Para>
<InformalExample>
<Para><ProgramListing>rpc_binding_handle_t bindingHandle;
interface_class * object = interface_class::bind(bindingHandle);
diff_if_class * new_object = diff_if_class::bind(object);
</ProgramListing></Para>
</InformalExample>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.124">
<Title>The secure() Function for Setting Object Security</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.377">
<Primary><Function>secure()</Function> function</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.378">
<Primary>security for objects</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.379">
<Primary>object security</Primary>
</IndexTerm>Objects use the <Command>idl</Command>-generated <Function>secure()</Function> member function to set
their authorization and authentication information from the client.
This sets the information for all the binding handles encapsulated in
the client proxy object.  The <Function>secure()</Function> function is a public 
member function of the <Literal>rpc_object_reference</Literal> class. 
This function's prototype is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><Literal>void</Literal> <Replaceable> interface_class</Replaceable><Literal>::secure(</Literal>
   <Replaceable>[</Replaceable><Literal>unsigned_char_t</Literal> *	<Replaceable>server_principal_name	= </Replaceable><Literal>0</Literal>,<Replaceable>]</Replaceable>
   <Replaceable>[</Replaceable><Literal>unsigned32</Literal>		<Replaceable>protection_level</Replaceable>		= <Literal>rpc_c_protect_level_default</Literal>,<Replaceable>]</Replaceable>
   <Replaceable>[</Replaceable><Literal>unsigned32</Literal>		<Replaceable>authentication_protocol	= </Replaceable><Literal>rpc_c_authn_default</Literal>,<Replaceable>]</Replaceable>
   <Replaceable>[</Replaceable><Literal>rpc_auth_identity_handle_t</Literal> <Replaceable>authorization_identity	= </Replaceable><Literal>NULL</Literal>,<Replaceable>]</Replaceable>
   <Replaceable>[</Replaceable><Literal>unsigned32</Literal>		<Replaceable>authorization_policy		= </Replaceable><Literal>rpc_c_authz_name</Literal><Replaceable>]</Replaceable>
)
</ProgramListing></Para>
</InformalExample>
<Para>The following code shows an example of how to use the <Function>secure()</Function> 
member function: 
</Para>
<InformalExample>
<Para><ProgramListing>Matrix         *m;

cout &lt;&lt; "creating a remote matrix" &lt;&lt; endl;
m = Matrix::createMatrix(1, 2, 3, 4);

cout &lt;&lt; "calling set() operation without authorization" &lt;&lt; endl;
m->set(0,0,99);
// Without authorization, operation should have not changed anything.
assert(m->get(0,0) == 1);

cout &lt;&lt; "setting security privileges on object" &lt;&lt; endl;
m->secure(
	(unsigned_char_t *) "refmon_test",	// server principal name
	rpc_c_protect_level_pkt_integ,	// protection level
	rpc_c_authn_dce_secret,		// authentication protocol
	NULL,				// inherited login context
	rpc_c_authz_name		// authorization policy
);

// since we now have set security flags, the set() operation 
// should work
m->set(0,0,99);
assert(m->get(0,0) == 99);
</ProgramListing></Para>
</InformalExample>
<Para>The example shows that unauthorized use of a matrix's member function
will not change values (<Literal>m->get(0,0,99);</Literal>).
However, after setting the appropriate authorization and authentication 
information with <Function>secure()</Function>, the member function will work as expected.
All parameters to the <Function>secure()</Function> function are optional, 
but it is recommended that you specify values rather than depend on the 
default values.

</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.125">
<Title>The SetRebind( ) Function</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.380">
<Primary><Function>SetRebind()</Function> function</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.381">
<Primary>objects</Primary>
<Secondary>automatic rebinding</Secondary>
</IndexTerm>A client can automatically rebind to an object if the client first sets a 
rebind policy by using the <Function>SetRebind()</Function> function.  
This allows a degree of fault tolerance in an application.  
For example, if a server goes down and is restarted, 
the client can re-establish communications with the new server.  
In another example, if a server provides access over multiple 
protocols or addresses and one of those links fails,
the client can choose another link automatically. 
Finally, if multiple servers support the same object and one 
server exits, clients can still access the object via another server.
</Para>
<Para>The format of the function is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><Literal>void</Literal> <Replaceable>interface_class</Replaceable>::<Literal>SetRebind(</Literal>
<Literal>        DCERebindPolicy </Literal> <Replaceable>policy</Replaceable>,
<Replaceable>        [</Replaceable> <Literal>unsigned32</Literal> *	<Replaceable>n</Replaceable> = 0 <Replaceable>]</Replaceable>
)
</ProgramListing></Para>
</InformalExample>
<Para>The second argument is optional and only used when the 
rebind policy is <Literal>attempt_rebind_n</Literal>.  
The valid policies include the following:
</Para>
<VariableList>
<VarListEntry role="linebreak">
<Term><Literal>attempt_rebind_n</Literal></Term>
<ListItem>
<?sml-break>
<IndexTerm Id="DCEADG.RPCIDL.indx.382">
<Primary><Literal>attempt_rebind_n</Literal></Primary>
</IndexTerm>
<Para>If a communication fails, try to communicate with the object
by selecting another binding until successful or until <Symbol Role="Variable">n</Symbol> 
attempts have been tried.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>wait_on_rebind</Literal></Term>
<ListItem>
<?sml-break>
<IndexTerm Id="DCEADG.RPCIDL.indx.383">
<Primary><Literal>wait_on_rebind</Literal></Primary>
</IndexTerm>
<Para>If a communication fails, try to communicate with the object
by selecting another binding until successful or until the calling 
thread is canceled.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>attempt_rebind</Literal></Term>
<ListItem>
<?sml-break>
<IndexTerm Id="DCEADG.RPCIDL.indx.384">
<Primary><Literal>attempt_rebind</Literal></Primary>
</IndexTerm>
<Para>If a communication fails, try to communicate with the object
by selecting another binding, if possible.  
If all handles have been tried, return an error.
This is the default policy.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>never_rebind</Literal></Term>
<ListItem>
<IndexTerm Id="DCEADG.RPCIDL.indx.385">
<Primary><Literal>never_rebind</Literal></Primary>
</IndexTerm>
<Para>If a communication fails, return an error.  
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para>
</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.126">
<Title>The register_named_object() Function</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.386">
<Primary><Function>register_named_object()</Function></Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.387">
<Primary>objects</Primary>
<Secondary>registering</Secondary>
</IndexTerm>Persistent objects can name and register themselves from the server by 
using the <Command>idl</Command>-generated <Function>register_named_object()</Function> 
member function.   This function performs the following tasks:
</Para>
<ItemizedList>
<ListItem>
<Para>Creates the name service entry (if it doesn't already exist) 
and adds the server's binding information so clients can find 
the server's host
</Para>
</ListItem>
<ListItem>
<Para>Replaces or adds the object's binding information in this host's 
endpoint map so clients can find this server
</Para>
</ListItem>
</ItemizedList>
<Para>This function's prototype is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><Literal>void</Literal> <Replaceable> interface_class</Replaceable>::<Literal>register_named_object(
                unsigned_char_t</Literal> *	<Replaceable>name_service_name</Replaceable>
        <Replaceable>[</Replaceable><Literal>, boolean32</Literal>	<Replaceable>replace_endpoint	=</Replaceable><Literal> TRUE</Literal> <Replaceable>]</Replaceable>
)
</ProgramListing></Para>
</InformalExample>
<Para>The function takes a pointer argument of type <StructName Role="typedef">unsigned_char_t</StructName>,
representing the name to use for the name service entry.  The function
has an optional second argument of type<Literal> boolean32</Literal> to indicate
whether to replace or add the object's binding information to the
host's endpoint map.  If the second argument is not used (or is set to
<Literal>TRUE</Literal>) and the object's binding information already exists, this
function replaces the information.  If the second argument is set to
<Literal>FALSE</Literal>, the object's binding information is added to the endpoint
map (not replaced).  You should add the binding information rather
than replace it in circumstances where a single host has more than one
server that offers the same interface.  The function does not return a
value.

</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCIDL.div.127">
<Title>The get_binding_handle() Function</Title>
<Para><IndexTerm Id="DCEADG.RPCIDL.indx.388">
<Primary><Function>get_binding_handle()</Function> function </Primary>
</IndexTerm>Server manager code uses the <Command>idl</Command>-generated 
<Function>get_binding_handle()</Function> function to obtain the binding handle 
used to invoke the call.  The function's prototype is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Function>rpc_binding_handle_t   get_binding_handle();</Function>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>Member functions (that are not static) cannot have an explicit binding
handle argument since the handle is encapsulated in the
<Literal>rpc_object_reference</Literal> base class.  A member function
implementation uses this function to obtain the binding handle to
verify security information, among other things.

</Para>
</Sect3>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.RPCIDL.div.128">
<Title>Associating a Data Type with a Transmitted Type</Title>
<IndexTerm Id="DCEADG.RPCIDL.indx.389">
<Primary>transmit_as attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.390" SpanEnd="DCEADG.RPCIDL.indx.14">
<Para>The <Literal>transmit_as</Literal> attribute associates a transmitted type
that stubs pass over the network with a presented type that
clients and servers manipulate.  The specified transmitted type 
must be a named type defined previously in another type declaration.
</Para>
<Para>There are two primary uses for this attribute:
</Para>
<ItemizedList>
<ListItem>
<Para>To
<IndexTerm Id="DCEADG.RPCIDL.indx.391">
<Primary>types</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCIDL.indx.392">
<Primary>complex types</Primary>
</IndexTerm>pass complex data types for which the IDL compiler cannot generate
marshalling and unmarshalling code.
</Para>
</ListItem>
<ListItem>
<Para>To pass data more efficiently.  An application can
provide routines to convert a data type between a sparse representation
(presented to the client and server programs) and a compact one (transmitted
over the network).
</Para>
</ListItem>
</ItemizedList>
<Para>To build an application that uses presented and transmitted types,
you must write routines to perform conversions between the types and
to manage storage for the types, and you must link those routines
with your application code.  At runtime, the client and server stubs
call these routines before sending and after receiving data of these
types.
</Para>
<Para>The following paragraphs specify C prototypes for generic binding
and unbinding routines; in these prototypes, <Symbol Role="Variable">PRES</Symbol> is the
name of the presented type and <Symbol Role="Variable">TRANS</Symbol> is the name of the transmitted
type.
</Para>
<Para>The <Symbol Role="Variable">PRES</Symbol><Function>_to_xmit()</Function> routine allocates storage for the
transmitted type and converts from the presented type to the transmitted
type:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>void </Literal><Symbol Role="Variable">PRES</Symbol><Literal>_to_xmit (</Literal><Symbol Role="Variable">PRES </Symbol><Literal>*</Literal><Symbol Role="Variable">presented</Symbol><Literal>,</Literal><Symbol Role="Variable"> TRANS </Symbol><Literal>**</Literal><Symbol Role="Variable">transmitted</Symbol><Literal>)</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Symbol Role="Variable">PRES</Symbol><Function>_from_xmit()</Function> routine converts from the transmitted
type to the presented type and allocates any storage referenced by
pointers in the presented type:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>void </Literal><Symbol Role="Variable">PRES</Symbol><Literal>_from_xmit</Literal> (<Symbol Role="Variable">TRANS </Symbol><Literal>*</Literal><Symbol Role="Variable">transmitted</Symbol><Literal>,</Literal><Symbol Role="Variable"> PRES </Symbol><Literal>*</Literal><Symbol Role="Variable">presented</Symbol><Literal>)</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para><?sml-need 6>The <Symbol Role="Variable">PRES</Symbol><Function>_free_inst()</Function> routine frees any storage referenced 
by pointers in the presented type by <Symbol Role="Variable">PRES</Symbol><Function>_from_xmit()</Function>:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>void </Literal><Symbol Role="Variable">PRES</Symbol><Literal>_free_inst</Literal> (<Symbol Role="Variable">PRES </Symbol><Literal>*</Literal><Symbol Role="Variable">presented</Symbol><Literal>)</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>Suppose that the <Literal>transmit_as</Literal> attribute appears either on the type of
a parameter or on a component of a parameter and that the parameter
has the <Literal>out</Literal> or <Literal>in,out</Literal> attribute.  Then, the
<Symbol Role="Variable">PRES</Symbol><Function>_free_inst()</Function>
routine will be called automatically for the data item that
has the <Literal>transmit_as</Literal> attribute.
</Para>
<Para>Suppose that the <Literal>transmit_as</Literal> attribute appears
on the type of a parameter and that the parameter has only the <Literal>in</Literal>
attribute.  Then, the <Symbol Role="Variable">PRES</Symbol><Function>_free_inst()</Function> routine will be called
automatically.
</Para>
<Para>Finally, suppose that the <Literal>transmit_as</Literal>
attribute appears on a component of a parameter and that the
parameter has only the <Literal>in</Literal> attribute.  Then, the <Symbol Role="Variable">PRES</Symbol><Function>_free_inst()</Function>
routine will not be called automatically for the component; the
manager application code must release any resources that the
component uses, possibly by explicitly calling the <Symbol Role="Variable">PRES</Symbol><Function>_free_inst()</Function>
routine.
</Para>
<Para>The <Symbol Role="Variable">PRES</Symbol><Function>_free_xmit()</Function> routine frees any storage that
has been allocated for the transmitted type by <Symbol Role="Variable">PRES</Symbol><Function>_to_xmit()</Function>:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>void </Literal><Symbol Role="Variable">PRES</Symbol><Literal>_free_xmit</Literal> (<Symbol Role="Variable">TRANS </Symbol><Literal>*</Literal><Symbol Role="Variable">transmitted</Symbol><Literal>)</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>A type with the <Literal>transmit_as</Literal> attribute cannot have other type
attributes, specifically the following:
</Para>
<ItemizedList>
<ListItem>
<Para>A pipe type.
</Para>
</ListItem>
<ListItem>
<Para>A pipe element type.
</Para>
</ListItem>
<ListItem>
<Para>A type with the <Literal>context_handle</Literal> attribute.
</Para>
</ListItem>
<ListItem>
<Para>A type of which any instance has the <Literal>context_handle</Literal> attribute.
</Para>
</ListItem>
<ListItem>
<Para>A type that includes the <Literal>handle</Literal> attribute in its definition
cannot be used, directly or indirectly, in the definition of a type
with the <Literal>transmit_as</Literal> attribute.  Nor can a type that 
includes the <Literal>transmit_as</Literal> attribute in its definition be
used, directly or indirectly, in the definition of a type with the
<Literal>handle</Literal> attribute.
</Para>
</ListItem>
<ListItem>
<Para>A conformant array type.
</Para>
</ListItem>
<ListItem>
<Para>A varying array type.
</Para>
</ListItem>
<ListItem>
<Para>A structure type containing a conformant array.
</Para>
</ListItem>
<ListItem>
<Para>An array type of which any instance is varying.
</Para>
</ListItem>
<ListItem>
<Para>A type with the <Literal>represent_as</Literal> attribute.
</Para>
</ListItem>
</ItemizedList>
<Para>The type name in a declaration for a <Literal>transmit_as</Literal> attribute
is restricted to 21 characters.
</Para>
<Para>A transmitted type specified by the <Literal>transmit_as</Literal> attribute
must be either a base type, a predefined type, or a named type defined
via <Literal>typedef</Literal>.  A transmitted type cannot be a conformant array
type or a conformant structure type if any instance of that type is
an <Literal>in</Literal> parameter or an <Literal>in, out</Literal> parameter.
</Para>
<Para>The following is an example of <Literal>transmit_as</Literal>.
Assuming the following declarations:
</Para>
<InformalExample>
<Para><ProgramListing>typedef
   struct tree_node_t {
      data_t data;
      struct tree_node_t * left;
      struct tree_node_t * right;
   } tree_node_t;

typedef
   [transmit_as(tree_xmit_t)] tree_node_t *tree_t;
</ProgramListing></Para>
</InformalExample>
<Para>The application code must include routines that
match the prototypes:
</Para>
<InformalExample>
<Para><ProgramListing>void tree_t_to_xmit ( tree_t *, (tree_xmit_t **) );
void tree_t_from_xmit ( (tree_xmit_t *), (tree_t *) );
void tree_t_free_inst ( tree_t *);
void tree_t_free_xmit ( (tree_xmit_t *) );
</ProgramListing></Para>
</InformalExample>
<?sml-break>
<?sml-need 20>
</Sect1>
<Sect1 Id="DCEADG.RPCIDL.div.129">
<Title>IDL Grammar Synopsis</Title>
<Para RevisionFlag="Changed">This section summarizes IDL syntax,
in extended Backus-Naur Format (BNF) notation.
<IndexTerm Id="DCEADG.RPCIDL.indx.393">
<Primary>IDL</Primary>
<Secondary>grammar synopsis</Secondary>
</IndexTerm><?og-ChangeStart def,13428,R1.2.2,removed align attribute"></Para>
<InformalExample>
<Para><ProgramListing RevisionFlag="Changed"><?sml-point-size 10>
<!--no-op:  12-->
&lt;interface> ::= &lt;interface_header> "{" &lt;interface_body> "}"

&lt;interface_header> ::=
    "[" &lt;interface_attributes> "]" "interface" &lt;identifier> \
             [ ":" &lt;identifier> ]

&lt;interface_attributes> ::=
 &lt;interface_attribute> [ "," &lt;interface_attribute> ] ...

&lt;interface_attribute> ::= "uuid" "(" &lt;uuid_rep> ")"
 | "version" "(" &lt;major> [ "." &lt;minor> ] ")"
 | "endpoint" "(" &lt;endpoint_spec> [ "," &lt;endpoint_spec> ] ... ")"
 | "pointer_default" "(" &lt;pointer_attribute> ")"
 | "local"
 | "exceptions" "(" &lt;excep_name> ["," &lt;excep_name>] ... ")"

&lt;excep_name> ::= &lt;Identifier>

&lt;major> ::= &lt;integer>

&lt;minor> ::= &lt;integer>

&lt;endpoint_spec> ::=
 """ &lt;family_string> ":" "[" &lt;endpoint_string> "]" """

&lt;family_string> ::= &lt;identifier>

&lt;endpoint_string> ::= &lt;identifier>

&lt;interface_body> ::= [ &lt;import> ] ... [ &lt;export> ] ...

&lt;export> ::= &lt;const_declaration> ";"
 | &lt;type_declaration> ";"
 | &lt;op_declaration> ";"

&lt;import> ::= import &lt;import_files> ";"

&lt;import_files> ::= &lt;filename> [ "," &lt;filename> ] ... ";"

&lt;filename> ::= """ &lt;character> ... """

&lt;const_declaration> ::=
 "const" &lt;const_type_spec> &lt;identifier> "=" &lt;const_exp>

&lt;const_type_spec> ::=
 &lt;integer_type> | "char" | "char" "*" | "boolean" | "void" "*"

&lt;const_exp> ::=
 &lt;integer_const_exp> | &lt;character_const> | &lt;string_const> 
 | &lt;identifier> | "TRUE" | "FALSE" | "NULL"

&lt;integer_const_exp> ::= &lt;conditional_exp>

&lt;conditional_exp> ::= &lt;logical_or_exp> 
 | &lt;logical_or_exp> "?" &lt;integer_const_exp> ":" &lt;conditional_exp>

&lt;logical_or_exp> ::= &lt;logical_and_exp> 
 | &lt;logical_or_exp> "||" &lt;logical_and_exp> 

&lt;logical_and_exp> ::= &lt;inclusive_or_exp>
 | &lt;logical_and_exp> "&amp;&amp;" &lt;inclusive_or_exp>

&lt;inclusive_or_exp> ::= &lt;exclusive_or_exp>
 | &lt;inclusive_or_exp> "|" &lt;exclusive_or_exp>

&lt;exclusive_or_exp> ::= &lt;and_exp> 
 | &lt;and_exp> "&caret;" &lt;and_exp> 

&lt;and_exp> ::= &lt;equality_exp> 
 | &lt;and_exp> "&amp;" &lt;equality_exp>

&lt;equality_exp> ::= &lt;relational_exp>
 | &lt;equality_exp> "==" &lt;relational_exp>
 | &lt;equality_exp> "!=" &lt;relational_exp>

&lt;relational_exp> ::= &lt;shift_exp>
 | &lt;relational_exp> "&lt;" &lt;shift_exp>
 | &lt;relational_exp> ">" &lt;shift_exp>
 | &lt;relational_exp> "&lt;=" &lt;shift_exp>
 | &lt;relational_exp> ">=" &lt;shift_exp>

&lt;shift_exp> ::= &lt;additive_exp>
 | &lt;shift_exp> "&lt;&lt;" &lt;additive_exp>
 | &lt;shift_exp> ">>" &lt;additive_exp>

&lt;additive_exp> ::= &lt;multiplicative_exp>
 | &lt;additive_exp> "+" &lt;multiplicative_exp>
 | &lt;additive_exp> "-" &lt;multiplicative_exp>

&lt;multiplicative_exp> ::= &lt;unary_exp>
 | &lt;multiplicative_exp> "*" &lt;unary_exp>
 | &lt;multiplicative_exp> "/" &lt;unary_exp>
 | &lt;multiplicative_exp> "%" &lt;unary_exp>

<?sml-need 5>&lt;unary_exp> ::= &lt;primary_exp>
 | "+" &lt;primary_exp>
 | "-" &lt;primary_exp>
 | "~" &lt;primary_exp>
 | "!" &lt;primary_exp>

&lt;primary_exp> ::= &lt;integer_literal> 
 | &lt;identifier>

&lt;character_const> ::= "'" &lt;character> "'"

&lt;string_const> ::= """ [ &lt;character> ] ... """

&lt;type_declaration> ::=
 "typedef" [ &lt;type_attributes> ] &lt;type_spec> &lt;declarators>

&lt;type_spec> ::= &lt;simple_type_spec> 
 | &lt;constructed_type_spec>

&lt;simple_type_spec> ::= &lt;base_type_spec>
 | &lt;predefined_type_spec>
 | &lt;identifier>

&lt;declarators> ::= &lt;declarator> [ "," &lt;declarator> ] ...

&lt;declarator> ::= &lt;simple_declarator>
 | &lt;complex_declarator>

&lt;simple_declarator> ::= &lt;identifier>

&lt;complex_declarator> ::= &lt;array_declarator>
 | &lt;function_ptr_declarator>
 | &lt;ptr_declarator>
 | &lt;ref_declarator>

&lt;ref_declarator> ::= "&amp;" &lt;identifier>

&lt;tagged_declarator> ::= &lt;tagged_struct_declarator>
 | &lt;tagged_union_declarator>

&lt;base_type_spec> ::= &lt;integer_type>
 | &lt;floating_type>
 | &lt;char_type>
 | &lt;boolean_type>
 | &lt;byte_type>
 | &lt;void_type>
 | &lt;handle_type>

&lt;floating_type> ::= "float" | "double"

&lt;integer_type> ::= &lt;signed_int> | &lt;unsigned_int>

&lt;signed_int> ::= &lt;int_size> [ "int" ]

<?sml-need 2>&lt;unsigned_int> ::= &lt;int_size> "unsigned" [ "int" ]
 | "unsigned" &lt;int_size> [ "int" ]

&lt;int_size> ::= "hyper" | "long" | "short" | "small"

&lt;char_type> ::= [ "unsigned" ] "char"

&lt;boolean_type> ::= "boolean"

&lt;byte_type> ::= "byte"

&lt;void_type> ::= "void"

&lt;handle_type> ::= "handle_t"

&lt;constructed_type_spec> ::= &lt;struct_type>
 | &lt;union_type>
 | &lt;tagged_declarator>
 | &lt;enumeration_type>
 | &lt;pipe_type>

&lt;tagged_struct_declarator> ::= "struct" &lt;tag>
 | &lt;tagged_struct>

&lt;struct_type> ::= "struct" "{" &lt;member_list> "}"

&lt;tagged_struct> ::= "struct" &lt;tag> "{" &lt;member_list> "}"

&lt;tag> ::= &lt;identifier>

&lt;member_list> ::= &lt;member> [ &lt;member> ] ...

&lt;member> ::= &lt;field_declarator> ";"

&lt;field_declarator> ::= [ &lt;field_attribute_list> ]
 &lt;type_spec> &lt;declarators>

&lt;field_attribute_list> ::= "[" &lt;field_attribute> [ ","
 &lt;field_attribute>] ... "]" 

&lt;tagged_union_declarator> ::= "union" &lt;tag>
 | &lt;tagged_union>

&lt;union_type> ::= "union" &lt;union_switch> "{" &lt;union_body>
 "}" | "union" "{" &lt;union_body_n_e> "}"

&lt;union_switch> ::= "switch" "(" &lt;switch_type_spec> &lt;identifier> ")"
 [ &lt;union_name> ]

<?sml-need 6>&lt;switch_type_spec> ::= &lt;integer_type>
 | &lt;char_type>
 | &lt;boolean_type>
 | &lt;enumeration_type>
&lt;tagged_union_declarator> ::= "union" &lt;tag> 
 | &lt;tagged_union>

&lt;union_type> ::= "union" &lt;union_switch> "{" &lt;union_body> "}" 
 | "union" "{" &lt;union_body_n_e> "}"

&lt;union_switch> ::= "switch" "(" &lt;switch_type_spec> \
      &lt;Identifier> ")" [ &lt;union_name> ]

&lt;switch_type_spec> ::= &lt;primitive_integer_type> 
 | &lt;char_type>
 | &lt;boolean_type>
 | &lt;enumeration_type>

&lt;tagged_union> ::= "union" &lt;tag> &lt;union_switch> "{" &lt;union_body> "}"
 | "union" &lt;tag> "{" &lt;union_body_n_e> "}"

&lt;union_name> ::= &lt;Identifier>

&lt;union_body> ::= &lt;union_case> [  &lt;union_case> ] ... 

&lt;union_body_n_e> ::=  &lt;union_case_n_e> [ &lt;union_case_n_e> ] ...

&lt;union_case> ::= &lt;union_case_label>  \
     [ &lt;union_case_label> ] ... &lt;union_arm> | &lt;default_case>

&lt;union_case_n_e> ::= &lt;union_case_label_n_e> &lt;union_arm>
 | &lt;default_case_n_e> 

&lt;union_case_label> ::= "case" &lt;const_exp> ":" 

&lt;union_case_label_n_e> ::= "[" "case" "(" &lt;const_exp> \
      [ , &lt;const_exp>] ...")" "]"

&lt;default_case> ::= "default" ":" &lt;union_arm>

&lt;default_case_n_e> ::= "[" "default" "]" &lt;union_arm>

&lt;union_arm> ::= [ &lt;field_declarator> ] ";"

&lt;union_type_switch_attr> ::= "switch_type" "(" \
       &lt;switch_type_spec> ")"

&lt;union_instance_switch_attr> ::= "switch_is" "(" &lt;attr_var> ")"

&lt;enumeration_type> ::=

&lt;enum_identifier> ::= &lt;identifier> [ "=" &lt;const_exp> ]

&lt;pipe_type> ::= "pipe" &lt;type_spec> &lt;pipe_declarators>

&lt;array_declarator> ::= &lt;identifier> &lt;array_bounds_list>

&lt;array_bounds_list> ::= &lt;array_bounds_declarator> 
 [ &lt;array_bounds_declarator> ] ...

&lt;array_bounds_declarator> ::= "[" [ &lt;array_bound> ] "]"
 | "[" &lt;array_bounds_pair> "]"

&lt;array_bounds_pair> ::= &lt;array_bound> ".." &lt;array_bound>

&lt;array_bound> ::= "*" 
 | &lt;integer_literal>
 | &lt;identifier>

&lt;type_attribute> ::= "transmit_as" "(" &lt;xmit_type> ")"
 | "handle"
 | &lt;usage_attribute>
 | &lt;union_type_switch_attr>
 | &lt;ptr_attr>

&lt;usage_attribute> ::= "string"
 | "context_handle"

&lt;xmit_type> ::= &lt;simple_type_spec>

&lt;field_attribute> ::= "first_is" "(" &lt;attr_var_list> ")"
 | "last_is" "(" &lt;attr_var_list> ")"
 | "length_is" "(" &lt;attr_var_list> ")"
 | "max_is" "(" &lt;attr_var_list> ")"
 | "min_is" "(" &lt;attr_var_list> ")"
 | "size_is" "(" &lt;attr_var_list> ")"
 | &lt;usage_attribute>
 | &lt;union_instance_switch_attr>
 | "ignore"
 | &lt;ptr_attr>

&lt;attr_var_list> ::= &lt;attr_var> [ "," &lt;attr_var> ] ...

&lt;attr_var> ::= [ ["*"]&lt;identifier> ]

&lt;ptr_declarator> ::= "*"&lt;identifier>

&lt;ptr_attr> ::= "ref"
 | "unique"
 | "full"

&lt;op_declarator> ::= [ &lt;operation_attributes> ]
 &lt;simple_type_spec> &lt;identifier> &lt;parameter_declarators>

<?sml-need 2>&lt;operation_attributes> ::=  "[" &lt;operation_attribute> [ "static" ]
 [ "," &lt;operation_attribute> ] ... "]"

<?sml-need 6>&lt;operation_attribute> ::= "idempotent"
 | "broadcast"
 | "maybe"
 | "reflect_deletions"
 | &lt;usage_attribute>
 | &lt;ptr_attr>

&lt;param_declarators> ::= "(" "void" ")"
 | "(" [ &lt;param_declarator> [ "," &lt;param_declarator> ] ... ] ")"

&lt;param_declarator> ::= &lt;param_attributes> &lt;type_spec> &lt;declarator>

&lt;param_attributes> ::=
 "[" &lt;param_attribute> [ "," &lt;param_attribute> ] ... "]"

&lt;param_attribute> ::= &lt;directional_attribute>
 | &lt;field_attribute>

&lt;directional_attribute> ::= "in" [ "(" "shape" ")" ]
 | "out" [ "(" "shape" ")" ] 

&lt;function_ptr_declarator> ::= &lt;simple_type_spec>
 "(" "*"&lt;identifier> ")" &lt;param_declarators>

&lt;predefined_type_spec> ::= "error_status_t"
 | &lt;international_character_type>

&lt;international_character_type> ::= ISO_LATIN_1
 | ISO_MULTI_LINGUAL
 | ISO_UCS

&lt;pipe_declarators> ::= &lt;pipe_declarator> \
         [ "," &lt;pipe_declarator> ] ...

&lt;pipe_declarator> ::= &lt;simple_declarator>
 | &lt;ptr_declarator>
 | &lt;ref_declarator> 
<?sml-point-size 12>
<!--no-op:  14-->
</ProgramListing></Para>
</InformalExample>
<?og-ChangeEnd def,13428,R1.2.2,removed align attribute">
<Para>
</Para>
</Sect1>
</Chapter>
<!--+ 11/27/96 19:53:47
    | tagMorph:  $Id: idl.sgm,v 1.1.2.9 1996/12/15 17:23:36 wardr Exp $
    | tagMorph library:  $Id: idl.sgm,v 1.1.2.9 1996/12/15 17:23:36 wardr Exp $
    | sml-to-docbook:  1.25
    +-->
