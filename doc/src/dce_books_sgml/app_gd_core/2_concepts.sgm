<!--
# @OSF_COPYRIGHT@
# 
# 
# HISTORY
# $Log: 2_concepts.sgm,v $
# Revision 1.1.2.8  1996/12/14  20:23:49  wardr
# 	{edit,R1.2.2}
# 	penultimate format fixes
# 	[1996/12/14  20:21:35  wardr]
#
# Revision 1.1.2.7  1996/12/13  22:10:19  wardr
# 	{edit,R1.2.2}
# 	Fixed formatting problems
# 	[1996/12/13  22:08:10  wardr]
# 
# Revision 1.1.2.6  1996/12/12  21:29:59  wardr
# 	{edit,R1.2.2}
# 	Fixed formatting problems
# 	[1996/12/12  21:28:08  wardr]
# 
# Revision 1.1.2.5  1996/12/12  16:49:00  carrig
# 	{enh,R1.2.2}
# 	Minor edits
# 	[1996/12/12  16:46:42  carrig]
# 
# Revision 1.1.2.4  1996/12/06  21:09:38  carrig
# 	{enh,R1.2.2}
# 	Second pass for editor
# 	[1996/12/06  21:07:26  carrig]
# 
# Revision 1.1.2.3  1996/12/05  21:38:30  carrig
# 	{enh,R1.2.2}
# 	First pass to prepare for editing
# 	[1996/12/05  21:36:31  carrig]
# 
# Revision 1.1.2.2  1996/12/02  15:40:37  weir
# 	Removed thinsp entities, corrected other minor errors
# 	[1996/12/02  15:38:50  weir]
# 
# Revision 1.1.2.1  1996/12/01  20:42:57  weir
# 	Initial submission
# 	[1996/12/01  20:41:14  weir]
# 
# 	Initial submission
# 	[1996/11/29  20:35:24  weir]
# 
# $EndLog$
-->
<!-- Fragment document type declaration subset:
ArborText, Inc., 1988-1993, v.4001
<!DOCTYPE Book PUBLIC "-//Davenport//DTD DocBook V2.4//EN" [
<!ENTITY  DCEADG.THRC.ent.5  SYSTEM "eps/2_concepts_10.ps" NDATA eps>
<!ENTITY  DCEADG.THRC.ent.6  SYSTEM "eps/2_concepts_20.ps" NDATA eps>
<!ENTITY  DCEADG.THRC.ent.7  SYSTEM "eps/2_concepts_30.ps" NDATA eps>
<!ENTITY  DCEADG.THRC.ent.8  SYSTEM "eps/2_concepts_02.ps" NDATA EPS>
]>
-->
<!---->
<!-- COPYRIGHT NOTICE-->
<!-- Copyright (c) 1990, 1991, 1992, 1993 Open Software Foundation, Inc.-->
<!-- ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE in the-->
<!-- src directory for the full copyright text.-->
<!---->
<!---->
<!-- OLD HISTORY-->
<!-- Revision 1.1.6.16  1995/06/07  14:42:55  rcb-->
<!-- 	PRENTICE HALL reformat; final edits and changes-->
<!-- 	[1995/06/05  19:57:45  rcb]-->
<!---->
<!-- 	PRENTICE HALL reformat-->
<!-- 	[1995/04/13  16:06:54  rcb]-->
<!---->
<!-- 	PRENTICE HALL reformat-->
<!-- 	[1995/04/13  15:33:15  rcb]-->
<!---->
<!-- 	incorporated 1.1 edits-->
<!-- 	[1995/04/13  14:57:50  rcb]-->
<!---->
<!-- Revision 1.1.6.15  1994/11/03  23:35:43  neilson-->
<!-- 	Substituted macros for book names in cross refs.-->
<!-- 	[1994/11/03  01:39:14  neilson]-->
<!-- -->
<!-- 	Substituted macros for book names in cross refs.-->
<!-- -->
<!-- Revision 1.1.6.14  1994/10/20  22:07:07  jshirley-->
<!-- 	Fixed cross references.-->
<!-- 	[1994/10/20  22:06:45  jshirley]-->
<!-- 	Revision 1.1.6.13  1994/10/19  20:15:22  neilson-->
<!-- 	CR 10326 - Automatic fix to name of intro ref page-->
<!-- 	[1994/10/19  20:09:03  neilson]-->
<!-- 	Revision 1.1.6.12  1994/10/19  19:34:04  weir-->
<!-- 	Removed register set request-->
<!-- 	[1994/10/19  19:33:42  weir]-->
<!-- 	Revision 1.1.6.11  1994/10/18  15:16:01  weir-->
<!-- 	{def,9772,R1.1}-->
<!-- 	Fixed various inaccuracies-->
<!-- 	[1994/10/18  15:15:07  weir]-->
<!-- 	Revision 1.1.6.10  1994/09/30  18:51:42  weir-->
<!-- 	Fixing internal cross-references-->
<!-- 	[1994/09/30  18:51:05  weir]-->
<!-- 	Revision 1.1.6.9  1994/03/14  22:00:59  rom-->
<!-- 	{enh, 10129, R1.1}-->
<!-- 	Fix pathnames of included files for new three-book organization.-->
<!-- 	[1994/03/14  21:20:37  rom]-->
<!-- 	Revision 1.1.6.8  1993/02/22  21:25:49  weir-->
<!-- 	Fixed CR7104-->
<!-- 	[1993/02/22  21:25:01  weir]-->
<!-- 	Revision 1.1.6.7  1993/02/19  19:50:35  johnson-->
<!-- 	No changes made.-->
<!-- 	[1993/02/19  19:49:41  johnson]-->
<!-- 	Revision 1.1.6.6  1993/02/03  20:04:21  buckler-->
<!-- 	Changed .P! to .pI and added Postscript boundary boxes-->
<!-- 	[1993/02/03  20:03:44  buckler]-->
<!-- 	Revision 1.1.6.5  1993/01/28  18:46:40  cjd-->
<!-- 	Embedded copyright notice-->
<!-- 	[1993/01/28  18:07:44  cjd]-->
<!-- 	Revision 1.1.6.4  1993/01/14  18:55:17  buckler-->
<!-- 	Corrected bug number in change marker codes (4909 became 4908).-->
<!-- 	[1993/01/14  18:54:36  buckler]-->
<!-- 	Revision 1.1.6.3  1993/01/08  19:22:25  johnson-->
<!-- 	CR#:     4908-->
<!-- 	File:    /src/app_gd/threads/2_concepts.gpsml-->
<!-- 	Change:  Added types of errors that can cause thread termination-->
<!-- 	[1993/01/08  19:13:28  johnson]-->
<!-- 	Revision 1.1.6.2  1992/11/20  21:00:24  weir-->
<!-- 	Moved into 1.0.2doc tree-->
<!-- 	[1992/11/20  20:57:46  weir]-->
<!-- 	Revision 1.1.4.6  1992/11/11  23:54:18  buckler-->
<!-- 	Corrected index entries-->
<!-- 	[1992/11/11  22:59:19  buckler]-->
<!-- 	Revision 1.1.4.5  1992/11/06  16:36:30  lmk-->
<!-- 	Prentice-Hall index edits only-->
<!-- 	[1992/11/06  16:33:40  lmk]-->
<!-- 	Revision 1.1.4.4  1992/10/12  22:19:39  casey-->
<!-- 	Index corrections for PH-->
<!-- 	[1992/10/12  22:16:20  casey]-->
<!-- 	Revision 1.1.4.3  1992/10/08  17:45:34  lmk-->
<!-- 	Prentice-Hall edits only-->
<!-- 	[1992/10/08  17:43:56  lmk]-->
<!-- 	Revision 1.1.4.2  1992/09/10  20:43:01  buckler-->
<!-- 	Second editorial review-->
<!-- 	[1992/09/10  20:39:11  buckler]-->
<!-- 	Revision 1.1.2.2  1992/06/17  18:50:47  buckler-->
<!-- 	Incorporated editorial review-->
<!-- 	[1992/06/17  18:50:02  buckler]-->
<!-- 	Revision 1.1  1992/01/29  16:07:27  damon-->
<!-- 	Initial revision-->
<!-- -->
<!---->
<!-- (c) Copyright 1991, Open Software Foundation, Inc.  ALL RIGHTS RESERVED-->
<!-- ********************************************************************-->
<!--                                                                    *-->
<!-- COPYRIGHT (c) 1991 BY DIGITAL EQUIPMENT CORPORATION,               *-->
<!-- Maynard, Massachusetts                                             *-->
<!-- All Rights Reserved.                                               *-->
<!--                                                                    *-->
<!-- This document is furnished under a license and may be used and     *-->
<!-- copied only in accordance with the terms of such license and with  *-->
<!-- the inclusion of the above copyright notice.  No title to or        *-->
<!-- ownership of the document is hereby transferred.                   *-->
<!--                                                                    *-->
<!-- The information in this document is subject to change without      *-->
<!-- notice and should not be construed as a commitment by Digital      *-->
<!-- Equipment Corporation.                                             *-->
<!--                                                                    *-->
<!-- ********************************************************************-->
<Chapter Id="DCEADG.THRC.div.1">
<Title>Thread Concepts and Operations</Title>
<Para>This chapter discusses concepts and techniques related to DCE Threads.
The following topics are covered:
</Para>
<ItemizedList>
<ListItem>
<Para>Thread operations
</Para>
</ListItem>
<ListItem>
<Para>New primitives
</Para>
</ListItem>
<ListItem>
<Para>Attributes objects
</Para>
</ListItem>
<ListItem>
<Para>Synchronization objects
</Para>
</ListItem>
<ListItem>
<Para>One-time initialization code
</Para>
</ListItem>
<ListItem>
<Para>Thread-specific data
</Para>
</ListItem>
<ListItem>
<Para>Thread cancellation
</Para>
</ListItem>
<ListItem>
<Para>Thread scheduling
</Para>
</ListItem>
</ItemizedList>
<Para>For detailed information on the multithreading routines referred to in this
chapter, see the reference page for that routine in the &DCEDr;.
</Para>
<Sect1 Id="DCEADG.THRC.div.2">
<Title>Thread Operations</Title>
<Para><IndexTerm Id="DCEADG.THRC.indx.1">
<Primary>thread</Primary>
<Secondary>states</Secondary>
</IndexTerm>A thread changes states as it runs, waits to synchronize, or is ready 
to be run.  A thread is in one of the following states:
</Para>
<ItemizedList>
<ListItem>
<Para>Waiting
</Para>
<Para>The thread is not eligible to execute because it is
synchronizing with another thread or with an external event.
</Para>
</ListItem>
<ListItem>
<Para>Ready
</Para>
<Para>The thread is eligible to be executed by a processor.
</Para>
</ListItem>
<ListItem>
<Para>Running
</Para>
<Para>The thread is currently being executed by a processor.
</Para>
</ListItem>
<ListItem>
<Para>Terminated
</Para>
<Para>The thread has completed all of its work.
</Para>
</ListItem>
</ItemizedList>
<Para>Figure 7-1 shows the transitions between states for a
typical thread implementation.
</Para>
<Para><IndexTerm Id="DCEADG.THRC.indx.2">
<Primary>thread</Primary>
<Secondary>state transitions</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.3">
<Primary>state transitions, threads</Primary>
</IndexTerm></Para>
<Figure>
<Title>Thread State Transitions</Title>
<Graphic Entityref="DCEADG.THRC.ent.1"></Graphic>
</Figure>
<Para>The operations that you can perform include starting, 
waiting for, terminating, and deleting threads.
</Para>
<Sect2 Id="DCEADG.THRC.div.3">
<Title>Starting a Thread</Title>
<Para><IndexTerm Id="DCEADG.THRC.indx.4">
<Primary>starting</Primary>
<Secondary>threads</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.5">
<Primary>creating</Primary>
<Secondary>threads</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.6">
<Primary>thread</Primary>
<Secondary>starting</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.7">
<Primary>thread</Primary>
<Secondary>creating</Secondary>
</IndexTerm>To start a thread, create it using the <Function>pthread_create()</Function> routine.
This routine creates the thread, assigns specified or default
attributes, and starts execution of the function you specified as the
thread's start routine.  A unique identifier (handle) for that thread 
is returned from the <Function>pthread_create()</Function> routine.
</Para>
</Sect2>
<Sect2 Id="DCEADG.THRC.div.4">
<Title>Terminating a Thread</Title>
<Para><IndexTerm Id="DCEADG.THRC.indx.8">
<Primary>thread</Primary>
<Secondary>terminating</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.9">
<Primary>terminating</Primary>
<Secondary>threads</Secondary>
</IndexTerm>A thread exists until it terminates and the <Function>pthread_detach()</Function>
<IndexTerm Id="DCEADG.THRC.indx.10">
<Primary>pthread functions</Primary>
</IndexTerm>routine is called for the thread.  The <Function>pthread_detach()</Function> routine can be
called for a thread before or after it terminates.  If the thread 
terminates before <Function>pthread_detach()</Function> is called for it, then the 
thread continues to exist and can be 
synchronized (joined) until it is detached. 
Thus, the object (thread) can be detached by any thread that has access 
to a handle to the object.
</Para>
<Para>Note that <Function>pthread_detach()</Function> 
must be called to release the memory allocated
for the thread objects so that this storage does not build up and cause the
process to run out of memory.  For example, after a thread returns from a call
to join, it detaches the joined-to thread if no other threads 
join with it.  Similarly, if a thread has no other threads joining with
it, it detaches itself so that its thread object is deallocated as
soon as it terminates.
</Para>
<Para>A thread terminates for any of the following reasons:
</Para>
<ItemizedList>
<ListItem>
<Para>The thread returns from its start routine; this is the usual case.
</Para>
</ListItem>
<ListItem>
<Para>The thread calls the <Function>pthread_exit()</Function> routine.
</Para>
<Para>The <Function>pthread_exit()</Function> routine terminates the calling thread and
returns a status value, indicating the thread's exit status to any 
potential joiners.
</Para>
</ListItem>
<ListItem>
<Para>The thread is canceled by a call to the <Function>pthread_cancel()</Function>
routine.
</Para>
<Para>The <Function>pthread_cancel()</Function> routine requests termination of a specified
thread if cancellation is permitted. (See Section 7.7 for more
information on canceling threads and controlling whether or not cancellation
is permitted.)
</Para>
</ListItem>
<ListItem>
<Para>An error occurs in the thread.
</Para>
<Para>Examples of errors that cause thread termination are programming errors,
segmentation faults, or unhandled exceptions.
</Para>
</ListItem>
</ItemizedList>
</Sect2>
<Sect2 Id="DCEADG.THRC.div.5">
<Title>Waiting for a Thread to Terminate</Title>
<Para><IndexTerm Id="DCEADG.THRC.indx.11">
<Primary>waiting</Primary>
<Secondary>for a thread to terminate</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.12">
<Primary>thread</Primary>
<Secondary>waiting for another to terminate</Secondary>
</IndexTerm>A thread waits for the termination of another thread by calling the
<Function>pthread_join()</Function> routine. 
Execution in the current thread is
suspended until the specified thread terminates.  If multiple threads call
this routine and specify the same thread, all threads resume execution when
the specified
thread terminates.
</Para>
<Para>If you specify the current thread with the <Function>pthread_join()</Function> routine,
a deadlock results.
</Para>
<Para>Do not confuse <Function>pthread_join()</Function> with other routines that cause waits
and that are related to the use of a particular multithreading feature.  For
example, use <Function>pthread_cond_wait()</Function> or 
<Function>pthread_cond_timedwait()</Function> 
to wait
for a condition variable to be signaled or broadcast.
</Para>
</Sect2>
<Sect2 Id="DCEADG.THRC.div.6">
<Title>Deleting a Thread</Title>
<Para><IndexTerm Id="DCEADG.THRC.indx.13">
<Primary>deleting</Primary>
<Secondary>threads</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.14">
<Primary>thread</Primary>
<Secondary>deleting</Secondary>
</IndexTerm>A thread is automatically deleted after it terminates; that is, no explicit
deletion operation is required.  Use 
<Function>pthread_detach()</Function> to free the storage of a terminated thread. 
Use <Function>pthread_cancel()</Function> to request that a running thread terminate 
itself.
</Para>
<Para>If the thread has not yet terminated, the
<Function>pthread_detach()</Function> routine marks the thread for deletion, and its
storage is reclaimed immediately when the thread terminates.  A thread cannot
be joined or canceled after the <Function>pthread_detach()</Function> routine is called for
the thread, even if the thread has not yet terminated.
</Para>
<Para>If a thread that is not detached terminates, its storage remains so
that other threads can join with it.  Storage is reclaimed when the thread is
eventually detached.
</Para>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.THRC.div.7">
<Title>New Primitives</Title>
<Para>Routines implemented by DCE Threads that are not specified
by Draft 4 of the POSIX 1003.4a standard are indicated by an <Literal>_np</Literal>
suffix to the name.  These routines have not been incorporated into the
POSIX standard, and as such are extensions to that document.  The routines
are fully portable.
</Para>
</Sect1>
<Sect1 Id="DCEADG.THRC.div.8">
<Title>Attributes Objects</Title>
<Para><IndexTerm Id="DCEADG.THRC.indx.15">
<Primary>attributes</Primary>
<Secondary>object</Secondary>
<Tertiary>definition of</Tertiary>
</IndexTerm>An attributes object 
is used to describe the behavior of threads, mutexes, and
condition variables.  This description consists of the individual attribute
values that are used to create an attributes object.  Whether an 
attribute is valid depends on whether it describes threads, mutexes, or 
condition variables.
</Para>
<Para>When you create an object, you can accept the default attributes for 
that object, or you can specify an attributes object 
that contains individual attributes that you
have set.  For a thread, you can also change one or more attributes after
thread execution starts; for example, calling the 
<Function>pthread_setprio()</Function> 
routine to change the priority that you 
specified with the <Function>pthread_attr_setprio()</Function> routine.
</Para>
<Para>The following subsections describe how to create and delete attributes objects
and describe the individual attributes that you can specify for different
objects.
</Para>
<Sect2 Id="DCEADG.THRC.div.9">
<Title>Creating an Attributes Object</Title>
<Para><IndexTerm Id="DCEADG.THRC.indx.16">
<Primary>attributes</Primary>
<Secondary>object</Secondary>
<Tertiary>creating</Tertiary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.17">
<Primary>creating</Primary>
<Secondary>attributes object</Secondary>
</IndexTerm>To create an attributes object, use one of the following routines, depending
on the type of object to which the attributes apply:
</Para>
<ItemizedList>
<ListItem>
<Para>The <Function>pthread_attr_create()</Function> routine for thread attributes objects
</Para>
</ListItem>
<ListItem>
<Para>The <Function>pthread_condattr_create()</Function> routine for condition variable attributes
objects
</Para>
</ListItem>
<ListItem>
<Para>The <Function>pthread_mutexattr_create()</Function> routine for mutex attributes objects
</Para>
</ListItem>
</ItemizedList>
<Para>These routines create an attributes object containing default values for the
individual attributes.  To modify any attribute values in an attributes
object, use one of the set routines described in the following subsections.
</Para>
<Para>Creating an attributes object or changing the values in an attributes object
does not affect the attributes of objects previously created.
</Para>
</Sect2>
<Sect2 Id="DCEADG.THRC.div.10">
<Title>Deleting an Attributes Object</Title>
<Para><IndexTerm Id="DCEADG.THRC.indx.18">
<Primary>attributes</Primary>
<Secondary>object</Secondary>
<Tertiary>deleting</Tertiary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.19">
<Primary>deleting</Primary>
<Secondary>attributes object</Secondary>
</IndexTerm>To delete an attributes object, use one of the following routines:
</Para>
<ItemizedList>
<ListItem>
<Para>The <Function>pthread_attr_delete()</Function> routine for thread attributes objects
</Para>
</ListItem>
<ListItem>
<Para>The <Function>pthread_condattr_delete()</Function> routine for condition variable attributes
objects
</Para>
</ListItem>
<ListItem>
<Para>The <Function>pthread_mutexattr_delete()</Function> routine for mutex attributes objects
</Para>
</ListItem>
</ItemizedList>
<Para>Deleting an attributes object does not affect the attributes of objects
previously created.
</Para>
</Sect2>
<Sect2 Id="DCEADG.THRC.div.11">
<Title>Thread Attributes</Title>
<Para><IndexTerm Id="DCEADG.THRC.indx.20">
<Primary>attributes</Primary>
<Secondary>thread</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.21">
<Primary>thread</Primary>
<Secondary>attributes</Secondary>
</IndexTerm>A thread attributes object allows you to specify values for thread
attributes other than the defaults when you create a thread with the
<Function>pthread_create()</Function> routine. 
To use a thread attributes object,
perform the following steps:
<IndexTerm Id="DCEADG.THRC.indx.22">
<Primary>using a thread attributes object</Primary>
</IndexTerm></Para>
<OrderedList>
<ListItem>
<Para>Create a thread attributes object by calling the routine
<Function>pthread_attr_create()</Function>.
</Para>
</ListItem>
<ListItem>
<Para>Call the routines discussed in the following subsections to set the
individual attributes of the thread attributes object.
</Para>
</ListItem>
<ListItem>
<Para>Create a new thread by calling the <Function>pthread_create()</Function> 
routine and specifying the identifier of the thread attributes object.
</Para>
</ListItem>
</OrderedList>
<Para><?sml-need 8>You have control over the following attributes of a new thread:
</Para>
<ItemizedList>
<ListItem>
<Para>Scheduling policy attribute
</Para>
</ListItem>
<ListItem>
<Para>Scheduling priority attribute
</Para>
</ListItem>
<ListItem>
<Para>Inherit scheduling attribute
</Para>
</ListItem>
<ListItem>
<Para>Stacksize attribute
</Para>
</ListItem>
</ItemizedList>
<Sect3 Id="DCEADG.THRC.div.12">
<Title>Scheduling Policy Attribute</Title>
<IndexTerm Id="DCEADG.THRC.indx.23">
<Primary>attributes</Primary>
<Secondary>scheduling policy</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.24">
<Primary>FIFO (First in, First out) scheduling</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.25">
<Primary>RR (Round Robin) scheduling</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.26">
<Primary>scheduling</Primary>
<Secondary>policy attribute</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.27">
<Primary>threads</Primary>
<Secondary>scheduling</Secondary>
</IndexTerm>
<Para>The scheduling policy attribute describes the overall scheduling
policy of the threads in your application.  A thread has one of the
following scheduling policies:
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>SCHED_FIFO</Literal> (First In, First Out)
</Para>
<Para>The highest-priority thread runs
until it blocks.  If there is more than one thread with the same priority,
and that priority is the highest among other threads, the first thread to
begin running continues until it blocks.
</Para>
</ListItem>
<ListItem>
<Para><Literal>SCHED_RR</Literal> (Round Robin)
</Para>
<Para>The highest-priority thread runs until
it blocks; however, threads of equal priority, if that priority is the
highest among other threads, are timesliced. 
<IndexTerm Id="DCEADG.THRC.indx.28">
<Primary>timeslice</Primary>
</IndexTerm>(Timeslicing is a mechanism that ensures that every thread is allowed time
to execute by preempting running threads at fixed intervals.)
</Para>
</ListItem>
<ListItem>
<Para><Literal>SCHED_OTHER, SCHED_FG_NP</Literal> (Default)
</Para>
<Para>All threads are timesliced.
<Literal>SCHED_OTHER</Literal> and <Literal>SCHED_FG_NP</Literal> do the same thing; however, <Literal>SCHED_FG_NP</Literal>
is simply more precise terminology.  The <Literal>FG</Literal> stands for <Symbol Role="Variable">foreground</Symbol> 
and the <Literal>NP</Literal> for <Symbol Role="Variable">new primitive</Symbol>.  All threads running under
the <Literal>SCHED_OTHER</Literal> and <Literal>SCHED_FG_NP</Literal> policy, regardless of priority,
receive some scheduling.  Therefore, no thread is completely denied
execution time.  However, <Literal>SCHED_OTHER</Literal> and <Literal>SCHED_FG_NP</Literal> threads
can be denied execution time by <Literal>SCHED_FIFO</Literal> or <Literal>SCHED_RR</Literal> threads.
</Para>
</ListItem>
<ListItem>
<?sml-need 7>
<Para><Literal>SCHED_BG_NP</Literal> (Background)
</Para>
<Para>Like <Literal>SCHED_OTHER</Literal> and 
<Literal>SCHED_FG_NP</Literal>, <Literal>SCHED_BG_NP</Literal>  ensures that all threads, 
regardless of priority, 
receive some scheduling.  However, <Literal>SCHED_BG_NP</Literal> can be denied 
execution by the <Literal>SCHED_FIFO</Literal> or <Literal>SCHED_RR</Literal> policies.
The <Literal>BG</Literal> stands for <Symbol Role="Variable">background</Symbol>.
</Para>
</ListItem>
</ItemizedList>
<Para>The following two methods are used to set the scheduling policy attribute:
</Para>
<ItemizedList>
<ListItem>
<Para>Set the scheduling policy attribute in the attributes object, which
establishes the scheduling policy of a new thread when it is created.  To do
this, call the <Function>pthread_attr_setsched()</Function> routine.
</Para>
</ListItem>
<ListItem>
<?sml-need 4>
<Para>Change the scheduling policy of an existing thread (and, at the same
time, the scheduling priority) by calling the 
<Function>pthread_setscheduler()</Function> routine.
</Para>
</ListItem>
</ItemizedList>
<Para>Section 7.8 describes and shows the effect of scheduling policy 
on thread scheduling.
</Para>
</Sect3>
<Sect3 Id="DCEADG.THRC.div.13">
<Title>Scheduling Priority Attribute</Title>
<IndexTerm Id="DCEADG.THRC.indx.29">
<Primary>attributes</Primary>
<Secondary>scheduling priority</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.30">
<Primary>scheduling</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.31">
<Primary>thread</Primary>
<Secondary>scheduling</Secondary>
<Tertiary>priority attribute</Tertiary>
</IndexTerm>
<Para>The scheduling priority attribute specifies the execution of a 
thread.  This attribute is expressed relative to other threads on a continuum
of minimum to maximum for each scheduling policy.  A thread's priority falls
within one of the following ranges, which are implementation defined:
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>PRI_FIFO_MIN</Literal> to <Literal>PRI_FIFO_MAX</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>PRI_RR_MIN</Literal> to <Literal>PRI_RR_MAX</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>PRI_OTHER_MIN</Literal> to <Literal>PRI_OTHER_MAX</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>PRI_FG_MIN_NP</Literal> to <Literal>PRI_FG_MAX_NP</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>PRI_BG_MIN_NP</Literal> to <Literal>PRI_BG_MAX_NP</Literal>
</Para>
</ListItem>
</ItemizedList>
<Para>The following two methods are used to set the scheduling priority
attribute:
</Para>
<ItemizedList>
<ListItem>
<Para>Set the scheduling priority attribute in the attributes object, which
establishes the execution priority of a new thread when it is created.  To do
this, call the <Function>pthread_attr_setprio()</Function> routine.
</Para>
</ListItem>
<ListItem>
<Para>Change the scheduling priority attribute of an existing thread by
calling the <Function>pthread_setprio()</Function> routine. (Call the 
<Function>pthread_setscheduler()</Function> routine to change both the scheduling
priority and scheduling policy of an existing thread.)
</Para>
</ListItem>
</ItemizedList>
</Sect3>
<Sect3 Id="DCEADG.THRC.div.14">
<Title>Inherit Scheduling Attribute</Title>
<IndexTerm Id="DCEADG.THRC.indx.32">
<Primary>attributes</Primary>
<Secondary>inherit scheduling</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.33">
<Primary>inherit scheduling attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.34" SpanEnd="DCEADG.THRC.indx.27">
<IndexTerm Id="DCEADG.THRC.indx.35">
<Primary>scheduling</Primary>
</IndexTerm>
<Para>The inherit scheduling attribute specifies whether a newly created thread
inherits the scheduling attributes (scheduling priority and policy) of the
creating thread (the default), or uses the scheduling attributes stored in
the attributes object.  Set this attribute by calling the routine
<Function>pthread_attr_setinheritsched()</Function>.
</Para>
</Sect3>
<Sect3 Id="DCEADG.THRC.div.15">
<Title>Stacksize Attribute</Title>
<IndexTerm Id="DCEADG.THRC.indx.36">
<Primary>attributes</Primary>
<Secondary>stacksize</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.37">
<Primary>stacksize attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.38">
<Primary>memory</Primary>
<Secondary>setting for thread stack</Secondary>
</IndexTerm>
<Para>The stacksize attribute is the minimum size (in bytes) of the memory
required for a thread's stack.  The default value is machine dependent.
Set this attribute by calling the <Function>pthread_attr_setstacksize()</Function> routine.
</Para>
</Sect3>
</Sect2>
<Sect2 Id="DCEADG.THRC.div.16">
<Title>Mutex Attributes</Title>
<IndexTerm Id="DCEADG.THRC.indx.39">
<Primary>attributes</Primary>
<Secondary>mutex type</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.40">
<Primary>mutex</Primary>
<Secondary>type attribute</Secondary>
</IndexTerm>
<Para>A mutex attributes object allows you to specify values for mutex
attributes other than the defaults when you create a mutex with the
routine <Function>pthread_mutex_init()</Function>.
</Para>
<Para>The mutex type attribute specifies whether a mutex is fast, 
recursive, or nonrecursive.  Set 
the mutex type attribute by calling the routine
<Function>pthread_mutexattr_setkind_np()</Function>.  (Any routine with the 
<Literal>_np</Literal> suffix is a new primitive; see Section 7.2.)
If you do not use a mutex attributes object to select a mutex type, calling
the <Function>pthread_mutex_init()</Function> routine creates a fast mutex by default.
</Para>
</Sect2>
<Sect2 Id="DCEADG.THRC.div.17">
<Title>Condition Variable Attributes</Title>
<IndexTerm Id="DCEADG.THRC.indx.41">
<Primary>attributes</Primary>
<Secondary>condition variable</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.42">
<Primary>condition variable</Primary>
<Secondary>attributes</Secondary>
</IndexTerm>
<Para>Currently, attributes affecting condition variables are not defined.
You cannot change any attributes in the condition variable attributes
object.
</Para>
<Para>Section 7.4.2 describes the purpose and uses of condition
variables.
</Para>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.THRC.div.18">
<Title>Synchronization Objects</Title>
<Para>In a multithreaded program, you must use synchronization objects whenever
there is a possibility of corruption of shared data or conflicting
scheduling of threads that have mutual scheduling dependencies.  The
following subsections discuss two kinds of 
synchronization objects: mutexes and condition variables.
</Para>
<Sect2 Id="DCEADG.THRC.div.19">
<Title>Mutexes</Title>
<Para><IndexTerm Id="DCEADG.THRC.indx.43">
<Primary>synchronization objects</Primary>
<Secondary>mutex</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.44">
<Primary>mutex</Primary>
</IndexTerm>A mutex 
(<Replaceable>mut</Replaceable>ual <Replaceable>ex</Replaceable>clusion) is an object
that multiple threads use
to ensure the integrity of a shared resource that they access, most commonly
shared data.
A mutex has two states: locked and unlocked.  For each piece of shared data,
all threads accessing that data must use the same mutex; each thread locks the
mutex before it accesses the shared data and unlocks the mutex when it is
finished accessing that data.  If the mutex is locked by another
thread, the thread requesting the lock is blocked when it tries to 
lock the mutex if you call <Function>pthread_mutex_lock()</Function> (see Figure 7-2).  
The blocked thread continues and is not blocked if you call 
<Function>pthread_mutex_trylock()</Function>.
</Para>
<?sml-need 2.5i>
<Figure>
<Title>Only One Thread Can Lock a Mutex</Title>
<Graphic Entityref="DCEADG.THRC.ent.2"></Graphic>
</Figure>
<?sml-space .5>
<Para>Each mutex must be initialized. (To initialize mutexes as part of the program's
one-time initialization code, see Section 7.5.) To initialize a mutex,
use the <Function>pthread_mutex_init()</Function> routine. 
This routine allows you to
specify an attributes object, which allows you to specify the mutex type.
The following are types of mutexes:
</Para>
<ItemizedList>
<ListItem>
<Para>A fast mutex 
(the default) is locked only once by a thread.
If the thread tries to lock the mutex again without first unlocking it, the
thread waits for itself to release the first lock and deadlocks on itself.
</Para>
<Para>This type of mutex is called <FirstTerm>fast</FirstTerm> because it
can be locked and unlocked more rapidly than a recursive mutex.  It is the
most efficient form of mutex.
</Para>
</ListItem>
<ListItem>
<Para>A recursive mutex 
can be locked more than once by a given
thread without causing a deadlock.  The thread must call the 
<Function>pthread_mutex_unlock()</Function> routine 
the same number of times that it
called the <Function>pthread_mutex_lock()</Function> 
routine before another thread can
lock the mutex.  Recursive mutexes have the notion of a mutex owner.  
When a thread successfully locks a recursive mutex, it owns that mutex 
and the lock count is set to 1. Any other thread attempting to lock 
the mutex blocks until the mutex becomes unlocked.  If the owner 
of the mutex attempts to lock the mutex again, the lock count is 
incremented, and the thread continues running.  When an owner unlocks a 
recursive mutex, the lock count is decremented.  The mutex remains 
locked and owned until the count reaches 0 (zero).  It is an error for any 
thread other than the owner to  attempt to unlock the mutex.
</Para>
<Para><?sml-need 4>A recursive mutex is useful if a thread needs exclusive
access to a piece of data, and it needs to call another routine (or itself)
that needs exclusive access to the data.  A recursive mutex allows nested
attempts to lock the mutex to succeed rather than deadlock.
</Para>
<Para>This type of mutex requires more careful programming.
Never use a recursive mutex with condition variables because the
implicit unlock performed for a <Function>pthread_cond_wait()</Function> 
or 
<Function>pthread_cond_timedwait()</Function> 
may not actually release the mutex.  In
that case, no other thread can satisfy the condition of the predicate.
</Para>
</ListItem>
<ListItem>
<Para>A nonrecursive mutex is locked only once by a thread, like a
fast mutex.  If the thread tries to lock the mutex again without first
unlocking it, the thread receives an error.  Thus, nonrecursive
mutexes are more informative than fast mutexes because fast mutexes
block in such a case, leaving it up to you to determine why the
thread no longer executes.  Also, if someone other than the owner tries
to unlock a nonrecursive mutex, an error is returned.
</Para>
</ListItem>
</ItemizedList>
<Para>To lock a mutex, use one of the following routines, depending on what you
want to happen if the mutex is locked:
</Para>
<ItemizedList>
<ListItem>
<Para>The <Function>pthread_mutex_lock()</Function> routine
</Para>
<Para>If the mutex is locked, the thread waits for the mutex to become
available.
</Para>
</ListItem>
<ListItem>
<Para>The <Function>pthread_mutex_trylock()</Function> routine
</Para>
<Para>If the mutex is locked, the thread continues without waiting for the
mutex to become available.  The thread immediately checks the return status
to see if the lock was successful, and then takes whatever action is
appropriate if it was not.
</Para>
</ListItem>
</ItemizedList>
<Para>When a thread is finished accessing a piece of shared data, it unlocks the
associated mutex by calling the <Function>pthread_mutex_unlock()</Function> routine.
</Para>
<Para>If another thread is waiting on the mutex, its execution is unblocked.  If more
than one thread is waiting on the mutex, the scheduling policy 
and the thread scheduling priority determine which thread acquires the mutex.
</Para>
<Para>You can delete a mutex and reclaim its storage by calling the 
<Function>pthread_mutex_destroy()</Function> routine. 
Use this routine only after the
mutex is no longer needed by any thread.  Mutexes are automatically
deleted when the program terminates.
<IndexTerm Id="DCEADG.THRC.indx.45" SpanEnd="DCEADG.THRC.indx.44"></Para>
</Sect2>
<Sect2 Id="DCEADG.THRC.div.20">
<Title>Condition Variables</Title>
<Para><IndexTerm Id="DCEADG.THRC.indx.46">
<Primary>synchronization objects</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.47">
<Primary>condition variable</Primary>
</IndexTerm>A condition variable
allows a thread to block its own execution
until some shared data reaches a particular state.  Cooperating threads check
the shared data and wait on the condition variable.  For example, one thread
in a program produces work-to-do packets and another thread consumes these
packets (does the work).  If the work queue is empty when the consumer thread
checks it, that thread waits on a work-to-do condition variable.  When the
producer thread puts a packet on the queue, it signals the work-to-do
condition variable.
</Para>
<Para>A condition variable is used to wait for a shared resource to assume 
some specific state (a predicate).  A mutex, on the other hand, is used 
to reserve some shared resource while the resource is being 
manipulated.
For example, a thread A may need to wait for a thread B to finish a 
task X before thread A proceeds to execute a task Y. Thread B can 
tell thread A that it has finished task X by using a variable they 
both have access to, a condition variable.  When thread A is ready to 
execute task Y, it looks at the condition variable to see if thread B 
is finished (see Figure 7-3).
</Para>
<Figure>
<Title>Thread A Waits on Condition Ready, Then Wakes Up and Proceeds</Title>
<Graphic Format="EPS" Entityref="DCEADG.THRC.ent.8"></Graphic>
</Figure>
<!-- .pI ../threads/figures/2_concepts_02.ps 0 0 1-->
<?sml-space .2>
<?sml-space .5>
<Para><?sml-need 9>
<IndexTerm Id="DCEADG.THRC.indx.48">
<Primary>condition variable</Primary>
<Secondary>diagram of</Secondary>
</IndexTerm>First, thread A locks the mutex named <Literal>mutex_ready</Literal> that is associated 
with the condition variable.  Then it reads the predicate associated 
with the condition variable 
named <Literal>ready</Literal>.  If the predicate indicates that thread B has 
finished task X, then thread A can unlock the mutex and proceed with 
task Y.  If the condition variable predicate indicated 
that thread B has not yet finished task X, 
however, then thread A waits for the condition variable to change.  Thread A 
calls the <Literal>wait</Literal> primitive.  Waiting on the condition variable 
automatically unlocks the mutex, 
allowing thread B to lock the mutex when it has finished task X 
(see Figure 7-4).
</Para>
<Figure>
<Title>Thread B Signals Condition Ready</Title>
<Graphic Entityref="DCEADG.THRC.ent.3"></Graphic>
</Figure>
<?sml-space .5>
<Para><?sml-need 3>
<IndexTerm Id="DCEADG.THRC.indx.49">
<Primary>condition variable</Primary>
<Secondary>figure of</Secondary>
</IndexTerm>Thread B updates the predicate named 
<Literal>ready</Literal> associated with the condition variable to the state thread 
A is waiting for.  It also executes a signal on the condition variable 
while holding the mutex <Literal>mutex_ready</Literal>.
</Para>
<?sml-need 2.5i>
<Figure>
<Title>Thread A Wakes Up and Proceeds</Title>
<Graphic Entityref="DCEADG.THRC.ent.4"></Graphic>
</Figure>
<?sml-space .5>
<Para>Thread A wakes up, verifies that the condition variable is in the 
correct state, and proceeds to execute task Y (see Figure 7-3).
</Para>
<Para>Note that, although the condition variable is used for explicit 
communications among threads, the communications are anonymous.  Thread B 
does not necessarily know that thread A is waiting on the condition 
variable that thread B signals.  And thread A does not know that it 
was thread B that woke it up from its wait on the condition variable.
<!-- You must associate a condition variable with a mutex.  A thread locks a mutex-->
<!-- for some shared data and then checks whether or-->
<!-- not the shared data is in the proper state.  If it is not in the proper-->
<!-- state, the thread waits on the appropriate condition variable.  Waiting on-->
<!-- the condition variable unlocks the-->
<!-- mutex.  It is essential that the mutex be unlocked because another thread-->
<!-- needs to acquire the mutex in order to put the data in the appropriate state-->
<!-- for the waiting thread.  When the thread that acquires the mutex puts the-->
<!-- data in the appropriate state, it wakes-->
<!-- a waiting thread by signaling the condition variable.  One thread comes out-->
<!-- of its wait state with the mutex locked (the thread relocks the mutex before-->
<!-- returning from the wait); other threads waiting on the condition variable-->
<!-- remain blocked.-->
</Para>
<Para>Use the <Function>pthread_cond_init()</Function> routine 
to create a condition variable.
To create condition variables as part of the program's one-time
initialization code, see Section 7.5.
</Para>
<Para>Use the <Function>pthread_cond_wait()</Function> routine to cause a thread to wait
until the condition is signaled or broadcast.
This routine specifies a condition variable and a mutex that you have
locked. (If you have not locked the mutex, the results of 
<Function>pthread_cond_wait()</Function> 
are unpredictable.) This routine unlocks the
mutex and causes the calling thread to wait on the condition variable until
another thread calls one of the following routines:
</Para>
<ItemizedList>
<ListItem>
<Para>The <Function>pthread_cond_signal()</Function> 
routine to wake one thread that is waiting on the
condition variable
</Para>
</ListItem>
<ListItem>
<Para>The <Function>pthread_cond_broadcast()</Function> 
routine to wake all threads that are waiting
on a condition variable
</Para>
</ListItem>
</ItemizedList>
<Para>If you want to limit the time that a thread waits for a condition to be
signaled or broadcast, use the <Function>pthread_cond_timedwait()</Function> routine.
This routine specifies the condition variable, mutex, and absolute time at
which the wait should expire if the condition variable is not signaled
or broadcast.
</Para>
<Para>You can delete a condition variable and reclaim its storage by calling the
<Function>pthread_cond_destroy()</Function> routine. 
Use this routine only after the
condition variable is no longer needed by any thread.  Condition variables
are automatically deleted when the program terminates.
<IndexTerm Id="DCEADG.THRC.indx.50" SpanEnd="DCEADG.THRC.indx.47"></Para>
</Sect2>
<Sect2 Id="DCEADG.THRC.div.21">
<Title>Other Synchronization Methods</Title>
<Para><IndexTerm Id="DCEADG.THRC.indx.51">
<Primary>join primitive</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.52">
<Primary>synchronization methods</Primary>
</IndexTerm>There is another synchronization method that is not anonymous: the 
<Command>join</Command> primitive.  This allows a thread to wait for another 
specific thread to complete its execution.  When the second thread is
finished, the first thread unblocks and continues its execution.  
Unlike mutexes and condition variables, the <Command>join</Command> primitive is not 
associated with any particular shared data.
</Para>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.THRC.div.22">
<Title>One-Time Initialization Routines</Title>
<Para><IndexTerm Id="DCEADG.THRC.indx.53">
<Primary>initialization routines, one-time</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.54">
<Primary>one-time initialization routines</Primary>
</IndexTerm>You probably have one or more routines that must be executed <Replaceable>before</Replaceable>
any thread executes code in your application, but must be executed 
<FirstTerm>only once</FirstTerm>
regardless of the sequence in which threads start executing.  For example,
you may want to create mutexes and condition variables (each of which must
be created only once) in an initialization routine.
Multiple threads can call the <Function>pthread_once()</Function> 
routine, or 
the <Function>pthread_once()</Function> 
routine can be called multiple times in the same thread,
resulting in only one call to the specified routine.
</Para>
<Para>Use the <Function>pthread_once()</Function> routine to ensure that your application 
initialization routine is executed only a single time, that is, by the 
first thread that tries to initialize the application.  
This routine is the only way to guarantee that one-time 
initialization is performed in a multithreaded environment 
on a given platform.  The <Function>pthread_once()</Function>
routine is of particular use for runtime libraries, which are often 
called for the first time after multiple threads are created.
</Para>
<Para>Refer to the <Filename MoreInfo="RefEntry">thr_intro(3thr)</Filename> reference page for a list of the
DCE Threads routines which, when called, implicitly perform any necessary
initialization of the threads package.  Any application that uses DCE Threads
must call one of these routines before calling any other threads routines.
</Para>
</Sect1>
<Sect1 Id="DCEADG.THRC.div.23">
<Title>Thread-Specific Data</Title>
<Para><IndexTerm Id="DCEADG.THRC.indx.55">
<Primary>thread-specific data</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.56">
<Primary>data</Primary>
<Secondary>thread-specific</Secondary>
</IndexTerm>
<!-- Each thread has an area in which thread-specific context information is-->
<!-- kept.-->
<!-- You can also associate arbitrary data with a thread's context.  That is, you-->
<!-- can think of this as the ability to add one or more user-specified fields to-->
<!-- the current thread's context.-->
The thread-specific data interfaces allow each thread to associate an 
arbitrary value with a shared key value created by the program.
</Para>
<Para>Thread-specific data is like a global variable in which each thread can keep
its own value, but is accessible to the thread anywhere in the program.
</Para>
<Para>Use the following routines to create and access thread-specific data:
</Para>
<ItemizedList>
<ListItem>
<Para>The <Function>pthread_keycreate()</Function> routine to create a unique key value
</Para>
</ListItem>
<ListItem>
<Para>The <Function>pthread_setspecific()</Function> routine to associate data with a key
</Para>
</ListItem>
<ListItem>
<Para>The <Function>pthread_getspecific()</Function> 
routine to obtain the data associated with a key
</Para>
</ListItem>
</ItemizedList>
<Para>The <Function>pthread_keycreate()</Function> routine generates a unique key value
that is shared by all threads in the process. 
This key is the identifier of a piece of thread-specific data.  
Each thread uses the 
same key value to assign or retrieve a thread-specific value.
This keeps your data separate
from other thread-specific data.  One call to the <Function>pthread_keycreate()</Function> 
routine creates a cell in all threads.
Call this routine to specify a routine to be called to destroy the context
value associated with this key when the thread terminates.
</Para>
<Para>The <Function>pthread_setspecific()</Function> routine associates the address of some
data with a specific key. 
Multiple threads associate different data (by
specifying different addresses) with the same key.  For example, each thread
points to a different block of dynamically allocated memory that it has
reserved.
</Para>
<Para>The <Function>pthread_getspecific()</Function> routine obtains the address of the
thread-specific data value associated with a specified key.  Use this routine
to locate the data associated with the current thread's context.
</Para>
</Sect1>
<Sect1 Id="DCEADG.THRC.div.24">
<Title>Thread Cancellation</Title>
<Para><IndexTerm Id="DCEADG.THRC.indx.57">
<Primary>canceling a thread</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.58">
<Primary>thread</Primary>
<Secondary>canceling</Secondary>
</IndexTerm>Canceling is a mechanism by which one thread terminates another
thread (or itself).  When you request that a thread be canceled, you are
requesting that it terminate as soon as possible.  However,
the target thread
can control how quickly it terminates by controlling its general
cancelability and its asynchronous cancelability.
</Para>
<Para>The following is a list of the pthread calls that are cancellation 
points:
</Para>
<ItemizedList>
<ListItem>
<Para>The <Function>pthread_setasynccancel()</Function> routine
</Para>
</ListItem>
<ListItem>
<Para>The <Function>pthread_testcancel()</Function> routine
</Para>
</ListItem>
<ListItem>
<Para>The <Function>pthread_delay_np()</Function> routine
</Para>
</ListItem>
<ListItem>
<Para>The <Function>pthread_join()</Function> routine
</Para>
</ListItem>
<ListItem>
<Para>The <Function>pthread_cond_wait()</Function> routine
</Para>
</ListItem>
<ListItem>
<Para>The <Function>pthread_cond_timedwait()</Function> routine
</Para>
</ListItem>
</ItemizedList>
<Para><IndexTerm Id="DCEADG.THRC.indx.59">
<Primary>thread</Primary>
<Secondary>canceling</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.60">
<Primary>general cancelability</Primary>
</IndexTerm>General cancelability is enabled by default.  A thread is canceled
only at specific places in the program; for example, when a call to the
<Function>pthread_cond_wait()</Function> 
routine is made.  If general cancelability is
enabled, request the delivery of any pending cancel request by using the
<Function>pthread_testcancel()</Function> 
routine.  This routine allows you to permit
cancellation to occur at places where it may not otherwise be permitted
under general cancelability, and it is especially useful within very long
loops to ensure that cancel requests are noticed within a reasonable time.
</Para>
<Para>If you disable general cancelability, the thread cannot be terminated by any
cancel request.  Disabling general cancelability means that a thread could
wait indefinitely if it does not come to a normal conclusion. Therefore, be
careful about disabling general cancelability.
</Para>
<Para><IndexTerm Id="DCEADG.THRC.indx.61">
<Primary>thread</Primary>
<Secondary>canceling</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.62">
<Primary>asynchronous cancelability</Primary>
</IndexTerm>Asynchronous cancelability, when it is enabled, allows cancels to be 
delivered to the enabling thread at any time, not only at those times 
that are permitted when just general cancelability is enabled.
Thus, use asynchronous cancellation primarily during long processes 
that do not have specific places for cancel requests.
Asynchronous cancelability is disabled by default.  Disable asynchronous 
cancelability when calling threads routines or any other runtime library 
routines that are not explicitly documented as cancel-safe.
</Para>
<Note>
<Para>If general cancelability is disabled, the thread cannot be canceled,
regardless of whether asynchronous cancelability is enabled or disabled.  The
setting of asynchronous cancelability is relevant only when general
cancelability is enabled.
</Para>
</Note>
<Para>Use the following routines to control the canceling of threads:
</Para>
<ItemizedList>
<ListItem>
<Para>The <Function>pthread_setcancel()</Function> 
routine to enable and disable general cancelability
</Para>
</ListItem>
<ListItem>
<Para>The <Function>pthread_testcancel()</Function> 
routine to request delivery of a pending cancel to
the current thread
</Para>
</ListItem>
<ListItem>
<Para>The <Function>pthread_setasynccancel()</Function> 
routine to enable and disable asynchronous cancelability
</Para>
</ListItem>
<ListItem>
<Para>The <Function>pthread_cancel()</Function> routine to request that a thread be canceled
</Para>
</ListItem>
</ItemizedList>
<IndexTerm Id="DCEADG.THRC.indx.63" SpanEnd="DCEADG.THRC.indx.10">
</Sect1>
<Sect1 Id="DCEADG.THRC.div.25">
<Title>Thread Scheduling</Title>
<Para><IndexTerm Id="DCEADG.THRC.indx.64">
<Primary>scheduling</Primary>
<Secondary>threads</Secondary>
<See>threads, scheduling</See>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.65">
<Primary>threads</Primary>
<Secondary>scheduling</Secondary>
</IndexTerm>Threads are scheduled according to their scheduling priority and how the
scheduling policy treats those priorities.  To understand the discussion in
this section, you must understand the concepts in the following sections 
of this chapter:
</Para>
<ItemizedList>
<ListItem>
<Para>Section 7.3.3.1 discusses scheduling policies, including the way in
which each policy handles thread scheduling priority.
</Para>
</ListItem>
<ListItem>
<Para>Section 7.3.3.2 discusses thread scheduling priorities.
</Para>
</ListItem>
<ListItem>
<Para>Section 7.3.3.3 discusses inheritance of scheduling
attributes by created threads.
</Para>
</ListItem>
</ItemizedList>
<Para>To specify the minimum or maximum priority, use the appropriate symbol;
for example, <Literal>PRI_OTHER_MIN</Literal> or <Literal>PRI_OTHER_MAX</Literal>.  To
specify a value between the minimum and maximum priority, use an
appropriate arithmetic expression.  
</Para>
<Para><?sml-need 5>For example, to specify a priority
midway between the minimum and maximum for the default scheduling
policy, specify the following concept using your programming
language's syntax:
</Para>
<InformalExample>
<Para><ProgramListing>pri_other_mid = (PRI_OTHER_MIN + PRI_OTHER_MAX)/2
</ProgramListing></Para>
</InformalExample>
<Para>If your expression results in a value outside the range of minimum to
maximum, an error results when you use it.
Priority values are integers.
</Para>
<Para>To show results of the different scheduling policies, consider the following
example: a program has four threads, called threads A, B, C, and D. For each
scheduling policy, three scheduling priorities have been defined: minimum,
middle, and maximum.  The threads have the priorities shown in Table 7-1.
<IndexTerm Id="DCEADG.THRC.indx.66">
<Primary>thread</Primary>
<Secondary>priorities</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.67">
<Primary>priority</Primary>
<Secondary>of scheduling routines</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THRC.indx.68">
<Primary>scheduling</Primary>
</IndexTerm></Para>
<Table Frame="all" Remap="center" Orient="Port">
<Title>Sample Thread Properties</Title>
<TGroup Rowsep="1" Colsep="1" Cols="2">
<ColSpec Colsep="1" Align="Center" Colwidth="1*" Colname="col1" Colnum="1">
<ColSpec Align="Left" Colwidth="1*" Colname="col2" Colnum="2">
<TBody>
<Row>
<Entry Rowsep="1" Align="Left"><Literal>Thread</Literal></Entry>
<Entry Rowsep="1"><Literal>Priority</Literal></Entry>
</Row>
<Row>
<Entry>A</Entry>
<Entry>Minimum</Entry>
</Row>
<Row>
<Entry>B</Entry>
<Entry>Middle</Entry>
</Row>
<Row>
<Entry>C</Entry>
<Entry>Middle</Entry>
</Row>
<Row>
<Entry>D</Entry>
<Entry>Maximum</Entry>
</Row>
</TBody>
</TGroup>
</Table>
<Para>Figures 7-6 through 7-8 show execution flows, depending on whether the 
threads use the 
<Literal>SCHED_FIFO</Literal>, <Literal>SCHED_RR</Literal>, or <Literal>SCHED_OTHER</Literal> (default)
scheduling policy.  Assume that all waiting threads are
ready to execute when the current thread waits or terminates and that
no higher-priority thread is awakened while a thread is executing
(during the flow shown in each figure).
</Para>
<Para>Figure 7-6 shows a flow with  
<Literal>SCHED_FIFO</Literal> (First In, First Out) scheduling.
</Para>
<Figure>
<Title>Flow with SCHED_FIFO Scheduling</Title>
<Graphic Entityref="DCEADG.THRC.ent.5"></Graphic>
</Figure>
<Para>Thread D executes until it waits or terminates, then Thread B starts because
it has been waiting longer than Thread C and it executes until it waits or
terminates, then Thread C executes until it waits or terminates, then Thread
A executes.
</Para>
<Para><?sml-need 2i>Figure 7-7 shows a flow with <Literal>SCHED_RR</Literal> (Round Robin)
scheduling.
</Para>
<Figure>
<Title>Flow with SCHED_RR Scheduling</Title>
<Graphic Entityref="DCEADG.THRC.ent.6"></Graphic>
</Figure>
<Para>All four threads are timesliced.  Threads with higher priority are 
generally scheduled when more than one thread is ready to run; 
however, to ensure fairness, all threads are given some time.  The 
effective priority of threads may be modified over time by the 
scheduler, depending on the use of processor resources.
</Para>
<Para>Thread D executes until it waits or terminates, then threads B and C are
timesliced because they both have middle priority, then thread A executes.
</Para>
<Para>Figure 7-8 shows a flow with <Literal>SCHED_OTHER</Literal> (default)
scheduling. 
<IndexTerm Id="DCEADG.THRC.indx.69" SpanEnd="DCEADG.THRC.indx.65"></Para>
<Figure>
<Title>Flow with SCHED_OTHER Scheduling</Title>
<Graphic Entityref="DCEADG.THRC.ent.7" Scalefit="1" Reprodep="350" Reprowid="350"></Graphic>
</Figure>
<Para>Thread D executes until it waits or terminates; then threads B, C, and A are
timesliced, even though thread A has a lower priority than the other two.
Thread A receives less execution time than thread B or C if either is ready
to execute as often as thread A is.  However, the default scheduling policy
protects thread A against being blocked from executing indefinitely.
</Para>
<Para>Because low-priority threads eventually run, the default scheduling policy
protects against the problem of priority inversion discussed in 
Chapter 8.
</Para>
</Sect1>
</Chapter>
<!--+ 11/27/96 19:53:47
    | tagMorph:  $Id: 2_concepts.sgm,v 1.1.2.8 1996/12/14 20:23:49 wardr Exp $
    | tagMorph library:  $Id: 2_concepts.sgm,v 1.1.2.8 1996/12/14 20:23:49 wardr Exp $
    | sml-to-docbook:  1.25
    +-->
