<!--
# @OSF_COPYRIGHT@
# 
# 
# HISTORY
# $Log: rpc_and_dce.sgm,v $
# Revision 1.1.2.8  1996/12/14  20:24:36  wardr
# 	{edit,R1.2.2}
# 	penultimate format fixes
# 	[1996/12/14  20:22:38  wardr]
#
# Revision 1.1.2.7  1996/12/13  22:11:23  wardr
# 	{edit,R1.2.2}
# 	Fixed formatting problems
# 	[1996/12/13  22:09:11  wardr]
# 
# Revision 1.1.2.6  1996/12/12  21:31:02  wardr
# 	{edit,R1.2.2}
# 	Fixed formatting problems
# 	[1996/12/12  21:29:08  wardr]
# 
# Revision 1.1.2.5  1996/12/12  16:50:05  carrig
# 	{enh,R1.2.2}
# 	Minor edits
# 	[1996/12/12  16:47:51  carrig]
# 
# Revision 1.1.2.4  1996/12/06  21:10:38  carrig
# 	{enh,R1.2.2}
# 	Second pass for editor
# 	[1996/12/06  21:08:38  carrig]
# 
# Revision 1.1.2.3  1996/12/05  21:39:29  carrig
# 	{enh,R1.2.2}
# 	First pass to prepare for editing
# 	[1996/12/05  21:37:41  carrig]
# 
# Revision 1.1.2.2  1996/12/02  15:41:35  weir
# 	Removed thinsp entities, corrected other minor errors
# 	[1996/12/02  15:39:50  weir]
# 
# Revision 1.1.2.1  1996/12/01  20:44:06  weir
# 	Initial submission
# 	[1996/12/01  20:42:05  weir]
# 
# $EndLog$
-->
<!-- Fragment document type declaration subset:
ArborText, Inc., 1988-1993, v.4001
<!DOCTYPE Book PUBLIC "-//Davenport//DTD DocBook V2.4//EN" [
<!ENTITY  DCEADG.RPCRAD.ent.1  SYSTEM "eps/7_advanced_topics_03.ps" NDATA eps>
<!ENTITY  DCEADG.RPCRAD.ent.2  SYSTEM "eps/7_advanced_topics_04.ps" NDATA eps>
<!ENTITY  DCEADG.RPCRAD.ent.3  SYSTEM "eps/7_advanced_topics_05.ps" NDATA eps>
<!ENTITY  DCEADG.RPCRAD.ent.4  SYSTEM "eps/7_advanced_topics_06.ps" NDATA eps>
<!ENTITY  DCEADG.RPCRAD.ent.5  SYSTEM "eps/7_advanced_topics_07.ps" NDATA eps>
<!ENTITY  DCEADG.RPCRAD.ent.6  SYSTEM "eps/7_advanced_topics_08.ps" NDATA eps>
<!ENTITY  DCEADG.RPCRAD.ent.7  SYSTEM "eps/7_advanced_topics_01.ps" NDATA eps>
<!ENTITY  DCEADG.RPCRAD.ent.8  SYSTEM "eps/6_nsi_usage_01.ps" NDATA eps>
<!ENTITY  DCEADG.RPCRAD.ent.9  SYSTEM "eps/6_nsi_usage_02.ps" NDATA eps>
<!ENTITY  DCEADG.RPCRAD.ent.10  SYSTEM "eps/6_nsi_usage_03.ps" NDATA eps>
<!ENTITY  DCEADG.RPCRAD.ent.11  SYSTEM "eps/6_nsi_usage_04.ps" NDATA eps>
<!ENTITY  DCEADG.RPCRAD.ent.12  SYSTEM "eps/7_advanced_topics_02.ps" NDATA eps>
<!ENTITY  DCEADG.RPCRAD.ent.13  SYSTEM "eps/6_nsi_usage_05.ps" NDATA eps>
<!ENTITY  DCEADG.RPCRAD.ent.14  SYSTEM "eps/6_nsi_usage_06.ps" NDATA eps>
<!ENTITY  DCEADG.RPCRAD.ent.15  SYSTEM "eps/6_nsi_usage_07.ps" NDATA eps>
<!ENTITY  DCEADG.RPCRAD.ent.16  SYSTEM "eps/6_nsi_usage_08.ps" NDATA eps>
<!ENTITY  DCEADG.RPCRAD.ent.17  SYSTEM "eps/6_nsi_usage_09.ps" NDATA eps>
<!ENTITY  DCEADG.RPCRAD.ent.18  SYSTEM "eps/6_nsi_usage_10.ps" NDATA eps>
<!ENTITY  DCEADG.RPCRAD.ent.19  SYSTEM "eps/6_nsi_usage_11.ps" NDATA eps>
]>
-->
<!-- COPYRIGHT NOTICE-->
<!-- Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.-->
<!-- ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for-->
<!-- the full copyright text.-->
<!-- -->
<!-- -->
<!-- OLD HISTORY-->
<!-- Revision 1.1.6.2  1996/09/24  14:48:36  sherman-->
<!-- 	{edt,R1.2.2}-->
<!-- 	OSF edits for 13625 single-threaded client-->
<!-- 	[1996/09/24  14:47:17  sherman]-->
<!---->
<!-- Revision 1.1.6.1  1996/09/05  17:13:36  sherman-->
<!-- 	{enh,13625,R1.2.2}-->
<!-- 	[1996/09/05  17:12:58  sherman]-->
<!-- -->
<!-- Revision 1.1.4.2  1996/03/27  13:32:25  wardr-->
<!-- 	{edit R1.2.1}-->
<!-- 	More Release Edits-->
<!-- 	[1996/03/27  13:31:49  wardr]-->
<!-- -->
<!-- Revision 1.1.4.1  1996/03/21  20:31:34  wardr-->
<!-- 	{edit R1.2.1}-->
<!-- 	Release Edits-->
<!-- 	[1996/03/21  20:31:03  wardr]-->
<!-- -->
<!-- Revision 1.1.2.11  1995/06/07  14:38:34  rcb-->
<!-- 	PRENTICE HALL reformat; final edits and changes-->
<!-- 	[1995/06/05  19:56:13  rcb]-->
<!-- -->
<!-- 	minor change-->
<!-- 	[1995/05/22  16:42:08  rcb]-->
<!-- -->
<!-- 	PRENTICE HALL reformat-->
<!-- 	[1995/04/19  15:00:46  rcb]-->
<!-- -->
<!-- 	incorporated 1.1 edits-->
<!-- 	[1995/04/17  20:30:37  rcb]-->
<!-- -->
<!-- Revision 1.1.2.10  1994/11/03  23:34:36  neilson-->
<!-- 	Substituted macros for book names in cross refs.-->
<!-- 	[1994/11/03  01:39:01  neilson]-->
<!-- -->
<!-- 	Substituted macros for book names in cross refs.-->
<!-- -->
<!-- Revision 1.1.2.9  1994/10/27  19:43:02  jshirley-->
<!-- 	Final edits.-->
<!-- 	[1994/10/27  19:42:04  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.8  1994/10/11  03:02:10  jshirley-->
<!-- 	{def,10526,R1.1} Reorganization of RPC chapters.-->
<!-- 	[1994/10/11  03:01:39  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.7  1994/10/10  16:06:13  rjohnson-->
<!-- 	No changes were made.-->
<!-- 	[1994/10/10  16:05:48  rjohnson]-->
<!-- -->
<!-- 	Changes made: None.-->
<!-- -->
<!-- Revision 1.1.2.6  1994/09/13  19:41:30  buckler-->
<!-- 	{def, 9272, R1.1}-->
<!-- 	Added information about how authentication is established-->
<!-- 	between servers and clients.-->
<!-- 	[1994/09/13  19:41:06  buckler]-->
<!-- -->
<!-- Revision 1.1.2.5  1994/08/31  15:22:35  hal-->
<!-- 	Moved "would" to start of log header line for Rev 1.1.2.4 that started-->
<!-- 	with "build" in order to prevent error message when formatting.-->
<!-- 	[1994/08/31  15:22:15  hal]-->
<!-- -->
<!-- Revision 1.1.2.4  1994/08/29  20:12:48  jshirley-->
<!-- 	(CR, 10526, R1.1}-->
<!-- 	Rearranged the headings in the Namespace sections so the book-->
<!-- 	would build correctly.-->
<!-- 	[1994/08/29  20:11:22  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.3  1994/08/11  20:36:33  jhh-->
<!-- 	expand copyright-->
<!-- 	[1994/08/11  19:58:38  jhh]-->
<!-- -->
<!-- Revision 1.1.2.2  1994/07/11  17:50:57  jshirley-->
<!-- 	{def,10526,R1.1}-->
<!-- 	Updated headings for new reorganization and inserted all of old file-->
<!-- 	7_nsi_usage.gpsml.  THe Name Service Section is two distinct chunks,-->
<!-- 	concatenated together.  Reorganization and heading renumbering is needed.-->
<!-- 	[1994/07/11  17:49:33  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.1  1994/07/08  15:20:20  jshirley-->
<!-- 	{def,10526,R1.1}-->
<!-- 	Created new file for the RPC reorganization based on the old file-->
<!-- 	.../rpc/6_advanced_topics.gpsml-->
<!-- 	[1994/07/08  15:18:49  jshirley]-->
<!-- -->
<!-- -->
<!---->
<Chapter Id="DCEADG.RPCRAD.div.1">
<Title>RPC and Other DCE Components</Title>
<Para>This chapter discusses aspects of the internal behavior of 
remote procedure calls that are significant for advanced RPC
programmers, including the following topics:
</Para>
<ItemizedList>
<ListItem>
<Para>Threads of execution in RPC applications
</Para>
</ListItem>
<ListItem>
<Para>Authenticated remote procedure calls
</Para>
</ListItem>
<ListItem>
<Para>Using the Name Service Interface
</Para>
</ListItem>
</ItemizedList>
<!-- .ML (bulleted) list-->
<Para>DCE RPC is a fully integrated part of the distributed computing
environment.  The communications capabilities of DCE RPC are used
by clients and servers of other DCE components.  In turn, RPC uses
services provided by
DCE Threads, 
the DCE Security Service, and the DCE Cell Directory Service.
</Para>
<Para>A thread is a
single sequential flow of control with one point of execution on a single
processor at any instant.  Multiple threads can coexist in a single process.
DCE RPC uses threads internally for its own operations. 
DCE RPC also provides an environment where RPC applications can use
thread services. 
</Para>
<Para><?sml-need 10>The DCE RPC runtime provides RPC applications with a programming
<IndexTerm Id="DCEADG.RPCRAD.indx.1">
<Primary>authorization interface</Primary>
<Secondary>authenticated RPC</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.2">
<Primary>authenticated RPC</Primary>
<Secondary>authorization</Secondary>
</IndexTerm>interface to the security service.  The RPC authentication interface
enables RPC clients and servers to mutually authenticate
(that is, prove the identity of) each other.
<IndexTerm Id="DCEADG.RPCRAD.indx.3">
<Primary>authenticated RPC</Primary>
<Secondary>authenticate</Secondary>
</IndexTerm>An authenticated remote procedure call provides client authorization
information and authentication information to servers. 
<IndexTerm Id="DCEADG.RPCRAD.indx.4">
<Primary>authenticated RPC</Primary>
<Secondary>authorization</Secondary>
</IndexTerm>Authorization information includes
the credentials a client has and the identities a client is associated with at
the time of a call.  By comparing client authorization information to access
control lists, a server can find out whether a client is eligible to use a
requested remote procedure. 
<IndexTerm Id="DCEADG.RPCRAD.indx.5">
<Primary>client</Primary>
<Secondary>authentication information, RPC</Secondary>
</IndexTerm>Client authentication information identifies a client to a server. 
</Para>
<Para>To help RPC clients find RPC servers, RPC applications typically use
a namespace.  A namespace is a collection of information about
applications, systems, and any other relevant computing resources.
A namespace is maintained by a directory service such 
as CDS.  DCE RPC 
provides a Name Service Interface (NSI) that is independent of any
particular directory service. 
</Para>
<Para>NSI communicates with supported directory services for both
RPC applications and the RPC control program.  NSI insulates RPC
applications from the intricacies of using a 
directory service.  An RPC server uses
NSI to store information about itself in a namespace, and a
client uses NSI to access information about a server that meets the
client's requirements for a specific RPC interface and object, among
other things.  The client uses this information to establish a
relationship, known as a <FirstTerm>binding</FirstTerm>, with the server. 
</Para>
<Sect1 Id="DCEADG.RPCRAD.div.2">
<Title>Threads of Execution in RPC Applications</Title>
<Para>Each remote procedure call occurs in an execution context 
called a <FirstTerm>thread</FirstTerm>.
<!-- .gL "thread"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.6">
<Primary>thread</Primary>
</IndexTerm>A thread is a single sequential flow of control with one point
of execution on a single processor at any instant.
<!-- .gL "application thread"-->
A thread created and managed by application code
is an <FirstTerm>application thread</FirstTerm>.
<IndexTerm Id="DCEADG.RPCRAD.indx.7">
<Primary>application</Primary>
<Secondary>RPC thread</Secondary>
</IndexTerm></Para>
<Para>Traditional processing occurs 
exclusively within 
<!-- .gL "local application thread"-->
local application threads.
<IndexTerm Id="DCEADG.RPCRAD.indx.8">
<Primary>local application thread</Primary>
<Secondary>RPC</Secondary>
</IndexTerm>Local application threads execute within the confines of one address space on a
local system and pass control exclusively among local code segments, 
as illustrated in Figure 14-1.
</Para>
<?sml-need 2i>
<Figure>
<Title>Local Application Thread During a Procedure Call</Title>
<Graphic Entityref="DCEADG.RPCRAD.ent.1" Scalefit="1" Reprodep="250" Reprowid="250"></Graphic>
</Figure>
<!-- DEC-file name .P! pictures/rpc-thread-local.ps 2.0i-->
<?sml-space .5>
<Para>RPC applications also use application threads
to issue both remote procedure calls and runtime calls, as follows:
</Para>
<ItemizedList>
<ListItem>
<Para>An RPC client contains one or more 
<!-- .gL "client application thread"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.9">
<Primary>client</Primary>
<Secondary>application thread</Secondary>
<Tertiary>RPC</Tertiary>
</IndexTerm>client application threads; that is, a thread that executes client
application code that makes one or more remote procedure calls. 
</Para>
</ListItem>
<ListItem>
<Para>A DCE RPC server uses one 
<!-- .gL "server application thread"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.10">
<Primary>server</Primary>
<Secondary>application thread</Secondary>
</IndexTerm>server application thread to execute the server
application code that listens for incoming calls. 
</Para>
</ListItem>
</ItemizedList>
<!-- .ML (bulleted) list-->
<Para>In addition, for executing called remote procedures, an RPC server uses one or
more 
<!-- .gL "call thread"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.11">
<Primary>call thread</Primary>
</IndexTerm>call threads that the RPC runtime provides.  As part of initiating
listening, the server application thread specifies the maximum number of
concurrent calls it will execute.  
The maximum number of call threads in
multithreaded applications depends on the design of the application.  The RPC
runtime creates the same number of call threads in the server process. 
</Para>
<Para>The number of call threads is significant to application code.
When using only one call execution thread, application code does not have to
protect itself against concurrent resource use.  When using more than one call
thread, application code must protect itself against concurrent resource use. 
</Para>
<Para>Figure 14-2 shows a multithreaded server with a maximum
of four concurrently executing calls.  Of the four call threads for the
server, only one is currently in use; the other three threads are available
for executing calls.
</Para>
<?sml-need 3i>
<Figure>
<Title>Server Application Thread and Multiple Call Threads</Title>
<Graphic Entityref="DCEADG.RPCRAD.ent.2" Scalefit="1" Reprodep="250" Reprowid="250"></Graphic>
</Figure>
<!-- DEC-file name .P! pictures/rpc-threads-server-side.ps 3.0i-->
<Sect2 Id="DCEADG.RPCRAD.div.3">
<Title>Remote Procedure Call Threads</Title>
<Para>In distributed processing, a call extends to and from client and server address
spaces.  Therefore, when a client application thread calls a remote procedure,
it becomes part of a logical thread of execution known as 
<!-- .gL "RPC thread"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.12">
<Primary>RPC</Primary>
<Secondary>thread</Secondary>
</IndexTerm>an <FirstTerm>RPC thread</FirstTerm>.
An RPC thread is a logical construct that encompasses the various phases of a
remote procedure call as it extends across actual threads of execution and the
network. 
After making a remote procedure call, the calling client application thread
becomes part of the RPC thread.  Usually, the RPC thread maintains execution
control until the call returns. 
</Para>
<Para>The RPC thread of a successful remote procedure call moves through the 
execution phases illustrated in Figure 14-3. 
</Para>
<?sml-need 2.5i>
<Figure>
<Title>Execution Phases of an RPC Thread</Title>
<Graphic Entityref="DCEADG.RPCRAD.ent.3" Scalefit="1" Reprodep="300" Reprowid="300"></Graphic>
</Figure>
<!-- DEC-file name .P! pictures/rpc-thread-rpc.ps 2.5i-->
<?sml-space .5>
<Para>The execution phases of an RPC thread in the preceding figure
include the following operations:
</Para>
<OrderedList>
<ListItem>
<Para>The RPC thread begins in the client process, as a client application thread
makes a remote procedure call to its stub; at this point, 
the client thread becomes part of the RPC thread.
</Para>
</ListItem>
<ListItem>
<Para>The RPC thread extends across the network to the server address space.
</Para>
</ListItem>
<ListItem>
<!-- Assuming the server accepts the call,-->
<Para>The RPC thread extends into a call thread, where the remote
procedure executes.
While a called remote procedure is executing, the call thread becomes part of
the RPC thread.  When the call finishes executing, the call thread ceases being
part of the RPC thread. 
</Para>
</ListItem>
<ListItem>
<Para>The RPC thread then retracts across the network to the client.
</Para>
</ListItem>
<ListItem>
<Para>When the RPC thread arrives at the
calling client application thread, the remote procedure call
returns any call results and the client application thread
ceases to be part of the RPC thread.
</Para>
</ListItem>
</OrderedList>
<!-- .AL (numbered) list-->
<Para>Figure 14-4 shows a server executing remote procedures in its two call
threads, while the server application thread listens. 
</Para>
<?sml-need 4i>
<Figure>
<Title>Concurrent Call Threads Executing in Shared Address Space</Title>
<Graphic Entityref="DCEADG.RPCRAD.ent.4" Scalefit="1" Reprodep="300" Reprowid="300"></Graphic>
</Figure>
<!-- DEC-file name .P! pictures/rpc-threads-multi-call.ps 4.25i-->
<?sml-space .5>
<Note>
<Para>Although a remote procedure can be viewed logically as executing
within the exclusive control of an RPC thread,
some parallel activity does occur in both the client and server.
</Para>
</Note>
<Para>An RPC server can concurrently execute as many remote procedure calls as it has
call threads.  When a server is using all of its call threads, the server
application thread continues listening for incoming remote procedure calls. 
While waiting for a call thread to become available, DCE RPC server runtimes
can queue incoming calls.  Queuing incoming calls 
avoids remote procedure calls failing during short-term congestion.
The queue capacity for incoming calls is implementation dependent;
most implementations offer a small queue capacity.
The queuing of incoming calls is discussed
in Chapter 17, under the topic of the routing of incoming calls. 
</Para>
</Sect2>
<Sect2 Id="DCEADG.RPCRAD.div.4">
<Title>Cancels</Title>
<Para>DCE RPC uses and supports 
the synchronous cancel capability provided by POSIX threads (pthreads).
A 
<!-- .gL "cancel"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.13">
<Primary>cancels</Primary>
<Secondary>RPC</Secondary>
<Tertiary>use of</Tertiary>
</IndexTerm><FirstTerm>cancel</FirstTerm> is a mechanism by which a thread informs 
<!-- .gL "canceled thread"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.14">
<Primary>canceled thread</Primary>
</IndexTerm>another thread (the canceled thread) to terminate as soon as possible.  Cancels
operate on the RPC thread exactly as they would on a local thread, except for
an application-specified, cancel-timeout period. 
A 
<!-- .gL "cancel-timeout period"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.15">
<Primary>cancel-timeout period</Primary>
</IndexTerm>cancel-timeout period is an optional value that limits the amount of time
the canceled RPC thread has before it releases control. 
</Para>
<Para>During a remote procedure call, if its thread is canceled and the
cancel-timeout period expires before the call returns, the calling thread
regains control and the call is orphaned at the server.  An orphaned
call may continue to execute in the call thread.  However, the call thread is
no longer part of the RPC thread, and the orphaned call is unable to return
results to the client. 
</Para>
<Para>A client application thread can cancel any other client application thread in
the same process (it is possible, but unlikely, for a thread to cancel itself.)
While executing as part of an RPC thread, a call thread can be 
canceled only by a client application thread. 
</Para>
<Para>A cancel goes through several phases.  Figure 14-5
shows where each of these phases occur. 
</Para>
<Figure>
<Title>Phases of a Cancel in an RPC Thread</Title>
<Graphic Entityref="DCEADG.RPCRAD.ent.5" Scalefit="1" Reprodep="300" Reprowid="300"></Graphic>
</Figure>
<!-- DEC-file name .P! pictures/rpc-cancel-phases.ps 2.5i-->
<?sml-space .5>
<Para><?sml-need 6>The phases of a cancel in the preceding figure include
the following:
</Para>
<OrderedList>
<ListItem>
<!-- 1-->
<Para>A cancel that becomes pending at the client application thread at the
start of or during a remote procedure call becomes pending for the entire RPC
thread.  Thus, while still part of the RPC thread, 
the call thread also has this cancel pending. 
</Para>
</ListItem>
<ListItem>
<!-- 2-->
<Para>If the call thread of an RPC thread makes a cancelable call
when cancels are not deferred and a cancel is pending,
the cancel exception is raised.
</Para>
</ListItem>
<ListItem>
<!-- 3-->
<Para>The RPC thread returns to the canceled client application thread
with one of the following outcomes:
</Para>
<ItemizedList>
<ListItem>
<Para>If a cancel exception has not been taken, the RPC thread returns normal call
results (output arguments, return value, or both) with a pending
cancel. 
</Para>
</ListItem>
<ListItem>
<Para>If the remote procedure is using an exception handler, a cancel exception can be
handled.  The procedure resumes, and the RPC thread returns normal call results
without pending any cancel. 
</Para>
</ListItem>
<ListItem>
<Para>If the remote procedure failed to handle a raised cancel exception, 
the RPC thread returns with the cancel exception still raised.
This is returned as a fault.
</Para>
</ListItem>
<ListItem>
<Para>If the cancel-timeout period expires, the RPC thread returns either
a cancel-timeout exception or status code, depending
on how the application sets up its error handling.
This is true for all cases where any abnormal termination is returned.
</Para>
</ListItem>
</ItemizedList>
</ListItem>
</OrderedList>
</Sect2>
<Sect2 Id="DCEADG.RPCRAD.div.5">
<Title>Multithreaded RPC Applications</Title>
<Para>DCE RPC provides an environment for RPC applications that
create multiple application threads (multithreaded applications).
<IndexTerm Id="DCEADG.RPCRAD.indx.16">
<Primary>multithreaded applications</Primary>
</IndexTerm>The application threads of a multithreaded application share a common address
space and much of the common environment. 
If a multithreaded application must be 
thread-safe (guarantee that multiple threads can execute
simultaneously and correctly), the application is
responsible for its own concurrency control.
<!-- .gL "concurrency control"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.17">
<Primary>concurrency control</Primary>
<Secondary>RPC</Secondary>
</IndexTerm>Concurrency control involves programming techniques such as controlling
access to code that can share a data structure or other resource to prevent
conflicting overlapping access by separate threads. 
</Para>
<Para><?sml-need 10>A multithreaded RPC application can have diverse activities going on
simultaneously.  A multithreaded client can make 
concurrent remote procedure calls and a multithreaded server can
handle concurrent remote procedure calls.
Using multiple threads allows an RPC client or server to support local
application threads that continue processing independently of remote procedure
calls.  Also, multithreading enables 
the server application thread and the client application threads of an RPC
application to share a single address space as a joint client/server
instance.
A multithreaded RPC application can also create local application threads that 
are uninvolved in the RPC activity of the application.
</Para>
<Para>Figure 14-6 shows an address space where application threads are
executing concurrently. 
</Para>
<Para>The application threads in Figure 14-6 are performing
the following activities:
</Para>
<ItemizedList>
<ListItem>
<Para>The server application thread is listening for calls.
</Para>
</ListItem>
<ListItem>
<Para>A call thread is available to execute an incoming remote procedure call.
</Para>
</ListItem>
<ListItem>
<Para>One client application thread has separated from an RPC thread and another
is currently part of an RPC thread. 
</Para>
</ListItem>
<ListItem>
<Para>A local application thread is engaging in non-RPC activity.
</Para>
</ListItem>
</ItemizedList>
<?sml-need 5i>
<Figure>
<Title>A Multithreaded RPC Application Acting as Both Server and Client</Title>
<Graphic Entityref="DCEADG.RPCRAD.ent.6" Scalefit="1" Reprodep="350" Reprowid="350"></Graphic>
</Figure>
<!-- DEC-file name .P! pictures/rpc-threads-mixed.ps 7.25i-->
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.RPCRAD.div.6">
<Title>Security and RPC: Using Authenticated Remote Procedure Calls</Title>
<IndexTerm Id="DCEADG.RPCRAD.indx.18">
<Primary>authenticated RPC</Primary>
<Secondary>definition</Secondary>
</IndexTerm>
<Para>DCE RPC supports authenticated communications between clients and
servers.  Authenticated RPC works with the authentication and
authorization services provided by the DCE Security Service.
</Para>
<Para>On the application level, a server makes itself available for 
authenticated communications by registering its principal name
and the authentication service that it supports with the RPC 
runtime.  The server principal name is the name used to identify the 
server as a principal to the registry service provided by the 
security service.  In practice, this name is usually the same as the name that 
the server uses to register itself with the DCE Directory Service.
<IndexTerm Id="DCEADG.RPCRAD.indx.19">
<Primary>registry</Primary>
<Secondary>service</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.20">
<Primary>authenticated RPC</Primary>
<Secondary>and RPC runtime</Secondary>
</IndexTerm></Para>
<Para>A client must establish the authentication service, protection level,
and authorization service that it wishes to use in its communications
with a server.  The client identifies the intended server by means of
the principal name that the server has registered with the RPC
runtime.  Once the required authentication, protection, and
authorization parameters have been established for the server binding
handle, the client issues remote procedure calls to the server as it
normally does.
<IndexTerm Id="DCEADG.RPCRAD.indx.21">
<Primary>authenticated RPC</Primary>
<Secondary>authentication</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.22">
<Primary>authenticated RPC</Primary>
<Secondary>authorization</Secondary>
<SeeAlso>authorization</SeeAlso>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.23">
<Primary>authenticated RPC</Primary>
<Secondary>protection level</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.24">
<Primary>authentication</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.25">
<Primary>authorization</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.26">
<Primary>protection levels</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.27">
<Primary>authenticated RPC</Primary>
<Secondary>and DCE security</Secondary>
</IndexTerm></Para>
<Para>The security service, in conjunction with the 
RPC runtime, assumes responsibility for the following:
</Para>
<ItemizedList>
<ListItem>
<Para>Authenticating the client and server in accordance with the requested
authentication service
</Para>
</ListItem>
<ListItem>
<Para>Applying the requested level of protection to 
communications between the client and server
</Para>
</ListItem>
<ListItem>
<Para>Providing client authorization data to the server in a form 
determined by the requested authorization service
</Para>
</ListItem>
</ItemizedList>
<Note>
<Para>For a detailed discussion of authentication within the context of 
DCE security, refer to Chapter 24 of this guide.
</Para>
</Note>
<Sect2 Id="DCEADG.RPCRAD.div.7">
<Title>Authentication </Title>
<Para>When a client
establishes authenticated RPC, it must indicate the authentication
service that it wants to use.  The possible values are the following:
</Para>
<VariableList>
<VarListEntry role="linebreak">
<Term><Literal>rpc_c_authn_none</Literal></Term>
<ListItem>
<Para>No authentication
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>rpc_c_authn_dce_secret</Literal></Term>
<ListItem>
<Para>DCE shared-secret key authentication
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>rpc_c_authn_dce_public</Literal></Term>
<ListItem>
<Para>DCE public key authentication
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>rpc_c_authn_default</Literal></Term>
<ListItem>
<Para>DCE default authentication service
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<IndexTerm Id="DCEADG.RPCRAD.indx.28">
<Primary>authentication</Primary>
</IndexTerm>
<Para>The value <Literal>rpc_c_authn_none</Literal> is used to turn off authentication
already established for a binding handle.  The default authentication
is DCE shared-secret (also known as private key) authentication.
</Para>
<Para>Before a client and server can engage in authenticated RPC, they must
``agree'' on which authentication service to use.  Specifically, the
server must register the ``agreed on'' authentication service with the
RPC runtime, along with the server's principal name.  For its part,
the client must select the same service for the server's
binding handle.  The client indicates the appropriate server by
supplying the server's principal name.  If the client does not know
the server's name, it can use the 
<Function>rpc_mgmt_inq_server_princ_name()</Function> 
routine to determine the name.  
<IndexTerm Id="DCEADG.RPCRAD.indx.29">
<Primary>authenticated RPC</Primary>
<Secondary>server principal name</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.30">
<Primary>authentication</Primary>
<Secondary>server principal name</Secondary>
</IndexTerm></Para>
<Sect3 Id="DCEADG.RPCRAD.div.8">
<Title>Cross-Cell Authentication</Title>
<IndexTerm Id="DCEADG.RPCRAD.indx.31">
<Primary>authenticated RPC</Primary>
<Secondary>authentication</Secondary>
<Tertiary>cross-cell</Tertiary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.32">
<Primary>cross-cell authentication</Primary>
</IndexTerm>
<Para>A client can engage in authenticated RPC with a target server that is
in the client's cell or in a foreign cell.  In the case of cross-cell
authentication, DCE security performs the necessary additional steps
on behalf of the client.
</Para>
<Para>To establish authenticated RPC with a foreign
server, a client must supply the fully qualified principal
name of the server.  A fully qualified name includes the name of the
cell as well as the name of the principal and takes the following form:
</Para>
<InformalExample>
<Para><ProgramListing>/.../<Replaceable>cell_name</Replaceable>/<Replaceable>principal_name</Replaceable>
</ProgramListing></Para>
</InformalExample>
<Para><IndexTerm Id="DCEADG.RPCRAD.indx.33">
<Primary>authentication</Primary>
<Secondary>protection level</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.34">
<Primary>authenticated RPC</Primary>
<Secondary>protection level</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.35">
<Primary>protection levels</Primary>
</IndexTerm></Para>
</Sect3>
<Sect3 Id="DCEADG.RPCRAD.div.9">
<Title>Protection Levels</Title>
<Para>When a client establishes authenticated RPC, it can specify the level
of protection to be applied to its communications with the server.
The protection level determines how much of client/server
messages are encrypted.  As a rule, the more restrictive the
protection level, the greater the impact on performance.
Different levels are provided so that applications can control the
protection versus performance tradeoffs.
</Para>
<Para>Note that the protection level is entirely a client responsibility.
When a server registers its supported authentication service with the
RPC runtime, it does not specify any protection information for that
service.  However, the server can include the protection 
level used for a particular operation when deciding if the caller is 
authorized to perform the operation.
</Para>
<Para>Authenticated RPC supports the following protection levels:
</Para>
<VariableList>
<VarListEntry role="linebreak">
<Term><Literal>rpc_c_protect_level_default</Literal></Term>
<ListItem>
<?sml-break>
<Para>Uses the default protection level for the specified 
authentication service.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>rpc_c_protect_level_none</Literal></Term>
<ListItem>
<?sml-break>
<Para>There is no protection level.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>rpc_c_protect_level_connect</Literal></Term>
<ListItem>
<?sml-break>
<Para>Performs protection only when
the client establishes a relationship with the server.  This level
performs an encrypted handshake when the client first communicates
with the server.  Encryption or decryption is not performed on the data
sent between the client and server.  The fact that the handshake
succeeds indicates that the client is active on the network.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>rpc_c_protect_level_call</Literal></Term>
<ListItem>
<?sml-break>
<Para>Performs protection only at the beginning of each remote procedure 
call when the server receives the request.  This level 
attaches a verifier to each client call and server response.
</Para>
<Para>This level does not apply to remote procedure calls made over a 
connection-based protocol sequence; that is, 
<Literal>ncacn_ip_tcp</Literal>.  If this level is specified and the binding 
handle uses a connection-based protocol sequence, 
the routine uses the <Literal>rpc_c_protect_level_pkt</Literal> level instead.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>rpc_c_protect_level_pkt</Literal></Term>
<ListItem>
<?sml-break>
<Para>Ensures that all data received is from the expected client.  This level 
attaches a verifier to each message.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>rpc_c_protect_level_pkt_integrity</Literal></Term>
<ListItem>
<?sml-break>
<Para>Ensures and verifies that
none of the data transferred between client and server has been
modified.  This level computes a cryptographic checksum of each
message to verify that none of the data transferred between the client
and server has been modified in transit.
</Para>
<Para>This is the highest protection level that is guaranteed to be 
present in the RPC runtime.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>rpc_c_protect_level_pkt_privacy</Literal></Term>
<ListItem>
<?sml-break>
<Para>Performs protection as specified by all of the previous levels and 
also encrypts each remote procedure call argument and return values.  
This level encrypts all user data in each call.
</Para>
<Para>This is the highest protection level, but it may not be 
available in the RPC runtime.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para>If a client wants to use the default protection level but does not 
know what this level is, it can use the 
<Function>rpc_mgmt_inq_dflt_protect_level()</Function> routine to determine what the 
default level is.
</Para>
</Sect3>
</Sect2>
<Sect2 Id="DCEADG.RPCRAD.div.10">
<Title>Authorization </Title>
<IndexTerm Id="DCEADG.RPCRAD.indx.36">
<Primary>authenticated RPC</Primary>
<Secondary>access checking</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.37">
<Primary>authorization</Primary>
</IndexTerm>
<Para>Authorization is the process of checking a client's permissions to an
object that is controlled by the server.  Access checking is entirely
a server responsibility and involves matching the client's credentials
against the permissions associated with the object.  A
client's credentials consist of the principal ID and group memberships
contained in the client's network login context.
</Para>
<Para>Authenticated RPC supports the following options for making 
client authorization information available to servers for access 
checking:
<IndexTerm Id="DCEADG.RPCRAD.indx.38">
<Primary>authorization</Primary>
<Secondary>options</Secondary>
</IndexTerm></Para>
<VariableList>
<VarListEntry role="linebreak">
<Term><Literal>rpc_c_authz_none</Literal></Term>
<ListItem>
<?sml-break>
<Para>No authorization information is 
provided to the server, usually because the server does not 
perform access checking.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>rpc_c_authz_name</Literal></Term>
<ListItem>
<?sml-break>
<Para>Only the client principal name is 
provided to the server.  The server can then perform authorization 
based on the provided name.  This form of authorization is 
sometimes referred to as <FirstTerm>name-based</FirstTerm> authorization.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>rpc_c_authz_dce</Literal></Term>
<ListItem>
<?sml-break>
<Para>The client's credentials (DCE Privilege 
Attribute Certificate or PAC) is provided to the server 
with each remote procedure call that is made using the binding parameter.  
The server performs authorization by using the client credentials.  
Generally, access is checked against DCE ACLs.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para>When a client establishes authenticated RPC, it must indicate which
authorization option it wants to use.
</Para>
<Para>It is the server's responsibility to implement the type of authorization 
appropriate for the objects that it controls.  When the server calls 
<Function>rpc_binding_inq_auth_caller()</Function> to return information about an 
authenticated client, it gets back either the client's principal 
name or a pointer to the data structure that contains the client's
credentials.
The value that is returned depends on which type of authorization the 
client specified on its call to establish authenticated RPC with 
that server.
</Para>
<Para>Each server is responsible for implementing its own access checking by
means of ACL managers.  When a server receives a client
request for an object, the server invokes the ACL manager
appropriate for that type of object and passes the manager the
client's authorization data.  The manager compares the client
authorization data to the permissions associated with the object and
either refuses or permits the requested operation.  In the case of
certified (PAC-based) authorization, servers must implement access
checking by using the ACL facility provided by the DCE
Security Service.
</Para>
<Para>An ACL management API (<Literal>dce_acl*</Literal>) is also available.
</Para>
<Sect3 Id="DCEADG.RPCRAD.div.11">
<Title>Name-Based Authorization </Title>
<IndexTerm Id="DCEADG.RPCRAD.indx.39">
<Primary>authorization</Primary>
<Secondary>name-based</Secondary>
</IndexTerm>
<Para>Name-based authorization (<Literal>rpc_c_authz_name</Literal>) 
provides a server with the client's principal name.  The 
server call to <Function>rpc_binding_inq_auth_caller()</Function>
retrieves the name from the binding handle associated with the client
and returns it as a character string.
</Para>
<Para>It is not recommended that names be used for authorization.  To
perform access checking using client principal names, the names must
be stored in the access lists associated with the protected objects.
Each time a name is changed, the change must be propagated
through all the access lists in which the name is defined.
</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCRAD.div.12">
<Title>DCE Authorization </Title>
<IndexTerm Id="DCEADG.RPCRAD.indx.40">
<Primary>authorization</Primary>
<Secondary>DCE</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.41">
<Primary>authorization</Primary>
<Secondary>with PACs</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.42">
<Primary>authorization</Primary>
<Secondary>certified</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.43">
<Primary>PAC</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.44">
<Primary>privilege attribute certificate</Primary>
</IndexTerm>
<Para>DCE authorization (<Literal>rpc_c_authz_dce</Literal>) provides 
a server with the client's credentials.
</Para>
<Para>Credentials offer a trusted mechanism for conveying client authorization
data to authenticated servers.  The security service generates a 
client's credentials in a tamper-proof manner.  When a server receives a 
client credentials, it knows that the credentials has been certified by 
DCE security.
<IndexTerm Id="DCEADG.RPCRAD.indx.45">
<Primary>authenticated RPC</Primary>
<Secondary>and DCE security</Secondary>
</IndexTerm></Para>
<Para>Credentials are designed to be used with the DCE ACL
facility.  The ACL facility provides an editor and a set of API
routines that support the implementation of access control lists and
the managers to control them.
<IndexTerm Id="DCEADG.RPCRAD.indx.46">
<Primary>ACL</Primary>
</IndexTerm></Para>
</Sect3>
</Sect2>
<Sect2 Id="DCEADG.RPCRAD.div.13" RevisionFlag="Changed">
<Title>Authenticated RPC Routines</Title>
<IndexTerm Id="DCEADG.RPCRAD.indx.47">
<Primary>authenticated RPC</Primary>
<Secondary>routines</Secondary>
</IndexTerm>
<Para>Authenticated RPC is implemented as a set of related RPC routines.
Some of the routines are for use by clients, some are for use by
servers and their managers, and some are for use by both clients and
servers.  The authenticated RPC routines are as follows:
</Para>
<VariableList>
<VarListEntry role="linebreak">
<Term><Function>rpc_binding_set_auth_info()</Function></Term>
<ListItem>
<?sml-need 6>
<?sml-break>
<Para>A client calls this routine to
establish an authentication service, protection level, and
authorization service for a server binding handle.  The client
identifies the server by supplying the server's principal name.  The
RPC runtime, in conjunction with the security service, applies the
authentication service and protection level to all subsequent remote
procedure calls made using the binding handle.
<!-- .LI-->
<!-- \*Lrpc_ss_register_auth_info(\|)\*O: A client calls this routine to-->
<!-- register an authentication service, protection level, and-->
<!-- authorization service for an interface specification.  After a client-->
<!-- calls this routine, the RPC runtime automatically applies the-->
<!-- authentication and authorization information to all remote procedure-->
<!-- calls that the client makes using implicit binding handles.  An-->
<!-- example is when the client uses an implicit handle with the IDL-->
<!-- \*Lauto_handle\*O attribute or a customized handle with the-->
<!-- \*Lhandle\*O attribute.-->
<!-- .iX "authenticated RPC" "rpc_ss_register_auth_info(\|)"  -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_binding_inq_auth_info()</Function></Term>
<ListItem>
<?sml-break>
<Para>A client calls this routine to 
return the authentication service, protection level, and 
authorization service that are in effect for a specified server 
binding handle.  This routine also returns the principal 
name of the server associated with the binding handle.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_mgmt_inq_dflt_protect_level()</Function></Term>
<ListItem>
<?sml-break>
<Para>A client or a server 
calls this routine to learn the default protection level that is 
in force for a given authentication service.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_mgmt_inq_server_princ_name()</Function></Term>
<ListItem>
<?sml-break>
<Para>A client, a server, or a
server manager can call this routine to return the principal name that
a server has registered with the RPC runtime via
the <Function>rpc_server_register_auth_info()</Function> routine.  A client can identify the
desired server by supplying a server binding handle and the
authentication service associated with the registered principal name.
<IndexTerm Id="DCEADG.RPCRAD.indx.48">
<Primary>authenticated RPC</Primary>
<Secondary>server principal name</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.49">
<Primary>authentication</Primary>
<Secondary>server principal name</Secondary>
</IndexTerm></Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_server_register_auth_info()</Function></Term>
<ListItem>
<?sml-break>
<Para>A server calls this routine
to register an authentication service that it wants to support
and the server principal name to be associated with the registered
service.  The server can also optionally supply the address of a key retrieval
routine to be called by the security service as part of the client
authentication process.  The routine is a user-supplied function whose
purpose is to provide the server's key to the DCE security
runtime.
</Para>
<Para>Note that the server registers only an authentication 
service.  It does not establish a protection level or an authorization 
service.  These are the responsibilities of the client. 
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_binding_inq_auth_caller()</Function></Term>
<ListItem>
<?sml-break>
<Para>A server calls this 
routine to return the authentication service, protection level, and 
authorization service that is associated with the binding handle of 
an authenticated client.  This call also returns the server 
principal name specified by the client on its call to 
<Function>rpc_binding_set_auth_info()</Function>.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_mgmt_set_authorization_fn()</Function></Term>
<ListItem>
<?sml-break>
<Para>A server calls this routine 
to establish a user-supplied authorization function to 
validate remote client calls to the 
server's management routines.  For example, the user function can 
call <Function>rpc_binding_inq_auth_caller()</Function> to return authentication and 
authorization information about the calling client.  The RPC runtime calls 
the user-supplied function whenever it receives a client request to 
execute one of the following server management routines: 
</Para>
<ItemizedList>
<ListItem>
<Para><Function>rpc_mgmt_inq_if_ids()</Function> 
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_mgmt_inq_server_princ_name()</Function> 
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_mgmt_inq_stats()</Function> 
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_mgmt_is_server_listening()</Function> 
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_mgmt_stop_server_listening()</Function> 
</Para>
</ListItem>
</ItemizedList>
</ListItem>
</VarListEntry>
</VariableList>
<Para>When an unauthenticated client calls a server that has
specified authentication, the RPC runtime will not
perform any authentication, and <Replaceable>the call will reach the application
manager code</Replaceable>.  It is up to the manager to decide how to deal with
the unauthenticated call.
</Para>
<Para>Typically, servers and clients establish authentication as follows:
</Para>
<ItemizedList>
<ListItem>
<Para>The server specifies an authentication service for a principal
identity under which it runs by calling
<Function>rpc_server_register_auth_info()</Function>.  The authentication service
is specified by the <Symbol Role="Variable">authn_svc</Symbol> parameter of this call.
Currently, servers may specify either DCE secret key authentication
(by supplying either <Literal>rpc_c_authn_dce_secret</Literal> or
<Literal>rpc_c_authn_default</Literal>) or no authentication (by supplying
<Literal>rpc_c_authn_none</Literal>).  The specified authentication service will be
used <Replaceable>if it is also requested by the client</Replaceable>.
</Para>
</ListItem>
<ListItem>
<?sml-need 4>
<Para>The client sets authentication for a binding handle by calling
<Function>rpc_binding_set_auth_info()</Function>.  The choices are also currently
either DCE secret key or no authentication.  Client calls made on the
binding handle attempt to use the specified authentication service.
</Para>
</ListItem>
<ListItem>
<Para>The server manager code calls <Function>rpc_binding_inq_auth_caller()</Function> to
extract any authorization information from the client binding for the call.
</Para>
</ListItem>
</ItemizedList>
<!---->
<!---->
<?og-ChangeStart enh,13625,R1.2.2,added single-threaded client">
</Sect2>
<Sect2 Id="DCEADG.RPCRAD.div.14">
<Title RevisionFlag="Changed">Using RPC Within a Single Thread</Title>
<!---->
<!---->
<Para RevisionFlag="Changed">The default behavior
for an application client is to be single-threaded. This means that
only one thread, the main thread, exists in the client process. All
application and RPC runtime execution takes place within this single thread.
This behavior applies only to clients that use the User Datagram
Protocol (UDP). If another protocol sequence is used for RPC transport,
the RPC runtime will spawn several threads and revert to
multithreaded behavior.
</Para>
<Para RevisionFlag="Changed">Single-threaded behavior, compared to multithreaded client behavior,
provides several benefits to application developers:
</Para>
<ItemizedList>
<ListItem>
<Para RevisionFlag="Changed">Debugging is easier. Using advanced thread-aware debuggers and following code 
execution through multiple thread context switches are unnecessary. 
The same debugging techniques and tools used to debug standard applications 
can be used to debug an RPC client. 
</Para>
</ListItem>
<ListItem>
<Para RevisionFlag="Changed">Usage of system resources is lower.
The DCE Threads runtime is not initialized in single-threaded mode. This means
startup time will be faster, less memory will be used, and
performance will improve because context switching does not take
place.
</Para>
</ListItem>
<ListItem>
<Para RevisionFlag="Changed">Linking libraries that are not thread-safe into DCE applications is
less dangerous. Some third-party libraries depend on default
behavior from certain operating system functions. However, in a multithreaded
process
this behavior is defined differently. Examples of this
include signal
handling, I/O, and <Literal>fork</Literal>, and <Literal>exec</Literal> functions. When an 
application client is single-threaded, the default behavior for these 
functions is guaranteed, and without risk when using libraries that are not
thread-safe.
</Para>
</ListItem>
</ItemizedList>
<Para RevisionFlag="Changed">If any application-level threads are created in the RPC client,
the single-threaded process immediately reverts to multithreaded behavior. 
This
means that both the RPC runtime and DCE Threads runtime will be
initialized and create several runtime-level threads, and the benefits
described for a single-threaded client will no longer apply. Once the
client becomes multithreaded, it remains so even if all of the
user-level threads have terminated.
</Para>
<Para RevisionFlag="Changed">Existing applications can take advantage of single-threaded
mode without requiring changes to the code.
As long as the client is using the UDP protocol
sequence and has not performed a <Literal>pthread_create</Literal> call, single-threaded 
behavior automatically remains; applications can continue to make
pthread API calls and remain in single-threaded mode. If, for
example, the application creates mutex variables, and even locks or
unlocks these variables, these calls will behave correctly and not cause the
process to become multithreaded. However, after the first
<Literal>pthread_create</Literal> call
takes place in the client application, it becomes multithreaded
and all previously initialized pthreads primitives will function
as expected in a multithreaded environment.
</Para>
<Para RevisionFlag="Changed">To implement single-threaded behavior, the DCE Threads library
performs its
initialization in two phases:
</Para>
<ItemizedList>
<ListItem>
<Para RevisionFlag="Changed">Phase 1 occurs when the first pthread
API call is made. This initializes mutexes, condition variables,
and attributes. 
</Para>
</ListItem>
<ListItem>
<Para RevisionFlag="Changed">Phase 2 occurs when the first <Literal>pthread_create</Literal> call
is made. This initializes the remaining DCE Threads
functionality,
including thread management, context switching, the creation of a
null background thread, and all of the multithreaded operating
system
behavior as described in the chapter on multithreaded programming.
</Para>
</ListItem>
</ItemizedList>
<?og-ChangeEnd enh,13625,R1.2.2,added single-threaded client">
<!---->
<!---->
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.RPCRAD.div.15">
<Title>Directory Services and RPC: Using the Namespace</Title>
<!---->
<!---->
<Para>This section discusses how the DCE RPC NSI
configures directory service entries and how
RPC applications can use those entries.
The following topics are included:
</Para>
<ItemizedList>
<ListItem>
<Para>Directory service entries defined by NSI
</Para>
<Para>Describes the kinds of directory service entries NSI defines.
</Para>
</ListItem>
<ListItem>
<Para>Searching the namespace
</Para>
<Para>Describes how the namespace is searched when a client requests binding information.
</Para>
</ListItem>
<ListItem>
<Para>Strategies for using directory service entries
</Para>
<Para>Outlines strategies for using each kind of entry.
</Para>
</ListItem>
<ListItem>
<Para>The service model
</Para>
<Para>Describes the service model for defining RPC servers
and introduces NSI usage models intended to guide application
developers in assessing how to best use NSI for a given application.
</Para>
</ListItem>
<ListItem>
<Para>The resource model
</Para>
<Para>Describes the resource model for defining RPC servers.
</Para>
</ListItem>
</ItemizedList>
<Sect2 Id="DCEADG.RPCRAD.div.16">
<Title>NSI Directory Service Entries</Title>
<Para>To store information about RPC servers, interfaces, and objects,
NSI defines the following directory service entries in the namespace:
server entries, groups, and profiles.
These directory service entries are CDS objects.
</Para>
<ItemizedList>
<ListItem>
<Para>A 
<!-- .gL "server entry"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.50">
<Primary>NSI</Primary>
<Secondary>directory service entries</Secondary>
<Tertiary>server entry</Tertiary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.51">
<Primary>server</Primary>
<Secondary>entry</Secondary>
</IndexTerm>server entry is a directory service
entry that stores binding information and object 
UUIDs for an RPC server. 
</Para>
</ListItem>
<ListItem>
<?sml-need 3>
<Para>A
<!-- .gL "group" -->
<IndexTerm Id="DCEADG.RPCRAD.indx.52">
<Primary>NSI</Primary>
<Secondary>directory service entries</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.53">
<Primary>group</Primary>
<Secondary>RPC</Secondary>
</IndexTerm>group is a directory service entry that corresponds to one or more RPC servers
that offer one or more RPC interfaces, type of RPC object, or both in common.
</Para>
</ListItem>
<ListItem>
<Para>A 
<!-- .gL "profile"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.54">
<Primary>NSI</Primary>
<Secondary>directory service entries</Secondary>
<Tertiary>profile</Tertiary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.55">
<Primary>profile</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.56">
<Primary>RPC</Primary>
<Secondary>profile</Secondary>
<Tertiary>definition of</Tertiary>
</IndexTerm>profile is a directory service entry that defines search paths 
in a namespace for a server that offers a particular RPC interface
and object. 
</Para>
</ListItem>
</ItemizedList>
<!-- .ML (bulleted) list-->
<Para>The use of server entries, groups, and profiles determines how clients view
servers.  A server describes itself to its clients by exporting 
binding information associated with
interfaces and objects to one or more server entries. 
A group corresponds to servers that offer a given
interface, service, or object.  Profiles enable clients to access 
alternative directory 
service entries when searching for an interface or object. 
Used together,
groups and profiles offer sophisticated ways for RPC applications to
maintain and use directory service data. 
</Para>
<Sect3 Id="DCEADG.RPCRAD.div.17">
<Title>NSI Attributes</Title>
<Para>Usually, the distinct server entries, groups, and profiles concepts
are adequate
for using NSI.  However, the way NSI stores RPC information
allows you to combine server entries, groups, and profiles
into a single directory service entry.
To store information about
RPC applications in a directory service entry, the RPC 
directory service interface
defines several RPC-specific directory service attributes, or 
NSI attributes.
<!-- .gL "name service attribute"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.57">
<Primary>NSI</Primary>
<Secondary>attributes</Secondary>
<Tertiary>RPC</Tertiary>
</IndexTerm>NSI attributes contain information about RPC applications 
in a directory service entry.  The NSI attributes are as follows:
</Para>
<ItemizedList>
<ListItem>
<Para>NSI binding attribute
</Para>
<Para>The 
<!-- .gL "NSI binding attribute"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.58">
<Primary>binding attribute</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.59">
<Primary>NSI</Primary>
<Secondary>binding attribute</Secondary>
</IndexTerm>binding attribute stores binding information and
interface identifiers (interface UUID and version numbers) exported to the
server entry. 
This attribute identifies a directory service entry as a server entry.
</Para>
</ListItem>
<ListItem>
<Para>NSI object attribute
</Para>
<Para>The object attribute stores a list of one or more object UUIDs.
<IndexTerm Id="DCEADG.RPCRAD.indx.60">
<Primary>object</Primary>
<Secondary>attribute</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.61">
<Primary>NSI</Primary>
<Secondary>object attribute</Secondary>
</IndexTerm>
<!-- .gL "object attribute"-->
Whenever a server exports any object UUIDs to a server entry, the server entry
contains an object attribute as well as a binding attribute.  When a client
imports from that entry, the import operation returns an object UUID from the
list stored in the object attribute. 
</Para>
</ListItem>
<ListItem>
<?sml-need 5>
<Para>NSI group attribute
</Para>
<Para>The
<!-- .gL "NSI group attribute"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.62">
<Primary>group</Primary>
<Secondary>RPC attribute</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.63">
<Primary>NSI</Primary>
<Secondary>group attribute</Secondary>
</IndexTerm>group attribute stores the entry names of the 
members of a single group.
This attribute identifies a directory service entry as an RPC group.
</Para>
</ListItem>
<ListItem>
<Para>NSI profile attribute
</Para>
<Para>The 
<!-- .gL "NSI profile attribute"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.64">
<Primary>profile</Primary>
<Secondary>attribute</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.65">
<Primary>NSI</Primary>
<Secondary>profile attribute</Secondary>
</IndexTerm>profile attribute
stores a set of profile elements.
This attribute identifies a directory service entry as an RPC profile.
</Para>
</ListItem>
</ItemizedList>
<!-- .ML (bulleted) list-->
<Para>Figure 14-7 represents the correspondence between NSI attributes
and the different directory service entries:  server entries, groups, and
profiles. 
</Para>
<Figure>
<Title>NSI Attributes</Title>
<Graphic Entityref="DCEADG.RPCRAD.ent.7" Scalefit="1" Reprodep="250" Reprowid="250"></Graphic>
</Figure>
<!-- DEC-file name .P! pictures/rpc-nsi-attributes.ps 4.5i-->
<?sml-space .5>
<Para>Any directory service entry can contain any combination of the four NSI
attributes.  However, to facilitate administrating directory service entries, 
avoid creating binding, group, and profile attributes in the same entry.
Instead, use distinct directory service entries for server entries, groups, and
profiles.  The object attribute, in contrast, is designed as an adjunct to
another NSI attribute, especially the binding attribute. 
</Para>
<Para><?sml-need 11>When implementing
the resource model or when used to distinguish server instances, a server entry
contains an object attribute as well as a binding attribute.  On finding a
server entry whose binding attribute contains compatible binding information,
an NSI search operation also looks in the entry for an object attribute.  For
groups whose membership is selected according to a shared object or set of
objects, it may be useful to export those objects to the group.  In this case,
the directory service entry 
of the group contains both group and object attributes.
For reading the object UUIDs in the NSI object attribute in 
any directory service entry, NSI provides a set of object inquiry operations, 
called using the 
<IndexTerm Id="DCEADG.RPCRAD.indx.66">
<Primary>RPC</Primary>
<Secondary>runtime</Secondary>
<Tertiary>routines</Tertiary>
</IndexTerm><Literal>rpc_ns_entry_object_inq_</Literal>{<Literal>begin</Literal>,<Literal>next</Literal>,<Literal>done</Literal>}<Literal>()</Literal>
routines. 
</Para>
<Para>Using separate entries facilitates administration of the namespace;
for example, by enabling entry names to specifically
describe their contents.
Keeping server entries, profiles, and groups separate allows
clear references to each of them.
</Para>
<Note>
<Para>In addition to any NSI attributes, a directory 
service entry contains other kinds 
of directory service attributes.  Every 
entry in a namespace contains standard
attributes created by the directory service.  NSI operations rely on some
standard attributes to identify and use an entry. 
</Para>
</Note>
</Sect3>
<Sect3 Id="DCEADG.RPCRAD.div.18">
<Title>Structure of Entry Names</Title>
<IndexTerm Id="DCEADG.RPCRAD.indx.67">
<Primary>directory service</Primary>
<Secondary>entries</Secondary>
</IndexTerm>
<Para>Each entry in a namespace is identified by a unique 
global name comprising a cell name and a cell-relative name. 
</Para>
<Para><IndexTerm Id="DCEADG.RPCRAD.indx.68">
<Primary>cell</Primary>
<Secondary>RPC</Secondary>
</IndexTerm>A  cell is a group of users, systems, and resources that share common DCE
services.  A cell configuration includes at least one cell directory server
and one security server.  A cell's size can range from one
system to thousands of systems. 
A host is assigned to its cell by a DCE configuration file.
For information on cells, see the 
&DCEAg;.
<!--\*VOSF DCE Administration Guide\*O. -->
</Para>
<Para>The following is an example of a global name:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>/.../C=US/O=uw/OU=MadCity/LandS/anthro/Stats_host_2
</UserInput></ProgramListing></Para>
</InformalExample>
<Para><?sml-need 12>The parts of a global name are as follows:
</Para>
<ItemizedList>
<ListItem>
<IndexTerm Id="DCEADG.RPCRAD.indx.69">
<Primary>cell</Primary>
<Secondary>name</Secondary>
<Tertiary>RPC</Tertiary>
</IndexTerm>
<Para>Cell name (using X.500 name syntax):
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>/.../C=US/O=uw/OU=MadCity
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The symbol <Literal>/...</Literal> begins a cell name.
The letters before the <Literal>=</Literal> (equal signs) are abbreviations 
for Country (<Literal>C</Literal>),
Organization (<Literal>O</Literal>), and Organization Unit (<Literal>OU</Literal>). 
For entries in the local cell, the cell name can be represented by a 
<Filename>/.:</Filename> prefix, in place of the actual cell name; for example:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>/.:/LandS/anthro/Stats_host_2
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Literal>/</Literal> (slash) to the right of the cell name represents the root of
<IndexTerm Id="DCEADG.RPCRAD.indx.70">
<Primary>cell</Primary>
<Secondary>root</Secondary>
<Tertiary>RPC</Tertiary>
</IndexTerm>the cell directory (the cell root).
</Para>
<Para>For NSI operations on entries in the local cell, you can omit the cell name.
</Para>
</ListItem>
<ListItem>
<!-- .gL "cell-relative name"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.71">
<Primary>cell-relative name</Primary>
<Secondary>RPC</Secondary>
</IndexTerm>
<Para>Cell-relative name (using DCE name syntax):
</Para>
<Para>Each directory service entry requires a
cell-relative name, which contains a directory pathname and a leaf name.
</Para>
<ItemizedList>
<ListItem>
<Para>A directory pathname follows the cell name and
<!-- .gL "directory pathname"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.72">
<Primary>directory pathname</Primary>
<Secondary>RPC</Secondary>
</IndexTerm>indicates the hierarchical relationship of the entry to the cell root.
</Para>
<Para>The directory pathname contains the names of any
subdirectories in the path; each subdirectory name begins with a 
<Literal>/</Literal> (slash), as
follows: 
<?sml-space>/<Symbol Role="Variable">sub-dir-a-name</Symbol>/<Symbol Role="Variable">sub-dir-b-name</Symbol>/<Symbol Role="Variable">sub-dir-c-name</Symbol>
</Para>
<Para>Directory pathnames are created by directory service administrators. 
If an appropriate directory pathname does not exist, 
ask your directory service administrator to extend an
existing pathname or create a new pathname. 
In a directory pathname, the name of a
subdirectory should reflect its relationship to its 
<IndexTerm Id="DCEADG.RPCRAD.indx.73">
<Primary>parent directory</Primary>
</IndexTerm>parent directory (the directory that contains the subdirectory).
</Para>
</ListItem>
<ListItem>
<?sml-need 4>
<Para>A leaf name identifies 
<!-- .gL "leaf name"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.74">
<Primary>leaf name, RPC</Primary>
</IndexTerm>the specific entry.
</Para>
<Para>The leaf name constitutes the right-hand part of a global name,
beginning with the rightmost <Literal>/</Literal> (slash).
</Para>
</ListItem>
</ItemizedList>
<!-- .ML (numbered) list-->
<Para>For example, <Filename>/.:/LandS/anthro/Cal_host_4</Filename>, where <Filename>/.:/</Filename> represents
the cell name, <Filename>/LandS/anthro</Filename> is the directory pathname,
and <Filename>/Cal_host_4</Filename> is the leaf name. 
If the directory service entry is located at the cell root, 
the leaf name directly follows the cell name;
for example, <Filename>/.:/cell-profile</Filename>.
<!-- .ML (numbered) list-->
</Para>
<Note>
<?sml-need 2>
<Para>When NSI is used with CDS, the cell-relative name 
is a CDS name.
</Para>
</Note>
</ListItem>
</ItemizedList>
<Para>Figure 14-8 shows the parts of a global name.
</Para>
<?sml-need 1.6i>
<Figure>
<Title>Parts of a Global Name</Title>
<Graphic Entityref="DCEADG.RPCRAD.ent.8" Scalefit="1" Reprodep="300" Reprowid="300"></Graphic>
</Figure>
<!-- DEC-file name .P! pictures/rpc-nsi-global-name.ps 1.5i-->
</Sect3>
<Sect3 Id="DCEADG.RPCRAD.div.19">
<Title>Server Entries</Title>
<IndexTerm Id="DCEADG.RPCRAD.indx.75">
<Primary>directory service</Primary>
<Secondary>entries</Secondary>
<Tertiary>RPC server entries</Tertiary>
</IndexTerm>
<Para>NSI enables any RPC server with the necessary directory service permissions to
create and maintain its own server entries in the namespace.  A server
can use as many server entries as it needs to advertise combinations of its RPC
interfaces and objects. 
</Para>
<Para>Each server entry must correspond to a single server (or a group of
interchangeable server instances) on a given system. 
<IndexTerm Id="DCEADG.RPCRAD.indx.76">
<Primary>server</Primary>
<Secondary>instance</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.77">
<Primary>instance</Primary>
<Secondary>of an RPC server</Secondary>
<Tertiary>interchangeable instances</Tertiary>
</IndexTerm>Interchangeable server instances are instances of the same server running
on the same system that offer the same RPC objects (if any). 
Only interchangeable server instances can share a server entry.
</Para>
<Para>Each server entry must contain binding information.  Every combination of
protocol sequence and network addressing information represents a potential
binding.  The network addressing information can contain a network address, but
lacks an endpoint, making the address partially bound.  
</Para>
<Para><?sml-need 5>A server entry can also
contain a list of object UUIDs exported by the server.  Each of the object UUIDs
corresponds to an object offered by the server.  In a given server entry, each
interface identifier is associated with every object UUID, but with only the
binding information exported with the interface.
</Para>
<Para>Figure 14-9 represents a server entry.  This server entry was
created by two calls to the <Function>rpc_ns_binding_export()</Function> routine.  
The first call created the first column of the
top half of the figure.  The routine's <Symbol Role="Variable">binding_vec</Symbol> parameter had
three elements, each of which is paired with the routine's <Symbol Role="Variable">if_handle</Symbol>
parameter.  The vertical ellipsis points under the last box indicate that
more elements in the routine's <Symbol Role="Variable">binding_vec</Symbol> parameter would have resulted
in more interface UUID/binding information pairs in the first column.
</Para>
<Para>Similarly, the second call to the <Function>rpc_ns_binding_export()</Function> routine created
the second column of the top half of the figure.  The routine's
<Symbol Role="Variable">binding_vec</Symbol> parameter had two elements, each of which is paired with
the routine's <Symbol Role="Variable">if_handle</Symbol> parameter.  For example, the first element
could have contained binding information with the <Replaceable>ncacn_ip_tcp</Replaceable>
protocol sequence, and the second element could have contained binding
information with the <Literal>ncadg_ip_udp</Literal> protocol sequence.  As in
the first column, more elements in the routine's <Symbol Role="Variable">binding_vec</Symbol>
parameter would have resulted in more interface UUID/binding
information pairs.
</Para>
<Para>Third and subsequent calls to the <Function>rpc_ns_binding_export()</Function> routine would
create more columns; the two pairs of horizontal ellipsis points indicate
this expansion.
</Para>
<Para>Finally, note that the <Function>rpc_ns_binding_export()</Function> routine optionally takes
a vector of object UUIDs.  The four object UUIDs in the bottom half of
the figure came from the two calls to the routine, or from another call
to the routine with no interface UUID/version and with no binding
information, but with object UUIDs.  The object UUIDs
are associated with no particular binding.  Instead, they are associated with
all the bindings.  Third and subsequent calls to the routine could
create more object UUIDs; the vertical ellipsis points indicate this
expansion.
</Para>
<Note>
<Para>To distinguish among RPC objects when using the CDS ACL editor,
export the RPC objects to separate directory service entries. 
</Para>
</Note>
<?sml-need 4.5i>
<Figure>
<Title>Possible Information in a Server Entry</Title>
<Graphic Entityref="DCEADG.RPCRAD.ent.9" Scalefit="1" Reprodep="350" Reprowid="350"></Graphic>
</Figure>
<!-- Old DEC-file name .P! pictures/rpc-nsi-server-entry.ps 3.25i-->
</Sect3>
<Sect3 Id="DCEADG.RPCRAD.div.20">
<Title>Groups</Title>
<Para>Administrators or users of RPC applications can organize searches of a namespace
for binding information by having clients use an RPC group
as the starting point for NSI search operations.
A group provides NSI 
<IndexTerm Id="DCEADG.RPCRAD.indx.78">
<Primary>NSI</Primary>
<Secondary>search operations</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.79">
<Primary>search</Primary>
<Secondary>operations</Secondary>
</IndexTerm>search operations (<Literal>import_next</Literal> or <Literal>lookup_next</Literal> operations) 
with access to the server entries
of different servers that offer a common RPC interface or object.
A group contains names of one or more server entries,
other groups, or both.  Since a group can contain group names, groups
can be nested.  Each server entry or group named in a group is a 
<!-- .gL "group member"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.80">
<Primary>group</Primary>
<Secondary>RPC member</Secondary>
</IndexTerm>member of the group.  A group's members must offer one or more RPC
interfaces, the type of RPC object, or both in common. 
</Para>
<Para><?sml-need 2>Figure 14-10 shows an example of the kinds of members 
a group can contain and how those members correspond to database entries.
</Para>
<?sml-need 4.7i>
<Figure>
<Title>Possible Mappings of a Group</Title>
<Graphic Entityref="DCEADG.RPCRAD.ent.10" Scalefit="1" Reprodep="300" Reprowid="300"></Graphic>
</Figure>
<!-- DEC-file name .P! pictures/rpc-nsi-group-mappings.ps 5.5i-->
<?sml-space .5>
<Para>The members of Group A are Server Entry 1, Server Entry 2, and 
Group B.  The members of the nested group, Group B, are
Server Entry 3 and Server Entry 4.
An additional server entry that advertises the common interface or object,
Server Entry 5, is omitted from either group.
</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCRAD.div.21">
<Title>Profiles</Title>
<Para>Administrators or users of RPC applications can organize searches of a 
namespace for binding information by having clients use an RPC profile
as the starting point for NSI search operations.
<!-- .gL "profile"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.81">
<Primary>profile</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.82">
<Primary>RPC</Primary>
<Secondary>profile</Secondary>
</IndexTerm>A profile is an entry in a namespace that contains a
collection of 
<!-- .gL "profile element"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.83">
<Primary>profile</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.84">
<Primary>RPC</Primary>
<Secondary>profile element</Secondary>
</IndexTerm>profile elements.  A profile element
is a database record that corresponds to a single RPC interface and
that refers to a server entry, group, or profile. 
Each profile element contains the following information:
</Para>
<ItemizedList>
<ListItem>
<?sml-need 4>
<Para>Interface identifier
</Para>
<Para>This field is the key to the profile.
The 
<!-- .gL "interface identifier"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.85">
<Primary>interface</Primary>
<Secondary>RPC identifier</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.86">
<Primary>RPC</Primary>
<Secondary>interface</Secondary>
<Tertiary>identifier</Tertiary>
</IndexTerm>interface identifier
consists of the interface UUID and the interface version numbers.
</Para>
</ListItem>
<ListItem>
<Para>Member name
</Para>
<Para>The entry name of one of the following kinds of directory service entries:
</Para>
<ItemizedList>
<ListItem>
<Para>A server entry for a server offering the requested RPC interface 
</Para>
</ListItem>
<ListItem>
<Para>A group corresponding to the requested RPC interface
</Para>
</ListItem>
<ListItem>
<Para>A profile 
</Para>
</ListItem>
</ItemizedList>
</ListItem>
<ListItem>
<Para>Priority value
</Para>
<Para>The priority value 
(0 is the highest priority; 7 is the lowest priority)
is designated by the creator of a profile element to
help determine the order for using the element 
NSI search operations to select among like-priority elements at random.
<!-- The default is 0.-->
</Para>
</ListItem>
<ListItem>
<Para>Annotation string
</Para>
<Para>The annotation string enables you to identify the
purpose of the profile element.  The annotation can be any textual information;
for example, an interface name associated with the interface identifier or a
description of a service or resource associated with a group. 
</Para>
<Para>Unlike the interface identifier field, the annotation string is not a
search key.
</Para>
</ListItem>
</ItemizedList>
<Para>Optionally, a profile can contain one default profile element.
A 
<!-- .gL "default profile element"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.87">
<Primary>default</Primary>
<Secondary>profile element</Secondary>
</IndexTerm>default profile element is the element that an NSI search operation uses
when a search using the other elements of a profile finds no compatible
binding information; for example, when the current profile lacks any element
corresponding to the requested interface.  A default profile element contains
the nil interface identifier, a priority of 0, the entry name of a default
profile, and an optional annotation. 
</Para>
<Para>A 
<!-- .gL "default profile"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.88">
<Primary>default</Primary>
<Secondary>profile</Secondary>
</IndexTerm>default profile
is a backup profile, referred to by a default profile element in another
profile.  A profile designated as a default profile should be a 
comprehensive profile maintained by an administrator for a major set of users,
such as the members of an organization or the owners of computer accounts on a
local area network (LAN). 
</Para>
<Para><?sml-need 3>A default profile must not create circular dependencies between
profiles; for example, when a public profile refers to an application's
profile, the application's profile must not specify that public profile as a
default profile. 
</Para>
<Para>Figure 14-11 shows an example of the kinds of elements a profile can
contain and how those elements correspond to database entries. 
</Para>
<?sml-need 7i>
<Figure>
<Title>Possible Mappings of a Profile</Title>
<Graphic Entityref="DCEADG.RPCRAD.ent.11" Scalefit="1" Reprodep="350" Reprowid="350"></Graphic>
</Figure>
<!-- DEC-file name .P! pictures/rpc-nsi-profile-mappings.ps 7.0i-->
<?sml-space .5>
<Para><?sml-need 4>NSI search operations use a profile to construct an
NSI search path.  
<IndexTerm Id="DCEADG.RPCRAD.indx.89">
<Primary>path</Primary>
<Secondary>for NSI searches</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.90">
<Primary>NSI</Primary>
<Secondary>search path</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.91">
<Primary>RPC</Primary>
<Secondary>search path</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.92">
<Primary>search</Primary>
<Secondary>path</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.93">
<Primary>profile</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.94">
<Primary>RPC</Primary>
<Secondary>profile</Secondary>
<Tertiary>explanation of</Tertiary>
</IndexTerm>When an NSI search operation reads a profile, the operation dynamically
constructs its NSI search path from the set of elements that correspond to a
common RPC interface.
</Para>
<Para>A profile element is used only once per NSI search path.  The construction of
NSI search paths depends partly on the priority rankings of the elements.  A
search operation uses higher-priority elements before lower-priority elements. 
Elements of equal priority are used in random order, permitting some variation
in the NSI search paths between searches for a given interface.  If nondefault
profile elements do not satisfy a search, the search path extends to the
default profile element, if any.
</Para>
<Para>Profiles meet the needs of particular individuals, systems, LANs, sites,
organizations, and so forth, with minimal configuration management. 
The administrator of a profile can set up NSI search paths that reflect the
preferences of the profile's user or users.  The profile administrator can set
up profile elements that refer (directly or indirectly) to only a subset of the
server entries that offer a given RPC interface.  Also, the administrator can
assign different search priorities to the elements for an interface. 
</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCRAD.div.22">
<Title>Guidelines for Constructing Names of Directory Service Entries</Title>
<IndexTerm Id="DCEADG.RPCRAD.indx.95">
<Primary>NSI</Primary>
<Secondary>directory service names</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.96">
<Primary>names</Primary>
<Secondary>directory service entry</Secondary>
</IndexTerm>
<Para>A global name includes both a cell name and a cell-relative name
composed of a directory pathname and a leaf name.  The cell name is assigned to
a cell root at its creation.  When you specify only a cell-relative name to an
NSI operation, NSI automatically expands the name into a global name by
inserting the local cell name.  When returning the name of a
directory service entry, a group member, or a member in a profile element, NSI
operations return global names. 
</Para>
<Para>The directory pathname and leaf name uniquely identify a directory service
entry.  The leaf name should somehow describe 
the entry; for example, by identifying its
owner or its contents.  The remainder of this section contains guidelines for
choosing leaf names. 
</Para>
<Note>
<Para>Directory pathnames and leaf names are case sensitive.
</Para>
</Note>
<Para>Use the following guidelines for constructing names:
</Para>
<ItemizedList>
<ListItem>
<Para>Naming a server entry
</Para>
<Para>For a server entry that advertises an RPC interface or service offered by a
server, the leaf name must distinguish the entry from the equivalent entries of
other servers.  When a single server instance runs on a host, you can ensure a
unique name by combining the name of the service, interface (from the interface
definition), or the system name for the server's host system. 
</Para>
<Para>For example, consider two servers, one offering a calendar service on host
<Literal>JULES</Literal>, and one on host <Literal>VERNE</Literal>. 
</Para>
<Para>The server on <Literal>JULES</Literal> uses the following leaf name: 
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>calendar_JULES    
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The server on <Literal>VERNE</Literal> uses the following leaf name:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>calendar_VERNE    
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>For servers that perform tasks on or for a specific system,
an alternative approach is to create server entries in a system-specific host
directory within the namespace.  Each host directory 
takes the name of the host to which it corresponds.
Because the directory name identifies the system, the leaf name of the server
entry name does not need to include the host name, for example: 
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>/.:/LandS/host_1/Process_control
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>To construct names for the server entries used by distinctive server instances
on a single host, you can construct unique server entry names by combining the
following information: the name of the server's service, interface, or object;
the system name of the server's host system; and a reusable instance
identifier such as an integer. 
</Para>
<Para>For example, the following leaf names
distinguish two instances of a calendar service on the <Literal>JULES</Literal> system: 
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>calendar_JULES_01 

calendar_JULES_02 
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>Avoid automatically generating entry names for the server entries of server
instances; for example, by using unique data such as a timestamp
(<Literal>calendar_verne_15OCT91_21:25:32</Literal>) or a process identifier
(<Literal>calendar_jules_208004D6</Literal>). 
When a server incorporates such unique data into its
server entry names, each server instance creates a separate server entry,
causing many server entries.  When a server instance stops running, it leaves an
obsolete server entry that is not reused.  The creation of a new entry whenever 
a server instance starts may impair performance. 
</Para>
<Para>A server can use multiple server entries to advertise different combinations of
interfaces and objects.  For example, a server can create a separate server
entry for a specific object, and the associated interfaces.  The name of
such a server entry should correspond to a well-known name for
the object.  For example, consider a server that offers a horticulture bulletin
board known to users as <Literal>horticulture_bb</Literal>.  The server exports the
<Literal>horticulture_bb</Literal> object, binding information, 
and the associated bulletin-board
interface to a server entry whose leaf name identifies the object, as follows: 
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>horticulture_bb
</UserInput></ProgramListing></Para>
</InformalExample>
<Note>
<IndexTerm Id="DCEADG.RPCRAD.indx.97">
<Primary>authenticated RPC</Primary>
<Secondary>choosing a server principal name</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.98">
<Primary>security</Primary>
<Secondary>service</Secondary>
<Tertiary>RPC principal names</Tertiary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.99">
<Primary>names</Primary>
<Secondary>server principal</Secondary>
</IndexTerm>
<Para>An RPC server that uses RPC authentication can choose identical names for its
principal name and its server entry.  Use of identical names permits a client
that calls the <Function>rpc_binding_set_auth_info()</Function> routine to automatically
determine a server's principal name.  (The client will assume the principal name
to be the same as the server's entry name.)  If a server uses different
principal and server entry names, users must explicitly supply the principal
name.  For an explanation of principal names, see Part 5 of this guide.
</Para>
</Note>
</ListItem>
<ListItem>
<Para>Naming a group
</Para>
<Para>The leaf name of 
a group should indicate the interface,
service, or object that determines membership in the group.  For example, for
a group whose members are selected because they advertise
an interface named <Literal>Statistics</Literal>, the following is an effective leaf name:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>Statistics
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>For a group whose members advertise laser printer print queues as objects, 
the following is an effective leaf name:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>laser-printer
</UserInput></ProgramListing></Para>
</InformalExample>
</ListItem>
<ListItem>
<Para>Naming a profile
</Para>
<Para>The leaf name of a profile should indicate the profile users; for example, for 
a profile that serves the members of an accounting department, 
the following is an effective leaf name:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>accounting_profile
</UserInput></ProgramListing></Para>
</InformalExample>
</ListItem>
</ItemizedList>
<Para>The following text describes the NSI <Literal>begin</Literal>, <Literal>next</Literal>,
and <Literal>done</Literal> operations.
NSI accesses a variety of search and inquire operations that read
NSI attributes in directory service entries.
<!-- .gL "NSI attribute"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.100">
<Primary>NSI</Primary>
<Secondary>attribute</Secondary>
</IndexTerm>An NSI attribute is an RPC-defined attribute of a directory service entry used
by the DCE RPC directory service interface.  An NSI attribute stores one of the
following: binding information, object UUIDs, a group, or a profile. 
Reading information from any attribute involves an equivalent set of search or
inquire operations; that is,
an integral set of <Literal>begin</Literal>, <Literal>next</Literal>, and <Literal>done</Literal> operations. 
An RPC application uses these operations as follows: 
</Para>
<OrderedList>
<ListItem>
<Para>The application creates a 
<IndexTerm Id="DCEADG.RPCRAD.indx.101">
<Primary>NSI</Primary>
<Secondary>directory service handle</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.102">
<Primary>directory service</Primary>
<Secondary>handle</Secondary>
</IndexTerm>directory service handle
(a reference to the context of the ensuing series of <Literal>next</Literal> operations) 
by calling an NSI <Literal>begin</Literal> operation. 
</Para>
</ListItem>
<ListItem>
<Para>The application calls the NSI <Literal>next</Literal> operation corresponding to 
the <Literal>begin</Literal>
operation one or more times.  Each <Literal>next</Literal> operation returns another value 
or list of values from the target RPC directory service attribute. 
For example, an <Literal>import_next</Literal> operation 
returns binding information from a binding
attribute and an object from an object attribute.
</Para>
</ListItem>
<ListItem>
<Para>The application deletes the directory service handle
by calling the corresponding NSI <Literal>done</Literal> operation.
</Para>
</ListItem>
</OrderedList>
<IndexTerm Id="DCEADG.RPCRAD.indx.103">
<Primary>search</Primary>
<Secondary>operations</Secondary>
</IndexTerm>
<Note>
<Para>Search and inquire operations are also accessible interactively from within the
RPC control program. 
</Para>
</Note>
<Para>Table 14-1 lists the NSI <Literal>next</Literal> operations used by
RPC applications.
</Para>
<?sml-need 4i>
<Table Frame="all" Remap="center" Orient="Port">
<Title>NSI next Operations</Title>
<TGroup Rowsep="1" Colsep="1" Cols="2">
<ColSpec Colsep="1" Align="Left" Colwidth="232*" Colname="col1" Colnum="1">
<ColSpec Align="Left" Colwidth="223*" Colname="col2" Colnum="2">
<TBody>
<Row>
<Entry Rowsep="1"><Literal>Search Operation</Literal></Entry>
<Entry Rowsep="1"><Literal>Attributes Traversed</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Function>rpc_ns_binding_import_next()</Function></Entry>
<Entry Rowsep="1">Searches for binding and object attributes of a compatible server;
reads any NSI attribute in a search path.
Returns a binding handle that refers to a potential binding for a compatible
server, and also to a single object UUID.
</Entry>
</Row>
<Row>
<Entry><Function>rpc_ns_binding_lookup_next()</Function></Entry>
<Entry>Searches for binding and object attributes of a compatible server;
reads any NSI attribute in a search path.
Returns a list of binding handles, each of which refers to
a potential binding for a compatible server,
and also to a single object UUID.  The same object UUID is
associated with each potential binding.
<?Pub _newline>
Note that, after calling the <Literal>lookup_next</Literal> 
operation, the client must select one
binding handle from the list.  To select a binding handle at random, the client
can call the NSI binding select routine 
<Function>rpc_ns_binding_select()</Function>.  For an
alternative selection algorithm, the client can define and call its own
application-specific select algorithm. 
</Entry>
</Row>

<Row>
<Entry Rowsep="1" Colsep="1"><Literal>Inquire Operation</Literal></Entry>
<Entry Rowsep="1"><Literal>Attributes Traversed</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Function>rpc_ns_group_mbr_inq_next()</Function></Entry>
<Entry Rowsep="1">Reads a group attribute and returns a member name.
</Entry>
</Row>
<Row>
<Entry><Function>rpc_ns_profile_elt_inq_next()</Function></Entry>
<Entry>Reads a profile attribute and returns the fields of a profile element.
</Entry>
</Row>
</TBody>
</TGroup>
</Table>
</Sect3>
<Sect3 Id="DCEADG.RPCRAD.div.23">
<Title>Selecting the Starting Entry</Title>
<Para>When searching a namespace for an RPC interface and object, a
client supplies the name of the 
directory service entry where the search begins.  
The entry can be a server entry, group, or profile.  Generally, an NSI
search starts with a group or profile.  The group or profile defines a
search path that ends at a server entry containing the requested interface
identifier, object UUID, and compatible binding information. 
</Para>
<Para>A user may know in advance what server instance to use.  In this case,
starting with a server entry for the server instance is appropriate. 
</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCRAD.div.24">
<Title>Environment Variables</Title>
<Para>DCE RPC provides predefined environment variables that a client can use for
NSI operations. 
<!-- .gL "environment variable"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.104">
<Primary>environment variable</Primary>
<Secondary>NSI</Secondary>
</IndexTerm>An environment variable is a
variable that stores information, such as a name, about a particular
environment.  The NSI interface provides two environment variables,
<Literal>RPC_DEFAULT_ENTRY</Literal> and <Literal>RPC_DEFAULT_ENTRY_SYNTAX</Literal>, which are
described in the &DCEDr;.  Used
together, these environment variables identify an entry name and
indicate its syntax.
</Para>
<Para>When a client searches for binding information, the search starts with a
specific entry name.  Optionally, a client can specify this
entry name as the value of the <Literal>RPC_DEFAULT_ENTRY</Literal> variable.  
A client can
also specify the name syntax of the starting entry as the value of the
<Literal>RPC_DEFAULT_ENTRY_SYNTAX</Literal> variable; the default name syntax
is <Literal>dce</Literal>.
</Para>
<Note>
<Para>The <Literal>dce</Literal> name syntax is the only syntax currently supported by CDS.
However, NSI is independent of any specific directory
service and depending on your vendor, may support one or more alternative
directory services that use different name syntaxes. 
</Para>
</Note>
</Sect3>
</Sect2>
<Sect2 Id="DCEADG.RPCRAD.div.25">
<Title>Searching the Namespace for Binding Information</Title>
<Para>Searching the namespace for binding information requires that a
client specify a starting point for the search.  A client can start with a
specific server entry.  However, this is a limiting approach because the
client is restricted to using one server.  To avoid this, a client can start
searching with a group or a profile instead of with a server entry.  Searches
that start with a profile or a group should encounter the server entry of a
compatible server.  If such an entry is not encountered, a search operation
<IndexTerm Id="DCEADG.RPCRAD.indx.105">
<Primary>status</Primary>
<Secondary>codes</Secondary>
</IndexTerm>returns the <Literal>rpc_s_no_more_bindings</Literal> status code to the client.
When calling the routines <Function>rpc_ns_binding_import_next()</Function> or 
<Function>rpc_ns_binding_lookup_next()</Function>,
a client must track whether the routine returns this status code.
</Para>
<Sect3 Id="DCEADG.RPCRAD.div.26">
<Title>The <Literal>import_next</Literal> and <Literal>lookup_next</Literal> Search Algorithm</Title>
<Para>The NSI search operations (<Literal>import_next</Literal> and <Literal>lookup_next</Literal>)
traverse one or more entries in the namespace when searching for
compatible binding information. 
In each directory service entry, these operations ignore non-RPC
attributes and process the NSI attributes in the following order:
</Para>
<OrderedList>
<ListItem>
<Para>Binding attribute (and object attribute, if present)
</Para>
</ListItem>
<ListItem>
<Para>Group attribute
</Para>
</ListItem>
<ListItem>
<Para>Profile attribute
</Para>
</ListItem>
</OrderedList>
<!-- .AL (numbered) list-->
<Para>If an NSI search path includes a group attribute, the search path 
can encompass every entry named as a group member.
If a search path includes a profile attribute, the search path 
can encompass every entry named as the member of a profile element that contains
the target interface identifier. 
<IndexTerm Id="DCEADG.RPCRAD.indx.106">
<Primary>NSI</Primary>
<Secondary>search operations</Secondary>
</IndexTerm>A search finishes only when it finds a server entry containing compatible
<IndexTerm Id="DCEADG.RPCRAD.indx.107">
<Primary>search</Primary>
<Secondary>operations</Secondary>
</IndexTerm>binding information and the nonnil object UUID, if requested.  Search
operations take the following steps when traversing 
a directory service entry:
</Para>
<VariableList>
<?sml-need 10>
<VarListEntry>
<Term>Step 1:</Term>
<ListItem>
<Para>Binding attribute 
</Para>
<Para>In each entry, the search operation starts by searching 
for a compatible interface identifier in the binding attribute, if present. 
<IndexTerm Id="DCEADG.RPCRAD.indx.108">
<Primary>NSI</Primary>
<Secondary>attributes</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.109">
<Primary>binding attribute</Primary>
<Secondary>searches of</Secondary>
</IndexTerm></Para>
<Para>The absence of a binding attribute or
of any compatible interface identifier causes
the search operation to go directly to step 2.
</Para>
<Para>The presence of any compatible interface identifier indicates
that compatible potential bindings may exist in the binding attribute.
At this point, object UUIDs may impact the search, as follows:
</Para>
<ItemizedList>
<ListItem>
<Para>If the client specified the nil object UUID, object UUIDs do not
affect the success or failure of the search.
The search returns compatible binding information for one or more
potential bindings. 
</Para>
</ListItem>
<ListItem>
<Para>If the client specified a nonnil object UUID, the search reads the
object attribute, if present, to look for the requested object UUID.
This search for an object UUID has one of the following outcomes:
</Para>
<ItemizedList>
<ListItem>
<Para>On finding the specified object UUID, the search returns 
the object UUID along with compatible binding information for one or more
potential bindings. 
</Para>
</ListItem>
<ListItem>
<Para>If a requested object UUID is absent, the search continues to step 2.
</Para>
</ListItem>
</ItemizedList>
<!-- .ML (bulleted) list-->
</ListItem>
</ItemizedList>
<!-- .ML (bulleted) list-->
<Note>
<Para>If a search involves a series of <Literal>import_next</Literal> 
or <Literal>lookup_next</Literal> operations, a
subsequent next operation resumes the search at the point
in the search path where the preceding operation left off. 
</Para>
</Note>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>Step 2:</Term>
<ListItem>
<?sml-need 15>
<Para>Group attribute
<IndexTerm Id="DCEADG.RPCRAD.indx.110">
<Primary>group</Primary>
<Secondary>RPC attribute</Secondary>
</IndexTerm></Para>
<Para>If the binding attribute does not lead to compatible binding information
or 
if a series of <Literal>import_next</Literal> or <Literal>lookup_next</Literal> operations
exhausts the compatible binding information,
the search continues by reading the group attribute, if
present; if the directory service entry lacks a group attribute,
the search goes directly to step 3.
</Para>
<Para><?sml-need 5>The search operation selects a member of the group at random, goes to the entry
of that member, and resumes the search at step 1. Unless a group member leads
the search to compatible binding information, the search looks at all
the members of the group, one by one in random order, until none remain. 
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>Step 3:</Term>
<ListItem>
<?sml-need 6>
<Para>Profile attribute
<IndexTerm Id="DCEADG.RPCRAD.indx.111">
<Primary>profile</Primary>
<Secondary>attribute</Secondary>
</IndexTerm></Para>
<Para>If the binding and group attributes do not lead to compatible binding
information, the search continues by reading the profile attribute, if
present; if the directory service entry lacks a profile attribute, the search
fails. 
</Para>
<Para>The search operation identifies all the profile elements containing the
requested interface identifier and searches them in the order of their priority,
beginning with the 0 (zero)
priority elements.  Profile elements of a given priority
are searched in random order.  For the selected profile element, the search reads
the member name and goes to the corresponding 
directory service entry.  There, the
search resumes at step 1.  Unless a profile element leads the search to
compatible binding information, the search eventually looks at all the profile
elements with the requested interface identifier, one by one, until none remain.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para>If the starting entry does not contain NSI attributes, or if none of the 
steps satisfies the search, the search operation returns the status code
<Literal>rpc_s_no_more_bindings</Literal> to the client. 
</Para>
<Note>
<Para>The inquire next (<Literal>inq_next</Literal>)
operations for objects, groups, or profiles look at only the
entry specified in its corresponding inquire begin (<Literal>inq_begin</Literal>) operation.
The search ignores nested groups or nested profiles.
</Para>
</Note>
<Para>Figure 14-12 illustrates the three steps of the
<Literal>import_next</Literal> and <Literal>lookup_next</Literal> search operations. 
</Para>
<?sml-need 8.1i>
<Figure>
<Title>The import_next, lookup_next Search Algorithm in a Single Entry</Title>
<Graphic Entityref="DCEADG.RPCRAD.ent.12" Scalefit="1" Reprodep="350" Reprowid="350"></Graphic>
</Figure>
<!-- DEC-file name .P! pictures/rpc-nsi-bi-search.ps 8.25i-->
</Sect3>
<Sect3 Id="DCEADG.RPCRAD.div.27">
<Title>Examples of Searching for Server Entries</Title>
<Para>This subsection provides several examples of how the NSI 
<Literal>import_next</Literal> and <Literal>lookup_next</Literal>
operations search for binding information associated with
a given RPC interface and object in a namespace. 
</Para>
<Para>The examples in this guide use the following conventions: 
</Para>
<ItemizedList>
<ListItem>
<Para>To simplify the following examples, 
each member name is represented by a leaf name preceded by the symbol that
represents the local cell (<Filename>/.:</Filename>).
For example, the full global name of the 
group for the <Literal>Bulletin_board_interface</Literal> is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>/.../C=US/O=uw/OU=MadCity/LandS/bb_grp
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The abridged name is <Filename>/.:/LandS/bb_grp</Filename>.
</Para>
</ListItem>
<ListItem>
<Para>Except for the nil interface UUID of the default profile, the examples avoid
string representations of actual UUIDs.  Instead, the examples represent a UUID
as a value consisting of the name of the interface and the string 
<Symbol Role="Variable">if-uuid</Symbol> or of the name of the object and the string <Symbol Role="Variable">object-uuid</Symbol>;
for example:
</Para>
<InformalExample>
<Para><ProgramListing><Replaceable>calendar-if-uuid</Replaceable>,1.0

<Replaceable>laser-printer-object-uuid</Replaceable>
</ProgramListing></Para>
</InformalExample>
</ListItem>
<ListItem>
<Para>Profile elements in the examples are organized as follows
(annotations are not displayed):
</Para>
<InformalExample>
<Para><ProgramListing><Replaceable>interface-identifier   member-name   priority</Replaceable>
</ProgramListing></Para>
</InformalExample>
<Para>For example,
</Para>
<InformalExample>
<Para><ProgramListing><?sml-point-size 11>2fac8900-31f8-11ca-b331-08002b13d56d,1.0 /.:/LandS/C_host_7  0  
<?sml-point-size 12></ProgramListing></Para>
</InformalExample>
<Para>which, in the following examples, is represented as follows:
</Para>
<InformalExample>
<Para><ProgramListing><Replaceable>calendar-if-uuid</Replaceable>,1.0    /.:/LandS/C_host_7   0
</ProgramListing></Para>
</InformalExample>
<Note>
<Para>The priority is a value of 0 to 7, with 0 having the highest 
search priority and 7 having the lowest priority.  
</Para>
</Note>
</ListItem>
</ItemizedList>
<Para><!-- -->
The first two examples begin with the personal profile of a user, Esther
Rose, whose user name is <Literal>esther_r</Literal> and whose profile has the leaf
name of <Literal>esther_r_profile</Literal>.  To use this profile, 
Esther must specify its entry
name to the client.  Usually, a client either uses the predefined RPC
environment variable <Literal>RPC_DEFAULT_ENTRY</Literal> or prompts for an entry name.  For
a client to use <Literal>RPC_DEFAULT_ENTRY</Literal>, the 
client or user must have already set the variable
to a directory service entry. 
</Para>
<Para>The following example illustrates six profile elements from the
individual user profile used in the first two examples.
The six elements include five nondefault elements for some
frequently used interfaces and a default profile element. 
Each profile element is displayed on three lines, but in an actual profile all
the fields occupy a single record.  The fields are the interface identifier
(interface UUID and version numbers), member name, priority, and annotation.
<!---->
</Para>
<InformalExample>
<Para><ProgramListing>
<?Pub _font TypeSize="8pt">
/.:/LandS/anthro/esther_r_profile contents:

ec1eeb60-5943-11c9-a309-08002b102989,1.0
   /.../C=US/O=uw/OU=MadCity/LandS/Cal_host_7 
   0  Calendar_interface_V1.0

ec1eeb60-5943-11c9-a309-08002b102989,2.0  
   /.../C=US/O=uw/OU=MadCity/LandS/Cal_host_4 
   1  Calendar_interface_V2.0 

62251ddd-51ed-11ca-852c-08002b1bb4f6,2.0  
   /.../C=US/O=uw/OU=MadCity/bb_grp 
   0  Bulletin_board_interface_V2.0 

62251ddd-51ed-11ca-852c-08002b1bb4f6,2.1
   /.../C=US/O=uw/OU=MadCity/bb_grp 
   1  Bulletin_board_interface_V2.1 

9e18d295-51ec-11ca-9cc0-08002b1bb4f5,1.0  
   /.../C=US/O=uw/OU=MadCity/LandS/anthro/Zork_host_2 
   0  Zork_interface_V1.0 

00000000-0000-0000-0000-000000000000,0.0  
   /.../C=US/O=uw/OU=MadCity/cell-profile
   0  Default_profile_element
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
<Sect4 Id="DCEADG.RPCRAD.div.28">
<Title>Example 1: Importing for an Interface with Multiple Versions</Title>
<Para><Literal>Target Interface:</Literal> Calendar V2.0 
</Para>
<OrderedList>
<ListItem>
<Para>The search for binding information associated with
Calendar V2.0
starts with the entry <Literal>esther_r_profile</Literal>:
</Para>
<InformalExample>
<Para><ProgramListing>
<?Pub _font TypeSize="8pt">
<!--no-op:  12-->
/.../C=US/O=uw/OU=MadCity/LandS/anthro/esther_r_profile contents:

   <Replaceable>calendar-if-uuid</Replaceable>,1.0   /.:/LandS/C_host_7   0
   <Replaceable>calendar-if-uuid</Replaceable>,2.0   /.:/LandS/C_host_4   1

   <Replaceable>bulletin_board-if-uuid</Replaceable>,2.0   /.:/LandS/bb_grp   2
   <Replaceable>bulletin_board-if-uuid</Replaceable>,2.1   /.:/LandS/bb_grp   3

   <Replaceable>Zork-if-uuid</Replaceable>,1.0   /.:/Eng/Zork_host_2   0
   00000000-0000-0000-0000-000000000000,0.0   /.:/cell-profile   0
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
<Para>The search operation examines only the two profile elements
that refer to the Calendar interface:
</Para>
<OrderedList>
<ListItem>
<Para>The operation rejects the first profile element for the interface because 
it refers to the wrong version numbers.
</Para>
</ListItem>
<ListItem>
<Para>In the next profile element, the operation finds the correct version numbers
(<Literal>2.0</Literal>).  The search proceeds to the associated server entry,
<Filename>/.:/LandS/Cal_host_4</Filename>.
</Para>
</ListItem>
</OrderedList>
</ListItem>
<ListItem>
<Para>The search ends with the indicated server entry, 
where the binding information requested by the client resides:
</Para>
<InformalExample>
<Para><ProgramListing>/.:/LandS/Cal_host_4 contents:
   <Replaceable>calendar-if-uuid</Replaceable>,2.0  

   <Replaceable>binding-information</Replaceable>
</ProgramListing></Para>
</InformalExample>
</ListItem>
</OrderedList>
<?sml-need 20>
</Sect4>
<Sect4 Id="DCEADG.RPCRAD.div.29">
<Title>Example 2: Using a Default Profile for Importing an Interface</Title>
<Para><Literal>Target Interface:</Literal>  Statistics V1.0 
</Para>
<OrderedList>
<ListItem>
<Para>The search for binding information associated with
Statistics V1.0 starts with the entry
<Literal>esther_r_profile</Literal>.  But
the profile lacks any elements for the interface.
Thus the search reaches the default profile element, which provides the
entry name for the default profile, <Filename>/.:/cell-profile</Filename>:
</Para>
<InformalExample>
<Para><ProgramListing>
<?Pub _font TypeSize="8pt">
/.:/LandS/anthro/esther_r_profile contents:

   <Replaceable>calendar-if-uuid</Replaceable>,1.0   /.:/LandS/C_host_7   0
   <Replaceable>calendar-if-uuid</Replaceable>,2.0   /.:/LandS/C_host_4   1

   <Replaceable>bulletin_board-if-uuid</Replaceable>,2.0   /.:/LandS/bb_grp   2
   <Replaceable>bulletin_board-if-uuid</Replaceable>,2.1   /.:/LandS/bb_grp   3

   <Replaceable>Zork-if-uuid</Replaceable>,1.0   /.:/Eng/Zork_host_2   0
   00000000-0000-0000-0000-000000000000,0.0   /.:/cell-profile   0
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
</ListItem>
<ListItem>
<Para>The search continues to the indicated default profile, 
<Filename>/.:/cell-profile</Filename>, which contains
a profile element for the requested Statistics V1.0 interface:
</Para>
<InformalExample>
<Para><ProgramListing>/.:/LandS/cell-profile contents:
 .
 .
 . 
 <Replaceable>Statistics-if-uuid</Replaceable>,1.0   /.:/LandS/Stats_host_6   0 
 .
 .
 .
</ProgramListing></Para>
</InformalExample>
</ListItem>
<ListItem>
<Para>The search ends at the indicated server entry,
<Filename>/.:/LandS/Stats_host_6</Filename>, where a server address for the requested
interface resides:
</Para>
<InformalExample>
<Para><ProgramListing>/.:/LandS/Stats_host_6 contents:

   <Replaceable>Statistics-if-uuid</Replaceable>,1.0   

   <Replaceable>binding-information</Replaceable> 
</ProgramListing></Para>
</InformalExample>
</ListItem>
</OrderedList>
<?sml-break>
<?sml-need 20>
</Sect4>
<Sect4 Id="DCEADG.RPCRAD.div.30">
<Title>Example 3: Importing an Interface and an Object</Title>
<Para><Literal>Target Interface:</Literal> Print Server V2.1 
</Para>
<Para><Literal>Target Object:</Literal> Laser Printer Print Queue
</Para>
<OrderedList>
<ListItem>
<Para>The search starts with the entry <Filename>/.:/Bldg/Print_queue_grp</Filename>, 
which contains the entry names
of several server entries that advertise the <Literal>Print_server</Literal> 
interface and the object UUID of a given <Literal>Laser_printer</Literal> 
print queue.  The search begins by randomly
selecting a member name.  In this instance, the search selects 
the name <Filename>/.:/Bldg/Print_server_host_3</Filename>:
</Para>
<InformalExample>
<Para><ProgramListing>/.:/Bldg/Print_queue_grp contents:

   /.:/Bldg/Print_server_host_3
   /.:/Bldg/Print_server_host_7
   /.:/Bldg/Print_server_host_9
</ProgramListing></Para>
</InformalExample>
</ListItem>
<ListItem>
<Para>The search continues with the <Filename>/.:/Bldg/Print_server_host_3</Filename> 
entry.  There, it finds the
requested Version 2.1 of the <Literal>Print_server</Literal> interface.  However, the search
continues because the entry lacks the object UUID of the requested 
<Literal>Laser_printer</Literal> queue:
</Para>
<InformalExample>
<Para><ProgramListing>/.:/Bldg/Print_server_host_3 contents:

<Replaceable>print_server-if-uuid</Replaceable>,2.1

<Replaceable>binding-information</Replaceable>

<Replaceable>line_printer_queue-object-uuid</Replaceable>
</ProgramListing></Para>
</InformalExample>
</ListItem>
<ListItem>
<Para>The search goes back to the previous entry, which was 
<Filename>/.:/Bldg/Print_queue_grp</Filename>, 
to select another entry name; in this instance 
<Filename>/.:/Bldg/Print_server_host_9</Filename>:
</Para>
<InformalExample>
<Para><ProgramListing>/.:/Bldg/Print_queue_grp contents:

   /.:/Bldg/Print_server_host_3
   /.:/Bldg/Print_server_host_7
   /.:/Bldg/Print_server_host_9
</ProgramListing></Para>
</InformalExample>
</ListItem>
<ListItem>
<Para>The search selects the <Filename>/.:/Bldg/Print_server_host_9</Filename> entry.
This entry contains both a server address for the requested Version
2.1 of the interface and the requested object UUID
of the <Literal>Laser_printer</Literal> queue:
</Para>
<InformalExample>
<Para><ProgramListing>/.:/Bldg/Print_server_host_9 contents:

<Replaceable>print_server-if-uuid</Replaceable>, 2.1

<Replaceable>binding-information</Replaceable>

<Replaceable>laser_printer_queue-object-uuid</Replaceable>
</ProgramListing></Para>
</InformalExample>
<Para>The search returns binding information from this entry to the client.
</Para>
</ListItem>
</OrderedList>
</Sect4>
</Sect3>
<Sect3 Id="DCEADG.RPCRAD.div.31">
<Title>Expiration Age of a Local Copy of Directory Service Data</Title>
<Para>To prevent accessing a namespace unnecessarily,
previously requested directory service data is sometimes stored
on the system where the request originated.  A local copy
of directory service data is not automatically updated
at each request.  Automatic updating of the local copy 
occurs only when it exceeds its expiration age.
<!-- .gL "expiration age"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.112">
<Primary>expiration age</Primary>
</IndexTerm>The expiration age is the amount of time that a local copy of 
directory service data from an
NSI attribute can remain unchanged before a request from an RPC
application for the attribute requires updating of the local copy.  When an
RPC application begins running, the RPC runtime randomly specifies a 
value between 8 and 12 hours as the
default expiration age for that instance of the application.
Most applications use only this default expiration age, which
is global to the application. 
</Para>
<Para>An expiration age is used by an NSI next operation, which reads data
from directory service attributes.  For a given search or inquire operation, 
you can override the default expiration age 
by calling the routine <Function>rpc_ns_mgmt_handle_set_exp_age()</Function> 
after the operation's begin routine.  Note that specifying a low default age
will result in increased network updates among the name servers in your cell. 
This will adversely affect the performance of all network traffic.  Therefore,
use the default whenever possible.  If you must override the default age,
specify a number that is high enough to avoid frequent updates of local data. 
</Para>
<Para>An NSI next operation usually starts by
looking for a local copy of the attribute data being requested by an
application.  In the absence of a local copy, the NSI next operation
creates one with fresh attribute data from the namespace.  If a
local copy already exists, the operation compares its actual age to
the expiration age used by the application.  If the actual age
exceeds the expiration age, the operation automatically tries to
update the local copy with fresh attribute data.  If updating is
impossible, the old local data remains in place and the NSI next
operation fails, returning the 
<IndexTerm Id="DCEADG.RPCRAD.indx.113">
<Primary>status codes</Primary>
</IndexTerm><Literal>rpc_s_name_service_unavailable</Literal> status code.
</Para>
</Sect3>
</Sect2>
<Sect2 Id="DCEADG.RPCRAD.div.32">
<Title>Strategies for Using Directory Service Entries</Title>
<Para>When developing an RPC application, decide
how an application will use the namespace 
and design your application accordingly.  The following subsections
discuss issues associated with how
servers use different types of directory service entries.
</Para>
<Sect3 Id="DCEADG.RPCRAD.div.33">
<Title>Using Server Entries</Title>
<Para>An application requires separate server entries for servers on different hosts.
For example, if a server offering the calendar 
service runs on two hosts, <Literal>JULES</Literal> and <Literal>VERNE</Literal>, 
one server entry is necessary for
the server on <Literal>JULES</Literal> and another is 
necessary for the server on <Literal>VERNE</Literal>. 
</Para>
<Para>Each server entry requires a unique cell-relative entry name. 
If a server adheres to a simple and consistent arrangement of server
entries, you
may be able to use server initialization code to automatically generate a name
for each server entry, and also to ensure that the entry exists.  However, some
servers will need to obtain the entry name of a server entry from an external
source such as a command-line argument or a local database belonging to the
application. 
</Para>
<Note>
<Para>Applications that obtain entry names and UUIDs as command-line arguments
should accept user-defined values that represent them as an alternative to
accepting the actual names. 
</Para>
</Note>
<Para><?sml-need 11>Some applications, such as a process-control application, 
require only one server instance per system.  Many
applications, however, can accommodate multiple server instances on a system.
When multiple instances of a server run simultaneously on a single system,
all instances on a host can use a single server entry, every instance can use
separate server entries, or the instances can be classified into subsets with
a separate server entry.  A client importing from a shared server entry
cannot distinguish among the server instances that export to the entry. 
Therefore, the recommended strategy for a server on a given system depends
on which server instances are viewed by clients as interchangeable
entities and which are viewed as unique entities, as follows: 
</Para>
<ItemizedList>
<ListItem>
<Para>Interchangeable server instances
</Para>
<Para>When clients consider all the server instances on a host as 
equivalent alternatives, all of the instances can (and should) share a 
server entry.  For example, multiple instances of the calendar service
running on host <Literal>JULES</Literal> can all export to the <Literal>calendar_JULES</Literal> entry. 
</Para>
</ListItem>
<ListItem>
<Para>Unique server instances
</Para>
<Para>A unique server instance possesses a significant difference from 
other instances of the same host.  Unique server instances require separate
server entries.  Each server instance must export unique information
to its own server entry; this unique information can be either a
server-specific, well-known endpoint or an object UUID belonging exclusively to
the one server instance. 
</Para>
<Para>Before exporting, each server instance must acquire the entry name of its 
server entry from an external source.  When a unique server instance stops
running, its server entry becomes available.  An available server entry should
be reused for a new instance of that server by providing the existing entry's
name for a new server instance to use with the export operation.  If any
existing server entries are unavailable, a new server instance requires a new
server entry name. 
</Para>
<Para>For a discussion of when a server instance should remove the 
binding information from its server entry, see the
<Filename MoreInfo="RefEntry">rpc_ns_binding_unexport(3rpc)</Filename> reference page.
</Para>
</ListItem>
</ItemizedList>
</Sect3>
<Sect3 Id="DCEADG.RPCRAD.div.34">
<Title>Using Groups</Title>
<Para>When a server is first installed on a system, the server or the installer
creates one or more server entries for the server.  Also, when installing the
first instance of the server within a cell, the installer usually creates one
or more groups for the application. 
For any application, the local system and directory service administrators can
create site-specific groups whose members
are server entries, groups, or both. 
Typically, a server adds a server entry to at least one group.
</Para>
<Para>Design decisions for defining groups may reflect a number of possible factors.
Typical factors that help define effective groups include the proximity of
services or resources to clients, the types of any resources offered by
servers, the uses of UUIDs, 
and the types of users that require a specific server.
</Para>
<Para>For example, for a print server, proximity to the clients and the type of
supported file formats are both relevant.  These factors may affect
print servers as follows:
</Para>
<ItemizedList>
<ListItem>
<Para>Proximity
</Para>
<Para>If the proximity of a server is important to clients, assign servers to groups
according to their locations.  For example, print servers that are located
together can use their own group (for example, print servers in
building 1 use the group <Literal>bldg_1_print_servers</Literal>). 
Each server instance can add
its own entry to the group, or a system administrator can add server entries
by using the RPC control program. 
</Para>
<Para>To select randomly among servers in a given location, a client imports using the
name of a group that corresponds to those servers (or of a profile that
refers to that group). 
</Para>
<Note>
<Para>If proximity is the key factor in selecting among servers,
name each server entry for the server's location; for
example, <Literal>bldg_1_pole_27_print_server</Literal>. 
</Para>
</Note>
</ListItem>
<ListItem>
<Para>Object types
</Para>
<Para>When accessing specific classes of resources is important to clients, you can
group server instances based on the type of object they offer. 
</Para>
<Para><?sml-need 6>For servers that advertise resources in server entries,
groups often use subsets for server entries according to the
resources they advertise.
For example, print servers can be grouped according to supported file formats. 
In this case, an administrator creates a group entry 
for each file format; for
example, <Literal>post_printers</Literal>, <Literal>sixel_printers</Literal>, and <Literal>ascii_printers</Literal>. 
Each print server entry is a member of one or more groups.
</Para>
<Para>Users that specify a group for a file format must find the printer that
processes the print command.  To help the user find the printer, the client can
obtain the name of the server entry that supplied the server 
binding information by calling <Function>rpc_ns_binding_inq_entry_name()</Function>, and
then display the name for the user. 
If the server entry name indicates the location
of the print server (for example, <Literal>floor_3_room_45A_print_server</Literal>), 
the user can then find the printer. 
</Para>
</ListItem>
</ItemizedList>
<Para>An application can set up groups according to different factors for
different purposes.  For example, the print server application can set up
groups of neighboring print servers and a group of print servers for each of
the file formats.  The same server is a member of at least one group of each
kind.  Clients require users to specify the name of a 
directory service entry as a
command-line argument of remote print commands.  The user 
specifies the name of
the appropriate group. 
</Para>
<Note>
<Para>If a user wants a specific print server and knows the name of its server entry,
the user can specify that name to the client instead of a group. 
</Para>
</Note>
</Sect3>
<Sect3 Id="DCEADG.RPCRAD.div.35">
<Title>Using Profiles</Title>
<IndexTerm Id="DCEADG.RPCRAD.indx.114">
<Primary>profile</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.115">
<Primary>RPC</Primary>
<Secondary>profile</Secondary>
</IndexTerm>
<Para>Profiles are tools for managing NSI searches (performed by <Literal>import_next</Literal> or
<Literal>lookup_next</Literal> operations).  Often profiles are set up as
<!-- .gL "public profile"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.116">
<Primary>public profile</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.117">
<Primary>RPC</Primary>
<Secondary>public profile</Secondary>
</IndexTerm>public profiles for
the users of a particular environment, such as a 
directory service cell, a
system, a specific application, or an organization.  For example, the
administrator of the local directory service cell should set up a 
<!-- .gL "cell profile"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.118">
<Primary>cell</Primary>
<Secondary>profile</Secondary>
<Tertiary>RPC</Tertiary>
</IndexTerm>cell profile for all RPC applications that use the cell, and the
administrator of each system in the distributed computing environment should
set up a 
<!-- .gL "system profile"-->
<IndexTerm Id="DCEADG.RPCRAD.indx.119">
<Primary>system profile</Primary>
</IndexTerm>system profile for local servers.
</Para>
<Para><?sml-need 10>For each application, a directory service administrator or the owner of an
application should add profile elements to the public profiles that
serve the general user population; for example, a cell profile,
a system profile, or a profile of an organization.  Each profile element
associates a profile member (represented in the member field of an
element as the global name of a directory service entry) with an interface
identifier, access priority, and optional annotation.  A candidate for
membership in a cell profile is a group or another profile; for example, a
group that refers, directly or indirectly, to the servers of an application
installed in the local cell or an application-specific profile. 
</Para>
<Para>An application may benefit from an application-specific profile.  For example,
an administrator at a specific location, such as a company's regional
headquarters, can assign priorities to profile elements based on the proximity
of servers to the headquarters, as illustrated by Figure 14-13.
</Para>
<?sml-need 3.5i>
<Figure>
<Title>Priorities Assigned on Proximity of Members</Title>
<Graphic Entityref="DCEADG.RPCRAD.ent.13" Scalefit="1" Reprodep="250" Reprowid="250"></Graphic>
</Figure>
<!-- DEC-file name .P! pictures/rpc-nsi-profile-priority.ps 3.25i-->
<?sml-space .5>
<Para>An individual user can have a personalized user profile that contains
elements for interfaces the user uses regularly and a default element that
specifies a public profile, such as the cell profile, as the default profile.
NSI searches use the default profile when a client needs an RPC interface that
lacks an element in the user profile. 
</Para>
</Sect3>
</Sect2>
<Sect2 Id="DCEADG.RPCRAD.div.36">
<Title>The Service Model for Defining Servers</Title>
<IndexTerm Id="DCEADG.RPCRAD.indx.120">
<Primary>NSI</Primary>
<Secondary>usage models</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.121">
<Primary>service</Primary>
<Secondary>model</Secondary>
</IndexTerm>
<Para>The NSI operations accommodate two distinct models for defining servers: the
service model and the resource model.  These models express different views of
how clients use servers and how servers can present themselves in the directory
service database.   The models are not
mutually exclusive, and an application may need to implement both models to
meet diverse goals.  By evaluating these models before designing an RPC
application, you can make informed decisions about whether and how to use
object UUIDs, how many server entries to use per server, how to distinguish
among instances of a server on a system, whether and how to use
groups or profiles or both, and so forth.  The two models are the
service model and resource model.
</Para>
<Para>The service model views a server exclusively as a distributed service composed of one
or more application-defined interfaces that meet a common goal independently of
specific resources. 
The service model is used by applications whose servers offer an identical
service and whose clients do not request an RPC resource when importing an
interface.  Often, with the service model, all the server instances of an
application are equivalent and are viewed as interchangeable.  However, the
service model can accommodate applications that view each server instance as
unique.  The implications of whether server instances are viewed as
interchangeable or unique are significant, so the following subsections
address these alternatives separately. 
</Para>
<Sect3 Id="DCEADG.RPCRAD.div.37">
<Title>Interchangeable Server Instances</Title>
<IndexTerm Id="DCEADG.RPCRAD.indx.122">
<Primary>server</Primary>
<Secondary>interchangeable instances</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.123">
<Primary>instance</Primary>
<Secondary>of an RPC server</Secondary>
<Tertiary>interchangeable instances</Tertiary>
</IndexTerm>
<Para>With the service model, servers offer an identical service that operates the
same way on all host systems.  For example, an application that uses the
service model is a collection of equivalent print servers that support an
identical set of file formats, and that are installed on printers in a single
location.  The print servers in any
location can be segregated from printer servers elsewhere by using a
location-specific group. 
</Para>
<Para>Figure 14-14 shows interchangeable print servers offering an identical
print service on different hosts.  To access this service, clients request the
Print V1.0 interface and specify the nil object UUID.  In this illustration, the
starting entry for the NSI search is a group corresponding to local print
servers.  Note that a client may be able to reach this print server group by
starting from a profile or another group. 
</Para>
<Note>
<Para>To simplify the illustrations of the usage models, the contents of server
entries are represented without listing any binding information.  
</Para>
</Note>
<Figure>
<Title>Service Model: Interchangeable Instances on Two Hosts</Title>
<Graphic Entityref="DCEADG.RPCRAD.ent.14" Scalefit="1" Reprodep="350" Reprowid="350"></Graphic>
</Figure>
<!-- DEC-file name .P! pictures/rpc-model-service-2-hosts.ps 6.0i-->
<Note>
<Para>The number of entries traversed by a search operation is unrelated to the
number of binding handles it returns. 
</Para>
</Note>
<Para>Figure 14-15 shows interchangeable service instances 
offering an identical statistics service on a single host.
To access this service, clients request the Statistics V1.0 interface
and specify the nil object UUID.  The starting entry for the NSI search
is a group corresponding to local servers that
offer the service (or a profile that refers to that group).
</Para>
<Figure>
<Title>Service Model: Interchangeable Instances on One Host</Title>
<Graphic Entityref="DCEADG.RPCRAD.ent.15" Scalefit="1" Reprodep="300" Reprowid="300"></Graphic>
</Figure>
<!-- DEC-file name .P! pictures/rpc-model-service-sharing.ps 6.5i-->
<?sml-space .5>
<Para>Note that, if an application with interchangeable server instances uses the
connectionless RPC protocol, the default behavior of the
endpoint map service is to always return the endpoint 
from the first map element for that set of server instances.
To avoid having
all clients using only one of the instances, before making a remote
procedure call to the server, each client must inquire for an endpoint.
<IndexTerm Id="DCEADG.RPCRAD.indx.124">
<Primary>endpoint</Primary>
<Secondary>register operation</Secondary>
</IndexTerm>For a random selection, a client calls the <Function>rpc_ep_resolve_binding()</Function>
routine.  Alternatively, 
a client can call the <Function>rpc_mgmt_ep_elt_inq_...()</Function>
routines to obtain all the map elements for compatible server instances,
and then use an application-specific selection algorithm to select one
of the returned elements.
</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCRAD.div.38">
<Title>Distinct Service Instances on a Single Host</Title>
<Para>With the service model, when multiple server instances on a given host
are somehow unique, each instance must export to a separate server entry.  The
exported binding information must contain one or more instance-specific,
well-known endpoints or an instance UUID.  
Well-known endpoints and instance UUIDs are used under the following
circumstances:
<IndexTerm Id="DCEADG.RPCRAD.indx.125">
<Primary>server</Primary>
<Secondary>distinguishing RPC instances</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.126">
<Primary>instance</Primary>
<Secondary>of an RPC server</Secondary>
</IndexTerm></Para>
<ItemizedList>
<ListItem>
<Para>Well-known endpoints
</Para>
<Para>An instance-specific, well-known endpoint must be provided to a server
instance as part of its installation; for example, as a command-line argument.
Before calling the export operation, the server instance tells the RPC runtime
to use each of its well-known endpoints; it does this by calling 
<Function>rpc_server_use_protseq_ep()</Function>. 
The runtime includes these endpoints in the
instance's binding information, which the runtime makes available to the
instance via a list of server binding handles.  The server instance uses this
list of binding handles to export its binding information, including the
well-known endpoints.  The server also uses this list of binding handles
to export its well-known endpoint with the local endpoint map; it does
this by calling <Function>rpc_ep_register()</Function> 
or <Function>rpc_ep_register_no_replace()</Function>.  Remote calls made
using an imported well-known endpoint from a server entry are guaranteed by
the RPC runtime to go only to the server instance that exported the endpoint
to that entry. 
</Para>
<Note>
<?sml-need 2>
<Para>Only one server instance per system can use a well-known endpoint obtained from
a given interface specification. 
</Para>
</Note>
</ListItem>
<ListItem>
<Para>Instance UUID
</Para>
<Para><!-- For the service mode, when calling the import operation, a client -->
<!-- usually specifies the nil object UUID.  -->
</Para>
<Para>Create an instance UUID only for a new server entry.  Generating a
new instance UUID each time a server instance exports to a server entry will
result in many instance UUIDs that are difficult to manage and
may affect performance as new instance UUIDs are constantly added to server
entries.  If a new server instance inherits a currently unused server entry left
behind by an earlier instance, before exporting, the new server instance should
inquire for an instance UUID in the server entry; this is done
by calling the 
<Literal>rpc_ns_entry_object_inq_</Literal>{<Literal>begin</Literal>,<Literal>next</Literal>,<Literal>done</Literal>}<Literal>()</Literal>
routines.  If the inherited entry contains 
an instance UUID, the server uses it for an instance UUID, rather than creating
and exporting a new instance UUID. If an inherited entry lacks an instance UUID,
however, the server must create a UUID and export it to the server entry.  
</Para>
<Para><?sml-need 2>Note
that every server instance must register its instance UUID along with its
endpoints in the local endpoint map. 
</Para>
<Note>
<Para>Using an instance UUID precludes any other use of object UUIDs
for the application.
</Para>
</Note>
</ListItem>
</ItemizedList>
<Para>Figure 14-16 shows distinct instances of a statistics-service 
server on the same
host.  Each server instance uses an instance UUID to identify itself to
clients.  The instance UUID is the only object UUID a server instance exports
to its server entry.  Starting at the statistics-service group,
clients import the statistics interface.  
</Para>
<Para>After finding a server entry with compatible binding information for the
statistics interface, the import operation returns an instance UUID along with
binding information.  Every remote procedure call made with that 
binding information goes to the server instance that exported the instance
UUID. 
<!---->
</Para>
<?sml-need 5.5i>
<Figure>
<Title>Service Model:  Distinct Instances on One Host</Title>
<Graphic Entityref="DCEADG.RPCRAD.ent.16" Scalefit="1" Reprodep="300" Reprowid="300"></Graphic>
</Figure>
<!-- DEC-file name .P! pictures/rpc-model-service-1-host.ps 6.5i-->
</Sect3>
</Sect2>
<Sect2 Id="DCEADG.RPCRAD.div.39">
<Title>The Resource Model for Defining Servers</Title>
<IndexTerm Id="DCEADG.RPCRAD.indx.127">
<Primary>NSI</Primary>
<Secondary>usage models</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.128">
<Primary>resource model</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.129">
<Primary>RPC</Primary>
<Secondary>resource model</Secondary>
</IndexTerm>
<Para>The resource model views servers and clients as manipulating resources.  
A server and its clients use object UUIDs to identify specific resources.
With the resource model, any resource 
an application's servers and clients manipulate
using an object UUID is considered an RPC resource.  
Typically, an RPC resource is a physical resource such as a
database.  However, an RPC resource may be abstract; for example, a print format
such as ASCII. Note that an application that uses the resource model for one
context may use the service model for another.
(See earlier sections for details of the service model.) 
</Para>
<Para>Applications use object UUIDs to refer to resources as follows: 
</Para>
<OrderedList>
<ListItem>
<Para>Servers offer resources by assigning an object
UUID to each specific resource.
</Para>
</ListItem>
<ListItem>
<Para>Clients obtain those object UUIDs and use them to learn about a server that
offers a given resource.
</Para>
</ListItem>
<ListItem>
<Para>When making a remote procedure call, a client requests a resource
by passing its UUID as part of the server binding information.
</Para>
</ListItem>
</OrderedList>
<!-- .AL (numbered) list-->
<Para>Each RPC resource or type of resource requires its own object UUID.
A calendar server, for example, may require a distinct UUID to
identify each calendar.
</Para>
<Para>RPC interfaces can be defined to operate with different types of resources and
can be implemented separately for each type; for example, a print server
application that supports PostScript, sixel, and ASCII file formats.  When using
different implementations of an interface (different managers),
servers must associate the object UUID of a resource, such as an ASCII file
format and its manager, by assigning them a single type UUID. To request 
the resource, a client specifies its object UUID in the server 
binding information.  When a print server receives the remote procedure call, it
looks up the corresponding type UUID and selects the associated manager. 
</Para>
<Para><IndexTerm Id="DCEADG.RPCRAD.indx.130">
<Primary>RPC</Primary>
<Secondary>server instances</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.131">
<Primary>server</Primary>
<Secondary>distinguishing RPC instances</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.RPCRAD.indx.132">
<Primary>instance</Primary>
<Secondary>of an RPC server</Secondary>
<Tertiary>distinguishing</Tertiary>
</IndexTerm>Some RPC resources, such as print queues, belong exclusively to a 
single server instance.  
Some can be shared among server instances; for
example, a file format or an airline reservation database.  For server
instances on the same system, sharing a resource means that its object UUID
cannot distinguish between the two instances.  For a print server, this is
unlikely to be a problem, assuming that each printer runs only one instance of
the print server.  In contrast, an application with a widely accessed database,
such as an airline reservation application, may need to ensure that clients can
distinguish server instances from each other.  An application can distinguish
itself by supplying its clients with instance-specific
information; for example, a well-known endpoint or an instance UUID. 
</Para>
<Note>
<Para>Multiple server instances that access the same set of resources can introduce
concurrency control problems, such as two instances accessing a tape drive at
the same time.  Also, where the system provides concurrency control, servers may
compete and have to wait for resources such as databases.
Dealing with delayed access to shared resources may require an
application-specific mechanism, such as queuing access requests. 
</Para>
</Note>
<Sect3 Id="DCEADG.RPCRAD.div.40">
<Title>Guidelines for Defining and Using RPC Resources</Title>
<Para>When developing an RPC application, you need to decide whether to use object
UUIDs to identify RPC resources and, if so, what sorts of resources receive
UUIDs that servers export to the namespace.   When making these
decisions, consider 
the following questions:
</Para>
<ItemizedList>
<ListItem>
<Para>Will users need to select a server entry from
the namespace based on what object UUIDs the entry contains
(and what the client needs)?
</Para>
<Para>If yes, then a client must specify an object UUID to the import 
operation.
</Para>
</ListItem>
<ListItem>
<Para>Does the type of resource you are using last for a long time (months
or years), so you can advertise object UUIDs efficiently in the namespace? 
</Para>
<Para>The information kept in a namespace should be static
or rarely change.  For example, print queues are appropriate RPC resources. 
In contrast, 
quickly changing information, such as the jobs queued
for the printer, owners of the jobs, or the time the job was
added to the queue, should not be viewed as RPC resources.
Such short-lived data may be viewed as local objects, which are stored
and managed at a specific server.  
Programming with local objects is in the area
of regular object-oriented programming and is independent of
an application's use of RPC resources.
</Para>
</ListItem>
<ListItem>
<Para>Is the number of objects belonging to the type of resource bounded
in order to avoid placing high demands on the directory service?
</Para>
</ListItem>
<ListItem>
<Para>Will the server implement an interface for different types of
a resource, such as different forms of calendar databases or 
different types of queues?
</Para>
<Para>If yes, then the server must classify objects into types.  For each type,
the server generates a nonnil UUID for the type UUID, sets the type UUID for
every object of the type, and specifies that type as the manager type when
registering the interface.  When making a remote procedure call to the
interface, a client must supply an object UUID to specify an RPC resource. 
</Para>
</ListItem>
<ListItem>
<?sml-need 5>
<Para>Is control over specific resources an important factor for distinguishing among
server instances on a host? 
</Para>
<Para>If yes, then each server must generate an object UUID for each of its
resources.
</Para>
</ListItem>
</ItemizedList>
<!-- .ML (bulleted) list-->
<Para>For some applications, such as those accessing a database that many people use,
shared access to one or more objects
may be essential.  However, not all objects accommodate such shared
access.
</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCRAD.div.41">
<Title>Using Objects and Groups Together</Title>
<Para>Servers can associate object UUIDs with a group.  Each server exports one or
more object UUIDs (without exporting any binding information) to the
directory service entry of the group.  This involves specifying 
the NULL interface
identifier to the export operation along with the list of object UUIDs.  The
object UUIDs reside in the directory service entry of the
group. 
If a server stops offering an advertised object, a server must unexport its
object UUID from the group entry in order to keep its object list up-to-date. 
</Para>
<Para>Clients use objects in a group entry as follows:
</Para>
<OrderedList>
<!-- step 1-->
<ListItem>
<Para>The client inquires for an object UUID from the group entry 
by calling the 
<Literal>rpc_ns_entry_object_inq_</Literal>{<Literal>begin</Literal>,<Literal>next</Literal>,<Literal>done</Literal>}<Literal>()</Literal> 
routines.  This routine selects one object UUID at random and returns it to
the client.
<!-- step 2-->
</Para>
</ListItem>
<ListItem>
<Para>The client imports binding information for the returned
object UUID (and the interface of the called remote procedure),
specifying the group for the start of the search.
<!-- step 3-->
</Para>
</ListItem>
<ListItem>
<Para>The import operation returns a binding handle
that refers to the requested object UUID and
binding information for a server that offers the corresponding
object.
<!-- step 4-->
</Para>
</ListItem>
<ListItem>
<Para>The client issues the remote procedure call by using that binding handle.
<!-- step 5-->
</Para>
</ListItem>
<ListItem>
<Para>The server looks up the type of the requested object.
<!-- step 6-->
</Para>
</ListItem>
<ListItem>
<Para>The server assigns the remote procedure call to the manager that implements the
called remote procedure for that type of object. 
</Para>
</ListItem>
</OrderedList>
</Sect3>
<Sect3 Id="DCEADG.RPCRAD.div.42">
<Title>System-Specific Applications</Title>
<Para>For some applications, the clients need to import an RPC resource that belongs
to a specific system, and the clients can specify a server entry name to 
learn about a server on that system.  For example, a process server that allows 
clients to monitor and control processes on a remote machine
is useful only to that machine.  Figure 14-17 illustrates this
type of system-specific interpretation of the resource model. 
</Para>
<Figure>
<Title>Resource Model:  A System-Specific Application</Title>
<Graphic Entityref="DCEADG.RPCRAD.ent.17" Scalefit="1" Reprodep="300" Reprowid="300"></Graphic>
</Figure>
<!-- DEC-file name .P! pictures/rpc-model-server.ps 6.5i-->
<?sml-space .5>
<Para><?sml-need 9>Because clients usually find a system-specific server by specifying its server
entry to the import operation, groups are usually not part of the NSI search
path for system-specific applications.  However, groups are a management
tool for such applications.  A group containing the names of the server entries
of all the current servers can act as an accounting database.  Also, a group for
the servers on each set of related systems, such as the members of a 
LAN or an administrative grouping, permits a client to sequentially use the
application on every system in the set.  An application with system-specific
servers should <Symbol Role="Variable">not</Symbol> use profiles. 
</Para>
</Sect3>
<Sect3 Id="DCEADG.RPCRAD.div.43">
<Title>Exporting Multiple Object UUIDs to a Single Server Entry</Title>
<Para>Often a single server offers more than one resource, or 
it offers several types of
resources.  In cases where a server instance has a large number of object
UUIDs, the application should usually place multiple object UUIDs into a
single server entry.  Typically, an application places all its object UUIDs
into one server entry; however, it 
may need to segregate them into several server
entries according to factors such as object type, location, or who uses
the different types of objects.  When you are subsetting resources, 
try to assign each resource to a single set so that its object 
UUID is exported to only one server entry. 
Figure 14-18 illustrates a single server entry implementation
for each server for the resource model.
</Para>
<?sml-need 6i>
<Figure>
<Title>Resource Model:  A Single Server Entry for Each Server</Title>
<Graphic Entityref="DCEADG.RPCRAD.ent.18" Scalefit="1" Reprodep="350" Reprowid="350"></Graphic>
</Figure>
<!-- DEC-file name .P! pictures/rpc-model-object-1-entry.ps 6.75i-->
</Sect3>
<Sect3 Id="DCEADG.RPCRAD.div.44">
<Title>Exporting Every Object UUID to a Separate Server Entry</Title>
<Para>For some applications, exporting each object UUID to a separate server entry is
a practical strategy.  To avoid excessive demands on  directory service
resources, however, this strategy requires that the set of objects 
remain small.  Applications with many RPC resources should usually
have each server create a single server entry for itself and export the object
UUIDs of the resources it offers to that server entry.  For example, an
application that accesses a different personal calendar for every member of an
organization needs to avoid using a separate server entry for each calendar. 
</Para>
<Para>For some applications, however, you can use a separate server entry for each
object UUID;  for example, a print server application 
that supports a small number of file formats.
Each server can create a separate server entry for each supported file format 
and export its object UUID to that server entry.
The server entries for a file format are members of a distinct group.
</Para>
<Para>To import binding information for a server
that supports a required file format, a client specifies the nil UUID as
the object UUID and the group for that format as the starting entry.
The import operation selects a group member at random and goes to the
corresponding server entry.
Along with binding information, the operation returns the server's
object UUID  for the requested file format from the server entry.
When the client issues a remote procedure call to the server,
the imported object UUID correctly identifies the file format
the client needs.
Figure 14-19 illustrates this use of object UUIDs.
</Para>
<Para><?sml-need 6i>
<!-- rpc-model-object-separate-print-->
</Para>
<Figure>
<Title>Resource Model:  A Separate Server Entry for Each Object</Title>
<Graphic Entityref="DCEADG.RPCRAD.ent.19" Scalefit="1" Reprodep="350" Reprowid="350"></Graphic>
</Figure>
<!-- DEC-file name .P! pictures/rpc-model-object-separate-print.ps 8.0i-->
<?sml-space .5>
<Para><?sml-need 14>Applications that use a separate entry for each object UUID need to use groups
cautiously.  Keeping groups small when clients are requesting a specific object
is essential because an NSI search looks up the group members in random
order.  Therefore, the members of a group form a localized flat NSI search path
rather than the hierarchical path.  Flat search paths are inefficient because
the average search will look at half the members.  Small groups are not a
problem.  For example, if a group contains only 4 members, each of whom refers
to a server entry that advertises a distinct set of RPC resources,
the average number of server entries accessed in each search is 2
entries  and the maximum is only 4. The larger the group, however, the more
inefficient the resulting search path.  For example, for a group containing 12
members, each of whom refers to a server entry that advertises a
distinct set of object UUIDs, the average search accesses 6 entries and some
searches access all 12 server entries. 
</Para>
</Sect3>
</Sect2>
</Sect1>
</Chapter>
<!--+ 11/27/96 19:53:47
    | tagMorph:  $Id: rpc_and_dce.sgm,v 1.1.2.8 1996/12/14 20:24:36 wardr Exp $
    | tagMorph library:  $Id: rpc_and_dce.sgm,v 1.1.2.8 1996/12/14 20:24:36 wardr Exp $
    | sml-to-docbook:  1.25
    +-->
